<!DOCTYPE html><html><head><title>Help for package geostan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geostan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geostan-package'><p>The geostan R package.</p></a></li>
<li><a href='#aple'><p>Spatial autocorrelation estimator</p></a></li>
<li><a href='#as.matrix.geostan_fit'><p>Extract samples from a fitted model</p></a></li>
<li><a href='#auto_gaussian'><p>Auto-Gaussian family for CAR models</p></a></li>
<li><a href='#edges'><p>Edge list</p></a></li>
<li><a href='#eigen_grid'><p>Eigenvalues of a spatial weights matrix: raster analysis</p></a></li>
<li><a href='#expected_mc'><p>Expected value of the residual Moran coefficient</p></a></li>
<li><a href='#georgia'><p>Georgia all-cause, sex-specific mortality, ages 55-64, years 2014-2018</p></a></li>
<li><a href='#get_shp'><p>Download shapefiles</p></a></li>
<li><a href='#gr'><p>The Geary Ratio</p></a></li>
<li><a href='#lg'><p>Local Geary</p></a></li>
<li><a href='#lisa'><p>Local Moran's I</p></a></li>
<li><a href='#make_EV'><p>Extract eigenfunctions of a connectivity matrix for spatial filtering</p></a></li>
<li><a href='#mc'><p>The Moran coefficient</p></a></li>
<li><a href='#me_diag'><p>Data model diagnostics</p></a></li>
<li><a href='#moran_plot'><p>Moran plot</p></a></li>
<li><a href='#n_eff'><p>Effective sample size</p></a></li>
<li><a href='#posterior_predict'><p>Draw samples from the posterior predictive distribution</p></a></li>
<li><a href='#predict.geostan_fit'><p>Predict method for <code>geostan_fit</code> models</p></a></li>
<li><a href='#prep_car_data'><p>Prepare data for the CAR model</p></a></li>
<li><a href='#prep_car_data2'><p>Prepare data for the CAR model: raster analysis</p></a></li>
<li><a href='#prep_icar_data'><p>Prepare data for ICAR models</p></a></li>
<li><a href='#prep_me_data'><p>Prepare data for spatial measurement error models</p></a></li>
<li><a href='#prep_sar_data'><p>Prepare data for a simultaneous autoregressive (SAR) model</p></a></li>
<li><a href='#prep_sar_data2'><p>Prepare data for SAR model: raster analysis</p></a></li>
<li><a href='#print.geostan_fit'><p>print or plot a fitted geostan model</p></a></li>
<li><a href='#priors'><p>Prior distributions</p></a></li>
<li><a href='#residuals.geostan_fit'><p>Extract residuals, fitted values, or the spatial trend</p></a></li>
<li><a href='#row_standardize'><p>Row-standardize a matrix; safe for zero row-sums.</p></a></li>
<li><a href='#se_log'><p>Standard error of log(x)</p></a></li>
<li><a href='#sentencing'><p>Florida state prison sentencing counts by county, 1905-1910</p></a></li>
<li><a href='#shape2mat'><p>Create spatial and space-time connectivity matrices</p></a></li>
<li><a href='#sim_sar'><p>Simulate spatially autocorrelated data</p></a></li>
<li><a href='#sp_diag'><p>Spatial data diagnostics</p></a></li>
<li><a href='#stan_car'><p>Conditional autoregressive (CAR) models</p></a></li>
<li><a href='#stan_esf'><p>Spatial filtering</p></a></li>
<li><a href='#stan_glm'><p>Generalized linear models</p></a></li>
<li><a href='#stan_icar'><p>Intrinsic autoregressive models</p></a></li>
<li><a href='#stan_sar'><p>Simultaneous autoregressive (SAR) models</p></a></li>
<li><a href='#waic'><p>Widely Applicable Information Criteria (WAIC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Spatial Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-01</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://connordonegan.github.io/geostan/">https://connordonegan.github.io/geostan/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ConnorDonegan/geostan/issues">https://github.com/ConnorDonegan/geostan/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>For Bayesian inference with spatial data, provides exploratory spatial analysis tools, multiple spatial model specifications, spatial model diagnostics, and special methods for inference with small area survey data (e.g., the America Community Survey (ACS)) and censored population health surveillance data. Models are pre-specified using the Stan programming language, a platform for Bayesian inference using Markov chain Monte Carlo (MCMC). References: Carpenter et al. (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i01">doi:10.18637/jss.v076.i01</a>&gt;; Donegan (2021) &lt;<a href="https://doi.org/10.31219%2Fosf.io%2F3ey65">doi:10.31219/osf.io/3ey65</a>&gt;; Donegan (2022) &lt;<a href="https://doi.org/10.21105%2Fjoss.04716">doi:10.21105/joss.04716</a>&gt;; Donegan, Chun and Hughes (2020) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a>&gt;; Donegan, Chun and Griffith (2021) &lt;<a href="https://doi.org/10.3390%2Fijerph18136856">doi:10.3390/ijerph18136856</a>&gt;; Morris et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.sste.2019.100301">doi:10.1016/j.sste.2019.100301</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spdep (&ge; 1.0), sf (&ge; 1.0-10), ggplot2 (&ge; 3.0.0), methods,
graphics, stats, MASS, truncnorm, signs, gridExtra, utils,
Matrix (&ge; 1.3), Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1),
rstan (&ge; 2.26.0), rstantools (&ge; 2.1.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, bayesplot</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 00:01:25 UTC; connor</td>
</tr>
<tr>
<td>Author:</td>
<td>Connor Donegan <a href="https://orcid.org/0000-0002-9698-5443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mitzi Morris [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Connor Donegan &lt;connor.donegan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 15:22:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='geostan-package'>The geostan R package.</h2><span id='topic+geostan-package'></span><span id='topic+geostan'></span>

<h3>Description</h3>

<p>Bayesian spatial modeling powered by Stan. <strong>geostan</strong> provides access to a variety of hierarchical spatial models using the R formula interface, supporting a complete spatial analysis workflow with a suite of spatial analysis tools. It is designed primarily for public health and social science research but is generally applicable to modeling areal data. Unique features of the package include its spatial measurement error model (for inference with small area estimates such as those from the American Community Survey), its fast proper conditional autoregressive (CAR) and simultaneous autoregressive (SAR) models, and its eigenvector spatial filtering (ESF) models. The package also supports spatial regression with raster layers.
</p>


<h3>References</h3>

<p>Carpenter, B., Gelman, A., Hoffman, M.D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M., Guo, J., Li, P., Riddell, A., 2017. Stan: A probabilistic programming language. Journal of statistical software 76. <a href="https://doi.org/10.18637/jss.v076.i01">doi:10.18637/jss.v076.i01</a>.
</p>
<p>Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moran’s Eigenvectors and hierarchical shrinkage priors. <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a> (open access: <a href="https://doi.org/10.31219/osf.io/fah3z">doi:10.31219/osf.io/fah3z</a>).
</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. <a href="https://doi.org/10.3390/ijerph18136856">doi:10.3390/ijerph18136856</a>. Supplementary material: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Donegan, Connor (2022) geostan: An R package for Bayesian spatial analysis. <em>The Journal of Open Source Software</em>. 7, no. 79: 4716. <a href="https://doi.org/10.21105/joss.04716">doi:10.21105/joss.04716</a>.
</p>
<p>Gabry, J., Goodrich, B. and Lysy, M. (2020). rstantools: Tools for developers of R packages interfacing with Stan. R package version 2.1.1 <a href="https://mc-stan.org/rstantools/">https://mc-stan.org/rstantools/</a>.
</p>
<p>Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., &amp; DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan. Spatial and spatio-temporal epidemiology, 31, 100301. <a href="https://doi.org/10.1016/j.sste.2019.100301">doi:10.1016/j.sste.2019.100301</a>.
</p>
<p>Stan Development Team (2019). RStan: the R interface to Stan. R package version 2.19.2. <a href="https://mc-stan.org">https://mc-stan.org</a>
</p>

<hr>
<h2 id='aple'>Spatial autocorrelation estimator</h2><span id='topic+aple'></span>

<h3>Description</h3>

<p>The approximate-profile likelihood estimator for the spatial autocorrelation parameter from a simultaneous autoregressive (SAR) model (Li et al. 2007). Note, the <code>APLE</code> approximation is not reliable when the number of observations is large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aple(x, w, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aple_+3A_x">x</code></td>
<td>
<p>Numeric vector of values, length <code>n</code>. This will be standardized internally with <code>scale(x)</code>.</p>
</td></tr>
<tr><td><code id="aple_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> row-standardized spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>.</p>
</td></tr>
<tr><td><code id="aple_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>APLE</code> is an estimate of the spatial autocorrelation parameter one would obtain from fitting an intercept-only SAR model.
</p>


<h3>Value</h3>

<p>the APLE estimate, a numeric value.
</p>


<h3>Source</h3>

<p>Li, Honfei and Calder, Catherine A. and Cressie, Noel (2007). Beyond Moran's I: testing for spatial dependence based on the spatial autoregressive model. Geographical Analysis: 39(4): 357-375.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc">mc</a>, <a href="#topic+moran_plot">moran_plot</a>, <a href="#topic+lisa">lisa</a>, <a href="#topic+sim_sar">sim_sar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
data(georgia)
w &lt;- shape2mat(georgia, "W")
x &lt;- georgia$ICE
aple(x, w)
</code></pre>

<hr>
<h2 id='as.matrix.geostan_fit'>Extract samples from a fitted model</h2><span id='topic+as.matrix.geostan_fit'></span><span id='topic+as.data.frame.geostan_fit'></span><span id='topic+as.array.geostan_fit'></span>

<h3>Description</h3>

<p>Extract samples from the joint posterior distribution of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
as.matrix(x, ...)

## S3 method for class 'geostan_fit'
as.data.frame(x, ...)

## S3 method for class 'geostan_fit'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.geostan_fit_+3A_x">x</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="as.matrix.geostan_fit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>rstan</code> methods for for <code>as.data.frame</code>, <code>as.matrix</code>, or <code>as.array</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, data frame, or array of MCMC samples is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
A &lt;- shape2mat(georgia, "B")

fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)),
                C = A,
                data = georgia,
                family = poisson(),
                chains = 1, iter = 600) # for speed only


s &lt;- as.matrix(fit)
dim(s)

a &lt;- as.matrix(fit, pars = "intercept")
dim(a)

# Or extract the stanfit object
S &lt;- fit$stanfit
print(S, pars = "intercept")
samples &lt;- as.matrix(S)
dim(samples)
</code></pre>

<hr>
<h2 id='auto_gaussian'>Auto-Gaussian family for CAR models</h2><span id='topic+auto_gaussian'></span>

<h3>Description</h3>

<p>create a family object for the auto-Gaussian CAR or SAR specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_gaussian(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_gaussian_+3A_type">type</code></td>
<td>
<p>Optional; either &quot;CAR&quot; for conditionally specified auto-model or &quot;SAR&quot; for the simultaneously specified auto-model. The type is added internally by <code>stan_car</code> or <code>stan_sar</code> when needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>family</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_car">stan_car</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cp = prep_car_data(shape2mat(georgia))
fit &lt;- stan_car(log(rate.male) ~ 1,
                data = georgia,
                car_parts = cp,
                family = auto_gaussian(),
                chains = 2, iter = 700) # for speed only
print(fit)
</code></pre>

<hr>
<h2 id='edges'>Edge list</h2><span id='topic+edges'></span>

<h3>Description</h3>

<p>Creates a list of connected nodes following the graph representation of a spatial connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(C, unique_pairs_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_c">C</code></td>
<td>
<p>A connectivity matrix where connection between two nodes is indicated by non-zero entries.</p>
</td></tr>
<tr><td><code id="edges_+3A_unique_pairs_only">unique_pairs_only</code></td>
<td>
<p>By default, only unique pairs of nodes (i, j) will be included in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally for <code><a href="#topic+stan_icar">stan_icar</a></code> and it is also helpful for creating the scaling factor for BYM2 models fit with <code><a href="#topic+stan_icar">stan_icar</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with three columns. The first two columns (<code>node1</code> and <code>node2</code>) contain the indices of connected pairs of nodes; only unique pairs of nodes are included (unless <code>unique_pairs_only = FALSE</code>). The third column (<code>weight</code>) contains the corresponding matrix element, <code>C[node1, node2]</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape2mat">shape2mat</a></code>, <code><a href="#topic+prep_icar_data">prep_icar_data</a></code>, <code><a href="#topic+stan_icar">stan_icar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)
C &lt;- shape2mat(sentencing)
nbs &lt;- edges(C)
head(nbs)

## similar to:
head(Matrix::summary(C))
head(Matrix::summary(shape2mat(georgia, "W")))
</code></pre>

<hr>
<h2 id='eigen_grid'>Eigenvalues of a spatial weights matrix: raster analysis</h2><span id='topic+eigen_grid'></span>

<h3>Description</h3>

<p>Approximate eigenvalues for the row-standardized spatial connectivity matrix W of a regular tessellation, e.g., remotely sensed imagery.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_grid(row = 5, col = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_grid_+3A_row">row</code></td>
<td>
<p>Number of rows in the raster dataset</p>
</td></tr>
<tr><td><code id="eigen_grid_+3A_col">col</code></td>
<td>
<p>Number of columns in the raster dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Equation 5 from Griffith (2000) to calculate the eigenvalues for a row-standardized spatial weights matrix; this is valid for a regular tessellation (rectangular grid or raster). The rook criteria is used to define adjacency.
</p>
<p>The purpose is to calculate eigenvalues of the spatial weights matrix for the CAR and SAR models, enabling spatial regression with large raster data sets. This function is used internally by <code><a href="#topic+prep_sar_data2">prep_sar_data2</a></code> and <code><a href="#topic+prep_car_data2">prep_car_data2</a></code>. For more details, see: <code>vignette("raster-regression", package = "geostan")</code>.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2000). Eigenfunction properties and approximations of selected incidence matrices employed in spatial analyses. <em>Linear Algebra and its Applications</em> 321 (1-3): 95-112. <a href="https://doi.org/10.1016/S0024-3795%2800%2900031-8">doi:10.1016/S0024-3795(00)00031-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_sar_data2">prep_sar_data2</a></code>, <code><a href="#topic+prep_car_data2">prep_car_data2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e &lt;- eigen_grid(row = 50, col = 95)
print(head(e, 25))

</code></pre>

<hr>
<h2 id='expected_mc'>Expected value of the residual Moran coefficient</h2><span id='topic+expected_mc'></span>

<h3>Description</h3>

<p>Expected value for the Moran coefficient of model residuals under the null hypothesis of no spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_mc(X, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_mc_+3A_x">X</code></td>
<td>
<p>model matrix, including column of ones.</p>
</td></tr>
<tr><td><code id="expected_mc_+3A_c">C</code></td>
<td>
<p>Connectivity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value.
</p>


<h3>Source</h3>

<p>Chun, Yongwan and Griffith, Daniel A. (2013). Spatial statistics and geostatistics. Sage, p. 18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
C &lt;- shape2mat(georgia)
X &lt;- model.matrix(~ ICE + college, georgia)
expected_mc(X, C)
</code></pre>

<hr>
<h2 id='georgia'>Georgia all-cause, sex-specific mortality, ages 55-64, years 2014-2018</h2><span id='topic+georgia'></span>

<h3>Description</h3>

<p>A simple features (sf) object for Georgia counties with sex- and age-specific deaths and populations at risk (2014-2018), plus select estimates (with standard errors) of county characteristics. Standard errors of the ICE were calculated using the Census Bureau's variance replicate tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>georgia
</code></pre>


<h3>Format</h3>

<p>A simple features object with county geometries and the following columns:
</p>

<dl>
<dt>GEOID</dt><dd><p>Six digit combined state and county FIPS code</p>
</dd>
<dt>NAME</dt><dd><p>County name</p>
</dd>
<dt>ALAND</dt><dd><p>Land area</p>
</dd>
<dt>AWATER</dt><dd><p>Water area</p>
</dd>
<dt>population</dt><dd><p>Census Bureau 2018 county population estimate</p>
</dd>
<dt>white</dt><dd><p>Percent White, ACS 2018 five-year estimate</p>
</dd>
<dt>black</dt><dd><p>Percent Black, ACS 2018 five-year estimate</p>
</dd>
<dt>hisp</dt><dd><p>Percent Hispanic/Latino, ACS 2018 five-year estimate</p>
</dd>
<dt>ai</dt><dd><p>Percent American Indian, ACS 2018 five-year estimate</p>
</dd>
<dt>deaths.male</dt><dd><p>Male deaths, 55-64 yo, 2014-2018</p>
</dd>
<dt>pop.at.risk.male</dt><dd><p>Population estimate, males, 55-64 yo, years 2014-2018 (total), ACS 2018 five-year estimate</p>
</dd>
<dt>pop.at.risk.male.se</dt><dd><p>Standard error of the pop.at.risk.male estimate</p>
</dd>
<dt>deaths.female</dt><dd><p>Female deaths, 55-64 yo, 2014-2018</p>
</dd>
<dt>pop.at.risk.female</dt><dd><p>Population estimate, females, 55-64 yo, years 2014-2018 (total), ACS 2018 five-year estimate</p>
</dd>
<dt>pop.at.risk.female.se</dt><dd><p>Standard error of the pop.at.risk.female estimate</p>
</dd>
<dt>ICE</dt><dd><p>Index of Concentration at the Extremes</p>
</dd>
<dt>ICE.se</dt><dd><p>Standard error of the ICE estimate, calculated using variance replicate tables</p>
</dd>
<dt>income</dt><dd><p>Median household income, ACS 2018 five-year estimate</p>
</dd>
<dt>income.se</dt><dd><p>Standard error of the income estimate</p>
</dd>
<dt>college</dt><dd><p>Percent of the population age 25 or higher than has a bachelors degree of higher, ACS 2018 five-year estimate</p>
</dd>
<dt>college.se</dt><dd><p>Standard error of the college estimate</p>
</dd>
<dt>insurance</dt><dd><p>Percent of the population with health insurance coverage, ACS 2018 five-year estimate</p>
</dd>
<dt>insurance.se</dt><dd><p>Standard error of the insurance estimate</p>
</dd>
<dt>rate.male</dt><dd><p>Raw (crude) age-specific male mortality rate, 2014-2018</p>
</dd>
<dt>rate.female</dt><dd><p>Raw (crude) age-specific female mortality rate, 2014-2018</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry for county boundaries</p>
</dd>
</dl>



<h3>Source</h3>

<p>Centers for Disease Control and Prevention, National Center for Health Statistics. Underlying Cause of Death 1999-2018 on CDC Wonder Online Database. 2020. Available online: <a href="http://wonder.cdc.gov">http://wonder.cdc.gov</a> (accessed on 19 October 2020).
</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). &ldquo;Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure.&rdquo; <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Kyle Walker and Matt Herman (2020). tidycensus: Load US Census Boundary and Attribute Data as 'tidyverse' and 'sf'-Ready Data  Frames. R package version 0.11. <a href="https://CRAN.R-project.org/package=tidycensus">https://CRAN.R-project.org/package=tidycensus</a>
</p>
<p>US Census Bureau. Variance Replicate Tables, 2018. Available online: <a href="https://www.census.gov/programs-surveys/acs/data/variance-tables.2018.html">https://www.census.gov/programs-surveys/acs/data/variance-tables.2018.html</a> (accessed on 19 October 2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
head(georgia)

library(sf)
plot(georgia[,'rate.female'])
</code></pre>

<hr>
<h2 id='get_shp'>Download shapefiles</h2><span id='topic+get_shp'></span>

<h3>Description</h3>

<p>Given a url to a shapefile in a compressed .zip file, download the file and unzip it into a folder in your working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shp(url, folder = "shape")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_shp_+3A_url">url</code></td>
<td>
<p>url to download a shapefile.</p>
</td></tr>
<tr><td><code id="get_shp_+3A_folder">folder</code></td>
<td>
<p>what to name the new folder in your working directory containing the shapefile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A folder in your working directory with the shapefile; filepaths are printed to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
url &lt;- "https://www2.census.gov/geo/tiger/GENZ2019/shp/cb_2019_us_state_20m.zip"
folder &lt;- tempdir()
print(folder)
get_shp(url, folder)
states &lt;- sf::st_read(folder)
head(states)

## End(Not run)
</code></pre>

<hr>
<h2 id='gr'>The Geary Ratio</h2><span id='topic+gr'></span>

<h3>Description</h3>

<p>An index for spatial autocorrelation. Complete spatial randomness (lack of spatial pattern) is indicated by a Geary Ratio (GR) of 1; positive autocorrelation moves the index towards zero, while negative autocorrelation will push the index towards 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr(x, w, digits = 3, na.rm = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code>n</code>. By default, this will be standardized using the <code>scale</code> function.</p>
</td></tr>
<tr><td><code id="gr_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>.</p>
</td></tr>
<tr><td><code id="gr_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
<tr><td><code id="gr_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, observations with <code>NA</code> values will be dropped from both <code>x</code> and <code>w</code>.</p>
</td></tr>
<tr><td><code id="gr_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, no warning will be printed to inform you when observations with <code>NA</code> values have been dropped, or if any observations without neighbors have been found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Geary Ratio is an index of spatial autocorrelation. The
numerator contains a series of sums of squared deviations, which
will be smaller when each observation is similar to its
neighbors. This term makes the index sensitive to local outliers,
which is advantageous for detecting such outliers and for measuring
negative autocorrelation. The denominator contains the total sum of
squared deviations from the mean value. Hence, under strong
positive autocorrelation, the GR approaches zero. Zero spatial
autocorrelation is represented by a GR of 1. Negative
autocorrelation pushes the GR above 1, towards 2.  </p>
<p style="text-align: center;"><code class="reqn">GR =
\frac{n-1}{2K} \frac{M}{D}</code>
</p>
 <p style="text-align: center;"><code class="reqn">M = \sum_i \sum_j w_{i,j} (x_i -
x_j)^2 </code>
</p>
 <p style="text-align: center;"><code class="reqn">D = \sum_i (x_i - \overline{x})^2 </code>
</p>
<p> Observations
with no neighbors are removed before calculating the GR. The
alternative is for those observations to contribute zero to the
numerator&mdash;but zero is not a neutral value, it represents strong
positive autocorrelation.
</p>


<h3>Source</h3>

<p>Chun, Yongwan, and Daniel A. Griffith. Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology. Sage, 2013.
</p>
<p>Geary, R. C. &quot;The contiguity ratio and statistical mapping.&quot; The Incorporated Statistician 5, no. 3 (1954): 115-127_129-146.
</p>
<p>Unwin, Antony. &quot;Geary's Contiguity Ratio.&quot; The Economic and Social Review 27, no. 2 (1996): 145-159.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
x &lt;- log(georgia$income)
w &lt;- shape2mat(georgia, "W")
gr(x, w)


</code></pre>

<hr>
<h2 id='lg'>Local Geary</h2><span id='topic+lg'></span>

<h3>Description</h3>

<p>A local indicator of spatial association based on the Geary Ratio (Geary's C) for exploratory spatial data analysis. Large values of this statistic highlight local outliers, that is, values that are not like their neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lg(x, w, digits = 3, scale = TRUE, na.rm = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lg_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code>n</code>. By default, this will be standardized using the <code>scale</code> function.</p>
</td></tr>
<tr><td><code id="lg_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>.</p>
</td></tr>
<tr><td><code id="lg_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
<tr><td><code id="lg_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, then <code>x</code> will automatically be standardized using <code>scale(x, center = TRUE, scale = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="lg_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, observations with <code>NA</code> values will be dropped from both <code>x</code> and <code>w</code>.</p>
</td></tr>
<tr><td><code id="lg_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, no warning will be printed to inform you when observations with <code>NA</code> values have been dropped, or if any observations without neighbors have been found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local Geary's C is found in the numerator of the Geary Ratio (GR). For the <code class="reqn">i^{th}</code> observation, the local Geary statistic is
</p>
<p style="text-align: center;"><code class="reqn">C_i = \sum_j w_{i,j} * (x_i - x_j)^2</code>
</p>

<p>Hence, local Geary values will be largest for those observations that are most unlike their neighboring values. If a binary connectivity matrix is used (rather than row-standardized), then having many neighbors will also increase the value of the local Geary statistic. For most purposes, the row-standardized spatial weights matrix may be the more appropriate choice.
</p>


<h3>Value</h3>

<p>The function returns a vector of numeric values, each value being a local indicator of spatial association (or dissimilarity), ordered as <code>x</code>.
</p>


<h3>Source</h3>

<p>Anselin, Luc. &quot;Local indicators of spatial association—LISA.&quot; Geographical analysis 27, no. 2 (1995): 93-115.
</p>
<p>Chun, Yongwan, and Daniel A. Griffith. Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology. Sage, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data(georgia)
x &lt;- log(georgia$income)
w &lt;- shape2mat(georgia, "W")
lisd &lt;- lg(x, w)
hist(lisd)
ggplot(georgia) +
  geom_sf(aes(fill = lisd)) +
scale_fill_gradient(high = "navy",  
                   low = "white") 
 ## or try: scale_fill_viridis() 

</code></pre>

<hr>
<h2 id='lisa'>Local Moran's I</h2><span id='topic+lisa'></span>

<h3>Description</h3>

<p>A local indicator of spatial association (LISA) based on Moran's I (the Moran coefficient) for exploratory data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa(x, w, type = TRUE, scale = TRUE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="lisa_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>. If <code>w</code> is not row standardized (<code>all(Matrix::rowSums(w) == 1)</code>), it will automatically be row-standardized.</p>
</td></tr>
<tr><td><code id="lisa_+3A_type">type</code></td>
<td>
<p>Return the type of association also (High-High, Low-Low, High-Low, and Low-High)? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lisa_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, then <code>x</code> will automatically be standardized using <code>scale(x, center = TRUE, scale = TRUE)</code>. If <code>FALSE</code>, then the variate will be centered but not scaled, using <code>scale(x, center = TRUE, scale = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="lisa_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>x</code> will automatically be centered first with <code>z = scale(x, center = TRUE, scale = scale)</code> (with user control over the <code>scale</code> argument). The LISA values are the product of each <code>z</code> value with the weighted sum of their respective surrounding value: </p>
<p style="text-align: center;"><code class="reqn">I_i = z_i \sum_j w_{ij} z_j</code>
</p>
<p> (or in R code: <code>lisa = z * (w %*% z)</code>). These are for exploratory analysis and model diagnostics.
</p>
<p>An above-average value (i.e. positive z-value) with positive mean spatial lag indicates local positive spatial autocorrelation and is designated type &quot;High-High&quot;; a low value surrounded by high values indicates negative spatial autocorrelation and is designated type &quot;Low-High&quot;, and so on.
</p>
<p>This function uses Equation 7 from Anselin (1995). Note that the <code>spdep</code> package uses Formula 12, which divides the same value by a constant term <code class="reqn">\sum_i z_i^2/n</code>. So the <code>geostan</code> version can be made equal to the <code>spdep</code> version by dividing by that value.
</p>


<h3>Value</h3>

<p>If <code>type = FALSE</code> a numeric vector of lisa values for exploratory analysis of local spatial autocorrelation. If <code>type = TRUE</code>, a <code>data.frame</code> with columns <code>Li</code> (the lisa value) and <code>type</code>.
</p>


<h3>Source</h3>

<p>Anselin, Luc. &quot;Local indicators of spatial association—LISA.&quot; Geographical Analysis 27, no. 2 (1995): 93-115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+aple">aple</a></code>, <code><a href="#topic+lg">lg</a></code>, <code><a href="#topic+gr">gr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(sf)
data(georgia)
w &lt;- shape2mat(georgia, "W")
x &lt;- georgia$ICE
li = lisa(x, w)
head(li)
ggplot(georgia, aes(fill = li$Li)) +
  geom_sf() +
  scale_fill_gradient2()
</code></pre>

<hr>
<h2 id='make_EV'>Extract eigenfunctions of a connectivity matrix for spatial filtering</h2><span id='topic+make_EV'></span>

<h3>Description</h3>

<p>Extract eigenfunctions of a connectivity matrix for spatial filtering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_EV(C, nsa = FALSE, threshold = 0.2, values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_EV_+3A_c">C</code></td>
<td>
<p>A binary spatial weights matrix. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="make_EV_+3A_nsa">nsa</code></td>
<td>
<p>Logical. Default of <code>nsa = FALSE</code> excludes eigenvectors capturing negative spatial autocorrelation.
Setting <code>nsa = TRUE</code> will result in a candidate set of EVs that contains eigenvectors representing positive and negative SA.</p>
</td></tr>
<tr><td><code id="make_EV_+3A_threshold">threshold</code></td>
<td>
<p>Defaults to <code>threshold=0.2</code> to exclude eigenvectors representing spatial autocorrelation levels that are less than <code>threshold</code> times the maximum possible Moran coefficient achievable for the given spatial connectivity matrix. If <code>theshold = 0</code>, all eigenvectors will be returned (however, the eigenvector of constants (with eigenvalue of zero) will be dropped automatically).</p>
</td></tr>
<tr><td><code id="make_EV_+3A_values">values</code></td>
<td>
<p>Should eigenvalues be returned also? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a set of eigenvectors related to the Moran coefficient (MC), limited to those eigenvectors with |MC| &gt; <code>threshold</code> if <code>nsa = TRUE</code> or MC &gt; <code>threshold</code> if <code>nsa = FALSE</code>, optionally with corresponding eigenvalues.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of eigenvectors for spatial filtering. If <code>values=TRUE</code> then a named list is returned with elements <code>eigenvectors</code> and <code>eigenvalues</code>.
</p>


<h3>Source</h3>

<p>Daniel Griffith and Yongwan Chun. 2014. &quot;Spatial Autocorrelation and Spatial Filtering.&quot; in M. M. Fischer and P. Nijkamp (eds.), <em>Handbook of Regional Science.</em> Springer.
</p>


<h3>See Also</h3>

<p><a href="#topic+stan_esf">stan_esf</a>, <a href="#topic+mc">mc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data(georgia)
C &lt;- shape2mat(georgia, style = "B")
EV &lt;- make_EV(C)
head(EV)

ggplot(georgia) +
  geom_sf(aes(fill = EV[,1])) +
  scale_fill_gradient2()
</code></pre>

<hr>
<h2 id='mc'>The Moran coefficient</h2><span id='topic+mc'></span>

<h3>Description</h3>

<p>The Moran coefficient, a measure of spatial autocorrelation (also known as Global Moran's I)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc(x, w, digits = 3, warn = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_+3A_x">x</code></td>
<td>
<p>Numeric vector of input values, length n.</p>
</td></tr>
<tr><td><code id="mc_+3A_w">w</code></td>
<td>
<p>An n x n spatial connectivity matrix. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="mc_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
<tr><td><code id="mc_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, no warning will be printed to inform you when observations with zero neighbors or <code>NA</code> values have been dropped.</p>
</td></tr>
<tr><td><code id="mc_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, observations with <code>NA</code> values will be dropped from both <code>x</code> and <code>w</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the Moran coefficient (MC) is
</p>
<p style="text-align: center;"><code class="reqn">MC = \frac{n}{K}\frac{\sum_i \sum_j w_{ij} (y_i - \overline{y})(y_j - \overline{y})}{\sum_i (y_i - \overline{y})^2}</code>
</p>

<p>where <code class="reqn">n</code> is the number of observations and <code class="reqn">K</code> is the sum of all values in the spatial connectivity matrix <code class="reqn">W</code>, i.e., the sum of all row-sums: <code class="reqn">K = \sum_i \sum_j w_{ij}</code>.
</p>
<p>If any observations with no neighbors are found (i.e. <code>any(Matrix::rowSums(w) == 0)</code>) they will be dropped automatically and a message will print stating how many were dropped. The alternative is for those observations to have a spatial lage of zero&mdash;but zero is not a neutral value, see the Moran scatter plot.
</p>


<h3>Value</h3>

<p>The Moran coefficient, a numeric value.
</p>


<h3>Source</h3>

<p>Chun, Yongwan, and Daniel A. Griffith. Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology. Sage, 2013.
</p>
<p>Cliff, Andrew David, and J. Keith Ord. Spatial processes: models &amp; applications. Taylor &amp; Francis, 1981.
</p>


<h3>See Also</h3>

<p><a href="#topic+moran_plot">moran_plot</a>, <a href="#topic+lisa">lisa</a>, <a href="#topic+aple">aple</a>, <a href="#topic+gr">gr</a>, <a href="#topic+lg">lg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
data(georgia)
w &lt;- shape2mat(georgia, style = "W")
x &lt;- georgia$ICE
mc(x, w)
</code></pre>

<hr>
<h2 id='me_diag'>Data model diagnostics</h2><span id='topic+me_diag'></span>

<h3>Description</h3>

<p>Visual diagnostics for spatial measurement error models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me_diag(
  fit,
  varname,
  shape,
  probs = c(0.025, 0.975),
  plot = TRUE,
  mc_style = c("scatter", "hist"),
  size = 0.25,
  index = 0,
  style = c("W", "B"),
  w = shape2mat(shape, match.arg(style)),
  binwidth = function(x) 0.5 * sd(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="me_diag_+3A_fit">fit</code></td>
<td>
<p>A <code>geostan_fit</code> model object as returned from a call to one of the <code>geostan::stan_*</code> functions.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_varname">varname</code></td>
<td>
<p>Name of the modeled variable (a character string, as it appears in the model formula).</p>
</td></tr>
<tr><td><code id="me_diag_+3A_shape">shape</code></td>
<td>
<p>An object of class <code>sf</code> or another spatial object coercible to <code>sf</code> with <code>sf::st_as_sf</code>.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_probs">probs</code></td>
<td>
<p>Lower and upper quantiles of the credible interval to plot.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, return a list of <code>ggplot</code>s and a <code>data.frame</code> with the raw data values alongside a posterior summary of the modeled variable.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_mc_style">mc_style</code></td>
<td>
<p>Character string indicating how to plot the Moran coefficient for the delta values: if <code>mc = "scatter"</code>, then <code><a href="#topic+moran_plot">moran_plot</a></code> will be used with the marginal residuals; if <code>mc = "hist"</code>, then a histogram of Moran coefficient values will be returned, where each plotted value represents the degree of residual autocorrelation in a draw from the join posterior distribution of delta values.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_size">size</code></td>
<td>
<p>Size of points and lines, passed to <code>geom_pointrange</code>.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_index">index</code></td>
<td>
<p>Integer value; use this if you wish to identify observations with the largest <code>n=index</code> absolute Delta values; data on the top <code>n=index</code> observations ordered by absolute Delta value will be printed to the console and the plots will be labeled with the indices of the identified observations.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_style">style</code></td>
<td>
<p>Style of connectivity matrix; if <code>w</code> is not provided, <code>style</code> is passed to <code><a href="#topic+shape2mat">shape2mat</a></code> and defaults to &quot;W&quot; for row-standardized.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_w">w</code></td>
<td>
<p>An optional spatial connectivity matrix; if not provided, one will be created using <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_binwidth">binwidth</code></td>
<td>
<p>A function with a single argument that will be passed to the <code>binwidth</code> argument in <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>. The default is to set the width of bins to <code>0.5 * sd(x)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of spatial diagnostic plots for measurement error models comparing the raw observations to the posterior distribution of the true values. Includes a point-interval plot of raw values and modeled values; a Moran scatter plot for <code>delta = z - x</code> where <code>z</code> are the survey estimates and <code>x</code> are the modeled values; and a map of the delta values (take at their posterior means).
</p>


<h3>Source</h3>

<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). &ldquo;Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure.&rdquo; <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sp_diag">sp_diag</a></code>, <code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+aple">aple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)
data(georgia)
## binary adjacency matrix
A &lt;- shape2mat(georgia, "B")
## prepare data for the CAR model, using WCAR specification
cars &lt;- prep_car_data(A, style = "WCAR")
## provide list of data for the measurement error model
ME &lt;- prep_me_data(se = data.frame(ICE = georgia$ICE.se),
                   car_parts = cars)
## sample from the prior probability model only, including the ME model
fit &lt;- stan_glm(log(rate.male) ~ ICE,
                ME = ME,
                data = georgia, 
                prior_only = TRUE,
                iter = 800, # for speed only
                chains = 2, # for speed only
                refresh = 0 # silence some printing
                )

## see ME diagnostics
me_diag(fit, "ICE", georgia)
## see index values for the largest (absolute) delta values
 ## (differences between raw estimate and the posterior mean)
me_diag(fit, "ICE", georgia, index = 3)

</code></pre>

<hr>
<h2 id='moran_plot'>Moran plot</h2><span id='topic+moran_plot'></span>

<h3>Description</h3>

<p>Plots a set of values against their spatially lagged values and gives the Moran coefficient as a measure of spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran_plot(
  x,
  w,
  xlab = "x (centered)",
  ylab = "Spatial Lag",
  pch = 20,
  col = "darkred",
  size = 2,
  alpha = 1,
  lwd = 0.5,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran_plot_+3A_x">x</code></td>
<td>
<p>A numeric vector of length n.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_w">w</code></td>
<td>
<p>An n x n spatial connectivity matrix.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_pch">pch</code></td>
<td>
<p>Symbol type.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_col">col</code></td>
<td>
<p>Symbol color.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_size">size</code></td>
<td>
<p>Symbol size.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_alpha">alpha</code></td>
<td>
<p>Symbol transparency.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_lwd">lwd</code></td>
<td>
<p>Width of the regression line.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, any observations of <code>x</code> with <code>NA</code> values will be dropped from <code>x</code> and from <code>w</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the symbol parameters see the documentation for <a href="ggplot2.html#topic+geom_point">geom_point</a>.
</p>
<p>If any observations with no neighbors are found (i.e. <code>any(Matrix::rowSums(w) == 0)</code>) they will be dropped automatically and a message will print stating how many were dropped.
</p>


<h3>Value</h3>

<p>Returns a <code>gg</code> plot, a scatter plot with <code>x</code> on the horizontal and its spatially lagged values on the vertical axis (i.e. a Moran scatter plot).
</p>


<h3>Source</h3>

<p>Anselin, Luc. &quot;Local indicators of spatial association—LISA.&quot; Geographical analysis 27, no. 2 (1995): 93-115.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc">mc</a>, <a href="#topic+lisa">lisa</a>, <a href="#topic+aple">aple</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
x &lt;- georgia$income
w &lt;- shape2mat(georgia, "W")
moran_plot(x, w)
</code></pre>

<hr>
<h2 id='n_eff'>Effective sample size</h2><span id='topic+n_eff'></span>

<h3>Description</h3>

<p>An approximate calculation for the effective sample size for spatially autocorrelated data. Only valid for approximately normally distributed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_eff(n, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_eff_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="n_eff_+3A_rho">rho</code></td>
<td>
<p>Spatial autocorrelation parameter from a simultaneous autoregressive model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements Equation 3 from Griffith (2005).
</p>


<h3>Value</h3>

<p>Returns effective sample size n*, a numeric value.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2005). Effective geographic sample size in the presence of spatial autocorrelation. Annals of the Association of American Geographers. Vol. 95(4): 740-760.
</p>


<h3>See Also</h3>

<p><a href="#topic+sim_sar">sim_sar</a>, <a href="#topic+aple">aple</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_eff(100, 0)
n_eff(100, 0.5)
n_eff(100, 0.9)
n_eff(100, 1)

rho &lt;- seq(0, 1, by = 0.01)
plot(rho, n_eff(100, rho),
     type = 'l',
     ylab = "Effective Sample Size")
</code></pre>

<hr>
<h2 id='posterior_predict'>Draw samples from the posterior predictive distribution</h2><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Draw samples from the posterior predictive distribution of a fitted <code>geostan</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_predict(object, S, summary = FALSE, width = 0.95, car_parts, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict_+3A_object">object</code></td>
<td>
<p>A <code>geostan_fit</code> object.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_s">S</code></td>
<td>
<p>Optional; number of samples to take from the posterior distribution. The default, and maximum, is the total number of samples stored in the model.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_summary">summary</code></td>
<td>
<p>Should the predictive distribution be summarized by its means and central quantile intervals? If <code>summary = FALSE</code>, an <code>S</code> x <code>N</code> matrix of samples will be returned. If <code>summary = TRUE</code>, then a <code>data.frame</code> with the means and <code>100*width</code> credible intervals is returned.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_width">width</code></td>
<td>
<p>Only used if <code>summary = TRUE</code>, to set the quantiles for the credible intervals. Defaults to <code>width = 0.95</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_car_parts">car_parts</code></td>
<td>
<p>Data for CAR model specification; only required for <code><a href="#topic+stan_car">stan_car</a></code> with <code>family = auto_gaussian()</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_seed">seed</code></td>
<td>
<p>A single integer value to be used in a call to <code><a href="base.html#topic+set.seed">set.seed</a></code> before taking samples from the posterior distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size S x N containing samples from the posterior predictive distribution, where S is the number of samples drawn and N is the number of observations. If <code>summary = TRUE</code>, a <code>data.frame</code> with N rows and 3 columns is returned (with column names <code>mu</code>, <code>lwr</code>, and <code>upr</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- stan_glm(sents ~ offset(log(expected_sents)),
                  re = ~ name,
                  data = sentencing,
                  family = poisson(),
                  chains = 2, iter = 600) # for speed only

 yrep &lt;- posterior_predict(fit, S = 65)
 plot(density(yrep[1,]))
 for (i in 2:nrow(yrep)) lines(density(yrep[i,]), col = 'gray30')
 lines(density(sentencing$sents), col = 'darkred', lwd = 2)
</code></pre>

<hr>
<h2 id='predict.geostan_fit'>Predict method for <code>geostan_fit</code> models</h2><span id='topic+predict.geostan_fit'></span>

<h3>Description</h3>

<p>Obtain predicted values from a fitted model by providing new covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
predict(
  object,
  newdata,
  alpha = mean(as.matrix(object, pars = "intercept")),
  center = object$x_center,
  summary = TRUE,
  type = c("link", "response"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.geostan_fit_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables with which to predict, presumably for the purpose of viewing marginal effects. Note that if the model formula includes an offset term, <code>newdata</code> must contain the offset. Note also that any spatially-lagged covariate terms will be ignored if they were provided using the <code>slx</code> argument. If covariates in the model were centered using the <code>centerx</code> argument, the <code>predict.geostan_fit</code> method will automatically center the predictors in <code>newdata</code> using the values stored in <code>object$x_center</code>. If <code>newdata</code> is missing, the fitted values of the model will be returned.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric value or a numeric vector with length equal to <code>nrow(newdata)</code>; <code>alpha</code> serves as the intercept in the linear predictor. The default is to use the posterior mean of the intercept. Even if <code>type = "response"</code>, this needs to be provided on the scale of the linear predictor.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_center">center</code></td>
<td>
<p>May be a vector of numeric values or a logical scalar to pass to <code><a href="base.html#topic+scale">scale</a></code>. Defaults to using <code>object$x_center</code>. If the model was fit using <code>centerx = TRUE</code>, then covariates were centered and their mean values are stored in <code>object$x_center</code> and the <code>predict</code> method will use them to automatically center <code>newdata</code>; if the model was fit with <code>centerx = FALSE</code>, then <code>object$x_center = FALSE</code> and <code>newdata</code> will not be centered.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_summary">summary</code></td>
<td>
<p>Logical; should the values be summarized with the mean, standard deviation and quantiles (<code>probs = c(.025, .2, .5, .8, .975)</code>) for each observation? Otherwise a matrix containing samples from the posterior distribution at each observation is returned.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_type">type</code></td>
<td>
<p>By default, results from <code>predict</code> are on the scale of the linear predictor (<code style="white-space: pre;">&#8288;type = "link")&#8288;</code>). The alternative (<code>type = "response"</code>) is on the scale of the response variable. For example, the default return values for a Poisson model on the log scale, and using <code>type = "response"</code> will return the original scale of the outcome variable (by exponentiating the log values).</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of the predict method is to explore marginal effects of (combinations of) covariates. The method sets the intercept equal to its posterior mean (i.e., <code>alpha = mean(as.matrix(object, pars = "intercept"))</code>); the only source of uncertainty in the results is the posterior distribution of the coefficients, which can be obtained using <code>Beta = as.matrix(object, pars = "beta")</code>.
</p>
<p>The model formula will be taken from <code>object$formula</code>, and then a model matrix will be created by passing <code>newdata</code> to the <a href="stats.html#topic+model.frame">model.frame</a> function (as in: <code>model.frame(newdata, object$formula</code>).
</p>
<p>Be aware that in generalized linear models (such as Poisson and Binomial models) marginal effects of each covariate are sensitive to the level of other covariates in the model. If the model includes any spatially-lagged covariates (introduced using the <code>slx</code> argument) or a spatial autocorrelation term (for example, you used a spatial CAR, SAR, or ESF model), these terms will essentially be fixed at zero for the purposes of calculating marginal effects. If you want to change this, you can introduce spatial trend values by specifying a varying intercept using the <code>alpha</code> argument.
</p>


<h3>Value</h3>

<p>If <code>summary = FALSE</code>, a matrix of samples is returned. If <code>summary = TRUE</code> (the default), a data frame is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
georgia$income &lt;- georgia$income / 1e3

fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)) + log(income),
               data = georgia,
               centerx = TRUE,
               family = poisson(),
               chains = 2, iter = 600) # for speed only

# note: pop.at.risk.male=1 leads to log(pop.at.risk.male)=0
# so that the predicted values are rates
newdata &lt;- data.frame(
             income = seq(min(georgia$income),
                          max(georgia$income),
                           length.out = 100),
             pop.at.risk.male = 1)

preds &lt;- predict(fit, newdata, type = "response")
head(preds)
plot(preds$income,
     preds$mean * 10e3,
     type = "l",
     ylab = "Deaths per 10,000",
     xlab = "Income ($1,000s)")

# here the predictions are rates per 10,000
newdata$pop.at.risk.male &lt;- 10e3
preds &lt;- predict(fit, newdata, type = "response")
head(preds)
plot(preds$income,
    preds$mean,
    type = "l",
    ylab = "Deaths per 10,000",
    xlab = "Income ($1,000s)")
</code></pre>

<hr>
<h2 id='prep_car_data'>Prepare data for the CAR model</h2><span id='topic+prep_car_data'></span>

<h3>Description</h3>

<p>Prepare data for the CAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_car_data(
  A,
  style = c("WCAR", "ACAR", "DCAR"),
  k = 1,
  gamma = 0,
  lambda = TRUE,
  cmat = TRUE,
  stan_fn = ifelse(style == "WCAR", "wcar_normal_lpdf", "car_normal_lpdf")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_car_data_+3A_a">A</code></td>
<td>
<p>Binary adjacency matrix; for <code>style = DCAR</code>, provide a symmetric matrix of distances instead. The distance matrix should be sparse, meaning that most distances should be zero (usually obtained by setting some threshold distance beyond which all are zero).</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_style">style</code></td>
<td>
<p>Specification for the connectivity matrix (C) and conditional variances (M); one of &quot;WCAR&quot;, &quot;ACAR&quot;, or &quot;DCAR&quot;.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_k">k</code></td>
<td>
<p>For <code>style = DCAR</code>, distances will be raised to the -k power (d^-k).</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_gamma">gamma</code></td>
<td>
<p>For <code>style = DCAR</code>, distances will be offset by <code>gamma</code> before raising to the <code>-k</code>th power.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_lambda">lambda</code></td>
<td>
<p>If TRUE, return eigenvalues required for calculating the log determinant of the precision matrix and for determining the range of permissible values of rho. These will also be printed with a message if lambda = TRUE.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_cmat">cmat</code></td>
<td>
<p>If <code>cmat = TRUE</code>, return the full matrix C (in sparse matrix format).</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_stan_fn">stan_fn</code></td>
<td>
<p>Two computational methods are available for CAR models using <code><a href="#topic+stan_car">stan_car</a></code>: <code>car\_normal\_lpdf</code> and <code>wcar\_normal\_lpdf</code>. For WCAR models, either method will work but <code>wcar\_normal\_lpdf</code> is faster. To force use <code>car\_normal\_lpdf</code> when <code>style = 'WCAR'</code>, provide <code>stan_fn = "car_normal_lpdf"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CAR model is:
</p>
<div class="sourceCode"><pre>  Normal(Mu, Sigma), Sigma = (I - rho * C)^-1 * M * tau^2,
</pre></div>
<p>where <code>I</code> is the identity matrix, <code>rho</code> is a spatial autocorrelation parameter, <code>C</code> is a connectivity matrix, and <code>M * tau^2</code> is a diagonal matrix with conditional variances on the diagonal. <code>tau^2</code> is a (scalar) scale parameter.
</p>
<p>In the WCAR specification, <code>C</code> is the row-standardized version of <code>A</code>. This means that the non-zero elements of <code>A</code> will be converted to <code>1/N_i</code> where <code>N_i</code> is the number of neighbors for the <code>i</code>th site (obtained using <code>Matrix::rowSums(A)</code>. The conditional variances (on the diagonal of <code>M * tau^2</code>), are also proportional to <code>1/N_i</code>.
</p>
<p>The ACAR specification is from Cressie, Perrin and Thomas-Agnon (2005); also see Cressie and Wikle (2011, p. 188) and Donegan (2021).
</p>
<p>The DCAR specification is inverse distance-based, and requires the user provide a (sparse) distance matrix instead of a binary adjacency matrix. (For <code>A</code>, provide a symmetric matrix of distances, not inverse distances!) Internally, non-zero elements of <code>A</code> will be converted to: <code style="white-space: pre;">&#8288;d_{ij} = (a_{ij} + gamma)^(-k)&#8288;</code> (Cliff and Ord 1981, p. 144; Donegan 2021). Default values are <code>k=1</code> and <code>gamma=0</code>. Following Cressie (2015), these values will be scaled (divided) by their maximum value. For further details, see the DCAR_A specification in Donegan (2021).
</p>
<p>For inverse-distance weighting schemes, see Cliff and Ord (1981); for distance-based CAR specifications, see Cressie (2015 [1993]), Haining and Li (2020), and Donegan (2021).
</p>
<p>When using <code><a href="#topic+stan_car">stan_car</a></code>, always use <code>cmat = TRUE</code> (the default).
</p>
<p>Details on CAR model specifications can be found in Table 1 of Donegan (2021).
</p>


<h3>Value</h3>

<p>A list containing all of the data elements required by the CAR model in <code><a href="#topic+stan_car">stan_car</a></code>.
</p>


<h3>Source</h3>

<p>Cliff A, Ord J (1981). Spatial Processes: Models and Applications. Pion.
</p>
<p>Cressie N (2015 [1993]). Statistics for Spatial Data. Revised edition. John Wiley &amp; Sons.
</p>
<p>Cressie N, Perrin O, Thomas-Agnan C (2005). “Likelihood-based estimation for Gaussian MRFs.” Statistical Methodology, 2(1), 1–16.
</p>
<p>Cressie N, Wikle CK (2011). Statistics for Spatio-Temporal Data. John Wiley &amp; Sons.
</p>
<p>Donegan, Connor (2021). Spatial conditional autoregressive models in Stan. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Haining RP, Li G (2020). Modelling Spatial and Spatio-Temporal Data: A Bayesian Approach. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)

## use a binary adjacency matrix
A &lt;- shape2mat(georgia, style = "B")

## WCAR specification
cp &lt;- prep_car_data(A, "WCAR")
1 / range(cp$lambda)

## ACAR specification
cp &lt;- prep_car_data(A, "ACAR")

## DCAR specification (inverse-distance based)
A &lt;- shape2mat(georgia, "B")
D &lt;- sf::st_distance(sf::st_centroid(georgia))
A &lt;- D * A
cp &lt;- prep_car_data(A, "DCAR", k = 1)
</code></pre>

<hr>
<h2 id='prep_car_data2'>Prepare data for the CAR model: raster analysis</h2><span id='topic+prep_car_data2'></span>

<h3>Description</h3>

<p>Prepare a list of data required for the CAR model; this is for working with (large) raster data files only. For non-raster analysis, see <a href="#topic+prep_car_data">prep_car_data</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_car_data2(row = 100, col = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_car_data2_+3A_row">row</code></td>
<td>
<p>Number of rows in the raster</p>
</td></tr>
<tr><td><code id="prep_car_data2_+3A_col">col</code></td>
<td>
<p>Number of columns in the raster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prepare input data for the CAR model when your dataset consists of observations on a regular (rectangular) tessellation, such as a raster layer or remotely sensed imagery. The rook criteria is used to determine adjacency. This function uses Equation 5 from Griffith (2000) to generate approximate eigenvalues for a row-standardized spatial weights matrix from a P-by-Q dimension regular tessellation.
</p>
<p>This function can accommodate very large numbers of observations for use with <code><a href="#topic+stan_car">stan_car</a></code>; for large N data, it is also recommended to use <code>slim = TRUE</code> or the <code>drop</code> argument. For more details, see: <code>vignette("raster-regression", package = "geostan")</code>.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2000). Eigenfunction properties and approximations of selected incidence matrices employed in spatial analyses. <em>Linear Algebra and its Applications</em> 321 (1-3): 95-112. <a href="https://doi.org/10.1016/S0024-3795%2800%2900031-8">doi:10.1016/S0024-3795(00)00031-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_sar_data2">prep_sar_data2</a></code>, <code><a href="#topic+prep_car_data">prep_car_data</a></code>, <code><a href="#topic+stan_car">stan_car</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
row = 100
col = 120
car_dl &lt;- prep_car_data2(row = row, col = col)

</code></pre>

<hr>
<h2 id='prep_icar_data'>Prepare data for ICAR models</h2><span id='topic+prep_icar_data'></span>

<h3>Description</h3>

<p>Given a symmetric n x n connectivity matrix, prepare data for intrinsic conditional autoregressive models in Stan. This function may be used for building custom ICAR models in Stan. This is used internally by <code><a href="#topic+stan_icar">stan_icar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_icar_data(C, scale_factor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_icar_data_+3A_c">C</code></td>
<td>
<p>Connectivity matrix</p>
</td></tr>
<tr><td><code id="prep_icar_data_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Optional vector of scale factors for each connected portion of the graph structure. If not provided by the user it will be fixed to a vector of ones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally to prepare data for <code><a href="#topic+stan_icar">stan_icar</a></code> models. It can also be helpful for fitting custom ICAR models outside of <code>geostan</code>.
</p>


<h3>Value</h3>

<p>list of data to add to Stan data list:
</p>

<dl>
<dt>k</dt><dd><p>number of groups</p>
</dd>
<dt>group_size</dt><dd><p>number of nodes per group</p>
</dd>
<dt>n_edges</dt><dd><p>number of connections between nodes (unique pairs only)</p>
</dd>
<dt>node1</dt><dd><p>first node</p>
</dd>
<dt>node2</dt><dd><p>second node. (<code>node1[i]</code> and <code>node2[i]</code> form a connected pair)</p>
</dd>
<dt>weight</dt><dd><p>The element <code>C[node1, node2]</code>.</p>
</dd>
<dt>group_idx</dt><dd><p>indices for each observation belonging each group, ordered by group.</p>
</dd>
<dt>m</dt><dd><p>number of disconnected regions requiring their own intercept.</p>
</dd>
<dt>A</dt><dd><p>n-by-m matrix of dummy variables for the component-specific intercepts.</p>
</dd>
<dt>inv_sqrt_scale_factor</dt><dd><p>By default, this will be a k-length vector of ones. Placeholder for user-specified information. If user provided <code>scale_factor</code>, then this will be <code>1/sqrt(scale_factor)</code>.</p>
</dd>
<dt>comp_id</dt><dd><p>n-length vector indicating the group membership of each observation.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Besag, Julian, Jeremy York, and Annie Mollié. 1991. “Bayesian Image Restoration, with Two Applications in Spatial Statistics.” Annals of the Institute of Statistical Mathematics 43 (1): 1–20.
</p>
<p>Donegan, Connor. Flexible Functions for ICAR, BYM, and BYM2 Models in Stan. Code Repository. 2021. Available online: <a href="https://github.com/ConnorDonegan/Stan-IAR/">https://github.com/ConnorDonegan/Stan-IAR/</a> (accessed Sept. 10, 2021).
</p>
<p>Freni-Sterrantino, Anna, Massimo Ventrucci, and Håvard Rue. 2018. “A Note on Intrinsic Conditional Autoregressive Models for Disconnected Graphs.” Spatial and Spatio-Temporal Epidemiology 26: 25–34.
</p>
<p>Morris, Mitzi, Katherine Wheeler-Martin, Dan Simpson, Stephen J Mooney, Andrew Gelman, and Charles DiMaggio. 2019. “Bayesian Hierarchical Spatial Models: Implementing the Besag York Mollié Model in Stan.” Spatial and Spatio-Temporal Epidemiology 31: 100301.
</p>
<p>Riebler, Andrea, Sigrunn H Sørbye, Daniel Simpson, and Håvard Rue. 2016. “An Intuitive Bayesian Spatial Model for Disease Mapping That Accounts for Scaling.” Statistical Methods in Medical Research 25 (4): 1145–65.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges">edges</a></code>, <code><a href="#topic+shape2mat">shape2mat</a></code>, <code><a href="#topic+stan_icar">stan_icar</a></code>, <code><a href="#topic+prep_car_data">prep_car_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)
C &lt;- shape2mat(sentencing)
icar.data.list &lt;- prep_icar_data(C)
</code></pre>

<hr>
<h2 id='prep_me_data'>Prepare data for spatial measurement error models</h2><span id='topic+prep_me_data'></span>

<h3>Description</h3>

<p>Prepares the list of data required for geostan's (spatial) measurement error models. Given a data frame of standard errors and any optional arguments, the function returns a list with all required data for the models, filling in missing elements with default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_me_data(
  se,
  car_parts,
  prior,
  logit = rep(FALSE, times = ncol(se)),
  bounds = c(-Inf, Inf)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_me_data_+3A_se">se</code></td>
<td>
<p>Data frame of standard errors; column names must match (exactly) the variable names used in the model formula.</p>
</td></tr>
<tr><td><code id="prep_me_data_+3A_car_parts">car_parts</code></td>
<td>
<p>A list of data required for spatial CAR models, as created by <code><a href="#topic+prep_car_data">prep_car_data</a></code>; optional. If omitted, the measurement error model will be a non-spatial Student's t model.</p>
</td></tr>
<tr><td><code id="prep_me_data_+3A_prior">prior</code></td>
<td>
<p>A named list of prior distributions (see <code><a href="#topic+priors">priors</a></code>). If none are provided, default priors will be assigned. The list of priors may include the following parameters:
</p>

<dl>
<dt>df</dt><dd><p>If using a non-spatial ME model, the degrees of freedom (df) for the Student's t model is assigned a gamma prior with default parameters of <code>gamma2(alpha = 3, beta = 0.2)</code>. Provide values for each covariate in <code>se</code>, listing the values in the same order as the columns of <code>se</code>.</p>
</dd>
<dt>location</dt><dd><p>The prior for the location parameter (mu) is a normal (Gaussian) distribution (the default being <code>normal(location = 0, scale = 100)</code>). To adjust the prior distributions, provide values for each covariate in <code>se</code>, listing the values in the same order as the columns of se.</p>
</dd>
<dt>scale</dt><dd><p>The prior for the scale parameters is Student's t, and the default parameters are <code>student_t(df = 10, location = 0, scale = 40)</code>. To adjust, provide values for each covariate in <code>se</code>, listing the values in the same order as the columns of se.</p>
</dd>
<dt>car_rho</dt><dd><p>The CAR model, if used, has a spatial autocorrelation parameter, <code>rho</code>, which is assigned a uniform prior distribution. You must specify values that are within the permissible range of values for <code>rho</code>; these are automatically printed to the console by the <code><a href="#topic+prep_car_data">prep_car_data</a></code> function.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="prep_me_data_+3A_logit">logit</code></td>
<td>
<p>Optional vector of logical values (<code>TRUE</code>, <code>FALSE</code>) indicating if the latent variable should be logit-transformed. Only use for rates. This keeps rates between zero and one and may improve modeling of skewed variables (e.g., the poverty rate).</p>
</td></tr>
<tr><td><code id="prep_me_data_+3A_bounds">bounds</code></td>
<td>
<p>Rarely needed; an optional numeric vector of length two providing the upper and lower bounds, respectively, of the variables (e.g., a magnitudes must be greater than 0). If not provided, they will be set to c(-Inf, Inf) (i.e., unbounded).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data as required for (spatial) ME models. Missing arguments will be filled in with default values, including prior distributions.
</p>


<h3>See Also</h3>

<p><a href="#topic+se_log">se_log</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)

## for a non-spatial prior model for two covariates
se &lt;- data.frame(ICE = georgia$ICE.se,
                 college = georgia$college.se)
ME &lt;- prep_me_data(se)

## see default priors
print(ME$prior)

## set prior for the scale parameters
ME &lt;- prep_me_data(se,
                   prior = list(scale = student_t(df = c(10, 10),
                                                  location = c(0, 0),
                                                  scale = c(20, 20))))

## for a spatial prior model (often recommended)
A &lt;- shape2mat(georgia, "B")
cars &lt;- prep_car_data(A)
ME &lt;- prep_me_data(se,
                   car_parts = cars)
</code></pre>

<hr>
<h2 id='prep_sar_data'>Prepare data for a simultaneous autoregressive (SAR) model</h2><span id='topic+prep_sar_data'></span>

<h3>Description</h3>

<p>Given a spatial weights matrix <code class="reqn">W</code>, this function prepares data for the simultaneous autoregressive (SAR) model (a.k.a spatial error model (SEM)) in Stan. This is used internally by <code><a href="#topic+stan_sar">stan_sar</a></code>, and may also be used for building custom SAR models in Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_sar_data(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_sar_data_+3A_w">W</code></td>
<td>
<p>Spatial weights matrix, typically row-standardized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally to prepare data for <code><a href="#topic+stan_sar">stan_sar</a></code> models. It can also be helpful for fitting custom SAR models in Stan (outside of <code>geostan</code>).
</p>


<h3>Value</h3>

<p>list of data to add to a Stan data list:
</p>

<dl>
<dt>ImW_w</dt><dd><p>Numeric vector containing the non-zero elements of matrix <code class="reqn">(I - W)</code>.</p>
</dd>
<dt>ImW_v</dt><dd><p>An integer vector containing the column indices of the non-zero elements of <code class="reqn">(I - W)</code>.</p>
</dd>
<dt>ImW_u</dt><dd><p>An integer vector indicating where in <code>ImW_w</code> a given row's non-zero values start.</p>
</dd>
<dt>nImW_w</dt><dd><p>Number of entries in <code>ImW_w</code>.</p>
</dd>
<dt>Widx</dt><dd><p>Integer vector containing the indices corresponding to values of <code>-W</code> in <code>ImW_w</code> (i.e. non-diagonal entries of <code class="reqn">(I-W)</code>).</p>
</dd>
<dt>nW</dt><dd><p>Integer length of <code>Widx</code>.</p>
</dd>
<dt>eigenvalues_w</dt><dd><p>Eigenvalues of <code class="reqn">W</code> matrix.</p>
</dd>
<dt>n</dt><dd><p>Number of rows in <code class="reqn">W</code>.</p>
</dd>
<dt>W</dt><dd><p>Sparse matrix representation of <code class="reqn">W</code></p>
</dd>
<dt>rho_min</dt><dd><p>Minimum permissible value of <code class="reqn">\rho</code> (<code>1/min(eigenvalues_w)</code>).</p>
</dd>
<dt>rho_max</dt><dd><p>Maximum permissible value of <code class="reqn">\rho</code> (<code>1/max(eigenvalues_w)</code>.</p>
</dd>
</dl>

<p>The function will also print the range of permissible <code class="reqn">\rho</code> values to the console.
</p>


<h3>See Also</h3>

<p><a href="#topic+shape2mat">shape2mat</a>, <a href="#topic+stan_sar">stan_sar</a>, <a href="#topic+prep_car_data">prep_car_data</a>, <a href="#topic+prep_icar_data">prep_icar_data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
W &lt;- shape2mat(georgia, "W")
sar_dl &lt;- prep_sar_data(W)

</code></pre>

<hr>
<h2 id='prep_sar_data2'>Prepare data for SAR model: raster analysis</h2><span id='topic+prep_sar_data2'></span>

<h3>Description</h3>

<p>Prepares a list of data required for using the SAR model; this is for working with (large) raster data files. For non-raster analysis, see <a href="#topic+prep_sar_data">prep_sar_data</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_sar_data2(row, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_sar_data2_+3A_row">row</code></td>
<td>
<p>Number of rows in the raster</p>
</td></tr>
<tr><td><code id="prep_sar_data2_+3A_col">col</code></td>
<td>
<p>Number of columns in the raster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prepare data for the SAR model when your raw dataset consists of observations on a regular tessellation, such as a raster layer or remotely sensed imagery. The rook criteria is used to determine adjacency. This function uses Equation 5 from Griffith (2000) to calculate the eigenvalues for a row-standardized spatial weights matrix of a P-by-Q dimension regular tessellation.
</p>
<p>This function can accommodate very large numbers of observations for use with <code><a href="#topic+stan_sar">stan_sar</a></code>; for large N data, it is also recommended to use <code>slim = TRUE</code> or the <code>drop</code> argument. For details, see: <code>vignette("raster-regression", package = "geostan")</code>.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2000). Eigenfunction properties and approximations of selected incidence matrices employed in spatial analyses. <em>Linear Algebra and its Applications</em> 321 (1-3): 95-112. <a href="https://doi.org/10.1016/S0024-3795%2800%2900031-8">doi:10.1016/S0024-3795(00)00031-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_car_data2">prep_car_data2</a></code>, <code><a href="#topic+prep_sar_data">prep_sar_data</a></code>, <code><a href="#topic+stan_sar">stan_sar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
row = 100
col = 120
sar_dl &lt;- prep_sar_data2(row = row, col = col)

</code></pre>

<hr>
<h2 id='print.geostan_fit'>print or plot a fitted geostan model</h2><span id='topic+print.geostan_fit'></span><span id='topic+plot.geostan_fit'></span>

<h3>Description</h3>

<p>Print a summary of model results to the R console, or plot posterior distributions of model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
print(
  x,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  digits = 3,
  pars = NULL,
  ...
)

## S3 method for class 'geostan_fit'
plot(x, pars, plotfun = "hist", fill = "steelblue4", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.geostan_fit_+3A_x">x</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_probs">probs</code></td>
<td>
<p>Argument passed to <code>quantile</code>; which quantiles to calculate and print.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_pars">pars</code></td>
<td>
<p>parameters to include; a character string (or vector) of parameter names.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>rstan::plot</code> or <code>rstan::print.stanfit</code>.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_plotfun">plotfun</code></td>
<td>
<p>Argument passed to <code>rstan::plot</code>. Options include histograms (&quot;hist&quot;), MCMC traceplots (&quot;trace&quot;), and density plots (&quot;dens&quot;). Diagnostic plots are also available such as Rhat statistics (&quot;rhat&quot;), effective sample size (&quot;ess&quot;), and MCMC autocorrelation (&quot;ac&quot;).</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_fill">fill</code></td>
<td>
<p>fill color for histograms and density plots.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
georgia$income &lt;- georgia$income/1e3

fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)) + log(income),
                centerx = TRUE,
                data = georgia,
                family = poisson(),
                chains = 2, iter = 600) # for speed only


# print and plot results
print(fit)
plot(fit)
</code></pre>

<hr>
<h2 id='priors'>Prior distributions</h2><span id='topic+priors'></span><span id='topic+uniform'></span><span id='topic+normal'></span><span id='topic+student_t'></span><span id='topic+gamma2'></span><span id='topic+hs'></span>

<h3>Description</h3>

<p>Prior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform(lower, upper, variable = NULL)

normal(location = 0, scale, variable = NULL)

student_t(df = 10, location = 0, scale, variable = NULL)

gamma2(alpha, beta, variable = NULL)

hs(global_scale = 1, slab_df = 10, slab_scale, variable = "beta_ev")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_lower">lower</code>, <code id="priors_+3A_upper">upper</code></td>
<td>
<p>lower and upper bounds of the distribution</p>
</td></tr>
<tr><td><code id="priors_+3A_variable">variable</code></td>
<td>
<p>A reserved slot for the variable name; if provided by the user, this may be ignored by <strong>geostan</strong>.</p>
</td></tr>
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>Location parameter(s), numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>Scale parameter(s), positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_df">df</code></td>
<td>
<p>Degrees of freedom, positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_alpha">alpha</code></td>
<td>
<p>shape parameter, positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_beta">beta</code></td>
<td>
<p>inverse scale parameter, positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_global_scale">global_scale</code></td>
<td>
<p>Control the (prior) degree of sparsity in the horseshoe model (0 &lt; global_scale &lt; 1).</p>
</td></tr>
<tr><td><code id="priors_+3A_slab_df">slab_df</code></td>
<td>
<p>Degrees of freedom for the Student's t model for large coefficients in the horseshoe model (slab_df &gt; 0).</p>
</td></tr>
<tr><td><code id="priors_+3A_slab_scale">slab_scale</code></td>
<td>
<p>Scale parameter for the Student's t model for large coefficients in the horseshoe model (slab_scale &gt; 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior distribution functions are used to set the values of prior parameters.
</p>
<p>Users can control the values of the parameters, but the distribution (model) itself is fixed. The intercept and regression coefficients are given Gaussian prior distributions and scale parameters are assigned Student's t prior distributions. Degrees of freedom parameters are assigned gamma priors, and the spatial autocorrelation parameter in the CAR model, rho, is assigned a uniform prior. The horseshoe (<code>hs</code>) model is used by <code><a href="#topic+stan_esf">stan_esf</a></code>.
</p>
<p>Note that the <code>variable</code> argument is used internally by <code>geostan</code>, and any user provided values will be ignored.
</p>


<h4>Parameterizations</h4>

<p>For details on how any distribution is parameterized, see the Stan Language Functions Reference document: <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>



<h4>The horseshoe prior</h4>

<p>The horseshoe prior is used by <code><a href="#topic+stan_esf">stan_esf</a></code> as a prior for the eigenvector coefficients. The horseshoe model encodes a prior state of knowledge that effectively states, 'I believe a small number of these variables may be important, but I don't know which of them is important.' The horseshoe is a normal distribution with unknown scale (Polson and Scott 2010):
</p>
<div class="sourceCode"><pre>       beta_j ~ Normal(0, tau^2 * lambda_j^2)
</pre></div>
<p>The scale parameter for this prior is the product of two terms: <code>lambda_j^2</code> is specific to the variable <code>beta_j</code>, and <code>tau^2</code> is known as the global shrinkage parameter.
</p>
<p>The global shrinkage parameter is assigned a half-Cauchy prior:
</p>
<div class="sourceCode"><pre>       tau ~ Cauchy(0, global_scale * sigma)
</pre></div>
<p>where <code>global_scale</code> is provided by the user and <code>sigma</code> is the scale parameter for the outcome variable; for Poisson and binomial models, sigma is fixed at one. Use <code>global_scale</code> to control the overall sparsity of the model.
</p>
<p>The second part of the model is a Student's t prior for <code>lambda_j</code>. Most <code>lambda_j</code> will be small, since the model is half-Cauchy:
</p>
<div class="sourceCode"><pre>       lambda_j ~ Cauchy(0, 1)
</pre></div>
<p>This model results in most <code>lambda_j</code> being small, but due to the long tails of the Cauchy distribution, strong evidence in the data can force any particular <code>lambda_j</code> to be large. Piironen and Vehtari (2017) adjust the model so that those large <code>lambda_j</code> are effectively assigned a Student's t model:
</p>
<div class="sourceCode"><pre>       Big_lambda_j ~ Student_t(slab_df, 0, slab_scale)
</pre></div>
<p>This is a schematic representation of the model; see Piironen and Vehtari (2017) or Donegan et al. (2020) for details.
</p>



<h3>Value</h3>

<p>An object of class <code>prior</code> which will be used internally by <strong>geostan</strong> to set parameters of prior distributions.
</p>


<h4>Student's t</h4>

<p>Return value for <code>student_t</code> depends on the input; if no arguments are provided (specifically, if the scale parameter is missing), this will return an object of class 'family'; if at least the scale parameter is provided, <code>student_t</code> will return an object of class <code>prior</code> containing parameter values for the Student's t distribution.
</p>



<h3>Source</h3>

<p>Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moran’s Eigenvectors and hierarchical shrinkage priors. <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a> (open access: <a href="https://doi.org/10.31219/osf.io/fah3z">doi:10.31219/osf.io/fah3z</a>).
</p>
<p>Polson, N.G. and J.G. Scott (2010). Shrink globally, act locally: Sparse Bayesian regularization and prediction. <em>Bayesian Statistics</em> 9, 501-538.
</p>
<p>Piironen, J and A. Vehtari (2017). Sparsity information and regularization in the horseshoe and other shrinkage priors. In <em>Electronic Journal of Statistics</em>, 11(2):5018-5051.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# std. normal priors to k=2 covariates
data(georgia)
prior &lt;- list()
k &lt;- 2
prior$beta &lt;- normal(location = rep(0, times = k),
                     scale = rep(1, times = k))
prior$intercept &lt;- normal(-5, 3)
print(prior)
fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)) + ICE + college,
                re = ~ GEOID,
                data = georgia,
                family = poisson(),
                prior = prior,
                prior_only = TRUE,
                chains = 2, iter = 600) # for speed only
plot(fit)

se &lt;- data.frame(insurance = georgia$insurance.se)
prior &lt;- list()
prior$df &lt;- gamma2(3, 0.2)
prior$location &lt;- normal(50, 50)
prior$scale &lt;- student_t(12, 10, 20)
print(prior)
ME &lt;- prep_me_data(se = se, prior = prior)
fit &lt;- stan_glm(log(rate.male) ~ insurance, 
                data = georgia,
                ME = ME,
                prior_only = TRUE,
               chains = 2, iter = 600) # for speed only

</code></pre>

<hr>
<h2 id='residuals.geostan_fit'>Extract residuals, fitted values, or the spatial trend</h2><span id='topic+residuals.geostan_fit'></span><span id='topic+fitted.geostan_fit'></span><span id='topic+spatial'></span><span id='topic+spatial.geostan_fit'></span>

<h3>Description</h3>

<p>Extract model residuals, fitted values, or spatial trend from a fitted <code>geostan_fit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
residuals(object, summary = TRUE, rates = TRUE, detrend = TRUE, ...)

## S3 method for class 'geostan_fit'
fitted(object, summary = TRUE, rates = TRUE, trend = TRUE, ...)

spatial(object, summary = TRUE, ...)

## S3 method for class 'geostan_fit'
spatial(object, summary = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.geostan_fit_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_summary">summary</code></td>
<td>
<p>Logical; should the values be summarized by their mean, standard deviation, and quantiles (<code>probs = c(.025, .2, .5, .8, .975)</code>) for each observation? Otherwise, a matrix containing samples from the posterior distributions is returned.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_rates">rates</code></td>
<td>
<p>For Poisson and Binomial models, should the fitted values be returned as rates, as opposed to raw counts? Defaults to <code>TRUE</code>; see the <code>Details</code> section for more information.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_detrend">detrend</code></td>
<td>
<p>For auto-normal models (CAR and SAR models with Gaussian likelihood only); if <code>detrend = TRUE</code>, the implicit spatial trend will be removed from the residuals. The implicit spatial trend is <code>Trend = rho * C %*% (Y - Mu)</code> (see <a href="#topic+stan_car">stan_car</a> or <a href="#topic+stan_sar">stan_sar</a>). I.e., <code>resid = Y - (Mu + Trend)</code>.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_trend">trend</code></td>
<td>
<p>For auto-normal models (CAR and SAR models with Gaussian likelihood only); if <code>trend = TRUE</code>, the fitted values will include the implicit spatial trend term. The implicit spatial trend is <code>Trend = rho * C %*% (Y - Mu)</code> (see <a href="#topic+stan_car">stan_car</a> or <a href="#topic+stan_sar">stan_sar</a>). I.e., if <code>trend = TRUE</code>, <code>fitted = Mu + Trend</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>rates = FALSE</code> and the model is Poisson or Binomial, the fitted values returned by the <code>fitted</code> method are the expected value of the response variable. The <code>rates</code> argument is used to translate count outcomes to rates by dividing by the appropriate denominator. The behavior of the <code>rates</code> argument depends on the model specification. Consider a Poisson model of disease incidence, such as the following intercept-only case:
</p>
<div class="sourceCode"><pre>fit &lt;- stan_glm(y ~ offset(log(E)),
               data = data,
               family = poisson())
</pre></div>
<p>If the fitted values are extracted using <code>rates = FALSE</code>, then <code>fitted(fit)</code> will return the expectation of <code class="reqn">y</code>. If <code>rates = TRUE</code> (the default), then <code>fitted(fit)</code> will return the expected value of the rate <code class="reqn">\frac{y}{E}</code>.
</p>
<p>If a binomial model is used instead of the Poisson, then using <code>rates = TRUE</code> will return the expectation of <code class="reqn">\frac{y}{N}</code> where <code class="reqn">N</code> is the sum of the number of 'successes' and 'failures', as in:
</p>
<div class="sourceCode"><pre>fit &lt;- stan_glm(cbind(successes, failures) ~ 1,
               data = data,
               family = binomial())
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>
data(georgia)
A &lt;- shape2mat(georgia, "B")

fit &lt;- stan_esf(deaths.male ~ offset(log(pop.at.risk.male)),
                C = A,
                data = georgia,
                family = poisson(),
                chains = 1, iter = 600) # for speed only


# Residuals
r &lt;- resid(fit)
moran_plot(r$mean, A)
head(r)

# Fitted values
f &lt;- fitted(fit)

# Fitted values, unstandardized
f &lt;- fitted(fit, rates = FALSE)
head(f)

# Spatial trend
esf &lt;- spatial(fit)
head(esf)

</code></pre>

<hr>
<h2 id='row_standardize'>Row-standardize a matrix; safe for zero row-sums.</h2><span id='topic+row_standardize'></span>

<h3>Description</h3>

<p>Row-standardize a matrix; safe for zero row-sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_standardize(C, warn = TRUE, msg = "Row standardizing connectivity matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_standardize_+3A_c">C</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="row_standardize_+3A_warn">warn</code></td>
<td>
<p>Print <code>msg</code> if <code>warn = TRUE</code>.</p>
</td></tr>
<tr><td><code id="row_standardize_+3A_msg">msg</code></td>
<td>
<p>A warning message to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row-standardized matrix, W (i.e., all row sums equal 1, or zero).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- shape2mat(georgia)
head(Matrix::summary(A))
Matrix::rowSums(A)

W &lt;- row_standardize(A)
head(Matrix::summary(W))
Matrix::rowSums(W)
</code></pre>

<hr>
<h2 id='se_log'>Standard error of log(x)</h2><span id='topic+se_log'></span>

<h3>Description</h3>

<p>Transform the standard error of <code>x</code> to standard error of <code>log(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se_log(x, se, method = c("mc", "delta"), nsim = 5000, bounds = c(0, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_log_+3A_x">x</code></td>
<td>
<p>An estimate</p>
</td></tr>
<tr><td><code id="se_log_+3A_se">se</code></td>
<td>
<p>Standard error of <code>x</code></p>
</td></tr>
<tr><td><code id="se_log_+3A_method">method</code></td>
<td>
<p>The <code>"delta"</code> method uses a Taylor series approximation; the default method, <code>"mc"</code>, uses a simple monte carlo method.</p>
</td></tr>
<tr><td><code id="se_log_+3A_nsim">nsim</code></td>
<td>
<p>Number of draws to take if <code>method = "mc"</code>.</p>
</td></tr>
<tr><td><code id="se_log_+3A_bounds">bounds</code></td>
<td>
<p>Lower and upper bounds for the variable, used in the monte carlo method. Must be a length-two numeric vector with lower bound greater than or equal to zero (i.e. <code>c(lower, upper)</code> as in default <code>bounds = c(0, Inf)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delta method returns <code>x^(-1) * se</code>. The monte carlo method is detailed in the examples section.
</p>


<h3>Value</h3>

<p>Numeric vector of standard errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
x = georgia$college
se = georgia$college.se

lse1 = se_log(x, se)
lse2 = se_log(x, se, method = "delta")
plot(lse1, lse2); abline(0, 1)

# the monte carlo method
x = 10
se = 2
z = rnorm(n = 20e3, mean = x,  sd = se)
l.z = log(z)
sd(l.z)
se_log(x, se, method = "mc")
se_log(x, se, method = "delta")
</code></pre>

<hr>
<h2 id='sentencing'>Florida state prison sentencing counts by county, 1905-1910</h2><span id='topic+sentencing'></span>

<h3>Description</h3>

<p>Simple features (<code>sf</code>) with historic (1910) county boundaries of Florida with aggregated state prison sentencing counts and census data.
Sentencing and population counts are aggregates over the period 1905-1910, where populations were interpolated linearly between decennial censuses of 1900 and 1910.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentencing
</code></pre>


<h3>Format</h3>

<p>Simple features (<code>sf</code>)/<code>data.frame</code> with the following attributes:
</p>

<dl>
<dt>name</dt><dd><p>County name</p>
</dd>
<dt>wpop</dt><dd><p>White population total for years 1905-1910</p>
</dd>
<dt>bpop</dt><dd><p>Black population total for years 1905-1910</p>
</dd>
<dt>sents</dt><dd><p>Number of state prison sentences, 1905-1910</p>
</dd>
<dt>plantation_belt</dt><dd><p>Binary indicator for inclusion in the plantation belt</p>
</dd>
<dt>pct_ag_1910</dt><dd><p>Percent of land area in agriculture, 1910</p>
</dd>
<dt>expected_sents</dt><dd><p>Expected sentences given demographic information and state level sentencing rates by race</p>
</dd>
<dt>sir_raw</dt><dd><p>Standardized incident ratio (observed/expected sentences)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Donegan, Connor. &quot;The Making of Florida's 'Criminal Class': Race, Modernity and the Convict Leasing Program.&quot; Florida Historical Quarterly 97.4 (2019): 408-434. <a href="https://osf.io/2wj7s/">https://osf.io/2wj7s/</a>.
</p>
<p>Mullen, Lincoln A. and Bratt, Jordon. &quot;USABoundaries: Historical and Contemporary Boundaries of the United States of America,&quot;
Journal of Open Source Software 3, no. 23 (2018): 314, <a href="https://doi.org/10.21105/joss.00314">doi:10.21105/joss.00314</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)
print(sentencing)
</code></pre>

<hr>
<h2 id='shape2mat'>Create spatial and space-time connectivity matrices</h2><span id='topic+shape2mat'></span>

<h3>Description</h3>

<p>Creates sparse matrix representations of spatial connectivity structures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape2mat(
  shape,
  style = c("B", "W"),
  queen = TRUE,
  snap = sqrt(.Machine$double.eps),
  t = 1,
  st.style = c("contemp", "lag")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape2mat_+3A_shape">shape</code></td>
<td>
<p>An object of class <code>sf</code>, <code>SpatialPolygons</code> or <code>SpatialPolygonsDataFrame</code>.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_style">style</code></td>
<td>
<p>What kind of coding scheme should be used to create the spatial connectivity matrix? Defaults to &quot;B&quot; for binary; use &quot;W&quot; for row-standardized weights.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_queen">queen</code></td>
<td>
<p>Passed to <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code> to set the contiguity condition. Defaults to <code>TRUE</code> so that a single shared boundary point (rather than a shared border/line) between polygons is sufficient for them to be considered neighbors.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_snap">snap</code></td>
<td>
<p>Passed to <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>; &quot;boundary points less than ‘snap’ distance apart are considered to indicate contiguity.&quot;</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_t">t</code></td>
<td>
<p>Number of time periods. Only the binary coding scheme is available for space-time connectivity matrices.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_st.style">st.style</code></td>
<td>
<p>For space-time data, what type of space-time connectivity structure should be used? Options are &quot;lag&quot; for the lagged specification and &quot;contemp&quot; (the default) for contemporaneous specification (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haining and Li (Ch. 4) provide a helpful discussion of spatial connectivity matrices (Ch. 4).
</p>
<p>The space-time connectivity matrix can be used for eigenvector space-time filtering (<code><a href="#topic+stan_esf">stan_esf</a></code>. The <code style="white-space: pre;">&#8288;lagged' space-time structure connects each observation to its own past (one period lagged) value and the past value of its neighbors. The &#8288;</code>contemporaneous' specification links each observation to its neighbors and to its own in situ past (one period lagged) value (Griffith 2012, p. 23).
</p>


<h3>Value</h3>

<p>A spatial connectivity matrix
</p>


<h3>Source</h3>

<p>Bivand, Roger S. and Pebesma, Edzer and Gomez-Rubio, Virgilio (2013). Applied spatial data analysis with R, Second edition. Springer, NY. https://asdar-book.org/
</p>
<p>Griffith, Daniel A. (2012). Space, time, and space-time eigenvector filter specifications that account for autocorrelation. Estadística Espanola, 54(177), 7-34.
</p>
<p>Haining, Robert P. and Li, Guangquan (2020). Regression Modelling Wih Spatial and Spatial-Temporal Data: A Bayesian Approach. CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges">edges</a></code> <code><a href="#topic+prep_car_data">prep_car_data</a></code> <code><a href="#topic+prep_icar_data">prep_icar_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)

## binary adjacency matrix
C &lt;- shape2mat(georgia, "B")
## row sums gives the numbers of neighbors per observation
Matrix::rowSums(C)
head(Matrix::summary(C))

## row-standardized matrix 
W &lt;- shape2mat(georgia, "W")
Matrix::rowSums(W)
head(Matrix::summary(W))

## space-time matricies 
## for eigenvector space-time filtering
## if you have multiple years with same neighbors,
## provide the geography (for a single year!) and number of years \code{t}
Cst &lt;- shape2mat(georgia, t = 5)
dim(Cst)
EVst &lt;- make_EV(Cst)
dim(EVst)
</code></pre>

<hr>
<h2 id='sim_sar'>Simulate spatially autocorrelated data</h2><span id='topic+sim_sar'></span>

<h3>Description</h3>

<p>Given a spatial weights matrix and degree of autocorrelation, returns autocorrelated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_sar(m = 1, mu = rep(0, nrow(w)), w, rho, sigma = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_sar_+3A_m">m</code></td>
<td>
<p>The number of samples required. Defaults to <code>m=1</code> to return an <code>n</code>-length vector; if <code>m&gt;1</code>, an <code>m x n</code> matrix is returned (i.e. each row will contain a sample of correlated values).</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_mu">mu</code></td>
<td>
<p>An <code>n</code>-length vector of mean values. Defaults to a vector of zeros with length equal to <code>nrow(w)</code>.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_w">w</code></td>
<td>
<p>Row-standardized <code>n x n</code> spatial weights matrix.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_rho">rho</code></td>
<td>
<p>Spatial autocorrelation parameter in the range (-1, 1). Typically a scalar value; otherwise an n-length numeric vector.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter (standard deviation). Defaults to <code>sigma = 1</code>. Typically a scalar value; otherwise an n-length numeric vector.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>MASS::mvrnorm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code>MASS::mvrnorm</code> internally to draw from the multivariate normal distribution. The covariance matrix is specified following the simultaneous autoregressive (SAR) model.
</p>


<h3>Value</h3>

<p>If <code>m = 1</code> a vector of the same length as <code>mu</code>, otherwise an <code>m x length(mu)</code> matrix with one sample in each row.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aple">aple</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+lisa">lisa</a></code>, <code><a href="#topic+shape2mat">shape2mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
w &lt;- shape2mat(georgia, "W")
x &lt;- sim_sar(w = w, rho = 0.5)
aple(x, w)

x &lt;- sim_sar(w = w, rho = 0.7, m = 10)
dim(x)
apply(x, 1, aple, w = w)
</code></pre>

<hr>
<h2 id='sp_diag'>Spatial data diagnostics</h2><span id='topic+sp_diag'></span><span id='topic+sp_diag.geostan_fit'></span><span id='topic+sp_diag.numeric'></span>

<h3>Description</h3>

<p>Visual diagnostics for areal data and model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_diag(y, shape, ...)

## S3 method for class 'geostan_fit'
sp_diag(
  y,
  shape,
  name = "Residual",
  plot = TRUE,
  mc_style = c("scatter", "hist"),
  style = c("W", "B"),
  w,
  rates = TRUE,
  binwidth = function(x) 0.5 * stats::sd(x, na.rm = TRUE),
  size = 0.1,
  ...
)

## S3 method for class 'numeric'
sp_diag(
  y,
  shape,
  name = "y",
  plot = TRUE,
  mc_style = c("scatter", "hist"),
  style = c("W", "B"),
  w = shape2mat(shape, match.arg(style)),
  binwidth = function(x) 0.5 * stats::sd(x, na.rm = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_diag_+3A_y">y</code></td>
<td>
<p>A numeric vector, or a fitted <code>geostan</code> model (class <code>geostan_fit</code>).</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_shape">shape</code></td>
<td>
<p>An object of class <code>sf</code> or another spatial object coercible to <code>sf</code> with <code>sf::st_as_sf</code> such as <code>SpatialPolygonsDataFrame</code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a></code>. For binomial and Poisson models, this includes the option to view the outcome variable as a rate (the default) rather than a count; for <code><a href="#topic+stan_car">stan_car</a></code> models with auto-Gaussian likelihood (<code style="white-space: pre;">&#8288;fit$family$family = "auto_gaussian"), the residuals will be detrended by default, but this can be changed using &#8288;</code>detrend = FALSE'.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_name">name</code></td>
<td>
<p>The name to use on the plot labels; default to &quot;y&quot; or, if <code>y</code> is a <code>geostan_fit</code> object, to &quot;Residuals&quot;.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, return a list of <code>gg</code> plots.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_mc_style">mc_style</code></td>
<td>
<p>Character string indicating how to plot the residual Moran coefficient (only used if <code>y</code> is a fitted model): if <code>mc = "scatter"</code>, then <code><a href="#topic+moran_plot">moran_plot</a></code> will be used with the marginal residuals; if <code>mc = "hist"</code>, then a histogram of Moran coefficient values will be returned, where each plotted value represents the degree of residual autocorrelation in a draw from the join posterior distribution of model parameters.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_style">style</code></td>
<td>
<p>Style of connectivity matrix; if <code>w</code> is not provided, <code>style</code> is passed to <code><a href="#topic+shape2mat">shape2mat</a></code> and defaults to &quot;W&quot; for row-standardized.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_w">w</code></td>
<td>
<p>An optional spatial connectivity matrix; if not provided and <code>y</code> is a numeric vector, one will be created using <code><a href="#topic+shape2mat">shape2mat</a></code>. If <code>w</code> is not provided and <code>y</code> is a fitted <code>geostan</code> model, then the spatial connectivity matrix that is stored with the fitted model (<code>y$C</code>) will be used.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_rates">rates</code></td>
<td>
<p>For Poisson and binomial models, convert the outcome variable to a rate before plotting fitted values and residuals. Defaults to <code>rates = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_binwidth">binwidth</code></td>
<td>
<p>A function with a single argument that will be passed to the <code>binwidth</code> argument in <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>. The default is to set the width of bins to <code>0.5 * sd(x)</code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_size">size</code></td>
<td>
<p>Point size and linewidth for point-interval plot of observed vs. fitted values (passed to <code><a href="ggplot2.html#topic+geom_pointrange">geom_pointrange</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When provided with a numeric vector, this function plots a histogram, Moran scatter plot, and map.
</p>
<p>When provided with a fitted <code>geostan</code> model, the function returns a point-interval plot of observed values against fitted values (mean and 95 percent credible interval), either a Moran scatter plot of residuals or a histogram of Moran coefficient values calculated from the joint posterior distribution of the residuals, and a map of the mean posterior residuals (means of the marginal distributions).
</p>
<p>When <code>y</code> is a fitted CAR or SAR model with <code>family = auto_gaussian()</code>, the fitted values will include implicit spatial trend term, i.e. the call to <a href="#topic+fitted.geostan_fit">fitted.geostan_fit</a> will use the default <code>trend = TRUE</code> and the call to <a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a> will use the default <code>detrend = TRUE</code>. (See <a href="#topic+stan_car">stan_car</a> or <a href="#topic+stan_sar">stan_sar</a> for additional details on their implicit spatial trend components.)
</p>


<h3>Value</h3>

<p>A grid of spatial diagnostic plots. If <code>plot = TRUE</code>, the <code>ggplots</code> are drawn using <a href="gridExtra.html#topic+grid.arrange">grid.arrange</a>; otherwise, they are returned in a list. For the <code>geostan_fit</code> method, the underlying data for the Moran coefficient (as required for <code>mc_style = "hist"</code>) will also be returned if <code>plot = FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+me_diag">me_diag</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+aple">aple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(georgia)
sp_diag(georgia$college, georgia)

bin_fn &lt;- function(y) mad(y, na.rm = TRUE)
sp_diag(georgia$college, georgia, binwidth = bin_fn)

fit &lt;- stan_glm(log(rate.male) ~ log(income),
                data = georgia,
                chains = 2, iter = 800) # for speed only
sp_diag(fit, georgia)

</code></pre>

<hr>
<h2 id='stan_car'>Conditional autoregressive (CAR) models</h2><span id='topic+stan_car'></span>

<h3>Description</h3>

<p>Use the CAR model as a prior on parameters, or fit data to a spatial Gaussian CAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_car(
  formula,
  slx,
  re,
  data,
  car_parts,
  C,
  family = gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  censor_point,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_car_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <code><a href="stats.html#topic+formula">formula</a></code> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div>
<p>With the CAR model, any <code>alpha_re</code> term should be at a <em>different</em> level or scale than the observations; that is, at a different scale than the autocorrelation structure of the CAR model itself.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_car_parts">car_parts</code></td>
<td>
<p>A list of data for the CAR model, as returned by <code><a href="#topic+prep_car_data">prep_car_data</a></code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_c">C</code></td>
<td>
<p>Optional spatial connectivity matrix which will be used to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms; it will automatically be row-standardized before calculating <code>slx</code> terms. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>auto_gaussian()</code>, <code>binomial(link = "logit")</code>, and <code>poisson(link = "log")</code>; if <code>family = gaussian()</code> is provided, it will automatically be converted to <code>auto_gaussian()</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>car_scale</dt><dd><p>Scale parameter for the CAR model, <code>car_scale</code>. The scale is assigned a Student's t prior model (constrained to be positive).</p>
</dd>
<dt>car_rho</dt><dd><p>The spatial autocorrelation parameter in the CAR model, <code>rho</code>, is assigned a uniform prior distribution. By default, the prior will be uniform over all permissible values as determined by the eigenvalues of the connectivity matrix, <code>C</code>. The range of permissible values for <code>rho</code> is automatically printed to the console by <code><a href="#topic+prep_car_data">prep_car_data</a></code>.</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for any varying intercepts (a.k.a exchangeable random effects, or partial pooling) terms. This scale parameter, <code>tau</code>, is assigned a Student's t prior (constrained to be positive).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_car_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_prior_only">prior_only</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, draw samples only from the prior distributions of parameters.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to use.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from CAR models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>log_lambda_mu</dt><dd><p>Linear predictor inside the CAR model (for Poisson and binomial models)</p>
</dd>
<dt>log_lik</dt><dd><p>The N-length vector of pointwise log-likelihoods, which is used to calculate WAIC.</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
</dl>

<p>If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <code><a href="rstan.html#topic+stan">stan</a></code> for details.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CAR models are discussed in Cressie and Wikle (2011, p. 184-88), Cressie (2015, Ch. 6-7), and Haining and Li (2020, p. 249-51). It is often used for areal or lattice data.
</p>
<p>Details for the Stan code for this implementation of the CAR model can be found in Donegan (2021).
</p>
<p>The general scheme for the CAR model is as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 y \sim Gauss( \mu, ( I - \rho C)^{-1} M),
</code>
</p>

<p>where <code class="reqn">I</code> is the identity matrix, <code class="reqn">\rho</code> is a spatial dependence parameter, <code class="reqn">C</code> is a spatial connectivity matrix, and <code class="reqn">M</code> is a diagonal matrix of variance terms. The diagonal of <code class="reqn">M</code> contains a scale parameter <code class="reqn">\tau</code> multiplied by a vector of weights (often set to be proportional to the inverse of the number of neighbors assigned to each site). The CAR model owes its name to the fact that this joint distribution corresponds to a set of conditional distributions that relate the expected value of each observation to a function of neighboring values, i.e., the Markov condition holds:
</p>
<p style="text-align: center;"><code class="reqn">
E(y_i | y_1, y_2, \dots, y_{i-1}, y_{i+1}, \dots, y_n) = \mu_i + \rho \sum_{j=1}^n c_{i,j} (y_j - \mu_j),
</code>
</p>

<p>where entries of <code class="reqn">c_{i,j}</code> are non-zero only if <code class="reqn">j \in N(i)</code> and <code class="reqn">N(i)</code> indexes the sites that are neighbors of the <code class="reqn">i^{th}</code> site.
</p>
<p>With the Gaussian probability distribution,
</p>
<p style="text-align: center;"><code class="reqn">
 y_i | y_j: j \neq i \sim Gauss(\mu_i + \rho \sum_{j=1}^n c_{i,j} (y_j - \mu_j), \tau_i^2)
</code>
</p>

<p>where <code class="reqn">\tau_i</code> is a scale parameter and <code class="reqn">\mu_i</code> may contain covariates or simply the intercept.
</p>
<p>The covariance matrix of the CAR model contains two parameters: <code class="reqn">\rho</code> (<code>car_rho</code>) which controls the kind (positive or negative) and degree of spatial autocorrelation, and the scale parameter <code class="reqn">\tau</code> (<code>car_scale</code>). The range of permissible values for <code class="reqn">\rho</code> depends on the specification of <code class="reqn">\boldsymbol C</code> and <code class="reqn">\boldsymbol M</code>; for specification options, see <a href="#topic+prep_car_data">prep_car_data</a> and Cressie and Wikle (2011, pp. 184-188) or Donegan (2021).
</p>
<p>Further details of the models and results depend on the <code>family</code> argument, as well as on the particular CAR specification chosen (from <a href="#topic+prep_car_data">prep_car_data</a>).
</p>


<h4>Auto-Gaussian</h4>

<p>When <code>family = auto_gaussian()</code> (the default), the CAR model is applied directly to the data as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 y \sim Gauss( \mu, (I - \rho C)^{-1} M),
</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean vector (with intercept, covariates, etc.), <code class="reqn">C</code> is a spatial connectivity matrix, and <code class="reqn">M</code> is a known diagonal matrix containing the conditional variances <code class="reqn">\tau_i^2</code>. <code class="reqn">C</code> and <code class="reqn">M</code> are provided by <a href="#topic+prep_car_data">prep_car_data</a>.
</p>
<p>The auto-Gaussian model contains an implicit spatial trend (i.e. autocorrelation) component <code class="reqn">\phi</code> which can be calculated as follows (Cressie 2015, p. 564):
</p>
<p style="text-align: center;"><code class="reqn">
 \phi = \rho C (y - \mu).
</code>
</p>

<p>This term can be extracted from a fitted auto-Gaussian model using the <a href="#topic+spatial">spatial</a> method.
</p>
<p>When applied to a fitted auto-Gaussian model, the <a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a> method returns 'de-trended' residuals <code class="reqn">R</code> by default. That is,
</p>
<p style="text-align: center;"><code class="reqn">
R = y - \mu - \rho C (y - \mu).
</code>
</p>

<p>To obtain &quot;raw&quot; residuals (<code class="reqn">y - \mu</code>), use <code>residuals(fit, detrend = FALSE)</code>. Similarly, the fitted values obtained from the <a href="#topic+fitted.geostan_fit">fitted.geostan_fit</a> will include the spatial trend term by default.
</p>



<h4>Poisson</h4>

<p>For <code>family = poisson()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \lambda})</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda \sim Gauss(\mu, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>If the raw outcome consists of a rate <code class="reqn">\frac{y}{p}</code> with observed counts <code class="reqn">y</code> and denominator <code class="reqn">p</code> (often this will be the size of the population at risk), then the offset term <code class="reqn">O=log(p)</code> is the log of the denominator.
</p>
<p>This is often written (equivalently) as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \mu + \phi})</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi \sim Gauss(0, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>For Poisson models, the <a href="#topic+spatial">spatial</a> method returns the parameter vector <code class="reqn">\phi</code>.
</p>
<p>In the Poisson CAR model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it: <code class="reqn">\phi_i = \rho \sum_{i=1}^n c_{ij} \phi_j + \epsilon_i</code>, where <code class="reqn">\epsilon_i \sim Gauss(0, \tau_i^2)</code>. If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating (following Cressie 2015, p. 564):
</p>
<p style="text-align: center;"><code class="reqn">\rho  C  \phi.</code>
</p>




<h4>Binomial</h4>

<p>For <code>family = binomial()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Binomial(N, \lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\lambda) \sim Gauss(\mu, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>where outcome data <code class="reqn">y</code> are counts, <code class="reqn">N</code> is the number of trials, <code class="reqn">\lambda</code> is the 'success' rate, and <code class="reqn">\mu</code> contains the intercept and possibly covariates. Note that the model formula should be structured as: <code>cbind(sucesses, failures) ~ x</code>, such that <code>trials = successes + failures</code>.
</p>
<p>This is often written (equivalently) as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Binomial(N, \lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\lambda) = \mu + \phi</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi \sim Gauss(0, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>For fitted Binomial models, the <a href="#topic+spatial">spatial</a> method will return the parameter vector <code>phi</code>.
</p>
<p>As is also the case for the Poisson model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it. If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating:
</p>
<p style="text-align: center;"><code class="reqn">
\rho C \phi.
</code>
</p>




<h4>Additional functionality</h4>

<p>The CAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame.</p>
</dd>
<dt>diagnostic</dt><dd><p>Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (<code>eff_pars</code>) and mean log pointwise predictive density (<code>lpd</code>), and mean residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including CAR component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>, the varying intercepts (<code>re</code>) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial component parameter (either &quot;phi&quot; or, for auto Gaussian models, &quot;trend&quot;) and method (&quot;CAR&quot;)</p>
</dd>
<dt>ME</dt><dd><p>A list indicating if the object contains an ME model; if so, the user-provided ME list is also stored here.</p>
</dd>
<dt>C</dt><dd><p>Spatial connectivity matrix (in sparse matrix format).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Besag, Julian (1974). Spatial interaction and the statistical analysis of lattice systems. <em>Journal of the Royal Statistical Society</em> B36.2: 192–225.
</p>
<p>Cressie, Noel (2015 (1993)). <em>Statistics for Spatial Data</em>. Wiley Classics, Revised Edition.
</p>
<p>Cressie, Noel and Wikle, Christopher (2011). <em>Statistics for Spatio-Temporal Data</em>. Wiley.
</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Haining, Robert and Li, Guangquan (2020). <em>Modelling Spatial and Spatial-Temporal Data: A Bayesian Approach</em>. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# model mortality risk
data(georgia)
C &lt;- shape2mat(georgia, style = "B")
cp &lt;- prep_car_data(C)

fit &lt;- stan_car(deaths.male ~ offset(log(pop.at.risk.male)),
                car_parts = cp,
                data = georgia,
                family = poisson(),
                iter = 800, chains = 1 # for example speed only
                 )
rstan::stan_rhat(fit$stanfit)
rstan::stan_mcse(fit$stanfit)
print(fit)
sp_diag(fit, georgia)


## DCAR specification (inverse-distance based)
library(sf)
A &lt;- shape2mat(georgia, "B")
D &lt;- sf::st_distance(sf::st_centroid(georgia))
A &lt;- D * A
cp &lt;- prep_car_data(A, "DCAR", k = 1)

fit &lt;- stan_car(deaths.male ~ offset(log(pop.at.risk.male)),
               data = georgia,
               car = cp,
               family = poisson(),
               iter = 800, chains = 1 # for example speed only 
)
print(fit)


</code></pre>

<hr>
<h2 id='stan_esf'>Spatial filtering</h2><span id='topic+stan_esf'></span>

<h3>Description</h3>

<p>Fit a spatial regression model using eigenvector spatial filtering (ESF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_esf(
  formula,
  slx,
  re,
  data,
  C,
  EV = make_EV(C, nsa = nsa, threshold = threshold),
  nsa = FALSE,
  threshold = 0.25,
  family = gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  censor_point,
  prior_only = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_esf_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <code><a href="stats.html#topic+formula">formula</a></code> syntax. Binomial models are specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div></td></tr>
<tr><td><code id="stan_esf_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix which will be used to calculate eigenvectors, if <code>EV</code> is not provided by the user. Typically, the binary connectivity matrix is best for calculating eigenvectors (i.e., using <code>C = shape2mat(shape, style = "B")</code>). This matrix will also be used to calculate residual spatial autocorrelation and any user specified <code>slx</code> terms; it will be row-standardized before calculating <code>slx</code> terms. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_ev">EV</code></td>
<td>
<p>A matrix of eigenvectors from any (transformed) connectivity matrix, presumably spatial (see <code><a href="#topic+make_EV">make_EV</a></code>). If <code>EV</code> is provided, still also provide a spatial weights matrix <code>C</code> for other purposes; <code>threshold</code> and <code>nsa</code> are ignored for user provided <code>EV</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_nsa">nsa</code></td>
<td>
<p>Include eigenvectors representing negative spatial autocorrelation? Defaults to <code>nsa = FALSE</code>. This is ignored if <code>EV</code> is provided.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_threshold">threshold</code></td>
<td>
<p>Eigenvectors with standardized Moran coefficient values below this <code>threshold</code> value will be excluded from the candidate set of eigenvectors, <code>EV</code>. This defaults to <code>threshold = 0.25</code>, and is ignored if <code>EV</code> is provided.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>family = gaussian()</code>, <code>student_t()</code> and <code>poisson(link = "log")</code>, and <code>binomial(link = "logit")</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):  </p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sigma</dt><dd><p>For <code>family = gaussian()</code> and <code>family = student_t()</code> models, the scale parameter, <code>sigma</code>, is assigned a (half-) Student's t prior distribution. The half-Student's t prior for <code>sigma</code> is constrained to be positive.</p>
</dd>
<dt>nu</dt><dd><p><code>nu</code> is the degrees of freedom parameter in the Student's t likelihood (only used when <code>family = student_t()</code>). <code>nu</code> is assigned a gamma prior distribution. The default prior is <code>prior = list(nu = gamma2(alpha = 3, beta = 0.2))</code>. </p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for random effects, or varying intercepts, terms. This scale parameter, <code>tau</code>, is assigned a half-Student's t prior. To set this, use, e.g., <code>prior = list(tau = student_t(df = 20, location = 0, scale = 20))</code>.</p>
</dd>
<dt>beta_ev</dt><dd><p>The eigenvector coefficients are assigned the horseshoe prior (Piironen and Vehtari, 2017), parameterized by <code>global_scale</code> (to control overall prior sparsity), plus the degrees of freedom and scale of a Student's t model for any large coefficients (see <code><a href="#topic+priors">priors</a></code>). To allow the spatial filter to account for a greater amount of spatial autocorrelation (i.e., if you find the residuals contain spatial autocorrelation), increase the global scale parameter (to a maximum of <code>global_scale = 1</code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_esf_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths. For example, the US Centers for Disease Control and Prevention censors (does not report) death counts that are nine or fewer, so if you're using CDC WONDER mortality data you could provide <code>censor_point = 9</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_prior_only">prior_only</code></td>
<td>
<p>Draw samples from the prior distributions of parameters only.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to estimate. Default <code>chains = 4</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain. Default <code>iter = 2000</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Defaults to <code>500</code>; set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is useful for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from ESF models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>log_lik</dt><dd><p>The N-length vector of pointwise log-likelihoods, which is used to calculate WAIC.</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
<dt>esf</dt><dd><p>The N-length eigenvector spatial filter.</p>
</dd>
<dt>beta_ev</dt><dd><p>The vector of coefficients for the eigenvectors.</p>
</dd>
</dl>

<p>If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="rstan.html#topic+sampling">sampling</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eigenvector spatial filtering (ESF) is a method for spatial regression analysis. ESF is extensively covered in Griffith et al. (2019). This function implements the methodology introduced in Donegan et al. (2020), which uses Piironen and Vehtari's (2017) regularized horseshoe prior.
</p>
<p>ESF decomposes spatial autocorrelation into a linear combination of various patterns, typically at different scales (such as local, regional, and global trends). By adding a spatial filter to a regression model, these spatial autocorrelation patterns are shifted from the residuals to the spatial filter. ESF models take the spectral decomposition of a transformed spatial connectivity matrix, <code class="reqn">C</code>. The resulting eigenvectors, <code class="reqn">E</code>, are mutually orthogonal and uncorrelated map patterns. The spatial filter equals <code class="reqn">E \beta_{E}</code> where <code class="reqn">\beta_{E}</code> is a vector of coefficients.
</p>
<p>ESF decomposes the data into a global mean, <code class="reqn">\alpha</code>, global patterns contributed by covariates <code class="reqn">X \beta</code>, spatial trends <code class="reqn">E \beta_{E}</code>, and residual variation. Thus, for <code>family=gaussian()</code>,
</p>
<p style="text-align: center;"><code class="reqn">
y \sim Gauss(\alpha + X * \beta + E \beta_{E}, \sigma).
</code>
</p>

<p>An ESF component can be incorporated into the linear predictor of any generalized linear model. For example, a spatial Poisson model for rare disease incidence may be specified as follows:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \mu})</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = \alpha + E \beta_{E} + A </code>
</p>

<p style="text-align: center;"><code class="reqn"> A \sim Guass(0, \tau) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau \sim student(20, 0, 2) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \beta_{E} \sim horseshoe(.) </code>
</p>

<p>The form of this model is similar to the BYM model (see <a href="#topic+stan_icar">stan_icar</a>), in the sense that it contains a spatially structured trend term (<code class="reqn">E \beta_{E}</code>) and an unstructured ('random effects') term (<code class="reqn">A</code>).
</p>
<p>The <a href="#topic+spatial.geostan_fit">spatial.geostan_fit</a> method will return <code class="reqn">E \beta_{E}</code>.
</p>
<p>The model can also be extended to the space-time domain; see <a href="#topic+shape2mat">shape2mat</a> to specify a space-time connectivity matrix.
</p>
<p>The coefficients <code class="reqn">\beta_{E}</code> are assigned the regularized horseshoe prior (Piironen and Vehtari, 2017), resulting in a relatively sparse model specification. In addition, numerous eigenvectors are automatically dropped because they represent trace amounts of spatial autocorrelation (this is controlled by the <code>threshold</code> argument). By default, <code>stan_esf</code> will drop all eigenvectors representing negative spatial autocorrelation patterns. You can change this behavior using the <code>nsa</code> argument.
</p>


<h4>Additional functionality</h4>

<p>The CAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame</p>
</dd>
<dt>diagnostic</dt><dd><p>Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (<code>eff_pars</code>) and mean log pointwise predictive density (<code>lpd</code>), and mean residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>EV</dt><dd><p>A matrix of eigenvectors created with <code>w</code> and <code>geostan::make_EV</code></p>
</dd>
<dt>C</dt><dd><p>The spatial weights matrix used to construct EV</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including ESF component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>,  the random effects (varying intercepts) formula if provided, and
<code>data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>ME</dt><dd><p>The <code>ME</code> data list, if one was provided by the user for measurement error models.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial component parameter (&quot;esf&quot;) and method (&quot;ESF&quot;)</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Chun, Y., D. A. Griffith, M. Lee and P. Sinha (2016). Eigenvector selection with stepwise regression techniques to construct eigenvector spatial filters. <em>Journal of Geographical Systems</em>, 18(1), 67-85. <a href="https://doi.org/10.1007/s10109-015-0225-3">doi:10.1007/s10109-015-0225-3</a>.
</p>
<p>Dray, S., P. Legendre &amp; P. R. Peres-Neto (2006). Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM). <em>Ecological Modeling</em>, 196(3-4), 483-493.
</p>
<p>Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moran’s Eigenvectors and hierarchical shrinkage priors. <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a> (open access: <a href="https://doi.org/10.31219/osf.io/fah3z">doi:10.31219/osf.io/fah3z</a>).
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Griffith, Daniel A., and P. R. Peres-Neto (2006). Spatial modeling in ecology: the flexibility of eigenfunction spatial analyses. <em>Ecology</em> 87(10), 2603-2613.
</p>
<p>Griffith, D., and Y. Chun (2014). Spatial autocorrelation and spatial filtering, Handbook of Regional Science. Fischer, MM and Nijkamp, P. eds.
</p>
<p>Griffith, D., Chun, Y. and Li, B. (2019). <em>Spatial Regression Analysis Using Eigenvector Spatial Filtering</em>. Elsevier.
</p>
<p>Piironen, J and A. Vehtari (2017). Sparsity information and regularization in the horseshoe and other shrinkage priors. In <em>Electronic Journal of Statistics</em>, 11(2):5018-5051.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sentencing)
# spatial weights matrix with binary coding scheme
C &lt;- shape2mat(sentencing, style = "B")

# log-expected number of sentences
## expected counts are based on county racial composition and mean sentencing rates
log_e &lt;- log(sentencing$expected_sents)

# fit spatial Poisson model with ESF + unstructured 'random effects'
fit.esf &lt;- stan_esf(sents ~ offset(log_e),
                   re = ~ name,
                   family = poisson(),
                   data = sentencing,
                   C = C,
                   chains = 2, iter = 800) # for speed only

# spatial diagnostics 
sp_diag(fit.esf, sentencing)
plot(fit.esf)

# plot marginal posterior distributions of beta_ev (eigenvector coefficients)
plot(fit.esf, pars = "beta_ev")

# plot the marginal posterior distributions of the spatial filter 
plot(fit.esf, pars = "esf")

# calculate log-standardized incidence ratios 
library(ggplot2)
library(sf)
f &lt;- fitted(fit.esf, rates = FALSE)$mean
SSR &lt;-  f / sentencing$expected_sents
log.SSR &lt;- log( SSR, base = 2 )

# map the log-SSRs
 ggplot(sentencing) +
   geom_sf(aes(fill = log.SSR)) +
   scale_fill_gradient2(
    midpoint = 0,
    name = NULL,
    breaks = seq(-3, 3, by = 0.5)
  ) +
   labs(title = "Log-Standardized Sentencing Ratios",
    subtitle = "log( Fitted/Expected ), base 2"
 ) +
   theme_void()

</code></pre>

<hr>
<h2 id='stan_glm'>Generalized linear models</h2><span id='topic+stan_glm'></span>

<h3>Description</h3>

<p>Fit a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_glm(
  formula,
  slx,
  re,
  data,
  C,
  family = gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  censor_point,
  chains = 4,
  iter = 2000,
  refresh = 1000,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_glm_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <a href="stats.html#topic+formula">formula</a> syntax. Binomial models are specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div></td></tr>
<tr><td><code id="stan_glm_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_c">C</code></td>
<td>
<p>Optional spatial connectivity matrix which will be used to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms; it will automatically be row-standardized before calculating <code>slx</code> terms.  See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>poisson(link = "log")</code>, <code>binomial(link = "logit")</code>, <code>student_t()</code>, and the default <code>gaussian()</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sigma</dt><dd><p>For <code>family = gaussian()</code> and <code>family = student_t()</code> models, the scale parameter, <code>sigma</code>, is assigned a (half-) Student's t prior distribution. The half-Student's t prior for <code>sigma</code> is constrained to be positive.</p>
</dd>
<dt>nu</dt><dd><p><code>nu</code> is the degrees of freedom parameter in the Student's t likelihood (only used when <code>family = student_t()</code>). <code>nu</code> is assigned a gamma prior distribution. The default prior is <code>prior = list(nu = gamma2(alpha = 3, beta = 0.2))</code>.
</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for random effects, or varying intercepts, terms. This scale parameter, <code>tau</code>, is assigned a half-Student's t prior. To set this, use, e.g., <code>prior = list(tau = student_t(df = 20, location = 0, scale = 20))</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_glm_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_only">prior_only</code></td>
<td>
<p>Draw samples from the prior distributions of parameters only.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths. For example, the US Centers for Disease Control and Prevention censors (does not report) death counts that are nine or fewer, so if you're using CDC WONDER mortality data you could provide <code>censor_point = 9</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to estimate.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples; set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is required if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from GLM models:
</p>

<dl>
<dt>'fitted'</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>'log_lik'</dt><dd><p>The N-length vector of pointwise log-likelihoods, which is used to calculate WAIC.</p>
</dd>
<dt>'alpha_re'</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>'x_true'</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
</dl>

<p>Using <code>drop = c('fitted', 'log_lik', 'alpha_re', 'x_true')</code> is equivalent to <code>slim = TRUE</code>. If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_pars">pars</code></td>
<td>
<p>Specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="rstan.html#topic+sampling">sampling</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a generalized linear model using the R formula interface. Default prior distributions are designed to be weakly informative relative to the data. Much of the functionality intended for spatial models, such as the ability to add spatially lagged covariates and observational error models, are also available in <code>stan_glm</code>. All of <code>geostan</code>'s spatial models build on top of the same Stan code used in <code>stan_glm</code>.
</p>


<h4>Poisson models and disease mapping</h4>

<p>In spatial statistics, Poisson models are often used to calculate incidence rates (mortality rates, or disease incidence rates) for administrative areas like counties or census tracts. If <code class="reqn">y</code> are counts of cases, and <code class="reqn">P</code> are populations at risk, then the crude rates are <code class="reqn">y/P</code>. The purpose is to model risk <code class="reqn">\eta</code> for which crude rates are a (noisy) indicator. Our analysis should also respect the fact that the amount of information contained in the observations <code class="reqn">y/P</code> increases with <code class="reqn">P</code>. Hierarchical Poisson models are often used to incorporate all of this information.
</p>
<p>For the Poisson model, <code class="reqn">y</code> is specified as the outcome and the log of the population at risk <code>log(P)</code> needs to be provided as an offset term. For such a case, disease incidence across the collection of areas could be modeled as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{log(P) + \eta})</code>
</p>

<p style="text-align: center;"><code class="reqn"> \eta = \alpha + A</code>
</p>

<p style="text-align: center;"><code class="reqn"> A \sim Gauss(0, \tau)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau \sim Student(20, 0, 2)</code>
</p>

<p>where <code class="reqn">\alpha</code> is the mean log-risk (incidence rate) and <code class="reqn">A</code> is a vector of (so-called) random effects, which enable partial pooling of information across observations. Covariates can be added to the model for the log-rates, such that <code class="reqn">\eta = \alpha + X \beta + A</code>.
</p>
<p>Note that the denominator for the rates is specified as a log-offset to provide a consistent, formula-line interface to the model. Using the log-offest (as above) is equivalent to the following:
</p>
<p style="text-align: center;"><code class="reqn">
y \sim Poisson(P * e^{\eta})
</code>
</p>

<p>where <code class="reqn">P</code> is still the population at risk and it is multiplied by <code class="reqn">e^{\eta}</code>, the incidence rate (risk).
</p>



<h4>Spatially lagged covariates (SLX)</h4>

<p>The <code>slx</code> argument is a convenience function for including SLX terms. For example,
</p>
<p style="text-align: center;"><code class="reqn">
 y = W X \gamma + X \beta + \epsilon
</code>
</p>

<p>where <code class="reqn">W</code> is a row-standardized spatial weights matrix (see <code><a href="#topic+shape2mat">shape2mat</a></code>), <code class="reqn">WX</code> is the mean neighboring value of <code class="reqn">X</code>, and <code class="reqn">\gamma</code> is a coefficient vector. This specifies a regression with spatially lagged covariates. SLX terms can specified by providing a formula to the <code>slx</code> argument:
</p>
<div class="sourceCode"><pre>stan_glm(y ~ x1 + x2, slx = ~ x1 + x2, \...),
</pre></div>
<p>which is a shortcut for
</p>
<div class="sourceCode"><pre>stan_glm(y ~ I(W \%*\% x1) + I(W \%*\% x2) + x1 + x2, \...)
</pre></div>
<p>SLX terms will always be <em>prepended</em> to the design matrix, as above, which is important to know when setting prior distributions for regression coefficients.
</p>
<p>For measurement error (ME) models, the SLX argument is the only way to include spatially lagged covariates since the SLX term needs to be re-calculated on each iteration of the MCMC algorithm.
</p>



<h4>Measurement error (ME) models</h4>

<p>The ME models are designed for surveys with spatial sampling designs, such as the American Community Survey (ACS) estimates. For a tutorial, see <code>vignette("spatial-me-models", package = "geostan")</code>.
</p>
<p>Given estimates <code class="reqn">x</code>, their standard errors <code class="reqn">s</code>, and the target quantity of interest (i.e., the unknown true value) <code class="reqn">z</code>, the ME models have one of the the following two specifications, depending on the user input. If a spatial CAR model is specified, then:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">z \sim Gauss(\mu_z, \Sigma_z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_z = (I - \rho C)^{-1} M</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_z \sim Gauss(0, 100)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_z \sim Student(10, 0, 40), \tau &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\rho_z \sim uniform(l, u)</code>
</p>

<p>where <code class="reqn">\Sigma</code> specifies the covariance matrix of a spatial conditional autoregressive (CAR) model with scale parameter <code class="reqn">\tau</code> (on the diagonal of <code class="reqn">M</code>), autocorrelation parameter <code class="reqn">\rho</code>, and <code class="reqn">l</code>, <code class="reqn">u</code> are the lower and upper bounds that <code class="reqn">\rho</code> is permitted to take (which is determined by the extreme eigenvalues of the spatial connectivity matrix <code class="reqn">C</code>). <code class="reqn">M</code> contains the inverse of the row sums of <code class="reqn">C</code> on its diagonal multiplied by <code class="reqn">\tau</code> (following the &quot;WCAR&quot; specification).
</p>
<p>For non-spatial ME models, the following is used instead:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">z \sim student_t(\nu_z, \mu_z, \sigma_z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu_z \sim gamma(3, 0.2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_z \sim Gauss(0, 100)</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_z \sim student(10, 0, 40)</code>
</p>

<p>For strongly skewed variables, such as census tract poverty rates, it can be advantageous to apply a logit transformation to <code class="reqn">z</code> before applying the CAR or Student-t prior model. When the <code>logit</code> argument is used, the first two lines of the model specification become:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(z) \sim Gauss(\mu_z, \Sigma_z) </code>
</p>

<p>and similarly for the Student t model:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(z) \sim student(\nu_z, \mu_z, \sigma_z)</code>
</p>




<h4>Censored counts</h4>

<p>Vital statistics systems and disease surveillance programs typically suppress case counts when they are smaller than a specific threshold value. In such cases, the observation of a censored count is not the same as a missing value; instead, you are informed that the value is an integer somewhere between zero and the threshold value. For Poisson models (<code style="white-space: pre;">&#8288;family = poisson())&#8288;</code>), you can use the <code>censor_point</code> argument to encode this information into your model.
</p>
<p>Internally, <code>geostan</code> will keep the index values of each censored observation, and the index value of each of the fully observed outcome values. For all observed counts, the likelihood statement will be:
</p>
<p style="text-align: center;"><code class="reqn">
p(y_i | data, model) = poisson(y_i | \mu_i), 
</code>
</p>

<p>as usual, where <code class="reqn">\mu_i</code> may include whatever spatial terms are present in the model.
</p>
<p>For each censored count, the likelihood statement will equal the cumulative Poisson distribution function for values zero through the censor point:
</p>
<p style="text-align: center;"><code class="reqn">
p(y_i | data, model) = \sum_{m=0}^{M} Poisson( m | \mu_i),
</code>
</p>

<p>where <code class="reqn">M</code> is the censor point and <code class="reqn">\mu_i</code> again is the fitted value for the <code class="reqn">i^{th}</code> observation.
</p>
<p>For example, the US Centers for Disease Control and Prevention's CDC WONDER database censors all death counts between 0 and 9. To model CDC WONDER mortality data, you could provide <code>censor_point = 9</code> and then the likelihood statement for censored counts would equal the summation of the Poisson probability mass function over each integer ranging from zero through 9 (inclusive), conditional on the fitted values (i.e., all model parameters). See Donegan (2021) for additional discussion, references, and Stan code.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame</p>
</dd>
<dt>diagnostic</dt><dd><p>Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (<code>eff_pars</code>) and mean log pointwise predictive density (<code>lpd</code>), and mean residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including ESF component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>C</dt><dd><p>The spatial weights matrix, if one was provided by the user.</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>, the random effects (varying intercepts) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>ME</dt><dd><p>The <code>ME</code> data list, if one was provided by the user for measurement error models.</p>
</dd>
<dt>spatial</dt><dd><p>NA, slot is maintained for use in <code>geostan_fit</code> methods.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)

sentencing$log_e &lt;- log(sentencing$expected_sents)
fit.pois &lt;- stan_glm(sents ~ offset(log_e),
                     re = ~ name,
                     family = poisson(),
                     data = sentencing,
                    chains = 2, iter = 800) # for speed only

# MCMC diagnostics plot: Rhat values should all by very near 1
rstan::stan_rhat(fit.pois$stanfit)

# effective sample size for all parameters and generated quantities
# (including residuals, predicted values, etc.)
rstan::stan_ess(fit.pois$stanfit)

# or for a particular parameter
rstan::stan_ess(fit.pois$stanfit, "alpha_re")

# Spatial autocorrelation/residual diagnostics
sp_diag(fit.pois, sentencing)

## Posterior predictive distribution                                       
yrep &lt;- posterior_predict(fit.pois, S = 65)
y &lt;- sentencing$sents
plot(density(yrep[1,]))
for (i in 2:nrow(yrep)) lines(density(yrep[i,]), col = "gray30")
lines(density(sentencing$sents), col = "darkred", lwd = 2)
</code></pre>

<hr>
<h2 id='stan_icar'>Intrinsic autoregressive models</h2><span id='topic+stan_icar'></span>

<h3>Description</h3>

<p>The intrinsic conditional auto-regressive (ICAR) model for spatial count data. Options include the BYM model, the BYM2 model, and a solo ICAR term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_icar(
  formula,
  slx,
  re,
  data,
  C,
  family = poisson(),
  type = c("icar", "bym", "bym2"),
  scale_factor = NULL,
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  censor_point,
  prior_only = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_icar_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <a href="stats.html#topic+formula">formula</a> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div>
<p>Before using this term, read the <code>Details</code> section and the <code>type</code> argument. Specifically, if you use <code>type = bym</code>, then an observational-level <code>re</code> term is already included in the model. (Similar for <code>type = bym2</code>.)</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix which will be used to construct an edge list for the ICAR model, and to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms. It will automatically be row-standardized before calculating <code>slx</code> terms. <code>C</code> must be a binary symmetric <code>n x n</code> matrix.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>binomial(link = "logit")</code> and <code>poisson(link = "log")</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_type">type</code></td>
<td>
<p>Defaults to &quot;icar&quot; (partial pooling of neighboring observations through parameter <code>phi</code>); specify &quot;bym&quot; to add a second parameter vector <code>theta</code> to perform partial pooling across all observations; specify &quot;bym2&quot; for the innovation introduced by Riebler et al. (2016). See <code>Details</code> for more information.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_scale_factor">scale_factor</code></td>
<td>
<p>For the BYM2 model, optional. If missing, this will be set to a vector of ones. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sigma</dt><dd><p>For <code>family = gaussian()</code> and <code>family = student_t()</code> models, the scale parameter, <code>sigma</code>, is assigned a (half-) Student's t prior distribution. The half-Student's t prior for <code>sigma</code> is constrained to be positive.</p>
</dd>
<dt>nu</dt><dd><p><code>nu</code> is the degrees of freedom parameter in the Student's t likelihood (only used when <code>family = student_t()</code>). <code>nu</code> is assigned a gamma prior distribution. The default prior is <code>prior = list(nu = gamma2(alpha = 3, beta = 0.2))</code>.
</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for random effects, or varying intercepts, terms. This scale parameter, <code>tau</code>, is assigned a half-Student's t prior. To set this, use, e.g., <code>prior = list(tau = student_t(df = 20, location = 0, scale = 20))</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_icar_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths. For example, the US Centers for Disease Control and Prevention censors (does not report) death counts that are nine or fewer, so if you're using CDC WONDER mortality data you could provide <code>censor_point = 9</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_prior_only">prior_only</code></td>
<td>
<p>Draw samples from the prior distributions of parameters only.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to estimate.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain. .</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples; set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from ICAR models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>log_lik</dt><dd><p>The N-length vector of pointwise log-likelihoods, which is used to calculate WAIC.</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
<dt>phi</dt><dd><p>The N-length vector of spatially-autocorrelated parameters (with the ICAR prior).</p>
</dd>
<dt>theta</dt><dd><p>The N-length vector of spatially unstructured parameters ('random effects'), for the BYM and BYM2 models.</p>
</dd>
</dl>

<p>If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <code><a href="rstan.html#topic+stan">stan</a></code> for details.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="rstan.html#topic+sampling">sampling</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intrinsic conditional autoregressive (ICAR) model for spatial data was introduced by Besag et al. (1991). The Stan code for the ICAR component of the model and the BYM2 option is from Morris et al. (2019) with adjustments to enable non-binary weights and disconnected graph structures (see Freni-Sterrantino (2018) and Donegan (2021)).
</p>
<p>The exact specification depends on the <code>type</code> argument.
</p>


<h4>ICAR</h4>

<p>For Poisson models for count data, y, the basic model specification (<code>type = "icar"</code>) is:
</p>
<p style="text-align: center;"><code class="reqn">y ~ Poisson(e^{O + \mu + \phi}) </code>
</p>

<p style="text-align: center;"><code class="reqn">\phi \sim ICAR(\tau_s) </code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_s \sim Gauss(0, 1)</code>
</p>

<p>where <code class="reqn">\mu</code> contains an intercept and potentially covariates. The spatial trend <code class="reqn">phi</code> has a mean of zero and a single scale parameter <code class="reqn">\tau_s</code> (which user's will see printed as the parameter named <code>spatial_scale</code>).
</p>
<p>The ICAR prior model is a CAR model that has a spatial autocorrelation parameter <code class="reqn">\rho</code> equal to 1 (see <a href="#topic+stan_car">stan_car</a>). Thus the ICAR prior places high probability on a very smooth spatially (or temporally) varying mean. This is rarely sufficient to model the amount of variation present in social and health data. For this reason, the BYM model is typically employed.
</p>



<h4>BYM</h4>

<p>Often, an observational-level random effect term, <code>theta</code>, is added to capture (heterogeneous or unstructured) deviations from <code class="reqn">\mu + \phi</code>. The combined term is referred to as a convolution term:
</p>
<p><code class="reqn">
 convolution = \phi + \theta.
</code>
</p>
<p>This is known as the BYM model (Besag et al. 1991), and can be specified using <code>type = "bym"</code>:
</p>
<p><code class="reqn">y \sim Poisson(e^{O + \mu + \phi + \theta}) </code>
</p>
<p style="text-align: center;"><code class="reqn"> \phi \sim ICAR(\tau_s) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta \sim Gaussian(0, \tau_{ns}) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau_s \sim Gaussian(0, 1) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau_{ns} \sim Gaussian(0, 1) </code>
</p>

<p>The model is named after Besag, York, and Mollié (1991).
</p>



<h4>BYM2</h4>

<p>Riebler et al. (2016) introduce a variation on the BYM model (<code>type = "bym2"</code>). This specification combines <code class="reqn">\phi</code> and <code class="reqn">\theta</code> using a mixing parameter <code class="reqn">\rho</code> that controls the proportion of the variation that is attributable to the spatially autocorrelated term <code class="reqn">\phi</code> rather than the spatially unstructured term <code class="reqn">\theta</code>. The terms share a single scale parameter <code class="reqn">\tau</code>:
</p>
<p style="text-align: center;"><code class="reqn">convolution = [sqrt(\rho * S) * \tilde{\phi} + sqrt(1 - \rho)  \tilde{\theta}] * \tau
</code>
</p>

<p style="text-align: center;"><code class="reqn"> \tilde{\phi} \sim Gaussian(0, 1) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tilde{\theta} \sim Gaussian(0, 1) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau \sim Gaussian(0, 1) </code>
</p>

<p>The terms <code class="reqn">\tilde{\phi}</code>, <code class="reqn">\tilde{\theta}</code> are standard normal deviates, <code class="reqn">\rho</code> is restricted to values between zero and one, and <code class="reqn">S</code> is the 'scale_factor' (a constant term provided by the user). By default, the 'scale_factor' is equal to one, so that it does nothing. Riebler et al. (2016) argue that the interpretation or meaning of the scale of the ICAR model depends on the graph structure of the connectivity matrix <code class="reqn">C</code>. This implies that the same prior distribution assigned to <code class="reqn">\tau_s</code> will differ in its implications if <code class="reqn">C</code> is changed; in other words, the priors are not transportable across models, and models that use the same nominal prior actually have different priors assigned to <code class="reqn">\tau_s</code>.
</p>
<p>Borrowing <code>R</code> code from Morris (2017) and following Freni-Sterrantino et al. (2018), the following <code>R</code> code can be used to create the 'scale_factor' <code class="reqn">S</code> for the BYM2 model (note, this requires the INLA R package), given a spatial adjacency matrix, <code class="reqn">C</code>:
</p>
<div class="sourceCode"><pre>## create a list of data for stan_icar
icar.data &lt;- geostan::prep_icar_data(C)
## calculate scale_factor for each of k connected group of nodes
k &lt;- icar.data$k
scale_factor &lt;- vector(mode = "numeric", length = k)
for (j in 1:k) {
  g.idx &lt;- which(icar.data$comp_id == j) 
  if (length(g.idx) == 1) {
       scale_factor[j] &lt;- 1
       next
    }    
  Cg &lt;- C[g.idx, g.idx] 
  scale_factor[j] &lt;- scale_c(Cg) 
}
</pre></div>
<p>This code adjusts for 'islands' or areas with zero neighbors, and it also handles disconnected graph structures (see Donegan and Morris 2021). Following Freni-Sterrantino (2018), disconnected components of the graph structure are given their own intercept term; however, this value is added to <code class="reqn">\phi</code> automatically inside the Stan model. Therefore, the user never needs to make any adjustments for this term. (To avoid complications from using a disconnected graph structure, you can apply a proper CAR model instead of the ICAR: <code><a href="#topic+stan_car">stan_car</a></code>).
</p>
<p>Note, the code above requires the <code>scale_c</code> function; it has package dependencies that are not included in <code>geostan</code>. To use <code>scale_c</code>, you have to load the following <code>R</code> function:
</p>
<div class="sourceCode"><pre>#' compute scaling factor for adjacency matrix, accounting for differences in spatial connectivity 
#'
#' @param C connectivity matrix
#'
#' @details
#'
#' Requires the following packages: 
#'
#' library(Matrix)
#' library(INLA);
#' library(spdep)
#' library(igraph)
#'  
#' @source
#'
#'   Morris, Mitzi (2017). Spatial Models in Stan: Intrinsic Auto-Regressive Models for Areal Data. &lt;https://mc-stan.org/users/documentation/case-studies/icar_stan.html&gt;
#'
scale_c &lt;- function(C) {
 geometric_mean &lt;- function(x) exp(mean(log(x))) 
 N = dim(C)[1]
 Q =  Diagonal(N, rowSums(C)) - C
 Q_pert = Q + Diagonal(N) * max(diag(Q)) * sqrt(.Machine$double.eps)
 Q_inv = inla.qinv(Q_pert, constr=list(A = matrix(1,1,N),e=0))
 scaling_factor &lt;- geometric_mean(Matrix::diag(Q_inv)) 
 return(scaling_factor) 
}
</pre></div>



<h4>Additional functionality</h4>

<p>The CAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame</p>
</dd>
<dt>diagnostic</dt><dd><p>Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (<code>eff_pars</code>) and mean log pointwise predictive density (<code>lpd</code>), and mean residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>edges</dt><dd><p>The edge list representing all unique sets of neighbors and the weight attached to each pair (i.e., their corresponding element in the connectivity matrix  C</p>
</dd>
<dt>C</dt><dd><p>Spatial connectivity matrix</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including ICAR component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list with two name elements, <code>formula</code> and <code>Data</code>, containing the formula <code>re</code> and a data frame with columns <code>id</code> (the grouping variable) and <code>idx</code> (the index values assigned to each group).</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial parameter (<code>"phi"</code> if <code>type = "icar"</code> else <code>"convolution"</code>) and method (<code>toupper(type)</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Besag, J. (1974). Spatial interaction and the statistical analysis of lattice systems. <em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, 36(2), 192-225.
</p>
<p>Besag, J., York, J., and Mollié, A. (1991). Bayesian image restoration, with two applications in spatial statistics. <em>Annals of the Institute of Statistical Mathematics</em>, 43(1), 1-20.
</p>
<p>Donegan, Connor and Morris, Mitzi (2021). Flexible functions for ICAR, BYM, and BYM2 models in Stan. Code repository. <a href="https://github.com/ConnorDonegan/Stan-IAR">https://github.com/ConnorDonegan/Stan-IAR</a>
</p>
<p>Donegan, Connor (2021b). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Freni-Sterrantino, Anna, Massimo Ventrucci, and Håvard Rue (2018). A Note on Intrinsic Conditional Autoregressive Models for Disconnected Graphs. <em>Spatial and Spatio-Temporal Epidemiology</em>, 26: 25–34.
</p>
<p>Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., &amp; DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan. <em>Spatial and spatio-temporal epidemiology</em>, 31, 100301.
</p>
<p>Riebler, A., Sorbye, S. H., Simpson, D., &amp; Rue, H. (2016). An intuitive Bayesian spatial model for disease mapping that accounts for scaling. <em>Statistical Methods in Medical Research</em>, 25(4), 1145-1165.
</p>


<h3>See Also</h3>

<p><a href="#topic+shape2mat">shape2mat</a>, <a href="#topic+stan_car">stan_car</a>, <a href="#topic+stan_esf">stan_esf</a>, <a href="#topic+stan_glm">stan_glm</a>, <a href="#topic+prep_icar_data">prep_icar_data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sentencing)
C &lt;- shape2mat(sentencing, "B")
log_e &lt;- log(sentencing$expected_sents)
fit.bym &lt;- stan_icar(sents ~ offset(log_e),
                     family = poisson(),
                     data = sentencing,
                     type = "bym",
                     C = C,
                     chains = 2, iter = 800) # for speed only

# spatial diagnostics
sp_diag(fit.bym, sentencing)
                                       
# check effective sample size and convergence
library(rstan)
rstan::stan_ess(fit.bym$stanfit)
rstan::stan_rhat(fit.bym$stanfit)

# calculate log-standardized incidence ratios 
# (observed/exected case counts)
library(ggplot2)
library(sf)

f &lt;- fitted(fit.bym, rates = FALSE)$mean
SSR &lt;- f / sentencing$expected_sents
log.SSR &lt;- log( SSR, base = 2)

ggplot(sentencing) +
  geom_sf(aes(fill = log.SSR)) +
  scale_fill_gradient2(
   low = "navy",
   high = "darkred"
  ) +
  labs(title = "Log-standardized sentencing ratios",
       subtitle = "log( Fitted/Expected), base 2") +
  theme_void() +
  theme(
   legend.position = "bottom",
   legend.key.height = unit(0.35, "cm"),
   legend.key.width = unit(1.5, "cm")
  )

</code></pre>

<hr>
<h2 id='stan_sar'>Simultaneous autoregressive (SAR) models</h2><span id='topic+stan_sar'></span>

<h3>Description</h3>

<p>Fit data to an spatial Gaussian SAR (spatial error) model, or model a vector of spatially-autocorrelated parameters using a SAR prior model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_sar(
  formula,
  slx,
  re,
  data,
  C,
  sar_parts = prep_sar_data(C),
  family = auto_gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  censor_point,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  pars = NULL,
  slim = FALSE,
  drop = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_sar_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <code><a href="stats.html#topic+formula">formula</a></code> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div>
<p>With the SAR model, any <code>alpha_re</code> term should be at a <em>different</em> level or scale than the observations; that is, at a different scale than the autocorrelation structure of the SAR model itself.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_c">C</code></td>
<td>
<p>Spatial weights matrix (conventionally referred to as <code class="reqn">W</code> in the SAR model). Typically, this will be created using <code>geostan::shape2mat(shape, style = "W")</code>. This will be passed internally to <code><a href="#topic+prep_sar_data">prep_sar_data</a></code>, and will also be used to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms; it will automatically be row-standardized before calculating <code>slx</code> terms. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_sar_parts">sar_parts</code></td>
<td>
<p>Optional. If not provided, then <code><a href="#topic+prep_sar_data">prep_sar_data</a></code> will be used automatically to create <code>sar_parts</code> using the user-provided spatial weights matrix.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>auto_gaussian()</code>, <code>binomial(link = "logit")</code>, and <code>poisson(link = "log")</code>; if <code>family = gaussian()</code> is provided, it will automatically be converted to <code>auto_gaussian()</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sar_scale</dt><dd><p>Scale parameter for the SAR model, <code>sar_scale</code>. The scale is assigned a Student's t prior model (constrained to be positive).</p>
</dd>
<dt>sar_rho</dt><dd><p>The spatial autocorrelation parameter in the SAR model, <code>rho</code>, is assigned a uniform prior distribution. By default, the prior will be uniform over all permissible values as determined by the eigenvalues of the spatial weights matrix. The range of permissible values for <code>rho</code> is printed to the console by <code><a href="#topic+prep_sar_data">prep_sar_data</a></code>.</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for any varying intercepts (a.k.a exchangeable random effects, or partial pooling) terms. This scale parameter, <code>tau</code>, is assigned a Student's t prior (constrained to be positive).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_sar_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_prior_only">prior_only</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, draw samples only from the prior distributions of parameters.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to use.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from SAR models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>log_lik</dt><dd><p>The N-length vector of pointwise log-likelihoods, which is used to calculate WAIC.</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>log_lambda_mu</dt><dd><p>Linear predictor inside the SAR model (for Poisson and binomial models)</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
</dl>

<p>Using <code>drop = c('fitted', 'log_lik', 'alpha_re', 'x_true')</code> is equivalent to <code>slim = TRUE</code>. Note that if <code>slim = TRUE</code>, then <code>drop</code> will be ignored&mdash;so only use one or the other.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <code><a href="rstan.html#topic+stan">stan</a></code> for details.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discussions of SAR models may be found in Cliff and Ord (1981), Cressie (2015, Ch. 6), LeSage and Pace (2009), and LeSage (2014). The Stan implementation draws from Donegan (2021).
</p>
<p>The general scheme of the SAR model for numeric vector <code class="reqn">y</code> is
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + ( I - \rho W)^{-1} \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon \sim Gauss(0, \sigma^2 I)</code>
</p>

<p>where <code class="reqn">W</code> is the spatial weights matrix, <code class="reqn">I</code> is the n-by-n identity matrix, and <code class="reqn">\rho</code> is a spatial autocorrelation parameter. In words, the errors of the regression equation are spatially autocorrelated.
</p>
<p>Re-arranging terms, the model can also be written as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \rho W (y - \mu)  + \epsilon</code>
</p>

<p>which perhaps shows more intuitively the implicit spatial trend component, <code class="reqn">\rho W (y - \mu)</code>.
</p>
<p>Most often, this model is applied directly to observations (referred to below as the auto-Gaussian model). The SAR model can also be applied to a vector of parameters inside a hierarchical model. The latter enables spatial autocorrelation to be modeled when the observations are discrete counts (e.g., disease incidence data).
</p>
<p>A note on terminology: the spatial statistics literature conceptualizes the simultaneously-specified spatial autoregressive model (SAR) in relation to the conditionally-specified spatial autoregressive model (CAR) (see <a href="#topic+stan_car">stan_car</a>) (see Cliff and Ord 1981). The spatial econometrics literature, by contrast, refers to the simultaneously-specified spatial autoregressive (SAR) model as the spatial error model (SEM), and they contrast the SEM with the spatial lag model (which contains a spatially-lagged dependent variable on the right-hand-side of the regression equation) (see LeSage 2014).
</p>


<h4>Auto-Gaussian</h4>

<p>When <code>family = auto_gaussian()</code>, the SAR model is specified as follows:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Gauss(\mu, \Sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \sigma^2 (I - \rho W)^{-1}(I - \rho W')^{-1}</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean vector (with intercept, covariates, etc.), <code class="reqn">W</code> is a spatial weights matrix (usually row-standardized), and <code class="reqn">\sigma</code> is a scale parameter.
</p>
<p>The SAR model contains an implicit spatial trend (i.e., spatial autocorrelation) component <code class="reqn">\phi</code> which is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
\phi = \rho W (y - \mu)
</code>
</p>

<p>This term can be extracted from a fitted auto-Gaussian model using the <a href="#topic+spatial">spatial</a> method.
</p>
<p>When applied to a fitted auto-Gaussian model, the <a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a> method returns 'de-trended' residuals <code class="reqn">R</code> by default. That is,
</p>
<p style="text-align: center;"><code class="reqn">
R = y - \mu - \rho W (y - \mu).
</code>
</p>

<p>To obtain &quot;raw&quot; residuals (<code class="reqn">y - \mu</code>), use <code>residuals(fit, detrend = FALSE)</code>. Similarly, the fitted values obtained from the <a href="#topic+fitted.geostan_fit">fitted.geostan_fit</a> will include the spatial trend term by default.
</p>



<h4>Poisson</h4>

<p>For <code>family = poisson()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \lambda})</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda \sim Gauss(\mu, \Sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \sigma^2 (I - \rho W)^{-1}(I - \rho W')^{-1}.</code>
</p>

<p>If the raw outcome consists of a rate <code class="reqn">\frac{y}{p}</code> with observed counts <code class="reqn">y</code> and denominator <code class="reqn">p</code> (often this will be the size of the population at risk), then the offset term <code class="reqn">O=log(p)</code> is the log of the denominator.
</p>
<p>This is often written (equivalently) as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \mu + \phi})</code>
</p>

<p style="text-align: center;"><code class="reqn"> \phi \sim Gauss(0, \Sigma) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \Sigma = \sigma^2 (I - \rho W)^{-1}(I - \rho W')^{-1}.</code>
</p>

<p>For Poisson models, the <a href="#topic+spatial">spatial</a> method returns the parameter vector <code class="reqn">\phi</code>.
</p>
<p>In the Poisson SAR model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it. If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating:
</p>
<p style="text-align: center;"><code class="reqn">
 \rho W \phi.
</code>
</p>




<h4>Binomial</h4>

<p>For <code>family = binomial()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Binomial(N, \lambda) </code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\lambda) \sim Gauss(\mu, \Sigma) </code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \sigma^2 (I - \rho W)^{-1}(I - \rho W')^{-1}.</code>
</p>

<p>where outcome data <code class="reqn">y</code> are counts, <code class="reqn">N</code> is the number of trials, and <code class="reqn">\lambda</code> is the rate of 'success'. Note that the model formula should be structured as: <code>cbind(sucesses, failures) ~ 1</code> (for an intercept-only model), such that <code>trials = successes + failures</code>.
</p>
<p>For fitted Binomial models, the <code><a href="#topic+spatial">spatial</a></code> method will return the parameter vector <code>phi</code>, equivalent to:
</p>
<p style="text-align: center;"><code class="reqn">\phi = logit(\lambda) - \mu.</code>
</p>

<p>As is also the case for the Poisson model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it. If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating:
</p>
<p style="text-align: center;"><code class="reqn">
\rho W \phi.
</code>
</p>




<h4>Additional functionality</h4>

<p>The SAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame.</p>
</dd>
<dt>diagnostic</dt><dd><p>Widely Applicable Information Criteria (WAIC) with a measure of effective number of parameters (<code>eff_pars</code>) and mean log pointwise predictive density (<code>lpd</code>), and mean residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including CAR component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>, the varying intercepts (<code>re</code>) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial component parameter (either &quot;phi&quot; or, for auto Gaussian models, &quot;trend&quot;) and method (&quot;SAR&quot;)</p>
</dd>
<dt>ME</dt><dd><p>A list indicating if the object contains an ME model; if so, the user-provided ME list is also stored here.</p>
</dd>
<dt>C</dt><dd><p>Spatial weights matrix (in sparse matrix format).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Cliff, A D and Ord, J K (1981). <em>Spatial Processes: Models and Applications</em>. Pion.
</p>
<p>Cressie, Noel (2015 (1993)). <em>Statistics for Spatial Data</em>. Wiley Classics, Revised Edition.
</p>
<p>Cressie, Noel and Wikle, Christopher (2011). <em>Statistics for Spatio-Temporal Data</em>. Wiley.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>LeSage, James (2014). What Regional Scientists Need to Know about Spatial Econometrics. <em>The Review of Regional Science</em> 44: 13-32 (2014 Southern Regional Science Association Fellows Address).
</p>
<p>LeSage, James, &amp; Pace, Robert Kelley (2009). <em>Introduction to Spatial Econometrics</em>. Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># model mortality risk
data(georgia)
W &lt;- shape2mat(georgia, style = "W")

fit &lt;- stan_sar(log(rate.male) ~ 1,
                C = W,
                data = georgia,
                chains = 1, # for ex. speed only
                iter = 700 
                )

rstan::stan_rhat(fit$stanfit)
rstan::stan_mcse(fit$stanfit)
print(fit)
plot(fit)
sp_diag(fit, georgia)


 # a more appropriate model for count data:
fit2 &lt;- stan_sar(deaths.male ~ offset(log(pop.at.risk.male)),
                C = W,
                data = georgia,
                family = poisson(),
                chains = 1, # for ex. speed only
                iter = 700 
                 )
sp_diag(fit2, georgia)

</code></pre>

<hr>
<h2 id='waic'>Widely Applicable Information Criteria (WAIC)</h2><span id='topic+waic'></span>

<h3>Description</h3>

<p>Widely Application Information Criteria (WAIC) for model comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waic(fit, pointwise = FALSE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waic_+3A_fit">fit</code></td>
<td>
<p>An <code>geostan_fit</code> object or any Stan model with a parameter named &quot;log_lik&quot;, the pointwise log likelihood of the observations.</p>
</td></tr>
<tr><td><code id="waic_+3A_pointwise">pointwise</code></td>
<td>
<p>Logical (defaults to <code>FALSE</code>), should a vector of values for each observation be returned?</p>
</td></tr>
<tr><td><code id="waic_+3A_digits">digits</code></td>
<td>
<p>Round results to this many digits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 3 with <code>WAIC</code>, a rough measure of the effective number of parameters estimated by the model <code>Eff_pars</code>, and log predictive density <code>Lpd</code>. If <code>pointwise = TRUE</code>, results are returned in a <code>data.frame</code>.
</p>


<h3>Source</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely application information criterion in singular learning theory. Journal of Machine Learning Research 11, 3571-3594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
fit &lt;- stan_glm(log(rate.male) ~ 1, data = georgia,
                chains = 2, iter = 800) # for speed only
waic(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
