<!DOCTYPE html><html lang="en"><head><title>Help for package geostan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geostan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geostan-package'><p>The geostan R package.</p></a></li>
<li><a href='#aple'><p>Spatial autocorrelation estimator</p></a></li>
<li><a href='#as.matrix.geostan_fit'><p>Extract samples from a fitted model</p></a></li>
<li><a href='#auto_gaussian'><p>Auto-Gaussian family for CAR models</p></a></li>
<li><a href='#edges'><p>Edge list</p></a></li>
<li><a href='#eigen_grid'><p>Eigenvalues of a spatial weights matrix: for spatial regression with raster data</p></a></li>
<li><a href='#expected_mc'><p>Expected value of the residual Moran coefficient</p></a></li>
<li><a href='#georgia'><p>Georgia all-cause, sex-specific mortality, ages 55-64, years 2014-2018</p></a></li>
<li><a href='#get_shp'><p>Download shapefiles</p></a></li>
<li><a href='#gr'><p>The Geary Ratio</p></a></li>
<li><a href='#lg'><p>Local Geary</p></a></li>
<li><a href='#lisa'><p>Local Moran's I</p></a></li>
<li><a href='#log_lik'><p>Extract log-likelihood</p></a></li>
<li><a href='#make_EV'><p>Prepare data for spatial filtering</p></a></li>
<li><a href='#mc'><p>The Moran coefficient (Moran's I)</p></a></li>
<li><a href='#me_diag'><p>Measurement error model diagnostics</p></a></li>
<li><a href='#moran_plot'><p>Moran scatter plot</p></a></li>
<li><a href='#n_eff'><p>Effective sample size</p></a></li>
<li><a href='#n_nbs'><p>Count neighbors in a connectivity matrix</p></a></li>
<li><a href='#posterior_predict'><p>Sample from the posterior predictive distribution</p></a></li>
<li><a href='#predict.geostan_fit'><p>Predict method for <code>geostan_fit</code> models</p></a></li>
<li><a href='#prep_car_data'><p>Prepare data for the CAR model</p></a></li>
<li><a href='#prep_car_data2'><p>Prepare data for the CAR model: raster analysis</p></a></li>
<li><a href='#prep_icar_data'><p>Prepare data for ICAR models</p></a></li>
<li><a href='#prep_me_data'><p>Prepare data for spatial measurement error models</p></a></li>
<li><a href='#prep_sar_data'><p>Prepare data for a simultaneous autoregressive (SAR) model</p></a></li>
<li><a href='#prep_sar_data2'><p>Prepare data for SAR model: raster analysis</p></a></li>
<li><a href='#print.geostan_fit'><p>print or plot a fitted geostan model</p></a></li>
<li><a href='#priors'><p>Prior distributions</p></a></li>
<li><a href='#residuals.geostan_fit'><p>Extract residuals, fitted values, or the spatial trend</p></a></li>
<li><a href='#row_standardize'><p>Row-standardize a matrix; safe for zero row-sums.</p></a></li>
<li><a href='#se_log'><p>Standard error of log(x)</p></a></li>
<li><a href='#sentencing'><p>Florida state prison sentencing counts by county, 1905-1910</p></a></li>
<li><a href='#shape2mat'><p>Create spatial and space-time connectivity matrices</p></a></li>
<li><a href='#sim_sar'><p>Simulate spatially autocorrelated data</p></a></li>
<li><a href='#sp_diag'><p>Visual displays of spatial data and spatial models</p></a></li>
<li><a href='#spill'><p>Spillover/diffusion effects for spatial lag models</p></a></li>
<li><a href='#stan_car'><p>Conditional autoregressive (CAR) models</p></a></li>
<li><a href='#stan_esf'><p>Spatial filtering</p></a></li>
<li><a href='#stan_glm'><p>Generalized linear models</p></a></li>
<li><a href='#stan_icar'><p>Intrinsic autoregressive models</p></a></li>
<li><a href='#stan_sar'><p>Simultaneous autoregressive (SAR) models</p></a></li>
<li><a href='#waic'><p>Model comparison</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Spatial Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-04</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://connordonegan.github.io/geostan/">https://connordonegan.github.io/geostan/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ConnorDonegan/geostan/issues">https://github.com/ConnorDonegan/geostan/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>For spatial data analysis; provides exploratory spatial analysis tools, spatial regression, spatial econometric, and disease mapping models, model diagnostics, and special methods for inference with small area survey data (e.g., the America Community Survey (ACS)) and censored population health monitoring data. Models are pre-specified using the Stan programming language, a platform for Bayesian inference using Markov chain Monte Carlo (MCMC). References: Carpenter et al. (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i01">doi:10.18637/jss.v076.i01</a>&gt;; Donegan (2021) &lt;<a href="https://doi.org/10.31219%2Fosf.io%2F3ey65">doi:10.31219/osf.io/3ey65</a>&gt;; Donegan (2022) &lt;<a href="https://doi.org/10.21105%2Fjoss.04716">doi:10.21105/joss.04716</a>&gt;; Donegan, Chun and Hughes (2020) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a>&gt;; Donegan, Chun and Griffith (2021) &lt;<a href="https://doi.org/10.3390%2Fijerph18136856">doi:10.3390/ijerph18136856</a>&gt;; Morris et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.sste.2019.100301">doi:10.1016/j.sste.2019.100301</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spdep (&ge; 1.0), sf (&ge; 1.0-10), ggplot2 (&ge; 3.0.0), methods,
graphics, stats, spData, MASS, truncnorm, signs, gridExtra,
utils, Matrix (&ge; 1.3), Rcpp (&ge; 0.12.0), RcppParallel (&ge;
5.0.1), rstan (&ge; 2.26.0), rstantools (&ge; 2.1.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, bayesplot</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-04 21:54:21 UTC; connor</td>
</tr>
<tr>
<td>Author:</td>
<td>Connor Donegan <a href="https://orcid.org/0000-0002-9698-5443"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mitzi Morris [ctb],
  Amy Tims [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Connor Donegan &lt;connor.donegan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-04 22:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='geostan-package'>The geostan R package.</h2><span id='topic+geostan-package'></span><span id='topic+geostan'></span>

<h3>Description</h3>

<p>Bayesian spatial modeling powered by Stan. <strong>geostan</strong> provides access to a variety of hierarchical spatial models using the R formula interface, supporting a complete spatial analysis workflow with a suite of spatial analysis tools. It is designed primarily for public health and social science research but is generally applicable to modeling areal data. Unique features of the package include its spatial measurement error model (for inference with small area estimates such as those from the American Community Survey), its fast proper conditional autoregressive (CAR) and simultaneous autoregressive (SAR) models, and its eigenvector spatial filtering (ESF) models. The package also supports spatial regression with raster layers.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Connor Donegan <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a> (<a href="https://orcid.org/0000-0002-9698-5443">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Mitzi Morris [contributor]
</p>
</li>
<li><p> Amy Tims [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Carpenter, B., Gelman, A., Hoffman, M.D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M., Guo, J., Li, P., Riddell, A., 2017. Stan: A probabilistic programming language. Journal of statistical software 76. <a href="https://doi.org/10.18637/jss.v076.i01">doi:10.18637/jss.v076.i01</a>.
</p>
<p>Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moran’s Eigenvectors and hierarchical shrinkage priors. <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a> (open access: <a href="https://doi.org/10.31219/osf.io/fah3z">doi:10.31219/osf.io/fah3z</a>).
</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. <a href="https://doi.org/10.3390/ijerph18136856">doi:10.3390/ijerph18136856</a>. Supplementary material: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Donegan, Connor (2022) geostan: An R package for Bayesian spatial analysis. <em>The Journal of Open Source Software</em>. 7, no. 79: 4716. <a href="https://doi.org/10.21105/joss.04716">doi:10.21105/joss.04716</a>.
</p>
<p>Gabry, J., Goodrich, B. and Lysy, M. (2020). rstantools: Tools for developers of R packages interfacing with Stan. R package version 2.1.1 <a href="https://mc-stan.org/rstantools/">https://mc-stan.org/rstantools/</a>.
</p>
<p>Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., &amp; DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan. Spatial and spatio-temporal epidemiology, 31, 100301. <a href="https://doi.org/10.1016/j.sste.2019.100301">doi:10.1016/j.sste.2019.100301</a>.
</p>
<p>Stan Development Team (2019). RStan: the R interface to Stan. R package version 2.19.2. <a href="https://mc-stan.org">https://mc-stan.org</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://connordonegan.github.io/geostan/">https://connordonegan.github.io/geostan/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ConnorDonegan/geostan/issues">https://github.com/ConnorDonegan/geostan/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aple'>Spatial autocorrelation estimator</h2><span id='topic+aple'></span>

<h3>Description</h3>

<p>The approximate-profile likelihood estimator for the spatial autocorrelation parameter from a simultaneous autoregressive (SAR) model (Li et al. 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aple(x, w, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aple_+3A_x">x</code></td>
<td>
<p>Numeric vector of values, length <code>n</code>. This will be standardized internally with <code>scale(x)</code>.</p>
</td></tr>
<tr><td><code id="aple_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> row-standardized spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>.</p>
</td></tr>
<tr><td><code id="aple_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>APLE</code> is an estimate of the spatial autocorrelation parameter one would obtain from fitting an intercept-only SAR model. Note, the <code>APLE</code> approximation is not reliable when the number of observations is large.
</p>


<h3>Value</h3>

<p>the APLE estimate, a numeric value.
</p>


<h3>Source</h3>

<p>Li, Honfei and Calder, Catherine A. and Cressie, Noel (2007). Beyond Moran's I: testing for spatial dependence based on the spatial autoregressive model. Geographical Analysis: 39(4): 357-375.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc">mc</a>, <a href="#topic+moran_plot">moran_plot</a>, <a href="#topic+lisa">lisa</a>, <a href="#topic+sim_sar">sim_sar</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
data(georgia)
w &lt;- shape2mat(georgia, "W")
x &lt;- georgia$ICE
aple(x, w)
</code></pre>

<hr>
<h2 id='as.matrix.geostan_fit'>Extract samples from a fitted model</h2><span id='topic+as.matrix.geostan_fit'></span><span id='topic+as.data.frame.geostan_fit'></span><span id='topic+as.array.geostan_fit'></span>

<h3>Description</h3>

<p>Extract samples from the joint posterior distribution of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
as.matrix(x, ...)

## S3 method for class 'geostan_fit'
as.data.frame(x, ...)

## S3 method for class 'geostan_fit'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.geostan_fit_+3A_x">x</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="as.matrix.geostan_fit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>rstan</code> methods for for <code>as.data.frame</code>, <code>as.matrix</code>, or <code>as.array</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, data frame, or array of MCMC samples is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
A &lt;- shape2mat(georgia, "B")

fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)),
                C = A,
                data = georgia,
                family = poisson(),
                chains = 1, iter = 600) # for speed only


s &lt;- as.matrix(fit)
dim(s)

a &lt;- as.matrix(fit, pars = "intercept")
dim(a)

# Or extract the stanfit object
S &lt;- fit$stanfit
print(S, pars = "intercept")
samples &lt;- as.matrix(S)
dim(samples)
</code></pre>

<hr>
<h2 id='auto_gaussian'>Auto-Gaussian family for CAR models</h2><span id='topic+auto_gaussian'></span>

<h3>Description</h3>

<p>create a family object for the auto-Gaussian CAR or SAR specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_gaussian(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_gaussian_+3A_type">type</code></td>
<td>
<p>Optional; either &quot;CAR&quot; for conditionally specified auto-model or &quot;SAR&quot; for the simultaneously specified auto-model. The type is added internally by <code>stan_car</code> or <code>stan_sar</code> when needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>family</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_car">stan_car</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cp = prep_car_data(shape2mat(georgia))
fit &lt;- stan_car(log(rate.male) ~ 1,
                data = georgia,
                car_parts = cp,
                family = auto_gaussian(),
                chains = 2, iter = 700) # for speed only
print(fit)
</code></pre>

<hr>
<h2 id='edges'>Edge list</h2><span id='topic+edges'></span>

<h3>Description</h3>

<p>Creates a list of connected nodes following the graph representation of a spatial connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(C, unique_pairs_only = TRUE, shape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edges_+3A_c">C</code></td>
<td>
<p>A connectivity matrix where connection between two nodes is indicated by non-zero entries.</p>
</td></tr>
<tr><td><code id="edges_+3A_unique_pairs_only">unique_pairs_only</code></td>
<td>
<p>By default, only unique pairs of nodes (i, j) will be included in the output.</p>
</td></tr>
<tr><td><code id="edges_+3A_shape">shape</code></td>
<td>
<p>Optional spatial object (geometry) to which <code>C</code> refers. If given, the function returns an <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally for <code><a href="#topic+stan_icar">stan_icar</a></code>, can be helpful for creating the scaling factor for BYM2 models fit with <code><a href="#topic+stan_icar">stan_icar</a></code>, and can be used for visualizing a spatial connectivity matrix.
</p>


<h3>Value</h3>

<p>If <code>shape</code> is missing, this returns a <code>data.frame</code> with three columns. The first two columns (<code>node1</code> and <code>node2</code>) contain the indices of connected pairs of nodes; only unique pairs of nodes are included (unless <code>unique_pairs_only = FALSE</code>). The third column (<code>weight</code>) contains the corresponding matrix element, <code>C[node1, node2]</code>.
</p>
<p>If <code>shape</code> is provided, the results are joined to an <code>sf</code> object so the connections can be visualized.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape2mat">shape2mat</a></code>, <code><a href="#topic+prep_icar_data">prep_icar_data</a></code>, <code><a href="#topic+stan_icar">stan_icar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)
C &lt;- shape2mat(sentencing)
nbs &lt;- edges(C)
head(nbs)

## similar to:
head(Matrix::summary(C))
head(Matrix::summary(shape2mat(georgia, "W")))

## add geometry for plotting
library(sf)
E &lt;- edges(C, shape = sentencing)
g1 = st_geometry(E)
g2 = st_geometry(sentencing)
plot(g1, lwd = .2)
plot(g2, add = TRUE)

</code></pre>

<hr>
<h2 id='eigen_grid'>Eigenvalues of a spatial weights matrix: for spatial regression with raster data</h2><span id='topic+eigen_grid'></span>

<h3>Description</h3>

<p>Approximate eigenvalues for the row-standardized spatial connectivity matrix W of a regular tessellation, e.g., remotely sensed imagery.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_grid(row = 5, col = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen_grid_+3A_row">row</code></td>
<td>
<p>Number of rows in the raster dataset</p>
</td></tr>
<tr><td><code id="eigen_grid_+3A_col">col</code></td>
<td>
<p>Number of columns in the raster dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Equation 5 from Griffith (2000) to calculate the eigenvalues for a row-standardized spatial weights matrix; this is valid for a regular tessellation (rectangular grid or raster). The rook criteria is used to define adjacency.
</p>
<p>The purpose is to calculate eigenvalues of the spatial weights matrix for the CAR and SAR models, enabling spatial regression with large raster data sets. This function is used internally by <code><a href="#topic+prep_sar_data2">prep_sar_data2</a></code> and <code><a href="#topic+prep_car_data2">prep_car_data2</a></code>. For more details, see: <code>vignette("raster-regression", package = "geostan")</code>.
</p>


<h3>Value</h3>

<p>Returns the eigenvalues of the row-standardized spatial weights matrix (a numeric vector length <code>row * col</code>).
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2000). Eigenfunction properties and approximations of selected incidence matrices employed in spatial analyses. <em>Linear Algebra and its Applications</em> 321 (1-3): 95-112. <a href="https://doi.org/10.1016/S0024-3795%2800%2900031-8">doi:10.1016/S0024-3795(00)00031-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_sar_data2">prep_sar_data2</a></code>, <code><a href="#topic+prep_car_data2">prep_car_data2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e &lt;- eigen_grid(row = 50, col = 95)
print(head(e, 25))

</code></pre>

<hr>
<h2 id='expected_mc'>Expected value of the residual Moran coefficient</h2><span id='topic+expected_mc'></span>

<h3>Description</h3>

<p>Expected value for the Moran coefficient of model residuals under the null hypothesis of no spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_mc(X, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected_mc_+3A_x">X</code></td>
<td>
<p>model matrix, including column of ones.</p>
</td></tr>
<tr><td><code id="expected_mc_+3A_c">C</code></td>
<td>
<p>Connectivity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value.
</p>


<h3>Source</h3>

<p>Chun, Yongwan and Griffith, Daniel A. (2013). Spatial statistics and geostatistics. Sage, p. 18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
C &lt;- shape2mat(georgia)
X &lt;- model.matrix(~ college, georgia)
expected_mc(X, C)
</code></pre>

<hr>
<h2 id='georgia'>Georgia all-cause, sex-specific mortality, ages 55-64, years 2014-2018</h2><span id='topic+georgia'></span>

<h3>Description</h3>

<p>A simple features (sf) object for Georgia counties with sex- and age-specific deaths and populations at risk (2014-2018), plus select estimates (with standard errors) of county characteristics. Standard errors of the ICE were calculated using the Census Bureau's variance replicate tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>georgia
</code></pre>


<h3>Format</h3>

<p>A simple features object with county geometries and the following columns:
</p>

<dl>
<dt>GEOID</dt><dd><p>Six digit combined state and county FIPS code</p>
</dd>
<dt>NAME</dt><dd><p>County name</p>
</dd>
<dt>ALAND</dt><dd><p>Land area</p>
</dd>
<dt>AWATER</dt><dd><p>Water area</p>
</dd>
<dt>population</dt><dd><p>Census Bureau 2018 county population estimate</p>
</dd>
<dt>white</dt><dd><p>Percent White, ACS 2018 five-year estimate</p>
</dd>
<dt>black</dt><dd><p>Percent Black, ACS 2018 five-year estimate</p>
</dd>
<dt>hisp</dt><dd><p>Percent Hispanic/Latino, ACS 2018 five-year estimate</p>
</dd>
<dt>ai</dt><dd><p>Percent American Indian, ACS 2018 five-year estimate</p>
</dd>
<dt>deaths.male</dt><dd><p>Male deaths, 55-64 yo, 2014-2018</p>
</dd>
<dt>pop.at.risk.male</dt><dd><p>Population estimate, males, 55-64 yo, years 2014-2018 (total), ACS 2018 five-year estimate</p>
</dd>
<dt>pop.at.risk.male.se</dt><dd><p>Standard error of the pop.at.risk.male estimate</p>
</dd>
<dt>deaths.female</dt><dd><p>Female deaths, 55-64 yo, 2014-2018</p>
</dd>
<dt>pop.at.risk.female</dt><dd><p>Population estimate, females, 55-64 yo, years 2014-2018 (total), ACS 2018 five-year estimate</p>
</dd>
<dt>pop.at.risk.female.se</dt><dd><p>Standard error of the pop.at.risk.female estimate</p>
</dd>
<dt>ICE</dt><dd><p>Index of Concentration at the Extremes</p>
</dd>
<dt>ICE.se</dt><dd><p>Standard error of the ICE estimate, calculated using variance replicate tables</p>
</dd>
<dt>income</dt><dd><p>Median household income, ACS 2018 five-year estimate</p>
</dd>
<dt>income.se</dt><dd><p>Standard error of the income estimate</p>
</dd>
<dt>college</dt><dd><p>Percent of the population age 25 or higher than has a bachelors degree of higher, ACS 2018 five-year estimate</p>
</dd>
<dt>college.se</dt><dd><p>Standard error of the college estimate</p>
</dd>
<dt>insurance</dt><dd><p>Percent of the population with health insurance coverage, ACS 2018 five-year estimate</p>
</dd>
<dt>insurance.se</dt><dd><p>Standard error of the insurance estimate</p>
</dd>
<dt>rate.male</dt><dd><p>Raw (crude) age-specific male mortality rate, 2014-2018</p>
</dd>
<dt>rate.female</dt><dd><p>Raw (crude) age-specific female mortality rate, 2014-2018</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry for county boundaries</p>
</dd>
</dl>



<h3>Source</h3>

<p>Centers for Disease Control and Prevention, National Center for Health Statistics. Underlying Cause of Death 1999-2018 on CDC Wonder Online Database. 2020. Available online: <a href="http://wonder.cdc.gov">http://wonder.cdc.gov</a> (accessed on 19 October 2020).
</p>
<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). &ldquo;Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure.&rdquo; <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Kyle Walker and Matt Herman (2020). tidycensus: Load US Census Boundary and Attribute Data as 'tidyverse' and 'sf'-Ready Data  Frames. R package version 0.11. <a href="https://CRAN.R-project.org/package=tidycensus">https://CRAN.R-project.org/package=tidycensus</a>
</p>
<p>US Census Bureau. Variance Replicate Tables, 2018. Available online: <a href="https://www.census.gov/programs-surveys/acs/data/variance-tables.2018.html">https://www.census.gov/programs-surveys/acs/data/variance-tables.2018.html</a> (accessed on 19 October 2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
head(georgia)

library(sf)
plot(georgia[,'rate.female'])
</code></pre>

<hr>
<h2 id='get_shp'>Download shapefiles</h2><span id='topic+get_shp'></span>

<h3>Description</h3>

<p>Given a url to a shapefile in a compressed .zip file, download the file and unzip it into a folder in your working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shp(url, folder = "shape")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_shp_+3A_url">url</code></td>
<td>
<p>url to download a shapefile.</p>
</td></tr>
<tr><td><code id="get_shp_+3A_folder">folder</code></td>
<td>
<p>what to name the new folder in your working directory containing the shapefile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A folder in your working directory with the shapefile; filepaths are printed to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)
url &lt;- "https://www2.census.gov/geo/tiger/GENZ2019/shp/cb_2019_us_state_20m.zip"
folder &lt;- tempdir()
print(folder)
get_shp(url, folder)
states &lt;- sf::st_read(folder)
head(states)

</code></pre>

<hr>
<h2 id='gr'>The Geary Ratio</h2><span id='topic+gr'></span>

<h3>Description</h3>

<p>An index for spatial autocorrelation. Complete spatial randomness (lack of spatial pattern) is indicated by a Geary Ratio (GR) of 1; positive autocorrelation moves the index towards zero, while negative autocorrelation will push the index towards 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr(x, w, digits = 3, na.rm = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gr_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code>n</code>. By default, this will be standardized using the <code>scale</code> function.</p>
</td></tr>
<tr><td><code id="gr_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>.</p>
</td></tr>
<tr><td><code id="gr_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
<tr><td><code id="gr_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, observations with <code>NA</code> values will be dropped from both <code>x</code> and <code>w</code>.</p>
</td></tr>
<tr><td><code id="gr_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, no warning will be printed to inform you when observations with <code>NA</code> values have been dropped, or if any observations without neighbors have been found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Geary Ratio is an index of spatial autocorrelation. The
numerator contains a series of sums of squared deviations, which
will be smaller when each observation is similar to its
neighbors. This term makes the index sensitive to local outliers,
which is advantageous for detecting such outliers and for measuring
negative autocorrelation. The denominator contains the total sum of
squared deviations from the mean value. Hence, under strong
positive autocorrelation, the GR approaches zero. Zero spatial
autocorrelation is represented by a GR of 1. Negative
autocorrelation pushes the GR above 1, towards 2.  </p>
<p style="text-align: center;"><code class="reqn">GR =
\frac{n-1}{2K} \frac{M}{D}</code>
</p>
 <p style="text-align: center;"><code class="reqn">M = \sum_i \sum_j w_{i,j} (x_i -
x_j)^2 </code>
</p>
 <p style="text-align: center;"><code class="reqn">D = \sum_i (x_i - \overline{x})^2 </code>
</p>

<p>Observations
with no neighbors are removed before calculating the GR. (The
alternative would be for those observations to contribute zero to the
numerator&mdash;but zero is not a neutral value, it represents strong
positive autocorrelation.)
</p>


<h3>Value</h3>

<p>Returns the Geary ratio (a single numeric value).
</p>


<h3>Source</h3>

<p>Chun, Yongwan, and Daniel A. Griffith. Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology. Sage, 2013.
</p>
<p>Geary, R. C. &quot;The contiguity ratio and statistical mapping.&quot; The Incorporated Statistician 5, no. 3 (1954): 115-127_129-146.
</p>
<p>Unwin, Antony. &quot;Geary's Contiguity Ratio.&quot; The Economic and Social Review 27, no. 2 (1996): 145-159.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
x &lt;- log(georgia$income)
w &lt;- shape2mat(georgia, "W")
gr(x, w)


</code></pre>

<hr>
<h2 id='lg'>Local Geary</h2><span id='topic+lg'></span>

<h3>Description</h3>

<p>A local indicator of spatial association based on the Geary Ratio (Geary's C) for exploratory spatial data analysis. Large values of this statistic highlight local outliers, that is, values that are not like their neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lg(x, w, digits = 3, scale = TRUE, na.rm = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lg_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code>n</code>. By default, this will be standardized using the <code>scale</code> function.</p>
</td></tr>
<tr><td><code id="lg_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>.</p>
</td></tr>
<tr><td><code id="lg_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
<tr><td><code id="lg_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, then <code>x</code> will automatically be standardized using <code>scale(x, center = TRUE, scale = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="lg_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, observations with <code>NA</code> values will be dropped from both <code>x</code> and <code>w</code>.</p>
</td></tr>
<tr><td><code id="lg_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, no warning will be printed to inform you when observations with <code>NA</code> values have been dropped, or if any observations without neighbors have been found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local Geary's C is found in the numerator of the Geary Ratio (GR). For the <code class="reqn">i^{th}</code> observation, the local Geary statistic is
</p>
<p style="text-align: center;"><code class="reqn">C_i = \sum_j w_{i,j} * (x_i - x_j)^2</code>
</p>

<p>Hence, local Geary values will be largest for those observations that are most unlike their neighboring values. If a binary connectivity matrix is used (rather than row-standardized), then having many neighbors can also increase the value of the local Geary statistic. For most purposes, the row-standardized spatial weights matrix may be the more appropriate choice.
</p>


<h3>Value</h3>

<p>The function returns a vector of numeric values, each value being a local indicator of spatial association (or dissimilarity), ordered as <code>x</code>.
</p>


<h3>Source</h3>

<p>Anselin, Luc. &quot;Local indicators of spatial association—LISA.&quot; Geographical analysis 27, no. 2 (1995): 93-115.
</p>
<p>Chun, Yongwan, and Daniel A. Griffith. Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology. Sage, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data(georgia)
x &lt;- log(georgia$income)
w &lt;- shape2mat(georgia, "W")
lisa &lt;- lg(x, w)
hist(lisa)
ggplot(georgia) +
  geom_sf(aes(fill = lisa)) +
scale_fill_gradient(high = "navy",  
                   low = "white") 
 ## or try: scale_fill_viridis() 

</code></pre>

<hr>
<h2 id='lisa'>Local Moran's I</h2><span id='topic+lisa'></span>

<h3>Description</h3>

<p>A local indicator of spatial association (LISA) based on Moran's I (the Moran coefficient) for exploratory data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa(x, w, type = TRUE, scale = TRUE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lisa_+3A_x">x</code></td>
<td>
<p>Numeric vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="lisa_+3A_w">w</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> spatial connectivity matrix. See <a href="#topic+shape2mat">shape2mat</a>. If <code>w</code> is not row standardized (<code>all(Matrix::rowSums(w) == 1)</code>), it will automatically be row-standardized.</p>
</td></tr>
<tr><td><code id="lisa_+3A_type">type</code></td>
<td>
<p>Return the type of association also (High-High, Low-Low, High-Low, and Low-High)? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lisa_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, then <code>x</code> will automatically be standardized using <code>scale(x, center = TRUE, scale = TRUE)</code>. If <code>FALSE</code>, then the variate will be centered but not scaled, using <code>scale(x, center = TRUE, scale = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="lisa_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>x</code> will automatically be centered first with <code>z = scale(x, center = TRUE, scale = scale)</code> (with user control over the <code>scale</code> argument). The LISA values are the product of each <code>z</code> value with the weighted sum of their respective surrounding value: </p>
<p style="text-align: center;"><code class="reqn">I_i = z_i \sum_j w_{ij} z_j</code>
</p>
<p> (or in R code: <code>lisa = z * (w %*% z)</code>). These are for exploratory analysis and model diagnostics.
</p>
<p>An above-average value (i.e. positive z-value) with positive mean spatial lag indicates local positive spatial autocorrelation and is designated type &quot;High-High&quot;; a low value surrounded by high values indicates negative spatial autocorrelation and is designated type &quot;Low-High&quot;, and so on.
</p>
<p>This function uses Equation 7 from Anselin (1995). Note that the <code>spdep</code> package uses Formula 12, which divides the same value by a constant term <code class="reqn">\sum_i z_i^2/n</code>. So the <code>geostan</code> version can be made equal to the <code>spdep</code> version by dividing by that value.
</p>


<h3>Value</h3>

<p>If <code>type = FALSE</code> a numeric vector of lisa values for exploratory analysis of local spatial autocorrelation. If <code>type = TRUE</code>, a <code>data.frame</code> with columns <code>Li</code> (the lisa value) and <code>type</code>.
</p>


<h3>Source</h3>

<p>Anselin, Luc. &quot;Local indicators of spatial association—LISA.&quot; Geographical Analysis 27, no. 2 (1995): 93-115.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+aple">aple</a></code>, <code><a href="#topic+lg">lg</a></code>, <code><a href="#topic+gr">gr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(sf)
data(georgia)
w &lt;- shape2mat(georgia, "W")
x &lt;- georgia$ICE
li = lisa(x, w)
head(li)
ggplot(georgia, aes(fill = li$Li)) +
  geom_sf() +
  scale_fill_gradient2()
</code></pre>

<hr>
<h2 id='log_lik'>Extract log-likelihood</h2><span id='topic+log_lik'></span><span id='topic+log_lik.geostan_fit'></span>

<h3>Description</h3>

<p>Extract log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_lik(object, array = FALSE, ...)

## S3 method for class 'geostan_fit'
log_lik(object, array = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_lik_+3A_object">object</code></td>
<td>
<p>A <code>geostan_fit</code> model</p>
</td></tr>
<tr><td><code id="log_lik_+3A_array">array</code></td>
<td>
<p>Return results as an array, one matrix per MCMC chain?</p>
</td></tr>
<tr><td><code id="log_lik_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or array) of MCMC samples for the log-likelihood: the casewise probability of the data conditional on estimated parameter values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+waic">waic</a></code> <code><a href="#topic+dic">dic</a></code>
</p>

<hr>
<h2 id='make_EV'>Prepare data for spatial filtering</h2><span id='topic+make_EV'></span>

<h3>Description</h3>

<p>Prepare data for spatial filtering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_EV(C, nsa = FALSE, threshold = 0.2, values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_EV_+3A_c">C</code></td>
<td>
<p>A binary spatial weights matrix. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="make_EV_+3A_nsa">nsa</code></td>
<td>
<p>Logical. Default of <code>nsa = FALSE</code> excludes eigenvectors capturing negative spatial autocorrelation.
Setting <code>nsa = TRUE</code> will result in a candidate set of EVs that contains eigenvectors representing positive and negative SA.</p>
</td></tr>
<tr><td><code id="make_EV_+3A_threshold">threshold</code></td>
<td>
<p>Defaults to <code>threshold=0.2</code> to exclude eigenvectors representing spatial autocorrelation levels that are less than <code>threshold</code> times the maximum possible Moran coefficient achievable for the given spatial connectivity matrix. If <code>theshold = 0</code>, all eigenvectors will be returned (however, the eigenvector of constants (with eigenvalue of zero) will be dropped automatically).</p>
</td></tr>
<tr><td><code id="make_EV_+3A_values">values</code></td>
<td>
<p>Should eigenvalues be returned also? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a set of eigenvectors related to the Moran coefficient (MC), limited to those eigenvectors with |MC| &gt; <code>threshold</code> if <code>nsa = TRUE</code> or MC &gt; <code>threshold</code> if <code>nsa = FALSE</code>, optionally with corresponding eigenvalues.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of eigenvectors for spatial filtering. If <code>values=TRUE</code> then a named list is returned with elements <code>eigenvectors</code> and <code>eigenvalues</code>.
</p>


<h3>Source</h3>

<p>Daniel Griffith and Yongwan Chun. 2014. &quot;Spatial Autocorrelation and Spatial Filtering.&quot; in M. M. Fischer and P. Nijkamp (eds.), <em>Handbook of Regional Science.</em> Springer.
</p>


<h3>See Also</h3>

<p><a href="#topic+stan_esf">stan_esf</a>, <a href="#topic+mc">mc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data(georgia)
C &lt;- shape2mat(georgia, style = "B")
EV &lt;- make_EV(C)
head(EV)

ggplot(georgia) +
  geom_sf(aes(fill = EV[,1])) +
  scale_fill_gradient2()
</code></pre>

<hr>
<h2 id='mc'>The Moran coefficient (Moran's I)</h2><span id='topic+mc'></span>

<h3>Description</h3>

<p>The Moran coefficient, a measure of spatial autocorrelation (also known as Global Moran's I)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc(x, w, digits = 3, warn = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc_+3A_x">x</code></td>
<td>
<p>Numeric vector of input values, length n.</p>
</td></tr>
<tr><td><code id="mc_+3A_w">w</code></td>
<td>
<p>An n x n spatial connectivity matrix. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="mc_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round results to.</p>
</td></tr>
<tr><td><code id="mc_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, no warning will be printed to inform you when observations with zero neighbors or <code>NA</code> values have been dropped.</p>
</td></tr>
<tr><td><code id="mc_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, observations with <code>NA</code> values will be dropped from both <code>x</code> and <code>w</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the Moran coefficient (MC) is
</p>
<p style="text-align: center;"><code class="reqn">MC = \frac{n}{K}\frac{\sum_i \sum_j w_{ij} (y_i - \overline{y})(y_j - \overline{y})}{\sum_i (y_i - \overline{y})^2}</code>
</p>

<p>where <code class="reqn">n</code> is the number of observations and <code class="reqn">K</code> is the sum of all values in the spatial connectivity matrix <code class="reqn">W</code>, i.e., the sum of all row-sums: <code class="reqn">K = \sum_i \sum_j w_{ij}</code>.
</p>
<p>If any observations with no neighbors are found (i.e. <code>any(Matrix::rowSums(w) == 0)</code>) they will be dropped automatically and a message will print stating how many were dropped. (The alternative would be for those observations to have a spatial lage of zero, but zero is not a neutral value.)
</p>


<h3>Value</h3>

<p>The Moran coefficient, a numeric value.
</p>


<h3>Source</h3>

<p>Chun, Yongwan, and Daniel A. Griffith. Spatial Statistics and Geostatistics: Theory and Applications for Geographic Information Science and Technology. Sage, 2013.
</p>
<p>Cliff, Andrew David, and J. Keith Ord. Spatial processes: models &amp; applications. Taylor &amp; Francis, 1981.
</p>


<h3>See Also</h3>

<p><a href="#topic+moran_plot">moran_plot</a>, <a href="#topic+lisa">lisa</a>, <a href="#topic+aple">aple</a>, <a href="#topic+gr">gr</a>, <a href="#topic+lg">lg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
data(georgia)
w &lt;- shape2mat(georgia, style = "W")
x &lt;- georgia$ICE
mc(x, w)
</code></pre>

<hr>
<h2 id='me_diag'>Measurement error model diagnostics</h2><span id='topic+me_diag'></span>

<h3>Description</h3>

<p>Visual diagnostics for spatial measurement error models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me_diag(
  fit,
  varname,
  shape,
  probs = c(0.025, 0.975),
  plot = TRUE,
  mc_style = c("scatter", "hist"),
  size = 0.25,
  index = 0,
  style = c("W", "B"),
  w = shape2mat(shape, match.arg(style), quiet = TRUE),
  binwidth = function(x) 0.5 * sd(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="me_diag_+3A_fit">fit</code></td>
<td>
<p>A <code>geostan_fit</code> model object as returned from a call to one of the <code>geostan::stan_*</code> functions.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_varname">varname</code></td>
<td>
<p>Name of the modeled variable (a character string, as it appears in the model formula).</p>
</td></tr>
<tr><td><code id="me_diag_+3A_shape">shape</code></td>
<td>
<p>An object of class <code>sf</code> or another spatial object coercible to <code>sf</code> with <code>sf::st_as_sf</code>.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_probs">probs</code></td>
<td>
<p>Lower and upper quantiles of the credible interval to plot.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, return a list of <code>ggplot</code>s and a <code>data.frame</code> with the raw data values alongside a posterior summary of the modeled variable.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_mc_style">mc_style</code></td>
<td>
<p>Character string indicating how to plot the Moran coefficient for the delta values: if <code>mc = "scatter"</code>, then <code><a href="#topic+moran_plot">moran_plot</a></code> will be used with the marginal residuals; if <code>mc = "hist"</code>, then a histogram of Moran coefficient values will be returned, where each plotted value represents the degree of residual autocorrelation in a draw from the join posterior distribution of delta values.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_size">size</code></td>
<td>
<p>Size of points and lines, passed to <code>geom_pointrange</code>.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_index">index</code></td>
<td>
<p>Integer value; use this if you wish to identify observations with the largest <code>n=index</code> absolute Delta values; data on the top <code>n=index</code> observations ordered by absolute Delta value will be printed to the console and the plots will be labeled with the indices of the identified observations.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_style">style</code></td>
<td>
<p>Style of connectivity matrix; if <code>w</code> is not provided, <code>style</code> is passed to <code><a href="#topic+shape2mat">shape2mat</a></code> and defaults to &quot;W&quot; for row-standardized.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_w">w</code></td>
<td>
<p>An optional spatial connectivity matrix; if not provided, one will be created using <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="me_diag_+3A_binwidth">binwidth</code></td>
<td>
<p>A function with a single argument that will be passed to the <code>binwidth</code> argument in <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>. The default is to set the width of bins to <code>0.5 * sd(x)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of spatial diagnostic plots for measurement error models comparing the raw observations to the posterior distribution of the true values. Includes a point-interval plot of raw values and modeled values; a Moran scatter plot for <code>delta = z - x</code> where <code>z</code> are the survey estimates and <code>x</code> are the modeled values; and a map of the delta values (take at their posterior means).
</p>


<h3>Source</h3>

<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). &ldquo;Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure.&rdquo; <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sp_diag">sp_diag</a></code>, <code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+aple">aple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)
data(georgia)
## binary adjacency matrix
A &lt;- shape2mat(georgia, "B")
## prepare data for the CAR model, using WCAR specification
cars &lt;- prep_car_data(A, style = "WCAR")
## provide list of data for the measurement error model
ME &lt;- prep_me_data(se = data.frame(college = georgia$college.se),
                   car_parts = cars)
## sample from the prior probability model only, including the ME model
fit &lt;- stan_glm(log(rate.male) ~ college,
                ME = ME,
                data = georgia, 
                prior_only = TRUE,
                iter = 1e3, # for speed only
                chains = 2, # for speed only
                refresh = 0 # silence some printing
                )

## see ME diagnostics
me_diag(fit, "college", georgia)
## see index values for the largest (absolute) delta values
 ## (differences between raw estimate and the posterior mean)
me_diag(fit, "college", georgia, index = 3)

</code></pre>

<hr>
<h2 id='moran_plot'>Moran scatter plot</h2><span id='topic+moran_plot'></span>

<h3>Description</h3>

<p>Plots a set of values against their spatially lagged values and gives the Moran coefficient as a measure of spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran_plot(
  x,
  w,
  xlab = "x (centered)",
  ylab = "Spatial Lag",
  pch = 20,
  col = "darkred",
  size = 2,
  alpha = 1,
  lwd = 0.5,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moran_plot_+3A_x">x</code></td>
<td>
<p>A numeric vector of length n.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_w">w</code></td>
<td>
<p>An n x n spatial connectivity matrix.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_pch">pch</code></td>
<td>
<p>Symbol type.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_col">col</code></td>
<td>
<p>Symbol color.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_size">size</code></td>
<td>
<p>Symbol size.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_alpha">alpha</code></td>
<td>
<p>Symbol transparency.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_lwd">lwd</code></td>
<td>
<p>Width of the regression line.</p>
</td></tr>
<tr><td><code id="moran_plot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, any observations of <code>x</code> with <code>NA</code> values will be dropped from <code>x</code> and from <code>w</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the symbol parameters see the documentation for <a href="ggplot2.html#topic+geom_point">geom_point</a>.
</p>
<p>If any observations with no neighbors are found (i.e. <code>any(Matrix::rowSums(w) == 0)</code>) they will be dropped automatically and a message will print stating how many were dropped.
</p>


<h3>Value</h3>

<p>Returns a <code>gg</code> plot, a scatter plot with <code>x</code> on the horizontal and its spatially lagged values on the vertical axis (i.e. a Moran scatter plot).
</p>


<h3>Source</h3>

<p>Anselin, Luc. &quot;Local indicators of spatial association—LISA.&quot; Geographical analysis 27, no. 2 (1995): 93-115.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc">mc</a>, <a href="#topic+lisa">lisa</a>, <a href="#topic+aple">aple</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
x &lt;- georgia$income
w &lt;- shape2mat(georgia, "W")
moran_plot(x, w)
</code></pre>

<hr>
<h2 id='n_eff'>Effective sample size</h2><span id='topic+n_eff'></span>

<h3>Description</h3>

<p>An approximate calculation for the effective sample size for spatially autocorrelated data. Only valid for approximately normally distributed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_eff(n, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_eff_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="n_eff_+3A_rho">rho</code></td>
<td>
<p>Spatial autocorrelation parameter from a simultaneous autoregressive model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements Equation 3 from Griffith (2005).
</p>


<h3>Value</h3>

<p>Returns effective sample size n*, a numeric value.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2005). Effective geographic sample size in the presence of spatial autocorrelation. Annals of the Association of American Geographers. Vol. 95(4): 740-760.
</p>


<h3>See Also</h3>

<p><a href="#topic+sim_sar">sim_sar</a>, <a href="#topic+aple">aple</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_eff(100, 0)
n_eff(100, 0.5)
n_eff(100, 0.9)
n_eff(100, 1)

rho &lt;- seq(0, 1, by = 0.01)
plot(rho, n_eff(100, rho),
     type = 'l',
     ylab = "Effective Sample Size")
</code></pre>

<hr>
<h2 id='n_nbs'>Count neighbors in a connectivity matrix</h2><span id='topic+n_nbs'></span>

<h3>Description</h3>

<p>Count neighbors in a connectivity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_nbs(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_nbs_+3A_c">C</code></td>
<td>
<p>A connectivity matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the number of non-zero values in each row of <code>C</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sentencing)
C &lt;- shape2mat(sentencing)
sentencing$Ni &lt;- n_nbs(C)

</code></pre>

<hr>
<h2 id='posterior_predict'>Sample from the posterior predictive distribution</h2><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Draw samples from the posterior predictive distribution of a fitted <code>geostan</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_predict(
  object,
  S,
  summary = FALSE,
  width = 0.95,
  approx = TRUE,
  K = 20,
  preserve_order = FALSE,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_predict_+3A_object">object</code></td>
<td>
<p>A <code>geostan_fit</code> object.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_s">S</code></td>
<td>
<p>Optional; number of samples to take from the posterior distribution. The default, and maximum, is the total number of samples stored in the model.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_summary">summary</code></td>
<td>
<p>Should the predictive distribution be summarized by its means and central quantile intervals? If <code>summary = FALSE</code>, an <code>S</code> x <code>N</code> matrix of samples will be returned. If <code>summary = TRUE</code>, then a <code>data.frame</code> with the means and <code>100*width</code> credible intervals is returned.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_width">width</code></td>
<td>
<p>Only used if <code>summary = TRUE</code>, to set the quantiles for the credible intervals. Defaults to <code>width = 0.95</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_approx">approx</code></td>
<td>
<p>For SAR models only; <code>approx = TRUE</code> uses an approximation method for the inverse of matrix <code>(I - rho * W)</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_k">K</code></td>
<td>
<p>For SAR models only; number of matrix powers to for the matrix inverse approximation (used when <code>approx = TRUE</code>). High values of rho (especially &gt; 0.9) require larger K for accurate approximation.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_preserve_order">preserve_order</code></td>
<td>
<p>If <code>TRUE</code>, the order of posterior draws will remain fixed; the default is to permute the MCMC samples so that (with small sample size <code>S</code>) each successive call to <code>posterior_predict</code> will return a different sample from the posterior probability distribution.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_seed">seed</code></td>
<td>
<p>A single integer value to be used in a call to <code><a href="base.html#topic+set.seed">set.seed</a></code> before taking samples from the posterior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method returns samples from the posterior predictive distribution of the model (at the observed values of covariates, etc.). The predictions incorporate uncertainty of all parameter values (used to calculate the expected value of the model, for example) plus the error term (the model's description of the amount of variability of observations around the expected value). If the model includes measurement error in the covariates, this source of uncertainty (about <code class="reqn">X</code>) is passed into the posterior predictive distribution as well.
</p>
<p>For SAR models (and all other models), the observed outcomes are <em>not</em> used to formulate the posterior predictive distribution. The posterior predictive distribution for the SLM (see <a href="#topic+stan_sar">stan_sar</a>) is given by
</p>
<p style="text-align: center;"><code class="reqn">(I - \rho W)^{-1} (\mu + \epsilon).</code>
</p>

<p>The SDLM is the same but includes spatially-lagged covariates in <code class="reqn">mu</code>. The <code>approx = FALSE</code> method for SAR models requires a call to <code>Matrix::solve(I - rho * W)</code> for each MCMC sample; the <code>approx = TRUE</code> method uses an approximation based on matrix powers (LeSage and Pace 2009). The approximation will deteriorate if <code class="reqn">\rho^K</code> is not near zero, so use with care.
</p>


<h3>Value</h3>

<p>A matrix of size S x N containing samples from the posterior predictive distribution, where S is the number of samples drawn and N is the number of observations. If <code>summary = TRUE</code>, a <code>data.frame</code> with N rows and 3 columns is returned (with column names <code>mu</code>, <code>lwr</code>, and <code>upr</code>).
</p>


<h3>Source</h3>

<p>LeSage, James, &amp; Robert kelley Pace (2009). <em>Introduction to Spatial Econometrics</em>. Chapman and Hall/CRC.
</p>
<p>Gelman, A., J. B.Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, &amp; D. B. Rubin, D. B. (2014). <em>Bayesian data analysis</em> (3rd ed.). CRC Press.
</p>
<p>McElreath, Richard (2016). <em>Statistical Rethinking: A Bayesian Course with Examples in R and Stan</em>. CRC Press, Ch. 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E &lt;- sentencing$expected_sents
sentencing$log_E &lt;- log(E)
 fit &lt;- stan_glm(sents ~ offset(log_E),
                  re = ~ name,
                  data = sentencing,
                  family = poisson(),
                  chains = 2, iter = 600) # for speed only


 yrep &lt;- posterior_predict(fit, S = 65)
 plot(density(yrep[1,] / E ))
 for (i in 2:nrow(yrep)) lines(density(yrep[i,] / E), col = 'gray30')
 lines(density(sentencing$sents / E), col = 'darkred', lwd = 2)

sars &lt;- prep_sar_data2(row = 9, col = 9)
W &lt;- sars$W
y &lt;- sim_sar(rho = .9, w = W)
fit &lt;- stan_sar(y ~ 1, data = data.frame(y=y), sar = sars,
                iter = 650, quiet = TRUE)
yrep &lt;- posterior_predict(fit, S = 15)

</code></pre>

<hr>
<h2 id='predict.geostan_fit'>Predict method for <code>geostan_fit</code> models</h2><span id='topic+predict.geostan_fit'></span>

<h3>Description</h3>

<p>Obtain predicted values from a fitted model by providing new covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
predict(
  object,
  newdata,
  alpha = as.matrix(object, pars = "intercept"),
  center = object$x_center,
  summary = TRUE,
  type = c("link", "response"),
  add_slx = FALSE,
  approx = FALSE,
  K = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.geostan_fit_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables with which to predict. Note that if the model formula includes an offset term, <code>newdata</code> must contain the offset column (see examples below). If covariates in the model were centered using the <code>centerx</code> argument, the <code>predict.geostan_fit</code> method will automatically center the predictors in <code>newdata</code> using the values stored in <code>object$x_center</code>. If <code>newdata</code> is missing, the fitted values of the model will be returned.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_alpha">alpha</code></td>
<td>
<p>An N-by-1 matrix of MCMC samples for the intercept; this is provided by default. If used, note that the intercept needs to be provided on the scale of the linear predictor. This argument might be used if there is a need to incorporate the spatial trend term (as a spatially-varying intercept).</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_center">center</code></td>
<td>
<p>Optional vector of numeric values or a logical scalar to pass to <code><a href="base.html#topic+scale">scale</a></code>. Defaults to using <code>object$x_center</code>. If the model was fit using <code>centerx = TRUE</code>, then covariates were centered and their mean values are stored in <code>object$x_center</code> and the <code>predict</code> method will use them automatically to center <code>newdata</code>; if the model was fit with <code>centerx = FALSE</code>, then <code>object$x_center = FALSE</code> and <code>newdata</code> will not be centered.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_summary">summary</code></td>
<td>
<p>If <code>FALSE</code>, a matrix containing samples from the posterior distribution at each observation is returned. The default, <code>TRUE</code>, will summarize results by providing an estimate (mean) and credible interval (formed by taking quantiles of the MCMC samples).</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_type">type</code></td>
<td>
<p>By default, results from <code>predict</code> are on the scale of the linear predictor (<code style="white-space: pre;">&#8288;type = "link")&#8288;</code>). The alternative (<code>type = "response"</code>) is on the scale of the response variable. For example, the default return values for a Poisson model on the log scale, and using <code>type = "response"</code> will return the original scale of the outcome variable (by exponentiating the log values).</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_add_slx">add_slx</code></td>
<td>
<p>Logical. If <code>add_slx = TRUE</code>, any spatially-lagged covariates that were specified through the 'slx' argument (of the model fitting function, e.g., <code>stan_glm</code>) will be added to the linear predictor. The spatial lag terms will be calculated internally using <code>object$C</code>, the spatial weights matrix used to fit the model. Hence, <code>newdata</code> must have <code>N = object$N</code> rows. Predictions from spatial lag models (SAR models of type 'SLM' and 'SDLM') always include the SLX terms (i.e., any value passed to <code>add_slx</code> will be overwritten with <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_approx">approx</code></td>
<td>
<p>For SAR models of type 'SLM' or 'SDLM' only; use an approximation for matrix inversion? See details below.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_k">K</code></td>
<td>
<p>Number of matrix powers to use with <code>approx</code>.</p>
</td></tr>
<tr><td><code id="predict.geostan_fit_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary purpose of the predict method is to explore marginal effects of covariates. The uncertainty present in these predictions refers to uncertainty in the expected value of the model. The expectation does not include the error term of the model (nb: one expects actual observations to form a cloud of points around the expected value). By contrast, <a href="#topic+posterior_predict">posterior_predict</a> returns the complete (posterior) predictive distribution of the model (the expectation plus noise).
</p>
<p>The model formula will be taken from <code>object$formula</code>, and then a model matrix will be created by passing <code>newdata</code> to the <a href="stats.html#topic+model.frame">model.frame</a> function (as in: <code>model.frame(object$formula, newdata)</code>. Parameters are taken from <code>as.matrix(object, pars = c("intercept", "beta"))</code>.
</p>
<p>The examples illustrate how to use the function in most cases.
</p>
<p>Special considerations apply to models with spatially-lagged covariates and a spatially-lagged dependent variable (i.e., the 'SLM' and 'SDLM' models fit by <a href="#topic+stan_sar">stan_sar</a>).
</p>


<h4>Spatial lag of X</h4>

<p>Spatially-lagged covariates which were included via the <code>slx</code> argument will, by default, not be included in the predicted values. (The user can have greater control by manually adding the spatially-lagged covariate to the main model formula.) The <code>slx</code> term will be be included in predictions if <code>add_slx = TRUE</code> or if the fitted model is a SAR model of type 'SLM' or 'SDLM'. In either of those cases, <code>newdata</code> must have the same number of rows as were used to fit the original data.
</p>



<h4>Spatial lag of Y</h4>

<p>The typical 'marginal effect' interpretation of the regression coefficients does not hold for the SAR models of type 'SLM' or 'SDLM'. For details on these 'spillover effects', see LeSage and Pace (2009), LeSage (2014), and <a href="#topic+impacts">impacts</a>.
</p>
<p>Predictions for the spatial lag model (SAR models of type 'SLM') are equal to:
</p>
<p style="text-align: center;"><code class="reqn">
 (I - \rho W)^{-1} X \beta
</code>
</p>

<p>where <code class="reqn">X \beta</code> contains the intercept and covariates. Predictions for the spatial Durbin lag model (SAR models of type 'SDLM') are equal to:
</p>
<p style="text-align: center;"><code class="reqn">
 (I - \rho W)^{-1} (X \beta + WX \gamma)
</code>
</p>

<p>where <code class="reqn">WX \gamma</code> are spatially lagged covariates multiplied by their coefficients. For this reason, the <code>predict.geostan_fit</code> method requires that <code>newdata</code> have as many rows as the original data (so that <code>nrow(newdata) == nrow(object$C)</code>); the spatial weights matrix will be taken from <code>object$C</code>.
</p>
<p>The inverse of the matrix <code class="reqn">(I - \rho W)</code> can be time consuming to compute (especially when iterating over MCMC samples). You can use <code>approx = TRUE</code> to approximate the inverse using a series of matrix powers. The argument <code class="reqn">K</code> controls how many powers to use for the approximation. As a rule, higher values of <code class="reqn">\rho</code> require larger <code class="reqn">K</code> to obtain accuracy. Notice that <code class="reqn">\rho^K</code> should be close to zero for the approximation to hold. For example, for <code class="reqn">\rho = .5</code> a value of <code class="reqn">K=8</code> may suffice (<code class="reqn">0.5^8 = 0.004</code>), but larger values of <code class="reqn">\rho</code> require higher values of <code class="reqn">K</code>.
</p>



<h4>Generalized linear models</h4>

<p>In generalized linear models (such as Poisson and Binomial models) marginal effects plots on the response scale may be sensitive to the level of other covariates in the model and to geographic location (given a spatially-varying mean value). If the model includes a spatial autocorrelation component (for example, you used a spatial CAR, SAR, or ESF model, or used the <code>re</code> argument for random effects), by default these terms will be fixed at zero for the purposes of calculating marginal effects. If you want to change this, you can introduce a varying intercept manually using the <code>alpha</code> argument.
</p>



<h3>Value</h3>

<p>If <code>summary = FALSE</code>, a matrix of samples is returned. If <code>summary = TRUE</code> (the default), a data frame is returned.
</p>


<h3>Source</h3>

<p>Goulard, Michael, Thibault Laurent, and Christine Thomas-Agnan (2017). About predictions in spatial autoregressive models: optimal and almost optimal strategies. <em>Spatial Economic Analysis</em> 12 (2-3): 304-325.
</p>
<p>LeSage, James (2014). What Regional Scientists Need to Know about Spatial Econometrics. <em>The Review of Regional Science</em> 44: 13-32 (2014 Southern Regional Science Association Fellows Address).
</p>
<p>LeSage, James, &amp; Robert kelley Pace (2009). <em>Introduction to Spatial Econometrics</em>. Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
georgia$income &lt;- georgia$income / 1e3

fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)) + log(income),
               data = georgia,
               re = ~ GEOID,
               centerx = TRUE,
               family = poisson(),
               chains = 2, iter = 600) # for speed only

# note: pop.at.risk.male=1 leads to offset of log(pop.at.risk.male)=0
# so that the predicted values are rates
newdata &lt;- data.frame(
             income = seq(min(georgia$income),
                          max(georgia$income),
                           length.out = 200),
             pop.at.risk.male = 1)

preds &lt;- predict(fit, newdata, type = "response")
head(preds)
plot(preds$income,
     preds$mean * 10e3,
     type = "l",
     ylab = "Deaths per 10,000",
     xlab = "Income ($1,000s)")

# here the predictions are rates per 10,000
newdata$pop.at.risk.male &lt;- 10e3
preds &lt;- predict(fit, newdata, type = "response")
head(preds)

# plot range
y_lim &lt;- c(min(preds$`2.5%`), max(preds$`97.5%`))

# plot line
plot(preds$income,
    preds$mean,
    type = "l",    
    ylab = "Deaths per 10,000",
    xlab = "Income ($1,000s)",
    ylim = y_lim,
    axes = FALSE)

# add shaded cred. interval
x &lt;- c(preds$income, rev(preds$income))
y &lt;- c(preds$`2.5%`, rev(preds$`97.5%`))
polygon(x = x, y = y,
       col = rgb(0.1, 0.2, 0.3, 0.3),
       border = NA)

# add axes
yat = seq(0, 300, by = 20)
axis(2, at = yat)

xat = seq(0, 200, by = 10)
axis(1, at = xat)

# show county incomes
rug(georgia$income)
</code></pre>

<hr>
<h2 id='prep_car_data'>Prepare data for the CAR model</h2><span id='topic+prep_car_data'></span>

<h3>Description</h3>

<p>Prepare data for the CAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_car_data(
  A,
  style = c("WCAR", "ACAR", "DCAR"),
  k = 1,
  gamma = 0,
  lambda = TRUE,
  stan_fn = ifelse(style == "WCAR", "wcar_normal_lpdf", "car_normal_lpdf"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_car_data_+3A_a">A</code></td>
<td>
<p>Binary adjacency matrix; for <code>style = DCAR</code>, provide a symmetric matrix of distances instead. The distance matrix should be sparse, meaning that most distances should be zero (usually obtained by setting some threshold distance beyond which all are zero).</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_style">style</code></td>
<td>
<p>Specification for the connectivity matrix (C) and conditional variances (M); one of &quot;WCAR&quot;, &quot;ACAR&quot;, or &quot;DCAR&quot;.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_k">k</code></td>
<td>
<p>For <code>style = DCAR</code>, distances will be raised to the -k power (d^-k).</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_gamma">gamma</code></td>
<td>
<p>For <code>style = DCAR</code>, distances will be offset by <code>gamma</code> before raising to the <code>-k</code>th power.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_lambda">lambda</code></td>
<td>
<p>If TRUE, return eigenvalues required for calculating the log determinant of the precision matrix and for determining the range of permissible values of rho. These will also be printed with a message if lambda = TRUE.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_stan_fn">stan_fn</code></td>
<td>
<p>Two computational methods are available for CAR models using <code><a href="#topic+stan_car">stan_car</a></code>: <code>car\_normal\_lpdf</code> and <code>wcar\_normal\_lpdf</code>. For WCAR models, either method will work but <code>wcar\_normal\_lpdf</code> is faster. To force use <code>car\_normal\_lpdf</code> when <code>style = 'WCAR'</code>, provide <code>stan_fn = "car_normal_lpdf"</code>.</p>
</td></tr>
<tr><td><code id="prep_car_data_+3A_quiet">quiet</code></td>
<td>
<p>Controls printing behavior. By default, <code>quiet = FALSE</code> and the range of permissible values for the spatial dependence parameter is printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CAR model is:
</p>
<div class="sourceCode"><pre>  Normal(Mu, Sigma), Sigma = (I - rho * C)^-1 * M * tau^2,
</pre></div>
<p>where <code>I</code> is the identity matrix, <code>rho</code> is a spatial autocorrelation parameter, <code>C</code> is a connectivity matrix, and <code>M * tau^2</code> is a diagonal matrix with conditional variances on the diagonal. <code>tau^2</code> is a (scalar) scale parameter.
</p>
<p>In the WCAR specification, <code>C</code> is the row-standardized version of <code>A</code>. This means that the non-zero elements of <code>A</code> will be converted to <code>1/N_i</code> where <code>N_i</code> is the number of neighbors for the <code>i</code>th site (obtained using <code>Matrix::rowSums(A)</code>. The conditional variances (on the diagonal of <code>M * tau^2</code>), are also proportional to <code>1/N_i</code>.
</p>
<p>The ACAR specification is from Cressie, Perrin and Thomas-Agnon (2005); also see Cressie and Wikle (2011, p. 188) and Donegan (2021).
</p>
<p>The DCAR specification is inverse distance-based, and requires the user provide a (sparse) distance matrix instead of a binary adjacency matrix. (For <code>A</code>, provide a symmetric matrix of distances, not inverse distances!) Internally, non-zero elements of <code>A</code> will be converted to: <code style="white-space: pre;">&#8288;d_{ij} = (a_{ij} + gamma)^(-k)&#8288;</code> (Cliff and Ord 1981, p. 144; Donegan 2021). Default values are <code>k=1</code> and <code>gamma=0</code>. Following Cressie (2015), these values will be scaled (divided) by their maximum value. For further details, see the DCAR_A specification in Donegan (2021).
</p>
<p>For inverse-distance weighting schemes, see Cliff and Ord (1981); for distance-based CAR specifications, see Cressie (2015 [1993]), Haining and Li (2020), and Donegan (2021).
</p>
<p>Details on CAR model specifications can be found in Table 1 of Donegan (2021).
</p>


<h3>Value</h3>

<p>A list containing all of the data elements required by the CAR model in <code><a href="#topic+stan_car">stan_car</a></code>.
</p>


<h3>Source</h3>

<p>Cliff A, Ord J (1981). Spatial Processes: Models and Applications. Pion.
</p>
<p>Cressie N (2015 [1993]). Statistics for Spatial Data. Revised edition. John Wiley &amp; Sons.
</p>
<p>Cressie N, Perrin O, Thomas-Agnan C (2005). “Likelihood-based estimation for Gaussian MRFs.” Statistical Methodology, 2(1), 1–16.
</p>
<p>Cressie N, Wikle CK (2011). Statistics for Spatio-Temporal Data. John Wiley &amp; Sons.
</p>
<p>Donegan, Connor (2021). Spatial conditional autoregressive models in Stan. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Haining RP, Li G (2020). Modelling Spatial and Spatio-Temporal Data: A Bayesian Approach. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(georgia)

## use a binary adjacency matrix
A &lt;- shape2mat(georgia, style = "B")

## WCAR specification
cp &lt;- prep_car_data(A, "WCAR")
1 / range(cp$lambda)

## ACAR specification
cp &lt;- prep_car_data(A, "ACAR")

## DCAR specification (inverse-distance based)
A &lt;- shape2mat(georgia, "B")
D &lt;- sf::st_distance(sf::st_centroid(georgia))
A &lt;- D * A
cp &lt;- prep_car_data(A, "DCAR", k = 1)

</code></pre>

<hr>
<h2 id='prep_car_data2'>Prepare data for the CAR model: raster analysis</h2><span id='topic+prep_car_data2'></span>

<h3>Description</h3>

<p>Prepare a list of data required for the CAR model; this is for working with (large) raster data files only. For non-raster analysis, see <a href="#topic+prep_car_data">prep_car_data</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_car_data2(row = 100, col = 100, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_car_data2_+3A_row">row</code></td>
<td>
<p>Number of rows in the raster</p>
</td></tr>
<tr><td><code id="prep_car_data2_+3A_col">col</code></td>
<td>
<p>Number of columns in the raster</p>
</td></tr>
<tr><td><code id="prep_car_data2_+3A_quiet">quiet</code></td>
<td>
<p>Controls printing behavior. By default, <code>quiet = FALSE</code> and the range of permissible values for the spatial dependence parameter is printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prepare input data for the CAR model when your dataset consists of observations on a regular (rectangular) tessellation, such as a raster layer or remotely sensed imagery. The rook criteria is used to determine adjacency. This function uses Equation 5 from Griffith (2000) to generate approximate eigenvalues for a row-standardized spatial weights matrix from a P-by-Q dimension regular tessellation.
</p>
<p>This function can accommodate very large numbers of observations for use with <code><a href="#topic+stan_car">stan_car</a></code>; for large N data, it is also recommended to use <code>slim = TRUE</code> or the <code>drop</code> argument. For more details, see: <code>vignette("raster-regression", package = "geostan")</code>.
</p>


<h3>Value</h3>

<p>A list containing all of the data elements required by the CAR model in <code><a href="#topic+stan_car">stan_car</a></code>.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2000). Eigenfunction properties and approximations of selected incidence matrices employed in spatial analyses. <em>Linear Algebra and its Applications</em> 321 (1-3): 95-112. <a href="https://doi.org/10.1016/S0024-3795%2800%2900031-8">doi:10.1016/S0024-3795(00)00031-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_sar_data2">prep_sar_data2</a></code>, <code><a href="#topic+prep_car_data">prep_car_data</a></code>, <code><a href="#topic+stan_car">stan_car</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
row = 100
col = 120
car_dl &lt;- prep_car_data2(row = row, col = col)

</code></pre>

<hr>
<h2 id='prep_icar_data'>Prepare data for ICAR models</h2><span id='topic+prep_icar_data'></span>

<h3>Description</h3>

<p>Given a symmetric n x n connectivity matrix, prepare data for intrinsic conditional autoregressive models in Stan. This function may be used for building custom ICAR models in Stan. This is used internally by <code><a href="#topic+stan_icar">stan_icar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_icar_data(C, scale_factor = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_icar_data_+3A_c">C</code></td>
<td>
<p>Connectivity matrix</p>
</td></tr>
<tr><td><code id="prep_icar_data_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Optional vector of scale factors for each connected portion of the graph structure. If not provided by the user it will be fixed to a vector of ones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally to prepare data for <code><a href="#topic+stan_icar">stan_icar</a></code> models. It can also be helpful for fitting custom ICAR models outside of <code>geostan</code>.
</p>


<h3>Value</h3>

<p>list of data to add to Stan data list:
</p>

<dl>
<dt>k</dt><dd><p>number of groups</p>
</dd>
<dt>group_size</dt><dd><p>number of nodes per group</p>
</dd>
<dt>n_edges</dt><dd><p>number of connections between nodes (unique pairs only)</p>
</dd>
<dt>node1</dt><dd><p>first node</p>
</dd>
<dt>node2</dt><dd><p>second node. (<code>node1[i]</code> and <code>node2[i]</code> form a connected pair)</p>
</dd>
<dt>weight</dt><dd><p>The element <code>C[node1, node2]</code>.</p>
</dd>
<dt>group_idx</dt><dd><p>indices for each observation belonging each group, ordered by group.</p>
</dd>
<dt>m</dt><dd><p>number of disconnected regions requiring their own intercept.</p>
</dd>
<dt>A</dt><dd><p>n-by-m matrix of dummy variables for the component-specific intercepts.</p>
</dd>
<dt>inv_sqrt_scale_factor</dt><dd><p>By default, this will be a k-length vector of ones. Placeholder for user-specified information. If user provided <code>scale_factor</code>, then this will be <code>1/sqrt(scale_factor)</code>.</p>
</dd>
<dt>comp_id</dt><dd><p>n-length vector indicating the group membership of each observation.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Besag, Julian, Jeremy York, and Annie Mollié. 1991. “Bayesian Image Restoration, with Two Applications in Spatial Statistics.” Annals of the Institute of Statistical Mathematics 43 (1): 1–20.
</p>
<p>Donegan, Connor. Flexible Functions for ICAR, BYM, and BYM2 Models in Stan. Code Repository. 2021. Available online: <a href="https://github.com/ConnorDonegan/Stan-IAR/">https://github.com/ConnorDonegan/Stan-IAR/</a> (accessed Sept. 10, 2021).
</p>
<p>Freni-Sterrantino, Anna, Massimo Ventrucci, and Håvard Rue. 2018. “A Note on Intrinsic Conditional Autoregressive Models for Disconnected Graphs.” Spatial and Spatio-Temporal Epidemiology 26: 25–34.
</p>
<p>Morris, Mitzi, Katherine Wheeler-Martin, Dan Simpson, Stephen J Mooney, Andrew Gelman, and Charles DiMaggio. 2019. “Bayesian Hierarchical Spatial Models: Implementing the Besag York Mollié Model in Stan.” Spatial and Spatio-Temporal Epidemiology 31: 100301.
</p>
<p>Riebler, Andrea, Sigrunn H Sørbye, Daniel Simpson, and Håvard Rue. 2016. “An Intuitive Bayesian Spatial Model for Disease Mapping That Accounts for Scaling.” Statistical Methods in Medical Research 25 (4): 1145–65.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges">edges</a></code>, <code><a href="#topic+shape2mat">shape2mat</a></code>, <code><a href="#topic+stan_icar">stan_icar</a></code>, <code><a href="#topic+prep_car_data">prep_car_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)
C &lt;- shape2mat(sentencing)
icar.data.list &lt;- prep_icar_data(C)
</code></pre>

<hr>
<h2 id='prep_me_data'>Prepare data for spatial measurement error models</h2><span id='topic+prep_me_data'></span>

<h3>Description</h3>

<p>Prepares the list of data required for geostan's (spatial) measurement error models. Given a data frame of standard errors and any optional arguments, the function returns a list with all required data for the models, filling in missing elements with default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_me_data(
  se,
  car_parts,
  prior,
  logit = rep(FALSE, times = ncol(se)),
  bounds = c(-Inf, Inf)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_me_data_+3A_se">se</code></td>
<td>
<p>Data frame of standard errors; column names must match (exactly) the variable names used in the model formula.</p>
</td></tr>
<tr><td><code id="prep_me_data_+3A_car_parts">car_parts</code></td>
<td>
<p>A list of data required for spatial CAR models, as created by <code><a href="#topic+prep_car_data">prep_car_data</a></code>; optional. If omitted, the measurement error model will be a non-spatial Student's t model.</p>
</td></tr>
<tr><td><code id="prep_me_data_+3A_prior">prior</code></td>
<td>
<p>A named list of prior distributions (see <code><a href="#topic+priors">priors</a></code>). If none are provided, default priors will be assigned. The list of priors may include the following parameters:
</p>

<dl>
<dt>df</dt><dd><p>If using a non-spatial ME model, the degrees of freedom (df) for the Student's t model is assigned a gamma prior with default parameters of <code>gamma2(alpha = 3, beta = 0.2)</code>. Provide values for each covariate in <code>se</code>, listing the values in the same order as the columns of <code>se</code>.</p>
</dd>
<dt>location</dt><dd><p>The prior for the location parameter (mu) is a normal (Gaussian) distribution (the default being <code>normal(location = 0, scale = 100)</code>). To adjust the prior distributions, provide values for each covariate in <code>se</code>, listing the values in the same order as the columns of se.</p>
</dd>
<dt>scale</dt><dd><p>The prior for the scale parameters is Student's t, and the default parameters are <code>student_t(df = 10, location = 0, scale = 40)</code>. To adjust, provide values for each covariate in <code>se</code>, listing the values in the same order as the columns of se.</p>
</dd>
<dt>car_rho</dt><dd><p>The CAR model, if used, has a spatial autocorrelation parameter, <code>rho</code>, which is assigned a uniform prior distribution. You must specify values that are within the permissible range of values for <code>rho</code>; these are automatically printed to the console by the <code><a href="#topic+prep_car_data">prep_car_data</a></code> function.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="prep_me_data_+3A_logit">logit</code></td>
<td>
<p>Optional vector of logical values (<code>TRUE</code>, <code>FALSE</code>) indicating if the latent variable should be logit-transformed. Only use for rates. This keeps rates between zero and one and may improve modeling of skewed variables (e.g., the poverty rate).</p>
</td></tr>
<tr><td><code id="prep_me_data_+3A_bounds">bounds</code></td>
<td>
<p>Rarely needed; an optional numeric vector of length two providing the upper and lower bounds, respectively, of the variables (e.g., a magnitudes must be greater than 0). If not provided, they will be set to c(-Inf, Inf) (i.e., unbounded).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data as required for (spatial) ME models. Missing arguments will be filled in with default values, including prior distributions.
</p>


<h3>See Also</h3>

<p><a href="#topic+se_log">se_log</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)

## for a non-spatial prior model for two covariates
se &lt;- data.frame(ICE = georgia$ICE.se,
                 college = georgia$college.se)
ME &lt;- prep_me_data(se)

## see default priors
print(ME$prior)

## set prior for the scale parameters
ME &lt;- prep_me_data(se,
                   prior = list(scale = student_t(df = c(10, 10),
                                                  location = c(0, 0),
                                                  scale = c(20, 20))))

## for a spatial prior model (often recommended)
A &lt;- shape2mat(georgia, "B")
cars &lt;- prep_car_data(A)
ME &lt;- prep_me_data(se,
                   car_parts = cars)
</code></pre>

<hr>
<h2 id='prep_sar_data'>Prepare data for a simultaneous autoregressive (SAR) model</h2><span id='topic+prep_sar_data'></span>

<h3>Description</h3>

<p>Given a spatial weights matrix <code class="reqn">W</code>, this function prepares data for the simultaneous autoregressive (SAR) model (a.k.a spatial error model (SEM)) in Stan. This is used internally by <code><a href="#topic+stan_sar">stan_sar</a></code>, and may also be used for building custom SAR models in Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_sar_data(W, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_sar_data_+3A_w">W</code></td>
<td>
<p>Spatial weights matrix, typically row-standardized.</p>
</td></tr>
<tr><td><code id="prep_sar_data_+3A_quiet">quiet</code></td>
<td>
<p>Controls printing behavior. By default, <code>quiet = FALSE</code> and the range of permissible values for the spatial dependence parameter is printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally to prepare data for <code><a href="#topic+stan_sar">stan_sar</a></code> models. It can also be helpful for fitting custom SAR models in Stan (outside of <code>geostan</code>), as described in the geostan vignette on custom spatial models.
</p>


<h3>Value</h3>

<p>Return's a list of data required as input for geostan's SAR models, as implemented in Stan. The list contains:
</p>

<dl>
<dt>ImW_w</dt><dd><p>Numeric vector containing the non-zero elements of matrix <code class="reqn">(I - W)</code>.</p>
</dd>
<dt>ImW_v</dt><dd><p>An integer vector containing the column indices of the non-zero elements of <code class="reqn">(I - W)</code>.</p>
</dd>
<dt>ImW_u</dt><dd><p>An integer vector indicating where in <code>ImW_w</code> a given row's non-zero values start.</p>
</dd>
<dt>nImW_w</dt><dd><p>Number of entries in <code>ImW_w</code>.</p>
</dd>
<dt>Widx</dt><dd><p>Integer vector containing the indices corresponding to values of <code>-W</code> in <code>ImW_w</code> (i.e. non-diagonal entries of <code class="reqn">(I-W)</code>).</p>
</dd>
<dt>nW</dt><dd><p>Integer length of <code>Widx</code>.</p>
</dd>
<dt>eigenvalues_w</dt><dd><p>Eigenvalues of <code class="reqn">W</code> matrix.</p>
</dd>
<dt>n</dt><dd><p>Number of rows in <code class="reqn">W</code>.</p>
</dd>
<dt>W</dt><dd><p>Sparse matrix representation of <code class="reqn">W</code></p>
</dd>
<dt>rho_min</dt><dd><p>Minimum permissible value of <code class="reqn">\rho</code> (<code>1/min(eigenvalues_w)</code>).</p>
</dd>
<dt>rho_max</dt><dd><p>Maximum permissible value of <code class="reqn">\rho</code> (<code>1/max(eigenvalues_w)</code>.</p>
</dd>
</dl>

<p>The function will also print the range of permissible <code class="reqn">\rho</code> values to the console (unless <code>quiet = TRUE</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+shape2mat">shape2mat</a>, <a href="#topic+stan_sar">stan_sar</a>, <a href="#topic+prep_car_data">prep_car_data</a>, <a href="#topic+prep_icar_data">prep_icar_data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
W &lt;- shape2mat(georgia, "W")
sar_dl &lt;- prep_sar_data(W)

</code></pre>

<hr>
<h2 id='prep_sar_data2'>Prepare data for SAR model: raster analysis</h2><span id='topic+prep_sar_data2'></span>

<h3>Description</h3>

<p>Prepares a list of data required for using the SAR model; this is for working with (large) raster data files. For non-raster analysis, see <a href="#topic+prep_sar_data">prep_sar_data</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_sar_data2(row, col, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_sar_data2_+3A_row">row</code></td>
<td>
<p>Number of rows in the raster</p>
</td></tr>
<tr><td><code id="prep_sar_data2_+3A_col">col</code></td>
<td>
<p>Number of columns in the raster</p>
</td></tr>
<tr><td><code id="prep_sar_data2_+3A_quiet">quiet</code></td>
<td>
<p>Controls printing behavior. By default, <code>quiet = FALSE</code> and the range of permissible values for the spatial dependence parameter is printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prepare data for the SAR model when your raw dataset consists of observations on a regular tessellation, such as a raster layer or remotely sensed imagery. The rook criteria is used to determine adjacency. This function uses Equation 5 from Griffith (2000) to calculate the eigenvalues for a row-standardized spatial weights matrix of a P-by-Q dimension regular tessellation.
</p>
<p>This function can accommodate very large numbers of observations for use with <code><a href="#topic+stan_sar">stan_sar</a></code>; for large N data, it is also recommended to use <code>slim = TRUE</code> or the <code>drop</code> argument. For details, see: <code>vignette("raster-regression", package = "geostan")</code>.
</p>


<h3>Value</h3>

<p>A list containing all of the data elements required by the SAR model in <code><a href="#topic+stan_sar">stan_sar</a></code>.
</p>


<h3>Source</h3>

<p>Griffith, Daniel A. (2000). Eigenfunction properties and approximations of selected incidence matrices employed in spatial analyses. <em>Linear Algebra and its Applications</em> 321 (1-3): 95-112. <a href="https://doi.org/10.1016/S0024-3795%2800%2900031-8">doi:10.1016/S0024-3795(00)00031-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_car_data2">prep_car_data2</a></code>, <code><a href="#topic+prep_sar_data">prep_sar_data</a></code>, <code><a href="#topic+stan_sar">stan_sar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
row = 100
col = 120
sar_dl &lt;- prep_sar_data2(row = row, col = col)

</code></pre>

<hr>
<h2 id='print.geostan_fit'>print or plot a fitted geostan model</h2><span id='topic+print.geostan_fit'></span><span id='topic+plot.geostan_fit'></span>

<h3>Description</h3>

<p>Print a summary of model results to the R console, or plot posterior distributions of model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
print(x, probs = c(0.025, 0.2, 0.5, 0.8, 0.975), digits = 3, pars = NULL, ...)

## S3 method for class 'geostan_fit'
plot(x, pars, plotfun = "hist", fill = "steelblue4", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.geostan_fit_+3A_x">x</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_probs">probs</code></td>
<td>
<p>Argument passed to <code>quantile</code>; which quantiles to calculate and print.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_pars">pars</code></td>
<td>
<p>parameters to include; a character string (or vector) of parameter names.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>rstan::plot</code> or <code>rstan::print.stanfit</code>.</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_plotfun">plotfun</code></td>
<td>
<p>Argument passed to <code>rstan::plot</code>. Options include histograms (&quot;hist&quot;), MCMC traceplots (&quot;trace&quot;), and density plots (&quot;dens&quot;). Diagnostic plots are also available such as Rhat statistics (&quot;rhat&quot;), effective sample size (&quot;ess&quot;), and MCMC autocorrelation (&quot;ac&quot;).</p>
</td></tr>
<tr><td><code id="print.geostan_fit_+3A_fill">fill</code></td>
<td>
<p>fill color for histograms and density plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The print methods writes text to the console to summarize model results. The plot method resturns a <code>ggplot</code> (from <code>rstan::plot</code> for stanfit objects).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
georgia$income &lt;- georgia$income/1e3

fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)) + log(income),
                centerx = TRUE,
                data = georgia,
                family = poisson(),
                chains = 2, iter = 600) # for speed only


# print and plot results
print(fit)
plot(fit)
</code></pre>

<hr>
<h2 id='priors'>Prior distributions</h2><span id='topic+priors'></span><span id='topic+uniform'></span><span id='topic+normal'></span><span id='topic+student_t'></span><span id='topic+gamma2'></span><span id='topic+hs'></span>

<h3>Description</h3>

<p>Prior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform(lower, upper, variable = NULL)

normal(location = 0, scale, variable = NULL)

student_t(df = 10, location = 0, scale, variable = NULL)

gamma2(alpha, beta, variable = NULL)

hs(global_scale = 1, slab_df = 10, slab_scale, variable = "beta_ev")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="priors_+3A_lower">lower</code>, <code id="priors_+3A_upper">upper</code></td>
<td>
<p>lower and upper bounds of the distribution</p>
</td></tr>
<tr><td><code id="priors_+3A_variable">variable</code></td>
<td>
<p>A reserved slot for the variable name; if provided by the user, this may be ignored by <strong>geostan</strong>.</p>
</td></tr>
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>Location parameter(s), numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>Scale parameter(s), positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_df">df</code></td>
<td>
<p>Degrees of freedom, positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_alpha">alpha</code></td>
<td>
<p>shape parameter, positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_beta">beta</code></td>
<td>
<p>inverse scale parameter, positive numeric value(s)</p>
</td></tr>
<tr><td><code id="priors_+3A_global_scale">global_scale</code></td>
<td>
<p>Control the (prior) degree of sparsity in the horseshoe model (0 &lt; global_scale &lt; 1).</p>
</td></tr>
<tr><td><code id="priors_+3A_slab_df">slab_df</code></td>
<td>
<p>Degrees of freedom for the Student's t model for large coefficients in the horseshoe model (slab_df &gt; 0).</p>
</td></tr>
<tr><td><code id="priors_+3A_slab_scale">slab_scale</code></td>
<td>
<p>Scale parameter for the Student's t model for large coefficients in the horseshoe model (slab_scale &gt; 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior distribution functions are used to set the values of prior parameters.
</p>
<p>Users can control the values of the parameters, but the distribution (model) itself is fixed. The intercept and regression coefficients are given Gaussian prior distributions and scale parameters are assigned Student's t prior distributions. Degrees of freedom parameters are assigned gamma priors, and the spatial autocorrelation parameter in the CAR model, rho, is assigned a uniform prior. The horseshoe (<code>hs</code>) model is used by <code><a href="#topic+stan_esf">stan_esf</a></code>.
</p>
<p>Note that the <code>variable</code> argument is used internally by <code>geostan</code>, and any user provided values will be ignored.
</p>


<h4>Parameterizations</h4>

<p>For details on how any distribution is parameterized, see the Stan Language Functions Reference document: <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>



<h4>The horseshoe prior</h4>

<p>The horseshoe prior is used by <code><a href="#topic+stan_esf">stan_esf</a></code> as a prior for the eigenvector coefficients. The horseshoe model encodes a prior state of knowledge that effectively states, 'I believe a small number of these variables may be important, but I don't know which of them is important.' The horseshoe is a normal distribution with unknown scale (Polson and Scott 2010):
</p>
<div class="sourceCode"><pre>       beta_j ~ Normal(0, tau^2 * lambda_j^2)
</pre></div>
<p>The scale parameter for this prior is the product of two terms: <code>lambda_j^2</code> is specific to the variable <code>beta_j</code>, and <code>tau^2</code> is known as the global shrinkage parameter.
</p>
<p>The global shrinkage parameter is assigned a half-Cauchy prior:
</p>
<div class="sourceCode"><pre>       tau ~ Cauchy(0, global_scale * sigma)
</pre></div>
<p>where <code>global_scale</code> is provided by the user and <code>sigma</code> is the scale parameter for the outcome variable; for Poisson and binomial models, sigma is fixed at one. Use <code>global_scale</code> to control the overall sparsity of the model.
</p>
<p>The second part of the model is a Student's t prior for <code>lambda_j</code>. Most <code>lambda_j</code> will be small, since the model is half-Cauchy:
</p>
<div class="sourceCode"><pre>       lambda_j ~ Cauchy(0, 1)
</pre></div>
<p>This model results in most <code>lambda_j</code> being small, but due to the long tails of the Cauchy distribution, strong evidence in the data can force any particular <code>lambda_j</code> to be large. Piironen and Vehtari (2017) adjust the model so that those large <code>lambda_j</code> are effectively assigned a Student's t model:
</p>
<div class="sourceCode"><pre>       Big_lambda_j ~ Student_t(slab_df, 0, slab_scale)
</pre></div>
<p>This is a schematic representation of the model; see Piironen and Vehtari (2017) or Donegan et al. (2020) for details.
</p>



<h3>Value</h3>

<p>An object of class <code>prior</code> which will be used internally by <strong>geostan</strong> to set parameters of prior distributions.
</p>


<h4>Student's t</h4>

<p>Return value for <code>student_t</code> depends on the input; if no arguments are provided (specifically, if the scale parameter is missing), this will return an object of class 'family'; if at least the scale parameter is provided, <code>student_t</code> will return an object of class <code>prior</code> containing parameter values for the Student's t distribution.
</p>



<h3>Source</h3>

<p>Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moran’s Eigenvectors and hierarchical shrinkage priors. <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a> (open access: <a href="https://doi.org/10.31219/osf.io/fah3z">doi:10.31219/osf.io/fah3z</a>).
</p>
<p>Polson, N.G. and J.G. Scott (2010). Shrink globally, act locally: Sparse Bayesian regularization and prediction. <em>Bayesian Statistics</em> 9, 501-538.
</p>
<p>Piironen, J and A. Vehtari (2017). Sparsity information and regularization in the horseshoe and other shrinkage priors. In <em>Electronic Journal of Statistics</em>, 11(2):5018-5051.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# normal priors for k=2 covariates
data(georgia)
prior &lt;- list()
k &lt;- 2
prior$beta &lt;- normal(location = rep(0, times = k),
                     scale = rep(2, times = k))
prior$intercept &lt;- normal(-5, 3)
print(prior)
fit &lt;- stan_glm(deaths.male ~ offset(log(pop.at.risk.male)) + log(income) + college,
                re = ~ GEOID,
                centerx = TRUE,
                data = georgia,
                family = poisson(),
                prior = prior,
                chains = 2, iter = 600) # for speed only
plot(fit)

# setting (hyper-) priors in ME models
se &lt;- data.frame(insurance = georgia$insurance.se)
prior &lt;- list()
prior$df &lt;- gamma2(3, 0.2)
prior$location &lt;- normal(50, 50)
prior$scale &lt;- student_t(12, 10, 20)
print(prior)
ME &lt;- prep_me_data(se = se, prior = prior)
fit &lt;- stan_glm(log(rate.male) ~ insurance, 
                data = georgia,
                centerx = TRUE,
                ME = ME,
               chains = 2, iter = 600) # for speed only

</code></pre>

<hr>
<h2 id='residuals.geostan_fit'>Extract residuals, fitted values, or the spatial trend</h2><span id='topic+residuals.geostan_fit'></span><span id='topic+fitted.geostan_fit'></span><span id='topic+spatial'></span><span id='topic+spatial.geostan_fit'></span>

<h3>Description</h3>

<p>Extract model residuals, fitted values, or spatial trend from a fitted <code>geostan_fit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostan_fit'
residuals(object, summary = TRUE, rates = TRUE, detrend = TRUE, ...)

## S3 method for class 'geostan_fit'
fitted(object, summary = TRUE, rates = TRUE, trend = TRUE, ...)

spatial(object, summary = TRUE, ...)

## S3 method for class 'geostan_fit'
spatial(object, summary = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.geostan_fit_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>geostan_fit</code>.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_summary">summary</code></td>
<td>
<p>Logical; should the values be summarized by their mean, standard deviation, and quantiles (<code>probs = c(.025, .2, .5, .8, .975)</code>) for each observation? Otherwise, a matrix containing samples from the posterior distributions is returned.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_rates">rates</code></td>
<td>
<p>For Poisson and Binomial models, should the fitted values be returned as rates, as opposed to raw counts? Defaults to <code>TRUE</code>; see the <code>Details</code> section for more information.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_detrend">detrend</code></td>
<td>
<p>For auto-normal models (CAR and SAR models with Gaussian likelihood only); if <code>detrend = TRUE</code>, the implicit spatial trend will be removed from the residuals. The implicit spatial trend is <code>Trend = rho * C %*% (Y - Mu)</code> (see <a href="#topic+stan_car">stan_car</a> or <a href="#topic+stan_sar">stan_sar</a>). I.e., <code>resid = Y - (Mu + Trend)</code>.</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="residuals.geostan_fit_+3A_trend">trend</code></td>
<td>
<p>For auto-normal models (CAR and SAR models with Gaussian likelihood only); if <code>trend = TRUE</code>, the fitted values will include the implicit spatial trend term. The implicit spatial trend is <code>Trend = rho * C %*% (Y - Mu)</code> (see <a href="#topic+stan_car">stan_car</a> or <a href="#topic+stan_sar">stan_sar</a>). I.e., if <code>trend = TRUE</code>, <code>fitted = Mu + Trend</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>rates = FALSE</code> and the model is Poisson or Binomial, the fitted values returned by the <code>fitted</code> method are the expected value of the response variable. The <code>rates</code> argument is used to translate count outcomes to rates by dividing by the appropriate denominator. The behavior of the <code>rates</code> argument depends on the model specification. Consider a Poisson model of disease incidence, such as the following intercept-only case:
</p>
<div class="sourceCode"><pre>fit &lt;- stan_glm(y ~ offset(log(E)),
               data = data,
               family = poisson())
</pre></div>
<p>If the fitted values are extracted using <code>rates = FALSE</code>, then <code>fitted(fit)</code> will return the expectation of <code class="reqn">y</code>. If <code>rates = TRUE</code> (the default), then <code>fitted(fit)</code> will return the expected value of the rate <code class="reqn">\frac{y}{E}</code>.
</p>
<p>If a binomial model is used instead of the Poisson, then using <code>rates = TRUE</code> will return the expectation of <code class="reqn">\frac{y}{N}</code> where <code class="reqn">N</code> is the sum of the number of 'successes' and 'failures', as in:
</p>
<div class="sourceCode"><pre>fit &lt;- stan_glm(cbind(successes, failures) ~ 1,
               data = data,
               family = binomial())
</pre></div>


<h3>Value</h3>

<p>By default, these methods return a <code>data.frame</code>. The column named <code>mean</code> is what most users will be looking for. These contain the fitted values (for the <code>fitted</code> method), the residuals (fitted values minus observed values, for the <code>resid</code> method), or the spatial trend (for the <code>spatial</code> method). The <code>mean</code> column is the posterior mean of each value, and the column <code>sd</code> contains the posterior standard deviation for each value. The posterior distributions are also summarized by select quantiles (including 2.5\
</p>
<p>If <code>summary = FALSE</code> then the method returns an S-by-N matrix of MCMC samples, where S is the number of MCMC samples and N is the number of observations in the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(georgia)
C &lt;- shape2mat(georgia, "B")

fit &lt;- stan_esf(deaths.male ~ offset(log(pop.at.risk.male)),
                C = C,
                re = ~ GEOID,
                data = georgia,
                family = poisson(),
                chains = 1, iter = 600) # for speed only


# Residuals
r &lt;- resid(fit)
head(r)
moran_plot(r$mean, C)

# Fitted values
f &lt;- fitted(fit)
head(f)

f2 &lt;- fitted(fit, rates = FALSE)
head(f2)

# Spatial trend
esf  &lt;- spatial(fit)
head(esf)

</code></pre>

<hr>
<h2 id='row_standardize'>Row-standardize a matrix; safe for zero row-sums.</h2><span id='topic+row_standardize'></span>

<h3>Description</h3>

<p>Row-standardize a matrix; safe for zero row-sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_standardize(C, warn = FALSE, msg = "Row standardizing connectivity matrix")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_standardize_+3A_c">C</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="row_standardize_+3A_warn">warn</code></td>
<td>
<p>Print message <code>msg</code> if <code>warn = TRUE</code>.</p>
</td></tr>
<tr><td><code id="row_standardize_+3A_msg">msg</code></td>
<td>
<p>A warning message; used internally by geostan.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row-standardized matrix, W (i.e., all row sums equal 1, or zero).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- shape2mat(georgia)
head(Matrix::summary(A))
Matrix::rowSums(A)

W &lt;- row_standardize(A)
head(Matrix::summary(W))
Matrix::rowSums(W)

</code></pre>

<hr>
<h2 id='se_log'>Standard error of log(x)</h2><span id='topic+se_log'></span>

<h3>Description</h3>

<p>Transform the standard error of <code>x</code> to standard error of <code>log(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se_log(x, se, method = c("mc", "delta"), nsim = 5000, bounds = c(0, Inf))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se_log_+3A_x">x</code></td>
<td>
<p>An estimate</p>
</td></tr>
<tr><td><code id="se_log_+3A_se">se</code></td>
<td>
<p>Standard error of <code>x</code></p>
</td></tr>
<tr><td><code id="se_log_+3A_method">method</code></td>
<td>
<p>The <code>"delta"</code> method uses a Taylor series approximation; the default method, <code>"mc"</code>, uses a simple monte carlo method.</p>
</td></tr>
<tr><td><code id="se_log_+3A_nsim">nsim</code></td>
<td>
<p>Number of draws to take if <code>method = "mc"</code>.</p>
</td></tr>
<tr><td><code id="se_log_+3A_bounds">bounds</code></td>
<td>
<p>Lower and upper bounds for the variable, used in the monte carlo method. Must be a length-two numeric vector with lower bound greater than or equal to zero (i.e. <code>c(lower, upper)</code> as in default <code>bounds = c(0, Inf)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delta method returns <code>x^(-1) * se</code>. The monte carlo method is detailed in the examples section.
</p>


<h3>Value</h3>

<p>Numeric vector of standard errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
x = georgia$college
se = georgia$college.se

lse1 = se_log(x, se)
lse2 = se_log(x, se, method = "delta")
plot(lse1, lse2); abline(0, 1)

# the monte carlo method
x = 10
se = 2
z = rnorm(n = 20e3, mean = x,  sd = se)
l.z = log(z)
sd(l.z)
se_log(x, se, method = "mc")
se_log(x, se, method = "delta")
</code></pre>

<hr>
<h2 id='sentencing'>Florida state prison sentencing counts by county, 1905-1910</h2><span id='topic+sentencing'></span>

<h3>Description</h3>

<p>Simple features (<code>sf</code>) with historic (1910) county boundaries of Florida with aggregated state prison sentencing counts and census data.
Sentencing and population counts are aggregates over the period 1905-1910, where populations were interpolated linearly between decennial censuses of 1900 and 1910.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentencing
</code></pre>


<h3>Format</h3>

<p>Simple features (<code>sf</code>)/<code>data.frame</code> with the following attributes:
</p>

<dl>
<dt>name</dt><dd><p>County name</p>
</dd>
<dt>wpop</dt><dd><p>White population total for years 1905-1910</p>
</dd>
<dt>bpop</dt><dd><p>Black population total for years 1905-1910</p>
</dd>
<dt>sents</dt><dd><p>Number of state prison sentences, 1905-1910</p>
</dd>
<dt>plantation_belt</dt><dd><p>Binary indicator for inclusion in the plantation belt</p>
</dd>
<dt>pct_ag_1910</dt><dd><p>Percent of land area in agriculture, 1910</p>
</dd>
<dt>expected_sents</dt><dd><p>Expected sentences given demographic information and state level sentencing rates by race</p>
</dd>
<dt>sir_raw</dt><dd><p>Standardized incident ratio (observed/expected sentences)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Donegan, Connor. &quot;The Making of Florida's 'Criminal Class': Race, Modernity and the Convict Leasing Program.&quot; Florida Historical Quarterly 97.4 (2019): 408-434. <a href="https://osf.io/2wj7s/">https://osf.io/2wj7s/</a>.
</p>
<p>Mullen, Lincoln A. and Bratt, Jordon. &quot;USABoundaries: Historical and Contemporary Boundaries of the United States of America,&quot;
Journal of Open Source Software 3, no. 23 (2018): 314, <a href="https://doi.org/10.21105/joss.00314">doi:10.21105/joss.00314</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sentencing)
print(sentencing)
</code></pre>

<hr>
<h2 id='shape2mat'>Create spatial and space-time connectivity matrices</h2><span id='topic+shape2mat'></span>

<h3>Description</h3>

<p>Creates sparse matrix representations of spatial connectivity structures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape2mat(
  shape,
  style = c("B", "W"),
  queen,
  method = c("queen", "rook", "knn"),
  k = 1,
  longlat = NULL,
  snap = sqrt(.Machine$double.eps),
  t = 1,
  st.style = c("contemp", "lag"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape2mat_+3A_shape">shape</code></td>
<td>
<p>An object of class <code>sf</code>, <code>SpatialPolygons</code> or <code>SpatialPolygonsDataFrame</code>.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_style">style</code></td>
<td>
<p>What kind of coding scheme should be used to create the spatial connectivity matrix? Defaults to &quot;B&quot; for binary; use &quot;W&quot; for row-standardized weights.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_queen">queen</code></td>
<td>
<p>Deprecated: use the &lsquo;method&rsquo; argument instead. This option is passed to <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code> to set the contiguity condition. Defaults to <code>TRUE</code> so that a single shared boundary point (rather than a shared border/line) between polygons is sufficient for them to be considered neighbors.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_method">method</code></td>
<td>
<p>Method for determining neighbors: queen, rook, or k-nearest neighbors. See Details for more information.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_k">k</code></td>
<td>
<p>Number of neighbors to select for k-nearest neighbor method. Passed to <code>spdep::knearneigh</code>.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_longlat">longlat</code></td>
<td>
<p>If longlat = TRUE, Great Circle (rather than Euclidean) distances are used; great circle circle distances account for curvature of the Earth.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_snap">snap</code></td>
<td>
<p>Passed to <code>spdep::poly2nb</code>; &quot;boundary points less than ‘snap’ distance apart are considered to indicate contiguity.&quot;</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_t">t</code></td>
<td>
<p>Number of time periods. Only the binary coding scheme is available for space-time connectivity matrices.</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_st.style">st.style</code></td>
<td>
<p>For space-time data, what type of space-time connectivity structure should be used? Options are &quot;lag&quot; for the lagged specification and &quot;contemp&quot; (the default) for contemporaneous specification (see Details).</p>
</td></tr>
<tr><td><code id="shape2mat_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, messages will be silenced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method argument currently has three options. The queen contiguity condition defines neighbors as polygons that share at least one point with one another. The rook condition requires that they share a line or border with one another. K-nearest neighbors is based on distance between centroids. All methods are implemented using the spdep package and then converted to sparse matrix format.
</p>
<p>Alternatively, one can use spdep directly to create a <code>listw</code> object and then convert that to a sparse matrix using <code>as(listw, 'CsparseMatrix')</code> for use with geostan.
</p>
<p>Haining and Li (Ch. 4) provide a helpful discussion of spatial connectivity matrices (Ch. 4).
</p>
<p>The space-time connectivity matrix can be used for eigenvector space-time filtering (<code><a href="#topic+stan_esf">stan_esf</a></code>. The 'lagged' space-time structure connects each observation to its own past (one period lagged) value and the past value of its neighbors. The 'contemporaneous' specification links each observation to its neighbors and to its own in situ past (one period lagged) value (Griffith 2012, p. 23).
</p>


<h3>Value</h3>

<p>A spatial connectivity matrix in sparse matrix format. Binary matrices are of class <code>ngCMatrix</code>, row-standardized are of class <code>dgCMatrix</code>, created by <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
</p>


<h3>Source</h3>

<p>Bivand, Roger S. and Pebesma, Edzer and Gomez-Rubio, Virgilio (2013). Applied spatial data analysis with R, Second edition. Springer, NY. https://asdar-book.org/
</p>
<p>Griffith, Daniel A. (2012). Space, time, and space-time eigenvector filter specifications that account for autocorrelation. Estadística Espanola, 54(177), 7-34.
</p>
<p>Haining, Robert P. and Li, Guangquan (2020). Modelling Spatial and Spatial-Temporal Data: A Bayesian Approach. CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges">edges</a></code> <code><a href="#topic+row_standardize">row_standardize</a></code> <code><a href="#topic+n_nbs">n_nbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)

## binary adjacency matrix
C &lt;- shape2mat(georgia, "B", method = 'rook')

## number of neighbors per observation
summary( n_nbs(C) )
head(Matrix::summary(C))

## row-standardized matrix 
W &lt;- shape2mat(georgia, "W", method = 'rook')

## summary of weights
E &lt;- edges(W, unique_pairs_only = FALSE)
summary(E$weight)

## space-time matricies 
## for eigenvector space-time filtering
## if you have multiple years with same geometry/geography,
## provide the geometry (for a single year!) and number of years \code{t}
Cst &lt;- shape2mat(georgia, t = 5)
dim(Cst)
EVst &lt;- make_EV(Cst)
dim(EVst)

</code></pre>

<hr>
<h2 id='sim_sar'>Simulate spatially autocorrelated data</h2><span id='topic+sim_sar'></span>

<h3>Description</h3>

<p>Given a spatial weights matrix and degree of autocorrelation, returns autocorrelated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_sar(
  m = 1,
  mu = rep(0, nrow(w)),
  rho,
  sigma = 1,
  w,
  type = c("SEM", "SLM"),
  approx = FALSE,
  K = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_sar_+3A_m">m</code></td>
<td>
<p>The number of samples required. Defaults to <code>m=1</code> to return an <code>n</code>-length vector; if <code>m&gt;1</code>, an <code>m x n</code> matrix is returned (i.e. each row will contain a sample of auto-correlated values).</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_mu">mu</code></td>
<td>
<p>An <code>n</code>-length vector of mean values. Defaults to a vector of zeros with length equal to <code>nrow(w)</code>.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_rho">rho</code></td>
<td>
<p>Spatial autocorrelation parameter in the range (-1, 1). A single numeric value.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter (standard deviation). Defaults to <code>sigma = 1</code>. A single numeric value.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_w">w</code></td>
<td>
<p><code>n x n</code> spatial weights matrix; typically row-standardized.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_type">type</code></td>
<td>
<p>Type of SAR model: spatial error model (&quot;SEM&quot;) or spatial lag model (&quot;SLM&quot;).</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_approx">approx</code></td>
<td>
<p>Use power of matrix W to approximate the inverse term?</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_k">K</code></td>
<td>
<p>Number of matrix powers to use if <code>approx = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_sar_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>MASS::mvrnorm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes <code>n = nrow(w)</code> draws from the normal distribution using <code>rnorm</code> to obtain vector <code>x</code>; if <code style="white-space: pre;">&#8288;type = 'SEM', it then pre-multiplies &#8288;</code>x<code style="white-space: pre;">&#8288;by the inverse of the matrix&#8288;</code>(I - rho * W)<code style="white-space: pre;">&#8288;to obtain spatially autocorrelated values. For&#8288;</code>type = 'SLM', the multiplier matrix is applied to <code>x + mu</code> to produce the desired values.
</p>
<p>The <code>approx</code> method approximates the matrix inversion using the method described by LeSage and Pace (2009, p. 40). For high values of rho, larger values of K are required for the approximation to suffice; you want <code>rho^K</code> to be near zero.
</p>


<h3>Value</h3>

<p>If <code>m = 1</code> then <code>sim_sar</code> returns a vector of the same length as <code>mu</code>, otherwise an <code>m x length(mu)</code> matrix with one sample in each row.
</p>


<h3>Source</h3>

<p>LeSage, J. and Pace, R. K. (2009). <em>An Introduction to Spatial Econometrics</em>. CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aple">aple</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+lisa">lisa</a></code>, <code><a href="#topic+shape2mat">shape2mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatially autocorrelated data on a regular grid
library(sf)
row = 10
col = 10
sar_parts &lt;- prep_sar_data2(row = row, col = col)
w &lt;- sar_parts$W
x &lt;- sim_sar(rho = 0.65, w = w)
dat &lt;- data.frame(x = x)

# create grid 
sfc = st_sfc(st_polygon(list(rbind(c(0,0), c(col,0), c(col,row), c(0,0)))))
grid &lt;- st_make_grid(sfc, cellsize = 1, square = TRUE)
st_geometry(dat) &lt;- grid
plot(dat)

# draw form SAR (SEM) model
z &lt;- sim_sar(rho = 0.9, w = w)
moran_plot(z, w)
grid$z &lt;- z

# multiple sets of observations
# each row is one N-length draw from the SAR model
x &lt;- sim_sar(rho = 0.7, w = w, m = 4)
nrow(w)
dim(x)
apply(x, 1, aple, w = w)
apply(x, 1, mc, w = w)

# Spatial lag model (SLM): y = rho*Wy + beta*x + epsilon
x &lt;- sim_sar(rho = 0.5, w = w)
y &lt;- sim_sar(mu = x, rho = 0.7, w = w, type = "SLM")

# Spatial Durbin lag model (SLM with spatial lag of x)
# SDLM: y = rho*Wy + beta*x + gamma*Wx + epsilon
x = sim_sar(w = w, rho = 0.5)
mu &lt;- -0.5*x + 0.5*(w %*% x)[,1]
y &lt;- sim_sar(mu = mu, w = w, rho = 0.6, type = "SLM")


</code></pre>

<hr>
<h2 id='sp_diag'>Visual displays of spatial data and spatial models</h2><span id='topic+sp_diag'></span><span id='topic+sp_diag.geostan_fit'></span><span id='topic+sp_diag.numeric'></span>

<h3>Description</h3>

<p>Visual diagnostics for areal data and model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_diag(y, shape, ...)

## S3 method for class 'geostan_fit'
sp_diag(
  y,
  shape,
  name = "Residual",
  plot = TRUE,
  mc_style = c("scatter", "hist"),
  style = c("W", "B"),
  w = y$C,
  rates = TRUE,
  binwidth = function(x) 0.5 * stats::sd(x, na.rm = TRUE),
  size = 0.1,
  ...
)

## S3 method for class 'numeric'
sp_diag(
  y,
  shape,
  name = "y",
  plot = TRUE,
  mc_style = c("scatter", "hist"),
  style = c("W", "B"),
  w = shape2mat(shape, match.arg(style)),
  binwidth = function(x) 0.5 * stats::sd(x, na.rm = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp_diag_+3A_y">y</code></td>
<td>
<p>A numeric vector, or a fitted <code>geostan</code> model (class <code>geostan_fit</code>).</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_shape">shape</code></td>
<td>
<p>An object of class <code>sf</code> or another spatial object coercible to <code>sf</code> with <code>sf::st_as_sf</code> such as <code>SpatialPolygonsDataFrame</code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a></code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_name">name</code></td>
<td>
<p>The name to use on the plot labels; default to &quot;y&quot; or, if <code>y</code> is a <code>geostan_fit</code> object, to &quot;Residuals&quot;.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, return a list of <code>gg</code> plots.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_mc_style">mc_style</code></td>
<td>
<p>Character string indicating how to plot the residual Moran coefficient (only used if <code>y</code> is a fitted model): if <code>mc = "scatter"</code>, then <code><a href="#topic+moran_plot">moran_plot</a></code> will be used with the marginal residuals; if <code>mc = "hist"</code>, then a histogram of Moran coefficient values will be returned, where each plotted value represents the degree of residual autocorrelation in a draw from the join posterior distribution of model parameters.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_style">style</code></td>
<td>
<p>Style of connectivity matrix; if <code>w</code> is not provided, <code>style</code> is passed to <code><a href="#topic+shape2mat">shape2mat</a></code> and defaults to &quot;W&quot; for row-standardized.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_w">w</code></td>
<td>
<p>An optional spatial connectivity matrix; if not provided and <code>y</code> is a numeric vector, one will be created using <code><a href="#topic+shape2mat">shape2mat</a></code>. If <code>w</code> is not provided and <code>y</code> is a fitted <code>geostan</code> model, then the spatial connectivity matrix that is stored with the fitted model (<code>y$C</code>) will be used.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_rates">rates</code></td>
<td>
<p>For Poisson and binomial models, convert the outcome variable to a rate before plotting fitted values and residuals. Defaults to <code>rates = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_binwidth">binwidth</code></td>
<td>
<p>A function with a single argument that will be passed to the <code>binwidth</code> argument in <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>. The default is to set the width of bins to <code>0.5 * sd(x)</code>.</p>
</td></tr>
<tr><td><code id="sp_diag_+3A_size">size</code></td>
<td>
<p>Point size and linewidth for point-interval plot of observed vs. fitted values (passed to <code><a href="ggplot2.html#topic+geom_pointrange">geom_pointrange</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When provided with a numeric vector, this function plots a histogram, Moran scatter plot, and map.
</p>
<p>When provided with a fitted <code>geostan</code> model, the function returns a point-interval plot of observed values against fitted values (mean and 95 percent credible interval), a Moran scatter plot for the model residuals, and a map of the mean posterior residuals (means of the marginal distributions). If if <code>mc_style = 'hist'</code>, the Moran scatter plot is replaced by a histogram of Moran coefficient values calculated from the joint posterior distribution of the residuals.
</p>


<h3>Value</h3>

<p>A grid of spatial diagnostic plots. If <code>plot = TRUE</code>, the <code>ggplots</code> are drawn using <a href="gridExtra.html#topic+grid.arrange">grid.arrange</a>; otherwise, they are returned in a list. For the <code>geostan_fit</code> method, the underlying data for the Moran coefficient (as required for <code>mc_style = "hist"</code>) will also be returned if <code>plot = FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+me_diag">me_diag</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+moran_plot">moran_plot</a></code>, <code><a href="#topic+aple">aple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(georgia)
sp_diag(georgia$college, georgia)

bin_fn &lt;- function(y) mad(y, na.rm = TRUE)
sp_diag(georgia$college, georgia, binwidth = bin_fn)


fit &lt;- stan_glm(log(rate.male) ~ log(income),
                data = georgia,
                centerx = TRUE,
                chains = 1, iter = 1e3) # for speed only
sp_diag(fit, georgia)

</code></pre>

<hr>
<h2 id='spill'>Spillover/diffusion effects for spatial lag models</h2><span id='topic+spill'></span><span id='topic+impacts'></span><span id='topic+print.impacts_slm'></span>

<h3>Description</h3>

<p>Spillover/diffusion effects for spatial lag models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spill(beta, gamma = 0, rho, W, approx = TRUE, K = 15)

impacts(object, approx = TRUE, K = 15)

## S3 method for class 'impacts_slm'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spill_+3A_beta">beta</code></td>
<td>
<p>Coefficient for covariates (numeric vector)</p>
</td></tr>
<tr><td><code id="spill_+3A_gamma">gamma</code></td>
<td>
<p>Coefficient for spatial lag of covariates</p>
</td></tr>
<tr><td><code id="spill_+3A_rho">rho</code></td>
<td>
<p>Spatial dependence parameter (single numeric value)</p>
</td></tr>
<tr><td><code id="spill_+3A_w">W</code></td>
<td>
<p>Spatial weights matrix</p>
</td></tr>
<tr><td><code id="spill_+3A_approx">approx</code></td>
<td>
<p>For a computationally efficient approximation to the required matrix inverse (after LeSage and Pace 2009, pp. 114&ndash;115); if <code>FALSE</code>, then a proper matrix inverse will be computed using <code>Matrix::solve</code>.</p>
</td></tr>
<tr><td><code id="spill_+3A_k">K</code></td>
<td>
<p>Degree of polynomial in the expansion to use when 'approx = TRUE'.</p>
</td></tr>
<tr><td><code id="spill_+3A_object">object</code></td>
<td>
<p>A fitted spatial lag  model (from <code>stan_sar</code>)</p>
</td></tr>
<tr><td><code id="spill_+3A_x">x</code></td>
<td>
<p>An object of class 'impacts_slm', as returned by <code>geostan::impacts</code></p>
</td></tr>
<tr><td><code id="spill_+3A_digits">digits</code></td>
<td>
<p>Round results to this many digits</p>
</td></tr>
<tr><td><code id="spill_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed to <code>base::print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods apply only to the spatial lag and spatial Durbin lag models (SLM and SDLM) as fit by <code>geostan::stan_sar</code>.
</p>
<p>The equation for these SAR models specifies simultaneous feedback between all units, such that changing the outcome in one location has a spill-over effect that may extend to all other locations (a ripple or diffusion effect); the induced changes will also react back onto the first unit. (This presumably takes time, even if the observations are cross-sectional.)
</p>
<p>These spill-overs have to be incorporated into the interpretation and reporting of the regression coefficients of SLM and SDLM models. A unit change in the value of <code class="reqn">X</code> in one location will impact <code class="reqn">y</code> in that same place ('direct' impact) and will also impact <code class="reqn">y</code> elsewhere through the diffusion process ('indirect' impact). The 'total' expected impact of a unit change in <code>X</code> is the sum of the direct and indirect effects (LeSage and Pace 2009).
</p>
<p>The <code>spill</code> function is for quickly calculating average spillover effects given point estimates of parameters.
</p>
<p>The <code>impacts</code> function calculates the (average) direct, indirect, and total effects once for every MCMC sample to produce samples from the posterior distribution for the impacts; the samples are returned together with a summary of the posterior distribution (mean, median, and select quantiles).
</p>


<h3>Source</h3>

<p>LeSage, James and Pace, R. Kelley (2009). <em>Introduction to Spatial Econometrics</em>. CRC Press.
</p>
<p>LeSage, James (2014). What Regional Scientists Need to Know about Spatial Econometrics. <em>The Review of Regional Science</em> 44: 13-32 (2014 Southern Regional Science Association Fellows Address).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## SDLM data
##

parts &lt;- prep_sar_data2(row = 9, col = 9, quiet = TRUE)
W &lt;- parts$W
x &lt;- sim_sar(w=W, rho=.6)
Wx &lt;- (W %*% x)[,1]
mu &lt;- .5 * x + .25 * Wx
y &lt;- sim_sar(w=W, rho=0.6, mu = mu, type = "SLM")
dat &lt;- cbind(y, x)

# impacts per the above parameters
spill(0.5, 0.25, 0.6, W)

##
## impacts for SDLM
##

fit &lt;- stan_sar(y ~ x, data = dat, sar = parts,
                type = "SDLM", iter = 500,
                slim = TRUE, quiet = TRUE) 

# impacts (posterior distribution)
impax &lt;- impacts(fit)
print(impax)

# plot posterior distributions
og = par(mfrow = c(1, 3),
         mar = c(3, 3, 1, 1))
S &lt;- impax$samples[[1]]
hist(S[,1], main = 'Direct')
hist(S[,2], main = 'Indirect')
hist(S[,3], main = 'Total')
par(og)

##
## The approximate method
##

# High rho value requires more K; rho^K must be near zero
Ks &lt;- c(10, 15, 20, 30, 35, 40)
print(cbind(Ks, 0.9^Ks))

# understand sensitivity of results to K when rho is high
spill(0.5, -0.25, 0.9, W, approx = TRUE, K = 10)
spill(0.5, -0.25, 0.9, W, approx = TRUE, K = 20)
spill(0.5, -0.25, 0.9, W, approx = TRUE, K = 30)
spill(0.5, -0.25, 0.9, W, approx = TRUE, K = 50)

# the correct results
spill(0.5, -0.25, 0.9, W, approx = FALSE)

# moderate and low rho values are fine with smaller K
spill(0.5, -0.25, 0.7, W, approx = TRUE, K = 15)
spill(0.5, -0.25, 0.7, W, approx = FALSE)

</code></pre>

<hr>
<h2 id='stan_car'>Conditional autoregressive (CAR) models</h2><span id='topic+stan_car'></span>

<h3>Description</h3>

<p>Use the CAR model as a prior on parameters, or fit data to a spatial Gaussian CAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_car(
  formula,
  slx,
  re,
  data,
  C,
  car_parts = prep_car_data(C, "WCAR"),
  family = gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  censor_point,
  zmp,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_car_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <code><a href="stats.html#topic+formula">formula</a></code> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div>
<p>With the CAR model, any <code>alpha_re</code> term should be at a <em>different</em> level or scale than the observations; that is, at a different scale than the autocorrelation structure of the CAR model itself.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix which will be used internally to create <code>car_parts</code> (if <code>car_parts</code> is missing); if the user provides an <code>slx</code> formula for the model, the required connectivity matrix will be taken from the <code>car_parts</code> list. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_car_parts">car_parts</code></td>
<td>
<p>A list of data for the CAR model, as returned by <code><a href="#topic+prep_car_data">prep_car_data</a></code>. If not provided by the user, then <code>C</code> will automatically be passed to <code>prep_car_data</code> to create it.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>auto_gaussian()</code>, <code>binomial(link = "logit")</code>, and <code>poisson(link = "log")</code>; if <code>family = gaussian()</code> is provided, it will automatically be converted to <code>auto_gaussian()</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>car_scale</dt><dd><p>Scale parameter for the CAR model, <code>car_scale</code>. The scale is assigned a Student's t prior model (constrained to be positive).</p>
</dd>
<dt>car_rho</dt><dd><p>The spatial autocorrelation parameter in the CAR model, <code>rho</code>, is assigned a uniform prior distribution. By default, the prior will be uniform over all permissible values as determined by the eigenvalues of the connectivity matrix, <code>C</code>. The range of permissible values for <code>rho</code> is automatically printed to the console by <code><a href="#topic+prep_car_data">prep_car_data</a></code>.</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for any varying intercepts (a.k.a exchangeable random effects, or partial pooling) terms. This scale parameter, <code>tau</code>, is assigned a Student's t prior (constrained to be positive).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_car_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_prior_only">prior_only</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, draw samples only from the prior distributions of parameters.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_zmp">zmp</code></td>
<td>
<p>Use zero-mean parameterization for the CAR model? Only relevant for Poisson and binomial outcome models (i.e., hierarchical models). See details below; this can sometimes improve MCMC sampling when the data is sparse, but does not alter the model specification.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to use.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from CAR models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>log_lambda_mu</dt><dd><p>Linear predictor inside the CAR model (for Poisson and binomial models)</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
</dl>

<p>If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <code><a href="rstan.html#topic+stan">stan</a></code> for details.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_quiet">quiet</code></td>
<td>
<p>Controls (most) automatic printing to the console. By default, any prior distributions that have not been assigned by the user are printed to the console. If <code>quiet = TRUE</code>, these will not be printed. Using <code>quiet = TRUE</code> will also force <code>refresh = 0</code>.</p>
</td></tr>
<tr><td><code id="stan_car_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CAR models are discussed in Cressie and Wikle (2011, p. 184-88), Cressie (2015, Ch. 6-7), and Haining and Li (2020, p. 249-51). It is often used for areal or lattice data.
</p>
<p>Details for the Stan code for this implementation of the CAR model can be found in Donegan (2021) and the geostan vignette 'Custom spatial models with Rstan and geostan'.
</p>
<p>For outcome variable <code class="reqn">y</code> and N-by-N connectivity matrix <code class="reqn">C</code>, a standard spatial CAR model may be written as
</p>
<p style="text-align: center;"><code class="reqn">
 y = \mu + \rho C (y - \mu) + \epsilon
</code>
</p>

<p>where <code class="reqn">\rho</code> is a spatial dependence or autocorrelation parameter. The models accounts for autocorrelated errors in the regression.
</p>
<p>The model is defined by its covariance matrix. The general scheme for the CAR model is as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 y \sim Gauss( \mu, ( I - \rho C)^{-1} M),
</code>
</p>

<p>where <code class="reqn">I</code> is the identity matrix, <code class="reqn">\rho</code> is a spatial dependence parameter, <code class="reqn">C</code> is a spatial connectivity matrix, and <code class="reqn">M</code> is a diagonal matrix of variance terms. The diagonal of <code class="reqn">M</code> contains a scale parameter <code class="reqn">\tau</code> multiplied by a vector of weights (often set to be proportional to the inverse of the number of neighbors assigned to each site).
</p>
<p>The covariance matrix of the CAR model contains two parameters: <code class="reqn">\rho</code> (<code>car_rho</code>) which controls the kind (positive or negative) and degree of spatial autocorrelation, and the scale parameter <code class="reqn">\tau</code>. The range of permissible values for <code class="reqn">\rho</code> depends on the specification of <code class="reqn">\boldsymbol C</code> and <code class="reqn">\boldsymbol M</code>; for specification options, see <a href="#topic+prep_car_data">prep_car_data</a> and Cressie and Wikle (2011, pp. 184-188) or Donegan (2021).
</p>
<p>Further details of the models and results depend on the <code>family</code> argument, as well as on the particular CAR specification chosen (from <a href="#topic+prep_car_data">prep_car_data</a>).
</p>


<h4>Auto-Normal</h4>

<p>When <code>family = auto_gaussian()</code> (the default), the CAR model is applied directly to the data as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 y \sim Gauss( \mu, (I - \rho C)^{-1} M),
</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean vector (with intercept, covariates, etc.), <code class="reqn">C</code> is a spatial connectivity matrix, and <code class="reqn">M</code> is a known diagonal matrix containing the conditional variances <code class="reqn">\tau_i^2</code>. <code class="reqn">C</code> and <code class="reqn">M</code> are provided by <a href="#topic+prep_car_data">prep_car_data</a>.
</p>
<p>The auto-Gaussian model contains an implicit spatial trend (i.e. autocorrelation) component <code class="reqn">\phi</code> which can be calculated as follows (Cressie 2015, p. 564):
</p>
<p style="text-align: center;"><code class="reqn">
 \phi = \rho C (y - \mu).
</code>
</p>

<p>This term can be extracted from a fitted auto-Gaussian model using the <a href="#topic+spatial">spatial</a> method.
</p>
<p>When applied to a fitted auto-Gaussian model, the <a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a> method returns 'de-trended' residuals <code class="reqn">R</code> by default. That is,
</p>
<p style="text-align: center;"><code class="reqn">
R = y - \mu - \rho C (y - \mu).
</code>
</p>

<p>To obtain &quot;raw&quot; residuals (<code class="reqn">y - \mu</code>), use <code>residuals(fit, detrend = FALSE)</code>. Similarly, the fitted values obtained from the <a href="#topic+fitted.geostan_fit">fitted.geostan_fit</a> will include the spatial trend term by default.
</p>



<h4>Poisson</h4>

<p>For <code>family = poisson()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \lambda})</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda \sim Gauss(\mu, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>If the raw outcome consists of a rate <code class="reqn">\frac{y}{p}</code> with observed counts <code class="reqn">y</code> and denominator <code class="reqn">p</code> (often this will be the size of the population at risk), then the offset term <code class="reqn">O=log(p)</code> is the log of the denominator.
</p>
<p>The same model can also be described or specified such that <code class="reqn">\phi</code> has a mean of zero:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \mu + \phi})</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi \sim Gauss(0, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>This is the zero-mean parameterization (ZMP) of the CAR model; although the non-ZMP is typically better for MCMC sampling, use of the ZMP can greatly improve MCMC sampling <em>when the data is sparse</em>. Use <code>zmp = TRUE</code> in <code>stan_car</code> to apply this specification. (See the geostan vignette on 'custom spatial models' for full details on implementation of the ZMP.)
</p>
<p>For all CAR Poisson models, the <a href="#topic+spatial">spatial</a> method returns the (zero-mean) parameter vector <code class="reqn">\phi</code>. When <code>zmp = FALSE</code> (the default), <code class="reqn">phi</code> is obtained by subtraction: <code class="reqn">\phi = \lambda - \mu</code>.
</p>
<p>In the Poisson CAR model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it: <code class="reqn">\phi_i = \rho \sum_{i=1}^n c_{ij} \phi_j + \epsilon_i</code>, where <code class="reqn">\epsilon_i \sim Gauss(0, \tau_i^2)</code>. If for some reason you would like to extract the smoother latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating (following Cressie 2015, p. 564):
</p>
<p style="text-align: center;"><code class="reqn">\rho  C  \phi.</code>
</p>




<h4>Binomial</h4>

<p>For <code>family = binomial()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Binomial(N, \lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\lambda) \sim Gauss(\mu, (I - \rho C)^{-1} \boldsymbol M).</code>
</p>

<p>where outcome data <code class="reqn">y</code> are counts, <code class="reqn">N</code> is the number of trials, <code class="reqn">\lambda</code> is the 'success' rate, and <code class="reqn">\mu</code> contains the intercept and possibly covariates. Note that the model formula should be structured as: <code>cbind(sucesses, failures) ~ x</code>, such that <code>trials = successes + failures</code>.
</p>
<p>As is also the case for the Poisson model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it. If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating:
</p>
<p style="text-align: center;"><code class="reqn">
\rho C \phi.
</code>
</p>

<p>The zero-mean parameterization (ZMP) of the CAR model can also be applied here (see the Poisson model for details); ZMP provides an equivalent model specification that can improve MCMC sampling when data is sparse.
</p>



<h4>Additional functionality</h4>

<p>The CAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), missing outcome data, and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame.</p>
</dd>
<dt>diagnostic</dt><dd><p>Residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including CAR component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>, the varying intercepts (<code>re</code>) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial component parameter (either &quot;phi&quot; or, for auto Gaussian models, &quot;trend&quot;) and method (&quot;CAR&quot;)</p>
</dd>
<dt>ME</dt><dd><p>A list indicating if the object contains an ME model; if so, the user-provided ME list is also stored here.</p>
</dd>
<dt>C</dt><dd><p>Spatial connectivity matrix (in sparse matrix format).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Besag, Julian (1974). Spatial interaction and the statistical analysis of lattice systems. <em>Journal of the Royal Statistical Society</em> B36.2: 192–225.
</p>
<p>Cressie, Noel (2015 (1993)). <em>Statistics for Spatial Data</em>. Wiley Classics, Revised Edition.
</p>
<p>Cressie, Noel and Wikle, Christopher (2011). <em>Statistics for Spatio-Temporal Data</em>. Wiley.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Haining, Robert and Li, Guangquan (2020). <em>Modelling Spatial and Spatial-Temporal Data: A Bayesian Approach</em>. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## model mortality risk
##

# simple spatial model for log rates

data(georgia)
C &lt;- shape2mat(georgia, style = "B")
cars &lt;- prep_car_data(C)

# MCMC specs: set for purpose of demo speed 
iter = 500
chains = 2

fit &lt;- stan_car(log(rate.male) ~ 1, data = georgia,
          car_parts = cars, iter = iter, chains = chains)

# model diagnostics
sp_diag(fit, georgia)

# A more appropriate model for mortality rates:
# hierarchical spatial Poisson model
fit &lt;- stan_car(deaths.male ~ offset(log(pop.at.risk.male)),
                car_parts = cars,
                data = georgia,
                family = poisson(),
                iter = iter, chains = chains)

# model diagnostics
sp_diag(fit, georgia)

# county mortality rates
eta = fitted(fit)

# spatial trend component
phi = spatial(fit)



##
## Distance-based weights matrix:
##   the 'DCAR' model
##

library(sf)
A &lt;- shape2mat(georgia, "B")
D &lt;- sf::st_distance(sf::st_centroid(georgia))
D &lt;- D * A
dcars &lt;- prep_car_data(D, "DCAR", k = 1)

Dfit &lt;- stan_car(deaths.male ~ offset(log(pop.at.risk.male)),
               data = georgia,
               car = dcars,
               family = poisson(),
               iter = iter, chains = chains)

sp_diag(Dfit, georgia, dcars$C)
dic(Dfit); dic(fit)



</code></pre>

<hr>
<h2 id='stan_esf'>Spatial filtering</h2><span id='topic+stan_esf'></span>

<h3>Description</h3>

<p>Fit a spatial regression model using eigenvector spatial filtering (ESF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_esf(
  formula,
  slx,
  re,
  data,
  C,
  EV = make_EV(C, nsa = nsa, threshold = threshold),
  nsa = FALSE,
  threshold = 0.25,
  family = gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  censor_point,
  prior_only = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_esf_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <code><a href="stats.html#topic+formula">formula</a></code> syntax. Binomial models are specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div></td></tr>
<tr><td><code id="stan_esf_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix. This will be used to calculate eigenvectors if <code>EV</code> is not provided by the user. See <code><a href="#topic+shape2mat">shape2mat</a></code>. Use of row-normalization (as in '<code>shape2mat(shape, 'W')</code> is not recommended for creating <code>EV</code>. Matrix <code>C</code> will also be used ('as is') to create any user-specified <code>slx</code> terms.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_ev">EV</code></td>
<td>
<p>A matrix of eigenvectors from any (transformed) connectivity matrix, presumably spatial or network-based (see <code><a href="#topic+make_EV">make_EV</a></code>). If <code>EV</code> is provided, still also provide a spatial weights matrix <code>C</code> for other purposes; <code>threshold</code> and <code>nsa</code> are ignored for user provided <code>EV</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_nsa">nsa</code></td>
<td>
<p>Include eigenvectors representing negative spatial autocorrelation? Defaults to <code>nsa = FALSE</code>. This is ignored if <code>EV</code> is provided.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_threshold">threshold</code></td>
<td>
<p>Eigenvectors with standardized Moran coefficient values below this <code>threshold</code> value will be excluded from the candidate set of eigenvectors, <code>EV</code>. This defaults to <code>threshold = 0.25</code>, and is ignored if <code>EV</code> is provided.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>family = gaussian()</code>, <code>student_t()</code> and <code>poisson(link = "log")</code>, and <code>binomial(link = "logit")</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):  </p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sigma</dt><dd><p>For <code>family = gaussian()</code> and <code>family = student_t()</code> models, the scale parameter, <code>sigma</code>, is assigned a (half-) Student's t prior distribution. The half-Student's t prior for <code>sigma</code> is constrained to be positive.</p>
</dd>
<dt>nu</dt><dd><p><code>nu</code> is the degrees of freedom parameter in the Student's t likelihood (only used when <code>family = student_t()</code>). <code>nu</code> is assigned a gamma prior distribution. The default prior is <code>prior = list(nu = gamma2(alpha = 3, beta = 0.2))</code>. </p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for random effects, or varying intercepts, terms. This scale parameter, <code>tau</code>, is assigned a half-Student's t prior. To set this, use, e.g., <code>prior = list(tau = student_t(df = 20, location = 0, scale = 20))</code>.</p>
</dd>
<dt>beta_ev</dt><dd><p>The eigenvector coefficients are assigned the horseshoe prior (Piironen and Vehtari, 2017), parameterized by <code>global_scale</code> (to control overall prior sparsity), plus the degrees of freedom and scale of a Student's t model for any large coefficients (see <code><a href="#topic+priors">priors</a></code>). To allow the spatial filter to account for a greater amount of spatial autocorrelation (i.e., if you find the residuals contain spatial autocorrelation), increase the global scale parameter (to a maximum of <code>global_scale = 1</code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_esf_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths. For example, the US Centers for Disease Control and Prevention censors (does not report) death counts that are nine or fewer, so if you're using CDC WONDER mortality data you could provide <code>censor_point = 9</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_prior_only">prior_only</code></td>
<td>
<p>Draw samples from the prior distributions of parameters only.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to estimate. Default <code>chains = 4</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain. Default <code>iter = 2000</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Defaults to <code>500</code>; set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is useful for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from ESF models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
<dt>esf</dt><dd><p>The N-length eigenvector spatial filter.</p>
</dd>
<dt>beta_ev</dt><dd><p>The vector of coefficients for the eigenvectors.</p>
</dd>
</dl>

<p>If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_quiet">quiet</code></td>
<td>
<p>By default, any prior distributions that have not been assigned by the user are printed to the console. If <code>quiet = TRUE</code>, these will not be printed.</p>
</td></tr>
<tr><td><code id="stan_esf_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="rstan.html#topic+sampling">sampling</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eigenvector spatial filtering (ESF) is a method for spatial regression analysis. ESF is extensively covered in Griffith et al. (2019). This function implements the methodology introduced in Donegan et al. (2020), which uses Piironen and Vehtari's (2017) regularized horseshoe prior.
</p>
<p>By adding a spatial filter to a regression model, spatial autocorrelation patterns are shifted from the residuals to the spatial filter. ESF models take the spectral decomposition of a transformed spatial connectivity matrix, <code class="reqn">C</code>. The resulting eigenvectors, <code class="reqn">E</code>, are mutually orthogonal and uncorrelated map patterns (at various scales, 'local' to 'regional' to 'global'). The spatial filter equals <code class="reqn">E \beta_{E}</code> where <code class="reqn">\beta_{E}</code> is a vector of coefficients.
</p>
<p>ESF decomposes the data into a global mean, <code class="reqn">\alpha</code>, global patterns contributed by covariates <code class="reqn">X \beta</code>, spatial trends <code class="reqn">E \beta_{E}</code>, and residual variation. Thus, for <code>family=gaussian()</code>,
</p>
<p style="text-align: center;"><code class="reqn">
y \sim Gauss(\alpha + X * \beta + E \beta_{E}, \sigma).
</code>
</p>

<p>An ESF component can be incorporated into the linear predictor of any generalized linear model. For example, using <code>stan_esf</code> with <code>family = poisson()</code> and adding a 'random effects' term for each spatial unit (via the <code>re</code> argument) will produce a model that resembles the BYM model (combining spatially structured and spatially-unstructured components).
</p>
<p>The <a href="#topic+spatial.geostan_fit">spatial.geostan_fit</a> method will return <code class="reqn">E \beta_{E}</code>.
</p>
<p>The model can also be extended to the space-time domain; see <a href="#topic+shape2mat">shape2mat</a> to specify a space-time connectivity matrix.
</p>
<p>The coefficients <code class="reqn">\beta_{E}</code> are assigned the regularized horseshoe prior (Piironen and Vehtari, 2017), resulting in a relatively sparse model specification. In addition, numerous eigenvectors are automatically dropped because they represent trace amounts of spatial autocorrelation (this is controlled by the <code>threshold</code> argument). By default, <code>stan_esf</code> will drop all eigenvectors representing negative spatial autocorrelation patterns. You can change this behavior using the <code>nsa</code> argument.
</p>


<h4>Additional functionality</h4>

<p>The ESF models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), missing outcome data, and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame</p>
</dd>
<dt>diagnostic</dt><dd><p>Residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>EV</dt><dd><p>A matrix of eigenvectors created with <code>w</code> and <code>geostan::make_EV</code></p>
</dd>
<dt>C</dt><dd><p>The spatial weights matrix used to construct EV</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including ESF component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>,  the random effects (varying intercepts) formula if provided, and
<code>data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>ME</dt><dd><p>The <code>ME</code> data list, if one was provided by the user for measurement error models.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial component parameter (&quot;esf&quot;) and method (&quot;ESF&quot;)</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Chun, Y., D. A. Griffith, M. Lee and P. Sinha (2016). Eigenvector selection with stepwise regression techniques to construct eigenvector spatial filters. <em>Journal of Geographical Systems</em>, 18(1), 67-85. <a href="https://doi.org/10.1007/s10109-015-0225-3">doi:10.1007/s10109-015-0225-3</a>.
</p>
<p>Dray, S., P. Legendre &amp; P. R. Peres-Neto (2006). Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM). <em>Ecological Modeling</em>, 196(3-4), 483-493.
</p>
<p>Donegan, C., Y. Chun and A. E. Hughes (2020). Bayesian estimation of spatial filters with Moran’s Eigenvectors and hierarchical shrinkage priors. <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2020.100450">doi:10.1016/j.spasta.2020.100450</a> (open access: <a href="https://doi.org/10.31219/osf.io/fah3z">doi:10.31219/osf.io/fah3z</a>).
</p>
<p>Griffith, Daniel A., and P. R. Peres-Neto (2006). Spatial modeling in ecology: the flexibility of eigenfunction spatial analyses. <em>Ecology</em> 87(10), 2603-2613.
</p>
<p>Griffith, D., and Y. Chun (2014). Spatial autocorrelation and spatial filtering, Handbook of Regional Science. Fischer, MM and Nijkamp, P. eds.
</p>
<p>Griffith, D., Chun, Y. and Li, B. (2019). <em>Spatial Regression Analysis Using Eigenvector Spatial Filtering</em>. Elsevier.
</p>
<p>Piironen, J and A. Vehtari (2017). Sparsity information and regularization in the horseshoe and other shrinkage priors. In <em>Electronic Journal of Statistics</em>, 11(2):5018-5051.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sentencing)
# spatial weights matrix with binary coding scheme
C &lt;- shape2mat(sentencing, style = "B", quiet = TRUE)

# expected number of sentences
log_e &lt;- log(sentencing$expected_sents)

# fit spatial Poisson model with ESF + unstructured 'random effects'
fit.esf &lt;- stan_esf(sents ~ offset(log_e),
                   re = ~ name,
                   family = poisson(),
                   data = sentencing,
                   C = C, 
                   chains = 2, iter = 800) # for speed only

# spatial diagnostics 
sp_diag(fit.esf, sentencing)

# plot marginal posterior distributions of beta_ev (eigenvector coefficients)
plot(fit.esf, pars = "beta_ev")

# calculate log-standardized incidence ratios (SIR)
#  # SIR = observed/exected number of cases
# in this case, prison sentences
library(ggplot2)
library(sf)
f &lt;- fitted(fit.esf, rates = FALSE)$mean
SSR &lt;-  f / sentencing$expected_sents
log.SSR &lt;- log( SSR, base = 2 )

# map the log-SSRs
 ggplot(sentencing) +
   geom_sf(aes(fill = log.SSR)) +
   scale_fill_gradient2(
    midpoint = 0,
    name = NULL,
    breaks = seq(-3, 3, by = 0.5)
  ) +
   labs(title = "Log-Standardized Sentencing Ratios",
    subtitle = "log( Fitted/Expected ), base 2"
 ) +
   theme_void()

</code></pre>

<hr>
<h2 id='stan_glm'>Generalized linear models</h2><span id='topic+stan_glm'></span>

<h3>Description</h3>

<p>Fit a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_glm(
  formula,
  slx,
  re,
  data,
  C,
  family = gaussian(),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  censor_point,
  chains = 4,
  iter = 2000,
  refresh = 1000,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_glm_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <a href="stats.html#topic+formula">formula</a> syntax. Binomial models are specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div></td></tr>
<tr><td><code id="stan_glm_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix which will be used to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>poisson(link = "log")</code>, <code>binomial(link = "logit")</code>, <code>student_t()</code>, and the default <code>gaussian()</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sigma</dt><dd><p>For <code>family = gaussian()</code> and <code>family = student_t()</code> models, the scale parameter, <code>sigma</code>, is assigned a (half-) Student's t prior distribution. The half-Student's t prior for <code>sigma</code> is constrained to be positive.</p>
</dd>
<dt>nu</dt><dd><p><code>nu</code> is the degrees of freedom parameter in the Student's t likelihood (only used when <code>family = student_t()</code>). <code>nu</code> is assigned a gamma prior distribution. The default prior is <code>prior = list(nu = gamma2(alpha = 3, beta = 0.2))</code>.
</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for random effects, or varying intercepts, terms. This scale parameter, <code>tau</code>, is assigned a half-Student's t prior. To set this, use, e.g., <code>prior = list(tau = student_t(df = 20, location = 0, scale = 20))</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_glm_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_only">prior_only</code></td>
<td>
<p>Draw samples from the prior distributions of parameters only.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths. For example, the US Centers for Disease Control and Prevention censors (does not report) death counts that are nine or fewer, so if you're using CDC WONDER mortality data you could provide <code>censor_point = 9</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to estimate.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples; set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is required if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from GLM models:
</p>

<dl>
<dt>'fitted'</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>'alpha_re'</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>'x_true'</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
</dl>

<p>Using <code>drop = c('fitted', 'alpha_re', 'x_true')</code> is equivalent to <code>slim = TRUE</code>. If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_pars">pars</code></td>
<td>
<p>Specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_quiet">quiet</code></td>
<td>
<p>Controls (most) automatic printing to the console. By default, any prior distributions that have not been assigned by the user are printed to the console. If <code>quiet = TRUE</code>, these will not be printed. Using <code>quiet = TRUE</code> will also force <code>refresh = 0</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="rstan.html#topic+sampling">sampling</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a generalized linear model using the R formula interface. Default prior distributions are designed to be weakly informative relative to the data. Much of the functionality intended for spatial models, such as the ability to add spatially lagged covariates and observational error models, are also available in <code>stan_glm</code>. All of <code>geostan</code>'s spatial models build on top of the same Stan code used in <code>stan_glm</code>.
</p>


<h4>Spatially lagged covariates (SLX)</h4>

<p>The <code>slx</code> argument is a convenience function for including SLX terms. For example,
</p>
<p style="text-align: center;"><code class="reqn">
 y = W X \gamma + X \beta + \epsilon
</code>
</p>

<p>where <code class="reqn">W</code> is a row-standardized spatial weights matrix (see <code><a href="#topic+shape2mat">shape2mat</a></code>), <code class="reqn">WX</code> is the mean neighboring value of <code class="reqn">X</code>, and <code class="reqn">\gamma</code> is a coefficient vector. This specifies a regression with spatially lagged covariates. SLX terms can specified by providing a formula to the <code>slx</code> argument:
</p>
<div class="sourceCode"><pre>stan_glm(y ~ x1 + x2, slx = ~ x1 + x2, \...),
</pre></div>
<p>which is a shortcut for
</p>
<div class="sourceCode"><pre>stan_glm(y ~ I(W \%*\% x1) + I(W \%*\% x2) + x1 + x2, \...)
</pre></div>
<p>SLX terms will always be <em>prepended</em> to the design matrix, as above, which is important to know when setting prior distributions for regression coefficients.
</p>
<p>For measurement error (ME) models, the SLX argument is the only way to include spatially lagged covariates since the SLX term needs to be re-calculated on each iteration of the MCMC algorithm.
</p>



<h4>Measurement error (ME) models</h4>

<p>The ME models are designed for surveys with spatial sampling designs, such as the American Community Survey (ACS) estimates. For a tutorial, see <code>vignette("spatial-me-models", package = "geostan")</code>.
</p>
<p>Given estimates <code class="reqn">x</code>, their standard errors <code class="reqn">s</code>, and the target quantity of interest (i.e., the unknown true value) <code class="reqn">z</code>, the ME models have one of the the following two specifications, depending on the user input. If a spatial CAR model is specified, then:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">z \sim Gauss(\mu_z, \Sigma_z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma_z = (I - \rho C)^{-1} M</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_z \sim Gauss(0, 100)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_z \sim Student(10, 0, 40), \tau &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\rho_z \sim uniform(l, u)</code>
</p>

<p>where <code class="reqn">\Sigma</code> specifies the covariance matrix of a spatial conditional autoregressive (CAR) model with scale parameter <code class="reqn">\tau</code> (on the diagonal of <code class="reqn">M</code>), autocorrelation parameter <code class="reqn">\rho</code>, and <code class="reqn">l</code>, <code class="reqn">u</code> are the lower and upper bounds that <code class="reqn">\rho</code> is permitted to take (which is determined by the extreme eigenvalues of the spatial connectivity matrix <code class="reqn">C</code>). <code class="reqn">M</code> contains the inverse of the row sums of <code class="reqn">C</code> on its diagonal multiplied by <code class="reqn">\tau</code> (following the &quot;WCAR&quot; specification).
</p>
<p>For non-spatial ME models, the following is used instead:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">z \sim student_t(\nu_z, \mu_z, \sigma_z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu_z \sim gamma(3, 0.2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_z \sim Gauss(0, 100)</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_z \sim student(10, 0, 40)</code>
</p>

<p>For strongly skewed variables, such as census tract poverty rates, it can be advantageous to apply a logit transformation to <code class="reqn">z</code> before applying the CAR or Student-t prior model. When the <code>logit</code> argument is used, the first two lines of the model specification become:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(z) \sim Gauss(\mu_z, \Sigma_z) </code>
</p>

<p>and similarly for the Student t model:
</p>
<p style="text-align: center;"><code class="reqn">x \sim Gauss(z, s^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(z) \sim student(\nu_z, \mu_z, \sigma_z)</code>
</p>




<h4>Missing data</h4>

<p>For most geostan models, missing (NA) observations are allowed in the outcome variable. However, there cannot be any missing covariate data. Models that can handle missing data are: any Poisson or binomial model (GLM, SAR, CAR, ESF, ICAR), all GLMs and ESF models. The only models that cannot handle missing outcome data are the CAR and SAR models when the outcome is a continuous variable (auto-normal/Gaussian models).
</p>
<p>When observations are missing, they will simply be ignored when calculating the likelihood in the MCMC sampling process (reflecting the absence of information). The estimated model parameters (including any covariates and spatial trend) will then be used to produce estimates or fitted values for the missing observations. The <code>fitted</code> and <code>posterior_predict</code> functions will work as normal in this case, and return values for all rows in your data.
</p>



<h4>Censored counts</h4>

<p>Vital statistics systems and disease surveillance programs typically suppress case counts when they are smaller than a specific threshold value. In such cases, the observation of a censored count is not the same as a missing value; instead, you are informed that the value is an integer somewhere between zero and the threshold value. For Poisson models (<code style="white-space: pre;">&#8288;family = poisson())&#8288;</code>), you can use the <code>censor_point</code> argument to encode this information into your model.
</p>
<p>Internally, <code>geostan</code> will keep the index values of each censored observation, and the index value of each of the fully observed outcome values. For all observed counts, the likelihood statement will be:
</p>
<p style="text-align: center;"><code class="reqn">
p(y_i | data, model) = poisson(y_i | \mu_i), 
</code>
</p>

<p>as usual, where <code class="reqn">\mu_i</code> may include whatever spatial terms are present in the model.
</p>
<p>For each censored count, the likelihood statement will equal the cumulative Poisson distribution function for values zero through the censor point:
</p>
<p style="text-align: center;"><code class="reqn">
p(y_i | data, model) = \sum_{m=0}^{M} Poisson( m | \mu_i),
</code>
</p>

<p>where <code class="reqn">M</code> is the censor point and <code class="reqn">\mu_i</code> again is the fitted value for the <code class="reqn">i^{th}</code> observation.
</p>
<p>For example, the US Centers for Disease Control and Prevention's CDC WONDER database censors all death counts between 0 and 9. To model CDC WONDER mortality data, you could provide <code>censor_point = 9</code> and then the likelihood statement for censored counts would equal the summation of the Poisson probability mass function over each integer ranging from zero through 9 (inclusive), conditional on the fitted values (i.e., all model parameters). See Donegan (2021) for additional discussion, references, and Stan code.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame</p>
</dd>
<dt>diagnostic</dt><dd><p>Residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including ESF component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>C</dt><dd><p>The spatial weights matrix, if one was provided by the user.</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>, the random effects (varying intercepts) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>ME</dt><dd><p>The <code>ME</code> data list, if one was provided by the user for measurement error models.</p>
</dd>
<dt>spatial</dt><dd><p>NA, slot is maintained for use in <code>geostan_fit</code> methods.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Donegan, Connor and Chun, Yongwan and Griffith, Daniel A. (2021). Modeling community health with areal data: Bayesian inference with survey standard errors and spatial structure. <em>Int. J. Env. Res. and Public Health</em> 18 (13): 6856. DOI: 10.3390/ijerph18136856 Data and code: <a href="https://github.com/ConnorDonegan/survey-HBM">https://github.com/ConnorDonegan/survey-HBM</a>.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Linear regression model
##

N = 100
x &lt;- rnorm(N)
y &lt;- .5 * x + rnorm(N)
dat &lt;- cbind(y, x)

# no. of MCMC samples
iter = 600

# fit model
fit &lt;- stan_glm(y ~ x, data = dat, iter = iter, quiet = TRUE)

# see results with MCMC diagnostics
print(fit)

##
## Custom prior distributions
##

PL &lt;- list(
      intercept = normal(0, 1),
      beta = normal(0, 1),
      sigma = student_t(10, 0, 2)
)

fit2 &lt;- stan_glm(y ~ x, data = dat, prior = PL, iter = iter,
                quiet = TRUE)

print(fit2)

# example prior for two covariates
pl &lt;- list(beta = normal(c(0, 0),
                         c(1, 1))
           )

##
## Poisson model for count data
## with county 'random effects' 
##

data(sentencing)

# note: 'name' is county identifier
head(sentencing)

# denominator in standardized rate Y/E
# (observed count Y over expected count E)
# (use the log-denominator as the offest term)
sentencing$log_e &lt;- log(sentencing$expected_sents)

# fit model
fit.pois &lt;- stan_glm(sents ~ offset(log_e),
                     re = ~ name,
                     family = poisson(),
                     data = sentencing,                    
                    iter = iter, quiet = TRUE) 

# Spatial autocorrelation/residual diagnostics
sp_diag(fit.pois, sentencing)

# summary of results with MCMC diagnostics
print(fit.pois)


# MCMC diagnostics plot: Rhat values should all by very near 1
rstan::stan_rhat(fit.pois$stanfit)


# effective sample size for all parameters and generated quantities
# (including residuals, predicted values, etc.)
rstan::stan_ess(fit.pois$stanfit)

# or for a particular parameter
rstan::stan_ess(fit.pois$stanfit, "alpha_re")


##
## Visualize the posterior predictive distribution
##

# plot observed values and model replicate values
yrep &lt;- posterior_predict(fit.pois, S = 65)
y &lt;- sentencing$sents
ltgray &lt;- rgb(0.3, 0.3, 0.3, 0.5)

plot(density(yrep[1,]), col = ltgray,
     ylim = c(0, 0.014), xlim = c(0, 700),
     bty = 'L', xlab = NA, main = NA)

for (i in 2:nrow(yrep)) lines(density(yrep[i,]), col = ltgray)

lines(density(sentencing$sents), col = "darkred", lwd = 2)

legend("topright", legend = c('Y-observed', 'Y-replicate'),
       col = c('darkred', ltgray), lwd = c(1.5, 1.5))

# plot replicates of Y/E
E &lt;- sentencing$expected_sents

# set plot margins
old_pars &lt;- par(mar=c(2.5, 3.5, 1, 1))

# plot yrep
plot(density(yrep[1,] / E), col = ltgray,
    ylim = c(0, 0.9), xlim = c(0, 7),
    bty = 'L', xlab = NA, ylab = NA, main = NA)

for (i in 2:nrow(yrep)) lines(density(yrep[i,] / E), col = ltgray)

# overlay y
lines(density(sentencing$sents / E), col = "darkred", lwd = 2)

# legend, y-axis label
legend("topright", legend = c('Y-observed', 'Y-replicate'),
      col = c('darkred', ltgray), lwd = c(1.5, 1.5))

mtext(side = 2, text = "Density", line = 2.5)

# return margins to previous settings
par(old_pars)

</code></pre>

<hr>
<h2 id='stan_icar'>Intrinsic autoregressive models</h2><span id='topic+stan_icar'></span>

<h3>Description</h3>

<p>The intrinsic conditional auto-regressive (ICAR) model for spatial count data. Options include the BYM model, the BYM2 model, and a solo ICAR term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_icar(
  formula,
  slx,
  re,
  data,
  C,
  family = poisson(),
  type = c("icar", "bym", "bym2"),
  scale_factor = NULL,
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  censor_point,
  prior_only = FALSE,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  slim = FALSE,
  drop = NULL,
  pars = NULL,
  control = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_icar_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <a href="stats.html#topic+formula">formula</a> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div>
<p>Before using this term, read the <code>Details</code> section and the <code>type</code> argument. Specifically, if you use <code>type = bym</code>, then an observational-level <code>re</code> term is already included in the model. (Similar for <code>type = bym2</code>.)</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix which will be used to construct an edge list for the ICAR model, and to calculate residual spatial autocorrelation as well as any user specified <code>slx</code> terms. It will automatically be row-standardized before calculating <code>slx</code> terms (matching the ICAR model). <code>C</code> must be a binary symmetric <code>n x n</code> matrix.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>binomial(link = "logit")</code> and <code>poisson(link = "log")</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_type">type</code></td>
<td>
<p>Defaults to &quot;icar&quot; (partial pooling of neighboring observations through parameter <code>phi</code>); specify &quot;bym&quot; to add a second parameter vector <code>theta</code> to perform partial pooling across all observations; specify &quot;bym2&quot; for the innovation introduced by Riebler et al. (2016). See <code>Details</code> for more information.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_scale_factor">scale_factor</code></td>
<td>
<p>For the BYM2 model, optional. If missing, this will be set to a vector of ones. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sigma</dt><dd><p>For <code>family = gaussian()</code> and <code>family = student_t()</code> models, the scale parameter, <code>sigma</code>, is assigned a (half-) Student's t prior distribution. The half-Student's t prior for <code>sigma</code> is constrained to be positive.</p>
</dd>
<dt>nu</dt><dd><p><code>nu</code> is the degrees of freedom parameter in the Student's t likelihood (only used when <code>family = student_t()</code>). <code>nu</code> is assigned a gamma prior distribution. The default prior is <code>prior = list(nu = gamma2(alpha = 3, beta = 0.2))</code>.
</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for random effects, or varying intercepts, terms. This scale parameter, <code>tau</code>, is assigned a half-Student's t prior. To set this, use, e.g., <code>prior = list(tau = student_t(df = 20, location = 0, scale = 20))</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_icar_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty (i.e. measurement or sampling error) in any or all of the covariates, provide a list of data as constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. If the ME argument is used, the modeled covariate (i.e., latent variable), rather than the raw observations, will be centered. When using the ME argument, this is the recommended method for centering the covariates.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths. For example, the US Centers for Disease Control and Prevention censors (does not report) death counts that are nine or fewer, so if you're using CDC WONDER mortality data you could provide <code>censor_point = 9</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_prior_only">prior_only</code></td>
<td>
<p>Draw samples from the prior distributions of parameters only.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to estimate.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_iter">iter</code></td>
<td>
<p>Number of samples per chain. .</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples; set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors and the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not collect the most memory-intensive parameters (including n-length vectors of fitted values, log-likelihoods, and ME-modeled covariate values). This will disable many convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, WAIC, and spatial diagnostics, and ME diagnostics; many quantities of interest, such as fitted values and spatial trends, can still be calculated manually using given parameter estimates. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models. For more control over which parameters are kept or dropped, use the <code>drop</code> argument instead of <code>slim</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from ICAR models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
<dt>phi</dt><dd><p>The N-length vector of spatially-autocorrelated parameters (with the ICAR prior).</p>
</dd>
<dt>theta</dt><dd><p>The N-length vector of spatially unstructured parameters ('random effects'), for the BYM and BYM2 models.</p>
</dd>
</dl>

<p>If <code>slim = TRUE</code>, then <code>drop</code> will be ignored.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_pars">pars</code></td>
<td>
<p>Optional; specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <code><a href="rstan.html#topic+stan">stan</a></code> for details.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_quiet">quiet</code></td>
<td>
<p>Controls (most) automatic printing to the console. By default, any prior distributions that have not been assigned by the user are printed to the console. If <code>quiet = TRUE</code>, these will not be printed. Using <code>quiet = TRUE</code> will also force <code>refresh = 0</code>.</p>
</td></tr>
<tr><td><code id="stan_icar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="rstan.html#topic+sampling">sampling</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intrinsic conditional autoregressive (ICAR) model for spatial data was introduced by Besag et al. (1991). The Stan code for the ICAR component of the model and the BYM2 option is from Morris et al. (2019) with adjustments to enable non-binary weights and disconnected graph structures (see Freni-Sterrantino (2018) and Donegan (2021)).
</p>
<p>The exact specification depends on the <code>type</code> argument.
</p>


<h4>ICAR</h4>

<p>For Poisson models for count data, y, the basic model specification (<code>type = "icar"</code>) is:
</p>
<p style="text-align: center;"><code class="reqn">y ~ Poisson(e^{O + \mu + \phi}) </code>
</p>

<p style="text-align: center;"><code class="reqn">\phi \sim ICAR(\tau_s) </code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_s \sim Gauss(0, 1)</code>
</p>

<p>where <code class="reqn">\mu</code> contains an intercept and potentially covariates. The spatial trend <code class="reqn">phi</code> has a mean of zero and a single scale parameter <code class="reqn">\tau_s</code> (which user's will see printed as the parameter named <code>spatial_scale</code>).
</p>
<p>The ICAR prior model is a CAR model that has a spatial autocorrelation parameter <code class="reqn">\rho</code> equal to 1 (see <a href="#topic+stan_car">stan_car</a>). Thus the ICAR prior places high probability on a very smooth spatially (or temporally) varying mean. This is rarely sufficient to model the amount of variation present in social and health data. For this reason, the BYM model is typically employed.
</p>



<h4>BYM</h4>

<p>Often, an observational-level random effect term, <code>theta</code>, is added to capture (heterogeneous or unstructured) deviations from <code class="reqn">\mu + \phi</code>. The combined term is referred to as a convolution term:
</p>
<p><code class="reqn">
 convolution = \phi + \theta.
</code>
</p>
<p>This is known as the BYM model (Besag et al. 1991), and can be specified using <code>type = "bym"</code>:
</p>
<p><code class="reqn">y \sim Poisson(e^{O + \mu + \phi + \theta}) </code>
</p>
<p style="text-align: center;"><code class="reqn"> \phi \sim ICAR(\tau_s) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta \sim Gaussian(0, \tau_{ns}) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau_s \sim Gaussian(0, 1) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau_{ns} \sim Gaussian(0, 1) </code>
</p>

<p>The model is named after Besag, York, and Mollié (1991).
</p>



<h4>BYM2</h4>

<p>Riebler et al. (2016) introduce a variation on the BYM model (<code>type = "bym2"</code>). This specification combines <code class="reqn">\phi</code> and <code class="reqn">\theta</code> using a mixing parameter <code class="reqn">\rho</code> that controls the proportion of the variation that is attributable to the spatially autocorrelated term <code class="reqn">\phi</code> rather than the spatially unstructured term <code class="reqn">\theta</code>. The terms share a single scale parameter <code class="reqn">\tau</code>:
</p>
<p style="text-align: center;"><code class="reqn">convolution = [sqrt(\rho * S) * \tilde{\phi} + sqrt(1 - \rho)  \tilde{\theta}] * \tau
</code>
</p>

<p style="text-align: center;"><code class="reqn"> \tilde{\phi} \sim Gaussian(0, 1) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tilde{\theta} \sim Gaussian(0, 1) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \tau \sim Gaussian(0, 1) </code>
</p>

<p>The terms <code class="reqn">\tilde{\phi}</code>, <code class="reqn">\tilde{\theta}</code> are standard normal deviates, <code class="reqn">\rho</code> is restricted to values between zero and one, and <code class="reqn">S</code> is the 'scale_factor' (a constant term provided by the user). By default, the 'scale_factor' is equal to one, so that it does nothing. Riebler et al. (2016) argue that the interpretation or meaning of the scale of the ICAR model depends on the graph structure of the connectivity matrix <code class="reqn">C</code>. This implies that the same prior distribution assigned to <code class="reqn">\tau_s</code> will differ in its implications if <code class="reqn">C</code> is changed; in other words, the priors are not transportable across models, and models that use the same nominal prior actually have different priors assigned to <code class="reqn">\tau_s</code>.
</p>
<p>Borrowing <code>R</code> code from Morris (2017) and following Freni-Sterrantino et al. (2018), the following <code>R</code> code can be used to create the 'scale_factor' <code class="reqn">S</code> for the BYM2 model (note, this requires the INLA R package), given a spatial adjacency matrix, <code class="reqn">C</code>:
</p>
<div class="sourceCode"><pre>## create a list of data for stan_icar
icar.data &lt;- geostan::prep_icar_data(C)
## calculate scale_factor for each of k connected group of nodes
k &lt;- icar.data$k
scale_factor &lt;- vector(mode = "numeric", length = k)
for (j in 1:k) {
  g.idx &lt;- which(icar.data$comp_id == j) 
  if (length(g.idx) == 1) {
       scale_factor[j] &lt;- 1
       next
    }    
  Cg &lt;- C[g.idx, g.idx] 
  scale_factor[j] &lt;- scale_c(Cg) 
}
</pre></div>
<p>This code adjusts for 'islands' or areas with zero neighbors, and it also handles disconnected graph structures (see Donegan and Morris 2021). Following Freni-Sterrantino (2018), disconnected components of the graph structure are given their own intercept term; however, this value is added to <code class="reqn">\phi</code> automatically inside the Stan model. Therefore, the user never needs to make any adjustments for this term. (To avoid complications from using a disconnected graph structure, you can apply a proper CAR model instead of the ICAR: <code><a href="#topic+stan_car">stan_car</a></code>).
</p>
<p>Note, the code above requires the <code>scale_c</code> function; it has package dependencies that are not included in <code>geostan</code>. To use <code>scale_c</code>, you have to load the following <code>R</code> function:
</p>
<div class="sourceCode"><pre>#' compute scaling factor for adjacency matrix, accounting for differences in spatial connectivity 
#'
#' @param C connectivity matrix
#'
#' @details
#'
#' Requires the following packages: 
#'
#' library(Matrix)
#' library(INLA);
#' library(spdep)
#' library(igraph)
#'  
#' @source  Morris (2017)
#'
scale_c &lt;- function(C) {
 geometric_mean &lt;- function(x) exp(mean(log(x))) 
 N = dim(C)[1]
 Q =  Diagonal(N, rowSums(C)) - C
 Q_pert = Q + Diagonal(N) * max(diag(Q)) * sqrt(.Machine$double.eps)
 Q_inv = inla.qinv(Q_pert, constr=list(A = matrix(1,1,N),e=0))
 scaling_factor &lt;- geometric_mean(Matrix::diag(Q_inv)) 
 return(scaling_factor) 
}
</pre></div>



<h4>Additional functionality</h4>

<p>The ICAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), missing outcome data, and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame</p>
</dd>
<dt>diagnostic</dt><dd><p>Residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>edges</dt><dd><p>The edge list representing all unique sets of neighbors and the weight attached to each pair (i.e., their corresponding element in the connectivity matrix  C</p>
</dd>
<dt>C</dt><dd><p>Spatial connectivity matrix</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including ICAR component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list with two name elements, <code>formula</code> and <code>Data</code>, containing the formula <code>re</code> and a data frame with columns <code>id</code> (the grouping variable) and <code>idx</code> (the index values assigned to each group).</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial parameter (<code>"phi"</code> if <code>type = "icar"</code> else <code>"convolution"</code>) and method (<code>toupper(type)</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Besag, J. (1974). Spatial interaction and the statistical analysis of lattice systems. <em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, 36(2), 192-225.
</p>
<p>Besag, J., York, J., and Mollié, A. (1991). Bayesian image restoration, with two applications in spatial statistics. <em>Annals of the Institute of Statistical Mathematics</em>, 43(1), 1-20.
</p>
<p>Donegan, Connor and Morris, Mitzi (2021). Flexible functions for ICAR, BYM, and BYM2 models in Stan. Code repository. <a href="https://github.com/ConnorDonegan/Stan-IAR">https://github.com/ConnorDonegan/Stan-IAR</a>
</p>
<p>Donegan, Connor (2021b). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>Freni-Sterrantino, Anna, Massimo Ventrucci, and Håvard Rue (2018). A Note on Intrinsic Conditional Autoregressive Models for Disconnected Graphs. <em>Spatial and Spatio-Temporal Epidemiology</em>, 26: 25–34.
</p>
<p>Morris, Mitzi (2017). Spatial Models in Stan: Intrinsic Auto-Regressive Models for Areal Data. <a href="https://mc-stan.org/users/documentation/case-studies/icar_stan.html">https://mc-stan.org/users/documentation/case-studies/icar_stan.html</a>
</p>
<p>Morris, M., Wheeler-Martin, K., Simpson, D., Mooney, S. J., Gelman, A., &amp; DiMaggio, C. (2019). Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan. <em>Spatial and spatio-temporal epidemiology</em>, 31, 100301.
</p>
<p>Riebler, A., Sorbye, S. H., Simpson, D., &amp; Rue, H. (2016). An intuitive Bayesian spatial model for disease mapping that accounts for scaling. <em>Statistical Methods in Medical Research</em>, 25(4), 1145-1165.
</p>


<h3>See Also</h3>

<p><a href="#topic+shape2mat">shape2mat</a>, <a href="#topic+stan_car">stan_car</a>, <a href="#topic+stan_esf">stan_esf</a>, <a href="#topic+stan_glm">stan_glm</a>, <a href="#topic+prep_icar_data">prep_icar_data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sentencing)
C &lt;- shape2mat(sentencing, "B")
log_e &lt;- log(sentencing$expected_sents)
fit.bym &lt;- stan_icar(sents ~ offset(log_e),
                     family = poisson(),
                     data = sentencing,
                     type = "bym",
                     C = C,
                     chains = 2, iter = 800) # for speed only

# spatial diagnostics
sp_diag(fit.bym, sentencing)
                                       
# check effective sample size and convergence
library(rstan)
rstan::stan_ess(fit.bym$stanfit)
rstan::stan_rhat(fit.bym$stanfit)

</code></pre>

<hr>
<h2 id='stan_sar'>Simultaneous autoregressive (SAR) models</h2><span id='topic+stan_sar'></span>

<h3>Description</h3>

<p>Fit data to a simultaneous spatial autoregressive (SAR) model, or use the SAR model as the prior model for a parameter vector in a hierarchical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_sar(
  formula,
  slx,
  re,
  data,
  C,
  sar_parts = prep_sar_data(C, quiet = TRUE),
  family = auto_gaussian(),
  type = c("SEM", "SDEM", "SDLM", "SLM"),
  prior = NULL,
  ME = NULL,
  centerx = FALSE,
  prior_only = FALSE,
  censor_point,
  zmp,
  chains = 4,
  iter = 2000,
  refresh = 500,
  keep_all = FALSE,
  pars = NULL,
  slim = FALSE,
  drop = NULL,
  control = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_sar_+3A_formula">formula</code></td>
<td>
<p>A model formula, following the R <code><a href="stats.html#topic+formula">formula</a></code> syntax. Binomial models can be specified by setting the left hand side of the equation to a data frame of successes and failures, as in <code>cbind(successes, failures) ~ x</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_slx">slx</code></td>
<td>
<p>Formula to specify any spatially-lagged covariates. As in, <code>~ x1 + x2</code> (the intercept term will be removed internally). When setting priors for <code>beta</code>, remember to include priors for any SLX terms.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_re">re</code></td>
<td>
<p>To include a varying intercept (or &quot;random effects&quot;) term, <code>alpha_re</code>, specify the grouping variable here using formula syntax, as in <code>~ ID</code>. Then, <code>alpha_re</code> is a vector of parameters added to the linear predictor of the model, and:
</p>
<div class="sourceCode"><pre>alpha_re ~ N(0, alpha_tau)
alpha_tau ~ Student_t(d.f., location, scale).
</pre></div>
<p>With the SAR model, any <code>alpha_re</code> term should be at a <em>different</em> level or scale than the observations; that is, at a different scale than the autocorrelation structure of the SAR model itself.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an object coercible to a data frame by <code>as.data.frame</code> containing the model data.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_c">C</code></td>
<td>
<p>Spatial connectivity matrix which will be used internally to create <code>sar_parts</code> (if <code>sar_parts</code> is missing); if the user provides an <code>slx</code> formula for the model, the required connectivity matrix will be taken from the <code>sar_parts</code> list. See <code><a href="#topic+shape2mat">shape2mat</a></code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_sar_parts">sar_parts</code></td>
<td>
<p>List of data constructed by <code><a href="#topic+prep_sar_data">prep_sar_data</a></code>. If not provided, then <code>C</code> will automatically be passed to <code><a href="#topic+prep_sar_data">prep_sar_data</a></code> to create <code>sar_parts</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_family">family</code></td>
<td>
<p>The likelihood function for the outcome variable. Current options are <code>auto_gaussian()</code>, <code>binomial()</code> (with logit link function) and <code>poisson()</code> (with log link function); if <code>family = gaussian()</code> is provided, it will automatically be converted to <code>auto_gaussian()</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_type">type</code></td>
<td>
<p>Type of SAR model (character string): spatial error model ('SEM'), spatial Durbin error model ('SDEM'), spatial Durbin lag model ('SDLM'), or spatial lag model ('SLM'). see Details below.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for prior distributions (see <code><a href="#topic+priors">priors</a></code>):
</p>

<dl>
<dt>intercept</dt><dd><p>The intercept is assigned a Gaussian prior distribution (see <code><a href="#topic+normal">normal</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>beta</dt><dd><p>Regression coefficients are assigned Gaussian prior distributions. Variables must follow their order of appearance in the model <code>formula</code>. Note that if you also use <code>slx</code> terms (spatially lagged covariates), and you use custom priors for <code>beta</code>, then you have to provide priors for the slx terms. Since slx terms are <em>prepended</em> to the design matrix, the prior for the slx term will be listed first.
</p>
</dd>
<dt>sar_scale</dt><dd><p>Scale parameter for the SAR model, <code>sar_scale</code>. The scale is assigned a Student's t prior model (constrained to be positive).</p>
</dd>
<dt>sar_rho</dt><dd><p>The spatial autocorrelation parameter in the SAR model, <code>rho</code>, is assigned a uniform prior distribution. By default, the prior will be uniform over all permissible values as determined by the eigenvalues of the spatial weights matrix. The range of permissible values for <code>rho</code> is printed to the console by <code><a href="#topic+prep_sar_data">prep_sar_data</a></code>.</p>
</dd>
<dt>tau</dt><dd><p>The scale parameter for any varying intercepts (a.k.a exchangeable random effects, or partial pooling) terms. This scale parameter, <code>tau</code>, is assigned a Student's t prior (constrained to be positive).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_sar_+3A_me">ME</code></td>
<td>
<p>To model observational uncertainty in any or all of the covariates (i.e. measurement or sampling error), provide a list of data constructed by the <code><a href="#topic+prep_me_data">prep_me_data</a></code> function.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_centerx">centerx</code></td>
<td>
<p>To center predictors on their mean values, use <code>centerx = TRUE</code>. This increases sampling speed. If the ME argument is used, the modeled covariate (i.e., the latent variable), rather than the raw observations, will be centered.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_prior_only">prior_only</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, draw samples only from the prior distributions of parameters.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_censor_point">censor_point</code></td>
<td>
<p>Integer value indicating the maximum censored value; this argument is for modeling censored (suppressed) outcome data, typically disease case counts or deaths which are left-censored to protect confidentiality when case counts are very low.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_zmp">zmp</code></td>
<td>
<p>Use zero-mean parameterization for the SAR model? Only relevant for Poisson and binomial outcome models (i.e., hierarchical models). See details below; this can sometimes improve MCMC sampling when the data is sparse, but does not alter the model specification.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to use.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_iter">iter</code></td>
<td>
<p>Number of MCMC samples per chain.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_refresh">refresh</code></td>
<td>
<p>Stan will print the progress of the sampler every <code>refresh</code> number of samples. Set <code>refresh=0</code> to silence this.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>keep_all = TRUE</code> then samples for all parameters in the Stan model will be kept; this is necessary if you want to do model comparison with Bayes factors using the <code>bridgesampling</code> package.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_pars">pars</code></td>
<td>
<p>Specify any additional parameters you'd like stored from the Stan model.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_slim">slim</code></td>
<td>
<p>If <code>slim = TRUE</code>, then the Stan model will not save the most memory-intensive parameters (including n-length vectors of fitted values, other 'random effects', and ME-modeled covariate values). This will disable some convenience functions that are otherwise available for fitted <code>geostan</code> models, such as the extraction of residuals, fitted values, and spatial trends, spatial diagnostics, and ME diagnostics. The &quot;slim&quot; option is designed for data-intensive routines, such as regression with raster data, Monte Carlo studies, and measurement error models.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_drop">drop</code></td>
<td>
<p>Provide a vector of character strings to specify the names of any parameters that you do not want MCMC samples for. Dropping parameters in this way can improve sampling speed and reduce memory usage. The following parameter vectors can potentially be dropped from SAR models:
</p>

<dl>
<dt>fitted</dt><dd><p>The N-length vector of fitted values</p>
</dd>
<dt>alpha_re</dt><dd><p>Vector of 'random effects'/varying intercepts.</p>
</dd>
<dt>log_lambda_mu</dt><dd><p>Linear predictor inside the SAR model (for Poisson and binomial models)</p>
</dd>
<dt>x_true</dt><dd><p>N-length vector of 'latent'/modeled covariate values created for measurement error (ME) models.</p>
</dd>
</dl>

<p>Using <code>drop = c('fitted', 'alpha_re', 'x_true', 'log_lambda_mu')</code> is equivalent to <code>slim = TRUE</code>. Note that if <code>slim = TRUE</code>, then <code>drop</code> will be ignored&mdash;so only use one or the other.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior. See <code><a href="rstan.html#topic+stan">stan</a></code> for details.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_quiet">quiet</code></td>
<td>
<p>Controls (most) automatic printing to the console. By default, any prior distributions that have not been assigned by the user are printed to the console; if <code>quiet = TRUE</code>, these will not be printed. Using <code>quiet = TRUE</code> will also force <code>refresh = 0</code>.</p>
</td></tr>
<tr><td><code id="stan_sar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discussions of SAR models may be found in Cliff and Ord (1981), Cressie (2015, Ch. 6), LeSage and Pace (2009), and LeSage (2014). The Stan implementation draws from Donegan (2021). It is a multivariate normal distribution with covariance matrix of <code class="reqn">\Sigma = \sigma^2 (I - \rho C)^{-1}(I - \rho C')^{-1}.</code>.
</p>
<p>There are two SAR specification options which are commonly known as the spatial error ('SEM') and the spatial lag ('SLM') models. When the spatial-lags of all covariates are included in the linear predictor (as in <code class="reqn">\mu = \alpha + X \beta + W X \gamma</code>), then the model is referred to as a spatial Durbin model; depending on the model type, it becomes a spatial Durbin error model ('SDEM') or a spatial Durbin lag model ('SDLM'). To control which covariates are introduced in spatial-lag form, use the <code>slx</code> argument together with 'type = SEM' or 'type = SLM'.
</p>


<h4>Auto-normal: spatial error</h4>

<p>The spatial error specification ('SEM') is
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + ( I - \rho C)^{-1} \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon \sim Gauss(0, \sigma^2)</code>
</p>

<p>where <code class="reqn">C</code> is the spatial connectivity matrix, <code class="reqn">I</code> is the n-by-n identity matrix, and <code class="reqn">\rho</code> is a spatial autocorrelation parameter. In words, the errors of the regression equation are spatially autocorrelated. The expected value for the SEM is the usual <code class="reqn">\mu</code>: the intercept plus <code>X*beta</code> and any other terms added to the linear predictor.
</p>
<p>Re-arranging terms, the model can also be written as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \rho C (y - \mu)  + \epsilon</code>
</p>

<p>which shows more intuitively the implicit spatial trend component, <code class="reqn">\phi = \rho C (y - \mu)</code>. This term <code class="reqn">\phi</code> can be extracted from a fitted auto-Gaussian/auto-normal model using the <a href="#topic+spatial">spatial</a> method.
</p>
<p>When applied to a fitted auto-Gaussian model, the <a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a> method returns 'de-trended' residuals <code class="reqn">R</code> by default. That is,
</p>
<p style="text-align: center;"><code class="reqn">
R = y - \mu - \rho C (y - \mu).
</code>
</p>

<p>To obtain &quot;raw&quot; residuals (<code class="reqn">y - \mu</code>), use <code>residuals(fit, detrend = FALSE)</code>. Similarly, the fitted values obtained from the <a href="#topic+fitted.geostan_fit">fitted.geostan_fit</a> will include the spatial trend term by default.
</p>



<h4>Auto-normal: spatial lag</h4>

<p>The second SAR specification type is the 'spatial lag of y' ('SLM'). This model describes a diffusion or contagion process:
</p>
<p style="text-align: center;"><code class="reqn">y = \rho C y + \mu + \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon \sim Gauss(0, \sigma^2)</code>
</p>

<p>This is very attractive for modeling actual contagion or diffusion processes (or static snapshots of such processes). The model does not allow for the usual interpretation of regression coefficients as marginal effects. To interpret SLM results, use <a href="#topic+impacts">impacts</a>.
</p>
<p>Note that the expected value of the SLM is equal to <code class="reqn">(I - \rho C)^{-1} \mu</code>.
</p>
<p>The <a href="#topic+spatial">spatial</a> method returns the vector
</p>
<p style="text-align: center;"><code class="reqn"> \phi = \rho C y, </code>
</p>

<p>the spatial lag of <code class="reqn">y</code>.
</p>
<p>The <a href="#topic+residuals.geostan_fit">residuals.geostan_fit</a> method returns 'de-trended' residuals <code class="reqn">R</code> by default:
</p>
<p style="text-align: center;"><code class="reqn">R = y - \rho C y - \mu,</code>
</p>

<p>where <code class="reqn">\mu</code> contains the intercept and any covariates (and possibly other terms).
</p>
<p>Similarly, the fitted values obtained from the <a href="#topic+fitted.geostan_fit">fitted.geostan_fit</a> will include the spatial trend <code class="reqn">\rho C y</code> by default to equal
</p>
<p style="text-align: center;"><code class="reqn">\rho C y + \mu.</code>
</p>

<p>For now at least, the SLM/SDLM option is only supported for auto-normal models (as opposed to hierarchical Poisson and binomial models).
</p>



<h4>Poisson</h4>

<p>For <code>family = poisson()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \lambda})</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda \sim Gauss(\mu, \Sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \sigma^2 (I - \rho C)^{-1}(I - \rho C')^{-1}</code>
</p>

<p>where <code class="reqn">O</code> is a constant/offset term and <code class="reqn">e^\lambda</code> is a rate parameter.
</p>
<p>If the raw outcome consists of a rate <code class="reqn">\frac{y}{p}</code> with observed counts <code class="reqn">y</code> and denominator <code class="reqn">p</code> (often this will be the size of the population at risk), then the offset term should be the log of the denominator: <code class="reqn">O=log(p)</code>.
</p>
<p>This same model can be written (equivalently) as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Poisson(e^{O + \mu + \phi})</code>
</p>

<p style="text-align: center;"><code class="reqn"> \phi \sim Gauss(0, \Sigma) </code>
</p>

<p>This second version is referred to here as the zero-mean parameterization (ZMP), since the SAR model is forced to have mean of zero. Although the non-ZMP is typically better for MCMC sampling, use of the ZMP can greatly improve MCMC sampling <em>when the data is sparse</em>. Use <code>zmp = TRUE</code> in <code>stan_sar</code> to apply this specification. (See the geostan vignette on 'custom spatial models' for full details on implementation of the ZMP.)
</p>
<p>For Poisson models, the <a href="#topic+spatial">spatial</a> method returns the (zero-mean) parameter vector <code class="reqn">\phi</code>. When <code>zmp = FALSE</code> (the default), <code class="reqn">\phi</code> is obtained by subtraction: <code class="reqn">\phi = \lambda - \mu</code>.
</p>
<p>In the Poisson SAR model, <code class="reqn">\phi</code> contains a latent (smooth) spatial trend as well as additional variation around it (this is merely a verbal description of the CAR model). If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating:
</p>
<p style="text-align: center;"><code class="reqn">
 \rho C \phi.
</code>
</p>




<h4>Binomial</h4>

<p>For <code>family = binomial()</code>, the model is specified as:
</p>
<p style="text-align: center;"><code class="reqn">y \sim Binomial(N, \lambda) </code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\lambda) \sim Gauss(\mu, \Sigma) </code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = \sigma^2 (I - \rho C)^{-1}(I - \rho C')^{-1},</code>
</p>

<p>where outcome data <code class="reqn">y</code> are counts, <code class="reqn">N</code> is the number of trials, and <code class="reqn">\lambda</code> is the rate of 'success'. Note that the model formula should be structured as: <code>cbind(sucesses, failures) ~ 1</code> (for an intercept-only model), such that <code>trials = successes + failures</code>.
</p>
<p>For fitted Binomial models, the <code><a href="#topic+spatial">spatial</a></code> method will return the parameter vector <code>phi</code>, equivalent to:
</p>
<p style="text-align: center;"><code class="reqn">\phi = logit(\lambda) - \mu.</code>
</p>

<p>The zero-mean parameterization (ZMP) of the SAR model can also be applied here (see the Poisson model for details); ZMP provides an equivalent model specification that can improve MCMC sampling when data is sparse.
</p>
<p>As is also the case for the Poisson model, <code class="reqn">\phi</code> contains a latent spatial trend as well as additional variation around it. If you would like to extract the latent/implicit spatial trend from <code class="reqn">\phi</code>, you can do so by calculating:
</p>
<p style="text-align: center;"><code class="reqn">
\rho C \phi.
</code>
</p>




<h4>Additional functionality</h4>

<p>The SAR models can also incorporate spatially-lagged covariates, measurement/sampling error in covariates (particularly when using small area survey estimates as covariates), missing outcome data (for Poisson and binomial models), and censored outcomes (such as arise when a disease surveillance system suppresses data for privacy reasons). For details on these options, please see the Details section in the documentation for <a href="#topic+stan_glm">stan_glm</a>.
</p>



<h3>Value</h3>

<p>An object of class class <code>geostan_fit</code> (a list) containing:
</p>

<dl>
<dt>summary</dt><dd><p>Summaries of the main parameters of interest; a data frame.</p>
</dd>
<dt>diagnostic</dt><dd><p>Residual spatial autocorrelation as measured by the Moran coefficient.</p>
</dd>
<dt>stanfit</dt><dd><p>an object of class <code>stanfit</code> returned by <code>rstan::stan</code></p>
</dd>
<dt>data</dt><dd><p>a data frame containing the model data</p>
</dd>
<dt>family</dt><dd><p>the user-provided or default <code>family</code> argument used to fit the model</p>
</dd>
<dt>formula</dt><dd><p>The model formula provided by the user (not including CAR component)</p>
</dd>
<dt>slx</dt><dd><p>The <code>slx</code> formula</p>
</dd>
<dt>re</dt><dd><p>A list containing <code>re</code>, the varying intercepts (<code>re</code>) formula if provided, and
<code>Data</code> a data frame with columns <code>id</code>, the grouping variable, and <code>idx</code>, the index values assigned to each group.</p>
</dd>
<dt>priors</dt><dd><p>Prior specifications.</p>
</dd>
<dt>x_center</dt><dd><p>If covariates are centered internally (<code>centerx = TRUE</code>), then <code>x_center</code> is a numeric vector of the values on which covariates were centered.</p>
</dd>
<dt>spatial</dt><dd><p>A data frame with the name of the spatial component parameter (either &quot;phi&quot; or, for auto Gaussian models, &quot;trend&quot;) and method (&quot;SAR&quot;)</p>
</dd>
<dt>ME</dt><dd><p>A list indicating if the object contains an ME model; if so, the user-provided ME list is also stored here.</p>
</dd>
<dt>C</dt><dd><p>Spatial weights matrix (in sparse matrix format).</p>
</dd>
<dt>sar_type</dt><dd><p>Type of SAR model: 'SEM', 'SDEM', 'SDLM', or 'SLM'.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Connor Donegan, <a href="mailto:connor.donegan@gmail.com">connor.donegan@gmail.com</a>
</p>


<h3>Source</h3>

<p>Cliff, A D and Ord, J K (1981). <em>Spatial Processes: Models and Applications</em>. Pion.
</p>
<p>Cressie, Noel (2015 (1993)). <em>Statistics for Spatial Data</em>. Wiley Classics, Revised Edition.
</p>
<p>Cressie, Noel and Wikle, Christopher (2011). <em>Statistics for Spatio-Temporal Data</em>. Wiley.
</p>
<p>Donegan, Connor (2021). Building spatial conditional autoregressive (CAR) models in the Stan programming language. <em>OSF Preprints</em>. <a href="https://doi.org/10.31219/osf.io/3ey65">doi:10.31219/osf.io/3ey65</a>.
</p>
<p>LeSage, James (2014). What Regional Scientists Need to Know about Spatial Econometrics. <em>The Review of Regional Science</em> 44: 13-32 (2014 Southern Regional Science Association Fellows Address).
</p>
<p>LeSage, James, &amp; Pace, Robert Kelley (2009). <em>Introduction to Spatial Econometrics</em>. Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## simulate SAR data on a regular grid
##

sars &lt;- prep_sar_data2(row = 10, col = 10, quiet = TRUE)
w &lt;- sars$W

# draw x
x &lt;- sim_sar(w = w, rho = 0.5)

# draw y = mu + rho*W*(y - mu) + epsilon
# beta = 0.5, rho = 0.5
y &lt;- sim_sar(w = w, rho = .5, mu = 0.5 * x)
dat &lt;- data.frame(y = y, x = x)

##
## fit SEM
##

fit_sem &lt;- stan_sar(y ~ x, data = dat, sar = sars,
                    chains = 1, iter = 800)
print(fit_sem)

##
## data for SDEM
##

# mu = x*beta + wx*gamma; beta=1, gamma=-0.25
x &lt;- sim_sar(w = w, rho = 0.5)
mu &lt;- 1 * x - 0.25 * (w %*% x)[,1]
y &lt;- sim_sar(w = w, rho = .5, mu = mu)
# or for SDLM:
# y &lt;- sim_sar(w = w, rho = 0.5, mu = mu, type = "SLM")
dat &lt;- data.frame(y=y, x=x)

#
## fit models
##

# SDEM
# y = mu + rho*W*(y - mu) + epsilon
# mu = beta*x + gamma*Wx
fit_sdem &lt;- stan_sar(y ~ x, data = dat,
                    sar_parts = sars, type = "SDEM",
                    iter = 800, chains = 1,
                    quiet = TRUE)

# SDLM
# y = rho*Wy + beta*x + gamma*Wx + epsilon
fit_sdlm &lt;- stan_sar(y ~ x, data = dat,
                    sar_parts = sars,
                    type = "SDLM",
                    iter = 800,
                    chains = 1,
                    quiet = TRUE)

# compare by DIC
dic(fit_sdem)
dic(fit_sdlm)


##
## Modeling mortality rates
##

# simple spatial regression
data(georgia)
W &lt;- shape2mat(georgia, style = "W")

fit &lt;- stan_sar(log(rate.male) ~ 1,
                C = W,
                data = georgia,
                iter = 900
                )

# view fitted vs. observed, etc.
sp_diag(fit, georgia)

# A more appropriate model for count data:
# hierarchical spatial poisson model
fit2 &lt;- stan_sar(deaths.male ~ offset(log(pop.at.risk.male)),
                C = W,
                data = georgia,
                family = poisson(),
                chains = 1, # for ex. speed only
                iter = 900,
                quiet = TRUE
                 )

# view fitted vs. observed, etc.
sp_diag(fit2, georgia)

</code></pre>

<hr>
<h2 id='waic'>Model comparison</h2><span id='topic+waic'></span><span id='topic+dic'></span>

<h3>Description</h3>

<p>Deviance Information Criteria (DIC) and Widely Application Information Criteria (WAIC) for model comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waic(object, pointwise = FALSE, digits = 2)

dic(object, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waic_+3A_object">object</code></td>
<td>
<p>A fitted <code>geostan</code> model</p>
</td></tr>
<tr><td><code id="waic_+3A_pointwise">pointwise</code></td>
<td>
<p>Logical (defaults to <code>FALSE</code>), should a vector of values for each observation be returned?</p>
</td></tr>
<tr><td><code id="waic_+3A_digits">digits</code></td>
<td>
<p>Round results to this many digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WAIC (widely applicable information criteria) and DIC (deviance information criteria) are used for model comparison. They are based on theories of out-of-sample predictive accuracy. The DIC is implemented with penalty term defined as 1/2 times the posterior variance of the deviance (Spiegelhatler et al. 2014).
</p>
<p>The limitations of these methods include that DIC is less robust than WAIC and that WAIC is not strictly valid for autocorrelated data (viz. geostan's spatial models).
</p>
<p>For both DIC and WAIC, lower values indicate better models.
</p>


<h3>Value</h3>

<p>WAIC returns a vector of length 3 with the <code>WAIC</code> value, a penalty term which measures the effective number of parameters estimated by the model <code>Eff_pars</code>, and log predictive density <code>Lpd</code>. If <code>pointwise = TRUE</code>, results are returned in a <code>data.frame</code>.
</p>
<p>DIC returns a vector of length 2: the DIC value and the penalty term (which is part of the DIC calculation).
</p>


<h3>Source</h3>

<p>D. Spiegelhatler, N. G. Best, B. P. Carlin and G. Linde (2014) The Deviance Information Criterion: 12 Years on. J. Royal Statistical Society Series B: Stat Methodology. 76(3): 485-493.
</p>
<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely application information criterion in singular learning theory. Journal of Machine Learning Research 11, 3571-3594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)

fit &lt;- stan_glm(log(rate.male) ~ 1, data = georgia,
                iter=600, chains = 2, quiet = TRUE)
fit2 &lt;- stan_glm(log(rate.male) ~ log(income), data = georgia,
                centerx = TRUE, iter=600, chains = 2, quiet = TRUE)

dic(fit)
dic(fit2)

waic(fit)
waic(fit2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
