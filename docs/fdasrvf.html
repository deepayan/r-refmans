<!DOCTYPE html><html><head><title>Help for package fdasrvf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdasrvf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align_fPCA'><p>Group-wise function alignment and PCA Extractions</p></a></li>
<li><a href='#ampbox_data'><p>Amplitude Boxplot Data</p></a></li>
<li><a href='#beta'><p>MPEG7 Curve Dataset</p></a></li>
<li><a href='#bootTB'><p>Tolerance Bound Calculation using Bootstrap Sampling</p></a></li>
<li><a href='#boxplot.fdawarp'><p>Functional Boxplot</p></a></li>
<li><a href='#calc_shape_dist'><p>Elastic Shape Distance</p></a></li>
<li><a href='#curve_depth'><p>Calculates elastic depth for a set of curves</p></a></li>
<li><a href='#curve_geodesic'><p>Form geodesic between two curves</p></a></li>
<li><a href='#curve_karcher_cov'><p>Curve Karcher Covariance</p></a></li>
<li><a href='#curve_karcher_mean'><p>Karcher Mean of Curves</p></a></li>
<li><a href='#curve_pair_align'><p>Pairwise align two curves</p></a></li>
<li><a href='#curve_principal_directions'><p>Curve PCA</p></a></li>
<li><a href='#curve_srvf_align'><p>Align Curves</p></a></li>
<li><a href='#curve_to_q'><p>Convert to SRVF space</p></a></li>
<li><a href='#elastic_amp_change_ff'><p>Elastic Amplitude Changepoint Detection</p></a></li>
<li><a href='#elastic_change_fpca'><p>Elastic Changepoint Detection</p></a></li>
<li><a href='#elastic_ph_change_ff'><p>Elastic Phase Changepoint Detection</p></a></li>
<li><a href='#elastic.depth'><p>Calculates elastic depth</p></a></li>
<li><a href='#elastic.distance'><p>Calculates two elastic distance</p></a></li>
<li><a href='#elastic.logistic'><p>Elastic Logistic Regression</p></a></li>
<li><a href='#elastic.lpcr.regression'><p>Elastic logistic Principal Component Regression</p></a></li>
<li><a href='#elastic.mlogistic'><p>Elastic Multinomial Logistic Regression</p></a></li>
<li><a href='#elastic.mlpcr.regression'><p>Elastic Multinomial logistic Principal Component Regression</p></a></li>
<li><a href='#elastic.pcr.regression'><p>Elastic Linear Principal Component Regression</p></a></li>
<li><a href='#elastic.prediction'><p>Elastic Prediction from Regression Models</p></a></li>
<li><a href='#elastic.regression'><p>Elastic Linear Regression</p></a></li>
<li><a href='#f_to_srvf'><p>Transformation to SRVF Space</p></a></li>
<li><a href='#fdasrvf'><p>Elastic Functional Data Analysis</p></a></li>
<li><a href='#function_group_warp_bayes'><p>Bayesian Group Warping</p></a></li>
<li><a href='#function_mean_bayes'><p>Bayesian Karcher Mean Calculation</p></a></li>
<li><a href='#gam_to_v'><p>map warping function to tangent space at identity</p></a></li>
<li><a href='#gauss_model'><p>Gaussian model of functional data</p></a></li>
<li><a href='#gradient'><p>Gradient using finite differences</p></a></li>
<li><a href='#growth_vel'><p>Berkeley Growth Velocity Dataset</p></a></li>
<li><a href='#horizFPCA'><p>Horizontal Functional Principal Component Analysis</p></a></li>
<li><a href='#im'><p>Example Image Data set</p></a></li>
<li><a href='#inv_exp_map'><p>map square root of warping function to tangent space</p></a></li>
<li><a href='#invertGamma'><p>Invert Warping Function</p></a></li>
<li><a href='#joint_gauss_model'><p>Gaussian model of functional data using joint Model</p></a></li>
<li><a href='#jointFPCA'><p>Joint Vertical and Horizontal Functional Principal Component Analysis</p></a></li>
<li><a href='#kmeans_align'><p>K-Means Clustering and Alignment</p></a></li>
<li><a href='#LongRunCovMatrix'><p>Long Run Covariance Matrix Estimation for Multivariate Time Series</p></a></li>
<li><a href='#multiple_align_functions'><p>Group-wise function alignment to specified mean</p></a></li>
<li><a href='#multivariate_karcher_mean'><p>Karcher Mean of Multivariate Functional Data</p></a></li>
<li><a href='#optimum.reparam'><p>Align two functions</p></a></li>
<li><a href='#outlier.detection'><p>Outlier Detection</p></a></li>
<li><a href='#pair_align_functions'><p>Align two functions</p></a></li>
<li><a href='#pair_align_functions_bayes'><p>Align two functions</p></a></li>
<li><a href='#pair_align_functions_expomap'><p>Align two functions using geometric properties of warping functions</p></a></li>
<li><a href='#pair_align_image'><p>Pairwise align two images</p>
This function aligns to images using the q-map framework</a></li>
<li><a href='#pcaTB'><p>Tolerance Bound Calculation using Elastic Functional PCA</p></a></li>
<li><a href='#phbox_data'><p>Phase Boxplot Data</p></a></li>
<li><a href='#predict.hfpca'><p>Elastic Prediction for functional PCA</p></a></li>
<li><a href='#predict.jfpca'><p>Elastic Prediction for functional PCA</p></a></li>
<li><a href='#predict.lpcr'><p>Elastic Prediction for functional logistic PCR Model</p></a></li>
<li><a href='#predict.mlpcr'><p>Elastic Prediction for functional multinomial logistic PCR Model</p></a></li>
<li><a href='#predict.pcr'><p>Elastic Prediction for functional PCR Model</p></a></li>
<li><a href='#predict.vfpca'><p>Elastic Prediction for functional PCA</p></a></li>
<li><a href='#q_to_curve'><p>Convert to curve space</p></a></li>
<li><a href='#reparam_curve'><p>Align two curves</p></a></li>
<li><a href='#reparam_image'><p>Find optimum reparameterization between two images</p></a></li>
<li><a href='#resamplecurve'><p>Resample Curve</p></a></li>
<li><a href='#rgam'><p>Random Warping</p></a></li>
<li><a href='#sample_shapes'><p>Sample shapes from model</p></a></li>
<li><a href='#simu_data'><p>Simulated two Gaussian Dataset</p></a></li>
<li><a href='#simu_warp'><p>Aligned Simulated two Gaussian Dataset</p></a></li>
<li><a href='#simu_warp_median'><p>Aligned Simulated two Gaussian Dataset using Median</p></a></li>
<li><a href='#smooth.data'><p>Smooth Functions</p></a></li>
<li><a href='#SqrtMean'><p>SRVF transform of warping functions</p></a></li>
<li><a href='#SqrtMeanInverse'><p>SRVF transform of warping functions</p></a></li>
<li><a href='#SqrtMedian'><p>SRVF transform of warping functions</p></a></li>
<li><a href='#srvf_to_f'><p>Transformation from SRSF Space</p></a></li>
<li><a href='#time_warping'><p>Alignment of univariate functional data</p></a></li>
<li><a href='#toy_data'><p>Distributed Gaussian Peak Dataset</p></a></li>
<li><a href='#toy_warp'><p>Aligned Distributed Gaussian Peak Dataset</p></a></li>
<li><a href='#v_to_gam'><p>map shooting vector to warping function at identity</p></a></li>
<li><a href='#vertFPCA'><p>Vertical Functional Principal Component Analysis</p></a></li>
<li><a href='#warp_f_gamma'><p>Warp Function</p></a></li>
<li><a href='#warp_q_gamma'><p>Warp SRSF</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Elastic Functional Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-1-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs alignment, PCA, and modeling of multidimensional and 
    unidimensional functions using the square-root velocity framework 
    (Srivastava et al., 2011 &lt;<a href="https://arxiv.org/abs/1103.3817">arXiv:1103.3817</a>&gt; and Tucker et al., 2014 
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2012.12.001">doi:10.1016/j.csda.2012.12.001</a>&gt;). This framework allows for elastic 
    analysis of functional data through phase and amplitude separation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, coda, doParallel, fields, foreach, lpSolve, Matrix,
mvtnorm, Rcpp, rlang, tolerance, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, interp, plot3D, plot3Drgl, rgl, testthat (&ge; 3.0.0),
withr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0),</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jdtuck/fdasrvf_R">https://github.com/jdtuck/fdasrvf_R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jdtuck/fdasrvf_R/issues">https://github.com/jdtuck/fdasrvf_R/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 17:15:18 UTC; jdtuck</td>
</tr>
<tr>
<td>Author:</td>
<td>J. Derek Tucker <a href="https://orcid.org/0000-0001-8844-2169"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>J. Derek Tucker &lt;jdtuck@sandia.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='align_fPCA'>Group-wise function alignment and PCA Extractions</h2><span id='topic+align_fPCA'></span>

<h3>Description</h3>

<p>This function aligns a collection of functions while extracting principal
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_fPCA(
  f,
  time,
  num_comp = 3L,
  showplot = TRUE,
  smooth_data = FALSE,
  sparam = 25L,
  parallel = FALSE,
  cores = NULL,
  max_iter = 51L,
  lambda = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_fPCA_+3A_f">f</code></td>
<td>
<p>A numeric matrix of shape <code class="reqn">M \times N</code> specifying a sample of
<code class="reqn">N</code> <code class="reqn">1</code>-dimensional curves observed on a grid of size <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_time">time</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> specifying the grid on which
functions <code>f</code> have been evaluated.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_num_comp">num_comp</code></td>
<td>
<p>An integer value specifying the number of principal
components to extract. Defaults to <code>3L</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_showplot">showplot</code></td>
<td>
<p>A boolean specifying whether to display plots along the way.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_smooth_data">smooth_data</code></td>
<td>
<p>A boolean specifying whether to smooth data using box
filter. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_sparam">sparam</code></td>
<td>
<p>An integer value specifying the number of times to apply box
filter. Defaults to <code>25L</code>. This argument is only used if <code>smooth_data == TRUE</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_parallel">parallel</code></td>
<td>
<p>A boolean specifying whether computations should run in
parallel. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_cores">cores</code></td>
<td>
<p>An integer value specifying the number of cores to use for
parallel computations. Defaults to <code>NULL</code> in which case it uses all
available cores but one. This argument is only used when <code>parallel == TRUE</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer value specifying the maximum number of iterations.
Defaults to <code>51L</code>.</p>
</td></tr>
<tr><td><code id="align_fPCA_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the elasticity. Defaults to <code>0.0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li> <p><code>f0</code>: A numeric matrix of shape <code class="reqn">M \times N</code> storing the original
functions;
</p>
</li>
<li> <p><code>fn</code>: A numeric matrix of the same shape as <code>f0</code> storing the aligned
functions;
</p>
</li>
<li> <p><code>qn</code>: A numeric matrix of the same shape as <code>f0</code> storing the aligned
SRSFs;
</p>
</li>
<li> <p><code>q0</code>: A numeric matrix of the same shape as <code>f0</code> storing the SRSFs of the
original functions;
</p>
</li>
<li> <p><code>mqn</code>: A numeric vector of length <code class="reqn">M</code> storing the mean SRSF;
</p>
</li>
<li> <p><code>gam</code>: A numeric matrix of the same shape as <code>f0</code> storing the estimated
warping functions;
</p>
</li>
<li> <p><code>vfpca</code>: A list storing information about the vertical PCA with the
following components:
</p>

<ul>
<li> <p><code>q_pca</code>: A numeric matrix of shape <code class="reqn">(M + 1) \times 5 \times
  \mathrm{num\_comp}</code> storing the first <code class="reqn">3</code> principal directions in SRSF
space; the first dimension is <code class="reqn">M + 1</code> because, in SRSF space, the
original functions are represented by the SRSF and the initial value of the
functions.
</p>
</li>
<li> <p><code>f_pca</code>: A numeric matrix of shape <code class="reqn">M \times 5 \times
  \mathrm{num\_comp}</code> storing the first <code class="reqn">3</code> principal directions in
original space;
</p>
</li>
<li> <p><code>latent</code>: A numeric vector of length <code class="reqn">M + 1</code> storing the singular
values of the SVD decomposition in SRSF space;
</p>
</li>
<li> <p><code>coef</code>: A numeric matrix of shape <code class="reqn">N \times \mathrm{num\_comp}</code>
storing the scores of the <code class="reqn">N</code> original functions on the first
<code>num_comp</code> principal components;
</p>
</li>
<li> <p><code>U</code>: A numeric matrix of shape <code class="reqn">(M + 1) \times (M + 1)</code> storing the
eigenvectors associated with the SVD decomposition in SRSF space.
</p>
</li></ul>

</li>
<li> <p><code>Dx</code>: A numeric vector of length <code>max_iter</code> storing the value of the cost
function at each iteration.
</p>
</li></ul>



<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using phase and amplitude separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out &lt;- align_fPCA(simu_data$f, simu_data$time)

## End(Not run)
</code></pre>

<hr>
<h2 id='ampbox_data'>Amplitude Boxplot Data</h2><span id='topic+ampbox_data'></span>

<h3>Description</h3>

<p>This function constructs the amplitude boxplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ampbox_data(warp_median, alpha = 0.05, ka = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ampbox_data_+3A_warp_median">warp_median</code></td>
<td>
<p>fdawarp object from <code><a href="#topic+time_warping">time_warping()</a></code> of aligned data using
the median</p>
</td></tr>
<tr><td><code id="ampbox_data_+3A_alpha">alpha</code></td>
<td>
<p>quantile value (default=.05, i.e., 95%)</p>
</td></tr>
<tr><td><code id="ampbox_data_+3A_ka">ka</code></td>
<td>
<p>scalar for outlier cutoff (default=1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>ampbox</code> object containing:
</p>

<ul>
<li> <p><code>median_y</code>: median function
</p>
</li>
<li> <p><code>Q1</code>: First quartile
</p>
</li>
<li> <p><code>Q3</code>: Second quartile
</p>
</li>
<li> <p><code>Q1a</code>: First quantile based on alpha
</p>
</li>
<li> <p><code>Q3a</code>: Second quantile based on alpha
</p>
</li>
<li> <p><code>minn</code>: minimum extreme function
</p>
</li>
<li> <p><code>maxx</code>: maximum extreme function
</p>
</li>
<li> <p><code>outlier_index</code>: indexes of outlier functions
</p>
</li>
<li> <p><code>fmedian</code>: median function
</p>
</li></ul>



<h3>References</h3>

<p>Xie, W., S. Kurtek, K. Bharath, and Y. Sun  (2016). &quot;A geometric
approach to visualization of variability in functional data.&quot; Journal of
the American Statistical Association in press: 1-34.
</p>

<hr>
<h2 id='beta'>MPEG7 Curve Dataset</h2><span id='topic+beta'></span>

<h3>Description</h3>

<p>Contains the MPEG7 curve data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta
</code></pre>


<h3>Format</h3>



<h4><code>beta</code></h4>

<p>An array of shape <code class="reqn">2 \times 100 \times 65 \times 20</code> storing a sample of
<code class="reqn">20</code> curves from <code class="reqn">R</code> to <code class="reqn">R^2</code> distributed in
<code class="reqn">65</code> different classes, evaluated on a grid of size <code class="reqn">100</code>.
</p>


<hr>
<h2 id='bootTB'>Tolerance Bound Calculation using Bootstrap Sampling</h2><span id='topic+bootTB'></span>

<h3>Description</h3>

<p>This function computes tolerance bounds for functional data containing
phase and amplitude variation using bootstrap sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootTB(f, time, a = 0.05, p = 0.99, B = 500, no = 5, Nsamp = 100, parallel = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootTB_+3A_f">f</code></td>
<td>
<p>matrix of functions</p>
</td></tr>
<tr><td><code id="bootTB_+3A_time">time</code></td>
<td>
<p>vector describing time sampling</p>
</td></tr>
<tr><td><code id="bootTB_+3A_a">a</code></td>
<td>
<p>confidence level of tolerance bound (default = 0.05)</p>
</td></tr>
<tr><td><code id="bootTB_+3A_p">p</code></td>
<td>
<p>coverage level of tolerance bound (default = 0.99)</p>
</td></tr>
<tr><td><code id="bootTB_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples (default = 500)</p>
</td></tr>
<tr><td><code id="bootTB_+3A_no">no</code></td>
<td>
<p>number of principal components (default = 5)</p>
</td></tr>
<tr><td><code id="bootTB_+3A_nsamp">Nsamp</code></td>
<td>
<p>number of functions per bootstrap (default = 100)</p>
</td></tr>
<tr><td><code id="bootTB_+3A_parallel">parallel</code></td>
<td>
<p>enable parallel processing (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>amplitude tolerance bounds</p>
</td></tr>
<tr><td><code>ph</code></td>
<td>
<p>phase tolerance bounds</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, C. King, and S. Kurtek, “A Geometric
Approach for Computing Tolerance Bounds for Elastic Functional Data,”
Journal of Applied Statistics, 10.1080/02664763.2019.1645818, 2019.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative Models for
Function Data using Phase and Amplitude Separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>
<p>Jung, S. L. a. S. (2016). &quot;Combined Analysis of Amplitude and
Phase Variations in Functional Data.&quot; arXiv:1603.01775.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out1 &lt;- bootTB(simu_data$f, simu_data$time)

## End(Not run)
</code></pre>

<hr>
<h2 id='boxplot.fdawarp'>Functional Boxplot</h2><span id='topic+boxplot.fdawarp'></span><span id='topic+boxplot.ampbox'></span><span id='topic+boxplot.phbox'></span>

<h3>Description</h3>

<p>This function computes the required statistics for building up a boxplot of
the aligned functional data. Since the process of alignment provides
separation of phase and amplitude variability, the computed boxplot can focus
either on amplitude variability or phase variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdawarp'
boxplot(
  x,
  variability_type = c("amplitude", "phase"),
  alpha = 0.05,
  range = 1,
  what = c("plot", "stats", "plot+stats"),
  ...
)

## S3 method for class 'ampbox'
boxplot(x, ...)

## S3 method for class 'phbox'
boxplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.fdawarp_+3A_x">x</code></td>
<td>
<p>An object of class <code>fdawarp</code> typically produced by <code><a href="#topic+time_warping">time_warping()</a></code>
or of class <code>ampbox</code> or <code>phbox</code> typically produced by <code><a href="#topic+boxplot.fdawarp">boxplot.fdawarp()</a></code>.</p>
</td></tr>
<tr><td><code id="boxplot.fdawarp_+3A_variability_type">variability_type</code></td>
<td>
<p>A string specifying which kind of variability should
be displayed in the boxplot. Choices are <code>"amplitude"</code> or <code>"phase"</code>.
Defaults to <code>"amplitude"</code>.</p>
</td></tr>
<tr><td><code id="boxplot.fdawarp_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value specifying the quantile value. Defaults to
<code class="reqn">0.05</code> which uses the <code class="reqn">95\%</code> quantile.</p>
</td></tr>
<tr><td><code id="boxplot.fdawarp_+3A_range">range</code></td>
<td>
<p>A positive numeric value specifying how far the plot whiskers
extend out from the box. The whiskers extend to the most extreme data point
which is no more than <code>range</code> times the interquartile range from the box.
Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="boxplot.fdawarp_+3A_what">what</code></td>
<td>
<p>A string specifying what the function should return. Choices are
<code>"plot"</code>, <code>"stats"</code> or <code>"plot+stats"</code>. Defaults to <code>"plot"</code>.</p>
</td></tr>
<tr><td><code id="boxplot.fdawarp_+3A_...">...</code></td>
<td>
<p>Unused here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+boxplot.fdawarp">boxplot.fdawarp()</a></code> returns optionally an object of class either
<code>ampbox</code> if <code>variability_type = "amplitude"</code> or <code>phbox</code> if <code>variability_type = "phase"</code>. <code>S3</code> methods specialized for objects of these classes are
provided as well to avoid re-computation of the boxplot statistics.
</p>


<h3>Value</h3>

<p>If <code>what</code> contains <code>stats</code>, a list containing the computed statistics
necessary for drawing the boxplot. Otherwise, the function simply draws the
boxplot and no object is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- time_warping(simu_data$f, simu_data$time)
boxplot(out, what = "stats")

## End(Not run)
</code></pre>

<hr>
<h2 id='calc_shape_dist'>Elastic Shape Distance</h2><span id='topic+calc_shape_dist'></span>

<h3>Description</h3>

<p>Calculate elastic shape distance between two curves beta1 and beta2. If the
curves beta1 and beta2 are describing multidimensional functional data, then
<code>rotation == FALSE</code> and <code>mode == 'O'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_shape_dist(
  beta1,
  beta2,
  mode = "O",
  rotation = TRUE,
  scale = TRUE,
  include.length = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_shape_dist_+3A_beta1">beta1</code></td>
<td>
<p>curve1, provided as a matrix of sizes <code class="reqn">n\times T</code> for
<code class="reqn">n</code>-dimensional curve on <code class="reqn">T</code> sample points</p>
</td></tr>
<tr><td><code id="calc_shape_dist_+3A_beta2">beta2</code></td>
<td>
<p>curve 2, provided as a matrix of sizes <code class="reqn">n\times T</code> for
<code class="reqn">n</code>-dimensional curve on <code class="reqn">T</code> sample points</p>
</td></tr>
<tr><td><code id="calc_shape_dist_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
<tr><td><code id="calc_shape_dist_+3A_rotation">rotation</code></td>
<td>
<p>Include rotation (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="calc_shape_dist_+3A_scale">scale</code></td>
<td>
<p>scale curves to unit length (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="calc_shape_dist_+3A_include.length">include.length</code></td>
<td>
<p>include length in distance calculation (default = <code>FALSE</code>)
this only applies if <code>scale=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>d</code></td>
<td>
<p>geodesic distance</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>phase distance</p>
</td></tr>
<tr><td><code>q1</code></td>
<td>
<p>srvf of curve 1</p>
</td></tr>
<tr><td><code>q2n</code></td>
<td>
<p>srvf of aligned curve 2</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape
analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine
Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>
<p>Kurtek, S., Srivastava, A., Klassen, E., and Ding, Z. (2012),
“Statistical Modeling of Curves Using Shapes and Related Features,” Journal
of the American Statistical Association, 107, 1152–1165.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- calc_shape_dist(beta[, , 1, 1], beta[, , 1, 4])
</code></pre>

<hr>
<h2 id='curve_depth'>Calculates elastic depth for a set of curves</h2><span id='topic+curve_depth'></span>

<h3>Description</h3>

<p>This functions calculates the elastic depth between set of curves. If the
curves are describing multidimensional functional data, then
<code>rotated == FALSE</code> and <code>mode == 'O'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_depth(beta, mode = "O", rotated = TRUE, scale = TRUE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_depth_+3A_beta">beta</code></td>
<td>
<p>Array of sizes <code class="reqn">n \times T \times N</code> for <code class="reqn">N</code> curves
of dimension <code class="reqn">n</code> evaluated on a grid of <code class="reqn">T</code> points</p>
</td></tr>
<tr><td><code id="curve_depth_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
<tr><td><code id="curve_depth_+3A_rotated">rotated</code></td>
<td>
<p>Include rotation (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="curve_depth_+3A_scale">scale</code></td>
<td>
<p>scale curves to unit length (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="curve_depth_+3A_parallel">parallel</code></td>
<td>
<p>run computation in parallel (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>amplitude depth</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>phase depth</p>
</td></tr>
</table>


<h3>References</h3>

<p>T. Harris, J. D. Tucker, B. Li, and L. Shand, &quot;Elastic depths for
detecting shape anomalies in functional data,&quot; Technometrics,
10.1080/00401706.2020.1811156, 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mpeg7")
# note: use more shapes and iterations, small for speed
out = curve_depth(beta[,,1,1:2])
</code></pre>

<hr>
<h2 id='curve_geodesic'>Form geodesic between two curves</h2><span id='topic+curve_geodesic'></span>

<h3>Description</h3>

<p>Form geodesic between two curves using Elastic Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_geodesic(beta1, beta2, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_geodesic_+3A_beta1">beta1</code></td>
<td>
<p>curve 1, provided as a matrix of dimensions <code class="reqn">n \times T</code> for
<code class="reqn">n</code>-dimensional curve evaluated on <code class="reqn">T</code> sample points</p>
</td></tr>
<tr><td><code id="curve_geodesic_+3A_beta2">beta2</code></td>
<td>
<p>curve 2, provided as a matrix of dimensions <code class="reqn">n \times T</code> for
<code class="reqn">n</code>-dimensional curve evaluated on <code class="reqn">T</code> sample points</p>
</td></tr>
<tr><td><code id="curve_geodesic_+3A_k">k</code></td>
<td>
<p>number of curves along geodesic (default <code>5</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing </p>
<table>
<tr><td><code>geod</code></td>
<td>
<p>curves along geodesic (n,T,k)</p>
</td></tr>
<tr><td><code>geod_q</code></td>
<td>
<p>srvf's along geodesic</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- curve_geodesic(beta[, , 1, 1], beta[, , 1, 5])
</code></pre>

<hr>
<h2 id='curve_karcher_cov'>Curve Karcher Covariance</h2><span id='topic+curve_karcher_cov'></span>

<h3>Description</h3>

<p>Calculate Karcher Covariance of a set of curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_karcher_cov(v, len = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_karcher_cov_+3A_v">v</code></td>
<td>
<p>array of sizes <code class="reqn">n \times T \times N</code> for <code class="reqn">N</code> shooting
vectors of dimension <code class="reqn">n</code> evaluated on a grid of <code class="reqn">T</code> points</p>
</td></tr>
<tr><td><code id="curve_karcher_cov_+3A_len">len</code></td>
<td>
<p>lengths of curves (default = <code>NA</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>K covariance matrix
</p>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- curve_karcher_mean(beta[, , 1, 1:2], maxit = 2)
# note: use more shapes, small for speed
K &lt;- curve_karcher_cov(out$v)
</code></pre>

<hr>
<h2 id='curve_karcher_mean'>Karcher Mean of Curves</h2><span id='topic+curve_karcher_mean'></span>

<h3>Description</h3>

<p>Calculates Karcher mean or median of a collection of curves using the elastic
square-root velocity (srvf) framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_karcher_mean(
  beta,
  mode = "O",
  rotated = TRUE,
  scale = TRUE,
  lambda = 0,
  maxit = 20,
  ms = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_karcher_mean_+3A_beta">beta</code></td>
<td>
<p>Array of sizes <code class="reqn">n \times T \times N</code> describing <code class="reqn">N</code>
curves of dimension <code class="reqn">n</code> evaluated on <code class="reqn">T</code> points</p>
</td></tr>
<tr><td><code id="curve_karcher_mean_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
<tr><td><code id="curve_karcher_mean_+3A_rotated">rotated</code></td>
<td>
<p>Optimize over rotation (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="curve_karcher_mean_+3A_scale">scale</code></td>
<td>
<p>scale curves to unit length (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="curve_karcher_mean_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the elasticity. Defaults to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="curve_karcher_mean_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="curve_karcher_mean_+3A_ms">ms</code></td>
<td>
<p>string defining whether the Karcher mean (<code>"mean"</code>) or Karcher
median (<code>"median"</code>) is returned (default = <code>"mean"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>mean srvf</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>centered data</p>
</td></tr>
<tr><td><code>betamean</code></td>
<td>
<p>mean or median curve</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>string indicating whether mean or median is returned</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>shooting vectors</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>array of srvfs</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>array of warping functions</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>centers of original curves</p>
</td></tr>
<tr><td><code>len</code></td>
<td>
<p>length of curves</p>
</td></tr>
<tr><td><code>len_q</code></td>
<td>
<p>length of srvfs</p>
</td></tr>
<tr><td><code>mean_scale</code></td>
<td>
<p>mean length</p>
</td></tr>
<tr><td><code>mean_scale_q</code></td>
<td>
<p>mean length srvf</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>energy</p>
</td></tr>
<tr><td><code>qun</code></td>
<td>
<p>cost function</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape
analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine
Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- curve_karcher_mean(beta[, , 1, 1:2], maxit = 2)
# note: use more shapes, small for speed
</code></pre>

<hr>
<h2 id='curve_pair_align'>Pairwise align two curves</h2><span id='topic+curve_pair_align'></span>

<h3>Description</h3>

<p>This function aligns to curves using Elastic Framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_pair_align(beta1, beta2, mode = "O", rotation = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_pair_align_+3A_beta1">beta1</code></td>
<td>
<p>curve 1, provided as a matrix of dimensions <code class="reqn">n \times T</code> for
<code class="reqn">n</code>-dimensional curve evaluated on <code class="reqn">T</code> sample points</p>
</td></tr>
<tr><td><code id="curve_pair_align_+3A_beta2">beta2</code></td>
<td>
<p>curve 2, provided as a matrix of dimensions <code class="reqn">n \times T</code> for
<code class="reqn">n</code>-dimensional curve evaluated on <code class="reqn">T</code> sample points</p>
</td></tr>
<tr><td><code id="curve_pair_align_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
<tr><td><code id="curve_pair_align_+3A_rotation">rotation</code></td>
<td>
<p>Include rotation (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="curve_pair_align_+3A_scale">scale</code></td>
<td>
<p>scale curves to unit length (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing </p>
<table>
<tr><td><code>beta2n</code></td>
<td>
<p>aligned curve 2 to 1</p>
</td></tr>
<tr><td><code>q2n</code></td>
<td>
<p>aligned srvf 2 to 1</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>warping function</p>
</td></tr>
<tr><td><code>q1</code></td>
<td>
<p>srvf of curve 1</p>
</td></tr>
<tr><td><code>beta1</code></td>
<td>
<p>centered curve 1</p>
</td></tr>
<tr><td><code>beta2</code></td>
<td>
<p>centered curve 2</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>rotation matrix</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>seed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape
analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine
Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- curve_pair_align(beta[, , 1, 1], beta[, , 1, 5])
</code></pre>

<hr>
<h2 id='curve_principal_directions'>Curve PCA</h2><span id='topic+curve_principal_directions'></span>

<h3>Description</h3>

<p>Calculate principal directions of a set of curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_principal_directions(v, K, mu, len = NA, no = 3, N = 5, mode = "O")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_principal_directions_+3A_v">v</code></td>
<td>
<p>array of sizes <code class="reqn">n \times T \times N1</code> for <code class="reqn">N1</code> shooting
vectors of dimension <code class="reqn">n</code> evaluated on a grid of <code class="reqn">T</code> points</p>
</td></tr>
<tr><td><code id="curve_principal_directions_+3A_k">K</code></td>
<td>
<p>matrix of sizes <code class="reqn">nT \times nT</code> of covariance matrix</p>
</td></tr>
<tr><td><code id="curve_principal_directions_+3A_mu">mu</code></td>
<td>
<p>matrix of sizes <code class="reqn">n \times T</code> of mean srvf</p>
</td></tr>
<tr><td><code id="curve_principal_directions_+3A_len">len</code></td>
<td>
<p>length of original curves (default = <code>NA</code>)</p>
</td></tr>
<tr><td><code id="curve_principal_directions_+3A_no">no</code></td>
<td>
<p>number of components</p>
</td></tr>
<tr><td><code id="curve_principal_directions_+3A_n">N</code></td>
<td>
<p>number of samples on each side of mean</p>
</td></tr>
<tr><td><code id="curve_principal_directions_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>s</code></td>
<td>
<p>singular values</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>singular vectors</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>principal coefficients</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p>principal directions</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- curve_karcher_mean(beta[, , 1, 1:2], maxit = 2)
# note: use more shapes, small for speed
K &lt;- curve_karcher_cov(out$v)
out &lt;- curve_principal_directions(out$v, K, out$mu)
</code></pre>

<hr>
<h2 id='curve_srvf_align'>Align Curves</h2><span id='topic+curve_srvf_align'></span>

<h3>Description</h3>

<p>Aligns a collection of curves using the elastic square-root velocity (srvf)
framework. If the curves are describing multidimensional functional data, then
<code>rotated == FALSE</code> and <code>mode == 'O'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_srvf_align(
  beta,
  mode = "O",
  rotated = TRUE,
  scale = FALSE,
  lambda = 0,
  maxit = 20,
  ms = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_srvf_align_+3A_beta">beta</code></td>
<td>
<p>Array of sizes <code class="reqn">n \times T \times N</code> for <code class="reqn">N</code> curves
of dimension <code class="reqn">n</code> evaluated on a grid of <code class="reqn">T</code> points</p>
</td></tr>
<tr><td><code id="curve_srvf_align_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
<tr><td><code id="curve_srvf_align_+3A_rotated">rotated</code></td>
<td>
<p>Optimize over rotation (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="curve_srvf_align_+3A_scale">scale</code></td>
<td>
<p>Include scale (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="curve_srvf_align_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the elasticity. Defaults to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="curve_srvf_align_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="curve_srvf_align_+3A_ms">ms</code></td>
<td>
<p>string defining whether the Karcher mean (&quot;mean&quot;) or Karcher median (&quot;median&quot;) is returned (default = &quot;mean&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>betan</code></td>
<td>
<p>aligned curves</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>aligned srvfs</p>
</td></tr>
<tr><td><code>betamean</code></td>
<td>
<p>mean curve</p>
</td></tr>
<tr><td><code>q_mu</code></td>
<td>
<p>mean SRVFs</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mpeg7")
# note: use more shapes and iterations, small for speed
out = curve_srvf_align(beta[,,1,1:2],maxit=2)
</code></pre>

<hr>
<h2 id='curve_to_q'>Convert to SRVF space</h2><span id='topic+curve_to_q'></span>

<h3>Description</h3>

<p>This function converts curves or multidimesional functional data to SRVF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_to_q(beta, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_to_q_+3A_beta">beta</code></td>
<td>
<p>either a matrix of shape <code class="reqn">n \times T</code> describing curve or
multidimensional functional data in <code class="reqn">R^n</code>, where <code class="reqn">n</code> is the dimension
and <code class="reqn">T</code> is the number of time points</p>
</td></tr>
<tr><td><code id="curve_to_q_+3A_scale">scale</code></td>
<td>
<p>scale curve to unit length (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric array of the same shape as the input array <code>beta</code> storing the
SRVFs of the original curves.
</p>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011).
Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and M
achine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- curve_to_q(beta[, , 1, 1])$q
</code></pre>

<hr>
<h2 id='elastic_amp_change_ff'>Elastic Amplitude Changepoint Detection</h2><span id='topic+elastic_amp_change_ff'></span>

<h3>Description</h3>

<p>This function identifies a amplitude changepoint using a fully functional
approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic_amp_change_ff(
  f,
  time,
  d = 1000,
  h = 0,
  smooth_data = FALSE,
  sparam = 25,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic_amp_change_ff_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic_amp_change_ff_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic_amp_change_ff_+3A_d">d</code></td>
<td>
<p>number of monte carlo iterations of Brownian Bridge (default = 1000)</p>
</td></tr>
<tr><td><code id="elastic_amp_change_ff_+3A_h">h</code></td>
<td>
<p>window selection of long range covariance function (default = 0)</p>
</td></tr>
<tr><td><code id="elastic_amp_change_ff_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic_amp_change_ff_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic_amp_change_ff_+3A_showplot">showplot</code></td>
<td>
<p>show results plots (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object containing
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p>p value</p>
</td></tr>
<tr><td><code>change</code></td>
<td>
<p>indice of changepoint</p>
</td></tr>
<tr><td><code>DataBefore</code></td>
<td>
<p>functions before changepoint</p>
</td></tr>
<tr><td><code>DataAfter</code></td>
<td>
<p>functions after changepoint</p>
</td></tr>
<tr><td><code>MeanBefore</code></td>
<td>
<p>mean function before changepoint</p>
</td></tr>
<tr><td><code>MeanAfter</code></td>
<td>
<p>mean function after changepoint</p>
</td></tr>
<tr><td><code>WarpingBefore</code></td>
<td>
<p>warping functions before changepoint</p>
</td></tr>
<tr><td><code>WarpingAfter</code></td>
<td>
<p>warping functions after changepoint</p>
</td></tr>
<tr><td><code>WarpingMeanBefore</code></td>
<td>
<p>mean warping function before changepoint</p>
</td></tr>
<tr><td><code>WarpingMeanAfter</code></td>
<td>
<p>mean warping function after changepoint</p>
</td></tr>
<tr><td><code>change_fun</code></td>
<td>
<p>amplitude change function</p>
</td></tr>
<tr><td><code>Sn</code></td>
<td>
<p>test statistic values</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>mean srsfs</p>
</td></tr>
<tr><td><code>mu_f</code></td>
<td>
<p>mean functions</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker and D. Yarger, “Elastic Functional Changepoint
Detection of Climate Impacts from Localized Sources”, Envirometrics,
10.1002/env.2826, 2023.
</p>

<hr>
<h2 id='elastic_change_fpca'>Elastic Changepoint Detection</h2><span id='topic+elastic_change_fpca'></span>

<h3>Description</h3>

<p>This function identifies changepoints using a functional PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic_change_fpca(
  f,
  time,
  pca.method = "combined",
  pc = 0.95,
  d = 1000,
  n_pcs = 5,
  smooth_data = FALSE,
  sparam = 25,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic_change_fpca_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_pca.method">pca.method</code></td>
<td>
<p>string specifying pca method (options = &quot;combined&quot;,
&quot;vert&quot;, or &quot;horiz&quot;, default = &quot;combined&quot;)</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_pc">pc</code></td>
<td>
<p>percentage of cummulation explained variance (default = 0.95)</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_d">d</code></td>
<td>
<p>number of monte carlo iterations of Brownian Bridge (default = 1000)</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_n_pcs">n_pcs</code></td>
<td>
<p>scalar specify number of principal components (default = 5)</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic_change_fpca_+3A_showplot">showplot</code></td>
<td>
<p>show results plots (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object containing
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p>p value</p>
</td></tr>
<tr><td><code>change</code></td>
<td>
<p>indice of changepoint</p>
</td></tr>
<tr><td><code>DataBefore</code></td>
<td>
<p>functions before changepoint</p>
</td></tr>
<tr><td><code>DataAfter</code></td>
<td>
<p>functions after changepoint</p>
</td></tr>
<tr><td><code>MeanBefore</code></td>
<td>
<p>mean function before changepoint</p>
</td></tr>
<tr><td><code>MeanAfter</code></td>
<td>
<p>mean function after changepoint</p>
</td></tr>
<tr><td><code>WarpingBefore</code></td>
<td>
<p>warping functions before changepoint</p>
</td></tr>
<tr><td><code>WarpingAfter</code></td>
<td>
<p>warping functions after changepoint</p>
</td></tr>
<tr><td><code>WarpingMeanBefore</code></td>
<td>
<p>mean warping function before changepoint</p>
</td></tr>
<tr><td><code>WarpingMeanAfter</code></td>
<td>
<p>mean warping function after changepoint</p>
</td></tr>
<tr><td><code>change_fun</code></td>
<td>
<p>amplitude change function</p>
</td></tr>
<tr><td><code>Sn</code></td>
<td>
<p>test statistic values</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker and D. Yarger, “Elastic Functional Changepoint
Detection of Climate Impacts from Localized Sources”, Envirometrics,
10.1002/env.2826, 2023.
</p>

<hr>
<h2 id='elastic_ph_change_ff'>Elastic Phase Changepoint Detection</h2><span id='topic+elastic_ph_change_ff'></span>

<h3>Description</h3>

<p>This function identifies a phase changepoint using a fully functional
approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic_ph_change_ff(
  f,
  time,
  d = 1000,
  h = 0,
  smooth_data = FALSE,
  sparam = 25,
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic_ph_change_ff_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic_ph_change_ff_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic_ph_change_ff_+3A_d">d</code></td>
<td>
<p>number of monte carlo iterations of Brownian Bridge (default = 1000)</p>
</td></tr>
<tr><td><code id="elastic_ph_change_ff_+3A_h">h</code></td>
<td>
<p>window selection of long range covariance function (default = 0)</p>
</td></tr>
<tr><td><code id="elastic_ph_change_ff_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic_ph_change_ff_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic_ph_change_ff_+3A_showplot">showplot</code></td>
<td>
<p>show results plots (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object containing
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p>p value</p>
</td></tr>
<tr><td><code>change</code></td>
<td>
<p>indice of changepoint</p>
</td></tr>
<tr><td><code>DataBefore</code></td>
<td>
<p>functions before changepoint</p>
</td></tr>
<tr><td><code>DataAfter</code></td>
<td>
<p>functions after changepoint</p>
</td></tr>
<tr><td><code>MeanBefore</code></td>
<td>
<p>mean function before changepoint</p>
</td></tr>
<tr><td><code>MeanAfter</code></td>
<td>
<p>mean function after changepoint</p>
</td></tr>
<tr><td><code>WarpingBefore</code></td>
<td>
<p>warping functions before changepoint</p>
</td></tr>
<tr><td><code>WarpingAfter</code></td>
<td>
<p>warping functions after changepoint</p>
</td></tr>
<tr><td><code>WarpingMeanBefore</code></td>
<td>
<p>mean warping function before changepoint</p>
</td></tr>
<tr><td><code>WarpingMeanAfter</code></td>
<td>
<p>mean warping function after changepoint</p>
</td></tr>
<tr><td><code>change_fun</code></td>
<td>
<p>amplitude change function</p>
</td></tr>
<tr><td><code>Sn</code></td>
<td>
<p>test statistic values</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>mean shooting vectors</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker and D. Yarger, “Elastic Functional Changepoint
Detection of Climate Impacts from Localized Sources”, Envirometrics,
10.1002/env.2826, 2023.
</p>

<hr>
<h2 id='elastic.depth'>Calculates elastic depth</h2><span id='topic+elastic.depth'></span>

<h3>Description</h3>

<p>This functions calculates the elastic depth between set of functions in
<code class="reqn">R^1</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.depth(f, time, lambda = 0, pen = "roughness", parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.depth_+3A_f">f</code></td>
<td>
<p>matrix of sizes <code class="reqn">M \times N</code>, specifying values of <code class="reqn">N</code>
function of <code class="reqn">M</code> time points</p>
</td></tr>
<tr><td><code id="elastic.depth_+3A_time">time</code></td>
<td>
<p>vector of length <code class="reqn">M</code>, specifying the sample points of functions</p>
</td></tr>
<tr><td><code id="elastic.depth_+3A_lambda">lambda</code></td>
<td>
<p>controls amount of warping (default = <code>0</code>)</p>
</td></tr>
<tr><td><code id="elastic.depth_+3A_pen">pen</code></td>
<td>
<p>alignment penalty (default = <code>"roughness"</code>) options are
second derivative (<code>"roughness"</code>), geodesic distance from id (<code>"geodesic"</code>),
and norm from id (<code>"norm"</code>)</p>
</td></tr>
<tr><td><code id="elastic.depth_+3A_parallel">parallel</code></td>
<td>
<p>run computation in parallel (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>amplitude depth</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>phase depth</p>
</td></tr>
</table>


<h3>References</h3>

<p>T. Harris, J. D. Tucker, B. Li, and L. Shand, &quot;Elastic depths for
detecting shape anomalies in functional data,&quot; Technometrics,
10.1080/00401706.2020.1811156, 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depths &lt;- elastic.depth(simu_data$f[, 1:4], simu_data$time)
</code></pre>

<hr>
<h2 id='elastic.distance'>Calculates two elastic distance</h2><span id='topic+elastic.distance'></span>

<h3>Description</h3>

<p>This functions calculates the distances between functions in <code class="reqn">R^1</code>
<code class="reqn">D_y</code> and <code class="reqn">D_x</code>, where function 1 is aligned to function 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.distance(f1, f2, time, lambda = 0, pen = "roughness")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.distance_+3A_f1">f1</code></td>
<td>
<p>sample function 1, provided as a vector of length <code class="reqn">M</code></p>
</td></tr>
<tr><td><code id="elastic.distance_+3A_f2">f2</code></td>
<td>
<p>sample function 2, provided as a vector of length <code class="reqn">M</code></p>
</td></tr>
<tr><td><code id="elastic.distance_+3A_time">time</code></td>
<td>
<p>sample points of functions, provided as a vector of length
<code class="reqn">M</code></p>
</td></tr>
<tr><td><code id="elastic.distance_+3A_lambda">lambda</code></td>
<td>
<p>controls amount of warping (default = <code>0</code>)</p>
</td></tr>
<tr><td><code id="elastic.distance_+3A_pen">pen</code></td>
<td>
<p>alignment penalty (default = <code>"roughness"</code>) options are
second derivative (<code>"roughness"</code>), geodesic distance from id (<code>"geodesic"</code>),
and norm from id (<code>"norm"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>Dy</code></td>
<td>
<p>amplitude distance</p>
</td></tr>
<tr><td><code>Dx</code></td>
<td>
<p>phase distance</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distances &lt;- elastic.distance(
  f1 = simu_data$f[, 1],
  f2 = simu_data$f[, 2],
  time = simu_data$time
)
</code></pre>

<hr>
<h2 id='elastic.logistic'>Elastic Logistic Regression</h2><span id='topic+elastic.logistic'></span>

<h3>Description</h3>

<p>This function identifies a logistic regression model with
phase-variability using elastic methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.logistic(
  f,
  y,
  time,
  B = NULL,
  df = 20,
  max_itr = 20,
  smooth_data = FALSE,
  sparam = 25,
  parallel = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.logistic_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">M</code> labels (1/-1)</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_b">B</code></td>
<td>
<p>matrix defining basis functions (default = NULL)</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_df">df</code></td>
<td>
<p>scalar controlling degrees of freedom if B=NULL (default=20)</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_max_itr">max_itr</code></td>
<td>
<p>scalar number of iterations (default=20)</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_parallel">parallel</code></td>
<td>
<p>enable parallel mode using <code><a href="foreach.html#topic+foreach">foreach()</a></code> and
<code>doParallel</code> package</p>
</td></tr>
<tr><td><code id="elastic.logistic_+3A_cores">cores</code></td>
<td>
<p>set number of cores to use with <code>doParallel</code> (default = 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>model intercept</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>regressor function</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>aligned functions - matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>aligned srvfs - similar structure to fn</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>warping functions - similar structure to fn</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>original srvf - similar structure to fn</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>basis matrix</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>basis coefficients</p>
</td></tr>
<tr><td><code>Loss</code></td>
<td>
<p>logistic loss</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>model type ('logistic')</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Elastic Functional Logistic Regression with Application to Physiological Signal Classification,
Electronic Journal of Statistics (2014), submitted.
</p>

<hr>
<h2 id='elastic.lpcr.regression'>Elastic logistic Principal Component Regression</h2><span id='topic+elastic.lpcr.regression'></span>

<h3>Description</h3>

<p>This function identifies a logistic regression model with phase-variability
using elastic pca
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.lpcr.regression(
  f,
  y,
  time,
  pca.method = "combined",
  no = 5,
  smooth_data = FALSE,
  sparam = 25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.lpcr.regression_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.lpcr.regression_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">M</code> labels</p>
</td></tr>
<tr><td><code id="elastic.lpcr.regression_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.lpcr.regression_+3A_pca.method">pca.method</code></td>
<td>
<p>string specifying pca method (options = &quot;combined&quot;,
&quot;vert&quot;, or &quot;horiz&quot;, default = &quot;combined&quot;)</p>
</td></tr>
<tr><td><code id="elastic.lpcr.regression_+3A_no">no</code></td>
<td>
<p>scalar specify number of principal components (default=5)</p>
</td></tr>
<tr><td><code id="elastic.lpcr.regression_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.lpcr.regression_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a lpcr object containing
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>model intercept</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>regressor vector</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>label vector</p>
</td></tr>
<tr><td><code>warp_data</code></td>
<td>
<p>fdawarp object of aligned data</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>pca object of principal components</p>
</td></tr>
<tr><td><code>Loss</code></td>
<td>
<p>logistic loss</p>
</td></tr>
<tr><td><code>pca.method</code></td>
<td>
<p>string specifying pca method used</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic
Functional Principal Component Regression,” Statistical Analysis and Data
Mining, 10.1002/sam.11399, 2018.
</p>

<hr>
<h2 id='elastic.mlogistic'>Elastic Multinomial Logistic Regression</h2><span id='topic+elastic.mlogistic'></span>

<h3>Description</h3>

<p>This function identifies a multinomial logistic regression model with
phase-variability using elastic methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.mlogistic(
  f,
  y,
  time,
  B = NULL,
  df = 20,
  max_itr = 20,
  smooth_data = FALSE,
  sparam = 25,
  parallel = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.mlogistic_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">M</code> labels (1,2,...,m) for m classes</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_b">B</code></td>
<td>
<p>matrix defining basis functions (default = NULL)</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_df">df</code></td>
<td>
<p>scalar controlling degrees of freedom if B=NULL (default=20)</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_max_itr">max_itr</code></td>
<td>
<p>scalar number of iterations (default=20)</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_parallel">parallel</code></td>
<td>
<p>enable parallel mode using <code><a href="foreach.html#topic+foreach">foreach()</a></code> and
<code>doParallel</code> package</p>
</td></tr>
<tr><td><code id="elastic.mlogistic_+3A_cores">cores</code></td>
<td>
<p>set number of cores to use with <code>doParallel</code> (default = 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>model intercept</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>regressor function</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>aligned functions - matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>aligned srvfs - similar structure to fn</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>warping functions - similar structure to fn</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>original srvf - similar structure to fn</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>basis matrix</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>basis coefficients</p>
</td></tr>
<tr><td><code>Loss</code></td>
<td>
<p>logistic loss</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>model type ('mlogistic')</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Elastic Functional Logistic Regression with Application to Physiological Signal Classification,
Electronic Journal of Statistics (2014), submitted.
</p>

<hr>
<h2 id='elastic.mlpcr.regression'>Elastic Multinomial logistic Principal Component Regression</h2><span id='topic+elastic.mlpcr.regression'></span>

<h3>Description</h3>

<p>This function identifies a multinomial logistic regression model with phase-variability
using elastic pca
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.mlpcr.regression(
  f,
  y,
  time,
  pca.method = "combined",
  no = 5,
  smooth_data = FALSE,
  sparam = 25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.mlpcr.regression_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.mlpcr.regression_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">M</code> labels</p>
</td></tr>
<tr><td><code id="elastic.mlpcr.regression_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.mlpcr.regression_+3A_pca.method">pca.method</code></td>
<td>
<p>string specifying pca method (options = &quot;combined&quot;,
&quot;vert&quot;, or &quot;horiz&quot;, default = &quot;combined&quot;)</p>
</td></tr>
<tr><td><code id="elastic.mlpcr.regression_+3A_no">no</code></td>
<td>
<p>scalar specify number of principal components (default=5)</p>
</td></tr>
<tr><td><code id="elastic.mlpcr.regression_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.mlpcr.regression_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a mlpcr object containing
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>model intercept</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>regressor vector</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>label vector</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Coded labels</p>
</td></tr>
<tr><td><code>warp_data</code></td>
<td>
<p>fdawarp object of aligned data</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>pca object of principal components</p>
</td></tr>
<tr><td><code>Loss</code></td>
<td>
<p>logistic loss</p>
</td></tr>
<tr><td><code>pca.method</code></td>
<td>
<p>string specifying pca method used</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic
Functional Principal Component Regression,” Statistical Analysis and Data
Mining, 10.1002/sam.11399, 2018.
</p>

<hr>
<h2 id='elastic.pcr.regression'>Elastic Linear Principal Component Regression</h2><span id='topic+elastic.pcr.regression'></span>

<h3>Description</h3>

<p>This function identifies a regression model with phase-variability
using elastic pca
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.pcr.regression(
  f,
  y,
  time,
  pca.method = "combined",
  no = 5,
  smooth_data = FALSE,
  sparam = 25,
  parallel = F,
  C = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.pcr.regression_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">M</code> responses</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_pca.method">pca.method</code></td>
<td>
<p>string specifying pca method (options = &quot;combined&quot;,
&quot;vert&quot;, or &quot;horiz&quot;, default = &quot;combined&quot;)</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_no">no</code></td>
<td>
<p>scalar specify number of principal components (default = 5)</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_parallel">parallel</code></td>
<td>
<p>run in parallel (default = F)</p>
</td></tr>
<tr><td><code id="elastic.pcr.regression_+3A_c">C</code></td>
<td>
<p>scale balance parameter for combined method (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a pcr object containing
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>model intercept</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>regressor vector</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code>warp_data</code></td>
<td>
<p>fdawarp object of aligned data</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>pca object of principal components</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>sum of squared errors</p>
</td></tr>
<tr><td><code>pca.method</code></td>
<td>
<p>string specifying pca method used</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic
Functional Principal Component Regression,” Statistical Analysis and Data
Mining, 10.1002/sam.11399, 2018.
</p>

<hr>
<h2 id='elastic.prediction'>Elastic Prediction from Regression Models</h2><span id='topic+elastic.prediction'></span>

<h3>Description</h3>

<p>This function performs prediction from an elastic regression model
with phase-variability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.prediction(f, time, model, y = NULL, smooth_data = FALSE, sparam = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.prediction_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.prediction_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.prediction_+3A_model">model</code></td>
<td>
<p>list describing model from elastic regression methods</p>
</td></tr>
<tr><td><code id="elastic.prediction_+3A_y">y</code></td>
<td>
<p>responses of test matrix f (default=NULL)</p>
</td></tr>
<tr><td><code id="elastic.prediction_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.prediction_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>y_pred</code></td>
<td>
<p>predicted values of f or probabilities depending on model</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>sum of squared errors if linear</p>
</td></tr>
<tr><td><code>y_labels</code></td>
<td>
<p>labels if logistic model</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>probability of classification if logistic</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Elastic Functional Logistic Regression with Application to Physiological Signal Classification,
Electronic Journal of Statistics (2014), submitted.
</p>

<hr>
<h2 id='elastic.regression'>Elastic Linear Regression</h2><span id='topic+elastic.regression'></span>

<h3>Description</h3>

<p>This function identifies a regression model with phase-variability
using elastic methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.regression(
  f,
  y,
  time,
  B = NULL,
  lam = 0,
  df = 20,
  max_itr = 20,
  smooth_data = FALSE,
  sparam = 25,
  parallel = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.regression_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_y">y</code></td>
<td>
<p>vector of size <code class="reqn">M</code> responses</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_b">B</code></td>
<td>
<p>matrix defining basis functions (default = NULL)</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_lam">lam</code></td>
<td>
<p>scalar regularization parameter (default=0)</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_df">df</code></td>
<td>
<p>scalar controlling degrees of freedom if B=NULL (default=20)</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_max_itr">max_itr</code></td>
<td>
<p>scalar number of iterations (default=20)</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_parallel">parallel</code></td>
<td>
<p>enable parallel mode using <code><a href="foreach.html#topic+foreach">foreach()</a></code> and
<code>doParallel</code> package</p>
</td></tr>
<tr><td><code id="elastic.regression_+3A_cores">cores</code></td>
<td>
<p>set number of cores to use with <code>doParallel</code> (default = 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>model intercept</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>regressor function</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>aligned functions - matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>aligned srvfs - similar structure to fn</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>warping functions - similar structure to fn</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>original srvf - similar structure to fn</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>basis matrix</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>basis coefficients</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>sum of squared errors</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>model type ('linear')</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Elastic Functional Logistic Regression with Application to Physiological Signal Classification,
Electronic Journal of Statistics (2014), submitted.
</p>

<hr>
<h2 id='f_to_srvf'>Transformation to SRVF Space</h2><span id='topic+f_to_srvf'></span>

<h3>Description</h3>

<p>This function transforms functions in <code class="reqn">R^1</code> from their original functional
space to the SRVF space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_to_srvf(f, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_to_srvf_+3A_f">f</code></td>
<td>
<p>Either a numeric vector of a numeric matrix or a numeric array
specifying the functions that need to be transformed.
</p>

<ul>
<li><p> If a vector, it must be of shape <code class="reqn">M</code> and it is interpreted as a
single <code class="reqn">1</code>-dimensional curve observed on a grid of size <code class="reqn">M</code>.
</p>
</li>
<li><p> If a matrix, it must be of shape
<code class="reqn">M \times N</code>. In this case, it is interpreted as a sample of <code class="reqn">N</code>
curves observed on a grid of size <code class="reqn">M</code>, unless <code class="reqn">M = 1</code> in which case
it is interpreted as a single <code class="reqn">1</code>-dimensional curve observed on a grid
of size <code class="reqn">M</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="f_to_srvf_+3A_time">time</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> specifying the grid on which
the functions are evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of the same shape as the input array <code>f</code> storing the
SRVFs of the original curves.
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using Fisher-Rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using phase and amplitude Separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- f_to_srvf(simu_data$f, simu_data$time)
</code></pre>

<hr>
<h2 id='fdasrvf'>Elastic Functional Data Analysis</h2><span id='topic+fdasrvf'></span><span id='topic+fdasrvf-package'></span>

<h3>Description</h3>

<p>A library for functional data analysis using the square root velocity
framework which performs pair-wise and group-wise alignment as well as
modeling using functional component analysis.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: J. Derek Tucker <a href="mailto:jdtuck@sandia.gov">jdtuck@sandia.gov</a> (<a href="https://orcid.org/0000-0001-8844-2169">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Aymeric Stamm <a href="mailto:aymeric.stamm@math.cnrs.fr">aymeric.stamm@math.cnrs.fr</a> (<a href="https://orcid.org/0000-0002-8725-3654">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using Fisher-Rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using phase and amplitude separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>
<p>J. D. Tucker, W. Wu, and A. Srivastava, Phase-amplitude
separation of proteomics data using extended Fisher-Rao metric, Electronic
Journal of Statistics, Vol 8, no. 2. pp 1724-1733, 2014.
</p>
<p>J. D. Tucker, W. Wu, and A. Srivastava, &ldquo;Analysis of signals
under compositional noise with applications to SONAR data,&quot; IEEE Journal of
Oceanic Engineering, Vol 29, no. 2. pp 318-330, Apr 2014.
</p>
<p>Tucker, J. D. 2014, Functional Component Analysis and Regression
using Elastic Methods. Ph.D. Thesis, Florida State University.
</p>
<p>Robinson, D. T. 2012, Function Data Analysis and Partial Shape
Matching in the Square Root Velocity Framework. Ph.D. Thesis, Florida State
University.
</p>
<p>Kurtek, S., Srivastava, A., Klassen, E., and Ding, Z. (2012),
“Statistical Modeling of Curves Using Shapes and Related Features,” Journal
of the American Statistical Association, 107, 1152–1165.
</p>
<p>Huang, W. 2014, Optimization Algorithms on Riemannian Manifolds
with Applications. Ph.D. Thesis, Florida State University.
</p>
<p>Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian
registration of functions and curves. Bayesian Analysis, 11(2), 447-475.
</p>
<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape
analysis of elastic curves in euclidean spaces. Pattern Analysis and
Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>
<p>Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian
registration of functions and curves. Bayesian Analysis, 11(2), 447-475.
</p>
<p>W. Xie, S. Kurtek, K. Bharath, and Y. Sun, A geometric approach
to visualization of variability in functional data, Journal of American
Statistical Association 112 (2017), pp. 979-993.
</p>
<p>Lu, Y., R. Herbei, and S. Kurtek, 2017: Bayesian registration of
functions with a Gaussian process prior. Journal of Computational and
Graphical Statistics, 26, no. 4, 894–904.
</p>
<p>Lee, S. and S. Jung, 2017: Combined analysis of amplitude and
phase variations in functional data. arXiv:1603.01775, 1–21.
</p>
<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic Functional
Principal Component Regression,” Statistical Analysis and Data Mining, vol.
12, no. 2, pp. 101-115, 2019.
</p>
<p>J. D. Tucker, J. R. Lewis, C. King, and S. Kurtek, “A Geometric
Approach for Computing Tolerance Bounds for Elastic Functional Data,”
Journal of Applied Statistics, 10.1080/02664763.2019.1645818, 2019.
</p>
<p>T. Harris, J. D. Tucker, B. Li, and L. Shand, &quot;Elastic depths for
detecting shape anomalies in functional data,&quot; Technometrics,
10.1080/00401706.2020.1811156, 2020.
</p>
<p>J. D. Tucker and D. Yarger, “Elastic Functional Changepoint
Detection of Climate Impacts from Localized Sources”, Envirometrics,
10.1002/env.2826, 2023.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jdtuck/fdasrvf_R">https://github.com/jdtuck/fdasrvf_R</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jdtuck/fdasrvf_R/issues">https://github.com/jdtuck/fdasrvf_R/issues</a>
</p>
</li></ul>


<hr>
<h2 id='function_group_warp_bayes'>Bayesian Group Warping</h2><span id='topic+function_group_warp_bayes'></span>

<h3>Description</h3>

<p>This function aligns a set of functions using Bayesian SRSF framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_group_warp_bayes(
  f,
  time,
  iter = 50000,
  powera = 1,
  times = 5,
  tau = ceiling(times * 0.04),
  gp = seq(dim(f)[2]),
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function_group_warp_bayes_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_time">time</code></td>
<td>
<p>sample points of functions</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_iter">iter</code></td>
<td>
<p>number of iterations (default = 150000)</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_powera">powera</code></td>
<td>
<p>Dirichlet prior parameter (default 1)</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_times">times</code></td>
<td>
<p>factor of length of subsample points to look at (default = 5)</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_tau">tau</code></td>
<td>
<p>standard deviation of Normal prior for increment (default ceil(times*.4))</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_gp">gp</code></td>
<td>
<p>number of colors in plots (defaults <code>seq(dim(f)[2])</code>)</p>
</td></tr>
<tr><td><code id="function_group_warp_bayes_+3A_showplot">showplot</code></td>
<td>
<p>shows plots of functions (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>f0</code></td>
<td>
<p>original functions</p>
</td></tr>
<tr><td><code>f_q</code></td>
<td>
<p>f aligned quotient space</p>
</td></tr>
<tr><td><code>gam_q</code></td>
<td>
<p>warping functions quotient space</p>
</td></tr>
<tr><td><code>f_a</code></td>
<td>
<p>f aligned ambient space</p>
</td></tr>
<tr><td><code>gam_a</code></td>
<td>
<p>warping ambient space</p>
</td></tr>
<tr><td><code>qmn</code></td>
<td>
<p>mean srsf</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian
registration of functions and curves. Bayesian Analysis, 11(2), 447-475.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out &lt;- function_group_warp_bayes(simu_data$f, simu_data$time)

## End(Not run)
</code></pre>

<hr>
<h2 id='function_mean_bayes'>Bayesian Karcher Mean Calculation</h2><span id='topic+function_mean_bayes'></span>

<h3>Description</h3>

<p>This function calculates karcher mean of functions using Bayesian method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_mean_bayes(f, time, times = 5, group = 1:dim(f)[2], showplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function_mean_bayes_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="function_mean_bayes_+3A_time">time</code></td>
<td>
<p>sample points of functions</p>
</td></tr>
<tr><td><code id="function_mean_bayes_+3A_times">times</code></td>
<td>
<p>factor of length of subsample points to look at (default = 5)</p>
</td></tr>
<tr><td><code id="function_mean_bayes_+3A_group">group</code></td>
<td>
<p>(defaults <code>1:dim(f)[2]</code>)</p>
</td></tr>
<tr><td><code id="function_mean_bayes_+3A_showplot">showplot</code></td>
<td>
<p>shows plots of functions (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>distfamily</code></td>
<td>
<p>dist matrix</p>
</td></tr>
<tr><td><code>match.matrix</code></td>
<td>
<p>matrix of warping functions</p>
</td></tr>
<tr><td><code>position</code></td>
<td>
<p>position</p>
</td></tr>
<tr><td><code>mu_5</code></td>
<td>
<p>function mean</p>
</td></tr>
<tr><td><code>rtmatrix</code></td>
<td>
<p>rtmatrix</p>
</td></tr>
<tr><td><code>sumdist</code></td>
<td>
<p>sumdist</p>
</td></tr>
<tr><td><code>qt.fitted</code></td>
<td>
<p>aligned srsf functions</p>
</td></tr>
<tr><td><code>estimator</code></td>
<td>
<p>estimator</p>
</td></tr>
<tr><td><code>estimator2</code></td>
<td>
<p>estimator2</p>
</td></tr>
<tr><td><code>regfuncs</code></td>
<td>
<p>registered functions</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian
registration of functions and curves. Bayesian Analysis, 11(2), 447-475.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out &lt;- function_mean_bayes(simu_data$f, simu_data$time)

## End(Not run)
</code></pre>

<hr>
<h2 id='gam_to_v'>map warping function to tangent space at identity</h2><span id='topic+gam_to_v'></span>

<h3>Description</h3>

<p>map warping function to tangent space at identity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam_to_v(gam, smooth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam_to_v_+3A_gam">gam</code></td>
<td>
<p>Either a numeric vector of a numeric matrix or a numeric array
specifying the warping functions</p>
</td></tr>
<tr><td><code id="gam_to_v_+3A_smooth">smooth</code></td>
<td>
<p>Apply smoothing before gradient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of the same shape as the input array <code>gamma</code> storing the
shooting vectors of <code>gamma</code> obtained via finite differences.
</p>

<hr>
<h2 id='gauss_model'>Gaussian model of functional data</h2><span id='topic+gauss_model'></span>

<h3>Description</h3>

<p>This function models the functional data using a Gaussian model extracted from
the principal components of the srvfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss_model(warp_data, n = 1, sort_samples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauss_model_+3A_warp_data">warp_data</code></td>
<td>
<p>fdawarp object from <a href="#topic+time_warping">time_warping</a> of aligned data</p>
</td></tr>
<tr><td><code id="gauss_model_+3A_n">n</code></td>
<td>
<p>number of random samples (n = 1)</p>
</td></tr>
<tr><td><code id="gauss_model_+3A_sort_samples">sort_samples</code></td>
<td>
<p>sort samples (default = F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a fdawarp object containing </p>
<table>
<tr><td><code>fs</code></td>
<td>
<p>random aligned samples</p>
</td></tr>
<tr><td><code>gams</code></td>
<td>
<p>random warping function samples</p>
</td></tr>
<tr><td><code>ft</code></td>
<td>
<p>random function samples</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out1 &lt;- gauss_model(simu_warp, n = 10)
</code></pre>

<hr>
<h2 id='gradient'>Gradient using finite differences</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>This function computes the gradient of <code>f</code> using finite differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(f, binsize, multidimensional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_f">f</code></td>
<td>
<p>Either a numeric vector of a numeric matrix or a numeric array
specifying the curve(s) that need to be differentiated.
</p>

<ul>
<li><p> If a vector, it must be of shape <code class="reqn">M</code> and it is interpreted as a
single <code class="reqn">1</code>-dimensional curve observed on a grid of size <code class="reqn">M</code>.
</p>
</li>
<li><p> If a matrix and <code>multidimensional == FALSE</code>, it must be of shape
<code class="reqn">M \times N</code>. In this case, it is interpreted as a sample of <code class="reqn">N</code>
curves observed on a grid of size <code class="reqn">M</code>, unless <code class="reqn">M = 1</code> in which case
it is interpreted as a single <code class="reqn">1</code>-dimensional curve observed on a grid
of size <code class="reqn">M</code>.
</p>
</li>
<li><p> If a matrix and <code>multidimensional == TRUE</code>,it must be of shape
<code class="reqn">L \times M</code> and it is interpreted as a single <code class="reqn">L</code>-dimensional
curve observed on a grid of size <code class="reqn">M</code>.
</p>
</li>
<li><p> If a 3D array, it must be of shape <code class="reqn">L \times M \times N</code> and it is
interpreted as a sample of <code class="reqn">N</code> <code class="reqn">L</code>-dimensional curves observed on a
grid of size <code class="reqn">M</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gradient_+3A_binsize">binsize</code></td>
<td>
<p>A numeric value specifying the size of the bins for computing
finite differences.</p>
</td></tr>
<tr><td><code id="gradient_+3A_multidimensional">multidimensional</code></td>
<td>
<p>A boolean specifying if the curves are
multi-dimensional. This is useful when <code>f</code> is provided as a matrix to
determine whether it is a single multi-dimensional curve or a collection of
uni-dimensional curves. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of the same shape as the input array <code>f</code> storing the
gradient of <code>f</code> obtained via finite differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gradient(simu_data$f[, 1], mean(diff(simu_data$time)))
</code></pre>

<hr>
<h2 id='growth_vel'>Berkeley Growth Velocity Dataset</h2><span id='topic+growth_vel'></span>

<h3>Description</h3>

<p>Combination of both boys and girls growth velocity from the Berkley dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_vel
</code></pre>


<h3>Format</h3>



<h4><code>growth_vel</code></h4>

<p>A list with two components:
</p>

<ul>
<li> <p><code>f</code>: A numeric matrix of shape <code class="reqn">69 \times 93</code> storing a sample of size
<code class="reqn">N = 93</code> of curves evaluated on a grid of size <code class="reqn">M = 69</code>.
</p>
</li>
<li> <p><code>time</code>: A numeric vector of size <code class="reqn">M = 69</code> storing the grid on which
the curves <code>f</code> have been evaluated.
</p>
</li></ul>



<hr>
<h2 id='horizFPCA'>Horizontal Functional Principal Component Analysis</h2><span id='topic+horizFPCA'></span>

<h3>Description</h3>

<p>This function calculates vertical functional principal component analysis
on aligned data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horizFPCA(warp_data, no = 3, var_exp = NULL, ci = c(-1, 0, 1), showplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizFPCA_+3A_warp_data">warp_data</code></td>
<td>
<p>fdawarp object from <a href="#topic+time_warping">time_warping</a> of aligned data</p>
</td></tr>
<tr><td><code id="horizFPCA_+3A_no">no</code></td>
<td>
<p>number of principal components to extract</p>
</td></tr>
<tr><td><code id="horizFPCA_+3A_var_exp">var_exp</code></td>
<td>
<p>compute no based on value percent variance explained (example: 0.95)
will override <code>no</code></p>
</td></tr>
<tr><td><code id="horizFPCA_+3A_ci">ci</code></td>
<td>
<p>geodesic standard deviations (default = c(-1,0,1))</p>
</td></tr>
<tr><td><code id="horizFPCA_+3A_showplot">showplot</code></td>
<td>
<p>show plots of principal directions (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a hfpca object containing </p>
<table>
<tr><td><code>gam_pca</code></td>
<td>
<p>warping functions principal directions</p>
</td></tr>
<tr><td><code>psi_pca</code></td>
<td>
<p>srvf principal directions</p>
</td></tr>
<tr><td><code>latent</code></td>
<td>
<p>latent values</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>eigenvectors</p>
</td></tr>
<tr><td><code>vec</code></td>
<td>
<p>shooting vectors</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Karcher Mean</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hfpca &lt;- horizFPCA(simu_warp, no = 3)
</code></pre>

<hr>
<h2 id='im'>Example Image Data set</h2><span id='topic+im'></span>

<h3>Description</h3>

<p>Contains two simulated images for registration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im
</code></pre>


<h3>Format</h3>



<h4><code>im</code></h4>

<p>A list with two components:
</p>

<ul>
<li> <p><code>I1</code>: A numeric matrix of shape <code class="reqn">64 \times 64</code> storing the 1st image;
</p>
</li>
<li> <p><code>I2</code>: A numeric matrix of shape <code class="reqn">64 \times 64</code> storing the 2nd image.
</p>
</li></ul>



<hr>
<h2 id='inv_exp_map'>map square root of warping function to tangent space</h2><span id='topic+inv_exp_map'></span>

<h3>Description</h3>

<p>map square root of warping function to tangent space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_exp_map(Psi, psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_exp_map_+3A_psi">Psi</code></td>
<td>
<p>vector describing psi function at center of tangent space</p>
</td></tr>
<tr><td><code id="inv_exp_map_+3A_psi">psi</code></td>
<td>
<p>vector describing psi function to map to tangent space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of the same length as the input array <code>psi</code> storing the
shooting vector of <code>psi</code>
</p>

<hr>
<h2 id='invertGamma'>Invert Warping Function</h2><span id='topic+invertGamma'></span>

<h3>Description</h3>

<p>This function calculates the inverse of gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertGamma(gam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertGamma_+3A_gam">gam</code></td>
<td>
<p>vector of <code class="reqn">N</code> samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns gamI inverted vector
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- invertGamma(simu_warp$warping_functions[, 1])
</code></pre>

<hr>
<h2 id='joint_gauss_model'>Gaussian model of functional data using joint Model</h2><span id='topic+joint_gauss_model'></span>

<h3>Description</h3>

<p>This function models the functional data using a Gaussian model extracted from
the principal components of the srvfs using the joint model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_gauss_model(warp_data, n = 1, no = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joint_gauss_model_+3A_warp_data">warp_data</code></td>
<td>
<p>fdawarp object from <a href="#topic+time_warping">time_warping</a> of aligned data</p>
</td></tr>
<tr><td><code id="joint_gauss_model_+3A_n">n</code></td>
<td>
<p>number of random samples (n = 1)</p>
</td></tr>
<tr><td><code id="joint_gauss_model_+3A_no">no</code></td>
<td>
<p>number of principal components (n=4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a fdawarp object containing </p>
<table>
<tr><td><code>fs</code></td>
<td>
<p>random aligned samples</p>
</td></tr>
<tr><td><code>gams</code></td>
<td>
<p>random warping function samples</p>
</td></tr>
<tr><td><code>ft</code></td>
<td>
<p>random function samples</p>
</td></tr>
<tr><td><code>qs</code></td>
<td>
<p>random srvf samples</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A., Generative Models for
Function Data using Phase and Amplitude Separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>
<p>Jung, S. L. a. S. (2016). &quot;Combined Analysis of Amplitude and
Phase Variations in Functional Data.&quot; arXiv:1603.01775.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out1 &lt;- joint_gauss_model(simu_warp, n = 10)
</code></pre>

<hr>
<h2 id='jointFPCA'>Joint Vertical and Horizontal Functional Principal Component Analysis</h2><span id='topic+jointFPCA'></span>

<h3>Description</h3>

<p>This function calculates amplitude and phase joint  functional principal component
analysis on aligned data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointFPCA(
  warp_data,
  no = 3,
  var_exp = NULL,
  id = round(length(warp_data$time)/2),
  C = NULL,
  ci = c(-1, 0, 1),
  showplot = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointFPCA_+3A_warp_data">warp_data</code></td>
<td>
<p>fdawarp object from <a href="#topic+time_warping">time_warping</a> of aligned data</p>
</td></tr>
<tr><td><code id="jointFPCA_+3A_no">no</code></td>
<td>
<p>number of principal components to extract (default = 3)</p>
</td></tr>
<tr><td><code id="jointFPCA_+3A_var_exp">var_exp</code></td>
<td>
<p>compute no based on value percent variance explained (example: 0.95)
will override <code>no</code></p>
</td></tr>
<tr><td><code id="jointFPCA_+3A_id">id</code></td>
<td>
<p>integration point for f0 (default = midpoint)</p>
</td></tr>
<tr><td><code id="jointFPCA_+3A_c">C</code></td>
<td>
<p>balance value (default = NULL)</p>
</td></tr>
<tr><td><code id="jointFPCA_+3A_ci">ci</code></td>
<td>
<p>geodesic standard deviations (default = c(-1,0,1))</p>
</td></tr>
<tr><td><code id="jointFPCA_+3A_showplot">showplot</code></td>
<td>
<p>show plots of principal directions (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>q_pca</code></td>
<td>
<p>srvf principal directions</p>
</td></tr>
<tr><td><code>f_pca</code></td>
<td>
<p>f principal directions</p>
</td></tr>
<tr><td><code>latent</code></td>
<td>
<p>latent values</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>coefficients</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>eigenvectors</p>
</td></tr>
<tr><td><code>mu_psi</code></td>
<td>
<p>mean psi function</p>
</td></tr>
<tr><td><code>mu_g</code></td>
<td>
<p>mean g function</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>point use for f(0)</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>optimized phase amplitude ratio</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Jung, S. L. a. S. (2016). &quot;Combined Analysis of Amplitude and Phase Variations in Functional Data.&quot;
arXiv:1603.01775.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jfpca &lt;- jointFPCA(simu_warp, no = 3)
</code></pre>

<hr>
<h2 id='kmeans_align'>K-Means Clustering and Alignment</h2><span id='topic+kmeans_align'></span>

<h3>Description</h3>

<p>This function clusters functions and aligns using the elastic square-root
velocity function (SRVF) framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans_align(
  f,
  time,
  K = 1L,
  seeds = NULL,
  centroid_type = c("mean", "medoid"),
  nonempty = 0L,
  lambda = 0,
  showplot = FALSE,
  smooth_data = FALSE,
  sparam = 25L,
  parallel = FALSE,
  alignment = TRUE,
  rotation = FALSE,
  scale = TRUE,
  omethod = c("DP", "RBFGS"),
  max_iter = 50L,
  thresh = 0.01,
  use_verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans_align_+3A_f">f</code></td>
<td>
<p>Either a numeric matrix or a numeric 3D array specifying the
functions that need to be jointly clustered and aligned.
</p>

<ul>
<li><p> If a matrix, it must be of shape <code class="reqn">M \times N</code>. In this case, it is
interpreted as a sample of <code class="reqn">N</code> curves observed on a grid of size
<code class="reqn">M</code>.
</p>
</li>
<li><p> If a 3D array, it must be of shape <code class="reqn">L \times M \times N</code> and it is
interpreted as a sample of <code class="reqn">N</code> <code class="reqn">L</code>-dimensional curves observed on a
grid of size <code class="reqn">M</code>.
</p>
</li></ul>

<p>If this is multidimensional functional data, it is advised that
<code>rotation==FALSE</code></p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_time">time</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> specifying the grid on which
the curves are evaluated.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_k">K</code></td>
<td>
<p>An integer value specifying the number of clusters. Defaults to
<code>1L</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_seeds">seeds</code></td>
<td>
<p>An integer vector of length <code>K</code> specifying the indices of the
curves in <code>f</code> which will be chosen as initial centroids. Defaults to <code>NULL</code>
in which case such indices are randomly chosen.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code> or <code>"medoid"</code>. Defaults to <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_nonempty">nonempty</code></td>
<td>
<p>An integer value specifying the minimum number of curves per
cluster during the assignment step. Set it to a positive value to avoid the
problem of empty clusters. Defaults to <code>0L</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the elasticity. Defaults to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_showplot">showplot</code></td>
<td>
<p>A Boolean specifying whether to show plots. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_smooth_data">smooth_data</code></td>
<td>
<p>A Boolean specifying whether to smooth data using a box
filter. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_sparam">sparam</code></td>
<td>
<p>An integer value specifying the number of box filters applied.
Defaults to <code>25L</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_parallel">parallel</code></td>
<td>
<p>A Boolean specifying whether parallel mode (using
<code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> and the <strong>doParallel</strong> package) should be activated.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_alignment">alignment</code></td>
<td>
<p>A Boolean specifying whether to perform alignment. Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_rotation">rotation</code></td>
<td>
<p>A Boolean specifying whether to perform rotation. Defaults to
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_scale">scale</code></td>
<td>
<p>A Boolean specifying whether to scale curves to unit length. Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_omethod">omethod</code></td>
<td>
<p>A string specifying which method should be used to solve the
optimization problem that provides estimated warping functions. Choices are
<code>"DP"</code> or <code>"RBFGS"</code>. Defaults to <code>"DP"</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer value specifying the maximum number of iterations.
Defaults to <code>50L</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_thresh">thresh</code></td>
<td>
<p>A numeric value specifying a threshold on the cost function
below which convergence is assumed. Defaults to <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="kmeans_align_+3A_use_verbose">use_verbose</code></td>
<td>
<p>A Boolean specifying whether to display information about
the calculations in the console. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fdakma</code> which is a list containing:
</p>

<ul>
<li> <p><code>f0</code>: the original functions;
</p>
</li>
<li> <p><code>q0</code>: the original SRSFs;
</p>
</li>
<li> <p><code>fn</code>: the aligned functions as matrices or a 3D arrays of the same shape
than <code>f0</code> by clusters in a list;
</p>
</li>
<li> <p><code>qn</code>: the aligned SRSFs as matrices or a 3D arrays of the same shape
than <code>f0</code> separated in clusters in a list;
</p>
</li>
<li> <p><code>labels</code>: the cluster memberships as an integer vector;
</p>
</li>
<li> <p><code>templates</code>: the centroids in the original functional space;
</p>
</li>
<li> <p><code>templates.q</code>: the centroids in SRSF space;
</p>
</li>
<li> <p><code>distances_to_center</code>: A numeric vector storing the distances of each
observed curve to its center;
</p>
</li>
<li> <p><code>gam</code>: the warping functions as matrices or a 3D arrays of the same shape
than <code>f0</code> by clusters in a list;
</p>
</li>
<li> <p><code>qun</code>: cost function value.
</p>
</li></ul>



<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using Fisher-Rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using phase and amplitude separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>
<p>Sangalli, L. M., et al. (2010). &quot;k-mean alignment for curve
clustering.&quot; Computational Statistics &amp; Data Analysis 54(5): 1219-1233.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out &lt;- kmeans_align(growth_vel$f, growth_vel$time, K = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='LongRunCovMatrix'>Long Run Covariance Matrix Estimation for Multivariate Time Series</h2><span id='topic+LongRunCovMatrix'></span>

<h3>Description</h3>

<p>This function estimates the long run covariance matrix of a given multivariate data sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LongRunCovMatrix(mdobj, h = 0, kern_type = "bartlett")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LongRunCovMatrix_+3A_mdobj">mdobj</code></td>
<td>
<p>A multivariate data object</p>
</td></tr>
<tr><td><code id="LongRunCovMatrix_+3A_h">h</code></td>
<td>
<p>The bandwidth parameter. It is strictly non-zero. Choosing the bandwidth parameter to be zero is identical
to estimating covariance matrix assuming iid data.</p>
</td></tr>
<tr><td><code id="LongRunCovMatrix_+3A_kern_type">kern_type</code></td>
<td>
<p>Kernel function to be used for the estimation of the long run covariance
matrix. The choices are <code>c("BT", "PR", "SP", "FT")</code> which are respectively, bartlett, parzen, simple and flat-top kernels.
By default the function uses a <code>"barlett"</code> kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns long run covariance matrix
</p>

<hr>
<h2 id='multiple_align_functions'>Group-wise function alignment to specified mean</h2><span id='topic+multiple_align_functions'></span>

<h3>Description</h3>

<p>This function aligns a collection of functions using the elastic square-root
slope (srsf) framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple_align_functions(
  f,
  time,
  mu,
  lambda = 0,
  pen = "roughness",
  showplot = TRUE,
  smooth_data = FALSE,
  sparam = 25,
  parallel = FALSE,
  omethod = "DP",
  MaxItr = 20,
  iter = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiple_align_functions_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_mu">mu</code></td>
<td>
<p>vector of size <code class="reqn">N</code> that f is aligned to</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_lambda">lambda</code></td>
<td>
<p>controls the elasticity (default = 0)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_pen">pen</code></td>
<td>
<p>alignment penalty (default=&quot;roughness&quot;) options are
second derivative (&quot;roughness&quot;), geodesic distance from id (&quot;geodesic&quot;), and
norm from id (&quot;norm&quot;)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_showplot">showplot</code></td>
<td>
<p>shows plots of functions (default = T)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_smooth_data">smooth_data</code></td>
<td>
<p>smooth data using box filter (default = F)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_sparam">sparam</code></td>
<td>
<p>number of times to apply box filter (default = 25)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_parallel">parallel</code></td>
<td>
<p>enable parallel mode using <code><a href="foreach.html#topic+foreach">foreach()</a></code> and
<code>doParallel</code> package (default=F)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_omethod">omethod</code></td>
<td>
<p>optimization method (DP,DP2,RBFGS,dBayes,expBayes)</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_maxitr">MaxItr</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="multiple_align_functions_+3A_iter">iter</code></td>
<td>
<p>bayesian number of mcmc samples (default 2000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a fdawarp object containing </p>
<table>
<tr><td><code>f0</code></td>
<td>
<p>original functions</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>aligned functions - matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>aligned SRSFs - similar structure to fn</p>
</td></tr>
<tr><td><code>q0</code></td>
<td>
<p>original SRSF - similar structure to fn</p>
</td></tr>
<tr><td><code>fmean</code></td>
<td>
<p>function mean or median - vector of length <code class="reqn">N</code></p>
</td></tr>
<tr><td><code>mqn</code></td>
<td>
<p>SRSF mean or median - vector of length <code class="reqn">N</code></p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>warping functions - similar structure to fn</p>
</td></tr>
<tr><td><code>orig.var</code></td>
<td>
<p>Original Variance of Functions</p>
</td></tr>
<tr><td><code>amp.var</code></td>
<td>
<p>Amplitude Variance</p>
</td></tr>
<tr><td><code>phase.var</code></td>
<td>
<p>Phase Variance</p>
</td></tr>
<tr><td><code>qun</code></td>
<td>
<p>Cost Function Value</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>

<hr>
<h2 id='multivariate_karcher_mean'>Karcher Mean of Multivariate Functional Data</h2><span id='topic+multivariate_karcher_mean'></span>

<h3>Description</h3>

<p>Calculates Karcher mean or median of a collection of multivariate functional
data using the elastic square-root velocity (srvf) framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivariate_karcher_mean(beta, lambda = 0, maxit = 20, ms = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multivariate_karcher_mean_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">L \times M \times N</code> and it is
interpreted as a sample of <code class="reqn">N</code> <code class="reqn">L</code>-dimensional curves observed on a
grid of size <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code id="multivariate_karcher_mean_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the elasticity. Defaults to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="multivariate_karcher_mean_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="multivariate_karcher_mean_+3A_ms">ms</code></td>
<td>
<p>string defining whether the Karcher mean (<code>"mean"</code>) or Karcher
median (<code>"median"</code>) is returned (default = <code>"mean"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>mean srvf</p>
</td></tr>
<tr><td><code>betamean</code></td>
<td>
<p>mean or median curve</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>string indicating whether mean or median is returned</p>
</td></tr>
<tr><td><code>betan</code></td>
<td>
<p>aligned curves</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>array of srvfs</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>array of aligned srvfs</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>array of warping functions</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>energy</p>
</td></tr>
<tr><td><code>qun</code></td>
<td>
<p>cost function</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape
analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine
Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- multivariate_karcher_mean(beta[, , 1, 1:2], maxit = 2)
# note: use more functions, small for speed
</code></pre>

<hr>
<h2 id='optimum.reparam'>Align two functions</h2><span id='topic+optimum.reparam'></span>

<h3>Description</h3>

<p>This function aligns the SRVFs of two functions in <code class="reqn">R^1</code> defined on an
interval <code class="reqn">[t_{\min}, t_{\max}]</code> using dynamic programming or RBFGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimum.reparam(
  Q1,
  T1,
  Q2,
  T2,
  lambda = 0,
  pen = "roughness",
  method = c("DP", "DPo", "SIMUL", "RBFGS"),
  f1o = 0,
  f2o = 0,
  nbhd_dim = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimum.reparam_+3A_q1">Q1</code></td>
<td>
<p>A numeric matrix of shape <code style="white-space: pre;">&#8288;n_points x n_dimensions&#8288;</code> specifying the
SRSF of the 1st <code>n_dimensions</code>-dimensional function evaluated on a grid of
size <code>n_points</code> of its univariate domain.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_t1">T1</code></td>
<td>
<p>A numeric vector of size <code>n_points</code> specifying the grid on which
the 1st SRSF is evaluated.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_q2">Q2</code></td>
<td>
<p>A numeric matrix of shape <code style="white-space: pre;">&#8288;n_points x n_dimensions&#8288;</code> specifying the
SRSF of the 2nd <code>n_dimensions</code>-dimensional function evaluated on a grid of
size <code>n_points</code> of its univariate domain.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_t2">T2</code></td>
<td>
<p>A numeric vector of size <code>n_points</code> specifying the grid on which
the 1st SRSF is evaluated.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the amount of warping. Defaults to
<code>0.0</code>.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_pen">pen</code></td>
<td>
<p>alignment penalty (default=&quot;roughness&quot;) options are
second derivative (&quot;roughness&quot;), geodesic distance from id (&quot;geodesic&quot;), and
norm from id (&quot;l2gam&quot;), srvf norm from id (&quot;l2psi&quot;)</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_method">method</code></td>
<td>
<p>A string specifying the optimization method. Choices are
<code>"DP"</code>, <code>"DPo"</code>, <code>"SIMUL"</code>, or <code>"RBFGS"</code>. Defaults to <code>"DP"</code>.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_f1o">f1o</code></td>
<td>
<p>A numeric vector of size <code>n_dimensions</code> specifying the value of
the 1st function at <code class="reqn">t = t_{\min}</code>. Defaults to <code>rep(0, n_dimensions)</code>.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_f2o">f2o</code></td>
<td>
<p>A numeric vector of size <code>n_dimensions</code> specifying the value of
the 2nd function at <code class="reqn">t = t_{\min}</code>. Defaults to <code>rep(0, n_dimensions)</code>.</p>
</td></tr>
<tr><td><code id="optimum.reparam_+3A_nbhd_dim">nbhd_dim</code></td>
<td>
<p>size of the grid (default = 7)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of size <code>n_points</code> storing discrete evaluations of
the estimated boundary-preserving warping diffeomorphism on the initial
grid.
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using Fisher-Rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using phase and amplitude separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- f_to_srvf(simu_data$f, simu_data$time)
gam &lt;- optimum.reparam(q[, 1], simu_data$time, q[, 2], simu_data$time)
</code></pre>

<hr>
<h2 id='outlier.detection'>Outlier Detection</h2><span id='topic+outlier.detection'></span>

<h3>Description</h3>

<p>This function calculates outlier's using geodesic distances of the SRVFs from
the median
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier.detection(q, time, mq, k = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier.detection_+3A_q">q</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> SRVF functions with <code class="reqn">N</code>
samples</p>
</td></tr>
<tr><td><code id="outlier.detection_+3A_time">time</code></td>
<td>
<p>vector of size <code class="reqn">N</code> describing the sample points</p>
</td></tr>
<tr><td><code id="outlier.detection_+3A_mq">mq</code></td>
<td>
<p>median calculated using <code><a href="#topic+time_warping">time_warping()</a></code></p>
</td></tr>
<tr><td><code id="outlier.detection_+3A_k">k</code></td>
<td>
<p>cutoff threshold (default = 1.5)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>q_outlier</code></td>
<td>
<p>outlier functions</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q_outlier &lt;- outlier.detection(
  q = toy_warp$q0,
  time = toy_data$time,
  mq = toy_warp$mqn,
  k = .1
)
</code></pre>

<hr>
<h2 id='pair_align_functions'>Align two functions</h2><span id='topic+pair_align_functions'></span>

<h3>Description</h3>

<p>This function aligns two functions using SRSF framework. It will align f2
to f1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_align_functions(
  f1,
  f2,
  time,
  lambda = 0,
  pen = "roughness",
  method = "DP",
  w = 0.01,
  iter = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_align_functions_+3A_f1">f1</code></td>
<td>
<p>function 1</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_f2">f2</code></td>
<td>
<p>function 2</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_time">time</code></td>
<td>
<p>sample points of functions</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_lambda">lambda</code></td>
<td>
<p>controls amount of warping (default = 0)</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_pen">pen</code></td>
<td>
<p>alignment penalty (default=&quot;roughness&quot;) options are
second derivative (&quot;roughness&quot;), geodesic distance from id (&quot;geodesic&quot;), and
norm from id (&quot;norm&quot;)</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_method">method</code></td>
<td>
<p>controls which optimization method (default=&quot;DP&quot;) options are
Dynamic Programming (&quot;DP&quot;), Coordinate Descent (&quot;DP2&quot;), Riemannian BFGS
(&quot;RBFGS&quot;), Simultaneous Alignment (&quot;SIMUL&quot;), Dirichlet Bayesian (&quot;dBayes&quot;),
and Expo-Map Bayesian (&quot;expBayes&quot;)</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_w">w</code></td>
<td>
<p>controls LRBFGS (default = 0.01)</p>
</td></tr>
<tr><td><code id="pair_align_functions_+3A_iter">iter</code></td>
<td>
<p>number of mcmc iterations for mcmc method (default 2000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>f2tilde</code></td>
<td>
<p>aligned f2</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>warping function</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>
<p>Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian
registration of functions and curves. Bayesian Analysis, 11(2), 447-475.
</p>
<p>Lu, Y., Herbei, R., and Kurtek, S. (2017). Bayesian registration
of functions with a Gaussian process prior. Journal of Computational and
Graphical Statistics, DOI: 10.1080/10618600.2017.1336444.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- pair_align_functions(
  f1 = simu_data$f[, 1],
  f2 = simu_data$f[, 2],
  time = simu_data$time
)
</code></pre>

<hr>
<h2 id='pair_align_functions_bayes'>Align two functions</h2><span id='topic+pair_align_functions_bayes'></span>

<h3>Description</h3>

<p>This function aligns two functions using Bayesian SRSF framework. It will align f2
to f1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_align_functions_bayes(
  f1,
  f2,
  timet,
  iter = 15000,
  times = 5,
  tau = ceiling(times * 0.4),
  powera = 1,
  showplot = TRUE,
  extrainfo = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_align_functions_bayes_+3A_f1">f1</code></td>
<td>
<p>function 1</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_f2">f2</code></td>
<td>
<p>function 2</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_timet">timet</code></td>
<td>
<p>sample points of functions</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_iter">iter</code></td>
<td>
<p>number of iterations (default = 15000)</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_times">times</code></td>
<td>
<p>factor of length of subsample points to look at (default = 5)</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_tau">tau</code></td>
<td>
<p>standard deviation of Normal prior for increment (default ceil(times*.4))</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_powera">powera</code></td>
<td>
<p>Dirichlet prior parameter (default 1)</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_showplot">showplot</code></td>
<td>
<p>shows plots of functions (default = T)</p>
</td></tr>
<tr><td><code id="pair_align_functions_bayes_+3A_extrainfo">extrainfo</code></td>
<td>
<p>T/F whether additional information is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>f1</code></td>
<td>
<p>function 1</p>
</td></tr>
<tr><td><code>f2_q</code></td>
<td>
<p>registered function using quotient space</p>
</td></tr>
<tr><td><code>gam_q</code></td>
<td>
<p>warping function quotient space</p>
</td></tr>
<tr><td><code>f2_a</code></td>
<td>
<p>registered function using ambient space</p>
</td></tr>
<tr><td><code>q2_a</code></td>
<td>
<p>warping function ambient space</p>
</td></tr>
<tr><td><code>match_collect</code></td>
<td>
<p>posterior samples from warping function (returned if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>dist_collect</code></td>
<td>
<p>posterior samples from the distances (returned if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>kappa_collect</code></td>
<td>
<p>posterior samples from kappa (returned if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>log_collect</code></td>
<td>
<p>log-likelihood of each sample (returned if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>pct_accept</code></td>
<td>
<p>vector of acceptance ratios for the warping function (returned if extrainfo=TRUE)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian
registration of functions and curves. Bayesian Analysis, 11(2), 447-475.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- pair_align_functions_bayes(
  f1 = simu_data$f[, 1],
  f2 = simu_data$f[, 2],
  timet = simu_data$time
)
</code></pre>

<hr>
<h2 id='pair_align_functions_expomap'>Align two functions using geometric properties of warping functions</h2><span id='topic+pair_align_functions_expomap'></span>

<h3>Description</h3>

<p>This function aligns two functions using Bayesian framework. It will align
f2 to f1. It is based on mapping warping functions to a hypersphere, and a
subsequent exponential mapping to a tangent space. In the tangent space,
the Z-mixture pCN algorithm is used to explore both local and global
structure in the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_align_functions_expomap(
  f1,
  f2,
  timet,
  iter = 20000,
  burnin = min(5000, iter/2),
  alpha0 = 0.1,
  beta0 = 0.1,
  zpcn = list(betas = c(0.5, 0.05, 0.005, 1e-04), probs = c(0.1, 0.1, 0.7, 0.1)),
  propvar = 1,
  init.coef = rep(0, 2 * 10),
  npoints = 200,
  extrainfo = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_align_functions_expomap_+3A_f1">f1</code></td>
<td>
<p>observed data, numeric vector</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_f2">f2</code></td>
<td>
<p>observed data, numeric vector</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_timet">timet</code></td>
<td>
<p>sample points of functions</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_iter">iter</code></td>
<td>
<p>length of the chain</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_burnin">burnin</code></td>
<td>
<p>number of burnin MCMC iterations</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_alpha0">alpha0</code>, <code id="pair_align_functions_expomap_+3A_beta0">beta0</code></td>
<td>
<p>IG parameters for the prior of sigma1</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_zpcn">zpcn</code></td>
<td>
<p>list of mixture coefficients and prior probabilities for
Z-mixture pCN algorithm of the form list(betas, probs), where betas and
probs are numeric vectors of equal length</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_propvar">propvar</code></td>
<td>
<p>variance of proposal distribution</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_init.coef">init.coef</code></td>
<td>
<p>initial coefficients of warping function in exponential map;
length must be even</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_npoints">npoints</code></td>
<td>
<p>number of sample points to use during alignment</p>
</td></tr>
<tr><td><code id="pair_align_functions_expomap_+3A_extrainfo">extrainfo</code></td>
<td>
<p>T/F whether additional information is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Z-mixture pCN algorithm uses a mixture distribution for the proposal
distribution, controlled by input parameter zpcn. The zpcn$betas must be
between 0 and 1, and are the coefficients of the mixture components, with
larger coefficients corresponding to larger shifts in parameter space. The
zpcn$probs give the probability of each shift size.
</p>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>f2_warped</code></td>
<td>
<p>f2 aligned to f1</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Posterior mean gamma function</p>
</td></tr>
<tr><td><code>g.coef</code></td>
<td>
<p>matrix with iter columns, posterior draws of g.coef</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>Posterior mean psi function</p>
</td></tr>
<tr><td><code>sigma1</code></td>
<td>
<p>numeric vector of length iter, posterior draws of sigma1</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>Boolean acceptance for each sample (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>betas.ind</code></td>
<td>
<p>Index of zpcn mixture component for each sample (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>logl</code></td>
<td>
<p>numeric vector of length iter, posterior loglikelihood (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>gamma_mat</code></td>
<td>
<p>Matrix of all posterior draws of gamma (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>gamma_q025</code></td>
<td>
<p>Lower 0.025 quantile of gamma (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>gamma_q975</code></td>
<td>
<p>Upper 0.975 quantile of gamma (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>sigma_eff_size</code></td>
<td>
<p>Effective sample size of sigma (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>psi_eff_size</code></td>
<td>
<p>Vector of effective sample sizes of psi (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>xdist</code></td>
<td>
<p>Vector of posterior draws from xdist between registered functions (if extrainfo=TRUE)</p>
</td></tr>
<tr><td><code>ydist</code></td>
<td>
<p>Vector of posterior draws from ydist between registered functions (if extrainfo=TRUE)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lu, Y., Herbei, R., and Kurtek, S. (2017). Bayesian registration
of functions with a Gaussian process prior. Journal of Computational and
Graphical Statistics, DOI: 10.1080/10618600.2017.1336444.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # This is an MCMC algorithm and takes a long time to run
  myzpcn &lt;- list(
    betas = c(0.1, 0.01, 0.005, 0.0001),
    probs = c(0.2, 0.2, 0.4, 0.2)
  )
  out &lt;- pair_align_functions_expomap(
    f1 = simu_data$f[, 1],
    f2 = simu_data$f[, 2],
    timet = simu_data$time,
    zpcn = myzpcn,
    extrainfo = TRUE
  )
  # overall acceptance ratio
  mean(out$accept)
  # acceptance ratio by zpcn coefficient
  with(out, tapply(accept, myzpcn$betas[betas.ind], mean))

## End(Not run)
</code></pre>

<hr>
<h2 id='pair_align_image'>Pairwise align two images
This function aligns to images using the q-map framework</h2><span id='topic+pair_align_image'></span>

<h3>Description</h3>

<p>Pairwise align two images
This function aligns to images using the q-map framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_align_image(
  I1,
  I2,
  M = 5,
  ortho = TRUE,
  basis_type = "t",
  resizei = FALSE,
  N = 64,
  stepsize = 1e-05,
  itermax = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_align_image_+3A_i1">I1</code></td>
<td>
<p>reference image</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_i2">I2</code></td>
<td>
<p>image to warp</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_m">M</code></td>
<td>
<p>number of basis elements (default=5)</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_ortho">ortho</code></td>
<td>
<p>orthonormalize basis (default=TRUE)</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_basis_type">basis_type</code></td>
<td>
<p>(&quot;t&quot;,&quot;s&quot;,&quot;i&quot;,&quot;o&quot;; default=&quot;t&quot;)</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_resizei">resizei</code></td>
<td>
<p>resize image (default=TRUE)</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_n">N</code></td>
<td>
<p>size of resized image (default=64)</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_stepsize">stepsize</code></td>
<td>
<p>gradient stepsize (default=1e-5)</p>
</td></tr>
<tr><td><code id="pair_align_image_+3A_itermax">itermax</code></td>
<td>
<p>maximum number of iterations (default=1000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>Inew</code></td>
<td>
<p>aligned I2</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>warping function</p>
</td></tr>
</table>


<h3>References</h3>

<p>Q. Xie, S. Kurtek, E. Klassen, G. E. Christensen and A. Srivastava. Metric-based pairwise and multiple image registration. IEEE European Conference on Computer Vision (ECCV), September, 2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # This is a gradient descent algorithm and takes a long time to run
  out &lt;- pair_align_image(im$I1, im$I2)

## End(Not run)
</code></pre>

<hr>
<h2 id='pcaTB'>Tolerance Bound Calculation using Elastic Functional PCA</h2><span id='topic+pcaTB'></span>

<h3>Description</h3>

<p>This function computes tolerance bounds for functional data containing
phase and amplitude variation using principal component analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaTB(f, time, m = 4, B = 1e+05, a = 0.05, p = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaTB_+3A_f">f</code></td>
<td>
<p>matrix of functions</p>
</td></tr>
<tr><td><code id="pcaTB_+3A_time">time</code></td>
<td>
<p>vector describing time sampling</p>
</td></tr>
<tr><td><code id="pcaTB_+3A_m">m</code></td>
<td>
<p>number of principal components (default = 4)</p>
</td></tr>
<tr><td><code id="pcaTB_+3A_b">B</code></td>
<td>
<p>number of monte carlo iterations</p>
</td></tr>
<tr><td><code id="pcaTB_+3A_a">a</code></td>
<td>
<p>confidence level of tolerance bound (default = 0.05)</p>
</td></tr>
<tr><td><code id="pcaTB_+3A_p">p</code></td>
<td>
<p>coverage level of tolerance bound (default = 0.99)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>pca</code></td>
<td>
<p>pca output</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>tolerance factor</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, C. King, and S. Kurtek, “A Geometric
Approach for Computing Tolerance Bounds for Elastic Functional Data,”
Journal of Applied Statistics, 10.1080/02664763.2019.1645818, 2019.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative Models for
Function Data using Phase and Amplitude Separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>
<p>Jung, S. L. a. S. (2016). &quot;Combined Analysis of Amplitude and
Phase Variations in Functional Data.&quot; arXiv:1603.01775.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out1 &lt;- pcaTB(simu_data$f, simu_data$time)

## End(Not run)
</code></pre>

<hr>
<h2 id='phbox_data'>Phase Boxplot Data</h2><span id='topic+phbox_data'></span>

<h3>Description</h3>

<p>This function constructs the phase boxplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phbox_data(warp_median, alpha = 0.05, kp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phbox_data_+3A_warp_median">warp_median</code></td>
<td>
<p>fdawarp object from <a href="#topic+time_warping">time_warping</a> of aligned data using
the median.</p>
</td></tr>
<tr><td><code id="phbox_data_+3A_alpha">alpha</code></td>
<td>
<p>quantile value (default=.05, i.e., 95%).</p>
</td></tr>
<tr><td><code id="phbox_data_+3A_kp">kp</code></td>
<td>
<p>scalar for outlier cutoff (default=1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>phbox</code> object containing:
</p>

<ul>
<li> <p><code>median_x</code>: median warping function
</p>
</li>
<li> <p><code>Q1</code>: First quartile
</p>
</li>
<li> <p><code>Q3</code>: Second quartile
</p>
</li>
<li> <p><code>Q1a</code>: First quantile based on alpha
</p>
</li>
<li> <p><code>Q3a</code>: Second quantile based on alpha
</p>
</li>
<li> <p><code>minn</code>: minimum extreme function
</p>
</li>
<li> <p><code>maxx</code>: maximum extreme function
</p>
</li>
<li> <p><code>outlier_index</code>: indexes of outlier functions
</p>
</li></ul>



<h3>References</h3>

<p>Xie, W., S. Kurtek, K. Bharath, and Y. Sun  (2016). &quot;A geometric
approach to visualization of variability in functional data.&quot; Journal of
the American Statistical Association in press: 1-34.
</p>

<hr>
<h2 id='predict.hfpca'>Elastic Prediction for functional PCA</h2><span id='topic+predict.hfpca'></span>

<h3>Description</h3>

<p>This function performs projection of new functions on fPCA basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hfpca'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hfpca_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;horizFPCA&quot;</p>
</td></tr>
<tr><td><code id="predict.hfpca_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix in which to look for functions with which to predict. If omitted, the original functions are used.</p>
</td></tr>
<tr><td><code id="predict.hfpca_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>principle coefficients</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>

<hr>
<h2 id='predict.jfpca'>Elastic Prediction for functional PCA</h2><span id='topic+predict.jfpca'></span>

<h3>Description</h3>

<p>This function performs projection of new functions on fPCA basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jfpca'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.jfpca_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;jointFPCA&quot;</p>
</td></tr>
<tr><td><code id="predict.jfpca_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix in which to look for functions with which to predict. If omitted, the original functions are used.</p>
</td></tr>
<tr><td><code id="predict.jfpca_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>principle coefficients</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>

<hr>
<h2 id='predict.lpcr'>Elastic Prediction for functional logistic PCR Model</h2><span id='topic+predict.lpcr'></span>

<h3>Description</h3>

<p>This function performs prediction from an elastic logistic fPCR regression model
with phase-variability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcr'
predict(object, newdata = NULL, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lpcr_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;elastic.pcr.regression&quot;</p>
</td></tr>
<tr><td><code id="predict.lpcr_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.lpcr_+3A_y">y</code></td>
<td>
<p>An optional vector of labels to calculate PC. If omitted, PC is NULL</p>
</td></tr>
<tr><td><code id="predict.lpcr_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>y_pred</code></td>
<td>
<p>predicted probabilities of the class of newdata</p>
</td></tr>
<tr><td><code>y_labels</code></td>
<td>
<p>class labels of newdata</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>probability of classification</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic
Functional Principal Component Regression,” Statistical Analysis and Data
Mining, 10.1002/sam.11399, 2018.
</p>

<hr>
<h2 id='predict.mlpcr'>Elastic Prediction for functional multinomial logistic PCR Model</h2><span id='topic+predict.mlpcr'></span>

<h3>Description</h3>

<p>This function performs prediction from an elastic multinomial logistic fPCR regression model
with phase-variability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlpcr'
predict(object, newdata = NULL, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mlpcr_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;elastic.pcr.regression&quot;</p>
</td></tr>
<tr><td><code id="predict.mlpcr_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.mlpcr_+3A_y">y</code></td>
<td>
<p>An optional vector of labels to calculate PC. If omitted, PC is NULL</p>
</td></tr>
<tr><td><code id="predict.mlpcr_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>y_pred</code></td>
<td>
<p>predicted probabilities of the class of newdata</p>
</td></tr>
<tr><td><code>y_labels</code></td>
<td>
<p>class labels of newdata</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>probability of classification per class</p>
</td></tr>
<tr><td><code>PC.comb</code></td>
<td>
<p>total probability of classification</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic
Functional Principal Component Regression,” Statistical Analysis and Data
Mining, 10.1002/sam.11399, 2018.
</p>

<hr>
<h2 id='predict.pcr'>Elastic Prediction for functional PCR Model</h2><span id='topic+predict.pcr'></span>

<h3>Description</h3>

<p>This function performs prediction from an elastic pcr regression model
with phase-variability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcr'
predict(object, newdata = NULL, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pcr_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;elastic.pcr.regression&quot;</p>
</td></tr>
<tr><td><code id="predict.pcr_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.pcr_+3A_y">y</code></td>
<td>
<p>An optional vector of responses to calculate SSE. If omitted, SSE is NULL</p>
</td></tr>
<tr><td><code id="predict.pcr_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>y_pred</code></td>
<td>
<p>predicted values of newdata</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>sum of squared errors</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic
Functional Principal Component Regression,” Statistical Analysis and Data
Mining, 10.1002/sam.11399, 2018.
</p>

<hr>
<h2 id='predict.vfpca'>Elastic Prediction for functional PCA</h2><span id='topic+predict.vfpca'></span>

<h3>Description</h3>

<p>This function performs projection of new functions on fPCA basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vfpca'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.vfpca_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;vertFPCA&quot;</p>
</td></tr>
<tr><td><code id="predict.vfpca_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix in which to look for functions with which to predict. If omitted, the original functions are used.</p>
</td></tr>
<tr><td><code id="predict.vfpca_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>principle coefficients</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>

<hr>
<h2 id='q_to_curve'>Convert to curve space</h2><span id='topic+q_to_curve'></span>

<h3>Description</h3>

<p>This function converts SRVFs to curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_to_curve(q, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_to_curve_+3A_q">q</code></td>
<td>
<p>either a matrix of shape <code class="reqn">n \times T</code> describing SRVF or SRVF of
multidimensional functional data in <code class="reqn">R^n</code>, where <code class="reqn">n</code> is the dimension
and <code class="reqn">T</code> is the number of time points</p>
</td></tr>
<tr><td><code id="q_to_curve_+3A_scale">scale</code></td>
<td>
<p>scale of original beta (default = <code>1</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta array describing curve
</p>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- curve_to_q(beta[, , 1, 1])$q
beta1 &lt;- q_to_curve(q)
</code></pre>

<hr>
<h2 id='reparam_curve'>Align two curves</h2><span id='topic+reparam_curve'></span>

<h3>Description</h3>

<p>This function aligns two SRVF functions using Dynamic Programming. If the
curves beta1 and beta2 are describing multidimensional functional data, then
<code>rotation == FALSE</code> and <code>mode == 'O'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reparam_curve(
  beta1,
  beta2,
  lambda = 0,
  method = "DP",
  w = 0.01,
  rotated = TRUE,
  isclosed = FALSE,
  mode = "O"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reparam_curve_+3A_beta1">beta1</code></td>
<td>
<p>curve 1, provided as a matrix of dimensions <code class="reqn">n \times M</code> for
<code class="reqn">n</code>-dimensional curve evaluated on <code class="reqn">M</code> sample points</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_beta2">beta2</code></td>
<td>
<p>curve 1, provided as a matrix of dimensions <code class="reqn">n \times M</code> for
<code class="reqn">n</code>-dimensional curve evaluated on <code class="reqn">M</code> sample points</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_lambda">lambda</code></td>
<td>
<p>controls amount of warping (default = <code>0</code>)</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_method">method</code></td>
<td>
<p>controls which optimization method. Options are
Dynamic Programming (<code>"DP"</code>). (default = <code>"DP"</code>)</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_w">w</code></td>
<td>
<p>controls LRBFGS (default = <code>0.01</code>)</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_rotated">rotated</code></td>
<td>
<p>boolean if rotation is desired</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_isclosed">isclosed</code></td>
<td>
<p>boolean if curve is closed</p>
</td></tr>
<tr><td><code id="reparam_curve_+3A_mode">mode</code></td>
<td>
<p>Open (<code>"O"</code>) or Closed (<code>"C"</code>) curves</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a List containing </p>
<table>
<tr><td><code>gam</code></td>
<td>
<p>warping function</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>rotation matrix</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>seed point</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gam &lt;- reparam_curve(beta[, , 1, 1], beta[, , 1, 5])$gam
</code></pre>

<hr>
<h2 id='reparam_image'>Find optimum reparameterization between two images</h2><span id='topic+reparam_image'></span>

<h3>Description</h3>

<p>Finds the optimal warping function between two images using the elastic
framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reparam_image(It, Im, gam, b, stepsize = 1e-05, itermax = 1000, lmark = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reparam_image_+3A_it">It</code></td>
<td>
<p>template image matrix</p>
</td></tr>
<tr><td><code id="reparam_image_+3A_im">Im</code></td>
<td>
<p>test image matrix</p>
</td></tr>
<tr><td><code id="reparam_image_+3A_gam">gam</code></td>
<td>
<p>initial warping array</p>
</td></tr>
<tr><td><code id="reparam_image_+3A_b">b</code></td>
<td>
<p>basis matrix</p>
</td></tr>
<tr><td><code id="reparam_image_+3A_stepsize">stepsize</code></td>
<td>
<p>gradient stepsize (default=1e-5)</p>
</td></tr>
<tr><td><code id="reparam_image_+3A_itermax">itermax</code></td>
<td>
<p>maximum number of iterations (default=1000)</p>
</td></tr>
<tr><td><code id="reparam_image_+3A_lmark">lmark</code></td>
<td>
<p>use landmarks (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>gamnew</code></td>
<td>
<p>final warping</p>
</td></tr>
<tr><td><code>Inew</code></td>
<td>
<p>aligned image</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>energy</p>
</td></tr>
<tr><td><code>stepsize</code></td>
<td>
<p>final stepsize</p>
</td></tr>
</table>


<h3>References</h3>

<p>Q. Xie, S. Kurtek, E. Klassen, G. E. Christensen and A. Srivastava. Metric-based pairwise and multiple image registration. IEEE European Conference on Computer Vision (ECCV), September, 2014
</p>

<hr>
<h2 id='resamplecurve'>Resample Curve</h2><span id='topic+resamplecurve'></span>

<h3>Description</h3>

<p>This function resamples a curve to a number of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resamplecurve(x, N = 100, mode = "O")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamplecurve_+3A_x">x</code></td>
<td>
<p>matrix defining curve (n,T)</p>
</td></tr>
<tr><td><code id="resamplecurve_+3A_n">N</code></td>
<td>
<p>Number of samples to re-sample curve, N usually is &gt; T</p>
</td></tr>
<tr><td><code id="resamplecurve_+3A_mode">mode</code></td>
<td>
<p>Open (&quot;O&quot;) or Closed (&quot;C&quot;) curves</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xn matrix defining resampled curve
</p>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xn &lt;- resamplecurve(beta[, , 1, 1], 200)
</code></pre>

<hr>
<h2 id='rgam'>Random Warping</h2><span id='topic+rgam'></span>

<h3>Description</h3>

<p>Generates random warping functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgam(N, sigma, num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgam_+3A_n">N</code></td>
<td>
<p>length of warping function</p>
</td></tr>
<tr><td><code id="rgam_+3A_sigma">sigma</code></td>
<td>
<p>variance of warping functions</p>
</td></tr>
<tr><td><code id="rgam_+3A_num">num</code></td>
<td>
<p>number of warping functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gam warping functions
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gam = rgam(N=101, sigma=.01, num=35)
</code></pre>

<hr>
<h2 id='sample_shapes'>Sample shapes from model</h2><span id='topic+sample_shapes'></span>

<h3>Description</h3>

<p>Sample shapes from model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_shapes(mu, K, mode = "O", no = 3, numSamp = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_shapes_+3A_mu">mu</code></td>
<td>
<p>array (n,T) of mean srvf</p>
</td></tr>
<tr><td><code id="sample_shapes_+3A_k">K</code></td>
<td>
<p>array (2<em>T,2</em>T) covariance matrix</p>
</td></tr>
<tr><td><code id="sample_shapes_+3A_mode">mode</code></td>
<td>
<p>Open (&quot;O&quot;) or Closed (&quot;C&quot;) curves</p>
</td></tr>
<tr><td><code id="sample_shapes_+3A_no">no</code></td>
<td>
<p>number of principal components</p>
</td></tr>
<tr><td><code id="sample_shapes_+3A_numsamp">numSamp</code></td>
<td>
<p>number of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>samples list of sample curves
</p>


<h3>References</h3>

<p>Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence, IEEE Transactions on 33 (7), 1415-1428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- curve_karcher_mean(beta[, , 1, 1:2], maxit = 2)
# note: use more shapes, small for speed
K &lt;- curve_karcher_cov(out$v)
samples &lt;- sample_shapes(out$mu, K)
</code></pre>

<hr>
<h2 id='simu_data'>Simulated two Gaussian Dataset</h2><span id='topic+simu_data'></span>

<h3>Description</h3>

<p>A functional dataset where the individual functions are given by: <code class="reqn">y_i(t)
= z_{i,1} e^{-(t-1.5)^2/2} + z_{i,2}e^{-(t+1.5)^2/2}</code>, <code class="reqn">t \in [-3, 3],
~i=1,2,\dots, 21</code>, where <code class="reqn">z_{i,1}</code> and <code class="reqn">z_{i,2}</code> are <em>i.i.d.</em> normal
with mean one and standard deviation 0.25. Each of these functions is then
warped according to: <code class="reqn">\gamma_i(t) = 6({e^{a_i(t+3)/6} -1 \over e^{a_i} -
1}) - 3</code> if  <code class="reqn">a_i \neq 0</code>, otherwise <code class="reqn">\gamma_i = \gamma_{id}</code>
(<code class="reqn">gamma_{id}(t) = t</code>) is the identity warping). The variables are as
follows: f containing the 21 functions of 101 samples and time which
describes the sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_data
</code></pre>


<h3>Format</h3>



<h4><code>simu_data</code></h4>

<p>A list with 2 components:
</p>

<ul>
<li> <p><code>f</code>: A numeric matrix of shape <code class="reqn">101 \times 21</code> storing a sample of size
<code class="reqn">N = 21</code> of curves evaluated on a grid of size <code class="reqn">M = 101</code>.
</p>
</li>
<li> <p><code>time</code>: A numeric vector of size <code class="reqn">M = 101</code> storing the grid on which
the curves <code>f</code> have been evaluated.
</p>
</li></ul>



<hr>
<h2 id='simu_warp'>Aligned Simulated two Gaussian Dataset</h2><span id='topic+simu_warp'></span>

<h3>Description</h3>

<p>A functional dataset where the individual functions are given by: <code class="reqn">y_i(t)
= z_{i,1} e^{-(t-1.5)^2/2} + z_{i,2}e^{-(t+1.5)^2/2}</code>, <code class="reqn">t \in [-3, 3],
~i=1,2,\dots, 21</code>, where <code class="reqn">z_{i,1}</code> and <code class="reqn">z_{i,2}</code> are <em>i.i.d.</em> normal
with mean one and standard deviation 0.25. Each of these functions is then
warped according to: <code class="reqn">\gamma_i(t) = 6({e^{a_i(t+3)/6} -1 \over e^{a_i} -
1}) - 3</code> if  <code class="reqn">a_i \neq 0</code>, otherwise <code class="reqn">\gamma_i = \gamma_{id}</code>
(<code class="reqn">gamma_{id}(t) = t</code>) is the identity warping). The variables are as
follows: f containing the 21 functions of 101 samples and time which
describes the sampling which has been aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_warp
</code></pre>


<h3>Format</h3>



<h4><code>simu_warp</code></h4>

<p>A list which contains the output of the <code><a href="#topic+time_warping">time_warping()</a></code> function applied on
the data set <code>simu_data</code>.
</p>


<hr>
<h2 id='simu_warp_median'>Aligned Simulated two Gaussian Dataset using Median</h2><span id='topic+simu_warp_median'></span>

<h3>Description</h3>

<p>A functional dataset where the individual functions are given by: <code class="reqn">y_i(t)
= z_{i,1} e^{-(t-1.5)^2/2} + z_{i,2}e^{-(t+1.5)^2/2}</code>, <code class="reqn">t \in [-3, 3],
~i=1,2,\dots, 21</code>, where <code class="reqn">z_{i,1}</code> and <code class="reqn">z_{i,2}</code> are <em>i.i.d.</em> normal
with mean one and standard deviation 0.25. Each of these functions is then
warped according to: <code class="reqn">\gamma_i(t) = 6({e^{a_i(t+3)/6} -1 \over e^{a_i} -
1}) - 3</code> if  <code class="reqn">a_i \neq 0</code>, otherwise <code class="reqn">\gamma_i = \gamma_{id}</code>
(<code class="reqn">gamma_{id}(t) = t</code>) is the identity warping). The variables are as
follows: f containing the 21 functions of 101 samples and time which
describes the sampling which has been aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_warp_median
</code></pre>


<h3>Format</h3>



<h4><code>simu_warp_median</code></h4>

<p>A list which contains the output of the <code><a href="#topic+time_warping">time_warping()</a></code> function finding the
median applied on the data set <code>simu_data</code>.
</p>


<hr>
<h2 id='smooth.data'>Smooth Functions</h2><span id='topic+smooth.data'></span>

<h3>Description</h3>

<p>This function smooths functions using standard box filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.data(f, sparam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.data_+3A_f">f</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> functions with <code class="reqn">N</code> samples</p>
</td></tr>
<tr><td><code id="smooth.data_+3A_sparam">sparam</code></td>
<td>
<p>number of times to run box filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fo smoothed functions
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fo &lt;- smooth.data(simu_data$f, 25)
</code></pre>

<hr>
<h2 id='SqrtMean'>SRVF transform of warping functions</h2><span id='topic+SqrtMean'></span>

<h3>Description</h3>

<p>This function calculates the srvf of warping functions with corresponding
shooting vectors and finds the mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SqrtMean(gam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SqrtMean_+3A_gam">gam</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> warping functions with <code class="reqn">N</code> samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Karcher mean psi function</p>
</td></tr>
<tr><td><code>gam_mu</code></td>
<td>
<p>Karcher mean warping function</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>srvf of warping functions</p>
</td></tr>
<tr><td><code>vec</code></td>
<td>
<p>shooting vectors</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- SqrtMean(simu_warp$warping_functions)
</code></pre>

<hr>
<h2 id='SqrtMeanInverse'>SRVF transform of warping functions</h2><span id='topic+SqrtMeanInverse'></span>

<h3>Description</h3>

<p>This function calculates the srvf of warping functions with corresponding
shooting vectors and finds the inverse of mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SqrtMeanInverse(gam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SqrtMeanInverse_+3A_gam">gam</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> warping functions with <code class="reqn">N</code> samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gamI</code> inverse of Karcher mean warping function
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gamI &lt;- SqrtMeanInverse(simu_warp$warping_functions)
</code></pre>

<hr>
<h2 id='SqrtMedian'>SRVF transform of warping functions</h2><span id='topic+SqrtMedian'></span>

<h3>Description</h3>

<p>This function calculates the srvf of warping functions with corresponding
shooting vectors and finds the median
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SqrtMedian(gam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SqrtMedian_+3A_gam">gam</code></td>
<td>
<p>matrix (<code class="reqn">N</code> x <code class="reqn">M</code>) of <code class="reqn">M</code> warping functions with <code class="reqn">N</code> samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>
<table>
<tr><td><code>median</code></td>
<td>
<p>Karcher median psi function</p>
</td></tr>
<tr><td><code>gam_median</code></td>
<td>
<p>Karcher mean warping function</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>srvf of warping functions</p>
</td></tr>
<tr><td><code>vec</code></td>
<td>
<p>shooting vectors</p>
</td></tr>
</table>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- SqrtMedian(simu_warp_median$warping_functions)
</code></pre>

<hr>
<h2 id='srvf_to_f'>Transformation from SRSF Space</h2><span id='topic+srvf_to_f'></span>

<h3>Description</h3>

<p>This function transforms SRVFs back to the original functional space for
functions in <code class="reqn">R^1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srvf_to_f(q, time, f0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srvf_to_f_+3A_q">q</code></td>
<td>
<p>Either a numeric vector of a numeric matrix or a numeric array
specifying the SRSFs that need to be transformed.
</p>

<ul>
<li><p> If a vector, it must be of shape <code class="reqn">M</code> and it is interpreted as a
single <code class="reqn">1</code>-dimensional curve observed on a grid of size <code class="reqn">M</code>.
</p>
</li>
<li><p> If a matrix, it must be of shape
<code class="reqn">M \times N</code>. In this case, it is interpreted as a sample of <code class="reqn">N</code>
curves observed on a grid of size <code class="reqn">M</code>, unless <code class="reqn">M = 1</code> in which case
it is interpreted as a single <code class="reqn">1</code>-dimensional curve observed on a grid
of size <code class="reqn">M</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="srvf_to_f_+3A_time">time</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> specifying the grid on which
SRSFs are evaluated.</p>
</td></tr>
<tr><td><code id="srvf_to_f_+3A_f0">f0</code></td>
<td>
<p>Either a numeric value or a numeric vector of or a numeric matrix
specifying the initial value of the curves in the original functional
space. It must be:
</p>

<ul>
<li><p> a value if <code>q</code> represents a single SRSF.
</p>
</li>
<li><p> a vector of length <code class="reqn">N</code> if <code>q</code> represents a sample of <code class="reqn">N</code> SRVFs
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of the same shape as the input <code>q</code> storing the
transformation of the SRVFs <code>q</code> back to the original functional space.
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using amplitude and phase separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- f_to_srvf(simu_data$f, simu_data$time)
f &lt;- srvf_to_f(q, simu_data$time, simu_data$f[1, ])
</code></pre>

<hr>
<h2 id='time_warping'>Alignment of univariate functional data</h2><span id='topic+time_warping'></span>

<h3>Description</h3>

<p>This function aligns a collection of <code class="reqn">1</code>-dimensional curves that are
observed on the same grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_warping(
  f,
  time,
  lambda = 0,
  penalty_method = c("roughness", "geodesic", "norm"),
  centroid_type = c("mean", "median"),
  center_warpings = TRUE,
  smooth_data = FALSE,
  sparam = 25L,
  parallel = FALSE,
  optim_method = c("DP", "DPo", "DP2", "RBFGS"),
  max_iter = 20L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_warping_+3A_f">f</code></td>
<td>
<p>A numeric matrix of shape <code class="reqn">M \times N</code> specifying a sample of
<code class="reqn">N</code> curves observed on a grid of size <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_time">time</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> specifying the common grid on
which all curves <code>f</code> have been observed.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value specifying the elasticity. Defaults to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_penalty_method">penalty_method</code></td>
<td>
<p>A string specifying the penalty term used in the
formulation of the cost function to minimize for alignment. Choices are
<code>"roughness"</code> which uses the norm of the second derivative, <code>"geodesic"</code>
which uses the geodesic distance to the identity and <code>"norm"</code> which uses
the Euclidean distance to the identity. Defaults to <code>"roughness"</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to align to.
Choices are <code>"mean"</code> or <code>"median"</code>. Defaults to <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_center_warpings">center_warpings</code></td>
<td>
<p>A boolean specifying whether to center the estimated
warping functions. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_smooth_data">smooth_data</code></td>
<td>
<p>A boolean specifying whether to smooth curves using a box
filter. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_sparam">sparam</code></td>
<td>
<p>An integer value specifying the number of times to apply the
box filter. Defaults to <code>25L</code>. This is used only when <code>smooth_data = TRUE</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_parallel">parallel</code></td>
<td>
<p>A boolean specifying whether to run calculations in parallel.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_optim_method">optim_method</code></td>
<td>
<p>A string specifying the algorithm used for optimization.
Choices are <code>"DP"</code>, <code>"DPo"</code>, and <code>"RBFGS"</code>. Defaults to <code>"DP"</code>.</p>
</td></tr>
<tr><td><code id="time_warping_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer value specifying the maximum number of iterations.
Defaults to <code>20L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fdawarp</code> which is a list with the following
components:
</p>

<ul>
<li> <p><code>time</code>: a numeric vector of length <code class="reqn">M</code> storing the original grid;
</p>
</li>
<li> <p><code>f0</code>: a numeric matrix of shape <code class="reqn">M \times N</code> storing the original
sample of <code class="reqn">N</code> functions observed on a grid of size <code class="reqn">M</code>;
</p>
</li>
<li> <p><code>q0</code>: a numeric matrix of the same shape as <code>f0</code> storing the original
SRSFs;
</p>
</li>
<li> <p><code>fn</code>: a numeric matrix of the same shape as <code>f0</code> storing the aligned
functions;
</p>
</li>
<li> <p><code>qn</code>: a numeric matrix of the same shape as <code>f0</code> storing the aligned SRSFs;
</p>
</li>
<li> <p><code>fmean</code>: a numeric vector of length <code class="reqn">M</code> storing the mean or median
curve;
</p>
</li>
<li> <p><code>mqn</code>: a numeric vector of length <code class="reqn">M</code> storing the mean or median SRSF;
</p>
</li>
<li> <p><code>warping_functions</code>: a numeric matrix of the same shape as <code>f0</code> storing the
estimated warping functions;
</p>
</li>
<li> <p><code>original_variance</code>: a numeric value storing the variance of the original
sample;
</p>
</li>
<li> <p><code>amplitude_variance</code>: a numeric value storing the variance in amplitude of
the aligned sample;
</p>
</li>
<li> <p><code>phase_variance</code>: a numeric value storing the variance in phase of the
aligned sample;
</p>
</li>
<li> <p><code>qun</code>: a numeric vector of maximum length <code>max_iter + 2</code> storing the values
of the cost function after each iteration;
</p>
</li>
<li> <p><code>lambda</code>: the input parameter <code>lambda</code> which specifies the elasticity;
</p>
</li>
<li> <p><code>centroid_type</code>: the input centroid type;
</p>
</li>
<li> <p><code>optim_method</code>: the input optimization method;
</p>
</li>
<li> <p><code>inverse_average_warping_function</code>: the inverse of the mean estimated
warping function;
</p>
</li>
<li> <p><code>rsamps</code>: TO DO.
</p>
</li></ul>



<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using Fisher-Rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A., Generative models for
functional data using phase and amplitude Separation, Computational
Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  out &lt;- time_warping(simu_data$f, simu_data$time)

## End(Not run)
</code></pre>

<hr>
<h2 id='toy_data'>Distributed Gaussian Peak Dataset</h2><span id='topic+toy_data'></span>

<h3>Description</h3>

<p>A functional dataset where the individual functions are given by a Gaussian
peak with locations along the <code class="reqn">x</code>-axis. The variables are as follows: f
containing the 29 functions of 101 samples and time which describes the
sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy_data
</code></pre>


<h3>Format</h3>



<h4><code>toy_data</code></h4>

<p>A list with two components:
</p>

<ul>
<li> <p><code>f</code>: A numeric matrix of shape <code class="reqn">101 \times 29</code> storing a sample of size
<code class="reqn">N = 29</code> of curves evaluated on a grid of size <code class="reqn">M = 101</code>.
</p>
</li>
<li> <p><code>time</code>: A numeric vector of size <code class="reqn">M = 101</code> storing the grid on which
the curves <code>f</code> have been evaluated.
</p>
</li></ul>



<hr>
<h2 id='toy_warp'>Aligned Distributed Gaussian Peak Dataset</h2><span id='topic+toy_warp'></span>

<h3>Description</h3>

<p>A functional dataset where the individual functions are given by a Gaussian
peak with locations along the <code class="reqn">x</code>-axis. The variables are as follows: f
containing the 29 functions of 101 samples and time which describes the
sampling which as been aligned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy_warp
</code></pre>


<h3>Format</h3>



<h4><code>toy_warp</code></h4>

<p>A list which contains the output of the <code><a href="#topic+time_warping">time_warping()</a></code> function applied on
the data set <code>toy_data</code>.
</p>


<hr>
<h2 id='v_to_gam'>map shooting vector to warping function at identity</h2><span id='topic+v_to_gam'></span>

<h3>Description</h3>

<p>map shooting vector to warping function at identity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_to_gam(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_to_gam_+3A_v">v</code></td>
<td>
<p>Either a numeric vector of a numeric matrix or a numeric array
specifying the shooting vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of the same shape as the input array <code>v</code> storing the
shooting vectors of <code>v</code> obtained via finite differences.
</p>

<hr>
<h2 id='vertFPCA'>Vertical Functional Principal Component Analysis</h2><span id='topic+vertFPCA'></span>

<h3>Description</h3>

<p>This function calculates vertical functional principal component analysis
on aligned data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertFPCA(
  warp_data,
  no = 3,
  var_exp = NULL,
  id = round(length(warp_data$time)/2),
  ci = c(-1, 0, 1),
  showplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertFPCA_+3A_warp_data">warp_data</code></td>
<td>
<p>fdawarp object from <a href="#topic+time_warping">time_warping</a> of aligned data</p>
</td></tr>
<tr><td><code id="vertFPCA_+3A_no">no</code></td>
<td>
<p>number of principal components to extract</p>
</td></tr>
<tr><td><code id="vertFPCA_+3A_var_exp">var_exp</code></td>
<td>
<p>compute no based on value percent variance explained (example: 0.95)
will override <code>no</code></p>
</td></tr>
<tr><td><code id="vertFPCA_+3A_id">id</code></td>
<td>
<p>point to use for f(0) (default = midpoint)</p>
</td></tr>
<tr><td><code id="vertFPCA_+3A_ci">ci</code></td>
<td>
<p>geodesic standard deviations (default = c(-1,0,1))</p>
</td></tr>
<tr><td><code id="vertFPCA_+3A_showplot">showplot</code></td>
<td>
<p>show plots of principal directions (default = T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vfpca object containing </p>
<table>
<tr><td><code>q_pca</code></td>
<td>
<p>srvf principal directions</p>
</td></tr>
<tr><td><code>f_pca</code></td>
<td>
<p>f principal directions</p>
</td></tr>
<tr><td><code>latent</code></td>
<td>
<p>latent values</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>coefficients</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>eigenvectors</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>point used for f(0)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vfpca &lt;- vertFPCA(simu_warp, no = 3)
</code></pre>

<hr>
<h2 id='warp_f_gamma'>Warp Function</h2><span id='topic+warp_f_gamma'></span>

<h3>Description</h3>

<p>This function warps function <code class="reqn">f</code> by <code class="reqn">\gamma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp_f_gamma(f, time, gamma, spl.int = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_f_gamma_+3A_f">f</code></td>
<td>
<p>vector function</p>
</td></tr>
<tr><td><code id="warp_f_gamma_+3A_time">time</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="warp_f_gamma_+3A_gamma">gamma</code></td>
<td>
<p>vector warping function</p>
</td></tr>
<tr><td><code id="warp_f_gamma_+3A_spl.int">spl.int</code></td>
<td>
<p>use spline interpolation (default F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fnew warped function
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fnew &lt;- warp_f_gamma(
  f = simu_data$f[, 1],
  time = simu_data$time,
  gamma = seq(0, 1, length.out = 101)
)
</code></pre>

<hr>
<h2 id='warp_q_gamma'>Warp SRSF</h2><span id='topic+warp_q_gamma'></span>

<h3>Description</h3>

<p>This function warps srsf <code class="reqn">q</code> by <code class="reqn">\gamma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp_q_gamma(q, time, gamma, spl.int = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_q_gamma_+3A_q">q</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="warp_q_gamma_+3A_time">time</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="warp_q_gamma_+3A_gamma">gamma</code></td>
<td>
<p>vector warping function</p>
</td></tr>
<tr><td><code id="warp_q_gamma_+3A_spl.int">spl.int</code></td>
<td>
<p>use spline interpolation (default F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qnew warped function
</p>


<h3>References</h3>

<p>Srivastava, A., Wu, W., Kurtek, S., Klassen, E., Marron, J. S.,
May 2011. Registration of functional data using fisher-rao metric,
arXiv:1103.3817v2.
</p>
<p>Tucker, J. D., Wu, W., Srivastava, A.,
Generative Models for Function Data using Phase and Amplitude Separation,
Computational Statistics and Data Analysis (2012), 10.1016/j.csda.2012.12.001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- f_to_srvf(simu_data$f, simu_data$time)
qnew &lt;- warp_q_gamma(q[, 1], simu_data$time, seq(0, 1, length.out = 101))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
