<!DOCTYPE html><html><head><title>Help for package caTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {caTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#caTools-package'>
<p>Tools: moving window statistics, GIF, Base64, ROC AUC, etc.</p></a></li>
<li><a href='#base64encode &amp; base64decode'><p>Convert R vectors to/from the Base64 format</p></a></li>
<li><a href='#colAUC'><p>Column-wise Area Under ROC Curve (AUC)</p></a></li>
<li><a href='#combs'><p>All Combinations of k Elements from Vector v</p></a></li>
<li><a href='#EndRule'><p>internal function</p></a></li>
<li><a href='#LogitBoost'><p>LogitBoost Classification Algorithm</p></a></li>
<li><a href='#predict.LogitBoost'><p>Prediction Based on LogitBoost Classification Algorithm</p></a></li>
<li><a href='#read.ENVI &amp; write.ENVI'><p>Read and Write Binary Data in ENVI Format</p></a></li>
<li><a href='#read.gif &amp; write.gif'><p>Read and Write Images in GIF format</p></a></li>
<li><a href='#runmad'><p>Median Absolute Deviation of Moving Windows</p></a></li>
<li><a href='#runmean'><p>Mean of a Moving Window</p></a></li>
<li><a href='#runmin &amp; runmax'><p>Minimum and Maximum of Moving Windows</p></a></li>
<li><a href='#runquantile'><p>Quantile of Moving Window</p></a></li>
<li><a href='#runsd'><p>Standard Deviation of Moving Windows</p></a></li>
<li><a href='#sample.split'><p>Split Data into Test and Train Set</p></a></li>
<li><a href='#sumexact, cumsumexact'><p>Basic Sum Operations without Round-off Errors</p></a></li>
<li><a href='#trapz'><p>Trapezoid Rule Numerical Integration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools: Moving Window Statistics, GIF, Base64, ROC AUC, etc</td>
</tr>
<tr>
<td>Version:</td>
<td>1.18.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Jarek Tuszynski &lt;jaroslaw.w.tuszynski@saic.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dietze &lt;mdietze@gfz-potsdam.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bitops</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, rpart</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains several basic utility functions including: moving
        (rolling, running) window statistic functions, read/write for
        GIF and ENVI binary files, fast calculation of AUC, LogitBoost
        classifier, base64 encoder/decoder, round-off-error-free sum
        and cumsum, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-28 06:51:14 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-26 08:09:51 UTC; mdietze</td>
</tr>
</table>
<hr>
<h2 id='caTools-package'>
Tools: moving window statistics, GIF, Base64, ROC AUC, etc. 
</h2><span id='topic+caTools-package'></span><span id='topic+caTools'></span>

<h3>Description</h3>

<p>Contains several basic utility functions including: moving
(rolling, running) window statistic functions, read/write for
GIF and ENVI binary files, fast calculation of AUC, LogitBoost
classifier, base64 encoder/decoder, round-off error free sum
and cumsum, etc.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> caTools</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.17</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> April 21, 2014</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.2.0), bitops</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> MASS, rpart</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL=3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index:
</p>
<pre>
LogitBoost              LogitBoost Classification Algorithm
predict.LogitBoost      Prediction Based on LogitBoost Algorithm
base64encode            Convert R vectors to/from the Base64 format
colAUC                  Column-wise Area Under ROC Curve (AUC)
combs                   All Combinations of k Elements from Vector v
read.ENVI               Read and Write Binary Data in ENVI Format
read.gif                Read and Write Images in GIF format
runmean                 Mean of a Moving Window
runmin                  Minimum and Maximum of Moving Windows
runquantile             Quantile of Moving Window
runmad                  Median Absolute Deviation of Moving Windows
runsd                   Standard Deviation of Moving Windows
sample.split            Split Data into Test and Train Set
sumexact                Basic Sum Operations without Round-off Errors
trapz                   Trapezoid Rule Numerical Integration
</pre>


<h3>Author(s)</h3>

<p>Jarek Tuszynski &lt;jaroslaw.w.tuszynski@saic.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # GIF image read &amp; write
  write.gif( volcano, "volcano.gif", col=terrain.colors, flip=TRUE, 
           scale="always", comment="Maunga Whau Volcano")
  y = read.gif("volcano.gif", verbose=TRUE, flip=TRUE)
  image(y$image, col=y$col, main=y$comment, asp=1)
  file.remove("volcano.gif")

  # test runmin, runmax and runmed
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  col = c("black", "red", "green", "brown", "blue", "magenta", "cyan")
  plot(x, col=col[1], main = "Moving Window Analysis Functions (window size=25)")
  lines(runmin (x,k), col=col[2])
  lines(runmed (x,k), col=col[3])
  lines(runmean(x,k), col=col[4])
  lines(runmax (x,k), col=col[5])
  legend(0,.9*n, c("data", "runmin", "runmed", "runmean", "runmax"), col=col, lty=1 )

  # sum vs. sumexact
  x = c(1, 1e20, 1e40, -1e40, -1e20, -1)
  a = sum(x);         print(a)
  b = sumexact(x);    print(b)

</code></pre>

<hr>
<h2 id='base64encode+20+26amp+3B+20base64decode'>Convert R vectors to/from the Base64 format </h2><span id='topic+base64encode'></span><span id='topic+base64decode'></span>

<h3>Description</h3>

<p>Convert R vectors of any type to and from the Base64 format for encrypting
any binary data as string using alphanumeric subset of ASCII character set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  base64encode(x, size=NA, endian=.Platform$endian)
  base64decode(z, what, size=NA, signed = TRUE, endian=.Platform$endian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64encode+2B20+2B26amp+2B3B+2B20base64decode_+3A_x">x</code></td>
<td>
<p>vector or any structure that can be converted to a vector by  
<code><a href="base.html#topic+as.vector">as.vector</a></code> function. Strings are also allowed.</p>
</td></tr>
<tr><td><code id="base64encode+2B20+2B26amp+2B3B+2B20base64decode_+3A_z">z</code></td>
<td>
<p>String with Base64 code, using [A-Z,a-z,0-9,+,/,=] subset of 
characters</p>
</td></tr>
<tr><td><code id="base64encode+2B20+2B26amp+2B3B+2B20base64decode_+3A_what">what</code></td>
<td>
<p>Either an object whose mode will give the mode of the vector
to be created, or a character vector of length one describing
the mode: one of '&quot;numeric&quot;, &quot;double&quot;, &quot;integer&quot;, &quot;int&quot;,
&quot;logical&quot;, &quot;complex&quot;, &quot;character&quot;, &quot;raw&quot;.  
Same as variable <code>what</code> in <code><a href="base.html#topic+readBin">readBin</a></code> functions. </p>
</td></tr>
<tr><td><code id="base64encode+2B20+2B26amp+2B3B+2B20base64decode_+3A_size">size</code></td>
<td>
<p> integer.  The number of bytes per element in the byte stream 
stored in <code>r</code>. The default, '<code>NA</code>', uses the natural size. 
Same as variable <code>size</code> in <code><a href="base.html#topic+readBin">readBin</a></code> functions. </p>
</td></tr>
<tr><td><code id="base64encode+2B20+2B26amp+2B3B+2B20base64decode_+3A_signed">signed</code></td>
<td>
<p>logical. Only used for integers of sizes 1 and 2, when it
determines if the quantity stored as raw should be regarded as a
signed or unsigned integer.
Same as variable <code>signed</code> in <code><a href="base.html#topic+readBin">readBin</a></code> functions. </p>
</td></tr>
<tr><td><code id="base64encode+2B20+2B26amp+2B3B+2B20base64decode_+3A_endian">endian</code></td>
<td>
<p>If provided, can be used to swap endian-ness. Using '&quot;swap&quot;' 
will force swapping of byte order. Use '&quot;big&quot;' (big-endian, aka IEEE, 
aka &quot;network&quot;) or '&quot;little&quot;' (little-endian, format used on PC/Intel 
machines) to indicate type of data encoded in &quot;raw&quot; format.
Same as variable <code>endian</code> in <code><a href="base.html#topic+readBin">readBin</a></code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Base64 encoding is designed to encode arbitrary binary information for 
transmission by electronic mail. It is defined by MIME (Multipurpose Internet 
Mail Extensions) specification RFC 1341, RFC 1421, RFC 2045 and others. 
Triplets of 8-bit octets are encoded as groups of four characters, each 
representing 6 bits of the source 24 bits. Only a 65-character subset 
([A-Z,a-z,0-9,+,/,=]) present in all variants of ASCII and EBCDIC is used, 
enabling 6 bits to be represented per printable character.
</p>
<p>Default <code>size</code>s for different types of <code>what</code>: <code>logical</code> - 4, 
<code>integer</code> - 4, <code>double</code> - 8 , <code>complex</code> - 16, 
<code>character</code> - 2, <code>raw</code> - 1.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+base64encode">base64encode</a></code> returns a string with Base64 code.
Function <code><a href="#topic+base64decode">base64decode</a></code> returns vector of appropriate mode 
and length (see <code>x</code> above).
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>


<ul>
<li><p> Base64 description in <em>Connected: An Internet Encyclopedia</em>
<a href="https://www.freesoft.org/CIE/RFC/1521/7.htm">https://www.freesoft.org/CIE/RFC/1521/7.htm</a>
</p>
</li>
<li><p> MIME RFC 1341 <a href="http://www.faqs.org/rfcs/rfc1341.html">http://www.faqs.org/rfcs/rfc1341.html</a>
</p>
</li>
<li><p> MIME RFC 1421 <a href="http://www.faqs.org/rfcs/rfc1421.html">http://www.faqs.org/rfcs/rfc1421.html</a>
</p>
</li>
<li><p> MIME RFC 2045 <a href="http://www.faqs.org/rfcs/rfc2045.html">http://www.faqs.org/rfcs/rfc2045.html</a>
</p>
</li>
<li><p> Portions of the code are based on Matlab code by Peter Acklam
</p>
</li></ul>



<h3>See Also</h3>

 
<p><code><a href="XML.html#topic+xmlValue">xmlValue</a></code> from <span class="pkg">XML</span> package reads XML code
which sometimes is encoded in Base64 format.
</p>
<p><code><a href="base.html#topic+readBin">readBin</a></code>, <code><a href="base.html#topic+writeBin">writeBin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x = (10*runif(10)&gt;5) # logical
   for (i in c(NA, 1, 2, 4)) {
     y = base64encode(x, size=i)
     z = base64decode(y, typeof(x), size=i)
     stopifnot(x==z)
   }
   print("Checked base64 for encode/decode logical type")

   x = as.integer(1:10) # integer
   for (i in c(NA, 1, 2, 4)) {
     y = base64encode(x, size=i)
     z = base64decode(y, typeof(x), size=i)
     stopifnot(x==z)
   }
   print("Checked base64 encode/decode for integer type")
   
   x = (1:10)*pi        # double
   for (i in c(NA, 4, 8)) {
     y = base64encode(x, size=i)
     z = base64decode(y, typeof(x), size=i)
     stopifnot(mean(abs(x-z))&lt;1e-5)
   }
   print("Checked base64 for encode/decode double type")
   
   x = log(as.complex(-(1:10)*pi))        # complex
   y = base64encode(x)
   z = base64decode(y, typeof(x))
   stopifnot(x==z)
   print("Checked base64 for encode/decode complex type")
  
   x = "Chance favors the prepared mind" # character
   y = base64encode(x)
   z = base64decode(y, typeof(x))
   stopifnot(x==z)
   print("Checked base64 for encode/decode character type")
</code></pre>

<hr>
<h2 id='colAUC'>Column-wise Area Under ROC Curve (AUC)</h2><span id='topic+colAUC'></span>

<h3>Description</h3>

<p>Calculate Area Under the ROC Curve (AUC) for every column of a 
matrix. Also, can be used to plot the ROC curves.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  colAUC(X, y, plotROC=FALSE, alg=c("Wilcoxon","ROC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colAUC_+3A_x">X</code></td>
<td>
<p>A matrix or data frame. Rows contain samples 
and columns contain features/variables.</p>
</td></tr>
<tr><td><code id="colAUC_+3A_y">y</code></td>
<td>
<p>Class labels for the <code>X</code> data samples. 
A response vector with one label for each row/component of <code>X</code>.
Can be either a factor, string or a numeric vector.</p>
</td></tr>
<tr><td><code id="colAUC_+3A_plotroc">plotROC</code></td>
<td>
<p>Plot ROC curves. Use only for small number of features. 
If <code>TRUE</code>, will set <code>alg</code> to &quot;ROC&quot;.</p>
</td></tr>
<tr><td><code id="colAUC_+3A_alg">alg</code></td>
<td>
<p>Algorithm to use: &quot;ROC&quot; integrates ROC curves, while &quot;Wilcoxon&quot;
uses Wilcoxon Rank Sum Test to get the same results. Default &quot;Wilcoxon&quot; is
faster. This argument is mostly provided for verification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AUC is a very useful measure of similarity between two classes measuring area
under &quot;Receiver Operating Characteristic&quot; or ROC curve.
In case of data with no ties all sections of ROC curve are either horizontal
or vertical, in case of data with ties diagonal 
sections can also occur. Area under the ROC curve is calculated using 
<code><a href="#topic+trapz">trapz</a></code> function. AUC is always in between 0.5 
(two classes are statistically identical) and 1.0 (there is a threshold value
that can achieve a perfect separation between the classes).
</p>
<p>Area under ROC Curve (AUC) measure is very similar to Wilcoxon Rank Sum Test 
(see <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>) and Mann-Whitney U Test. 
</p>
<p>There are numerous other functions for calculating AUC in other packages. 
Unfortunately none of them had all the properties that were needed for 
classification preprocessing, to lower the dimensionality of the data (from 
tens of thousands to hundreds) before applying standard classification 
algorithms. 
</p>
<p>The main properties of this code are: 
</p>

<ul>
<li><p> Ability to work with multi-dimensional data (<code>X</code> can have many 
columns).
</p>
</li>
<li><p> Ability to work with multi-class datasets (<code>y</code> can have more 
than 2 different values).
</p>
</li>
<li><p> Speed - this code was written to calculate AUC's of large number of 
features, fast.
</p>
</li>
<li><p> Returned AUC is always bigger than 0.5, which is equivalent of 
testing for each feature <code>colAUC(x,y)</code> and <code>colAUC(-x,y)</code> and
returning the value of the bigger one.
</p>
</li></ul>

<p>If those properties do not fit your problem, see &quot;See Also&quot; and &quot;Examples&quot; 
sections for AUC 
functions in other packages that might be a better fit for your needs. 
</p>


<h3>Value</h3>

<p>An output is a single matrix with the same number of columns as <code>X</code> and 
&quot;n choose 2&quot; ( <code class="reqn">\frac{n!}{(n-2)! 2!} = n(n-1)/2</code> )
number of rows, 
where n is number of unique labels in <code>y</code> list. For example, if <code>y</code> 
contains only two unique class labels ( <code>length(unique(lab))==2</code> ) than
output 
matrix will  have a single row containing AUC of each column. If more than 
two unique labels are present than AUC is calculated for every possible 
pairing of classes (&quot;n choose 2&quot; of them).
</p>
<p>For multi-class AUC &quot;Total AUC&quot; as defined by Hand &amp; Till (2001) can be 
calculated by <code><a href="base.html#topic+colMeans">colMeans</a>(auc)</code>.  
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>


<ul>
<li><p> Mason, S.J. and Graham, N.E. (1982) <em>Areas beneath the relative 
operating characteristics (ROC) and relative operating levels (ROL) 
curves: Statistical significance and interpretation</em>,  Q. J. R. 
Meteorol. Soc. textbf30 291-303. 
</p>
</li>
<li><p> Fawcett, Tom (2004) <em>ROC Graphs: Notes and Practical 
Considerations for Researchers</em>
</p>
</li>
<li><p>  Hand, David and Till, Robert (2001) <em>A Simple 
Generalization of the Area Under the ROC Curve for Multiple Class 
Classification Problems</em>;  Machine Learning 45(2): 171-186
</p>
</li>
<li><p> See 
<a href="http://www.medicine.mcgill.ca/epidemiology/hanley/software/">http://www.medicine.mcgill.ca/epidemiology/hanley/software/</a> 
to find articles below: 
</p>

<ul>
<li><p> Hanley and McNeil (1982), <em>The Meaning and Use of the Area 
under a Receiver Operating Characteristic (ROC) Curve</em>, 
Radiology 143: 29-36.
</p>
</li>
<li><p> Hanley and McNeil (1983), <em>A Method of Comparing the Areas  
under ROC curves derived from same cases</em>, Radiology 148: 839-843.
</p>
</li>
<li><p> McNeil and Hanley (1984), <em>Statistical Approaches to the  
Analysis of ROC curves</em>, Medical Decision Making 4(2): 136-149.
</p>
</li></ul>

</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> and <code><a href="stats.html#topic+pwilcox">pwilcox</a></code>
</p>
</li>
<li> <p><code><a href="exactRankTests.html#topic+wilcox.exact">wilcox.exact</a></code> from <span class="pkg">exactRankTests</span> package
</p>
</li>
<li> <p><code><a href="coin.html#topic+wilcox_test">wilcox_test</a></code> from <span class="pkg">coin</span> package
</p>
</li>
<li> <p><code><a href="ROCR.html#topic+performance">performance</a></code> from <span class="pkg">ROCR</span> package
</p>
</li>
<li> <p><code><a href="Epi.html#topic+ROC">ROC</a></code> from <span class="pkg">Epi</span> package
</p>
</li>
<li> <p><code><a href="verification.html#topic+roc.area">roc.area</a></code> from <span class="pkg">verification</span> package
</p>
</li>
<li> <p><code><a href="Hmisc.html#topic+rcorr.cens">rcorr.cens</a></code> from <span class="pkg">Hmisc</span> package
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load MASS library with "cats" data set that have following columns: sex, body
# weight, hart weight. Calculate how good weights are in predicting sex of cats.
# 2 classes; 2 features; 144 samples
library(MASS); data(cats);
colAUC(cats[,2:3], cats[,1], plotROC=TRUE) 

# Load rpart library with "kyphosis" data set that records if kyphosis
# deformation was present after corrective surgery. Calculate how good age, 
# number and position of vertebrae are in predicting successful operation. 
# 2 classes; 3 features; 81 samples
library(rpart); data(kyphosis);
colAUC(kyphosis[,2:4], kyphosis[,1], plotROC=TRUE)

# Example of 3-class 4-feature 150-sample iris data
data(iris)
colAUC(iris[,-5], iris[,5], plotROC=TRUE)
cat("Total AUC: \n"); 
colMeans(colAUC(iris[,-5], iris[,5]))

# Test plots in case of data without column names
Iris = as.matrix(iris[,-5])
dim(Iris) = c(600,1)
dim(Iris) = c(150,4)
colAUC(Iris, iris[,5], plotROC=TRUE)

# Compare calAUC with other functions designed for similar purpose
auc = matrix(NA,12,3)
rownames(auc) = c("colAUC(alg='ROC')", "colAUC(alg='Wilcox')", "sum(rank)",
    "wilcox.test", "wilcox_test", "wilcox.exact", "roc.area", "AUC", 
    "performance", "ROC", "auROC", "rcorr.cens")
colnames(auc) = c("AUC(x)", "AUC(-x)", "AUC(x+noise)")
X = cbind(cats[,2], -cats[,2], cats[,2]+rnorm(nrow(cats)) )
y = ifelse(cats[,1]=='F',0,1)
for (i in 1:3) {
  x = X[,i]
  x1 = x[y==1]; n1 = length(x1);                 # prepare input data ...
  x2 = x[y==0]; n2 = length(x2);                 # ... into required format
  data = data.frame(x=x,y=factor(y))
  auc[1,i] = colAUC(x, y, alg="ROC") 
  auc[2,i] = colAUC(x, y, alg="Wilcox")
  r = rank(c(x1,x2))
  auc[3,i] = (sum(r[1:n1]) - n1*(n1+1)/2) / (n1*n2)
  auc[4,i] = wilcox.test(x1, x2, exact=0)$statistic / (n1*n2) 
  ## Not run: 
  if (require("coin"))
    auc[5,i] = statistic(wilcox_test(x~y, data=data)) / (n1*n2) 
  if (require("exactRankTests"))  
    auc[6,i] = wilcox.exact(x, y, exact=0)$statistic / (n1*n2) 
  if (require("verification"))
    auc[7,i] = roc.area(y, x)$A.tilda 
  if (require("ROC")) 
    auc[8,i] = AUC(rocdemo.sca(y, x, dxrule.sca))    
  if (require("ROCR")) 
    auc[9,i] = performance(prediction( x, y),"auc")@y.values[[1]]
  if (require("Epi"))   auc[10,i] = ROC(x,y,grid=0)$AUC
  if (require("limma")) auc[11,i] = auROC(y, x)
  if (require("Hmisc")) auc[12,i] = rcorr.cens(x, y)[1]
  
## End(Not run)
}
print(auc)
stopifnot(auc[1, ]==auc[2, ])   # results of 2 alg's in colAUC must be the same
stopifnot(auc[1,1]==auc[3,1])   # compare with wilcox.test results

# time trials
x = matrix(runif(100*1000),100,1000)
y = (runif(100)&gt;0.5)
system.time(colAUC(x,y,alg="ROC"   ))
system.time(colAUC(x,y,alg="Wilcox"))
</code></pre>

<hr>
<h2 id='combs'>All Combinations of k Elements from Vector v</h2><span id='topic+combs'></span>

<h3>Description</h3>

<p>Finds all unordered combinations of <code>k</code> elements from vector 
<code>v</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>combs(v,k)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combs_+3A_v">v</code></td>
<td>
<p>Any numeric vector</p>
</td></tr>
<tr><td><code id="combs_+3A_k">k</code></td>
<td>
<p>Number of elements to choose from vector <code>v</code>. Integer smaller 
or equal than length of <code>v</code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>combs(v,k)</code> (where <code>v</code> has length <code>n</code>) creates a matrix with 
<code class="reqn">\frac{n!}{(n-k)! k!}</code> (<code>n</code> choose <code>k</code>) rows
and <code>k</code> columns containing all possible combinations of <code>n</code> elements 
taken <code>k</code> at a time.
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>See Also</h3>

<p>I discovered recently that R packages already have two functions with 
similar capabilities:
<code><a href="gtools.html#topic+combinations">combinations</a></code> from <span class="pkg">gTools</span> package and
Also similar to Matlab's <code>nchoosek</code> function (<a href="http://www.mathworks.com/access/helpdesk/help/techdoc/ref/nchoosek.html">http://www.mathworks.com/access/helpdesk/help/techdoc/ref/nchoosek.html</a>) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  combs(2:5, 3) # display examples
  combs(c("cats", "dogs", "mice"), 2)
  
  a = combs(1:4, 2)
  b = matrix( c(1,1,1,2,2,3,2,3,4,3,4,4), 6, 2)
  stopifnot(a==b)
</code></pre>

<hr>
<h2 id='EndRule'>internal function</h2><span id='topic+EndRule'></span>

<h3>Description</h3>

<p>internal function</p>


<h3>Usage</h3>

<pre><code class='language-R'>EndRule(x, y, k, dimx,
             endrule=c("NA", "trim", "keep", "constant", "func"), 
             align = c("center", "left", "right"), Func, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EndRule_+3A_x">x</code></td>
<td>
<p>numeric vector of length n</p>
</td></tr>
<tr><td><code id="EndRule_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between one and n.</p>
</td></tr>
<tr><td><code id="EndRule_+3A_dimx">dimx</code></td>
<td>
<p>original dimension of x (usually <code>dim(x)</code>) used to choose 
dimentions of the output. </p>
</td></tr>
<tr><td><code id="EndRule_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning 
and the end, of the data, should be treated. Only first and last <code>k2</code> 
values at both ends are affected, where <code>k2</code> is the half-bandwidth 
<code>k2 = k %/% 2</code>.
</p>

<ul>
<li> <p><code>"mad"</code> - applies the mad function to
smaller and smaller sections of the array. Equivalent to: 
<code>for(i in 1:k2) out[i]=mad(x[1:(i+k2)])</code>. 
</p>
</li>
<li> <p><code>"trim"</code> - trim the ends; output array length is equal to 
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics 
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code> and other 
related functions.
</p>
</li>
<li> <p><code>"keep"</code> - fill the ends with numbers from <code>x</code> vector 
<code>(out[1:k2] = x[1:k2])</code>. This option makes more sense in case of 
smoothing functions, kept here for consistency.
</p>
</li>
<li> <p><code>"constant"</code> - fill the ends with first and last calculated 
value in output array <code>(out[1:k2] = out[k2+1])</code>
</p>
</li>
<li> <p><code>"NA"</code> - fill the ends with NA's <code>(out[1:k2] = NA)</code>
</p>
</li>
<li> <p><code>"func"</code> - same as <code>"mad"</code> option except that implemented
in R for testing purposes. Avoid since it can be very slow for large windows.
</p>
</li></ul>

</td></tr>
<tr><td><code id="EndRule_+3A_y">y</code></td>
<td>
<p>numeric vector of length n, which is partially filled output of 
one of the <code>run</code> functions. Function <code>EndRule</code> will fill the 
remaining beginning and end sections using method chosen by <code>endrule</code> 
argument.</p>
</td></tr>
<tr><td><code id="EndRule_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default), 
left-aligned or right-aligned. </p>
</td></tr>
<tr><td><code id="EndRule_+3A_func">Func</code></td>
<td>
<p>Function name that <code>EndRule</code> will use in case of 
<code>endrule="func"</code>.</p>
</td></tr>
<tr><td><code id="EndRule_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>Func</code> that <code>EndRule</code> will 
use in case of <code>endrule="func"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of the same length as <code>x</code>. Only in case of 
<code>endrule="trim"</code>.the output will be shorter. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>

<hr>
<h2 id='LogitBoost'>LogitBoost Classification Algorithm</h2><span id='topic+LogitBoost'></span>

<h3>Description</h3>

<p>Train logitboost classification algorithm using decision 
stumps (one node decision trees) as weak learners.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>LogitBoost(xlearn, ylearn, nIter=ncol(xlearn))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogitBoost_+3A_xlearn">xlearn</code></td>
<td>
<p>A matrix or data frame with training data. Rows contain samples 
and columns contain features</p>
</td></tr>
<tr><td><code id="LogitBoost_+3A_ylearn">ylearn</code></td>
<td>
<p>Class labels for the training data samples. 
A response vector with one label for each row/component of <code>xlearn</code>.
Can be either a factor, string or a numeric vector.</p>
</td></tr>
<tr><td><code id="LogitBoost_+3A_niter">nIter</code></td>
<td>
<p>An integer, describing the number of iterations for
which boosting should be run, or number of decision stumps that will be 
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function was adapted from logitboost.R function written by Marcel 
Dettling. See references and &quot;See Also&quot; section. The code was modified in 
order to make it much faster for very large data sets. The speed-up was 
achieved by implementing a internal version of decision stump classifier 
instead of using calls to <code><a href="rpart.html#topic+rpart">rpart</a></code>. That way, some of the most time 
consuming operations were precomputed once, instead of performing them at 
each iteration. Another difference is that training and testing phases of the 
classification process were split into separate functions.
</p>


<h3>Value</h3>

<p>An object of class &quot;LogitBoost&quot; including components: 
</p>
<table>
<tr><td><code>Stump</code></td>
<td>
<p>List of decision stumps (one node decision trees) used:
</p>

<ul>
<li><p> column 1: feature numbers or each stump, or which column each stump 
operates on
</p>
</li>
<li><p> column 2: threshold to be used for that column
</p>
</li>
<li><p> column 3: bigger/smaller info: 1 means that if values in the column 
are above threshold than corresponding samples will be labeled as 
<code>lablist[1]</code>. Value &quot;-1&quot; means the opposite.
</p>
</li></ul>

<p>If there are more than two classes, than several &quot;Stumps&quot; will be
<code>cbind</code>'ed
</p>
</td></tr>
<tr><td><code>lablist</code></td>
<td>
<p>names of each class</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>

<p>Dettling and Buhlmann (2002), <em>Boosting for Tumor  Classification of Gene Expression Data</em>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+predict.LogitBoost">predict.LogitBoost</a></code> has prediction half of LogitBoost code
</p>
</li>
<li> <p><code>logitboost</code> function from <span class="pkg">logitboost</span> library (not in CRAN
or BioConductor is very similar but much
slower on very large datasets. It also perform optional cross-validation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  data(iris)
  Data  = iris[,-5]
  Label = iris[, 5]
  
  # basic interface
  model = LogitBoost(Data, Label, nIter=20)
  Lab   = predict(model, Data)
  Prob  = predict(model, Data, type="raw")
  t     = cbind(Lab, Prob)
  t[1:10, ]

  # two alternative call syntax
  p=predict(model,Data)
  q=predict.LogitBoost(model,Data)
  pp=p[!is.na(p)]; qq=q[!is.na(q)]
  stopifnot(pp == qq)

  # accuracy increases with nIter (at least for train set)
  table(predict(model, Data, nIter= 2), Label)
  table(predict(model, Data, nIter=10), Label)
  table(predict(model, Data),           Label)
  
  # example of spliting the data into train and test set
  mask = sample.split(Label)
  model = LogitBoost(Data[mask,], Label[mask], nIter=10)
  table(predict(model, Data[!mask,], nIter=2), Label[!mask])
  table(predict(model, Data[!mask,]),          Label[!mask])
</code></pre>

<hr>
<h2 id='predict.LogitBoost'>Prediction Based on LogitBoost Classification Algorithm</h2><span id='topic+predict.LogitBoost'></span>

<h3>Description</h3>

<p>Prediction or Testing using logitboost classification algorithm</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogitBoost'
predict(object, xtest, type = c("class", "raw"), nIter=NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.LogitBoost_+3A_object">object</code></td>
<td>
<p>An object of class &quot;LogitBoost&quot; see &quot;Value&quot; section of 
<code><a href="#topic+LogitBoost">LogitBoost</a></code> for details</p>
</td></tr>
<tr><td><code id="predict.LogitBoost_+3A_xtest">xtest</code></td>
<td>
<p>A matrix or data frame with test data. Rows contain samples 
and columns contain features</p>
</td></tr>
<tr><td><code id="predict.LogitBoost_+3A_type">type</code></td>
<td>
<p>See &quot;Value&quot; section</p>
</td></tr>
<tr><td><code id="predict.LogitBoost_+3A_niter">nIter</code></td>
<td>
<p>An optional integer, used to lower number of iterations 
(decision stumps) used in the decision making. If not provided than the 
number will be the same as the one provided in <code><a href="#topic+LogitBoost">LogitBoost</a></code>. 
If provided than the results will be the same as running 
<code><a href="#topic+LogitBoost">LogitBoost</a></code> with fewer iterations. </p>
</td></tr>
<tr><td><code id="predict.LogitBoost_+3A_...">...</code></td>
<td>
<p>not used but needed for compatibility with generic predict 
method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Logitboost algorithm relies on a voting scheme to make classifications. Many
(<code>nIter</code> of them) week classifiers are applied to each sample and their
findings are used as votes to make the final classification. The class with 
the most votes &quot;wins&quot;. However, with this scheme it is common for two cases 
have a tie (the same number of votes), especially if number of iterations is 
even. In that case NA is returned, instead of a label. 
</p>


<h3>Value</h3>

<p>If type = &quot;class&quot; (default) label of the class with maximal probability is 
returned for each sample. If type = &quot;raw&quot;, the a-posterior probabilities for 
each class are returned.
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+LogitBoost">LogitBoost</a></code> has training half of LogitBoost code</p>


<h3>Examples</h3>

<pre><code class='language-R'># See LogitBoost example</code></pre>

<hr>
<h2 id='read.ENVI+20+26amp+3B+20write.ENVI'>Read and Write Binary Data in ENVI Format</h2><span id='topic+read.ENVI'></span><span id='topic+write.ENVI'></span>

<h3>Description</h3>

<p>Read and write binary data in ENVI format, which is supported by 
most GIS software.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  read.ENVI(filename, headerfile=paste(filename, ".hdr", sep="")) 
  write.ENVI (X, filename, interleave = c("bsq", "bil", "bip")) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ENVI+2B20+2B26amp+2B3B+2B20write.ENVI_+3A_x">X</code></td>
<td>
<p>data to be saved in ENVI file. Can be a matrix or 3D array.</p>
</td></tr>
<tr><td><code id="read.ENVI+2B20+2B26amp+2B3B+2B20write.ENVI_+3A_filename">filename</code></td>
<td>
<p>character string with name of the file (connection)</p>
</td></tr>
<tr><td><code id="read.ENVI+2B20+2B26amp+2B3B+2B20write.ENVI_+3A_headerfile">headerfile</code></td>
<td>
<p>optional character string with name of the header file</p>
</td></tr>
<tr><td><code id="read.ENVI+2B20+2B26amp+2B3B+2B20write.ENVI_+3A_interleave">interleave</code></td>
<td>
<p>optional character string specifying interleave to be used</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>ENVI binary files use a generalized raster data format that consists of two 
parts: 
</p>

<ul>
<li><p> binary file - flat binary file equivalent to memory dump, as produced by 
<code><a href="base.html#topic+writeBin">writeBin</a></code> in R or <code>fwrite</code> in C/C++.
</p>
</li>
<li><p> header file - small text (ASCII) file containing the metadata 
associated with the binary file. This file can contain the following 
fields, followed by equal sign and a variable: 
</p>

<ul>
<li> <p><code>samples</code> - number of columns <br />
</p>
</li>
<li> <p><code>lines</code> - number of rows <br />
</p>
</li>
<li> <p><code>bands</code> - number of bands (channels, planes) <br />
</p>
</li>
<li> <p><code>data type</code> - following types are supported:
</p>

<ul>
<li><p> 1 - 1-byte unsigned integer
</p>
</li>
<li><p> 2 - 2-byte signed integer
</p>
</li>
<li><p> 3 - 4-byte signed integer
</p>
</li>
<li><p> 4 - 4-byte float
</p>
</li>
<li><p> 5 - 8-byte double
</p>
</li>
<li><p> 9 - 2x8-byte complex number made up from 2 doubles
</p>
</li>
<li><p> 12 - 2-byte unsigned integer
</p>
</li></ul>

</li>
<li> <p><code>header offset</code> -  number of bytes to skip before 
raster data starts in binary file. 
</p>
</li>
<li> <p><code>interleave</code> - Permutations of dimensions in binary data:
</p>

<ul>
<li> <p><code>BSQ</code> - Band Sequential (X[col,row,band])
</p>
</li>
<li> <p><code>BIL</code> - Band Interleave by Line (X[col,band,row])
</p>
</li>
<li> <p><code>BIP</code> - Band Interleave by Pixel (X[band,col,row]) 
</p>
</li></ul>

</li>
<li> <p><code>byte order</code> - the endian-ness of the saved data: 
</p>

<ul>
<li><p> 0 - means little-endian byte order, format used on PC/Intel machines
</p>
</li>
<li><p> 1 - means big-endian (aka IEEE, aka &quot;network&quot;) byte order, format 
used on UNIX and Macintosh machines
</p>
</li></ul>

</li></ul>

</li></ul>

<p>Fields <code>samples</code>, <code>lines</code>, <code>bands</code>, <code>data type</code> are 
required, while <code>header offset</code>, <code>interleave</code>, <code>byte order</code> are
optional. All of them are in form of integers except <code>interleave</code> which
is a string.
</p>
<p>This generic format allows reading of many raw file formats, including those 
with embedded header information. Also it is a handy binary format to 
exchange data between PC and UNIX/Mac machines, as well as different 
languages like: C, Fortran, Matlab, etc. Especially since header files are 
simple enough to edit by hand.
</p>
<p>File type supported by most of GIS (geographic information system) software
including: ENVI software, Freelook (free file viewer by ENVI), ArcGIS, etc. 
</p>


<h3>Value</h3>

<p> Function <code>read.ENVI</code> returns either a matrix or 3D array. 
Function <code>write.ENVI</code> does not return anything.</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>See Also</h3>

<p>Displaying of images can be done through functions: <code>graphics::image</code>,
<code>fields::image.plot</code> and <code>fields:add.image</code> or 
<code>spatstat:plot.im</code>.
</p>
<p>ENVI files are practically C-style memory-dumps as performed by 
<code>readBin</code> and <code>writeBin</code> functions plus separate 
meta-data header file.
</p>
<p>GIF file formats can also store 3D data (see <code>read.gif</code> and 
<code>write.gif</code> functions).
</p>
<p>Packages related to GIS data: <span class="pkg">shapefiles</span>, <span class="pkg">maptools</span>, <span class="pkg">sp</span>, 
<span class="pkg">spdep</span>, <span class="pkg">adehabitat</span>, <span class="pkg">GRASS</span>, <span class="pkg">PBSmapping</span>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X = array(1:60, 3:5)
  write.ENVI(X, "temp.nvi")
  Y = read.ENVI("temp.nvi")
  stopifnot(X == Y)
  readLines("temp.nvi.hdr")
  
  d = c(20,30,40)
  X = array(runif(prod(d)), d)
  write.ENVI(X, "temp.nvi", interleave="bil")
  Y = read.ENVI("temp.nvi")
  stopifnot(X == Y)
  readLines("temp.nvi.hdr")
  
  file.remove("temp.nvi")
  file.remove("temp.nvi.hdr")
</code></pre>

<hr>
<h2 id='read.gif+20+26amp+3B+20write.gif'>Read and Write Images in GIF format</h2><span id='topic+read.gif'></span><span id='topic+write.gif'></span>

<h3>Description</h3>

<p>Read and write files in GIF format. Files can contain single images
or multiple frames. Multi-frame images are saved as animated GIF's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gif(filename, frame=0, flip=FALSE, verbose=FALSE) 
write.gif(image, filename, col="gray", scale=c("smart", "never", "always"), 
    transparent=NULL, comment=NULL, delay=0, flip=FALSE, interlace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_filename">filename</code></td>
<td>
<p>Character string with name of the file. In case of 
<code>read.gif</code> URL's are also allowed.</p>
</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_image">image</code></td>
<td>
<p>Data to be saved as GIF file. Can be a 2D matrix or 3D array. 
Allowed formats in order of preference:
</p>

<ul>
<li><p> array of integers in [0:255] range - this is format required by GIF 
file, and unless <code>scale='always'</code>, numbers will not be rescaled.
Each pixel <code>i</code> will have associated color <code>col[image[i]+1]</code>. 
This is the only format that can be safely used with non-continuous color 
maps.
</p>
</li>
<li><p> array of doubles in [0:1] range - Unless <code>scale='never'</code> the 
array will be multiplied by 255 and rounded.
</p>
</li>
<li><p> array of numbers in any range - will be scaled or clipped depending 
on <code>scale</code> option. 
</p>
</li></ul>

</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_frame">frame</code></td>
<td>
<p>Request specific frame from multiframe (i.e., animated) GIF file. 
By default all frames are read from the file (<code>frame=0</code>). Setting  
<code>frame=1</code> will ensure that output is always a 2D matrix containing the 
first frame.  Some files have to be read frame by frame, for example: files 
with subimages of different sizes and files with both global and local 
color-maps (palettes).</p>
</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_col">col</code></td>
<td>
<p>Color palette definition. Several formats are allowed: 
</p>

<ul>
<li><p> array (list) of colors in the same format as output of palette 
functions.  Preferred format for precise color control.
</p>
</li>
<li><p> palette function itself (ex. '<code>col=rainbow</code>'). Preferred 
format if not sure how many colors are needed.
</p>
</li>
<li><p> character string with name of internally defined palette. At the 
moment only &quot;gray&quot; and &quot;jet&quot; (Matlab's jet palette) are defined.
</p>
</li>
<li><p> character string with name of palette function  (ex. 
'<code>col="rainbow"</code>')
</p>
</li></ul>

<p>Usually palette will consist of 256 colors, which is the maximum allowed by 
GIF format. By default, grayscale will be used.</p>
</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_scale">scale</code></td>
<td>
<p>There are three approaches to rescaling the data to required 
[0, 255] integer range:
</p>
       
<ul>
<li><p> &quot;smart&quot; - Data is fitted to [0:255] range, only if it falls outside 
of it. Also, if <code>image</code> is an array of doubles in range [0, 1] than 
data is multiplied by 255.
</p>
</li>
<li><p> &quot;never&quot; - Pixels with intensities outside of the allowed range are 
clipped to either 0 or 255. Warning is given. 
</p>
</li>
<li><p> &quot;always&quot; - Data is always rescaled. If <code>image</code> is a array of 
doubles in range [0, 1] than data is multiplied by 255; otherwise it is 
scaled to fit to [0:255] range. 
</p>
</li></ul>

</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_delay">delay</code></td>
<td>
<p>In case of 3D arrays the data will be stored as animated GIF, and
<code>delay</code> controls speed of the animation. It is number of hundredths 
(1/100) of a second of delay between frames. </p>
</td></tr>  
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_comment">comment</code></td>
<td>
<p>Comments in text format are allowed in GIF files. Few file 
viewers can access them.</p>
</td></tr>  
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_flip">flip</code></td>
<td>
<p>By default data is stored in the same orientation as data 
displayed by <code>print</code> function: row 1 is on top, image x-axis 
corresponds to columns and y-axis corresponds to rows. However function 
<code>image</code> adopted different standard: column 1 is on the bottom, 
image x-axis corresponds to rows and y-axis corresponds to columns. Set 
<code>flip</code> to <code>TRUE</code> to get the orientation used by <code>image</code>. </p>
</td></tr>  
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_transparent">transparent</code></td>
<td>
<p>Optional color number to be shown as transparent. Has to be an
integer in [0:255] range. NA's in the <code>image</code> will be set to transparent.</p>
</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_interlace">interlace</code></td>
<td>
<p>GIF files allow image rows to be <code>interlace</code>d, or 
reordered in such a way as to allow viewer to display image using 4 passes, 
making image sharper with each pass. Irrelevant feature on fast computers.</p>
</td></tr>
<tr><td><code id="read.gif+2B20+2B26amp+2B3B+2B20write.gif_+3A_verbose">verbose</code></td>
<td>
<p>Display details sections encountered while reading GIF file.</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>Palettes often contain continuous colors, such that swapping palettes or 
rescaling of the image date does not affect image apperance in a drastic way. 
However, when working with non-continuous color-maps one should always provide 
image in [0:255] integer range (and set <code>scale="never"</code>), in order to 
prevent scaling.
</p>
<p>If <code>NA</code> or other infinite numbers are found in the <code>image</code> by 
<code>write.gif</code>, they will be converted to numbers given by <code>transparent</code>.
If <code>transparent</code> color is not provided than it will be created, possibly 
after reshretching.
</p>
<p>There are some GIF files not fully supported by <code>read.gif</code> function:
</p>

<ul>
<li><p> &quot;Plain Text Extension&quot; is not supported, and will be ignored.
</p>
</li>
<li><p> Multi-frame files with unique settings for each frame have to be read 
frame by frame. Possible settings include: frames with different sizes, 
frames using local color maps and frames using individual transparency colors.
</p>
</li></ul>



<h3>Value</h3>

 
<p>Function <code>write.gif</code> does not return anything.
Function <code>read.gif</code> returns a list with following fields:
</p>
<table>
<tr><td><code>image</code></td>
<td>
<p>matrix or 3D array of integers in [0:255] range.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>color palette definitions with number of colors ranging from 1 
to 256. In case when <code>frame=0</code> only the first (usually global) 
color-map (palette) is returned.</p>
</td></tr>
<tr><td><code>comment</code></td>
<td>
<p>Comments imbedded in GIF File</p>
</td></tr>
<tr><td><code>transparent</code></td>
<td>
<p>color number corresponding to transparent color. If none 
was stated than NULL, otherwise an integer in [0:255] range. In order for 
<code>graphics:image</code> to display transparent colors correctly one
should use <code>y$col[y$transparent+1] = NA</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a>. 
Encoding Algorithm adapted from code by Christoph Hohmann, which was adapted 
from code by Michael Mayer. Parts of decoding algorithm adapted from code by 
David Koblas.
</p>


<h3>References</h3>

  
<p>Ziv, J., Lempel, A. (1977) <em>An Universal Algorithm for Sequential Data 
Compression</em>, IEEE Transactions on Information Theory, May 1977. 
</p>


<h3>See Also</h3>

<p>Displaying of images can be done through functions: 
<code>graphics:image</code> (part of R),
<code>fields::image.plot</code> and <code>fields::add.image</code> or 
<code>spatstat:plot.im</code>, and possibly many other functions.
</p>
<p>Displayed image can be saved in GIF, JPEG or PNG format using several 
different functions, like <code>R2HTML:HTMLplot</code>.
</p>
<p>Functions for directly reading and writing image files: 
</p>

<ul>
<li> <p><code><a href="pixmap.html#topic+read.pnm">read.pnm</a></code> and <code>pixmap::write.pnm</code> can 
process PBM, PGM and PPM images (file types supported by ImageMagic software)
</p>
</li>
<li> <p><code>read.ENVI</code> and <code>write.ENVI</code> from this package
can process files in ENVI format. ENVI files can store 2D images and 3D data 
(multi-frame images), and are supported by most GIS (Geographic Information 
System) software including free &quot;freelook&quot;.
</p>
</li></ul>

<p>There are many functions for creating and managing color palettes:
</p>

<ul>
<li> <p><code>fields::tim.colors</code> contains a palette similar to Matlab's 
jet palette (see examples for simpler implementation) 
</p>
</li>
<li> <p><code>gplots::rich.colors</code> contains two palettes of continuous colors. 
</p>
</li>
<li><p> Functions <code>RColorBrewer::brewer.pal</code> and 
<code>epitools::colorbrewer.palette</code> contain tools for generating palettes.
</p>
</li>
<li> <p><code>grDevices::rgb</code> and <code>grDevices::hsv</code> 
create palette from RGB or HSV 3-vectors. 
</p>
</li>
<li> <p><code>grDevices::col2rgb</code> translates 
palette colors to RGB 3-vectors. 
</p>
</li></ul>
 


<h3>Examples</h3>

<pre><code class='language-R'># visual comparison between image and plot
write.gif( volcano, "volcano.gif", col=terrain.colors, flip=TRUE, 
           scale="always", comment="Maunga Whau Volcano")
y = read.gif("volcano.gif", verbose=TRUE, flip=TRUE)
image(y$image, col=y$col, main=y$comment, asp=1)
# browseURL("file://volcano.gif")  # inspect GIF file on your hard disk

# test reading &amp; writing
col = heat.colors(256) # choose colormap
trn = 222              # set transparent color
com = "Hello World"    # imbed comment in the file
write.gif( volcano, "volcano.gif", col=col, transparent=trn, comment=com)
y = read.gif("volcano.gif")
# This tested col==y$col, but colours may or may not have an alpha channel
# and for col this changed in R 4.0
stopifnot(volcano==y$image, trn==y$transparent, com==y$comment)
# browseURL("file://volcano.gif") # inspect GIF file on your hard disk

# create simple animated GIF (using image function in a loop is very rough,
# but only way I know of displaying 'animation" in R)
x &lt;- y &lt;- seq(-4*pi, 4*pi, len=200)
r &lt;- sqrt(outer(x^2, y^2, "+"))
image = array(0, c(200, 200, 10))
for(i in 1:10) image[,,i] = cos(r-(2*pi*i/10))/(r^.25)
write.gif(image, "wave.gif", col="rainbow")
y = read.gif("wave.gif")
for(i in 1:10) image(y$image[,,i], col=y$col, breaks=(0:256)-0.5, asp=1)
# browseURL("file://wave.gif") # inspect GIF file on your hard disk

# Another neat animation of Mandelbrot Set
jet.colors = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F",
             "yellow", "#FF7F00", "red", "#7F0000")) # define "jet" palette
m = 400
C = complex( real=rep(seq(-1.8,0.6, length.out=m), each=m ), 
             imag=rep(seq(-1.2,1.2, length.out=m),      m ) )
C = matrix(C,m,m)
Z = 0
X = array(0, c(m,m,20))
for (k in 1:20) {
  Z = Z^2+C
  X[,,k] = exp(-abs(Z))
}
image(X[,,k], col=jet.colors(256))
write.gif(X, "Mandelbrot.gif", col=jet.colors, delay=100)
# browseURL("file://Mandelbrot.gif") # inspect GIF file on your hard disk
file.remove("wave.gif", "volcano.gif", "Mandelbrot.gif")

# Display interesting images from the web
## Not run: 
url = "http://www.ngdc.noaa.gov/seg/cdroms/ged_iib/datasets/b12/gifs/eccnv.gif"
y = read.gif(url, verbose=TRUE, flip=TRUE)
image(y$image, col=y$col, breaks=(0:length(y$col))-0.5, asp=1,
           main="January Potential Evapotranspiration mm/mo")
url = "http://www.ngdc.noaa.gov/seg/cdroms/ged_iib/datasets/b01/gifs/fvvcode.gif"
y = read.gif(url, flip=TRUE)
y$col[y$transparent+1] = NA # mark transparent color in R way
image(y$image, col=y$col[1:87], breaks=(0:87)-0.5, asp=1,
           main="Vegetation Types")
url = "http://talc.geo.umn.edu/people/grads/hasba002/erosion_vids/run2/r2_dems_5fps(8color).gif"
y = read.gif(url, verbose=TRUE, flip=TRUE)
for(i in 2:dim(y$image)[3]) 
  image(y$image[,,i], col=y$col, breaks=(0:length(y$col))-0.5,
            asp=1, main="Erosion in Drainage Basins")

## End(Not run)
</code></pre>

<hr>
<h2 id='runmad'>Median Absolute Deviation of Moving Windows</h2><span id='topic+runmad'></span>

<h3>Description</h3>

<p> Moving (aka running, rolling) Window MAD (Median Absolute 
Deviation) calculated over a vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>   runmad(x, k, center = runmed(x,k), constant = 1.4826,
         endrule=c("mad", "NA", "trim", "keep", "constant", "func"),
         align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runmad_+3A_x">x</code></td>
<td>
<p>numeric vector of length n or matrix with n rows. If <code>x</code> is a 
matrix than each column will be processed separately.</p>
</td></tr>
<tr><td><code id="runmad_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between one and n. In case
of even k's one will have to provide different <code>center</code> function, since
<code><a href="stats.html#topic+runmed">runmed</a></code> does not take even k's.</p>
</td></tr>
<tr><td><code id="runmad_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning 
and the end, of the data, should be treated. Only first and last <code>k2</code> 
values at both ends are affected, where <code>k2</code> is the half-bandwidth 
<code>k2 = k %/% 2</code>.
</p>

<ul>
<li> <p><code>"mad"</code> - applies the mad function to
smaller and smaller sections of the array. Equivalent to: 
<code>for(i in 1:k2) out[i]=mad(x[1:(i+k2)])</code>. 
</p>
</li>
<li> <p><code>"trim"</code> - trim the ends; output array length is equal to 
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics 
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code> and other 
related functions.
</p>
</li>
<li> <p><code>"keep"</code> - fill the ends with numbers from <code>x</code> vector 
<code>(out[1:k2] = x[1:k2])</code>. This option makes more sense in case of 
smoothing functions, kept here for consistency.
</p>
</li>
<li> <p><code>"constant"</code> - fill the ends with first and last calculated 
value in output array <code>(out[1:k2] = out[k2+1])</code>
</p>
</li>
<li> <p><code>"NA"</code> - fill the ends with NA's <code>(out[1:k2] = NA)</code>
</p>
</li>
<li> <p><code>"func"</code> - same as <code>"mad"</code> option except that implemented
in R for testing purposes. Avoid since it can be very slow for large windows.
</p>
</li></ul>

<p>Similar to <code>endrule</code> in <code><a href="stats.html#topic+runmed">runmed</a></code> function which has the 
following options: &ldquo;<code>c("median", "keep", "constant")</code>&rdquo; .
</p>
</td></tr>
<tr><td><code id="runmad_+3A_center">center</code></td>
<td>
<p>moving window center. Defaults 
to running median (<code><a href="stats.html#topic+runmed">runmed</a></code> function). Similar to <code>center</code>  
in <code><a href="stats.html#topic+mad">mad</a></code> function. For best acuracy at the edges use 
<code><a href="#topic+runquantile">runquantile</a>(x,k,0.5,type=2)</code>, which is slower than default
<code><a href="stats.html#topic+runmed">runmed</a>(x,k,endrule="med")</code>. If <code>x</code> is a 2D array (and 
<code>endrule="mad"</code>) or if <code>endrule="func"</code> than array edges are 
filled by repeated calls to 
&ldquo;<code><a href="stats.html#topic+mad">mad</a>(x, center=<a href="stats.html#topic+median">median</a>(x), na.rm=TRUE)</code>&rdquo; function. 
Runmad's <code>center</code> parameter will be ignored for the beggining and the 
end of output <code>y</code>.  Please use  
<code>center=<a href="#topic+runquantile">runquantile</a>(x,k,0.5,type=2)</code> for those cases.  
</p>
</td></tr>
<tr><td><code id="runmad_+3A_constant">constant</code></td>
<td>
<p>scale factor such that for Gaussian 
distribution X, <code><a href="stats.html#topic+mad">mad</a></code>(X) is the same as <code><a href="stats.html#topic+sd">sd</a></code>(X). 
Same as <code>constant</code> in <code><a href="stats.html#topic+mad">mad</a></code> function.</p>
</td></tr>
<tr><td><code id="runmad_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default), 
left-aligned or right-aligned.  If <code>endrule</code>=&quot;mad&quot; then setting
<code>align</code> to &quot;left&quot; or &quot;right&quot; will fall back on slower implementation 
equivalent to <code>endrule</code>=&quot;func&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the end values, the result of y = runmad(x, k) is the same as 
&ldquo;<code>for(j=(1+k2):(n-k2)) y[j]=mad(x[(j-k2):(j+k2)], na.rm = TRUE)</code>&rdquo;. 
It can handle non-finite numbers like NaN's and Inf's 
(like &ldquo;<code><a href="stats.html#topic+mad">mad</a>(x, na.rm = TRUE)</code>&rdquo;).
</p>
<p>The main incentive to write this set of functions was relative slowness of 
majority of moving window functions available in R and its packages.  With the 
exception of <code><a href="stats.html#topic+runmed">runmed</a></code>, a running window median function, all 
functions listed in &quot;see also&quot; section are slower than very inefficient 
&ldquo;<code><a href="base.html#topic+apply">apply</a>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code>&rdquo; approach. 
</p>
<p>Functions <code>runquantile</code> and <code>runmad</code> are using insertion sort to 
sort the moving window, but gain speed by remembering results of the previous 
sort. Since each time the window is moved, only one point changes, all but one 
points in the window are already sorted. Insertion sort can fix that in O(k) 
time.
</p>


<h3>Value</h3>

<p>Returns a numeric vector or matrix of the same size as <code>x</code>. Only in case of 
<code>endrule="trim"</code> the output vectors will be shorter and output matrices 
will have fewer rows. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>

<p>About insertion sort used in <code>runmad</code> function see: 
R. Sedgewick (1988): <em>Algorithms</em>. Addison-Wesley (page 99)
</p>


<h3>See Also</h3>

<p>Links related to:
</p>
       
<ul>
<li> <p><code>runmad</code> - <code><a href="stats.html#topic+mad">mad</a></code>
</p>
</li>
<li><p> Other moving window functions  from this package: <code><a href="#topic+runmin">runmin</a></code>, 
<code><a href="#topic+runmax">runmax</a></code>, <code><a href="#topic+runquantile">runquantile</a></code>, <code><a href="#topic+runmean">runmean</a></code> and
<code><a href="#topic+runsd">runsd</a></code>
</p>
</li>
<li><p> generic running window functions: <code><a href="base.html#topic+apply">apply</a></code><code>
     (<a href="stats.html#topic+embed">embed</a>(x,k), 1, FUN)</code> (fastest), <code><a href="gtools.html#topic+running">running</a></code> from <span class="pkg">gtools</span> 
package (extremely slow for this purpose), <code><a href="magic.html#topic+subsums">subsums</a></code> from 
<span class="pkg">magic</span> library can perform running window operations on data with any 
dimensions. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # show runmed function
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  col = c("black", "red", "green")
  m=runmed(x, k)
  y=runmad(x, k, center=m)
  plot(x, col=col[1], main = "Moving Window Analysis Functions")
  lines(m    , col=col[2])
  lines(m-y/2, col=col[3])
  lines(m+y/2, col=col[3])
  lab = c("data", "runmed", "runmed-runmad/2", "runmed+runmad/2")
  legend(0,0.9*n, lab, col=col, lty=1 )

  # basic tests against apply/embed
  eps = .Machine$double.eps ^ 0.5
  k=25 # odd size window
  a = runmad(x,k, center=runmed(x,k), endrule="trim")
  b = apply(embed(x,k), 1, mad)
  stopifnot(all(abs(a-b)&lt;eps));
  k=24 # even size window
  a = runmad(x,k, center=runquantile(x,k,0.5,type=2), endrule="trim")
  b = apply(embed(x,k), 1, mad)
  stopifnot(all(abs(a-b)&lt;eps));
  
  # test against loop approach
  # this test works fine at the R prompt but fails during package check - need to investigate
  k=24; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # create random data
  x = rep(1:5,40)
  #x[seq(1,n,11)] = NaN;               # commented out for time beeing - on to do list
  #x[5] = NaN;                         # commented out for time beeing - on to do list
  k2 = k
  k1 = k-k2-1
  ac = array(runquantile(x,k,0.5))
  a  = runmad(x, k, center=ac)
  bc = array(0,n)
  b  = array(0,n)
  for(j in 1:n) {
    lo = max(1, j-k1)
    hi = min(n, j+k2)
    bc[j] = median(x[lo:hi], na.rm = TRUE)
    b [j] = mad   (x[lo:hi], na.rm = TRUE, center=bc[j])
  }
  eps = .Machine$double.eps ^ 0.5
  #stopifnot(all(abs(ac-bc)&lt;eps)); # commented out for time beeing - on to do list
  #stopifnot(all(abs(a-b)&lt;eps));   # commented out for time beeing - on to do list
  
  # compare calculation at array ends
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  c = runquantile(x,k,0.5,type=2)             # find the center
  a = runmad(x, k, center=c, endrule="mad" )  # fast C code
  b = runmad(x, k, center=c, endrule="func")  # slow R code
  stopifnot(all(abs(a-b)&lt;eps));
  
  # test if moving windows forward and backward gives the same results
  k=51;
  a = runmad(x     , k)
  b = runmad(x[n:1], k)
  stopifnot(all(a[n:1]==b, na.rm=TRUE));

  # test vector vs. matrix inputs, especially for the edge handling
  nRow=200; k=25; nCol=10
  x = rnorm(nRow,sd=30) + abs(seq(nRow)-n/4)
  X = matrix(rep(x, nCol ), nRow, nCol) # replicate x in columns of X
  a = runmad(x, k, center = runquantile(x,k,0.5,type=2))
  b = runmad(X, k, center = runquantile(X,k,0.5,type=2))
  stopifnot(all(abs(a-b[,1])&lt;eps));        # vector vs. 2D array
  stopifnot(all(abs(b[,1]-b[,nCol])&lt;eps)); # compare rows within 2D array
  
  # speed comparison
  ## Not run: 
  x=runif(1e5); k=51;                       # reduce vector and window sizes
  system.time(runmad( x,k,endrule="trim"))
  system.time(apply(embed(x,k), 1, mad))  
  
## End(Not run)
</code></pre>

<hr>
<h2 id='runmean'>Mean of a Moving Window</h2><span id='topic+runmean'></span>

<h3>Description</h3>

<p>Moving (aka running, rolling) Window Mean calculated over a vector  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  runmean(x, k, alg=c("C", "R", "fast", "exact"),
         endrule=c("mean", "NA", "trim", "keep", "constant", "func"),
         align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runmean_+3A_x">x</code></td>
<td>
<p>numeric vector of length n or matrix with n rows. If <code>x</code> is a 
matrix than each column will be processed separately.</p>
</td></tr>
<tr><td><code id="runmean_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between 1 and n </p>
</td></tr>
<tr><td><code id="runmean_+3A_alg">alg</code></td>
<td>
<p>an option to choose different algorithms
</p>

<ul>
<li> <p><code>"C"</code> - a version is written in C. It can handle non-finite 
numbers like NaN's and Inf's (like <code><a href="base.html#topic+mean">mean</a>(x, na.rm = TRUE)</code>). 
It works the fastest for <code>endrule="mean"</code>.
</p>
</li>
<li> <p><code>"fast"</code> - second, even faster, C version. This algorithm
does not work with non-finite numbers. It also works the fastest for
<code>endrule</code> other than  <code>"mean"</code>.
</p>
</li>
<li> <p><code>"R"</code> - much slower code written in R. Useful for 
debugging and as documentation.
</p>
</li>
<li> <p><code>"exact"</code> - same as <code>"C"</code>, except that all additions 
are performed using algorithm which tracks and corrects addition 
round-off errors
</p>
</li></ul>

</td></tr>
<tr><td><code id="runmean_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning 
and the end, of the data, should be treated. Only first and last <code>k2</code> 
values at both ends are affected, where <code>k2</code> is the half-bandwidth 
<code>k2 = k %/% 2</code>.
</p>

<ul>
<li> <p><code>"mean"</code> - applies the underlying function to smaller and 
smaller sections of the array. Equivalent to: 
<code>for(i in 1:k2) out[i] = mean(x[1:(i+k2)])</code>. This option is implemented in 
C if <code>alg="C"</code>, otherwise is done in R.
</p>
</li>
<li> <p><code>"trim"</code> - trim the ends; output array length is equal to 
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics 
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,mean)</code> and other 
related functions.
</p>
</li>
<li> <p><code>"keep"</code> - fill the ends with numbers from <code>x</code> vector 
<code>(out[1:k2] = x[1:k2])</code>
</p>
</li>
<li> <p><code>"constant"</code> - fill the ends with first and last calculated 
value in output array <code>(out[1:k2] = out[k2+1])</code>
</p>
</li>
<li> <p><code>"NA"</code> - fill the ends with NA's <code>(out[1:k2] = NA)</code>
</p>
</li>
<li> <p><code>"func"</code> - same as <code>"mean"</code> but implimented
in R. This option could be very slow, and is included mostly for testing
</p>
</li></ul>

<p>Similar to <code>endrule</code> in <code><a href="stats.html#topic+runmed">runmed</a></code> function which has the 
following options: &ldquo;<code>c("median", "keep", "constant")</code>&rdquo; .
</p>
</td></tr>
<tr><td><code id="runmean_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default), 
left-aligned or right-aligned.  If <code>endrule</code>=&quot;mean&quot; then setting
<code>align</code> to &quot;left&quot; or &quot;right&quot; will fall back on slower implementation 
equivalent to <code>endrule</code>=&quot;func&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the end values, the result of y = runmean(x, k) is the same as 
&ldquo;<code>for(j=(1+k2):(n-k2)) y[j]=mean(x[(j-k2):(j+k2)])</code>&rdquo;.
</p>
<p>The main incentive to write this set of functions was relative slowness of 
majority of moving window functions available in R and its packages.  With the 
exception of <code><a href="stats.html#topic+runmed">runmed</a></code>, a running window median function, all 
functions listed in &quot;see also&quot; section are slower than very inefficient 
&ldquo;<code><a href="base.html#topic+apply">apply</a>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code>&rdquo; approach. Relative 
speed of <code>runmean</code> function is O(n).
</p>
<p>Function <code>EndRule</code> applies one of the five methods (see <code>endrule</code> 
argument) to process end-points of the input array <code>x</code>. In current 
version of the code the default <code>endrule="mean"</code> option is calculated 
within C code. That is done to improve speed in case of large moving windows.
</p>
<p>In case of <code>runmean(..., alg="exact")</code> function a special algorithm is 
used (see references section) to ensure that round-off errors do not 
accumulate. As a result <code>runmean</code> is more accurate than 
<code><a href="stats.html#topic+filter">filter</a></code>(x, rep(1/k,k)) and <code>runmean(..., alg="C")</code> 
functions.
</p>


<h3>Value</h3>

<p>Returns a numeric vector or matrix of the same size as <code>x</code>. Only in case of 
<code>endrule="trim"</code> the output vectors will be shorter and output matrices 
will have fewer rows. 
</p>


<h3>Note</h3>

  
<p>Function <code>runmean(..., alg="exact")</code> is based by code by Vadim Ogranovich,
which is based on Python code (see last reference), pointed out by Gabor 
Grothendieck. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>

       
<ul>
<li><p> About round-off error correction used in <code>runmean</code>:
Shewchuk, Jonathan <em>Adaptive Precision Floating-Point Arithmetic and Fast 
Robust Geometric Predicates</em>,  
<a href="http://www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps">http://www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Links related to:
</p>
       
<ul>
<li><p> moving mean - <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+kernapply">kernapply</a></code>, 
<code><a href="stats.html#topic+filter">filter</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code><a href="stats.html#topic+stl">stl</a></code>,
<code><a href="zoo.html#topic+rollmean">rollmean</a></code> from <span class="pkg">zoo</span> library,
<code><a href="magic.html#topic+subsums">subsums</a></code> from <span class="pkg">magic</span> library,
</p>
</li>
<li><p> Other moving window functions  from this package: <code><a href="#topic+runmin">runmin</a></code>, 
<code><a href="#topic+runmax">runmax</a></code>, <code><a href="#topic+runquantile">runquantile</a></code>, <code><a href="#topic+runmad">runmad</a></code> and
<code><a href="#topic+runsd">runsd</a></code> 
</p>
</li>
<li> <p><code><a href="stats.html#topic+runmed">runmed</a></code>
</p>
</li>
<li><p> generic running window functions: <code><a href="base.html#topic+apply">apply</a></code><code>
     (<a href="stats.html#topic+embed">embed</a>(x,k), 1, FUN)</code> (fastest), <code><a href="gtools.html#topic+running">running</a></code> from <span class="pkg">gtools</span> 
package (extremely slow for this purpose), <code><a href="magic.html#topic+subsums">subsums</a></code> from 
<span class="pkg">magic</span> library can perform running window operations on data with any 
dimensions. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # show runmean for different window sizes
  n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  x[seq(1,n,10)] = NaN;              # add NANs
  col = c("black", "red", "green", "blue", "magenta", "cyan")
  plot(x, col=col[1], main = "Moving Window Means")
  lines(runmean(x, 3), col=col[2])
  lines(runmean(x, 8), col=col[3])
  lines(runmean(x,15), col=col[4])
  lines(runmean(x,24), col=col[5])
  lines(runmean(x,50), col=col[6])
  lab = c("data", "k=3", "k=8", "k=15", "k=24", "k=50")
  legend(0,0.9*n, lab, col=col, lty=1 )
  
  # basic tests against 2 standard R approaches
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)      # create random data
  a = runmean(x,k, endrule="trim")          # tested function
  b = apply(embed(x,k), 1, mean)            # approach #1
  c = cumsum(c( sum(x[1:k]), diff(x,k) ))/k # approach #2
  eps = .Machine$double.eps ^ 0.5
  stopifnot(all(abs(a-b)&lt;eps));
  stopifnot(all(abs(a-c)&lt;eps));
  
  # test against loop approach
  # this test works fine at the R prompt but fails during package check - need to investigate
  k=25; 
  data(iris)
  x = iris[,1]
  n = length(x)
  x[seq(1,n,11)] = NaN;                # add NANs
  k2 = k
  k1 = k-k2-1
  a = runmean(x, k)
  b = array(0,n)
  for(j in 1:n) {
    lo = max(1, j-k1)
    hi = min(n, j+k2)
    b[j] = mean(x[lo:hi], na.rm = TRUE)
  }
  #stopifnot(all(abs(a-b)&lt;eps)); # commented out for time beeing - on to do list
  
  # compare calculation at array ends
  a = runmean(x, k, endrule="mean")  # fast C code
  b = runmean(x, k, endrule="func")  # slow R code
  stopifnot(all(abs(a-b)&lt;eps));
  
  # Testing of different methods to each other for non-finite data
  # Only alg "C" and "exact" can handle not finite numbers 
  eps = .Machine$double.eps ^ 0.5
  n=200;  k=51;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # nice behaving data
  x[seq(1,n,10)] = NaN;                # add NANs
  x[seq(1,n, 9)] = Inf;                # add infinities
  b = runmean( x, k, alg="C")
  c = runmean( x, k, alg="exact")
  stopifnot(all(abs(b-c)&lt;eps));

  # Test if moving windows forward and backward gives the same results
  # Test also performed on data with non-finite numbers
  a = runmean(x     , alg="C", k)
  b = runmean(x[n:1], alg="C", k)
  stopifnot(all(abs(a[n:1]-b)&lt;eps));
  a = runmean(x     , alg="exact", k)
  b = runmean(x[n:1], alg="exact", k)
  stopifnot(all(abs(a[n:1]-b)&lt;eps));
  
  # test vector vs. matrix inputs, especially for the edge handling
  nRow=200; k=25; nCol=10
  x = rnorm(nRow,sd=30) + abs(seq(nRow)-n/4)
  x[seq(1,nRow,10)] = NaN;              # add NANs
  X = matrix(rep(x, nCol ), nRow, nCol) # replicate x in columns of X
  a = runmean(x, k)
  b = runmean(X, k)
  stopifnot(all(abs(a-b[,1])&lt;eps));        # vector vs. 2D array
  stopifnot(all(abs(b[,1]-b[,nCol])&lt;eps)); # compare rows within 2D array

  # Exhaustive testing of different methods to each other for different windows
  numeric.test = function (x, k) {
    a = runmean( x, k, alg="fast")
    b = runmean( x, k, alg="C")
    c = runmean( x, k, alg="exact")
    d = runmean( x, k, alg="R", endrule="func")
    eps = .Machine$double.eps ^ 0.5
    stopifnot(all(abs(a-b)&lt;eps));
    stopifnot(all(abs(b-c)&lt;eps));
    stopifnot(all(abs(c-d)&lt;eps));
  }
  n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # nice behaving data
  for(i in 1:5) numeric.test(x, i)     # test small window sizes
  for(i in 1:5) numeric.test(x, n-i+1) # test large window size

  # speed comparison
  ## Not run: 
  x=runif(1e7); k=1e4;
  system.time(runmean(x,k,alg="fast"))
  system.time(runmean(x,k,alg="C"))
  system.time(runmean(x,k,alg="exact"))
  system.time(runmean(x,k,alg="R"))           # R version of the function
  x=runif(1e5); k=1e2;                        # reduce vector and window sizes
  system.time(runmean(x,k,alg="R"))           # R version of the function
  system.time(apply(embed(x,k), 1, mean))     # standard R approach
  system.time(filter(x, rep(1/k,k), sides=2)) # the fastest alternative I know 
  
## End(Not run)
   
  # show different runmean algorithms with data spanning many orders of magnitude
  n=30; k=5;
  x = rep(100/3,n)
  d=1e10
  x[5] = d;     
  x[13] = d; 
  x[14] = d*d; 
  x[15] = d*d*d; 
  x[16] = d*d*d*d; 
  x[17] = d*d*d*d*d; 
  a = runmean(x, k, alg="fast" )
  b = runmean(x, k, alg="C"    )
  c = runmean(x, k, alg="exact")
  y = t(rbind(x,a,b,c))
  y
</code></pre>

<hr>
<h2 id='runmin+20+26amp+3B+20runmax'>Minimum and Maximum of Moving Windows</h2><span id='topic+runmin'></span><span id='topic+runmax'></span>

<h3>Description</h3>

<p>Moving (aka running, rolling) Window Minimum and Maximum 
calculated over a vector  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  runmin(x, k, alg=c("C", "R"),
         endrule=c("min", "NA", "trim", "keep", "constant", "func"),
         align = c("center", "left", "right"))
  runmax(x, k, alg=c("C", "R"),
         endrule=c("max", "NA", "trim", "keep", "constant", "func"),
         align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runmin+2B20+2B26amp+2B3B+2B20runmax_+3A_x">x</code></td>
<td>
<p>numeric vector of length n or matrix with n rows. If <code>x</code> is a 
matrix than each column will be processed separately.</p>
</td></tr>
<tr><td><code id="runmin+2B20+2B26amp+2B3B+2B20runmax_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between one and n </p>
</td></tr>
<tr><td><code id="runmin+2B20+2B26amp+2B3B+2B20runmax_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning 
and the end, of the array, should be treated. Only first and last <code>k2</code> 
values at both ends are affected, where <code>k2</code> is the half-bandwidth 
<code>k2 = k %/% 2</code>.
</p>

<ul>
<li> <p><code>"min"</code> &amp; <code>"max"</code> - applies the underlying function to 
smaller and smaller sections of the array. In case of min equivalent to: 
<code>for(i in 1:k2) out[i]=min(x[1:(i+k2)])</code>. Default.
</p>
</li>
<li> <p><code>"trim"</code> - trim the ends; output array length is equal to 
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics 
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code> and other 
related functions.
</p>
</li>
<li> <p><code>"keep"</code> - fill the ends with numbers from <code>x</code> vector 
<code>(out[1:k2] = x[1:k2])</code>
</p>
</li>
<li> <p><code>"constant"</code> - fill the ends with first and last calculated 
value in output array <code>(out[1:k2] = out[k2+1])</code>
</p>
</li>
<li> <p><code>"NA"</code> - fill the ends with NA's <code>(out[1:k2] = NA)</code>
</p>
</li>
<li> <p><code>"func"</code> - same as <code>"min"</code> &amp; <code>"max"</code> but implimented
in R. This option could be very slow, and is included mostly for testing
</p>
</li></ul>

<p>Similar to <code>endrule</code> in <code><a href="stats.html#topic+runmed">runmed</a></code> function which has the 
following options: &ldquo;<code>c("median", "keep", "constant")</code>&rdquo; .
</p>
</td></tr>
<tr><td><code id="runmin+2B20+2B26amp+2B3B+2B20runmax_+3A_alg">alg</code></td>
<td>
<p>an option allowing to choose different algorithms or 
implementations. Default is to use of code written in C (option <code>alg="C"</code>).
Option <code>alg="R"</code> will use slower code written in R. Useful for 
debugging and studying the algorithm.</p>
</td></tr>
<tr><td><code id="runmin+2B20+2B26amp+2B3B+2B20runmax_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default), 
left-aligned or right-aligned.  If <code>endrule</code>=&quot;min&quot; or &quot;max&quot; then setting
<code>align</code> to &quot;left&quot; or &quot;right&quot; will fall back on slower implementation 
equivalent to <code>endrule</code>=&quot;func&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the end values, the result of y = runFUN(x, k) is the same as 
&ldquo;<code>for(j=(1+k2):(n-k2)) y[j]=FUN(x[(j-k2):(j+k2)], na.rm = TRUE)</code>&rdquo;, where FUN 
stands for min or max functions.  Both functions can handle non-finite 
numbers like NaN's and Inf's the same way as <code><a href="base.html#topic+min">min</a>(x, na.rm = TRUE)</code>).
</p>
<p>The main incentive to write this set of functions was relative slowness of 
majority of moving window functions available in R and its packages.  With the 
exception of <code><a href="stats.html#topic+runmed">runmed</a></code>, a running window median function, all 
functions listed in &quot;see also&quot; section are slower than very inefficient 
&ldquo;<code><a href="base.html#topic+apply">apply</a>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code>&rdquo; approach. Relative 
speeds <code>runmin</code> and <code>runmax</code> functions is O(n) in best and average 
case and O(n*k) in worst case.
</p>
<p>Both functions work with infinite numbers (<code>NA</code>,<code>NaN</code>,<code>Inf</code>,
<code>-Inf</code>). Also default <code>endrule</code> is hardwired in C for speed.
</p>


<h3>Value</h3>

<p>Returns a numeric vector or matrix of the same size as <code>x</code>. Only in case of 
<code>endrule="trim"</code> the output vectors will be shorter and output matrices 
will have fewer rows. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>See Also</h3>

<p>Links related to:
</p>
       
<ul>
<li><p> Other moving window functions  from this package: <code><a href="#topic+runmean">runmean</a></code>, 
<code><a href="#topic+runquantile">runquantile</a></code>, <code><a href="#topic+runmad">runmad</a></code> and <code><a href="#topic+runsd">runsd</a></code>  
</p>
</li>
<li><p> R functions: <code><a href="stats.html#topic+runmed">runmed</a></code>, <code><a href="base.html#topic+min">min</a></code>, <code><a href="base.html#topic+max">max</a></code>
</p>
</li>
<li><p> Similar functions in other packages: <code><a href="zoo.html#topic+rollmax">rollmax</a></code> from <span class="pkg">zoo</span> library
</p>
</li>
<li><p> generic running window functions: <code><a href="base.html#topic+apply">apply</a></code><code>
     (<a href="stats.html#topic+embed">embed</a>(x,k), 1, FUN)</code> (fastest), <code><a href="gtools.html#topic+running">running</a></code> from <span class="pkg">gtools</span> 
package (extremely slow for this purpose), <code><a href="magic.html#topic+subsums">subsums</a></code> from 
<span class="pkg">magic</span> library can perform running window operations on data with any 
dimensions. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # show plot using runmin, runmax and runmed
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  col = c("black", "red", "green", "blue", "magenta", "cyan")
  plot(x, col=col[1], main = "Moving Window Analysis Functions")
  lines(runmin(x,k), col=col[2])
  lines(runmean(x,k), col=col[3])
  lines(runmax(x,k), col=col[4])
  legend(0,.9*n, c("data", "runmin", "runmean", "runmax"), col=col, lty=1 )

  # basic tests against standard R approach
  a = runmin(x,k, endrule="trim") # test only the inner part 
  b = apply(embed(x,k), 1, min)   # Standard R running min
  stopifnot(all(a==b));
  a = runmax(x,k, endrule="trim") # test only the inner part
  b = apply(embed(x,k), 1, max)   # Standard R running min
  stopifnot(all(a==b));
  
  # test against loop approach
  k=25; 
  data(iris)
  x = iris[,1]
  n = length(x)
  x[seq(1,n,11)] = NaN;                # add NANs
  k2 = k
  k1 = k-k2-1
  a1 = runmin(x, k)
  a2 = runmax(x, k)
  b1 = array(0,n)
  b2 = array(0,n)
  for(j in 1:n) {
    lo = max(1, j-k1)
    hi = min(n, j+k2)
    b1[j] = min(x[lo:hi], na.rm = TRUE)
    b2[j] = max(x[lo:hi], na.rm = TRUE)
  }
  # this test works fine at the R prompt but fails during package check - need to investigate
  ## Not run:  
  stopifnot(all(a1==b1, na.rm=TRUE));
  stopifnot(all(a2==b2, na.rm=TRUE));
  
## End(Not run)
  
  # Test if moving windows forward and backward gives the same results
  # Two data sets also corespond to best and worst-case scenatio data-sets
  k=51; n=200;
  a = runmin(n:1, k) 
  b = runmin(1:n, k)
  stopifnot(all(a[n:1]==b, na.rm=TRUE));
  a = runmax(n:1, k)
  b = runmax(1:n, k)
  stopifnot(all(a[n:1]==b, na.rm=TRUE));

  # test vector vs. matrix inputs, especially for the edge handling
  nRow=200; k=25; nCol=10
  x = rnorm(nRow,sd=30) + abs(seq(nRow)-n/4)
  x[seq(1,nRow,10)] = NaN;              # add NANs
  X = matrix(rep(x, nCol ), nRow, nCol) # replicate x in columns of X
  a = runmax(x, k)
  b = runmax(X, k)
  stopifnot(all(a==b[,1], na.rm=TRUE));        # vector vs. 2D array
  stopifnot(all(b[,1]==b[,nCol], na.rm=TRUE)); # compare rows within 2D array
  a = runmin(x, k)
  b = runmin(X, k)
  stopifnot(all(a==b[,1], na.rm=TRUE));        # vector vs. 2D array
  stopifnot(all(b[,1]==b[,nCol], na.rm=TRUE)); # compare rows within 2D array

  # Compare C and R algorithms to each other for extreme window sizes
  numeric.test = function (x, k) {
    a = runmin( x, k, alg="C")
    b = runmin( x, k, alg="R")
    c =-runmax(-x, k, alg="C")
    d =-runmax(-x, k, alg="R")
    stopifnot(all(a==b, na.rm=TRUE));
    #stopifnot(all(c==d, na.rm=TRUE)); 
    #stopifnot(all(a==c, na.rm=TRUE));
    stopifnot(all(b==d, na.rm=TRUE));
  }
  n=200;                               # n is an even number
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # random data
  for(i in 1:5) numeric.test(x, i)     # test for small window size
  for(i in 1:5) numeric.test(x, n-i+1) # test for large window size
  n=201;                               # n is an odd number
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # random data
  for(i in 1:5) numeric.test(x, i)     # test for small window size
  for(i in 1:5) numeric.test(x, n-i+1) # test for large window size
  n=200;                               # n is an even number
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # random data
  x[seq(1,200,10)] = NaN;              # with some NaNs
  for(i in 1:5) numeric.test(x, i)     # test for small window size
  for(i in 1:5) numeric.test(x, n-i+1) # test for large window size
  n=201;                               # n is an odd number
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # random data
  x[seq(1,200,2)] = NaN;               # with some NaNs
  for(i in 1:5) numeric.test(x, i)     # test for small window size
  for(i in 1:5) numeric.test(x, n-i+1) # test for large window size

  # speed comparison
  ## Not run: 
  n = 1e7;  k=991; 
  x1 = runif(n);                       # random data - average case scenario
  x2 = 1:n;                            #  best-case scenario data for runmax
  x3 = n:1;                            # worst-case scenario data for runmax
  system.time( runmax( x1,k,alg="C"))  # C alg on average data O(n)
  system.time( runmax( x2,k,alg="C"))  # C alg on  best-case data O(n)
  system.time( runmax( x3,k,alg="C"))  # C alg on worst-case data O(n*k)
  system.time(-runmin(-x1,k,alg="C"))  # use runmin to do runmax work
  system.time( runmax( x1,k,alg="R"))  # R version of the function
  x=runif(1e5); k=1e2;                 # reduce vector and window sizes
  system.time(runmax(x,k,alg="R"))     # R version of the function
  system.time(apply(embed(x,k), 1, max)) # standard R approach 
  
## End(Not run)
</code></pre>

<hr>
<h2 id='runquantile'>Quantile of Moving Window</h2><span id='topic+runquantile'></span>

<h3>Description</h3>

<p>Moving (aka running, rolling) Window Quantile calculated over a vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>  runquantile(x, k, probs, type=7, 
         endrule=c("quantile", "NA", "trim", "keep", "constant", "func"),
         align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runquantile_+3A_x">x</code></td>
<td>
<p>numeric vector of length n or matrix with n rows. If <code>x</code> is a 
matrix than each column will be processed separately.</p>
</td></tr>
<tr><td><code id="runquantile_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between one and n </p>
</td></tr>
<tr><td><code id="runquantile_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning 
and the end, of the array, should be treated. Only first and last <code>k2</code> 
values at both ends are affected, where <code>k2</code> is the half-bandwidth 
<code>k2 = k %/% 2</code>.
</p>

<ul>
<li> <p><code>"quantile"</code> - applies the <code><a href="stats.html#topic+quantile">quantile</a></code> 
function to smaller and smaller sections of the array. Equivalent to: 
<code>for(i in 1:k2) out[i]=quantile(x[1:(i+k2)])</code>. 
</p>
</li>
<li> <p><code>"trim"</code> - trim the ends; output array length is equal to 
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics 
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code> and other 
related functions.
</p>
</li>
<li> <p><code>"keep"</code> - fill the ends with numbers from <code>x</code> vector 
<code>(out[1:k2] = x[1:k2])</code>
</p>
</li>
<li> <p><code>"constant"</code> - fill the ends with first and last calculated 
value in output array <code>(out[1:k2] = out[k2+1])</code>
</p>
</li>
<li> <p><code>"NA"</code> - fill the ends with NA's <code>(out[1:k2] = NA)</code>
</p>
</li>
<li> <p><code>"func"</code> - same as <code>"quantile"</code> but implimented
in R. This option could be very slow, and is included mostly for testing
</p>
</li></ul>

<p>Similar to <code>endrule</code> in <code><a href="stats.html#topic+runmed">runmed</a></code> function which has the 
following options: &ldquo;<code>c("median", "keep", "constant")</code>&rdquo; .
</p>
</td></tr>
<tr><td><code id="runquantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1] range 
used by <code>runquantile</code>. For example <code>Probs=c(0,0.5,1)</code> would be 
equivalent to running <code>runmin</code>, <code><a href="stats.html#topic+runmed">runmed</a></code> and <code>runmax</code>.
Same as <code>probs</code> in <code><a href="stats.html#topic+quantile">quantile</a></code> function. </p>
</td></tr>
<tr><td><code id="runquantile_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the nine quantile 
algorithms, same as <code>type</code> in <code><a href="stats.html#topic+quantile">quantile</a></code> function. 
Another even more readable description of nine ways to calculate quantiles 
can be found at <a href="http://mathworld.wolfram.com/Quantile.html">http://mathworld.wolfram.com/Quantile.html</a>. </p>
</td></tr>
<tr><td><code id="runquantile_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default), 
left-aligned or right-aligned.  If <code>endrule</code>=&quot;quantile&quot; then setting
<code>align</code> to &quot;left&quot; or &quot;right&quot; will fall back on slower implementation 
equivalent to <code>endrule</code>=&quot;func&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the end values, the result of y = runquantile(x, k) is the same as 
&ldquo;<code>for(j=(1+k2):(n-k2)) y[j]=quintile(x[(j-k2):(j+k2)],na.rm = TRUE)</code>&rdquo;. It can handle 
non-finite numbers like NaN's and Inf's (like <code><a href="stats.html#topic+quantile">quantile</a>(x, na.rm = TRUE)</code>).
</p>
<p>The main incentive to write this set of functions was relative slowness of 
majority of moving window functions available in R and its packages.  With the 
exception of <code><a href="stats.html#topic+runmed">runmed</a></code>, a running window median function, all 
functions listed in &quot;see also&quot; section are slower than very inefficient 
&ldquo;<code><a href="base.html#topic+apply">apply</a>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code>&rdquo; approach. Relative 
speeds of <code>runquantile</code> is O(n*k)
</p>
<p>Functions <code>runquantile</code> and <code>runmad</code> are using insertion sort to 
sort the moving window, but gain speed by remembering results of the previous 
sort. Since each time the window is moved, only one point changes, all but one 
points in the window are already sorted. Insertion sort can fix that in O(k) 
time.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a matrix than function <code>runquantile</code> returns a matrix of 
size [n <code class="reqn">\times</code> <code><a href="base.html#topic+length">length</a></code>(probs)]. If <code>x</code> is vactor 
a than function <code>runquantile</code> returns a matrix of size 
[<code><a href="base.html#topic+dim">dim</a></code>(x) <code class="reqn">\times</code> <code><a href="base.html#topic+length">length</a></code>(probs)]. 
If <code>endrule="trim"</code> the output will have fewer rows. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>

       
<ul>
<li><p> About quantiles: Hyndman, R. J. and Fan, Y. (1996) <em>Sample 
quantiles in statistical packages, American Statistician</em>, 50, 361. 
</p>
</li>
<li><p> About quantiles: Eric W. Weisstein. <em>Quantile</em>. From MathWorld&ndash; 
A Wolfram Web Resource. <a href="http://mathworld.wolfram.com/Quantile.html">http://mathworld.wolfram.com/Quantile.html</a> 
</p>
</li>
<li><p> About insertion sort used in <code>runmad</code> and <code>runquantile</code>: 
R. Sedgewick (1988): <em>Algorithms</em>. Addison-Wesley (page 99)
</p>
</li></ul>



<h3>See Also</h3>

<p>Links related to:
</p>
       
<ul>
<li><p> Running Quantile - <code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+runmed">runmed</a></code>, 
<code><a href="stats.html#topic+smooth">smooth</a></code>, <code><a href="zoo.html#topic+rollmedian">rollmedian</a></code> from 
<span class="pkg">zoo</span> library
</p>
</li>
<li><p> Other moving window functions  from this package: <code><a href="#topic+runmin">runmin</a></code>, 
<code><a href="#topic+runmax">runmax</a></code>, <code><a href="#topic+runmean">runmean</a></code>, <code><a href="#topic+runmad">runmad</a></code> and
<code><a href="#topic+runsd">runsd</a></code>
</p>
</li>
<li><p> Running Minimum - <code><a href="base.html#topic+min">min</a></code>
</p>
</li>
<li><p> Running Maximum - <code><a href="base.html#topic+max">max</a></code>, <code><a href="zoo.html#topic+rollmax">rollmax</a></code> from <span class="pkg">zoo</span> library
</p>
</li>
<li><p> generic running window functions: <code><a href="base.html#topic+apply">apply</a></code><code>
     (<a href="stats.html#topic+embed">embed</a>(x,k), 1, FUN)</code> (fastest), <code><a href="gtools.html#topic+running">running</a></code> from <span class="pkg">gtools</span> 
package (extremely slow for this purpose), <code><a href="magic.html#topic+subsums">subsums</a></code> from 
<span class="pkg">magic</span> library can perform running window operations on data with any 
dimensions. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # show plot using runquantile
  k=31; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  y=runquantile(x, k, probs=c(0.05, 0.25, 0.5, 0.75, 0.95))
  col = c("black", "red", "green", "blue", "magenta", "cyan")
  plot(x, col=col[1], main = "Moving Window Quantiles")
  lines(y[,1], col=col[2])
  lines(y[,2], col=col[3])
  lines(y[,3], col=col[4])
  lines(y[,4], col=col[5])
  lines(y[,5], col=col[6])
  lab = c("data", "runquantile(.05)", "runquantile(.25)", "runquantile(0.5)", 
          "runquantile(.75)", "runquantile(.95)")
  legend(0,230, lab, col=col, lty=1 )

  # show plot using runquantile
  k=15; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  y=runquantile(x, k, probs=c(0.05, 0.25, 0.5, 0.75, 0.95))
  col = c("black", "red", "green", "blue", "magenta", "cyan")
  plot(x, col=col[1], main = "Moving Window Quantiles (smoothed)")
  lines(runmean(y[,1],k), col=col[2])
  lines(runmean(y[,2],k), col=col[3])
  lines(runmean(y[,3],k), col=col[4])
  lines(runmean(y[,4],k), col=col[5])
  lines(runmean(y[,5],k), col=col[6])
  lab = c("data", "runquantile(.05)", "runquantile(.25)", "runquantile(0.5)", 
          "runquantile(.75)", "runquantile(.95)")
  legend(0,230, lab, col=col, lty=1 )
  
  # basic tests against runmin &amp; runmax
  y = runquantile(x, k, probs=c(0, 1))
  a = runmin(x,k) # test only the inner part 
  stopifnot(all(a==y[,1], na.rm=TRUE));
  a = runmax(x,k) # test only the inner part
  stopifnot(all(a==y[,2], na.rm=TRUE));
  
  # basic tests against runmed, including testing endrules
  a = runquantile(x, k, probs=0.5, endrule="keep")
  b = runmed(x, k, endrule="keep")
  stopifnot(all(a==b, na.rm=TRUE));
  a = runquantile(x, k, probs=0.5, endrule="constant")
  b = runmed(x, k, endrule="constant")
  stopifnot(all(a==b, na.rm=TRUE));

  # basic tests against apply/embed
  a = runquantile(x,k, c(0.3, 0.7), endrule="trim")
  b = t(apply(embed(x,k), 1, quantile, probs = c(0.3, 0.7)))
  eps = .Machine$double.eps ^ 0.5
  stopifnot(all(abs(a-b)&lt;eps));
  
  # test against loop approach
  # this test works fine at the R prompt but fails during package check - need to investigate
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # create random data
  x[seq(1,n,11)] = NaN;                # add NANs
  k2 = k
  k1 = k-k2-1
  a = runquantile(x, k, probs=c(0.3, 0.8) )
  b = matrix(0,n,2);
  for(j in 1:n) {
    lo = max(1, j-k1)
    hi = min(n, j+k2)
    b[j,] = quantile(x[lo:hi], probs=c(0.3, 0.8), na.rm = TRUE)
  }
  #stopifnot(all(abs(a-b)&lt;eps));
  
  # compare calculation of array ends
  a = runquantile(x, k, probs=0.4, endrule="quantile") # fast C code
  b = runquantile(x, k, probs=0.4, endrule="func")     # slow R code
  stopifnot(all(abs(a-b)&lt;eps));
  
  # test if moving windows forward and backward gives the same results
  k=51;
  a = runquantile(x     , k, probs=0.4)
  b = runquantile(x[n:1], k, probs=0.4)
  stopifnot(all(a[n:1]==b, na.rm=TRUE));

  # test vector vs. matrix inputs, especially for the edge handling
  nRow=200; k=25; nCol=10
  x = rnorm(nRow,sd=30) + abs(seq(nRow)-n/4)
  x[seq(1,nRow,10)] = NaN;              # add NANs
  X = matrix(rep(x, nCol ), nRow, nCol) # replicate x in columns of X
  a = runquantile(x, k, probs=0.6)
  b = runquantile(X, k, probs=0.6)
  stopifnot(all(abs(a-b[,1])&lt;eps));        # vector vs. 2D array
  stopifnot(all(abs(b[,1]-b[,nCol])&lt;eps)); # compare rows within 2D array

  # Exhaustive testing of runquantile to standard R approach
  numeric.test = function (x, k) {
    probs=c(1, 25, 50, 75, 99)/100
    a = runquantile(x,k, c(0.3, 0.7), endrule="trim")
    b = t(apply(embed(x,k), 1, quantile, probs = c(0.3, 0.7), na.rm=TRUE))
    eps = .Machine$double.eps ^ 0.5
    stopifnot(all(abs(a-b)&lt;eps));
  }
  n=50;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # nice behaving data
  for(i in 2:5) numeric.test(x, i)     # test small window sizes
  for(i in 1:5) numeric.test(x, n-i+1) # test large window size
  x[seq(1,50,10)] = NaN;               # add NANs and repet the test
  for(i in 2:5) numeric.test(x, i)     # test small window sizes
  for(i in 1:5) numeric.test(x, n-i+1) # test large window size
  
  # Speed comparison
  ## Not run: 
  x=runif(1e6); k=1e3+1;
  system.time(runquantile(x,k,0.5))    # Speed O(n*k)
  system.time(runmed(x,k))             # Speed O(n * log(k)) 
  
## End(Not run)
</code></pre>

<hr>
<h2 id='runsd'>Standard Deviation of Moving Windows</h2><span id='topic+runsd'></span>

<h3>Description</h3>

<p> Moving (aka running, rolling) Window's Standard Deviation 
calculated over a vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>  runsd(x, k, center = runmean(x,k), 
        endrule=c("sd", "NA", "trim", "keep", "constant", "func"),
        align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runsd_+3A_x">x</code></td>
<td>
<p>numeric vector of length n or matrix with n rows. If <code>x</code> is a 
matrix than each column will be processed separately.</p>
</td></tr>
<tr><td><code id="runsd_+3A_k">k</code></td>
<td>
<p>width of moving window; must be an integer between one and n. In case
of even k's one will have to provide different <code>center</code> function, since
<code><a href="stats.html#topic+runmed">runmed</a></code> does not take even k's.</p>
</td></tr>
<tr><td><code id="runsd_+3A_endrule">endrule</code></td>
<td>
<p>character string indicating how the values at the beginning 
and the end, of the data, should be treated. Only first and last <code>k2</code> 
values at both ends are affected, where <code>k2</code> is the half-bandwidth 
<code>k2 = k %/% 2</code>.
</p>

<ul>
<li> <p><code>"sd"</code> - applies the <code>sd</code> function to
smaller and smaller sections of the array. Equivalent to: 
<code>for(i in 1:k2) out[i]=mad(x[1:(i+k2)])</code>. 
</p>
</li>
<li> <p><code>"trim"</code> - trim the ends; output array length is equal to 
<code>length(x)-2*k2 (out = out[(k2+1):(n-k2)])</code>. This option mimics 
output of <code><a href="base.html#topic+apply">apply</a></code> <code>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code> and other 
related functions.
</p>
</li>
<li> <p><code>"keep"</code> - fill the ends with numbers from <code>x</code> vector 
<code>(out[1:k2] = x[1:k2])</code>. This option makes more sense in case of 
smoothing functions, kept here for consistency.
</p>
</li>
<li> <p><code>"constant"</code> - fill the ends with first and last calculated 
value in output array <code>(out[1:k2] = out[k2+1])</code>
</p>
</li>
<li> <p><code>"NA"</code> - fill the ends with NA's <code>(out[1:k2] = NA)</code>
</p>
</li>
<li> <p><code>"func"</code> - same as <code>"mad"</code> option except that implemented
in R for testing purposes. Avoid since it can be very slow for large windows.
</p>
</li></ul>

<p>Similar to <code>endrule</code> in <code><a href="stats.html#topic+runmed">runmed</a></code> function which has the 
following options: &ldquo;<code>c("median", "keep", "constant")</code>&rdquo; .
</p>
</td></tr>
<tr><td><code id="runsd_+3A_center">center</code></td>
<td>
<p>moving window center. Defaults 
to running mean (<code><a href="#topic+runmean">runmean</a></code> function). Similar to <code>center</code>  
in <code><a href="stats.html#topic+mad">mad</a></code> function. </p>
</td></tr>
<tr><td><code id="runsd_+3A_align">align</code></td>
<td>
<p>specifies whether result should be centered (default), 
left-aligned or right-aligned.  If <code>endrule</code>=&quot;sd&quot; then setting
<code>align</code> to &quot;left&quot; or &quot;right&quot; will fall back on slower implementation 
equivalent to <code>endrule</code>=&quot;func&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the end values, the result of y = runmad(x, k) is the same as 
&ldquo;<code>for(j=(1+k2):(n-k2)) y[j]=sd(x[(j-k2):(j+k2)], na.rm = TRUE)</code>&rdquo;. It can handle 
non-finite numbers like NaN's and Inf's (like <code><a href="base.html#topic+mean">mean</a>(x, na.rm = TRUE)</code>).
</p>
<p>The main incentive to write this set of functions was relative slowness of 
majority of moving window functions available in R and its packages.  With the 
exception of <code><a href="stats.html#topic+runmed">runmed</a></code>, a running window median function, all 
functions listed in &quot;see also&quot; section are slower than very inefficient 
&ldquo;<code><a href="base.html#topic+apply">apply</a>(<a href="stats.html#topic+embed">embed</a>(x,k),1,FUN)</code>&rdquo; approach. 
</p>


<h3>Value</h3>

<p>Returns a numeric vector or matrix of the same size as <code>x</code>. Only in case of 
<code>endrule="trim"</code> the output vectors will be shorter and output matrices 
will have fewer rows. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>See Also</h3>

<p>Links related to:
</p>
       
<ul>
<li> <p><code>runsd</code> - <code><a href="stats.html#topic+sd">sd</a></code>
</p>
</li>
<li><p> Other moving window functions  from this package: <code><a href="#topic+runmin">runmin</a></code>, 
<code><a href="#topic+runmax">runmax</a></code>, <code><a href="#topic+runquantile">runquantile</a></code>, <code><a href="#topic+runmad">runmad</a></code> and
<code><a href="#topic+runmean">runmean</a></code> 
</p>
</li>
<li><p> generic running window functions: <code><a href="base.html#topic+apply">apply</a></code><code>
     (<a href="stats.html#topic+embed">embed</a>(x,k), 1, FUN)</code> (fastest), <code><a href="gtools.html#topic+running">running</a></code> from <span class="pkg">gtools</span> 
package (extremely slow for this purpose), <code><a href="magic.html#topic+subsums">subsums</a></code> from 
<span class="pkg">magic</span> library can perform running window operations on data with any 
dimensions. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # show runmed function
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  col = c("black", "red", "green")
  m=runmean(x, k)
  y=runsd(x, k, center=m)
  plot(x, col=col[1], main = "Moving Window Analysis Functions")
  lines(m    , col=col[2])
  lines(m-y/2, col=col[3])
  lines(m+y/2, col=col[3])
  lab = c("data", "runmean", "runmean-runsd/2", "runmean+runsd/2")
  legend(0,0.9*n, lab, col=col, lty=1 )

  # basic tests against apply/embed
  eps = .Machine$double.eps ^ 0.5
  k=25 # odd size window
  a = runsd(x,k, endrule="trim")
  b = apply(embed(x,k), 1, sd)
  stopifnot(all(abs(a-b)&lt;eps));
  k=24 # even size window
  a = runsd(x,k, endrule="trim")
  b = apply(embed(x,k), 1, sd)
  stopifnot(all(abs(a-b)&lt;eps));
  
  # test against loop approach
  # this test works fine at the R prompt but fails during package check - need to investigate
  k=25; n=200;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4) # create random data
  x[seq(1,n,11)] = NaN;                # add NANs
  k2 = k
  k1 = k-k2-1
  a = runsd(x, k)
  b = array(0,n)
  for(j in 1:n) {
    lo = max(1, j-k1)
    hi = min(n, j+k2)
    b[j] = sd(x[lo:hi], na.rm = TRUE)
  }
  #stopifnot(all(abs(a-b)&lt;eps));
  
  # compare calculation at array ends
  k=25; n=100;
  x = rnorm(n,sd=30) + abs(seq(n)-n/4)
  a = runsd(x, k, endrule="sd" )   # fast C code
  b = runsd(x, k, endrule="func")  # slow R code
  stopifnot(all(abs(a-b)&lt;eps));
  
  # test if moving windows forward and backward gives the same results
  k=51;
  a = runsd(x     , k)
  b = runsd(x[n:1], k)
  stopifnot(all(abs(a[n:1]-b)&lt;eps));
  
  # test vector vs. matrix inputs, especially for the edge handling
  nRow=200; k=25; nCol=10
  x = rnorm(nRow,sd=30) + abs(seq(nRow)-n/4)
  x[seq(1,nRow,10)] = NaN;              # add NANs
  X = matrix(rep(x, nCol ), nRow, nCol) # replicate x in columns of X
  a = runsd(x, k)
  b = runsd(X, k)
  stopifnot(all(abs(a-b[,1])&lt;eps));        # vector vs. 2D array
  stopifnot(all(abs(b[,1]-b[,nCol])&lt;eps)); # compare rows within 2D array

  # speed comparison
  ## Not run: 
  x=runif(1e5); k=51;                       # reduce vector and window sizes
  system.time(runsd( x,k,endrule="trim"))
  system.time(apply(embed(x,k), 1, sd)) 
  
## End(Not run)
</code></pre>

<hr>
<h2 id='sample.split'>Split Data into Test and Train Set</h2><span id='topic+sample.split'></span>

<h3>Description</h3>

<p>Split data from vector Y into two sets in predefined ratio while 
preserving relative ratios of different labels in Y. Used to split the data
used during classification into train and test subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> sample.split( Y, SplitRatio = 2/3, group = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.split_+3A_y">Y</code></td>
<td>
<p>Vector of data labels. If there are only a few labels (as is 
expected) than relative ratio of data in both subsets will be the same.</p>
</td></tr>
<tr><td><code id="sample.split_+3A_splitratio">SplitRatio</code></td>
<td>
<p> Splitting ratio: 
</p>

<ul>
<li><p> if <code>(0&lt;=SplitRatio&lt;1)</code> then <code>SplitRatio</code> fraction of 
points from Y will be set toTRUE
</p>
</li>
<li><p> if <code>(SplitRatio==1)</code> then one random point from Y will be set 
to TRUE
</p>
</li>
<li><p> if <code>(SplitRatio&gt;1)</code> then <code>SplitRatio</code> number of points 
from Y will be set to TRUE
</p>
</li></ul>

</td></tr>
<tr><td><code id="sample.split_+3A_group">group</code></td>
<td>
<p>Optional vector/list used when multiple copies of each sample 
are present. In such a case <code>group</code> contains unique sample labels, 
marking all copies of the same sample with the same 
label, and the function tries to place all copies in either train or test 
subset. If provided than has to have the same length as <code>Y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Function <code>msc.sample.split</code> is the old name of the 
<code>sample.split</code> function. To be retired soon. Note that the function
differs from <code>base::sample</code> by first restricting the input data set
to its unique values before generating the subset(s).
</p>


<h3>Value</h3>

<p>Returns logical vector of the same length as Y with random
<code>SplitRatio*length(Y)</code> elements set to TRUE. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>See Also</h3>


<ul>
<li><p> Similar to <code><a href="base.html#topic+sample">sample</a></code> function.
</p>
</li>
<li><p>  Variable <code>group</code> is used in the same way as <code>f</code> argument in 
<code><a href="base.html#topic+split">split</a></code> and <code>INDEX</code> argument in <code><a href="base.html#topic+tapply">tapply</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  library(MASS)
  data(cats)   # load cats data
  Y = cats[,1] # extract labels from the data
  msk = sample.split(Y, SplitRatio=3/4)
  table(Y,msk)
  t=sum( msk)  # number of elements in one class
  f=sum(!msk)  # number of elements in the other class
  stopifnot( round((t+f)*3/4) == t ) # test ratios
  
  # example of using group variable
  g = rep(seq(length(Y)/4), each=4); g[48]=12;
  msk = sample.split(Y, SplitRatio=1/2, group=g)
  table(Y,msk) # try to get correct split ratios ...
  split(msk,g) # ... while keeping samples with the same group label together

  # test results
  print(paste( "All Labels numbers: total=",t+f,", train=",t,", test=",f,
        ", ratio=", t/(t+f) ) )
  U = unique(Y)       # extract all unique labels
  for( i in 1:length(U)) {  # check for all labels
    lab = (Y==U[i])   # mask elements that have label U[i]
    t=sum( msk[lab])  # number of elements with label U[i] in one class
    f=sum(!msk[lab])  # number of elements with label U[i] in the other class 
    print(paste( "Label",U[i],"numbers: total=",t+f,", train=",t,", test=",f, 
                 ", ratio=", t/(t+f) ) )
  }
  
  # use results
  train = cats[ msk,2:3]  # use output of sample.split to ...
  test  = cats[!msk,2:3]  # create train and test subsets
  z = lda(train, Y[msk])  # perform classification
  table(predict(z, test)$class, Y[!msk]) # predicted &amp; true labels
  
  # see also LogitBoost example
</code></pre>

<hr>
<h2 id='sumexact+2C+20cumsumexact'>Basic Sum Operations without Round-off Errors</h2><span id='topic+sumexact'></span><span id='topic+cumsumexact'></span>

<h3>Description</h3>

<p>Functions for performing basic sum operations without round-off errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sumexact(..., na.rm = FALSE)
  cumsumexact(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumexact+2B2C+2B20cumsumexact_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="sumexact+2B2C+2B20cumsumexact_+3A_...">...</code></td>
<td>
<p>numeric vector(s), numbers or other objects to be summed</p>
</td></tr>
<tr><td><code id="sumexact+2B2C+2B20cumsumexact_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All three functions use full precision summation using multiple doubles for 
intermediate values. The sum of numbers x &amp; y is a=x+y with error term 
b=error(a+b). That way a+b is equal exactly x+y, so sum of 2 numbers is stored
as 2 or fewer values, which when added would under-flow. By extension sum of n 
numbers is calculated with intermediate results stored as array of numbers 
that can not be added without introducing an error. Only final result is 
converted to a single number
</p>


<h3>Value</h3>

<p>Function <code>sumexact</code> returns single number. Function <code>cumsumexact</code> 
returns vector of the same length as <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a> based on
code by Vadim Ogranovich, which is based on algorithms described in 
references, pointed out by Gabor Grothendieck. 
</p>


<h3>References</h3>

<p>Round-off error correction is based on:
Shewchuk, Jonathan, <em>Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates</em>
</p>
<p>McCullough, D.B., (1998) <em>Assessing the Reliability of Statistical 
Software, Part I</em>, The American Statistician, Vol. 52 No.
</p>
<p>McCullough, D.B., (1999) <em>Assessing the Reliability of Statistical 
Software, Part II</em>, The American Statistician, Vol. 53 No 2
</p>
<p>NIST Statistical Reference Datasets (StRD) website 
</p>


<h3>See Also</h3>

       
<ul>
<li> <p><code><a href="base.html#topic+sum">sum</a></code> is faster but not error-save version of 
<code>sumexact</code>
</p>
</li>
<li> <p><code><a href="base.html#topic+cumsum">cumsum</a></code> is equivalent to <code>cumsumexact</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  x = c(1, 1e20, 1e40, -1e40, -1e20, -1)
  a = sum(x);         print(a)
  b = sumexact(x);    print(b)
  stopifnot(b==0)
  a = cumsum(x);      print(a)
  b = cumsumexact(x); print(b)
  stopifnot(b[6]==0)
</code></pre>

<hr>
<h2 id='trapz'>Trapezoid Rule Numerical Integration</h2><span id='topic+trapz'></span>

<h3>Description</h3>

<p>Computes the integral of Y with respect to X using trapezoid rule 
integration.</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapz(x, y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trapz_+3A_x">x</code></td>
<td>
<p> Sorted vector of x-axis values. </p>
</td></tr> 
<tr><td><code id="trapz_+3A_y">y</code></td>
<td>
<p> Vector of y-axis values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has only two lines:
</p>
<pre>
    idx = 2:length(x)
    return (as.double( (x[idx] - x[idx-1]) %*% (y[idx] + y[idx-1])) / 2)
  </pre>


<h3>Value</h3>

<p>Integral of Y with respect to X or area under the Y curve.</p>


<h3>Note</h3>

<p>Trapezoid rule is not the most accurate way of calculating integrals (it is 
exact for linear functions), for example Simpson's rule (exact for linear and 
quadratic functions) is more accurate.
</p>


<h3>Author(s)</h3>

<p>Jarek Tuszynski (SAIC) <a href="mailto:jaroslaw.w.tuszynski@saic.com">jaroslaw.w.tuszynski@saic.com</a></p>


<h3>References</h3>

<p> D. Kincaid &amp; W. Chaney (1991), <em>Numerical Analysis</em>, p.445 </p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+integrate">integrate</a></code>
</p>
</li>
<li><p> Matlab's <code>trapz</code> function (<a href="http://www.mathworks.com/access/helpdesk/help/techdoc/ref/trapz.html">http://www.mathworks.com/access/helpdesk/help/techdoc/ref/trapz.html</a>) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # integral of sine function in [0, pi] range suppose to be exactly 2.
  # lets calculate it using 10 samples:
  x = (1:10)*pi/10
  trapz(x, sin(x))
  # now lets calculate it using 1000 samples:
  x = (1:1000)*pi/1000
  trapz(x, sin(x))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
