<!DOCTYPE html><html><head><title>Help for package rsyntax</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsyntax}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_span_quotes'><p>Add span quotes to a source-quote annotations</p></a></li>
<li><a href='#AND'><p>Use AND search in tquery</p></a></li>
<li><a href='#annotate'><p>Annotate a tokenlist based on rsyntax queries</p></a></li>
<li><a href='#annotate_nodes'><p>Annotate a tokenlist based on rsyntaxNodes</p></a></li>
<li><a href='#annotate_tqueries'><p>Annotate a tokenlist based on rsyntax queries</p></a></li>
<li><a href='#apply_queries'><p>Apply queries created with tquery</p></a></li>
<li><a href='#as_tokenindex'><p>Prepare a tokenIndex</p></a></li>
<li><a href='#BREAK'><p>A special NOT condition if depth &gt; 1</p></a></li>
<li><a href='#cast_text'><p>Cast annotations to text</p></a></li>
<li><a href='#chop'><p>Chop of a branch of the tree</p></a></li>
<li><a href='#climb_tree'><p>Have a node adopt its parent's position</p></a></li>
<li><a href='#copy_fill'><p>Copy nodes</p></a></li>
<li><a href='#copy_nodes'><p>Copy nodes</p></a></li>
<li><a href='#custom_fill'><p>Specify custom fill behavior</p></a></li>
<li><a href='#dutch'><p>Dutch lemma</p></a></li>
<li><a href='#fill'><p>Specify custom fill behavior</p></a></li>
<li><a href='#get_branch_id'><p>Add the branch id as a column to the tokenindex</p></a></li>
<li><a href='#get_long_ids'><p>Get ids in various forms to extract token_ids</p></a></li>
<li><a href='#get_nodes'><p>Transform the nodes to long format and match with token data</p></a></li>
<li><a href='#isolate_branch'><p>Isolate a branch in a dependency tree</p></a></li>
<li><a href='#mutate_nodes'><p>Mutate nodes</p></a></li>
<li><a href='#nested_nodes'><p>Search for parents or children in tquery</p></a></li>
<li><a href='#NOT'><p>Use NOT search in tquery</p></a></li>
<li><a href='#OR'><p>Use OR search in tquery</p></a></li>
<li><a href='#plot_tree'><p>Create an igraph tree from a sentence</p></a></li>
<li><a href='#print.tQuery'><p>S3 print for tQuery class</p></a></li>
<li><a href='#quote_punctuation'><p>Quote punctuation</p></a></li>
<li><a href='#remove_fill'><p>Remove fill</p></a></li>
<li><a href='#remove_nodes'><p>Remove nodes</p></a></li>
<li><a href='#reselect_nodes'><p>Within a chain of reshape operations, reapply the tquery</p></a></li>
<li><a href='#rsyntax_threads'><p>Get the number of threads to be used by rsyntax functions</p></a></li>
<li><a href='#select_nodes'><p>Apply tquery to initiate reshape operations</p></a></li>
<li><a href='#selected_nodes'><p>If select_nodes() is used, the selected nodes can be extracted with selected_nodes().</p>
This is mainly for internal use, but it can also be usefull for debugging, and to controll
loops of reshape operation (e.g. break if no selected nodes left)</a></li>
<li><a href='#set_rsyntax_threads'><p>Set number of threads to be used by rsyntax functions</p></a></li>
<li><a href='#split_UD_conj'><p>Split conjunctions for dependency trees in Universal Dependencies</p></a></li>
<li><a href='#subset_nodes'><p>Subset a select_nodes selection</p></a></li>
<li><a href='#syntax_reader'><p>Create a full text browser with highlighted rsyntax annotations</p></a></li>
<li><a href='#tokens_corenlp'><p>Example tokens for coreNLP English</p></a></li>
<li><a href='#tokens_dutchclauses'><p>Example tokens for Dutch clauses</p></a></li>
<li><a href='#tokens_dutchquotes'><p>Example tokens for Dutch quotes</p></a></li>
<li><a href='#tokens_spacy'><p>Example tokens for spacy English</p></a></li>
<li><a href='#tquery'><p>Create a query for dependency based parse trees in a data.table (CoNLL-U or similar format).</p></a></li>
<li><a href='#unselect_nodes'><p>Undo select_nodes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extract Semantic Relations from Text by Querying and Reshaping
Syntax</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Kasper Welbers and Wouter van Atteveldt</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kasper Welbers &lt;kasperwelbers@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, tidyselect, methods, stringi, digest, rlang, magrittr,
tokenbrowser, base64enc, png, data.table (&ge; 1.11.8)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>spacyr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Various functions for querying and reshaping dependency trees, 
    as for instance created with the 'spacyr' or 'udpipe' packages.
    This enables the automatic extraction of useful semantic relations from texts,
    such as quotes (who said what) and clauses (who did what). Method proposed in 
    Van Atteveldt et al. (2017) &lt;<a href="https://doi.org/10.1017%2Fpan.2016.12">doi:10.1017/pan.2016.12</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-06 13:19:12 UTC; kasper</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-07 04:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_span_quotes'>Add span quotes to a source-quote annotations</h2><span id='topic+add_span_quotes'></span>

<h3>Description</h3>

<p>Quotes can span across sentences, which makes it impossible to find them based on dependency tree quories. 
This function can be used as post-processing, AFTER using tqueries to find 'source' and 'quote' nodes, to add some of these quotes. 
</p>
<p>The quotes themselves are often easy to detect due to the use of quotation marks. There are two common ways of indicating the sources.
</p>
<p>Firstly, the source might be used before the start of the quote (Steve said: &quot;hey a quote!&quot;. &quot;I like quotes!&quot;).
Secondly, the source might be implied in the sentence where the quotes starts, or the sentence before that (Steve was mad. &quot;What a stupid way of quoting me!&quot;). 
</p>
<p>In the first case, the source can be found with a tquery. If there is a source (source_val) in the quote_col that is linked to a part of the quote (quote_val), this function will add the rest of the quote. 
</p>
<p>In the second case, we can look for candidates near the beginning of the quote. The candidate criteria can be specified as tqueries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_span_quotes(
  tokens,
  text_col,
  quote_col = "quotes",
  source_val = "source",
  quote_val = "quote",
  tqueries = NULL,
  par_col = NULL,
  space_col = NULL,
  lag_sentences = 1,
  add_quote_symbols = NULL,
  quote_subset = NULL,
  copy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_span_quotes_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex with rsyntax annotations for 'sources' and 'quotes'</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_text_col">text_col</code></td>
<td>
<p>The column with the text (often 'token' or 'word')</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_quote_col">quote_col</code></td>
<td>
<p>The column that contains the quote annotations</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_source_val">source_val</code></td>
<td>
<p>The value in quote_col that indicates the source</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_quote_val">quote_val</code></td>
<td>
<p>The value in quote_col that indicates the quote</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_tqueries">tqueries</code></td>
<td>
<p>A list of tqueries, that will be performed to find source candidates. The order of the queries determines which source candidates are preferred. It would make sense to use the same value as in source_val in the 'label' argument for the tquery.</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_par_col">par_col</code></td>
<td>
<p>If available in the parser output, the column with the paragraph id. We can assume that quotes do not span across paragraphs. By using this argument, quotes that are not properly closed (uneven number of quotes) will stop at the end of the paragraph</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_space_col">space_col</code></td>
<td>
<p>If par_col is not used, paragraphs will be identified based on hard enters in the text_col. In some parsers, there is an additional &quot;space&quot; column that hold the whitespace and linebreaks, which can be included here.</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_lag_sentences">lag_sentences</code></td>
<td>
<p>The max number of sentences looked backwards to find source candidates. Default is 1, which means the source candidates have to occur in the sentence where the quote begins (lag = 0) or the sentence before that (lag = 1)</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_add_quote_symbols">add_quote_symbols</code></td>
<td>
<p>Optionally, add additional punctuation symbols for finding quotation marks. 
In some contexts and languages it makes sense to add single quotes, but in that case it is oftne necessary to 
also use the quote_subset argument. For instance, in Spacy (and probably other UD based annotations), single quotes in posessives (e.g., Bob's, scholars') have a
PART POS tag, whereas quotation symbols have PUNCT, NOUN, VERB, or ADJ (for some reason).</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_quote_subset">quote_subset</code></td>
<td>
<p>Optionally, an expression to be evaluated on the columns of 'tokens' for selecting/deselecting tokens that can/cant be quotation marks. For example,
pos != &quot;PART&quot; can be used for the example mentioned in add_quote_symbols.</p>
</td></tr>
<tr><td><code id="add_span_quotes_+3A_copy">copy</code></td>
<td>
<p>If TRUE, deep copy the data.table (use if output tokens do not overwrite input tokens)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the tokenIndex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This function is best used after first annotating regular quotes
## Here we first apply 3 tqueries for annotating quotes in spacy tokens



tokens = tokens_spacy[tokens_spacy$doc_id == 'text6',]

verbs = c("tell", "show", "acknowledge", "admit", "affirm", "allege", 
  "announce", "assert", "attest", "avow", "call", "claim", "comment", 
  "concede", "confirm", "declare", "deny", "exclaim", "insist", "mention", 
  "note", "post","predict", "proclaim", "promise", "reply", "remark", 
  "report", "say", "speak", "state", "suggest", "talk", "tell", "think",
  "warn","write", "add")

direct = tquery(lemma = verbs, label='verb',
   children(req=FALSE, relation = c('npadvmod'), block=TRUE),
   children(relation=c('su','nsubj','agent','nmod:agent'), label='source'),
   children(label='quote'))

nosrc = tquery(pos='VERB*',
   children(relation= c('su', 'nsubj', 'agent', 'nmod:agent'), label='source'),
   children(lemma = verbs, relation='xcomp', label='verb',
     children(relation=c("ccomp","dep","parataxis","dobj","nsubjpass","advcl"), label='quote')))

according = tquery(label='quote',
   children(relation='nmod:according_to', label='source',
        children(label='verb')))

tokens = annotate_tqueries(tokens, 'quote', dir=direct, nos=nosrc, acc=according)
tokens

## now we add the span quotes. If a span quote is found, the algorithm will first
## look for already annotated sources as source candidates. If there are none,
## additional tqueries can be used to find candidates. Here we simply look for
## the most recent PERSON entity

tokens = tokens_spacy[tokens_spacy$doc_id == 'text6',]
tokens = annotate_tqueries(tokens, 'quote', dir=direct, nos=nosrc, acc=according)


last_person = tquery(entity = 'PERSON*', label='source')
tokens = add_span_quotes(tokens, 'token', 
                         quote_col = 'quote', source_val = 'source', quote_val = 'quote', 
                         tqueries=last_person)
tokens

## view as full text
syntax_reader(tokens, annotation = 'quote', value = 'source')

</code></pre>

<hr>
<h2 id='AND'>Use AND search in tquery</h2><span id='topic+AND'></span>

<h3>Description</h3>

<p>Use AND search in tquery
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AND(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AND_+3A_...">...</code></td>
<td>
<p>name-value pairs for look-up terms. see ?query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, to be used as input to <a href="#topic+tquery">tquery</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tquery(AND(lemma = 'walk', POS='Noun'))   ## is also the default
</code></pre>

<hr>
<h2 id='annotate'>Annotate a tokenlist based on rsyntax queries</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>This function has been renamed to annotate_tqueries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(
  tokens,
  column,
  ...,
  block = NULL,
  fill = TRUE,
  overwrite = FALSE,
  block_fill = FALSE,
  copy = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>.</p>
</td></tr>
<tr><td><code id="annotate_+3A_column">column</code></td>
<td>
<p>The name of the column in which the annotations are added. The unique ids are added as column_id</p>
</td></tr>
<tr><td><code id="annotate_+3A_...">...</code></td>
<td>
<p>One or multiple tqueries, or a list of queries, as created with <a href="#topic+tquery">tquery</a>. Queries can be given a named by using a named argument, which will be used in the annotation_id to keep track of which query was used.</p>
</td></tr>
<tr><td><code id="annotate_+3A_block">block</code></td>
<td>
<p>Optionally, specify ids (doc_id - sentence - token_id triples) that are blocked from querying and filling (ignoring the id and recursive searches through the id).</p>
</td></tr>
<tr><td><code id="annotate_+3A_fill">fill</code></td>
<td>
<p>Logical. If TRUE (default) also assign the fill nodes (as specified in the tquery). Otherwise these are ignored</p>
</td></tr>
<tr><td><code id="annotate_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, existing column will be overwritten. Otherwise (default), the exsting annotations in the column will be blocked, and new annotations will be added. This is identical to using multiple queries.</p>
</td></tr>
<tr><td><code id="annotate_+3A_block_fill">block_fill</code></td>
<td>
<p>If TRUE (and overwrite is FALSE), the existing fill nodes will also be blocked. In other words, the new annotations will only be added if the</p>
</td></tr>
<tr><td><code id="annotate_+3A_copy">copy</code></td>
<td>
<p>If TRUE (default), the data.table is copied. Otherwise, it is changed by reference. Changing by reference is faster and more memory efficient, but is not predictable R style, so is optional.</p>
</td></tr>
<tr><td><code id="annotate_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, report progress (only usefull if multiple queries are given)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply queries to extract syntax patterns, and add the results as two columns to a tokenlist.
One column contains the ids for each hit. The other column contains the annotations.
Only nodes that are given a name in the tquery (using the 'label' parameter) will be added as annotation.
</p>
<p>Note that while queries only find 1 node for each labeld component of a pattern (e.g., quote queries have 1 node for &quot;source&quot; and 1 node for &quot;quote&quot;), 
all children of these nodes can be annotated by settting fill to TRUE. If a child has multiple ancestors, only the most direct ancestors are used (see documentation for the fill argument).
</p>


<h3>Value</h3>

<p>The tokenIndex with the annotation columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

 
tokens = annotate_tqueries(tokens, "clause", pas=passive, act=active)
tokens
if (interactive()) plot_tree(tokens, annotation='clause')

</code></pre>

<hr>
<h2 id='annotate_nodes'>Annotate a tokenlist based on rsyntaxNodes</h2><span id='topic+annotate_nodes'></span>

<h3>Description</h3>

<p>Use rsyntaxNodes, as created with <a href="#topic+tquery">tquery</a> and <a href="#topic+apply_queries">apply_queries</a>, to annotate a tokenlist.
Three columns will be added: a unique id for the query match, the labels assigned in the tquery, and a column with the fill level (0 is direct match, 1 is child of match, 2 is grandchild, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_nodes(tokens, nodes, column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_nodes_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>.</p>
</td></tr>
<tr><td><code id="annotate_nodes_+3A_nodes">nodes</code></td>
<td>
<p>An rsyntaxNodes A data.table, as created with <a href="#topic+apply_queries">apply_queries</a>. Can be a list of multiple data.tables.</p>
</td></tr>
<tr><td><code id="annotate_nodes_+3A_column">column</code></td>
<td>
<p>The name of the column in which the annotations are added. The unique ids are added as [column]_id, and the fill values are added as [column]_fill.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that you can also directly use <a href="#topic+annotate">annotate</a>.
</p>


<h3>Value</h3>

<p>The tokenIndex data.table with the annotation columns added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

nodes = apply_queries(tokens, pas=passive, act=active)
annotate_nodes(tokens, nodes, 'clause')
</code></pre>

<hr>
<h2 id='annotate_tqueries'>Annotate a tokenlist based on rsyntax queries</h2><span id='topic+annotate_tqueries'></span>

<h3>Description</h3>

<p>Apply queries to extract syntax patterns, and add the results as three columns to a tokenlist.
The first column contains the ids for each hit. The second column contains the annotation label. The third column contains the fill level (which you probably won't use, but is important for some functionalities).
Only nodes that are given a name in the tquery (using the 'label' parameter) will be added as annotation.
</p>
<p>Note that while queries only find 1 node for each labeld component of a pattern (e.g., quote queries have 1 node for &quot;source&quot; and 1 node for &quot;quote&quot;), 
all children of these nodes can be annotated by settting fill to TRUE. If a child has multiple ancestors, only the most direct ancestors are used (see documentation for the fill argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_tqueries(
  tokens,
  column,
  ...,
  block = NULL,
  fill = TRUE,
  overwrite = NA,
  block_fill = FALSE,
  copy = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_tqueries_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>.</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_column">column</code></td>
<td>
<p>The name of the column in which the annotations are added. The unique ids are added as column_id</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_...">...</code></td>
<td>
<p>One or multiple tqueries, or a list of queries, as created with <a href="#topic+tquery">tquery</a>. Queries can be given a named by using a named argument, which will be used in the annotation_id to keep track of which query was used.</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_block">block</code></td>
<td>
<p>Optionally, specify ids (doc_id - sentence - token_id triples) that are blocked from querying and filling (ignoring the id and recursive searches through the id).</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_fill">fill</code></td>
<td>
<p>Logical. If TRUE (default) also assign the fill nodes (as specified in the tquery). Otherwise these are ignored</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_overwrite">overwrite</code></td>
<td>
<p>Applies if column already exists. If TRUE, existing column will be overwritten. If FALSE, the existing annotations in the column will be blocked, and new annotations will be added. This is identical to using multiple queries.</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_block_fill">block_fill</code></td>
<td>
<p>If TRUE (and overwrite is FALSE), the existing fill nodes will also be blocked. In other words, the new annotations will only be added if the</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_copy">copy</code></td>
<td>
<p>If TRUE (default), the data.table is copied. Otherwise, it is changed by reference. Changing by reference is faster and more memory efficient, but is not predictable R style, so is optional.</p>
</td></tr>
<tr><td><code id="annotate_tqueries_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, report progress (only usefull if multiple queries are given)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tokenIndex data.table with the annotation columns added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

tokens = annotate_tqueries(tokens, "clause", pas=passive, act=active)
tokens
 
if (interactive()) plot_tree(tokens, annotation='clause')

</code></pre>

<hr>
<h2 id='apply_queries'>Apply queries created with <a href="#topic+tquery">tquery</a></h2><span id='topic+apply_queries'></span>

<h3>Description</h3>

<p>Apply queries created with <a href="#topic+tquery">tquery</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_queries(
  tokens,
  ...,
  as_chain = FALSE,
  block = NULL,
  check = FALSE,
  fill = TRUE,
  return_wide = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_queries_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>.</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_...">...</code></td>
<td>
<p>tqueries, as created with <a href="#topic+tquery">tquery</a>. Can also be a list with tquery functions. It is recommended to use named arguments/lists, to name the tqueries.</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_as_chain">as_chain</code></td>
<td>
<p>If TRUE, Nodes that have already been assigned assigned earlier in the chain will be ignored (see 'block' argument).</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_block">block</code></td>
<td>
<p>Optionally, specify ids (doc_id - sentence - token_id triples) where find_nodes will stop (ignoring the id and recursive searches through the id). 
Can also be a data.table returned by (a previous) apply_queries, in which case all ids are blocked.</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_check">check</code></td>
<td>
<p>If TRUE, return a warning if nodes occur in multiple patterns, which could indicate that the find_nodes query is not specific enough.</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_fill">fill</code></td>
<td>
<p>If TRUE (default) the fill nodes are added. Otherwise these are ignored, even if the queries include fill()</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_return_wide">return_wide</code></td>
<td>
<p>If TRUE, return nodes in wide format.</p>
</td></tr>
<tr><td><code id="apply_queries_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, report progress (only useful if multiple queries are used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table in which each row is a node for which all conditions are satisfied, and each column is one of the linked nodes 
(parents / children) with names as specified in the label argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

nodes = apply_queries(tokens, pas=passive, act=active)
nodes
</code></pre>

<hr>
<h2 id='as_tokenindex'>Prepare a tokenIndex</h2><span id='topic+as_tokenindex'></span>

<h3>Description</h3>

<p>Creates a tokenIndex data.table. 
Accepts any data.frame given that the required columns (doc_id, sentence, token_id, parent, relation) are present.
The names of these columns must be one of the values specified in the respective arguments.
</p>
<p>The data in the data.frame will not be changed, with three exceptions. First, the columnnames will be changed if the default values are not used.
Second, if a token has itself as its parent (which in some parsers is used to indicate the root), the parent is set to NA (as used in other parsers) to prevent infinite cycles.
Third, the data will be sorted by doc_id, sentence, token_id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tokenindex(
  tokens,
  doc_id = c("doc_id", "document_id"),
  sentence = c("sentence", "sentence_id"),
  token_id = c("token_id"),
  parent = c("parent", "head_token_id"),
  relation = c("relation", "dep_rel"),
  paragraph = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tokenindex_+3A_tokens">tokens</code></td>
<td>
<p>A data.frame, data.table, or tokenindex.</p>
</td></tr>
<tr><td><code id="as_tokenindex_+3A_doc_id">doc_id</code></td>
<td>
<p>candidate names for the document id columns</p>
</td></tr>
<tr><td><code id="as_tokenindex_+3A_sentence">sentence</code></td>
<td>
<p>candidate names for sentence (id/index) column</p>
</td></tr>
<tr><td><code id="as_tokenindex_+3A_token_id">token_id</code></td>
<td>
<p>candidate names for the  token id column. Has to be numeric (Some parsers return token_id's as numbers with a prefix (t_1, w_1))</p>
</td></tr>
<tr><td><code id="as_tokenindex_+3A_parent">parent</code></td>
<td>
<p>candidate names for the parent id column. Has to be numeric</p>
</td></tr>
<tr><td><code id="as_tokenindex_+3A_relation">relation</code></td>
<td>
<p>candidate names for the relation column</p>
</td></tr>
<tr><td><code id="as_tokenindex_+3A_paragraph">paragraph</code></td>
<td>
<p>Optionally, the name of a column with paragraph ids. This is only necessary if sentences are numbered per paragraph, and therefore not unique within documents. If given, sentences are re-indexed to be unique within documents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tokenIndex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_tokenindex(tokens_corenlp)
</code></pre>

<hr>
<h2 id='BREAK'>A special NOT condition if depth &gt; 1</h2><span id='topic+BREAK'></span>

<h3>Description</h3>

<p>If depth &gt; 1 in the children, parents or fill function, the children/parents will
be retrieved recursively (i.e. children, children of children, etc.).
If the look-up conditions (e.g., relation = 'nsubj') are not satisfied, a node 
will not be matched by the query, but the search will still continue for it's
parents/children. The special BREAK look-up function allows you to specify a condition
for breaking the recursive loop (lending it's name from the 'break' in a for loop).
An example is that you might want to stop the recursive loop in a custom_fill() once it encounters
a nested sentence, such as a relative clause: custom_fill(BREAK(relation = 'relcl')).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BREAK(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BREAK_+3A_...">...</code></td>
<td>
<p>name-value pairs for look-up terms. see ?query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, to be used as input to <a href="#topic+tquery">tquery</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tquery(NOT(POS='Noun'))  
</code></pre>

<hr>
<h2 id='cast_text'>Cast annotations to text</h2><span id='topic+cast_text'></span>

<h3>Description</h3>

<p>Cast labeled tokens to sentences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_text(tokens, annotation, ..., text_col = "token", na.rm = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_text_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex</p>
</td></tr>
<tr><td><code id="cast_text_+3A_annotation">annotation</code></td>
<td>
<p>The name of annotations (the &quot;column&quot; argument in annotate_tqueries)</p>
</td></tr>
<tr><td><code id="cast_text_+3A_...">...</code></td>
<td>
<p>Optionally, group annotations together. Named arguments can be given
where the name is the new group, and the value is a character vector with
values in the annotation column. For example, text = c('verb','predicate') would 
group the 'verb' and 'predicate' nodes together under the name 'text'.</p>
</td></tr>
<tr><td><code id="cast_text_+3A_text_col">text_col</code></td>
<td>
<p>The name of the column in tokens with the text. Usually this is &quot;token&quot;,
but some parsers use alternatives such as 'word'.</p>
</td></tr>
<tr><td><code id="cast_text_+3A_na.rm">na.rm</code></td>
<td>
<p>If true (default), drop tokens where annotation id is NA (i.e. tokens without labels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "verb", fill=FALSE,
                 children(relation = "agent",
                          children(label="subject")),
                 children(relation = "nsubjpass", label="object"))
active =  tquery(pos = "VERB*", label = "verb", fill=FALSE,
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"),
                 children(relation = "dobj", label="object"))

tokens = annotate_tqueries(tokens, "clause", pas=passive, act=active, overwrite=T)

cast_text(tokens, 'clause')

## group annotations
cast_text(tokens, 'clause', text = c('verb','object'))

## use grouping to sort
cast_text(tokens, 'clause', subject = 'subject', 
                            verb = 'verb', object = 'object')
</code></pre>

<hr>
<h2 id='chop'>Chop of a branch of the tree</h2><span id='topic+chop'></span>

<h3>Description</h3>

<p>Using the query language for tquery, chop of the branch down from the node that is found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop(.tokens, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chop_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex</p>
</td></tr>
<tr><td><code id="chop_+3A_...">...</code></td>
<td>
<p>Arguments passed to tquery. For instance, relation = 'punct' cuts off all punctuation dependencies (in universal dependencies)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with the rows of the nodes in the selected branches removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spacy_conjunctions &lt;- function(tokens) {
  no_fill = c('compound*','case', 'relcl')
  tq = tquery(label='target', NOT(relation = 'conj'),
              rsyntax::fill(NOT(relation = no_fill), max_window = c(Inf,0)),
              children(relation = 'conj', label='origin',
                       rsyntax::fill(NOT(relation = no_fill), max_window=c(0,Inf))))
  tokens = climb_tree(tokens, tq)
  chop(tokens, relation = 'cc')
}

## spacy tokens for "Bob and John ate bread and drank wine"
tokens = tokens_spacy[tokens_spacy$doc_id == 'text5',]

tokens = spacy_conjunctions(tokens)
tokens

if (interactive()) plot_tree(tokens)

</code></pre>

<hr>
<h2 id='climb_tree'>Have a node adopt its parent's position</h2><span id='topic+climb_tree'></span>

<h3>Description</h3>

<p>given a tquery that identfies a node labeled &quot;origin&quot;, that has a parent labeled &quot;target&quot;, 
recursively have child adopt the parent's position (parent and relation column)
and adopt parents fill nodes. only_new restricts adding fill nodes to relations that child
does not already have. This seems to be a good heuristic for dealing with argument drop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>climb_tree(
  .tokens,
  tq,
  unpack = TRUE,
  isolate = TRUE,
  take_fill = TRUE,
  give_fill = TRUE,
  only_new = "relation",
  max_iter = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="climb_tree_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_tq">tq</code></td>
<td>
<p>A tquery. Needs to have a node labeled &quot;origin&quot; that has a parent labeled &quot;target&quot;</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_unpack">unpack</code></td>
<td>
<p>If TRUE (default), create separate branches for the parent and the node that inherits the parent position</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_isolate">isolate</code></td>
<td>
<p>If unpack is TRUE and isolate is TRUE (default is FALSE), isolate the new branch by recursively unpacking</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_take_fill">take_fill</code></td>
<td>
<p>If TRUE (default), give the node that will inherit the parent position a copy of the parent children (but only if it does not already have children with this relation; see only_new)</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_give_fill">give_fill</code></td>
<td>
<p>If TRUE (default), copy the children of the node that will inherit the parent position to the parent (but only if it does not already have children with this relation; see only_new)</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_only_new">only_new</code></td>
<td>
<p>A characetr vector giving one or multiple column names that need to be unique for take_fill and give_fill</p>
</td></tr>
<tr><td><code id="climb_tree_+3A_max_iter">max_iter</code></td>
<td>
<p>The climb tree function repeatedly resolves the first conjunction it encounters in a sentence. This can lead to many iterations
for sentences with many (nested) conjunctions. It could be the case that in unforseen cases or with certain parsers
an infinite loop is reached, which is why we use a max_iter argument that breaks the loop and sends a warning if the max is reached.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reshaped tokenIndex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spacy_conjunctions &lt;- function(tokens) {
  no_fill = c('compound*','case', 'relcl')
  tq = tquery(label='target', NOT(relation = 'conj'),
              rsyntax::fill(NOT(relation = no_fill), max_window = c(Inf,0)),
              children(relation = 'conj', label='origin',
                       rsyntax::fill(NOT(relation = no_fill), max_window=c(0,Inf))))
  tokens = climb_tree(tokens, tq)
  chop(tokens, relation = 'cc')
}

## spacy tokens for "Bob and John ate bread and drank wine"
tokens = tokens_spacy[tokens_spacy$doc_id == 'text5',]

tokens = spacy_conjunctions(tokens)

tokens

if (interactive()) plot_tree(tokens)

</code></pre>

<hr>
<h2 id='copy_fill'>Copy nodes</h2><span id='topic+copy_fill'></span>

<h3>Description</h3>

<p>Copy nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_fill(
  .tokens,
  from_node,
  to_node,
  subset = NULL,
  subset_fill = NULL,
  only_new = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_fill_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
<tr><td><code id="copy_fill_+3A_from_node">from_node</code></td>
<td>
<p>The name of the node from which fill is copied</p>
</td></tr>
<tr><td><code id="copy_fill_+3A_to_node">to_node</code></td>
<td>
<p>The name of the node to which fill is copied</p>
</td></tr>
<tr><td><code id="copy_fill_+3A_subset">subset</code></td>
<td>
<p>A subset expression (that evaluates to a logical vector). The token column for each labeled node in the tquery can be referred to as label$column.</p>
</td></tr>
<tr><td><code id="copy_fill_+3A_subset_fill">subset_fill</code></td>
<td>
<p>A subset on the fill nodes. Can only directly use token column. For example, use pos == 'VERB' to copy only verbs</p>
</td></tr>
<tr><td><code id="copy_fill_+3A_only_new">only_new</code></td>
<td>
<p>If TRUE, direct fill children will only be copied to to_node if it does not already have nodes of this relation. This is a good heuristic for dealing with argument drop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text1',]

tq = tquery(label='object', relation='dobj')
            
tokens2 = select_nodes(tokens, tq)
selected_nodes(tokens2)

tokens3 = copy_nodes(tokens2, 'object', 'new_object')
copy_fill(tokens3, 'object', 'new_object')
</code></pre>

<hr>
<h2 id='copy_nodes'>Copy nodes</h2><span id='topic+copy_nodes'></span>

<h3>Description</h3>

<p>Copy nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_nodes(
  .tokens,
  node,
  new,
  subset = NULL,
  keep_relation = TRUE,
  copy_fill = FALSE,
  subset_fill = NULL,
  only_new = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_node">node</code></td>
<td>
<p>The name of the node that is to be copied</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_new">new</code></td>
<td>
<p>The name given to the copy</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_subset">subset</code></td>
<td>
<p>A subset expression (that evaluates to a logical vector). The token column for each labeled node in the tquery can be referred to as label$column.</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_keep_relation">keep_relation</code></td>
<td>
<p>If FALSE, remove relation (making node a root)</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_copy_fill">copy_fill</code></td>
<td>
<p>If TRUE, also copy the fill</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_subset_fill">subset_fill</code></td>
<td>
<p>A subset on the fill nodes. Can only directly use token column. For example, use pos == 'VERB' to copy only verbs</p>
</td></tr>
<tr><td><code id="copy_nodes_+3A_only_new">only_new</code></td>
<td>
<p>If TRUE, direct fill children will only be copied to to_node if it does not already have nodes of this relation. This is a good heuristic for dealing with argument drop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text1',]

tq = tquery(label='object', relation='dobj')
            
tokens2 = select_nodes(tokens, tq)
selected_nodes(tokens2)

copy_nodes(tokens2, 'object', 'new_object')

tokens3 = copy_nodes(tokens2, 'object', 'new_object', copy_fill=TRUE)


if (interactive()) plot_tree(tokens3, token, pos)

</code></pre>

<hr>
<h2 id='custom_fill'>Specify custom fill behavior</h2><span id='topic+custom_fill'></span>

<h3>Description</h3>

<p>If a tquery(), parents() or children() function has set a label, all children of the matched node (that are not matched by another query) will also be given this label.
This is called the 'fill' heuristic.
The custom_fill() function can be used to give more specific conditions for which children need to be labeled.
</p>
<p>The function can be used almost identically to the children() function. The specification of the look-up conditions works in the same way.
NOTE that custom_fill, just like the children() function, should be passed as an unnamed argument, and NOT to the 'fill' argument 
(which is the boolean argument for whether fill should be used)
</p>
<p>For the custom_fill function, the special BREAK() look-up function is particularly powerful.
custom_fill will recursively search for children, children of children, etc.
The look-up conditions in custom_fill determine which of all these direct and indirect children to label.
Often, however, you would want to the recursive loop to 'break' when certain conditions are met.
For instance, to ignore children in a relative clause: custom_fill(BREAK(relation = 'relcl'))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_fill(
  ...,
  g_id = NULL,
  depth = Inf,
  connected = FALSE,
  max_window = c(Inf, Inf),
  min_window = c(0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_fill_+3A_...">...</code></td>
<td>
<p>Accepts two types of arguments: name-value pairs for finding nodes (i.e. rows), and functions to look for parents/children of these nodes.
</p>
<p>The name in the name-value pairs need to match a column in the data.table, and the value needs to be a vector of the same data type as the column.
By default, search uses case sensitive matching, with the option of using common wildcards (* for any number of characters, and ? for a single character).
Alternatively, flags can be used to to change this behavior to 'fixed' (__F), 'igoring case' (__I) or 'regex' (__R). See details for more information. 
</p>
<p>If multiple name-value pairs are given, they are considered as AND statements, but see details for syntax on using OR statements, and combinations.
</p>
<p>To look for parents and children of the nodes that are found, you can use the <a href="#topic+parents">parents</a> and <a href="#topic+children">children</a> functions as (named or unnamed) arguments. 
These functions have the same query arguments as tquery, but with some additional arguments.</p>
</td></tr>
<tr><td><code id="custom_fill_+3A_g_id">g_id</code></td>
<td>
<p>Find nodes by global id, which is the combination of the doc_id, sentence and token_id. Passed as a data.frame or data.table with 3 columns: (1) doc_id, (2) sentence and (3) token_id.</p>
</td></tr>
<tr><td><code id="custom_fill_+3A_depth">depth</code></td>
<td>
<p>A positive integer, determining how deep parents/children are sought. 1 
means that only direct parents and children of the node are retrieved. 2 means children and grandchildren, etc.
All parents/children must meet the filtering conditions (... or g_id)</p>
</td></tr>
<tr><td><code id="custom_fill_+3A_connected">connected</code></td>
<td>
<p>Controls behavior if depth &gt; 1 and filters are used. If FALSE, all parents/children to the given depth are retrieved, and then filtered. 
This way, grandchildren that satisfy the filter conditions are retrieved even if their parents do not satisfy the conditions.
If TRUE, the filter is applied at each level of depth, so that only fully connected branches of nodes that satisfy the conditions are retrieved.</p>
</td></tr>
<tr><td><code id="custom_fill_+3A_max_window">max_window</code></td>
<td>
<p>Set the max token distance of the children/parents to the node. Has to be either a numerical vector of length 1 for distance in both directions, or a 
vector of length 2, where the first value is the max distance to the left, and the second value the max distance to the right. Default is c(Inf, Inf) meaning that no max distance is used.</p>
</td></tr>
<tr><td><code id="custom_fill_+3A_min_window">min_window</code></td>
<td>
<p>Like max_window, but for the min distance. Default is c(0,0) meaning that no min is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Should not be used outside of <a href="#topic+tquery">tquery</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

## custom fill rule that ignores relative clauses
no_relcl_fill = custom_fill(BREAK(relation='relcl'))

## add custom fill as argument in children(). NOTE that it should be
## passed as an unnamed argument (and not to the fill boolean argument)
tq = tquery(label = 'verb', pos='VERB', fill=FALSE,
         children(label = 'subject', relation = 'nsubj', no_relcl_fill),
         children(label = 'object', relation = 'dobj', no_relcl_fill))
         
tokens = annotate_tqueries(tokens, "clause", tq)
tokens
</code></pre>

<hr>
<h2 id='dutch'>Dutch lemma</h2><span id='topic+dutch'></span>

<h3>Description</h3>

<p>Various categories of lemma, for use in syntax queries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dutch)
</code></pre>


<h3>Format</h3>

<p>list
</p>

<hr>
<h2 id='fill'>Specify custom fill behavior</h2><span id='topic+fill'></span>

<h3>Description</h3>

<p>This is soft deprecated, with the new preferred function being custom_fill to avoid namespace conflicts with tidyr::fill() and data.table::fill()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_...">...</code></td>
<td>
<p>passes to custom_fill</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Should not be used outside of <a href="#topic+tquery">tquery</a>
</p>

<hr>
<h2 id='get_branch_id'>Add the branch id as a column to the tokenindex</h2><span id='topic+get_branch_id'></span>

<h3>Description</h3>

<p>After splitting trees into branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_branch_id(tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_branch_id_+3A_tokens">tokens</code></td>
<td>
<p>A tokenindex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the tokenindex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]
tokens = as_tokenindex(tokens)


tokens2 = isolate_branch(tokens, relation = 'relcl', copy_parent = TRUE)
get_branch_id(tokens2)

</code></pre>

<hr>
<h2 id='get_long_ids'>Get ids in various forms to extract token_ids</h2><span id='topic+get_long_ids'></span>

<h3>Description</h3>

<p>Get ids in various forms to extract token_ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_long_ids(..., select = NULL, with_fill = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_long_ids_+3A_...">...</code></td>
<td>
<p>Either a data.table with the columns doc_id, sentence and token_id, or the output of <a href="#topic+apply_queries">apply_queries</a></p>
</td></tr>
<tr><td><code id="get_long_ids_+3A_select">select</code></td>
<td>
<p>If not null, a character vector for selecting column names</p>
</td></tr>
<tr><td><code id="get_long_ids_+3A_with_fill">with_fill</code></td>
<td>
<p>If TRUE, include the ids of the fill nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the columns doc_id, sentence and token_id
</p>

<hr>
<h2 id='get_nodes'>Transform the nodes to long format and match with token data</h2><span id='topic+get_nodes'></span>

<h3>Description</h3>

<p>Transform the nodes to long format and match with token data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nodes(tokens, nodes, use = NULL, token_cols = c("token"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nodes_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>.</p>
</td></tr>
<tr><td><code id="get_nodes_+3A_nodes">nodes</code></td>
<td>
<p>A data.table, as created with <a href="#topic+apply_queries">apply_queries</a>. Can be a list of multiple data.tables.</p>
</td></tr>
<tr><td><code id="get_nodes_+3A_use">use</code></td>
<td>
<p>Optionally, specify which columns from nodes to add. Other than convenient, this is slighly different 
from subsetting the columns in 'nodes' beforehand if fill is TRUE. When the children are collected,
the ids from the not-used columns are still blocked (see 'block')</p>
</td></tr>
<tr><td><code id="get_nodes_+3A_token_cols">token_cols</code></td>
<td>
<p>A character vector, specifying which columns from tokens to include in the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the nodes in long format, and the specified token_cols attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

nodes = apply_queries(tokens, pas=passive, act=active)
get_nodes(tokens, nodes)
</code></pre>

<hr>
<h2 id='isolate_branch'>Isolate a branch in a dependency tree</h2><span id='topic+isolate_branch'></span>

<h3>Description</h3>

<p>cuts of a branch at the nodes that match the lookup arguents (...).
A &quot;tree_parent&quot; column is added to the tokenindex, that indicates for the new roots
which node the parent was.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolate_branch(tokens, ..., copy_parent = TRUE, copy_parent_fill = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolate_branch_+3A_tokens">tokens</code></td>
<td>
<p>A tokenindex</p>
</td></tr>
<tr><td><code id="isolate_branch_+3A_...">...</code></td>
<td>
<p>lookup arguments to find the node to split. For example, isolate_branch(tokens, relation='relcl') 
isolates branches of which the top node (the new root) has the relation &quot;relcl&quot;.</p>
</td></tr>
<tr><td><code id="isolate_branch_+3A_copy_parent">copy_parent</code></td>
<td>
<p>If TRUE (default) copy the parent of the branch and include it in the isolated branch</p>
</td></tr>
<tr><td><code id="isolate_branch_+3A_copy_parent_fill">copy_parent_fill</code></td>
<td>
<p>If TRUE, also copy the parents fill nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the tokenindex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]
tokens = as_tokenindex(tokens)

tokens2 = isolate_branch(tokens, relation = 'relcl', copy_parent = TRUE)
tokens2

if (interactive()) plot_tree(tokens2)

</code></pre>

<hr>
<h2 id='mutate_nodes'>Mutate nodes</h2><span id='topic+mutate_nodes'></span>

<h3>Description</h3>

<p>Mutate nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_nodes(.tokens, node, ..., subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
<tr><td><code id="mutate_nodes_+3A_node">node</code></td>
<td>
<p>The name of the node that is to be mutated</p>
</td></tr>
<tr><td><code id="mutate_nodes_+3A_...">...</code></td>
<td>
<p>named arguments. The name should be a column in tokens</p>
</td></tr>
<tr><td><code id="mutate_nodes_+3A_subset">subset</code></td>
<td>
<p>A subset expression (that evaluates to a logical vector). The token column for each labeled node in the tquery can be referred to as label$column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(relation = "relcl", label = "relative_clause")

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

## as an example, we make the parent of the relative_clause
## nodes NA, effectively cutting of the relcl from the tree
tokens2 = mutate_nodes(tokens2, "relative_clause", parent=NA)

tokens2
</code></pre>

<hr>
<h2 id='nested_nodes'>Search for parents or children in tquery</h2><span id='topic+nested_nodes'></span><span id='topic+children'></span><span id='topic+not_children'></span><span id='topic+parents'></span><span id='topic+not_parents'></span>

<h3>Description</h3>

<p>Enables searching for parents or children.
Should only be used inside of the <a href="#topic+tquery">tquery</a> function, or within other children/parents functions.
Look-up conditions are specified in the same way as in the tquery function.
</p>
<p>Multiple children() or parents() functions can be nested side by side.
This works as an AND condition: the node must have all these parents/children (unless the req [required] argument is set to FALSE).
</p>
<p>The custom_fill() function is used to include the children of a 'labeled' node. It can only be nested in a query if the label argument is not NULL,
and by default will include all children of the node that have not been assigned to another node. If two nodes have a shared child, the child will be
assigned to the closest node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>children(
  ...,
  g_id = NULL,
  label = NA,
  req = TRUE,
  depth = 1,
  connected = FALSE,
  fill = TRUE,
  block = FALSE,
  max_window = c(Inf, Inf),
  min_window = c(0, 0)
)

not_children(
  ...,
  g_id = NULL,
  depth = 1,
  connected = FALSE,
  max_window = c(Inf, Inf),
  min_window = c(0, 0)
)

parents(
  ...,
  g_id = NULL,
  label = NA,
  req = TRUE,
  depth = 1,
  connected = FALSE,
  fill = TRUE,
  block = FALSE,
  max_window = c(Inf, Inf),
  min_window = c(0, 0)
)

not_parents(
  ...,
  g_id = NULL,
  depth = 1,
  connected = FALSE,
  max_window = c(Inf, Inf),
  min_window = c(0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_nodes_+3A_...">...</code></td>
<td>
<p>Accepts two types of arguments: name-value pairs for finding nodes (i.e. rows), and functions to look for parents/children of these nodes.
</p>
<p>The name in the name-value pairs need to match a column in the data.table, and the value needs to be a vector of the same data type as the column.
By default, search uses case sensitive matching, with the option of using common wildcards (* for any number of characters, and ? for a single character).
Alternatively, flags can be used to to change this behavior to 'fixed' (__F), 'igoring case' (__I) or 'regex' (__R). See details for more information. 
</p>
<p>If multiple name-value pairs are given, they are considered as AND statements, but see details for syntax on using OR statements, and combinations.
</p>
<p>To look for parents and children of the nodes that are found, you can use the <a href="#topic+parents">parents</a> and <a href="#topic+children">children</a> functions as (named or unnamed) arguments. 
These functions have the same query arguments as tquery, but with some additional arguments.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_g_id">g_id</code></td>
<td>
<p>Find nodes by global id, which is the combination of the doc_id, sentence and token_id. Passed as a data.frame or data.table with 3 columns: (1) doc_id, (2) sentence and (3) token_id.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_label">label</code></td>
<td>
<p>A character vector, specifying the column name under which the selected tokens are returned. 
If NA, the column is not returned.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_req">req</code></td>
<td>
<p>Can be set to false to not make a node 'required'. This can be used to include optional nodes in queries. For instance, in a query for finding subject - verb - object triples, 
make the object optional.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_depth">depth</code></td>
<td>
<p>A positive integer, determining how deep parents/children are sought. 1 
means that only direct parents and children of the node are retrieved. 2 means children and grandchildren, etc.
All parents/children must meet the filtering conditions (... or g_id)</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_connected">connected</code></td>
<td>
<p>Controls behavior if depth &gt; 1 and filters are used. If FALSE, all parents/children to the given depth are retrieved, and then filtered. 
This way, grandchildren that satisfy the filter conditions are retrieved even if their parents do not satisfy the conditions.
If TRUE, the filter is applied at each level of depth, so that only fully connected branches of nodes that satisfy the conditions are retrieved.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_fill">fill</code></td>
<td>
<p>Logical. If TRUE (default), the default custom_fill() will be used. To more specifically control fill, you can nest the <a href="#topic+custom_fill">custom_fill</a> 
function (a special version of the children function).</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_block">block</code></td>
<td>
<p>Logical. If TRUE, the node will be blocked from being assigned (labeld). This is mainly usefull if you have a node that you do not want to be assigned by fill,
but also don't want to 'label' it. Essentially, block is shorthand for using label and then removing the node afterwards. If block is TRUE, label has to be NA.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_max_window">max_window</code></td>
<td>
<p>Set the max token distance of the children/parents to the node. Has to be either a numerical vector of length 1 for distance in both directions, or a 
vector of length 2, where the first value is the max distance to the left, and the second value the max distance to the right. Default is c(Inf, Inf) meaning that no max distance is used.</p>
</td></tr>
<tr><td><code id="nested_nodes_+3A_min_window">min_window</code></td>
<td>
<p>Like max_window, but for the min distance. Default is c(0,0) meaning that no min is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Having nested queries can be confusing, so we tried to develop the find_nodes function and the accompanying functions in a way
that clearly shows the different levels. As shown in the examples, the idea is that each line is a node, and to look for parents
or children, we put them on the next line with indentation (in RStudio, it should automatically align correctly when you press enter inside
of the children() or parents() functions). 
</p>
<p>There are several flags that can be used to change search condition. To specify flags, add a double underscore and the flag character to the name in the name value pairs (...).
By adding the suffix __R, query terms are considered to be regular expressions, and the suffix __I uses case insensitive search (for normal or regex search).
If the suffix __F is used, only exact matches are valid (case sensitive, and no wildcards).
Multiple flags can be combined, such as lemma__RI, or lemma__IR  (order of flags is irrelevant)
</p>
<p>The not_children and not_parents functions will make the matched children/parents a NOT condition. Note that this is different from using the NOT() look-up function.
NOT operates at the node level, so you specify that a node should NOT be matched if certain conditions are met. the not_parents and not_children functions operate 
at the pattern level, so you can specify that a pattern is invalid if these parents/children are matched.
</p>
<p>Next to the OR, AND, and NOT functions, children/parents functions can have the special BREAK function for cases where depth &gt; 1.
If depth &gt; 1 in the children, parents or fill function, the children/parents will
be retrieved recursively (i.e. children, children of children, etc.).
If the look-up conditions (e.g., relation = 'nsubj') are not satisfied, a node 
will not be matched by the query, but the search will still continue for it's
parents/children. The special BREAK look-up function allows you to specify a condition
for breaking the recursive loop (lending it's name from the 'break' in a for loop).
An example is that you might want to stop the recursive loop in a custom_fill() once it encounters
a nested sentence, such as a relative clause: custom_fill(BREAK(relation = 'relcl')).
</p>


<h3>Value</h3>

<p>Should not be used outside of <a href="#topic+tquery">tquery</a>
</p>

<hr>
<h2 id='NOT'>Use NOT search in tquery</h2><span id='topic+NOT'></span>

<h3>Description</h3>

<p>Use NOT search in tquery
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOT(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOT_+3A_...">...</code></td>
<td>
<p>name-value pairs for look-up terms. see ?query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, to be used as input to <a href="#topic+tquery">tquery</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tquery(NOT(POS='Noun'))  
</code></pre>

<hr>
<h2 id='OR'>Use OR search in tquery</h2><span id='topic+OR'></span>

<h3>Description</h3>

<p>Use OR search in tquery
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OR(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OR_+3A_...">...</code></td>
<td>
<p>name-value pairs for look-up terms. see ?query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, to be used as input to <a href="#topic+tquery">tquery</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tquery(OR(lemma = 'walk', POS='Noun'))
</code></pre>

<hr>
<h2 id='plot_tree'>Create an igraph tree from a sentence</h2><span id='topic+plot_tree'></span>

<h3>Description</h3>

<p>Create an igraph tree from a token_index (<a href="#topic+as_tokenindex">as_tokenindex</a>) or a data.frame that can be coerced to a tokenindex.
</p>
<p>By default, all columns in the data are included as labels. This can be changes by using the ... argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree(
  tokens,
  ...,
  sentence_i = 1,
  doc_id = NULL,
  sentence = NULL,
  annotation = NULL,
  only_annotation = FALSE,
  pdf_file = NULL,
  allign_text = TRUE,
  ignore_rel = NULL,
  all_lower = FALSE,
  all_abbrev = NULL,
  textsize = 1,
  spacing = 1,
  use_color = TRUE,
  max_curve = 0.3,
  palette = grDevices::terrain.colors,
  rel_on_edge = F,
  pdf_viewer = FALSE,
  viewer_mode = TRUE,
  viewer_size = c(100, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tree_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>. Can also be a corpustools tCorpus.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_...">...</code></td>
<td>
<p>Optionally, select which columns to include as labels and how to present them. Can be quoted or unquoted names and expressions, using columns in the tokenIndex. For example, plot_tree(tokens, token, pos) will use the $token and $pos columns in tokens. You can also use expressions for easy controll of visulizations. For example: plot_tree(tokens, tolower(token), abbreviate(pos,1)). (note that abbreviate() is really usefull here)</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_sentence_i">sentence_i</code></td>
<td>
<p>By default, plot_tree uses the first sentence (sentence_i = 1) in the data. sentence_i can be changed to select other sentences by position (the i-th unique sentence in the data). Note that sentence_i does not refer to the values in the sentence column (for this use the sentence argument together with doc_id)</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_doc_id">doc_id</code></td>
<td>
<p>Optionally, the document id can be specified. If so, sentence_i refers to the i-th sentence within the given document.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_sentence">sentence</code></td>
<td>
<p>Optionally, the sentence id can be specified (note that sentence_i refers to the position). If sentence is given, doc_id has to be given as well.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_annotation">annotation</code></td>
<td>
<p>Optionally, a column with an rsyntax annotation, to add boxes around the annotated nodes.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_only_annotation">only_annotation</code></td>
<td>
<p>If annotation is given, only_annotation = TRUE will print only the nodes with annotations.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_pdf_file">pdf_file</code></td>
<td>
<p>Directly save the plot as a pdf file</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_allign_text">allign_text</code></td>
<td>
<p>If TRUE (default) allign text (the columns specified in ...) in a single horizontal line at the bottom, instead of following the different levels in the tree</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_ignore_rel">ignore_rel</code></td>
<td>
<p>Optionally, a character vector with relation names that will not be shown in the tree</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_all_lower">all_lower</code></td>
<td>
<p>If TRUE, make all text lowercase</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_all_abbrev">all_abbrev</code></td>
<td>
<p>If an integer, abbreviate all text, with the number being the target number of characters.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_textsize">textsize</code></td>
<td>
<p>A number to manually change the textsize. The function tries to set a suitable textsize for the plotting device, but if this goes wrong and now everything is broken and sad, you can multiply the textsize with the given number.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_spacing">spacing</code></td>
<td>
<p>A number for scaling the distance between words (between 0 and infinity)</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_use_color">use_color</code></td>
<td>
<p>If true, use colors</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_max_curve">max_curve</code></td>
<td>
<p>A number for controlling the allowed amount of curve in the edges.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_palette">palette</code></td>
<td>
<p>A function for creating a vector of n contiguous colors. See ?terrain.colors for standard functions and documentation</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_rel_on_edge">rel_on_edge</code></td>
<td>
<p>If TRUE, print relation label on edge instead of above the node</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_pdf_viewer">pdf_viewer</code></td>
<td>
<p>If TRUE, view the plot as a pdf. If no pdf_file is specified, the pdf will be saved to the temp folder</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_viewer_mode">viewer_mode</code></td>
<td>
<p>By default, the plot is saved as a PNG embedded in a HTML and opened in the viewer. This hack makes it independent of the 
size of the plotting device and enables scrolling. By setting viewer_mode to False, the current plotting device is used.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_viewer_size">viewer_size</code></td>
<td>
<p>A vector of length 2, that multiplies the width (first value) and height (second value) of the viewer_mode PNG</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots a dependency tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]


if (interactive()) plot_tree(tokens, token, pos)

## plot with annotations
direct = tquery(label = 'verb', pos = 'VERB', fill=FALSE,
                children(label = 'subject', relation = 'nsubj'),
                children(label = 'object', relation = 'dobj'))
passive = tquery(label = 'verb', pos = 'VERB', fill=FALSE,
                 children(label = 'subject', relation = 'agent'),
                 children(label = 'object', relation = 'nsubjpass'))
 
if (interactive()) {                
tokens %&gt;%
   annotate_tqueries('clause', pas=passive, dir=direct) %&gt;%
   plot_tree(token, pos, annotation='clause')
}

</code></pre>

<hr>
<h2 id='print.tQuery'>S3 print for tQuery class</h2><span id='topic+print.tQuery'></span>

<h3>Description</h3>

<p>S3 print for tQuery class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tQuery'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tQuery_+3A_x">x</code></td>
<td>
<p>a tQuery</p>
</td></tr>
<tr><td><code id="print.tQuery_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>q = tquery(label='quote',
           children(relation='nmod:according_to', label='source',
                    children(label='verb')))
q 
</code></pre>

<hr>
<h2 id='quote_punctuation'>Quote punctuation</h2><span id='topic+quote_punctuation'></span>

<h3>Description</h3>

<p>Punctuation used in quotes, for use in syntax queries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quote_punctuation)
</code></pre>


<h3>Format</h3>

<p>character()
</p>

<hr>
<h2 id='remove_fill'>Remove fill</h2><span id='topic+remove_fill'></span>

<h3>Description</h3>

<p>Like remove_nodes, but only removing the fill nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_fill(
  .tokens,
  node,
  rm_subset_fill = NULL,
  rm_subset = NULL,
  keep_shared = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_fill_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
<tr><td><code id="remove_fill_+3A_node">node</code></td>
<td>
<p>The name of the node that is to be mutated</p>
</td></tr>
<tr><td><code id="remove_fill_+3A_rm_subset_fill">rm_subset_fill</code></td>
<td>
<p>A subset on the fill nodes. Can only directly use token column. For example, use pos == 'VERB' to remove only verbs</p>
</td></tr>
<tr><td><code id="remove_fill_+3A_rm_subset">rm_subset</code></td>
<td>
<p>A subset expression (that evaluates to a logical vector) to more specifically specify which nodes to remove. The token column for each labeled node in the tquery can be referred to as label$column.</p>
</td></tr>
<tr><td><code id="remove_fill_+3A_keep_shared">keep_shared</code></td>
<td>
<p>If there is another node that has the same fill nodes, should the fill nodes that are shared also be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text1',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(pos = 'VERB',
            children(label = 'object', relation='dobj'))

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

remove_fill(tokens2, 'object')
</code></pre>

<hr>
<h2 id='remove_nodes'>Remove nodes</h2><span id='topic+remove_nodes'></span>

<h3>Description</h3>

<p>Remove nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_nodes(
  .tokens,
  node,
  rm_subset = NULL,
  with_fill = TRUE,
  rm_subset_fill = NULL,
  keep_shared = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_node">node</code></td>
<td>
<p>The name of the node that is to be mutated</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_rm_subset">rm_subset</code></td>
<td>
<p>A subset expression (that evaluates to a logical vector) to more specifically specify which nodes to remove. The token column for each labeled node in the tquery can be referred to as label$column.</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_with_fill">with_fill</code></td>
<td>
<p>If TRUE, also remove the fill nodes</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_rm_subset_fill">rm_subset_fill</code></td>
<td>
<p>A subset on the fill nodes. Can only directly use token column. For example, use pos == 'VERB' to remove only verbs</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_keep_shared">keep_shared</code></td>
<td>
<p>If there is another node that has the same fill nodes, should the fill nodes that are shared also be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text1',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(pos = 'VERB',
            children(label = 'object', relation='dobj'))

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

remove_nodes(tokens2, 'object')
remove_nodes(tokens2, 'object', with_fill=FALSE)
</code></pre>

<hr>
<h2 id='reselect_nodes'>Within a chain of reshape operations, reapply the tquery</h2><span id='topic+reselect_nodes'></span>

<h3>Description</h3>

<p>Within a chain of reshape operations, reapply the tquery
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reselect_nodes(.tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reselect_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(relation = "relcl", label = "relative_clause")

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

## reuses the tq, that is stored in tokens2
## this makes it easy to make the selection anew after a transformation
tokens2 = reselect_nodes(tokens2)
</code></pre>

<hr>
<h2 id='rsyntax_threads'>Get the number of threads to be used by rsyntax functions</h2><span id='topic+rsyntax_threads'></span>

<h3>Description</h3>

<p>rsyntax relies heavily on the data.table package, which supports multithreading. 
By default, the number of threads set by data.table are used, as you can see with <code><a href="data.table.html#topic+getDTthreads">getDTthreads</a></code>.
With <code><a href="#topic+set_rsyntax_threads">set_rsyntax_threads</a></code> you can set the number of threads for rsyntax functions, without affecting the data.table settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsyntax_threads()
</code></pre>


<h3>Value</h3>

<p>the setting for the number of threads used by rsyntax
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rsyntax_threads()
</code></pre>

<hr>
<h2 id='select_nodes'>Apply tquery to initiate reshape operations</h2><span id='topic+select_nodes'></span>

<h3>Description</h3>

<p>Apply tquery to initiate reshape operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_nodes(
  tokens,
  tquery,
  fill = TRUE,
  fill_only_first = TRUE,
  .one_per_sentence = FALSE,
  .order = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_nodes_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with <a href="#topic+as_tokenindex">as_tokenindex</a>.</p>
</td></tr>
<tr><td><code id="select_nodes_+3A_tquery">tquery</code></td>
<td>
<p>A <a href="#topic+tquery">tquery</a> that selects and labels the nodes that are used in the reshape operations</p>
</td></tr>
<tr><td><code id="select_nodes_+3A_fill">fill</code></td>
<td>
<p>Logical, should fill be used?</p>
</td></tr>
<tr><td><code id="select_nodes_+3A_fill_only_first">fill_only_first</code></td>
<td>
<p>Logical, should a node only be filled once, with the nearest (first) labeled node?</p>
</td></tr>
<tr><td><code id="select_nodes_+3A_.one_per_sentence">.one_per_sentence</code></td>
<td>
<p>If true, only one match per sentence is used, giving priority to paterns closest to the root (or fartest from the root if .order = -1). 
This is sometimes necessary to deal with recursion.</p>
</td></tr>
<tr><td><code id="select_nodes_+3A_.order">.order</code></td>
<td>
<p>If .one_per_sentence is used, .order determines whether the paterns closest to (1) or farthest away (-1) are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute, that enables the use of reshape operations on the selected nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(relation = "relcl", label = "relative_clause")

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

## as an example, we make the parent of the relative_clause
## nodes NA, effectively cutting of the relcl from the tree
tokens2 = mutate_nodes(tokens2, "relative_clause", parent=NA)

tokens2


if (interactive()) plot_tree(tokens2)

## this is designed to work nicely with magrittr piping
if (interactive()) {
tokens %&gt;%
  select_nodes(tq) %&gt;%
  mutate_nodes("relative_clause", parent=NA) %&gt;%
  plot_tree()
}

</code></pre>

<hr>
<h2 id='selected_nodes'>If select_nodes() is used, the selected nodes can be extracted with selected_nodes().
This is mainly for internal use, but it can also be usefull for debugging, and to controll
loops of reshape operation (e.g. break if no selected nodes left)</h2><span id='topic+selected_nodes'></span>

<h3>Description</h3>

<p>If select_nodes() is used, the selected nodes can be extracted with selected_nodes().
This is mainly for internal use, but it can also be usefull for debugging, and to controll
loops of reshape operation (e.g. break if no selected nodes left)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selected_nodes(.tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selected_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(relation = "relcl", label = "relative_clause")

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

## Get selected nodes from tokenindex
selected_nodes(tokens2)
</code></pre>

<hr>
<h2 id='set_rsyntax_threads'>Set number of threads to be used by rsyntax functions</h2><span id='topic+set_rsyntax_threads'></span>

<h3>Description</h3>

<p>rsyntax relies heavily on the data.table package, which supports multithreading. 
By default, the number of threads set by data.table are used, as you can see with <code><a href="data.table.html#topic+getDTthreads">getDTthreads</a></code>.
Here you can set the number of threads for rsyntax functions, without affecting the data.table settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_rsyntax_threads(threads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_rsyntax_threads_+3A_threads">threads</code></td>
<td>
<p>The number of threads to use. Cannot be higher than number of threads used by data.table, which you can change with <code><a href="data.table.html#topic+setDTthreads">setDTthreads</a></code>. If left empty (NULL), all data.table threads are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return a value. Sets the global 'rsyntax_threads' option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>current_threads = rsyntax_threads()

set_rsyntax_threads(2)

## undo change (necessary for CRAN checks)
set_rsyntax_threads(current_threads)
</code></pre>

<hr>
<h2 id='split_UD_conj'>Split conjunctions for dependency trees in Universal Dependencies</h2><span id='topic+split_UD_conj'></span>

<h3>Description</h3>

<p>Split conjunctions for dependency trees in Universal Dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_UD_conj(
  tokens,
  conj_rel = "conj",
  cc_rel = c("cc", "cc:preconj"),
  unpack = T,
  no_fill = NULL,
  min_dist = 0,
  max_dist = Inf,
  right_fill_dist = T,
  compound_rel = c("compound*", "flat"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_UD_conj_+3A_tokens">tokens</code></td>
<td>
<p>a tokenIndex based on texts parsed with <code><a href="spacyr.html#topic+spacy_parse">spacy_parse</a></code> (with dependency=TRUE)</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_conj_rel">conj_rel</code></td>
<td>
<p>The dependency relation for conjunctions. By default conj</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_cc_rel">cc_rel</code></td>
<td>
<p>The dependency relation for the coordinating conjunction. By default cc. This will be removed.</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_unpack">unpack</code></td>
<td>
<p>If TRUE (default), create separate branches for the parent and the node that inherits the parent position</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_no_fill">no_fill</code></td>
<td>
<p>Optionally, a character vector with relation types that will be excluded from fill</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_min_dist">min_dist</code></td>
<td>
<p>Optionally, a minimal distance between the conj node and its parent</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_max_dist">max_dist</code></td>
<td>
<p>Optionally, a maximum distance between the conj node and its parent</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_right_fill_dist">right_fill_dist</code></td>
<td>
<p>Should fill to the right of the conjunction be used?</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_compound_rel">compound_rel</code></td>
<td>
<p>The relation types indicating compounds</p>
</td></tr>
<tr><td><code id="split_UD_conj_+3A_...">...</code></td>
<td>
<p>specify conditions for the conjunction token. For instance, using 'pos = &quot;VERB&quot;' to only split VERB conjunctions.
This is especially usefull to use different no_fill conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenindex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text5',]

if (interactive()) {
tokens %&gt;%
   split_UD_conj() %&gt;%
   plot_tree()
}
</code></pre>

<hr>
<h2 id='subset_nodes'>Subset a select_nodes selection</h2><span id='topic+subset_nodes'></span>

<h3>Description</h3>

<p>Enables more control in reshape operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_nodes(.tokens, subset, copy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
<tr><td><code id="subset_nodes_+3A_subset">subset</code></td>
<td>
<p>A subset expression (that evaluates to a logical vector). The token column for each labeled node in the tquery can be referred to as label$column.</p>
</td></tr>
<tr><td><code id="subset_nodes_+3A_copy">copy</code></td>
<td>
<p>If TRUE, make a deep copy of .tokens. Use if output does not overwrite .tokens</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex with a .nodes attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

## use a tquery to label the nodes that you want to manipulate
tq = tquery(label='verb', children(relation='nsubj'))

## apply query to select nodes
tokens2 = select_nodes(tokens, tq) 

selected_nodes(tokens2)$nodes
tokens2 = subset_nodes(tokens2, verb$relation == 'ROOT')
selected_nodes(tokens2)$nodes
</code></pre>

<hr>
<h2 id='syntax_reader'>Create a full text browser with highlighted rsyntax annotations</h2><span id='topic+syntax_reader'></span>

<h3>Description</h3>

<p>Create a full text browser with highlighted rsyntax annotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syntax_reader(
  tokens,
  annotation,
  value = NULL,
  value2 = NULL,
  meta = NULL,
  token_col = "token",
  filename = NULL,
  view = TRUE,
  random_seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syntax_reader_+3A_tokens">tokens</code></td>
<td>
<p>A tokenIndex</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_annotation">annotation</code></td>
<td>
<p>The name of the column that contains the rsyntax annotation</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_value">value</code></td>
<td>
<p>Optionally, a character vector with values in annotation. If used, only these values are fully colored, and the other (non NA) values only have border colors.</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_value2">value2</code></td>
<td>
<p>Optionally, a character vector with values in annotation other than those specified in 'value'. If used, only these values have border colors.</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_meta">meta</code></td>
<td>
<p>Optionally, a data.frame with document meta data. Has to have a column named doc_id of which the values match with the doc_id column in tokens</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_token_col">token_col</code></td>
<td>
<p>The name of the column in tokens with the token text</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_filename">filename</code></td>
<td>
<p>Optionally, a filename to directly save the file. If not specified, a temporary file is created</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_view">view</code></td>
<td>
<p>If TRUE, the browser will immediatly be viewed in the viewer panel</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_random_seed">random_seed</code></td>
<td>
<p>If a number is given, it is used as a seed to randomize the order of documents. This is usefull for
validations purposes, because the doc_id in the tokenindex is sorted.</p>
</td></tr>
<tr><td><code id="syntax_reader_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="tokenbrowser.html#topic+create_browser">create_browser</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The url for the file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                children(relation = c("nsubj", "nsubjpass"), label = "subject"))



tokens = annotate_tqueries(tokens, 'clause', pas=passive, act=active)
syntax_reader(tokens, annotation = 'clause', value = 'subject')

</code></pre>

<hr>
<h2 id='tokens_corenlp'>Example tokens for coreNLP English</h2><span id='topic+tokens_corenlp'></span>

<h3>Description</h3>

<p>Example tokens for coreNLP English
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tokens_corenlp)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='tokens_dutchclauses'>Example tokens for Dutch clauses</h2><span id='topic+tokens_dutchclauses'></span>

<h3>Description</h3>

<p>Example tokens for Dutch clauses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tokens_dutchclauses)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='tokens_dutchquotes'>Example tokens for Dutch quotes</h2><span id='topic+tokens_dutchquotes'></span>

<h3>Description</h3>

<p>Example tokens for Dutch quotes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tokens_dutchquotes)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='tokens_spacy'>Example tokens for spacy English</h2><span id='topic+tokens_spacy'></span>

<h3>Description</h3>

<p>Example tokens for spacy English
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tokens_spacy)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='tquery'>Create a query for dependency based parse trees in a data.table (CoNLL-U or similar format).</h2><span id='topic+tquery'></span>

<h3>Description</h3>

<p>To find nodes you can use named arguments, where the names are column names (in the data.table on which the
queries will be used) and the values are vectors with look-up values. 
</p>
<p>Children or parents of nodes can be queried by passing the <a href="#topic+children">children</a> or <a href="#topic+parents">parents</a> function as (named or unnamed) arguments.
These functions use the same query format as the tquery function, and children and parents can be nested recursively to find children of children etc. 
</p>
<p>The custom_fill() function (also see fill argument) can be nested to customize which children of a 'labeled' node need to be matched. It can only be nested in a query if the label argument is not NULL,
and by default will include all children of the node that have not been assigned to another node. If two nodes have a shared child, the child will be
assigned to the closest node. 
</p>
<p>Please look at the examples below for a recommended syntactic style for using the find_nodes function and these nested functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tquery(..., g_id = NULL, label = NA, fill = TRUE, block = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tquery_+3A_...">...</code></td>
<td>
<p>Accepts two types of arguments: name-value pairs for finding nodes (i.e. rows), and functions to look for parents/children of these nodes.
</p>
<p>The name in the name-value pairs need to match a column in the data.table, and the value needs to be a vector of the same data type as the column.
By default, search uses case sensitive matching, with the option of using common wildcards (* for any number of characters, and ? for a single character).
Alternatively, flags can be used to to change this behavior to 'fixed' (__F), 'igoring case' (__I) or 'regex' (__R). See details for more information. 
</p>
<p>If multiple name-value pairs are given, they are considered as AND statements, but see details for syntax on using OR statements, and combinations.
</p>
<p>To look for parents and children of the nodes that are found, you can use the <a href="#topic+parents">parents</a> and <a href="#topic+children">children</a> functions as (named or unnamed) arguments. 
These functions have the same query arguments as tquery, but with some additional arguments.</p>
</td></tr>
<tr><td><code id="tquery_+3A_g_id">g_id</code></td>
<td>
<p>Find nodes by global id, which is the combination of the doc_id, sentence and token_id. Passed as a data.frame or data.table with 3 columns: (1) doc_id, (2) sentence and (3) token_id.</p>
</td></tr>
<tr><td><code id="tquery_+3A_label">label</code></td>
<td>
<p>A character vector, specifying the column name under which the selected tokens are returned. 
If NA, the column is not returned.</p>
</td></tr>
<tr><td><code id="tquery_+3A_fill">fill</code></td>
<td>
<p>Logical. If TRUE (default), the default custom_fill() will be used. To more specifically control fill, you can nest the <a href="#topic+custom_fill">custom_fill</a> 
function (a special version of the children function).</p>
</td></tr>
<tr><td><code id="tquery_+3A_block">block</code></td>
<td>
<p>Logical. If TRUE, the node will be blocked from being assigned (labeled). This is mainly useful if you have a node that you do not want to be assigned by fill,
but also don't want to 'label' it. Essentially, block is shorthand for using label and then removing the node afterwards. If block is TRUE, label has to be NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple values in a name-value pair operate as OR conditions.
For example, tquery(relation = c('nsubj','dobj')) means that the relation column should have the value 'nsubj' OR 'dobj'. 
</p>
<p>If multiple named arguments are given they operate as AND conditions. 
For example, tquery(relation = 'nsubj', pos = 'PROPN') means that the relation should be 'nsubj' AND the pos should be 'PROPN'.
</p>
<p>This easily combines for the most common use case, which is to select on multiple conditions (relation AND pos), but allowing different (similar) values ('PROPN' OR 'NOUN').
For example: tquery(relation = 'nsubj', pos = c('PROPN','NOUN')) means that the node should have the 'nsubj' relation, but pos can be either 'PROPN' or 'NOUN'.
</p>
<p>For more specific behavior, the AND(), OR() and NOT() functions can be used for boolean style conditions.
</p>
<p>There are several flags that can be used to change search condition. To specify flags, add a double underscore and the flag character to the name in the name value pairs (...).
By adding the suffix __R, query terms are considered to be regular expressions, and the suffix __I uses case insensitive search (for normal or regex search).
If the suffix __F is used, only exact matches are valid (case sensitive, and no wildcards).
Multiple flags can be combined, such as lemma__RI, or lemma_IR  (order of flags is irrelevant)
</p>


<h3>Value</h3>

<p>A tQuery object, that can be used with the <a href="#topic+apply_queries">apply_queries</a> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## it is convenient to first prepare vectors with relevant words/pos-tags/relations
.SAY_VERBS = c("tell", "show","say", "speak") ## etc.
.QUOTE_RELS=  c("ccomp", "dep", "parataxis", "dobj", "nsubjpass", "advcl")
.SUBJECT_RELS = c('su', 'nsubj', 'agent', 'nmod:agent') 

quotes_direct = tquery(lemma = .SAY_VERBS,
                         children(label = 'source', p_rel = .SUBJECT_RELS),
                         children(label = 'quote', p_rel = .QUOTE_RELS))
quotes_direct 
</code></pre>

<hr>
<h2 id='unselect_nodes'>Undo select_nodes</h2><span id='topic+unselect_nodes'></span>

<h3>Description</h3>

<p>Not strictly required. Only available for elegance and minor memory efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unselect_nodes(.tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unselect_nodes_+3A_.tokens">.tokens</code></td>
<td>
<p>A tokenIndex in which nodes are selected with <a href="#topic+select_nodes">select_nodes</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokenIndex (without a .nodes attribute)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokens = tokens_spacy[tokens_spacy$doc_id == 'text4',]

tq = tquery(relation = "relcl", label = "relative_clause")
tokens = select_nodes(tokens, tq) 
selected_nodes(tokens)

tokens = unselect_nodes(tokens)

is.null(attr(tokens, '.nodes'))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
