<!DOCTYPE html><html><head><title>Help for package bulletr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bulletr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot_fit_loess'><p>Fit a LOESS model with bootstrap samples</p></a></li>
<li><a href='#br411'><p>3d topological surface measurements for one land of a bullet from the Hamby study</p></a></li>
<li><a href='#bulletAlign'><p>Align two surface cross cuts according to maximal correlation</p></a></li>
<li><a href='#bulletCheckCrossCut'><p>Identifying a reliable cross section</p></a></li>
<li><a href='#bulletGetMaxCMS'><p>Identify the number of maximum CMS between two bullet lands</p></a></li>
<li><a href='#bulletGetMaxCMS_nist'><p>Identify the number of maximum CMS between two bullet lands</p></a></li>
<li><a href='#bulletSmooth'><p>Smooth the surface of a bullet</p></a></li>
<li><a href='#CMS'><p>Table of the number of consecutive matches</p></a></li>
<li><a href='#fit_loess'><p>Fit a loess curve to a bullet data frame</p></a></li>
<li><a href='#fortify_x3p'><p>Convert a list of x3p file into a data frame</p></a></li>
<li><a href='#get_bullet'><p>Deprecated function use get_crosscut</p></a></li>
<li><a href='#get_crosscut'><p>Read a crosscut from a 3d surface file</p></a></li>
<li><a href='#get_grooves'><p>Find the grooves of a bullet land</p></a></li>
<li><a href='#get_peaks'><p>Identify the location and the depth of peaks and heights at a crosscut</p></a></li>
<li><a href='#get_peaks_nist'><p>Identify the location and the depth of peaks and heights at a crosscut</p></a></li>
<li><a href='#getCircle'><p>Estimate center and radius</p></a></li>
<li><a href='#getTwist'><p>Estimate the twist in a bullet land</p></a></li>
<li><a href='#maxCMS'><p>Number of maximum consecutively matching striae</p></a></li>
<li><a href='#plot_3d_land'><p>Plot a bullet land using plotly</p></a></li>
<li><a href='#predCircle'><p>Estimate predictions and residuals for a circle fit of x and y</p></a></li>
<li><a href='#predSmooth'><p>Estimate predictions and residuals for a smooth of x and y</p></a></li>
<li><a href='#processBullets'><p>Process x3p file</p></a></li>
<li><a href='#read_x3p'><p>Read an x3p file as an R Data Frame</p></a></li>
<li><a href='#sample_x3p'><p>Sample every X element of a data frame</p></a></li>
<li><a href='#smoothloess'><p>Predict smooth from a fit</p></a></li>
<li><a href='#striation_identify'><p>Match striation marks across two cross sections based on previously identified peaks and valleys</p></a></li>
<li><a href='#unfortify_x3p'><p>Convert a data frame into an x3p file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Algorithms for Matching Bullet Lands</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2017-04-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyze bullet lands using nonparametric methods. We provide a
    reading routine for x3p files (see <a href="http://www.openfmc.org">http://www.openfmc.org</a> for more
    information) and a host of analysis functions designed to assess the
    probability that two bullets were fired from the same gun barrel.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/erichare/bulletr">https://github.com/erichare/bulletr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/erichare/bulletr/issues">https://github.com/erichare/bulletr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>xml2, zoo, ggplot2, plyr, dplyr, reshape2, plotly, robustbase,
smoother</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-04-25 23:59:38 UTC; erichare</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Hare [aut, cre],
  Heike Hofmann [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Hare &lt;erichare@iastate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-04-26 05:31:52 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot_fit_loess'>Fit a LOESS model with bootstrap samples</h2><span id='topic+boot_fit_loess'></span>

<h3>Description</h3>

<p>Fit a LOESS model with bootstrap samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_fit_loess(bullet, groove, B = 1000, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_fit_loess_+3A_bullet">bullet</code></td>
<td>
<p>Bullet as returned from fortify_x3p</p>
</td></tr>
<tr><td><code id="boot_fit_loess_+3A_groove">groove</code></td>
<td>
<p>Groove as returned from get_grooves</p>
</td></tr>
<tr><td><code id="boot_fit_loess_+3A_b">B</code></td>
<td>
<p>number of Bootstrap samples</p>
</td></tr>
<tr><td><code id="boot_fit_loess_+3A_alpha">alpha</code></td>
<td>
<p>The significance level</p>
</td></tr>
</table>

<hr>
<h2 id='br411'>3d topological surface measurements for one land of a bullet from the Hamby study</h2><span id='topic+br411'></span>

<h3>Description</h3>

<p>Some more info - not sure at the moment which bullet this is. Describe structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br411
</code></pre>


<h3>Format</h3>

<p>a list</p>

<hr>
<h2 id='bulletAlign'>Align two surface cross cuts according to maximal correlation</h2><span id='topic+bulletAlign'></span>

<h3>Description</h3>

<p>The bullet with the first name serves as a reference, the second bullet is shifted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulletAlign(data, value = "l30")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulletAlign_+3A_data">data</code></td>
<td>
<p>data frame consisting of at least two surface crosscuts as given by function <code>bulletSmooth</code>.</p>
</td></tr>
<tr><td><code id="bulletAlign_+3A_value">value</code></td>
<td>
<p>string of the variable to match. Defaults to l30, the variable returned from function <code>bulletSmooth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list consisting of a) the maximal cross correlation, b) the lag resulting in the highest cross correlation, and c) same data frame as input, but y vectors are aligned for maximal correlation between the
</p>

<hr>
<h2 id='bulletCheckCrossCut'>Identifying a reliable cross section</h2><span id='topic+bulletCheckCrossCut'></span>

<h3>Description</h3>

<p>Should be changed: x should just indicate lower and upper limit. That is cleaner and should speed things up as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulletCheckCrossCut(path, bullet = NULL, distance = 25, xlimits = c(50,
  500), minccf = 0.9, span = 0.03)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulletCheckCrossCut_+3A_path">path</code></td>
<td>
<p>path to an x3p file</p>
</td></tr>
<tr><td><code id="bulletCheckCrossCut_+3A_bullet">bullet</code></td>
<td>
<p>If passed in, the actual bullet already loaded</p>
</td></tr>
<tr><td><code id="bulletCheckCrossCut_+3A_distance">distance</code></td>
<td>
<p>positive numeric value indicating the distance between cross sections to use for a comparison</p>
</td></tr>
<tr><td><code id="bulletCheckCrossCut_+3A_xlimits">xlimits</code></td>
<td>
<p>vector of values between which to check for cross sections in a stable region</p>
</td></tr>
<tr><td><code id="bulletCheckCrossCut_+3A_minccf">minccf</code></td>
<td>
<p>minimal value of cross correlation to indicate a stable region</p>
</td></tr>
<tr><td><code id="bulletCheckCrossCut_+3A_span">span</code></td>
<td>
<p>The span for the loess smooth function</p>
</td></tr>
</table>

<hr>
<h2 id='bulletGetMaxCMS'>Identify the number of maximum CMS between two bullet lands</h2><span id='topic+bulletGetMaxCMS'></span>

<h3>Description</h3>

<p>Identify the number of maximum CMS between two bullet lands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulletGetMaxCMS(lof1, lof2, column = "resid", span = 35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulletGetMaxCMS_+3A_lof1">lof1</code></td>
<td>
<p>dataframe of smoothed first signature</p>
</td></tr>
<tr><td><code id="bulletGetMaxCMS_+3A_lof2">lof2</code></td>
<td>
<p>dataframe of smoothed second signature</p>
</td></tr>
<tr><td><code id="bulletGetMaxCMS_+3A_column">column</code></td>
<td>
<p>The column which to smooth</p>
</td></tr>
<tr><td><code id="bulletGetMaxCMS_+3A_span">span</code></td>
<td>
<p>positive number  for the smoothfactor to use for assessing peaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matching parameters, data set of the identified striae, and the aligned data sets.
</p>

<hr>
<h2 id='bulletGetMaxCMS_nist'>Identify the number of maximum CMS between two bullet lands</h2><span id='topic+bulletGetMaxCMS_nist'></span>

<h3>Description</h3>

<p>Identify the number of maximum CMS between two bullet lands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulletGetMaxCMS_nist(lof1, lof2, column = "resid", span = 35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulletGetMaxCMS_nist_+3A_lof1">lof1</code></td>
<td>
<p>dataframe of smoothed first signature</p>
</td></tr>
<tr><td><code id="bulletGetMaxCMS_nist_+3A_lof2">lof2</code></td>
<td>
<p>dataframe of smoothed second signature</p>
</td></tr>
<tr><td><code id="bulletGetMaxCMS_nist_+3A_column">column</code></td>
<td>
<p>The column which to smooth</p>
</td></tr>
<tr><td><code id="bulletGetMaxCMS_nist_+3A_span">span</code></td>
<td>
<p>positive number  for the smoothfactor to use for assessing peaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matching parameters, data set of the identified striae, and the aligned data sets.
</p>

<hr>
<h2 id='bulletSmooth'>Smooth the surface of a bullet</h2><span id='topic+bulletSmooth'></span>

<h3>Description</h3>

<p>Smooth the surface of a bullet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulletSmooth(data, span = 0.03, limits = c(-5, 5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulletSmooth_+3A_data">data</code></td>
<td>
<p>data frame as returned by the function <code>processBullets</code></p>
</td></tr>
<tr><td><code id="bulletSmooth_+3A_span">span</code></td>
<td>
<p>width of the smoother, defaults to 0.03</p>
</td></tr>
<tr><td><code id="bulletSmooth_+3A_limits">limits</code></td>
<td>
<p>vector of the form c(min, max). Results will be limited to be between these values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of the same form as the input extended by the vector l30 for the smooth.
</p>

<hr>
<h2 id='CMS'>Table of the number of consecutive matches</h2><span id='topic+CMS'></span>

<h3>Description</h3>

<p>Table of the number of consecutive matches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMS(match)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMS_+3A_match">match</code></td>
<td>
<p>is a Boolean vector of matches/non-matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table of the number of the CMS and their frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbinom(100, size = 1, prob = 1/3) 
CMS(x == 1) # expected value for longest match is 3
</code></pre>

<hr>
<h2 id='fit_loess'>Fit a loess curve to a bullet data frame</h2><span id='topic+fit_loess'></span>

<h3>Description</h3>

<p>First, the surface measurements of the bullet land is trimmed to be within left and right groove as specified by vector <code>groove</code>.
A loess regression is fit to the remaining surface measurements and residuals are calculated.
The most extreme 0.25
The result is called the signature of the bullet land.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_loess(bullet, groove, span = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_loess_+3A_bullet">bullet</code></td>
<td>
<p>The bullet object as returned from fortify_x3p</p>
</td></tr>
<tr><td><code id="fit_loess_+3A_groove">groove</code></td>
<td>
<p>vector of two numeric values indicating the location of the left and right groove.</p>
</td></tr>
<tr><td><code id="fit_loess_+3A_span">span</code></td>
<td>
<p>The span to use for the loess regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of a data frame of the original bullet measurements extended by loess fit, residuals, and standard errors and two plots: a plot of the fit, and a plot of the bullet's land signature.
</p>

<hr>
<h2 id='fortify_x3p'>Convert a list of x3p file into a data frame</h2><span id='topic+fortify_x3p'></span>

<h3>Description</h3>

<p>x3p format consists of a list with header info and a 2d matrix of scan depths. 
fortify_x3p turn the matrix into a variable within a data frame, using the parameters of the header as necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortify_x3p(x3p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify_x3p_+3A_x3p">x3p</code></td>
<td>
<p>a file in x3p format as return by function read_x3p</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with variables x, y, and value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(br411)
br411_fort &lt;- fortify_x3p(br411)
head(br411_fort)
</code></pre>

<hr>
<h2 id='get_bullet'>Deprecated function use get_crosscut</h2><span id='topic+get_bullet'></span>

<h3>Description</h3>

<p>Deprecated function use get_crosscut
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bullet(path, x = 243.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_bullet_+3A_path">path</code></td>
<td>
<p>The path to the x3p file</p>
</td></tr>
<tr><td><code id="get_bullet_+3A_x">x</code></td>
<td>
<p>The crosscut value</p>
</td></tr>
</table>

<hr>
<h2 id='get_crosscut'>Read a crosscut from a 3d surface file</h2><span id='topic+get_crosscut'></span>

<h3>Description</h3>

<p>Read a crosscut from a 3d surface file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_crosscut(path = NULL, x = 243.75, bullet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_crosscut_+3A_path">path</code></td>
<td>
<p>path to an x3p file. The path will only be considered, if bullet is not specified.</p>
</td></tr>
<tr><td><code id="get_crosscut_+3A_x">x</code></td>
<td>
<p>level of the crosscut to be taken. If this level does not exist, the crosscut with the closest level is returned.</p>
</td></tr>
<tr><td><code id="get_crosscut_+3A_bullet">bullet</code></td>
<td>
<p>alternative access to the surface measurements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>

<hr>
<h2 id='get_grooves'>Find the grooves of a bullet land</h2><span id='topic+get_grooves'></span>

<h3>Description</h3>

<p>Find the grooves of a bullet land
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_grooves(bullet, smoothfactor = 15, adjust = 10, groove_cutoff = 400,
  mean_left = NULL, mean_right = NULL, mean_window = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_grooves_+3A_bullet">bullet</code></td>
<td>
<p>data frame with topological data</p>
</td></tr>
<tr><td><code id="get_grooves_+3A_smoothfactor">smoothfactor</code></td>
<td>
<p>The smoothing window to use</p>
</td></tr>
<tr><td><code id="get_grooves_+3A_adjust">adjust</code></td>
<td>
<p>positive number to adjust the grooves</p>
</td></tr>
<tr><td><code id="get_grooves_+3A_groove_cutoff">groove_cutoff</code></td>
<td>
<p>The index at which a groove cannot exist past</p>
</td></tr>
<tr><td><code id="get_grooves_+3A_mean_left">mean_left</code></td>
<td>
<p>If provided, the location of the average left groove</p>
</td></tr>
<tr><td><code id="get_grooves_+3A_mean_right">mean_right</code></td>
<td>
<p>If provided, the location of the average right groove</p>
</td></tr>
<tr><td><code id="get_grooves_+3A_mean_window">mean_window</code></td>
<td>
<p>The window around the means to use</p>
</td></tr>
</table>

<hr>
<h2 id='get_peaks'>Identify the location and the depth of peaks and heights at a crosscut</h2><span id='topic+get_peaks'></span>

<h3>Description</h3>

<p>Identify the location and the depth of peaks and heights at a crosscut
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_peaks(loessdata, column = "resid", smoothfactor = 35, striae = TRUE,
  window = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_peaks_+3A_loessdata">loessdata</code></td>
<td>
<p>export from rollapply</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_column">column</code></td>
<td>
<p>The column which should be smoothed</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_smoothfactor">smoothfactor</code></td>
<td>
<p>set to default of 35. Smaller values will pick up on smaller changes in the crosscut.</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_striae">striae</code></td>
<td>
<p>If TRUE, show the detected striae on the plot</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_window">window</code></td>
<td>
<p>If TRUE, show the window of the striae on the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of several objects:
</p>

<hr>
<h2 id='get_peaks_nist'>Identify the location and the depth of peaks and heights at a crosscut</h2><span id='topic+get_peaks_nist'></span>

<h3>Description</h3>

<p>Identify the location and the depth of peaks and heights at a crosscut
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_peaks_nist(loessdata, column = "resid", smoothfactor = 35,
  striae = TRUE, window = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_peaks_nist_+3A_loessdata">loessdata</code></td>
<td>
<p>export from rollapply</p>
</td></tr>
<tr><td><code id="get_peaks_nist_+3A_column">column</code></td>
<td>
<p>The column which should be smoothed</p>
</td></tr>
<tr><td><code id="get_peaks_nist_+3A_smoothfactor">smoothfactor</code></td>
<td>
<p>set to default of 35. Smaller values will pick up on smaller changes in the crosscut.</p>
</td></tr>
<tr><td><code id="get_peaks_nist_+3A_striae">striae</code></td>
<td>
<p>If TRUE, show the detected striae on the plot</p>
</td></tr>
<tr><td><code id="get_peaks_nist_+3A_window">window</code></td>
<td>
<p>If TRUE, show the window of the striae on the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of several objects:
</p>

<hr>
<h2 id='getCircle'>Estimate center and radius</h2><span id='topic+getCircle'></span>

<h3>Description</h3>

<p>Assuming the variables x and y are describing points located on a circle, the function uses a likelihood approach to estimate center and radius of the circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCircle(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCircle_+3A_x">x</code></td>
<td>
<p>numeric vector of values</p>
</td></tr>
<tr><td><code id="getCircle_+3A_y">y</code></td>
<td>
<p>numeric vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>three dimensional vector of the circle center (x0, y0) and the radius
</p>

<hr>
<h2 id='getTwist'>Estimate the twist in a bullet land</h2><span id='topic+getTwist'></span>

<h3>Description</h3>

<p>Estimation of the twist in a barrel follows roughly the process described by Chu et al (2010).
At the moment, twist is estimated from a single land - but the twist should be the same for the whole barrel. Therefore all lands of the same barrel should
have the same twist.
A note on timing: at the moment calculating the twist rate for a bullet land takes several minutes.
XXX TODO XXX make the different methods a parameter. Also, accept other input than the path - if we start with the flattened bulletland we get results much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTwist(path, bullet = NULL, twistlimit = NULL, cutoff = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTwist_+3A_path">path</code></td>
<td>
<p>to a file in x3p format</p>
</td></tr>
<tr><td><code id="getTwist_+3A_bullet">bullet</code></td>
<td>
<p>data in x3p format as returned by function read_x3p</p>
</td></tr>
<tr><td><code id="getTwist_+3A_twistlimit">twistlimit</code></td>
<td>
<p>Constraint the possible twist value</p>
</td></tr>
<tr><td><code id="getTwist_+3A_cutoff">cutoff</code></td>
<td>
<p>Use this for the quantile cutoff</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value estimating the twist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# execution takes several minutes
load("data/b1.rda")
twist &lt;- getTwist(path="barrel 1 bullet 1", bullet = b1, twistlimit=c(-2,0)*1.5625)

## End(Not run)
</code></pre>

<hr>
<h2 id='maxCMS'>Number of maximum consecutively matching striae</h2><span id='topic+maxCMS'></span>

<h3>Description</h3>

<p>Number of maximum consecutively matching striae
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxCMS(match)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxCMS_+3A_match">match</code></td>
<td>
<p>is a Boolean vector of matches/non-matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer value of the maximum number of consecutive matches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbinom(100, size = 1, prob = 1/3) 
CMS(x == 1) # expected value for longest match is 3
maxCMS(x==1)
</code></pre>

<hr>
<h2 id='plot_3d_land'>Plot a bullet land using plotly</h2><span id='topic+plot_3d_land'></span>

<h3>Description</h3>

<p>Plot a bullet land using plotly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_3d_land(path, bullet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_3d_land_+3A_path">path</code></td>
<td>
<p>The path to the x3p file</p>
</td></tr>
<tr><td><code id="plot_3d_land_+3A_bullet">bullet</code></td>
<td>
<p>If not null, use this pre-loaded bullet</p>
</td></tr>
</table>

<hr>
<h2 id='predCircle'>Estimate predictions and residuals for a circle fit of x and y</h2><span id='topic+predCircle'></span>

<h3>Description</h3>

<p>estimate a circle, find predictive values and resiudals. depending on specification, vertical (regular) residuals or orthogonal residuals are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predCircle(x, y, resid.method = "response")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predCircle_+3A_x">x</code></td>
<td>
<p>vector of numeric values</p>
</td></tr>
<tr><td><code id="predCircle_+3A_y">y</code></td>
<td>
<p>vector of numeric values</p>
</td></tr>
<tr><td><code id="predCircle_+3A_resid.method">resid.method</code></td>
<td>
<p>character, one of &quot;response&quot; or &quot;ortho&quot;(gonal)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with predictions and residuals
</p>

<hr>
<h2 id='predSmooth'>Estimate predictions and residuals for a smooth of x and y</h2><span id='topic+predSmooth'></span>

<h3>Description</h3>

<p>Fit a smooth line throught x and y, find predictive values and resiudals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predSmooth(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predSmooth_+3A_x">x</code></td>
<td>
<p>vector of numeric values</p>
</td></tr>
<tr><td><code id="predSmooth_+3A_y">y</code></td>
<td>
<p>vector of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with predictions and residuals
</p>

<hr>
<h2 id='processBullets'>Process x3p file</h2><span id='topic+processBullets'></span>

<h3>Description</h3>

<p>x3p file of a 3d topological bullet surface is processed at surface crosscut x, 
the bullet grooves in the crosscuts are identified and removed, and a loess smooth 
is used (see <code>?loess</code> for details) to remove the big structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processBullets(bullet, name = "", x = 100, grooves = NULL, span = 0.75,
  window = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processBullets_+3A_bullet">bullet</code></td>
<td>
<p>file as returned from read_x3p</p>
</td></tr>
<tr><td><code id="processBullets_+3A_name">name</code></td>
<td>
<p>name of the bullet</p>
</td></tr>
<tr><td><code id="processBullets_+3A_x">x</code></td>
<td>
<p>(vector) of surface crosscuts to process.</p>
</td></tr>
<tr><td><code id="processBullets_+3A_grooves">grooves</code></td>
<td>
<p>The grooves to use as a two element vector, if desired</p>
</td></tr>
<tr><td><code id="processBullets_+3A_span">span</code></td>
<td>
<p>The span for the loess fit</p>
</td></tr>
<tr><td><code id="processBullets_+3A_window">window</code></td>
<td>
<p>The mean window around the ideal crosscut</p>
</td></tr>
<tr><td><code id="processBullets_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the get_grooves function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(br411)
br411_processed &lt;- processBullets(br411, name = "br411")
</code></pre>

<hr>
<h2 id='read_x3p'>Read an x3p file as an R Data Frame</h2><span id='topic+read_x3p'></span>

<h3>Description</h3>

<p>Read an x3p file as an R Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_x3p(path, profiley = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_x3p_+3A_path">path</code></td>
<td>
<p>The file path to the x3p file</p>
</td></tr>
<tr><td><code id="read_x3p_+3A_profiley">profiley</code></td>
<td>
<p>If TRUE, rotate the matrix (if necessary) to ensure a profile is taken across y</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
br411 &lt;- read_x3p("Br4 Bullet 4-1.x3p")

## End(Not run)

</code></pre>

<hr>
<h2 id='sample_x3p'>Sample every X element of a data frame</h2><span id='topic+sample_x3p'></span>

<h3>Description</h3>

<p>Sample every X element of a data frame in x and y direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_x3p(dframe, byxy = c(2, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_x3p_+3A_dframe">dframe</code></td>
<td>
<p>data frame with x and y variable</p>
</td></tr>
<tr><td><code id="sample_x3p_+3A_byxy">byxy</code></td>
<td>
<p>(vector) of numeric value indicating the sapling resolution. If a single number, the same resolution is used for x and y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subset of the input variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(br411)
br411_fort &lt;- fortify_x3p(br411)
br411_sample &lt;- sample_x3p(br411_fort, byxy = c(4, 4))
head(br411_sample)
</code></pre>

<hr>
<h2 id='smoothloess'>Predict smooth from a fit</h2><span id='topic+smoothloess'></span>

<h3>Description</h3>

<p>Predict smooth from a fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothloess(x, y, span, sub = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothloess_+3A_x">x</code></td>
<td>
<p>X values to use</p>
</td></tr>
<tr><td><code id="smoothloess_+3A_y">y</code></td>
<td>
<p>Y values to use</p>
</td></tr>
<tr><td><code id="smoothloess_+3A_span">span</code></td>
<td>
<p>The span of the loess fit</p>
</td></tr>
<tr><td><code id="smoothloess_+3A_sub">sub</code></td>
<td>
<p>Subsample factor</p>
</td></tr>
</table>

<hr>
<h2 id='striation_identify'>Match striation marks across two cross sections based on previously identified peaks and valleys</h2><span id='topic+striation_identify'></span>

<h3>Description</h3>

<p>Match striation marks across two cross sections based on previously identified peaks and valleys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>striation_identify(lines1, lines2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="striation_identify_+3A_lines1">lines1</code></td>
<td>
<p>data frame as returned from get_peaks function. data frames are expected to have 
the following variables: xmin, xmax, group, type, bullet, heights</p>
</td></tr>
<tr><td><code id="striation_identify_+3A_lines2">lines2</code></td>
<td>
<p>data frame as returned from get_peaks function. data frames are expected to have 
the following variables: xmin, xmax, group, type, bullet, heights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of the same form as lines1 and lines2, but consisting of an additional variable of whether the striation marks are matches
</p>

<hr>
<h2 id='unfortify_x3p'>Convert a data frame into an x3p file</h2><span id='topic+unfortify_x3p'></span>

<h3>Description</h3>

<p>Convert a data frame into an x3p file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfortify_x3p(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfortify_x3p_+3A_df">df</code></td>
<td>
<p>A data frame produced by fortify_x3p</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An x3p object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(br411)
br411_fort &lt;- fortify_x3p(br411)
br411_unfort &lt;- unfortify_x3p(br411_fort)
identical(br411_unfort, br411)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
