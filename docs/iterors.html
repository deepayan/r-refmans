<!DOCTYPE html><html lang="en"><head><title>Help for package iterors</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iterors}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.list.iteror'><p>Collect all (or some given number of) values from an iteror,</p>
returning a vector of the given type.</a></li>
<li><a href='#concat'><p>Concatenate contents of multiple iterators into a vector.</p></a></li>
<li><a href='#consume'><p>Consumes the first n elements of an iterator</p></a></li>
<li><a href='#count'><p>Consumes an iterator and computes its length</p></a></li>
<li><a href='#dotproduct'><p>Computes the dot product of two iterable objects.</p></a></li>
<li><a href='#hasNext'><p>Does This Iterator Have A Next Element</p></a></li>
<li><a href='#i_apply'><p>Apply a function to each element of an iterator.</p></a></li>
<li><a href='#i_break'><p>Create an iterator that can be told to stop.</p></a></li>
<li><a href='#i_chunk'><p>Combine an iterator's values into chunks.</p></a></li>
<li><a href='#i_concat'><p>Iteror that chains multiple arguments together into a single iterator</p></a></li>
<li><a href='#i_dropwhile'><p>Iterator that drops elements until the predicate function returns FALSE</p></a></li>
<li><a href='#i_enumerate'><p>Iterator that returns the elements of an object along with their indices</p></a></li>
<li><a href='#i_keep'><p>Iterator that filters elements not satisfying a predicate function</p></a></li>
<li><a href='#i_keepwhile'><p>Iterator that returns elements while a predicate function returns TRUE</p></a></li>
<li><a href='#i_limit'><p>Limit the length of an iterator.</p></a></li>
<li><a href='#i_map'><p>Iterator that applies a given function to several iterables concurrently.</p></a></li>
<li><a href='#i_mask'><p>Iterator that filters elements where corresponding selector is false.</p></a></li>
<li><a href='#i_pad'><p>Iterator that returns an object followed indefinitely by a fill value</p></a></li>
<li><a href='#i_recycle'><p>Create a recycling iterator</p></a></li>
<li><a href='#i_rep'><p>Repeat values from an iterator.</p></a></li>
<li><a href='#i_repeat'><p>Create a repeating iterator</p></a></li>
<li><a href='#i_rle'><p>Run-length encoding iterator.</p></a></li>
<li><a href='#i_roundrobin'><p>Iteror that traverses each given iterable in a roundrobin order</p></a></li>
<li><a href='#i_slice'><p>Iteror that returns selected elements from an iterable.</p></a></li>
<li><a href='#i_starmap'><p>Iteror that applies a given function to the elements of an iterable.</p></a></li>
<li><a href='#i_tee'><p>Create multiple iterators from one source</p></a></li>
<li><a href='#i_timeout'><p>Create a timeout iterator</p></a></li>
<li><a href='#i_unique'><p>Iterator that extracts the unique elements from an iterable object</p></a></li>
<li><a href='#i_window'><p>Construct a sliding window over an iterator</p></a></li>
<li><a href='#i_zip'><p>Combine several iterables in parallel.</p></a></li>
<li><a href='#icombinations'><p>Iterator that generates all combinations of a vector taken m at a time.</p></a></li>
<li><a href='#icount'><p>Counting Iterators</p></a></li>
<li><a href='#idedup'><p>Drop duplicated items from an iterator.</p></a></li>
<li><a href='#idiv'><p>Dividing Iterator</p></a></li>
<li><a href='#igrid'><p>Iterator that covers the Cartesian product of the arguments.</p></a></li>
<li><a href='#ipermutations'><p>Iterator that generates all permutations of a vector.</p></a></li>
<li><a href='#iread.table'><p>Iterator over Rows of a Data Frame Stored in a File</p></a></li>
<li><a href='#ireadBin'><p>Create an iterator to read binary data from a connection</p></a></li>
<li><a href='#ireaddf'><p>Create an iterator to read data frames from files</p></a></li>
<li><a href='#ireadLines'><p>Iterator over Lines of Text from a Connection</p></a></li>
<li><a href='#iRNGStream'><p>Iterators returning distant random-number seeds.</p></a></li>
<li><a href='#irnorm'><p>Random Number Iterators</p></a></li>
<li><a href='#is.iteror'><p><code>is.iteror</code> indicates if an object is an iteror.</p></a></li>
<li><a href='#iseq'><p>Iterators for sequence generation</p></a></li>
<li><a href='#isplit'><p>Split Iterator</p></a></li>
<li><a href='#itabulate'><p>Iterator that maps a function to a sequence of numeric values</p></a></li>
<li><a href='#iteror'><p>Make an iteror from a given object.</p></a></li>
<li><a href='#iteror.array'><p>Iterate over an array or data frame by a specified dimension.</p></a></li>
<li><a href='#iteror.function'><p>Construct an iteror object with custom-programmed behavior.</p></a></li>
<li><a href='#makeIwrapper'><p>Iterator Constructor-Constructor Function Wrapper</p></a></li>
<li><a href='#nextOr'><p>Retreive the next element from an iteror.</p></a></li>
<li><a href='#nth'><p>Returns the nth item of an iteror</p></a></li>
<li><a href='#quantify'><p>Count the number of times an iterable object is TRUE</p></a></li>
<li><a href='#r_to_py.iteror'><p>Wrap an iteror to appear as a Python iterator or vice versa.</p></a></li>
<li><a href='#record'><p>Record and replay iterators</p></a></li>
<li><a href='#reduce'><p>Compute the sum, product, or general reduction of an iterator.</p></a></li>
<li><a href='#take'><p>Return the first n elements of an iterable object in a vector.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast, Compact Iterators and Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Meilstrup &lt;peter.meilstrup@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A fresh take on iterators in R. Designed to be cross-compatible with the 'iterators' package, but using the 'nextOr' method will offer better performance as well as more compact code. With batteries included: includes a collection of iterator constructors and combinators ported and refined from the 'iterators', 'itertools', and 'itertools2' packages.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>reticulate, combinat, testthat (&ge; 3.0.0), foreach, iterators
(&ge; 1.0.7), rmarkdown, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/crowding/iterors">https://github.com/crowding/iterors</a>,
<a href="https://crowding.github.io/iterors/">https://crowding.github.io/iterors/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-18 02:53:41 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Meilstrup [cre, aut, cph],
  Folashade Daniel [aut],
  Revolution Analytics [aut, cph],
  Steve Weston [aut, cph],
  John A. Ramey [aut, cph],
  Kayla Schaefer [aut],
  Hadley Wickham [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-18 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.list.iteror'>Collect all (or some given number of) values from an iteror,
returning a vector of the given type.</h2><span id='topic+as.list.iteror'></span><span id='topic+as.double.iteror'></span><span id='topic+as.numeric.iteror'></span><span id='topic+as.logical.iteror'></span><span id='topic+as.character.iteror'></span><span id='topic+as.vector.iteror'></span>

<h3>Description</h3>

<p>Collect all (or some given number of) values from an iteror,
returning a vector of the given type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iteror'
as.list(x, n = as.integer(2^31 - 1), ...)

## S3 method for class 'iteror'
as.double(x, n = as.integer(2^31 - 1), ...)

## S3 method for class 'iteror'
as.numeric(x, n = as.integer(2^31 - 1), ...)

## S3 method for class 'iteror'
as.logical(x, n = as.integer(2^31 - 1), ...)

## S3 method for class 'iteror'
as.character(x, n = as.integer(2^31 - 1), ...)

## S3 method for class 'iteror'
as.vector(x, mode)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list.iteror_+3A_x">x</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="as.list.iteror_+3A_n">n</code></td>
<td>
<p>the maximum number of elements to return.</p>
</td></tr>
<tr><td><code id="as.list.iteror_+3A_...">...</code></td>
<td>
<p>Unused arguments will throw an error.</p>
</td></tr>
<tr><td><code id="as.list.iteror_+3A_mode">mode</code></td>
<td>
<p>What mode to use for the output vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value will be <code>n</code> elements long if the
iterator did not stop.
</p>


<h3>See Also</h3>

<p>concat take
</p>

<hr>
<h2 id='concat'>Concatenate contents of multiple iterators into a vector.</h2><span id='topic+concat'></span><span id='topic+concat.default'></span><span id='topic+concat.iteror'></span>

<h3>Description</h3>

<p><code>concat</code> collects all values from an iterable object, and pastes
them end to end into one vector.  In other words <code>concat</code> is to
<code>as.list.iteror</code> as <code>c</code> is to <code>list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat(obj, mode = "list", n = Inf, ...)

## Default S3 method:
concat(obj, mode = "list", n = as.integer(2^31 - 1), ...)

## S3 method for class 'iteror'
concat(obj, mode = "list", n = Inf, length.out = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concat_+3A_obj">obj</code></td>
<td>
<p>An iteror.</p>
</td></tr>
<tr><td><code id="concat_+3A_mode">mode</code></td>
<td>
<p>The mode of vector to return.</p>
</td></tr>
<tr><td><code id="concat_+3A_n">n</code></td>
<td>
<p>The maximum number of times to call <code>nextOr(obj)</code>.</p>
</td></tr>
<tr><td><code id="concat_+3A_...">...</code></td>
<td>
<p>passed along to <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
<tr><td><code id="concat_+3A_length.out">length.out</code></td>
<td>
<p>The target size of the output vector (after
results have been pasted together). If the iteror ends (or emits
<code>n</code> results) before emitting this many elements, the result will be
shorter than <code>length.out</code>. If the iterator does not end early, the output
will have at least <code>length.out</code> elements, and possibly more,
as the entire last chunk will be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with mode <code>mode</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
it &lt;- i_apply(icount(), seq_len) # [1], [1, 2], [1, 2, 3], ...
concat(it, n=4, mode="numeric")  # [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]
concat(it, length.out=4, mode="numeric")  # [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]
</code></pre>

<hr>
<h2 id='consume'>Consumes the first n elements of an iterator</h2><span id='topic+consume'></span><span id='topic+consume.iteror'></span>

<h3>Description</h3>

<p>Advances the iterator n-steps ahead without returning anything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consume(obj, n = Inf, ...)

## S3 method for class 'iteror'
consume(obj, n = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consume_+3A_obj">obj</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="consume_+3A_n">n</code></td>
<td>
<p>The number of elements to consume.</p>
</td></tr>
<tr><td><code id="consume_+3A_...">...</code></td>
<td>
<p>passed along to <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>obj</code>, invisibly.
</p>


<h3>See Also</h3>

<p>take collect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iteror(1:10)
# Skips the first 5 elements
consume(it, n=5)
# Returns 6
nextOr(it, NA)

it2 &lt;- iteror(letters)
# Skips the first 4 elements
consume(it2, 4)
# Returns 'e'
nextOr(it2, NA)
</code></pre>

<hr>
<h2 id='count'>Consumes an iterator and computes its length</h2><span id='topic+count'></span>

<h3>Description</h3>

<p>Counts the number of elements in an iterator. NOTE: The iterator is consumed
in the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>passed along to <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of elements in the iterator
</p>


<h3>See Also</h3>

<p>take consume as.list.iteror
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count(1:5) == length(1:5)

it &lt;- iteror(1:5)
count(it) == length(1:5)

it2 &lt;- i_chain(1:3, 4:5, 6)
count(it2)

it3 &lt;- i_chain(1:3, levels(iris$Species))
count(it3)

</code></pre>

<hr>
<h2 id='dotproduct'>Computes the dot product of two iterable objects.</h2><span id='topic+dotproduct'></span>

<h3>Description</h3>

<p>Returns the dot product of two numeric iterables of equal length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotproduct(vec1, vec2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotproduct_+3A_vec1">vec1</code></td>
<td>
<p>the first</p>
</td></tr>
<tr><td><code id="dotproduct_+3A_vec2">vec2</code></td>
<td>
<p>the second iterable object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dot product of the iterators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iteror(1:3)
it2 &lt;- iteror(4:6)
dotproduct(it, it2) # 32

it &lt;- iteror(1:4)
it2 &lt;- iteror(7:10)
dotproduct(1:4, 7:10) # 90

</code></pre>

<hr>
<h2 id='hasNext'>Does This Iterator Have A Next Element</h2><span id='topic+hasNext'></span><span id='topic+hasNext.ihasNext'></span><span id='topic+ihasNext'></span>

<h3>Description</h3>

<p><code>wrapped &lt;- ihasnext(obj)</code> wraps an <a href="#topic+iteror">iteror</a> object with the
<code>ihasNext</code> class. Then <code>hasNext(wrapped)</code> will indicate if the
iterator has another element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasNext(obj, ...)

ihasNext(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hasNext_+3A_obj">obj</code></td>
<td>
<p>an iterable</p>
</td></tr>
<tr><td><code id="hasNext_+3A_...">...</code></td>
<td>
<p>extra arguments may be passed along to <a href="#topic+iteror">iteror</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A class <code>ihasNext</code> was introduced in the <code>itertools</code>
package to try to reduce the boilerplate around extracting the
next value using <a href="iterators.html#topic+nextElem">iterators::nextElem</a>.  <code>ihasNext</code> is included
in <code>iterors</code> for backward compatibility with iterator code; however,
it is less needed when using the <a href="#topic+nextOr">nextOr</a> iteration method, as you can
directly give an action to take at end of iteration.
</p>


<h3>Value</h3>

<p>Logical value indicating whether the iterator has a next
element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The bad old style of consuming an iterator in a loop with `nextElem`:
  it &lt;- ihasNext(iteror(c('a', 'b', 'c')))
  tryCatch(repeat {
    print(iterators::nextElem(it))
  }, error=function(err) {
    if (conditionMessage(err) != "StopIteration")
      stop(err)
  })

# with ihasNext, this became:
  it &lt;- ihasNext(iteror(c('a', 'b', 'c')))
  while (hasNext(it))
    print(iterators::nextElem(it))

# But using `nextOr` all you need is:
  iteror(c('a', 'b', 'c'))
  repeat print(nextOr(it, break))

</code></pre>

<hr>
<h2 id='i_apply'>Apply a function to each element of an iterator.</h2><span id='topic+i_apply'></span>

<h3>Description</h3>

<p><code>i_apply(obj, f)</code> returns the iteror that applies <code>f</code> to
each element of the given iterable <code>obj</code>. It is an iterator
equivalent of <code>lapply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_apply(obj, f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_apply_+3A_obj">obj</code></td>
<td>
<p>an iterable.</p>
</td></tr>
<tr><td><code id="i_apply_+3A_f">f</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="i_apply_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed along to <code>f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iteror.
</p>


<h3>See Also</h3>

<p>To apply a function of multiple arguments to multiple
iterators, see <a href="#topic+i_map">i_map</a>. To split an array over margins (like
<code>iterators::i_apply</code> use <code><a href="#topic+iteror.array">iteror(obj, by=MARGIN</a></code>
</p>

<hr>
<h2 id='i_break'>Create an iterator that can be told to stop.</h2><span id='topic+i_break'></span>

<h3>Description</h3>

<p>Create an iterator that iterates over another iterator until a specified
function returns <code>FALSE</code>. This can be useful for breaking out of a
foreach loop, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_break(iterable, finished, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_break_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="i_break_+3A_finished">finished</code></td>
<td>
<p>Function that returns a logical value.  The iterator stops
when this function returns <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="i_break_+3A_...">...</code></td>
<td>
<p>Further arguments forwarded to <code>iteror</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>an iteror which will stop when <code>finished()</code> is <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See how high we can count in a tenth of a second
mkfinished &lt;- function(time) {
  starttime &lt;- proc.time()[3]
  function() proc.time()[3] &gt; starttime + time
}
length(as.list(i_break(icount(), mkfinished(0.1))))

</code></pre>

<hr>
<h2 id='i_chunk'>Combine an iterator's values into chunks.</h2><span id='topic+i_chunk'></span>

<h3>Description</h3>

<p>Create an iterator that issues lists of values from the underlying iterable.
This is useful for manually &ldquo;chunking&rdquo; values from an iterable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_chunk(iterable, size, mode = "list", fill, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_chunk_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="i_chunk_+3A_size">size</code></td>
<td>
<p>Maximum number of values from <code>iterable</code> to return
in each value issued by the resulting iterator.</p>
</td></tr>
<tr><td><code id="i_chunk_+3A_mode">mode</code></td>
<td>
<p>Mode of the objects returned by the iterator.</p>
</td></tr>
<tr><td><code id="i_chunk_+3A_fill">fill</code></td>
<td>
<p>Value to use to pad the last chunk to size, if it is
short. If missing, no padding will be done.</p>
</td></tr>
<tr><td><code id="i_chunk_+3A_...">...</code></td>
<td>
<p>Further arguments will be forwarded to <code>iteror(iterable, ...)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iteror that yields items of length <code>size</code> and mode <code>mode</code>.
</p>


<h3>See Also</h3>

<p><code>iteror.default</code>
</p>
<p>Argument <code>size</code> does not need to be an integer, for instance a
<code>chunk</code> of 3.5 will produce chunks of sizes 3 and 4
alternating. The precise behavior will be subject to floating
point precision.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Split the vector 1:10 into "chunks" with a maximum length of three
it &lt;- i_chunk(1:10, 3)
repeat print(unlist(nextOr(it, break)))

# Same as previous, but return integer vectors rather than lists
it &lt;- i_chunk(1:10, 3, mode='integer')
repeat print(unlist(nextOr(it, break)))

it &lt;- i_chunk(iterators::iter(1:5), 2, fill=NA)
# List: list(1, 2, 3)
nextOr(it, NULL)
# List: list(4, 5, NA)
nextOr(it, NULL)

it2 &lt;- i_chunk(levels(iris$Species), 4, fill="weeee")
# Returns: list("setosa", "versicolor", "virginica", "weeee")
nextOr(it2, NA)

</code></pre>

<hr>
<h2 id='i_concat'>Iteror that chains multiple arguments together into a single iterator</h2><span id='topic+i_concat'></span><span id='topic+i_chain'></span>

<h3>Description</h3>

<p><code>i_concat(obj)</code> takes an iterable that returns
iterables, and chains together all inner values of iterables into
one iterator. Analogous to <code>unlist(recursive=FALSE)</code>.
</p>
<p><code>i_chain</code> for iterators is analogous to <code><a href="base.html#topic+c">c()</a></code> on vectors. <code>i_chain</code>
constructs an <a href="#topic+iteror">iteror</a> that returns elements from the first
argument until it is exhausted, then elements from the next
argument, and so on until all arguments have been exhausted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_concat(obj, ...)

i_chain(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_concat_+3A_obj">obj</code></td>
<td>
<p>an iterable.</p>
</td></tr>
<tr><td><code id="i_concat_+3A_...">...</code></td>
<td>
<p>multiple iterable arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iteror that iterates through each argument in sequence
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- i_chain(1:3, 4:5, 6)
as.list(it)

it2 &lt;- i_chain(1:3, levels(iris$Species))
as.list(it2)
</code></pre>

<hr>
<h2 id='i_dropwhile'>Iterator that drops elements until the predicate function returns FALSE</h2><span id='topic+i_dropwhile'></span>

<h3>Description</h3>

<p>Constructs an iterator that drops elements from the iterable <code>object</code> as
long as the <code>predicate</code> function is true; afterwards, every element of
<code>iterable</code> object is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_dropwhile(object, predicate, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_dropwhile_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="i_dropwhile_+3A_predicate">predicate</code></td>
<td>
<p>a function that determines whether an element is <code>TRUE</code>
or <code>FALSE</code>. The function is assumed to take only one argument.</p>
</td></tr>
<tr><td><code id="i_dropwhile_+3A_...">...</code></td>
<td>
<p>Further arguments forwarded to <a href="#topic+iteror">iteror</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the iterator does not return any elements until the <code>predicate</code>
first becomes false, there may have a lengthy start-up time before elements
are returned.
</p>


<h3>Value</h3>

<p>An <a href="#topic+iteror">iteror</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out numbers exceeding 3
not_too_large &lt;- function(x) {
  x &lt;= 3
}
it &lt;- i_dropwhile(1:8, not_too_large)
as.list(it)

# Same approach but uses an anonymous function
it2 &lt;- i_dropwhile(seq(2, 20, by=2), function(x) x &lt;= 10)
as.list(it2)
</code></pre>

<hr>
<h2 id='i_enumerate'>Iterator that returns the elements of an object along with their indices</h2><span id='topic+i_enumerate'></span><span id='topic+ienumerate'></span><span id='topic+i_enumerate.default'></span><span id='topic+i_enum'></span><span id='topic+i_enumerate.array'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns the elements of an object along with each
element's indices. Enumeration is useful when looping through an
<code>object</code> and a counter is required.
</p>
<p>The <code>i_enumerate</code> method for arrays allows splitting an
array by arbitrary margins, including by multiple margins. The
<code>index</code> element returned will be a vector (or if chunking is used, a
matrix) of indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_enumerate(obj, ...)

ienumerate(obj, ...)

## Default S3 method:
i_enumerate(obj, ..., recycle = FALSE, chunkSize, chunks)

i_enum(obj, ...)

## S3 method for class 'array'
i_enumerate(
  obj,
  ...,
  recycle = FALSE,
  chunkSize,
  chunks,
  by = c("cell", "row", "column"),
  rowMajor = TRUE,
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_enumerate_+3A_obj">obj</code></td>
<td>
<p>object to return indefinitely.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_recycle">recycle</code></td>
<td>
<p>Whether to restart the iterator after finishing the
array.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_chunksize">chunkSize</code></td>
<td>
<p>How large a chunk to take along the specified
dimension.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_chunks">chunks</code></td>
<td>
<p>How many chunks to divide the array into.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_by">by</code></td>
<td>
<p>Which array margins to iterate over. Can be &quot;row&quot;, &quot;col&quot;, &quot;cell&quot;,
or a vector of numerical indices.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_rowmajor">rowMajor</code></td>
<td>
<p>If TRUE, the first index varies fastest, if FALSE, the last index varies fastest.</p>
</td></tr>
<tr><td><code id="i_enumerate_+3A_drop">drop</code></td>
<td>
<p>Whether to drop marginalized dimensions. If chunking is
used, this has no effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to follow the convention used in Python's
<code>enumerate</code> function where the primary difference is that a list is
returned instead of Python's <code>tuple</code> construct.
</p>
<p>Each call to <code><a href="iterators.html#topic+nextElem">nextElem</a></code> returns a list with two
elements:
</p>

<dl>
<dt>index:</dt><dd><p>a counter</p>
</dd>
<dt>value:</dt><dd><p>the current value of <code>object</code></p>
</dd>
</dl>

<p><code>i_enum</code> is an alias to <code>i_enumerate</code> to save a few keystrokes.
</p>
<p>First appeared in package <code>iterators2</code>.
</p>
<p>These are two closely closely related functions:
<code>i_enumerate</code> accepts an iterable, and will only emit a single
index starting with 1. <code>ienumerate</code> is a generic with methods for
vectors and arrays, supporting all chunking and recycling
options, and returning multiple indices for arrays.
</p>


<h3>Value</h3>

<p>iterator that returns the values of <code>obj</code> along with the
index of the object.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
it &lt;- i_enumerate(rnorm(5))
as.list(it)

# Iterates through the columns of the iris data.frame
it2 &lt;- i_enum(iris)
nextOr(it2, NA)
nextOr(it2, NA)
nextOr(it2, NA)
nextOr(it2, NA)
nextOr(it2, NA)

a &lt;- array(1:27, c(3, 3, 3))
as.list(i_enumerate(a, by=c(1, 2), drop=TRUE))
as.list(i_enumerate(a, by=c(3), drop=FALSE))
as.list(i_enumerate(a, by=c(2, 3), chunkSize=7))
</code></pre>

<hr>
<h2 id='i_keep'>Iterator that filters elements not satisfying a predicate function</h2><span id='topic+i_keep'></span><span id='topic+ifilter'></span><span id='topic+i_drop'></span><span id='topic+ifilterfalse'></span>

<h3>Description</h3>

<p><code>i_keep(iterable, predicate)</code> constructs an iterator that filters
elements from iterable returning only those for which the predicate
is <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_keep(iterable, predicate, ...)

i_drop(iterable, predicate, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_keep_+3A_iterable">iterable</code></td>
<td>
<p>an iterable object.</p>
</td></tr>
<tr><td><code id="i_keep_+3A_predicate">predicate</code></td>
<td>
<p>a function that determines whether an element is
<code>TRUE</code> or <code>FALSE</code>. The function is assumed to take only
one argument.</p>
</td></tr>
<tr><td><code id="i_keep_+3A_...">...</code></td>
<td>
<p>passed along to <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally called 'ifilter' from package
<code>itertools</code>. Renamed because the order of arguments has changed
to put the iterable in the first argument, the better to be used
with the <code style="white-space: pre;">&#8288;|&gt;&#8288;</code> operator.
</p>


<h3>Value</h3>

<p>iterator object
</p>


<h3>See Also</h3>

<p>i_drop i_keepwhile i_dropwhile
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out odd numbers and retains only even numbers
is_even &lt;- function(x) {
  x %% 2 == 0
}
it &lt;- i_keep(1:10, is_even)
as.list(it)

# Similar idea here but anonymous function is used to retain only odd
# numbers
it2 &lt;- i_drop(1:10, function(x) x %% 2 == 0)
nextOr(it2, NA) # 1
nextOr(it2, NA) # 3
nextOr(it2, NA) # 5
nextOr(it2, NA) # 7
nextOr(it2, NA) # 9

is_vowel &lt;- function(x) {
  x %in% c('a', 'e', 'i', 'o', 'u')
}
it3 &lt;- i_keep(letters, is_vowel)
as.list(it3)
# Filters out even numbers and retains only odd numbers
is_even &lt;- function(x) {
  x %% 2 == 0
}
it &lt;- i_drop(1:10, is_even)
as.list(it)

# Similar idea here but anonymous function is used to filter out odd
# numbers
it2 &lt;- i_drop(1:10, function(x) x %% 2 == 1)
as.list(it2)

is_vowel &lt;- function(x) {
  x %in% c('a', 'e', 'i', 'o', 'u')
}
it3 &lt;- i_drop(letters, is_vowel)
nextOr(it3, NA) # b
nextOr(it3, NA) # c
nextOr(it3, NA) # d
nextOr(it3, NA) # f
nextOr(it3, NA) # g
# nextOr(it, NA) continues through the rest of the consonants

</code></pre>

<hr>
<h2 id='i_keepwhile'>Iterator that returns elements while a predicate function returns TRUE</h2><span id='topic+i_keepwhile'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns elements from an iterable <code>object</code>
as long as the given <code>predicate</code> function returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_keepwhile(object, predicate, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_keepwhile_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="i_keepwhile_+3A_predicate">predicate</code></td>
<td>
<p>a function that determines whether an element is <code>TRUE</code>
or <code>FALSE</code>. The function is assumed to take only one argument.</p>
</td></tr>
<tr><td><code id="i_keepwhile_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(object, ...)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out numbers exceeding 5
not_too_large &lt;- function(x) {
  x &lt;= 5
}
it &lt;- i_keepwhile(1:100, not_too_large)
unlist(as.list(it)) == 1:5

# Same approach but uses an anonymous function
it2 &lt;- i_keepwhile(seq(2, 100, by=2), function(x) x &lt;= 10)
unlist(as.list(it2)) == c(2, 4, 6, 8, 10)
</code></pre>

<hr>
<h2 id='i_limit'>Limit the length of an iterator.</h2><span id='topic+i_limit'></span>

<h3>Description</h3>

<p>Create an iterator that limits the specified iterable to a specified number of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_limit(iterable, n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_limit_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="i_limit_+3A_n">n</code></td>
<td>
<p>Maximum number of values to return.</p>
</td></tr>
<tr><td><code id="i_limit_+3A_...">...</code></td>
<td>
<p>Extra arguments for <code>iteror(iterable, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>an <a href="#topic+iteror">iteror</a> which will stop after yielding <code>n</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Limit icount to only return three values
as.list(i_limit(icount(), 3))

</code></pre>

<hr>
<h2 id='i_map'>Iterator that applies a given function to several iterables concurrently.</h2><span id='topic+i_map'></span>

<h3>Description</h3>

<p>Constructs an iterator that computes the given function <code>f</code> using the
arguments from each of the iterables given in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_map(f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_map_+3A_f">f</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="i_map_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterator returned is exhausted when the shortest iterable in <code>...</code>
is exhausted. Note that <code>i_map</code> does not recycle arguments as
<code><a href="base.html#topic+Map">Map</a></code> does.
</p>
<p>The primary difference between <code>i_starmap</code> and
<code><a href="#topic+i_map">i_map</a></code> is that the former expects an iterable object
whose elements are already grouped together, while the latter case groups the
arguments together before applying the given function. The choice is a matter
of style and convenience.
</p>


<h3>Value</h3>

<p>iterator that returns the values of <code>object</code> along with the
index of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pow &lt;- function(x, y) {
  x^y
}
it &lt;- i_map(pow, c(2, 3, 10), c(5, 2, 3))
as.list(it)

# Similar to the above, but because the second vector is exhausted after two
# calls to `nextElem`, the iterator is exhausted.
it2 &lt;- i_map(pow, c(2, 3, 10), c(5, 2))
as.list(it2)

# Another similar example but with lists instead of vectors
it3 &lt;- i_map(pow, list(2, 3, 10), list(5, 2, 3))
nextOr(it3, NA) # 32
nextOr(it3, NA) # 9
nextOr(it3, NA) # 1000
</code></pre>

<hr>
<h2 id='i_mask'>Iterator that filters elements where corresponding selector is false.</h2><span id='topic+i_mask'></span>

<h3>Description</h3>

<p>Constructs an iterator that filters elements from iterable returning only
those for which the corresponding element from <code>selectors</code> is
<code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_mask(object, selectors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_mask_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="i_mask_+3A_selectors">selectors</code></td>
<td>
<p>an iterable that determines whether the corresponding
element in <code>object</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterator stops when either <code>object</code> or <code>selectors</code> has been
exhausted.
</p>


<h3>Value</h3>

<p>iterator object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filters out odd numbers and retains only even numbers
n &lt;- 10
selectors &lt;- rep(c(FALSE, TRUE), n)
it &lt;- i_mask(seq_len(n), selectors)
as.list(it)

# Similar idea here but anonymous function is used to filter out even
# numbers
n &lt;- 10
it2 &lt;- i_mask(seq_len(10), rep(c(TRUE, FALSE), n))
as.list(it2)

it3 &lt;- i_mask(letters, letters %in% c('a', 'e', 'i', 'o', 'u'))
as.list(it3)
</code></pre>

<hr>
<h2 id='i_pad'>Iterator that returns an object followed indefinitely by a fill value</h2><span id='topic+i_pad'></span>

<h3>Description</h3>

<p>Constructs an iterator that returns an iterable <code>object</code> before padding
the iterator with the given <code>fill</code> value indefinitely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_pad(object, fill = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_pad_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="i_pad_+3A_fill">fill</code></td>
<td>
<p>the value to pad the indefinite iterator after the initial
<code>object</code> is consumed. Default: <code>NA</code></p>
</td></tr>
<tr><td><code id="i_pad_+3A_...">...</code></td>
<td>
<p>Passed along to <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator that returns <code>object</code> followed indefinitely by the
<code>fill</code> value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
it &lt;- iteror(1:9)
it_i_pad &lt;- i_pad(it)
as.list(i_slice(it_i_pad, end=9)) # Same as as.list(1:9)

it2 &lt;- iteror(1:9)
it2_i_pad &lt;- i_pad(it2)
as.list(i_slice(it2_i_pad, end=10)) # Same as as.list(c(1:9, NA))

it3 &lt;- iteror(1:9)
it3_i_pad &lt;- i_pad(it3, fill=TRUE)
as.list(i_slice(it3_i_pad, end=10)) # Same as as.list(c(1:9, TRUE))

</code></pre>

<hr>
<h2 id='i_recycle'>Create a recycling iterator</h2><span id='topic+i_recycle'></span>

<h3>Description</h3>

<p>Create an iterator that recycles a specified iterable. On the first
repeat the iterable is buffered into memory until it finishes, then
we repeat the same sequence of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_recycle(iterable, times = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_recycle_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to recycle.</p>
</td></tr>
<tr><td><code id="i_recycle_+3A_times">times</code></td>
<td>
<p>integer.  Number of times to recycle the values .
Default value of <code>Inf</code> means to recycle indefinitely.</p>
</td></tr>
<tr><td><code id="i_recycle_+3A_...">...</code></td>
<td>
<p>Further arguments will be passed along to <a href="#topic+iteror">iteror</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>an <a href="#topic+iteror">iteror</a> recycling the values from the underlying iterable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Recycle over 'a', 'b', and 'c' three times
i &lt;- i_recycle(letters[1:3], 3)
as.character(i)

it &lt;- i_recycle(1:3)
nextOr(it, NA) # 1
nextOr(it, NA) # 2
nextOr(it, NA) # 3
nextOr(it, NA) # 1
nextOr(it, NA) # 2
nextOr(it, NA) # 3
nextOr(it, NA) # 1

it2 &lt;- i_recycle(1:3, times=2)
as.list(it2)

</code></pre>

<hr>
<h2 id='i_rep'>Repeat values from an iterator.</h2><span id='topic+i_rep'></span>

<h3>Description</h3>

<p>An analogue of the <code>rep</code> function operating on iterables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_rep(iterable, times = 1, length.out = NULL, each = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_rep_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to iterate over repeatedly.</p>
</td></tr>
<tr><td><code id="i_rep_+3A_times">times</code></td>
<td>
<p>How many times to recycle the underlying iteror (via
<a href="#topic+i_recycle">i_recycle</a>).</p>
</td></tr>
<tr><td><code id="i_rep_+3A_length.out">length.out</code></td>
<td>
<p>The maximum length of output. If this is given
<code>times</code> is ignored.</p>
</td></tr>
<tr><td><code id="i_rep_+3A_each">each</code></td>
<td>
<p>The number of times to repeat each element.  You can
pass a vector (recycled), or another iterable, to repeat each
element a varying number of times.</p>
</td></tr>
<tr><td><code id="i_rep_+3A_...">...</code></td>
<td>
<p>further arguments passed along to <code>iteror(iterable, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments <code>times</code> and <code>each</code> can work slightly
differently from <a href="base.html#topic+rep">rep</a>; <code>times</code> must always be of length 1; to
repeat each element a specific number of times, provide a vector to
<code>each</code> rather than <code>times</code>.
</p>
<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>an iteror yilding and repeating values from <code>iterable</code>.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+rep">base::rep</a>, <a href="#topic+i_recycle">i_recycle</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.numeric(i_rep(1:4, 2))
as.numeric(i_rep(1:4, each=2))
as.numeric(i_rep(1:4, each=c(2,2,2,2)))
as.numeric(i_rep(1:4, each=c(2,1,2,1)))
as.numeric(i_rep(1:4, each=2, len=4))
as.numeric(i_rep(1:4, each=2, len=10))
as.numeric(i_rep(1:4, each=2, times=3))

# Note `rep` makes `times` behave like `each` when given a vector.
# `i_rep` does not reproduce this behavior; give the vector to `each`.
# These are equivalent:
as.numeric(i_rep(1:4, each = 1:8, times=2))
rep(rep(1:4, times=2), times=1:8)

</code></pre>

<hr>
<h2 id='i_repeat'>Create a repeating iterator</h2><span id='topic+i_repeat'></span>

<h3>Description</h3>

<p>Create an iterator that returns a value a specified number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_repeat(x, times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_repeat_+3A_x">x</code></td>
<td>
<p>The value to return repeatedly.</p>
</td></tr>
<tr><td><code id="i_repeat_+3A_times">times</code></td>
<td>
<p>The number of times to repeat the value.  Default value is
infinity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>an <a href="#topic+iteror">iteror</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Repeat a value 10 times
unlist(as.list(i_repeat(42, 10)))

</code></pre>

<hr>
<h2 id='i_rle'>Run-length encoding iterator.</h2><span id='topic+i_rle'></span><span id='topic+i_rleinv'></span>

<h3>Description</h3>

<p>This is an iterator equivalent of <a href="base.html#topic+rle">rle</a>; it produces one output
value for each run if identical values in its input, along with the
lenght of the run. <code>i_rle_inverse()</code> performs the inverse
transformstion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_rle(obj, cmp = identical, ...)

i_rleinv(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_rle_+3A_obj">obj</code></td>
<td>
<p>An iterable</p>
</td></tr>
<tr><td><code id="i_rle_+3A_cmp">cmp</code></td>
<td>
<p>A function to use for comparison. It should take two
arguments and return <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="i_rle_+3A_...">...</code></td>
<td>
<p>further arguments forwarded to <code><a href="#topic+iteror">iteror(obj, ...)</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iterator returning entries of the form <code>list(length=n, value=X)</code>.
</p>
<p><code>i_rleinv</code> recreates the original data from the output of <code>i_rle</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>See Also</h3>

<p>i_dedupe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- isample(c(TRUE, FALSE), 1, replace=TRUE)
rle &lt;- i_rle(it)
x &lt;- take(rle, 10)
as.logical(i_rleinv(x))
</code></pre>

<hr>
<h2 id='i_roundrobin'>Iteror that traverses each given iterable in a roundrobin order</h2><span id='topic+i_roundrobin'></span>

<h3>Description</h3>

<p>Constructs an iterator that traverses each given iterable in a roundrobin
order. That is, the iterables are traversed in an alternating fashion such
that the each element is drawn from the next iterable. If an iterable has no
more available elements, it is skipped, and the next element is taken from
the next iterable having available elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_roundrobin(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_roundrobin_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in roundrobin sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iterator that alternates through each argument in roundrobin sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iteror(c("A", "B", "C"))
it2 &lt;- iteror("D")
it3 &lt;- iteror(c("E", "F"))
as.list(i_roundrobin(it, it2, it3)) # A D E B F C

it_rr &lt;- i_roundrobin(1:3, 4:5, 7:10)
as.list(it_rr) # 1 4 7 2 5 8 3 9 10

</code></pre>

<hr>
<h2 id='i_slice'>Iteror that returns selected elements from an iterable.</h2><span id='topic+i_slice'></span>

<h3>Description</h3>

<p>Constructs an iteror that returns elements from an iterable following the
given sequence with starting value <code>start</code> and ending value <code>end</code>.
The sequence's step size is given by <code>step</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_slice(object, start = 1, end = NULL, step = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_slice_+3A_object">object</code></td>
<td>
<p>iterable object through which this function iterates</p>
</td></tr>
<tr><td><code id="i_slice_+3A_start">start</code></td>
<td>
<p>the index of the first element to return from <code>object</code></p>
</td></tr>
<tr><td><code id="i_slice_+3A_end">end</code></td>
<td>
<p>the index of the last element to return from <code>object</code></p>
</td></tr>
<tr><td><code id="i_slice_+3A_step">step</code></td>
<td>
<p>the step size of the sequence</p>
</td></tr>
<tr><td><code id="i_slice_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(object, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterable given in <code>object</code> is traversed beginning with element
having index specified in <code>start</code>. If <code>start</code> is greater than 1,
then elements from the <code>object</code> are skipped until <code>start</code> is
reached. By default, elements are returned consecutively. However, if the
<code>step</code> size is greater than 1, elements in <code>object</code> are skipped.
</p>
<p>If <code>stop</code> is <code>Inf</code> (default), the iteration continues until the
iteror is exhausted unless <code>end</code> is specified. In this case,
<code>end</code> specifies the sequence position to stop iteration.
</p>
<p>Originally from package <code>itertools2</code>.
</p>


<h3>Value</h3>

<p>iteror that returns <code>object</code> in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- i_slice(1:5, start=2)
nextOr(it, NULL) # 2
nextOr(it, NULL) # 3
nextOr(it, NULL) # 4
nextOr(it, NULL) # 5

it2 &lt;- i_slice(1:10, start=2, end=5)
unlist(as.list(it2)) == 2:5

it3 &lt;- i_slice(1:10, start=2, end=9, step=2)
unlist(as.list(it3)) == c(2, 4, 6, 8)
</code></pre>

<hr>
<h2 id='i_starmap'>Iteror that applies a given function to the elements of an iterable.</h2><span id='topic+i_starmap'></span><span id='topic+i_star'></span>

<h3>Description</h3>

<p>Constructs an iteror that applies the function <code>f</code> concurrently to the
elements within the list <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_starmap(f, x)

i_star(f, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_starmap_+3A_f">f</code></td>
<td>
<p>a function to apply to the elements of <code>x</code></p>
</td></tr>
<tr><td><code id="i_starmap_+3A_x">x</code></td>
<td>
<p>an iterable object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iteror returned is exhausted when the shortest element in <code>x</code>
is exhausted. Note that <code>i_starmap</code> does not recycle arguments as
<code><a href="base.html#topic+Map">Map</a></code> does.
</p>
<p>The primary difference between <code>i_starmap</code> and
<code><a href="#topic+i_map">i_map</a></code> is that the former expects an iterable object
whose elements are already grouped together, while the latter case groups the
arguments together before applying the given function. The choice is a matter
of style and convenience.
</p>


<h3>Value</h3>

<p>iterator that returns the values of <code>object</code> along with the
index of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pow &lt;- function(x, y) {
  x^y
}
it &lt;- i_starmap(pow, list(c(2, 3, 10), c(5, 2, 3)))
unlist(as.list(it)) == c(32, 9, 1000)

# Similar to the above, but because the second vector is exhausted after two
# calls to `nextElem`, the iterator is exhausted.
it2 &lt;- i_starmap(pow, list(c(2, 3, 10), c(5, 2)))
unlist(as.list(it2)) == c(32, 9)

# Another similar example but with lists instead of vectors
it3 &lt;- i_starmap(pow, list(list(2, 3, 10), list(5, 2, 3)))
as.list(it3)

# Computes sum of each row in the iris data set
# Numerically equivalent to base::rowSums()
tolerance &lt;- sqrt(.Machine$double.eps)
iris_x &lt;- iris[, -5]
it4 &lt;- i_starmap(sum, iris_x)
unlist(as.list(it4)) - rowSums(iris_x) &lt; tolerance
</code></pre>

<hr>
<h2 id='i_tee'>Create multiple iterators from one source</h2><span id='topic+i_tee'></span>

<h3>Description</h3>

<p><code>i_tee(obj, n)</code> consumes and buffers the output of a single iterator
<code>obj</code> so that it can be read by <code>n</code> independent sub-iterators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_tee(obj, n, max = 2^16 - 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_tee_+3A_obj">obj</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="i_tee_+3A_n">n</code></td>
<td>
<p>the number of iterators to return</p>
</td></tr>
<tr><td><code id="i_tee_+3A_max">max</code></td>
<td>
<p>The maximum number of values to buffer.</p>
</td></tr>
<tr><td><code id="i_tee_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(obj, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It works by saving the output of source <code>obj</code> in a queue, while
each sub-iterator has a &quot;read pointer&quot; indexing into the
queue. Items are dropped from the queue after all sub-iterators
have seen them.
</p>
<p>This means that if one sub-iterator falls far behind the others, or
equivalently if one sub-iterator reads far ahead its cohort the
others, the intervening values will be kept in memory. The <code>max</code>
argument gives a limit on how many items will be held. If this
limit is exceeded due to one sub-iterator reading far ahead of the
others, an error will be thrown when that sub-iterator attempts to
read a new value.
</p>


<h3>Value</h3>

<p>a list of <code>n</code> iterators.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>

<hr>
<h2 id='i_timeout'>Create a timeout iterator</h2><span id='topic+i_timeout'></span>

<h3>Description</h3>

<p>Create an iterator that iterates over another iterator for a specified
period of time, and then stops.  This can be useful when you want to search
for something, or run a test for awhile, and then stop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_timeout(iterable, time, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_timeout_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="i_timeout_+3A_time">time</code></td>
<td>
<p>The time interval to iterate for, in seconds.</p>
</td></tr>
<tr><td><code id="i_timeout_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(iterable, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>an <a href="#topic+iteror">iteror</a> yielding values from <code>iterable</code> so long as <code>time</code> is in the future
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See how high we can count in a tenth of a second
length(as.list(i_timeout(icount(), 0.1)))

</code></pre>

<hr>
<h2 id='i_unique'>Iterator that extracts the unique elements from an iterable object</h2><span id='topic+i_unique'></span>

<h3>Description</h3>

<p>Constructs an iterator that extracts each unique element in turn from an
iterable <code>object</code>. Order of the elements is maintained. This function is
an iterator analogue to <a href="base.html#topic+unique">unique</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_unique(object, digest = rlang::hash, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_unique_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="i_unique_+3A_digest">digest</code></td>
<td>
<p>Optionally specify a custom hash function
(e.g. <code>digest::digest</code>, <code>rlang::hash</code>). It should be a function
returning a character value.</p>
</td></tr>
<tr><td><code id="i_unique_+3A_...">...</code></td>
<td>
<p>Extra arguments are forwarded to <a href="#topic+iteror">iteror</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: In order to determine whether an element is unique, a list of previous
unique elements is stored. In doing so, the list can potentially become large
if there are a large number of unique elements.
</p>


<h3>Value</h3>

<p>an iterator that returns only the unique elements from
<code>object</code>
</p>


<h3>See Also</h3>

<p>i_dedupe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- i_chain(rep(1, 4), rep(2, 5), 4:7, 2)
as.list(i_unique(it)) # 1 2 4 5 6 7

it2 &lt;- iterators::iter(c('a', 'a', "A", "V"))
as.list(i_unique(it2)) # a A V

x &lt;- as.character(gl(5, 10))
it_unique &lt;- i_unique(x)
as.list(it_unique) # 1 2 3 4 5
</code></pre>

<hr>
<h2 id='i_window'>Construct a sliding window over an iterator</h2><span id='topic+i_window'></span>

<h3>Description</h3>

<p>Each element returned by <code>i_window(obj)</code> consists of <code>n</code> consecutive
elements from the underlying <code>obj</code>, with the window advancing
forward by one element each iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_window(obj, n, tail, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_window_+3A_obj">obj</code></td>
<td>
<p>An iterable.</p>
</td></tr>
<tr><td><code id="i_window_+3A_n">n</code></td>
<td>
<p>The width of the window to apply</p>
</td></tr>
<tr><td><code id="i_window_+3A_tail">tail</code></td>
<td>
<p>If a value is given, tails will be included at
the beginning and end of iteration, filled with the given value.</p>
</td></tr>
<tr><td><code id="i_window_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(object, ...)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iteror.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' @examples
it &lt;- i_window(iteror(letters[1:4]), 2)
nextOr(it, NA) # list("a", "b")
nextOr(it, NA) # list("b", "c")
nextOr(it, NA) # list("c", "d")

it2 &lt;- i_window(icount(5), 2)
nextOr(it2, NA) # list(1, 2)
nextOr(it2, NA) # list(2, 3)
nextOr(it2, NA) # list(3, 4)
nextOr(it2, NA) # list(4, 5)

it &lt;- i_window(letters[1:4], 2)
nextOr(it, NA) # list("a", "b")
nextOr(it, NA) # list("b", "c")
nextOr(it, NA) # list("c", "d")

it &lt;- i_window(letters[1:4], 3)
nextOr(it) # list("a", "b", "c")
nextOr(it) # list("b", "c", "d")

it &lt;- i_window(letters[1:4], 3, tail=" ")
nextOr(it) # list(" ", " ", "a")
nextOr(it) # list(" ", "a", "b")
nextOr(it) # list("a", "b", "c")
nextOr(it) # list("b", "c", "d")
nextOr(it) # list("c", "d", " ")
nextOr(it) # list("d", " ", " ")
</code></pre>

<hr>
<h2 id='i_zip'>Combine several iterables in parallel.</h2><span id='topic+i_zip'></span><span id='topic+i_zip_longest'></span>

<h3>Description</h3>

<p>The resulting iterator aggregates one element from each of the
iterables into a list for each iteration. Used for lock-step
iteration over several iterables at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_zip(...)

i_zip_longest(..., fill = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_zip_+3A_...">...</code></td>
<td>
<p>multiple arguments to iterate through in parallel</p>
</td></tr>
<tr><td><code id="i_zip_+3A_fill">fill</code></td>
<td>
<p>the value used to replace missing values when the iterables in
<code>...</code> are of uneven length</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code style="white-space: pre;">&#8288;[i_zip]&#8288;</code>, the output will finish when any of the underlying iterables finish.
</p>
<p>Originally from the <code>itertools</code> package.
</p>
<p>Originally from package <code>itertools2</code>.
</p>


<h3>Value</h3>

<p>iterator that iterates through each argument in sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Iterate over two iterables of different sizes
as.list(i_zip(a=1:2, b=letters[1:3]))

it &lt;- i_zip_longest(x=1:3, y=4:6, z=7:9)
nextOr(it, NA) # list(x=1, y=4, z=7)
nextOr(it, NA) # list(x=2, y=5, z=8)
nextOr(it, NA) # list(x=3, y=6, z=9)

it2 &lt;- i_zip_longest(1:3, 4:8)
nextOr(it2, NA) # list(1, 4)
nextOr(it2, NA) # list(2, 5)
nextOr(it2, NA) # list(3, 6)
nextOr(it2, NA) # list(NA, 7)
nextOr(it2, NA) # list(NA, 8)

it3 &lt;- i_zip_longest(1:2, 4:7, levels(iris$Species), fill="w00t")
nextOr(it3, NA) # list(1, 4, "setosa")
nextOr(it3, NA) # list(2, 5, "versicolor")
nextOr(it3, NA) # list("w00t", 6, "virginica")
nextOr(it3, NA) # list("w00t", 7, "w00t")
</code></pre>

<hr>
<h2 id='icombinations'>Iterator that generates all combinations of a vector taken m at a time.</h2><span id='topic+icombinations'></span>

<h3>Description</h3>

<p>Constructs an iterator generates all combinations of a vector taken <code>m</code>
at a time. This function is similar to <code><a href="utils.html#topic+combn">combn</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icombinations(object, m, replacement = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icombinations_+3A_object">object</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="icombinations_+3A_m">m</code></td>
<td>
<p>the length of each combination</p>
</td></tr>
<tr><td><code id="icombinations_+3A_replacement">replacement</code></td>
<td>
<p>Generate combinations with replacement? Default: no.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the combinations are <strong>without replacement</strong> so that elements are
not repeated. To generate combinations <strong>with replacement</strong>, set
<code>replacement=TRUE</code>.
</p>
<p>The function implementation is loosely based on the <code>combinations</code>
function from Python's itertools. Combinations with replacement are based on
<code>combinations_with_replacement</code> from the same Python library.
</p>


<h3>Value</h3>

<p>iterator that generates all combinations of <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Combinations without replacement
it &lt;- icombinations(1:4, m=2)

nextOr(it, NA) # c(1, 2)
nextOr(it, NA) # c(1, 3)
nextOr(it, NA) # c(1, 4)
nextOr(it, NA) # c(2, 3)
nextOr(it, NA) # c(2, 4)
nextOr(it, NA) # c(3, 4)

# Combinations without replacement
it &lt;- icombinations(1:4, m=2, replacement=TRUE)

nextOr(it, NA) # c(1, 1)
nextOr(it, NA) # c(1, 2)
nextOr(it, NA) # c(1, 3)
nextOr(it, NA) # c(1, 4)
nextOr(it, NA) # c(2, 2)
nextOr(it, NA) # c(2, 3)
nextOr(it, NA) # c(2, 4)
nextOr(it, NA) # c(3, 3)
nextOr(it, NA) # c(3, 4)
nextOr(it, NA) # c(4, 4)

it3 &lt;- icombinations(1:5, m=2)
as.list(it3)
utils::combn(x=1:5, m=2, simplify=FALSE)

</code></pre>

<hr>
<h2 id='icount'>Counting Iterators</h2><span id='topic+icount'></span><span id='topic+icountn'></span>

<h3>Description</h3>

<p>Returns an iterator that counts starting from one.
</p>
<p><code>icountn(vn)</code> takes a vector specifying an array size,
and returns an iterator over array indices. Each returned element
is a vector the same length as vn, with the first index varying fastest.
If vn has a names attribute the output will have the same names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icount(count = Inf, ..., recycle = FALSE, chunkSize, chunks)

icountn(vn, ..., recycle = FALSE, chunkSize, chunks, rowMajor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icount_+3A_count">count</code></td>
<td>
<p>number of times that the iterator will fire. Use NA or
Inf to make an iterator that counts forever.</p>
</td></tr>
<tr><td><code id="icount_+3A_...">...</code></td>
<td>
<p>Undocumented</p>
</td></tr>
<tr><td><code id="icount_+3A_recycle">recycle</code></td>
<td>
<p>Whether to restart the count after finishing.</p>
</td></tr>
<tr><td><code id="icount_+3A_chunksize">chunkSize</code></td>
<td>
<p>How many valies to return from each call to nextOr().</p>
</td></tr>
<tr><td><code id="icount_+3A_chunks">chunks</code></td>
<td>
<p>How many chunks to split the input. Either <code>chunks</code> or <code>chunkSize</code> may be given but not both.</p>
</td></tr>
<tr><td><code id="icount_+3A_vn">vn</code></td>
<td>
<p>A vector of integers.</p>
</td></tr>
<tr><td><code id="icount_+3A_rowmajor">rowMajor</code></td>
<td>
<p>If <code>TRUE</code> (default), the earliest indices will cycle fastest;
if <code>FALSE</code>, last indices cycle fastest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>The counting iterator.
</p>


<h3>See Also</h3>

<p>For more control over starting number and step size, see
<a href="#topic+iseq">iseq</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create an iterator that counts from 1 to 3.
it &lt;- icount(3)
nextOr(it)
nextOr(it)
nextOr(it)
nextOr(it, NULL)  # expect NULL

x &lt;- icount(5)
repeat print(nextOr(x, break))

it2 &lt;- icount(100)
all.equal(as.numeric(it2), 1:100)
as.list(icountn(c(2, 3)))
</code></pre>

<hr>
<h2 id='idedup'>Drop duplicated items from an iterator.</h2><span id='topic+idedup'></span>

<h3>Description</h3>

<p>Constructs an iterator that removes runs of repeated elements from the
underlying iterator. Order of the elements is maintained. Only the element
just seen is remembered for determining whether to drop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idedup(object, cmp = identical, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idedup_+3A_object">object</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="idedup_+3A_cmp">cmp</code></td>
<td>
<p>A function to use for comparison.</p>
</td></tr>
<tr><td><code id="idedup_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(object, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originated as <code>itertools2::iunique_lastseen</code>.
<code>object</code>.
</p>


<h3>Value</h3>

<p>an iterator that skips over duplicate items from teh
unterlying iterator.
</p>


<h3>See Also</h3>

<p>i_rle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- i_chain(rep(1,4), rep(2, 5), 4:7, 2)
it_i_unique &lt;- idedup(it)
as.list(it_i_unique) # 1 2 4 5 6 7 2

it2 &lt;- iteror(c('a', 'a', "A", 'a', 'a', "V"))
i_dedupe &lt;- idedup(it2)
as.list(idedup) # a A a V

</code></pre>

<hr>
<h2 id='idiv'>Dividing Iterator</h2><span id='topic+idiv'></span>

<h3>Description</h3>

<p>Returns an iterator dividing a value into integer chunks, such that
<code>sum(idiv(n, ...)) == floor(n)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idiv(count, ..., recycle = FALSE, chunkSize, chunks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idiv_+3A_count">count</code></td>
<td>
<p>The total</p>
</td></tr>
<tr><td><code id="idiv_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="idiv_+3A_recycle">recycle</code></td>
<td>
<p>Whether to restart the count after finishing.</p>
</td></tr>
<tr><td><code id="idiv_+3A_chunksize">chunkSize</code></td>
<td>
<p>the maximum size of the pieces that <code>n</code> should be
divided into.  This is useful when you know the size of the pieces that you
want.  If specified, then <code>chunks</code> should not be.</p>
</td></tr>
<tr><td><code id="idiv_+3A_chunks">chunks</code></td>
<td>
<p>the number of pieces that <code>n</code> should be divided into.
This is useful when you know the number of pieces that you want.  If
specified, then <code>chunkSize</code> should not be.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>The dividing iterator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# divide the value 10 into 3 pieces
it &lt;- idiv(10, chunks = 3)
nextOr(it)
nextOr(it)
nextOr(it)
nextOr(it, NULL)  # expect NULL

# divide the value 10 into pieces no larger than 3
it &lt;- idiv(10, chunkSize = 3)
nextOr(it)
nextOr(it)
nextOr(it)
nextOr(it)
nextOr(it, NULL)  # end of iterator

</code></pre>

<hr>
<h2 id='igrid'>Iterator that covers the Cartesian product of the arguments.</h2><span id='topic+igrid'></span>

<h3>Description</h3>

<p>Given a number of vectors as arguments, constructs an iterator that enumerates the Cartesian product of all arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igrid(
  ...,
  recycle = FALSE,
  chunkSize,
  chunks,
  simplify = FALSE,
  rowMajor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igrid_+3A_...">...</code></td>
<td>
<p>Named vectors to iterate over.</p>
</td></tr>
<tr><td><code id="igrid_+3A_recycle">recycle</code></td>
<td>
<p>If TRUE, the iteror starts over on reaching the end.</p>
</td></tr>
<tr><td><code id="igrid_+3A_chunksize">chunkSize</code></td>
<td>
<p>Optional; how many rows to return in each step.</p>
</td></tr>
<tr><td><code id="igrid_+3A_chunks">chunks</code></td>
<td>
<p>Optional; how many chunks to divide the input into.</p>
</td></tr>
<tr><td><code id="igrid_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE, inputs are coerced to a common data type
and results are returned in a vector (or matrix if chunking is
enabled). If FALSE, results are returned as a list (or data.frame
if chunking).</p>
</td></tr>
<tr><td><code id="igrid_+3A_rowmajor">rowMajor</code></td>
<td>
<p>If TRUE, the left-most indices change fastest. If
FALSE the rightmost indices change fastest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although they share the same end goal, <code>igrid</code> can yield
drastic memory savings compared to <code><a href="base.html#topic+expand.grid">expand.grid</a></code>.
</p>


<h3>Value</h3>

<p>an <a href="#topic+iteror">iteror</a> that iterates through each element from the
Cartesian product of its arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a doubly-nested loop with a single while loop
it &lt;- igrid(a=1:3, b=1:2)
repeat {
  x &lt;- nextOr(it, break)
  cat(sprintf('a = %d, b = %d\n', x$a, x$b))
}

it &lt;- igrid(x=1:3, y=4:5)
nextOr(it, NA) # list(x=1, y=4)
nextOr(it, NA) # list(x=1, y=5)
nextOr(it, NA) # list(x=2, y=4)
nextOr(it, NA) # list(x=2, y=5)
nextOr(it, NA) # list(x=3, y=4)
nextOr(it, NA) # list(x=3, y=5)

# Second Cartesian product
nextOr(it, NA) # list(x=1, y=4)
nextOr(it, NA) # list(x=1, y=5)
nextOr(it, NA) # list(x=2, y=4)
nextOr(it, NA) # list(x=2, y=5)
nextOr(it, NA) # list(x=3, y=4)
nextOr(it, NA) # list(x=3, y=5)

# igrid is an iterator equivalent to base::expand.grid()
# Large data.frames are not created unless the iterator is manually consumed
a &lt;- 1:2
b &lt;- 3:4
c &lt;- 5:6
it3 &lt;- igrid(a=a, b=b, c=c)
df_igrid &lt;- do.call(rbind, as.list(it3))
df_igrid &lt;- data.frame(df_igrid)

# Compare df_igrid with the results from base::expand.grid()
base::expand.grid(a=a, b=b, c=c)
</code></pre>

<hr>
<h2 id='ipermutations'>Iterator that generates all permutations of a vector.</h2><span id='topic+ipermutations'></span>

<h3>Description</h3>

<p>Constructs an iterator generates all permutations of an iterable object. By
default, full-length permutations are generated. If <code>m</code> is specified,
successive <code>m</code> length permutations are instead generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipermutations(object, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipermutations_+3A_object">object</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="ipermutations_+3A_m">m</code></td>
<td>
<p>length of permutations. By default, full-length permutations are
generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is loosely based on that of Python's itertools.
</p>


<h3>Value</h3>

<p>iterator that generates all permutations of <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- ipermutations(1:3)

nextOr(it, NA) # c(1, 2, 3)
nextOr(it, NA) # c(1, 3, 2)
nextOr(it, NA) # c(3, 1, 2)
nextOr(it, NA) # c(3, 2, 1)
nextOr(it, NA) # c(2, 3, 1)
nextOr(it, NA) # c(2, 1, 3)

it2 &lt;- ipermutations(letters[1:4])
# 24 = 4! permutations of the letters a, b, c, and d
as.list(it2)

</code></pre>

<hr>
<h2 id='iread.table'>Iterator over Rows of a Data Frame Stored in a File</h2><span id='topic+iread.table'></span>

<h3>Description</h3>

<p>Returns an iterator over the rows of a data frame stored in a file in table
format.  It is a wrapper around the standard <code>read.table</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iread.table(file, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iread.table_+3A_file">file</code></td>
<td>
<p>the name of the file to read the data from.</p>
</td></tr>
<tr><td><code id="iread.table_+3A_...">...</code></td>
<td>
<p>all additional arguments are passed on to the <code>read.table</code>
function.  See the documentation for <code>read.table</code> for more information.</p>
</td></tr>
<tr><td><code id="iread.table_+3A_verbose">verbose</code></td>
<td>
<p>logical value indicating whether or not to print the calls to
<code>read.table</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>The file reading iterator.
</p>


<h3>Note</h3>

<p>In this version of <code>iread.table</code>, both the <code>read.table</code>
arguments <code>header</code> and <code>row.names</code> must be specified.  This is
because the default values of these arguments depend on the contents of the
beginning of the file.  In order to make the subsequent calls to
<code>read.table</code> work consistently, the user must specify those arguments
explicitly.  A future version of <code>iread.table</code> may remove this
requirement.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
</p>

<hr>
<h2 id='ireadBin'>Create an iterator to read binary data from a connection</h2><span id='topic+ireadBin'></span>

<h3>Description</h3>

<p>Create an iterator to read binary data from a connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ireadBin(
  con,
  what = "raw",
  n = 1L,
  size = NA_integer_,
  signed = TRUE,
  endian = .Platform$endian,
  ipos = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ireadBin_+3A_con">con</code></td>
<td>
<p>A connection object or a character string naming a file or a raw
vector.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_what">what</code></td>
<td>
<p>Either an object whose mode will give the mode of the vector to
be read, or a character vector of length one describing the mode: one of
&ldquo;numeric&rdquo;, &ldquo;double&rdquo;, &ldquo;integer&rdquo;, &ldquo;int&rdquo;,
&ldquo;logical&rdquo;, &ldquo;complex&rdquo;, &ldquo;character&rdquo;, &ldquo;raw&rdquo;.
Unlike <code>readBin</code>, the default value is &ldquo;raw&rdquo;.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_n">n</code></td>
<td>
<p>integer.  The (maximal) number of records to be read each time the
iterator is called.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_size">size</code></td>
<td>
<p>integer.  The number of bytes per element in the byte stream.
The default, &lsquo;NA_integer_&rsquo;, uses the natural size.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_signed">signed</code></td>
<td>
<p>logical.  Only used for integers of sizes 1 and 2, when it
determines if the quantity on file should be regarded as a signed or
unsigned integer.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_endian">endian</code></td>
<td>
<p>The endian-ness ('&ldquo;big&rdquo;' or '&ldquo;little&rdquo;') of the
target system for the file.  Using '&ldquo;swap&rdquo;' will force swapping
endian-ness.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_ipos">ipos</code></td>
<td>
<p>iterable.  If not <code>NULL</code>, values from this iterable will be
used to do a seek on the file before calling readBin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>An <a href="#topic+iteror">iteror</a> reading binary chunks from the connection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zz &lt;- file("testbin", "wb")
writeBin(1:100, zz)
close(zz)

it &lt;- ihasNext(ireadBin("testbin", integer(), 10))
repeat print(nextOr(it, break))
unlink("testbin")

</code></pre>

<hr>
<h2 id='ireaddf'>Create an iterator to read data frames from files</h2><span id='topic+ireaddf'></span>

<h3>Description</h3>

<p>Create an iterator to read data frames from files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ireaddf(filenames, n, start = 1, col.names, chunkSize = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ireaddf_+3A_filenames">filenames</code></td>
<td>
<p>Names of files contains column data.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_n">n</code></td>
<td>
<p>Maximum number of elements to read from each column file.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_start">start</code></td>
<td>
<p>Element to start reading from.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_col.names">col.names</code></td>
<td>
<p>Names of the columns.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_chunksize">chunkSize</code></td>
<td>
<p>Number of rows to read at a time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>An <a href="#topic+iteror">iteror</a> yielding <a href="base.html#topic+data.frame">data.frame</a> objects with up to <code>n</code> rows.
</p>

<hr>
<h2 id='ireadLines'>Iterator over Lines of Text from a Connection</h2><span id='topic+ireadLines'></span>

<h3>Description</h3>

<p>Returns an iterator over the lines of text from a connection.  It is a
wrapper around the standard <code>readLines</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ireadLines(con, n = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ireadLines_+3A_con">con</code></td>
<td>
<p>a connection object or a character string.</p>
</td></tr>
<tr><td><code id="ireadLines_+3A_n">n</code></td>
<td>
<p>integer.  The maximum number of lines to read.  Negative values
indicate that one should read up to the end of the connection.  The default
value is 1.</p>
</td></tr>
<tr><td><code id="ireadLines_+3A_...">...</code></td>
<td>
<p>passed on to the <code>readLines</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>The line reading iterator.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readLines">readLines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create an iterator over the lines of COPYING
it &lt;- ireadLines(file.path(R.home(), "COPYING"))
nextOr(it)
nextOr(it)
nextOr(it)

</code></pre>

<hr>
<h2 id='iRNGStream'>Iterators returning distant random-number seeds.</h2><span id='topic+iRNGStream'></span><span id='topic+iRNGSubStream'></span>

<h3>Description</h3>

<p>The <code>iRNGStream</code> creates a sequence of random number seeds
that are very &quot;far apart&quot; (2^127 steps) in the overall random
number sequence, so that each can be used to make a parallel,
psudo-independent random iterator. This uses
<a href="parallel.html#topic+RngStream">parallel::nextRNGStream</a> and the &quot;L'Ecuyer-CMRG&quot; generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iRNGStream(seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iRNGStream_+3A_seed">seed</code></td>
<td>
<p>Either a single number to be passed to <code>set.seed</code> or a</p>
</td></tr>
</table>


<h3>Details</h3>

<p>iRNGSubStream creates seeds that are somewhat less far apart (2^76
steps), which might be used as &quot;substream&quot; seeds.
</p>
<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>An <a href="#topic+iteror">iteror</a> which produces seed values.
vector to be passed to <code>nextRNGStream</code> or <code>nextRNGSubStream</code>.
</p>
<p>An <a href="#topic+iteror">iteror</a> which yields successive seed values.
</p>


<h3>References</h3>

<p>For more details on the L'Ecuyer-CMRG generator, see
<code>vignette("parallel", package="parallel")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+set.seed">set.seed</a></code>,
<code><a href="parallel.html#topic+nextRNGStream">nextRNGStream</a></code>,
<code><a href="parallel.html#topic+nextRNGSubStream">nextRNGSubStream</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
global.seed &lt;- .Random.seed

rng.seeds &lt;- iRNGStream(313)
print(nextOr(rng.seeds))
print(nextOr(rng.seeds))

# create three pseudo-independent and
# reproducible random number streams
it1 &lt;- isample(c(0, 1), 1, seed=nextOr(rng.seeds))
it2 &lt;- isample(c(0, 1), 1, seed=nextOr(rng.seeds))
it3 &lt;- isample(c(0, 1), 1, seed=nextOr(rng.seeds))

all(.Random.seed == global.seed)
take(it1, 5, "numeric") # 0 0 0 1 1
take(it2, 5, "numeric") # 0 1 1 1 1
take(it3, 5, "numeric") # 1 1 1 0 0

# none of this affects the global seed
all(global.seed == .Random.seed)


# Compute random numbers in three parallel processes with three
# well-separated seeds. Requires package "foreach"
library(foreach)
foreach(1:3, rseed=iRNGSubStream(1970), .combine='c') %dopar% {
  RNGkind("L'Ecuyer-CMRG") # would be better to initialize workers only once
  assign('.Random.seed', rseed, pos=.GlobalEnv)
  runif(1)
}

</code></pre>

<hr>
<h2 id='irnorm'>Random Number Iterators</h2><span id='topic+irnorm'></span><span id='topic+irunif'></span><span id='topic+irbinom'></span><span id='topic+irnbinom'></span><span id='topic+irpois'></span><span id='topic+isample'></span>

<h3>Description</h3>

<p>These functions each construct an iterator that produces
random numbers of various distributions. Each one is a wrapper
around a base R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irnorm(
  n,
  mean = 0,
  sd = 1,
  count = Inf,
  independent = !missing(seed) || !missing(kind),
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)

irbinom(
  n,
  size,
  prob,
  count = Inf,
  independent = !missing(seed) || !missing(kind),
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)

irnbinom(
  n,
  size,
  prob,
  mu,
  count = Inf,
  independent = !missing(seed) || !missing(kind),
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)

irpois(
  n,
  lambda,
  count = Inf,
  independent = !missing(seed) || !missing(kind),
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)

isample(
  x,
  size,
  replace = FALSE,
  prob = NULL,
  count = Inf,
  independent = !missing(seed) || !missing(kind),
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)

irunif(
  n,
  min = 0,
  max = 1,
  count = Inf,
  independent = !missing(seed) || !missing(kind),
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irnorm_+3A_n">n</code></td>
<td>
<p>How many samples to compute per call; see e.g. <a href="stats.html#topic+rnorm">rnorm</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_mean">mean</code></td>
<td>
<p>see <a href="stats.html#topic+rnorm">rnorm</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_sd">sd</code></td>
<td>
<p>see <a href="stats.html#topic+rnorm">rnorm</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_count">count</code></td>
<td>
<p>number of times that the iterator will fire.  If not
specified, it will fire values forever.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_independent">independent</code></td>
<td>
<p>If TRUE, this iterator will keep its own private
random state, so that its output is reproducible and independent
of anything else in the program; this comes at some performance
cost. Default is FALSE <em>unless</em> <code>seed</code> or <code>kind</code> are given.  If
<code>independent=TRUE</code> but neither <code>seed</code> nor <code>kind</code> are specified,
we will use the &quot;L'Ecuyer-CMRG&quot; generator with a seed value
taken from a package-private instance of <a href="#topic+iRNGStream">iRNGStream</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_seed">seed</code></td>
<td>
<p>A specific seed value for reproducibility. If given,
<code>independent=TRUE</code> is implied. This can be a single number (which
will be passed to <code><a href="base.html#topic+set.seed">set.seed(seed, kind, normal.kind, sample.kind)</a></code>; it can also be a vector containing a
complete, valid state for <a href="base.html#topic+.Random.seed">.Random.seed</a>. If the latter,
arguments <code>kind</code>, etc. are ignored.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_kind">kind</code></td>
<td>
<p>Which random number algorithm to use; passed along to
<a href="base.html#topic+set.seed">set.seed</a>, If given, <code>independent=TRUE</code> is implied.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_normal.kind">normal.kind</code></td>
<td>
<p>Passed along to <a href="base.html#topic+set.seed">set.seed</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_sample.kind">sample.kind</code></td>
<td>
<p>Passed along to <a href="base.html#topic+set.seed">set.seed</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_size">size</code></td>
<td>
<p>see e.g. <a href="stats.html#topic+rbinom">rbinom</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_prob">prob</code></td>
<td>
<p>see e.g. <a href="stats.html#topic+rbinom">rbinom</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_mu">mu</code></td>
<td>
<p>see <a href="stats.html#topic+rnbinom">rnbinom</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_lambda">lambda</code></td>
<td>
<p>see <a href="stats.html#topic+rpois">rpois</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_x">x</code></td>
<td>
<p>see <a href="#topic+isample">isample</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_replace">replace</code></td>
<td>
<p>see <a href="#topic+isample">isample</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_min">min</code></td>
<td>
<p>see <a href="stats.html#topic+runif">runif</a>.</p>
</td></tr>
<tr><td><code id="irnorm_+3A_max">max</code></td>
<td>
<p>see <a href="stats.html#topic+runif">runif</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>An iterator that is a wrapper around the corresponding
random number generator function.
</p>


<h3>See Also</h3>

<p>If you are creating multiple independent iterators,
<a href="#topic+iRNGStream">iRNGStream</a> will create well-separated seed values, which may
help avoid spurious correlations between iterators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create an iterator that returns three random numbers
it &lt;- irnorm(1, count = 3)
nextOr(it)
nextOr(it)
nextOr(it)
nextOr(it, NULL)

# iterators created with a specific seed will make reproducible values
it &lt;- irunif(n=1, seed=314, kind="L'Ecuyer-CMRG")
nextOr(it) # 0.4936700
nextOr(it) # 0.5103891
nextOr(it) # 0.2338745

# the iRNGStream produces a sequence of well separated seed values,
rng.seeds &lt;- iRNGStream(313)
it1 &lt;- isample(c(0, 1), 1, seed=nextOr(rng.seeds))
it2 &lt;- isample(c(0, 1), 1, seed=nextOr(rng.seeds))
it3 &lt;- isample(c(0, 1), 1, seed=nextOr(rng.seeds))
take(it1, 5, "numeric") # 0 1 0 0 1
take(it2, 5, "numeric") # 0 1 0 0 0
take(it3, 5, "numeric") # 0 0 0 1 1

</code></pre>

<hr>
<h2 id='is.iteror'><code>is.iteror</code> indicates if an object is an iteror.</h2><span id='topic+is.iteror'></span><span id='topic+is.iterator'></span>

<h3>Description</h3>

<p><code>is.iteror</code> indicates if an object is an iteror.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.iteror(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.iteror_+3A_x">x</code></td>
<td>
<p>any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the object has class <code>iteror</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
it &lt;- iteror(1:3)
stopifnot(is.iteror(it))
repeat {
  print(nextOr(it, break))
}

</code></pre>

<hr>
<h2 id='iseq'>Iterators for sequence generation</h2><span id='topic+iseq'></span><span id='topic+iseq_along'></span>

<h3>Description</h3>

<p>Constructs iterators that generate regular sequences that follow the
<code><a href="base.html#topic+seq">seq</a></code> family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iseq(
  from = 1,
  to = NULL,
  by = NULL,
  length_out = NULL,
  along_with = NULL,
  ...,
  recycle = FALSE,
  chunkSize,
  chunks
)

iseq_along(along_with, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iseq_+3A_from">from</code></td>
<td>
<p>the starting value of the sequence.</p>
</td></tr>
<tr><td><code id="iseq_+3A_to">to</code></td>
<td>
<p>the end value of the sequence.</p>
</td></tr>
<tr><td><code id="iseq_+3A_by">by</code></td>
<td>
<p>increment of the sequence.</p>
</td></tr>
<tr><td><code id="iseq_+3A_length_out">length_out</code></td>
<td>
<p>desired length of the sequence. A non-negative number,
which for <code>seq</code> will be rounded up if fractional.</p>
</td></tr>
<tr><td><code id="iseq_+3A_along_with">along_with</code></td>
<td>
<p>the length of the sequence will match the length of this</p>
</td></tr>
<tr><td><code id="iseq_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="iseq_+3A_recycle">recycle</code></td>
<td>
<p>Whether to restart the sequence after it reaches <code>to</code>.</p>
</td></tr>
<tr><td><code id="iseq_+3A_chunksize">chunkSize</code></td>
<td>
<p>Optional; return this many values per call.</p>
</td></tr>
<tr><td><code id="iseq_+3A_chunks">chunks</code></td>
<td>
<p>Optional; return this many chunks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>iseq</code> function generates a sequence of values beginning with
<code>from</code> and ending with <code>to</code>. The sequence of values between are
determined by the <code>by</code>, <code>length_out</code>, and <code>along_with</code>
arguments. The <code>by</code> argument determines the step size of the sequence,
whereas <code>length_out</code> and <code>along_with</code> determine the length of the
sequence. If <code>by</code> is not given, then it is determined by either
<code>length_out</code> or <code>along_with</code>. By default, neither are given, in
which case <code>by</code> is set to 1 or -1, depending on whether <code>to &gt;
from</code>.
</p>


<h3>Value</h3>

<p>an <a href="#topic+iteror">iteror</a>.
</p>


<h3>See Also</h3>

<p>icount icountn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iseq(from=2, to=5)
unlist(as.list(it)) == 2:5
</code></pre>

<hr>
<h2 id='isplit'>Split Iterator</h2><span id='topic+isplit'></span>

<h3>Description</h3>

<p>Returns an iterator that divides the data in the vector <code>x</code> into the
groups defined by <code>f</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isplit(x, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isplit_+3A_x">x</code></td>
<td>
<p>vector or data frame of values to be split into groups.</p>
</td></tr>
<tr><td><code id="isplit_+3A_f">f</code></td>
<td>
<p>a factor or list of factors used to categorize <code>x</code>.</p>
</td></tr>
<tr><td><code id="isplit_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not occur should be
dropped.</p>
</td></tr>
<tr><td><code id="isplit_+3A_...">...</code></td>
<td>
<p>current ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>The split iterator.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+split">split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(200)
f &lt;- factor(sample(1:10, length(x), replace = TRUE))

it &lt;- isplit(x, f)
expected &lt;- split(x, f)

for (i in expected) {
    actual &lt;- nextOr(it, break)
    stopifnot(actual$value == i)
}

</code></pre>

<hr>
<h2 id='itabulate'>Iterator that maps a function to a sequence of numeric values</h2><span id='topic+itabulate'></span>

<h3>Description</h3>

<p>Constructs an iterator that maps a given function over an indefinite sequence
of numeric values. The input the function <code>f</code> is expected to accept a
single numeric argument. The sequence of arguments passed to <code>f</code> begin
with <code>start</code> and are incremented by <code>step</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itabulate(f, start = 1, step = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="itabulate_+3A_f">f</code></td>
<td>
<p>the function to apply</p>
</td></tr>
<tr><td><code id="itabulate_+3A_start">start</code></td>
<td>
<p>sequence's initial value</p>
</td></tr>
<tr><td><code id="itabulate_+3A_step">step</code></td>
<td>
<p>sequence's step size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iterator that returns the mapped values from the sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- itabulate(f=function(x) x + 1)
take(it, 4) # 2 3 4 5

it2 &lt;- itabulate(f=function(x) x^2, start=-3)
take(it2, 6) # 9 4 1 0 1 4

it3 &lt;- itabulate(abs, start=-5, step=2)
take(it3, 6) # 5 3 1 1 3 5

it4 &lt;- itabulate(exp, start=6, step=-2)
take(it4, 4) # exp(c(6, 4, 2, 0))

</code></pre>

<hr>
<h2 id='iteror'>Make an iteror from a given object.</h2><span id='topic+iteror'></span><span id='topic+iteror.iter'></span><span id='topic+iteror.default'></span><span id='topic+iteror.connection'></span>

<h3>Description</h3>

<p><code>it &lt;- iteror(obj, ...)</code> is a generic constructor that creates
objects of class &quot;iteror&quot; from its input. An iteror outputs a
single element of a sequence each time you call
<code>nextOr(it)</code>. Different <code>iteror</code> methods exist for different data
types and may take different optional arguments as listed in this
page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iteror(obj, ...)

## S3 method for class 'iter'
iteror(obj, ...)

## Default S3 method:
iteror(obj, ..., recycle = FALSE, chunkSize, chunks)

## S3 method for class 'connection'
iteror(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iteror_+3A_obj">obj</code></td>
<td>
<p>An object to iterate with.</p>
</td></tr>
<tr><td><code id="iteror_+3A_...">...</code></td>
<td>
<p>Different <code>iteror</code> methods may take additional options
depending on the class of <code>obj</code>.</p>
</td></tr>
<tr><td><code id="iteror_+3A_recycle">recycle</code></td>
<td>
<p>a boolean describing whether the iterator should
reset after running through all its values.</p>
</td></tr>
<tr><td><code id="iteror_+3A_chunksize">chunkSize</code></td>
<td>
<p>How many elements (or slices) to include in each
chunk.</p>
</td></tr>
<tr><td><code id="iteror_+3A_chunks">chunks</code></td>
<td>
<p>Split the input into this many chunks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called, an iteror may either return a new value or stop. The
way an iteror signals a stop is that it does whatever you write in
the argument <code>or</code>. For instance you can write <code>or=break</code> to exit a
loop. Summing over an iteror this way looks like:
</p>
<div class="sourceCode r"><pre>sum &lt;- 0
it &lt;- iteror(iseq(0, 100, 7))
repeat {
  sum &lt;- sum + nextOr(it, break)
}
</pre></div>
<p>Another way to use the &quot;or&quot; argument is to give it a sentinel value;
that is, a special value that you will interpret as end of
iteration.  If the result of calling <code>nextOr</code> is <code>identical()</code> to
the value you provided, then you know the iterator has ended. This
pattern looks like:
</p>
<div class="sourceCode r"><pre>sum &lt;- 0
stopped &lt;- new.env()
it &lt;- iteror(iseq(0, 100, 7))
repeat {
  val &lt;- nextOr(it, stopped)
  if (identical(val, stopped)) break
  sum &lt;- sum + val
}
</pre></div>
<p>(Here I'm using <code>new.env()</code> as a sentinel value. In R it is
commonplace to use <code>NULL</code> or <code>NA</code> as a kind of sentinel value, but
that only works until you have an iterator that needs to yield NULL
itself. A safer alternative is to use a local, one-shot sentinel value;
<code>new.env()</code> is ideal, as it constructs an object that is
not <a href="base.html#topic+identical">identical</a> to any other object in the R session.)
</p>
<p>Note that <code>iteror</code> objects are simply functions with a class
attribute attached, and all <code>nextOr.iteror</code> does is call the
function. So if you were in the mood, you could skip calling
<code>nextOr</code> involving S3 dispatch and instead call the iteror
directly. If you take this approach, make sure you have called
<code>iteror()</code> first to ensure that you have a true <code>iteror</code> object.
</p>
<div class="sourceCode r"><pre>sum &lt;- 0
it &lt;- iteror(iseq(0, 100, 7))
repeat sum &lt;- sum + it(or=break)
sum
#&gt; [1] 735
</pre></div>
<p>To create iterors with custom-defined behavior, see
<a href="#topic+iteror.function">iteror.function</a>.
</p>


<h3>Value</h3>

<p>an object of classes 'iteror' and 'iter'.
</p>
<p>The method <code>iteror.iter</code> wraps an <a href="iterators.html#topic+iter">iterators::iter</a> object
and returns an iteror.
</p>
<p>The default method <code>iteror.default</code> treats <code>obj</code> as a
vector to yield values from.
</p>


<h3>See Also</h3>

<p>iteror.array iteror.function iteror.data.frame
</p>

<hr>
<h2 id='iteror.array'>Iterate over an array or data frame by a specified dimension.</h2><span id='topic+iteror.array'></span><span id='topic+iteror.matrix'></span><span id='topic+iteror.data.frame'></span>

<h3>Description</h3>

<p>Iterate over an array or data frame by a specified dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
iteror(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunkSize,
  chunks,
  recycle = FALSE,
  drop = FALSE,
  rowMajor = TRUE
)

## S3 method for class 'matrix'
iteror(
  obj,
  ...,
  by = c("cell", "row", "column"),
  chunkSize,
  chunks,
  recycle = FALSE,
  drop = FALSE,
  rowMajor = TRUE
)

## S3 method for class 'data.frame'
iteror(obj, ..., recycle = FALSE, chunkSize, chunks, by = c("column", "row"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iteror.array_+3A_obj">obj</code></td>
<td>
<p>An object to iterate over.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_by">by</code></td>
<td>
<p>Which dimension to slice an array or data frame by. Can be &quot;cell&quot;,
&quot;row&quot;, &quot;column&quot;, or numeric dimensions.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_chunksize">chunkSize</code></td>
<td>
<p>The thickness of the slice to take along the specified dimension.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_chunks">chunks</code></td>
<td>
<p>How many slices to take.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_recycle">recycle</code></td>
<td>
<p>If TRUE, the iteror starts over on reaching the end.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_drop">drop</code></td>
<td>
<p>Whether to drop the array dimensions enumerated over.</p>
</td></tr>
<tr><td><code id="iteror.array_+3A_rowmajor">rowMajor</code></td>
<td>
<p>If TRUE, will return slices in order with the first
indices varying fastest (same as in <a href="#topic+i_enumerate">i_enumerate</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an iteror yielding from <code>obj</code> along the specified dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- iteror(letters, chunkSize=7)
as.list(l)

a &lt;- array(1:8, c(2, 2, 2))

# iterate over all the slices
it &lt;- iteror(a, by=3)
as.list(it)

# iterate over all the columns of each slice
it &lt;- iteror(a, by=c(2, 3))
as.list(it)

# iterate over all the rows of each slice
it &lt;- iteror(a, by=c(1, 3))
as.list(it)

</code></pre>

<hr>
<h2 id='iteror.function'>Construct an iteror object with custom-programmed behavior.</h2><span id='topic+iteror.function'></span>

<h3>Description</h3>

<p>Pass <code>obj</code> a function that has a first argument named &quot;or&quot;.  In
writing this function, you can maintain state by using enclosed
variables and update using <code style="white-space: pre;">&#8288;&lt;&lt;-&#8288;</code>, Whatever value <code>obj()</code> returns is
the next element of the iteror. Treat argument <code>or</code> as a lazy value;
do not touch it until until you need to signal end of iteration;
to signal end of iteration, force and immediately return <code>or</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
iteror(obj, ..., catch, sentinel, count)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iteror.function_+3A_obj">obj</code></td>
<td>
<p>A function. It should have having an argument named &quot;or&quot;</p>
</td></tr>
<tr><td><code id="iteror.function_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="iteror.function_+3A_catch">catch</code></td>
<td>
<p>If <code>obj</code> does not have an <code>or</code> argument, specify
e.g. <code>catch="StopIteration"</code> to interpret that an error with
that message as end of iteration.</p>
</td></tr>
<tr><td><code id="iteror.function_+3A_sentinel">sentinel</code></td>
<td>
<p>If <code>obj</code> does not have an <code>or</code> argument, you can specify
a special value to watch for end of iteration. Stop will be signaled
if the function result is <code><a href="base.html#topic+identical">identical()</a></code> to <code>sentinel</code>.</p>
</td></tr>
<tr><td><code id="iteror.function_+3A_count">count</code></td>
<td>
<p>If <code>obj</code> does not have an <code>or</code> argument, you can specify
how many calls before stop iteration, or
give <code>NA</code> or <code>Inf</code> to never stop.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also provide <code>obj</code> a simple function of no arguments, as
long as you specify one of <code>catch</code>, <code>sentinel</code>, or <code>count</code> to specify
how to detect end of iteration.
</p>


<h3>Value</h3>

<p>An object of mode &quot;function&quot; and class &quot;iteror&quot;.
</p>
<p>An <a href="#topic+iteror">iteror</a> which calls the given function to produce values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# an iterator that counts from start to stop
irange &lt;- function(from=1, to=Inf) {
  current &lt;- from
  iteror(function(or) {
    if (current &gt; to) {
      return(or)
    } else {
      tmp &lt;- current
      current &lt;&lt;- current + 1
      tmp
    }
  })
}
it &lt;- irange(5, 10)
as.vector(it, "numeric")

# an endless random number generator
irand &lt;- function(min, max) {
 iteror(function() runif(1, min=min, max=max), count=Inf)
}
take(irand(5, 10), 10)
</code></pre>

<hr>
<h2 id='makeIwrapper'>Iterator Constructor-Constructor Function Wrapper</h2><span id='topic+makeIwrapper'></span>

<h3>Description</h3>

<p>The <code>makeIwrapper</code> function wraps an R function to produce an
iterator constructor.  It is used to construct random sampling
iterators in this package; for instance <code>irnorm</code> is defined as
<code>irnorm &lt;- makeIwrapper(rnorm)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeIwrapper(FUN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeIwrapper_+3A_fun">FUN</code></td>
<td>
<p>a function that generates different values each time it
is called; typically one of the standard random number generator
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting iterator constructors all take an optional
<code>count</code> argument which specifies the number of times the
resulting iterator should fire. They also have an argument
<code>independent</code> which enables independent tracking of the random
number seed. The <code>isample</code> function is an example of one such
iterator constructoe (as are <code>irnorm</code>, <code>irunif</code>, etc.).
</p>
<p>Original version appeared in the <code>iterators</code> package.
</p>


<h3>Value</h3>

<p>An iterator that is a wrapper around the corresponding
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create an iterator maker for the sample function
mysample &lt;- makeIwrapper(sample)
# use this iterator maker to generate an iterator that will generate three five
# member samples from the sequence 1:100
it &lt;- mysample(1:100, 5, count = 3)
nextOr(it)
nextOr(it)
nextOr(it)
nextOr(it, NULL)  # NULL
</code></pre>

<hr>
<h2 id='nextOr'>Retreive the next element from an iteror.</h2><span id='topic+nextOr'></span>

<h3>Description</h3>

<p>Retreive the next element from an iteror.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextOr(obj, or, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nextOr_+3A_obj">obj</code></td>
<td>
<p>An <a href="#topic+iteror">iteror</a>.</p>
</td></tr>
<tr><td><code id="nextOr_+3A_or">or</code></td>
<td>
<p>If the iterator has reached its end, this argument
will be forced and returned.</p>
</td></tr>
<tr><td><code id="nextOr_+3A_...">...</code></td>
<td>
<p>Other arguments may be used by specific iterors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the next value of <code>iteror</code>, or the value of <code>or</code>.
</p>

<hr>
<h2 id='nth'>Returns the nth item of an iteror</h2><span id='topic+nth'></span>

<h3>Description</h3>

<p>Returns the <code>n</code>th item of an <code>iteror</code> after advancing the
iteror <code>n</code> steps ahead. If the <code>iteror</code> is entirely consumed,
the argument <code>or</code> is returned instead. That is, if either <code>n &gt;
length(iteror)</code> or <code>n</code> is 0, then the <code>iteror</code> is consumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nth(obj, n, or, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nth_+3A_obj">obj</code></td>
<td>
<p>an iterable.</p>
</td></tr>
<tr><td><code id="nth_+3A_n">n</code></td>
<td>
<p>The index of the desired element to return.</p>
</td></tr>
<tr><td><code id="nth_+3A_or">or</code></td>
<td>
<p>If the iteror finishes before retuning <code>n</code> elements,
this argument will be forced and returned.</p>
</td></tr>
<tr><td><code id="nth_+3A_...">...</code></td>
<td>
<p>passed along to <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nth element of the iteror or the result of forcing <code>or</code>.
</p>


<h3>See Also</h3>

<p>take consume collect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iteror(1:10)
# Returns 5
nth(it, 5, NA)

it2 &lt;- iteror(letters)
# Returns 'e'
nth(it2, 5, NA)

it3 &lt;- iteror(letters)
# Returns default value of NA
nth(it3, 42, NA)

it4 &lt;- iteror(letters)
# Returns default value of "foo"
nth(it4, 42, or="foo")
</code></pre>

<hr>
<h2 id='quantify'>Count the number of times an iterable object is TRUE</h2><span id='topic+quantify'></span>

<h3>Description</h3>

<p>Returns the number of elements from an iterable object that
evaluate to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantify(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantify_+3A_obj">obj</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="quantify_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="#topic+iteror">iteror</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of <code>TRUE</code> elements
</p>


<h3>See Also</h3>

<p>reduce
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iteror(c(TRUE, FALSE, TRUE))
quantify(it) # 2

set.seed(42)
x &lt;- sample(c(TRUE, FALSE), size=10, replace=TRUE)
quantify(x) # Equivalent to sum(x)
</code></pre>

<hr>
<h2 id='r_to_py.iteror'>Wrap an iteror to appear as a Python iterator or vice versa.</h2><span id='topic+r_to_py.iteror'></span><span id='topic+iteror.python.builtin.object'></span>

<h3>Description</h3>

<p>This requires the <code>reticulate</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iteror'
r_to_py(x, convert = FALSE, ...)

## S3 method for class 'python.builtin.object'
iteror(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_to_py.iteror_+3A_x">x</code></td>
<td>
<p>An iterable object.</p>
</td></tr>
<tr><td><code id="r_to_py.iteror_+3A_convert">convert</code></td>
<td>
<p>does nothing.</p>
</td></tr>
<tr><td><code id="r_to_py.iteror_+3A_...">...</code></td>
<td>
<p>Passed along to <code><a href="#topic+iteror">iteror(x, ...)</a></code>.</p>
</td></tr>
<tr><td><code id="r_to_py.iteror_+3A_obj">obj</code></td>
<td>
<p>A Python object (as viewed by package <code>reticulate</code>.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>r_to_py(it)</code> returns a Python iterator.
</p>
<p>Method <code>iteror.python.builtin.object</code> returns an <a href="#topic+iteror">iteror</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pit &lt;- reticulate::r_to_py(iseq(2, 11, 5))
reticulate::iter_next(pit, NULL)
reticulate::iter_next(pit, NULL)
reticulate::iter_next(pit, NULL)

# create an R iterator and ask Python to sum it
triangulars &lt;- icount() |&gt; i_accum() |&gt; i_limit(10)
builtins &lt;- reticulate::import_builtins()
builtins$sum(triangulars) # r_to_py is called automatically

# create a generator in Python and sum it in R
pit &lt;- reticulate::py_eval("(n for n in range(1, 25) if n % 3 == 0)")
sum(iteror(pit))
</code></pre>

<hr>
<h2 id='record'>Record and replay iterators</h2><span id='topic+record'></span><span id='topic+ireplay'></span>

<h3>Description</h3>

<p>The <code>record</code> function records the values issued by a specified
iterator to a file or connection object.  The <code>ireplay</code> function
returns an iterator that will replay those values.  This is useful for
iterating concurrently over multiple, large matrices or data frames that you
can't keep in memory at the same time.  These large objects can be recorded
to files one at a time, and then be replayed concurrently using minimal
memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record(iterable, con, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="record_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to record to the file.</p>
</td></tr>
<tr><td><code id="record_+3A_con">con</code></td>
<td>
<p>A file path or open connection.</p>
</td></tr>
<tr><td><code id="record_+3A_...">...</code></td>
<td>
<p>passed along to <code>iteror(iterable, ...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from the <code>itertools</code> package.
</p>


<h3>Value</h3>

<p>NULL, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
suppressMessages(library(foreach))

m1 &lt;- matrix(rnorm(70), 7, 10)
f1 &lt;- tempfile()
record(iteror(m1, by='row', chunkSize=3), f1)

m2 &lt;- matrix(1:50, 10, 5)
f2 &lt;- tempfile()
record(iteror(m2, by='column', chunkSize=3), f2)

# Perform a simple out-of-core matrix multiply
p &lt;- foreach(col=ireplay(f2), .combine='cbind') %:%
       foreach(row=ireplay(f1), .combine='rbind') %do% {
         row %*% col
       }

dimnames(p) &lt;- NULL
print(p)
all.equal(p, m1 %*% m2)
unlink(c(f1, f2))

</code></pre>

<hr>
<h2 id='reduce'>Compute the sum, product, or general reduction of an iterator.</h2><span id='topic+reduce'></span><span id='topic+reduce.iteror'></span><span id='topic+i_accum'></span><span id='topic+sum.iteror'></span><span id='topic+prod.iteror'></span>

<h3>Description</h3>

<p><code>reduce(obj, fun)</code> applies a 2-argument function <code>fun</code> between
successive elements of obj. For example if <code>fun</code> is <code>+</code>,
<code style="white-space: pre;">&#8288;reduce(it, &#8288;</code>+<code style="white-space: pre;">&#8288;, init=0)&#8288;</code> computes <code>0 + nextElem(it) + nextElem(it) + nextElem(it) + ...</code> until the iterator finishes,
and returns the final value.
</p>
<p><code>i_accum(obj)</code> returns the iterator containing
each intermediate result. The default settings
produce a cumulative sum.
</p>
<p><code>sum.iteror(it)</code> is equivalent to <code>reduce(it, `+`)</code>
</p>
<p><code>prod.iteror(it)</code> is equivalent to <code>reduce(it, `*`)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(obj, fun = `+`, init = 0, ...)

## S3 method for class 'iteror'
reduce(obj, fun = `+`, init = 0, ...)

i_accum(obj, fun = `+`, init = 0, ...)

## S3 method for class 'iteror'
sum(..., na.rm = FALSE)

## S3 method for class 'iteror'
prod(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_+3A_obj">obj</code></td>
<td>
<p>an iterable object</p>
</td></tr>
<tr><td><code id="reduce_+3A_fun">fun</code></td>
<td>
<p>A function of as least two arguments.</p>
</td></tr>
<tr><td><code id="reduce_+3A_init">init</code></td>
<td>
<p>A starting value.</p>
</td></tr>
<tr><td><code id="reduce_+3A_...">...</code></td>
<td>
<p>Extra parameters will be passed to each call to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="reduce_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to drop NA values when computing sum or prod.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of accumulation.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- icount(5)
total &lt;- reduce(it, `+`) # 15

it &lt;- icount(5)
reduce(it, paste0, "") # "12345"

it &lt;- icount(5)
reduce(it, `*`, init=1) # 120

# triangular numbers: 1, 1+2, 1+2+3, ...
take(i_accum(icount()), 10, 'numeric')
</code></pre>

<hr>
<h2 id='take'>Return the first n elements of an iterable object in a vector.</h2><span id='topic+take'></span><span id='topic+take.default'></span><span id='topic+take.iteror'></span>

<h3>Description</h3>

<p>Returns the first <code>n</code> elements of an iterable <code>object</code> as a list.
If <code>n</code> is larger than the number of elements in <code>object</code>, the
entire iterator is consumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>take(obj, n = 1, mode = "list", ...)

## Default S3 method:
take(obj, n = 1, mode = "list", ...)

## S3 method for class 'iteror'
take(obj, n = 1, mode = "list", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="take_+3A_obj">obj</code></td>
<td>
<p>An iterable object.</p>
</td></tr>
<tr><td><code id="take_+3A_n">n</code></td>
<td>
<p>The maximum number of elements to extract from the iteror.</p>
</td></tr>
<tr><td><code id="take_+3A_mode">mode</code></td>
<td>
<p>The mode of vector to return.</p>
</td></tr>
<tr><td><code id="take_+3A_...">...</code></td>
<td>
<p>Further arguments may be passed along to the <a href="#topic+iteror">iteror</a> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function <code>take</code> first appeared in package <code>itertools2</code>.
It is basically an alias for <a href="base.html#topic+as.list">as.list</a> but defaults to n=1.
</p>


<h3>Value</h3>

<p>a list of the first <code>n</code> items of the iterable
<code>obj</code>
</p>


<h3>See Also</h3>

<p>concat as.vector.iteror
</p>
<p>as.vector.iteror
</p>


<h3>Examples</h3>

<pre><code class='language-R'>take(1:10, 3) # 1 2 3
take(icount(), 10) # 1:10
take(icount(5), 10) # 1 2 3 4 5
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
