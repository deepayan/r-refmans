<!DOCTYPE html><html lang="en-US"><head><title>Help for package CrossClustering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CrossClustering}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CrossClustering-package'><p>CrossClustering: A Partial Clustering Algorithm</p></a></li>
<li><a href='#ari'><p>Computes the adjusted Rand index and the confidence interval, comparing</p>
two classifications from a contingency table.</a></li>
<li><a href='#cc_crossclustering'><p>A partial clustering algorithm with automatic estimation of the</p>
number of clusters and identification of outliers</a></li>
<li><a href='#cc_get_cluster'><p>Provides the vector of clusters' ID to which each element belong to.</p></a></li>
<li><a href='#cc_test_ari'><p>A test for testing the null hypothesis of random</p>
agreement (i.e., adjusted Rand Index equal to 0) between two partitions.</a></li>
<li><a href='#cc_test_ari_permutation'><p>A permutation test for testing the null hypothesis of</p>
random agreement (i.e., adjusted Rand Index equal to 0) between
two partitions.</a></li>
<li><a href='#chain_effect'><p>A toy dataset for illustrating the chain effect.</p></a></li>
<li><a href='#consensus_cluster'><p>Get clusters which reach max consensus</p></a></li>
<li><a href='#is_zero'><p>Check for zero</p></a></li>
<li><a href='#nb_data'><p>RNA-Seq dataset example</p></a></li>
<li><a href='#prune_zero_tail'><p>Prune tail made of zeros</p></a></li>
<li><a href='#reverse_table'><p>Reverse the process of create a contingency table</p></a></li>
<li><a href='#toy'><p>A toy example matrix</p></a></li>
<li><a href='#twomoons'><p>A famous shape data set containing two clusters with two moons shapes and</p>
outliers</a></li>
<li><a href='#worms'><p>A famous shape data set containing two clusters with two worms shapes and</p>
outliers</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Partial Clustering Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paola Tellaroli &lt;paola.tellaroli@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide the 'CrossClustering' algorithm (Tellaroli et al.
    (2016) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0152333">doi:10.1371/journal.pone.0152333</a>&gt;), which is a partial
    clustering algorithm that combines the Ward's minimum variance and
    Complete Linkage algorithms, providing automatic estimation of a
    suitable number of clusters and identification of outlier elements.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=CrossClustering">https://CRAN.R-project.org/package=CrossClustering</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CorradoLanera/CrossClustering/issues">https://github.com/CorradoLanera/CrossClustering/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, cluster, crayon, dplyr, flip, mclust, purrr,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, devtools, lintr, roxygen2, spelling, testthat, usethis</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 15:43:56 UTC; corra</td>
</tr>
<tr>
<td>Author:</td>
<td>Paola Tellaroli [cre, aut],
  Marco Bazzi [aut],
  Michele Donato [aut],
  Livio Finos [aut],
  Philippe Courcoux [aut],
  Corrado Lanera [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-14 09:30:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='CrossClustering-package'>CrossClustering: A Partial Clustering Algorithm</h2><span id='topic+CrossClustering'></span><span id='topic+CrossClustering-package'></span>

<h3>Description</h3>

<p>Provide the 'CrossClustering' algorithm (Tellaroli et al. (2016) <a href="https://doi.org/10.1371/journal.pone.0152333">doi:10.1371/journal.pone.0152333</a>), which is a partial clustering algorithm that combines the Ward's minimum variance and Complete Linkage algorithms, providing automatic estimation of a suitable number of clusters and identification of outlier elements.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paola Tellaroli <a href="mailto:paola.tellaroli@gmail.com">paola.tellaroli@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Marco Bazzi <a href="mailto:bazzi@stat.unipd.it">bazzi@stat.unipd.it</a>
</p>
</li>
<li><p> Michele Donato <a href="mailto:mdonato@stanford.edu">mdonato@stanford.edu</a>
</p>
</li>
<li><p> Livio Finos <a href="mailto:livio.finos@unipd.it">livio.finos@unipd.it</a>
</p>
</li>
<li><p> Philippe Courcoux <a href="mailto:philippe.courcoux@oniris-nantes.fr">philippe.courcoux@oniris-nantes.fr</a>
</p>
</li>
<li><p> Corrado Lanera <a href="mailto:corrado.lanera@unipd.it">corrado.lanera@unipd.it</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=CrossClustering">https://CRAN.R-project.org/package=CrossClustering</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CorradoLanera/CrossClustering/issues">https://github.com/CorradoLanera/CrossClustering/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ari'>Computes the adjusted Rand index and the confidence interval, comparing
two classifications from a contingency table.</h2><span id='topic+ari'></span><span id='topic+print.ari'></span>

<h3>Description</h3>

<p>Computes the adjusted Rand index and the confidence interval, comparing
two classifications from a contingency table.
</p>
<p>print method for ari class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ari(mat, alpha = 0.05, digits = 2)

## S3 method for class 'ari'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ari_+3A_mat">mat</code></td>
<td>
<p>A matrix of integers representing the contingency table of
reference</p>
</td></tr>
<tr><td><code id="ari_+3A_alpha">alpha</code></td>
<td>
<p>A single number strictly included between 0 and 1
representing the significance level of interest. (default is 0.05)</p>
</td></tr>
<tr><td><code id="ari_+3A_digits">digits</code></td>
<td>
<p>An integer for the returned significant digits to return
(default is 2)</p>
</td></tr>
<tr><td><code id="ari_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="ari_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjusted Rand Index (ARI) should be interpreted as follows:
</p>
<p>ARI &gt;= 0.90 excellent recovery;
0.80 =&lt; ARI &lt; 0.90 good recovery;
0.65 =&lt; ARI &lt; 0.80 moderate recovery;
ARI &lt; 0.65 poor recovery.
</p>
<p>As the confidence interval is based on the approximation to the Normal
distribution, it is recommended to trust in the confidence interval only
in cases of total number of object clustered greater than 100.
</p>


<h3>Value</h3>

<p>An object of class <code>ari</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>AdjustedRandIndex</code></td>
<td>
<p>The adjusted Rand Index</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>The confidence interval</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(ari)</code>: 
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Paola Tellaroli, &lt;paola <code>dot</code> tellaroli <code>at</code> unipd <code>dot</code> it&gt;;
</p>


<h3>References</h3>

<p>L. Hubert and P. Arabie (1985) Comparing partitions, Journal of
Classification, 2, 193-218.
</p>
<p>E.M. Qannari, P. Courcoux and Faye P. (2014) Significance test of the
adjusted Rand index. Application to the free sorting task, Food Quality
and Preference, (32)93-97
</p>
<p>M.H. Samuh, F. Leisch, and L. Finos (2014), Tests for Random Agreement
in Cluster Analysis, Statistica Applicata-Italian Journal of Applied
Statistics, vol. 26, no. 3, pp. 219-234.
</p>
<p>D. Steinley (2004) Properties of the Hubert-Arabie Adjusted Rand Index,
Psychological Methods, 9(3), 386-396
</p>
<p>D. Steinley, M.J. Brusco, L. Hubert (2016) The Variance of the Adjusted
Rand Index, Psychological Methods, 21(2), 261-272
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### This example compares the adjusted Rand Index as computed on the
### partitions given by Ward's algorithm with the ground truth on the
### famous Iris data set by the adjustedRandIndex function
### {mclust package} and by the ari function.

library(CrossClustering)
library(mclust)

clusters &lt;- iris[-5] |&gt;
  dist() |&gt;
  hclust(method = 'ward.D') |&gt;
  cutree(k = 3)

ground_truth &lt;- iris[[5]] |&gt; as.numeric()

mc_ari &lt;- adjustedRandIndex(clusters, ground_truth)
mc_ari

ari_cc &lt;- table(ground_truth, clusters) |&gt;
  ari(digits = 7)
ari_cc

all.equal(mc_ari, unclass(ari_cc)[["ari"]], check.attributes = FALSE)

</code></pre>

<hr>
<h2 id='cc_crossclustering'>A partial clustering algorithm with automatic estimation of the
number of clusters and identification of outliers</h2><span id='topic+cc_crossclustering'></span><span id='topic+print.crossclustering'></span>

<h3>Description</h3>

<p>This function performs the CrossClustering algorithm. This method
combines the Ward's minimum variance and Complete-linkage (default,
useful for finding spherical clusters) or Single-linkage (useful for
finding elongated clusters) algorithms, providing automatic
estimation of a suitable number of clusters and identification of
outlier elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_crossclustering(
  dist,
  k_w_min = 2,
  k_w_max = attr(dist, "Size") - 2,
  k2_max = k_w_max + 1,
  out = TRUE,
  method = c("complete", "single")
)

## S3 method for class 'crossclustering'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_crossclustering_+3A_dist">dist</code></td>
<td>
<p>A dissimilarity structure as produced by the function
<code>dist</code></p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_k_w_min">k_w_min</code></td>
<td>
<p>(int) Minimum number of clusters for the Ward's
minimum variance method. By default is set equal 2</p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_k_w_max">k_w_max</code></td>
<td>
<p>(int) Maximum number of clusters for the Ward's
minimum variance method (see details)</p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_k2_max">k2_max</code></td>
<td>
<p>(int) Maximum number of clusters for the
Complete/Single-linkage method. It can not be equal or greater than
the number of elements to cluster (see details)</p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_out">out</code></td>
<td>
<p>(lgl) If <code>TRUE</code> (default) outliers must be searched
(see details)</p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_method">method</code></td>
<td>
<p>(chr) &quot;complete&quot; (default) or &quot;single&quot;. CrossClustering
combines Ward's algorithm with Complete-linkage if method is set to
&quot;complete&quot;, otherwise (if method is set to 'single') Single-linkage
will be used.</p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="cc_crossclustering_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See cited document for more details.
</p>


<h3>Value</h3>

<p>A list of objects describing characteristics of the
partitioning as follows:
</p>
<table role = "presentation">
<tr><td><code>Optimal_cluster</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code>cluster_list_elements</code></td>
<td>
<p>a list of clusters; each element of this
lists contains the indices of the elements belonging to the
cluster</p>
</td></tr>
<tr><td><code>Silhouette</code></td>
<td>
<p>the average silhouette width over all the clusters</p>
</td></tr>
<tr><td><code>n_total</code></td>
<td>
<p>total number of input elements</p>
</td></tr>
<tr><td><code>n_clustered</code></td>
<td>
<p>number of input elements that have actually
been clustered</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print(crossclustering)</code>: 
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Paola Tellaroli, &lt;paola <code>dot</code> tellaroli <code>at</code> unipd <code>dot</code> it&gt;;;
Marco Bazzi, &lt;bazzi <code>at</code> stat <code>dot</code> unipd <code>dot</code> it&gt;;
Michele Donato, &lt;mdonato <code>at</code> stanford <code>dot</code> edu&gt;
</p>


<h3>References</h3>

<p>Tellaroli P, Bazzi M., Donato M., Brazzale A. R., Draghici S. (2016).
Cross-Clustering: A Partial Clustering Algorithm with Automatic
Estimation of the Number of Clusters. PLoS ONE 11(3):   e0152333.
doi:10.1371/journal.pone.0152333
</p>
<p>#' Tellaroli P, Bazzi M., Donato M., Brazzale A. R., Draghici S. (2017).
E1829: Cross-Clustering: A Partial Clustering Algorithm with Automatic
Estimation of the Number of Clusters. CMStatistics 2017, London 16-18
December, Book of Abstracts (ISBN 978-9963-2227-4-2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CrossClustering)

#### Example of Cross-Clustering as in reference paper
#### method = "complete"

data(toy)

### toy is transposed as we want to cluster samples (columns of the
### original matrix)
toy_dist &lt;- t(toy) |&gt;
  dist(method = "euclidean")

### Run CrossClustering
cc_crossclustering(
  toy_dist,
  k_w_min = 2,
  k_w_max = 5,
  k2_max = 6,
  out = TRUE
)

#### Simulated data as in reference paper
#### method = "complete"
set.seed(10)
sg &lt;- c(500, 250, 700, 300, 100)

# 5 clusters

t &lt;- matrix(0, nrow = 5, ncol = 5)
t[1, ] &lt;- rep(6, 5)
t[2, ] &lt;- c( 0,  5, 12, 13, 15)
t[3, ] &lt;- c(15, 11,  9,  5,  0)
t[4, ] &lt;- c( 6, 12, 15, 10,  5)
t[5, ] &lt;- c(12, 17,  3,  7, 10)

t_mat &lt;- NULL
for (i in seq_len(nrow(t))) {
  t_mat &lt;- rbind(
    t_mat,
    matrix(rep(t[i, ], sg[i]), nrow = sg[i], byrow = TRUE)
  )
}

data_15 &lt;- matrix(NA, nrow = 2000, ncol = 5)
data_15[1:1850, ] &lt;- matrix(
  abs(rnorm(sum(sg) * 5, sd = 1.5)),
  nrow = sum(sg),
  ncol = 5
) + t_mat

set.seed(100) # simulate outliers
data_15[1851:2000, ] &lt;- matrix(
  runif(n = 150 * 5, min = 0, max = max(data_15, na.rm = TRUE)),
  nrow = 150,
  ncol = 5
)

### Run CrossClustering
cc_crossclustering(
  dist(data_15),
  k_w_min = 2,
  k_w_max = 19,
  k2_max = 20,
  out = TRUE
)


#### Correlation-based distance is often used in gene expression time-series
### data analysis. Here there is an example, using the "complete" method.

data(nb_data)
nb_dist &lt;- as.dist(1 - abs(cor(t(nb_data))))
cc_crossclustering(dist = nb_dist, k_w_max = 20, k2_max = 19)




#### method = "single"
### Example on a famous shape data set
### Two moons data

data(twomoons)

moons_dist &lt;- twomoons[, 1:2] |&gt;
  dist(method = "euclidean")

cc_moons &lt;- cc_crossclustering(
  moons_dist,
  k_w_max = 9,
  k2_max = 10,
  method = 'single'
)

moons_col &lt;- cc_get_cluster(cc_moons)
plot(
  twomoons[, 1:2],
  col = moons_col,
  pch      = 19,
  xlab     = "",
  ylab     = "",
  main     = "CrossClustering-Single"
)

### Worms data
data(worms)

worms_dist &lt;- worms[, 1:2] |&gt;
  dist(method = "euclidean")

cc_worms &lt;- cc_crossclustering(
  worms_dist,
  k_w_max = 9,
  k2_max  = 10,
  method  = "single"
)

worms_col &lt;-  cc_get_cluster(cc_worms)

plot(
  worms[, 1:2],
  col = worms_col,
  pch = 19,
  xlab = "",
  ylab = "",
  main = "CrossClustering-Single"
)


### CrossClustering-Single is not affected to chain-effect problem

data(chain_effect)

chain_dist &lt;- chain_effect |&gt;
  dist(method = "euclidean")
cc_chain &lt;- cc_crossclustering(
  chain_dist,
  k_w_max = 9,
  k2_max = 10,
  method = "single"
)

chain_col &lt;- cc_get_cluster(cc_chain)

plot(
  chain_effect,
  col = chain_col,
  pch = 19,
  xlab = "",
  ylab = "",
  main = "CrossClustering-Single"
)

</code></pre>

<hr>
<h2 id='cc_get_cluster'>Provides the vector of clusters' ID to which each element belong to.</h2><span id='topic+cc_get_cluster'></span><span id='topic+cc_get_cluster.default'></span><span id='topic+cc_get_cluster.crossclustering'></span>

<h3>Description</h3>

<p>Provides the vector of clusters' ID to which each element belong to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_get_cluster(x, n_elem)

## Default S3 method:
cc_get_cluster(x, n_elem)

## S3 method for class 'crossclustering'
cc_get_cluster(x, n_elem)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_get_cluster_+3A_x">x</code></td>
<td>
<p>list of clustered elements or a <code>crossclustering</code> object</p>
</td></tr>
<tr><td><code id="cc_get_cluster_+3A_n_elem">n_elem</code></td>
<td>
<p>total number of elements clustered (ignored if x
is of class <code>crossclustering</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of clusters to which the elements belong (<code>1</code>
for the outliers, ID + 1 for the others).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>cc_get_cluster(default)</code>: default method for <a href="#topic+cc_get_cluster">cc_get_cluster</a>.
</p>
</li>
<li> <p><code>cc_get_cluster(crossclustering)</code>: automatically extract inputs from a
<code>crossclustering</code> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Paola Tellaroli, &lt;paola <code>dot</code> tellaroli <code>at</code> unipd <code>dot</code> it&gt;;;
Marco Bazzi, &lt;bazzi <code>at</code> stat <code>dot</code> unipd <code>dot</code> it&gt;;
Michele Donato, &lt;mdonato <code>at</code> stanford <code>dot</code> edu&gt;.
</p>


<h3>References</h3>

<p>Tellaroli P, Bazzi M., Donato M., Brazzale A. R., Draghici S. (2016).
Cross-Clustering: A Partial Clustering Algorithm with Automatic
Estimation of the Number of Clusters. PLoS ONE 11(3):   e0152333.
doi:10.1371/journal.pone.0152333
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CrossClustering)

data(toy)

### toy is transposed as we want to cluster samples (columns of the
### original matrix)
toy_dist &lt;- t(toy) |&gt;
  dist(method = "euclidean")

### Run CrossClustering
toyres &lt;- cc_crossclustering(
  toy_dist,
  k_w_min = 2,
  k_w_max = 5,
  k2_max  = 6,
  out     = TRUE
)

### cc_get_cluster
cc_get_cluster(toyres[], 7)


### cc_get_cluster directly from a crossclustering object
cc_get_cluster(toyres)
</code></pre>

<hr>
<h2 id='cc_test_ari'>A test for testing the null hypothesis of random
agreement (i.e., adjusted Rand Index equal to 0) between two partitions.</h2><span id='topic+cc_test_ari'></span>

<h3>Description</h3>

<p>A test for testing the null hypothesis of random
agreement (i.e., adjusted Rand Index equal to 0) between two partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_test_ari(ground_truth, partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_test_ari_+3A_ground_truth">ground_truth</code></td>
<td>
<p>(int) A vector of the actual membership of elements
in clusters</p>
</td></tr>
<tr><td><code id="cc_test_ari_+3A_partition">partition</code></td>
<td>
<p>The partition coming from a clustering algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six elements:
</p>
<table role = "presentation">
<tr><td><code>Rand</code></td>
<td>
<p>the Rand Index</p>
</td></tr>
<tr><td><code>ExpectedRand</code></td>
<td>
<p>expected value of  Rand Index</p>
</td></tr>
<tr><td><code>AdjustedRand</code></td>
<td>
<p>Adjusted Rand Index</p>
</td></tr>
<tr><td><code>var_ari</code></td>
<td>
<p>variance of Rand Index</p>
</td></tr>
<tr><td><code>nari</code></td>
<td>
<p>nari</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>
<p>the p-value of the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paola Tellaroli, &lt;paola <code>dot</code> tellaroli <code>at</code> unipd <code>dot</code> it&gt;;
Philippe Courcoux, &lt;philippe <code>dot</code> courcoux <code>at</code> oniris-nantes <code>dot</code> fr&gt;
</p>


<h3>References</h3>

<p>E_M. Qannari, p. Courcoux and Faye p. (2014) Significance test of the
adjusted Rand index. Application to the free sorting task, Food Quality
and Preference, (32)93-97
</p>
<p>L. Hubert and p. Arabie (1985) Comparing partitions, Journal of
Classification, 2, 193-218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CrossClustering)

clusters &lt;- iris[-5] |&gt;
  dist() |&gt;
  hclust(method = 'ward.D') |&gt;
  cutree(k = 3)

ground_truth &lt;- iris[[5]] |&gt;
  as.numeric()

cc_test_ari(ground_truth, clusters)

</code></pre>

<hr>
<h2 id='cc_test_ari_permutation'>A permutation test for testing the null hypothesis of
random agreement (i.e., adjusted Rand Index equal to 0) between
two partitions.</h2><span id='topic+cc_test_ari_permutation'></span>

<h3>Description</h3>

<p>A permutation test for testing the null hypothesis of
random agreement (i.e., adjusted Rand Index equal to 0) between
two partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_test_ari_permutation(ground_truth, partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_test_ari_permutation_+3A_ground_truth">ground_truth</code></td>
<td>
<p>(int) A vector of the actual membership of elements
in clusters</p>
</td></tr>
<tr><td><code id="cc_test_ari_permutation_+3A_partition">partition</code></td>
<td>
<p>The partition coming from a clustering algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data_frame with two columns:
</p>
<table role = "presentation">
<tr><td><code>ari</code></td>
<td>
<p>the adjusted Rand Index</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>the p-value of the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paola Tellaroli, &lt;paola <code>dot</code> tellaroli <code>at</code> unipd <code>dot</code> it&gt;;
Livio Finos, &lt;livio <code>dot</code> finos <code>at</code> unipd <code>dot</code> it&gt;
</p>


<h3>References</h3>

<p>Samuh M. H., Leisch F., and Finos L. (2014), Tests for Random Agreement
in Cluster Analysis, Statistica Applicata-Italian Journal of Applied
Statistics, vol. 26, no. 3, pp. 219-234.
</p>
<p>L. Hubert and P. Arabie (1985) Comparing partitions, Journal of
Classification, 2, 193-218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CrossClustering)

clusters &lt;- iris[-5] |&gt;
  dist() |&gt;
  hclust(method = 'ward.D') |&gt;
  cutree(k = 3)

ground_truth &lt;- iris[[5]] |&gt;
  as.numeric()

cc_test_ari_permutation(ground_truth, clusters)

</code></pre>

<hr>
<h2 id='chain_effect'>A toy dataset for illustrating the chain effect.</h2><span id='topic+chain_effect'></span>

<h3>Description</h3>

<p>A toy dataset for illustrating the chain effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain_effect
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows and 2 variables:
</p>

<dl>
<dt><code>X</code></dt><dd><p>num</p>
</dd></dl>
<p> x coordinates
0 is negative.
</p>
<dl>
<dt><code>Y</code></dt><dd><p>num</p>
</dd></dl>
<p> y coordinates.

</p>

<hr>
<h2 id='consensus_cluster'>Get clusters which reach max consensus</h2><span id='topic+consensus_cluster'></span>

<h3>Description</h3>

<p>Computes the consensus between Ward's minimum variance and
Complete-linkage (or Single-linkage) algorithms (i.e., the number of
elements classified together by both algorithms).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_cluster(k, cluster_ward, cluster_other)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus_cluster_+3A_k">k</code></td>
<td>
<p>(int) a vector containing the number of clusters for Ward and
for Complete-linkage (or Single-linkage) algorithms, respectively</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_cluster_ward">cluster_ward</code></td>
<td>
<p>an object of class hclust for the Ward algorithm</p>
</td></tr>
<tr><td><code id="consensus_cluster_+3A_cluster_other">cluster_other</code></td>
<td>
<p>an object of class hclust for the
Complete-linkage (or Single-linkage) algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>consensus_cluster</code> with the following
elements:
</p>
<table role = "presentation">
<tr><td><code>elements</code></td>
<td>

<p>list of the elements belonging to each cluster
</p>
</td></tr></table>
<p>;
</p>
<table role = "presentation">
<tr><td><code>a_star</code></td>
<td>
<p>contingency table of the clustering</p>
</td></tr></table>
<p>;
</p>
<table role = "presentation">
<tr><td><code>max_consensus</code></td>
<td>
<p>maximum clustering consensus</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Paola Tellaroli, &lt;paola <code>dot</code> tellaroli <code>at</code> unipd <code>dot</code> it&gt;;;
Marco Bazzi, &lt;bazzi <code>at</code> stat <code>dot</code> unipd <code>dot</code> it&gt;;
Michele Donato, &lt;mdonato <code>at</code> stanford <code>dot</code> edu&gt;.
</p>


<h3>References</h3>

<p>Tellaroli P, Bazzi M., Donato M., Brazzale A. R., Draghici S. (2016).
Cross-Clustering: A Partial Clustering Algorithm with Automatic
Estimation of the Number of Clusters. PLoS ONE 11(3):   e0152333.
doi:10.1371/journal.pone.0152333
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CrossClustering)

data(toy)

### toy is transposed as we want to cluster samples (columns of the
### original matrix)
toy_dist &lt;- t(toy) |&gt;
  dist(method = "euclidean")

### Hierarchical clustering
cluster_ward &lt;- toy_dist |&gt;
  hclust(method = "ward.D")
cluster_other &lt;- toy_dist |&gt;
  hclust(method = "complete")


### consensus_cluster
consensus_cluster(
  c(3, 4),
  cluster_ward,
  cluster_other
)

</code></pre>

<hr>
<h2 id='is_zero'>Check for zero</h2><span id='topic+is_zero'></span>

<h3>Description</h3>

<p>Check if a given, single, number is 0 or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_zero(num)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_zero_+3A_num">num</code></td>
<td>
<p>a numerical vector of length one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if num is 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_zero(1)
is_zero(0)
</code></pre>

<hr>
<h2 id='nb_data'>RNA-Seq dataset example</h2><span id='topic+nb_data'></span>

<h3>Description</h3>

<p><code>nb_data</code> contains a subset of a bigger normalized negative binomial
simulated dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on 36 numeric variables.
</p>


<h3>Details</h3>

<p>This dataset is part of a larger simulated and normalized dataset with 2
experimental groups, 6 time-points and 3 replicates. Simulation has been done
by using a negative binomial distribution. The first 20 genes are simulated
with changes among time.
</p>


<h3>Source</h3>

<p>Data included in the bioconductor package <code>maSigPro</code>.
<a href="https://doi.org/doi:10.18129/B9.bioc.maSigPro">https://doi.org/doi:10.18129/B9.bioc.maSigPro</a>
</p>

<hr>
<h2 id='prune_zero_tail'>Prune tail made of zeros</h2><span id='topic+prune_zero_tail'></span>

<h3>Description</h3>

<p>Given a diagonal matrix which is supposed to have no non-zero entry in
the diagonal after the first one (if any) the  function returns the
diagonal (sub-)matrix without the columns and the row corresponding to
the zero-entries in the diagonal (if any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_zero_tail(diag_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune_zero_tail_+3A_diag_mat">diag_mat</code></td>
<td>
<p>a diagonal matrix which must satisfy the following
property: in the diagonal, every element after a zero is a zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagonal matrix without zeros in the diagonal, composed by the
first rows and columns of the original matrix with non zeros in the
diagonal (which are also the only ones)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diag_mat &lt;- diag(c(1, 2, 3, 0, 0, 0, 0))
prune_zero_tail(diag_mat)
</code></pre>

<hr>
<h2 id='reverse_table'>Reverse the process of create a contingency table</h2><span id='topic+reverse_table'></span>

<h3>Description</h3>

<p>Reverse the process of create a contingency table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_table(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_table_+3A_x">x</code></td>
<td>
<p>a contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 vector corresponding to the unrolled table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clust_1 &lt;- iris[, 1:4] |&gt;
  dist() |&gt;
  hclust() |&gt;
  cutree(k = 3)
clust_2 &lt;- iris[, 1:4] |&gt;
  dist() |&gt;
  hclust() |&gt;
  cutree(k = 4)
cont_table &lt;- table(clust_1, clust_2)

reverse_table(cont_table)
</code></pre>

<hr>
<h2 id='toy'>A toy example matrix</h2><span id='topic+toy'></span>

<h3>Description</h3>

<p>A toy example matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy
</code></pre>


<h3>Format</h3>

<p>A matrix of 10 row and 7 columns
</p>

<hr>
<h2 id='twomoons'>A famous shape data set containing two clusters with two moons shapes and
outliers</h2><span id='topic+twomoons'></span>

<h3>Description</h3>

<p>A famous shape data set containing two clusters with two moons shapes and
outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twomoons
</code></pre>


<h3>Format</h3>

<p>A data frame with 52 rows and 3 variables:
</p>

<dl>
<dt><code>x</code></dt><dd><p>num</p>
</dd></dl>
<p> x coordinates
</p>
<dl>
<dt><code>y</code></dt><dd><p>num</p>
</dd></dl>
<p> y coordinates.
</p>
<dl>
<dt><code>clusters</code></dt><dd><p>integer</p>
</dd></dl>
<p> cluster membership (outliers
classified as 3rd cluster).

</p>

<hr>
<h2 id='worms'>A famous shape data set containing two clusters with two worms shapes and
outliers</h2><span id='topic+worms'></span>

<h3>Description</h3>

<p>A famous shape data set containing two clusters with two worms shapes and
outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worms
</code></pre>


<h3>Format</h3>

<p>A data frame with 87 rows and 3 variables:
</p>

<dl>
<dt><code>x</code></dt><dd><p>num</p>
</dd></dl>
<p> x coordinates
</p>
<dl>
<dt><code>y</code></dt><dd><p>num</p>
</dd></dl>
<p> y coordinates.
</p>
<dl>
<dt><code>cluster</code></dt><dd><p>integer</p>
</dd></dl>
<p> cluster membership (outliers classified
as 3rd cluster).

</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
