<!DOCTYPE html><html><head><title>Help for package Compind</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Compind}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Compind-package'><p>Composite Indicators - Compind</p></a></li>
<li><a href='#bandwidth_CI'><p>Multivariate mixed bandwidth selection for exogenous variables</p></a></li>
<li><a href='#BLI_2017'><p>Better Life Index 2017 indicators</p></a></li>
<li><a href='#ci_ampi'><p>Adjusted Mazziotta-Pareto Index (AMPI) method</p></a></li>
<li><a href='#ci_bod'><p>Benefit of the Doubt approach (BoD)</p></a></li>
<li><a href='#ci_bod_constr'><p>Constrained Benefit of the Doubt approach (BoD)</p></a></li>
<li><a href='#ci_bod_constr_bad'><p>Constrained Benefit of the Doubt approach (BoD) in presence of undesirable  indicators</p></a></li>
<li><a href='#ci_bod_dir'><p>Directional Benefit of the Doubt (D-BoD) model</p></a></li>
<li><a href='#ci_bod_mdir'><p>Multi-directional Benefit of the Doubt approach (MDBoD)</p></a></li>
<li><a href='#ci_bod_var_w'><p>Variance weighted Benefit of the Doubt approach (BoD variance weighted)</p></a></li>
<li><a href='#ci_factor'><p>Weighting method based on Factor Analysis</p></a></li>
<li><a href='#ci_factor_mixed'><p>Weighting method based on Factor analysis of mixed data (FAMD)</p></a></li>
<li><a href='#ci_generalized_mean'><p>Weighting method based on generalized mean</p></a></li>
<li><a href='#ci_geom_bod_intertemp'><p>Intertemporal analysis for geometric mean quantity index numbers</p></a></li>
<li><a href='#ci_geom_gen'><p>Generalized geometric mean quantity index numbers</p></a></li>
<li><a href='#ci_mean_min'><p>Mean-Min Function</p></a></li>
<li><a href='#ci_mpi'><p>Mazziotta-Pareto Index (MPI) method</p></a></li>
<li><a href='#ci_ogwa'><p>Ordered Geographically Weighted Average (OWA)</p></a></li>
<li><a href='#ci_owa'><p>Ordered Weighted Average (OWA)</p></a></li>
<li><a href='#ci_rbod'><p>Robust Benefit of the Doubt approach (RBoD)</p></a></li>
<li><a href='#ci_rbod_constr_bad'><p>Robust constrained Benefit of the Doubt approach (BoD) in presence of undesirable  indicators</p></a></li>
<li><a href='#ci_rbod_constr_bad_Q'><p>Conditional robust constrained Benefit of the Doubt approach (BoD) in presence of undesirable  indicators</p></a></li>
<li><a href='#ci_rbod_dir'><p>Directional Robust Benefit of the Doubt approach (D-RBoD)</p></a></li>
<li><a href='#ci_rbod_mdir'><p>Robust multi-directional Benefit of the Doubt approach (MDRBoD)</p></a></li>
<li><a href='#ci_rbod_spatial'><p>Spatial robust Benefit of the Doubt approach (Sp-RBoD)</p></a></li>
<li><a href='#ci_smaa_constr'><p>Constrained stochastic multi-objective acceptability analysis (C-SMAA)</p></a></li>
<li><a href='#ci_wroclaw'><p>Wroclaw Taxonomic Method</p></a></li>
<li><a href='#data_HPI'><p>Happy Planet Index 2017-2019 indicators</p></a></li>
<li><a href='#EU_2020'><p>Europe 2020 indicators</p></a></li>
<li><a href='#EU_NUTS1'><p>EU NUTS1 Transportation data</p></a></li>
<li><a href='#normalise_ci'>
<p>Normalisation and polarity functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Composite Indicators Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Francesco Vidoli, Elisa Fusco</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francesco Vidoli &lt;fvidoli@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to calculate Composite Indicators methods, focusing, in particular, on the normalisation and weighting-aggregation steps, as described in OECD Handbook on constructing composite indicators: methodology and user guide <a href="https://www.oecd-ilibrary.org/economics/handbook-on-constructing-composite-indicators-methodology-and-user-guide_9789264043466-en">https://www.oecd-ilibrary.org/economics/handbook-on-constructing-composite-indicators-methodology-and-user-guide_9789264043466-en</a>, 'Vidoli' and 'Fusco' and 'Mazziotta' &lt;<a href="https://doi.org/10.1007%2Fs11205-014-0710-y">doi:10.1007/s11205-014-0710-y</a>&gt;, 'Mazziotta' and 'Pareto' (2016) &lt;<a href="https://doi.org/10.1007%2Fs11205-015-0998-2">doi:10.1007/s11205-015-0998-2</a>&gt;, 'Van Puyenbroeck and 'Rogge' &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2016.07.038">doi:10.1016/j.ejor.2016.07.038</a>&gt; and other authors.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Benchmarking, psych, boot, lpSolve, spdep</td>
</tr>
<tr>
<td>Imports:</td>
<td>Hmisc, MASS, GPArotation, nonparaeff, smaa, np, FactoMineR,
GWmodel, sp, Rcompadre</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 12:20:40 UTC; Fra</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 12:42:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='Compind-package'>Composite Indicators - Compind</h2><span id='topic+Compind-package'></span>

<h3>Description</h3>

<p>Compind package contains functions to enhance several approaches to the Composite Indicators (CIs) methods, focusing, in particular, on the normalisation and weighting-aggregation steps.</p>


<h3>Author(s)</h3>

<p>Francesco Vidoli, Elisa Fusco
Maintainer: Francesco Vidoli &lt;fvidoli@gmail.com&gt;
</p>


<h3>References</h3>

<p>Daraio, C., Simar, L. (2005) &quot;<em>Introducing environmental variables in nonparametric frontier models: a probabilistic approach</em>&quot;, Journal of productivity analysis, 24(1), 93-121.
</p>
<p>Fusco E. (2015) &quot;<em>Enhancing non compensatory composite indicators: A directional proposal</em>&quot;, European Journal of Operational Research, 242(2), 620-630.
</p>
<p>Fusco E. (2023) &quot;<em>Potential improvements approach in composite indicators construction: the Multi-directional Benefit of the Doubt model</em>&quot;, Socio-Economic Planning Sciences, vol. 85, 101447
</p>
<p>Fusco, E., Liborio, M.P., Rabiei-Dastjerdi, H., Vidoli, F., Brunsdon, C. and Ekel, P.I. (2023), Harnessing Spatial Heterogeneity in Composite Indicators through the Ordered Geographically Weighted Averaging (OGWA) Operator. Geographical Analysis. https://doi.org/10.1111/gean.12384
</p>
<p>R. Lahdelma, P. Salminen (2001) &quot;<em>SMAA-2: Stochastic multicriteria acceptability analysis for group decision making</em>&quot;, Operations Research, 49(3), pp. 444-454
</p>
<p>OECD (2008) &quot;<em>Handbook on constructing composite indicators: methodology and user guide</em>&quot;.
</p>
<p>Mazziotta C., Mazziotta M., Pareto A., Vidoli F. (2010) &quot;<em>La sintesi di indicatori territoriali di dotazione infrastrutturale: metodi di costruzione e procedure di ponderazione a confronto</em>&quot;, Rivista di Economia e Statistica del territorio, n.1.
</p>
<p>Melyn W. and Moesen W.W. (1991) &quot;<em>Towards a synthetic indicator of macroeconomic performance: unequal weighting when limited information is available</em>&quot;, Public Economic research Paper 17, CES, KU Leuven.
</p>
<p>Van Puyenbroeck T. and Rogge N. (2017) &quot;<em>Geometric mean quantity index numbers with Benefit-of-the-Doubt weights</em>&quot;, European Journal of Operational Research, 256(3), 1004-1014.
</p>
<p>Rogge N., de Jaeger S. and Lavigne C. (2017) &quot;<em>Waste Performance of NUTS 2-regions in the EU: A Conditional Directional Distance Benefit-of-the-Doubt Model</em>&quot;, Ecological Economics, vol.139, pp. 19-32.
</p>
<p>Simar L., Vanhems A. (2012) &quot;<em>Probabilistic characterization of directional distances and their robust versions</em>&quot;, Journal of Econometrics, 166(2), 342-354.
</p>
<p>UNESCO (1974)&quot;<em>Social indicators: problems of definition and of selection</em>&quot;, Paris.
</p>
<p>Vidoli F., Fusco E., Mazziotta C. (2015) &quot;<em>Non-compensability in composite indicators: a robust directional frontier method</em>&quot;, Social Indicators Research, 122(3), 635-652.
</p>
<p>Vidoli F., Mazziotta C. (2013) &quot;<em>Robust weighted composite indicators by means of frontier methods with an application to European infrastructure endowment</em>&quot;, Statistica Applicata, Italian Journal of Applied Statistics.
</p>
<p>Zanella A., Camanho A.S. and Dias T.G. (2015) &quot;<em>Undesirable outputs and weighting schemes in composite indicators based on data envelopment analysis</em>&quot;, European Journal of Operational Research, vol. 245(2), pp. 517-530.
</p>

<hr>
<h2 id='bandwidth_CI'>Multivariate mixed bandwidth selection for exogenous variables</h2><span id='topic+bandwidth_CI'></span>

<h3>Description</h3>

<p>A function for the selection of optimal multivariate mixed bandwidths for the kernel
density estimation of continuous and discrete exogenous variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth_CI(x, indic_col, ngood, nbad, Q=NULL, Q_ord=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth_CI_+3A_x">x</code></td>
<td>
<p>A data frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="bandwidth_CI_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="bandwidth_CI_+3A_ngood">ngood</code></td>
<td>
<p>The number of desirable outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="bandwidth_CI_+3A_nbad">nbad</code></td>
<td>
<p>The number of undesirable  outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="bandwidth_CI_+3A_q">Q</code></td>
<td>
<p>A matrix containing continuous exogenous variables.</p>
</td></tr>
<tr><td><code id="bandwidth_CI_+3A_q_ord">Q_ord</code></td>
<td>
<p>A matrix containing discrete exogenous variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Author thanks Nicky Rogge for his help and for making available the original code of the bandwidth function.</p>


<h3>Value</h3>

<table>
<tr><td><code>bandwidth</code></td>
<td>
<p>A matrix containing the optimal bandwidths for the exogenous variables indicate in Q and Q_ord.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>&quot;bandwidth_CI</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Rogge N.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_2020)
indic &lt;- c("employ_2011", "gasemiss_2011","deprived_2011")  
dat   &lt;- EU_2020[-c(10,18),indic]
Q_GDP &lt;- EU_2020[-c(10,18),"percGDP_2011"]

# Conditional robust BoD Constrained VWR
band = bandwidth_CI(dat, ngood=1, nbad=2, Q = Q_GDP)
</code></pre>

<hr>
<h2 id='BLI_2017'>Better Life Index 2017 indicators</h2><span id='topic+BLI_2017'></span>

<h3>Description</h3>

<p>Data related to BLI Edition 2017 (OECD, 2017) for all 38 OECD and non-OECD countries (Data extracted on: 19\02\2020).
</p>
<p>For more info, please see <a href="https://data-explorer.oecd.org">https://data-explorer.oecd.org</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BLI_2017)</code></pre>


<h3>Format</h3>

<p>BLI_2017 is a dataset with 38 observations and 12 indicators.
</p>

<dl>
<dt>country</dt><dd><p>OECD and non-OECD countries.</p>
</dd>	
<dt>housing</dt><dd><p>Housing.</p>
</dd>	
<dt>income</dt><dd><p>Income and wealth.</p>
</dd>	
<dt>jobs</dt><dd><p>Jobs and earnings.</p>
</dd>	
<dt>community</dt><dd><p>Community engagement.</p>
</dd>	
<dt>education</dt><dd><p>Education.</p>
</dd>	
<dt>environment</dt><dd><p>Environment quality.</p>
</dd>	
<dt>civic</dt><dd><p>Civic engagement.</p>
</dd>	
<dt>health</dt><dd><p>Health.</p>
</dd>	
<dt>satisfaction</dt><dd><p>Life satisfaction.</p>
</dd>	
<dt>safety</dt><dd><p>Personal security (safety).</p>
</dd>	
<dt>worklife</dt><dd><p>Work-Life balance.</p>
</dd>	
</dl>


<h3>Author(s)</h3>

<p>Fusco E.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BLI_2017)</code></pre>

<hr>
<h2 id='ci_ampi'>Adjusted Mazziotta-Pareto Index (AMPI) method</h2><span id='topic+ci_ampi'></span>

<h3>Description</h3>

<p>Adjusted Mazziotta-Pareto Index (AMPI) is a non-compensatory composite index that allows to take into account the time dimension, too. The calculation part is similat to the MPI framework, but the standardization part make the scores obtained over the years comparable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_ampi(x, indic_col, gp, time, polarity, penalty = "NEG")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_ampi_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators in a Long Data Format.</p>
</td></tr>
<tr><td><code id="ci_ampi_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_ampi_+3A_gp">gp</code></td>
<td>
<p>Goalposts; to facilitate the interpretation of results, the <code>goalposts</code> can be chosen so that 100 represents a reference value (e.g., the average in a given year).</p>
</td></tr>
<tr><td><code id="ci_ampi_+3A_time">time</code></td>
<td>
<p>The time variable (mandatory); if the analysis is carried out over a single year, it is necessary to create a constant variable (i.e. <code>dataframe@year &lt;- 2014</code>).</p>
</td></tr>
<tr><td><code id="ci_ampi_+3A_polarity">polarity</code></td>
<td>
<p>Polarity vector: &quot;POS&quot; = positive, &quot;NEG&quot; = negative. The polarity of a individual indicator is the sign of the relationship between the indicator and the phenomenon to be measured (e.g., in a well-being index, &quot;GDP per capita&quot; has 'positive' polarity and &quot;Unemployment rate&quot; has 'negative' polarity).</p>
</td></tr>
<tr><td><code id="ci_ampi_+3A_penalty">penalty</code></td>
<td>
<p>Penalty direction; Use &quot;NEG&quot; (default) in case of 'increasing' or 'positive' composite index (e.g., well-being index)), &quot;POS&quot; in case of 'decreasing' or 'negative' composite index (e.g., poverty index).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Author thanks Leonardo Alaimo for their help and for making available the original code of the AMPI function. Federico Roscioli for his integrations to the original code.</p>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_ampi_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;ampi&quot;.</p>
</td></tr>
<tr><td><code>ci_penalty</code></td>
<td>
<p>Matrix containing penalties only.</p>
</td></tr>
<tr><td><code>ci_norm</code></td>
<td>
<p>List containing only the normalised indicators for each year.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Alaimo L., Giovagnoli C., Patelli L., F. Roscioli</p>


<h3>References</h3>

<p>Mazziotta, M., Pareto, A. (2013) &quot;<em>A Non-compensatory Composite Index for Measuring Well-being over Time</em>&quot;, Cogito. Multidisciplinary Research Journal Vol. V, no. 4, pp. 93-104
</p>
<p>Mazziotta, M., Pareto, A. (2016).&quot;<em>On a Generalized Non-compensatory Composite Index for Measuring Socio-economic Phenomena</em>&quot;, Cogito. Social Indicators Research, Vol. 127, no. 3, pp. 983-1003
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+normalise_ci">normalise_ci</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_2020)

data_test = EU_2020[,c("employ_2010","employ_2011","finalenergy_2010","finalenergy_2011")] 

EU_2020_long&lt;-reshape(data_test, 
                      varying=c("employ_2010","employ_2011","finalenergy_2010","finalenergy_2011"), 
                      direction="long", 
                      idvar="geo", 
                      sep="_")

CI &lt;- ci_ampi(EU_2020_long, 
              indic_col=c(2:3),
              gp=c(50, 100), 
              time=EU_2020_long[,1], 
              polarity= c("POS", "POS"), 
              penalty="POS")
CI$ci_ampi_est
CI$ci_penalty
CI$ci_norm
</code></pre>

<hr>
<h2 id='ci_bod'>Benefit of the Doubt approach (BoD)</h2><span id='topic+ci_bod'></span>

<h3>Description</h3>

<p>Benefit of the Doubt approach (BoD) is the application of Data Envelopment Analysis (DEA) to the field of composite indicators. It was originally proposed by Melyn and Moesen (1991) to evaluate macroeconomic performance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_bod(x,indic_col)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_bod_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_bod_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;bod&quot;.</p>
</td></tr>
<tr><td><code>ci_bod_weights</code></td>
<td>
<p>Raw weights assigned to the simple indicators (Dual values - prices - in the dual DEA formulation).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>OECD (2008) &quot;<em>Handbook on constructing composite indicators: methodology and user guide</em>&quot;.
</p>
<p>Melyn W. and Moesen W.W. (1991) &quot;<em>Towards a synthetic indicator of macroeconomic performance: unequal weighting when limited information is available</em>&quot;, Public Economic research Paper 17, CES, KU Leuven.
</p>
<p>Witte, K. D., Rogge, N. (2009) &quot;<em>Accounting for exogenous influences in a benevolent performance evaluation of teachers</em>&quot;. Tech. rept. Working
Paper Series ces0913, Katholieke Universiteit Leuven, Centrum voor Economische Studien.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_dir">ci_bod_dir</a></code>,<code><a href="#topic+ci_rbod">ci_rbod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_bod(Indic)
 # validating BoD score
w = CI$ci_bod_weights
Indic[,1]*w[,1] + Indic[,2]*w[,2]


data(EU_NUTS1)
data_norm = normalise_ci(EU_NUTS1,c(2:3),polarity = c("POS","POS"), method=2)
CI = ci_bod(data_norm$ci_norm,c(1:2))
</code></pre>

<hr>
<h2 id='ci_bod_constr'>Constrained Benefit of the Doubt approach (BoD)</h2><span id='topic+ci_bod_constr'></span>

<h3>Description</h3>

<p>The constrained Benefit of the Doubt function lets to introduce additional constraints to the weight variation in the optimization procedure so that all the weights obtained are greater than a lower value (low_w) and less than an upper value (up_w).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_bod_constr(x,indic_col,up_w,low_w)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_bod_constr_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_+3A_up_w">up_w</code></td>
<td>
<p>Importance weights upper bound.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_+3A_low_w">low_w</code></td>
<td>
<p>Importance weights lower bound.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_bod_constr_est</code></td>
<td>
<p>Constrained composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;bod_constrained&quot;.</p>
</td></tr>
<tr><td><code>ci_bod_constr_weights</code></td>
<td>
<p>Raw constrained weights assigned to the simple indicators.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rogge N., Vidoli F.</p>


<h3>References</h3>

<p> Van Puyenbroeck T. and Rogge N. (2017) &quot;<em>Geometric mean quantity index numbers with Benefit-of-the-Doubt weights</em>&quot;, European Journal of Operational Research, Volume 256, Issue 3, Pages 1004 - 1014.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_dir">ci_bod_dir</a></code>,<code><a href="#topic+ci_bod">ci_bod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_bod_constr(Indic,up_w=1,low_w=0.05)

data(EU_NUTS1)
data_norm = normalise_ci(EU_NUTS1,c(2:3),polarity = c("POS","POS"), method=2)
CI = ci_bod_constr(data_norm$ci_norm,c(1:2),up_w=1,low_w=0.05)
</code></pre>

<hr>
<h2 id='ci_bod_constr_bad'>Constrained Benefit of the Doubt approach (BoD) in presence of undesirable  indicators</h2><span id='topic+ci_bod_constr_bad'></span>

<h3>Description</h3>

<p>The constrained Benefit of the Doubt function introduces additional constraints to the weight variation in the optimization procedure (Constrained Virtual Weights Restriction) allowing to restrict the importance attached to a single indicator expressed in percentage terms, ranging between a lower and an upper bound (VWR); this function, furthermore, allows to calculate the composite indicator simultaneously in presence of undesirable (bad) and desirable (good) indicators allowing to impose a preference structure (ordVWR).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_bod_constr_bad(x, indic_col, ngood=1, nbad=1, low_w=0, pref=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_bod_constr_bad_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators; the order is important: first columns must contain the desirable indicators, while second ones the undesirable indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_bad_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_bad_+3A_ngood">ngood</code></td>
<td>
<p>The number of desirable outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_bad_+3A_nbad">nbad</code></td>
<td>
<p>The number of undesirable  outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_bad_+3A_low_w">low_w</code></td>
<td>
<p>Importance weights lower bound.</p>
</td></tr>
<tr><td><code id="ci_bod_constr_bad_+3A_pref">pref</code></td>
<td>
<p>The preference vector among indicators; For example if <code>Indic1</code> is the most important, <code>Indic2</code>,<code>Indic3</code> are more important than <code>Indic4</code> and no preference judgment on <code>Indic5</code> (= not included in the vector), the <code>pref</code> vector can be written as: <code>c("Indic1", "Indic2","Indic3","Indic4")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_bod_constr_bad_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;bod_constr_bad&quot;.</p>
</td></tr>
<tr><td><code>ci_bod_constr_bad_weights</code></td>
<td>
<p>Raw weights assigned to each simple indicator.</p>
</td></tr>
<tr><td><code>ci_bod_constr_bad_target</code></td>
<td>
<p>Indicator target values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Rogge N.</p>


<h3>References</h3>

<p>Rogge N., de Jaeger S. and Lavigne C. (2017) &quot;<em>Waste Performance of NUTS 2-regions in the EU: A Conditional Directional Distance Benefit-of-the-Doubt Model</em>&quot;, Ecological Economics, vol.139, pp. 19-32.
</p>
<p>Zanella A., Camanho A.S. and Dias T.G. (2015) &quot;<em>Undesirable outputs and weighting schemes in composite indicators based on data envelopment analysis</em>&quot;, European Journal of Operational Research, vol. 245(2), pp. 517-530.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_constr">ci_bod_constr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_2020)
indic &lt;- c("employ_2011", "percGDP_2011", "gasemiss_2011","deprived_2011")  
dat &lt;- EU_2020[-c(10,18),indic]

# BoD Constrained VWR
CI_BoD_C = ci_bod_constr_bad(dat, ngood=2, nbad=2, low_w=0.05, pref=NULL)
CI_BoD_C$ci_bod_constr_bad_est

# BoD Constrained ordVWR
importance &lt;- c("gasemiss_2011","percGDP_2011","employ_2011")
CI_BoD_C = ci_bod_constr_bad(dat, ngood=2, nbad=2, low_w=0.05, pref=importance)
CI_BoD_C$ci_bod_constr_bad_est
</code></pre>

<hr>
<h2 id='ci_bod_dir'>Directional Benefit of the Doubt (D-BoD) model</h2><span id='topic+ci_bod_dir'></span>

<h3>Description</h3>

<p>Directional Benefit of the Doubt (D-BoD) model enhance non-compensatory property by introducing directional penalties in a standard BoD model in order to consider the preference structure among simple indicators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_bod_dir(x, indic_col, dir)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_bod_dir_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_dir_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_bod_dir_+3A_dir">dir</code></td>
<td>
<p>Main direction. For example you can set the average rates of substitution.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_bod_dir_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;bod_dir&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F., Fusco E.</p>


<h3>References</h3>

<p>Fusco E. (2015) &quot;<em>Enhancing non compensatory composite indicators: A directional proposal</em>&quot;, European Journal of Operational Research, 242(2), 620-630.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_rbod">ci_rbod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_bod_dir(Indic,dir=c(1,1))

data(EU_NUTS1)
data_norm = normalise_ci(EU_NUTS1,c(2:3),polarity = c("POS","POS"), method=2)
CI = ci_bod_dir(data_norm$ci_norm,c(1:2),dir=c(1,0.5))
</code></pre>

<hr>
<h2 id='ci_bod_mdir'>Multi-directional Benefit of the Doubt approach (MDBoD)</h2><span id='topic+ci_bod_mdir'></span>

<h3>Description</h3>

<p>Multi-directional Benefit of the Doubt (MDBoD) allows to introduce the non-compensability among simple indicators in a standard BOD in an objective manner: the preference structure, i.e., the direction, is determined directly from the data and is specific for each unit.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_bod_mdir(x,indic_col)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_bod_mdir_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_mdir_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_bod_mdir_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;bod&quot;.</p>
</td></tr>
<tr><td><code>ci_bod_mdir_spec</code></td>
<td>
<p>Simple indicators specific scores.</p>
</td></tr>
<tr><td><code>ci_bod_mdir_dir</code></td>
<td>
<p>Directions for each simple indicator and unit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E.</p>


<h3>References</h3>

<p>Fusco E. (2023) &quot;<em>Potential improvements approach in composite indicators construction: the Multi-directional Benefit of the Doubt model</em>&quot;, Socio-Economic Planning Sciences, vol. 85, 101447
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_dir">ci_bod_dir</a></code>, <code><a href="#topic+ci_rbod_mdir">ci_rbod_mdir</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BLI_2017)
CI &lt;- ci_bod_mdir(BLI_2017,c(2:12))
</code></pre>

<hr>
<h2 id='ci_bod_var_w'>Variance weighted Benefit of the Doubt approach (BoD variance weighted)</h2><span id='topic+ci_bod_var_w'></span>

<h3>Description</h3>

<p>Variance weighted Benefit of the Doubt approach (BoD variance weighted) is a particular form of BoD method with additional information in the optimization problem. In particular it has been added weight constraints (in form of an Assurance region type I (AR I)) endogenously determined in order to take into account the ratio of the vertical variability of each simple indicator relative to one another.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_bod_var_w(x,indic_col,boot_rep = 5000)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_bod_var_w_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_bod_var_w_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_bod_var_w_+3A_boot_rep">boot_rep</code></td>
<td>
<p>The number of bootstrap replicates (default=5000) for the estimates of the nonparametric bootstrap (first order normal approximation) confidence intervals for the variances of the simple indicators.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more informations about the estimation of the confidence interval for the variances, please see function <em>boot.ci</em>, package <em>boot</em>.</p>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_bod_var_w_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;bod_var_w&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>Vidoli F., Mazziotta C. (2013) &quot;<em>Robust weighted composite indicators by means of frontier methods with an application to European infrastructure endowment</em>&quot;, Statistica Applicata, Italian Journal of Applied Statistics.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_rbod">ci_rbod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_bod_var_w(Indic)

</code></pre>

<hr>
<h2 id='ci_factor'>Weighting method based on Factor Analysis</h2><span id='topic+ci_factor'></span>

<h3>Description</h3>

<p>Factor analysis groups together collinear simple indicators to estimate a composite indicator that captures as much as possible of the information common to individual indicators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_factor(x,indic_col,method="ONE",dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_factor_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_factor_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_factor_+3A_method">method</code></td>
<td>
<p>If method = &quot;ONE&quot; (default) the composite indicator estimated values are equal to first component scores; if method = &quot;ALL&quot; the composite indicator estimated values are equal to component score multiplied by its proportion variance;  if method = &quot;CH&quot; it can be choose the number of the component to take into account.</p>
</td></tr>
<tr><td><code id="ci_factor_+3A_dim">dim</code></td>
<td>
<p>Number of chosen component (if method = &quot;CH&quot;, default is 3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_factor_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>loadings_fact</code></td>
<td>
<p>Variance explained by principal factors (in percentage terms).</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;factor&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.
</p>


<h3>References</h3>

<p>OECD (2008) &quot;<em>Handbook on constructing composite indicators: methodology and user guide</em>&quot;.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_mpi">ci_mpi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_factor(Indic)

data(EU_NUTS1)
CI = ci_factor(EU_NUTS1,c(2:3), method="ALL")

data(EU_2020)
data_norm = normalise_ci(EU_2020,c(47:51),polarity = c("POS","POS","POS","POS","POS"), method=2)
CI3 = ci_factor(data_norm$ci_norm,c(1:5),method="CH", dim=3)
</code></pre>

<hr>
<h2 id='ci_factor_mixed'>Weighting method based on Factor analysis of mixed data (FAMD)</h2><span id='topic+ci_factor_mixed'></span>

<h3>Description</h3>

<p>Factor analysis of mixed data (FAMD) can be seen as a principal component method dedicated to analyze a data set containing both quantitative and qualitative variables making possible to compute composite indicators taking into account continous, dummy, or factor variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_factor_mixed(x,indic_col,method="ONE",dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_factor_mixed_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_factor_mixed_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_factor_mixed_+3A_method">method</code></td>
<td>
<p>If method = &quot;ONE&quot; (default) the composite indicator estimated values are equal to first component scores; if method = &quot;ALL&quot; the composite indicator estimated values are equal to component score multiplied by its proportion variance;  if method = &quot;CH&quot; it can be choose the number of the component to take into account.</p>
</td></tr>
<tr><td><code id="ci_factor_mixed_+3A_dim">dim</code></td>
<td>
<p>Number of chosen component (if method = &quot;CH&quot;, default is 3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_factor_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>loadings_fact</code></td>
<td>
<p>Variance explained by principal factors (in percentage terms).</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;factor_mixed&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luis Carlos Castillo Tellez</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_factor">ci_factor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
i3 &lt;- seq(0, 1, len = 100)
i3 = as.factor(ifelse(i3&gt;0.5,1,0))
Indic = data.frame(i1, i2, i3)

CI  = ci_factor_mixed(Indic,c(1:3))
CI2 = ci_factor_mixed(Indic,c(1:3), method="ALL")
CI3 = ci_factor_mixed(Indic,c(1:3), method="CH", dim=2)
</code></pre>

<hr>
<h2 id='ci_generalized_mean'>Weighting method based on generalized mean</h2><span id='topic+ci_generalized_mean'></span>

<h3>Description</h3>

<p>Generalized means are a family of functions for aggregating sets of numbers (it include as special cases the Pythagorean means, arithmetic, geometric, and harmonic means). The generalized mean is also known as power mean or Holder mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_generalized_mean(x, indic_col, p, na.rm=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_generalized_mean_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_generalized_mean_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_generalized_mean_+3A_p">p</code></td>
<td>
<p>Exponent <code class="reqn">p</code> (real number).</p>
</td></tr>
<tr><td><code id="ci_generalized_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA values before processing; default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_generalized_mean_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;generalized_mean&quot;.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <em>generalized mean</em> with the exponent <code class="reqn">p</code> can be espressed as:
</p>
<p style="text-align: center;"><code class="reqn">M_p(I_1,\dots,I_n) = \left( \frac{1}{n} \sum_{i=1}^n I_i^p \right)^{\frac{1}{p}}</code>
</p>

<p>Particular case are:
<code class="reqn">p=-\infty</code>: minimum, <code class="reqn">p=-1</code>: harmonic mean, <code class="reqn">p=0</code>: geometric mean, 
<code class="reqn">p=1</code>: arithmetic mean, <code class="reqn">p=2</code>: root-mean-square and <code class="reqn">p=\infty</code>: maximum.
</p>


<h3>Author(s)</h3>

<p>Vidoli F.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_geom_gen">ci_geom_gen</a></code>, <code><a href="#topic+ci_factor">ci_factor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_generalized_mean(Indic, p=-1) # harmonic mean

data(EU_NUTS1)
CI = ci_generalized_mean(EU_NUTS1,c(2:3),p=2) # geometric mean
</code></pre>

<hr>
<h2 id='ci_geom_bod_intertemp'>Intertemporal analysis for geometric mean quantity index numbers</h2><span id='topic+ci_geom_bod_intertemp'></span>

<h3>Description</h3>

<p>Intertemporal analysis for geometric mean quantity index numbers with Benefit-of-the-Doubt weights - see function <code><a href="#topic+ci_bod_constr">ci_bod_constr</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_geom_bod_intertemp(x0,x1,indic_col,up_w,low_w,bench)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_geom_bod_intertemp_+3A_x0">x0</code></td>
<td>
<p>A data.frame containing simple indicators - time 0</p>
</td></tr>
<tr><td><code id="ci_geom_bod_intertemp_+3A_x1">x1</code></td>
<td>
<p>A data.frame containing simple indicators - time 1</p>
</td></tr>
<tr><td><code id="ci_geom_bod_intertemp_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_geom_bod_intertemp_+3A_up_w">up_w</code></td>
<td>
<p>Weights upper bound.</p>
</td></tr>
<tr><td><code id="ci_geom_bod_intertemp_+3A_low_w">low_w</code></td>
<td>
<p>Weights lower bound.</p>
</td></tr>
<tr><td><code id="ci_geom_bod_intertemp_+3A_bench">bench</code></td>
<td>
<p>Row number of the benchmark unit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_geom_bod_intertemp_est</code></td>
<td>
<p>A matrix containing the Overall Change (period t1 vs t0), the Change Effect (period t1 vs t0), the Benchmark Effect (period t1 vs t0) and Weight Effect (period t1 vs t0).</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;Intertemporal_effects_Geometric_BoD&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rogge N., Vidoli F.</p>


<h3>References</h3>

<p> Van Puyenbroeck T. and Rogge N. (2017) &quot;<em>Geometric mean quantity index numbers with Benefit-of-the-Doubt weights</em>&quot;, European Journal of Operational Research, Volume 256, Issue 3, Pages 1004 - 1014</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_constr">ci_bod_constr</a></code>,<code><a href="#topic+ci_bod">ci_bod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
i1_t1 &lt;- seq(0.3, 0.5, len = 100)
i2_t1 &lt;- seq(0.3, 1, len = 100)  
Indic_t1 = data.frame(i1_t1, i2_t1)

i1_t0 &lt;- i1_t1 - rnorm (100, 0.2, 0.03)
i2_t0 &lt;- i2_t1   - rnorm (100, 0.2, 0.03)
Indic_t0 = data.frame(i1_t0, i2_t0)

intertemp = ci_geom_bod_intertemp(Indic_t0,Indic_t1,c(1:2),up_w=0.95,low_w=0.05,1)
intertemp 

</code></pre>

<hr>
<h2 id='ci_geom_gen'>Generalized geometric mean quantity index numbers</h2><span id='topic+ci_geom_gen'></span>

<h3>Description</h3>

<p>This function use the geometric mean to aggregate the single indicators. Two weighting criteria has been implemented: EQUAL: equal weighting and BOD: Benefit-of-the-Doubt weights following the Puyenbroeck and Rogge (2017) approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_geom_gen(x,indic_col,meth,up_w,low_w,bench)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_geom_gen_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_geom_gen_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_geom_gen_+3A_meth">meth</code></td>
<td>
<p>&quot;EQUAL&quot; = Equal weighting set, &quot;BOD&quot; =  Benefit-of-the-Doubt weighting set.</p>
</td></tr>
<tr><td><code id="ci_geom_gen_+3A_up_w">up_w</code></td>
<td>
<p>if meth=&quot;BOD&quot;; upper bound of the weighting set.</p>
</td></tr>
<tr><td><code id="ci_geom_gen_+3A_low_w">low_w</code></td>
<td>
<p>if meth=&quot;BOD&quot;; lower bound of the weighting set.</p>
</td></tr>
<tr><td><code id="ci_geom_gen_+3A_bench">bench</code></td>
<td>
<p>Row number of the benchmark unit used to normalize the data.frame x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<p>If meth = &quot;EQUAL&quot;:
</p>
<table>
<tr><td><code>ci_mean_geom_est</code></td>
<td>
<p>: Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>: Method used; for this function ci_method=&quot;mean_geom&quot;.</p>
</td></tr>
</table>
<p>If meth = &quot;BOD&quot;:  
</p>
<table>
<tr><td><code>ci_geom_bod_est</code></td>
<td>
<p>: Constrained composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_geom_bod_weights</code></td>
<td>
<p>: Raw constrained weights assigned to the simple indicators.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>: Method used; for this function ci_method=&quot;geometric_bod&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rogge N., Vidoli F.</p>


<h3>References</h3>

<p> Van Puyenbroeck T. and Rogge N. (2017) &quot;<em>Geometric mean quantity index numbers with Benefit-of-the-Doubt weights</em>&quot;, European Journal of Operational Research, Volume 256, Issue 3, Pages 1004 - 1014</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_dir">ci_bod_dir</a></code>,<code><a href="#topic+ci_bod">ci_bod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 1, len = 100) - rnorm (100, 0.1, 0.03)
i2 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.1, 0.03)
i3 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.1, 0.03)
Indic = data.frame(i1, i2,i3)

geom1 = ci_geom_gen(Indic,c(1:3),meth = "EQUAL")
geom1$ci_mean_geom_est
geom1$ci_method


geom2 = ci_geom_gen(Indic,c(1:3),meth = "BOD",0.7,0.3,100)
geom2$ci_geom_bod_est
geom2$ci_geom_bod_weights


</code></pre>

<hr>
<h2 id='ci_mean_min'>Mean-Min Function</h2><span id='topic+ci_mean_min'></span>

<h3>Description</h3>

<p>The Mean-Min Function (MMF) is an intermediate case between arithmetic <code>mean</code>, according to which no unbalance is penalized, and <code>min</code> function, according to which the penalization is maximum. It depends on two parameters that are respectively related to the intensity of penalization of unbalance (<code class="reqn">\alpha</code>) and intensity of complementarity (<code class="reqn">\beta</code>) among indicators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_mean_min(x, indic_col, alpha, beta)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_mean_min_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_mean_min_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_mean_min_+3A_alpha">alpha</code></td>
<td>
<p>The intensity of penalisation of unbalance among indicators, <code class="reqn">0 \le \alpha \le 1</code></p>
</td></tr>
<tr><td><code id="ci_mean_min_+3A_beta">beta</code></td>
<td>
<p>The intensity of complementarity among indicators, <code class="reqn">\beta \ge 0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_mean_min_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;mean_min&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>Casadio Tarabusi, E., &amp; Guarini, G. (2013) &quot;<em>An unbalance adjustment method
for development indicators</em>&quot;, Social indicators research, 112(1), 19-45.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_mpi">ci_mpi</a></code>, <code><a href="#topic+normalise_ci">normalise_ci</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_NUTS1)
data_norm = normalise_ci(EU_NUTS1,c(2:3),c("NEG","POS"),method=2)
CI = ci_mean_min(data_norm$ci_norm, alpha=0.5, beta=1)

</code></pre>

<hr>
<h2 id='ci_mpi'>Mazziotta-Pareto Index (MPI) method</h2><span id='topic+ci_mpi'></span>

<h3>Description</h3>

<p>Mazziotta-Pareto Index (MPI) is a non-linear composite index method which transforms a set of individual indicators in standardized variables and summarizes them using an arithmetic mean adjusted by a &quot;penalty&quot; coefficient related to the variability of each unit (method of the coefficient of variation penalty).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_mpi(x, indic_col, penalty="POS")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_mpi_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_mpi_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_mpi_+3A_penalty">penalty</code></td>
<td>
<p>Penalty direction; Use &quot;POS&quot; (default) in case of 'increasing' or 'positive' composite index (e.g., well-being index)), &quot;NEG&quot; in case of 'decreasing' or 'negative' composite index (e.g., poverty index).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_mpi_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;mpi&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>De Muro P., Mazziotta M., Pareto A. (2011), &quot;<em>Composite Indices of Development and Poverty: An Application to MDGs</em>&quot;, Social Indicators Research, Volume 104, Number 1, pp. 1-18.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+normalise_ci">normalise_ci</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_NUTS1)

# Please, pay attention. MPI can be calculated only with two standardizations methods:
# Classic MPI - method=1, z.mean=100 and z.std=10
# Correct MPI - method=2
# For more info, please see references.

data_norm = normalise_ci(EU_NUTS1,c(2:3),c("NEG","POS"),method=1,z.mean=100, z.std=10)
CI = ci_mpi(data_norm$ci_norm, penalty="NEG")

data(EU_NUTS1)
CI = ci_mpi(EU_NUTS1,c(2:3),penalty="NEG")
</code></pre>

<hr>
<h2 id='ci_ogwa'>Ordered Geographically Weighted Average (OWA)</h2><span id='topic+ci_ogwa'></span>

<h3>Description</h3>

<p>The Ordered Geographically Weighted Averaging (OWA) operator is an extension of the multi-criteria decision aggregation method called OWA (Yager, 1988) that accounts for spatial heterogeneity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_ogwa(x, id, indic_col, atleastjp, coords,
                    kernel = "bisquare", adaptive = F, bw, 
                    p = 2, theta = 0, longlat = F, dMat)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_ogwa_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_id">id</code></td>
<td>
<p>Units' unique identifier.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_coords">coords</code></td>
<td>
<p>A two-column matrix of latitude and longitude coordinates.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_atleastjp">atleastjp</code></td>
<td>
<p>Fuzzy linguistic quantifier &quot;At least j&quot;.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
gaussian: wgt = exp(-.5*(vdist/bw)^2);
exponential: wgt = exp(-vdist/bw);
bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise;
boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to                      the number of nearest neighbours (i.e. adaptive distance); default is FALSE,                      where a fixed kernel is found (bandwidth is a fixed distance).</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function.</p>
</td></tr>
<tr><td><code id="ci_ogwa_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance.</p>
</td></tr>	
<tr><td><code id="ci_ogwa_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0.</p>
</td></tr>	
<tr><td><code id="ci_ogwa_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated.</p>
</td></tr>	
<tr><td><code id="ci_ogwa_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="GWmodel.html#topic+gw.dist">gw.dist</a></code>.</p>
</td></tr>	
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>CI_OGWA_n</code></td>
<td>
<p>Composite indicator estimated values for OGWA-.</p>
</td></tr>
<tr><td><code>CI_OGWA_p</code></td>
<td>
<p>Composite indicator estimated values for OGWA+.</p>
</td></tr>
<tr><td><code>wp</code></td>
<td>
<p>OGWA weights' vector &quot;More than j&quot;.</p>
</td></tr>
<tr><td><code>wn</code></td>
<td>
<p>OGWA weights' vector &quot;At least j&quot;.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;ogwa&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Liborio M.P.</p>


<h3>References</h3>

<p>Fusco, E., Liborio, M.P., Rabiei-Dastjerdi, H., Vidoli, F., Brunsdon, C. and Ekel, P.I. (2023), Harnessing Spatial Heterogeneity in Composite Indicators through the Ordered Geographically Weighted Averaging (OGWA) Operator. Geographical Analysis. https://doi.org/10.1111/gean.12384
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_owa">ci_owa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_HPI)

data_HPI_2019 = data_HPI[data_HPI$year==2019,]
Indic_name = c("Life_Expectancy","Ladder_of_life","Ecological_Footprint")

Indic_norm = normalise_ci(data_HPI_2019, Indic_name, c("POS","POS","NEG"),method=2)$ci_norm
Indic_norm = Indic_norm[Indic_norm$Life_Expectancy&gt;0 &amp; 
              Indic_norm$Ladder_of_life&gt;0 &amp; 
              Indic_norm$Ecological_Footprint &gt;0,]

Indic_CI = data.frame(Indic_norm, 
                       data_HPI_2019[rownames(Indic_norm),
                       c("lat","long","HPI","ISO","Country")])

atleast = 2

coord = Indic_CI[,c("lat","long")]

CI_ogwa_n = ci_ogwa(Indic_CI, id="ISO", 
                      indic_col=c(1:3), 
                      atleastjp=atleast,
                      coords=as.matrix(coord),
                      kernel = "gaussian",
                      adaptive=FALSE, 
                      longlat=FALSE)$CI_OGWA_n


#CI_ogwa_p = ci_ogwa(Indic_CI, id="ISO", 
#                      indic_col=c(1:3), 
#                     atleastjp=atleast,
#                      coords=as.matrix(coord),
#                      kernel = "gaussian",
#                      adaptive=FALSE, 
#                      longlat=FALSE)$CI_OGWA_p

</code></pre>

<hr>
<h2 id='ci_owa'>Ordered Weighted Average (OWA)</h2><span id='topic+ci_owa'></span>

<h3>Description</h3>

<p>The Ordered Weighted Averaging (OWA) operator is a multi-criteria decision aggregation method that is structurally non-compensatory (Yager, 1988).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_owa(x, id, indic_col, atleastjp)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_owa_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_owa_+3A_id">id</code></td>
<td>
<p>Units' unique identifier.</p>
</td></tr>
<tr><td><code id="ci_owa_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_owa_+3A_atleastjp">atleastjp</code></td>
<td>
<p>Fuzzy linguistic quantifier &quot;At least j&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>CI_OWA_n</code></td>
<td>
<p>Composite indicator estimated values for OWA-.</p>
</td></tr>
<tr><td><code>CI_OWA_p</code></td>
<td>
<p>Composite indicator estimated values for OWA+.</p>
</td></tr>
<tr><td><code>wp</code></td>
<td>
<p>OWA weights' vector &quot;More than j&quot;.</p>
</td></tr>
<tr><td><code>wn</code></td>
<td>
<p>OWA weights' vector &quot;At least j&quot;.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;owa&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Liborio M.P.</p>


<h3>References</h3>

<p>Yager, R. R. (1988). On ordered weighted averaging aggregation operators in multicriteria decision making. IEEE Transactions on systems, Man, and Cybernetics, 18(1), 183-190.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_ogwa">ci_ogwa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_HPI)

data_HPI = data_HPI[complete.cases(data_HPI),]
data_HPI_2019 = data_HPI[data_HPI$year==2019,]

Indic_name = c("Life_Expectancy","Ladder_of_life","Ecological_Footprint")
Indic_norm = data.frame("ISO"=data_HPI_2019$ISO, 
                        normalise_ci(data_HPI_2019[, Indic_name], 
                        c(1:3), 
                        c("POS","POS","NEG"),
                        method=2)$ci_norm)
                        
Indic_norm = Indic_norm[Indic_norm$Life_Expectancy&gt;0 &amp; 
                         Indic_norm$Ladder_of_life&gt;0 &amp; 
                         Indic_norm$Ecological_Footprint &gt;0 ,]

atleast = 2
CI_owa_n = ci_owa(Indic_norm, id="ISO", 
                   indic_col=c(2:4), 
                   atleastjp=atleast)$CI_OWA_n
CI_owa_p = ci_owa(Indic_norm, id="ISO", 
                   indic_col=c(2:4), 
                   atleastjp=atleast)$CI_OWA_p
</code></pre>

<hr>
<h2 id='ci_rbod'>Robust Benefit of the Doubt approach (RBoD)</h2><span id='topic+ci_rbod'></span>

<h3>Description</h3>

<p>Robust Benefit of the Doubt approach (RBoD) is the robust version of the BoD method. It is based on the concept of the expected minimum input function of order-<em>m</em> so &quot;<em>in place of looking for the lower boundary of the support of F, as was typically the case for the full-frontier (DEA or FDH), the order-m efficiency score can be viewed as the expectation of the maximal score, when compared to m units randomly drawn from the population of units presenting a  greater level of simple indicators</em>&quot;, Daraio and Simar (2005).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_rbod(x,indic_col,M,B)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_rbod_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_rbod_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples.</p>
</td></tr>
<tr><td><code id="ci_rbod_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_rbod_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;rbod&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>Daraio, C., Simar, L. &quot;<em>Introducing environmental variables in nonparametric frontier models: a probabilistic approach</em>&quot;, Journal of productivity analysis, 2005, 24(1), 93 - 121.
</p>
<p>Vidoli F., Mazziotta C., &quot;<em>Robust weighted composite indicators by means of frontier methods with an application to European infrastructure endowment</em>&quot;, Statistica Applicata, Italian Journal of Applied Statistics, 2013.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_rbod(Indic,B=10)

data(EU_NUTS1)
data_norm = normalise_ci(EU_NUTS1,c(2:3),polarity = c("POS","POS"), method=2)
CI = ci_rbod(data_norm$ci_norm,c(1:2),M=10,B=20)
</code></pre>

<hr>
<h2 id='ci_rbod_constr_bad'>Robust constrained Benefit of the Doubt approach (BoD) in presence of undesirable  indicators</h2><span id='topic+ci_rbod_constr_bad'></span>

<h3>Description</h3>

<p>The Robust constrained Benefit of the Doubt function introduces additional constraints to the weight variation in the optimization procedure (Constrained Virtual Weights Restriction) allowing to restrict the importance attached to a single indicator expressed in percentage terms, ranging between a lower and an upper bound (VWR); this function, furthermore, allows to calculate the composite indicator simultaneously in presence of undesirable (bad) and desirable (good) indicators allowing to impose a preference structure (ordVWR). This function is the robust version of the <code>ci_bod_constr_bad</code>: it is based on the concept of the expected minimum input function of order-<em>m</em> (Daraio and Simar, 2005) allowing to compare the unit under analysis against <code>M</code> peers by extracting <code>B</code> samples with replacement.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_rbod_constr_bad(x, indic_col, ngood=1, nbad=1, low_w=0, pref=NULL, M, B) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_rbod_constr_bad_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_ngood">ngood</code></td>
<td>
<p>The number of desirable outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_nbad">nbad</code></td>
<td>
<p>The number of undesirable  outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_low_w">low_w</code></td>
<td>
<p>Importance weights lower bound.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_pref">pref</code></td>
<td>
<p>The preference vector among indicators; For example if <code>Indic1</code> is the most important, <code>Indic2</code>,<code>Indic3</code> are more important than <code>Indic4</code> and no preference judgment on <code>Indic5</code> (= not included in the vector), the <code>pref</code> vector can be written as: <code>c("Indic1", "Indic2","Indic3","Indic4")</code></p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_rbod_constr_bad_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;rbod_constr_bad&quot;.</p>
</td></tr>
<tr><td><code>ci_rbod_constr_bad_weights</code></td>
<td>
<p>Raw weights assigned to each simple indicator.</p>
</td></tr>
<tr><td><code>ci_rbod_constr_bad_target</code></td>
<td>
<p>Indicator target values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Rogge N.</p>


<h3>References</h3>

<p>Rogge N., de Jaeger S. and Lavigne C. (2017) &quot;<em>Waste Performance of NUTS 2-regions in the EU: A Conditional Directional Distance Benefit-of-the-Doubt Model</em>&quot;, Ecological Economics, vol.139, pp. 19-32.
</p>
<p>Zanella A., Camanho A.S. and Dias T.G. (2015) &quot;<em>Undesirable outputs and weighting schemes in composite indicators based on data envelopment analysis</em>&quot;, European Journal of Operational Research, vol. 245(2), pp. 517-530.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod_constr">ci_bod_constr</a></code>, <code><a href="#topic+ci_bod_constr_bad">ci_bod_constr_bad</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_2020)
indic &lt;- c("employ_2011", "percGDP_2011", "gasemiss_2011","deprived_2011")  
dat &lt;- EU_2020[-c(10,18),indic]

# Robust BoD Constrained VWR
CI_BoD_C = ci_rbod_constr_bad(dat, ngood=2, nbad=2, low_w=0.05, pref=NULL, M=10, B=50)
CI_BoD_C$ci_rbod_constr_bad_est

# Robust BoD Constrained ordVWR
importance &lt;- c("gasemiss_2011","percGDP_2011","employ_2011")
CI_BoD_C = ci_rbod_constr_bad(dat, ngood=2, nbad=2, low_w=0.05, pref=importance, M=10, B=50)
CI_BoD_C$ci_rbod_constr_bad_est
</code></pre>

<hr>
<h2 id='ci_rbod_constr_bad_Q'>Conditional robust constrained Benefit of the Doubt approach (BoD) in presence of undesirable  indicators</h2><span id='topic+ci_rbod_constr_bad_Q'></span>

<h3>Description</h3>

<p>The Conditional robust constrained Benefit of the Doubt function introduces additional constraints to the weight variation in the optimization procedure (Constrained Virtual Weights Restriction) allowing to restrict the importance attached to a single indicator expressed in percentage terms, ranging between a lower and an upper bound (VWR); this function, furthermore, allows to calculate the composite indicator simultaneously in presence of undesirable (bad) and desirable (good) indicators allowing to impose a preference structure (ordVWR). This function, in addition to being robust against outlier data (see <code>ci_rbod_constr_bad</code> function) allows to take into account external contextual continuous (<code>Q</code>) or/and ordinal (<code>Q_ord</code>) variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_rbod_constr_bad_Q(x, indic_col, ngood=1, nbad=1, 
low_w=0, pref=NULL, M, B, Q=NULL, Q_ord=NULL, bandwidth)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_ngood">ngood</code></td>
<td>
<p>The number of desirable outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_nbad">nbad</code></td>
<td>
<p>The number of undesirable  outputs; it has to be greater than 0.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_low_w">low_w</code></td>
<td>
<p>Importance weights lower bound.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_pref">pref</code></td>
<td>
<p>The preference vector among indicators; For example if <code>Indic1</code> is the most important, <code>Indic2</code>,<code>Indic3</code> are more important than <code>Indic4</code> and no preference judgment on <code>Indic5</code> (= not included in the vector), the <code>pref</code> vector can be written as: <code>c("Indic1", "Indic2","Indic3","Indic4")</code></p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_q">Q</code></td>
<td>
<p>A matrix containing continuous exogenous variables.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_q_ord">Q_ord</code></td>
<td>
<p>A matrix containing discrete exogenous variables.</p>
</td></tr>
<tr><td><code id="ci_rbod_constr_bad_Q_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Multivariate mixed bandwidth for exogenous variables; it can be calculated by <code>bandwidth_CI</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_rbod_constr_bad_Q_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;rbod_constr_bad_Q&quot;.</p>
</td></tr>
<tr><td><code>ci_rbod_constr_bad_Q_weights</code></td>
<td>
<p>Raw weights assigned to each simple indicator.</p>
</td></tr>
<tr><td><code>ci_rbod_constr_bad_Q_target</code></td>
<td>
<p>Indicator target values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Rogge N.</p>


<h3>References</h3>

<p>Rogge N., de Jaeger S. and Lavigne C. (2017) &quot;<em>Waste Performance of NUTS 2-regions in the EU: A Conditional Directional Distance Benefit-of-the-Doubt Model</em>&quot;, Ecological Economics, vol.139, pp. 19-32.
</p>
<p>Zanella A., Camanho A.S. and Dias T.G. (2015) &quot;<em>Undesirable outputs and weighting schemes in composite indicators based on data envelopment analysis</em>&quot;, European Journal of Operational Research, vol. 245(2), pp. 517-530.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_rbod_constr_bad">ci_rbod_constr_bad</a></code>, <code><a href="#topic+ci_bod_constr_bad">ci_bod_constr_bad</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_2020)

indic &lt;- c("employ_2011", "gasemiss_2011","deprived_2011")  
dat   &lt;- EU_2020[-c(10,18),indic]
Q_GDP &lt;- EU_2020[-c(10,18),"percGDP_2011"]

# Conditional robust BoD Constrained VWR
band = bandwidth_CI(dat, ngood=1, nbad=2, Q = Q_GDP)

CI_BoD_C = ci_rbod_constr_bad_Q(dat, 
                                ngood=1, 
                                nbad=2, 
                                low_w=0.05, 
                                pref=NULL, 
                                M=10, 
                                B=50, 
                                Q=Q_GDP, 
                                bandwidth = band$bandwidth)
CI_BoD_C$ci_rbod_constr_bad_Q_est


# # Conditional robust BoD Constrained ordVWR
# import &lt;- c("gasemiss_2011","employ_2011", "deprived_2011")
# 
# CI_BoD_C2 = ci_rbod_constr_bad_Q(dat, 
#                                  ngood=1, 
#                                  nbad=2, 
#                                  low_w=0.05, 
#                                  pref=import, 
#                                  M=10, 
#                                  B=50, 
#                                  Q=Q_GDP, 
#                                  bandwidth = band$bandwidth)
# CI_BoD_C2$ci_rbod_constr_bad_Q_est
</code></pre>

<hr>
<h2 id='ci_rbod_dir'>Directional Robust Benefit of the Doubt approach (D-RBoD)</h2><span id='topic+ci_rbod_dir'></span>

<h3>Description</h3>

<p>Directional Robust Benefit of the Doubt approach (D-RBoD) is the directional robust version of the BoD method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_rbod_dir(x,indic_col,M,B,dir)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_rbod_dir_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_dir_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_rbod_dir_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples.</p>
</td></tr>
<tr><td><code id="ci_rbod_dir_+3A_b">B</code></td>
<td>
<p>The number of bootstap replicates.</p>
</td></tr>
<tr><td><code id="ci_rbod_dir_+3A_dir">dir</code></td>
<td>
<p>Main direction. For example you can set the average rates of substitution.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_rbod_dir_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;rbod_dir&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Vidoli F.</p>


<h3>References</h3>

<p>Daraio C., Simar L., &quot;<em>Introducing environmental variables in nonparametric frontier models: a probabilistic approach</em>&quot;, Journal of productivity analysis, 2005, 24(1), 93 121.
</p>
<p>Simar L., Vanhems A., &quot;<em>Probabilistic characterization of directional distances and their robust versions</em>&quot;, Journal of Econometrics, 2012, 166(2), 342 354.
</p>
<p>Vidoli F., Fusco E., Mazziotta C., &quot;<em>Non-compensability in composite indicators: a robust directional frontier method</em>&quot;, Social Indicators Research, Springer Netherlands.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_rbod">ci_rbod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_NUTS1)
data_norm = normalise_ci(EU_NUTS1,c(2:3),polarity = c("POS","POS"), method=2)
CI = ci_rbod_dir(data_norm$ci_norm, c(1:2), M = 25, B = 50, c(1,0.1)) 
</code></pre>

<hr>
<h2 id='ci_rbod_mdir'>Robust multi-directional Benefit of the Doubt approach (MDRBoD)</h2><span id='topic+ci_rbod_mdir'></span>

<h3>Description</h3>

<p>Robust Multi-directional Benefit of the Doubt (MDRBoD) allows to introduce the non-compensability among simple indicators in a standard Robust BOD in an objective manner: the preference structure, i.e., the direction, is determined directly from the data and is specific for each unit and these estimated values are calculated as the reference sample varies in order to smooth out the effect of outliers or out-of-range data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_rbod_mdir(x,indic_col,M, B, interval)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_rbod_mdir_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_mdir_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_mdir_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples.</p>
</td></tr>
<tr><td><code id="ci_rbod_mdir_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="ci_rbod_mdir_+3A_interval">interval</code></td>
<td>
<p>Desired probability for Student distribution [see function qt()]; default = 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_rbod_mdir_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>lower_ci and upper_ci; Estimated confidence interval for the composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;rbod_mdir&quot;.</p>
</td></tr>
<tr><td><code>ci_rbod_mdir_spec</code></td>
<td>
<p>Simple indicators specific scores.</p>
</td></tr>
<tr><td><code>ci_rbod_mdir_dir</code></td>
<td>
<p>Directions for each simple indicator and unit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>F. Vidoli, E. Fusco, G. Pignataro, C. Guccio (2024) &quot;<em>Multi-directional Robust Benefit of the Doubt model: An application to the measurement of the quality of acute care services in OECD countries</em>&quot;, Socio-Economic Planning Sciences. https://doi.org/10.1016/j.seps.2024.101877  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_rbod">ci_rbod</a></code>, <code><a href="#topic+ci_bod_mdir">ci_bod_mdir</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BLI_2017)
CI &lt;- ci_rbod_mdir(BLI_2017,c(2:12), M=10,B=20, interval=0.05)
</code></pre>

<hr>
<h2 id='ci_rbod_spatial'>Spatial robust Benefit of the Doubt approach (Sp-RBoD)</h2><span id='topic+ci_rbod_spatial'></span>

<h3>Description</h3>

<p>The Spatial robust Benefit of the Doubt approach (Sp-RBoD) method allows to take into account the spatial contextual condition into the robust Benefit of the Doubt method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_rbod_spatial(x, indic_col, M=20, B=100, W) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_rbod_spatial_+3A_x">x</code></td>
<td>
<p>A data.frame containing score of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_rbod_spatial_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="ci_rbod_spatial_+3A_m">M</code></td>
<td>
<p>The number of elements in each of the bootstrapped samples; default is 20.</p>
</td></tr>
<tr><td><code id="ci_rbod_spatial_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replicates; default is 100.</p>
</td></tr>
<tr><td><code id="ci_rbod_spatial_+3A_w">W</code></td>
<td>
<p>The spatial weights matrix. A square non-negative matrix with no NAs representing spatial weights; may be a matrix of class &quot;sparseMatrix&quot; (spdep package)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_rbod_spatial_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;rbod_spatial&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fusco E., Vidoli F.</p>


<h3>References</h3>

<p>Fusco E., Vidoli F., Sahoo B.K. (2018) &quot;<em>Spatial heterogeneity in composite indicator: a methodological proposal</em>&quot;, Omega, Vol. 77, pp. 1-14
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_rbod">ci_rbod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EU_NUTS1)

coord = EU_NUTS1[,c("Long","Lat")]
k&lt;-knearneigh(as.matrix(coord), k=5)
k_nb&lt;-knn2nb(k)
W_mat &lt;-nb2mat(k_nb,style="W",zero.policy=TRUE)

CI = ci_rbod_spatial(EU_NUTS1,c(2:3),M=10,B=20, W=W_mat)
</code></pre>

<hr>
<h2 id='ci_smaa_constr'>Constrained stochastic multi-objective acceptability analysis (C-SMAA)</h2><span id='topic+ci_smaa_constr'></span>

<h3>Description</h3>

<p>Stochastic multiobjective acceptability analysis (SMAA) is a multicriteria decision support technique for multiple decision makers based on exploring the weight space. Inaccurate or uncertain input data can be represented as probability distributions. In SMAA the decision makers need not express their preferences explicitly or implicitly; instead the technique analyses what kind of valuations would make each alternative the preferred one. The method produces for each alternative an acceptability index measuring the variety of different valuations that support that alternative, a central weight vector representing the typical valuations resulting in that decision, and a confidence factor measuring whether the input data is accurate enough for making an informed decision. (R Lahdelma, J. Hokkanen and P. Salminen, 1998); this function, in particular, allows to restricts the range of allowable weights within the SMAA analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_smaa_constr(x,indic_col,rep, label, low_w=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_smaa_constr_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_smaa_constr_+3A_indic_col">indic_col</code></td>
<td>
<p>A numeric list indicating the positions of the simple indicators.</p>
</td></tr>
<tr><td><code id="ci_smaa_constr_+3A_rep">rep</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="ci_smaa_constr_+3A_label">label</code></td>
<td>
<p>A factor column useful to identify units.</p>
</td></tr>
<tr><td><code id="ci_smaa_constr_+3A_low_w">low_w</code></td>
<td>
<p>Importance weights lower bound vector; default is NULL (for standard SMAA)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Author thanks Giuliano Resce and Raffaele Lagravinese for their help and for making available the original code of the SMAA function.\
The lower bound vector must be set as a vector of the same size as the number of simple indicators; for example - in the presence of two indicators - if you want to constrain only one indicator, you must write: <code>low_w = c (0,0.2)</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_smaa_constr_rank_freq</code></td>
<td>
<p>Frequence of the SMAA ranks based on the sampled alternatives' values. The rows represent the analysis units while the first column represents the number of times the unit was in first rank, the second one in second rank and so on.</p>
</td></tr>
<tr><td><code>ci_smaa_constr_average_rank</code></td>
<td>
<p>The average rank.</p>
</td></tr>
<tr><td><code>ci_smaa_constr_values</code></td>
<td>
<p>The alternative values based on a set of samples from the criteria values distribution and the samples set from the feasible weight space.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;smaa_const&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>R. Lahdelma, P. Salminen (2001) &quot;<em>SMAA-2: Stochastic multicriteria acceptability analysis for group decision making</em>&quot;, Operations Research, 49(3), pp. 444-454
</p>
<p>S. Greco, A. Ishizaka, B. Matarazzo and G. Torrisi (2017) &quot;<em>Stochastic multi-attribute acceptability analysis (SMAA): an application to the ranking of Italian regions</em>&quot;, Regional Studies
</p>
<p>R. Lagravinese, P. Liberati and G. Resce (2017) &quot;<em>Exploring health outcomes by stochastic multi-objective acceptability analysis: an application to Italian regions</em>&quot;, Working Papers. Collection B: Regional and sectoral economics, 1703, Universidade de Vigo, GEN - Governance and Economics research Network.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# ----- Define a function for plotting a matrix ----- #
myImagePlot &lt;- function(x, ...){
     min &lt;- min(x)
     max &lt;- max(x)
     yLabels &lt;- rownames(x)
     xLabels &lt;- colnames(x)
     title &lt;-c()
  # check for additional function arguments
  if( length(list(...)) ){
    Lst &lt;- list(...)
    if( !is.null(Lst$zlim) ){
       min &lt;- Lst$zlim[1]
       max &lt;- Lst$zlim[2]
    }
    if( !is.null(Lst$yLabels) ){
       yLabels &lt;- c(Lst$yLabels)
    }
    if( !is.null(Lst$xLabels) ){
       xLabels &lt;- c(Lst$xLabels)
    }
    if( !is.null(Lst$title) ){
       title &lt;- Lst$title
    }
  }
# check for null values
if( is.null(xLabels) ){
   xLabels &lt;- c(1:ncol(x))
}
if( is.null(yLabels) ){
   yLabels &lt;- c(1:nrow(x))
}

layout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))

 # Red and green range from 0 to 1 while Blue ranges from 1 to 0
 ColorRamp &lt;- rgb( seq(0,1,length=256),  # Red
                   seq(0,1,length=256),  # Green
                   seq(1,0,length=256))  # Blue
 ColorLevels &lt;- seq(min, max, length=length(ColorRamp))

 # Reverse Y axis
 reverse &lt;- nrow(x) : 1
 yLabels &lt;- yLabels[reverse]
 x &lt;- x[reverse,]

 # Data Map
 par(mar = c(3,5,2.5,2))
 image(1:length(xLabels), 1:length(yLabels), t(x), col=ColorRamp, xlab="",
 ylab="", axes=FALSE, zlim=c(min,max))
 if( !is.null(title) ){
    title(main=title)
 }
axis(BELOW&lt;-1, at=1:length(xLabels), labels=xLabels, cex.axis=0.7)
 axis(LEFT &lt;-2, at=1:length(yLabels), labels=yLabels, las= HORIZONTAL&lt;-1,
 cex.axis=0.7)

 # Color Scale
 par(mar = c(3,2.5,2.5,2))
 image(1, ColorLevels,
      matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1),
      col=ColorRamp,
      xlab="",ylab="",
      xaxt="n")

 layout(1)
}
# ----- END plot function ----- #


data(EU_NUTS1)

# Standard SMAA 
test &lt;- ci_smaa_constr(EU_NUTS1,c(2,3), rep=200, label = EU_NUTS1[,1])
# source("http://www.phaget4.org/R/myImagePlot.R") 
# myImagePlot(test$ci_smaa_constr_rank_freq)
test$ci_smaa_constr_average_rank

# Constrained SMAA 
test2 &lt;- ci_smaa_constr(EU_NUTS1,c(2,3), rep=200, label = EU_NUTS1[,1], low_w=c(0.2,0.2) )
# myImagePlot(test2$ci_smaa_constr_rank_freq)
test2$ci_smaa_constr_average_rank

</code></pre>

<hr>
<h2 id='ci_wroclaw'>Wroclaw Taxonomic Method</h2><span id='topic+ci_wroclaw'></span>

<h3>Description</h3>

<p>Wroclaw taxonomy method (also known as the dendric method), originally developed at the University of Wroclaw, is based on the distance from a theoretical unit characterized by the best performance for all indicators considered; the composite indicator is therefore based on the sum of euclidean distances from the ideal unit and normalized by a measure of variability of these distance (mean + 2*std).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_wroclaw(x,indic_col)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_wroclaw_+3A_x">x</code></td>
<td>
<p>A data.frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="ci_wroclaw_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please pay attention that <em>ci_wroclaw_est</em> is the distance from the &quot;ideal&quot; unit; so, units with higher values for the simple indicators get lower values of composite indicator.</p>


<h3>Value</h3>

<p>An object of class &quot;CI&quot;. This is a list containing the following elements:
</p>
<table>
<tr><td><code>ci_wroclaw_est</code></td>
<td>
<p>Composite indicator estimated values.</p>
</td></tr>
<tr><td><code>ci_method</code></td>
<td>
<p>Method used; for this function ci_method=&quot;wroclaw&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vidoli F.</p>


<h3>References</h3>

<p>UNESCO, &quot;<em>Social indicators: problems of definition and of selection</em>&quot;, Paris 1974.
</p>
<p>Mazziotta C., Mazziotta M., Pareto A., Vidoli F., &quot;<em>La sintesi di indicatori territoriali di dotazione
infrastrutturale: metodi di costruzione e procedure di ponderazione a confronto</em>&quot;, Rivista di
Economia e Statistica del territorio, n.1, 2010.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_mpi">ci_mpi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(0.3, 0.5, len = 100) - rnorm (100, 0.2, 0.03)
i2 &lt;- seq(0.3, 1, len = 100)   - rnorm (100, 0.2, 0.03)
Indic = data.frame(i1, i2)
CI = ci_wroclaw(Indic)

data(EU_NUTS1)
CI = ci_wroclaw(EU_NUTS1,c(2:3))

data(EU_2020)
data_selez = EU_2020[,c(1,22,191)]
data_norm = normalise_ci(data_selez,c(2:3),c("POS","NEG"),method=3)
ci_wroclaw(data_norm$ci_norm,c(1:2))

</code></pre>

<hr>
<h2 id='data_HPI'>Happy Planet Index 2017-2019 indicators</h2><span id='topic+data_HPI'></span>

<h3>Description</h3>

<p>Data related to Happy Planet Index for 151 countries and the period 2017-2019.
</p>
<p>For more info, please see <a href="https://happyplanetindex.org">https://happyplanetindex.org</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data_HPI)</code></pre>


<h3>Format</h3>

<p>data_HPI is a dataset with 453 observations and 10 variables.
</p>

<dl>
<dt>Country</dt><dd><p>Country name</p>
</dd>	
<dt>ISO</dt><dd><p>ISO code</p>
</dd>	
<dt>year</dt><dd><p>Years 2017-2019</p>
</dd>	
<dt>Continent</dt><dd><p>Continent</p>
</dd>	
<dt>Population</dt><dd><p>Population (thousands)</p>
</dd>	
<dt>Life_Expectancy</dt><dd><p>Life Expectancy (years)</p>
</dd>	
<dt>Ladder_of_life</dt><dd><p>Ladder of life (Wellbeing) (0-10)</p>
</dd>	
<dt>Ecological_Footprint</dt><dd><p>Ecological Footprint (g ha)</p>
</dd>	
<dt>HPI</dt><dd><p>HPI</p>
</dd>	
<dt>GDP_per_capita</dt><dd><p>GDP per capita ($)</p>
</dd>	
</dl>


<h3>Author(s)</h3>

<p>Fusco E.</p>


<h3>References</h3>

<p><a href="https://happyplanetindex.org">https://happyplanetindex.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_HPI)</code></pre>

<hr>
<h2 id='EU_2020'>Europe 2020 indicators</h2><span id='topic+EU_2020'></span>

<h3>Description</h3>

<p>Europe 2020, a strategy for jobs and smart, sustainable and inclusive growth, is based on five EU headline targets which are currently measured by eight headline indicators, Headline indicators, Eurostat, year 1990-2012 (Last update:	21/11/2013).
</p>
<p>For more info, please see <a href="https://ec.europa.eu/eurostat/en/web/products-statistics-in-focus/-/KS-SF-12-039">https://ec.europa.eu/eurostat/en/web/products-statistics-in-focus/-/KS-SF-12-039</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EU_2020)</code></pre>


<h3>Format</h3>

<p>EU_2020 is a dataset with 30 observations and 12 indicators (190 indicator per year).
</p>

<dl>
<dt>geo</dt><dd><p>EU-Member States including EU (28 countries) and EU (27 countries) row.</p>
</dd>	
<dt>employXXXX</dt><dd><p>Employment rate - age group 20-64, year XXXX (1992-2012).</p>
</dd>	
<dt>perc_GDPXXXX</dt><dd><p>Gross domestic expenditure on R&amp;D (GERD), year XXXX (1990-2012).</p>
</dd>
<dt>gas_emissXXXX</dt><dd><p>Greenhouse gas emissions - base year 1990, year XXXX (1990-2011).</p>
</dd>
<dt>share_renXXXX</dt><dd><p>Share of renewable energy in gross final energy consumption, year XXXX (2004-2011).</p>
</dd>
<dt>prim_enerXXXX</dt><dd><p>Primary energy consumption, year XXXX (1990-2011).</p>
</dd>
<dt>final_energyXXXX</dt><dd><p>Final energy consumption, year XXXX (1990-2011).</p>
</dd>
<dt>final_energyXXXX</dt><dd><p>Early leavers from education and training - Perc. of the population aged 18-24 with at most lower secondary education and not in further education or training, year XXXX (1992-2012).</p>
</dd>	
<dt>tertiaryXXXX</dt><dd><p>Tertiary educational attainment - age group 30-34, year XXXX (2000-2012).</p>
</dd>
<dt>risk_povertyXXXX</dt><dd><p>People at risk of poverty or social exclusion - 1000 persons Perc. of total population, year XXXX (2004-2012).</p>
</dd>
<dt>low_workXXXX</dt><dd><p>People living in households with very low work intensity - 1000 persons Perc. of total population, year XXXX (2004-2012).</p>
</dd>
<dt>risk_povertyXXXX</dt><dd><p>People at risk of poverty after social transfers - 1000 persons Perc. of total population, year XXXX (2003-2012).</p>
</dd>
<dt>deprivedXXXX</dt><dd><p>Severely materially deprived people - 1000 persons Perc. of total population, year XXXX (2003-2012).</p>
</dd>	
</dl>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_2020)</code></pre>

<hr>
<h2 id='EU_NUTS1'>EU NUTS1 Transportation data</h2><span id='topic+EU_NUTS1'></span>

<h3>Description</h3>

<p>Eurostat regional transport statistics (reg_tran) data, year 2012.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EU_NUTS1)</code></pre>


<h3>Format</h3>

<p>EU_NUTS1 is a dataset with 34 observations and two indicators describing transportation infrastructure endowment of the main (in terms of population and GDP) European NUTS1 regions: France, Germany, Italy, Spain (United Kingdom has been omitted, due to lack of data concerning railways).
</p>

<dl>
<dt>roads</dt><dd><p>Calculated as (2 * Motorways - Kilometres per 1000 km2 + Other roads - Kilometres per 1000 km2 )/3</p>
</dd>	
<dt>trains</dt><dd><p>Calculated as (2 *Railway lines double+Electrified railway lines)/3</p>
</dd>	
</dl>


<h3>Author(s)</h3>

<p>Vidoli F.</p>


<h3>References</h3>

<p>Vidoli F., Mazziotta C., &quot;<em>Robust weighted composite indicators by means of frontier methods with an application to European infrastructure endowment</em>&quot;, Statistica Applicata, Italian Journal of Applied Statistics, 2013.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_NUTS1)</code></pre>

<hr>
<h2 id='normalise_ci'>
Normalisation and polarity functions
</h2><span id='topic+normalise_ci'></span>

<h3>Description</h3>

<p>This function lets to normalise simple indicators according to the polarity of each one.</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise_ci(x, indic_col, polarity, method=1, z.mean=0, z.std=1, ties.method ="average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_ci_+3A_x">x</code></td>
<td>
<p>A data frame containing simple indicators.</p>
</td></tr>
<tr><td><code id="normalise_ci_+3A_indic_col">indic_col</code></td>
<td>
<p>Simple indicators column number.</p>
</td></tr>
<tr><td><code id="normalise_ci_+3A_method">method</code></td>
<td>
<p>Normalisation methods: 
</p>

<ul>
<li> <p><b>1</b> (default) = standardization or z-scores using the following formulation: </p>
<p style="text-align: center;"><code class="reqn">z_{ij}=z.mean \pm \frac{x_{ij}-M_{x_j}}{S_{x_j}}\cdot z.std</code>
</p>
<p> where <code class="reqn">\pm</code> depends on <em>polarity</em> parameter and <em>z.mean</em> and <em>z.std</em> represent the shifting parameters.
</p>
</li>
<li> <p><b>2</b> = Min-max method using the following formulation: 
</p>
<p>if <em>polarity</em>=&quot;POS&quot;: </p>
<p style="text-align: center;"><code class="reqn">\frac{x-min(x)}{max(x)-min(x)}</code>
</p>
 
<p>if <em>polarity</em>=&quot;NEG&quot;: </p>
<p style="text-align: center;"><code class="reqn">\frac{max(x)-x}{max(x)-min(x)}</code>
</p>

</li>
<li> <p><b>3</b> = Ranking method. If <em>polarity</em>=&quot;POS&quot; ranking is increasing, while if <em>polarity</em>=&quot;NEG&quot; ranking is decreasing.
</p>
</li></ul>

</td></tr>
<tr><td><code id="normalise_ci_+3A_polarity">polarity</code></td>
<td>
<p>Polarity vector: &quot;POS&quot; = positive, &quot;NEG&quot; = negative. The polarity of a individual indicator is the sign of the relationship between the indicator and the phenomenon to be measured (e.g., in a well-being index, &quot;GDP per capita&quot; has 'positive' polarity and &quot;Unemployment rate&quot; has 'negative' polarity).</p>
</td></tr>
<tr><td><code id="normalise_ci_+3A_z.mean">z.mean</code></td>
<td>
<p>If method=1, Average shifting parameter. Default is 0.</p>
</td></tr>
<tr><td><code id="normalise_ci_+3A_z.std">z.std</code></td>
<td>
<p>If method=1, Standard deviation expansion parameter. Default is 1.</p>
</td></tr>
<tr><td><code id="normalise_ci_+3A_ties.method">ties.method</code></td>
<td>
<p>If method=3, A character string specifying how ties are treated, see <code><a href="base.html#topic+rank">rank</a></code> for details. Default is &quot;average&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>ci_norm</code></td>
<td>
<p>A data.frame containing normalised score of the choosen simple indicators.</p>
</td></tr>
<tr><td><code>norm_method</code></td>
<td>
<p>Normalisation method used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vidoli F.</p>


<h3>References</h3>

<p>OECD, &quot;<em>Handbook on constructing composite indicators: methodology and user guide</em>&quot;, 2008, pag.30.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ci_bod">ci_bod</a></code>, <code><a href="#topic+ci_mpi">ci_mpi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EU_NUTS1)

# Standard z-scores normalisation #
data_norm = normalise_ci(EU_NUTS1,c(2:3),c("NEG","POS"),method=1,z.mean=0, z.std=1)
summary(data_norm$ci_norm)

# Normalisation for MPI index #
data_norm = normalise_ci(EU_NUTS1,c(2:3),c("NEG","POS"),method=1,z.mean=100, z.std=10)
summary(data_norm$ci_norm)

data_norm = normalise_ci(EU_NUTS1,c(2:3),c("NEG","POS"),method=2)
summary(data_norm$ci_norm)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
