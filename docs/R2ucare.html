<!DOCTYPE html><html><head><title>Help for package R2ucare</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {R2ucare}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef_mixtures'><p>Estimation of multinomial mixture distributions parameters</p></a></li>
<li><a href='#deviance_mixture'><p>Deviance of multinomial mixture distributions</p></a></li>
<li><a href='#expval_table'><p>Expected values in a contingency table</p></a></li>
<li><a href='#gof_test'><p>Goodness-of-fit test for contingency tables</p></a></li>
<li><a href='#group_data'><p>Group individual capture-recapture data in encounter histories</p></a></li>
<li><a href='#group_data_gen'><p>Group individual capture-recapture data in encounter histories along specific column(s)</p></a></li>
<li><a href='#ind_test_22'><p>Test of independence for 2x2 contingency tables</p></a></li>
<li><a href='#ind_test_rc'><p>Test of independence for rxc contingency tables</p></a></li>
<li><a href='#inv_logit_gen'><p>Inverse generalized logit link</p></a></li>
<li><a href='#marray'><p>m-array: table of first recaptures</p></a></li>
<li><a href='#multimarray'><p>Multistate m-array</p></a></li>
<li><a href='#overall_CJS'><p>Overall goodness-of-fit test for the Cormack-Jolly-Seber model</p></a></li>
<li><a href='#overall_JMV'><p>Overall goodness-of-fit test for the Jolly-Move model</p></a></li>
<li><a href='#pool2K'><p>Pooling algorithm</p></a></li>
<li><a href='#pooling_ct'><p>Pooling algorithm (multisite goodness-of-fit tests)</p></a></li>
<li><a href='#pooling_mixtures'><p>Pooling algorithm (multisite goodness-of-fit tests)</p></a></li>
<li><a href='#read_headed'><p>Read capture-recapture data with Headed format used by program E-SURGE</p></a></li>
<li><a href='#read_inp'><p>Read capture-recapture data with Input (.inp) format used by program MARK</p></a></li>
<li><a href='#reconstitution'><p>Reformat outputs of multinomial mixture distributions parameters</p></a></li>
<li><a href='#repmat'><p>Replicate and tile a matrix</p></a></li>
<li><a href='#test2cl'><p>Test2.CL</p></a></li>
<li><a href='#test2ct'><p>Test2.CT</p></a></li>
<li><a href='#test3Gsm'><p>Test3G.SM</p></a></li>
<li><a href='#test3Gsr'><p>Test3G.SR</p></a></li>
<li><a href='#test3Gwbwa'><p>Test3G.WBWA</p></a></li>
<li><a href='#test3sm'><p>Test3.SM</p></a></li>
<li><a href='#test3sr'><p>Test3.SR</p></a></li>
<li><a href='#testMitec'><p>TestM.ITEC</p></a></li>
<li><a href='#testMltec'><p>TestM.LTEC</p></a></li>
<li><a href='#ungroup_data'><p>Ungroup encounter capture-recapture data in individual histories</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Goodness-of-Fit Tests for Capture-Recapture Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs goodness-of-fit tests for capture-recapture models as 
    described by Gimenez et al. (2018) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13014">doi:10.1111/2041-210X.13014</a>&gt;. 
    Also contains several functions to process capture-recapture data.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/oliviergimenez/R2ucare">https://github.com/oliviergimenez/R2ucare</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, RMark, stats, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/oliviergimenez/R2ucare/issues">https://github.com/oliviergimenez/R2ucare/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-09 01:26:19 UTC; Murray</td>
</tr>
<tr>
<td>Author:</td>
<td>Olivier Gimenez <a href="https://orcid.org/0000-0001-7001-5142"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jean-Dominique Lebreton [ctb],
  Remi Choquet [ctb],
  Roger Pradel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-11 08:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef_mixtures'>Estimation of multinomial mixture distributions parameters</h2><span id='topic+coef_mixtures'></span>

<h3>Description</h3>

<p>This function performs maximum likelihood inference for multinomial mixture distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_mixtures(Mp, Np)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_mixtures_+3A_mp">Mp</code></td>
<td>
<p>a matrix of mixtures (a row matrix if a vector)</p>
</td></tr>
<tr><td><code id="coef_mixtures_+3A_np">Np</code></td>
<td>
<p>a matrix of bases (a row matrix if a vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of maximum likelihood estimates for the cells of a mixture distribution:
</p>
<p>P matrix of cell probabilities estimates for mixtures
</p>
<p>PI matrix of mixture probabilities
</p>
<p>GAM matrix of cell probabilities estimates for bases
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>References</h3>

<p>Yantis, S., Meyer, D. E., and Smith, J. E. K. (1991). Analyses of multinomial mixture distributions: New tests for stochastic models of cognition and action. Psychological Bulletin 110, 350–374.
</p>

<hr>
<h2 id='deviance_mixture'>Deviance of multinomial mixture distributions</h2><span id='topic+deviance_mixture'></span>

<h3>Description</h3>

<p>This function calculates the deviance of multinomial mixture distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviance_mixture(x, M, N, s, n, nbmel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance_mixture_+3A_x">x</code></td>
<td>
<p>value to which the deviance is to be evaluated</p>
</td></tr>
<tr><td><code id="deviance_mixture_+3A_m">M</code></td>
<td>
<p>a vector of mixtures (see coef_mixtures.R)</p>
</td></tr>
<tr><td><code id="deviance_mixture_+3A_n">N</code></td>
<td>
<p>a vector of bases (see coef_mixtures.R)</p>
</td></tr>
<tr><td><code id="deviance_mixture_+3A_s">s</code></td>
<td>
<p>number of bases</p>
</td></tr>
<tr><td><code id="deviance_mixture_+3A_n">n</code></td>
<td>
<p>number of cell probabilities</p>
</td></tr>
<tr><td><code id="deviance_mixture_+3A_nbmel">nbmel</code></td>
<td>
<p>number of mixtures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the value of the deviance for mixture distributions.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>References</h3>

<p>Yantis, S., Meyer, D. E., and Smith, J. E. K. (1991). Analyses of multinomial mixture distributions: New tests for stochastic models of cognition and action. Psychological Bulletin 110, 350–374.
</p>

<hr>
<h2 id='expval_table'>Expected values in a contingency table</h2><span id='topic+expval_table'></span>

<h3>Description</h3>

<p>This function calculates expected values for a rxc contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expval_table(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expval_table_+3A_m">M</code></td>
<td>
<p>a matrix of observed probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of expected values.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>

<hr>
<h2 id='gof_test'>Goodness-of-fit test for contingency tables</h2><span id='topic+gof_test'></span>

<h3>Description</h3>

<p>This function carries out goodness-of-fit tests for contingency tables from the power-divergence family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_test(lambda, observes, theoriques)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_test_+3A_lambda">lambda</code></td>
<td>
<p>parameter defining the statistic to be used: lambda = -0.5 is for the Freeman-Tuckey statistic, lambda = 0 for the G2 statistic, lambda = 2/3 for the Cressie-Read statistic and lambda = 1 for the classical Chi-square statistic</p>
</td></tr>
<tr><td><code id="gof_test_+3A_observes">observes</code></td>
<td>
<p>vector of observed probabilities</p>
</td></tr>
<tr><td><code id="gof_test_+3A_theoriques">theoriques</code></td>
<td>
<p>vector of theoretical/expected probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the value of the goodness-of-fit statistic.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>

<hr>
<h2 id='group_data'>Group individual capture-recapture data in encounter histories</h2><span id='topic+group_data'></span>

<h3>Description</h3>

<p>This function pools together individuals with the same encounter capture-recapture history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_data(X, effX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_data_+3A_x">X</code></td>
<td>
<p>matrix of capture-recapture histories</p>
</td></tr>
<tr><td><code id="group_data_+3A_effx">effX</code></td>
<td>
<p>vector with numbers of individuals with that particular capture-recapture history</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with grouped capture-recapture histories and counts in the last column
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate fake capture-recapture dataset
X = matrix(round(runif(300)),nrow=100)
freq=rep(1,100)
cbind(X,freq)
group_data(X,freq)
</code></pre>

<hr>
<h2 id='group_data_gen'>Group individual capture-recapture data in encounter histories along specific column(s)</h2><span id='topic+group_data_gen'></span>

<h3>Description</h3>

<p>This function pools together individuals with the same encounter capture-recapture history along specified directions given by columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_data_gen(X, effX, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_data_gen_+3A_x">X</code></td>
<td>
<p>matrix of capture-recapture histories</p>
</td></tr>
<tr><td><code id="group_data_gen_+3A_effx">effX</code></td>
<td>
<p>vector with numbers of individuals with that particular capture-recapture history</p>
</td></tr>
<tr><td><code id="group_data_gen_+3A_s">s</code></td>
<td>
<p>scalar or vector of columns along which the grouping should be done</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with grouped capture-recapture histories and counts in the last column
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>

<hr>
<h2 id='ind_test_22'>Test of independence for 2x2 contingency tables</h2><span id='topic+ind_test_22'></span>

<h3>Description</h3>

<p>This function tests independence in 2x2 contingency tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_test_22(M, threshold = 2, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_test_22_+3A_m">M</code></td>
<td>
<p>is a 2x2 contingency table</p>
</td></tr>
<tr><td><code id="ind_test_22_+3A_threshold">threshold</code></td>
<td>
<p>is a threshold for low expected numbers; default is 2</p>
</td></tr>
<tr><td><code id="ind_test_22_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector with statistic of quadratic chi2 or inv chi2 corresponding to pvalue of Fisher test, p-value of quadratic chi2 test or Fisher test for low numbers, signed test and test performed (Chi-square, Fisher or None).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;,Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>

<hr>
<h2 id='ind_test_rc'>Test of independence for rxc contingency tables</h2><span id='topic+ind_test_rc'></span>

<h3>Description</h3>

<p>This function tests independence in rxc contingency tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_test_rc(M, threshold = 2, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_test_rc_+3A_m">M</code></td>
<td>
<p>is an r by c table of non-negative integers</p>
</td></tr>
<tr><td><code id="ind_test_rc_+3A_threshold">threshold</code></td>
<td>
<p>is a threshold for low expected numbers; default is 2</p>
</td></tr>
<tr><td><code id="ind_test_rc_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector with statistic of quadratic chi2 or inv chi2 corresponding to pvalue of Fisher test, p-value of quadratic chi2 test or Fisher test for low numbers, degree of freedom and test performed (Chi-square, Fisher or None).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;,Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>

<hr>
<h2 id='inv_logit_gen'>Inverse generalized logit link</h2><span id='topic+inv_logit_gen'></span>

<h3>Description</h3>

<p>This function computes the inverse (or reciprocal) of the generalized logit link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_logit_gen(petitv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_logit_gen_+3A_petitv">petitv</code></td>
<td>
<p>vector of values to be transformed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ev vector of transformed values
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>

<hr>
<h2 id='marray'>m-array: table of first recaptures</h2><span id='topic+marray'></span>

<h3>Description</h3>

<p>This function calculates the m-array, the number of released and never seen again individuals; deals with more than 1 group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marray(X, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marray_+3A_x">X</code></td>
<td>
<p>a matrix of encounter histories over K occasions</p>
</td></tr>
<tr><td><code id="marray_+3A_freq">freq</code></td>
<td>
<p>is a vector with the number of individuals having the corresponding encounter history</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with R the number of released individuals (K-1 x g matrix), m the m-array (K-1 x K-1 x g array) with upper triangle filled only and never the number of individuals never recaptured (K-1 x g matrix).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;,Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in the classical dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))

# Get encounter histories, counts and groups:
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
dip.group = dipper$groups

# get female data
mask = (dip.group == 'Female')
dip.fem.hist = dip.hist[mask,]
dip.fem.freq = dip.freq[mask]

# get number of released individuals (R), 
# the m-array (m) and 
# the number of individuals never seen again (never)
marray(dip.fem.hist,dip.fem.freq)
</code></pre>

<hr>
<h2 id='multimarray'>Multistate m-array</h2><span id='topic+multimarray'></span>

<h3>Description</h3>

<p>This function calculates the m-array for multistate capture-recapture data, the number of released and never seen again individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimarray(X, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimarray_+3A_x">X</code></td>
<td>
<p>a matrix of encounter histories over K occasions</p>
</td></tr>
<tr><td><code id="multimarray_+3A_freq">freq</code></td>
<td>
<p>is a vector with the number of individuals having the corresponding encounter history</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix in which R the number of released individuals is in the first column, the number of individuals never recaptured (K-1) is in the last column and m the m-array (K-1 x K-1) with upper triangle filled only is in sandwich between these two vectors.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;,Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read in Geese dataset:
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)

# Get encounter histories and number of individuals with corresponding histories
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size

# build m-array
multimarray(geese.hist, geese.freq)
</code></pre>

<hr>
<h2 id='overall_CJS'>Overall goodness-of-fit test for the Cormack-Jolly-Seber model</h2><span id='topic+overall_CJS'></span>

<h3>Description</h3>

<p>This function performs the overall goodness-of-fit test for the Cormack-Jolly-Seber model.
It is obtained as the sum of the 4 components Test3.SR, Test3.SM, Test2.CT and Test2.CL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_CJS(X, freq, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overall_CJS_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories</p>
</td></tr>
<tr><td><code id="overall_CJS_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="overall_CJS_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data.frame with the value of the test statistic, the degrees of freedom and the p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;,Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in the classical dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))

# Get encounter histories, counts and groups:
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
dip.group = dipper$groups

# split the dataset in males/females
mask = (dip.group == 'Female')
dip.fem.hist = dip.hist[mask,]
dip.fem.freq = dip.freq[mask]
mask = (dip.group == 'Male')
dip.mal.hist = dip.hist[mask,]
dip.mal.freq = dip.freq[mask]

# for females
overall_CJS(dip.fem.hist, dip.fem.freq)
</code></pre>

<hr>
<h2 id='overall_JMV'>Overall goodness-of-fit test for the Jolly-Move model</h2><span id='topic+overall_JMV'></span>

<h3>Description</h3>

<p>This function performs the overall goodness-of-fit test for the Jolly-Move model.
It is obtained as the sum of the 5 components Test3G.SR, Test3G.SM, Test3G.WBWA, TestM.ITEC, TestM.LTEC.
To perform the goodness-of-fit test for the Arnason-Schwarz model, both the Arnason-Schwarz (AS) and the Jolly-Move models need to be fitted to the data (to our knowledge, only E-SURGE can fit the JMV model).
Assuming the overall goodness-of-fit test for the JMV model has produced the value stat_jmv for the test statistic,
get the deviance (say dev_as and dev_jmv) and number of estimated parameters (say dof_as and dof_jmv) for both the AS and JMV models.
Then, finally, the p-value of the goodness-of-fit test for the AS model is obtained as 1 - pchisq(stat_as,dof_as) where stat_as = stat_jmv + (dev_as - dev_jmv) and dof_as = dof_jmv + (dof_jmv - dof_as)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_JMV(X, freq, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overall_JMV_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories</p>
</td></tr>
<tr><td><code id="overall_JMV_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="overall_JMV_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data.frame with the value of the test statistic, the degrees of freedom and the p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# read in Geese dataset
library(RMark)
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = convert.inp(geese)

geese.hist = matrix(as.numeric(unlist(strsplit(geese$ch, ''))),nrow=nrow(geese),byrow=TRUE)
geese.freq = geese$freq

# encounter histories and number of individuals with corresponding histories
X = geese.hist
freq = geese.freq

# load R2ucare package
library(R2ucare)

# perform overall gof test
overall_JMV(X, freq)

</code></pre>

<hr>
<h2 id='pool2K'>Pooling algorithm</h2><span id='topic+pool2K'></span>

<h3>Description</h3>

<p>This function pools columns of a 2xK contingency table (if needed, ie if low numbers present)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool2K(M, low = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool2K_+3A_m">M</code></td>
<td>
<p>is a 2 by K contingency table (or a K by 2 table)</p>
</td></tr>
<tr><td><code id="pool2K_+3A_low">low</code></td>
<td>
<p>is a threshold for low expected numbers; default is 2 (if this argument is big enough, the table is pooled down to 2 x 2; if this argument is 0, the table is not pooled)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with the pooled contingency table.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>

<hr>
<h2 id='pooling_ct'>Pooling algorithm (multisite goodness-of-fit tests)</h2><span id='topic+pooling_ct'></span>

<h3>Description</h3>

<p>This function pools rows and columns of a rxc contingency table according to Pradel et al. (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooling_ct(table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooling_ct_+3A_table">table</code></td>
<td>
<p>is a rxc contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with the pooled contingency table.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>References</h3>

<p>Pradel R., Wintrebert C.M.A. and Gimenez O. (2003). A proposal for a goodness-of-fit test to the Arnason-Schwarz multisite capture-recapture model. Biometrics 59: 43-53.
</p>

<hr>
<h2 id='pooling_mixtures'>Pooling algorithm (multisite goodness-of-fit tests)</h2><span id='topic+pooling_mixtures'></span>

<h3>Description</h3>

<p>This function pools rows and columns of a rxc bases and mixture table according to Pradel et al. (2003).
It provides the components of TestM in the multisite goodness-of-fit tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooling_mixtures(nk, nj, a, mixandbases)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooling_mixtures_+3A_nk">nk</code></td>
<td>
<p>number of mixtures</p>
</td></tr>
<tr><td><code id="pooling_mixtures_+3A_nj">nj</code></td>
<td>
<p>number of bases</p>
</td></tr>
<tr><td><code id="pooling_mixtures_+3A_a">a</code></td>
<td>
<p>number of sites/states</p>
</td></tr>
<tr><td><code id="pooling_mixtures_+3A_mixandbases">mixandbases</code></td>
<td>
<p>matrix with mixtures and bases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with the pooled table.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Rémi Choquet, Jean-Dominique Lebreton, Anne-Marie Reboulet, Roger Pradel
</p>


<h3>References</h3>

<p>Pradel R., Wintrebert C.M.A. and Gimenez O. (2003). A proposal for a goodness-of-fit test to the Arnason-Schwarz multisite capture-recapture model. Biometrics 59: 43-53.
</p>

<hr>
<h2 id='read_headed'>Read capture-recapture data with Headed format used by program E-SURGE</h2><span id='topic+read_headed'></span>

<h3>Description</h3>

<p>This function reads in capture-recapture dataset with the Headed format.
It ignores all forms of censorship for now, and drops continuous covariates because no goodness-of-fit test exists for such models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_headed(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_headed_+3A_file">file</code></td>
<td>
<p>text file with Headed format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with first component the matrix of encounter histories, second components the vector of number of individuals with corresponding histories and, if relevant, third component vector/matrix with group(s)
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in Dipper dataset
dipper = system.file("extdata", "ed.txt", package = "R2ucare")
read_headed(dipper)
# read in Geese dataset
geese = system.file("extdata", "geese.txt", package = "R2ucare")
read_headed(geese)
</code></pre>

<hr>
<h2 id='read_inp'>Read capture-recapture data with Input (.inp) format used by program MARK</h2><span id='topic+read_inp'></span>

<h3>Description</h3>

<p>This function reads in capture-recapture dataset with the Input format.
It is a wrapper for the function convert.inp from package RMark. It drops continuous covariates because no goodness-of-fit test exists for such models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_inp(file, group.df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_inp_+3A_file">file</code></td>
<td>
<p>text file with Input format (extension .inp)</p>
</td></tr>
<tr><td><code id="read_inp_+3A_group.df">group.df</code></td>
<td>
<p>dataframe with grouping variables; contains a row for each group defined in the input file row1=group1, row2=group2 etc. Names and number of columns in the dataframe is set by user to define grouping variables in RMark dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with first component the matrix of encounter histories, second components the vector of number of individuals with corresponding histories and, if relevant, third component vector/matrix with group(s)
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in Dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))
# read in Geese dataset
geese = system.file("extdata", "geese.inp", package = "R2ucare")
read_inp(geese)
</code></pre>

<hr>
<h2 id='reconstitution'>Reformat outputs of multinomial mixture distributions parameters</h2><span id='topic+reconstitution'></span>

<h3>Description</h3>

<p>This function reformat the outputs of multinomial mixture distributions parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstitution(x, s, n, nbmel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstitution_+3A_x">x</code></td>
<td>
<p>vector with cell probabilities estimates for mixtures and bases, along with mixture probilities</p>
</td></tr>
<tr><td><code id="reconstitution_+3A_s">s</code></td>
<td>
<p>number of bases</p>
</td></tr>
<tr><td><code id="reconstitution_+3A_n">n</code></td>
<td>
<p>number of cell probabilities</p>
</td></tr>
<tr><td><code id="reconstitution_+3A_nbmel">nbmel</code></td>
<td>
<p>number of mixtures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of maximum likelihood estimates for the cells of a mixture distribution with:
</p>
<p>P matrix of cell probabilities estimates for mixtures
</p>
<p>PI matrix of mixture probabilities
</p>
<p>GAM matrix of cell probabilities estimates for bases
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>

<hr>
<h2 id='repmat'>Replicate and tile a matrix</h2><span id='topic+repmat'></span>

<h3>Description</h3>

<p>This function creates a large matrix consisting of an m-by-n tiling of copies of X.
The dimensions of the returned matrix are nrow(X)*m x ncol(X)*n.
This is the equivalent of the repmat MATLAB function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmat(X, m, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repmat_+3A_x">X</code></td>
<td>
<p>matrix to be replicated</p>
</td></tr>
<tr><td><code id="repmat_+3A_m">m</code></td>
<td>
<p>row dimension of replication</p>
</td></tr>
<tr><td><code id="repmat_+3A_n">n</code></td>
<td>
<p>column dimension of replication</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A replicated matrix of X with dimensions nrow(X)*m x ncol(X)*n.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;
</p>

<hr>
<h2 id='test2cl'>Test2.CL</h2><span id='topic+test2cl'></span>

<h3>Description</h3>

<p>This function performs Test2.CL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test2cl(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test2cl_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test2cl_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test2cl_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test2cl_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with 5 columns for components i (2:K-3) (in rows) of test2.cli following Pradel 1993 (in Lebreton and North, Birkhauser Verlag): component, degree of freedom, statistic of the test, p-value, test performed.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in the classical dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))

# Get encounter histories, counts and groups:
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
dip.group = dipper$groups

# split the dataset in males/females
mask = (dip.group == 'Female')
dip.fem.hist = dip.hist[mask,]
dip.fem.freq = dip.freq[mask]
mask = (dip.group == 'Male')
dip.mal.hist = dip.hist[mask,]
dip.mal.freq = dip.freq[mask]

# for males
X = dip.mal.hist
freq = dip.mal.freq
res.males = test2cl(X,freq)
res.males
</code></pre>

<hr>
<h2 id='test2ct'>Test2.CT</h2><span id='topic+test2ct'></span>

<h3>Description</h3>

<p>This function performs Test2.CT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test2ct(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test2ct_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test2ct_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test2ct_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test2ct_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with 5 columns for components i (2:K-2) (in rows) of test2.Cti: component, degree of freedom, statistic of the test, p-value, signed test, test performed.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in the classical dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))

# Get encounter histories, counts and groups:
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
dip.group = dipper$groups

# split the dataset in males/females
mask = (dip.group == 'Female')
dip.fem.hist = dip.hist[mask,]
dip.fem.freq = dip.freq[mask]
mask = (dip.group == 'Male')
dip.mal.hist = dip.hist[mask,]
dip.mal.freq = dip.freq[mask]

# for females
X = dip.fem.hist
freq = dip.fem.freq
res.females = test2ct(X,freq)
res.females
</code></pre>

<hr>
<h2 id='test3Gsm'>Test3G.SM</h2><span id='topic+test3Gsm'></span>

<h3>Description</h3>

<p>This function performs Test3G.SM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test3Gsm(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test3Gsm_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test3Gsm_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test3Gsm_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test3Gsm_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with occasion, site, the value of the test statistic, degree of freedom, p-value and test performed (chi-square, Fisher or none).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read in Geese dataset:
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)

# Get encounter histories and number of individuals with corresponding histories
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size

# perform Test.3.GSm
test3Gsm(geese.hist,geese.freq)
</code></pre>

<hr>
<h2 id='test3Gsr'>Test3G.SR</h2><span id='topic+test3Gsr'></span>

<h3>Description</h3>

<p>This function performs Test3G.SR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test3Gsr(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test3Gsr_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test3Gsr_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test3Gsr_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test3Gsr_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with occasion, site, the value of the test statistic, degree of freedom, p-value and test performed (chi-square, Fisher or none).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read in Geese dataset:
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)

# Get encounter histories and number of individuals with corresponding histories
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size

# perform Test3.GSR
test3Gsr(geese.hist,geese.freq)
</code></pre>

<hr>
<h2 id='test3Gwbwa'>Test3G.WBWA</h2><span id='topic+test3Gwbwa'></span>

<h3>Description</h3>

<p>This function performs Test3G.WBWA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test3Gwbwa(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test3Gwbwa_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test3Gwbwa_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test3Gwbwa_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test3Gwbwa_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with occasion, site, the value of the test statistic, degree of freedom, p-value and test performed (chi-square, Fisher or none).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read in Geese dataset:
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)

# Get encounter histories and number of individuals with corresponding histories
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size

# perform Test.3GWBWA
test3Gwbwa(geese.hist,geese.freq)
</code></pre>

<hr>
<h2 id='test3sm'>Test3.SM</h2><span id='topic+test3sm'></span>

<h3>Description</h3>

<p>This function performs Test3.SM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test3sm(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test3sm_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test3sm_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test3sm_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test3sm_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with 5 columns for components i (2:K-1) (in rows) of test3.smi: component, degree of freedom, statistic of the test, p-value, test performed.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in the classical dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))

# Get encounter histories, counts and groups:
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
dip.group = dipper$groups

# split the dataset in males/females
mask = (dip.group == 'Female')
dip.fem.hist = dip.hist[mask,]
dip.fem.freq = dip.freq[mask]
mask = (dip.group == 'Male')
dip.mal.hist = dip.hist[mask,]
dip.mal.freq = dip.freq[mask]

# for females
res.females = test3sm(dip.fem.hist, dip.fem.freq)
res.females
</code></pre>

<hr>
<h2 id='test3sr'>Test3.SR</h2><span id='topic+test3sr'></span>

<h3>Description</h3>

<p>This function performs Test3.SR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test3sr(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test3sr_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="test3sr_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="test3sr_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="test3sr_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with 4 columns for components i (2:K-1) (in rows) of test3.sri: component, statistic of the test, p-value, signed test, test performed.
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Jean-Dominique Lebreton, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read in the classical dipper dataset
dipper = system.file("extdata", "ed.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))

# Get encounter histories, counts and groups:
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
dip.group = dipper$groups

# split the dataset in males/females
mask = (dip.group == 'Female')
dip.fem.hist = dip.hist[mask,]
dip.fem.freq = dip.freq[mask]
mask = (dip.group == 'Male')
dip.mal.hist = dip.hist[mask,]
dip.mal.freq = dip.freq[mask]

# Test3SR for males
res.males = test3sr(dip.mal.hist, dip.mal.freq)
res.males
</code></pre>

<hr>
<h2 id='testMitec'>TestM.ITEC</h2><span id='topic+testMitec'></span>

<h3>Description</h3>

<p>This function performs TestM.ITEC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMitec(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMitec_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="testMitec_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="testMitec_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="testMitec_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with occasion, the value of the test statistic, degree of freedom, p-value and test performed (chi-square, Fisher or none).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Rémi Choquet, Roger Pradel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read in Geese dataset:
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)

# Get encounter histories and number of individuals with corresponding histories
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size

# perform TestM.ITEC
testMitec(geese.hist,geese.freq)

</code></pre>

<hr>
<h2 id='testMltec'>TestM.LTEC</h2><span id='topic+testMltec'></span>

<h3>Description</h3>

<p>This function performs TestM.LTEC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMltec(X, freq, verbose = TRUE, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMltec_+3A_x">X</code></td>
<td>
<p>is a matrix of encounter histories with K occasions</p>
</td></tr>
<tr><td><code id="testMltec_+3A_freq">freq</code></td>
<td>
<p>is a vector of the number of individuals with the corresponding encounter history</p>
</td></tr>
<tr><td><code id="testMltec_+3A_verbose">verbose</code></td>
<td>
<p>controls the level of the details in the outputs; default is TRUE for all details</p>
</td></tr>
<tr><td><code id="testMltec_+3A_rounding">rounding</code></td>
<td>
<p>is the level of rounding for outputs; default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with first component the overall test and second component a data.frame with occasion, the value of the test statistic, degree of freedom, p-value and test performed (chi-square, Fisher or none).
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read in Geese dataset:
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)

# Get encounter histories and number of individuals with corresponding histories
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size

# perform TestM.LTEC
testMltec(geese.hist, geese.freq)

</code></pre>

<hr>
<h2 id='ungroup_data'>Ungroup encounter capture-recapture data in individual histories</h2><span id='topic+ungroup_data'></span>

<h3>Description</h3>

<p>This function splits encounter histories in as many individual histories as required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ungroup_data(X, effX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ungroup_data_+3A_x">X</code></td>
<td>
<p>matrix of encounter capture-recapture histories</p>
</td></tr>
<tr><td><code id="ungroup_data_+3A_effx">effX</code></td>
<td>
<p>vector with numbers of individuals with that particular encounter history</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with ungrouped capture-recapture histories and counts in the last column (should be 1s)
</p>


<h3>Author(s)</h3>

<p>Olivier Gimenez &lt;olivier.gimenez@cefe.cnrs.fr&gt;, Roger Pradel, Rémi Choquet
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate fake capture-recapture dataset
X = matrix(round(runif(9)),nrow=3)
freq=c(4,3,-8)
cbind(X,freq)
ungroup_data(X,freq)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
