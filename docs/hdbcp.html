<!DOCTYPE html><html lang="en"><head><title>Help for package hdbcp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdbcp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#generate_cov_datasets'><p>Generate Simulated Datasets with Change Points in Covariance Matrix</p></a></li>
<li><a href='#generate_mean_datasets'><p>Generate Simulated Datasets with Change Points in Mean Vector</p></a></li>
<li><a href='#majority_rule_mxPBF'><p>Majority Rule for Multiscale approach using mxPBF Results</p></a></li>
<li><a href='#mvrnorm_cpp'><p>Multivariate Normal Random Number Generator</p></a></li>
<li><a href='#mxPBF_combined'><p>Change Point Detection in Mean Structure using Maximum Pairwise Bayes Factor (mxPBF)</p></a></li>
<li><a href='#mxPBF_cov'><p>Change Point Detection in Covaraiance Structure using Maximum Pairwise Bayes Factor (mxPBF)</p></a></li>
<li><a href='#mxPBF_mean'><p>Change Point Detection in Mean Structure using Maximum Pairwise Bayes Factor (mxPBF)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Change Point Detection for High-Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>JaeHoon Kim &lt;jhkimstat@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions implementing change point detection methods using the maximum pairwise Bayes factor approach.
    Additionally, the package includes tools for generating simulated datasets for comparing and evaluating change point detection techniques.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JaeHoonKim98/hdbcp">https://github.com/JaeHoonKim98/hdbcp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JaeHoonKim98/hdbcp/issues">https://github.com/JaeHoonKim98/hdbcp/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats, dplyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-19 03:35:23 UTC; jhkim</td>
</tr>
<tr>
<td>Author:</td>
<td>JaeHoon Kim [aut, cre],
  KyoungJae Lee [aut, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-19 03:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='generate_cov_datasets'>Generate Simulated Datasets with Change Points in Covariance Matrix</h2><span id='topic+generate_cov_datasets'></span>

<h3>Description</h3>

<p>This function generates simulated datasets that include change points in the covariance matrix for change point detection.
Users can specify various parameters to control the dataset size, dimension, size of signal, and change point locations.
The generated datasets include datasets with and without change points, allowing for comparisons in simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cov_datasets(
  n,
  p,
  signal_size,
  sparse = TRUE,
  single_point = round(n/2),
  multiple_points = c(round(n/4), round(2 * n/4), round(3 * n/4)),
  type = c(1, 2, 3, 4, 5)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_cov_datasets_+3A_n">n</code></td>
<td>
<p>Number of observations to generate.</p>
</td></tr>
<tr><td><code id="generate_cov_datasets_+3A_p">p</code></td>
<td>
<p>Number of features or dimensions for each observation.</p>
</td></tr>
<tr><td><code id="generate_cov_datasets_+3A_signal_size">signal_size</code></td>
<td>
<p>Magnitude of the signal applied at change points.</p>
</td></tr>
<tr><td><code id="generate_cov_datasets_+3A_sparse">sparse</code></td>
<td>
<p>Determines if a sparse covariance structure is used (default is TRUE).</p>
</td></tr>
<tr><td><code id="generate_cov_datasets_+3A_single_point">single_point</code></td>
<td>
<p>Location of a single change point in the dataset (default is n/2).</p>
</td></tr>
<tr><td><code id="generate_cov_datasets_+3A_multiple_points">multiple_points</code></td>
<td>
<p>Locations of multiple change points within the dataset (default is quartiles of n).</p>
</td></tr>
<tr><td><code id="generate_cov_datasets_+3A_type">type</code></td>
<td>
<p>Integer vector specifying the type of dataset to return. Options are as follows:
- 1: No change points (H0 data)
- 2: Single change point with rare signals
- 3: Single change point with many signals
- 4: Multiple change points with rare signals
- 5: Multiple change points with many signals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D array containing the generated datasets. Each slice represents a different dataset type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a default dataset
datasets &lt;- generate_cov_datasets(100, 50, 1)

null_data &lt;- datasets[,,1]
single_many_data &lt;- datasets[,,3]

</code></pre>

<hr>
<h2 id='generate_mean_datasets'>Generate Simulated Datasets with Change Points in Mean Vector</h2><span id='topic+generate_mean_datasets'></span>

<h3>Description</h3>

<p>This function generates simulated datasets that include change points in the mean vector for change point detection.
Users can specify various parameters to control the dataset size, dimension, size of signal, and change point locations.
The generated datasets include datasets with and without change points, allowing for comparisons in simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_mean_datasets(
  n = 500,
  p = 200,
  signal_size = 1,
  pre_proportion = 0.4,
  pre_value = 0.3,
  single_point = round(n/2),
  multiple_points = c(round(n/4), round(2 * n/4), round(3 * n/4)),
  type = c(1, 2, 3, 4, 5)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_mean_datasets_+3A_n">n</code></td>
<td>
<p>Number of observations to generate.</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_p">p</code></td>
<td>
<p>Number of features or dimensions for each observation.</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_signal_size">signal_size</code></td>
<td>
<p>Magnitude of the signal to apply at change points.</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_pre_proportion">pre_proportion</code></td>
<td>
<p>Proportion of the covariance matrix's off-diagonal elements to be set to a pre-defined value (default is 0.4).</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_pre_value">pre_value</code></td>
<td>
<p>Value assigned to selected off-diagonal elements of the covariance matrix (default is 0.3).</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_single_point">single_point</code></td>
<td>
<p>Location of a single change point in the dataset (default is n/2).</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_multiple_points">multiple_points</code></td>
<td>
<p>Locations of multiple change points within the dataset (default is quartiles of n).</p>
</td></tr>
<tr><td><code id="generate_mean_datasets_+3A_type">type</code></td>
<td>
<p>Integer specifying the type of dataset to return. Options are as follows:
- 1: No change points (H0 data)
- 2: Single change point with rare signals
- 3: Single change point with many signals
- 4: Multiple change points with rare signals
- 5: Multiple change points with many signals
The default options are 1, 2, 3, 4, and 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D array containing the generated datasets. Each slice represents a different dataset type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a default dataset
datasets &lt;- generate_mean_datasets(100, 50, 1)

null_data &lt;- datasets[,,1]
single_many_data &lt;- datasets[,,3]

</code></pre>

<hr>
<h2 id='majority_rule_mxPBF'>Majority Rule for Multiscale approach using mxPBF Results</h2><span id='topic+majority_rule_mxPBF'></span>

<h3>Description</h3>

<p>This function implements a majority rule-based post-processing approach to identify common change points across multiple window sizes from mxPBF results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>majority_rule_mxPBF(res_mxPBF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="majority_rule_mxPBF_+3A_res_mxpbf">res_mxPBF</code></td>
<td>
<p>A list of results from <code>mxPBF_mean()</code> or <code>mxPBF_cov()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of final detected change points that are common across multiple windows based on majority rule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 500
p &lt;- 200
signal_size &lt;- 1
pre_value &lt;- 0.3
pre_proportion &lt;- 0.4
given_data &lt;- generate_mean_datasets(n, p, signal_size, pre_proportion, pre_value,
single_point = 250, multiple_points = c(150,300,350), type = 5)
nws &lt;- c(25, 60, 100)
alps &lt;- seq(1,10,0.05)
res_mxPBF &lt;- mxPBF_mean(given_data, nws, alps)
majority_rule_mxPBF(res_mxPBF)


</code></pre>

<hr>
<h2 id='mvrnorm_cpp'>Multivariate Normal Random Number Generator</h2><span id='topic+mvrnorm_cpp'></span>

<h3>Description</h3>

<p>Generates random numbers from a multivariate normal distribution with specified mean and covariance matrix using a C++ implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrnorm_cpp(n = 1, mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrnorm_cpp_+3A_n">n</code></td>
<td>
<p>The number of random samples to generate. Defaults to 1.</p>
</td></tr>
<tr><td><code id="mvrnorm_cpp_+3A_mu">mu</code></td>
<td>
<p>The mean vector of the distribution.</p>
</td></tr>
<tr><td><code id="mvrnorm_cpp_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix of the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix where each row is a random sample from the multivariate normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
mu &lt;- c(0, 0)
Sigma &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
mvrnorm_cpp(5, mu, Sigma)

</code></pre>

<hr>
<h2 id='mxPBF_combined'>Change Point Detection in Mean Structure using Maximum Pairwise Bayes Factor (mxPBF)</h2><span id='topic+mxPBF_combined'></span>

<h3>Description</h3>

<p>This function detects change points in both mean and covariance structure of multivariate Gaussian data using the Maximum Pairwise Bayes Factor (mxPBF).
The function selects alpha that controls the empirical False Positive Rate (FPR), as suggested in the paper.
The function conducts a multiscale approach using the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPBF_combined(
  given_data,
  nws,
  alps,
  a0 = 0.01,
  b0 = 0.01,
  FPR_want = 0.05,
  n_sample = 300,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mxPBF_combined_+3A_given_data">given_data</code></td>
<td>
<p>An <code class="reqn">(n \times p)</code> data matrix representing <code class="reqn">n</code> observations and <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_nws">nws</code></td>
<td>
<p>A set of window sizes for change point detection.</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_alps">alps</code></td>
<td>
<p>A grid of alpha values used in the empirical False Positive Rate (FPR) method.</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_a0">a0</code></td>
<td>
<p>A hyperparameter <code class="reqn">a_0</code> used in the mxPBF (default: 0.01).</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_b0">b0</code></td>
<td>
<p>A hyperparameter <code class="reqn">b_0</code> used in the mxPBF (default: 0.01).</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_fpr_want">FPR_want</code></td>
<td>
<p>Desired False Positive Rate for selecting alpha, used in the empirical FPR method (default: 0.05).</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of simulated samples to estimate the empirical FPR, used in the empirical FPR method (default: 300).</p>
</td></tr>
<tr><td><code id="mxPBF_combined_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of threads for parallel execution via OpenMP (default: 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list provided. Each element in the list contains: </p>

<dl>
<dt>Result_cov</dt><dd><p>A list result from the <code>mxPBF_cov()</code> function.</p>
</dd>
<dt>Result_mean</dt><dd><p>A list result from the <code>mxPBF_mean()</code> function applied to each segmented data.</p>
</dd>
<dt>Change_points_cov</dt><dd><p>Locations of detected change points identified by <code>mxPBF_cov()</code> function.</p>
</dd>
<dt>Change_points_mean</dt><dd><p>Locations of detected change points identified by <code>mxPBF_mean()</code> function.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nws &lt;- c(25, 60, 100)
alps &lt;- seq(1,10,0.05)
## H0 data
mu1 &lt;- rep(0,10)
sigma1 &lt;- diag(10)
X &lt;- mvrnorm_cpp(500, mu1, sigma1)
res1 &lt;- mxPBF_combined(X, nws, alps)

## H1 data
mu2 &lt;- rep(1,10)
sigma2 &lt;- diag(10)
for (i in 1:10) {
  for (j in i:10) {
    if (i == j) {
    next
    } else {
    cov_value &lt;- rnorm(1, 1, 1)
    sigma2[i, j] &lt;- cov_value
    sigma2[j, i] &lt;- cov_value
    }
  }
}
sigma2 &lt;- sigma2 + (abs(min(eigen(sigma2)$value))+0.1)*diag(10) # Make it nonsingular
Y1 &lt;- mvrnorm_cpp(150, mu1, sigma1)
Y2 &lt;- mvrnorm_cpp(150, mu2, sigma1)
Y3 &lt;- mvrnorm_cpp(200, mu2, sigma2)
Y &lt;- rbind(Y1, Y2, Y3)
res2 &lt;- mxPBF_combined(Y, nws, alps)


</code></pre>

<hr>
<h2 id='mxPBF_cov'>Change Point Detection in Covaraiance Structure using Maximum Pairwise Bayes Factor (mxPBF)</h2><span id='topic+mxPBF_cov'></span>

<h3>Description</h3>

<p>This function detects change points in the covariance structure of multivariate Gaussian data using the Maximum Pairwise Bayes Factor (mxPBF).
The function selects alpha that controls the empirical False Positive Rate (FPR), as suggested in the paper.
One can conduct a multiscale approach using the function <code>majority_rule_mxPBF()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPBF_cov(
  given_data,
  nws,
  alps,
  a0 = 0.01,
  b0 = 0.01,
  FPR_want = 0.05,
  n_sample = 300,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mxPBF_cov_+3A_given_data">given_data</code></td>
<td>
<p>An <code class="reqn">(n \times p)</code> data matrix representing <code class="reqn">n</code> observations and <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_nws">nws</code></td>
<td>
<p>A set of window sizes for change point detection.</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_alps">alps</code></td>
<td>
<p>A grid of alpha values used in the empirical False Positive Rate (FPR) method.</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_a0">a0</code></td>
<td>
<p>A hyperparameter <code class="reqn">a_0</code> used in the mxPBF (default: 0.01).</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_b0">b0</code></td>
<td>
<p>A hyperparameter <code class="reqn">b_0</code> used in the mxPBF (default: 0.01).</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_fpr_want">FPR_want</code></td>
<td>
<p>Desired False Positive Rate for selecting alpha, used in the empirical FPR method (default: 0.05).</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of simulated samples to estimate the empirical FPR, used in the empirical FPR method (default: 300).</p>
</td></tr>
<tr><td><code id="mxPBF_cov_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of threads for parallel execution via OpenMP (default: 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of window sizes provided. Each element in the list contains: </p>

<dl>
<dt>Change_points</dt><dd><p>Locations of detected change points.</p>
</dd>
<dt>Bayes_Factors</dt><dd><p>Vector of calculated Bayes Factors for each middle points.</p>
</dd>
<dt>Selected_alpha</dt><dd><p>Optimal alpha value selected based on the method that controls the empirical FPR.</p>
</dd>
<dt>Window_size</dt><dd><p>Window size used for change point detection.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nws &lt;- c(25, 60, 100)
alps &lt;- seq(1,10,0.05)
## H0 data
mu &lt;- rep(0,10)
sigma1 &lt;- diag(10)
X &lt;- mvrnorm_cpp(500, mu, sigma1)
res1 &lt;- mxPBF_cov(X, nws, alps)

## H1 data
mu &lt;- rep(0,10)
sigma2 &lt;- diag(10)
for (i in 1:10) {
  for (j in i:10) {
    if (i == j) {
    next
    } else {
    cov_value &lt;- rnorm(1, 1, 1)
    sigma2[i, j] &lt;- cov_value
    sigma2[j, i] &lt;- cov_value
    }
  }
}
sigma2 &lt;- sigma2 + (abs(min(eigen(sigma2)$value))+0.1)*diag(10) # Make it nonsingular
Y1 &lt;- mvrnorm_cpp(250, mu, sigma1)
Y2 &lt;- mvrnorm_cpp(250, mu, sigma2)
Y &lt;- rbind(Y1, Y2)
res2 &lt;- mxPBF_cov(Y, nws, alps)


</code></pre>

<hr>
<h2 id='mxPBF_mean'>Change Point Detection in Mean Structure using Maximum Pairwise Bayes Factor (mxPBF)</h2><span id='topic+mxPBF_mean'></span>

<h3>Description</h3>

<p>This function detects change points in the mean structure of multivariate Gaussian data using the Maximum Pairwise Bayes Factor (mxPBF).
The function selects alpha that controls the empirical False Positive Rate (FPR), as suggested in the paper.
One can conduct a multiscale approach using the function <code>majority_rule_mxPBF()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPBF_mean(given_data, nws, alps, FPR_want = 0.05, n_sample = 300, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mxPBF_mean_+3A_given_data">given_data</code></td>
<td>
<p>An <code class="reqn">(n \times p)</code> data matrix representing <code class="reqn">n</code> observations and <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="mxPBF_mean_+3A_nws">nws</code></td>
<td>
<p>A set of window sizes for change point detection.</p>
</td></tr>
<tr><td><code id="mxPBF_mean_+3A_alps">alps</code></td>
<td>
<p>A grid of alpha values used in the empirical False Positive Rate (FPR) method.</p>
</td></tr>
<tr><td><code id="mxPBF_mean_+3A_fpr_want">FPR_want</code></td>
<td>
<p>Desired False Positive Rate for selecting alpha, used in the empirical FPR method (default: 0.05).</p>
</td></tr>
<tr><td><code id="mxPBF_mean_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of simulated samples to estimate the empirical FPR, used in the empirical FPR method (default: 300).</p>
</td></tr>
<tr><td><code id="mxPBF_mean_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of threads for parallel execution via OpenMP (default: 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of window sizes provided. Each element in the list contains: </p>

<dl>
<dt>Change_points</dt><dd><p>Locations of detected change points.</p>
</dd>
<dt>Bayes_Factors</dt><dd><p>Vector of calculated Bayes Factors for each middle points.</p>
</dd>
<dt>Selected_alpha</dt><dd><p>Optimal alpha value selected based on the method that controls the empirical FPR.</p>
</dd>
<dt>Window_size</dt><dd><p>Window size used for change point detection.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nws &lt;- c(25, 60, 100)
alps &lt;- seq(1,10,0.05)
## H0 data
mu1 &lt;- rep(0,10)
sigma &lt;- diag(10)
X &lt;- mvrnorm_cpp(500, mu1, sigma)
res1 &lt;- mxPBF_mean(X, nws, alps)

## H1 data
mu2 &lt;- rep(1,10)
sigma &lt;- diag(10)
Y &lt;- rbind(mvrnorm_cpp(250,mu1,sigma), mvrnorm_cpp(250,mu2,sigma))
res2 &lt;- mxPBF_mean(Y, nws, alps)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
