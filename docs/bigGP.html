<!DOCTYPE html><html><head><title>Help for package bigGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alloc'>
<p>Create Object with its Own Memory</p></a></li>
<li><a href='#bigGP'>
<p>Package for Calculations with Big Gaussian Processes</p></a></li>
<li><a href='#bigGP-meta'>
<p>Information about the number and identities of the processes</p>
</p></a></li>
<li><a href='#bigGP.exit'>
<p>Exit bigGP Environment</p></a></li>
<li><a href='#bigGP.init'>
<p>Initialize bigGP package</p></a></li>
<li><a href='#calcD'>
<p>Calculate Partition Factor</p></a></li>
<li><a href='#calcIJ'>
<p>Calculate Slave Process Identifiers</p></a></li>
<li><a href='#collectDiagonal'>
<p>Return the Diagonal of a Distributed Square Matrix to the Master Process</p></a></li>
<li><a href='#collectRectangularMatrix'>
<p>Return a Distributed Rectangular Matrix to the Master Process</p></a></li>
<li><a href='#collectTriangularMatrix'>
<p>Return a Distributed Symmetric or Triangular Matrix to the Master Process</p></a></li>
<li><a href='#collectVector'>
<p>Return a Distributed Vector to the Master Process</p></a></li>
<li><a href='#distributedKrigeProblem-class'>
<p>ReferenceClass for Distributed Components of the krigeProblem ReferenceClass</p></a></li>
<li><a href='#distributeVector'>
<p>Distribute a Vector to the Slave Processes</p></a></li>
<li><a href='#getDistributedVectorLength'>
<p>Find Length of Subset of Vector or Matrix Stored on Slave Process</p></a></li>
<li><a href='#krigeProblem-class'><p>Class <code>"krigeProblem"</code></p></a></li>
<li><a href='#localAssign'>
<p>Assign a New Name to an Object on Slave Process</p></a></li>
<li><a href='#localCalc'>
<p>Local Calculation Functions</p></a></li>
<li><a href='#localCollectVector'>
<p>Local Distribution and Collection Functions</p></a></li>
<li><a href='#localGetVectorIndices'>
<p>Get Indices of Vector or Matrix Elements Stored on Slave Process</p></a></li>
<li><a href='#localKrigeProblemConstructMean'>
<p>Calculate Mean Vector or Covariance Matrix on Slave Process</p></a></li>
<li><a href='#localRm'>
<p>Remove Objects on Slave Process</p></a></li>
<li><a href='#pull'>
<p>Copy Object from Slave Processes to Master</p></a></li>
<li><a href='#push'>
<p>Copy Object from Master to Slave Processes</p></a></li>
<li><a href='#remoteCalc'>
<p>Do Arbitrary Calculations on One or Two Inputs</p></a></li>
<li><a href='#remoteCalcChol'>
<p>Calculate Distributed Cholesky Decomposition</p></a></li>
<li><a href='#remoteConstructRnormVector'>
<p>Create Distributed Vector or Matrix of Random Normals</p></a></li>
<li><a href='#remoteCrossProdMatSelf'>
<p>Distributed Crossproduct of a Rectangular Matrix with Itself</p></a></li>
<li><a href='#remoteCrossProdMatVec'>
<p>Distributed Crossproduct of a Rectangular Matrix and a Vector</p></a></li>
<li><a href='#remoteForwardsolve'>
<p>Solve a Distributed Triangular System</p></a></li>
<li><a href='#remoteGetIndices'>
<p>Determine Indices of Vector or Matrix Elements Stored on all Processes</p></a></li>
<li><a href='#remoteLs'><p>Remote List Objects</p></a></li>
<li><a href='#remoteMultChol'>
<p>Distributed Multiplication of Lower Triangular Matrix and a Vector or Matrix</p></a></li>
<li><a href='#remoteRm'>
<p>Remote Remove Objects</p></a></li>
<li><a href='#SN2011fe'>
<p>SN2011fe Supernova Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Distributed Gaussian Process Calculations</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), Rmpi (&ge; 0.6-2), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rlecuyer, fields</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Distributes Gaussian process calculations across nodes
    in a distributed memory setting, using Rmpi. The bigGP class 
    provides high-level methods for maximum likelihood with normal data, 
    prediction, calculation of uncertainty (i.e., posterior covariance 
    calculations), and simulation of realizations. In addition, bigGP 
    provides an API for basic matrix calculations with distributed 
    covariance matrices, including Cholesky decomposition, back/forwardsolve, 
    crossproduct, and matrix multiplication.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenMPI or MPICH2</td>
</tr>
<tr>
<td>OS_type:</td>
<td>unix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.18637/jss.v063.i10">https://doi.org/10.18637/jss.v063.i10</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'auxil.R' 'bigGP.R' 'collectDistribute.R'
'distributedComputation.R' 'krigeProblem.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-25 14:55:25 UTC; paciorek</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Paciorek [aut, cre],
  Benjamin Lipshitz [aut],
  Prabhat [ctb],
  Cari Kaufman [ctb],
  Tina Zhuo [ctb],
  Rollin Thomas [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Paciorek &lt;paciorek@stat.berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-25 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alloc'>
Create Object with its Own Memory
</h2><span id='topic+alloc'></span>

<h3>Description</h3>

<p><code>alloc</code> is an internal auxiliary function that creates an object
of the size of the input with the goal of allocating new memory for use
in the C functions used by the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alloc(input, inputPos = '.GlobalEnv')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alloc_+3A_input">input</code></td>
<td>
<p>an object name, given as a character string, giving the
name of the object whose size is to be mimiced in creating the
output, or the length of the output vector to be created.</p>
</td></tr>
<tr><td><code id="alloc_+3A_inputpos">inputPos</code></td>
<td>
<p> where to look for the input, given as a character
string (unlike <code>get</code>). This can indicate an environment, a
list, or a ReferenceClassobject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new numeric vector of the appropriate size.
</p>

<hr>
<h2 id='bigGP'>
Package for Calculations with Big Gaussian Processes
</h2><span id='topic+bigGP'></span><span id='topic+bigGP-package'></span>

<h3>Description</h3>

<p><code>bigGP</code> is a collection of functions for doing distributed
calculations in the context of various kinds of Gaussian process
models, combined with a ReferenceClass, <code>krigeProblem</code>,
for doing kriging calculations
based on maximum likelihood estimation. 
</p>


<h3>Details</h3>

<p>Full details on doing distributed kriging can be found in the help
page for <code><a href="#topic+krigeProblem">krigeProblem</a></code>. For general calculations with
distributed vectors and matrices, including extending the package for
additional use cases beyond standard kriging, one first needs to
create the needed vectors and matrices in a distributed fashion on the
slave processes.  To do this, the indices associated with relevant vectors and matrices  need to be found for each slave process; see
<code><a href="#topic+localGetVectorIndices">localGetVectorIndices</a></code>. Then these indices need to be
used by user-created functions to create the pieces of the vectors and
matrices residing on each slave process; see
<code><a href="#topic+localKrigeProblemConstructMean">localKrigeProblemConstructMean</a></code> and
<code><a href="#topic+localKrigeProblemConstructMean">localKrigeProblemConstructMean</a></code> for examples. Following
this, one can use the various functions for distributed linear
algebra.
</p>
<p>The functions provided for distributed linear algebra are:
</p>

<dl>
<dt><code>remoteCalcChol</code>: </dt><dd><p>calculates the Cholesky decomposition of
a (numerically) positive definite matrix, <code class="reqn">C = L L^{\top}</code>. Matrices that are not numerically positive.</p>
</dd>
</dl>
<p>definite will cause failure as pivoting is not implemented.
</p>
<dl>
<dt><code>remoteForwardsolve</code>: </dt><dd><p>does a forwardsolve using an
already-calculated Cholesky factor into a vector or matrix, <code class="reqn">L^{-1}Z</code>.</p>
</dd>
<dt><code>remoteBacksolve</code>: </dt><dd><p>does a backsolve using an
already-calculated Cholesky factor into a vector or matrix, <code class="reqn">L^{-\top}Z</code>.</p>
</dd>
<dt><code>remoteMultChol</code>: </dt><dd><p>multiplies and an
already-calculated Cholesky factor by a vector or matrix, <code class="reqn">LZ</code>.</p>
</dd>
<dt><code>remoteCrossProdMatVec</code>: </dt><dd><p>multiplies the transpose of a
matrix by a vector, <code class="reqn">X^{\top}z</code>.</p>
</dd>
<dt><code>remoteCrossProdMatSelf</code>: </dt><dd><p>does the crossproduct of a matrix, <code class="reqn">X^{\top}X</code>.</p>
</dd>
<dt><code>remoteCrossProdMatSelfDiag</code>: </dt><dd><p>finds the diagonal of the crossproduct of a matrix, <code class="reqn">\mbox{diag}(X^{\top}X)</code>.</p>
</dd>
<dt><code>remoteConstructRnormVector</code>: </dt><dd><p>generates a vector of
random standard normal variables.</p>
</dd>
<dt><code>remoteConstructRnormMatrix</code>: </dt><dd><p>generates a matrix of
random standard normal variables.</p>
</dd>
<dt><code>remoteCalc</code>: </dt><dd><p>does arbitrary calculations on one or two
inputs.</p>
</dd>
</dl>



<h3>Warnings</h3>

<p>Note that the block replication factor, <code class="reqn">h</code>, needs to be
consistent in any given calculation. So if one is doing a
forwardsolve, the replication factor used in distributing the
original matrix (and therefore its Cholesky factor) should be the
same as that used in distributing the vector being solved into (or the rows
of the matrix being solved into).
</p>
<p>Also note that when carrying out time-intensive calculations on the
slave processes, the slaves will not be responsive to additional
interaction, so commands such as <code>remoteLs</code> may appear to
hang. This may occur because the slave process needs to finish a
previous calculation before responding.
</p>
<p>Note that distributed vectors and distributed one-column
matrices are stored differently, with matrices stored with padded
columns. When using <code>remoteForwardSolve</code>, <code>remoteBacksolve</code>,
<code>remoteMultChol</code>, you should use <code>n2 = NULL</code> when the
second argument is a vector and <code>n2 = 1</code> when the second column
is a one-column matrix.
</p>
<p>Note that triangular and symmetric matrices are stored as vectors, column-major
order, of the lower triangular elements. To collect a distributed
symmetric matrix on the master process, one uses
<code>collectTriangularMatrix</code>. <code>collectTriangularMatrix</code> always
fills the upper triangle as the transpose of the lower triangle. 
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek and Benjamin Lipshitz, in collaboration with Tina
Zhuo, Cari Kaufman, Rollin Thomas, and Prabhat.
</p>
<p>Maintainer: Christopher Paciorek &lt;paciorek@alumni.cmu.edu&gt;
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+bigGP.init">bigGP.init</a></code> for the necessary initialization steps, and
<code><a href="#topic+krigeProblem">krigeProblem</a></code> for doing kriging based on maximum likelihood
estimation. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this is an example of using the API to do distributed linear algebra
#    for Gaussian process calculations; we'll demonstrate generating from
#    a Gaussian process with exponential covariance; note that this can
#    be done more easily through the krigeProblem ReferenceClass
## Not run: 
bigGP.init(3)
params &lt;- c(sigma2 = 1, rho = 0.25)
# for this example, we'll use a modest size problem, but to demo on a
#    cluster, increase m to a larger value
m &lt;- 80 
gd &lt;- seq(0, 1, length = m)
locns = expand.grid(x = gd, y = gd)
# indices will be a two column matrix with the index of the first set of
#  locations in the first column and of the second set in the second column
covfunc &lt;- function(params, locns, indices) {
dd &lt;- sqrt( (locns$x[indices[,1]] - locns$x[indices[,2]])^2 +
(locns$y[indices[,1]] - locns$y[indices[,2]])^2 )
return(params["sigma2"] * exp(-dd / params["rho"]))
}
mpi.bcast.Robj2slave(params)
mpi.bcast.Robj2slave(covfunc)
mpi.bcast.Robj2slave(locns)
mpi.bcast.cmd(indices &lt;- localGetTriangularMatrixIndices(nrow(locns)))
mpi.bcast.cmd(C &lt;- covfunc(params, locns, indices))
remoteLs() # this may pause before reporting, as slaves are busy doing
#    computations above
remoteCalcChol('C', 'L', n = m^2)
remoteConstructRnormVector('z', n = m^2)
remoteMultChol('L', 'z', 'x', n1 = m^2)
x &lt;- collectVector('x', n = m^2)
image(gd, gd, matrix(x, m))

## End(Not run)
</code></pre>

<hr>
<h2 id='bigGP-meta'>
Information about the number and identities of the processes
</h2><span id='topic+bigGP-meta'></span><span id='topic+.bigGP'></span><span id='topic+.bigGP.fill'></span>

<h3>Description</h3>

<p>The <code>.bigGP</code> object (an environment) contains information about
the processes involved in the distributed
computation. <code>.bigGP.fill</code> is an internal auxiliary function that
fills the 
<code>.bigGP</code> object with the values of <code class="reqn">P</code>, <code class="reqn">D</code>, <code class="reqn">I</code>, and <code class="reqn">J</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.bigGP
.bigGP.fill(init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigGP-meta_+3A_init">init</code></td>
<td>
<p>logical, indicating whether to initialize values to their
defaults for before the processes are set up</p>
</td></tr>
</table>

<hr>
<h2 id='bigGP.exit'>
Exit bigGP Environment
</h2><span id='topic+bigGP.exit'></span><span id='topic+bigGP.quit'></span>

<h3>Description</h3>

<p><code>bigGP.exit</code> terminates the package's execution environment and
detaches the package. After that, you can still work in R.
</p>
<p><code>bigGP.quit</code> terminates the package's execution environment and quits R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigGP.exit()
bigGP.quit(save = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigGP.exit_+3A_save">save</code></td>
<td>

<p>the same argument as <code>quit</code>, but defaulting to &quot;no&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions should be used to safely leave the <span class="pkg">&quot;bigGP&quot;</span>
execution context, specifically MPI, when R is started via MPI such as
by calling mpirun or analogous executables. They close the slave
processes and then invoke either <code>mpi.exit</code> or <code>mpi.quit</code>.
</p>
<p>If leaving R altogether, one simply uses <code>bigGP.quit</code>. 
</p>


<h3>See Also</h3>

<p><code>mpi.exit</code>
<code>mpi.quit</code>
</p>

<hr>
<h2 id='bigGP.init'>
Initialize bigGP package
</h2><span id='topic+bigGP.init'></span>

<h3>Description</h3>

<p><code>bigGP.init</code> initializes the bigGP and must be called before
using any bigGP functionality. It starts slave processes, if not
already started, and sets up the necessary objects containing
information for distributing calculations correctly. It also
initializes the RNG on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigGP.init(P = NULL, parallelRNGpkg = "rlecuyer", seed = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigGP.init_+3A_p">P</code></td>
<td>

<p>Number of slave processes. Should be equal to D(D+1)/2 for some
integer D. If <code>NULL</code>, will be taken to be
<code>mpi.comm.size()-1</code>, where the additional process is the
master. 
</p>
</td></tr>
<tr><td><code id="bigGP.init_+3A_parallelrngpkg">parallelRNGpkg</code></td>
<td>

<p>Package to be used for random number generation (RNG). At the moment
this should be one of <span class="pkg">relecuyer</span> or <span class="pkg">rsprng</span>, and
these packages must be installed.
</p>
</td></tr>
<tr><td><code id="bigGP.init_+3A_seed">seed</code></td>
<td>

<p>Seed to be used for initializing the parallel RNG.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initialization includes starting the slave processes, calculating
the partition factor, <code class="reqn">D</code>, and providing the slave processes with
unique identifying information. This information is stored in the
<code>.bigGP</code> object on each slave process.
</p>
<p>Note that in general, the number of processes (number of slave
processes, <code>P</code>, plus one for the master) should not exceed the number of
physical cores on the machine(s) available.
</p>
<p><code>bigGP.init</code> also sets up random number generation on the slaves,
using <code>parallelRNGpkg</code> when specified, and setting appropriate
seeds on each slave process. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3, seed = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='calcD'>
Calculate Partition Factor
</h2><span id='topic+calcD'></span>

<h3>Description</h3>

<p><code>calcD</code> is an internal auxiliary function that calculates the
partition factor, <code class="reqn">D</code>, based on the number of slave processes, <code class="reqn">P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcD(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcD_+3A_p">P</code></td>
<td>

<p>a positive integer, the number of slave processes.
</p>
</td></tr>
</table>

<hr>
<h2 id='calcIJ'>
Calculate Slave Process Identifiers
</h2><span id='topic+calcIJ'></span>

<h3>Description</h3>

<p><code>calcIJ</code> is an internal auxiliary function that calculates a
unique pair of identifiers for each slave process, corresponding to
the row and column of the block assigned to the slave process (things
are more complicated when the block replication factor, <code class="reqn">h</code>, is
greater than one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcIJ(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcIJ_+3A_d">D</code></td>
<td>

<p>a positive integer, the partition factor.
</p>
</td></tr>
</table>

<hr>
<h2 id='collectDiagonal'>
Return the Diagonal of a Distributed Square Matrix to the Master Process
</h2><span id='topic+collectDiagonal'></span>

<h3>Description</h3>

<p><code>collectDiagonal</code> retrieves the diagonal elements of a
distributed square matrix from the slave
processes in the proper order. Values can be copied from objects in environments, lists, and
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collectDiagonal(objName, objPos = '.GlobalEnv', n, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collectDiagonal_+3A_objname">objName</code></td>
<td>

<p>an object name, given as a character string, giving the name of the
matrix on the slave processes.
</p>
</td></tr>
<tr><td><code id="collectDiagonal_+3A_objpos">objPos</code></td>
<td>

<p>where to look for the matrix, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="collectDiagonal_+3A_n">n</code></td>
<td>

<p>a positive integer, the number of rows (and columns) of the matrix.
</p>
</td></tr>
<tr><td><code id="collectDiagonal_+3A_h">h</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant for the matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collectDiagonal</code> returns a vector of length <code class="reqn">n</code>.
</p>


<h3>See Also</h3>

<p><code>pull</code>
<code>collectVector</code>
<code>collectTriangularMatrix</code>
<code>collectRectangularMatrix</code>
<code>distributeVector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
nProc &lt;- 3
n &lt;- nrow(SN2011fe_subset)
inputs &lt;- c(as.list(SN2011fe_subset), as.list(SN2011fe_newdata_subset),
  nu =2)
# initialize the problem
prob &lt;- krigeProblem$new("prob", h_n = 1, numProcesses = nProc, n = n,
  meanFunction = SN2011fe_meanfunc, covFunction = SN2011fe_covfunc,
  inputs = inputs, params = SN2011fe_mle$par,
  data = SN2011fe_subset$flux, packages = c("fields"))
# calculate log density, primarily so Cholesky gets calculated
prob$calcLogDens()
diagC &lt;- collectDiagonal('C', "prob", n = n, h = 1)
diagL &lt;- collectDiagonal('L', "prob", n = n, h = 1)
diagC[1:5]
diagL[1:5]
}

## End(Not run)
</code></pre>

<hr>
<h2 id='collectRectangularMatrix'>
Return a Distributed Rectangular Matrix to the Master Process
</h2><span id='topic+collectRectangularMatrix'></span>

<h3>Description</h3>

<p><code>collectRectangularMatrix</code> retrieves a distributed rectangular matrix from the slave
processes, reconstructing the blocks correctly on the master process. 
Objects can be copied from environments, lists, and
ReferenceClass objects as well as the global environment on the slave
processes. WARNING: do not use with a distributed symmetric square matrix; instead
use <code>collectTriangularMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collectRectangularMatrix(objName, objPos = '.GlobalEnv', n1, n2, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collectRectangularMatrix_+3A_objname">objName</code></td>
<td>

<p>an object name, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="collectRectangularMatrix_+3A_objpos">objPos</code></td>
<td>

<p>where to look for the object, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="collectRectangularMatrix_+3A_n1">n1</code></td>
<td>

<p>a positive integer, the number of rows of the matrix.
</p>
</td></tr>
<tr><td><code id="collectRectangularMatrix_+3A_n2">n2</code></td>
<td>

<p>a positive integer, the number of columns of the matrix.
</p>
</td></tr>
<tr><td><code id="collectRectangularMatrix_+3A_h1">h1</code></td>
<td>

<p>a positive integer, the block replication factor relevant for the rows of
the matrix.
</p>
</td></tr>
<tr><td><code id="collectRectangularMatrix_+3A_h2">h2</code></td>
<td>

<p>a positive integer, the block replication factor relevant for the columns of
the matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collectRectangularMatrix</code> returns a matrix of dimension, <code class="reqn">n1
    \times n2</code>.
</p>


<h3>See Also</h3>

<p><code>pull</code>
<code>collectVector</code>
<code>collectTriangularMatrix</code>
<code>collectDiagonal</code>
<code>distributeVector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
nProc &lt;- 3
n &lt;- nrow(SN2011fe_subset)
m &lt;- nrow(SN2011fe_newdata_subset)
inputs &lt;- c(as.list(SN2011fe_subset), as.list(SN2011fe_newdata_subset),
  nu =2)
# initialize the problem
prob &lt;- krigeProblem$new("prob", h_n = 1, h_m = 1, numProcesses =
  nProc, n = n, m = m,
  meanFunction = SN2011fe_meanfunc, predMeanFunction = SN2011fe_predmeanfunc, 
  covFunction = SN2011fe_covfunc, crossCovFunction = SN2011fe_crosscovfunc,
predCovFunction = SN2011fe_predcovfunc, params = SN2011fe_mle$par,
  inputs = inputs, data = SN2011fe_subset$flux, packages = c("fields"))
# do predictions, primarily so cross-covariance gets calculated
pred &lt;- prob$predict(ret = TRUE, verbose = TRUE)

crossC &lt;- collectRectangularMatrix('crossC', "prob", n1 = n, n2 = m,
h1 = 1, h2 = 1)
crossC[1:5, 1:5]
}

## End(Not run)
</code></pre>

<hr>
<h2 id='collectTriangularMatrix'>
Return a Distributed Symmetric or Triangular Matrix to the Master Process
</h2><span id='topic+collectTriangularMatrix'></span>

<h3>Description</h3>

<p><code>collectTriangularMatrix</code> retrieves a distributed symmetric or
triangular matrix from the slave
processes, reconstructing the blocks correctly on the master process. 
Objects can be copied from environments, lists, and
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collectTriangularMatrix(objName, objPos = '.GlobalEnv', n, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collectTriangularMatrix_+3A_objname">objName</code></td>
<td>

<p>an object name, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="collectTriangularMatrix_+3A_objpos">objPos</code></td>
<td>

<p>where to look for the object, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="collectTriangularMatrix_+3A_n">n</code></td>
<td>

<p>a positive integer, the number of rows (and columns) of the matrix.
</p>
</td></tr>
<tr><td><code id="collectTriangularMatrix_+3A_h">h</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant for the matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collectTriangularMatrix</code> returns a matrix of dimension, <code class="reqn">n
    \times n</code>. Note that for lower triangular matrices, the upper
triangle is non-zero and is filled with the transpose of the lower
triangle, and vice versa for upper triangular matrices.
</p>


<h3>See Also</h3>

<p><code>pull</code>
<code>collectVector</code>
<code>collectRectangularMatrix</code>
<code>collectDiagonal</code>
<code>distributeVector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
nProc &lt;- 3
n &lt;- nrow(SN2011fe_subset)
inputs &lt;- c(as.list(SN2011fe_subset), as.list(SN2011fe_newdata_subset),
  nu =2)
# initialize the problem
prob &lt;- krigeProblem$new("prob", h_n = 1, numProcesses = nProc, n = n,
  meanFunction = SN2011fe_meanfunc, covFunction = SN2011fe_covfunc, inputs = inputs,
  params = SN2011fe_mle$par, data = SN2011fe_subset$flux, packages =
  c("fields"))
# calculate log density, primarily so Cholesky gets calculated
prob$calcLogDens()
C &lt;- collectTriangularMatrix('C', "prob", n = n, h = 1)
L &lt;- collectTriangularMatrix('L', "prob", n = n, h = 1)
C[1:5, 1:5]
L[1:5, 1:5]
}

## End(Not run)
</code></pre>

<hr>
<h2 id='collectVector'>
Return a Distributed Vector to the Master Process
</h2><span id='topic+collectVector'></span>

<h3>Description</h3>

<p><code>collectVector</code> retrieves a distributed vector from the slave
processes, reconstructing in the correct order on the master process. 
Objects can be copied from environments, lists, and
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collectVector(objName, objPos = '.GlobalEnv', n, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collectVector_+3A_objname">objName</code></td>
<td>

<p>an object name, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="collectVector_+3A_objpos">objPos</code></td>
<td>

<p>where to look for the object, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="collectVector_+3A_n">n</code></td>
<td>

<p>a positive integer, the length of the vector.
</p>
</td></tr>
<tr><td><code id="collectVector_+3A_h">h</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant for the vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collectVector</code> returns a vector of length, <code class="reqn">n</code>.
</p>


<h3>See Also</h3>

<p><code>pull</code>
<code>collectTriangularMatrix</code>
<code>collectRectangularMatrix</code>
<code>collectDiagonal</code>
<code>distributeVector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
n &lt;- 3000
x &lt;- rnorm(n)
distributeVector(x, 'tmp', n = n)
y &lt;- collectVector('tmp', n = n)
identical(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='distributedKrigeProblem-class'>
ReferenceClass for Distributed Components of the krigeProblem ReferenceClass
</h2><span id='topic+distributedKrigeProblem-class'></span><span id='topic+distributedKrigeProblem'></span>

<h3>Description</h3>

<p><code>distributedKrigeProblem</code> contains the distributed components of
the core vectors and matrices of the krigeProblem class, as well as
copies of the functions for calculating mean vectors and covariance
matrices, parameter values, and information about the pieces of the
distributed objects contained on a given slave process. The only
method associated with the ReferenceClass is a constructor.
</p>


<h3>See Also</h3>

<p><code>krigeProblem</code>
</p>

<hr>
<h2 id='distributeVector'>
Distribute a Vector to the Slave Processes
</h2><span id='topic+distributeVector'></span>

<h3>Description</h3>

<p><code>distributeVector</code> distributes a vector to the slave processes,
breaking into the appropriate pieces, in some cases with padded elements.
Objects can be distributed to environments and
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distributeVector(obj, objName = deparse(substitute(obj)), objPos = '.GlobalEnv', n, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distributeVector_+3A_obj">obj</code></td>
<td>

<p>object on master process to be copied, given either as the name of
an object or as a character.
</p>
</td></tr>
<tr><td><code id="distributeVector_+3A_objname">objName</code></td>
<td>

<p>an object name, given as a character string, giving the name to be
used for the object on the slave processes. If not provided, will be
the same as the name of <code>obj</code> in the calling environment.
</p>
</td></tr>
<tr><td><code id="distributeVector_+3A_objpos">objPos</code></td>
<td>

<p>where to do the assignment, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="distributeVector_+3A_n">n</code></td>
<td>

<p>a positive integer, the length of the vector.
</p>
</td></tr>
<tr><td><code id="distributeVector_+3A_h">h</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, to be used when distributing the vector.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>push</code>
<code>collectVector</code>
<code>collectTriangularMatrix</code>
<code>collectRectangularMatrix</code>
<code>collectDiagonal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
n &lt;- 3000
x &lt;- rnorm(n)
distributeVector(x, 'tmp', n = n)
y &lt;- collectVector('tmp', n = n)
identical(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='getDistributedVectorLength'>
Find Length of Subset of Vector or Matrix Stored on Slave Process
</h2><span id='topic+getDistributedVectorLength'></span><span id='topic+getDistributedTriangularMatrixLength'></span><span id='topic+getDistributedRectangularMatrixLength'></span>

<h3>Description</h3>

<p><code>getDistributedVectorLength</code>,
<code>getDistributedTriangularMatrixLength</code>, and
<code>getDistributedRectangularLength</code> are internal auxiliary
functions that find the length of the vector needed to store the subset
of a vector or matrix contained on a given slave process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistributedVectorLength(n, h = 1)
getDistributedTriangularMatrixLength(n, h = 1)
getDistributedRectangularMatrixLength(n1, n2, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistributedVectorLength_+3A_n">n</code></td>
<td>
<p>length of vector.</p>
</td></tr>
<tr><td><code id="getDistributedVectorLength_+3A_h">h</code></td>
<td>
<p>replication factor.</p>
</td></tr>
<tr><td><code id="getDistributedVectorLength_+3A_n1">n1</code></td>
<td>
<p>number of rows.</p>
</td></tr>
<tr><td><code id="getDistributedVectorLength_+3A_n2">n2</code></td>
<td>
<p>number of columns.</p>
</td></tr>
<tr><td><code id="getDistributedVectorLength_+3A_h1">h1</code></td>
<td>
<p>replication factor for the rows.</p>
</td></tr>
<tr><td><code id="getDistributedVectorLength_+3A_h2">h2</code></td>
<td>
<p>replication factor for the columns.</p>
</td></tr>
</table>

<hr>
<h2 id='krigeProblem-class'>Class <code>"krigeProblem"</code></h2><span id='topic+krigeProblem-class'></span><span id='topic+krigeProblem'></span><span id='topic+calcH+2C+20krigeProblem-method'></span><span id='topic+show+2C+20krigeProblem-method'></span><span id='topic+initializeSlaveProblems+2C+20krigeProblem-method'></span><span id='topic+setParams+2C+20krigeProblem-method'></span><span id='topic+remoteConstructMean+2C+20krigeProblem-method'></span><span id='topic+remoteConstructCov+2C+20krigeProblem-method'></span><span id='topic+calcLogDens+2C+20krigeProblem-method'></span><span id='topic+optimizeLogDens+2C+20krigeProblem-method'></span><span id='topic+predict+2C+20krigeProblem-method'></span><span id='topic+calcPostCov+2C+20krigeProblem-method'></span><span id='topic+simulateRealizations+2C+20krigeProblem-method'></span>

<h3>Description</h3>

<p>The <code>krigeProblem</code> class provides functionality for kriging using
distributed calculations, based on maximum likelihood estimation. The class includes methods for standard kriging calculations and metadata necessary for carrying out the methods in a distributed fashion.
</p>
<p>To carry out kriging calculations, one must first initialize an object
of the <code>krigeProblem</code> class. This is done using
<code>krigeProblem$new</code> and help on initialization can be obtained via
<code>krigeProblem$help('initialize')</code> (but noting that the call is
<code>krigeProblem$new</code> not <code>krigeProblem$initialize</code>).
</p>
<p>Note that in what follows I refer to observation and prediction
'locations'. This is natural for spatial problems, but for non-spatial
problems, 'locations' is meant to refer to the points within the
relevant domain at which observations are available and predictions
wish to be made.
</p>
<p>The user must provide functions that create the subsets of the mean
vector(s) and the covariance matrix/matrices. Functions for the mean
vector and covariance matrix for observation locations are required,
while those
for the mean vector for prediction locations, the cross-covariance
matrix (where the first column is the index of the observation
locations and the second of the prediction locations), and the
prediction covariance matrix for prediction locations are required
when doing prediction and posterior simulation. These functions should
follow the form of <code>SN2011fe_meanfunc</code>,
<code>SN2011fe_predmeanfunc</code>, <code>SN2011fe_covfunc</code>,
<code>SN2011fe_predcovfunc</code>, and <code>SN2011fe_crosscovfunc</code>. Namely,
they should take three arguments, the first a vector of all the
parameters for the Gaussian process (both mean and covariance),
the second an arbitrary list of inputs (in general this would include
the observation and prediction locations), and the third being
indices, which will be provided by the package and will differ between
slave processes. For the
mean functions, the indices will be a vector, indicating which of the
vector elements are stored on a given process. For the covariance
functions, the indices will be a two column matrix, with each row
a pair of indices (row, column), indicating the elements of the matrix
stored on a given process. Thus, the user-provided functions should use the second
and third arguments to construct the elements of the vectors/matrices
belonging on the slave process. Note that the elements of the
matrices are stored as vectors (vectorizing matrices column-wise, as
natural for column-major matrices). Users can simply have their
functions operate on the rows of the index matrix without worrying
about ordering. An optional fourth argument contains cached values that need
not be computed at every call to the user-provided function. If the
user wants to make use of caching of values to avoid expensive
recomputation, the user function should mimic
<code>SN2011fe_covfunc</code>. That is, when the user wishes to change the cached
values (including on first use of the function), the function should return 
a two-element list, with the first element being the covariance matrix
elements and the second containing whatever object is to be
cached. This cached object will be provided to the function on
subsequent calls as the fourth argument. 
</p>
<p>Note that one should have all necessary packages required for
calculation of the mean vector(s) and covariance matrix/matrices installed
on all machines used and the names of these packages should be passed
as the <code>packages</code> argument to the <code>krigeProblem</code> initialization.
</p>
<p>Help for the various methods of the class can be obtained with
<code>krigeProblem$help('methodName')</code> and a list of fields and
methods in the class with <code>krigeProblem$help()</code>.
</p>
<p>In general, <code>n</code> (or <code>n1</code> and <code>n2</code>) refer to the length
or number of rows/columns of vectors and matrices and <code>h</code> (or
<code>h1</code> and <code>h2</code>) to the block replication factor for these
vectors and matrices. More details on block replication factors can be
found in the references in &lsquo;references&rsquo;; these are set at
reasonable values automatically, and for simplicity, one can set them
at one, in which case the number of blocks into which the primary
covariance matrix is split is <code class="reqn">P</code>, the number of slave
processes. Cross-covariance matrices returned to the user will have
number of rows equal
to the number of observation locations and number of columns to the
number of prediction locations. Matrices of realizations will have
each realized field as a single column. 
</p>


<h3>Fields</h3>


<dl>
<dt><code>localProblemName</code>:</dt><dd><p>Object of class <code>"character"</code>
containing the name to be used for the object on the slave processes.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"numeric"</code>
containing the number of observation locations.</p>
</dd>
<dt><code>h_n</code>:</dt><dd><p>Object of class <code>"numeric"</code>
containing the block replication factor for the observation locations,
will be set to a reasonable value by default upon initialization of an
object in the class.</p>
</dd>
<dt><code>h_m</code>:</dt><dd><p>Object of class <code>"numeric"</code>
containing the block replication factor for the prediction locations,
will be set to a reasonable value by default upon initialization of an
object in the class.</p>
</dd>
<dt><code>meanFunction</code>:</dt><dd><p>Object of class <code>"function"</code>
containing the function used to calculate values of the mean function at
the observation locations. See above for detailed information on how
this function should be written.</p>
</dd>
<dt><code>predMeanFunction</code>:</dt><dd><p>Object of class <code>"function"</code>
containing the function used to calculate values of the mean function at
the prediction locations. See above for detailed information on how
this function should be written.</p>
</dd>
<dt><code>covFunction</code>:</dt><dd><p>Object of class <code>"function"</code>
containing the function used to calculate values of the covariance
function for pairs of observation locations. See above for detailed
information on how this function should be written.</p>
</dd>
<dt><code>crossCovFunction</code>:</dt><dd><p>Object of class <code>"function"</code>
containing the function used to calculate values of the covariance
function for pairs of observation and prediction locations. See above
for detailed information on how this function should be written.</p>
</dd>
<dt><code>predCovFunction</code>:</dt><dd><p>Object of class <code>"function"</code>
containing the function used to calculate values of the covariance
function for pairs of prediction locations. See above for detailed
information on how this function should be written.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"ANY"</code>
containing the vector of data values at the observation locations. This
will be numeric, but is specified as of class <code>"ANY"</code> so that can
default to <code>NULL</code>.</p>
</dd>
<dt><code>params</code>:</dt><dd><p>Object of class <code>"ANY"</code>
containing the vector of parameter values. This
will be numeric, but is specified as of class <code>"ANY"</code> so that can
default to <code>NULL</code>. This vector is what will be passed to the mean
and covariance functions.</p>
</dd>
<dt><code>meanCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed mean vector (for the
observation locations) on the slaves is
current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>predMeanCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed mean vector (for the
prediction locations) on the slaves is
current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>postMeanCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed posterior mean vector (for
the prediction locations) on the slaves is
current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>covCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed covariance matrix (for the
observation locations) on the slaves is
current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>crossCovCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed cross-covariance matrix
(between observation and prediction locations) on the slaves is
current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>predCovCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed prediction covariance matrix
on the slaves is current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>postCovCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed posterior covariance matrix
on the slaves is current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>cholCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed Cholesky factor of the
covariance matrix (for observation locations) on the slaves is current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
<dt><code>predCholCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed Cholesky factor of the
covariance matrix (the prior covariance matrix for prediction locations) on the slaves is current (i.e., whether it is based on the current value of
<code>params</code>). Note this is likely only relevant when generating
realizations for prediction locations not conditional on the
observations.</p>
</dd>
<dt><code>postCholCurrent</code>:</dt><dd><p>Object of class <code>"logical"</code>
indicating whether the current distributed Cholesky factor of the
posterior covariance matrix on the slaves is current (i.e., whether it is based on the current value of
<code>params</code>).</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>new(localProblemName = NULL, numProcesses = NULL, h_n =
NULL, h_m = NULL,  n = length(data), m = NULL, meanFunction =
function(){}, predMeanFunction = function(){}, covFunction =
function(){}, crossCovFunction = function(){}, predCovFunction =
function(){}, inputs = NULL, params = NULL, data = NULL, packages =
NULL, parallelRNGpkg = "rlecuyer", seed = 0, ...)</code>:</dt><dd><p> Initializes new
krigeProblem object, which is necessary for distributed kriging calculations.</p>
</dd>
<dt><code>calcH(n)</code>:</dt><dd><p> Internal method that calculates a good
choice of the block replication factor given <code>n</code>.</p>
</dd>
<dt><code>show(verbose = TRUE)</code>:</dt><dd><p> Show (i.e., print) method.</p>
</dd>
<dt><code>initializeSlaveProblems(packages)</code>:</dt><dd><p> Internal method
that sets up the slave
processes to carry out the <code>krigeProblem</code> distributed
calculations.</p>
</dd>
<dt><code>setParams(params, verbose = TRUE)</code>:</dt><dd><p> Sets (or changes) the value of
the parameters.</p>
</dd>
<dt><code>remoteConstructMean(obs = TRUE, pred = !obs, verbose =
FALSE)</code>:</dt><dd><p> Meant for internal use; calculates the value of the specified mean vector (for
observation and/or prediction locations) on the slave processes, using the
appropriate user-provided function.</p>
</dd>
<dt><code>remoteConstructCov(obs = TRUE, pred = FALSE, cross =
FALSE, verbose = FALSE)</code>:</dt><dd><p> Meant for internal use; calculates the value of the specified
covariance matrices on the slave processes, using the
appropriate user-provided function.</p>
</dd>
<dt><code>calcLogDeterminant()</code>:</dt><dd><p> Calculates the log-determinant
of the covariance matrix for the observation locations.</p>
</dd>
<dt><code>calcLogDens(newParams = NULL, newData = NULL, negative =
FALSE, verbose = TRUE)</code>:</dt><dd><p> Calculates the log-density of the data given
the parameters.</p>
</dd>
<dt><code>optimizeLogDens(newParams = NULL, newData = NULL, method
= "Nelder-Mead", verbose = FALSE, gr = NULL, lower = -Inf, upper = Inf,
control = list(), hessian = FALSE, ...)</code>:</dt><dd><p> Finds the maximum likelihood
estimate of the parameters given the data, using <code>optim</code>.</p>
</dd>
<dt><code>predict(ret = FALSE, verbose = FALSE)</code>:</dt><dd><p> Calculates
kriging predictions (i.e., the posterior mean for the prediction locations).</p>
</dd>
<dt><code>calcPostCov(returnDiag = TRUE, verbose = FALSE)</code>:</dt><dd>
<p>Calculates the prediction covariance (i.e., the posterior covariance
matrix for the prediction locations), returning the diagonal (the
variances) if requested.</p>
</dd> 
<dt><code>simulateRealizations(r = 1, h_r = NULL, obs = FALSE, pred
= FALSE, post = TRUE, verbose = FALSE)</code>:</dt><dd><p> Simulates realizations, which
would generally be from the posterior distribution (i.e., conditional on
the data), but could also be from the prior distribution (i.e., not
conditional on the data) at either observation or predition locations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek and Benjamin Lipshitz, in collaboration with Tina
Zhuo, Cari Kaufman, Rollin Thomas, and Prabhat.
</p>
<p>Maintainer: Christopher Paciorek &lt;paciorek@alumni.cmu.edu&gt;
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+bigGP">bigGP</a></code> for general information on the package and
<code><a href="#topic+bigGP.init">bigGP.init</a></code> for the necessary initialization steps
required before using the package, including the <code>krigeProblem</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
doSmallExample &lt;- TRUE

if(require(fields)) {

if(doSmallExample){
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
} else {
# users should select number of processors based on their system and the
# size of the full example
nProc &lt;- 210 
}


n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)

prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
 predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction = SN2011fe_crosscovfunc, 
predCovFunction = SN2011fe_predcovfunc, meanFunction = SN2011fe_meanfunc, 
covFunction = SN2011fe_covfunc,  inputs = inputs, params = SN2011fe_mle$par, 
data = SN2011fe$flux, packages = c("fields"))

prob$calcLogDens()

prob$optimizeLogDens(method = "L-BFGS-B", verbose = TRUE,
lower = rep(.Machine$double.eps, length(SN2011fe_initialParams)),
control = list(parscale = SN2011fe_initialParams, maxit = 2))
# the full optimization can take some time; only two iterations are done 
# are specified here; even this is not run as it takes 10s of seconds

prob$setParams(SN2011fe_mle$par)

pred &lt;- prob$predict(ret = TRUE, se.fit = TRUE, verbose = TRUE)
realiz &lt;- prob$simulateRealizations(r = 10, post = TRUE, verbose = TRUE)

show(prob)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='localAssign'>
Assign a New Name to an Object on Slave Process
</h2><span id='topic+localAssign'></span>

<h3>Description</h3>

<p><code>localAssign</code> is an internal auxiliary function used
to assign a new name to an object in an environment on a slave
process. The function needs to be executed on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localAssign(nameToAssign, currentName, objPos = ".GlobalEnv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localAssign_+3A_nametoassign">nameToAssign</code></td>
<td>

<p>a variable name, given as a character string, giving the new name
for the object.
</p>
</td></tr>
<tr><td><code id="localAssign_+3A_currentname">currentName</code></td>
<td>

<p>a variable name, given as a character string, giving the current
name for the object.
</p>
</td></tr>
<tr><td><code id="localAssign_+3A_objpos">objPos</code></td>
<td>

<p>where to do the assignment, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a
ReferenceClass object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily for internal use, but might be useful for
developers extending the package for use cases other than the
kriging use case contained in <code>krigeProblem</code> ReferenceClass.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
mpi.bcast.cmd(e &lt;- new.env())
mpi.bcast.cmd(a &lt;- 7)
mpi.remote.exec(localAssign, "x", "a", objPos = "e")
mpi.remote.exec(e$x, ret = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='localCalc'>
Local Calculation Functions
</h2><span id='topic+localCalc'></span><span id='topic+localForwardsolve'></span><span id='topic+localBacksolve'></span><span id='topic+localCalcChol'></span><span id='topic+localMultChol'></span><span id='topic+localCrossProdMatVec'></span><span id='topic+localCrossProdMatSelf'></span><span id='topic+localCrossProdMatSelfDiag'></span><span id='topic+localConstructRnormMatrix'></span>

<h3>Description</h3>

<p>These internal functions carry out the calculations of their respective remote
counterpart functions, e.g., <code>remoteCalc</code>, on the slave
process. The functions need to be executed on the slave processes.
</p>

<hr>
<h2 id='localCollectVector'>
Local Distribution and Collection Functions
</h2><span id='topic+localCollectVector'></span><span id='topic+localCollectVectorTest'></span><span id='topic+localDistributeVector'></span><span id='topic+localDistributeVectorTest'></span><span id='topic+localPull'></span><span id='topic+localPullTest'></span><span id='topic+localCollectDiagonal'></span><span id='topic+localCollectDiagonalTest'></span><span id='topic+localCollectTriangularMatrix'></span><span id='topic+localCollectTriangularMatrixTest'></span><span id='topic+localCollectRectangularMatrix'></span><span id='topic+localCollectRectangularMatrixTest'></span>

<h3>Description</h3>

<p>These internal functions carry out the tasks of their respective
primary functions, e.g., <code>collectVector</code>, on the slave
process. The functions need to be executed on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localCollectVector(objName, objPos, n, h)
localCollectVectorTest(objName, objPos, n, h)
localDistributeVector(objName, objPos, n, h)
localDistributeVectorTest(objName, objPos, n, h)
localPull(objName, objPos, tag = 1)
localCollectDiagonal(objName, objPos, n, h)
localCollectDiagonalTest(objName, objPos, n, h)
localCollectTriangularMatrix(objName, objPos, n, h)
localCollectTriangularMatrixTest(objName, objPos, n, h)
localCollectRectangularMatrix(objName, objPos, n1, n2, h1, h2)
localCollectRectangularMatrixTest(objName, objPos, n1, n2, h1, h2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localCollectVector_+3A_objname">objName</code></td>
<td>
<p>name of object as a character string.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_objpos">objPos</code></td>
<td>
<p> where to look for the object, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. </p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_n">n</code></td>
<td>
<p>length of vector.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_h">h</code></td>
<td>
<p>replication factor.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_tag">tag</code></td>
<td>
<p>MPI tag.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_n1">n1</code></td>
<td>
<p>number of rows.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_n2">n2</code></td>
<td>
<p>number of columns.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_h1">h1</code></td>
<td>
<p>replication factor for the rows.</p>
</td></tr>
<tr><td><code id="localCollectVector_+3A_h2">h2</code></td>
<td>
<p>replication factor for the columns.</p>
</td></tr>
</table>

<hr>
<h2 id='localGetVectorIndices'>
Get Indices of Vector or Matrix Elements Stored on Slave Process
</h2><span id='topic+localGetVectorIndices'></span><span id='topic+localGetTriangularMatrixIndices'></span><span id='topic+localGetRectangularMatrixIndices'></span>

<h3>Description</h3>

<p><code>localGetVectorIndices</code>, <code>localGetTriangularMatrixIndices</code>,
and <code>localGetRectangularMatrixIndices</code> are internal auxiliary
functions that determine the indices of the elements of a vector or
matrix that are stored on a slave process. These are primarily meant
for internal use, but can also be used in the process of creating
distributed vectors and matrices on the slave processes. The functions
need to be executed on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localGetVectorIndices(n, h = 1)
localGetTriangularMatrixIndices(n, h = 1)
localGetRectangularMatrixIndices(n1, n2, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localGetVectorIndices_+3A_n">n</code></td>
<td>

<p>a positive integer, giving the length of the vector or number of
rows and columns of the triangular/square matrix.
</p>
</td></tr>
<tr><td><code id="localGetVectorIndices_+3A_n1">n1</code></td>
<td>

<p>a positive integer, giving the  number of
rows of the rectangular matrix.
</p>
</td></tr>
<tr><td><code id="localGetVectorIndices_+3A_n2">n2</code></td>
<td>

<p>a positive integer, giving the  number of
columns of the rectangular matrix.
</p>
</td></tr>
<tr><td><code id="localGetVectorIndices_+3A_h">h</code></td>
<td>

<p>a positive integer, giving the block replication factor for the
vector or triangular/square matrix.
</p>
</td></tr>
<tr><td><code id="localGetVectorIndices_+3A_h1">h1</code></td>
<td>

<p>a positive integer, giving the block replication factor for the
rows of the rectangular matrix.
</p>
</td></tr>
<tr><td><code id="localGetVectorIndices_+3A_h2">h2</code></td>
<td>

<p>a positive integer, giving the block replication factor for the
columns of the rectangular matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>localGetVectorIndices</code> returns the indices (as a one-column matrix) of the
subset of a distributed vector that will be stored on the process on
which the function is called. <code>localGetTriangularMatrixIndices</code>,
and <code>localGetRectangularMatrixIndices</code> return a two-column
matrix with the indices for the subset of the distributed matrix that
will be stored (as a vector) on the process on which the function is called. I.e.,
the ith row of the matrix gives the (row, column) position in the full
matrix for the ith element of the vector on the local process that
contains a subset of that matrix.
</p>
<p>Warning: in some cases there is a small amount of buffering involved
in the distributed objects so that the blocks on each process are of
the same size. In this case, the index of the first element will
generally be added one or more times to the end of the indices assigned to the last process.
</p>

<hr>
<h2 id='localKrigeProblemConstructMean'>
Calculate Mean Vector or Covariance Matrix on Slave Process
</h2><span id='topic+localKrigeProblemConstructMean'></span><span id='topic+localKrigeProblemConstructCov'></span>

<h3>Description</h3>

<p><code>localKrigeProblemConstructMean</code> and
<code>localKrigeProblemConstructCov</code> are internal wrapper functions
for calculating a mean vector or covariance matrix on the slave
processes. They are called by member functions of the <code>krigeProblem</code> ReferenceClass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localKrigeProblemConstructMean(problemName, obs, pred)
localKrigeProblemConstructCov(problemName, obs, pred, cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localKrigeProblemConstructMean_+3A_problemname">problemName</code></td>
<td>
<p>name of the problem as a character string.</p>
</td></tr>
<tr><td><code id="localKrigeProblemConstructMean_+3A_obs">obs</code></td>
<td>
<p>logical, whether to compute the mean or covariance for the
observation locations.</p>
</td></tr>
<tr><td><code id="localKrigeProblemConstructMean_+3A_pred">pred</code></td>
<td>
<p>logical, whether to compute the mean or covariance for the
prediction locations.</p>
</td></tr>
<tr><td><code id="localKrigeProblemConstructMean_+3A_cross">cross</code></td>
<td>
<p>logical, whether to compute the cross-covariance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>krigeProblem</code>
</p>

<hr>
<h2 id='localRm'>
Remove Objects on Slave Process
</h2><span id='topic+localRm'></span>

<h3>Description</h3>

<p><code>localRm</code> is an internal auxiliary function used by
<code>remoteRm</code> to remove objects on a slave process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localRm(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localRm_+3A_list">list</code></td>
<td>
<p>a character vector naming objects to be removed.</p>
</td></tr>
</table>

<hr>
<h2 id='pull'>
Copy Object from Slave Processes to Master
</h2><span id='topic+pull'></span>

<h3>Description</h3>

<p>Copies all objects with a given name from the slave processes to the
master process, returning a list with one element per slave
process. Objects can be copied from lists, environments, and
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull(objName, objPos = ".GlobalEnv", tag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_+3A_objname">objName</code></td>
<td>

<p>a variable name, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="pull_+3A_objpos">objPos</code></td>
<td>

<p>where to look for the object, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="pull_+3A_tag">tag</code></td>
<td>

<p>non-negative integer, as in <code>mpi.send</code> and <code>mpi.recv</code>. Use <code>mpi.any.tag</code> for any tag flag.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pull</code> returns a list, with one element per slave process.
</p>


<h3>Warning</h3>

<p>Vectors and matrices that are part of the distributed linear algebra
computations are broken up in very specific ways on the slave processes
and often include padded elements. In general one should not use
<code>pull</code> for retrieving such objects from the slave
processes. Rather, use <code>collectVector</code>, <code>CollectTriangularMatrix</code>, etc.
</p>


<h3>See Also</h3>

<p><code>push</code>
<code>collectVector</code>
<code>collectTriangularMatrix</code>
<code>collectRectangularMatrix</code>
<code>collectDiagonal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
a &lt;- 3
push(a)
remoteLs()
pull('a')

## End(Not run)
</code></pre>

<hr>
<h2 id='push'>
Copy Object from Master to Slave Processes
</h2><span id='topic+push'></span>

<h3>Description</h3>

<p>Copies an objects from the master process to all slave processes. Objects can be copied to environments and
ReferenceClass objects as well as the global environment on the slaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>push(.tmp, objName = deparse(substitute(.tmp)), objPos = ".GlobalEnv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="push_+3A_.tmp">.tmp</code></td>
<td>

<p>object on master process to be copied, given either as the name of
an object or as a character.
</p>
</td></tr>
<tr><td><code id="push_+3A_objname">objName</code></td>
<td>

<p>the name to use for the object on the slave processes.
</p>
</td></tr>
<tr><td><code id="push_+3A_objpos">objPos</code></td>
<td>

<p>where to do the assignment, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Vectors that are part of the distributed linear algebra
computations are broken up in very specific ways on the slave processes
and often include padded elements. In general one should not use
<code>push</code> to distribute such objects as <code>push</code> would distribute
the entire vector to each slave process. Rather, use <code>distributeVector</code>.
</p>


<h3>See Also</h3>

<p><code>pull</code>
<code>distributeVector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
a &lt;- 3
push(a)
remoteLs()

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteCalc'>
Do Arbitrary Calculations on One or Two Inputs
</h2><span id='topic+remoteCalc'></span>

<h3>Description</h3>

<p><code>remoteCalc</code> applies a function to either one or two input
objects on the slave processes. Input objects can be obtained environments, lists, and
ReferenceClass objects as well as the global environment on the slave
processes. The output object can be assigned into a environment or a ReferenceClass objects as well as the global environment on the slave
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteCalc(input1Name, input2Name = NULL, FUN, outputName, input1Pos = '.GlobalEnv',
input2Pos = '.GlobalEnv', outputPos = '.GlobalEnv')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteCalc_+3A_input1name">input1Name</code></td>
<td>

<p>an object name, given as a character string, giving the name of the
first input on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCalc_+3A_input2name">input2Name</code></td>
<td>

<p>an object name, given as a character string, giving the name of the
first input on the slave processes. This is optional so that one can
carry out a calculation on a single input.
</p>
</td></tr>
<tr><td><code id="remoteCalc_+3A_fun">FUN</code></td>
<td>

<p>the function to be applied, see &lsquo;details&rsquo;.  In the case of operators like <code>+</code>,  the function name
must be backquoted.
</p>
</td></tr>
<tr><td><code id="remoteCalc_+3A_outputname">outputName</code></td>
<td>

<p>an object name, given as a character string, giving the name to be
used for the result of the function call.
</p>
</td></tr>
<tr><td><code id="remoteCalc_+3A_input1pos">input1Pos</code></td>
<td>

<p>where to look for the first input, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCalc_+3A_input2pos">input2Pos</code></td>
<td>

<p>where to look for the second input, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCalc_+3A_outputpos">outputPos</code></td>
<td>

<p>where to do the assignment of the output, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> is found by a call to <code>match.fun</code> and typically is either a
function or a symbol (e.g., a backquoted name) or a character
string specifying a function to be searched for from the
environment of the call to <code>remoteCalc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
mpi.bcast.cmd(x &lt;- 0:mpi.comm.rank())
remoteCalc('x', FUN = exp, outputName = 'exp.x')
remoteLs()
pull('exp.x')
remoteCalc('x', 'exp.x', FUN = `+`, outputName = 'silly')
pull('silly')

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteCalcChol'>
Calculate Distributed Cholesky Decomposition
</h2><span id='topic+remoteCalcChol'></span>

<h3>Description</h3>

<p><code>remoteCalcChol</code> calculates a distributed Cholesky decomposition
from a distributed positive definite matrix. The Cholesky factor and
the original matrix can both be contained within environments and 
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteCalcChol(matName, cholName, matPos = '.GlobalEnv', cholPos = '.GlobalEnv', n, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteCalcChol_+3A_matname">matName</code></td>
<td>

<p>name of the input (positive definite) matrix, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCalcChol_+3A_cholname">cholName</code></td>
<td>

<p>an name, given as a character string, giving the name to be
used for the Cholesky factor matrix on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCalcChol_+3A_matpos">matPos</code></td>
<td>

<p>where to look for the input matrix, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCalcChol_+3A_cholpos">cholPos</code></td>
<td>

<p>where to do the assignment of the Cholesky factor matrix, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCalcChol_+3A_n">n</code></td>
<td>

<p>a positive integer, the number of rows and columns of the input matrix.
</p>
</td></tr>
<tr><td><code id="remoteCalcChol_+3A_h">h</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the input matrix and used for the Cholesky factor as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distributed Cholesky decomposition using a blocked
algorithm similar to that in ScaLapack. When <code class="reqn">h</code> is 1, the number
of blocks, representing the
lower triangle of the original matrix and of the Cholesky factor, is
equal to the number of processes. For larger values of <code class="reqn">h</code>, there
are multiple blocks assigned to each process. 
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bigGP">bigGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)
prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction = SN2011fe_crosscovfunc,
predCovFunction = SN2011fe_predcovfunc, meanFunction = SN2011fe_meanfunc,
 covFunction = SN2011fe_covfunc,  inputs = inputs, params = SN2011fe_mle$par,
data = SN2011fe$flux, packages = c("fields"))
remoteCalcChol(matName = 'C', cholName = 'L', matPos = 'prob',
  cholPos = 'prob', n = n, h = prob$h_n)
L &lt;- collectTriangularMatrix('L', objPos = 'prob', n = n, h = prob$h_n)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteConstructRnormVector'>
Create Distributed Vector or Matrix of Random Normals
</h2><span id='topic+remoteConstructRnormVector'></span><span id='topic+remoteConstructRnormMatrix'></span>

<h3>Description</h3>

<p><code>remoteConstructRnormVector</code> constructs a distributed vector of
standard normal random variables, while
<code>remoteConstructRnormMatrix</code> constructs a distributed matrix. The output object can both be contained within environments or
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteConstructRnormVector(objName, objPos = ".GlobalEnv", n, h = 1)
 remoteConstructRnormMatrix(objName, objPos = ".GlobalEnv", n1, n2, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteConstructRnormVector_+3A_objname">objName</code></td>
<td>

<p>the name to use for the vector or matrix, on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_objpos">objPos</code></td>
<td>

<p>where to do the assignment of the output matrix or vector, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_n">n</code></td>
<td>

<p>a positive integer, the length of the vector
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_h">h</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the vector
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_n1">n1</code></td>
<td>

<p>a positive integer, the number of rows of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_n2">n2</code></td>
<td>

<p>a positive integer, the number of columns of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_h1">h1</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the rows of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteConstructRnormVector_+3A_h2">h2</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the columns of the matrix.
</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Note that a vector and a one-column matrix are stored differently,
with padded columns included for the matrix. For
other distributed computation functions, providing the argument <code>n2 = NULL</code>
indicates the input is a vector, while <code>n2 = 1</code> indicates a
one-column matrix. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bigGP">bigGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)
prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction = SN2011fe_crosscovfunc,  
predCovFunction = SN2011fe_predcovfunc, meanFunction = SN2011fe_meanfunc, 
covFunction = SN2011fe_covfunc,  inputs = inputs, params = SN2011fe_mle$par, 
data = SN2011fe$flux, packages = c("fields"))
remoteCalcChol(matName = 'C', cholName = 'L', matPos = 'prob',
  cholPos = 'prob', n = n, h = prob$h_n)
remoteConstructRnormVector('z', n = n, h = prob$h_n)
remoteMultChol(cholName = 'L', inputName = 'z', outputName = 'result',
cholPos = 'prob', n1 = n, h1 = prob$h_n)
realiz &lt;- collectVector('result', n = n, h = prob$h_n)

r = 10
remoteConstructRnormMatrix('z2', n1 = n, n2 = r, h1 = prob$h_n, h2 = 1)
remoteMultChol(cholName = 'L', inputName = 'z2', outputName = 'result2',
cholPos = 'prob', n1 = n, n2 = r, h1 = prob$h_n, h2 = 1)
realiz2 &lt;- collectRectangularMatrix('result2', n1 = prob$n, n2 = r, h1
= prob$h_n, h2 = 1)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteCrossProdMatSelf'>
Distributed Crossproduct of a Rectangular Matrix with Itself
</h2><span id='topic+remoteCrossProdMatSelf'></span><span id='topic+remoteCrossProdMatSelfDiag'></span>

<h3>Description</h3>

<p><code>remoteCrossProdMatSelf</code> multiplies the transpose of a
distributed rectangular matrix by
itself. <code>remoteCrossProdMatSelfDiag</code> calculates only the diagonal of
the crossproduct. The objects can both be contained within environments or
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteCrossProdMatSelf(inputName, outputName, inputPos = '.GlobalEnv',
outputPos = '.GlobalEnv', n1, n2, h1 = 1, h2 = 1)
remoteCrossProdMatSelfDiag(inputName, outputName, inputPos =
'.GlobalEnv', outputPos = '.GlobalEnv', n1, n2, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteCrossProdMatSelf_+3A_inputname">inputName</code></td>
<td>

<p>name of the matrix, given as a character string, giving
the name of the object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_outputname">outputName</code></td>
<td>

<p>the name to use for resulting matrix, on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_inputpos">inputPos</code></td>
<td>

<p>where to look for the matrix, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_outputpos">outputPos</code></td>
<td>

<p>where to do the assignment of the output matrix, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_n1">n1</code></td>
<td>

<p>a positive integer, the number of rows of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_n2">n2</code></td>
<td>

<p>a positive integer, the number of columns of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_h1">h1</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the rows of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatSelf_+3A_h2">h2</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the columns of the matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distributed product, <code class="reqn">X^T X</code> using a blocked algorithm, resulting in a distributed matrix.
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bigGP">bigGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)
prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction =
SN2011fe_crosscovfunc,  predCovFunction = SN2011fe_predcovfunc,
meanFunction = SN2011fe_meanfunc, covFunction = SN2011fe_covfunc,
inputs = inputs, params = SN2011fe_mle$par, data = SN2011fe$flux,
packages = c("fields"))

remoteCalcChol(matName = "C", cholName = "L", matPos = "prob",
  cholPos = "prob", n = n, h = prob$h_n)
prob$remoteConstructCov(obs = FALSE, pred = FALSE, cross = TRUE, verbose = TRUE)
# we now have a rectangular cross-covariance matrix named 'crossC'
remoteForwardsolve(cholName = "L", inputName = "crossC", outputName = "tmp1", 
cholPos = "prob", inputPos = "prob", n1 = n, n2 = m, h1 = prob$h_n, h2 = prob$h_m)

remoteCrossProdMatSelf(inputName = "tmp1", outputName = "result", n1 = n,
n2 = m, h1 = prob$h_n, h2 = prob$h_m)
result &lt;- collectTriangularMatrix("result", n = m, h = prob$h_m)

remoteCrossProdMatSelfDiag(inputName = "tmp1", outputName = "resultDiag",
n1 = n, n2 = m, h1 = prob$h_n, h2 = prob$h_m)
resultDiag &lt;- collectVector("resultDiag", n = m, h = prob$h_m)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteCrossProdMatVec'>
Distributed Crossproduct of a Rectangular Matrix and a Vector
</h2><span id='topic+remoteCrossProdMatVec'></span>

<h3>Description</h3>

<p><code>remoteCrossProdMatVec</code> multiplies the transpose of a distributed rectangular matrix
by a distributed vector or matrix. The objects can both be contained within environments or
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteCrossProdMatVec(matName, inputName, outputName, matPos = '.GlobalEnv',
inputPos = '.GlobalEnv', outputPos = '.GlobalEnv', n1, n2, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteCrossProdMatVec_+3A_matname">matName</code></td>
<td>

<p>name of the rectangular matrix, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_inputname">inputName</code></td>
<td>

<p>name of the vector being multiplied by, given as a character string, giving
the name of the object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_outputname">outputName</code></td>
<td>

<p>the name to use for resulting vector, on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_matpos">matPos</code></td>
<td>

<p>where to look for the rectangular matrix, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_inputpos">inputPos</code></td>
<td>

<p>where to look for the input vector, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_outputpos">outputPos</code></td>
<td>

<p>where to do the assignment of the output vector, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_n1">n1</code></td>
<td>

<p>a positive integer, the number of rows of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_n2">n2</code></td>
<td>

<p>a positive integer, the number of columns of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_h1">h1</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the rows of the matrix.
</p>
</td></tr>
<tr><td><code id="remoteCrossProdMatVec_+3A_h2">h2</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the columns of the matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distributed product using a blocked algorithm, resulting
in a distributed vector.
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bigGP">bigGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)
prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction =
SN2011fe_crosscovfunc,  predCovFunction = SN2011fe_predcovfunc,
meanFunction = SN2011fe_meanfunc, covFunction = SN2011fe_covfunc,
inputs = inputs, params = SN2011fe_mle$par, data = SN2011fe$flux,
packages = c("fields"))

remoteCalcChol(matName = "C", cholName = "L", matPos = "prob",
  cholPos = "prob", n = n, h = prob$h_n)
remoteCalc("data", "mean", `-`, "tmp1", input1Pos = "prob", input2Pos = "prob")
remoteForwardsolve(cholName = "L", inputName = "tmp1", outputName = "tmp2", 
cholPos = "prob", n1 = n, h1 = prob$h_n)
remoteBacksolve(cholName = "L", inputName = "tmp2", outputName = "tmp3",
 cholPos = "prob", n1 = n, h1 = prob$h_n)
prob$remoteConstructCov(obs = FALSE, pred = FALSE, cross = TRUE, verbose = TRUE)
# we now have a rectangular cross-covariance matrix named 'crossC'
remoteCrossProdMatVec(matName = "crossC", inputName = "tmp3", outputName = "result", 
matPos = "prob", n1 = n, n2 = m, h1 = prob$h_n, h2 = prob$h_m)
 
result &lt;- collectVector("result", n = n, h = prob$h_n)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteForwardsolve'>
Solve a Distributed Triangular System
</h2><span id='topic+remoteForwardsolve'></span><span id='topic+remoteBacksolve'></span>

<h3>Description</h3>

<p>Solves a distributed system of linear equations where the coefficient
matrix is lower triangular. <code>remoteBacksolve</code> solves
<code class="reqn">L^{\top} X = C</code> for vector or matrix <code class="reqn">X</code>, while <code>remoteForwardsolve</code> solves
<code class="reqn">L X = C</code>. Any of the matrices or vectors can  be contained within environments and 
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteBacksolve(cholName, inputName, outputName, cholPos = '.GlobalEnv',
 inputPos = '.GlobalEnv', outputPos = '.GlobalEnv', n1, n2 = NULL, h1 = 1,
h2 = NULL)
remoteForwardsolve(cholName, inputName, outputName, cholPos =
'.GlobalEnv', inputPos = '.GlobalEnv', outputPos = '.GlobalEnv', n1, n2
= NULL, h1 = 1, h2 = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteForwardsolve_+3A_cholname">cholName</code></td>
<td>

<p>name of the input lower triangular matrix matrix (the matrix of coefficients), given as a character string, of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_inputname">inputName</code></td>
<td>

<p>name of the vector
or matrix being solved into (the right-hand side(s) of the
equations), given as a character string,  of the object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_outputname">outputName</code></td>
<td>

<p>the name to use for the output object, the solution vector or matrix, on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_cholpos">cholPos</code></td>
<td>

<p>where to look for the lower triangular  matrix, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_inputpos">inputPos</code></td>
<td>

<p>where to look for the input right-hand side matrix or vector, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_outputpos">outputPos</code></td>
<td>

<p>where to do the assignment of the output matrix or vector, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_n1">n1</code></td>
<td>

<p>a positive integer, the number of rows and columns of the input matrix.
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_n2">n2</code></td>
<td>

<p>a positive integer, the number of columns of the right-hand side
values. When equal to one, indicates a single right-hand side vector.
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_h1">h1</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the input matrix and used for the solution (either for a vector,
or the rows of the solution for a matrix).
</p>
</td></tr>
<tr><td><code id="remoteForwardsolve_+3A_h2">h2</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the columns of the solution when the right-hand side is a matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the solution to a distributed set of linear equations, with
either a single or multiple right-hand side(s) (i.e., solving into a
vector or a matrix). Note that these functions work for any
distributed lower triangular matrix, but <code>bigGP</code> currently only
provides functionality for computing distributed Cholesky factors,
hence the argument names <code>cholName</code> and <code>cholPos</code>.
</p>
<p>When the right-hand side is vector that is stored as a vector, such as
created by <code>distributeVector</code> or
<code>remoteConstructRnormVector</code>, use <code>n2 = NULL</code>. When
multiplying by a one-column matrix, use <code>n2 = 1</code>.
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bigGP">bigGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)
prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction = SN2011fe_crosscovfunc,  
predCovFunction = SN2011fe_predcovfunc, meanFunction = SN2011fe_meanfunc, 
covFunction = SN2011fe_covfunc,  inputs = inputs, params = SN2011fe_mle$par, 
data = SN2011fe$flux, packages = c("fields"))
remoteCalcChol(matName = "C", cholName = "L", matPos = "prob",
  cholPos = "prob", n = n, h = prob$h_n)
remoteForwardsolve(cholName = "L", inputName = "data", outputName =
"tmp", cholPos = "prob", inputPos = "prob", n1 = n, h1 = prob$h_n)
LinvY &lt;- collectVector("tmp", n = n, h = prob$h_n)
remoteBacksolve(cholName = "L", inputName = "tmp", outputName =
"tmp2", cholPos = "prob", inputPos = "prob", n1 = n, h1 = prob$h_n)
CinvY &lt;- collectVector("tmp2", n = n, h = prob$h_n)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteGetIndices'>
Determine Indices of Vector or Matrix Elements Stored on all Processes
</h2><span id='topic+remoteGetIndices'></span>

<h3>Description</h3>

<p><code>remoteGetIndices</code> determines the indices of the subset of a
matrix or vector that are stored on each process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteGetIndices(type = "vector", objName, objPos = ".GlobalEnv", n1,
 n2 = NULL, h1 = 1, h2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteGetIndices_+3A_type">type</code></td>
<td>

<p>a string, one of 'vector', 'symmetric', 'triangular', or 'rectangular'
giving the type of object for which one wants the indices. Note that
square and symmetric matrices are both stored as lower triangles, so
these options both return the same result. For square, non-symmetric
matrices, use 'rectangular'.
</p>
</td></tr>
<tr><td><code id="remoteGetIndices_+3A_objname">objName</code></td>
<td>

<p>the name to use for the object containing the indices on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteGetIndices_+3A_objpos">objPos</code></td>
<td>

<p>where to do the assignment of the object, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass
object.
</p>
</td></tr>
<tr><td><code id="remoteGetIndices_+3A_n1">n1</code></td>
<td>

<p>a positive integer, giving the length of the vector, number of rows
and columns of a symmetric or triangular matrix and number of rows of
a rectangular matrix, including square, non-symmetric matrices.
</p>
</td></tr>
<tr><td><code id="remoteGetIndices_+3A_n2">n2</code></td>
<td>

<p>a positive integer, giving the number of columns of a 
a rectangular matrix.
</p>
</td></tr>
<tr><td><code id="remoteGetIndices_+3A_h1">h1</code></td>
<td>

<p>a positive integer, giving the block replication factor for a
vector, a symmetric or triangular matrix, or the rows of
a rectangular matrix.
</p>
</td></tr>
<tr><td><code id="remoteGetIndices_+3A_h2">h2</code></td>
<td>

<p>a positive integer, giving the block replication factor for the
columns of the rectangular matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>remoteGetIndices</code> calculates the indices as described in
<code><a href="#topic+localGetVectorIndices">localGetVectorIndices</a></code>,
<code><a href="#topic+localGetTriangularMatrixIndices">localGetTriangularMatrixIndices</a></code>, and
<code><a href="#topic+localGetRectangularMatrixIndices">localGetRectangularMatrixIndices</a></code>, and writes them to an
object named <code>objName</code>.
</p>

<hr>
<h2 id='remoteLs'>Remote List Objects</h2><span id='topic+remoteLs'></span>

<h3>Description</h3>

<p><code>remoteLs</code> returns the names of the objects in the global environment
on each slave process, as a list of character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteLs(all.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteLs_+3A_all.names">all.names</code></td>
<td>

<p>a logical value.  If 'TRUE', all object names are returned.
If 'FALSE', names which begin with a '.' are omitted.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with each element a vector of character strings giving the
names of the objects on a given slave process.
</p>


<h3>See Also</h3>

<p><code>remoteRm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
a &lt;- 3
b &lt;- 7
push(a); push(b)
remoteLs()
remoteRm(a)
remoteLs()

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteMultChol'>
Distributed Multiplication of Lower Triangular Matrix and a Vector or Matrix
</h2><span id='topic+remoteMultChol'></span>

<h3>Description</h3>

<p><code>remoteMultChol</code> multiplies a distributed lower triangular matrix
by a distributed vector or matrix. The objects can both be contained within environments or
ReferenceClass objects as well as the global environment on the slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteMultChol(cholName, inputName, outputName, cholPos = '.GlobalEnv',
inputPos = '.GlobalEnv', outputPos = '.GlobalEnv', n1, n2 = NULL, h1 = 1,
h2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteMultChol_+3A_cholname">cholName</code></td>
<td>

<p>name of the lower triangular matrix, given as a character string, giving the name of the
object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_inputname">inputName</code></td>
<td>

<p>name of the vector
or matrix being multiplied by, given as a character string, giving
the name of the object on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_outputname">outputName</code></td>
<td>

<p>the name to use for resulting vector or matrix product, on the slave processes.
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_cholpos">cholPos</code></td>
<td>

<p>where to look for the lower triangular  matrix, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_inputpos">inputPos</code></td>
<td>

<p>where to look for the input matrix or vector, given as a character string (unlike
<code>get</code>). This can indicate an environment, a list, or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_outputpos">outputPos</code></td>
<td>

<p>where to do the assignment of the output matrix or vector, given as a character string (unlike
<code>assign</code>). This can indicate an environment or a ReferenceClass object. 
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_n1">n1</code></td>
<td>

<p>a positive integer, the number of rows and columns of the lower triangular matrix.
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_n2">n2</code></td>
<td>

<p>a positive integer, the number of columns of the vector or matrix
being multiplied by. When equal to one, indicates multiplication by a vector.
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_h1">h1</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the input matrix and used for the solution (either for a vector,
or the rows of the solution for a matrix).
</p>
</td></tr>
<tr><td><code id="remoteMultChol_+3A_h2">h2</code></td>
<td>

<p>a positive integer, the block replication factor, <code class="reqn">h</code>, relevant
for the columns of the input and output matrices when the lower
triangular matrix is multiplied by a matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distributed product using a blocked algorithm. 
Note that the function works for any
distributed lower triangular matrix, but <code>bigGP</code> currently only
provides functionality for computing distributed Cholesky factors,
hence the argument names <code>cholName</code> and <code>cholPos</code>.
</p>
<p>When multiplying by a vector that is stored as a vector, such as
created by <code>distributeVector</code> or
<code>remoteConstructRnormVector</code>, use <code>n2 = NULL</code>. When
multiplying by a one-column matrix, use <code>n2 = 1</code>.
</p>


<h3>References</h3>

<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10),
1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bigGP">bigGP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(fields)) {
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)
prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction = SN2011fe_crosscovfunc,
predCovFunction = SN2011fe_predcovfunc, meanFunction = SN2011fe_meanfunc,
covFunction = SN2011fe_covfunc,  inputs = inputs, params = SN2011fe_mle$par,
data = SN2011fe$flux, packages = c("fields"))
remoteCalcChol(matName = 'C', cholName = 'L', matPos = 'prob',
  cholPos = 'prob', n = n, h = prob$h_n)
remoteConstructRnormVector('z', n = n, h = prob$h_n)
remoteMultChol(cholName = 'L', inputName = 'z', outputName = 'result',
cholPos = 'prob', n1 = n, h1 = prob$h_n)
realiz &lt;- collectVector('result', n = n, h = prob$h_n)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='remoteRm'>
Remote Remove Objects
</h2><span id='topic+remoteRm'></span>

<h3>Description</h3>

<p><code>remoteRm</code> is used to remove objects from the global environment on the
slave processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteRm(..., list = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remoteRm_+3A_...">...</code></td>
<td>

<p>the objects to be removed, as names (unquoted) or character
strings (quoted). 
</p>
</td></tr>
<tr><td><code id="remoteRm_+3A_list">list</code></td>
<td>

<p>a character vector naming objects to be removed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a distributed version of <code>rm</code>. It removes the named
objects from all of the slave processes. Unlike <code>rm</code>,
<code>remoteRm</code> is currently not enabled to remove objects from other
than the global environment. Note that unless <code>options(warn = 2)</code>
is set on the slave processes, no warning is reported if one tries to
remove objects that do not exist.
</p>


<h3>See Also</h3>

<p><code>remoteLs</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bigGP.init(3)
a &lt;- 3
b &lt;- 7
push(a); push(b)
remoteLs()
remoteRm(a)
remoteLs()

## End(Not run)
</code></pre>

<hr>
<h2 id='SN2011fe'>
SN2011fe Supernova Dataset
</h2><span id='topic+SN2011fe'></span><span id='topic+SN2011fe_subset'></span><span id='topic+SN2011fe_newdata'></span><span id='topic+SN2011fe_newdata_subset'></span><span id='topic+SN2011fe_mle'></span><span id='topic+SN2011fe_mle_subset'></span><span id='topic+SN2011fe_initialParams'></span><span id='topic+SN2011fe_meanfunc'></span><span id='topic+SN2011fe_predmeanfunc'></span><span id='topic+SN2011fe_covfunc'></span><span id='topic+SN2011fe_crosscovfunc'></span><span id='topic+SN2011fe_predcovfunc'></span>

<h3>Description</h3>

<p><code>SN2011fe</code> is a dataset of flux values and estimated standard errors, as a function of phase
and wavelength, from the SN 2011fe supernova event. Data were collected over multiple nights (phases)
and multiple wavelengths. 
</p>


<h3>Format</h3>

<p>The <code>SN2011fe</code> object is a data frame containing the following
columns:
</p>

<dl>
<dt><code>phase</code>: </dt><dd><p>time of measurement in days.</p>
</dd>
<dt><code>wavelength</code>: </dt><dd><p>wavelength of measurement in <code class="reqn">\mbox{\AA}</code>.</p>
</dd>
<dt><code>flux</code>: </dt><dd><p>flux measurement in <code class="reqn">\mbox{erg}\ \mbox{s}^{-1}\ \mbox{cm}^{-2}\ \mbox{\AA}^{-1}</code>.</p>
</dd>
<dt><code>fluxerror</code>: </dt><dd><p>estimated standard deviation of the
error in measurement of the flux.</p>
</dd>
<dt><code>phaseindex</code>: </dt><dd><p>1-based index value of the time of
measurement [check this]</p>
</dd>
<dt><code>logwavelength</code>: </dt><dd><p>log of wavelength.</p>
</dd>
</dl>

<p>The <code>SN2011fe_newdata</code> object is a data frame of prediction points
on a fine grid of phases and wavelengths. The columns correspond to
the phase and wavelength columns in <code>SN2011fe</code> but the initial 'p' stands for 'prediction'.
</p>
<p>The <code>SN2011fe_mle</code> object is the output from maximum likelihood
fitting of the parameters of a statistical model for the dataset, with
the <code>par</code> element containing the MLEs.
</p>
<p>The objects labeled '_subset' are analogous objects for a small subset
of the dataset feasible to be fit without parallel processing.
</p>
<p>The <code>SN2011fe_initialParams</code> object is a set of starting values for
the maximum likelihood fitting.
</p>
<p>The functions <code>SN2011fe_meanfunc</code>, <code>SN2011fe_predmeanfunc</code>,
<code>SN2011fe_covfunc</code>, <code>SN2011fe_crosscovfunc</code>, and
<code>SN2011fe_predcovfunc</code> are functions for calculating the various
mean vectors and covariance matrices used in the statistical analysis of
the dataset. Users will need to create analogous functions for their own
kriging problems, so these are provided in part as templates. 
</p>


<h3>Warning</h3>

<p>Note that the <code>SN2011fe_newdata</code> set of prediction points was
chosen to ensure that the points were not so close together as to result
in numerically non-positive definite covariance matrices when simulating
posterior realizations. 
</p>


<h3>Source</h3>

<p><a href="https://snfactory.lbl.gov/snf/data/SNfactory_Pereira_etal_2013_SN2011fe.tar.gz">https://snfactory.lbl.gov/snf/data/SNfactory_Pereira_etal_2013_SN2011fe.tar.gz</a>
</p>


<h3>References</h3>

<p>For more details on the dataset, see:
R. Pereira, et al., 2013, &quot;Spectrophotometric time series of SN 2011fe from
the Nearby Supernova Factory,&quot; Astronomy and Astrophysics, accepted
(arXiv:1302.1292v1), DOI: <a href="https://doi.org/10.1051/0004-6361/201221008">doi:10.1051/0004-6361/201221008</a>.
</p>
<p>For more details on the statistical model used to fit the data, see:
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and
R.C.  Thomas. 2015. Parallelizing Gaussian Process Calculations in
R. Journal of Statistical Software, 63(10), 1-23. <a href="https://doi.org/10.18637/jss.v063.i10">doi:10.18637/jss.v063.i10</a>.
</p>
<p>or
</p>
<p>Paciorek, C.J., B. Lipshitz, W. Zhuo, Prabhat, C.G. Kaufman, and R.C.  Thomas. 2013. Parallelizing Gaussian Process Calculations in R. arXiv:1305.4886. <a href="https://arxiv.org/abs/1305.4886">https://arxiv.org/abs/1305.4886</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krigeProblem-class">krigeProblem-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
doSmallExample &lt;- TRUE

if(require(fields)) {
if(doSmallExample){
  SN2011fe &lt;- SN2011fe_subset
  SN2011fe_newdata &lt;- SN2011fe_newdata_subset
  SN2011fe_mle &lt;- SN2011fe_mle_subset
  nProc &lt;- 3
} else {
# users should select number of processors based on their system and the
# size of the full example
nProc &lt;- 210 
}

n &lt;- nrow(SN2011fe)
m &lt;- nrow(SN2011fe_newdata)
nu &lt;- 2
inputs &lt;- c(as.list(SN2011fe), as.list(SN2011fe_newdata), nu = nu)

prob &lt;- krigeProblem$new("prob", numProcesses = nProc, n = n, m = m,
predMeanFunction = SN2011fe_predmeanfunc, crossCovFunction = SN2011fe_crosscovfunc,
predCovFunction = SN2011fe_predcovfunc, meanFunction =
SN2011fe_meanfunc, covFunction = SN2011fe_covfunc,  inputs = inputs,
params = SN2011fe_mle$par, data = SN2011fe$flux, packages = c("fields"))

prob$calcLogDens()
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
