<!DOCTYPE html><html><head><title>Help for package btb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {btb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#btb'><p>Beyond the Border - Kernel Density Estimation for Urban Geography</p></a></li>
<li><a href='#btb_add_centroids'><p>Link points to their centroids</p></a></li>
<li><a href='#btb_add_inspire'><p>Creates Inpire names for a grid</p></a></li>
<li><a href='#btb_ptsToGrid'><p>Compute a grid from centroid points</p></a></li>
<li><a href='#btb_smooth'><p>Smoothing with a bisquare kernel or median</p></a></li>
<li><a href='#constituerGrappes'><p>constituerGrappes</p></a></li>
<li><a href='#constituerMatriceEffectifs'><p>constituerMatriceEffectifs</p></a></li>
<li><a href='#dfPrix_SP95_2016'><p>Unleaded 95 price in France in 2016</p></a></li>
<li><a href='#dfRestaurantParis'><p>Parisian restaurants</p></a></li>
<li><a href='#dfToGrid'><p>Depreciated function of btb_ptsToGrid</p></a></li>
<li><a href='#kernelSmoothing'><p>Depreciated function of btb_smooth</p></a></li>
<li><a href='#pixel_france'><p>France grid with 1km square tiles</p></a></li>
<li><a href='#reunion'><p>Households of Reunion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Beyond the Border - Kernel Density Estimation for Urban
Geography</td>
</tr>
<tr>
<td>Description:</td>
<td>The kernelSmoothing() function allows you to square and smooth geolocated data. It calculates a classical kernel smoothing (conservative) or a geographically weighted median. There are four major call modes of the function. 
        The first call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth) for a classical kernel smoothing and automatic grid.
        The second call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth, quantiles) for a geographically weighted median and automatic grid.
        The third call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth, centroids) for a classical kernel smoothing and user grid.
        The fourth call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth, quantiles, centroids) for a geographically weighted median and user grid.
        Geographically weighted summary statistics : a framework for localised exploratory data analysis, C.Brunsdon &amp; al., in Computers, Environment and Urban Systems C.Brunsdon &amp; al. (2002) &lt;<a href="https://doi.org/10.1016%2FS0198-9715%2801%2900009-6">doi:10.1016/S0198-9715(01)00009-6</a>&gt;, 
        Statistical Analysis of Spatial and Spatio-Temporal Point Patterns, Third Edition, Diggle, pp. 83-86, (2003) &lt;<a href="https://doi.org/10.1080%2F13658816.2014.937718">doi:10.1080/13658816.2014.937718</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-24</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0.9), sf, RcppParallel, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0),</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), dplyr, mapsf</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kim Antunez &lt;antuki.kim+cran@gmail.com&gt;</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, BH (&ge; 1.60.0-1), RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/InseeFr/btb">https://github.com/InseeFr/btb</a>, <a href="https://inseefr.github.io/btb/">https://inseefr.github.io/btb/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/InseeFr/btb/issues">https://github.com/InseeFr/btb/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-24 13:53:57 UTC; onyxia</td>
</tr>
<tr>
<td>Author:</td>
<td>Arlindo Dos Santos [aut],
  François Sémécurbe [aut],
  Julien Pramil [aut],
  Kim Antunez [cre, ctb],
  Auriane Renaud [ctb],
  Farida Marouchi [ctb],
  Joachim Timotéo [ctb],
  Institut national de la statistique et des études économiques [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-24 15:25:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='btb'>Beyond the Border - Kernel Density Estimation for Urban Geography</h2><span id='topic+btb'></span>

<h3>Description</h3>

<p>The kernelSmoothing() function allows you to square and smooth geolocated data. It calculates a classical kernel smoothing (conservative) or a geographically weighted median. There are four major call modes of the function.
The first call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth) for a classical kernel smoothing and automatic grid.
The second call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth, quantiles) for a geographically weighted median and automatic grid.
The third call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth, centroids) for a classical kernel smoothing and user grid.
The fourth call mode is kernelSmoothing(obs, epsg, cellsize, bandwidth, quantiles, centroids) for a geographically weighted median and user grid.
</p>

<hr>
<h2 id='btb_add_centroids'>Link points to their centroids</h2><span id='topic+btb_add_centroids'></span>

<h3>Description</h3>


<ul>
<li><p> Link some points to their centroids in a grid segmentation
</p>
</li>
<li><p> Relie des points aux centroides des carreaux auxquels ces points appartiennent (dans un découpage de l'espace en grille carroyée)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>btb_add_centroids(
  pts,
  iCellSize,
  offset = c(0L, 0L),
  names_coords = c("x", "y"),
  names_centro = c("x_centro", "y_centro"),
  add = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btb_add_centroids_+3A_pts">pts</code></td>
<td>
<p>: points (<code>df</code> of <code>sf</code> object)</p>
</td></tr>
<tr><td><code id="btb_add_centroids_+3A_icellsize">iCellSize</code></td>
<td>
<p>:
</p>

<ul>
<li><p> Size of the square cells (<strong>meters</strong>)
</p>
</li>
<li><p> Taille des côtés des carreaux (<strong>mètres</strong>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="btb_add_centroids_+3A_offset">offset</code></td>
<td>
<p>(<strong>numeric vector of size 2</strong>)
</p>

<ul>
<li><p> Offset for a grid non centered on the geographical referential origin
</p>
</li>
<li><p> Décalage si utilisation d'une grille non centrée sur l'origine du référentiel géographique
</p>
</li></ul>
</td></tr>
<tr><td><code id="btb_add_centroids_+3A_names_coords">names_coords</code></td>
<td>
<p>:
</p>

<ul>
<li><p> Names of the latitude-longitude variables (<strong>character vector</strong>)
</p>
</li>
<li><p> Noms des variables de latitude-longitude (<strong>vecteur character</strong>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="btb_add_centroids_+3A_names_centro">names_centro</code></td>
<td>

<ul>
<li><p> Names of the latitude-longitude variables for added centroids  (<strong>character vector</strong>)
</p>

<ul>
<li><p> Noms des variables de latitude-longitude pour les centroïdes ajoutés (<strong>vecteur character</strong>)
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="btb_add_centroids_+3A_add">add</code></td>
<td>
<p>(<strong>boolean</strong>)
</p>

<ul>
<li><p> If TRUE : returns pts + centroids coordinates
</p>
</li>
<li><p> Si TRUE : retourne pts + les coordonnées des centroïdes
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Works with sf points but only with coordinates in meters (and not degrees !). Do not use sf points with GPS coordinates for example.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>pts</code> table with additional centroids coordinates <code>x_centro</code> and <code>y_centro</code> (<code>df</code> of <code>sf</code> object)
</p>
</li>
<li><p> Table <code>pts</code> avec les coordonnées des centroïdes <code>x_centro</code> and <code>y_centro</code> (objet <code>df</code> of <code>sf</code> )
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- data.frame(
x = c(656913.1 , 348296.3 , 842276.3 , 716750.0 , 667418.2),
y = c(6855995 , 6788073 , 6385680 , 7003984 , 6585793),
val = 1:5)
btb_add_centroids(pts, 100, names_centro = c("centroX", "centroY"))
btb_add_centroids(pts, 100, offset = c(50, 50), names_centro = c("centroX", "centroY"))
pts2 &lt;- sf::st_as_sf(pts, coords = c("x","y"), crs = 2154)
btb_add_centroids(pts2, 50)
</code></pre>

<hr>
<h2 id='btb_add_inspire'>Creates Inpire names for a grid</h2><span id='topic+btb_add_inspire'></span>

<h3>Description</h3>

<p>Creates Inpire names for a grid defined with :
</p>

<ul>
<li><p> centroids coordinates
</p>
</li>
<li><p> Squares size(s)
</p>
</li>
<li><p> Projection system
</p>
</li></ul>

<p>Ajoute les noms des identifiants en norme Inspire des carreaux définis à partir :
</p>

<ul>
<li><p> des coordonnées de leurs centroides
</p>
</li>
<li><p> de la taille de leur côté en mètres
</p>
</li>
<li><p> d'un système de projection)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>btb_add_inspire(
  pts_centro,
  sEPSG,
  iCellSize,
  names_centro = c("x_centro", "y_centro")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btb_add_inspire_+3A_pts_centro">pts_centro</code></td>
<td>
<p>(<strong>df object</strong>) : table of centroids.</p>
</td></tr>
<tr><td><code id="btb_add_inspire_+3A_sepsg">sEPSG</code></td>
<td>
<p>(<strong>integer or character</strong>) : epsg code.</p>
</td></tr>
<tr><td><code id="btb_add_inspire_+3A_icellsize">iCellSize</code></td>
<td>
<p>(<strong>integer</strong>) : cells size(s) in meters. Can be a vector for irregular grids</p>
</td></tr>
<tr><td><code id="btb_add_inspire_+3A_names_centro">names_centro</code></td>
<td>
<p>(<strong>character vector</strong>) : vector of names for longitude/latitude variables. Default c(&quot;x_centro&quot;,&quot;y_centro&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<strong>df</strong>) pts_centro table with additional <em>idInspire</em> variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts_centro &lt;- data.frame(x_centro = c(100, 100, 300, 300, 500), 
y_centro = c(100, 300, 100, 300, 100))
btb_add_inspire(pts_centro, sEPSG = 2154, iCellSize = 200)
</code></pre>

<hr>
<h2 id='btb_ptsToGrid'>Compute a grid from centroid points</h2><span id='topic+btb_ptsToGrid'></span>

<h3>Description</h3>

<p>Function to compute a grid (regular or not) from centroid points.
</p>
<p>(Fonction permettant de générer une grille (régulière ou non) à partir de centroïdes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btb_ptsToGrid(
  pts,
  sEPSG = NA,
  iCellSize = NULL,
  names_centro = c("x_centro", "y_centro"),
  inspire = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btb_ptsToGrid_+3A_pts">pts</code></td>
<td>
<p>A simple <code>data.frame</code> with the centroids coordinates of the squares to draw, or a <code>sf</code> object of centroides. To generate an irregular grid, a column with each cell size must be provided and named <code>iCellSize</code>.
</p>
<p>(Un simple <code>data.frame</code> comportant les coordonnées des carrés à dessiner, ou un objet <code>sf</code> des centroides. Pour obtenir une grille irrégulière, il faut fournir une colonne indiquant la taille de chaque carreau, et nommée <code>iCellSize</code>.</p>
</td></tr>
<tr><td><code id="btb_ptsToGrid_+3A_sepsg">sEPSG</code></td>
<td>
<p>EPSG code of projection (<code>character</code>). For example, the RGF93 / Lambert-93 projection has &quot;2154&quot; code.
</p>
<p>(code EPSG de la projection (<code>character</code>). Par exemple, la projection RGF93 / Lambert-93 a pour code &quot;2154&quot;.)</p>
</td></tr>
<tr><td><code id="btb_ptsToGrid_+3A_icellsize">iCellSize</code></td>
<td>
<p>Cell size of the grid. If this argument is provided, the grid is regular.
</p>
<p>(Taille des carreaux de la grille. Si cet argument est fourni, la grille est régulière.)</p>
</td></tr>
<tr><td><code id="btb_ptsToGrid_+3A_names_centro">names_centro</code></td>
<td>
<p>(<strong>character vector</strong>)
</p>

<ul>
<li><p> vector of names for longitude/latitude variables. Default c(&quot;x_centro&quot;,&quot;y_centro&quot;).
</p>
</li>
<li><p> vecteur des noms des variables de longitude/latitude. Par défaut :  c(&quot;x_centro&quot;,&quot;y_centro&quot;)
</p>
</li></ul>
</td></tr>
<tr><td><code id="btb_ptsToGrid_+3A_inspire">inspire</code></td>
<td>
<p>(boolean) : if TRUE, returns a column for Inspire grid names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>sf</code> and <code>data.frame</code>.
</p>
<p>(Retourne un objet de classe <code>sf</code> et <code>data.frame</code>.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# example 1 - regular grid
pts &lt;- data.frame(x_centro = c(100, 100, 300, 300, 500), 
y_centro = c(100, 300, 100, 300, 100))
carResult &lt;- btb_ptsToGrid(pts = pts, sEPSG = "2154", iCellSize = 200)
# write_sf(obj = carResult, dsn = "regularGrid.shp", delete_layer = TRUE)

# example 2 - irregular grid
pts &lt;- data.frame(x = c(50, 50, 150, 150, 300)
                 , y = c(50, 150, 50, 150, 100)
                 , iCellSize = c(50, 50, 50, 50, 100))
carResult &lt;- btb_ptsToGrid(pts = pts, sEPSG = "2154",names_centro=c("x","y"))
# write_sf(obj = carResult, dsn = "irregularGrid.shp", delete_layer = TRUE)
# Exemple 3 : sf points (no epsg)
pts &lt;- data.frame(x = c(100, 100, 300, 300, 500), y = c(100, 300, 100, 300, 100))
pts &lt;- sf::st_as_sf(pts,coords=c("x","y"))
carResult &lt;- btb_ptsToGrid(pts = pts, sEPSG = "2154", iCellSize = 200)
# Exemple 3 : sf points (no epsg)
pts &lt;- data.frame(x = c(100, 100, 300, 300, 500), 
y = c(100, 300, 100, 300, 100))
pts &lt;- sf::st_as_sf(pts,coords=c("x","y"),crs=2154)
carResult &lt;- btb_ptsToGrid(pts = pts, sEPSG = "2154", iCellSize = 200)
</code></pre>

<hr>
<h2 id='btb_smooth'>Smoothing with a bisquare kernel or median</h2><span id='topic+btb_smooth'></span>

<h3>Description</h3>

<p>Smoothing function with a bisquare kernel or median.
</p>
<p>(Fonction de lissage à partir d'un noyau bisquare ou de la médiane.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btb_smooth(
  pts,
  sEPSG = NA,
  iCellSize = NA,
  iBandwidth,
  vQuantiles = NULL,
  dfCentroids = NULL,
  iNeighbor = NULL,
  inspire = F,
  iNbObsMin = 250
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btb_smooth_+3A_pts">pts</code></td>
<td>
<p>A <code>data.frame</code> with cartesian geographical coordinates and variables to smooth. (x, y, var1, var2, ...)
</p>
<p>(Un <code>data.frame</code> comportant les coordonnées géographiques cartésiennes (x,y), ainsi que les variables que l'on souhaite lisser. (x, y, var1, var2, ...)</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_sepsg">sEPSG</code></td>
<td>
<p>EPSG code of projection (<code>character</code>). For example, the RGF93 / Lambert-93 projection has &quot;2154&quot; code.
</p>
<p>(code EPSG de la projection (<code>character</code>). Par exemple, la projection RGF93 / Lambert-93 a pour code &quot;2154&quot;.)'</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_icellsize">iCellSize</code></td>
<td>
<p>Cell size of the grid (<code>integer</code>). The unit of measurement is free. It must be the same as the unit of
<code>iBandwidth</code> variable.
</p>
<p>(Taille des carreaux (<code>integer</code>). Le choix de l'unité de mesure est laissé libre à l'utilisateur. Elle doit seulement être la même que celle de la variable <code>iBandwidth</code>.)</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_ibandwidth">iBandwidth</code></td>
<td>
<p>Radius of the Kernel Density Estimator (<code>integer</code>). This bandwidth acts as a smoothing parameter, controlling the balance between bias and variance. A large bandwidth leads to a very smooth (i.e. high-bias) density distribution. A small bandwidth leads to an unsmooth (i.e. high-variance) density distribution. The unit of measurement is free. It must be the same as the unit of <code>iCellSize</code> variable.
</p>
<p>(Rayon de lissage de l'estimation d'intensité par noyau (<code>integer</code>). Cette bande-passante se comporte comme un paramètre de lissage, controlant l'équilibre entre biais et variance. Un rayon élevé conduit à une densité tres lissée, avec un biais élevé. Un petit rayon génère une densité peu lissée avec une forte variance. Le choix de l'unité de mesure est laissé libre à l'utilisateur. Elle doit seulement être la même que celle de la variable <code>iCellSize</code>.</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_vquantiles">vQuantiles</code></td>
<td>
<p>Percentile vector to calculate. For example c(0.1, 0.25, 0.5) will calculate the first decile, the first quartile and the median.
</p>
<p>(Vecteur des quantiles à calculer. Par exemple c(0.1, 0.25, 0.5) retournera le premier décile, le premier quartile et la mediane.)'</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_dfcentroids">dfCentroids</code></td>
<td>
<p>A <code>data.frame</code> with two columns (x, y) containing coordinates of the user's centroids. The coordinates must be in the same projection than (<code>pts</code>).
</p>
<p>(Un <code>data.frame</code> avec deux colonnes (x, y) contenant les coordonnées des centroides de l'utilisateur. Les coordonnées doivent être dans le même système de coordonnées que (<code>pts</code>).)</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_ineighbor">iNeighbor</code></td>
<td>
<p>Technical parameter, leave empty. (<code>integer</code>)
</p>
<p>(Paramètre technique pour calculer l'étendue des points d'estimations, à ne pas remplir. (<code>integer</code>))</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_inspire">inspire</code></td>
<td>
<p>(boolean) : if TRUE, returns a column for Inspire grid names.</p>
</td></tr>
<tr><td><code id="btb_smooth_+3A_inbobsmin">iNbObsMin</code></td>
<td>
<p>Minimum size of constituted grappes for median smoothing.  (<code>integer</code>)
</p>
<p>(Taille minimale des grappes constituées pour le lissage &quot;médian&quot; (géographiquement pondéré). (<code>integer</code>))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object inheriting from the <code>data.frame</code> class. (Retourne un objet qui se comporte comme un <code>data.frame</code>, par heritage.)
</p>

<ul>
<li><p> Smoothing covers a set of methods to extract pertinent and structuring information from noisy data.  In the field of spatial analysis, and most widely in quantitative geography, smoothing is used to modelise density variations of a population distribution in geographical space. Kernel smoothing methods are widely used.
In this method, for each location x, we count the number of events of a process within a distance h of x, and weighted by the square reciprocal of the radius h. We apply a edge-correction to deal with edge-effects. So the method is conservative..
</p>
</li>
<li><p> Le lissage recouvre un ensemble de méthodes pour extraire d'une source de données bruitées une information pertinente et structurante. Dans le champ de l'analyse spatiale et plus largement de la géographie quantitative, le lissage est principalement utilisé pour modéliser les variations de densités d'une distribution de population dans l'espace géographique. On utilise principalement des méthodes de lissage par noyau.
Il s'agit ici, pour chaque point x, de comptabliser le nombre d' &quot;évènements&quot; d'un processus à une distance h de ce point, tout en ponderant ce nombre par l'inverse de la distance h au carré. On applique une correction à la ponderation afin de traiter les effets de bord. Cette méthode est conservative.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> &quot;Geographically weighted summary statistics : a framework for localised exploratory data analysis&quot;, C.Brunsdon &amp; al., in Computers, Environment and Urban Systems 2002
</p>
</li>
<li><p> Statistical Analysis of Spatial and Spatio-Temporal Point Patterns, Third Edition, Diggle, 2003, pp. 83-86
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1
data(dfPrix_SP95_2016)
dfPrix_SP95_2016$nbObs &lt;- 1L
dfSmoothed &lt;- btb::btb_smooth(pts = dfPrix_SP95_2016,
                              sEPSG = "2154",
                              iCellSize = 5000L,
                              iBandwidth = 30000L, 
                              inspire = TRUE)
dfSmoothed$prix95 &lt;- dfSmoothed$SP95 / dfSmoothed$nbObs * 100
library(mapsf)
mf_map(dfSmoothed,
      type = "choro",
      var = "prix95",
      breaks = "fisher",
      nbreaks = 5,
      border = NA,
      leg_title = "prix du SP95 en centimes")
# Example 2
data(reunion)
# Call mode 1: classic smoothing - automatic grid
reunionSmoothed &lt;- btb_smooth( pts = reunion,
                                    sEPSG = "32740",
                                    iCellSize = 200L,
                                    iBandwidth = 400L)
library(mapsf)
mf_map(reunionSmoothed,
      type = "choro",
      var = "houhold",
      breaks = "fisher",
      nbreaks = 5,
      border = NA)
# Call mode 2: median smoothing - automatic grid
reunionSmoothed &lt;- btb_smooth( pts = reunion,
                                     sEPSG = "32740",
                                     iCellSize = 200L,
                                     iBandwidth = 400L,
                                     vQuantiles = c(0.1, 0.5, 0.9))
mf_map(reunionSmoothed,
      type = "choro",
      var = "houhold_05",
      breaks = "fisher",
      nbreaks = 5,
      border = NA)
# Call mode 3: classic smoothing - user grid
dfCentroidsUser &lt;- merge( x = seq(from =  314400L, to =  378800L, by = 200L),
                          y = seq(from = 7634000L, to = 7691200L, by = 200L))
reunionSmoothed &lt;- btb_smooth( pts = reunion,
                                    sEPSG = "32740",
                                    iCellSize = 200L,
                                    iBandwidth = 400L,
                                    dfCentroids = dfCentroidsUser)
reunionSmoothed &lt;- reunionSmoothed[reunionSmoothed$houhold &gt; 0, ]
mf_map(reunionSmoothed,
      type = "choro",
      var = "houhold",
      breaks = "fisher",
      nbreaks = 5,
      border = NA)
# Call mode 4: median smoothing - user grid
reunionSmoothed &lt;- btb_smooth( pts = reunion,
                                    sEPSG = "32740",
                                    iCellSize = 200L,
                                    iBandwidth = 400L,
                                    vQuantiles = c(0.1, 0.5, 0.9),
                                    dfCentroids = dfCentroidsUser)
reunionSmoothed &lt;- reunionSmoothed[reunionSmoothed$nbObs &gt; 0, ]
mf_map(reunionSmoothed,
      type = "choro",
      var = "houhold_05",
      breaks = "fisher",
      nbreaks = 5,
      border = NA)

## End(Not run)
</code></pre>

<hr>
<h2 id='constituerGrappes'>constituerGrappes</h2><span id='topic+constituerGrappes'></span>

<h3>Description</h3>

<p>Quadtree variant function.
</p>
<p>(Variante de la fonction Quadtree.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constituerGrappes(iNbObsMin, mEffectifs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constituerGrappes_+3A_inbobsmin">iNbObsMin</code></td>
<td>

<ul>
<li><p> An <code>integer</code> representing the minimum number of elements in each cluster
</p>

<ul>
<li><p> Un <code>data.frame</code> représentant le nombre minimum d'éléments dans chaque grappe.)
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="constituerGrappes_+3A_meffectifs">mEffectifs</code></td>
<td>

<ul>
<li><p> staffing matrix for each cell (<code>matrix</code>).
</p>

<ul>
<li><p> matrice des effectifs pour chaque case (<code>matrix</code>). .)
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> Returns a <code>matrix</code> with the cluster number for each cell .
</p>
</li>
<li><p> Retourne une <code>matrix</code> avec le numéro de grappe pour chaque cellule.
</p>
</li></ul>



<h3>Author(s)</h3>


<ul>
<li><p> Psar Analyse Urbaine Insee
</p>
</li>
<li><p> Arlindo Dos Santos
</p>
</li>
<li><p> Francois Semecurbe
</p>
</li></ul>


<hr>
<h2 id='constituerMatriceEffectifs'>constituerMatriceEffectifs</h2><span id='topic+constituerMatriceEffectifs'></span>

<h3>Description</h3>

<p>Function constituting a membership matrix (Fonction constituant une matrice des effectifs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constituerMatriceEffectifs(vLigneObservation, vColonneObservation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constituerMatriceEffectifs_+3A_vligneobservation">vLigneObservation</code></td>
<td>
<p>:
</p>

<ul>
<li><p> A <code>vector</code> containing the line number of each observation
</p>
</li>
<li><p> (Un <code>vector</code> contenant le numéro de ligne de chaque observation.)
</p>
</li></ul>
</td></tr>
<tr><td><code id="constituerMatriceEffectifs_+3A_vcolonneobservation">vColonneObservation</code></td>
<td>
<p>:
</p>

<ul>
<li><p> A <code>vector</code> containing the column number of each observation
</p>
</li>
<li><p> (Un <code>vector</code> contenant le numéro de colonne de chaque observation.)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>matrix</code> with the number of observations for each cell.
</p>
<p>(Retourne une <code>matrix</code> avec le nombre d'observations pour chaque cellule.)
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Psar Analyse Urbaine Insee
</p>
</li>
<li><p> Arlindo Dos Santos
</p>
</li>
<li><p> Francois Semecurbe
</p>
</li></ul>


<hr>
<h2 id='dfPrix_SP95_2016'>Unleaded 95 price in France in 2016</h2><span id='topic+dfPrix_SP95_2016'></span>

<h3>Description</h3>

<p>Unleaded 95 price in France in 2016 (prix du sans-plomb 95 en France en 2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfPrix_SP95_2016
</code></pre>


<h3>Format</h3>



<h4><code>dfPrix_SP95_2016</code></h4>

<p>A data frame with 5,573 rows and 3 columns:
</p>

<dl>
<dt>x</dt><dd><p>longitude</p>
</dd>
<dt>y</dt><dd><p>latitude</p>
</dd>
<dt>SP95</dt><dd><p>Unleaded price - prix du sans plomb</p>
</dd>
</dl>




<h3>Source</h3>

<p>https://www.prix-carburants.gouv.fr/rubrique/opendata/
</p>

<hr>
<h2 id='dfRestaurantParis'>Parisian restaurants</h2><span id='topic+dfRestaurantParis'></span>

<h3>Description</h3>

<p>Parisian restaurants (Restaurants parisiens)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfRestaurantParis
</code></pre>


<h3>Format</h3>



<h4><code>dfRestaurantParis</code></h4>

<p>A data frame with 13,823 rows and 17 columns:
</p>

<dl>
<dt>x</dt><dd><p>longitude</p>
</dd>
<dt>y</dt><dd><p>latitude</p>
</dd>
<dt>french</dt><dd><p>French restaurant</p>
</dd>
<dt>asian</dt><dd><p>asian restaurant</p>
</dd>
<dt>caribbean</dt><dd><p>caribbean restaurant</p>
</dd>
<dt>maghreb</dt><dd><p>maghreb restaurant</p>
</dd>
<dt>african</dt><dd><p>african restaurant</p>
</dd>
<dt>european</dt><dd><p>european restaurant</p>
</dd>
<dt>south_america</dt><dd><p>south_american restaurant</p>
</dd>
<dt>indian</dt><dd><p>indian restaurant</p>
</dd>
<dt>world</dt><dd><p>world food restaurant</p>
</dd>
<dt>cafeteria</dt><dd><p>cafeteria restaurant</p>
</dd>
<dt>tea_house</dt><dd><p>tea_house</p>
</dd>
<dt>brasserie</dt><dd><p>brasserie restaurant</p>
</dd>
<dt>fastfood</dt><dd><p>fastfood restaurant</p>
</dd>
<dt>bar</dt><dd><p>bar</p>
</dd>
<dt>restaurant</dt><dd><p>restaurant</p>
</dd>
</dl>




<h3>Source</h3>

<p>source : https://opendata.paris.fr
</p>

<hr>
<h2 id='dfToGrid'>Depreciated function of btb_ptsToGrid</h2><span id='topic+dfToGrid'></span>

<h3>Description</h3>

<p>Function dfToGrid has been replaced by btb_ptsToGrid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfToGrid(df, sEPSG, iCellSize = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfToGrid_+3A_df">df</code></td>
<td>
<p>centroid points</p>
</td></tr>
<tr><td><code id="dfToGrid_+3A_sepsg">sEPSG</code></td>
<td>
<p>epsg code</p>
</td></tr>
<tr><td><code id="dfToGrid_+3A_icellsize">iCellSize</code></td>
<td>
<p>cell size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grid
</p>

<hr>
<h2 id='kernelSmoothing'>Depreciated function of btb_smooth</h2><span id='topic+kernelSmoothing'></span>

<h3>Description</h3>

<p>Function kernelSmoothing has been replaced by <code>btb_smooth</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelSmoothing(
  dfObservations,
  sEPSG,
  iCellSize,
  iBandwidth,
  vQuantiles = NULL,
  dfCentroids = NULL,
  fUpdateProgress = NULL,
  iNeighbor = NULL,
  iNbObsMin = 250
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernelSmoothing_+3A_dfobservations">dfObservations</code></td>
<td>
<p>points</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_sepsg">sEPSG</code></td>
<td>
<p>epsg code</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_icellsize">iCellSize</code></td>
<td>
<p>cell size</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_ibandwidth">iBandwidth</code></td>
<td>
<p>smoothing bandwidth</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_vquantiles">vQuantiles</code></td>
<td>
<p>quantiles</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_dfcentroids">dfCentroids</code></td>
<td>
<p>user grid</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_fupdateprogress">fUpdateProgress</code></td>
<td>
<p>message parameter</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_ineighbor">iNeighbor</code></td>
<td>
<p>number of neighbors pixels</p>
</td></tr>
<tr><td><code id="kernelSmoothing_+3A_inbobsmin">iNbObsMin</code></td>
<td>
<p>technical parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a warning message
</p>

<hr>
<h2 id='pixel_france'>France grid with 1km square tiles</h2><span id='topic+pixel_france'></span>

<h3>Description</h3>

<p>Whole France grid with 1km square tiles. Lambert 93 projection.
</p>
<p>(Grille France entière avec des carreaux d'1km de côté. Projection Lambert 93)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel_france
</code></pre>


<h3>Format</h3>



<h4><code>pixel_france</code></h4>

<p>A data frame with 54,8495 rows and 2 columns:
</p>

<dl>
<dt>x</dt><dd><p>longitude of pixel's centroids</p>
</dd>
<dt>y</dt><dd><p>latitude of pixel's centroids</p>
</dd>
</dl>




<h3>Source</h3>

<p>source : https://opendata.paris.fr
</p>

<hr>
<h2 id='reunion'>Households of Reunion</h2><span id='topic+reunion'></span>

<h3>Description</h3>

<p>Households of Reunion (Menages de La Reunion)
Gridded database with a grid cell resolution of 200 meters. (Données carroyées à 200 mètres).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reunion
</code></pre>


<h3>Format</h3>



<h4><code>reunion</code></h4>

<p>A data frame with 14,076 rows and 4 columns:
</p>

<dl>
<dt>x</dt><dd><p>longitude</p>
</dd>
<dt>y</dt><dd><p>latitude</p>
</dd>
<dt>houhold</dt><dd><p>number of households - nombre de ménages</p>
</dd>
<dt>phouhold</dt><dd><p>number of poor households - nombre de ménages pauvres</p>
</dd>
</dl>




<h3>Source</h3>

<p>Source : Insee, Localized data : Fiscal Revenue - 31/12/2010 and Housing Tax - 01/01/2011
</p>
<p>Source : Insee, Revenus Fiscaux Localisés (RFL) au 31 decembre 2010 et Taxe d'habitation (TH) au 1er janvier 2011)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
