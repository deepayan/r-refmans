<!DOCTYPE html><html><head><title>Help for package ggbrain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggbrain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+.ggb'><p>addition operator for ggb object to support ggplot-like syntax</p></a></li>
<li><a href='#+.ggbrain_images'><p>addition operator for combining ggbrain_images objects</p></a></li>
<li><a href='#annotate_coordinates'><p>Adds the coordinate labels to each panel based on the location of the slice along the slicing axis (e.g., z = 15)</p></a></li>
<li><a href='#annotate_panel'><p>Adds custom annotations to a single panel on the ggbrain plot</p></a></li>
<li><a href='#center_matrix'><p>helper function to center a numeric matrix within a (larger) target matrix size</p></a></li>
<li><a href='#contrast_parser'><p>helper function to calculate contrasts of one or more images using a combination of</p>
image arithmetic and logical subsetting</a></li>
<li><a href='#count_neighbors'><p>This function counts the number of neighboring/touching pixels in a 2D binary image</p></a></li>
<li><a href='#define'><p>Adds contrast definitions to the ggbrain plot</p></a></li>
<li><a href='#df2mat'><p>Convert a 3-column data.frame (dim1, dim2, value) to a 2-D matrix</p></a></li>
<li><a href='#fill_from_edge'><p>This function finds holes by flood filling TRUE into a 2D binary image, starting from the edge</p></a></li>
<li><a href='#find_threads'><p>This function finds 'threads' hanging off of the edges of blobs in an image, allowing the user to trim them</p></a></li>
<li><a href='#flood_fill'><p>This function flood fills a binary image with TRUE for any value of FALSE</p></a></li>
<li><a href='#geom_brain'><p>Adds a raster layer to the ggbrain plot, displaying pixels from the specified layer definition</p></a></li>
<li><a href='#geom_outline'><p>Adds an outline layer to the ggbrain plot, displaying outlines from the non-missing pixels in the specified layer definition</p></a></li>
<li><a href='#geom_region_label'><p>Variant of geom_label used for plotting region labels on slices</p></a></li>
<li><a href='#geom_region_label_repel'><p>Variant of geom_label_repel used for plotting region labels on slices with separation from other labels</p></a></li>
<li><a href='#geom_region_text'><p>Variant of geom_text used for plotting region labels on slices</p></a></li>
<li><a href='#geom_region_text_repel'><p>Variant of geom_text_repel used for plotting region labels on slices with separation from other labels</p></a></li>
<li><a href='#ggb'><p>Generic R6 base class that is used to support + semantics</p></a></li>
<li><a href='#ggbrain'><p>create ggb container object for a given plot</p></a></li>
<li><a href='#ggbrain_images'><p>R6 class for compiling images to render in ggplot</p></a></li>
<li><a href='#ggbrain_label'><p>R6 class for adding labels to a ggbrain_panel</p></a></li>
<li><a href='#ggbrain_layer'><p>R6 class for a single layer of a ggbrain panel</p></a></li>
<li><a href='#ggbrain_layer_brain'><p>R6 class for a single layer of a ggbrain panel using fill geom</p></a></li>
<li><a href='#ggbrain_layer_outline'><p>R6 class for a single layer of a ggbrain panel using outline geom</p></a></li>
<li><a href='#ggbrain_panel'><p>R6 class for a single panel of a ggbrain image</p></a></li>
<li><a href='#ggbrain_plot'><p>An R6 class for constructing a ggbrain plot from a ggbrain_slices object</p></a></li>
<li><a href='#ggbrain_slices'><p>R6 class for managing slice data for ggbrain plots</p></a></li>
<li><a href='#ggplot_add.ggbrain_label'><p>S3 method to support adding ggbrain_label objects to an existing ggplot object</p></a></li>
<li><a href='#ggplot_add.ggbrain_layer'><p>S3 method to support adding ggbrain_layer objects to an existing ggplot object</p></a></li>
<li><a href='#ggplot_add.ggbrain_panel'><p>S3 method to support adding ggbrain_layer objects to an existing ggplot object</p></a></li>
<li><a href='#images'><p>Add images to a ggbrain object</p></a></li>
<li><a href='#integer_breaks'><p>breaks function to encourage integer-valued breaks, based on input from pretty</p></a></li>
<li><a href='#integer_mode'><p>Finds the mode of an integer vector</p></a></li>
<li><a href='#mat2df'><p>Fast conversion of 2D mat to 3-column data.frame with dim1, dim2, value</p></a></li>
<li><a href='#montage'><p>Convenience function to add many slices in a montage along one of the 3D planes</p></a></li>
<li><a href='#named_list'><p>little helper function to create named list from objects</p></a></li>
<li><a href='#nearest_pts'><p>Finds the nearest non-missing neighbors of a target point in a 2D matrix</p></a></li>
<li><a href='#nn_impute'><p>Imputes missing values in a 2D matrix based on the nearest non-missing neighbors in a given radius</p></a></li>
<li><a href='#plot.ggb'><p>S3 method to allow for plot() syntax with ggbrain (ggb) objects</p></a></li>
<li><a href='#plot.ggbrain_panel'><p>S3 method to allow for plot() syntax with ggbrain_panel objects</p></a></li>
<li><a href='#plot.ggbrain_plot'><p>S3 method to allow for plot() syntax with ggbrain_panel objects</p></a></li>
<li><a href='#range_breaks'><p>breaks function for including min + max with labels, and a few unlabeled ticks in between</p></a></li>
<li><a href='#render'><p>Function to convert <code>ggb</code> object to ggplot/patchwork object</p></a></li>
<li><a href='#scale_fill_bisided'><p>scale for plotting separate color gradients for positive and negative values</p></a></li>
<li><a href='#slices'><p>Adds slices to the ggbrain plot, including additional panel aesthetics</p></a></li>
<li><a href='#sort_mat'><p>Sort Matrix by Column</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Images of Volumetric Brain Data in NIfTI Format Using
'ggplot2' Syntax</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hallquist &lt;michael.hallquist@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'ggplot2'-consistent approach to generating 2D displays of  volumetric brain imaging data.
  Display data from multiple NIfTI images using standard 'ggplot2' conventions such scales, limits, and
  themes to control the appearance of displays. The resulting plots are returned as 'patchwork' objects,
  inheriting from 'ggplot', allowing for any standard modifications of display aesthetics supported by 'ggplot2'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://michaelhallquist.github.io/ggbrain/">https://michaelhallquist.github.io/ggbrain/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michaelhallquist/ggbrain/issues">https://github.com/michaelhallquist/ggbrain/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, RNifti, checkmate, data.table, dplyr, ggplot2,
ggnewscale, ggrepel, glue, imager, patchwork, rlang, tibble,
tidyr, tidyselect, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-21 17:36:10 UTC; hallquist</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hallquist <a href="https://orcid.org/0000-0001-5894-8038"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-21 18:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B.ggb'>addition operator for ggb object to support ggplot-like syntax</h2><span id='topic++2B.ggb'></span>

<h3>Description</h3>

<p>addition operator for ggb object to support ggplot-like syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggb'
o1 + o2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.ggb_+3A_o1">o1</code></td>
<td>
<p>the first object inheriting the ggb class</p>
</td></tr>
<tr><td><code id="+2B2B.ggb_+3A_o2">o2</code></td>
<td>
<p>the second object inheriting the ggb class</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the addition operator always clones the underlying o1 object
rather than modifying it in place
</p>


<h3>Value</h3>

<p>a modified version of the o1 object with o2 added to it
</p>

<hr>
<h2 id='+2B.ggbrain_images'>addition operator for combining ggbrain_images objects</h2><span id='topic++2B.ggbrain_images'></span>

<h3>Description</h3>

<p>addition operator for combining ggbrain_images objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbrain_images'
o1 + o2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.ggbrain_images_+3A_o1">o1</code></td>
<td>
<p>first ggbrain_images object</p>
</td></tr>
<tr><td><code id="+2B2B.ggbrain_images_+3A_o2">o2</code></td>
<td>
<p>second ggbrain_images object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>note that the addition does not modify either existing object. Rather,
the first object is cloned and the second is added to it. If you want to add one
ggbrain_images object to another in place (i.e., modifying the extant object), use
the $add() method.
</p>


<h3>Value</h3>

<p>combined ggbrain_images object
</p>

<hr>
<h2 id='annotate_coordinates'>Adds the coordinate labels to each panel based on the location of the slice along the slicing axis (e.g., z = 15)</h2><span id='topic+annotate_coordinates'></span>

<h3>Description</h3>

<p>Adds the coordinate labels to each panel based on the location of the slice along the slicing axis (e.g., z = 15)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_coordinates(x = "right", y = "bottom", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_coordinates_+3A_x">x</code></td>
<td>
<p>the x position of the coordinate label. If numeric, it is assumed to be the pixel position along the x axis (e.g., 26).
In addition, convenience values of <code>"left"</code>, <code>"right"</code>, or <code>"q[1-100]"</code> can be used to look up the left-most,
right-most, or quantile-based positions along the x axis.</p>
</td></tr>
<tr><td><code id="annotate_coordinates_+3A_y">y</code></td>
<td>
<p>the y position of the coordinate label. If numeric, it is assumed to be the pixel position along the y axis (e.g., 26).
In addition, convenience values of 'top', <code>"bottom"</code>, or <code>"q[1-100]"</code> can be used to look up the top-most, bottom-most,
or quantile-based positions along the y axis.</p>
</td></tr>
<tr><td><code id="annotate_coordinates_+3A_...">...</code></td>
<td>
<p>any other arguments to ggplot2::annotate, which will be passed through to each panel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object with the action 'add_annotations', used in a <code>ggbrain</code> addition chain
</p>

<hr>
<h2 id='annotate_panel'>Adds custom annotations to a single panel on the ggbrain plot</h2><span id='topic+annotate_panel'></span>

<h3>Description</h3>

<p>Adds custom annotations to a single panel on the ggbrain plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_panel(x = "middle", y = "middle", slice_index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_panel_+3A_x">x</code></td>
<td>
<p>the x position of the annotation. If numeric, it is assumed to be the pixel position along the x axis (e.g., 26).
In addition, convenience values of 'left', 'right', or <code>'q[1-100]'</code> can be used to look up the left-most, right-most, or quantile-based
positions along the x axis.</p>
</td></tr>
<tr><td><code id="annotate_panel_+3A_y">y</code></td>
<td>
<p>the y position of the annotation. If numeric, it is assumed to be the pixel position along the y axis (e.g., 26).
In addition, convenience values of 'left', 'right', or <code>'q[1-100]'</code> can be used to look up the left-most, right-most, or quantile-based
positions along the x axis.</p>
</td></tr>
<tr><td><code id="annotate_panel_+3A_slice_index">slice_index</code></td>
<td>
<p>the slice number to which this annotation is added. These are numbered in the wrapping order from
patchwork::wrap_plots, which will normally go from top-left to bottom-right.</p>
</td></tr>
<tr><td><code id="annotate_panel_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to ggplot2::annotate such as <code>label</code> or <code>geom</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this only handles a single annotation on a single panel!
</p>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant annotations field and an action of &quot;add_annotations&quot;
</p>

<hr>
<h2 id='center_matrix'>helper function to center a numeric matrix within a (larger) target matrix size</h2><span id='topic+center_matrix'></span>

<h3>Description</h3>

<p>helper function to center a numeric matrix within a (larger) target matrix size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_matrix(output_dim, mat, default_value = NA_real_, drop_zeros = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_matrix_+3A_output_dim">output_dim</code></td>
<td>
<p>the desired dimensions of the output matrix</p>
</td></tr>
<tr><td><code id="center_matrix_+3A_mat">mat</code></td>
<td>
<p>the 2D numeric matrix containing values to be centered in the output matrix</p>
</td></tr>
<tr><td><code id="center_matrix_+3A_default_value">default_value</code></td>
<td>
<p>the value that should fill padded rows and columns of the output matrix</p>
</td></tr>
<tr><td><code id="center_matrix_+3A_drop_zeros">drop_zeros</code></td>
<td>
<p>if TRUE, all zero-valued rows and columns of <code>mat</code> will be dropped before
the data are centered within the output matrix. This is useful if the matrix is asymmetric,
but you still want to have it be dead-center in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an expanded matrix of size <code>output_dim</code> with the input matrix <code>mat</code> centered
within it.
</p>

<hr>
<h2 id='contrast_parser'>helper function to calculate contrasts of one or more images using a combination of
image arithmetic and logical subsetting</h2><span id='topic+contrast_parser'></span>

<h3>Description</h3>

<p>helper function to calculate contrasts of one or more images using a combination of
image arithmetic and logical subsetting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrast_parser(expr, data = NULL, default_val = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrast_parser_+3A_expr">expr</code></td>
<td>
<p>a string or expression containing the image calculation to be performed</p>
</td></tr>
<tr><td><code id="contrast_parser_+3A_data">data</code></td>
<td>
<p>a data.frame containing all variables used in <code>expr</code>. This will be used
to perform contrast calculations</p>
</td></tr>
<tr><td><code id="contrast_parser_+3A_default_val">default_val</code></td>
<td>
<p>the value to be returned for any element of the contrast calculation that
does not pass through the arithmetic, either because of logical subsetting or because it
is exactly zero. In general, leave this as <code>NA_real_</code> unless you know what you're doing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='count_neighbors'>This function counts the number of neighboring/touching pixels in a 2D binary image</h2><span id='topic+count_neighbors'></span>

<h3>Description</h3>

<p>This function counts the number of neighboring/touching pixels in a 2D binary image
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_neighbors_+3A_im">im</code></td>
<td>
<p>A boolean matrix representing a binary image</p>
</td></tr>
<tr><td><code id="count_neighbors_+3A_diagonal">diagonal</code></td>
<td>
<p>Whether to count diagonal elements as valid neighbors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function used by geom_outline to clean up outlines
</p>


<h3>Value</h3>

<p>A matrix of the same size as <code>im</code> containing the number of neighboring pixels
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='define'>Adds contrast definitions to the ggbrain plot</h2><span id='topic+define'></span>

<h3>Description</h3>

<p>Adds contrast definitions to the ggbrain plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define(contrasts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_+3A_contrasts">contrasts</code></td>
<td>
<p>a character vector or list containing contrasts to be computed as part of the
ggbrain object definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>contrasts</code> must take the form of <code style="white-space: pre;">&#8288;&lt;name&gt; := &lt;value expression&gt;&#8288;</code> or must use a named vector.
Note that defining a contrast does not directly impact the appearance of the plot unless the
contrast is named in a geom_* layer.
</p>
<p>Also note that contrasts can be specified in the definition of a layer. Thus, the <code>define</code> function
has two primary virtues. First, it allows for the conceptual separation of contrast definition versus usage
inside a geom_* layer, which is particularly useful if a contrast is used across several layers. Second, it allows
downstream layers to further modify the contrast, such as when we compute a
</p>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant contrasts and an action of 'add_contrasts'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # T1-weighted template
  t1 &lt;- system.file("extdata", "mni_template_2009c_3mm.nii.gz", package = "ggbrain")

  # signed reward prediction error map
  signed_pe &lt;- system.file("extdata", "pe_ptfce_fwep_0.05.nii.gz", package = "ggbrain")

  # unsigned (absolute value) prediction error map
  abspe &lt;- system.file("extdata", "abspe_ptfce_fwep_0.05.nii.gz", package = "ggbrain")

  # simple example of a difference contrast, separating definition from usage in geom_brain
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1, signed_pe = signed_pe, abspe = abspe)) +
    slices(c("x = 25%", "x = 75%")) +
    define("signed_gt_abs := signed_pe - abspe") +
    geom_brain("signed_gt_abs")

  # you can also use a named vector in define(), which is equivalent
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1, signed_pe = signed_pe, abspe = abspe)) +
    slices(c("x = 25%", "x = 75%")) +
    define(c(signed_gt_abs = "signed_pe - abspe")) +
    geom_brain("signed_gt_abs")
    
  # contrast definitions can also occur inline, yielding equivalent plots
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1, signed_pe = signed_pe, abspe = abspe)) +
    slices(c("x = 25%", "x = 75%")) +
    geom_brain("signed_pe - abspe")
    
  # The use of contrasts() is helpful when layers modify the contrast (e.g., subsetting)
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1, signed_pe = signed_pe, abspe = abspe)) +
    slices(c("x = 25%", "x = 75%")) +
    define(c(signed_gt_abs = "signed_pe - abspe")) +
    geom_brain(
      "signed_gt_abs[signed_gt_abs &gt; 0]", 
      fill_scale=ggplot2::scale_fill_distiller("Pos diff", palette = "Reds")
    )
</code></pre>

<hr>
<h2 id='df2mat'>Convert a 3-column data.frame (dim1, dim2, value) to a 2-D matrix</h2><span id='topic+df2mat'></span>

<h3>Description</h3>

<p>Convert a 3-column data.frame (dim1, dim2, value) to a 2-D matrix
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="df2mat_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> representing a melted 2-D matrix, having columns dim1, dim2, and value</p>
</td></tr>
<tr><td><code id="df2mat_+3A_replace_na">replace_na</code></td>
<td>
<p>if not <code>NULL</code>, this numeric value will be used to replace any NAs in <code>df</code> in the
resulting matrix. This is useful if downstream code is not built to handle missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is virtually no input validation of <code>df</code>. You must pass a data.frame that has dim1, dim2, and value as
columns. Otherwise, it will not work as expected.
</p>
<p>This is a much faster version of the acast function from <code>reshape2</code> that works only on 2-D matrix conversions.
</p>


<h3>Value</h3>

<p>The matrix form of the keyed data.frame object
</p>

<hr>
<h2 id='fill_from_edge'>This function finds holes by flood filling TRUE into a 2D binary image, starting from the edge</h2><span id='topic+fill_from_edge'></span>

<h3>Description</h3>

<p>This function finds holes by flood filling TRUE into a 2D binary image, starting from the edge
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_from_edge_+3A_im">im</code></td>
<td>
<p>A boolean matrix representing a binary image</p>
</td></tr>
<tr><td><code id="fill_from_edge_+3A_nedges">nedges</code></td>
<td>
<p>An integer specifying how many starting points along the edge to use for
filling TRUE. The starts are northwest (1), southwest (2), southeast (3), and northeast (4).
The compute time increases with the number of starts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function used by geom_outline to clean up outlines
</p>


<h3>Value</h3>

<p>A matrix of the same size as <code>im</code> containing the number of neighboring pixels
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='find_threads'>This function finds 'threads' hanging off of the edges of blobs in an image, allowing the user to trim them</h2><span id='topic+find_threads'></span>

<h3>Description</h3>

<p>This function finds 'threads' hanging off of the edges of blobs in an image, allowing the user to trim them
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_threads_+3A_im">im</code></td>
<td>
<p>A numeric matrix representing an image, with non-zero values representing pixels to display</p>
</td></tr>
<tr><td><code id="find_threads_+3A_min_neighbors">min_neighbors</code></td>
<td>
<p>the minimum number of neighbors a pixel must have to be retained</p>
</td></tr>
<tr><td><code id="find_threads_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to run the thread trimming algorithm. Default: 15.</p>
</td></tr>
<tr><td><code id="find_threads_+3A_diagonal">diagonal</code></td>
<td>
<p>Whether to count diagonal elements as valid neighbors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm runs count_neighbors iteratively until no pixel exceeds the trimming threshold <code>min_neighbors</code>
or the maximum number of iterations, <code>maxit</code>, is reached.
</p>
<p>By running iteratively, long tails are trimmed sequentially by pruning the most disconnected voxels.
</p>


<h3>Value</h3>

<p>A logical matrix matrix of the same size as <code>im</code> containing the number of neighboring pixels
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='flood_fill'>This function flood fills a binary image with TRUE for any value of FALSE</h2><span id='topic+flood_fill'></span>

<h3>Description</h3>

<p>This function flood fills a binary image with TRUE for any value of FALSE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="flood_fill_+3A_im">im</code></td>
<td>
<p>A boolean matrix reference representing a binary image</p>
</td></tr>
<tr><td><code id="flood_fill_+3A_x">x</code></td>
<td>
<p>the starting x position for fill</p>
</td></tr>
<tr><td><code id="flood_fill_+3A_y">y</code></td>
<td>
<p>the starting y position for fill</p>
</td></tr>
<tr><td><code id="flood_fill_+3A_r">r</code></td>
<td>
<p>the number of rows in im</p>
</td></tr>
<tr><td><code id="flood_fill_+3A_c">c</code></td>
<td>
<p>the number of columns in im</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function used by geom_outline to clean up outlines
</p>


<h3>Value</h3>

<p>Nothing. The matrix <code>im</code> is modified in place (by reference)
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='geom_brain'>Adds a raster layer to the ggbrain plot, displaying pixels from the specified layer definition</h2><span id='topic+geom_brain'></span>

<h3>Description</h3>

<p>Adds a raster layer to the ggbrain plot, displaying pixels from the specified layer definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_brain(
  definition = NULL,
  name = NULL,
  fill = NULL,
  fill_scale = NULL,
  mapping = NULL,
  limits = NULL,
  breaks = NULL,
  show_legend = TRUE,
  interpolate = FALSE,
  unify_scales = TRUE,
  alpha = NULL,
  blur_edge = NULL,
  fill_holes = NULL,
  remove_specks = NULL,
  trim_threads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_brain_+3A_definition">definition</code></td>
<td>
<p>a character string of the contrast or image definition used to define this layer.
Can be a simple image name (e.g., 'underlay') or a contrast string (e.g., <code>'overlay[overlay &gt; 5]'</code>)</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_name">name</code></td>
<td>
<p>the name of this layer, used for referencing in layer and panel modifications</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_fill">fill</code></td>
<td>
<p>A character string indicating the color used to fill all non-NA pixels in this layer. This is used to set
the fill color, in distinction to color mapping: <code>mapping=aes(fill=&lt;variable&gt;)</code>.</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_fill_scale">fill_scale</code></td>
<td>
<p>a ggplot scale_fill_* object used for mapping the fill column to the color of pixels in this layer.</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_mapping">mapping</code></td>
<td>
<p>the aesthetic mapping of the layer data to the display. Should be an aes() object and supports
<code>fill</code> (color of filled pixels). Default is <code>aes(fill=value)</code>, which maps the numeric value of the layer data
to the fill color of the squares at each spatial position. For labeled data, you might use <code>aes(fill=&lt;label_col_name&gt;)</code>.</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_limits">limits</code></td>
<td>
<p>if provided, sets the upper and lower bounds on the scale</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_breaks">breaks</code></td>
<td>
<p>if provided, a function to draw the breaks on the fill scale</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_show_legend">show_legend</code></td>
<td>
<p>if TRUE, show the fill scale in the plot legend</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_interpolate">interpolate</code></td>
<td>
<p>passes to geom_raster and controls whether the fill is interpolated over continuous space</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_unify_scales">unify_scales</code></td>
<td>
<p>if TRUE, when this layer is reused across panels, unify the scales to match</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_alpha">alpha</code></td>
<td>
<p>a number between 0 and 1 that sets the alpha transparency of this layer. Default: 1</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_blur_edge">blur_edge</code></td>
<td>
<p>the standard deviation (sigma) of a Gaussian kernel applied to the edge of this layer to
smooth it. This makes the layer less jagged in appearance and is akin to antialiasing.</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_fill_holes">fill_holes</code></td>
<td>
<p>An optional positive integer specifying the size of holes (in pixels) inside clusters
to be filled by nearest neighbor imputation. Default: 0.</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_remove_specks">remove_specks</code></td>
<td>
<p>An optional positive integer specifying the size of specks (in pixels) to be removed from each slice prior
to display. Specks are small clusters that may be distracting and contribute to a 'salt and pepper' appearance.</p>
</td></tr>
<tr><td><code id="geom_brain_+3A_trim_threads">trim_threads</code></td>
<td>
<p>the minimum number of neighboring pixels (including diagonals) that must be present to keep a pixel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the fill_scale and limits must be specified at the time of the geom_brain creation
in order for them to be mapped properly within ggplot. Because we overlay many raster layers in a ggplot
object that all use the fill aesthetic mapping, it becomes hard to map the color scales after the layer is
created using the typical + scale_fill_* syntax, and similarly for scale limits.
</p>


<h3>Value</h3>

<p>a ggb object populated with the relevant geom_brainand the action of 'add_layers'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # T1-weighted template
  t1 &lt;- system.file("extdata", "mni_template_2009c_3mm.nii.gz", package = "ggbrain")

  # signed reward prediction error map
  signed_pe &lt;- system.file("extdata", "pe_ptfce_fwep_0.05.nii.gz", package = "ggbrain")
  
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1, overlay = signed_pe)) +
    slices(c("x = 25%", "x = 75%")) +
    geom_brain("underlay") +
    geom_brain(definition="overlay[overlay &gt; 1]", fill_scale=ggplot2::scale_fill_viridis_c("pos z"))
</code></pre>

<hr>
<h2 id='geom_outline'>Adds an outline layer to the ggbrain plot, displaying outlines from the non-missing pixels in the specified layer definition</h2><span id='topic+geom_outline'></span>

<h3>Description</h3>

<p>Adds an outline layer to the ggbrain plot, displaying outlines from the non-missing pixels in the specified layer definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_outline(
  definition = NULL,
  name = NULL,
  outline = NULL,
  outline_scale = NULL,
  mapping = ggplot2::aes(outline = NULL, fill = NULL),
  size = NULL,
  limits = NULL,
  breaks = integer_breaks(),
  show_legend = TRUE,
  interpolate = FALSE,
  unify_scales = TRUE,
  alpha = 1,
  blur_edge = NULL,
  fill_holes = NULL,
  remove_specks = NULL,
  trim_threads = NULL,
  dil_ero = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_outline_+3A_definition">definition</code></td>
<td>
<p>a character string of the contrast or image definition used to define this layer.
Can be a simple image name (e.g., 'underlay') or a contrast string (e.g., <code>'overlay[overlay &gt; 5]'</code>)</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_name">name</code></td>
<td>
<p>the name of this layer, used for referencing in layer and panel modifications</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_outline">outline</code></td>
<td>
<p>A character string indicating the color used to draw outlines in this layer. This is used to set
the outline color, in distinction to outline color mapping: <code>mapping=aes(outline=&lt;variable&gt;)</code>.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_outline_scale">outline_scale</code></td>
<td>
<p>a ggplot scale_fill_* object used for mapping the fill column to the color of pixels in this layer.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_mapping">mapping</code></td>
<td>
<p>the aesthetic mapping of the layer data to the display. Should be an aes() object and supports
<code>outline</code> (outline color of pixels). Default is <code>aes(outline=NULL)</code>, which uses a set outline color.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_size">size</code></td>
<td>
<p>the size of outlines to be drawn in pixel units. Default: 1</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_limits">limits</code></td>
<td>
<p>if provided, sets the upper and lower bounds on the scale</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_breaks">breaks</code></td>
<td>
<p>if provided, a function to draw the breaks on the fill scale</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_show_legend">show_legend</code></td>
<td>
<p>if TRUE, show the fill scale in the plot legend</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_interpolate">interpolate</code></td>
<td>
<p>passes to geom_raster and controls whether the fill is interpolated over continuous space</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_unify_scales">unify_scales</code></td>
<td>
<p>if TRUE, when this layer is reused across panels, unify the scales to match</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_alpha">alpha</code></td>
<td>
<p>a number between 0 and 1 that sets the alpha transparency of this layer. Default: 1</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_blur_edge">blur_edge</code></td>
<td>
<p>the standard deviation (sigma) of a Gaussian kernel applied to the edge of this layer to
smooth it. This makes the layer less jagged in appearance and is akin to antialiasing.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_fill_holes">fill_holes</code></td>
<td>
<p>An optional positive integer specifying the size of holes (in pixels) inside clusters
to be filled by nearest neighbor imputation. Default: 0.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_remove_specks">remove_specks</code></td>
<td>
<p>An optional positive integer specifying the size of specks (in pixels) to be removed from each slice prior
to display. Specks are small clusters that may be distracting and contribute to a 'salt and pepper' appearance.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_trim_threads">trim_threads</code></td>
<td>
<p>the minimum number of neighboring pixels (including diagonals) that must be present to keep a pixel.</p>
</td></tr>
<tr><td><code id="geom_outline_+3A_dil_ero">dil_ero</code></td>
<td>
<p>the number of pixels to dilate (&gt; 0) or erode (&lt; 0) the outline for display purposes. Default: 0L</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the fill_scale and limits must be specified at the time of the geom_brain creation
in order for them to be mapped properly within ggplot. Because we overlay many raster layers in a ggplot
object that all use the fill aesthetic mapping, it becomes hard to map the color scales after the layer is
created using the typical + scale_fill_* syntax, and similarly for scale limits.
</p>


<h3>Value</h3>

<p>a ggb object populated with the geom_outline layer and the action of 'add_layers'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # T1-weighted template
  t1 &lt;- system.file("extdata", "mni_template_2009c_3mm.nii.gz", package = "ggbrain")

  # signed reward prediction error map
  signed_pe &lt;- system.file("extdata", "pe_ptfce_fwep_0.05.nii.gz", package = "ggbrain")
  
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1, overlay = signed_pe)) +
    slices(c("x = 25%", "x = 75%")) +
    geom_brain("underlay") +
    geom_outline(definition="overlay[overlay &gt; 2]", outline="cyan")
</code></pre>

<hr>
<h2 id='geom_region_label'>Variant of geom_label used for plotting region labels on slices</h2><span id='topic+geom_region_label'></span>

<h3>Description</h3>

<p>Variant of geom_label used for plotting region labels on slices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_region_label(image, label_column = "label", min_px = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_region_label_+3A_image">image</code></td>
<td>
<p>The name of the image within the underlying ggbrain_slices object that contains the labeled data positions</p>
</td></tr>
<tr><td><code id="geom_region_label_+3A_label_column">label_column</code></td>
<td>
<p>The column name name for the labels to use within the slice data</p>
</td></tr>
<tr><td><code id="geom_region_label_+3A_min_px">min_px</code></td>
<td>
<p>The minimum number of pixels present on a slice that will result in a text label. Default: 1</p>
</td></tr>
<tr><td><code id="geom_region_label_+3A_...">...</code></td>
<td>
<p>All other parameters passed through to geom_label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant ggbrain_label field and an action of &quot;add_region_labels&quot;
</p>

<hr>
<h2 id='geom_region_label_repel'>Variant of geom_label_repel used for plotting region labels on slices with separation from other labels</h2><span id='topic+geom_region_label_repel'></span>

<h3>Description</h3>

<p>Variant of geom_label_repel used for plotting region labels on slices with separation from other labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_region_label_repel(image, label_column = "label", min_px = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_region_label_repel_+3A_image">image</code></td>
<td>
<p>The name of the image within the underlying ggbrain_slices object that contains the labeled data positions</p>
</td></tr>
<tr><td><code id="geom_region_label_repel_+3A_label_column">label_column</code></td>
<td>
<p>The column name name for the labels to use within the slice data</p>
</td></tr>
<tr><td><code id="geom_region_label_repel_+3A_min_px">min_px</code></td>
<td>
<p>The minimum number of pixels present on a slice that will result in a text label. Default: 1</p>
</td></tr>
<tr><td><code id="geom_region_label_repel_+3A_...">...</code></td>
<td>
<p>All other parameters passed through to geom_label_repel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant ggbrain_label field and an action of &quot;add_region_labels&quot;
</p>

<hr>
<h2 id='geom_region_text'>Variant of geom_text used for plotting region labels on slices</h2><span id='topic+geom_region_text'></span>

<h3>Description</h3>

<p>Variant of geom_text used for plotting region labels on slices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_region_text(image, label_column = "label", min_px = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_region_text_+3A_image">image</code></td>
<td>
<p>The name of the image within the underlying ggbrain_slices object that contains the labeled data positions</p>
</td></tr>
<tr><td><code id="geom_region_text_+3A_label_column">label_column</code></td>
<td>
<p>The column name name for the labels to use within the slice data</p>
</td></tr>
<tr><td><code id="geom_region_text_+3A_min_px">min_px</code></td>
<td>
<p>The minimum number of pixels present on a slice that will result in a text label. Default: 1</p>
</td></tr>
<tr><td><code id="geom_region_text_+3A_...">...</code></td>
<td>
<p>All other parameters passed through to geom_text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant ggbrain_label field and an action of &quot;add_region_labels&quot;
</p>

<hr>
<h2 id='geom_region_text_repel'>Variant of geom_text_repel used for plotting region labels on slices with separation from other labels</h2><span id='topic+geom_region_text_repel'></span>

<h3>Description</h3>

<p>Variant of geom_text_repel used for plotting region labels on slices with separation from other labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_region_text_repel(image, label_column = "label", min_px = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_region_text_repel_+3A_image">image</code></td>
<td>
<p>The name of the image within the underlying ggbrain_slices object that contains the labeled data positions</p>
</td></tr>
<tr><td><code id="geom_region_text_repel_+3A_label_column">label_column</code></td>
<td>
<p>The column name name for the labels to use within the slice data</p>
</td></tr>
<tr><td><code id="geom_region_text_repel_+3A_min_px">min_px</code></td>
<td>
<p>The minimum number of pixels present on a slice that will result in a text label. Default: 1</p>
</td></tr>
<tr><td><code id="geom_region_text_repel_+3A_...">...</code></td>
<td>
<p>All other parameters passed through to geom_text_repel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant ggbrain_label field and an action of &quot;add_region_labels&quot;
</p>

<hr>
<h2 id='ggb'>Generic R6 base class that is used to support + semantics</h2><span id='topic+ggb'></span>

<h3>Description</h3>

<p>Generic R6 base class that is used to support + semantics
</p>
<p>Generic R6 base class that is used to support + semantics
</p>


<h3>Details</h3>

<p>this object becomes a simple storage class that contains all relevant objects
(e.g., ggbrain_images) required to generate a brain plot
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ggb_images</code></dt><dd><p>ggbrain_images object for this plot</p>
</dd>
<dt><code>ggb_image_labels</code></dt><dd><p>a named list of data.frames that label corresponding images</p>
</dd>
<dt><code>ggb_slices</code></dt><dd><p>list slices to extract for this plot</p>
</dd>
<dt><code>ggb_contrasts</code></dt><dd><p>a character vector of contrasts to be computed as part of this plot</p>
</dd>
<dt><code>ggb_layers</code></dt><dd><p>a list of ggbrain_layer objects containing the bottom-to-top layers to be plotted</p>
</dd>
<dt><code>ggb_plot</code></dt><dd><p>a ggbrain_plot object containing the specification of the plot</p>
</dd>
<dt><code>ggb_annotations</code></dt><dd><p>a list of annotation objects</p>
</dd>
<dt><code>ggb_region_labels</code></dt><dd><p>a list of ggbrain_label objects to be added as text to label regions</p>
</dd>
<dt><code>action</code></dt><dd><p>what should this ggb object contribute to another when added with it?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggb-new"><code>ggb$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-add_layers"><code>ggb$add_layers()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-add_slices"><code>ggb$add_slices()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-add_contrasts"><code>ggb$add_contrasts()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-add_annotations"><code>ggb$add_annotations()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-add_image_labels"><code>ggb$add_image_labels()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-add_region_labels"><code>ggb$add_region_labels()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-render"><code>ggb$render()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-plot"><code>ggb$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ggb-clone"><code>ggb$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggb-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a new ggb object. Note that inputs are always cloned to avoid
unintended modify-in-place behaviors of R6 classes.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$new(
  images = NULL,
  slices = NULL,
  contrasts = NULL,
  layers = NULL,
  labels = NULL,
  annotations = NULL,
  region_labels = NULL,
  title = NULL,
  bg_color = NULL,
  text_color = NULL,
  base_size = NULL,
  action = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>images</code></dt><dd><p>a ggbrain_images object containing relevant images</p>
</dd>
<dt><code>slices</code></dt><dd><p>a character vector of slices to extract</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>a character vector of contrasts to define and compute</p>
</dd>
<dt><code>layers</code></dt><dd><p>a list of ggbrain_layer objects</p>
</dd>
<dt><code>labels</code></dt><dd><p>a list of data.frames with labels that align with one or more images</p>
</dd>
<dt><code>annotations</code></dt><dd><p>a list of data.frames with annotations that will be added to specific slices</p>
</dd>
<dt><code>region_labels</code></dt><dd><p>a list of ggbrain_label objects with text-based labels to be drawn on the plot</p>
</dd>
<dt><code>title</code></dt><dd><p>overall title of the plot</p>
</dd>
<dt><code>bg_color</code></dt><dd><p>the background color of the overall plot</p>
</dd>
<dt><code>text_color</code></dt><dd><p>the text color of the overall plot</p>
</dd>
<dt><code>base_size</code></dt><dd><p>the base size of text on the plot</p>
</dd>
<dt><code>action</code></dt><dd><p>the action to be taken when adding this object to an existing ggb</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-add_layers"></a>



<h4>Method <code>add_layers()</code></h4>

<p>add layers from another ggb object to this one
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$add_layers(ilist)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ilist</code></dt><dd><p>a list of ggbrain_layer objects. If a ggb object is passed, we
will get this list from obj$ggb_layers</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-add_slices"></a>



<h4>Method <code>add_slices()</code></h4>

<p>add slices to the existing vector of slices
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$add_slices(slices = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slices</code></dt><dd><p>a character vector of slices to be appended to the existing slices</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-add_contrasts"></a>



<h4>Method <code>add_contrasts()</code></h4>

<p>add contrast definitions to the plot object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$add_contrasts(contrasts)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>contrasts</code></dt><dd><p>a character vector of contrasts to compute as part of the plot generation</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-add_annotations"></a>



<h4>Method <code>add_annotations()</code></h4>

<p>add annotations to panels
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$add_annotations(annotations = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>annotations</code></dt><dd><p>a list or data.frame containing the annotations to add to each panel. Minimally,
the list or data.frame must contain <code>position</code> and <code>label</code> columns that define the position
and text to be added. Other arguments that pass through to ggplot2::annotate() can be provided as columns/elements
in <code>annotations</code> and these will be passed through to annotate</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-add_image_labels"></a>



<h4>Method <code>add_image_labels()</code></h4>

<p>add labels to a given image
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$add_image_labels(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>a named list of arguments where each is a data.frame with labels denoting corresponding images</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-add_region_labels"></a>



<h4>Method <code>add_region_labels()</code></h4>

<p>add a list of ggbrain_label objects to the overall ggb for compiling a plot
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$add_region_labels(labels = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>labels</code></dt><dd><p>a list of data.frames with region labels that should be plotted on each slice. This is generated
internally by ggbrain_images$get_slices() in the $slice_labels field.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-render"></a>



<h4>Method <code>render()</code></h4>

<p>this method converts the ggb object into a compiled ggplot2 object that can then be passed to other
functions from cowplot, ggplot2, and patchwork. Once the object is rendered, it no longer retains the underlying ggb
fields that contain the elemental data.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$render(guides = "collect")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>guides</code></dt><dd><p>Passes through to patchwork::plot_layout to control how legends are combined across plots. The default
is &quot;collect&quot;, which collects legends within a given nesting level (removes duplicates).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggb-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>plot this ggb object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$plot(guides = "collect")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>guides</code></dt><dd><p>Passes through to patchwork::plot_layout to control how legends are combined across plots. The default
is &quot;collect&quot;, which collects legends within a given nesting level (removes duplicates).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>requires that required elements are in place already.
</p>


<hr>
<a id="method-ggb-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggb$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain'>create ggb container object for a given plot</h2><span id='topic+ggbrain'></span>

<h3>Description</h3>

<p>create ggb container object for a given plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbrain(
  images = NULL,
  slices = NULL,
  title = NULL,
  bg_color = "grey8",
  text_color = "grey92",
  base_size = 14
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbrain_+3A_images">images</code></td>
<td>
<p>a character vector or existing ggbrain_images object defining which
images should be included in this plot</p>
</td></tr>
<tr><td><code id="ggbrain_+3A_slices">slices</code></td>
<td>
<p>a set of slices to be added to the plot</p>
</td></tr>
<tr><td><code id="ggbrain_+3A_title">title</code></td>
<td>
<p>the overall title to be added to the plot</p>
</td></tr>
<tr><td><code id="ggbrain_+3A_bg_color">bg_color</code></td>
<td>
<p>The background color of the overall plot</p>
</td></tr>
<tr><td><code id="ggbrain_+3A_text_color">text_color</code></td>
<td>
<p>The default text color of the overall plot (passes through to panels)</p>
</td></tr>
<tr><td><code id="ggbrain_+3A_base_size">base_size</code></td>
<td>
<p>The base size of fonts used in the plot (cf. <code>theme_minimal</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object containing basic information for a <code>ggbrain</code> plot such as background color,
text color, and font size
</p>

<hr>
<h2 id='ggbrain_images'>R6 class for compiling images to render in ggplot</h2><span id='topic+ggbrain_images'></span>

<h3>Description</h3>

<p>R6 class for compiling images to render in ggplot
</p>
<p>R6 class for compiling images to render in ggplot
</p>


<h3>Details</h3>

<p>Note that this class is exported only for power users and rarely needs to be called directly
in typical use of the package. Instead, look at images().
</p>


<h3>Value</h3>

<p>a <code>ggbrain_images</code> R6 class containing fields related to a set of NIfTI images imported into R
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>zero_tol</code></dt><dd><p>the (positive) numeric value that should be treated as indistinguishable from zero.
This value is used to set small values in the images to exactly zero for proper masking. Default 1e-6</p>
</dd>
<dt><code>slices</code></dt><dd><p>a character vector of cached slice specifications to be used in $get_slices()</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>a character vector of cached contrast specifications to be used in $get_slices()</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_images-new"><code>ggbrain_images$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-add"><code>ggbrain_images$add()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-add_labels"><code>ggbrain_images$add_labels()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-add_images"><code>ggbrain_images$add_images()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-filter_images"><code>ggbrain_images$filter_images()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-dim"><code>ggbrain_images$dim()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_image_names"><code>ggbrain_images$get_image_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_images"><code>ggbrain_images$get_images()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_headers"><code>ggbrain_images$get_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-remove_images"><code>ggbrain_images$remove_images()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-winsorize_images"><code>ggbrain_images$winsorize_images()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-na_images"><code>ggbrain_images$na_images()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-summary"><code>ggbrain_images$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_nz_indices"><code>ggbrain_images$get_nz_indices()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-add_slices"><code>ggbrain_images$add_slices()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-add_contrasts"><code>ggbrain_images$add_contrasts()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-reset_slices"><code>ggbrain_images$reset_slices()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_slices"><code>ggbrain_images$get_slices()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_slices_inplane"><code>ggbrain_images$get_slices_inplane()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-get_labels"><code>ggbrain_images$get_labels()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-lookup_slices"><code>ggbrain_images$lookup_slices()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_images-clone"><code>ggbrain_images$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggbrain_images-new"></a>



<h4>Method <code>new()</code></h4>

<p>create ggbrain_images object consisting of one or more NIfTI images
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$new(images = NULL, volumes = NULL, labels = NULL, filter = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>images</code></dt><dd><p>a character vector of file names containing NIfTI images to read</p>
</dd>
<dt><code>volumes</code></dt><dd><p>the volumes to be read from each element of <code>images</code>. By default, this is 1, in which case the first volume is
used, which is appropriate for all 3-D images. For 4-D images, <code>volumes</code> gives you more flexibility over the volume to display.</p>
</dd>
<dt><code>labels</code></dt><dd><p>A named list of data.frames with labels that map to values in the integer-valued/atlas elements of <code>images</code>. If
a single data.frame is passed, it will be accepted if only a single image is passed, too. These are then assumed to correspond</p>
</dd>
<dt><code>filter</code></dt><dd><p>A named list of filter expressions to be applied to particular images. The names of the list correspond to the names
of the <code>images</code> provided. Each element of the list can either be a character vector denoting a filtering expression
(e.g., <code>'value &lt; 100'</code>) or a numeric vector denoting values of the image that should be retained (e.g., <code>c(5, 10, 12)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-add"></a>



<h4>Method <code>add()</code></h4>

<p>method to add another ggbrain_images object to this one
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$add(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>the ggbrain_images object to combine with this one</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-add_labels"></a>



<h4>Method <code>add_labels()</code></h4>

<p>add a labels data.frame that connects an integer-valued image with a set of labels
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$add_labels(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>named arguments containing data.frame objects for each image to be labeled. The argument name should
match the image name to be labeled and the value should be a data.frame containing <code>value</code> and <code>label</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>As a result of $add_labels, the $get_slices method will always remap the numeric values for label images to the corresponding
text-based labels in the label data. In addition, a new attribute will be returned called &quot;slice_labels&quot; that contains
a row for each region represented in each slice.
</p>


<hr>
<a id="method-ggbrain_images-add_images"></a>



<h4>Method <code>add_images()</code></h4>

<p>add one or more images to this ggbrain_images object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$add_images(images = NULL, volumes = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>images</code></dt><dd><p>a character vector of file names containing NIfTI images to read</p>
</dd>
<dt><code>volumes</code></dt><dd><p>a number indicating the volume within the <code>images</code> to read. At present, this must
be a single number &ndash; perhaps in the future, it could be a vector so that many timepoints in a 4-D image could
be displayed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-filter_images"></a>



<h4>Method <code>filter_images()</code></h4>

<p>filters an image based on an expression such as a subsetting operation
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$filter_images(filter = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filter</code></dt><dd><p>a character string or numeric vector of the filter to apply</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>if expr is a numeric vector, only values in this set will be retained. If a character
string expression is used, it should use the variable name <code>'value'</code> to refer to the numeric
values to be filtered, such as <code>'value &gt; 10'</code>.
</p>


<hr>
<a id="method-ggbrain_images-dim"></a>



<h4>Method <code>dim()</code></h4>

<p>return the 3D dimensions of the images contained in this object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$dim()</pre></div>


<hr>
<a id="method-ggbrain_images-get_image_names"></a>



<h4>Method <code>get_image_names()</code></h4>

<p>return the names of the images contained in this object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_image_names()</pre></div>


<hr>
<a id="method-ggbrain_images-get_images"></a>



<h4>Method <code>get_images()</code></h4>

<p>return the RNifti objects of one or more images contained in this object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_images(img_names = NULL, drop = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_names</code></dt><dd><p>The names of images to return. Use <code>$get_image_names()</code> if you're uncertain
about what is available.</p>
</dd>
<dt><code>drop</code></dt><dd><p>If TRUE, a single image is returned as an RNifti object, rather than a single-element list
containing that object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-get_headers"></a>



<h4>Method <code>get_headers()</code></h4>

<p>return the NIfTI headers for one or more images contained in this object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_headers(img_names = NULL, drop = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_names</code></dt><dd><p>The names of images whose header are returned. Use <code>$get_image_names()</code> if you're uncertain
about what is available.</p>
</dd>
<dt><code>drop</code></dt><dd><p>If TRUE, a single header is returned as an niftiHeader object, rather than a single-element list
containing that object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-remove_images"></a>



<h4>Method <code>remove_images()</code></h4>

<p>method for removing one or more images from the ggbrain_images object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$remove_images(img_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_names</code></dt><dd><p>names of images to remove from object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-winsorize_images"></a>



<h4>Method <code>winsorize_images()</code></h4>

<p>winsorize the tails of a set of images to pull in extreme values
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$winsorize_images(img_names, quantiles = c(0.001, 0.999))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_names</code></dt><dd><p>The names of images in the ggbrain_images object to be winsorized</p>
</dd>
<dt><code>quantiles</code></dt><dd><p>The lower and upper quantiles used to define the thresholds for winsorizing.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-na_images"></a>



<h4>Method <code>na_images()</code></h4>

<p>method to set values less than <code>threshold</code> to NA
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$na_images(img_names, threshold = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_names</code></dt><dd><p>The names of images in the ggbrain_images object whose values should be set to NA</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The threshold value whose absolute value used to determine which voxels to set to NA.
If <code>NULL</code>, use the pvt_zero_tol field (default 1e-6).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>print a summary of the ggbrain_images object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$summary()</pre></div>


<hr>
<a id="method-ggbrain_images-get_nz_indices"></a>



<h4>Method <code>get_nz_indices()</code></h4>

<p>return the indices of non-zero voxels
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_nz_indices(img_names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_names</code></dt><dd><p>The names of images in the ggbrain_images object whose non-zero indices should be looked up</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Note that this function looks for non-zero voxels in any of the images specified by <code>img_names</code>.
</p>


<hr>
<a id="method-ggbrain_images-add_slices"></a>



<h4>Method <code>add_slices()</code></h4>

<p>adds one or more slices to the cached slices that will be retrieved by
$get_slices() when no <code>slices</code> argument is passed.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$add_slices(slices = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slices</code></dt><dd><p>a character vector containing one or more slices to be extracted by <code>$get_slices</code>.
Uses the syntax <code>"&lt;xyz&gt;=&lt;number&gt;"</code>. Example: <code>c("x=10", "y=50%")</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-add_contrasts"></a>



<h4>Method <code>add_contrasts()</code></h4>

<p>adds one or more contrasts to the cached contrasts that will be retrieved by
$get_slices() when no <code>contrasts</code> argument is passed.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$add_contrasts(contrasts = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>contrasts</code></dt><dd><p>a character vector containing one or more contrasts to be extracted by <code>$get_slices</code>.
Uses the syntax <code>"&lt;img_name&gt;[subset_expression] + &lt;img_name&gt;"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-reset_slices"></a>



<h4>Method <code>reset_slices()</code></h4>

<p>remove all cached slice settings
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$reset_slices()</pre></div>


<hr>
<a id="method-ggbrain_images-get_slices"></a>



<h4>Method <code>get_slices()</code></h4>

<p>get slice data for one or more slices based on their coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_slices(
  slices = NULL,
  img_names = NULL,
  contrasts = NULL,
  fill_labels = FALSE,
  make_square = TRUE,
  remove_null_space = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slices</code></dt><dd><p>a vector of slice positions</p>
</dd>
<dt><code>img_names</code></dt><dd><p>a character vector of images contained in the ggbrain_images object to be sliced</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>a named character vector of contrasts to be calculated for each slice</p>
</dd>
<dt><code>fill_labels</code></dt><dd><p>if TRUE, the numeric value of the image will be used for any value that does not
have a corresponding label in the labels data.frame. Default: FALSE</p>
</dd>
<dt><code>make_square</code></dt><dd><p>If TRUE, make all images square and of the same size</p>
</dd>
<dt><code>remove_null_space</code></dt><dd><p>If TRUE, remove slices where all values are approximately zero</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function always returns a data.frame where each row represents a slice requested
by the user. The $slice_data element is a list-column where each element is itself a list
of slice data for a given layer/image (e.g., underlay or overlay) . The $slice_matrix
is a list-column where each element is a list of 2-D matrices, one per layer/image.
@return a ggbrain_slices object containing the requested slices and contrasts
</p>


<hr>
<a id="method-ggbrain_images-get_slices_inplane"></a>



<h4>Method <code>get_slices_inplane()</code></h4>

<p>get_slices_inplane is mostly an internal funciton for getting one or more slices from a given plane
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_slices_inplane(
  imgs = NULL,
  slice_numbers,
  plane,
  drop = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>imgs</code></dt><dd><p>The names of images to slice</p>
</dd>
<dt><code>slice_numbers</code></dt><dd><p>The numbers of slices in the specified plant to grab</p>
</dd>
<dt><code>plane</code></dt><dd><p>The image plane to slice. Must be &quot;coronal&quot;, &quot;sagittal&quot;, or &quot;axial&quot;</p>
</dd>
<dt><code>drop</code></dt><dd><p>if TRUE, a single slice is returned as a 2D matrix instead of a 3D matrix with a singleton first dimension</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A 3D matrix of slices x dim1 x dim2
</p>


<hr>
<a id="method-ggbrain_images-get_labels"></a>



<h4>Method <code>get_labels()</code></h4>

<p>return a list of data.frames containing labels for a given image
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$get_labels()</pre></div>



<h5>Details</h5>

<p>the names of the list correspond directly with the names of the images
</p>


<hr>
<a id="method-ggbrain_images-lookup_slices"></a>



<h4>Method <code>lookup_slices()</code></h4>

<p>internal function to lookup which slices to display along each axis based on their quantile,
xyz coordinate, or ijk coordinate
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$lookup_slices(slices, ignore_null_space = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slices</code></dt><dd><p>A character vector of coordinates for slices to display</p>
</dd>
<dt><code>ignore_null_space</code></dt><dd><p>If TRUE, any coordinates specified as quantiles (e.g., x = 50%)
use the quantiles of only the non-zero slices (ignoring blank sliaces)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_images-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_images$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_label'>R6 class for adding labels to a ggbrain_panel</h2><span id='topic+ggbrain_label'></span>

<h3>Description</h3>

<p>R6 class for adding labels to a ggbrain_panel
</p>
<p>R6 class for adding labels to a ggbrain_panel
</p>


<h3>Value</h3>

<p>a <code>ggbrain_label</code> R6 class containing fields related to ggbrain plot labels
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>addl_args</code></dt><dd><p>a named list of additional argument to be passed to geom_text/geom_label at render</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>data</code></dt><dd><p>a data.frame containing labels to be printed on the panel. Must contain dim1, dim2, and label as columns.
The dim1 and dim2 columns control where the labels will appear on the panel</p>
</dd>
<dt><code>image</code></dt><dd><p>A character string specifying the image to which these labels pertain</p>
</dd>
<dt><code>label_column</code></dt><dd><p>A character string indicating which data.frame column should be used for drawing labels</p>
</dd>
<dt><code>min_px</code></dt><dd><p>A positive integer indicating the minimum number of pixels present on slice that will generate a label</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_label-new"><code>ggbrain_label$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_label-add_to_gg"><code>ggbrain_label$add_to_gg()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_label-clone"><code>ggbrain_label$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggbrain_label-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a new ggbrain_label object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_label$new(
  data = NULL,
  geom = "text",
  image = NULL,
  label_column = NULL,
  min_px = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a data.frame containing labels to be printed on the panel. Must contain dim1, dim2, and label as columns.
The dim1 and dim2 columns control where the labels will appear on the panel</p>
</dd>
<dt><code>geom</code></dt><dd><p>The geom type to be plotted. Must be &quot;text&quot; or &quot;label&quot;, corresponding to geom_text and geom_label, respectively.</p>
</dd>
<dt><code>image</code></dt><dd><p>A string specifying the image to which these labels pertain</p>
</dd>
<dt><code>label_column</code></dt><dd><p>the column in <code>data</code> that should be drawn as labels on the plot</p>
</dd>
<dt><code>min_px</code></dt><dd><p>the minimum number of pixels</p>
</dd>
<dt><code>...</code></dt><dd><p>All other arguments that will be passed directly to geom_text or geom_label such as hjust, size, and color</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_label-add_to_gg"></a>



<h4>Method <code>add_to_gg()</code></h4>

<p>add this text layer to an existing ggplot object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_label$add_to_gg(base_gg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_gg</code></dt><dd><p>the ggplot object to which we add the layer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_label-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_label$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_layer'>R6 class for a single layer of a ggbrain panel</h2><span id='topic+ggbrain_layer'></span>

<h3>Description</h3>

<p>R6 class for a single layer of a ggbrain panel
</p>
<p>R6 class for a single layer of a ggbrain panel
</p>


<h3>Details</h3>

<p>Note that this class is exported only for power users and rarely needs to be called directly
in typical use of the package. Instead, look at geom_brain() and geom_outline().
</p>


<h3>Value</h3>

<p>a <code>ggbrain_layer</code> R6 class containing fields related to a visual layer on the <code>ggbrain</code> plot
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>name</code></dt><dd><p>the name of this layer, used for referencing in layer and panel modifications</p>
</dd>
<dt><code>all_na</code></dt><dd><p>whether all values for this layer are NA in the <code>data</code> field</p>
</dd>
<dt><code>definition</code></dt><dd><p>a character string specifying the image name or contrast that defines this layer</p>
</dd>
<dt><code>source</code></dt><dd><p>a character string specifying the layer source within a relevant ggbrain_slices object.
This is used to lookup the right layer information when combining slices and layers together
Note that multiple layers can potentially have the same source, which is why a 1:1 mapping to name does not work</p>
</dd>
<dt><code>data</code></dt><dd><p>the data.frame containing relevant data for this layer.</p>
</dd>
<dt><code>show_legend</code></dt><dd><p>a logical indicating whether to show or hide the fill/color scale</p>
</dd>
<dt><code>unify_scales</code></dt><dd><p>a logical indicating whether to unify scale limits and levels when this layer
is added across many panels</p>
</dd>
<dt><code>bisided</code></dt><dd><p>read-only access to whether this layer uses a bisided color scale</p>
</dd>
<dt><code>categorical_fill</code></dt><dd><p>read-only access to whether this layer has a categorical fill scale</p>
</dd>
<dt><code>fill_column</code></dt><dd><p>read-only access to layer fill column</p>
</dd>
<dt><code>fill_scale</code></dt><dd><p>a scale_fill_* object containing the ggplot2 fill scale for this layer</p>
</dd>
<dt><code>alpha</code></dt><dd><p>sets the alpha transparency of this layer.</p>
</dd>
<dt><code>blur_edge</code></dt><dd><p>controls the standard deviation (sigma) of a Gaussian blur applied to the layer at the edge</p>
</dd>
<dt><code>trim_threads</code></dt><dd><p>iteratively trim any pixels that have fewer than this number of neighboring pixels</p>
</dd>
<dt><code>fill_holes</code></dt><dd><p>controls the size of holes to be filled for display (in pixels)</p>
</dd>
<dt><code>remove_specks</code></dt><dd><p>controls the size of specks to be removed (in pixels)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_layer-new"><code>ggbrain_layer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-set_limits"><code>ggbrain_layer$set_limits()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-set_pos_limits"><code>ggbrain_layer$set_pos_limits()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-set_neg_limits"><code>ggbrain_layer$set_neg_limits()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-set_breaks"><code>ggbrain_layer$set_breaks()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-set_pos_breaks"><code>ggbrain_layer$set_pos_breaks()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-set_neg_breaks"><code>ggbrain_layer$set_neg_breaks()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-plot"><code>ggbrain_layer$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-add_to_gg"><code>ggbrain_layer$add_to_gg()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-get_data"><code>ggbrain_layer$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-is_empty"><code>ggbrain_layer$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer-clone"><code>ggbrain_layer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggbrain_layer-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a new ggbrain_layer object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$new(
  name = NULL,
  definition = NULL,
  limits = NULL,
  breaks = integer_breaks(),
  show_legend = TRUE,
  interpolate = NULL,
  unify_scales = TRUE,
  alpha = NULL,
  blur_edge = NULL,
  fill_holes = NULL,
  remove_specks = NULL,
  trim_threads = NULL,
  data = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of this layer, used for referencing in layer and panel modifications</p>
</dd>
<dt><code>definition</code></dt><dd><p>an optional character string defining the image or contrast that should be used
to lookup data from a ggbrain_slices object. This is mostly used internally by the ggbrain + syntax
to allow layers to be defined without data in advance of the plot.</p>
</dd>
<dt><code>limits</code></dt><dd><p>if provided, sets the upper and lower bounds on the scale</p>
</dd>
<dt><code>breaks</code></dt><dd><p>if provided, a function to draw the breaks on the color scale</p>
</dd>
<dt><code>show_legend</code></dt><dd><p>if TRUE, show the scale on the plot legend</p>
</dd>
<dt><code>interpolate</code></dt><dd><p>passes to geom_raster and controls whether the fill is interpolated over continuous space</p>
</dd>
<dt><code>unify_scales</code></dt><dd><p>if TRUE, when this layer is reused across panels, unify the scales to match</p>
</dd>
<dt><code>alpha</code></dt><dd><p>fixed alpha transparency of this layer (use <code>mapping</code> for alpha mapping')</p>
</dd>
<dt><code>blur_edge</code></dt><dd><p>the standard deviation (sigma) of a Gaussian kernel applied to the edge of this layer to
smooth it. This makes the layer less jagged in appearance and is akin to antialiasing.</p>
</dd>
<dt><code>fill_holes</code></dt><dd><p>the size of holes (in pixels) inside clusters to be filled by nearest neighbor imputation prior to display</p>
</dd>
<dt><code>remove_specks</code></dt><dd><p>the size of specks (in pixels) to be removed from each slice prior to display</p>
</dd>
<dt><code>trim_threads</code></dt><dd><p>the minimum number of neighboring pixels (including diagonals) that must be present to keep a pixel</p>
</dd>
<dt><code>data</code></dt><dd><p>the data.frame containing image data for this layer. Must contain &quot;dim1&quot;, &quot;dim2&quot;,
and &quot;value&quot; as columns</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-set_limits"></a>



<h4>Method <code>set_limits()</code></h4>

<p>set the limits for this layer's scale
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$set_limits(limits)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>limits</code></dt><dd><p>a 2-element numeric vector setting the lower and upper limits on the layer's scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-set_pos_limits"></a>



<h4>Method <code>set_pos_limits()</code></h4>

<p>set the limits for this layer's positive scale (only relevant to bisided)
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$set_pos_limits(limits)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>limits</code></dt><dd><p>a 2-element numeric vector setting the lower and upper limits on the layer's positive scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-set_neg_limits"></a>



<h4>Method <code>set_neg_limits()</code></h4>

<p>set the limits for this layer's positive scale (only relevant to bisided)
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$set_neg_limits(limits)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>limits</code></dt><dd><p>a 2-element numeric vector setting the lower and upper limits on the layer's positive scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-set_breaks"></a>



<h4>Method <code>set_breaks()</code></h4>

<p>set the breaks element of this layer's scale
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$set_breaks(breaks)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>breaks</code></dt><dd><p>a function used to label the breaks</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-set_pos_breaks"></a>



<h4>Method <code>set_pos_breaks()</code></h4>

<p>set the breaks element of this layer's positive scale (only relevant to bisided)
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$set_pos_breaks(breaks)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>breaks</code></dt><dd><p>a function used to label the positive breaks</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-set_neg_breaks"></a>



<h4>Method <code>set_neg_breaks()</code></h4>

<p>set the breaks element of this layer's negative scale (only relevant to bisided)
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$set_neg_breaks(breaks)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>breaks</code></dt><dd><p>a function used to label the negative breaks</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>plot this layer alone (mostly for debugging)
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$plot()</pre></div>


<hr>
<a id="method-ggbrain_layer-add_to_gg"></a>



<h4>Method <code>add_to_gg()</code></h4>

<p>method to add this layer to an existing ggplot object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$add_to_gg(base_gg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_gg</code></dt><dd><p>the ggplot object to which we add the layer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>return the data.frame associated with this layer
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$get_data(add_layer_name = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_layer_name</code></dt><dd><p>if TRUE, adds a <code>layer_name</code> column to the data.frame for record-keeping.
Default: FALSE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_layer-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>returns TRUE if all values are NA or if the data has 0 rows
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$is_empty()</pre></div>


<hr>
<a id="method-ggbrain_layer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_layer_brain'>R6 class for a single layer of a ggbrain panel using fill geom</h2><span id='topic+ggbrain_layer_brain'></span>

<h3>Description</h3>

<p>R6 class for a single layer of a ggbrain panel using fill geom
</p>
<p>R6 class for a single layer of a ggbrain panel using fill geom
</p>


<h3>Details</h3>

<p>Note that this class is exported only for power users and rarely needs to be called directly
in typical use of the package. Instead, look at <code>geom_brain()</code>.
</p>


<h3>Value</h3>

<p>a <code>ggbrain_layer_brain</code> R6 class with fields related to a brain visual layer (relates to <code>geom_brain</code>)
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ggbrain_layer">ggbrain::ggbrain_layer</a></code> -&gt; <code>ggbrain_layer_brain</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>fill</code></dt><dd><p>controls color of the filled in pixels for non-NA (valid) voxels. Note that this
<strong>sets</strong> the fill color, while the <code>mapping=aes(fill=&lt;value&gt;)</code> would <strong>map</strong> the fill to a column
in the data, consistent with ggplot2 logic.</p>
</dd>
<dt><code>mapping</code></dt><dd><p>the ggplot2 aesthetic mapping between the data columns and the display</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_layer_brain-new"><code>ggbrain_layer_brain$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer_brain-clone"><code>ggbrain_layer_brain$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="add_to_gg"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-add_to_gg'><code>ggbrain::ggbrain_layer$add_to_gg()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="get_data"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-get_data'><code>ggbrain::ggbrain_layer$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="is_empty"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-is_empty'><code>ggbrain::ggbrain_layer$is_empty()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="plot"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-plot'><code>ggbrain::ggbrain_layer$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_breaks"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_breaks'><code>ggbrain::ggbrain_layer$set_breaks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_limits"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_limits'><code>ggbrain::ggbrain_layer$set_limits()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_neg_breaks"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_neg_breaks'><code>ggbrain::ggbrain_layer$set_neg_breaks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_neg_limits"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_neg_limits'><code>ggbrain::ggbrain_layer$set_neg_limits()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_pos_breaks"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_pos_breaks'><code>ggbrain::ggbrain_layer$set_pos_breaks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_pos_limits"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_pos_limits'><code>ggbrain::ggbrain_layer$set_pos_limits()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ggbrain_layer_brain-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a new ggbrain_layer object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer_brain$new(
  name = NULL,
  definition = NULL,
  limits = NULL,
  breaks = integer_breaks(),
  show_legend = TRUE,
  interpolate = NULL,
  unify_scales = TRUE,
  alpha = NULL,
  mapping = ggplot2::aes(fill = value),
  fill = NULL,
  fill_scale = NULL,
  blur_edge = NULL,
  fill_holes = NULL,
  remove_specks = NULL,
  trim_threads = NULL,
  data = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of this layer, used for referencing in layer and panel modifications</p>
</dd>
<dt><code>definition</code></dt><dd><p>an optional character string defining the image or contrast that should be used
to lookup data from a ggbrain_slices object. This is mostly used internally by the ggbrain + syntax
to allow layers to be defined without data in advance of the plot.</p>
</dd>
<dt><code>limits</code></dt><dd><p>if provided, sets the upper and lower bounds on the scale</p>
</dd>
<dt><code>breaks</code></dt><dd><p>if provided, a function to draw the breaks on the color scale</p>
</dd>
<dt><code>show_legend</code></dt><dd><p>if TRUE, show the scale on the plot legend</p>
</dd>
<dt><code>interpolate</code></dt><dd><p>passes to geom_raster and controls whether the fill is interpolated over continuous space</p>
</dd>
<dt><code>unify_scales</code></dt><dd><p>if TRUE, when this layer is reused across panels, unify the scales to match</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a number between 0 and 1 that sets the alpha transparency of this layer. Default: 1</p>
</dd>
<dt><code>mapping</code></dt><dd><p>the aesthetic mapping of the layer data to the display. Should be an aes() object and supports
<code>fill</code> (color of filled pixels). Default is <code>aes(fill=value)</code>, which maps the numeric value of the layer data
to the fill color of the squares at each spatial position. For labeled data, you might use <code>aes(fill=&lt;label_col_name&gt;)</code>.</p>
</dd>
<dt><code>fill</code></dt><dd><p>A character string indicating the color used to fill all non-NA pixels in this layer. This is used in
distinction to <code>mapping=aes(fill=&lt;variable&gt;)</code>.</p>
</dd>
<dt><code>fill_scale</code></dt><dd><p>a ggplot scale object used for mapping the value column as the fill color for the
layer.</p>
</dd>
<dt><code>blur_edge</code></dt><dd><p>the standard deviation (sigma) of a Gaussian kernel applied to the edge of this layer to
smooth it. This makes the layer less jagged in appearance and is akin to antialiasing.</p>
</dd>
<dt><code>fill_holes</code></dt><dd><p>the size of holes (in pixels) inside clusters to be filled by nearest neighbor imputation prior to display</p>
</dd>
<dt><code>remove_specks</code></dt><dd><p>the size of specks (in pixels) to be removed from each slice prior to display</p>
</dd>
<dt><code>trim_threads</code></dt><dd><p>the minimum number of neighboring pixels (including diagonals) that must be present to keep a pixel</p>
</dd>
<dt><code>data</code></dt><dd><p>the data.frame containing image data for this layer. Must contain &quot;dim1&quot;, &quot;dim2&quot;,
and &quot;value&quot; as columns</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>To set mapping, you must provide a ggplot2 aes() object. A geom_brain() layer requires
a <code>fill</code> aesthetic mapping, which controls the fill color of regions.
</p>


<hr>
<a id="method-ggbrain_layer_brain-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer_brain$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_layer_outline'>R6 class for a single layer of a ggbrain panel using outline geom</h2><span id='topic+ggbrain_layer_outline'></span>

<h3>Description</h3>

<p>R6 class for a single layer of a ggbrain panel using outline geom
</p>
<p>R6 class for a single layer of a ggbrain panel using outline geom
</p>


<h3>Details</h3>

<p>Note that this class is exported only for power users and rarely needs to be called directly
in typical use of the package. Instead, look at <code>geom_outline()</code>.
</p>


<h3>Value</h3>

<p>a <code>ggbrain_layer_outline</code> R6 class with fields related to a brain visual layer (relates to <code>geom_outline</code>)
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ggbrain_layer">ggbrain::ggbrain_layer</a></code> -&gt; <code>ggbrain_layer_outline</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mapping</code></dt><dd><p>the ggplot2 aesthetic mapping between the data columns and the display</p>
</dd>
<dt><code>outline</code></dt><dd><p>controls color of outline draw around non-NA (valid) voxels</p>
</dd>
<dt><code>outline_scale</code></dt><dd><p>a scale_fill_* object containing the ggplot2 outline color scale for this layer</p>
</dd>
<dt><code>size</code></dt><dd><p>controls size of outline drawn around non-NA (valid) voxels</p>
</dd>
<dt><code>dil_ero</code></dt><dd><p>controls the number of pixels to dilate (&gt; 0) or erode (&lt; 0) the outline</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_layer_outline-new"><code>ggbrain_layer_outline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_layer_outline-clone"><code>ggbrain_layer_outline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="add_to_gg"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-add_to_gg'><code>ggbrain::ggbrain_layer$add_to_gg()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="get_data"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-get_data'><code>ggbrain::ggbrain_layer$get_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="is_empty"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-is_empty'><code>ggbrain::ggbrain_layer$is_empty()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="plot"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-plot'><code>ggbrain::ggbrain_layer$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_breaks"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_breaks'><code>ggbrain::ggbrain_layer$set_breaks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_limits"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_limits'><code>ggbrain::ggbrain_layer$set_limits()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_neg_breaks"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_neg_breaks'><code>ggbrain::ggbrain_layer$set_neg_breaks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_neg_limits"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_neg_limits'><code>ggbrain::ggbrain_layer$set_neg_limits()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_pos_breaks"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_pos_breaks'><code>ggbrain::ggbrain_layer$set_pos_breaks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ggbrain" data-topic="ggbrain_layer" data-id="set_pos_limits"><a href='../../ggbrain/html/ggbrain_layer.html#method-ggbrain_layer-set_pos_limits'><code>ggbrain::ggbrain_layer$set_pos_limits()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ggbrain_layer_outline-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a new ggbrain_layer object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer_outline$new(
  name = NULL,
  definition = NULL,
  limits = NULL,
  breaks = integer_breaks(),
  show_legend = TRUE,
  interpolate = NULL,
  unify_scales = TRUE,
  alpha = NULL,
  mapping = ggplot2::aes(outline = NULL, fill = NULL),
  outline = NULL,
  outline_scale = NULL,
  size = NULL,
  blur_edge = NULL,
  fill_holes = NULL,
  remove_specks = NULL,
  trim_threads = NULL,
  dil_ero = NULL,
  data = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of this layer, used for referencing in layer and panel modifications</p>
</dd>
<dt><code>definition</code></dt><dd><p>an optional character string defining the image or contrast that should be used
to lookup data from a ggbrain_slices object. This is mostly used internally by the ggbrain + syntax
to allow layers to be defined without data in advance of the plot.</p>
</dd>
<dt><code>limits</code></dt><dd><p>if provided, sets the upper and lower bounds on the scale</p>
</dd>
<dt><code>breaks</code></dt><dd><p>if provided, a function to draw the breaks on the color scale</p>
</dd>
<dt><code>show_legend</code></dt><dd><p>if TRUE, show the scale on the plot legend</p>
</dd>
<dt><code>interpolate</code></dt><dd><p>passes to geom_raster and controls whether the fill is interpolated over continuous space</p>
</dd>
<dt><code>unify_scales</code></dt><dd><p>if TRUE, when this layer is reused across panels, unify the scales to match</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a number between 0 and 1 that sets the alpha transparency of this layer. Default: 1</p>
</dd>
<dt><code>mapping</code></dt><dd><p>the aesthetic mapping of the layer data to the display. Should be an aes() object and supports
<code>outline</code> (color of outline around clusters). Default is <code>aes(outline=value)</code>, which maps the numeric value of the layer data
to the outline color of the squares at around spatial regions. For labeled data, you might use <code>aes(fill=&lt;label_col_name&gt;)</code>.</p>
</dd>
<dt><code>outline</code></dt><dd><p>A character string indicating the color used to outline all non-NA pixels in this layer. This is used in
distinction to <code>mapping=aes(outline=&lt;variable&gt;)</code>.</p>
</dd>
<dt><code>outline_scale</code></dt><dd><p>a ggplot scale object used for mapping the value column as the outline color for the layer.</p>
</dd>
<dt><code>size</code></dt><dd><p>controls the thickness of outlines</p>
</dd>
<dt><code>blur_edge</code></dt><dd><p>the standard deviation (sigma) of a Gaussian kernel applied to the edge of this layer to
smooth it. This makes the layer less jagged in appearance and is akin to antialiasing.</p>
</dd>
<dt><code>fill_holes</code></dt><dd><p>the size of holes (in pixels) inside clusters to be filled by nearest neighbor imputation prior to display</p>
</dd>
<dt><code>remove_specks</code></dt><dd><p>the size of specks (in pixels) to be removed from each slice prior to display</p>
</dd>
<dt><code>trim_threads</code></dt><dd><p>the minimum number of neighboring pixels (including diagonals) that must be present to keep a pixel</p>
</dd>
<dt><code>dil_ero</code></dt><dd><p>the number of pixels to dilate (&gt; 0) or erode (&lt;0) the outline.</p>
</dd>
<dt><code>data</code></dt><dd><p>the data.frame containing image data for this layer. Must contain &quot;dim1&quot;, &quot;dim2&quot;,
and &quot;value&quot; as columns</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>To set mapping, you must provide a ggplot2 aes() object. A geom_outline() layer requires
an <code>outline</code> aesthetic mapping, which controls the color of outlines drawn around regions.
</p>
<p>note that the ggbrain_layer_outline class maps onto *_fill fields
</p>


<hr>
<a id="method-ggbrain_layer_outline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_layer_outline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_panel'>R6 class for a single panel of a ggbrain image</h2><span id='topic+ggbrain_panel'></span>

<h3>Description</h3>

<p>R6 class for a single panel of a ggbrain image
</p>
<p>R6 class for a single panel of a ggbrain image
</p>


<h3>Details</h3>

<p>Note that this class is exported only for power users and rarely needs to be called directly
in typical use of the package. Instead, look at <code>slices()</code>.
</p>


<h3>Value</h3>

<p>a <code>ggbrain_panel</code> R6 class with fields related to a panel on the <code>ggbrain</code> plot
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>gg</code></dt><dd><p>The ggplot object that contains the panel</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_panel-new"><code>ggbrain_panel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-reset_limits"><code>ggbrain_panel$reset_limits()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-plot"><code>ggbrain_panel$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-add_to_gg"><code>ggbrain_panel$add_to_gg()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-add_layer"><code>ggbrain_panel$add_layer()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-remove_layers"><code>ggbrain_panel$remove_layers()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-get_data"><code>ggbrain_panel$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-get_layer_names"><code>ggbrain_panel$get_layer_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-get_layers"><code>ggbrain_panel$get_layers()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-set_layer_order"><code>ggbrain_panel$set_layer_order()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_panel-clone"><code>ggbrain_panel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggbrain_panel-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a new ggbrain_panel object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$new(
  layers = NULL,
  title = NULL,
  bg_color = NULL,
  text_color = NULL,
  border_color = NULL,
  border_size = NULL,
  xlab = NULL,
  ylab = NULL,
  theme_custom = NULL,
  annotations = NULL,
  region_labels = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layers</code></dt><dd><p>a list of ggbrain_layer objects to form the panel</p>
</dd>
<dt><code>title</code></dt><dd><p>a title for the panel added to the ggplot object using ggtitle()</p>
</dd>
<dt><code>bg_color</code></dt><dd><p>the color used for the background of the plot. Default: 'gray10' (nearly black)</p>
</dd>
<dt><code>text_color</code></dt><dd><p>the color used for text displayed on the plot. Default: 'white'.</p>
</dd>
<dt><code>border_color</code></dt><dd><p>the color used for drawing a border around on the plot. Default: 'gray50'
(though borders are not drawn by default).</p>
</dd>
<dt><code>border_size</code></dt><dd><p>the size of the border line drawn around the panel. Default: NULL. If this value is
greater than zero, a border of this size and with color <code>border_color</code> will be drawn around the panel</p>
</dd>
<dt><code>xlab</code></dt><dd><p>The label to place on x axis. Default is NULL.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>The label to place on y axis. Default is NULL.</p>
</dd>
<dt><code>theme_custom</code></dt><dd><p>Any custom theme() settings to be added to the plot</p>
</dd>
<dt><code>annotations</code></dt><dd><p>a data.frame containing all annotations to be added to this plot. Each row is cleaned up
and passed to ggplot2::annotate()</p>
</dd>
<dt><code>region_labels</code></dt><dd><p>a list of ggbrain_label objects with data for plotting region labels on this panel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_panel-reset_limits"></a>



<h4>Method <code>reset_limits()</code></h4>

<p>Reset the scale limits for the specified layers
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$reset_limits(layer_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layer_names</code></dt><dd><p>not implemented yet</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_panel-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>plot the panel
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$plot(use_global_limits = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_global_limits</code></dt><dd><p>Not implemented at present</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_panel-add_to_gg"></a>



<h4>Method <code>add_to_gg()</code></h4>

<p>add one or more custom ggplot settings to the panel
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$add_to_gg(list_args)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>list_args</code></dt><dd><p>A list containing elements to add to the ggplot object</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Note that passing in an expression such as theme_bw() + ggtitle(&quot;hello&quot;)
will not work because it creates an object that cannot be added sequentially to
the ggplot. As noted in ggplot2's documentation (https://ggplot2.tidyverse.org/reference/gg-add.html),
to programmatically add elements to a ggplot, pass in a list where each element is added sequentially
</p>


<hr>
<a id="method-ggbrain_panel-add_layer"></a>



<h4>Method <code>add_layer()</code></h4>

<p>adds a ggplot_layer object to the panel
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$add_layer(layer_obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layer_obj</code></dt><dd><p>a ggbrain_layer object to add to the panel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_panel-remove_layers"></a>



<h4>Method <code>remove_layers()</code></h4>

<p>removes one or more layers by name
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$remove_layers(layer_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layer_names</code></dt><dd><p>a character string of the layers to remove from the panel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_panel-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>returns the data for all layers in the object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$get_data()</pre></div>


<hr>
<a id="method-ggbrain_panel-get_layer_names"></a>



<h4>Method <code>get_layer_names()</code></h4>

<p>returns the names of the layers in this panel, ordered from bottom to top
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$get_layer_names()</pre></div>


<hr>
<a id="method-ggbrain_panel-get_layers"></a>



<h4>Method <code>get_layers()</code></h4>

<p>returns a list of ggbrain_layer objects that comprise this panel
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$get_layers()</pre></div>


<hr>
<a id="method-ggbrain_panel-set_layer_order"></a>



<h4>Method <code>set_layer_order()</code></h4>

<p>sets the order of layers from bottom to top based on the layer names provided
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$set_layer_order(ordered_names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ordered_names</code></dt><dd><p>the names of the layers in the desired order from bottom to top. All layer names
must be provided, not just a subset</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_panel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_panel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_plot'>An R6 class for constructing a ggbrain plot from a ggbrain_slices object</h2><span id='topic+ggbrain_plot'></span>

<h3>Description</h3>

<p>An R6 class for constructing a ggbrain plot from a ggbrain_slices object
</p>
<p>An R6 class for constructing a ggbrain plot from a ggbrain_slices object
</p>


<h3>Details</h3>

<p>Note that this class is exported only for power users and rarely needs to be called directly
in typical use of the package. Instead, look at <code>ggbrain()</code>.
</p>


<h3>Value</h3>

<p>a <code>ggbrain_plot</code> R6 class containing fields related to a ggbrain plot object
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>slices</code></dt><dd><p>a ggbrain_slices object containing all slice data for this plot</p>
</dd>
<dt><code>layers</code></dt><dd><p>a list of ggbrain_layer objects for this plot. Note that in assignment, the
input can be a list of ggbrain_layer objects, or a list of lists where each inner element
specifies the settings for that layer. Example: <code style="white-space: pre;">&#8288;list(list(name='hello', fill_scale=scale_fill_distiller())&#8288;</code></p>
</dd>
<dt><code>annotations</code></dt><dd><p>a list of annotations to be added to this plot</p>
</dd>
<dt><code>region_labels</code></dt><dd><p>a list of region_labels to be added to this plot</p>
</dd>
<dt><code>panel_settings</code></dt><dd><p>a list of panel settings (aesthetics) to be added to this plot</p>
</dd>
<dt><code>title</code></dt><dd><p>overall plot title, added to composite plot by <code>patchwork::plot_annotation()</code></p>
</dd>
<dt><code>bg_color</code></dt><dd><p>background color of plot</p>
</dd>
<dt><code>text_color</code></dt><dd><p>the color of text use across panels (can be overridden by panel settings)</p>
</dd>
<dt><code>base_size</code></dt><dd><p>the base size of text used in ggplot theming</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_plot-new"><code>ggbrain_plot$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_plot-add_layers"><code>ggbrain_plot$add_layers()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_plot-reset_layers"><code>ggbrain_plot$reset_layers()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_plot-generate_plot"><code>ggbrain_plot$generate_plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_plot-plot"><code>ggbrain_plot$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_plot-clone"><code>ggbrain_plot$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggbrain_plot-new"></a>



<h4>Method <code>new()</code></h4>

<p>instantiate a new instance of a ggbrain_plot object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_plot$new(
  title = NULL,
  bg_color = NULL,
  text_color = NULL,
  base_size = NULL,
  slice_data = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>title</code></dt><dd><p>overall plot title</p>
</dd>
<dt><code>bg_color</code></dt><dd><p>background color of plot</p>
</dd>
<dt><code>text_color</code></dt><dd><p>text color of plot</p>
</dd>
<dt><code>base_size</code></dt><dd><p>base size of text used in ggplot theming</p>
</dd>
<dt><code>slice_data</code></dt><dd><p>a ggbrain_slices object generated by ggbrain_images$get_slices()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_plot-add_layers"></a>



<h4>Method <code>add_layers()</code></h4>

<p>adds one or more ggbrain_layer objects to this plot
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_plot$add_layers(layers = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layers</code></dt><dd><p>a list of ggbrain_layer objects (can also be a list that just specifies names, definitions, etc.)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_plot-reset_layers"></a>



<h4>Method <code>reset_layers()</code></h4>

<p>removes all existing layers from this ggbrain_plot object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_plot$reset_layers()</pre></div>


<hr>
<a id="method-ggbrain_plot-generate_plot"></a>



<h4>Method <code>generate_plot()</code></h4>

<p>generate the plot
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_plot$generate_plot(layers = NULL, slice_indices = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layers</code></dt><dd><p>a list of layers to be displayed on each panel, the order of which yields the
bottom-to-to drawing order within ggplot2. Each element of <code>layers</code> should be a list
that follows the approximate structure of the ggbrain_layer class, minimally including
the layer <code>name</code>, which is used to lookup data of images or contrasts within the
slice_data object. If NULL, all layers in the slices object will be plotted. If only
a character string is passed, then those layers will be plotted with default scales.</p>
</dd>
<dt><code>slice_indices</code></dt><dd><p>An optional subset of slice indices to display from the stored slice data</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In addition to <code>name</code>, the elements of a layer can include
<code>fill_scale</code> a ggplot2 scale object for coloring the layer. Should be a scale_fill_* object.
<code>limits</code> the numeric limits to use for the color scale of this layer
<code>breaks</code> the scale breaks to use for the color scale of this layer
<code>show_legend</code> if FALSE, the color scale will not appear in the legend
</p>


<hr>
<a id="method-ggbrain_plot-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>return a plot of all panels as a patchwork object
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_plot$plot(guides = "collect")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>guides</code></dt><dd><p>Passes through to patchwork::plot_layout to control how legends are combined across plots. The default
is &quot;collect&quot;, which collects legends within a given nesting level (removes duplicates).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_plot-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_plot$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ggbrain_slices'>R6 class for managing slice data for ggbrain plots</h2><span id='topic+ggbrain_slices'></span>

<h3>Description</h3>

<p>R6 class for managing slice data for ggbrain plots
</p>
<p>R6 class for managing slice data for ggbrain plots
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>slice_index</code></dt><dd><p>read-only access to the slice_index containing the slice numbers</p>
</dd>
<dt><code>coord_input</code></dt><dd><p>the input string used to lookup the slices</p>
</dd>
<dt><code>coord_label</code></dt><dd><p>the calculated x, y, or z coordinate of the relevant slice</p>
</dd>
<dt><code>slice_number</code></dt><dd><p>the slice number along the relevant axis of the 3D image matrix</p>
</dd>
<dt><code>slice_data</code></dt><dd><p>a nested list of data.frames where each element contains all data relevant to
that slice and the list elements within are each a given image</p>
</dd>
<dt><code>slice_matrix</code></dt><dd><p>the slice data in matrix form</p>
</dd>
<dt><code>slice_labels</code></dt><dd><p>a data.frame for each slice containing the coordinates of labels available to be drawn</p>
</dd>
<dt><code>layer_names</code></dt><dd><p>a character vector of layer names within each slice</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ggbrain_slices-new"><code>ggbrain_slices$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_slices-compute_contrasts"><code>ggbrain_slices$compute_contrasts()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_slices-as_tibble"><code>ggbrain_slices$as_tibble()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_slices-get_ranges"><code>ggbrain_slices$get_ranges()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_slices-get_uvals"><code>ggbrain_slices$get_uvals()</code></a>
</p>
</li>
<li> <p><a href="#method-ggbrain_slices-clone"><code>ggbrain_slices$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ggbrain_slices-new"></a>



<h4>Method <code>new()</code></h4>

<p>create a ggbrain_slices object based
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_slices$new(slice_df = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slice_df</code></dt><dd><p>a data.frame generated by ggbrain_images$get_slices()</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If this becomes a user-facing/exported class, we may want a more friendly constructor
</p>


<hr>
<a id="method-ggbrain_slices-compute_contrasts"></a>



<h4>Method <code>compute_contrasts()</code></h4>

<p>computes contrasts of the sliced image data
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_slices$compute_contrasts(contrast_list = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>contrast_list</code></dt><dd><p>a named list or character vector containing contrasts to be computed.
The names of the list form the contrast names, while the values should be character strings
that use standard R syntax for logical tests, subsetting, and arithmetic</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_slices-as_tibble"></a>



<h4>Method <code>as_tibble()</code></h4>

<p>convert the slices object into a data.frame with list-columns for slice data elements
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_slices$as_tibble()</pre></div>


<hr>
<a id="method-ggbrain_slices-get_ranges"></a>



<h4>Method <code>get_ranges()</code></h4>

<p>calculates the numeric ranges of each image/contrast in this object, across all
constituent slices. This is useful for setting scale limits that are shared across panels
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_slices$get_ranges(slice_indices = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slice_indices</code></dt><dd><p>an optional integer vector of slice indices to be used as a subset in the calculation</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a tibble keyed by 'layer' with overall low and high values, as well as split by pos/neg
</p>


<hr>
<a id="method-ggbrain_slices-get_uvals"></a>



<h4>Method <code>get_uvals()</code></h4>

<p>returns a data.frame with the unique values for each label layer, across all
constituent slices
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_slices$get_uvals(slice_indices = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>slice_indices</code></dt><dd><p>an optional integer vector of slice indices to be used as a subset in the calculation</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ggbrain_slices-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ggbrain_slices$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='ggplot_add.ggbrain_label'>S3 method to support adding ggbrain_label objects to an existing ggplot object</h2><span id='topic+ggplot_add.ggbrain_label'></span>

<h3>Description</h3>

<p>S3 method to support adding ggbrain_label objects to an existing ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbrain_label'
ggplot_add(object, plot, object_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_add.ggbrain_label_+3A_object">object</code></td>
<td>
<p>the ggbrain_layer object to be added to an existing ggplot</p>
</td></tr>
<tr><td><code id="ggplot_add.ggbrain_label_+3A_plot">plot</code></td>
<td>
<p>the ggplot object</p>
</td></tr>
<tr><td><code id="ggplot_add.ggbrain_label_+3A_object_name">object_name</code></td>
<td>
<p>not used, but required by ggplot_add</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot_add.ggbrain_layer'>S3 method to support adding ggbrain_layer objects to an existing ggplot object</h2><span id='topic+ggplot_add.ggbrain_layer'></span>

<h3>Description</h3>

<p>S3 method to support adding ggbrain_layer objects to an existing ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbrain_layer'
ggplot_add(object, plot, object_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_add.ggbrain_layer_+3A_object">object</code></td>
<td>
<p>the ggbrain_layer object to be added to an existing ggplot</p>
</td></tr>
<tr><td><code id="ggplot_add.ggbrain_layer_+3A_plot">plot</code></td>
<td>
<p>the ggplot object</p>
</td></tr>
<tr><td><code id="ggplot_add.ggbrain_layer_+3A_object_name">object_name</code></td>
<td>
<p>not used, but required by ggplot_add</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot_add.ggbrain_panel'>S3 method to support adding ggbrain_layer objects to an existing ggplot object</h2><span id='topic+ggplot_add.ggbrain_panel'></span>

<h3>Description</h3>

<p>S3 method to support adding ggbrain_layer objects to an existing ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbrain_panel'
ggplot_add(object, plot, object_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_add.ggbrain_panel_+3A_object">object</code></td>
<td>
<p>the ggbrain_layer object to be added to an existing ggplot</p>
</td></tr>
<tr><td><code id="ggplot_add.ggbrain_panel_+3A_plot">plot</code></td>
<td>
<p>the ggplot object</p>
</td></tr>
<tr><td><code id="ggplot_add.ggbrain_panel_+3A_object_name">object_name</code></td>
<td>
<p>not used, but required by ggplot_add</p>
</td></tr>
</table>

<hr>
<h2 id='images'>Add images to a ggbrain object</h2><span id='topic+images'></span>

<h3>Description</h3>

<p>Add images to a ggbrain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images(images = NULL, volumes = NULL, labels = NULL, filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="images_+3A_images">images</code></td>
<td>
<p>a character vector or ggbrain_images object containing NIfTI images to add to this plot</p>
</td></tr>
<tr><td><code id="images_+3A_volumes">volumes</code></td>
<td>
<p>a number indicating the volume within the <code>images</code> to display. At present, this must
be a single number &ndash; perhaps in the future, it could be a vector so that many timepoints in a 4-D image could
be displayed.</p>
</td></tr>
<tr><td><code id="images_+3A_labels">labels</code></td>
<td>
<p>a data.frame or named list of data.frame objects corresponding to images that should be labeled.
You can only provide a data.frame if there is a single image being added. If multiple images are added, the names of
the <code>labels</code> list are used to align the labels with a given matching image.</p>
</td></tr>
<tr><td><code id="images_+3A_filter">filter</code></td>
<td>
<p>a named list or character string specifying an expression of values to retain in the image,
or a numeric vector of values to retain. Calls ggbrain_images$filter_image()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant images and an action of 'add_images'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  t1 &lt;- system.file("extdata", "mni_template_2009c_3mm.nii.gz", package = "ggbrain")
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1))
</code></pre>

<hr>
<h2 id='integer_breaks'>breaks function to encourage integer-valued breaks, based on input from pretty</h2><span id='topic+integer_breaks'></span>

<h3>Description</h3>

<p>breaks function to encourage integer-valued breaks, based on input from pretty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integer_breaks(n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integer_breaks_+3A_n">n</code></td>
<td>
<p>number of breaks (default = 5)</p>
</td></tr>
<tr><td><code id="integer_breaks_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the pretty() function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code from here: https://joshuacook.netlify.app/post/integer-values-ggplot-axis/
</p>


<h3>Value</h3>

<p>a function for generating integer-valued breaks on a continuous scale
</p>

<hr>
<h2 id='integer_mode'>Finds the mode of an integer vector</h2><span id='topic+integer_mode'></span>

<h3>Description</h3>

<p>Finds the mode of an integer vector
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="integer_mode_+3A_v">v</code></td>
<td>
<p>a vector of integers</p>
</td></tr>
<tr><td><code id="integer_mode_+3A_demote_zeros">demote_zeros</code></td>
<td>
<p>if TRUE, zero will not be allowed to be the mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer representing the mode of the vector. If multiple modes are found, then the lowest-valued mode
is returned
</p>

<hr>
<h2 id='mat2df'>Fast conversion of 2D mat to 3-column data.frame with dim1, dim2, value</h2><span id='topic+mat2df'></span>

<h3>Description</h3>

<p>Converts a 2D numeric matrix into a 3-column data.frame
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2df_+3A_mat">mat</code></td>
<td>
<p>A <code>matrix</code> to convert to data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a faster version of reshape2::melt for the simple 2-D case. It is about 2.5x faster than melt.
</p>


<h3>Value</h3>

<p>A 3-column data.frame with dim1, dim2, and value
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist
</p>

<hr>
<h2 id='montage'>Convenience function to add many slices in a montage along one of the 3D planes</h2><span id='topic+montage'></span>

<h3>Description</h3>

<p>Convenience function to add many slices in a montage along one of the 3D planes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>montage(
  plane = NULL,
  n = 12,
  min = 0.1,
  max = 0.9,
  min_coord = NULL,
  max_coord = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="montage_+3A_plane">plane</code></td>
<td>
<p>a character string specifying the 3D plane: &quot;sagittal&quot;, &quot;axial&quot;, &quot;coronal&quot;, &quot;x&quot;, &quot;y&quot;, or &quot;z&quot;</p>
</td></tr>
<tr><td><code id="montage_+3A_n">n</code></td>
<td>
<p>number of slices to add in this plane. Default: 12</p>
</td></tr>
<tr><td><code id="montage_+3A_min">min</code></td>
<td>
<p>the lowest quantile to be included in the montage (between 0 and 1). Default: 0.1</p>
</td></tr>
<tr><td><code id="montage_+3A_max">max</code></td>
<td>
<p>the highest quantile to be included in the montage (between 0 and 1). Default: 0.9</p>
</td></tr>
<tr><td><code id="montage_+3A_min_coord">min_coord</code></td>
<td>
<p>the lowest spatial position (in image coordinate space) to be included in the montage.</p>
</td></tr>
<tr><td><code id="montage_+3A_max_coord">max_coord</code></td>
<td>
<p>the highest spatial position (in image coordinate space) to be included in the montage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be used with <code>slices</code> to make a quick montage, such as <code style="white-space: pre;">&#8288;slices(montage("axial", 10)&#8288;</code>.
</p>
<p>Also note that use of standardized coordinates (in quantiles, using <code>min</code> and <code>max</code>) is mutually exclusive
with the the image coordinate specifications <code>min_coord</code> and <code>max_coord.</code>
</p>


<h3>Value</h3>

<p>a character string containing the slice positions along the requested axis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  t1 &lt;- system.file("extdata", "mni_template_2009c_3mm.nii.gz", package = "ggbrain")
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1)) +
    slices(montage("sagittal", 15))
</code></pre>

<hr>
<h2 id='named_list'>little helper function to create named list from objects</h2><span id='topic+named_list'></span>

<h3>Description</h3>

<p>little helper function to create named list from objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="named_list_+3A_...">...</code></td>
<td>
<p>A set of arguments to be compiled into a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the objects will form the names of the list elements
</p>

<hr>
<h2 id='nearest_pts'>Finds the nearest non-missing neighbors of a target point in a 2D matrix</h2><span id='topic+nearest_pts'></span>

<h3>Description</h3>

<p>Finds the nearest non-missing neighbors of a target point in a 2D matrix
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_pts_+3A_x">x</code></td>
<td>
<p>x-position of the point whose neighbors should be found within <code>in_mat</code></p>
</td></tr>
<tr><td><code id="nearest_pts_+3A_y">y</code></td>
<td>
<p>y-position of the point whose neighbors should be found within <code>in_mat</code></p>
</td></tr>
<tr><td><code id="nearest_pts_+3A_in_mat">in_mat</code></td>
<td>
<p>a 2D matrix to search for neighbors of <code>pt</code></p>
</td></tr>
<tr><td><code id="nearest_pts_+3A_neighbors">neighbors</code></td>
<td>
<p>the number of closest non-NA neighboring values to return within <code>in_mat</code></p>
</td></tr>
<tr><td><code id="nearest_pts_+3A_radius">radius</code></td>
<td>
<p>the radius around <code>pt</code> to search. Default: 8.</p>
</td></tr>
<tr><td><code id="nearest_pts_+3A_ignore_zeros">ignore_zeros</code></td>
<td>
<p>if TRUE, then zero is not a valid imputation value (since these are not data in NIfTIs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>neighbors</code> closest neighboring values around <code>pt</code>
</p>

<hr>
<h2 id='nn_impute'>Imputes missing values in a 2D matrix based on the nearest non-missing neighbors in a given radius</h2><span id='topic+nn_impute'></span>

<h3>Description</h3>

<p>Imputes missing values in a 2D matrix based on the nearest non-missing neighbors in a given radius
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn_impute_+3A_in_mat">in_mat</code></td>
<td>
<p>a 2D matrix to fill using nearest neighbors</p>
</td></tr>
<tr><td><code id="nn_impute_+3A_neighbors">neighbors</code></td>
<td>
<p>the number of closest non-NA neighboring values to return within <code>in_mat</code>. Default is 4.</p>
</td></tr>
<tr><td><code id="nn_impute_+3A_radius">radius</code></td>
<td>
<p>the radius (in pixels) around each missing value to search for non-missing neighbors. Default is 8.</p>
</td></tr>
<tr><td><code id="nn_impute_+3A_aggfun">aggfun</code></td>
<td>
<p>the function used to aggregate the neighbors in imputation. Supports &quot;mean&quot;, &quot;median&quot;, and &quot;mode.&quot;</p>
</td></tr>
<tr><td><code id="nn_impute_+3A_ignore_zeros">ignore_zeros</code></td>
<td>
<p>if TRUE, then zero is not a valid imputation value (since these are not data in NIfTIs)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;mode&quot; aggfun should only be used when the matrix <code>in_mat</code> can be converted to integers without loss
of information (i.e., the data are integerish values already).
</p>


<h3>Value</h3>

<p>A copy of the matrix with NA values imputed by their nearest neighbors
</p>

<hr>
<h2 id='plot.ggb'>S3 method to allow for plot() syntax with ggbrain (ggb) objects</h2><span id='topic+plot.ggb'></span>

<h3>Description</h3>

<p>S3 method to allow for plot() syntax with ggbrain (ggb) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggb'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ggb_+3A_x">x</code></td>
<td>
<p>the <code>ggb</code> object to be plotted</p>
</td></tr>
<tr><td><code id="plot.ggb_+3A_...">...</code></td>
<td>
<p>additional argument passed to the plot method</p>
</td></tr>
</table>

<hr>
<h2 id='plot.ggbrain_panel'>S3 method to allow for plot() syntax with ggbrain_panel objects</h2><span id='topic+plot.ggbrain_panel'></span>

<h3>Description</h3>

<p>S3 method to allow for plot() syntax with ggbrain_panel objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbrain_panel'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ggbrain_panel_+3A_x">x</code></td>
<td>
<p>the <code>ggbrain_panel</code> object to be plotted</p>
</td></tr>
<tr><td><code id="plot.ggbrain_panel_+3A_...">...</code></td>
<td>
<p>additional argument passed to the plot method</p>
</td></tr>
</table>

<hr>
<h2 id='plot.ggbrain_plot'>S3 method to allow for plot() syntax with ggbrain_panel objects</h2><span id='topic+plot.ggbrain_plot'></span>

<h3>Description</h3>

<p>S3 method to allow for plot() syntax with ggbrain_panel objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggbrain_plot'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ggbrain_plot_+3A_x">x</code></td>
<td>
<p>the <code>ggbrain_plot</code> object to be plotted</p>
</td></tr>
<tr><td><code id="plot.ggbrain_plot_+3A_...">...</code></td>
<td>
<p>additional argument passed to the plot method</p>
</td></tr>
</table>

<hr>
<h2 id='range_breaks'>breaks function for including min + max with labels, and a few unlabeled ticks in between</h2><span id='topic+range_breaks'></span>

<h3>Description</h3>

<p>breaks function for including min + max with labels, and a few unlabeled ticks in between
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_breaks(n = 3, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_breaks_+3A_n">n</code></td>
<td>
<p>number of breaks added within the min-max range</p>
</td></tr>
<tr><td><code id="range_breaks_+3A_digits">digits</code></td>
<td>
<p>number of decimal places to display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function for generating breaks on a continuous scale with the min and max labeled
</p>

<hr>
<h2 id='render'>Function to convert <code>ggb</code> object to ggplot/patchwork object</h2><span id='topic+render'></span>

<h3>Description</h3>

<p>Function to convert <code>ggb</code> object to ggplot/patchwork object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render()
</code></pre>


<h3>Value</h3>

<p>a <code>ggb</code> object with the action 'render', used in a <code>ggbrain</code> addition chain
</p>

<hr>
<h2 id='scale_fill_bisided'>scale for plotting separate color gradients for positive and negative values</h2><span id='topic+scale_fill_bisided'></span>

<h3>Description</h3>

<p>scale for plotting separate color gradients for positive and negative values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_bisided(
  name = ggplot2::waiver(),
  neg_scale = scale_fill_distiller(palette = "Blues", direction = 1),
  pos_scale = scale_fill_distiller(palette = "Reds"),
  symmetric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_fill_bisided_+3A_name">name</code></td>
<td>
<p>the scale name to be printed in the legend (above positive scale)</p>
</td></tr>
<tr><td><code id="scale_fill_bisided_+3A_neg_scale">neg_scale</code></td>
<td>
<p>a scale_fill_* object used for negative values</p>
</td></tr>
<tr><td><code id="scale_fill_bisided_+3A_pos_scale">pos_scale</code></td>
<td>
<p>a scale_fill_* object used for positive values</p>
</td></tr>
<tr><td><code id="scale_fill_bisided_+3A_symmetric">symmetric</code></td>
<td>
<p>if TRUE, the limits of the positive scale will equal the inverse limits of
the negative scale. Said differently, this makes the positive and negative scales symmetric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this will absolutely not work as a general purpose ggplot2 scale!
The positive/negative combination is achieved by adding two layers/geoms behind the
scenes with different color scale.
</p>


<h3>Value</h3>

<p>a <code>ggplot2</code> scale of type <code>ScaleContinuous</code> that includes negative and positive fill
scales internally in the <code style="white-space: pre;">&#8288;$neg_scale&#8288;</code> and <code style="white-space: pre;">&#8288;$pos_scale&#8288;</code> elements
</p>

<hr>
<h2 id='slices'>Adds slices to the ggbrain plot, including additional panel aesthetics</h2><span id='topic+slices'></span>

<h3>Description</h3>

<p>Adds slices to the ggbrain plot, including additional panel aesthetics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slices(
  coordinates = NULL,
  title = NULL,
  bg_color = NULL,
  text_color = NULL,
  border_color = NULL,
  border_size = NULL,
  xlab = NULL,
  ylab = NULL,
  theme_custom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slices_+3A_coordinates">coordinates</code></td>
<td>
<p>a character vector specifying the x, y, or z coordinates of the slices to be added.</p>
</td></tr>
<tr><td><code id="slices_+3A_title">title</code></td>
<td>
<p>a title for the slice panels added to the ggplot object using <code>ggtitle()</code></p>
</td></tr>
<tr><td><code id="slices_+3A_bg_color">bg_color</code></td>
<td>
<p>the color used for the background of the panels. Default: <code>'gray10'</code> (nearly black)</p>
</td></tr>
<tr><td><code id="slices_+3A_text_color">text_color</code></td>
<td>
<p>the color used for text displayed on the panels. Default: <code>'white'</code>.</p>
</td></tr>
<tr><td><code id="slices_+3A_border_color">border_color</code></td>
<td>
<p>the color used for drawing a border around on the panels. Default: <code>'gray50'</code>
(though borders are not drawn by default).</p>
</td></tr>
<tr><td><code id="slices_+3A_border_size">border_size</code></td>
<td>
<p>the size of the border line drawn around the panels. Default: NULL. If this value is
greater than zero, a border of this size and with color <code>border_color</code> will be drawn around the panels.</p>
</td></tr>
<tr><td><code id="slices_+3A_xlab">xlab</code></td>
<td>
<p>The label to place on x axis. Default is NULL.</p>
</td></tr>
<tr><td><code id="slices_+3A_ylab">ylab</code></td>
<td>
<p>The label to place on y axis. Default is NULL.</p>
</td></tr>
<tr><td><code id="slices_+3A_theme_custom">theme_custom</code></td>
<td>
<p>Any custom theme() settings to be added to the panels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>note that if you pass in multiple coordinates (as a vector), the <code>title</code>, <code>bg_color</code>, and other attributes
will be reused for all slices added by this operation. Thus, if you want to customize specific slices or groups of slices, use
multiple addition operations, as in <code>slices(c('x=10', 'y=15'), bg_color='white') + slices(c('x=18', 'y=22'), bg_color='black')</code>.
</p>


<h3>Value</h3>

<p>a <code>ggb</code> object with the relevant slices and an action of 'add_slices'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  t1 &lt;- system.file("extdata", "mni_template_2009c_3mm.nii.gz", package = "ggbrain")
  gg_obj &lt;- ggbrain() +
    images(c(underlay = t1)) +
    slices(c("x = 25%", "x = 75%"), border_color = "blue")
</code></pre>

<hr>
<h2 id='sort_mat'>Sort Matrix by Column</h2><span id='topic+sort_mat'></span>

<h3>Description</h3>

<p>Sorts a given matrix by a specific column while retain the elements in each row.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_mat_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> to sort</p>
</td></tr>
<tr><td><code id="sort_mat_+3A_col">col</code></td>
<td>
<p>A <code>int</code> that indicates the column the matrix should sort by.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions sorts a matrix based on one column, keeping the rows together.
Note that <code>col</code> should be a zero-based index of <code>x</code> (i.e., first column is 0).
</p>


<h3>Value</h3>

<p>The matrix sorted by values in the specified column.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
