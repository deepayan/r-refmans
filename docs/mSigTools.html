<!DOCTYPE html><html><head><title>Help for package mSigTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mSigTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#find_best_reconstruction_QP'><p>Find &quot;best&quot; reconstruction of a target signature or spectrum from a set of signatures.</p></a></li>
<li><a href='#match_two_sig_sets'><p>Find an optimal matching between two sets of signatures subject to a maximum distance.</p></a></li>
<li><a href='#optimize_exposure_QP'><p>Quadratic programming optimization of signature activities</p></a></li>
<li><a href='#plot_exposure'><p>Plot exposures in multiple plots, with each plot showing exposures for a manageable number of samples.</p></a></li>
<li><a href='#plot_exposure_internal'><p>Plot a matrix of exposures in a single plot.</p></a></li>
<li><a href='#plot_exposure_to_pdf'><p>Plot exposures in multiple plots to a single PDF file, with each plot showing</p>
exposures for a manageable number of samples.</a></li>
<li><a href='#read_exposure'><p>Read an exposure matrix from a file.</p></a></li>
<li><a href='#sig_dist_matrix'><p>Compute a matrix of distances / similarities between two sets of signatures.</p></a></li>
<li><a href='#sort_exposure'><p>Sort columns of an exposure matrix based on the number of mutations in each sample (column).</p></a></li>
<li><a href='#TP_FP_FN_avg_sim'><p>Find best matches (by cosine similarity) of a set of mutational signatures to</p>
a set of reference mutational signatures.</a></li>
<li><a href='#write_exposure'><p>Write an exposure matrix to a file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mutational Signature Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility functions for mutational signature analysis
             as described in Alexandrov, L. B. (2020)
             &lt;<a href="https://doi.org/10.1038%2Fs41586-020-1943-3">doi:10.1038/s41586-020-1943-3</a>&gt;.
             This package provides two groups of functions. One is
             for dealing with mutational signature "exposures"
             (i.e. the counts of mutations in a sample that are
             due to each mutational signature). The other group of
             functions is for matching or comparing sets of 
             mutational signatures. 'mSigTools' stands for 
             mutational Signature analysis Tools. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Rozen-Lab/mSigTools">https://github.com/Rozen-Lab/mSigTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Rozen-Lab/mSigTools/issues">https://github.com/Rozen-Lab/mSigTools/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>clue, philentropy, quadprog, sets</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cosmicsig, ICAMS, spelling, testthat (&ge; 3.0.0),</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-13 09:40:32 UTC; e0012078</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven Rozen <a href="https://orcid.org/0000-0002-4288-0056"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nanhai Jiang <a href="https://orcid.org/0000-0003-4974-2753"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steven Rozen &lt;steverozen@pm.me&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-13 13:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='find_best_reconstruction_QP'>Find &quot;best&quot; reconstruction of a target signature or spectrum from a set of signatures.</h2><span id='topic+find_best_reconstruction_QP'></span>

<h3>Description</h3>

<p>Find &quot;best&quot; reconstruction of a target signature or spectrum from a set of signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_reconstruction_QP(
  target.sig,
  sig.universe,
  max.subset.size = NULL,
  method = "cosine",
  trim.less.than = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_best_reconstruction_QP_+3A_target.sig">target.sig</code></td>
<td>
<p>The signature or spectrum to reconstruct;
a non-negative numeric vector or 1-column matrix-like object.</p>
</td></tr>
<tr><td><code id="find_best_reconstruction_QP_+3A_sig.universe">sig.universe</code></td>
<td>
<p>The universe of signatures from which to reconstruct
<code>target.sig</code>; a non-negative numeric matrix-like object with
<code>nrow(sig.universe) == length(target.sig)</code>. The sums of each column
must be 1. Must not contain duplicate columns or have other
non-unique quadratic programming solutions (not checked, but will generate
an error from <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> in package <code>quadprog</code>).</p>
</td></tr>
<tr><td><code id="find_best_reconstruction_QP_+3A_max.subset.size">max.subset.size</code></td>
<td>
<p>Maximum number of signatures to use to
reconstruct <code>target.sig</code>.</p>
</td></tr>
<tr><td><code id="find_best_reconstruction_QP_+3A_method">method</code></td>
<td>
<p>As in <code><a href="philentropy.html#topic+dist_one_one">dist_one_one</a></code> in
package <code>philentropy</code>, and used only
to find the final &quot;best&quot; reconstruction. The optimized exposures from which
to selected the &quot;best&quot; reconstruction are calculated using
<code><a href="#topic+optimize_exposure_QP">optimize_exposure_QP</a></code>, which uses <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code>
in package <code>quadprog</code>.</p>
</td></tr>
<tr><td><code id="find_best_reconstruction_QP_+3A_trim.less.than">trim.less.than</code></td>
<td>
<p>After optimizing exposures with
<code><a href="#topic+optimize_exposure_QP">optimize_exposure_QP</a></code>, remove exposures less than
<code>trim.less.than</code> and then re-optimize.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be fast if you do not specify <code>max.subset.size</code>,
but it will be combinatorially slow if <code>max.subset.size</code> is large
and <code>trim.less.than</code> is small or negative. So do not do that.
If <code>max.subset.size</code> is <code>NULL</code>, then the function just uses <code><a href="#topic+optimize_exposure_QP">optimize_exposure_QP</a></code>.
and then excludes exposures &lt; <code>trim.less.than</code>, and then re-runs
<code><a href="#topic+optimize_exposure_QP">optimize_exposure_QP</a></code>. Otherwise, after excluding
exposures &lt; <code>trim.less.than</code>, then the function runs <code><a href="#topic+optimize_exposure_QP">optimize_exposure_QP</a></code> on
subsets of signatures of size &lt;= <code>max.subset.size</code>, removes exposures &lt; <code>trim.less.than</code>,
reruns <code><a href="#topic+optimize_exposure_QP">optimize_exposure_QP</a></code>, calculates the reconstruction and
similarity between the reconstruction and the <code>target.sig</code> and returns the information for
the exposures that have the greatest similarity.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>optimized.exposure</code> A numerical vector of the exposures that
give the &quot;best&quot; reconstruction. This vector is empty if there is
an error.
</p>
</li>
<li> <p><code>similarity</code> The similarity between the <code>reconstruction</code>
(see below) and <code>target.sig</code> according to the distance
or similarity provided by the <code>method</code> argument.
</p>
</li>
<li> <p><code>method</code> The value specified for the <code>method</code> argument,
or an error message if <code>optimize.exposure</code> is empty.
</p>
</li>
<li> <p><code>reconstruction</code> The reconstruction of <code>target.sig</code> according to
<code>optimized.exposure</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
sig.u &lt;-
  do.call(
    cbind,
    lapply(1:6, function(x) {
      col &lt;- runif(n = 96)
      col / sum(col)
    })
  )
rr &lt;- find_best_reconstruction_QP(
  target.sig = sig.u[, 1, drop = FALSE],
  sig.universe = sig.u[, 2:6]
)
names(rr)
rr$optimized.exposure
rr$similarity
rr &lt;- find_best_reconstruction_QP(
  target.sig = sig.u[, 1, drop = FALSE],
  sig.universe = sig.u[, 2:6],
  max.subset.size = 3
)
rr$optimized.exposure
rr$similarity

</code></pre>

<hr>
<h2 id='match_two_sig_sets'>Find an optimal matching between two sets of signatures subject to a maximum distance.</h2><span id='topic+match_two_sig_sets'></span>

<h3>Description</h3>

<p>Find an optimal matching between two sets of signatures subject to a maximum distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_two_sig_sets(
  x1,
  x2,
  method = "cosine",
  convert.sim.to.dist = function(x) {
     return(1 - x)
 },
  cutoff = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_two_sig_sets_+3A_x1">x1</code></td>
<td>
<p>A numerical-matrix-like object with columns as signatures.</p>
</td></tr>
<tr><td><code id="match_two_sig_sets_+3A_x2">x2</code></td>
<td>
<p>A numerical-matrix-like object with columns as signatures.
Needs to have the same number of rows as <code>x1</code>.</p>
</td></tr>
<tr><td><code id="match_two_sig_sets_+3A_method">method</code></td>
<td>
<p>As for the <code><a href="philentropy.html#topic+distance">distance</a></code> function in package
<code>philenropy</code>.</p>
</td></tr>
<tr><td><code id="match_two_sig_sets_+3A_convert.sim.to.dist">convert.sim.to.dist</code></td>
<td>
<p>If <code>method</code> specifies a similarity
rather than a distance, use this function to convert the
similarity to a distance.</p>
</td></tr>
<tr><td><code id="match_two_sig_sets_+3A_cutoff">cutoff</code></td>
<td>
<p>A maximum distance or minimum similarity over which to
pair signatures between <code>x1</code> and <code>x2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Match signatures between <code>x1</code> and <code>x2</code>
using the function
<code><a href="clue.html#topic+solve_LSAP">solve_LSAP</a></code>, which uses the
&quot;Hungarian&quot; (a.k.a &quot;Kuhn–Munkres&quot;) algorithm
<a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">https://en.wikipedia.org/wiki/Hungarian_algorithm</a>,
which optimizes the total cost associated with the links
between nodes.
This function generates a distance matrix between the two
sets of signatures using <code>method</code> and, if necessary,
<code>convert.sim.to.dist</code>.
It then sets distances &gt; <code>cutoff</code> to very large values and
then applies <code><a href="clue.html#topic+solve_LSAP">solve_LSAP</a></code> to the resulting
matrix to compute a matching between
<code>x1</code> and <code>x2</code> that minimizes the sum of the
distances.
</p>


<h3>Value</h3>

<p>A list with the elements
</p>

<ul>
<li> <p><code>table</code> Table of extracted signatures that matched a reference
signature. Each row contains the extracted signature name,
the reference
signature name, and the distance of the match.
</p>
</li>
<li> <p><code>orig.matrix</code> The matrix of numeric distances between
<code>x1</code> and <code>x2</code>.
</p>
</li>
<li> <p><code>modified.matrix</code> The argument <code>orig.matrix</code>
with distances &gt;
<code>cutoff</code> changed to very large values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ex.sigs &lt;- matrix(c(0.2, 0.8, 0.3, 0.7, 0.6, 0.4), nrow = 2)
colnames(ex.sigs) &lt;- c("ex1", "ex2", "ex3")
ref.sigs &lt;- matrix(c(0.21, 0.79, 0.19, 0.81), nrow = 2)
colnames(ref.sigs) &lt;- c("ref1", "ref2")
match_two_sig_sets(ex.sigs, ref.sigs, cutoff = .9)

</code></pre>

<hr>
<h2 id='optimize_exposure_QP'>Quadratic programming optimization of signature activities</h2><span id='topic+optimize_exposure_QP'></span>

<h3>Description</h3>

<p>Quadratic programming optimization of signature activities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_exposure_QP(spectrum, signatures)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_exposure_QP_+3A_spectrum">spectrum</code></td>
<td>
<p>Mutational signature or mutational spectrum
as a numeric vector or single column data frame or matrix.</p>
</td></tr>
<tr><td><code id="optimize_exposure_QP_+3A_signatures">signatures</code></td>
<td>
<p>Matrix or data frame of signatures from which to
reconstruct <code>spectrum</code>. Rows are mutation types and columns are
signatures. Should have column names for interpretable results. Cannot be a
vector because the column names are needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code adapted from <code>SignatureEstimation::decomposeQP</code> and
uses <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> in package <code>quadprog</code>.
</p>


<h3>Value</h3>

<p>A vector of exposures with names being the <code>colnames</code> from
<code>signatures</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>usigs &lt;- matrix(c(0.2, 0.7, 0.1,
                  0.3, 0.6, 0.1,
                  0.1, 0.1, 0.8), nrow = 3)
colnames(usigs) &lt;- c("u1", "u2", "u3")
tsig &lt;- matrix(c(0.25, 0.65, 0.1), nrow = 3)
optimize_exposure_QP(tsig, usigs)
</code></pre>

<hr>
<h2 id='plot_exposure'>Plot exposures in multiple plots, with each plot showing exposures for a manageable number of samples.</h2><span id='topic+plot_exposure'></span>

<h3>Description</h3>

<p>Plot exposures in multiple plots, with each plot showing exposures for a manageable number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_exposure(
  exposure,
  samples.per.line = 30,
  plot.proportion = FALSE,
  xlim = NULL,
  ylim = NULL,
  legend.x = NULL,
  legend.y = NULL,
  cex.legend = 0.9,
  cex.yaxis = 1,
  cex.xaxis = NULL,
  plot.sample.names = TRUE,
  yaxis.labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_exposure_+3A_exposure">exposure</code></td>
<td>
<p>Exposures as a numerical <code>matrix</code> (or <code>data.frame</code>)
with signatures in rows and samples in columns. Rownames are taken as the
signature names and column names are taken as the sample IDs. If you want
<code>exposure</code> sorted from largest to smallest, use
<code><a href="#topic+sort_exposure">sort_exposure</a></code>. Do not use column names that start with
multiple underscores. The exposures will often be mutation counts, but
could also be e.g. mutations per megabase.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_samples.per.line">samples.per.line</code></td>
<td>
<p>Number of samples to show in each plot.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_plot.proportion">plot.proportion</code></td>
<td>
<p>Plot exposure proportions rather than counts.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_xlim">xlim</code>, <code id="plot_exposure_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axis. If <code>NULL</code>(default), the
function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_legend.x">legend.x</code>, <code id="plot_exposure_+3A_legend.y">legend.y</code></td>
<td>
<p>The x and y co-ordinates to be used to position the
legend.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_cex.legend">cex.legend</code></td>
<td>
<p>A numerical value giving the amount by which legend
plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_cex.yaxis">cex.yaxis</code></td>
<td>
<p>A numerical value giving the amount by which y axis values
should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_cex.xaxis">cex.xaxis</code></td>
<td>
<p>A numerical value giving the amount by which x axis values
should be magnified relative to the default. If
<code>NULL</code>(default), the function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_plot.sample.names">plot.sample.names</code></td>
<td>
<p>Whether to plot sample names below the x axis.
Default is TRUE. Ignored if there are no column names on
<code>exposure</code>.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_yaxis.labels">yaxis.labels</code></td>
<td>
<p>User defined y axis labels to be plotted. If
<code>NULL</code>(default), the function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>. If
<code>ylab</code> is not included, it defaults to a value depending on
<code>plot.proportion</code>. If <code>col</code> is not supplied the function tries to
do something reasonable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <strong>invisible</strong> list.
The first element is a logical value
indicating whether the plot is successful.
The second element is a numeric
vector giving the coordinates of
the bar x-axis midpoints drawn, useful for
adding to the graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
  "Liver-HCC.exposure.csv",
  package = "mSigTools"
)
exposure &lt;- read_exposure(file)
old.par &lt;- par(mar = c(8, 5, 1, 1))
plot_exposure(exposure[, 1:30],
  main = "Liver-HCC exposure", cex.yaxis = 0.8,
  plot.proportion = TRUE
)
par(old.par)
</code></pre>

<hr>
<h2 id='plot_exposure_internal'>Plot a matrix of exposures in a single plot.</h2><span id='topic+plot_exposure_internal'></span>

<h3>Description</h3>

<p>Plot a matrix of exposures in a single plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_exposure_internal(
  exposure,
  plot.proportion = FALSE,
  xlim = NULL,
  ylim = NULL,
  legend.x = NULL,
  legend.y = NULL,
  cex.legend = 0.9,
  cex.yaxis = 1,
  cex.xaxis = NULL,
  plot.sample.names = TRUE,
  yaxis.labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_exposure_internal_+3A_exposure">exposure</code></td>
<td>
<p>Exposures as a numerical <code>matrix</code> (or <code>data.frame</code>)
with signatures in rows and samples in columns. Rownames are taken as the
signature names and column names are taken as the sample IDs. If you want
<code>exposure</code> sorted from largest to smallest, use
<code><a href="#topic+sort_exposure">sort_exposure</a></code>. Do not use column names that start with
multiple underscores. The exposures will often be mutation counts, but
could also be e.g. mutations per megabase.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_plot.proportion">plot.proportion</code></td>
<td>
<p>Plot exposure proportions rather than counts.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_xlim">xlim</code>, <code id="plot_exposure_internal_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axis. If <code>NULL</code>(default), the
function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_legend.x">legend.x</code>, <code id="plot_exposure_internal_+3A_legend.y">legend.y</code></td>
<td>
<p>The x and y co-ordinates to be used to position the
legend.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>A numerical value giving the amount by which legend
plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_cex.yaxis">cex.yaxis</code></td>
<td>
<p>A numerical value giving the amount by which y axis values
should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_cex.xaxis">cex.xaxis</code></td>
<td>
<p>A numerical value giving the amount by which x axis values
should be magnified relative to the default. If
<code>NULL</code>(default), the function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_plot.sample.names">plot.sample.names</code></td>
<td>
<p>Whether to plot sample names below the x axis.
Default is TRUE. Ignored if there are no column names on
<code>exposure</code>.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_yaxis.labels">yaxis.labels</code></td>
<td>
<p>User defined y axis labels to be plotted. If
<code>NULL</code>(default), the function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_internal_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>. If
<code>ylab</code> is not included, it defaults to a value depending on
<code>plot.proportion</code>. If <code>col</code> is not supplied the function tries to
do something reasonable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <strong>invisible</strong> list.
The first element
is a logical value
indicating whether the plot was successful.
The second element is a numeric
vector giving the coordinates of
the bar x-axis midpoints drawn, useful for
adding to the graph.
</p>

<hr>
<h2 id='plot_exposure_to_pdf'>Plot exposures in multiple plots to a single PDF file, with each plot showing
exposures for a manageable number of samples.</h2><span id='topic+plot_exposure_to_pdf'></span>

<h3>Description</h3>

<p>Plot exposures in multiple plots to a single PDF file, with each plot showing
exposures for a manageable number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_exposure_to_pdf(
  exposure,
  file,
  mfrow = c(2, 1),
  mar = c(6, 4, 3, 2),
  oma = c(3, 2, 0, 2),
  samples.per.line = 30,
  plot.proportion = FALSE,
  xlim = NULL,
  ylim = NULL,
  legend.x = NULL,
  legend.y = NULL,
  cex.legend = 0.9,
  cex.yaxis = 1,
  cex.xaxis = NULL,
  plot.sample.names = TRUE,
  yaxis.labels = NULL,
  width = 8.2677,
  height = 11.6929,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_exposure_to_pdf_+3A_exposure">exposure</code></td>
<td>
<p>Exposures as a numerical <code>matrix</code> (or <code>data.frame</code>)
with signatures in rows and samples in columns. Rownames are taken as the
signature names and column names are taken as the sample IDs. If you want
<code>exposure</code> sorted from largest to smallest, use
<code><a href="#topic+sort_exposure">sort_exposure</a></code>. Do not use column names that start with
multiple underscores. The exposures will often be mutation counts, but
could also be e.g. mutations per megabase.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_file">file</code></td>
<td>
<p>The name of the PDF file to be produced.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_mfrow">mfrow</code></td>
<td>
<p>A vector of the form <code>c(nr, nc)</code>.
Subsequent figures will be drawn in an <code>nr</code>-by-<code>nc</code>
array on the device by rows.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom,
left, top, right)</code> which gives the number of lines of margin to be
specified on the four sides of the plot.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_oma">oma</code></td>
<td>
<p>A vector of the form <code>c(bottom, left, top,
right)</code> giving the size of the outer margins in lines of text.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_samples.per.line">samples.per.line</code></td>
<td>
<p>Number of samples to show in each plot.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_plot.proportion">plot.proportion</code></td>
<td>
<p>Plot exposure proportions rather than counts.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_xlim">xlim</code>, <code id="plot_exposure_to_pdf_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axis. If <code>NULL</code>(default), the
function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_legend.x">legend.x</code>, <code id="plot_exposure_to_pdf_+3A_legend.y">legend.y</code></td>
<td>
<p>The x and y co-ordinates to be used to position the
legend.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_cex.legend">cex.legend</code></td>
<td>
<p>A numerical value giving the amount by which legend
plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_cex.yaxis">cex.yaxis</code></td>
<td>
<p>A numerical value giving the amount by which y axis values
should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_cex.xaxis">cex.xaxis</code></td>
<td>
<p>A numerical value giving the amount by which x axis values
should be magnified relative to the default. If
<code>NULL</code>(default), the function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_plot.sample.names">plot.sample.names</code></td>
<td>
<p>Whether to plot sample names below the x axis.
Default is TRUE. Ignored if there are no column names on
<code>exposure</code>.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_yaxis.labels">yaxis.labels</code></td>
<td>
<p>User defined y axis labels to be plotted. If
<code>NULL</code>(default), the function tries to do something reasonable.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_width">width</code>, <code id="plot_exposure_to_pdf_+3A_height">height</code></td>
<td>
<p>The width and height of the graphics region in inches.</p>
</td></tr>
<tr><td><code id="plot_exposure_to_pdf_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>. If
<code>ylab</code> is not included, it defaults to a value depending on
<code>plot.proportion</code>. If <code>col</code> is not supplied the function tries to
do something reasonable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <strong>invisible</strong> list.
The first element is a logical value
indicating whether the plot is successful.
The second element is a numeric
vector giving the coordinates of
the bar x-axis midpoints drawn, useful for
adding to the graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
  "Liver-HCC.exposure.csv",
  package = "mSigTools"
)
exposure &lt;- read_exposure(file)
plot_exposure_to_pdf(exposure,
  file = file.path(tempdir(), "Liver-HCC.exposure.pdf"),
  cex.yaxis = 0.8, plot.proportion = TRUE
)
</code></pre>

<hr>
<h2 id='read_exposure'>Read an exposure matrix from a file.</h2><span id='topic+read_exposure'></span>

<h3>Description</h3>

<p>Read an exposure matrix from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_exposure(file, check.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_exposure_+3A_file">file</code></td>
<td>
<p>File path to a CSV file containing an exposure matrix, i.e.
the numbers of mutations due to each mutational signature.
Each row corresponds to a mutational signature an each
column corresponds to a tumor or other biological sample.</p>
</td></tr>
<tr><td><code id="read_exposure_+3A_check.names">check.names</code></td>
<td>
<p>Passed to <code>read.csv</code>.
<strong>IMPORTANT</strong>: If <code>TRUE</code> this will replace the double
colon in identifiers of the form &lt;tumor_type&gt;::&lt;sample_id&gt;
with two periods (i.e. &lt;tumor_type&gt;..&lt;sample_id&gt;.
If <code>check.names</code> is true, generate a warning
if double colons were present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical matrix of exposures, with the same
shape as the contents of <code>file</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
  "Liver-HCC.exposure.csv",
  package = "mSigTools"
)
exposure &lt;- read_exposure(file)
</code></pre>

<hr>
<h2 id='sig_dist_matrix'>Compute a matrix of distances / similarities between two sets of signatures.</h2><span id='topic+sig_dist_matrix'></span>

<h3>Description</h3>

<p>Compute a matrix of distances / similarities between two sets of signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_dist_matrix(x1, x2, method = "cosine")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_dist_matrix_+3A_x1">x1</code></td>
<td>
<p>The first set of signatures (a numerical matrix-like object
in which each column is a signature).</p>
</td></tr>
<tr><td><code id="sig_dist_matrix_+3A_x2">x2</code></td>
<td>
<p>The second set of signatures, similar data type to <code>x1</code>,
and must have the same number of rows as <code>x1</code>.</p>
</td></tr>
<tr><td><code id="sig_dist_matrix_+3A_method">method</code></td>
<td>
<p>As for the <code><a href="philentropy.html#topic+distance">distance</a></code> function in package
<code>philenropy</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with dimensions
<code>ncol(x1)</code> X <code>ncol(x2)</code>.
Each element represents the distance or
similarity (depending on <code>method</code>)
between a column in <code>x1</code> and a column in <code>x2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex.sigs &lt;- matrix(c(0.2, 0.8, 0.3, 0.7, 0.4, 0.6), nrow = 2)
colnames(ex.sigs) &lt;- c("ex1", "ex2", "ex3")
ref.sigs &lt;- matrix(c(0.21, 0.79, 0.19, 0.81), nrow = 2)
colnames(ref.sigs) &lt;- c("ref1", "ref2")
sig_dist_matrix(ex.sigs, ref.sigs)

</code></pre>

<hr>
<h2 id='sort_exposure'>Sort columns of an exposure matrix based on the number of mutations in each sample (column).</h2><span id='topic+sort_exposure'></span>

<h3>Description</h3>

<p>Sort columns of an exposure matrix based on the number of mutations in each sample (column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_exposure(exposure, decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_exposure_+3A_exposure">exposure</code></td>
<td>
<p>Exposures as a numerical matrix (or data.frame) with
signatures in rows and samples in columns. Rownames are taken as the
signature names and column names are taken as the sample IDs.</p>
</td></tr>
<tr><td><code id="sort_exposure_+3A_decreasing">decreasing</code></td>
<td>
<p>If <code>TRUE</code>, sort from largest to smallest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>exposure</code> with columns sorted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
  "Liver-HCC.exposure.csv",
  package = "mSigTools"
)
exposure &lt;- read_exposure(file)
exposure.sorted &lt;- sort_exposure(exposure)
</code></pre>

<hr>
<h2 id='TP_FP_FN_avg_sim'>Find best matches (by cosine similarity) of a set of mutational signatures to
a set of reference mutational signatures.</h2><span id='topic+TP_FP_FN_avg_sim'></span>

<h3>Description</h3>

<p>Find best matches (by cosine similarity) of a set of mutational signatures to
a set of reference mutational signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TP_FP_FN_avg_sim(extracted.sigs, reference.sigs, similarity.cutoff = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TP_FP_FN_avg_sim_+3A_extracted.sigs">extracted.sigs</code></td>
<td>
<p>Mutational signatures discovered by some analysis.
A numerical-matrix-like object with columns as signatures.</p>
</td></tr>
<tr><td><code id="TP_FP_FN_avg_sim_+3A_reference.sigs">reference.sigs</code></td>
<td>
<p>A numerical-matrix-like object with columns
as signatures. This matrix should contain the
reference mutational signatures. For example,
these might be from a synthetic data set or they
could be from reference set of signatures,
such as the signatures at the COSMIC mutational
signatures web site. See CRAN package cosmicsig.</p>
</td></tr>
<tr><td><code id="TP_FP_FN_avg_sim_+3A_similarity.cutoff">similarity.cutoff</code></td>
<td>
<p>A signature in <code>reference.sigs</code>
must be matched
by <code>&gt;= similarity.cutoff</code> by a signature in <code>extracted.sigs</code>
to be considered detected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Match signatures in <code>extracted.sigs</code> to
signatures in <code>reference.sigs</code> using <code><a href="#topic+match_two_sig_sets">match_two_sig_sets</a></code>
based on cosine similarity.
</p>


<h3>Value</h3>

<p>A list with the elements
</p>

<ul>
<li> <p><code>TP</code> The number of true positive extracted signatures.
</p>
</li>
<li> <p><code>FP</code> The number of false positive extracted signatures.
</p>
</li>
<li> <p><code>FN</code> The number of false negative reference signatures.
</p>
</li>
<li> <p><code>avg.cos.sim</code> The average cosine similarity of
true positives to their matching reference signatures.
</p>
</li>
<li> <p><code>table</code> A data.frame of extracted signatures
that matched a reference signature.
Each row contains the extracted signature name,
the reference signature name, and the
cosine similarity of the match.
</p>
</li>
<li> <p><code>sim.matrix</code> The numeric distance or similarity
matrix between <code>extracted.sigs</code> and
<code>reference.sigs</code> as returned from
<code><a href="#topic+sig_dist_matrix">sig_dist_matrix</a></code>.
</p>
</li>
<li> <p><code>unmatched.ex.sigs</code> The identifiers of
the extracted signatures that did not match a
reference signature.
</p>
</li>
<li> <p><code>unmatched.ref.sigs</code> The identifiers of
the reference signatures that did not match an
extracted signature.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ex.sigs &lt;- matrix(c(0.2, 0.8, 0.3, 0.7, 0.6, 0.4), nrow = 2)
colnames(ex.sigs) &lt;- c("ex1", "ex2", "ex3")
ref.sigs &lt;- matrix(c(0.21, 0.79, 0.19, 0.81), nrow = 2)
colnames(ref.sigs) &lt;- c("ref1", "ref2")
TP_FP_FN_avg_sim(
  extracted.sigs = ex.sigs,
  reference.sigs = ref.sigs,
  similarity.cutoff = .9
)

</code></pre>

<hr>
<h2 id='write_exposure'>Write an exposure matrix to a file.</h2><span id='topic+write_exposure'></span>

<h3>Description</h3>

<p>Write an exposure matrix to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_exposure(exposure, file, row.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_exposure_+3A_exposure">exposure</code></td>
<td>
<p>Exposures as a numerical matrix (or data.frame) with
signatures in rows and samples in columns. Rownames are taken as the
signature names and column names are taken as the sample IDs.</p>
</td></tr>
<tr><td><code id="write_exposure_+3A_file">file</code></td>
<td>
<p>File to which to write the exposure matrix (as a CSV file).</p>
</td></tr>
<tr><td><code id="write_exposure_+3A_row.names">row.names</code></td>
<td>
<p>Either a logical value indicating whether the row names of
<code>exposure</code> are to be written along with <code>exposure</code>, or a
character vector of row names to be written.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
  "Liver-HCC.exposure.csv",
  package = "mSigTools"
)
exposure &lt;- read_exposure(file)
write_exposure(exposure, file = file.path(tempdir(), "Liver-HCC.exposure.csv"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
