<!DOCTYPE html><html><head><title>Help for package dbplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dbplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrange.tbl_lazy'><p>Arrange rows by column values</p></a></li>
<li><a href='#backend-access'><p>Backend: MS Access</p></a></li>
<li><a href='#backend-hana'><p>Backend: SAP HANA</p></a></li>
<li><a href='#backend-hive'><p>Backend: Hive</p></a></li>
<li><a href='#backend-impala'><p>Backend: Impala</p></a></li>
<li><a href='#backend-mssql'><p>Backend: SQL server</p></a></li>
<li><a href='#backend-mysql'><p>Backend: MySQL/MariaDB</p></a></li>
<li><a href='#backend-odbc'><p>Backend: ODBC</p></a></li>
<li><a href='#backend-oracle'><p>Backend: Oracle</p></a></li>
<li><a href='#backend-postgres'><p>Backend: PostgreSQL</p></a></li>
<li><a href='#backend-redshift'><p>Backend: Redshift</p></a></li>
<li><a href='#backend-snowflake'><p>Backend: Snowflake</p></a></li>
<li><a href='#backend-spark-sql'><p>Backend: Databricks Spark SQL</p></a></li>
<li><a href='#backend-sqlite'><p>Backend: SQLite</p></a></li>
<li><a href='#backend-teradata'><p>Backend: Teradata</p></a></li>
<li><a href='#build_sql'><p>Build a SQL string.</p></a></li>
<li><a href='#collapse.tbl_sql'><p>Compute results of a query</p></a></li>
<li><a href='#complete.tbl_lazy'><p>Complete a SQL table with missing combinations of data</p></a></li>
<li><a href='#copy_inline'><p>Use a local data frame in a dbplyr query</p></a></li>
<li><a href='#copy_to.src_sql'><p>Copy a local data frame to a remote database</p></a></li>
<li><a href='#count.tbl_lazy'><p>Count observations by group</p></a></li>
<li><a href='#db-io'><p>Database I/O generics</p></a></li>
<li><a href='#db-misc'><p>Miscellaneous database generics</p></a></li>
<li><a href='#db-quote'><p>SQL escaping/quoting generics</p></a></li>
<li><a href='#db-sql'><p>SQL generation generics</p></a></li>
<li><a href='#dbplyr_uncount'><p>&quot;Uncount&quot; a database table</p></a></li>
<li><a href='#dbplyr-package'><p>dbplyr: A 'dplyr' Back End for Databases</p></a></li>
<li><a href='#dbplyr-slice'><p>Subset rows using their positions</p></a></li>
<li><a href='#distinct.tbl_lazy'><p>Subset distinct/unique rows</p></a></li>
<li><a href='#do.tbl_sql'><p>Perform arbitrary computation on remote backend</p></a></li>
<li><a href='#escape'><p>Escape/quote a string.</p></a></li>
<li><a href='#expand.tbl_lazy'><p>Expand SQL tables to include all possible combinations of values</p></a></li>
<li><a href='#fill.tbl_lazy'><p>Fill in missing values with previous or next value</p></a></li>
<li><a href='#filter.tbl_lazy'><p>Subset rows using column values</p></a></li>
<li><a href='#get_returned_rows'><p>Extract and check the <code>RETURNING</code> rows</p></a></li>
<li><a href='#group_by.tbl_lazy'><p>Group by one or more variables</p></a></li>
<li><a href='#head.tbl_lazy'><p>Subset the first rows</p></a></li>
<li><a href='#ident'><p>Flag a character vector as SQL identifiers</p></a></li>
<li><a href='#ident_q'><p>Declare a identifier as being pre-quoted.</p></a></li>
<li><a href='#in_schema'><p>Refer to a table in a schema or a database catalog</p></a></li>
<li><a href='#intersect.tbl_lazy'><p>SQL set operations</p></a></li>
<li><a href='#join.tbl_sql'><p>Join SQL tables</p></a></li>
<li><a href='#lahman'><p>Cache and retrieve an <code>src_sqlite</code> of the Lahman baseball database.</p></a></li>
<li><a href='#lazy_multi_join_query'><p>Build and render SQL from a sequence of lazy operations</p></a></li>
<li><a href='#lazy_ops'><p>Lazy operations</p></a></li>
<li><a href='#memdb_frame'><p>Create a database table in temporary in-memory database.</p></a></li>
<li><a href='#mutate.tbl_lazy'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#named_commas'><p>Provides comma-separated string out of the parameters</p></a></li>
<li><a href='#nycflights13'><p>Database versions of the nycflights13 data</p></a></li>
<li><a href='#partial_eval'><p>Partially evaluate an expression.</p></a></li>
<li><a href='#pivot_longer.tbl_lazy'><p>Pivot data from wide to long</p></a></li>
<li><a href='#pivot_wider.tbl_lazy'><p>Pivot data from long to wide</p></a></li>
<li><a href='#pull.tbl_sql'><p>Extract a single column</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remote_name'><p>Metadata about a remote table</p></a></li>
<li><a href='#replace_na.tbl_lazy'><p>Replace NAs with specified values</p></a></li>
<li><a href='#rows_insert.tbl_lazy'><p>Edit individual rows in the underlying database table</p></a></li>
<li><a href='#select.tbl_lazy'><p>Subset, rename, and reorder columns using their names</p></a></li>
<li><a href='#simulate_dbi'><p>Simulate database connections</p></a></li>
<li><a href='#sql'><p>SQL escaping.</p></a></li>
<li><a href='#sql_expr'><p>Generate SQL from R expressions</p></a></li>
<li><a href='#sql_options'><p>Options for generating SQL</p></a></li>
<li><a href='#sql_query_insert'><p>Generate SQL for Insert, Update, Upsert, and Delete</p></a></li>
<li><a href='#sql_quote'><p>Helper function for quoting sql elements.</p></a></li>
<li><a href='#sql_substr'><p>Create an sql translator</p></a></li>
<li><a href='#src_dbi'><p>Database src</p></a></li>
<li><a href='#src_sql'><p>Create a &quot;sql src&quot; object</p></a></li>
<li><a href='#summarise.tbl_lazy'><p>Summarise each group to one row</p></a></li>
<li><a href='#tbl_lazy'><p>Create a local lazy tibble</p></a></li>
<li><a href='#tbl_sql'><p>Create an SQL tbl (abstract)</p></a></li>
<li><a href='#tbl.src_dbi'><p>Use dplyr verbs with a remote database table</p></a></li>
<li><a href='#testing'><p>Infrastructure for testing dplyr</p></a></li>
<li><a href='#translate_sql'><p>Translate an expression to SQL</p></a></li>
<li><a href='#win_over'><p>Generate SQL expression for window functions</p></a></li>
<li><a href='#window_order'><p>Override window order and frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A 'dplyr' Back End for Databases</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'dplyr' back end for databases that allows you to work with
    remote database tables as if they are in-memory data frames.  Basic
    features works with any database that has a 'DBI' back end; more
    advanced features require 'SQL' translation to be provided by the
    package author.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dbplyr.tidyverse.org/">https://dbplyr.tidyverse.org/</a>, <a href="https://github.com/tidyverse/dbplyr">https://github.com/tidyverse/dbplyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/dbplyr/issues">https://github.com/tidyverse/dbplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>blob (&ge; 1.2.0), cli (&ge; 3.6.1), DBI (&ge; 1.1.3), dplyr (&ge;
1.1.2), glue (&ge; 1.6.2), lifecycle (&ge; 1.0.3), magrittr,
methods, pillar (&ge; 1.9.0), purrr (&ge; 1.0.1), R6 (&ge; 2.2.2),
rlang (&ge; 1.1.1), tibble (&ge; 3.2.1), tidyr (&ge; 1.3.0),
tidyselect (&ge; 1.2.0), utils, vctrs (&ge; 0.6.3), withr (&ge;
2.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, covr, knitr, Lahman, nycflights13, odbc, RMariaDB (&ge;
1.2.2), rmarkdown, RPostgres (&ge; 1.4.5), RPostgreSQL, RSQLite
(&ge; 2.3.1), testthat (&ge; 3.1.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-gb</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'db-sql.R' 'utils-check.R' 'import-standalone-types-check.R'
'import-standalone-obj-type.R' 'utils.R' 'sql.R' 'escape.R'
'translate-sql-cut.R' 'translate-sql-quantile.R'
'translate-sql-string.R' 'translate-sql-paste.R'
'translate-sql-helpers.R' 'translate-sql-window.R'
'translate-sql-conditional.R' 'backend-.R' 'backend-access.R'
'backend-hana.R' 'backend-hive.R' 'backend-impala.R'
'verb-copy-to.R' 'backend-mssql.R' 'backend-mysql.R'
'backend-odbc.R' 'backend-oracle.R' 'backend-postgres.R'
'backend-postgres-old.R' 'backend-redshift.R'
'backend-snowflake.R' 'backend-spark-sql.R' 'backend-sqlite.R'
'backend-teradata.R' 'build-sql.R' 'data-cache.R'
'data-lahman.R' 'data-nycflights13.R' 'db-escape.R' 'db-io.R'
'db.R' 'dbplyr.R' 'explain.R' 'ident.R' 'join-by-compat.R'
'join-cols-compat.R' 'lazy-join-query.R' 'lazy-ops.R'
'lazy-query.R' 'lazy-select-query.R' 'lazy-set-op-query.R'
'memdb.R' 'optimise-utils.R' 'pillar.R' 'progress.R'
'sql-build.R' 'query-join.R' 'query-select.R'
'query-semi-join.R' 'query-set-op.R' 'query.R' 'reexport.R'
'remote.R' 'rows.R' 'schema.R' 'simulate.R' 'sql-clause.R'
'sql-expr.R' 'src-sql.R' 'src_dbi.R' 'table-ident.R'
'tbl-lazy.R' 'tbl-sql.R' 'test-frame.R' 'testthat.R'
'tidyeval-across.R' 'tidyeval.R' 'translate-sql.R'
'utils-format.R' 'verb-arrange.R' 'verb-compute.R'
'verb-count.R' 'verb-distinct.R' 'verb-do-query.R' 'verb-do.R'
'verb-expand.R' 'verb-fill.R' 'verb-filter.R' 'verb-group_by.R'
'verb-head.R' 'verb-joins.R' 'verb-mutate.R'
'verb-pivot-longer.R' 'verb-pivot-wider.R' 'verb-pull.R'
'verb-select.R' 'verb-set-ops.R' 'verb-slice.R'
'verb-summarise.R' 'verb-uncount.R' 'verb-window.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-25 20:30:22 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Maximilian Girlich [aut],
  Edgar Ruiz [aut],
  RStudio [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-26 07:40:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; ; 2024-01-02 08:45:41 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='arrange.tbl_lazy'>Arrange rows by column values</h2><span id='topic+arrange.tbl_lazy'></span>

<h3>Description</h3>

<p>This is an method for the dplyr <code><a href="dplyr.html#topic+arrange">arrange()</a></code> generic. It generates
the <code style="white-space: pre;">&#8288;ORDER BY&#8288;</code> clause of the SQL query. It also affects the
<code><a href="dbplyr.html#topic+window_order">window_order()</a></code> of windowed expressions in <code><a href="dbplyr.html#topic+mutate.tbl_lazy">mutate.tbl_lazy()</a></code>.
</p>
<p>Note that <code style="white-space: pre;">&#8288;ORDER BY&#8288;</code> clauses can not generally appear in subqueries, which
means that you should <code>arrange()</code> as late as possible in your pipelines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
arrange(.data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="arrange.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="arrange.tbl_lazy_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Missing values</h3>

<p>Unlike R, most databases sorts <code>NA</code> (<code>NULL</code>s) at the front. You can
can override this behaviour by explicitly sorting on <code>is.na(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA))
db %&gt;% arrange(a) %&gt;% show_query()

# Note that NAs are sorted first
db %&gt;% arrange(b)
# override by sorting on is.na() first
db %&gt;% arrange(is.na(b), b)
</code></pre>

<hr>
<h2 id='backend-access'>Backend: MS Access</h2><span id='topic+simulate_access'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li> <p><code>SELECT</code> uses <code>TOP</code>, not <code>LIMIT</code>
</p>
</li>
<li><p> Non-standard types and mathematical functions
</p>
</li>
<li><p> String concatenation uses <code>&amp;</code>
</p>
</li>
<li><p> No <code>ANALYZE</code> equivalent
</p>
</li>
<li> <p><code>TRUE</code> and <code>FALSE</code> converted to 1 and 0
</p>
</li></ul>

<p>Use <code>simulate_access()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_access()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
lf &lt;- lazy_frame(x = 1, y = 2, z = "a", con = simulate_access())

lf %&gt;% head()
lf %&gt;% mutate(y = as.numeric(y), z = sqrt(x^2 + 10))
lf %&gt;% mutate(a = paste0(z, " times"))
</code></pre>

<hr>
<h2 id='backend-hana'>Backend: SAP HANA</h2><span id='topic+simulate_hana'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li><p> Temporary tables get <code style="white-space: pre;">&#8288;#&#8288;</code> prefix and use <code style="white-space: pre;">&#8288;LOCAL TEMPORARY COLUMN&#8288;</code>.
</p>
</li>
<li><p> No table analysis performed in <code><a href="dplyr.html#topic+copy_to">copy_to()</a></code>.
</p>
</li>
<li> <p><code>paste()</code> uses <code>||</code>
</p>
</li>
<li><p> Note that you can't create new boolean columns from logical expressions;
you need to wrap with explicit <code>ifelse</code>: <code>ifelse(x &gt; y, TRUE, FALSE)</code>.
</p>
</li></ul>

<p>Use <code>simulate_hana()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hana()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_hana())
lf %&gt;% transmute(x = paste0(d, " times"))
</code></pre>

<hr>
<h2 id='backend-hive'>Backend: Hive</h2><span id='topic+simulate_hive'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are a scattering of custom translations provided by users.
</p>
<p>Use <code>simulate_hive()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hive()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, d = 2, c = "z", con = simulate_hive())
lf %&gt;% transmute(x = cot(b))
lf %&gt;% transmute(x = bitwShiftL(c, 1L))
lf %&gt;% transmute(x = str_replace_all(c, "a", "b"))

lf %&gt;% summarise(x = median(d, na.rm = TRUE))
lf %&gt;% summarise(x = var(c, na.rm = TRUE))
</code></pre>

<hr>
<h2 id='backend-impala'>Backend: Impala</h2><span id='topic+simulate_impala'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are a scattering of custom translations provided by users, mostly focussed
on bitwise operations.
</p>
<p>Use <code>simulate_impala()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_impala()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_impala())
lf %&gt;% transmute(X = bitwNot(bitwOr(b, c)))
</code></pre>

<hr>
<h2 id='backend-mssql'>Backend: SQL server</h2><span id='topic+simulate_mssql'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li> <p><code>SELECT</code> uses <code>TOP</code> not <code>LIMIT</code>
</p>
</li>
<li><p> Automatically prefixes <code style="white-space: pre;">&#8288;#&#8288;</code> to create temporary tables. Add the prefix
yourself to avoid the message.
</p>
</li>
<li><p> String basics: <code>paste()</code>, <code>substr()</code>, <code>nchar()</code>
</p>
</li>
<li><p> Custom types for <code style="white-space: pre;">&#8288;as.*&#8288;</code> functions
</p>
</li>
<li><p> Lubridate extraction functions, <code>year()</code>, <code>month()</code>, <code>day()</code> etc
</p>
</li>
<li><p> Semi-automated bit &lt;-&gt; boolean translation (see below)
</p>
</li></ul>

<p>Use <code>simulate_mssql()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_mssql(version = "15.0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backend-mssql_+3A_version">version</code></td>
<td>
<p>Version of MS SQL to simulate. Currently only, difference is
that 15.0 and above will use <code>TRY_CAST()</code> instead of <code>CAST()</code>.</p>
</td></tr>
</table>


<h3>Bit vs boolean</h3>

<p>SQL server uses two incompatible types to represent <code>TRUE</code> and <code>FALSE</code>
values:
</p>

<ul>
<li><p> The <code>BOOLEAN</code> type is the result of logical comparisons (e.g. <code>x &gt; y</code>)
and can be used <code>WHERE</code> but not to create new columns in <code>SELECT</code>.
<a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/comparison-operators-transact-sql">https://docs.microsoft.com/en-us/sql/t-sql/language-elements/comparison-operators-transact-sql</a>
</p>
</li>
<li><p> The <code>BIT</code> type is a special type of numeric column used to store
<code>TRUE</code> and <code>FALSE</code> values, but can't be used in <code>WHERE</code> clauses.
<a href="https://learn.microsoft.com/en-us/sql/t-sql/data-types/bit-transact-sql?view=sql-server-ver15">https://learn.microsoft.com/en-us/sql/t-sql/data-types/bit-transact-sql?view=sql-server-ver15</a>
</p>
</li></ul>

<p>dbplyr does its best to automatically create the correct type when needed,
but can't do it 100% correctly because it does not have a full type
inference system. This means that you many need to manually do conversions
from time to time.
</p>

<ul>
<li><p> To convert from bit to boolean use <code>x == 1</code>
</p>
</li>
<li><p> To convert from boolean to bit use <code style="white-space: pre;">&#8288;as.logical(if(x, 0, 1))&#8288;</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_mssql())
lf %&gt;% head()
lf %&gt;% transmute(x = paste(b, c, d))

# Can use boolean as is:
lf %&gt;% filter(c &gt; d)
# Need to convert from boolean to bit:
lf %&gt;% transmute(x = c &gt; d)
# Can use boolean as is:
lf %&gt;% transmute(x = ifelse(c &gt; d, "c", "d"))
</code></pre>

<hr>
<h2 id='backend-mysql'>Backend: MySQL/MariaDB</h2><span id='topic+simulate_mysql'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li> <p><code>paste()</code> uses <code>CONCAT_WS()</code>
</p>
</li>
<li><p> String translations for <code>str_detect()</code>, <code>str_locate()</code>, and
<code>str_replace_all()</code>
</p>
</li>
<li><p> Clear error message for unsupported full joins
</p>
</li></ul>

<p>Use <code>simulate_mysql()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_mysql()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_mysql())
lf %&gt;% transmute(x = paste0(d, " times"))
</code></pre>

<hr>
<h2 id='backend-odbc'>Backend: ODBC</h2><span id='topic+simulate_odbc'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are minor translations for common data types.
</p>
<p>Use <code>simulate_odbc()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_odbc()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, d = 2, c = "z", con = simulate_odbc())
lf %&gt;% transmute(x = as.numeric(b))
lf %&gt;% transmute(x = as.integer(b))
lf %&gt;% transmute(x = as.character(b))
</code></pre>

<hr>
<h2 id='backend-oracle'>Backend: Oracle</h2><span id='topic+simulate_oracle'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li><p> Use <code style="white-space: pre;">&#8288;FETCH FIRST&#8288;</code> instead of <code>LIMIT</code>
</p>
</li>
<li><p> Custom types
</p>
</li>
<li> <p><code>paste()</code> uses <code>||</code>
</p>
</li>
<li><p> Custom subquery generation (no <code>AS</code>)
</p>
</li>
<li> <p><code>setdiff()</code> uses <code>MINUS</code> instead of <code>EXCEPT</code>
</p>
</li></ul>

<p>Use <code>simulate_oracle()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_oracle()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_oracle())
lf %&gt;% transmute(x = paste0(c, " times"))
lf %&gt;% setdiff(lf)
</code></pre>

<hr>
<h2 id='backend-postgres'>Backend: PostgreSQL</h2><span id='topic+simulate_postgres'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li><p> Many stringr functions
</p>
</li>
<li><p> lubridate date-time extraction functions
</p>
</li>
<li><p> More standard statistical summaries
</p>
</li></ul>

<p>Use <code>simulate_postgres()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_postgres()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_postgres())
lf %&gt;% summarise(x = sd(b, na.rm = TRUE))
lf %&gt;% summarise(y = cor(b, c), z = cov(b, c))
</code></pre>

<hr>
<h2 id='backend-redshift'>Backend: Redshift</h2><span id='topic+simulate_redshift'></span>

<h3>Description</h3>

<p>Base translations come from <a href="dbplyr.html#topic+simulate_postgres">PostgreSQL backend</a>. There
are generally few differences, apart from string manipulation.
</p>
<p>Use <code>simulate_redshift()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_redshift()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_redshift())
lf %&gt;% transmute(x = paste(c, " times"))
lf %&gt;% transmute(x = substr(c, 2, 3))
lf %&gt;% transmute(x = str_replace_all(c, "a", "z"))
</code></pre>

<hr>
<h2 id='backend-snowflake'>Backend: Snowflake</h2><span id='topic+simulate_snowflake'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology.
</p>
<p>Use <code>simulate_snowflake()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_snowflake()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_snowflake())
lf %&gt;% transmute(x = paste0(d, " times"))
</code></pre>

<hr>
<h2 id='backend-spark-sql'>Backend: Databricks Spark SQL</h2><span id='topic+simulate_spark_sql'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are better translation of statistical aggregate functions
(e.g. <code>var()</code>, <code>median()</code>) and use of temporary views instead of temporary
tables when copying data.
</p>
<p>Use <code>simulate_spark_sql()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_spark_sql()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, d = 2, c = "z", con = simulate_spark_sql())

lf %&gt;% summarise(x = median(d, na.rm = TRUE))
lf %&gt;% summarise(x = var(c, na.rm = TRUE), .by = d)

lf %&gt;% mutate(x = first(c))
lf %&gt;% mutate(x = first(c), .by = d)
</code></pre>

<hr>
<h2 id='backend-sqlite'>Backend: SQLite</h2><span id='topic+simulate_sqlite'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li><p> Uses non-standard <code>LOG()</code> function
</p>
</li>
<li><p> Date-time extraction functions from lubridate
</p>
</li>
<li><p> Custom median translation
</p>
</li>
<li><p> Right and full joins are simulated using left joins
</p>
</li></ul>

<p>Use <code>simulate_sqlite()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sqlite()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_sqlite())
lf %&gt;% transmute(x = paste(c, " times"))
lf %&gt;% transmute(x = log(b), y = log(b, base = 2))
</code></pre>

<hr>
<h2 id='backend-teradata'>Backend: Teradata</h2><span id='topic+simulate_teradata'></span>

<h3>Description</h3>

<p>See <code>vignette("translation-function")</code> and <code>vignette("translation-verb")</code> for
details of overall translation technology. Key differences for this backend
are:
</p>

<ul>
<li><p> Uses <code>TOP</code> instead of <code>LIMIT</code>
</p>
</li>
<li><p> Selection of user supplied translations
</p>
</li></ul>

<p>Use <code>simulate_teradata()</code> with <code>lazy_frame()</code> to see simulated SQL without
converting to live access database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_teradata()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

lf &lt;- lazy_frame(a = TRUE, b = 1, c = 2, d = "z", con = simulate_teradata())
lf %&gt;% head()
</code></pre>

<hr>
<h2 id='build_sql'>Build a SQL string.</h2><span id='topic+build_sql'></span>

<h3>Description</h3>

<p>This is a convenience function that should prevent sql injection attacks
(which in the context of dplyr are most likely to be accidental not
deliberate) by automatically escaping all expressions in the input, while
treating bare strings as sql. This is unlikely to prevent any serious
attack, but should make it unlikely that you produce invalid sql.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_sql(..., .env = parent.frame(), con = sql_current_con())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_sql_+3A_...">...</code></td>
<td>
<p>input to convert to SQL. Use <code><a href="dbplyr.html#topic+sql">sql()</a></code> to preserve
user input as is (dangerous), and <code><a href="dbplyr.html#topic+ident">ident()</a></code> to label user
input as sql identifiers (safe)</p>
</td></tr>
<tr><td><code id="build_sql_+3A_.env">.env</code></td>
<td>
<p>the environment in which to evaluate the arguments. Should not
be needed in typical use.</p>
</td></tr>
<tr><td><code id="build_sql_+3A_con">con</code></td>
<td>
<p>database connection; used to select correct quoting characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be used only when generating <code>SELECT</code> clauses,
other high level queries, or for other syntax that has no R equivalent.
For individual function translations, prefer <code><a href="dbplyr.html#topic+sql_expr">sql_expr()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- simulate_dbi()
build_sql("SELECT * FROM TABLE", con = con)
x &lt;- "TABLE"
build_sql("SELECT * FROM ", x, con = con)
build_sql("SELECT * FROM ", ident(x), con = con)
build_sql("SELECT * FROM ", sql(x), con = con)

# http://xkcd.com/327/
name &lt;- "Robert'); DROP TABLE Students;--"
build_sql("INSERT INTO Students (Name) VALUES (", name, ")", con = con)
</code></pre>

<hr>
<h2 id='collapse.tbl_sql'>Compute results of a query</h2><span id='topic+collapse.tbl_sql'></span><span id='topic+compute.tbl_sql'></span><span id='topic+collect.tbl_sql'></span>

<h3>Description</h3>

<p>These are methods for the dplyr generics <code><a href="nlme.html#topic+collapse">collapse()</a></code>, <code><a href="dplyr.html#topic+compute">compute()</a></code>,
and <code><a href="dplyr.html#topic+collect">collect()</a></code>. <code>collapse()</code> creates a subquery, <code>compute()</code> stores
the results in a remote table, and <code>collect()</code> executes the query and
downloads the data into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_sql'
collapse(x, ...)

## S3 method for class 'tbl_sql'
compute(
  x,
  name = NULL,
  temporary = TRUE,
  unique_indexes = list(),
  indexes = list(),
  analyze = TRUE,
  ...,
  cte = FALSE
)

## S3 method for class 'tbl_sql'
collect(x, ..., n = Inf, warn_incomplete = TRUE, cte = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.tbl_sql_+3A_x">x</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_...">...</code></td>
<td>
<p>other parameters passed to methods.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_name">name</code></td>
<td>
<p>Table name in remote database.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_temporary">temporary</code></td>
<td>
<p>Should the table be temporary (<code>TRUE</code>, the default<code style="white-space: pre;">&#8288;) or persistent (&#8288;</code>FALSE')?</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_unique_indexes">unique_indexes</code></td>
<td>
<p>a list of character vectors. Each element of the list
will create a new unique index over the specified column(s). Duplicate rows
will result in failure.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_indexes">indexes</code></td>
<td>
<p>a list of character vectors. Each element of the list
will create a new index.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_analyze">analyze</code></td>
<td>
<p>if <code>TRUE</code> (the default), will automatically ANALYZE the
new table so that the query optimiser has useful information.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_cte">cte</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Use common table expressions in the generated SQL?</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_n">n</code></td>
<td>
<p>Number of rows to fetch. Defaults to <code>Inf</code>, meaning all rows.</p>
</td></tr>
<tr><td><code id="collapse.tbl_sql_+3A_warn_incomplete">warn_incomplete</code></td>
<td>
<p>Warn if <code>n</code> is less than the number of result rows?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA))
db %&gt;% filter(a &lt;= 2) %&gt;% collect()
</code></pre>

<hr>
<h2 id='complete.tbl_lazy'>Complete a SQL table with missing combinations of data</h2><span id='topic+complete.tbl_lazy'></span>

<h3>Description</h3>

<p>Turns implicit missing values into explicit missing values. This is a method
for the <code><a href="tidyr.html#topic+complete">tidyr::complete()</a></code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
complete(data, ..., fill = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete.tbl_lazy_+3A_data">data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="complete.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Specification of columns to expand. See <a href="tidyr.html#topic+expand">tidyr::expand</a> for
more details.</p>
</td></tr>
<tr><td><code id="complete.tbl_lazy_+3A_fill">fill</code></td>
<td>
<p>A named list that for each variable supplies a single value to
use instead of NA for missing combinations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- memdb_frame(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c("a", "b", "b"),
  value1 = 1:3,
  value2 = 4:6
)

df %&gt;% tidyr::complete(group, nesting(item_id, item_name))

# You can also choose to fill in missing values
df %&gt;% tidyr::complete(group, nesting(item_id, item_name), fill = list(value1 = 0))

</code></pre>

<hr>
<h2 id='copy_inline'>Use a local data frame in a dbplyr query</h2><span id='topic+copy_inline'></span>

<h3>Description</h3>

<p>This is an alternative to <code><a href="dplyr.html#topic+copy_to">copy_to()</a></code> that does not need write access and
is faster for small data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_inline(con, df, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_inline_+3A_con">con</code></td>
<td>
<p>A database connection.</p>
</td></tr>
<tr><td><code id="copy_inline_+3A_df">df</code></td>
<td>
<p>A local data frame. The data is written directly in the SQL query
so it should be small.</p>
</td></tr>
<tr><td><code id="copy_inline_+3A_types">types</code></td>
<td>
<p>A named character vector of SQL data types to use for the columns.
The data types are backend specific. For example for Postgres this could
be <code>c(id = "bigint", created_at = "timestamp", values = "integer[]")</code>.
If <code>NULL</code>, the default, the types are determined from <code>df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It writes the data directly in the SQL query via the <code>VALUES</code> clause.
</p>


<h3>Value</h3>

<p>A <code>tbl_lazy</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+copy_to">copy_to()</a></code> to copy the data into a new database table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = 1:3, y = c("a", "b", "c"))
con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

copy_inline(con, df)

copy_inline(con, df) %&gt;% dplyr::show_query()
</code></pre>

<hr>
<h2 id='copy_to.src_sql'>Copy a local data frame to a remote database</h2><span id='topic+copy_to.src_sql'></span>

<h3>Description</h3>

<p>This is an implementation of the dplyr <code><a href="dplyr.html#topic+copy_to">copy_to()</a></code> generic and it mostly
a wrapper around <code><a href="DBI.html#topic+dbWriteTable">DBI::dbWriteTable()</a></code>.
</p>
<p>It is useful for copying small amounts of data to a database for examples,
experiments, and joins. By default, it creates temporary tables which are
only visible within the current connection to the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'src_sql'
copy_to(
  dest,
  df,
  name = deparse(substitute(df)),
  overwrite = FALSE,
  types = NULL,
  temporary = TRUE,
  unique_indexes = NULL,
  indexes = NULL,
  analyze = TRUE,
  ...,
  in_transaction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_to.src_sql_+3A_dest">dest</code></td>
<td>
<p>remote data source</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_df">df</code></td>
<td>
<p>A local data frame, a <code>tbl_sql</code> from same source, or a <code>tbl_sql</code>
from another source. If from another source, all data must transition
through R in one pass, so it is only suitable for transferring small
amounts of data.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_name">name</code></td>
<td>
<p>name for new remote table.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, will overwrite an existing table with
name <code>name</code>. If <code>FALSE</code>, will throw an error if <code>name</code> already
exists.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_types">types</code></td>
<td>
<p>a character vector giving variable types to use for the columns.
See <a href="https://www.sqlite.org/datatype3.html">https://www.sqlite.org/datatype3.html</a> for available types.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_temporary">temporary</code></td>
<td>
<p>if <code>TRUE</code>, will create a temporary table that is
local to this connection and will be automatically deleted when the
connection expires</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_unique_indexes">unique_indexes</code></td>
<td>
<p>a list of character vectors. Each element of the list
will create a new unique index over the specified column(s). Duplicate rows
will result in failure.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_indexes">indexes</code></td>
<td>
<p>a list of character vectors. Each element of the list
will create a new index.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_analyze">analyze</code></td>
<td>
<p>if <code>TRUE</code> (the default), will automatically ANALYZE the
new table so that the query optimiser has useful information.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_...">...</code></td>
<td>
<p>other parameters passed to methods.</p>
</td></tr>
<tr><td><code id="copy_to.src_sql_+3A_in_transaction">in_transaction</code></td>
<td>
<p>Should the table creation be wrapped in a transaction?
This typically makes things faster, but you may want to suppress if the
database doesn't support transactions, or you're wrapping in a transaction
higher up (and your database doesn't support nested transactions.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>See Also</h3>

<p><code><a href="dbplyr.html#topic+copy_inline">copy_inline()</a></code> to use small data in an SQL query without actually
writing to a table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

df &lt;- data.frame(x = 1:5, y = letters[5:1])
db &lt;- copy_to(src_memdb(), df)
db

df2 &lt;- data.frame(y = c("a", "d"), fruit = c("apple", "date"))
# copy_to() is called automatically if you set copy = TRUE
# in the join functions
db %&gt;% left_join(df2, copy = TRUE)
</code></pre>

<hr>
<h2 id='count.tbl_lazy'>Count observations by group</h2><span id='topic+count.tbl_lazy'></span><span id='topic+add_count.tbl_lazy'></span><span id='topic+tally.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <code><a href="dplyr.html#topic+count">count()</a></code> and <code><a href="dplyr.html#topic+tally">tally()</a></code> generics. They
wrap up <code><a href="dbplyr.html#topic+group_by.tbl_lazy">group_by.tbl_lazy()</a></code>, <code><a href="dbplyr.html#topic+summarise.tbl_lazy">summarise.tbl_lazy()</a></code> and, optionally,
<code><a href="dbplyr.html#topic+arrange.tbl_lazy">arrange.tbl_lazy()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
count(x, ..., wt = NULL, sort = FALSE, name = NULL)

## S3 method for class 'tbl_lazy'
add_count(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = NULL)

## S3 method for class 'tbl_lazy'
tally(x, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.tbl_lazy_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="count.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="count.tbl_lazy_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="count.tbl_lazy_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count.tbl_lazy_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="count.tbl_lazy_+3A_.drop">.drop</code></td>
<td>
<p>Not supported for lazy tables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2))
db %&gt;% count(g) %&gt;% show_query()
db %&gt;% count(g, wt = x) %&gt;% show_query()
db %&gt;% count(g, wt = x, sort = TRUE) %&gt;% show_query()
</code></pre>

<hr>
<h2 id='db-io'>Database I/O generics</h2><span id='topic+db_copy_to'></span><span id='topic+db_compute'></span><span id='topic+db_collect'></span><span id='topic+db_table_temporary'></span>

<h3>Description</h3>

<p>These generics are responsible for getting data into and out of the
database. They should be used a last resort - only use them when you can't
make a backend work by providing methods for DBI generics, or for dbplyr's
SQL generation generics. They tend to be most needed when a backend has
special handling of temporary tables.
</p>

<ul>
<li> <p><code>db_copy_to()</code> implements <code><a href="dbplyr.html#topic+copy_to.src_sql">copy_to.src_sql()</a></code> by calling
<code>db_write_table()</code> (which calls <code><a href="DBI.html#topic+dbWriteTable">DBI::dbWriteTable()</a></code>) to transfer the
data, then optionally adds indexes (via <code><a href="dbplyr.html#topic+sql_table_index">sql_table_index()</a></code>) and
analyses (via <code><a href="dbplyr.html#topic+sql_table_analyze">sql_table_analyze()</a></code>).
</p>
</li>
<li> <p><code>db_compute()</code> implements <code><a href="dbplyr.html#topic+compute.tbl_sql">compute.tbl_sql()</a></code> by calling
<code><a href="dbplyr.html#topic+sql_query_save">sql_query_save()</a></code> to create the table, then optionally adds indexes
(via <code><a href="dbplyr.html#topic+sql_table_index">sql_table_index()</a></code>) and analyses (via <code><a href="dbplyr.html#topic+sql_table_analyze">sql_table_analyze()</a></code>).
</p>
</li>
<li> <p><code>db_collect()</code> implements <code><a href="dbplyr.html#topic+collect.tbl_sql">collect.tbl_sql()</a></code> using <code><a href="DBI.html#topic+dbSendQuery">DBI::dbSendQuery()</a></code>
and <code><a href="DBI.html#topic+dbFetch">DBI::dbFetch()</a></code>.
</p>
</li>
<li> <p><code>db_table_temporary()</code> is used for databases that have special naming
schemes for temporary tables (e.g. SQL server and SAP HANA require
temporary tables to start with <code style="white-space: pre;">&#8288;#&#8288;</code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>db_copy_to(
  con,
  table,
  values,
  ...,
  overwrite = FALSE,
  types = NULL,
  temporary = TRUE,
  unique_indexes = NULL,
  indexes = NULL,
  analyze = TRUE,
  in_transaction = TRUE
)

db_compute(
  con,
  table,
  sql,
  ...,
  overwrite = FALSE,
  temporary = TRUE,
  unique_indexes = list(),
  indexes = list(),
  analyze = TRUE,
  in_transaction = TRUE
)

db_collect(con, sql, n = -1, warn_incomplete = TRUE, ...)

db_table_temporary(con, table, temporary, ...)
</code></pre>


<h3>See Also</h3>

<p>Other generic: 
<code><a href="dbplyr.html#topic+db-sql">db-sql</a></code>,
<code><a href="dbplyr.html#topic+db_connection_describe">db_connection_describe</a>()</code>,
<code><a href="dbplyr.html#topic+sql_escape_logical">sql_escape_logical</a>()</code>
</p>

<hr>
<h2 id='db-misc'>Miscellaneous database generics</h2><span id='topic+db_connection_describe'></span><span id='topic+sql_join_suffix'></span><span id='topic+db_sql_render'></span><span id='topic+db_col_types'></span><span id='topic+dbplyr_edition'></span>

<h3>Description</h3>


<ul>
<li> <p><code>db_connection_describe()</code> provides a short string describing the
database connection, helping users tell which database a table comes
from. It should be a single line, and ideally less than 60 characters wide.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>db_connection_describe(con, ...)

sql_join_suffix(con, suffix, ...)

db_sql_render(con, sql, ..., cte = FALSE, sql_options = NULL)

db_col_types(con, table, call)

dbplyr_edition(con)
</code></pre>


<h3>Details</h3>


<ul>
<li> <p><code>dbplyr_edition()</code> declares which version of the dbplyr API you want.
See below for more details.
</p>
</li>
<li> <p><code>db_col_types()</code> returns the column types of a table.
</p>
</li></ul>



<h3>dbplyr 2.0.0</h3>

<p>dbplyr 2.0.0 renamed a number of generics so that they could be cleanly moved
from dplyr to dbplyr. If you have an existing backend, you'll need to rename
the following methods.
</p>

<ul>
<li> <p><code>dplyr::db_desc()</code> -&gt; <code>dbplyr::db_connection_describe()</code> (also note that
the argument named changed from <code>x</code> to <code>con</code>).
</p>
</li></ul>



<h3>See Also</h3>

<p>Other generic: 
<code><a href="dbplyr.html#topic+db-sql">db-sql</a></code>,
<code><a href="dbplyr.html#topic+db_copy_to">db_copy_to</a>()</code>,
<code><a href="dbplyr.html#topic+sql_escape_logical">sql_escape_logical</a>()</code>
</p>

<hr>
<h2 id='db-quote'>SQL escaping/quoting generics</h2><span id='topic+sql_escape_logical'></span><span id='topic+sql_escape_date'></span><span id='topic+sql_escape_datetime'></span><span id='topic+sql_escape_raw'></span>

<h3>Description</h3>

<p>These generics translate individual values into SQL. The core
generics are <code><a href="DBI.html#topic+dbQuoteIdentifier">DBI::dbQuoteIdentifier()</a></code> and<a href="DBI.html#topic+dbQuoteString">DBI::dbQuoteString</a>
for quoting identifiers and strings, but dbplyr needs additional
tools for inserting logical, date, date-time, and raw values into
queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_escape_logical(con, x)

sql_escape_date(con, x)

sql_escape_datetime(con, x)

sql_escape_raw(con, x)
</code></pre>


<h3>See Also</h3>

<p>Other generic: 
<code><a href="dbplyr.html#topic+db-sql">db-sql</a></code>,
<code><a href="dbplyr.html#topic+db_connection_describe">db_connection_describe</a>()</code>,
<code><a href="dbplyr.html#topic+db_copy_to">db_copy_to</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- simulate_dbi()
sql_escape_logical(con, c(TRUE, FALSE, NA))
sql_escape_date(con, Sys.Date())
sql_escape_date(con, Sys.time())
sql_escape_raw(con, charToRaw("hi"))
</code></pre>

<hr>
<h2 id='db-sql'>SQL generation generics</h2><span id='topic+db-sql'></span><span id='topic+sql_expr_matches'></span><span id='topic+sql_translation'></span><span id='topic+sql_random'></span><span id='topic+sql_table_analyze'></span><span id='topic+sql_table_index'></span><span id='topic+sql_query_explain'></span><span id='topic+sql_query_fields'></span><span id='topic+sql_query_save'></span><span id='topic+sql_query_wrap'></span><span id='topic+sql_indent_subquery'></span><span id='topic+sql_query_rows'></span><span id='topic+supports_window_clause'></span><span id='topic+db_supports_table_alias_with_as'></span><span id='topic+sql_query_select'></span><span id='topic+sql_query_join'></span><span id='topic+sql_query_multi_join'></span><span id='topic+sql_query_semi_join'></span><span id='topic+sql_query_set_op'></span><span id='topic+sql_query_union'></span><span id='topic+sql_returning_cols'></span>

<h3>Description</h3>

<p>SQL translation:
</p>

<ul>
<li> <p><code>sql_expr_matches(con, x, y)</code> generates an alternative to <code>x = y</code> when a
pair of <code>NULL</code>s should match. The default translation uses a <code style="white-space: pre;">&#8288;CASE WHEN&#8288;</code>
as described in <a href="https://modern-sql.com/feature/is-distinct-from">https://modern-sql.com/feature/is-distinct-from</a>.
</p>
</li>
<li> <p><code>sql_translation(con)</code> generates a SQL translation environment.
</p>
</li>
<li><p> Deprecated: <code>sql_random(con)</code> generates SQL to get a random number which can be used
to select random rows in <code>slice_sample()</code>. This is now replaced by adding
a translation for <code>runif(n())</code>.
</p>
</li>
<li> <p><code>supports_window_clause(con)</code> does the backend support named windows?
</p>
</li>
<li> <p><code>db_supports_table_alias_with_as(con)</code> does the backend support using <code>AS</code> when using a table alias?
</p>
</li></ul>

<p>Tables:
</p>

<ul>
<li> <p><code>sql_table_analyze(con, table)</code> generates SQL that &quot;analyzes&quot; the table,
ensuring that the database has up-to-date statistics for use in the query
planner. It called from <code><a href="dplyr.html#topic+copy_to">copy_to()</a></code> when <code>analyze = TRUE</code>.
</p>
</li>
<li> <p><code>sql_table_index()</code> generates SQL for adding an index to table.
</p>
</li></ul>

<p>Query manipulation:
</p>

<ul>
<li> <p><code>sql_query_explain(con, sql)</code> generates SQL that &quot;explains&quot; a query,
i.e. generates a query plan describing what indexes etc that the
database will use.
</p>
</li>
<li> <p><code>sql_query_fields()</code> generates SQL for a 0-row result that is used to
capture field names in <code><a href="dbplyr.html#topic+tbl_sql">tbl_sql()</a></code>
</p>
</li>
<li> <p><code>sql_query_save(con, sql)</code> generates SQL for saving a query into a
(temporary) table.
</p>
</li>
<li> <p><code>sql_query_wrap(con, from)</code> generates SQL for wrapping a query into a
subquery.
</p>
</li></ul>

<p>Query indentation:
</p>

<ul>
<li> <p><code>sql_indent_subquery(from, con, lvl)</code> helps indenting a subquery.
</p>
</li></ul>

<p>Query generation:
</p>

<ul>
<li> <p><code>sql_query_select()</code> generates SQL for a <code>SELECT</code> query
</p>
</li>
<li> <p><code>sql_query_join()</code> generates SQL for joins
</p>
</li>
<li> <p><code>sql_query_semi_join()</code> generates SQL for semi- and anti-joins
</p>
</li>
<li> <p><code>sql_query_set_op()</code> generates SQL for <code>UNION</code>, <code>INTERSECT</code>, and <code>EXCEPT</code>
queries.
</p>
</li></ul>

<p>Query generation for manipulation:
</p>

<ul>
<li> <p><code>sql_query_insert()</code> and <code>sql_query_append()</code> generate SQL for an <code style="white-space: pre;">&#8288;INSERT FROM&#8288;</code> query.
</p>
</li>
<li> <p><code>sql_query_update_from()</code> generates SQL for an <code style="white-space: pre;">&#8288;UPDATE FROM&#8288;</code> query.
</p>
</li>
<li> <p><code>sql_query_upsert()</code> generates SQL for an <code>UPSERT</code> query.
</p>
</li>
<li> <p><code>sql_query_delete()</code> generates SQL for an <code style="white-space: pre;">&#8288;DELETE FROM&#8288;</code> query
</p>
</li>
<li> <p><code>sql_returning_cols()</code> generates SQL for a <code>RETURNING</code> clause
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sql_expr_matches(con, x, y, ...)

sql_translation(con)

sql_random(con)

sql_table_analyze(con, table, ...)

sql_table_index(
  con,
  table,
  columns,
  name = NULL,
  unique = FALSE,
  ...,
  call = caller_env()
)

sql_query_explain(con, sql, ...)

sql_query_fields(con, sql, ...)

sql_query_save(con, sql, name, temporary = TRUE, ...)

sql_query_wrap(con, from, name = NULL, ..., lvl = 0)

sql_indent_subquery(from, con, lvl = 0)

sql_query_rows(con, sql, ...)

supports_window_clause(con)

db_supports_table_alias_with_as(con)

sql_query_select(
  con,
  select,
  from,
  where = NULL,
  group_by = NULL,
  having = NULL,
  window = NULL,
  order_by = NULL,
  limit = NULL,
  distinct = FALSE,
  ...,
  subquery = FALSE,
  lvl = 0
)

sql_query_join(
  con,
  x,
  y,
  select,
  type = "inner",
  by = NULL,
  na_matches = FALSE,
  ...,
  lvl = 0
)

sql_query_multi_join(con, x, joins, table_names, by_list, select, ..., lvl = 0)

sql_query_semi_join(con, x, y, anti, by, where, vars, ..., lvl = 0)

sql_query_set_op(con, x, y, method, ..., all = FALSE, lvl = 0)

sql_query_union(con, x, unions, ..., lvl = 0)

sql_returning_cols(con, cols, table, ...)
</code></pre>


<h3>dbplyr 2.0.0</h3>

<p>Many <code style="white-space: pre;">&#8288;dplyr::db_*&#8288;</code> generics have been replaced by <code style="white-space: pre;">&#8288;dbplyr::sql_*&#8288;</code> generics.
To update your backend, you'll need to extract the SQL generation out of your
existing code, and place it in a new method for a dbplyr <code>sql_</code> generic.
</p>

<ul>
<li> <p><code>dplyr::db_analyze()</code> is replaced by <code>dbplyr::sql_table_analyze()</code>
</p>
</li>
<li> <p><code>dplyr::db_explain()</code> is replaced by <code>dbplyr::sql_query_explain()</code>
</p>
</li>
<li> <p><code>dplyr::db_create_index()</code> is replaced by <code>dbplyr::sql_table_index()</code>
</p>
</li>
<li> <p><code>dplyr::db_query_fields()</code> is replaced by <code>dbplyr::sql_query_fields()</code>
</p>
</li>
<li> <p><code>dplyr::db_query_rows()</code> is no longer used; you can delete it
</p>
</li>
<li> <p><code>dplyr::db_save_query()</code> is replaced by <code>dbplyr::sql_query_save()</code>
</p>
</li></ul>

<p>The query generating functions have also changed names. Their behaviour is
unchanged, so you just need to rename the generic and import from dbplyr
instead of dplyr.
</p>

<ul>
<li> <p><code>dplyr::sql_select()</code> is replaced by <code>dbplyr::sql_query_select()</code>
</p>
</li>
<li> <p><code>dplyr::sql_join()</code> is replaced by <code>dbplyr::sql_query_join()</code>
</p>
</li>
<li> <p><code>dplyr::sql_semi_join()</code> is replaced by <code>dbplyr::sql_query_semi_join()</code>
</p>
</li>
<li> <p><code>dplyr::sql_set_op()</code> is replaced by <code>dbplyr::sql_query_set_op()</code>
</p>
</li>
<li> <p><code>dplyr::sql_subquery()</code> is replaced by <code>dbplyr::sql_query_wrap()</code>
</p>
</li></ul>

<p>Learn more in <code>vignette("backend-2.0")</code>
</p>


<h3>See Also</h3>

<p>Other generic: 
<code><a href="dbplyr.html#topic+db_connection_describe">db_connection_describe</a>()</code>,
<code><a href="dbplyr.html#topic+db_copy_to">db_copy_to</a>()</code>,
<code><a href="dbplyr.html#topic+sql_escape_logical">sql_escape_logical</a>()</code>
</p>

<hr>
<h2 id='dbplyr_uncount'>&quot;Uncount&quot; a database table</h2><span id='topic+dbplyr_uncount'></span>

<h3>Description</h3>

<p>This is a method for the tidyr <code>uncount()</code> generic. It uses a temporary
table, so your database user needs permissions to create one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbplyr_uncount(data, weights, .remove = TRUE, .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbplyr_uncount_+3A_data">data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="dbplyr_uncount_+3A_weights">weights</code></td>
<td>
<p>A vector of weights. Evaluated in the context of <code>data</code>;
supports quasiquotation.</p>
</td></tr>
<tr><td><code id="dbplyr_uncount_+3A_.remove">.remove</code></td>
<td>
<p>If <code>TRUE</code>, and <code>weights</code> is the name of a column in <code>data</code>,
then this column is removed.</p>
</td></tr>
<tr><td><code id="dbplyr_uncount_+3A_.id">.id</code></td>
<td>
<p>Supply a string to create a new variable which gives a unique
identifier for each created row.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- memdb_frame(x = c("a", "b"), n = c(1, 2))
dbplyr_uncount(df, n)
dbplyr_uncount(df, n, .id = "id")

# You can also use constants
dbplyr_uncount(df, 2)

# Or expressions
dbplyr_uncount(df, 2 / n)
</code></pre>

<hr>
<h2 id='dbplyr-package'>dbplyr: A 'dplyr' Back End for Databases</h2><span id='topic+dbplyr'></span><span id='topic+dbplyr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A 'dplyr' back end for databases that allows you to work with remote database tables as if they are in-memory data frames. Basic features works with any database that has a 'DBI' back end; more advanced features require 'SQL' translation to be provided by the package author.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@rstudio.com">hadley@rstudio.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Maximilian Girlich
</p>
</li>
<li><p> Edgar Ruiz
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dbplyr.tidyverse.org/">https://dbplyr.tidyverse.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/dbplyr">https://github.com/tidyverse/dbplyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/dbplyr/issues">https://github.com/tidyverse/dbplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dbplyr-slice'>Subset rows using their positions</h2><span id='topic+slice_min.tbl_lazy'></span><span id='topic+slice_max.tbl_lazy'></span><span id='topic+slice_sample.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr generics <code><a href="dplyr.html#topic+slice_min">slice_min()</a></code>, <code><a href="dplyr.html#topic+slice_max">slice_max()</a></code>, and
<code><a href="dplyr.html#topic+slice_sample">slice_sample()</a></code>. They are translated to SQL using <code><a href="stats.html#topic+filter">filter()</a></code> and
window functions (<code>ROWNUMBER</code>, <code>MIN_RANK</code>, or <code>CUME_DIST</code> depending on
arguments). <code>slice()</code>, <code>slice_head()</code>, and <code>slice_tail()</code> are not supported
since database tables have no intrinsic order.
</p>
<p>If data is grouped, the operation will be performed on each group so that
(e.g.) <code>slice_min(db, x, n = 3)</code> will select the three rows with the smallest
value of <code>x</code> in each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
slice_min(
  .data,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = TRUE
)

## S3 method for class 'tbl_lazy'
slice_max(
  .data,
  order_by,
  ...,
  n,
  by = NULL,
  prop,
  with_ties = TRUE,
  na_rm = TRUE
)

## S3 method for class 'tbl_lazy'
slice_sample(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbplyr-slice_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_order_by">order_by</code></td>
<td>
<p>Variable or function of variables to order by.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_n">n</code>, <code id="dbplyr-slice_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used.
</p>
<p>If <code>n</code> is greater than the number of rows in the group (or <code>prop</code> &gt; 1),
the result will be silently truncated to the group size. If the proportion
of a group size is not an integer, it is rounded down.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_by">by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>, may
return more rows than you request. Use FALSE to ignore ties, and return
the first n rows.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</td></tr>
<tr><td><code id="dbplyr-slice_+3A_weight_by">weight_by</code>, <code id="dbplyr-slice_+3A_replace">replace</code></td>
<td>
<p>Not supported for database backends.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = 1:3, y = c(1, 1, 2))
db %&gt;% slice_min(x) %&gt;% show_query()
db %&gt;% slice_max(x) %&gt;% show_query()
db %&gt;% slice_sample() %&gt;% show_query()

db %&gt;% group_by(y) %&gt;% slice_min(x) %&gt;% show_query()

# By default, ties are includes so you may get more rows
# than you expect
db %&gt;% slice_min(y, n = 1)
db %&gt;% slice_min(y, n = 1, with_ties = FALSE)

# Non-integer group sizes are rounded down
db %&gt;% slice_min(x, prop = 0.5)
</code></pre>

<hr>
<h2 id='distinct.tbl_lazy'>Subset distinct/unique rows</h2><span id='topic+distinct.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+distinct">distinct()</a></code> generic. It adds the
<code>DISTINCT</code> clause to the SQL query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="distinct.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="distinct.tbl_lazy_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = c(1, 1, 2, 2), y = c(1, 2, 1, 1))
db %&gt;% distinct() %&gt;% show_query()
db %&gt;% distinct(x) %&gt;% show_query()
</code></pre>

<hr>
<h2 id='do.tbl_sql'>Perform arbitrary computation on remote backend</h2><span id='topic+do.tbl_sql'></span>

<h3>Description</h3>

<p>Perform arbitrary computation on remote backend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_sql'
do(.data, ..., .chunk_size = 10000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.tbl_sql_+3A_.data">.data</code></td>
<td>
<p>a tbl</p>
</td></tr>
<tr><td><code id="do.tbl_sql_+3A_...">...</code></td>
<td>
<p>Expressions to apply to each group. If named, results will be
stored in a new column. If unnamed, must return a data frame. You can
use <code>.</code> to refer to the current group. You can not mix named and
unnamed arguments.</p>
</td></tr>
<tr><td><code id="do.tbl_sql_+3A_.chunk_size">.chunk_size</code></td>
<td>
<p>The size of each chunk to pull into R. If this number is
too big, the process will be slow because R has to allocate and free a lot
of memory. If it's too small, it will be slow, because of the overhead of
talking to the database.</p>
</td></tr>
</table>

<hr>
<h2 id='escape'>Escape/quote a string.</h2><span id='topic+escape'></span><span id='topic+escape_ansi'></span><span id='topic+sql_vector'></span>

<h3>Description</h3>

<p><code>escape()</code> requires you to provide a database connection to control the
details of escaping. <code>escape_ansi()</code> uses the SQL 92 ANSI standard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>escape(x, parens = NA, collapse = " ", con = NULL)

escape_ansi(x, parens = NA, collapse = "")

sql_vector(x, parens = NA, collapse = " ", con = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="escape_+3A_x">x</code></td>
<td>
<p>An object to escape. Existing sql vectors will be left as is,
character vectors are escaped with single quotes, numeric vectors have
trailing <code>.0</code> added if they're whole numbers, identifiers are
escaped with double quotes.</p>
</td></tr>
<tr><td><code id="escape_+3A_parens">parens</code>, <code id="escape_+3A_collapse">collapse</code></td>
<td>
<p>Controls behaviour when multiple values are supplied.
<code>parens</code> should be a logical flag, or if <code>NA</code>, will wrap in
parens if length &gt; 1.
</p>
<p>Default behaviour: lists are always wrapped in parens and separated by
commas, identifiers are separated by commas and never wrapped,
atomic vectors are separated by spaces and wrapped in parens if needed.</p>
</td></tr>
<tr><td><code id="escape_+3A_con">con</code></td>
<td>
<p>Database connection.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Doubles vs. integers
escape_ansi(1:5)
escape_ansi(c(1, 5.4))

# String vs known sql vs. sql identifier
escape_ansi("X")
escape_ansi(sql("X"))
escape_ansi(ident("X"))

# Escaping is idempotent
escape_ansi("X")
escape_ansi(escape_ansi("X"))
escape_ansi(escape_ansi(escape_ansi("X")))
</code></pre>

<hr>
<h2 id='expand.tbl_lazy'>Expand SQL tables to include all possible combinations of values</h2><span id='topic+expand.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the <a href="tidyr.html#topic+expand">tidyr::expand</a> generics. It doesn't sort the
result explicitly, so the order might be different to what <code>expand()</code>
returns for data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
expand(data, ..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.tbl_lazy_+3A_data">data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="expand.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Specification of columns to expand. See <a href="tidyr.html#topic+expand">tidyr::expand</a> for
more details.</p>
</td></tr>
<tr><td><code id="expand.tbl_lazy_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fruits &lt;- memdb_frame(
  type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
  year   = c(2010, 2010, 2012, 2010, 2010, 2012),
  size = c("XS", "S",  "M", "S", "S", "M"),
  weights = rnorm(6)
)

# All possible combinations ---------------------------------------
fruits %&gt;% tidyr::expand(type)
fruits %&gt;% tidyr::expand(type, size)

# Only combinations that already appear in the data ---------------
fruits %&gt;% tidyr::expand(nesting(type, size))

</code></pre>

<hr>
<h2 id='fill.tbl_lazy'>Fill in missing values with previous or next value</h2><span id='topic+fill.tbl_lazy'></span>

<h3>Description</h3>

<p>Fill in missing values with previous or next value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
fill(.data, ..., .direction = c("down", "up", "updown", "downup"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="fill.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Columns to fill.</p>
</td></tr>
<tr><td><code id="fill.tbl_lazy_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently
either &quot;down&quot; (the default) or &quot;up&quot;. Note that &quot;up&quot; does not work when
<code>.data</code> is sorted by non-numeric columns. As a workaround revert the order
yourself beforehand; for example replace <code>arrange(x, desc(y))</code> by
<code>arrange(desc(x), y)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
squirrels &lt;- tibble::tribble(
  ~group,    ~name,     ~role,     ~n_squirrels, ~ n_squirrels2,
  1,      "Sam",    "Observer",   NA,                 1,
  1,     "Mara", "Scorekeeper",    8,                NA,
  1,    "Jesse",    "Observer",   NA,                NA,
  1,      "Tom",    "Observer",   NA,                 4,
  2,     "Mike",    "Observer",   NA,                NA,
  2,  "Rachael",    "Observer",   NA,                 6,
  2,  "Sydekea", "Scorekeeper",   14,                NA,
  2, "Gabriela",    "Observer",   NA,                NA,
  3,  "Derrick",    "Observer",   NA,                NA,
  3,     "Kara", "Scorekeeper",    9,                 10,
  3,    "Emily",    "Observer",   NA,                NA,
  3, "Danielle",    "Observer",   NA,                NA
)
squirrels$id &lt;- 1:12

tbl_memdb(squirrels) %&gt;%
  window_order(id) %&gt;%
  tidyr::fill(
    n_squirrels,
    n_squirrels2,
  )

</code></pre>

<hr>
<h2 id='filter.tbl_lazy'>Subset rows using column values</h2><span id='topic+filter.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="stats.html#topic+filter">filter()</a></code> generic. It generates the
<code>WHERE</code> clause of the SQL query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
filter(.data, ..., .by = NULL, .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="filter.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="filter.tbl_lazy_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="filter.tbl_lazy_+3A_.preserve">.preserve</code></td>
<td>
<p>Not supported by this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = c(2, NA, 5, NA, 10), y = 1:5)
db %&gt;% filter(x &lt; 5) %&gt;% show_query()
db %&gt;% filter(is.na(x)) %&gt;% show_query()
</code></pre>

<hr>
<h2 id='get_returned_rows'>Extract and check the <code>RETURNING</code> rows</h2><span id='topic+get_returned_rows'></span><span id='topic+has_returned_rows'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>get_returned_rows()</code> extracts the <code>RETURNING</code> rows produced by
<code><a href="dplyr.html#topic+rows_insert">rows_insert()</a></code>, <code><a href="dplyr.html#topic+rows_append">rows_append()</a></code>, <code><a href="dplyr.html#topic+rows_update">rows_update()</a></code>, <code><a href="dplyr.html#topic+rows_upsert">rows_upsert()</a></code>,
or <code><a href="dplyr.html#topic+rows_delete">rows_delete()</a></code> if these are called with the <code>returning</code> argument.
An error is raised if this information is not available.
</p>
<p><code>has_returned_rows()</code> checks if <code>x</code> has stored RETURNING rows produced by
<code><a href="dplyr.html#topic+rows_insert">rows_insert()</a></code>, <code><a href="dplyr.html#topic+rows_append">rows_append()</a></code>, <code><a href="dplyr.html#topic+rows_update">rows_update()</a></code>, <code><a href="dplyr.html#topic+rows_upsert">rows_upsert()</a></code>,
or <code><a href="dplyr.html#topic+rows_delete">rows_delete()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_returned_rows(x)

has_returned_rows(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_returned_rows_+3A_x">x</code></td>
<td>
<p>A lazy tbl.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_returned_rows()</code>, a tibble.
</p>
<p>For <code>has_returned_rows()</code>, a scalar logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbExecute(con, "CREATE TABLE Info (
   id INTEGER PRIMARY KEY AUTOINCREMENT,
   number INTEGER
)")
info &lt;- tbl(con, "Info")

rows1 &lt;- copy_inline(con, data.frame(number = c(1, 5)))
rows_insert(info, rows1, conflict = "ignore", in_place = TRUE)
info

# If the table has an auto incrementing primary key, you can use
# the returning argument + `get_returned_rows()` its value
rows2 &lt;- copy_inline(con, data.frame(number = c(13, 27)))
info &lt;- rows_insert(
  info,
  rows2,
  conflict = "ignore",
  in_place = TRUE,
  returning = id
)
info
get_returned_rows(info)
</code></pre>

<hr>
<h2 id='group_by.tbl_lazy'>Group by one or more variables</h2><span id='topic+group_by.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+group_by">group_by()</a></code> generic. It is translated to
the <code style="white-space: pre;">&#8288;GROUP BY&#8288;</code> clause of the SQL query when used with
<code><a href="dbplyr.html#topic+summarise.tbl_lazy">summarise()</a></code> and to the <code style="white-space: pre;">&#8288;PARTITION BY&#8288;</code> clause of
window functions when used with <code><a href="dbplyr.html#topic+mutate.tbl_lazy">mutate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
group_by(.data, ..., .add = FALSE, add = NULL, .drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="group_by.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="group_by.tbl_lazy_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group_by.tbl_lazy_+3A_add">add</code></td>
<td>
<p>Deprecated. Please use <code>.add</code> instead.</p>
</td></tr>
<tr><td><code id="group_by.tbl_lazy_+3A_.drop">.drop</code></td>
<td>
<p>Not supported by this method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2))
db %&gt;%
  group_by(g) %&gt;%
  summarise(n()) %&gt;%
  show_query()

db %&gt;%
  group_by(g) %&gt;%
  mutate(x2 = x / sum(x, na.rm = TRUE)) %&gt;%
  show_query()
</code></pre>

<hr>
<h2 id='head.tbl_lazy'>Subset the first rows</h2><span id='topic+head.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="utils.html#topic+head">head()</a></code> generic. It is usually translated to the
<code>LIMIT</code> clause of the SQL query. Because <code>LIMIT</code> is not an official part of
the SQL specification, some database use other clauses like <code>TOP</code> or
<code style="white-space: pre;">&#8288;FETCH ROWS&#8288;</code>.
</p>
<p>Note that databases don't really have a sense of row order, so what &quot;first&quot;
means is subject to interpretation. Most databases will respect ordering
performed with <code>arrange()</code>, but it's not guaranteed. <code>tail()</code> is not
supported at all because the situation is even murkier for the &quot;last&quot; rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
head(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.tbl_lazy_+3A_x">x</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="head.tbl_lazy_+3A_n">n</code></td>
<td>
<p>Number of rows to return</p>
</td></tr>
<tr><td><code id="head.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = 1:100)
db %&gt;% head() %&gt;% show_query()

# Pretend we have data in a SQL server database
db2 &lt;- lazy_frame(x = 1:100, con = simulate_mssql())
db2 %&gt;% head() %&gt;% show_query()
</code></pre>

<hr>
<h2 id='ident'>Flag a character vector as SQL identifiers</h2><span id='topic+ident'></span><span id='topic+is.ident'></span>

<h3>Description</h3>

<p><code>ident()</code> takes unquoted strings and flags them as identifiers.
<code>ident_q()</code> assumes its input has already been quoted, and ensures
it does not get quoted again. This is currently used only for
<code>schema.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident(...)

is.ident(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ident_+3A_...">...</code></td>
<td>
<p>A character vector, or name-value pairs</p>
</td></tr>
<tr><td><code id="ident_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># SQL92 quotes strings with '
escape_ansi("x")

# And identifiers with "
ident("x")
escape_ansi(ident("x"))

# You can supply multiple inputs
ident(a = "x", b = "y")
ident_q(a = "x", b = "y")
</code></pre>

<hr>
<h2 id='ident_q'>Declare a identifier as being pre-quoted.</h2><span id='topic+ident_q'></span>

<h3>Description</h3>

<p>No longer needed; please use <code><a href="dbplyr.html#topic+sql">sql()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident_q(...)
</code></pre>

<hr>
<h2 id='in_schema'>Refer to a table in a schema or a database catalog</h2><span id='topic+in_schema'></span><span id='topic+in_catalog'></span>

<h3>Description</h3>

<p><code>in_schema()</code> can be used in <code><a href="dplyr.html#topic+tbl">tbl()</a></code> to indicate a table in a specific
schema.
<code>in_catalog()</code> additionally allows specifying the database catalog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_schema(schema, table)

in_catalog(catalog, schema, table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_schema_+3A_catalog">catalog</code>, <code id="in_schema_+3A_schema">schema</code>, <code id="in_schema_+3A_table">table</code></td>
<td>
<p>Names of catalog, schema, and table.
These will be automatically quoted; use <code><a href="dbplyr.html#topic+sql">sql()</a></code> to pass a raw name
that won't get quoted.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>in_schema("my_schema", "my_table")
in_catalog("my_catalog", "my_schema", "my_table")
# eliminate quotes
in_schema(sql("my_schema"), sql("my_table"))

# Example using schemas with SQLite
con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

# Add auxiliary schema
tmp &lt;- tempfile()
DBI::dbExecute(con, paste0("ATTACH '", tmp, "' AS aux"))

library(dplyr, warn.conflicts = FALSE)
copy_to(con, iris, "df", temporary = FALSE)
copy_to(con, mtcars, in_schema("aux", "df"), temporary = FALSE)

con %&gt;% tbl("df")
con %&gt;% tbl(in_schema("aux", "df"))
</code></pre>

<hr>
<h2 id='intersect.tbl_lazy'>SQL set operations</h2><span id='topic+intersect.tbl_lazy'></span><span id='topic+union.tbl_lazy'></span><span id='topic+union_all.tbl_lazy'></span><span id='topic+setdiff.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr generics <code>dplyr::intersect()</code>,
<code>dplyr::union()</code>, and <code>dplyr::setdiff()</code>. They are translated to
<code>INTERSECT</code>, <code>UNION</code>, and <code>EXCEPT</code> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
intersect(x, y, copy = FALSE, ..., all = FALSE)

## S3 method for class 'tbl_lazy'
union(x, y, copy = FALSE, ..., all = FALSE)

## S3 method for class 'tbl_lazy'
union_all(x, y, copy = FALSE, ...)

## S3 method for class 'tbl_lazy'
setdiff(x, y, copy = FALSE, ..., all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.tbl_lazy_+3A_x">x</code>, <code id="intersect.tbl_lazy_+3A_y">y</code></td>
<td>
<p>A pair of lazy data frames backed by database queries.</p>
</td></tr>
<tr><td><code id="intersect.tbl_lazy_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a
temporary table in same database as <code>x</code>. <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will automatically
run <code>ANALYZE</code> on the created table in the hope that this will make
you queries as efficient as possible by giving more data to the query
planner.
</p>
<p>This allows you to join tables across srcs, but it's potentially expensive
operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="intersect.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Not currently used; provided for future extensions.</p>
</td></tr>
<tr><td><code id="intersect.tbl_lazy_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, includes all matches in output, not just unique rows.</p>
</td></tr>
</table>

<hr>
<h2 id='join.tbl_sql'>Join SQL tables</h2><span id='topic+join.tbl_sql'></span><span id='topic+inner_join.tbl_lazy'></span><span id='topic+left_join.tbl_lazy'></span><span id='topic+right_join.tbl_lazy'></span><span id='topic+full_join.tbl_lazy'></span><span id='topic+cross_join.tbl_lazy'></span><span id='topic+semi_join.tbl_lazy'></span><span id='topic+anti_join.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <a href="dplyr.html#topic+join">join</a> generics. They are translated
to the following SQL queries:
</p>

<ul>
<li> <p><code>inner_join(x, y)</code>: <code style="white-space: pre;">&#8288;SELECT * FROM x JOIN y ON x.a = y.a&#8288;</code>
</p>
</li>
<li> <p><code>left_join(x, y)</code>:  <code style="white-space: pre;">&#8288;SELECT * FROM x LEFT JOIN y ON x.a = y.a&#8288;</code>
</p>
</li>
<li> <p><code>right_join(x, y)</code>: <code style="white-space: pre;">&#8288;SELECT * FROM x RIGHT JOIN y ON x.a = y.a&#8288;</code>
</p>
</li>
<li> <p><code>full_join(x, y)</code>:  <code style="white-space: pre;">&#8288;SELECT * FROM x FULL JOIN y ON x.a = y.a&#8288;</code>
</p>
</li>
<li> <p><code>semi_join(x, y)</code>:  <code style="white-space: pre;">&#8288;SELECT * FROM x WHERE EXISTS (SELECT 1 FROM y WHERE x.a = y.a)&#8288;</code>
</p>
</li>
<li> <p><code>anti_join(x, y)</code>:  <code style="white-space: pre;">&#8288;SELECT * FROM x WHERE NOT EXISTS (SELECT 1 FROM y WHERE x.a = y.a)&#8288;</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = NULL,
  ...,
  keep = NULL,
  na_matches = c("never", "na"),
  multiple = NULL,
  unmatched = "drop",
  relationship = NULL,
  sql_on = NULL,
  auto_index = FALSE,
  x_as = NULL,
  y_as = NULL
)

## S3 method for class 'tbl_lazy'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = NULL,
  ...,
  keep = NULL,
  na_matches = c("never", "na"),
  multiple = NULL,
  unmatched = "drop",
  relationship = NULL,
  sql_on = NULL,
  auto_index = FALSE,
  x_as = NULL,
  y_as = NULL
)

## S3 method for class 'tbl_lazy'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = NULL,
  ...,
  keep = NULL,
  na_matches = c("never", "na"),
  multiple = NULL,
  unmatched = "drop",
  relationship = NULL,
  sql_on = NULL,
  auto_index = FALSE,
  x_as = NULL,
  y_as = NULL
)

## S3 method for class 'tbl_lazy'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = NULL,
  ...,
  keep = NULL,
  na_matches = c("never", "na"),
  multiple = NULL,
  relationship = NULL,
  sql_on = NULL,
  auto_index = FALSE,
  x_as = NULL,
  y_as = NULL
)

## S3 method for class 'tbl_lazy'
cross_join(
  x,
  y,
  ...,
  copy = FALSE,
  suffix = c(".x", ".y"),
  x_as = NULL,
  y_as = NULL
)

## S3 method for class 'tbl_lazy'
semi_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  na_matches = c("never", "na"),
  sql_on = NULL,
  auto_index = FALSE,
  x_as = NULL,
  y_as = NULL
)

## S3 method for class 'tbl_lazy'
anti_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  na_matches = c("never", "na"),
  sql_on = NULL,
  auto_index = FALSE,
  x_as = NULL,
  y_as = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join.tbl_sql_+3A_x">x</code>, <code id="join.tbl_sql_+3A_y">y</code></td>
<td>
<p>A pair of lazy data frames backed by database queries.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a
temporary table in same database as <code>x</code>. <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will automatically
run <code>ANALYZE</code> on the created table in the hope that this will make
you queries as efficient as possible by giving more data to the query
planner.
</p>
<p>This allows you to join tables across srcs, but it's potentially expensive
operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_na_matches">na_matches</code></td>
<td>
<p>Should NA (NULL) values match one another?
The default, &quot;never&quot;, is how databases usually work. <code>"na"</code> makes
the joins behave like the dplyr join functions, <code><a href="base.html#topic+merge">merge()</a></code>, <code><a href="base.html#topic+match">match()</a></code>,
and <code>%in%</code>.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_multiple">multiple</code>, <code id="join.tbl_sql_+3A_unmatched">unmatched</code></td>
<td>
<p>Unsupported in database backends. As a workaround
for multiple use a unique key and for unmatched a foreign key constraint.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_relationship">relationship</code></td>
<td>
<p>Unsupported in database backends.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_sql_on">sql_on</code></td>
<td>
<p>A custom join predicate as an SQL expression.
Usually joins use column equality, but you can perform more complex
queries by supply <code>sql_on</code> which should be a SQL expression that
uses <code>LHS</code> and <code>RHS</code> aliases to refer to the left-hand side or
right-hand side of the join respectively.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_auto_index">auto_index</code></td>
<td>
<p>if <code>copy</code> is <code>TRUE</code>, automatically create
indices for the variables in <code>by</code>. This may speed up the join if
there are matching indexes in <code>x</code>.</p>
</td></tr>
<tr><td><code id="join.tbl_sql_+3A_x_as">x_as</code>, <code id="join.tbl_sql_+3A_y_as">y_as</code></td>
<td>
<p>Alias to use for <code>x</code> resp. <code>y</code>. Defaults to <code>"LHS"</code> resp.
<code>"RHS"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

band_db &lt;- tbl_memdb(dplyr::band_members)
instrument_db &lt;- tbl_memdb(dplyr::band_instruments)
band_db %&gt;% left_join(instrument_db) %&gt;% show_query()

# Can join with local data frames by setting copy = TRUE
band_db %&gt;%
  left_join(dplyr::band_instruments, copy = TRUE)

# Unlike R, joins in SQL don't usually match NAs (NULLs)
db &lt;- memdb_frame(x = c(1, 2, NA))
label &lt;- memdb_frame(x = c(1, NA), label = c("one", "missing"))
db %&gt;% left_join(label, by = "x")
# But you can activate R's usual behaviour with the na_matches argument
db %&gt;% left_join(label, by = "x", na_matches = "na")

# By default, joins are equijoins, but you can use `sql_on` to
# express richer relationships
db1 &lt;- memdb_frame(x = 1:5)
db2 &lt;- memdb_frame(x = 1:3, y = letters[1:3])
db1 %&gt;% left_join(db2) %&gt;% show_query()
db1 %&gt;% left_join(db2, sql_on = "LHS.x &lt; RHS.x") %&gt;% show_query()
</code></pre>

<hr>
<h2 id='lahman'>Cache and retrieve an <code>src_sqlite</code> of the Lahman baseball database.</h2><span id='topic+lahman'></span><span id='topic+lahman_sqlite'></span><span id='topic+lahman_postgres'></span><span id='topic+lahman_mysql'></span><span id='topic+copy_lahman'></span><span id='topic+has_lahman'></span><span id='topic+lahman_srcs'></span>

<h3>Description</h3>

<p>This creates an interesting database using data from the Lahman baseball
data source, provided by Sean Lahman at
<a href="http://seanlahman.com/download-baseball-database/">http://seanlahman.com/download-baseball-database/</a>, and
made easily available in R through the <span class="pkg">Lahman</span> package by
Michael Friendly, Dennis Murphy and Martin Monkman. See the documentation
for that package for documentation of the individual tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lahman_sqlite(path = NULL)

lahman_postgres(dbname = "lahman", host = "localhost", ...)

lahman_mysql(dbname = "lahman", ...)

copy_lahman(con, ...)

has_lahman(type, ...)

lahman_srcs(..., quiet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lahman_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>src</code> on first
load. For MySQL and PostgreSQL, the defaults assume you have a local
server with <code>lahman</code> database already created.
For <code>lahman_srcs()</code>, character vector of names giving srcs to generate.</p>
</td></tr>
<tr><td><code id="lahman_+3A_type">type</code></td>
<td>
<p>src type.</p>
</td></tr>
<tr><td><code id="lahman_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code>, suppress messages about databases failing to
connect.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Connect to a local sqlite database, if already created

library(dplyr)

if (has_lahman("sqlite")) {
  lahman_sqlite()
  batting &lt;- tbl(lahman_sqlite(), "Batting")
  batting
}

# Connect to a local postgres database with lahman database, if available
if (has_lahman("postgres")) {
  lahman_postgres()
  batting &lt;- tbl(lahman_postgres(), "Batting")
}

</code></pre>

<hr>
<h2 id='lazy_multi_join_query'>Build and render SQL from a sequence of lazy operations</h2><span id='topic+lazy_multi_join_query'></span><span id='topic+lazy_rf_join_query'></span><span id='topic+lazy_semi_join_query'></span><span id='topic+lazy_query'></span><span id='topic+lazy_select_query'></span><span id='topic+lazy_set_op_query'></span><span id='topic+lazy_union_query'></span><span id='topic+sql_build'></span><span id='topic+sql_render'></span><span id='topic+sql_optimise'></span><span id='topic+join_query'></span><span id='topic+select_query'></span><span id='topic+semi_join_query'></span><span id='topic+set_op_query'></span><span id='topic+union_query'></span>

<h3>Description</h3>

<p><code>sql_build()</code> creates a <code>select_query</code> S3 object, that is rendered
to a SQL string by <code>sql_render()</code>. The output from <code>sql_build()</code> is
designed to be easy to test, as it's database agnostic, and has
a hierarchical structure. Outside of testing, however, you should
always call <code>sql_render()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazy_multi_join_query(
  x,
  joins,
  table_names,
  vars,
  group_vars = op_grps(x),
  order_vars = op_sort(x),
  frame = op_frame(x),
  call = caller_env()
)

lazy_rf_join_query(
  x,
  y,
  type,
  by,
  table_names,
  vars,
  group_vars = op_grps(x),
  order_vars = op_sort(x),
  frame = op_frame(x),
  call = caller_env()
)

lazy_semi_join_query(
  x,
  y,
  vars,
  anti,
  by,
  where,
  group_vars = op_grps(x),
  order_vars = op_sort(x),
  frame = op_frame(x),
  call = caller_env()
)

lazy_query(
  query_type,
  x,
  ...,
  group_vars = op_grps(x),
  order_vars = op_sort(x),
  frame = op_frame(x)
)

lazy_select_query(
  x,
  select = NULL,
  where = NULL,
  group_by = NULL,
  having = NULL,
  order_by = NULL,
  limit = NULL,
  distinct = FALSE,
  group_vars = NULL,
  order_vars = NULL,
  frame = NULL,
  select_operation = c("select", "mutate", "summarise"),
  message_summarise = NULL
)

lazy_set_op_query(x, y, type, all, call = caller_env())

lazy_union_query(x, unions, call = caller_env())

sql_build(op, con = NULL, ..., sql_options = NULL)

sql_render(
  query,
  con = NULL,
  ...,
  sql_options = NULL,
  subquery = FALSE,
  lvl = 0
)

sql_optimise(x, con = NULL, ..., subquery = FALSE)

join_query(
  x,
  y,
  select,
  ...,
  type = "inner",
  by = NULL,
  suffix = c(".x", ".y"),
  na_matches = FALSE
)

select_query(
  from,
  select = sql("*"),
  where = character(),
  group_by = character(),
  having = character(),
  window = character(),
  order_by = character(),
  limit = NULL,
  distinct = FALSE,
  from_alias = NULL
)

semi_join_query(
  x,
  y,
  vars,
  anti = FALSE,
  by = NULL,
  where = NULL,
  na_matches = FALSE
)

set_op_query(x, y, type, all = FALSE)

union_query(x, unions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lazy_multi_join_query_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to the methods. Not currently used.</p>
</td></tr>
<tr><td><code id="lazy_multi_join_query_+3A_op">op</code></td>
<td>
<p>A sequence of lazy operations</p>
</td></tr>
<tr><td><code id="lazy_multi_join_query_+3A_con">con</code></td>
<td>
<p>A database connection. The default <code>NULL</code> uses a set of
rules that should be very similar to ANSI 92, and allows for testing
without an active database connection.</p>
</td></tr>
<tr><td><code id="lazy_multi_join_query_+3A_sql_options">sql_options</code></td>
<td>
<p>SQL rendering options generated by <code>sql_options()</code>.</p>
</td></tr>
<tr><td><code id="lazy_multi_join_query_+3A_subquery">subquery</code></td>
<td>
<p>Is this SQL going to be used in a subquery?
This is important because you can place a bare table name in a subquery
and  ORDER BY does not work in subqueries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sql_build()</code> is generic over the lazy operations, <a href="dbplyr.html#topic+lazy_ops">lazy_ops</a>,
and generates an S3 object that represents the query. <code>sql_render()</code>
takes a query object and then calls a function that is generic
over the database. For example, <code>sql_build.op_mutate()</code> generates
a <code>select_query</code>, and <code>sql_render.select_query()</code> calls
<code>sql_select()</code>, which has different methods for different databases.
The default methods should generate ANSI 92 SQL where possible, so you
backends only need to override the methods if the backend is not ANSI
compliant.
</p>

<hr>
<h2 id='lazy_ops'>Lazy operations</h2><span id='topic+lazy_ops'></span><span id='topic+lazy_base_query'></span><span id='topic+op_grps'></span><span id='topic+op_vars'></span><span id='topic+op_sort'></span><span id='topic+op_frame'></span>

<h3>Description</h3>

<p>This set of S3 classes describe the action of dplyr verbs. These are
currently used for SQL sources to separate the description of operations
in R from their computation in SQL. This API is very new so is likely
to evolve in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazy_base_query(x, vars, class = character(), ...)

op_grps(op)

op_vars(op)

op_sort(op)

op_frame(op)
</code></pre>


<h3>Details</h3>

<p><code>op_vars()</code> and <code>op_grps()</code> compute the variables and groups from
a sequence of lazy operations. <code>op_sort()</code> and <code>op_frame()</code> tracks the
order and frame for use in window functions.
</p>

<hr>
<h2 id='memdb_frame'>Create a database table in temporary in-memory database.</h2><span id='topic+memdb_frame'></span><span id='topic+tbl_memdb'></span><span id='topic+src_memdb'></span>

<h3>Description</h3>

<p><code>memdb_frame()</code> works like <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>, but instead of creating a new
data frame in R, it creates a table in <code><a href="dbplyr.html#topic+src_memdb">src_memdb()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memdb_frame(..., .name = unique_table_name())

tbl_memdb(df, name = deparse(substitute(df)))

src_memdb()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memdb_frame_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
A set of name-value pairs. These arguments are
processed with <code><a href="rlang.html#topic+defusing-advanced">rlang::quos()</a></code> and support unquote via <code><a href="rlang.html#topic++21+21">!!</a></code> and
unquote-splice via <code><a href="rlang.html#topic++21+21+21">!!!</a></code>. Use <code style="white-space: pre;">&#8288;:=&#8288;</code> to create columns that start with a dot.
</p>
<p>Arguments are evaluated sequentially.
You can refer to previously created elements directly or using the <a href="dplyr.html#topic+.data">.data</a>
pronoun.
To refer explicitly to objects in the calling environment, use <code><a href="rlang.html#topic++21+21">!!</a></code> or
<a href="igraph.html#topic+.env">.env</a>, e.g. <code>!!.data</code> or <code>.env$.data</code> for the special case of an object
named <code>.data</code>.</p>
</td></tr>
<tr><td><code id="memdb_frame_+3A_df">df</code></td>
<td>
<p>Data frame to copy</p>
</td></tr>
<tr><td><code id="memdb_frame_+3A_name">name</code>, <code id="memdb_frame_+3A_.name">.name</code></td>
<td>
<p>Name of table in database: defaults to a random name that's
unlikely to conflict with an existing table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- memdb_frame(x = runif(100), y = runif(100))
df %&gt;% arrange(x)
df %&gt;% arrange(x) %&gt;% show_query()

mtcars_db &lt;- tbl_memdb(mtcars)
mtcars_db %&gt;% group_by(cyl) %&gt;% summarise(n = n()) %&gt;% show_query()
</code></pre>

<hr>
<h2 id='mutate.tbl_lazy'>Create, modify, and delete columns</h2><span id='topic+mutate.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <code><a href="dplyr.html#topic+mutate">mutate()</a></code> and <code><a href="dplyr.html#topic+transmute">transmute()</a></code> generics.
They are translated to computed expressions in the <code>SELECT</code> clause of
the SQL query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="mutate.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="mutate.tbl_lazy_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="mutate.tbl_lazy_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.tbl_lazy_+3A_.before">.before</code>, <code id="mutate.tbl_lazy_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = 1:5, y = 5:1)
db %&gt;%
  mutate(a = (x + y) / 2, b = sqrt(x^2L + y^2L)) %&gt;%
  show_query()

# dbplyr automatically creates subqueries as needed
db %&gt;%
  mutate(x1 = x + 1, x2 = x1 * 2) %&gt;%
  show_query()
</code></pre>

<hr>
<h2 id='named_commas'>Provides comma-separated string out of the parameters</h2><span id='topic+named_commas'></span>

<h3>Description</h3>

<p>Provides comma-separated string out of the parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_commas(x)
</code></pre>

<hr>
<h2 id='nycflights13'>Database versions of the nycflights13 data</h2><span id='topic+nycflights13'></span><span id='topic+nycflights13_sqlite'></span><span id='topic+nycflights13_postgres'></span><span id='topic+has_nycflights13'></span><span id='topic+copy_nycflights13'></span>

<h3>Description</h3>

<p>These functions cache the data from the <code>nycflights13</code> database in
a local database, for use in examples and vignettes. Indexes are created
to making joining tables on natural keys efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nycflights13_sqlite(path = NULL)

nycflights13_postgres(dbname = "nycflights13", ...)

has_nycflights13(type = c("sqlite", "postgres"), ...)

copy_nycflights13(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nycflights13_+3A_path">path</code></td>
<td>
<p>location of SQLite database file</p>
</td></tr>
<tr><td><code id="nycflights13_+3A_dbname">dbname</code>, <code id="nycflights13_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="dplyr.html#topic+src_postgres">src_postgres()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='partial_eval'>Partially evaluate an expression.</h2><span id='topic+partial_eval'></span>

<h3>Description</h3>

<p>This function partially evaluates an expression, using information from
the tbl to determine whether names refer to local expressions
or remote variables. This simplifies SQL translation because expressions
don't need to carry around their environment - all relevant information
is incorporated into the expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_eval(call, data, env = caller_env(), vars = NULL, error_call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_eval_+3A_call">call</code></td>
<td>
<p>an unevaluated expression, as produced by <code><a href="base.html#topic+quote">quote()</a></code></p>
</td></tr>
<tr><td><code id="partial_eval_+3A_data">data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="partial_eval_+3A_env">env</code></td>
<td>
<p>environment in which to search for local values</p>
</td></tr>
<tr><td><code id="partial_eval_+3A_vars">vars</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>: Pass a lazy frame to <code>data</code>
instead.</p>
</td></tr>
</table>


<h3>Symbol substitution</h3>

<p><code>partial_eval()</code> needs to guess if you're referring to a variable on the
server (remote), or in the current environment (local). It's not possible to
do this 100% perfectly. <code>partial_eval()</code> uses the following heuristic:
</p>

<ul>
<li><p> If the tbl variables are known, and the symbol matches a tbl
variable, then remote.
</p>
</li>
<li><p> If the symbol is defined locally, local.
</p>
</li>
<li><p> Otherwise, remote.
</p>
</li></ul>

<p>You can override the guesses using <code>local()</code> and <code>remote()</code> to force
computation, or by using the <code>.data</code> and <code>.env</code> pronouns of tidy evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lf &lt;- lazy_frame(year = 1980, id = 1)
partial_eval(quote(year &gt; 1980), data = lf)

ids &lt;- c("ansonca01", "forceda01", "mathebo01")
partial_eval(quote(id %in% ids), lf)

# cf.
partial_eval(quote(id == .data$id), lf)

# You can use local() or .env to disambiguate between local and remote
# variables: otherwise remote is always preferred
year &lt;- 1980
partial_eval(quote(year &gt; year), lf)
partial_eval(quote(year &gt; local(year)), lf)
partial_eval(quote(year &gt; .env$year), lf)

# Functions are always assumed to be remote. Use local to force evaluation
# in R.
f &lt;- function(x) x + 1
partial_eval(quote(year &gt; f(1980)), lf)
partial_eval(quote(year &gt; local(f(1980))), lf)
</code></pre>

<hr>
<h2 id='pivot_longer.tbl_lazy'>Pivot data from wide to long</h2><span id='topic+pivot_longer.tbl_lazy'></span>

<h3>Description</h3>

<p><code>pivot_longer()</code> &quot;lengthens&quot; data, increasing the number of rows and
decreasing the number of columns. The inverse transformation is
'tidyr::pivot_wider()]
</p>
<p>Learn more in <code>vignette("pivot", "tidyr")</code>.
</p>
<p>While most functionality is identical there are some differences to
<code>pivot_longer()</code> on local data frames:
</p>

<ul>
<li><p> the output is sorted differently/not explicitly,
</p>
</li>
<li><p> the coercion of mixed column types is left to the database,
</p>
</li>
<li> <p><code>values_ptypes</code> NOT supported.
</p>
</li></ul>

<p>Note that <code>build_longer_spec()</code> and <code>pivot_longer_spec()</code> do not work with
remote tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
pivot_longer(
  data,
  cols,
  ...,
  cols_vary,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes,
  values_transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_cols">cols</code></td>
<td>
<p>Columns to pivot into longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_cols_vary">cols_vary</code></td>
<td>
<p>Unsupported; included for compatibility with the generic.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_names_to">names_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in the column names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_names_sep">names_sep</code>, <code id="pivot_longer.tbl_lazy_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_names_ptypes">names_ptypes</code></td>
<td>
<p>A list of column name-prototype pairs.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_names_transform">names_transform</code>, <code id="pivot_longer.tbl_lazy_+3A_values_transform">values_transform</code></td>
<td>
<p>A list of column name-function pairs.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column.</p>
</td></tr>
<tr><td><code id="pivot_longer.tbl_lazy_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>Not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SQL translation basically works as follows:
</p>

<ol>
<li><p> split the specification by its key columns i.e. by variables crammed
into the column names.
</p>
</li>
<li><p> for each part in the split specification <code>transmute()</code> <code>data</code> into the
following columns
</p>
</li></ol>


<ul>
<li><p> id columns i.e. columns that are not pivotted
</p>
</li>
<li><p> key columns
</p>
</li>
<li><p> value columns i.e. columns that are pivotted
</p>
</li></ul>


<ol>
<li><p> combine all the parts with <code>union_all()</code>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
# See vignette("pivot") for examples and explanation

# Simplest case where column names are character data
memdb_frame(
  id = c("a", "b"),
  x = 1:2,
  y = 3:4
) %&gt;%
  tidyr::pivot_longer(-id)

</code></pre>

<hr>
<h2 id='pivot_wider.tbl_lazy'>Pivot data from long to wide</h2><span id='topic+pivot_wider.tbl_lazy'></span><span id='topic+dbplyr_pivot_wider_spec'></span>

<h3>Description</h3>

<p><code>pivot_wider()</code> &quot;widens&quot; data, increasing the number of columns and
decreasing the number of rows. The inverse transformation is
<code>pivot_longer()</code>.
Learn more in <code>vignette("pivot", "tidyr")</code>.
</p>
<p>Note that <code>pivot_wider()</code> is not and cannot be lazy because we need to look
at the data to figure out what the new column names will be.
If you have a long running query you have two options:
</p>

<ul>
<li><p> (temporarily) store the result of the query via <code>compute()</code>.
</p>
</li>
<li><p> Create a spec before and use <code>dbplyr_pivot_wider_spec()</code> - dbplyr's version
of <code>tidyr::pivot_wider_spec()</code>. Note that this function is only a temporary
solution until <code>pivot_wider_spec()</code> becomes a generic. It will then be
removed soon afterwards.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
pivot_wider(
  data,
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = ~max(.x, na.rm = TRUE),
  unused_fn = NULL
)

dbplyr_pivot_wider_spec(
  data,
  spec,
  ...,
  names_repair = "check_unique",
  id_cols = NULL,
  id_expand = FALSE,
  values_fill = NULL,
  values_fn = ~max(.x, na.rm = TRUE),
  unused_fn = NULL,
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_data">data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Unused; included for compatibility with generic.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_id_cols">id_cols</code></td>
<td>
<p>A set of columns that uniquely identifies each observation.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_id_expand">id_expand</code></td>
<td>
<p>Unused; included for compatibility with the generic.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_from">names_from</code>, <code id="pivot_wider.tbl_lazy_+3A_values_from">values_from</code></td>
<td>
<p>A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_prefix">names_prefix</code></td>
<td>
<p>String added to the start of every variable name.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_vary">names_vary</code></td>
<td>
<p>When <code>names_from</code> identifies a column (or columns) with
multiple unique values, and multiple <code>values_from</code> columns are provided,
in what order should the resulting column names be combined?
</p>

<ul>
<li> <p><code>"fastest"</code> varies <code>names_from</code> values fastest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value1_name2, value2_name1, value2_name2&#8288;</code>. This is the default.
</p>
</li>
<li> <p><code>"slowest"</code> varies <code>names_from</code> values slowest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value2_name1, value1_name2, value2_name2&#8288;</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_expand">names_expand</code></td>
<td>
<p>Should the values in the <code>names_from</code> columns be expanded
by <code><a href="Matrix.html#topic+expand">expand()</a></code> before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in <code>names_from</code>. Additionally, the column names will be
sorted, identical to what <code>names_sort</code> would produce.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_values_fn">values_fn</code></td>
<td>
<p>A function, the default is <code>max()</code>, applied to the <code>value</code>
in each cell in the output. In contrast to local data frames it must not be
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_unused_fn">unused_fn</code></td>
<td>
<p>Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by <code>id_cols</code>,
<code>names_from</code>, or <code>values_from</code>).
</p>
<p>The default drops all unused columns from the result.
</p>
<p>This can be a named list if you want to apply different aggregations
to different unused columns.
</p>
<p><code>id_cols</code> must be supplied for <code>unused_fn</code> to be useful, since otherwise
all unspecified columns will be considered <code>id_cols</code>.
</p>
<p>This is similar to grouping by the <code>id_cols</code> then summarizing the
unused columns using <code>unused_fn</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_spec">spec</code></td>
<td>
<p>A specification data frame. This is useful for more complex
pivots because it gives you greater control on how metadata stored in the
columns become column names in the result.
</p>
<p>Must be a data frame containing character <code>.name</code> and <code>.value</code> columns.
Additional columns in <code>spec</code> should be named to match columns in the
long format of the dataset and contain values corresponding to columns
pivoted from the wide format.
The special <code>.seq</code> variable is used to disambiguate rows internally;
it is automatically removed after pivoting.</p>
</td></tr>
<tr><td><code id="pivot_wider.tbl_lazy_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The big difference to <code>pivot_wider()</code> for local data frames is that
<code>values_fn</code> must not be <code>NULL</code>. By default it is <code>max()</code> which yields
the same results as for local data frames if the combination of <code>id_cols</code>
and <code>value</code> column uniquely identify an observation.
Mind that you also do not get a warning if an observation is not uniquely
identified.
</p>
<p>The translation to SQL code basically works as follows:
</p>

<ol>
<li><p> Get unique keys in <code>names_from</code> column.
</p>
</li>
<li><p> For each key value generate an expression of the form:
</p>
<div class="sourceCode sql"><pre>value_fn(
  CASE WHEN (`names from column` == `key value`)
  THEN (`value column`)
  END
) AS `output column`
</pre></div>
</li>
<li><p> Group data by id columns.
</p>
</li>
<li><p> Summarise the grouped data with the expressions from step 2.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
memdb_frame(
  id = 1,
  key = c("x", "y"),
  value = 1:2
) %&gt;%
  tidyr::pivot_wider(
    id_cols = id,
    names_from = key,
    values_from = value
  )

</code></pre>

<hr>
<h2 id='pull.tbl_sql'>Extract a single column</h2><span id='topic+pull.tbl_sql'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+pull">pull()</a></code> generic. It evaluates the query
retrieving just the specified column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_sql'
pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull.tbl_sql_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="pull.tbl_sql_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the
column you've created most recently).
</p>
<p>This argument is taken by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names and column locations).</p>
</td></tr>
<tr><td><code id="pull.tbl_sql_+3A_name">name</code></td>
<td>
<p>An optional parameter that specifies the column to be used
as names for a named vector. Specified in a similar manner as <code>var</code>.</p>
</td></tr>
<tr><td><code id="pull.tbl_sql_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = 1:5, y = 5:1)
db %&gt;%
  mutate(z = x + y * 2) %&gt;%
  pull()
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remote_name'>Metadata about a remote table</h2><span id='topic+remote_name'></span><span id='topic+remote_table'></span><span id='topic+remote_src'></span><span id='topic+remote_con'></span><span id='topic+remote_query'></span><span id='topic+remote_query_plan'></span>

<h3>Description</h3>

<p><code>remote_name()</code> gives the unescaped name of the remote table, or <code>NULL</code> if it
is a query (created by <code>sql()</code>) or already escape (created by <code>ident_q()</code>).
<code>remote_table()</code> gives the remote table or the query.
<code>remote_query()</code> gives the text of the query, and <code>remote_query_plan()</code>
the query plan (as computed by the remote database). <code>remote_src()</code> and
<code>remote_con()</code> give the dplyr source and DBI connection respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remote_name(x, null_if_local = TRUE)

remote_table(x, null_if_local = TRUE)

remote_src(x)

remote_con(x)

remote_query(x, cte = FALSE, sql_options = NULL)

remote_query_plan(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remote_name_+3A_x">x</code></td>
<td>
<p>Remote table, currently must be a <a href="dbplyr.html#topic+tbl_sql">tbl_sql</a>.</p>
</td></tr>
<tr><td><code id="remote_name_+3A_null_if_local">null_if_local</code></td>
<td>
<p>Return <code>NULL</code> if the remote table is created via
<code>tbl_lazy()</code> or <code>lazy_frame()</code>?</p>
</td></tr>
<tr><td><code id="remote_name_+3A_cte">cte</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Use the <code>render_otions</code> argument instead.</p>
</td></tr>
<tr><td><code id="remote_name_+3A_sql_options">sql_options</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
SQL rendering options generated by <code>sql_options()</code>.</p>
</td></tr>
<tr><td><code id="remote_name_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value, or <code>NULL</code> if not remote table, or not applicable.
For example, computed queries do not have a &quot;name&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mf &lt;- memdb_frame(x = 1:5, y = 5:1, .name = "blorp")
remote_name(mf)
remote_src(mf)
remote_con(mf)
remote_query(mf)

mf2 &lt;- dplyr::filter(mf, x &gt; 3)
remote_name(mf2)
remote_src(mf2)
remote_con(mf2)
remote_query(mf2)
</code></pre>

<hr>
<h2 id='replace_na.tbl_lazy'>Replace NAs with specified values</h2><span id='topic+replace_na.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
replace_na(data, replace = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na.tbl_lazy_+3A_data">data</code></td>
<td>
<p>A pair of lazy data frame backed by database queries.</p>
</td></tr>
<tr><td><code id="replace_na.tbl_lazy_+3A_replace">replace</code></td>
<td>
<p>A named list of values, with one value for each column that
has NA values to be replaced.</p>
</td></tr>
<tr><td><code id="replace_na.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Unused; included for compatibility with generic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- memdb_frame(x = c(1, 2, NA), y = c("a", NA, "b"))
df %&gt;% tidyr::replace_na(list(x = 0, y = "unknown"))

</code></pre>

<hr>
<h2 id='rows_insert.tbl_lazy'>Edit individual rows in the underlying database table</h2><span id='topic+rows_insert.tbl_lazy'></span><span id='topic+rows_append.tbl_lazy'></span><span id='topic+rows_update.tbl_lazy'></span><span id='topic+rows_patch.tbl_lazy'></span><span id='topic+rows_upsert.tbl_lazy'></span><span id='topic+rows_delete.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <code><a href="dplyr.html#topic+rows_insert">rows_insert()</a></code>, <code><a href="dplyr.html#topic+rows_append">rows_append()</a></code>,
<code><a href="dplyr.html#topic+rows_update">rows_update()</a></code>, <code><a href="dplyr.html#topic+rows_patch">rows_patch()</a></code>, <code><a href="dplyr.html#topic+rows_upsert">rows_upsert()</a></code>, and <code><a href="dplyr.html#topic+rows_delete">rows_delete()</a></code>
generics.
</p>
<p>When <code>in_place = TRUE</code> these verbs do not generate <code>SELECT</code> queries, but
instead directly modify the underlying data using <code>INSERT</code>, <code>UPDATE</code>, or
<code>DELETE</code> operators. This will require that you have write access to
the database: the connection needs permission to insert, modify or delete
rows, but not to alter the structure of the table.
</p>
<p>The default, <code>in_place = FALSE</code>, generates equivalent lazy tables (using
<code>SELECT</code> queries) that allow previewing the result without actually
modifying the underlying table on the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
rows_insert(
  x,
  y,
  by = NULL,
  ...,
  conflict = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE,
  returning = NULL,
  method = NULL
)

## S3 method for class 'tbl_lazy'
rows_append(x, y, ..., copy = FALSE, in_place = FALSE, returning = NULL)

## S3 method for class 'tbl_lazy'
rows_update(
  x,
  y,
  by = NULL,
  ...,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE,
  returning = NULL
)

## S3 method for class 'tbl_lazy'
rows_patch(
  x,
  y,
  by = NULL,
  ...,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE,
  returning = NULL
)

## S3 method for class 'tbl_lazy'
rows_upsert(
  x,
  y,
  by = NULL,
  ...,
  copy = FALSE,
  in_place = FALSE,
  returning = NULL,
  method = NULL
)

## S3 method for class 'tbl_lazy'
rows_delete(
  x,
  y,
  by = NULL,
  ...,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE,
  returning = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rows_insert.tbl_lazy_+3A_x">x</code></td>
<td>
<p>A lazy table.
For <code>in_place = TRUE</code>, this must be a table instantiated with <code><a href="dplyr.html#topic+tbl">tbl()</a></code> or
<code><a href="dplyr.html#topic+compute">compute()</a></code>, not to a lazy query. The <code><a href="dbplyr.html#topic+remote_name">remote_name()</a></code> function is used to
determine the name of the table to be updated.</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_y">y</code></td>
<td>
<p>A lazy table, data frame, or data frame extensions (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_by">by</code></td>
<td>
<p>An unnamed character vector giving the key columns. The key columns
must exist in both <code>x</code> and <code>y</code>. Keys typically uniquely identify each row,
but this is only enforced for the key values of <code>y</code> when <code>rows_update()</code>,
<code>rows_patch()</code>, or <code>rows_upsert()</code> are used.
</p>
<p>By default, we use the first column in <code>y</code>, since the first column is
a reasonable place to put an identifier variable.</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_conflict">conflict</code></td>
<td>
<p>For <code>rows_insert()</code>, how should keys in <code>y</code> that conflict
with keys in <code>x</code> be handled? A conflict arises if there is a key in <code>y</code>
that already exists in <code>x</code>.
</p>
<p>One of:
</p>

<ul>
<li> <p><code>"error"</code>, the default, is not supported for database tables. To get the
same behaviour add a unique index on the <code>by</code> columns and use
<code>rows_append()</code>.
</p>
</li>
<li> <p><code>"ignore"</code> will ignore rows in <code>y</code> with keys that conflict with keys in
<code>x</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_in_place">in_place</code></td>
<td>
<p>Should <code>x</code> be modified in place? If <code>FALSE</code> will
generate a <code>SELECT</code> query that returns the modified table; if <code>TRUE</code>
will modify the underlying table using a DML operation (<code>INSERT</code>, <code>UPDATE</code>,
<code>DELETE</code> or similar).</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_returning">returning</code></td>
<td>
<p>Columns to return. See <code><a href="dbplyr.html#topic+get_returned_rows">get_returned_rows()</a></code> for details.</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_method">method</code></td>
<td>
<p>A string specifying the method to use. This is only relevant for
<code>in_place = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rows_insert.tbl_lazy_+3A_unmatched">unmatched</code></td>
<td>
<p>For <code>rows_update()</code>, <code>rows_patch()</code>, and <code>rows_delete()</code>,
how should keys in <code>y</code> that are unmatched by the keys in <code>x</code> be handled?
</p>
<p>One of:
</p>

<ul>
<li> <p><code>"error"</code>, the default, is not supported for database tables. Add a
foreign key constraint on the <code>by</code> columns of <code>y</code> to let the database
check this behaviour for you.
</p>
</li>
<li> <p><code>"ignore"</code> will ignore rows in <code>y</code> with keys that are unmatched by the
keys in <code>x</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>tbl_lazy</code> of the modified data.
With <code>in_place = FALSE</code>, the result is a lazy query that prints visibly,
because the purpose of this operation is to preview the results.
With <code>in_place = TRUE</code>, <code>x</code> is returned invisibly,
because the purpose of this operation is the side effect of modifying rows
in the table behind <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbExecute(con, "CREATE TABLE Ponies (
   id INTEGER PRIMARY KEY AUTOINCREMENT,
   name TEXT,
   cutie_mark TEXT
)")

ponies &lt;- tbl(con, "Ponies")

applejack &lt;- copy_inline(con, data.frame(
  name = "Apple Jack",
  cutie_mark = "three apples"
))

# The default behavior is to generate a SELECT query
rows_insert(ponies, applejack, conflict = "ignore")
# And the original table is left unchanged:
ponies

# You can also choose to modify the table with in_place = TRUE:
rows_insert(ponies, applejack, conflict = "ignore", in_place = TRUE)
# In this case `rows_insert()` returns nothing and the underlying
# data is modified
ponies
</code></pre>

<hr>
<h2 id='select.tbl_lazy'>Subset, rename, and reorder columns using their names</h2><span id='topic+select.tbl_lazy'></span><span id='topic+rename.tbl_lazy'></span><span id='topic+rename_with.tbl_lazy'></span><span id='topic+relocate.tbl_lazy'></span>

<h3>Description</h3>

<p>These are methods for the dplyr <code><a href="MASS.html#topic+select">select()</a></code>, <code><a href="dplyr.html#topic+rename">rename()</a></code>, and <code><a href="dplyr.html#topic+relocate">relocate()</a></code>
generics. They generate the <code>SELECT</code> clause of the SQL query.
</p>
<p>These functions do not support predicate functions, i.e. you can
not use <code>where(is.numeric)</code> to select all numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
select(.data, ...)

## S3 method for class 'tbl_lazy'
rename(.data, ...)

## S3 method for class 'tbl_lazy'
rename_with(.data, .fn, .cols = everything(), ...)

## S3 method for class 'tbl_lazy'
relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="select.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="select.tbl_lazy_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="select.tbl_lazy_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</td></tr>
<tr><td><code id="select.tbl_lazy_+3A_.before">.before</code>, <code id="select.tbl_lazy_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(x = 1, y = 2, z = 3)
db %&gt;% select(-y) %&gt;% show_query()
db %&gt;% relocate(z) %&gt;% show_query()
db %&gt;% rename(first = x, last = z) %&gt;% show_query()
</code></pre>

<hr>
<h2 id='simulate_dbi'>Simulate database connections</h2><span id='topic+simulate_dbi'></span>

<h3>Description</h3>

<p>These functions generate S3 objects that have been designed to simulate
the action of a database connection, without actually having the database
available. Obviously, this simulation can only be incomplete, but most
importantly it allows us to simulate SQL generation for any database without
actually connecting to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dbi(class = character(), ...)
</code></pre>


<h3>Details</h3>

<p>Simulated SQL always quotes identifies with <code>`x`</code>, and strings with
<code>'x'</code>.
</p>

<hr>
<h2 id='sql'>SQL escaping.</h2><span id='topic+sql'></span><span id='topic+is.sql'></span><span id='topic+as.sql'></span>

<h3>Description</h3>

<p>These functions are critical when writing functions that translate R
functions to sql functions. Typically a conversion function should escape
all its inputs and return an sql object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql(...)

is.sql(x)

as.sql(x, con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_+3A_...">...</code></td>
<td>
<p>Character vectors that will be combined into a single SQL
expression.</p>
</td></tr>
<tr><td><code id="sql_+3A_x">x</code></td>
<td>
<p>Object to coerce</p>
</td></tr>
<tr><td><code id="sql_+3A_con">con</code></td>
<td>
<p>Needed when <code>x</code> is directly supplied from the user so that
schema specifications can be quoted using the correct identifiers.</p>
</td></tr>
</table>

<hr>
<h2 id='sql_expr'>Generate SQL from R expressions</h2><span id='topic+sql_expr'></span><span id='topic+sql_call2'></span>

<h3>Description</h3>

<p>Low-level building block for generating SQL from R expressions.
Strings are escaped; names become bare SQL identifiers. User infix
functions have <code style="white-space: pre;">&#8288;%&#8288;</code> stripped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_expr(x, con = sql_current_con())

sql_call2(.fn, ..., con = sql_current_con())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_expr_+3A_x">x</code></td>
<td>
<p>A quasiquoted expression</p>
</td></tr>
<tr><td><code id="sql_expr_+3A_con">con</code></td>
<td>
<p>Connection to use for escaping. Will be set automatically when
called from a function translation.</p>
</td></tr>
<tr><td><code id="sql_expr_+3A_.fn">.fn</code></td>
<td>
<p>Function name (as string, call, or symbol)</p>
</td></tr>
<tr><td><code id="sql_expr_+3A_...">...</code></td>
<td>
<p>Arguments to function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>sql_expr()</code> in package will require use of <code><a href="utils.html#topic+globalVariables">globalVariables()</a></code>
to avoid <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> NOTES. This is a small amount of additional pain,
which I think is worthwhile because it leads to more readable translation
code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- simulate_dbi() # not necessary when writing translations

sql_expr(f(x + 1), con = con)
sql_expr(f("x", "y"), con = con)
sql_expr(f(x, y), con = con)

x &lt;- ident("x")
sql_expr(f(!!x, y), con = con)

sql_expr(cast("x" %as% DECIMAL), con = con)
sql_expr(round(x) %::% numeric, con = con)

sql_call2("+", quote(x), 1, con = con)
sql_call2("+", "x", 1, con = con)
</code></pre>

<hr>
<h2 id='sql_options'>Options for generating SQL</h2><span id='topic+sql_options'></span>

<h3>Description</h3>

<p>Options for generating SQL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_options(cte = FALSE, use_star = TRUE, qualify_all_columns = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_options_+3A_cte">cte</code></td>
<td>
<p>If <code>FALSE</code>, the default, subqueries are used. If <code>TRUE</code> common
table expressions are used.</p>
</td></tr>
<tr><td><code id="sql_options_+3A_use_star">use_star</code></td>
<td>
<p>If <code>TRUE</code>, the default, <code>*</code> is used to select all columns of
a table. If <code>FALSE</code> all columns are explicitly selected.</p>
</td></tr>
<tr><td><code id="sql_options_+3A_qualify_all_columns">qualify_all_columns</code></td>
<td>
<p>If <code>FALSE</code>, the default, columns are only
qualified with the table they come from if the same column name appears in
multiple tables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &lt;dbplyr_sql_options&gt; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
lf1 &lt;- lazy_frame(key = 1, a = 1, b = 2)
lf2 &lt;- lazy_frame(key = 1, a = 1, c = 3)

result &lt;- left_join(lf1, lf2, by = "key") %&gt;%
  filter(c &gt;= 3)

show_query(result)
sql_options &lt;- sql_options(cte = TRUE, qualify_all_columns = TRUE)
show_query(result, sql_options = sql_options)
</code></pre>

<hr>
<h2 id='sql_query_insert'>Generate SQL for Insert, Update, Upsert, and Delete</h2><span id='topic+sql_query_insert'></span><span id='topic+sql_query_append'></span><span id='topic+sql_query_update_from'></span><span id='topic+sql_query_upsert'></span><span id='topic+sql_query_delete'></span>

<h3>Description</h3>

<p>These functions generate the SQL used in <code>rows_*(in_place = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_query_insert(
  con,
  table,
  from,
  insert_cols,
  by,
  ...,
  conflict = c("error", "ignore"),
  returning_cols = NULL,
  method = NULL
)

sql_query_append(con, table, from, insert_cols, ..., returning_cols = NULL)

sql_query_update_from(
  con,
  table,
  from,
  by,
  update_values,
  ...,
  returning_cols = NULL
)

sql_query_upsert(
  con,
  table,
  from,
  by,
  update_cols,
  ...,
  returning_cols = NULL,
  method = NULL
)

sql_query_delete(con, table, from, by, ..., returning_cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_query_insert_+3A_con">con</code></td>
<td>
<p>Database connection.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_table">table</code></td>
<td>
<p>Table to update. Must be a table identifier, e.g. single string
or created via <code>in_schema()</code>.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_from">from</code></td>
<td>
<p>Table or query that contains the new data. Either a table
identifier or SQL.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_insert_cols">insert_cols</code></td>
<td>
<p>Names of columns to insert.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_by">by</code></td>
<td>
<p>An unnamed character vector giving the key columns. The key columns
must exist in both <code>x</code> and <code>y</code>. Keys typically uniquely identify each row,
but this is only enforced for the key values of <code>y</code> when <code>rows_update()</code>,
<code>rows_patch()</code>, or <code>rows_upsert()</code> are used.
</p>
<p>By default, we use the first column in <code>y</code>, since the first column is
a reasonable place to put an identifier variable.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_conflict">conflict</code></td>
<td>
<p>For <code>rows_insert()</code>, how should keys in <code>y</code> that conflict
with keys in <code>x</code> be handled? A conflict arises if there is a key in <code>y</code>
that already exists in <code>x</code>.
</p>
<p>One of:
</p>

<ul>
<li> <p><code>"error"</code>, the default, will error if there are any keys in <code>y</code> that
conflict with keys in <code>x</code>.
</p>
</li>
<li> <p><code>"ignore"</code> will ignore rows in <code>y</code> with keys that conflict with keys in
<code>x</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_returning_cols">returning_cols</code></td>
<td>
<p>Optional. Names of columns to return.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_method">method</code></td>
<td>
<p>Optional. The method to use.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_update_values">update_values</code></td>
<td>
<p>A named SQL vector that specify how to update the columns.</p>
</td></tr>
<tr><td><code id="sql_query_insert_+3A_update_cols">update_cols</code></td>
<td>
<p>Names of columns to update.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Insert Methods
</p>


<h4><code>"where_not_exists"</code></h4>

<p>The default for most databases.
</p>
<div class="sourceCode"><pre>INSERT INTO x_name
SELECT *
FROM y
WHERE NOT EXISTS &lt;match on by columns&gt;
</pre></div>



<h4><code>"on_conflict"</code></h4>

<p>Supported by:
</p>

<ul>
<li><p> Postgres
</p>
</li>
<li><p> SQLite
</p>
</li></ul>

<p>This method uses the <code style="white-space: pre;">&#8288;ON CONFLICT&#8288;</code> clause and therefore requires a unique
index on the columns specified in <code>by</code>.
</p>

<p>Upsert Methods
</p>


<h4><code>"merge"</code></h4>

<p>The upsert method according to the SQL standard. It uses the <code>MERGE</code> statement
</p>
<div class="sourceCode"><pre>MERGE INTO x_name
USING y
  ON &lt;match on by columns&gt;
WHEN MATCHED THEN
  UPDATE SET ...
WHEN NOT MATCHED THEN
  INSERT ...
</pre></div>



<h4><code>"on_conflict"</code></h4>

<p>Supported by:
</p>

<ul>
<li><p> Postgres
</p>
</li>
<li><p> SQLite
</p>
</li></ul>

<p>This method uses the <code style="white-space: pre;">&#8288;ON CONFLICT&#8288;</code> clause and therefore requires a unique
index on the columns specified in <code>by</code>.
</p>



<h4><code>"cte_update"</code></h4>

<p>Supported by:
</p>

<ul>
<li><p> Postgres
</p>
</li>
<li><p> SQLite
</p>
</li>
<li><p> Oracle
</p>
</li></ul>

<p>The classical way to upsert in Postgres and SQLite before support for
<code style="white-space: pre;">&#8288;ON CONFLICT&#8288;</code> was added. The update is done in a CTE clause and the unmatched
values are then inserted outside of the CTE.
</p>



<h3>Value</h3>

<p>A SQL query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sql_query_upsert(
  con = simulate_postgres(),
  table = ident("airlines"),
  from = ident("df"),
  by = "carrier",
  update_cols = "name"
)
</code></pre>

<hr>
<h2 id='sql_quote'>Helper function for quoting sql elements.</h2><span id='topic+sql_quote'></span>

<h3>Description</h3>

<p>If the quote character is present in the string, it will be doubled.
<code>NA</code>s will be replaced with NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_quote(x, quote)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_quote_+3A_x">x</code></td>
<td>
<p>Character vector to escape.</p>
</td></tr>
<tr><td><code id="sql_quote_+3A_quote">quote</code></td>
<td>
<p>Single quoting character.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sql_quote("abc", "'")
sql_quote("I've had a good day", "'")
sql_quote(c("abc", NA), "'")
</code></pre>

<hr>
<h2 id='sql_substr'>Create an sql translator</h2><span id='topic+sql_substr'></span><span id='topic+sql_str_sub'></span><span id='topic+sql_paste'></span><span id='topic+sql_paste_infix'></span><span id='topic+sql_variant'></span><span id='topic+sql_translator'></span><span id='topic+sql_infix'></span><span id='topic+sql_prefix'></span><span id='topic+sql_aggregate'></span><span id='topic+sql_aggregate_2'></span><span id='topic+sql_aggregate_n'></span><span id='topic+sql_not_supported'></span><span id='topic+sql_cast'></span><span id='topic+sql_try_cast'></span><span id='topic+sql_log'></span><span id='topic+sql_cot'></span><span id='topic+sql_runif'></span><span id='topic+base_scalar'></span><span id='topic+base_agg'></span><span id='topic+base_win'></span><span id='topic+base_no_win'></span><span id='topic+base_odbc_scalar'></span><span id='topic+base_odbc_agg'></span><span id='topic+base_odbc_win'></span>

<h3>Description</h3>

<p>When creating a package that maps to a new SQL based src, you'll often
want to provide some additional mappings from common R commands to the
commands that your tbl provides. These three functions make that
easy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_substr(f = "SUBSTR")

sql_str_sub(subset_f = "SUBSTR", length_f = "LENGTH", optional_length = TRUE)

sql_paste(default_sep, f = "CONCAT_WS")

sql_paste_infix(default_sep, op, cast)

sql_variant(
  scalar = sql_translator(),
  aggregate = sql_translator(),
  window = sql_translator()
)

sql_translator(..., .funs = list(), .parent = new.env(parent = emptyenv()))

sql_infix(f, pad = TRUE)

sql_prefix(f, n = NULL)

sql_aggregate(f, f_r = f)

sql_aggregate_2(f)

sql_aggregate_n(f, f_r = f)

sql_not_supported(f)

sql_cast(type)

sql_try_cast(type)

sql_log()

sql_cot()

sql_runif(rand_expr, n = n(), min = 0, max = 1)

base_scalar

base_agg

base_win

base_no_win

base_odbc_scalar

base_odbc_agg

base_odbc_win
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_substr_+3A_f">f</code></td>
<td>
<p>the name of the sql function as a string</p>
</td></tr>
<tr><td><code id="sql_substr_+3A_scalar">scalar</code>, <code id="sql_substr_+3A_aggregate">aggregate</code>, <code id="sql_substr_+3A_window">window</code></td>
<td>
<p>The three families of functions than an
SQL variant can supply.</p>
</td></tr>
<tr><td><code id="sql_substr_+3A_...">...</code>, <code id="sql_substr_+3A_.funs">.funs</code></td>
<td>
<p>named functions, used to add custom converters from standard
R functions to sql functions. Specify individually in <code>...</code>, or
provide a list of <code>.funs</code></p>
</td></tr>
<tr><td><code id="sql_substr_+3A_.parent">.parent</code></td>
<td>
<p>the sql variant that this variant should inherit from.
Defaults to <code>base_agg</code> which provides a standard set of
mappings for the most common operators and functions.</p>
</td></tr>
<tr><td><code id="sql_substr_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, the default, pad the infix operator with spaces.</p>
</td></tr>
<tr><td><code id="sql_substr_+3A_n">n</code></td>
<td>
<p>for <code>sql_infix()</code>, an optional number of arguments to expect.
Will signal error if not correct.</p>
</td></tr>
<tr><td><code id="sql_substr_+3A_f_r">f_r</code></td>
<td>
<p>the name of the r function being translated as a string</p>
</td></tr>
</table>


<h3>Helper functions</h3>

<p><code>sql_infix()</code> and <code>sql_prefix()</code> create default SQL infix and prefix
functions given the name of the SQL function. They don't perform any input
checking, but do correctly escape their input, and are useful for
quickly providing default wrappers for a new SQL variant.
</p>


<h3>See Also</h3>

<p><code><a href="dbplyr.html#topic+win_over">win_over()</a></code> for helper functions for window functions.
</p>
<p><code><a href="dbplyr.html#topic+sql">sql()</a></code> for an example of a more customised sql
conversion function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example of adding some mappings for the statistical functions that
# postgresql provides: http://bit.ly/K5EdTn

postgres_agg &lt;- sql_translator(.parent = base_agg,
  cor = sql_aggregate_2("CORR"),
  cov = sql_aggregate_2("COVAR_SAMP"),
  sd =  sql_aggregate("STDDEV_SAMP", "sd"),
  var = sql_aggregate("VAR_SAMP", "var")
)

# Next we have to simulate a connection that uses this variant
con &lt;- simulate_dbi("TestCon")
sql_translation.TestCon &lt;- function(x) {
  sql_variant(
    base_scalar,
    postgres_agg,
    base_no_win
  )
}

translate_sql(cor(x, y), con = con, window = FALSE)
translate_sql(sd(income / years), con = con, window = FALSE)

# Any functions not explicitly listed in the converter will be translated
# to sql as is, so you don't need to convert all functions.
translate_sql(regr_intercept(y, x), con = con)
</code></pre>

<hr>
<h2 id='src_dbi'>Database src</h2><span id='topic+src_dbi'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Since can generate a <code>tbl()</code> directly from a DBI connection we no longer
recommend using <code>src_dbi()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_dbi(con, auto_disconnect = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_dbi_+3A_con">con</code></td>
<td>
<p>An object that inherits from <a href="DBI.html#topic+DBIConnection-class">DBI::DBIConnection</a>,
typically generated by <a href="DBI.html#topic+dbConnect">DBI::dbConnect</a></p>
</td></tr>
<tr><td><code id="src_dbi_+3A_auto_disconnect">auto_disconnect</code></td>
<td>
<p>Should the connection be automatically closed when
the src is deleted? Set to <code>TRUE</code> if you initialize the connection
the call to <code>src_dbi()</code>. Pass <code>NA</code> to auto-disconnect but print a message
when this happens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with class <code>src_dbi</code>, <code>src_sql</code>, <code>src</code>.
</p>

<hr>
<h2 id='src_sql'>Create a &quot;sql src&quot; object</h2><span id='topic+src_sql'></span>

<h3>Description</h3>

<p>Deprecated: please use directly use a <code>DBIConnection</code> object instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_sql(subclass, con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_sql_+3A_subclass">subclass</code></td>
<td>
<p>name of subclass. &quot;src_sql&quot; is an abstract base class, so you
must supply this value. <code>src_</code> is automatically prepended to the
class name</p>
</td></tr>
<tr><td><code id="src_sql_+3A_con">con</code></td>
<td>
<p>the connection object</p>
</td></tr>
<tr><td><code id="src_sql_+3A_...">...</code></td>
<td>
<p>fields used by object</p>
</td></tr>
</table>

<hr>
<h2 id='summarise.tbl_lazy'>Summarise each group to one row</h2><span id='topic+summarise.tbl_lazy'></span>

<h3>Description</h3>

<p>This is a method for the dplyr <code><a href="dplyr.html#topic+summarise">summarise()</a></code> generic. It generates the
<code>SELECT</code> clause of the SQL query, and generally needs to be combined with
<code>group_by()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_lazy'
summarise(.data, ..., .by = NULL, .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise.tbl_lazy_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="summarise.tbl_lazy_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="summarise.tbl_lazy_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="summarise.tbl_lazy_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it defaults to &quot;drop_last&quot;.
</p>
<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another <code>tbl_lazy</code>. Use <code><a href="dplyr.html#topic+show_query">show_query()</a></code> to see the generated
query, and use <code><a href="dbplyr.html#topic+collect.tbl_sql">collect()</a></code> to execute the query
and return data to R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2))
db %&gt;%
  summarise(n()) %&gt;%
  show_query()

db %&gt;%
  group_by(g) %&gt;%
  summarise(n()) %&gt;%
  show_query()
</code></pre>

<hr>
<h2 id='tbl_lazy'>Create a local lazy tibble</h2><span id='topic+tbl_lazy'></span><span id='topic+lazy_frame'></span>

<h3>Description</h3>

<p>These functions are useful for testing SQL generation without having to
have an active database connection. See <code><a href="dbplyr.html#topic+simulate_dbi">simulate_dbi()</a></code> for a list
available database simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_lazy(df, con = NULL, ..., name = "df")

lazy_frame(..., con = NULL, .name = "df")
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(x = 1, y = 2)

df_sqlite &lt;- tbl_lazy(df, con = simulate_sqlite())
df_sqlite %&gt;% summarise(x = sd(x, na.rm = TRUE)) %&gt;% show_query()
</code></pre>

<hr>
<h2 id='tbl_sql'>Create an SQL tbl (abstract)</h2><span id='topic+tbl_sql'></span>

<h3>Description</h3>

<p>Generally, you should no longer need to provide a custom <code>tbl()</code>
method.
The default <code>tbl.DBIConnect</code> method should work in most cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_sql(subclass, src, from, ..., vars = NULL, check_from = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_sql_+3A_subclass">subclass</code></td>
<td>
<p>name of subclass</p>
</td></tr>
<tr><td><code id="tbl_sql_+3A_...">...</code></td>
<td>
<p>needed for agreement with generic. Not otherwise used.</p>
</td></tr>
<tr><td><code id="tbl_sql_+3A_vars">vars</code></td>
<td>
<p>Provide column names as a character vector
to avoid retrieving them from the database.
Mainly useful for better performance when creating
multiple <code>tbl</code> objects.</p>
</td></tr>
<tr><td><code id="tbl_sql_+3A_check_from">check_from</code></td>
<td>
<p>Check if <code>from</code> is likely misspecified SQL or a table in a schema.</p>
</td></tr>
</table>

<hr>
<h2 id='tbl.src_dbi'>Use dplyr verbs with a remote database table</h2><span id='topic+tbl.src_dbi'></span><span id='topic+tbl_dbi'></span>

<h3>Description</h3>

<p>All data manipulation on SQL tbls are lazy: they will not actually
run the query or retrieve the data unless you ask for it: they all return
a new <code>tbl_dbi</code> object. Use <code><a href="dplyr.html#topic+compute">compute()</a></code> to run the query and save the
results in a temporary in the database, or use <code><a href="dplyr.html#topic+collect">collect()</a></code> to retrieve the
results to R. You can see the query with <code><a href="dplyr.html#topic+show_query">show_query()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'src_dbi'
tbl(src, from, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl.src_dbi_+3A_src">src</code></td>
<td>
<p>A <code>DBIConnection</code> object produced by <code>DBI::dbConnect()</code>.</p>
</td></tr>
<tr><td><code id="tbl.src_dbi_+3A_from">from</code></td>
<td>
<p>Either a string (giving a table name),
a fully qualified table name created by <code><a href="dbplyr.html#topic+in_schema">in_schema()</a></code>
or a literal <code><a href="dbplyr.html#topic+sql">sql()</a></code> string.</p>
</td></tr>
<tr><td><code id="tbl.src_dbi_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="dbplyr.html#topic+tbl_sql">tbl_sql()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For best performance, the database should have an index on the variables
that you are grouping by. Use <code><a href="dplyr.html#topic+explain">explain()</a></code> to check that the database is using
the indexes that you expect.
</p>
<p>There is one verb that is not lazy: <code><a href="dplyr.html#topic+do">do()</a></code> is eager because it must pull
the data into R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Connect to a temporary in-memory SQLite database
con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

# Add some data
copy_to(con, mtcars)
DBI::dbListTables(con)

# To retrieve a single table from a source, use `tbl()`
con %&gt;% tbl("mtcars")

# Use `in_schema()` for fully qualified table names
con %&gt;% tbl(in_schema("temp", "mtcars")) %&gt;% head(1)

# You can also use pass raw SQL if you want a more sophisticated query
con %&gt;% tbl(sql("SELECT * FROM mtcars WHERE cyl = 8"))

# If you just want a temporary in-memory database, use src_memdb()
src2 &lt;- src_memdb()

# To show off the full features of dplyr's database integration,
# we'll use the Lahman database. lahman_sqlite() takes care of
# creating the database.

if (requireNamespace("Lahman", quietly = TRUE)) {
batting &lt;- copy_to(con, Lahman::Batting)
batting

# Basic data manipulation verbs work in the same way as with a tibble
batting %&gt;% filter(yearID &gt; 2005, G &gt; 130)
batting %&gt;% select(playerID:lgID)
batting %&gt;% arrange(playerID, desc(yearID))
batting %&gt;% summarise(G = mean(G), n = n())

# There are a few exceptions. For example, databases give integer results
# when dividing one integer by another. Multiply by 1 to fix the problem
batting %&gt;%
  select(playerID:lgID, AB, R, G) %&gt;%
  mutate(
   R_per_game1 = R / G,
   R_per_game2 = R * 1.0 / G
 )

# All operations are lazy: they don't do anything until you request the
# data, either by `print()`ing it (which shows the first ten rows),
# or by `collect()`ing the results locally.
system.time(recent &lt;- filter(batting, yearID &gt; 2010))
system.time(collect(recent))

# You can see the query that dplyr creates with show_query()
batting %&gt;%
  filter(G &gt; 0) %&gt;%
  group_by(playerID) %&gt;%
  summarise(n = n()) %&gt;%
  show_query()
}
</code></pre>

<hr>
<h2 id='testing'>Infrastructure for testing dplyr</h2><span id='topic+testing'></span><span id='topic+test_register_src'></span><span id='topic+test_register_con'></span><span id='topic+src_test'></span><span id='topic+test_load'></span><span id='topic+test_frame'></span>

<h3>Description</h3>

<p>Register testing sources, then use <code>test_load()</code> to load an existing
data frame into each source. To create a new table in each source,
use <code>test_frame()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_register_src(name, src)

test_register_con(name, ...)

src_test(name)

test_load(
  df,
  name = unique_table_name(),
  srcs = test_srcs$get(),
  ignore = character()
)

test_frame(..., srcs = test_srcs$get(), ignore = character())
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test_register_src("sqlite", {
  DBI::dbConnect(RSQLite::SQLite(), ":memory:", create = TRUE)
})

test_frame(x = 1:3, y = 3:1)
test_load(mtcars)

## End(Not run)
</code></pre>

<hr>
<h2 id='translate_sql'>Translate an expression to SQL</h2><span id='topic+translate_sql'></span><span id='topic+translate_sql_'></span>

<h3>Description</h3>

<p>dbplyr translates commonly used base functions including logical
(<code>!</code>, <code>&amp;</code>, <code>|</code>), arithmetic (<code>^</code>), and comparison (<code>!=</code>) operators, as well
as common summary (<code>mean()</code>, <code>var()</code>), and transformation (<code>log()</code>)
functions.  All other functions will be preserved as is. R's infix functions
(e.g. <code style="white-space: pre;">&#8288;%like%&#8288;</code>) will be converted to their SQL equivalents (e.g. <code>LIKE</code>).
</p>
<p>Learn more in <code>vignette("translation-function")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_sql(
  ...,
  con,
  vars_group = NULL,
  vars_order = NULL,
  vars_frame = NULL,
  window = TRUE
)

translate_sql_(
  dots,
  con,
  vars_group = NULL,
  vars_order = NULL,
  vars_frame = NULL,
  window = TRUE,
  context = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_sql_+3A_...">...</code>, <code id="translate_sql_+3A_dots">dots</code></td>
<td>
<p>Expressions to translate. <code>translate_sql()</code>
automatically quotes them for you.  <code>translate_sql_()</code> expects
a list of already quoted objects.</p>
</td></tr>
<tr><td><code id="translate_sql_+3A_con">con</code></td>
<td>
<p>An optional database connection to control the details of
the translation. The default, <code>NULL</code>, generates ANSI SQL.</p>
</td></tr>
<tr><td><code id="translate_sql_+3A_vars_group">vars_group</code>, <code id="translate_sql_+3A_vars_order">vars_order</code>, <code id="translate_sql_+3A_vars_frame">vars_frame</code></td>
<td>
<p>Parameters used in the <code>OVER</code>
expression of windowed functions.</p>
</td></tr>
<tr><td><code id="translate_sql_+3A_window">window</code></td>
<td>
<p>Use <code>FALSE</code> to suppress generation of the <code>OVER</code>
statement used for window functions. This is necessary when generating
SQL for a grouped summary.</p>
</td></tr>
<tr><td><code id="translate_sql_+3A_context">context</code></td>
<td>
<p>Use to carry information for special translation cases. For example, MS SQL needs a different conversion for is.na() in WHERE vs. SELECT clauses.  Expects a list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- simulate_dbi()

# Regular maths is translated in a very straightforward way
translate_sql(x + 1, con = con)
translate_sql(sin(x) + tan(y), con = con)

# Note that all variable names are escaped
translate_sql(like == "x", con = con)
# In ANSI SQL: "" quotes variable _names_, '' quotes strings

# Logical operators are converted to their sql equivalents
translate_sql(x &lt; 5 &amp; !(y &gt;= 5), con = con)
# xor() doesn't have a direct SQL equivalent
translate_sql(xor(x, y), con = con)

# If is translated into case when
translate_sql(if (x &gt; 5) "big" else "small", con = con)

# Infix functions are passed onto SQL with % removed
translate_sql(first %like% "Had%", con = con)
translate_sql(first %is% NA, con = con)
translate_sql(first %in% c("John", "Roger", "Robert"), con = con)

# And be careful if you really want integers
translate_sql(x == 1, con = con)
translate_sql(x == 1L, con = con)

# If you have an already quoted object, use translate_sql_:
x &lt;- quote(y + 1 / sin(t))
translate_sql_(list(x), con = simulate_dbi())

# Windowed translation --------------------------------------------
# Known window functions automatically get OVER()
translate_sql(mpg &gt; mean(mpg), con = con)

# Suppress this with window = FALSE
translate_sql(mpg &gt; mean(mpg), window = FALSE, con = con)

# vars_group controls partition:
translate_sql(mpg &gt; mean(mpg), vars_group = "cyl", con = con)

# and vars_order controls ordering for those functions that need it
translate_sql(cumsum(mpg), con = con)
translate_sql(cumsum(mpg), vars_order = "mpg", con = con)
</code></pre>

<hr>
<h2 id='win_over'>Generate SQL expression for window functions</h2><span id='topic+win_over'></span><span id='topic+win_rank'></span><span id='topic+win_aggregate'></span><span id='topic+win_aggregate_2'></span><span id='topic+win_recycled'></span><span id='topic+win_cumulative'></span><span id='topic+win_absent'></span><span id='topic+win_current_group'></span><span id='topic+win_current_order'></span><span id='topic+win_current_frame'></span><span id='topic+win_rank_tdata'></span>

<h3>Description</h3>

<p><code>win_over()</code> makes it easy to generate the window function specification.
<code>win_absent()</code>, <code>win_rank()</code>, <code>win_aggregate()</code>, and <code>win_cumulative()</code>
provide helpers for constructing common types of window functions.
<code>win_current_group()</code> and <code>win_current_order()</code> allow you to access
the grouping and order context set up by <code><a href="dplyr.html#topic+group_by">group_by()</a></code> and <code><a href="dplyr.html#topic+arrange">arrange()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win_over(
  expr,
  partition = NULL,
  order = NULL,
  frame = NULL,
  con = sql_current_con()
)

win_rank(f, empty_order = FALSE)

win_aggregate(f)

win_aggregate_2(f)

win_cumulative(f)

win_absent(f)

win_current_group()

win_current_order()

win_current_frame()

win_rank_tdata(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win_over_+3A_expr">expr</code></td>
<td>
<p>The window expression</p>
</td></tr>
<tr><td><code id="win_over_+3A_partition">partition</code></td>
<td>
<p>Variables to partition over</p>
</td></tr>
<tr><td><code id="win_over_+3A_order">order</code></td>
<td>
<p>Variables to order by</p>
</td></tr>
<tr><td><code id="win_over_+3A_frame">frame</code></td>
<td>
<p>A numeric vector of length two defining the frame.</p>
</td></tr>
<tr><td><code id="win_over_+3A_f">f</code></td>
<td>
<p>The name of an sql function as a string</p>
</td></tr>
<tr><td><code id="win_over_+3A_empty_order">empty_order</code></td>
<td>
<p>A logical value indicating whether to order by NULL if <code>order</code> is not specified</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- simulate_dbi()

win_over(sql("avg(x)"), con = con)
win_over(sql("avg(x)"), "y", con = con)
win_over(sql("avg(x)"), order = "y", con = con)
win_over(sql("avg(x)"), order = c("x", "y"), con = con)
win_over(sql("avg(x)"), frame = c(-Inf, 0), order = "y", con = con)
</code></pre>

<hr>
<h2 id='window_order'>Override window order and frame</h2><span id='topic+window_order'></span><span id='topic+window_frame'></span>

<h3>Description</h3>

<p>These allow you to override the <code style="white-space: pre;">&#8288;PARTITION BY&#8288;</code> and <code style="white-space: pre;">&#8288;ORDER BY&#8288;</code> clauses
of window functions generated by grouped mutates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_order(.data, ...)

window_frame(.data, from = -Inf, to = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_order_+3A_.data">.data</code></td>
<td>
<p>A lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="window_order_+3A_...">...</code></td>
<td>
<p>Variables to order by</p>
</td></tr>
<tr><td><code id="window_order_+3A_from">from</code>, <code id="window_order_+3A_to">to</code></td>
<td>
<p>Bounds of the frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

db &lt;- memdb_frame(g = rep(1:2, each = 5), y = runif(10), z = 1:10)
db %&gt;%
  window_order(y) %&gt;%
  mutate(z = cumsum(y)) %&gt;%
  show_query()

db %&gt;%
  group_by(g) %&gt;%
  window_frame(-3, 0) %&gt;%
  window_order(z) %&gt;%
  mutate(z = sum(y)) %&gt;%
  show_query()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
