<!DOCTYPE html><html><head><title>Help for package DNAtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DNAtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DNAtools-package'><p>Tools for analysing forensic genetic DNA databases</p></a></li>
<li><a href='#dbCollapse'><p>Collapse m/p output to vector</p></a></li>
<li><a href='#dbCompare'><p>Compare DNA profiles</p></a></li>
<li><a href='#dbExample'><p>Simulated database with 1,000 individuals</p></a></li>
<li><a href='#dbExpect'><p>Expected value of cell counts in DNA database comparison</p></a></li>
<li><a href='#dbSimulate'><p>Simulate a DNA database</p></a></li>
<li><a href='#dbVariance'><p>Covariance matrix of cell counts in DNA database comparison</p></a></li>
<li><a href='#estimatePD'><p>Estimate the drop-out probability based on number of alleles</p></a></li>
<li><a href='#freqEst'><p>Simple allele frequency estimation</p></a></li>
<li><a href='#genRypeRec'><p>Generates DNA profiles of n individuals.</p></a></li>
<li><a href='#genTypeRec'><p>Generates DNA profiles of n unrelated individuals for a locus</p></a></li>
<li><a href='#optim.relatedness'><p>Estimate theta and the fraction of comparisons between close relatives</p></a></li>
<li><a href='#pContrib'><p>Compute the posterior probabilities for P(m|n0) for a given prior P(m) and</p>
observed vector n0 of locus counts</a></li>
<li><a href='#pContrib_locus'><p>Compute the posterior probabilities for <code class="reqn">\Pr(m|n_0)</code> for a given prior</p>
<code class="reqn">\Pr(m)</code>.</a></li>
<li><a href='#plot.dbcompare'><p>Plots the summary matrix</p></a></li>
<li><a href='#plot.dbOptim'><p>Plots the fitted object function for estimated familial relationships in the</p>
database and theta.</a></li>
<li><a href='#Pnm_all'><p>The exact distribution of the number of alleles in a m-person DNA mixture</p></a></li>
<li><a href='#print.dbcompare'><p>Prints the summary matrix</p></a></li>
<li><a href='#print.dbOptim'><p>Prints the results from optim.relatedness()</p></a></li>
<li><a href='#simAlleleFreqs'><p>Simulate Allele Frequencies</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Analysing Forensic Genetic DNA Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-4</td>
</tr>
<tr>
<td>Author:</td>
<td>Torben Tvedebrink [aut],
  James Curran [aut],
  Mikkel Meyer Andersen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikkel Meyer Andersen &lt;mikl@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computationally efficient tools for comparing all pairs of profiles
    in a DNA database. The expectation and covariance of the summary statistic
    is implemented for fast computing. Routines for estimating proportions of
    close related individuals are available. The use of wildcards (also called F-
    designation) is implemented. Dedicated functions ease plotting the results. 
    See Tvedebrink et al. (2012) &lt;<a href="https://doi.org/10.1016%2Fj.fsigen.2011.08.001">doi:10.1016/j.fsigen.2011.08.001</a>&gt;. 
    Compute the distribution of the numbers of alleles in DNA mixtures. 
    See Tvedebrink (2013) &lt;<a href="https://doi.org/10.1016%2Fj.fsigss.2013.10.142">doi:10.1016/j.fsigss.2013.10.142</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp (&ge; 1.16), multicool (&ge; 0.1-10), Rcpp (&ge; 0.12.12),
RcppParallel (&ge; 4.3.20)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppProgress</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, GNU make</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mikldk/DNAtools/issues">https://github.com/mikldk/DNAtools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, testthis, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils, knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-17 12:21:48 UTC; mikl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-17 13:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='DNAtools-package'>Tools for analysing forensic genetic DNA databases</h2><span id='topic+DNAtools-package'></span><span id='topic+DNAtools'></span>

<h3>Description</h3>

<p>Computational efficient tools for comparing all pairs of profiles in a DNA
database. The expectation and covariance of the summary statistic is
implemented for fast computing. Routines for estimating proportions of close
related individuals are available. The use of wildcards (also called
F-designation) is implemented. Dedicated functions ease plotting the
results.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> DNAtools</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
0.1</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2014-08-25</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> dbCompare:
Compares make all n(n-1)/2 pairwise comparisons between profiles of a
database with n DNA profiles. dbExpect: Computes the expected number of
matching and partial matching loci for a given number of profiles in a
database. dbVariance: Calculates the associated covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Torben Tvedebrink &lt;tvede@math.aau.dk&gt;, James Curran
&lt;j.curran@auckland.ac.nz&gt; and Mikkel Meyer Andersen
&lt;mikl@math.aau.dk&gt;.
</p>


<h3>References</h3>

<p>Tvedebrink T, JM Curran, PS Eriksen, HS Mogensen and N Morling
(2012).  Analysis of matches and partial-matches in a Danish STR data set.
Forensic Science International: Genetics, 6(3): 387-392.
</p>
<p>Read the vignette: <code>vigette('DNAtools')</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(dbExample)
  dbCompare(dbExample,hit=5,trace=TRUE)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dbCollapse'>Collapse m/p output to vector</h2><span id='topic+dbCollapse'></span>

<h3>Description</h3>

<p>Collapse a m/p-matrix from dbCompare/dbExpect to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbCollapse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCollapse_+3A_x">x</code></td>
<td>
<p>Either a object of class 'dbcompare' (result from dbCompare) or
'matrix'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collapse a m/p-matrix from dbCompare/dbExpect to a vector with entry i being
the sum of all entries from m/p-matrix satisfying 2*m+p=i.
</p>


<h3>Value</h3>

<p>A vector of length 2*max(m)+1 with entries begin the sum of entries
i in m/p-matrix satisfying i=2*m+p.
</p>


<h3>Author(s)</h3>

<p>Torben Tvedebrink
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(dbExample)
  res &lt;- dbCompare(dbExample, hit=5, trace=TRUE)
  dbCollapse(res) ## same as dbCompare(dbExample, hit=5, trace=TRUE, collapse=TRUE)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='dbCompare'>Compare DNA profiles</h2><span id='topic+dbCompare'></span>

<h3>Description</h3>

<p>Compare DNA profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbCompare(
  x,
  profiles = NULL,
  hit = 7,
  trace = TRUE,
  vector = FALSE,
  collapse = FALSE,
  wildcard = FALSE,
  wildcard.effect = FALSE,
  wildcard.impose = FALSE,
  Rallele = FALSE,
  threads = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCompare_+3A_x">x</code></td>
<td>
<p>Database with DNA profiles. The database format is expected to be a
data frame with each column containing an allelic number such that for each
DNA marker there are two columns in the data frame. See
<code>data(dbExample)</code> for an example of the format.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_profiles">profiles</code></td>
<td>
<p>One or more profiles to be compared with all profiles in the
database. Input is a vector, matrix or data frame of same length/width as a
row in the database <code>x</code>.  If profiles is non-null only one CPU will be
used. In case threads&gt;1 a warning will be given but computations performed
using single core.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_hit">hit</code></td>
<td>
<p>The number of matching loci for further investigation</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_trace">trace</code></td>
<td>
<p>Shows a progress bar</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_vector">vector</code></td>
<td>
<p>Logical. Whether the result should be returned as vector or a
matrix. Note if 'collapse' is TRUE vector is ignored.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_collapse">collapse</code></td>
<td>
<p>Logical (default FALSE). If TRUE the (m,p)-matrix will be
collapased into a (2*m+p)-vector containing the total number of matching
alleles.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_wildcard">wildcard</code></td>
<td>
<p>Use the wildcard comparing.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_wildcard.effect">wildcard.effect</code></td>
<td>
<p>Compare result of wildcard and no wildcard.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_wildcard.impose">wildcard.impose</code></td>
<td>
<p>Force homozygouse profiles (aa) to have wildcard
(aF).</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_rallele">Rallele</code></td>
<td>
<p>Implementation of 'Rare allele'designation matching.</p>
</td></tr>
<tr><td><code id="dbCompare_+3A_threads">threads</code></td>
<td>
<p>The number of threads to use for performing comparisons in
parallel for increased computation time. Use 0 for using the same number as
the computer has CPU cores. NOTE: Only available on Linux and MacOS
operating systems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distance between DNA profiles in terms of matching and
partially-matching STR loci.
</p>


<h3>Value</h3>

<p>Returns a matrix with the number of pairs
mathcing/partially-matching at (i,j)-loci.
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink. The multicore/CPU implementation
was provided by Mikkel Meyer Andersen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(dbExample)
  dbCompare(dbExample,hit=5,trace=TRUE)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='dbExample'>Simulated database with 1,000 individuals</h2><span id='topic+dbExample'></span>

<h3>Description</h3>

<p>Database containing 1,000 simulated DNA profiles typed on ten autosomal
markers.
</p>


<h3>Format</h3>

<p>A data frame with each row being a DNA profile and each column a
part of a genetic marker. Note that homozygote profiles has the same allelic
value in the two columns associated to the same marker.
</p>

<hr>
<h2 id='dbExpect'>Expected value of cell counts in DNA database comparison</h2><span id='topic+dbExpect'></span>

<h3>Description</h3>

<p>Computes the expected number of cell counts when comparing DNA profiles in a
DNA database. For every pair of DNA profiles in a database the number of
matching and partial matching loci is recorded. A match is declared if the
two DNA profiles coincide for both alleles in a locus and a partial-match is
recorded if only one allele is shared between the profiles. With a total of
L loci the number of matching loci is 0,...,L and partial number of matches
is 0,...,L-m, where m is the number of matching loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbExpect(
  probs,
  theta = 0,
  k = c(0, 0, 1),
  n = 1,
  r = 0,
  R = 0,
  round = FALSE,
  na = TRUE,
  vector = FALSE,
  collapse = FALSE,
  wildcard = FALSE,
  no.wildcard = NULL,
  rare.allele = FALSE,
  no.rare.allele = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbExpect_+3A_probs">probs</code></td>
<td>
<p>List of vectors with allele probabilities for each locus</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_theta">theta</code></td>
<td>
<p>The coancestery coefficient</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_k">k</code></td>
<td>
<p>The vector of identical-by-descent probabilities, k=(k2,k1,k0),
where for full-siblings k=c(1,2,1)/4. The default is k=c(0,0,1) refering to
unrelated individuals.</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_n">n</code></td>
<td>
<p>Number of DNA profiles in the database</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_r">r</code></td>
<td>
<p>The probability assigned to the rare alleles (see rare allele
matching). If a vector must be of same length as <code>probs</code>.</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_r">R</code></td>
<td>
<p>The probability assigned to alleles shorter or longer than allelic
ladder (see rare allele matching). If a vector must be of length 1 or 2, and
if a list it must be same length as <code>probs</code>.</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_round">round</code></td>
<td>
<p>Whether or not the results should be rounded or not</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_na">na</code></td>
<td>
<p>Whether or not the off-elements should be returned as 0 or NA</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_vector">vector</code></td>
<td>
<p>Whether or not the result should be returned as a matrix or
vector. Note if 'collapse' is TRUE vector is ignored.</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_collapse">collapse</code></td>
<td>
<p>Logical (default FALSE). If TRUE the (m,p)-matrix will be
collapased into a (2*m+p)-vector containing the total number of matching
alleles.</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_wildcard">wildcard</code></td>
<td>
<p>Should wildcards be used?</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_no.wildcard">no.wildcard</code></td>
<td>
<p>Should 'w' wildcards be used?</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_rare.allele">rare.allele</code></td>
<td>
<p>Should rare allele matching be used?</p>
</td></tr>
<tr><td><code id="dbExpect_+3A_no.rare.allele">no.rare.allele</code></td>
<td>
<p>Should 'r' rare allele loci be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the expected cell counts using a recursion formula. See Tvedebrink
et al (2011) for details.
</p>


<h3>Value</h3>

<p>Returns a matrix (or vector, see above) of expected cell counts.
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>References</h3>

<p>T Tvedebrink, PS Eriksen, J Curran, HS Mogensen, N Morling.
'Analysis of matches and partial-matches in Danish DNA reference profile
database'. Forensic Science International: Genetics, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Simulate some allele frequencies:
  freqs &lt;-  replicate(10, { g = rgamma(n=10,scale=4,shape=3); g/sum(g)},
              simplify=FALSE)
  ## Compute the expected number for a DB with 10000 profiles:
  dbExpect(freqs,theta=0,n=10000)
  
## End(Not run) 

</code></pre>

<hr>
<h2 id='dbSimulate'>Simulate a DNA database</h2><span id='topic+dbSimulate'></span>

<h3>Description</h3>

<p>Simulates a DNA database given a set of allele probabilities and theta
value. It is possible to have close relatives in the database simulated in
pairs, such that within each pair the profiles are higher correlated due to
close familial relationship, but between pairs of profiles the correlation
is only modelled by theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbSimulate(probs, theta = 0, n = 1000, relatives = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSimulate_+3A_probs">probs</code></td>
<td>
<p>List of allele probabilities, where each element in the list is
a vector of allele probabilities.</p>
</td></tr>
<tr><td><code id="dbSimulate_+3A_theta">theta</code></td>
<td>
<p>The coancestry coefficient</p>
</td></tr>
<tr><td><code id="dbSimulate_+3A_n">n</code></td>
<td>
<p>The number of profiles in the database</p>
</td></tr>
<tr><td><code id="dbSimulate_+3A_relatives">relatives</code></td>
<td>
<p>A vector of length 4. Determining the number of PAIRS of
profiles in the database: (FULL-SIBLINGS, FIRST-COUSINS, PARENT-CHILD,
AVUNCULAR). They should obey that 2*sum(relatives)&lt;=n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates a DNA database with a given number of DNA profiles (and possibly
relatives) with a correlation between profiles governed by theta.
</p>


<h3>Value</h3>

<p>A data frame where each row represents a DNA profile. The first
column is a profile identifier (id) and the next 2*L columns contains the
simulated genotype for each of the L loci. L is determined by the length of
the list 'probs' with allele probabilities
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Simulate some allele frequencies:
                                                                                
  freq &lt;-  replicate(10, { g = rgamma(n=10,scale=4,shape=3); g/sum(g)},
             simplify=FALSE)
  ## Simulate a single database with 5000 DNA profiles:
  simdb &lt;- dbSimulate(freq,theta=0,n=5000)
  ## Simulate a number of databases, say N=50. For each database compute
  ## the summary statistic using dbCompare:
  N &lt;- 50
  Msummary &lt;- matrix(0,N,(length(freq)+1)*(length(freq)+2)/2)
  for(i in 1:N)
    Msummary[i,] &lt;- dbCompare(dbSimulate(freq,theta=0,n=1000),
                      vector=TRUE,trace=FALSE)$m
  ## Give the columns  representative names:
  dimnames(Msummary)[[2]] &lt;- DNAtools:::dbCats(length(freq),vector=TRUE)
  ## Plot the simulations using a boxplot
  boxplot(log10(Msummary))
  ## There might come some warnings due to taking log10 to zero-values (no counts)
  ## Add the expected number to the plot:
  points(1:ncol(Msummary),log10(dbExpect(freq,theta=0,n=1000,vector=TRUE)),
         col=2,pch=16)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='dbVariance'>Covariance matrix of cell counts in DNA database comparison</h2><span id='topic+dbVariance'></span>

<h3>Description</h3>

<p>Computes the covariance matrix for the cell counts when comparing DNA
profiles in a DNA database. For every pair of DNA profiles in a database the
number of matching and partial matching loci is recorded. A match is
declared if the two DNA profiles coincide for both alleles in a locus and a
partial-match is recorded if only one allele is shared between the profiles.
With a total of L loci the number of matching loci is 0,...,L and partial
number of matches is 0,...,L-m, where m is the number of matching loci. The
expression is given by: </p>
<p style="text-align: center;"><code class="reqn">latex</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbVariance(probs, theta = 0, n = 1, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbVariance_+3A_probs">probs</code></td>
<td>
<p>List of vectors with allele probabilities for each locus</p>
</td></tr>
<tr><td><code id="dbVariance_+3A_theta">theta</code></td>
<td>
<p>The coancestery coefficient. If a vector of different theta
values are supplied a list of covariance matrices is returned. Note it is
faster to give a vector of theta values as argument than calculating each
matrix at the time.</p>
</td></tr>
<tr><td><code id="dbVariance_+3A_n">n</code></td>
<td>
<p>Number of DNA profiles in the database. If n=1 is supplied a list
of the components for computing the variance is returned. That is, the
variance and two covariances on the right hand side of the equation above.</p>
</td></tr>
<tr><td><code id="dbVariance_+3A_collapse">collapse</code></td>
<td>
<p>Logical, default FALSE. If TRUE the covariance matrix is
collapsed such that it relates to (2*m+p)-vectors of total number of
matching alleles rather than (m,p)-matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the covariance matrix of the cell counts using a recursion formula.
See Tvedebrink et al (2011) for details.
</p>


<h3>Value</h3>

<p>Returns a covariance matrix for the cell counts.
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>References</h3>

<p>T Tvedebrink, PS Eriksen, J Curran, HS Mogensen, N Morling.
'Analysis of matches and partial-matches in Danish DNA reference profile
database'. Forensic Science International: Genetics, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Simulate some allele frequencies:
  freqs &lt;-  replicate(10, { g = rgamma(n=10,scale=4,shape=3); g/sum(g)}, simplify=FALSE)
  ## List of elements needed to compute the covariance matrix.
  ## Useful option when the covariance needs to be computed for varying
  ## database sizes but for identical theta-value.
  comps &lt;- dbVariance(freqs,theta=0,n=1)
  ## Covariance for a DB with 1000 DNA profiles
  cov1000 &lt;- dbVariance(freqs,theta=0,n=1000)
  ## The result is the same as:
  comps1000 &lt;- choose(1000,2)*comps$V1 + 6*choose(1000,3)*comps$V2 + 6*choose(1000,4)*comps$V3
  
## End(Not run)

</code></pre>

<hr>
<h2 id='estimatePD'>Estimate the drop-out probability based on number of alleles</h2><span id='topic+estimatePD'></span>

<h3>Description</h3>

<p>An inferior may to estimate the drop-out probability compared to using the
peak heights from the electropherogram. However, to compare the performance
with Gill et al. (2007) this implements a theoretical approach based on
their line of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePD(n0, m, pnoa = NULL, probs = NULL, theta = 0, locuswise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatePD_+3A_n0">n0</code></td>
<td>
<p>Vector of observed allele counts - same length as the number of
loci</p>
</td></tr>
<tr><td><code id="estimatePD_+3A_m">m</code></td>
<td>
<p>The number of contributors</p>
</td></tr>
<tr><td><code id="estimatePD_+3A_pnoa">pnoa</code></td>
<td>
<p>The vector of <code class="reqn">\P(N(m)=n)</code> for <code class="reqn">n=1,\ldots,2Lm</code>, where <code class="reqn">L</code> is the number
of loci and <code class="reqn">m</code> is the number of contributors OR</p>
</td></tr>
<tr><td><code id="estimatePD_+3A_probs">probs</code></td>
<td>
<p>List of vectors with allele probabilities for each locus</p>
</td></tr>
<tr><td><code id="estimatePD_+3A_theta">theta</code></td>
<td>
<p>The coancestery coefficient</p>
</td></tr>
<tr><td><code id="estimatePD_+3A_locuswise">locuswise</code></td>
<td>
<p>Logical. Indicating whether computations should be done
locuswise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the <code class="reqn">\Pr(D)</code> that maximises equation (10) in Tvedebrink (2014).
</p>


<h3>Value</h3>

<p>Returns the MLE of <code class="reqn">\Pr(D)</code> based on equation (10) in Tvedebrink (2014)
</p>


<h3>Author(s)</h3>

<p>Torben Tvedebrink
</p>


<h3>References</h3>

<p>Gill, P., A. Kirkham, and J. Curran (2007).  LoComatioN: A
software tool for the analysis of low copy number DNA profiles.  Forensic
Science International 166(2-3): 128 - 138.
</p>
<p>T. Tvedebrink (2014). 'On the exact distribution of the number of 
alleles in DNA mixtures', International Journal of Legal Medicine; 128(3):427&ndash;37. 
&lt;https://doi.org/10.1007/s00414-013-0951-3&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Simulate some allele frequencies:
  freqs &lt;-  simAlleleFreqs()
  ## Assume 15 alleles are observed in a 2-person DNA mixture with 10 loci:
  estimatePD(n0 = 15, m = 2, probs = freqs)

</code></pre>

<hr>
<h2 id='freqEst'>Simple allele frequency estimation</h2><span id='topic+freqEst'></span>

<h3>Description</h3>

<p>Estimates allele frequencies from a database with DNA profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqEst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqEst_+3A_x">x</code></td>
<td>
<p>A database of the form ['id','locus1 allele1','locus1
allele2',...,'locusN allele 1','locusN allele2'].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the allele frequencies for a given database.
</p>


<h3>Value</h3>

<p>Returns a list of probability vectors - one vector for each locus.
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(dbExample)
  freqEst(dbExample)

</code></pre>

<hr>
<h2 id='genRypeRec'>Generates DNA profiles of n individuals.</h2><span id='topic+genRypeRec'></span>

<h3>Description</h3>

<p>These are formed as n/2 pairs for relatives with
a IDB-vector given by k. I.e. the profiles are 
mutually unrelated between pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRypeRec(x, t, k, n, print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genRypeRec_+3A_x">x</code></td>
<td>
<p>Allele probabilities</p>
</td></tr>
<tr><td><code id="genRypeRec_+3A_t">t</code></td>
<td>
<p>theta correction</p>
</td></tr>
<tr><td><code id="genRypeRec_+3A_k">k</code></td>
<td>
<p>Relatedness vector</p>
</td></tr>
<tr><td><code id="genRypeRec_+3A_n">n</code></td>
<td>
<p>Number of probles</p>
</td></tr>
<tr><td><code id="genRypeRec_+3A_print">print</code></td>
<td>
<p>Print information</p>
</td></tr>
</table>

<hr>
<h2 id='genTypeRec'>Generates DNA profiles of n unrelated individuals for a locus</h2><span id='topic+genTypeRec'></span>

<h3>Description</h3>

<p>Generates DNA profiles of n unrelated individuals for a locus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTypeRec(x, t, n, z = rep(0, lx &lt;- length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTypeRec_+3A_x">x</code></td>
<td>
<p>Allele probabilities</p>
</td></tr>
<tr><td><code id="genTypeRec_+3A_t">t</code></td>
<td>
<p>theta correction</p>
</td></tr>
<tr><td><code id="genTypeRec_+3A_n">n</code></td>
<td>
<p>Number of probles</p>
</td></tr>
<tr><td><code id="genTypeRec_+3A_z">z</code></td>
<td>
<p>FIXME</p>
</td></tr>
</table>

<hr>
<h2 id='optim.relatedness'>Estimate theta and the fraction of comparisons between close relatives</h2><span id='topic+optim.relatedness'></span>

<h3>Description</h3>

<p>Estimates the fraction of comparisons between pairs of close relatives while
fitting the theta parameter minimising the object function. The function
makes use of the R-package 'Rsolnp' which is an implementation of an solver
for non-linear minimisation problems with parameter constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.relatedness(
  obs,
  theta0 = 0,
  theta1 = 0.03,
  theta.tol = 10^(-7),
  theta.step = NULL,
  max.bisect = 15,
  probs,
  var.list = NULL,
  init.alpha = 10^c(-4, -6, -8, -10),
  init.keep = FALSE,
  objFunction = c("T2", "T1", "C3", "C2", "C1"),
  collapse = FALSE,
  trace = FALSE,
  solnp.ctrl = list(tol = 10^(-9), rho = 10, delta = min(init.alpha) * 0.01, trace =
    FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.relatedness_+3A_obs">obs</code></td>
<td>
<p>The matrix or vector of observed matches/partial-matches as
returned by the dbCompare()-function</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_theta0">theta0</code></td>
<td>
<p>The left value of the interval in which a bisection-like
search is performed for theta</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_theta1">theta1</code></td>
<td>
<p>Right value of interval (see theta0)</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_theta.tol">theta.tol</code></td>
<td>
<p>A stopping criterion for the search. If the search narrows
within theta.tol the function terminates</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_theta.step">theta.step</code></td>
<td>
<p>Default is NULL. If not a grid search will be performed on
seq(from = theta0, to = theta1, by = theta.step)</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_max.bisect">max.bisect</code></td>
<td>
<p>The maximum number of bisectional iterations perform prior
to termination</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_probs">probs</code></td>
<td>
<p>List of vectors with allele probabilities for each locus</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_var.list">var.list</code></td>
<td>
<p>A named list of components for computing variances, see
dbVariance. The names of the elements are the associated theta-values, and
each component is a list of (V1,V2,V3) - see dbVariance with n=1</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_init.alpha">init.alpha</code></td>
<td>
<p>Initial values for alpha, where the order is
(First-cousins, Avuncular, Parent-child, Full-siblings). The value for
Unrelated is computed as 1-sum(init.alpha)</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_init.keep">init.keep</code></td>
<td>
<p>Whether the initial values should be used in successive
steps for the current optimum should be used.</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_objfunction">objFunction</code></td>
<td>
<p>Which of the five different object functions should be
used to compare observed and expected</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_collapse">collapse</code></td>
<td>
<p>Not yet implemented</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_trace">trace</code></td>
<td>
<p>Should iteration steps and other process indicators be printed</p>
</td></tr>
<tr><td><code id="optim.relatedness_+3A_solnp.ctrl">solnp.ctrl</code></td>
<td>
<p>See solnp for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the proportion of comparisons between close relatives in a database
matching exercise for each theta value under investigation.
</p>


<h3>Value</h3>

<p>Returns a list of three components: value, solution and var.list.
The first element, value, is a dataframe with the value of the objection
function for each of the theta values investigated. Solution is the
estimated alpha-vector where the objection function was minimised. Finally,
var.list is a names list of components for computing variances. May be
reused in later computations for increased speed in some iterations.
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>References</h3>

<p>T Tvedebrink, PS Eriksen, J Curran, HS Mogensen, N Morling.
'Analysis of matches and partial-matches in Danish DNA reference profile
database'. Forensic Science International: Genetics, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Simulate some allele frequencies:
  freqs &lt;-  replicate(10, { g = rgamma(n=10,scale=4,shape=3); g/sum(g)},
              simplify=FALSE)
  ## Load the sample database:
  data(dbExample)
  obs &lt;- dbCompare(dbExample,trace=FALSE)$m
  C3 &lt;- optim.relatedness(obs,theta0=0.0,theta1=0.03,probs=freqs,
          objFunction='C3',max.bisect=30,trace=TRUE)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='pContrib'>Compute the posterior probabilities for P(m|n0) for a given prior P(m) and
observed vector n0 of locus counts</h2><span id='topic+pContrib'></span>

<h3>Description</h3>

<p>where m ranges from 1 to <code class="reqn">m_{\max}</code> and <code class="reqn">n_0</code> is
the observed locus counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pContrib(n0, probs = NULL, m.prior = rep(1/m.max, m.max), m.max = 8, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pContrib_+3A_n0">n0</code></td>
<td>
<p>Vector of observed allele counts - same length as the number of
loci.</p>
</td></tr>
<tr><td><code id="pContrib_+3A_probs">probs</code></td>
<td>
<p>List of vectors with allele probabilities for each locus</p>
</td></tr>
<tr><td><code id="pContrib_+3A_m.prior">m.prior</code></td>
<td>
<p>A vector with prior probabilities (summing to 1), where the
length of <code>m.prior</code> determines the plausible range of m</p>
</td></tr>
<tr><td><code id="pContrib_+3A_m.max">m.max</code></td>
<td>
<p>Derived from the length of <code>m.prior</code>, and if
<code>m.prior=NULL</code> a uniform prior is speficied by <code>m.max</code>:
<code>m.prior = rep(1/m.max,m.max)</code>.</p>
</td></tr>
<tr><td><code id="pContrib_+3A_theta">theta</code></td>
<td>
<p>The coancestery coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a vector P(m|n0) evaluated over the plausible range 1,...,m.max.
</p>


<h3>Value</h3>

<p>Returns a vector P(m|n0) for m=1,...,m.max
</p>


<h3>Author(s)</h3>

<p>Torben Tvedebrink, James Curran
</p>


<h3>References</h3>

<p>T. Tvedebrink (2014). 'On the exact distribution of the number of 
alleles in DNA mixtures', International Journal of Legal Medicine; 128(3):427&ndash;37. 
&lt;https://doi.org/10.1007/s00414-013-0951-3&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Simulate some allele frequencies:
  freqs &lt;-  simAlleleFreqs()
  m &lt;- 2
  n0 &lt;- sapply(freqs, function(px){
                            peaks = unique(sample(length(px),
                                             size = 2 * m,
                                             replace = TRUE,
                                             prob = px))
                            return(length(peaks))
                       })
  ## Compute P(m|n0) for m=1,...,4 and the sampled n0
  pContrib(n0=n0,probs=freqs,m.max=4)

</code></pre>

<hr>
<h2 id='pContrib_locus'>Compute the posterior probabilities for <code class="reqn">\Pr(m|n_0)</code> for a given prior 
<code class="reqn">\Pr(m)</code>.</h2><span id='topic+pContrib_locus'></span>

<h3>Description</h3>

<p>Compute a matrix of posterior probabilties <code class="reqn">\Pr(m|n_0)</code> where <code class="reqn">m</code>
ranges from 1 to <code class="reqn">m_{\max}</code>, and <code class="reqn">n_0</code> is
<code class="reqn">0,\ldots,2m_{\max}</code>. This is done by evaluating
<code class="reqn">\Pr(m|n_0)=Pr(n_0|m)Pr(m)/Pr(n)</code>, where
<code class="reqn">\Pr(n_0|m)</code> is evaluated by <code><a href="#topic+pNoA">pNoA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pContrib_locus(
  prob = NULL,
  m.prior = NULL,
  m.max = 8,
  pnoa.locus = NULL,
  theta = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pContrib_locus_+3A_prob">prob</code></td>
<td>
<p>Vectors with allele probabilities for the specific locus</p>
</td></tr>
<tr><td><code id="pContrib_locus_+3A_m.prior">m.prior</code></td>
<td>
<p>A vector with prior probabilities (summing to 1), where the
length of <code>m.prior</code> determines the plausible range of <code class="reqn">m</code></p>
</td></tr>
<tr><td><code id="pContrib_locus_+3A_m.max">m.max</code></td>
<td>
<p>Derived from the length of <code>m.prior</code>, and if
<code>m.prior=NULL</code> a uniform prior is speficied by <code>m.max</code>:
<code>m.prior = rep(1/m.max,m.max)</code>.</p>
</td></tr>
<tr><td><code id="pContrib_locus_+3A_pnoa.locus">pnoa.locus</code></td>
<td>
<p>A named vector of locus specific probabilities
<code class="reqn">P(N(m)=n), n=1,\ldots,2m</code>.</p>
</td></tr>
<tr><td><code id="pContrib_locus_+3A_theta">theta</code></td>
<td>
<p>The coancestery coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a matrix of <code class="reqn">\Pr(m|n_0)</code> values for a specific locus.
</p>


<h3>Value</h3>

<p>Returns a matrix <code class="reqn">[\Pr(m|n_0)]</code> for 
<code class="reqn">m = 1,\ldots,m.max</code> and <code class="reqn">n_0 = 1,\ldots,2m.max</code>.
</p>


<h3>Author(s)</h3>

<p>Torben Tvedebrink, James Curran
</p>


<h3>References</h3>

<p>T. Tvedebrink (2014). 'On the exact distribution of the number of 
alleles in DNA mixtures', International Journal of Legal Medicine; 128(3):427&ndash;37. 
&lt;https://doi.org/10.1007/s00414-013-0951-3&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Simulate some allele frequencies:
  freqs &lt;-  simAlleleFreqs()
  
  ## Compute Pr(m|n0) for m = 1, ..., 5 and n0 = 1, ..., 10 for the first locus:
  pContrib_locus(prob = freqs[[1]], m.max = 5)

</code></pre>

<hr>
<h2 id='plot.dbcompare'>Plots the summary matrix</h2><span id='topic+plot.dbcompare'></span>

<h3>Description</h3>

<p>Plots the summary matrix with counts on y-axis and classification on x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbcompare'
plot(x, log = "y", las = 3, xlab = "Match/Partial", ylab = "Counts", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dbcompare_+3A_x">x</code></td>
<td>
<p>Summary matrix returned from dbcompare</p>
</td></tr>
<tr><td><code id="plot.dbcompare_+3A_log">log</code></td>
<td>
<p>Specifies whether log(Counts) should be plotted (default)</p>
</td></tr>
<tr><td><code id="plot.dbcompare_+3A_las">las</code></td>
<td>
<p>Direction of the labels on x-axis. Default is 3 which gives
perpendicular labels</p>
</td></tr>
<tr><td><code id="plot.dbcompare_+3A_xlab">xlab</code></td>
<td>
<p>Axis label</p>
</td></tr>
<tr><td><code id="plot.dbcompare_+3A_ylab">ylab</code></td>
<td>
<p>Axis label</p>
</td></tr>
<tr><td><code id="plot.dbcompare_+3A_...">...</code></td>
<td>
<p>Other plot options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the summary matrix. The counts are on log10 scale and the
x-axis is labeled by appropriate matching/partially-matching levels.
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>See Also</h3>

<p>dbCompare,print.dbcompare
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(dbExample)
  M = dbCompare(dbExample,hit=5)
  plot(M)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.dbOptim'>Plots the fitted object function for estimated familial relationships in the
database and theta.</h2><span id='topic+plot.dbOptim'></span><span id='topic+points.dbOptim'></span><span id='topic+lines.dbOptim'></span>

<h3>Description</h3>

<p>Plots the minimised object function for included values of theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbOptim'
plot(x, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dbOptim_+3A_x">x</code></td>
<td>
<p>Object returned by optim.relatedness</p>
</td></tr>
<tr><td><code id="plot.dbOptim_+3A_type">type</code></td>
<td>
<p>The type of plot character ('l'=line, 'p'=points, ...), see
'par' for more details</p>
</td></tr>
<tr><td><code id="plot.dbOptim_+3A_...">...</code></td>
<td>
<p>Other plot options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the object function
</p>


<h3>Value</h3>

<p>A plot of the object function
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>See Also</h3>

<p>optim.relatedness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Simulate some allele frequencies:
  freqs &lt;-  replicate(10, { g = rgamma(n=10,scale=4,shape=3); g/sum(g)},
              simplify=FALSE)
  ## Load the sample database:
  data(dbExample)
  obs &lt;- dbCompare(dbExample,trace=FALSE)$m
  C3 &lt;- optim.relatedness(obs,theta0=0.0,theta1=0.03,probs=freqs,
          objFunction='C3',max.bisect=30,trace=TRUE)
  plot(C3)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='Pnm_all'>The exact distribution of the number of alleles in a m-person DNA mixture</h2><span id='topic+Pnm_all'></span><span id='topic+pNoA'></span><span id='topic+p.numberofalleles'></span><span id='topic+Pnm_locus'></span><span id='topic+convolve'></span>

<h3>Description</h3>

<p>Computes the exact distribution of the number of alleles in a <code class="reqn">m</code>-person DNA
mixture typed with STR loci. For a m-person DNA mixture it is possible to
observe <code class="reqn">1,\ldots,2\times m \times L</code> alleles, where <code class="reqn">L</code> is 
the total number of typed STR loci. The method allows incorporation of the 
subpopulation correction, the so-called <code class="reqn">\theta</code>-correction, to adjust 
for shared ancestry. If needed, the locus-specific probabilities can be obtained using the
<code>locuswise</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pnm_all(m, theta, probs, locuswise = FALSE)
Pnm_locus(m, theta, alleleProbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pnm_all_+3A_m">m</code></td>
<td>
<p>The number of contributors</p>
</td></tr>
<tr><td><code id="Pnm_all_+3A_theta">theta</code></td>
<td>
<p>The coancestery coefficient</p>
</td></tr>
<tr><td><code id="Pnm_all_+3A_probs">probs</code></td>
<td>
<p>List of vectors with allele probabilities for each locus</p>
</td></tr>
<tr><td><code id="Pnm_all_+3A_locuswise">locuswise</code></td>
<td>
<p>Logical. If <code>TRUE</code> the locus-wise probabilities will be
returned. Otherwise, the probability over all loci is returned.</p>
</td></tr>
<tr><td><code id="Pnm_all_+3A_alleleprobs">alleleProbs</code></td>
<td>
<p>Vectors with allele probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the exact distribution of the number of alleles for a m-person DNA
mixture.
</p>


<h3>Value</h3>

<p>Returns a vector of probabilities, or a matrix of locuswise
probability vectors.
</p>


<h3>Author(s)</h3>

<p>Torben Tvedebrink, James Curran, Mikkel Andersen
</p>


<h3>References</h3>

<p>T. Tvedebrink (2014). 'On the exact distribution of the number of 
alleles in DNA mixtures', International Journal of Legal Medicine; 128(3):427&ndash;37. 
&lt;https://doi.org/10.1007/s00414-013-0951-3&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Simulate some allele frequencies:
  freqs &lt;-  structure(replicate(10, { g = rgamma(n = 10, scale = 4, shape = 3); 
                                      g/sum(g)
                                    },
              simplify = FALSE), .Names = paste('locus', 1:10, sep = '.'))

  ## Compute \eqn{\Pr(N(m = 3) = n)}, \eqn{n = 1,\ldots,2 * L *m}, where \eqn{L = 10}
  ## here
  Pnm_all(m = 2, theta = 0, freqs)
  ## Same, but locuswise results
  Pnm_all(m = 2, theta = 0, freqs, locuswise = TRUE)
  
</code></pre>

<hr>
<h2 id='print.dbcompare'>Prints the summary matrix</h2><span id='topic+print.dbcompare'></span>

<h3>Description</h3>

<p>Prints the summary matrix and possible 'big hits'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbcompare'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dbcompare_+3A_x">x</code></td>
<td>
<p>Summary matrix returned from dbcompare</p>
</td></tr>
<tr><td><code id="print.dbcompare_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the summary matrix
</p>


<h3>Value</h3>

<p>Prints the summary matrix and data frame with 'big hits'
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>See Also</h3>

<p>dbCompare,plot.dbcompare
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  data(dbExample)
  M = dbCompare(dbExample,hit=5)
  M
  
## End(Not run)

</code></pre>

<hr>
<h2 id='print.dbOptim'>Prints the results from optim.relatedness()</h2><span id='topic+print.dbOptim'></span>

<h3>Description</h3>

<p>Prints the evaluated functions for the object function, best estimate of
alpha and possibly list of variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbOptim'
print(x, var.list = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dbOptim_+3A_x">x</code></td>
<td>
<p>Object returned by optim.relatedness()</p>
</td></tr>
<tr><td><code id="print.dbOptim_+3A_var.list">var.list</code></td>
<td>
<p>Logical. Whether the (long) list of variance components
should be printed to the screen.</p>
</td></tr>
<tr><td><code id="print.dbOptim_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the summary details of the fit
</p>


<h3>Value</h3>

<p>A dataframe with [theta,value] and a vector of fitted alpha
parameters
</p>


<h3>Author(s)</h3>

<p>James Curran and Torben Tvedebrink
</p>


<h3>See Also</h3>

<p>optim.relatedness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  ## Simulate some allele frequencies:
  freqs &lt;-  replicate(10, { g = rgamma(n=10,scale=4,shape=3); g/sum(g)},
              simplify=FALSE)
  ## Load the sample database:
  data(dbExample)
  obs &lt;- dbCompare(dbExample,trace=FALSE)$m
  C3 &lt;- optim.relatedness(obs,theta0=0.0,theta1=0.03,probs=freqs,
          objFunction='C3',max.bisect=30,trace=TRUE)
  print(C3)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='simAlleleFreqs'>Simulate Allele Frequencies</h2><span id='topic+simAlleleFreqs'></span>

<h3>Description</h3>

<p>Simulate some allele frequencies using Dirichlet Random variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simAlleleFreqs(
  nLoci = 10,
  allelesPerLocus = rep(10, nLoci),
  shape = rep(3, nLoci)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simAlleleFreqs_+3A_nloci">nLoci</code></td>
<td>
<p><code class="reqn">L</code> the number of loci in the multiplex</p>
</td></tr>
<tr><td><code id="simAlleleFreqs_+3A_allelesperlocus">allelesPerLocus</code></td>
<td>
<p>the number of alleles per locus</p>
</td></tr>
<tr><td><code id="simAlleleFreqs_+3A_shape">shape</code></td>
<td>
<p>the shape parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>locus.</code><code class="reqn">l</code> where <code class="reqn">l=1,\ldots,L</code>, each 
of which are vectors of length <code>allelesPerLocus[l]</code>, consisting of allele 
frequencies for that locus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
simAlleleFreqs()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
