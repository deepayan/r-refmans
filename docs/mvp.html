<!DOCTYPE html><html><head><title>Help for package mvp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allvars'><p>All variables in a multivariate polynomial</p></a></li>
<li><a href='#as.function.mvp'><p>Functional form for multivariate polynomials</p></a></li>
<li><a href='#coeffs'><p>Functionality for <code>coeffs</code> objects</p></a></li>
<li><a href='#constant'><p>The constant term</p></a></li>
<li><a href='#deriv'><p>Differentiation of <code>mvp</code> objects</p></a></li>
<li><a href='#horner'><p>Horner's method</p></a></li>
<li><a href='#invert'><p>Replace symbols with their reciprocals</p></a></li>
<li><a href='#kahle'><p>A sparse multivariate polynomial</p></a></li>
<li><a href='#knight'><p>Chess knight</p></a></li>
<li><a href='#lose'><p>Drop empty variables</p></a></li>
<li><a href='#lowlevel'><p>Low level functions</p></a></li>
<li><a href='#mpoly'><p>Conversion to and from mpoly form</p></a></li>
<li><a href='#mvp'><p>Multivariate polynomials, mvp objects</p></a></li>
<li><a href='#mvp-package'>
<p>Fast Symbolic Multivariate Polynomials</p></a></li>
<li><a href='#ooom'><p>One over one minus a multivariate polynomial</p></a></li>
<li><a href='#Ops.mvp'><p>Arithmetic Ops Group Methods for <code>mvp</code> objects</p></a></li>
<li><a href='#print'>
<p>Print methods for <code>mvp</code> objects</p></a></li>
<li><a href='#rmvp'><p>Random multivariate polynomials</p></a></li>
<li><a href='#series'><p>Decomposition of multivariate polynomials by powers</p></a></li>
<li><a href='#special'><p>Various functions to create simple multivariate polynomials</p></a></li>
<li><a href='#subs'><p>Substitution</p></a></li>
<li><a href='#summary'><p>Summary methods for mvp objects</p></a></li>
<li><a href='#zero'><p>The zero polynomial</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Symbolic Multivariate Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-14</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods,magrittr, mpoly (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown, microbenchmark,testthat,spray</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast manipulation of symbolic multivariate polynomials
  using the 'Map' class of the Standard Template Library.  The package
  uses print and coercion methods from the 'mpoly' package (Kahle
  2013, "Multivariate polynomials in R", The R Journal, 5(1):162), but
  offers speed improvements.  It is comparable in speed to the 'spray'
  package for sparse arrays, but retains the symbolic benefits of
  'mpoly'.  To cite the package in publications, use Hankin 2022
  &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.15991">doi:10.48550/ARXIV.2210.15991</a>&gt;.  Uses 'disordR' discipline.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0-7), partitions, magic, digest, disordR (&ge; 0.9),
numbers</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/mvp">https://github.com/RobinHankin/mvp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/mvp/issues">https://github.com/RobinHankin/mvp/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-19 19:36:59 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-19 22:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='allvars'>All variables in a multivariate polynomial</h2><span id='topic+allvars'></span>

<h3>Description</h3>

<p>Returns a character vector containing all the variables present in a
<code>mvp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allvars(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allvars_+3A_x">x</code></td>
<td>
<p>object of class <code>mvp</code></p>
</td></tr></table>


<h3>Note</h3>

<p>The character vector returned is not in any particular order</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- rmvp(5)
p
allvars(p)
</code></pre>

<hr>
<h2 id='as.function.mvp'>Functional form for multivariate polynomials</h2><span id='topic+as.function.mvp'></span>

<h3>Description</h3>

<p>Coerces a multivariate polynomial into a function</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.mvp_+3A_x">x</code></td>
<td>
<p>Multivariate polynomial</p>
</td></tr>
<tr><td><code id="as.function.mvp_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- as.mvp("1+a^2 + a*b^2 + c")
p
f &lt;- as.function(p)
f

f(a=1)
f(a=1,b=2)
f(a=1,b=2,c=3)             # coerces to a scalar
f(a=1,b=2,c=3,lose=FALSE)  # formal mvp object
</code></pre>

<hr>
<h2 id='coeffs'>Functionality for <code>coeffs</code> objects</h2><span id='topic+Ops.coeffs'></span><span id='topic+coeffs'></span><span id='topic+coeffs.mvp'></span><span id='topic+Ops.mvp_coeffs'></span><span id='topic+hash'></span><span id='topic+as_coeffs'></span><span id='topic+is.coeffs'></span><span id='topic+print.coeffs'></span><span id='topic+print.mvp_coeffs'></span><span id='topic+accessors'></span><span id='topic+vars'></span><span id='topic+powers'></span><span id='topic+coeffs'></span><span id='topic+coeffs+3C-'></span><span id='topic+coeffs+3C-.mvp'></span><span id='topic+coefficients'></span><span id='topic+consistent'></span><span id='topic++25~+25'></span>

<h3>Description</h3>

<p>Function <code>coeffs()</code> allows arithmetic operators to be used for the
coefficients of multivariate polynomials, bearing in mind that the
order of coefficients is not determined.  It uses the <code>disord</code>
class of the <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffs(x)
vars(x)
powers(x)
coeffs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeffs_+3A_x">x</code></td>
<td>
<p>Object of class <code>disord</code></p>
</td></tr>
<tr><td><code id="coeffs_+3A_value">value</code></td>
<td>
<p>Object of class <code>disord</code>, or length-1 numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(much of the discussion below appears in the vignette of the
<a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> package). 
</p>
<p>Accessing elements of an <code>mvp</code> object is problematic because the
order of the terms of an <code>mvp</code> object is not well-defined.  This
is because the <code>map</code> class of the <code>STL</code> does not specify an
order for the key-value pairs (and indeed the actual order in which
they are stored may be implementation dependent).  The situation is
similar to the <code>hyper2</code> package which uses the <code>STL</code> in a
similar way.
</p>
<p>A <code>coeffs</code> object is a vector of coefficients of a <code>mvp</code>
object.  But it is not a conventional vector; in a conventional
vector, we can identify the first element unambiguously, and the
second, and so on.  An <code>mvp</code> is a map from terms to coefficients,
and a map has no intrinsic ordering: the maps
</p>
<pre>{x -&gt; 1, y -&gt; 3, xy^3 -&gt; 4}</pre>
<p>and </p>
<pre>{xy^3 -&gt; 4, x -&gt; 1, y -&gt; 3}</pre>
<p>are the same map and correspond to the same multinomial (symbolically,
<code class="reqn">x+3y+4xy^3=4xy^3+x+3y</code>).  Thus the coefficients of the
multinomial might be <code>c(1,3,4)</code> or <code>c(4,1,3)</code>, or indeed any
ordering.  But note that any particular ordering imposes an ordering
on the terms.  If we choose <code>c(1,3,4)</code> then the terms are
<code>x,y,xy^3</code>, and if we choose <code>c(4,1,3)</code> the terms are
<code>xy^3,x,y</code>.
</p>
<p>In the package, <code>coeffs()</code> returns an object of class
<code>disord</code>.  This class of object has a slot for the coefficients
in the form of a numeric R vector, but also another slot which uses
hash codes to prevent users from misusing the ordering of the numeric
vector.
</p>
<p>For example, a multinomial <code>x+2y+3z</code> might have coefficients
<code>c(1,2,3)</code> or <code>c(3,1,2)</code>.  Package idiom to extract the
coefficients of a multivariate polynomial <code>a</code> is
<code>coeffs(a)</code>; but this cannot return a standard numeric vector
because a numeric vector has elements in a particular order, and the
coefficients of a multivariate polynomial are stored in an
implementation-specific (and thus unknown) order.
</p>
<p>Suppose we have two multivariate polynomials, <code>a</code> as defined as
above with <code>a=x+2y+3z</code> and <code>b=x+3y+4z</code>.  Even though
<code>a+b</code> is well-defined algebraically, and <code>coeffs(a+b)</code> will
return a well-defined <code>mvp_coeffs</code> object, idiom such as
<code>coeffs(a) + coeffs(b)</code> is not defined because there is no
guarantee that the coefficients of the two multivariate polynomials
are stored in the same order.  We might have
<code>c(1,2,3)+c(1,3,4)=c(2,5,7)</code> or
<code>c(1,2,3)+c(1,4,3)=c(2,6,6)</code>, with neither being more
&ldquo;correct&rdquo; than the other.  In the package, <code>coeffs(a) +
  coeffs(b)</code> will return an error.  In the same way <code>coeffs(a) +
  1:3</code> is not defined and will return an error.  Further, idiom such as
<code>coeffs(a) &lt;- 1:3</code> and <code>coeffs(a) &lt;- coeffs(b)</code> are not
defined and will return an error.  However, note that <code>coeffs(a)
  + coeffs(a)</code> and <code>coeffs(a)+coeffs(a)^2</code> are fine, these
returning a <code>mvp_coeffs</code> object specific to <code>a</code>.
</p>
<p>Idiom such as <code>coeffs(a) &lt;- coeffs(a)^2</code> is fine too, for one
does not need to know the order of the coefficients on either side, so
long as the order is the same on both sides.  That would translate
into idiomatic English: &ldquo;the coefficient of each term of
<code>a</code> becomes its square&rdquo;; note that this operation is insensitive
to the order of coefficients.  The whole shebang is intended to make
idiom such as <code>coeffs(a) &lt;- coeffs(a)%%2</code> possible (so we can
manipulate polynomials over finite rings, here <code class="reqn">Z/2Z</code>).
</p>
<p>The replacement methods are defined so that an expression like
<code>coeffs(a)[coeffs(a) &gt; 5] &lt;- 5</code> works as expected; the English
idiom would be &ldquo;Replace any coefficient greater than 5 with 5&rdquo;.
</p>
<p>To fix ideas, consider <code>a &lt;- rmvp(8)</code>.  Extraction presents
issues; consider <code>coeffs(a)&lt;5</code>.  This object has Boolean elements
but has the same ordering ambiguity as <code>coeffs(a)</code>.  One might
expect that we could use this to extract elements of <code>coeffs(a)</code>,
specifically elements less than 5.  However,
<code>coeffs(a)[coeffs(a)&lt;5]</code> in isolation is meaningless: what can be
done with such an object?  However, it makes sense on the left hand
side of an assignment, as long as the right hand side is a length-one
vector.  Idiom such as
</p>

<ul>
<li><pre>coeffs(a)[coeffs(a)&lt;5] &lt;- 4+coeffs(a)[coeffs(a)&lt;5]</pre>
</li>
<li><pre>coeffs(a) &lt;- pmax(a,3)</pre>
</li></ul>

<p>is algebraically meaningful (&ldquo;Add 4 to any element less than
5&rdquo;; &ldquo;coefficients become the pairwise maximum of themselves and
3&rdquo;).  The <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> package uses <code>pmaxdis()</code> rather than
<code>pmax()</code> for technical reasons.
</p>
<p>So the output of <code>coeffs(x)</code> is defined only up to an unknown
rearrangement.  The same considerations apply to the output of
<code>vars()</code>, which returns a list of character vectors in an
undefined order, and the output of <code>powers()</code>, which returns a
numeric list whose elements are in an undefined order.  However, even
though the order of these three objects is undefined individually,
their ordering is jointly consistent in the sense that the first
element of <code>coeffs(x)</code> corresponds to the first element of
<code>vars(x)</code> and the first element of <code>powers(x)</code>.  The
identity of this element is not defined&mdash;but whatever it is, the
first element of all three accessor methods refers to it.
</p>
<p>Note also that a single term (something like <code>4a^3*b*c^6</code>) has
the same issue: the variables are not stored in a well-defined order.
This does not matter because the algebraic value of the term does not
depend on the order in which the variables appear and this term would
be equivalent to <code>4b*c^6*a^3</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- 5+rmvp(6))
(y &lt;- 2+rmvp(6))

coeffs(x)^2
coeffs(y) &lt;- coeffs(y)%%3  # fine, all coeffs of y now modulo 3
y

coeffs(y) &lt;- 4               
y

## Not run: 
coeffs(x) &lt;- coeffs(y)          # not defined, will give an error
coeffs(x) &lt;- seq_len(nterms(x)) # not defined, will give an error

## End(Not run)

</code></pre>

<hr>
<h2 id='constant'>The constant term</h2><span id='topic+constant'></span><span id='topic+constant'></span><span id='topic+is.constant'></span><span id='topic+constant+3C-'></span><span id='topic+constant.mvp'></span><span id='topic+constant+3C-.mvp'></span><span id='topic+constant.numeric'></span>

<h3>Description</h3>

<p>Get and set the constant term of an <code>mvp</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
constant(x)
## S3 replacement method for class 'mvp'
constant(x) &lt;- value
## S3 method for class 'numeric'
constant(x)
is.constant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvp</code></p>
</td></tr>
<tr><td><code id="constant_+3A_value">value</code></td>
<td>
<p>Scalar value for the constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constant term in a polynomial is the coefficient of the empty term.
In an <code>mvp</code> object, the map <code>{} -&gt; c</code>, implies that <code>c</code> is
the constant.
</p>
<p>If <code>x</code> is an <code>mvp</code> object, <code>constant(x)</code> returns the value of
the constant in the multivariate polynomial; if <code>x</code> is numeric,
it returns a constant multivariate polynomial with value <code>x</code>.
</p>
<p>Function <code>is.constant()</code> returns <code>TRUE</code> if its argument has
no variables and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rmvp(5)+4
a
constant(a)
constant(a) &lt;- 33
a

constant(0)  # the zero mvp
</code></pre>

<hr>
<h2 id='deriv'>Differentiation of <code>mvp</code> objects</h2><span id='topic+deriv'></span><span id='topic+aderiv'></span><span id='topic+deriv.mvp'></span><span id='topic+deriv_mvp'></span><span id='topic+aderiv.mvp'></span><span id='topic+aderiv_mvp'></span>

<h3>Description</h3>

<p>Differentiation of <code>mvp</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
deriv(expr, v, ...)
## S3 method for class 'mvp'
aderiv(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_+3A_expr">expr</code></td>
<td>
<p>Object of class <code>mvp</code></p>
</td></tr>
<tr><td><code id="deriv_+3A_v">v</code></td>
<td>
<p>Character vector.  Elements denote variables to differentiate with respect to</p>
</td></tr>
<tr><td><code id="deriv_+3A_...">...</code></td>
<td>
<p>Further arguments, ignored in <code>deriv()</code> but specifies
the differentials in <code>aderiv()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>deriv(S,v)</code> returns <code class="reqn">\frac{\partial^r S}{\partial
  v_1\partial v_2\ldots\partial v_r}</code>.
</p>
<p>Function <code>aderiv()</code> uses the ellipsis construction with the names
of the argument being the variable to be differentiated with respect
to.  Thus <code>aderiv(S,x=1,y=2)</code> returns <code class="reqn">\frac{\partial^3
  S}{\partial x\partial y^2}</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+taylor">taylor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- rmvp(10,9,9,letters[1:4])
p
deriv(p,letters[1:3])
deriv(p,rev(letters[1:3]))  # should be the same

aderiv(p,a=1,b=2,c=1)

## verify the chain rule:
x &lt;- rmvp(7,symbols=6)
v &lt;- allvars(x)[1]
s &lt;- as.mvp("1  +  y  -  y^2 zz  +  y^3 z^2")
LHS &lt;- subsmvp(deriv(x,v)*deriv(s,"y"),v,s)   # dx/ds*ds/dy
RHS &lt;- deriv(subsmvp(x,v,s),"y")              # dx/dy

LHS - RHS # should be zero

</code></pre>

<hr>
<h2 id='horner'>Horner's method</h2><span id='topic+horner'></span>

<h3>Description</h3>

<p>Horner's method for multivariate polynomials</p>


<h3>Usage</h3>

<pre><code class='language-R'>horner(P,v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horner_+3A_p">P</code></td>
<td>
<p>Multivariate polynomial</p>
</td></tr>
<tr><td><code id="horner_+3A_v">v</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a polynomial
</p>
<p style="text-align: center;"><code class="reqn">p(x) = a_0 +a_1+a_2x^2+\cdots + a_nx^n</code>
</p>

<p>it is possible to express <code class="reqn">p(x)</code> in the algebraically equivalent
form
</p>
<p style="text-align: center;"><code class="reqn">p(x) = a_0 + x\left(a_1+x\left(a_2+\cdots + x\left(a_{n-1} +xa_n
\right)\cdots\right)\right)</code>
</p>

<p>which is much more efficient for evaluation, as it requires only <code class="reqn">n</code>
multiplications and <code class="reqn">n</code> additions, and this is optimal.  But this is
not implemented here because it's efficient.  It is implemented because
it works if <code class="reqn">x</code> is itself a (multivariate) polynomial, and that is
the second coolest thing ever.  The coolest thing ever is the
<code>Reduce()</code> function.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ooom">ooom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>horner("x",1:5)
horner("x+y",1:3)

w &lt;- as.mvp("x+y^2")
stopifnot(1 + 2*w + 3*w^2 == horner(w,1:3))  # note off-by-one issue

"x+y+x*y" %&gt;% horner(1:3) %&gt;% horner(1:2)
</code></pre>

<hr>
<h2 id='invert'>Replace symbols with their reciprocals</h2><span id='topic+invert'></span>

<h3>Description</h3>

<p>Given an <code>mvp</code> object, replace one or more symbols with their reciprocals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert(p, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_+3A_p">p</code></td>
<td>
<p>Object (coerced to) <code>mvp</code> form</p>
</td></tr>
<tr><td><code id="invert_+3A_v">v</code></td>
<td>
<p>Character vector of symbols to be replaced with their
reciprocal; missing interpreted as replace all symbols</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+subs">subs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>invert("x")

(P &lt;- as.mvp("1+a+6*a^2 -7*a*b"))
invert(P,"a")

</code></pre>

<hr>
<h2 id='kahle'>A sparse multivariate polynomial</h2><span id='topic+kahle'></span>

<h3>Description</h3>

<p>A sparse multivariate polynomial inspired by Kahle (2013)</p>


<h3>Usage</h3>

<pre><code class='language-R'>kahle(n = 26, r = 1, p = 1, coeffs = 1, symbols = letters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kahle_+3A_n">n</code></td>
<td>
<p>Number of different symbols to use</p>
</td></tr>
<tr><td><code id="kahle_+3A_r">r</code></td>
<td>
<p>Number of symbols in a single term</p>
</td></tr>
<tr><td><code id="kahle_+3A_p">p</code></td>
<td>
<p>Power of each symbol in each terms</p>
</td></tr>
<tr><td><code id="kahle_+3A_coeffs">coeffs</code></td>
<td>
<p>Coefficients of the terms</p>
</td></tr>
<tr><td><code id="kahle_+3A_symbols">symbols</code></td>
<td>
<p>Alphabet of symbols</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>David Kahle 2013.  &ldquo;<a href="https://CRAN.R-project.org/package=mpoly"><span class="pkg">mpoly</span></a>: multivariate polynomials in R&rdquo;.
<em>R Journal</em>, volume 5/1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+special">special</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>kahle()  # a+b+...+z
kahle(r=2,p=1:2)  # Kahle's original example

## example where mvp runs faster than spray (mvp does not need a 200x200 matrix):
k &lt;- kahle(200,r=3,p=1:3,symbols=paste("x",sprintf("%02d",1:200),sep=""))
system.time(ignore &lt;- k^2)
#system.time(ignore &lt;- mvp_to_spray(k)^2)   # needs spray package loaded
</code></pre>

<hr>
<h2 id='knight'>Chess knight</h2><span id='topic+knight_mvp'></span><span id='topic+knight'></span>

<h3>Description</h3>

<p>Generating function for a chess knight on an infinite
<code class="reqn">d</code>-dimensional chessboard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knight(d, can_stay_still = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knight_+3A_d">d</code></td>
<td>
<p>Dimension of the board</p>
</td></tr>
<tr><td><code id="knight_+3A_can_stay_still">can_stay_still</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning that
the knight is obliged to move and <code>FALSE</code> meaning that it has
the option of remaining on its square</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function is a slight modification of <code>spray::knight()</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
knight(2)      # regular chess knight on a regular chess board
knight(2,TRUE) # regular chess knight that can stay still

# Q: how many ways are there for a 4D knight to return to its starting
# square after four moves?

# A:
constant(knight(4)^4)

# Q ...and how many ways in four moves or fewer?

# A1:
constant(knight(4,TRUE)^4)

# A2:
constant((1+knight(4))^4)

</code></pre>

<hr>
<h2 id='lose'>Drop empty variables</h2><span id='topic+lose'></span><span id='topic+lose.mvp'></span><span id='topic+drop'></span>

<h3>Description</h3>

<p>Convert an <code>mvp</code> object which is a pure constant into a scalar
whose value is the coefficient of the empty term.
</p>
<p>A few functions in the package (currently <code>subs()</code>, <code>subsy()</code>)
take a <code>lose</code> argument that behaves much like the <code>drop</code>
argument in base extraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
lose(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lose_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvp</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+subs">subs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m1 &lt;- as.mvp("1+bish +bash^2 + bosh^3"))
(m2 &lt;- as.mvp("bish +bash^2 + bosh^3"))

m1-m2         # an mvp object
lose(m1-m2)   # numeric



</code></pre>

<hr>
<h2 id='lowlevel'>Low level functions</h2><span id='topic+lowlevel'></span><span id='topic+mvp_substitute_mvp'></span><span id='topic+mvp_substitute'></span><span id='topic+mvp_vectorised_substitute'></span><span id='topic+mvp_vectorized_substitute'></span><span id='topic+mvp_prod'></span><span id='topic+mvp_add'></span><span id='topic+mvp_power'></span><span id='topic+mvp_deriv'></span><span id='topic+simplify'></span>

<h3>Description</h3>

<p>Various low-level functions that call the C routines</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvp_substitute(allnames,allpowers,coefficients,v,values)
mvp_substitute_mvp(allnames1, allpowers1, coefficients1, allnames2, allpowers2, 
    coefficients2, v)
mvp_vectorised_substitute(allnames, allpowers, coefficients, M, nrows, ncols, v)
mvp_prod(allnames1,allpowers1,coefficients1,allnames2,allpowers2,coefficients2)
mvp_add(allnames1, allpowers1, coefficients1, allnames2, allpowers2,coefficients2)
simplify(allnames,allpowers,coefficients)
mvp_deriv(allnames, allpowers, coefficients, v)
mvp_power(allnames, allpowers, coefficients, n) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowlevel_+3A_allnames">allnames</code>, <code id="lowlevel_+3A_allpowers">allpowers</code>, <code id="lowlevel_+3A_coefficients">coefficients</code>, <code id="lowlevel_+3A_allnames1">allnames1</code>, <code id="lowlevel_+3A_allpowers1">allpowers1</code>, <code id="lowlevel_+3A_coefficients1">coefficients1</code>, <code id="lowlevel_+3A_allnames2">allnames2</code>, <code id="lowlevel_+3A_allpowers2">allpowers2</code>, <code id="lowlevel_+3A_coefficients2">coefficients2</code>, <code id="lowlevel_+3A_v">v</code>, <code id="lowlevel_+3A_values">values</code>, <code id="lowlevel_+3A_n">n</code>, <code id="lowlevel_+3A_m">M</code>, <code id="lowlevel_+3A_nrows">nrows</code>, <code id="lowlevel_+3A_ncols">ncols</code></td>
<td>
<p>Variables
sent to the C routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions call the functions defined in <code>RcppExports.R</code></p>


<h3>Note</h3>

<p>These functions are not intended for the end-user.  Use the
syntactic sugar (as in <code>a+b</code> or <code>a*b</code> or <code>a^n</code>), or
functions like <code>mvp_plus_mvp()</code>, which are more user-friendly.</p>


<h3>Author(s)</h3>

<p>Robin K. S.  Hankin</p>

<hr>
<h2 id='mpoly'>Conversion to and from mpoly form</h2><span id='topic+mpoly'></span><span id='topic+mpoly_to_mvp'></span><span id='topic+mvp_to_mpoly'></span><span id='topic+as.mpoly.mvp'></span>

<h3>Description</h3>

<p>The <a href="https://CRAN.R-project.org/package=mpoly"><span class="pkg">mpoly</span></a> package by David Kahle provides similar
functionality to this package, and the functions documented here
convert between mpoly and <code>mvp</code> objects.  The mvp package uses
<code>mpoly::mp()</code> to convert character strings to <code>mvp</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpoly_to_mvp(m)
## S3 method for class 'mvp'
as.mpoly(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpoly_+3A_m">m</code></td>
<td>
<p>object of class mvp</p>
</td></tr>
<tr><td><code id="mpoly_+3A_x">x</code></td>
<td>
<p>object of class mpoly</p>
</td></tr>
<tr><td><code id="mpoly_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rmvp(5)

x == mpoly_to_mvp(mpoly::as.mpoly(x))        # should be TRUE
</code></pre>

<hr>
<h2 id='mvp'>Multivariate polynomials, mvp objects</h2><span id='topic+mvp'></span><span id='topic+is.mvp'></span><span id='topic+as.mvp'></span><span id='topic+as.mvp.character'></span><span id='topic+as.mvp.list'></span><span id='topic+as.mvp.mvp'></span><span id='topic+as.mvp.numeric'></span><span id='topic+as.mvp.mpoly'></span><span id='topic+is_ok_mvp'></span>

<h3>Description</h3>

<p>Create, test for, an coerce to, <code>mvp</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvp(vars, powers, coeffs)
is_ok_mvp(vars,powers,coeffs)
is.mvp(x)
as.mvp(x)
## S3 method for class 'character'
as.mvp(x)
## S3 method for class 'list'
as.mvp(x)
## S3 method for class 'mpoly'
as.mvp(x)
## S3 method for class 'mvp'
as.mvp(x)
## S3 method for class 'numeric'
as.mvp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvp_+3A_vars">vars</code></td>
<td>
<p>List of variables comprising each term of an <code>mvp</code> object</p>
</td></tr>
<tr><td><code id="mvp_+3A_powers">powers</code></td>
<td>
<p>List of powers corresponding to the variables of the
<code>vars</code> argument</p>
</td></tr>
<tr><td><code id="mvp_+3A_coeffs">coeffs</code></td>
<td>
<p>Numeric vector corresponding to the coefficients to each
element of the <code>var</code> and <code>powers</code> lists</p>
</td></tr>
<tr><td><code id="mvp_+3A_x">x</code></td>
<td>
<p>Object to be coerced to or tested for being class <code>mvp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>mvp()</code> is the formal creation mechanism for <code>mvp</code>
objects.  However, it is not very user-friendly; it is better to use
<code>as.mvp()</code> in day-to-day use.
</p>
<p>Function <code>is_ok_mvp()</code> checks for consistency of its arguments.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mvp(list("x", c("x","y"), "a", c("y","x")), list(1,1:2,3,c(-1,4)), 1:4)

## Note how the terms appear in an arbitrary order, as do
## the symbols within a term.

kahle  &lt;- mvp(
    vars   = split(cbind(letters,letters[c(26,1:25)]),rep(seq_len(26),each=2)),
    powers = rep(list(1:2),26),
    coeffs = 1:26
)
kahle
## again note arbitrary order of terms and symbols within a term

## Standard arithmetic rules apply:

a &lt;- as.mvp("1 + 4*x*y + 7*z")
b &lt;- as.mvp("-7*z + 3*x^34 - 2*z*x")

a+b
a*b^2

(a+b)*(a-b) == a^2-b^2 # should be TRUE


</code></pre>

<hr>
<h2 id='mvp-package'>
Fast Symbolic Multivariate Polynomials
</h2><span id='topic+mvp-package'></span>

<h3>Description</h3>

<p>Fast manipulation of symbolic multivariate polynomials
  using the 'Map' class of the Standard Template Library.  The package
  uses print and coercion methods from the 'mpoly' package (Kahle
  2013, &quot;Multivariate polynomials in R&quot;, The R Journal, 5(1):162), but
  offers speed improvements.  It is comparable in speed to the 'spray'
  package for sparse arrays, but retains the symbolic benefits of
  'mpoly'.  To cite the package in publications, use Hankin 2022
  &lt;doi:10.48550/ARXIV.2210.15991&gt;.  Uses 'disordR' discipline.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mvp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Fast Symbolic Multivariate Polynomials</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-14</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods,magrittr, mpoly (&gt;= 1.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,rmarkdown, microbenchmark,testthat,spray</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Fast manipulation of symbolic multivariate polynomials
  using the 'Map' class of the Standard Template Library.  The package
  uses print and coercion methods from the 'mpoly' package (Kahle
  2013, "Multivariate polynomials in R", The R Journal, 5(1):162), but
  offers speed improvements.  It is comparable in speed to the 'spray'
  package for sparse arrays, but retains the symbolic benefits of
  'mpoly'.  To cite the package in publications, use Hankin 2022
  &lt;doi:10.48550/ARXIV.2210.15991&gt;.  Uses 'disordR' discipline.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0-7),
partitions,
magic,
digest,
disordR (&gt;= 0.9),
numbers</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/mvp</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/mvp/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Ops.mvp                 Arithmetic Ops Group Methods for 'mvp' objects
allvars                 All variables in a multivariate polynomial
as.function.mvp         Functional form for multivariate polynomials
coeffs                  Functionality for 'coeffs' objects
constant                The constant term
deriv                   Differentiation of 'mvp' objects
horner                  Horner's method
invert                  Replace symbols with their reciprocals
kahle                   A sparse multivariate polynomial
knight                  Chess knight
lose                    Drop empty variables
lowlevel                Low level functions
mpoly                   Conversion to and from mpoly form
mvp                     Multivariate polynomials, mvp objects
mvp-package             Fast Symbolic Multivariate Polynomials
ooom                    One over one minus a multivariate polynomial
print.mvp               Print methods for 'mvp' objects
rmvp                    Random multivariate polynomials
series                  Decomposition of multivariate polynomials by
                        powers
special                 Various functions to create simple multivariate
                        polynomials
subs                    Substitution
summary                 Summary methods for mvp objects
zero                    The zero polynomial
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(p &lt;- as.mvp("1+x+x*y+x^5"))

p + as.mvp("a+b^6")

p^3

subs(p^4,x="a+b^2")
aderiv(p^2,x=4)
horner(p,1:3)
</code></pre>

<hr>
<h2 id='ooom'>One over one minus a multivariate polynomial</h2><span id='topic+ooom'></span>

<h3>Description</h3>

<p>Uses Taylor's theorem to give one over one minus a multipol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ooom(P,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ooom_+3A_n">n</code></td>
<td>
<p>Order of expansion</p>
</td></tr>
<tr><td><code id="ooom_+3A_p">P</code></td>
<td>
<p>Multivariate polynomial</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+horner">horner</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ooom("x",5)
ooom("x",5) * as.mvp("1-x")  # 1 + O(x^6)


ooom("x+y",4)

"x+y" %&gt;% ooom(5) %&gt;% `-`(1) %&gt;% ooom(3)

</code></pre>

<hr>
<h2 id='Ops.mvp'>Arithmetic Ops Group Methods for <code>mvp</code> objects</h2><span id='topic+Ops.mvp'></span><span id='topic+Ops'></span><span id='topic+mvp_negative'></span><span id='topic+mvp_times_mvp'></span><span id='topic+mvp_times_scalar'></span><span id='topic+mvp_plus_mvp'></span><span id='topic+mvp_plus_numeric'></span><span id='topic+mvp_plus_scalar'></span><span id='topic+mvp_power_scalar'></span><span id='topic+mvp_eq_mvp'></span><span id='topic+mvp_modulo'></span>

<h3>Description</h3>

<p>Allows arithmetic operators to be used for
multivariate polynomials  such as addition, multiplication,
integer powers, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
Ops(e1, e2)
mvp_negative(S)
mvp_times_mvp(S1,S2)
mvp_times_scalar(S,x)
mvp_plus_mvp(S1,S2)
mvp_plus_numeric(S,x)
mvp_eq_mvp(S1,S2)
mvp_modulo(S1,S2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.mvp_+3A_e1">e1</code>, <code id="Ops.mvp_+3A_e2">e2</code>, <code id="Ops.mvp_+3A_s">S</code>, <code id="Ops.mvp_+3A_s1">S1</code>, <code id="Ops.mvp_+3A_s2">S2</code></td>
<td>
<p>Objects of class <code>mvp</code></p>
</td></tr>
<tr><td><code id="Ops.mvp_+3A_x">x</code></td>
<td>
<p>Scalar, length one numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.mvp()</code> passes unary and binary arithmetic
operators &ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;, &ldquo;<code>*</code>&rdquo; and
&ldquo;<code>^</code>&rdquo; to the appropriate specialist function.
</p>
<p>The most interesting operator is &ldquo;<code>*</code>&rdquo;, which is passed to
<code>mvp_times_mvp()</code>.  I guess &ldquo;<code>+</code>&rdquo; is quite
interesting too.
</p>


<h3>Value</h3>

<p>The high-level functions documented here return an object of
<code>mvp</code>, the low-level functions documented at <code>lowlevel.Rd</code>
return lists.   But don't use the low-level functions.
</p>


<h3>Note</h3>

<p>Function <code>mvp_modulo()</code> is distinctly sub-optimal and
<code>inst/mvp_modulo.Rmd</code> details ideas for better implementation.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+lowlevel">lowlevel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(p1 &lt;- rmvp(3))
(p2 &lt;- rmvp(3))

p1*p2

p1+p2

p1^3


p1*(p1+p2) == p1^2+p1*p2  # should be TRUE

</code></pre>

<hr>
<h2 id='print'>
Print methods for <code>mvp</code> objects
</h2><span id='topic+print.mvp'></span><span id='topic+print_mvp'></span>

<h3>Description</h3>

<p>Print methods for <code>mvp</code> objects: to print, an <code>mvp</code> object is coerced to
<code>mpoly</code> form and the <code>mpoly</code> print method used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvp</code>, coerced to <code>mpoly</code> form</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns its argument invisibly</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rmvp(4)
a
print(a)
print(a,stars=TRUE)
print(a,varorder=rev(letters))
</code></pre>

<hr>
<h2 id='rmvp'>Random multivariate polynomials</h2><span id='topic+rmvp'></span>

<h3>Description</h3>

<p>Random multivariate polynomials, intended as quick
&ldquo;get you going&rdquo; examples of <code>mvp</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvp(n=7, size = 6, pow = 6, symbols = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvp_+3A_n">n</code></td>
<td>
<p>Number of terms to generate</p>
</td></tr>
<tr><td><code id="rmvp_+3A_size">size</code></td>
<td>
<p>Maximum number of symbols in each term</p>
</td></tr>
<tr><td><code id="rmvp_+3A_pow">pow</code></td>
<td>
<p>Maximum power of each symbol</p>
</td></tr>
<tr><td><code id="rmvp_+3A_symbols">symbols</code></td>
<td>
<p>Symbols to use; if numeric, interpret as the first
<code>symbols</code> letters of the alphabet</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What you see is what you get, basically.  Note that a term such as
<code>a^2*b*a^3</code> will be simplified to <code>a^5*b</code>, so powers in the
result may be larger than argument <code>pow</code>. 
</p>


<h3>Value</h3>

<p>Returns a multivariate polynomial, an object of class <code>mvp</code></p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmvp()
rmvp(5,symbols=state.abb)
</code></pre>

<hr>
<h2 id='series'>Decomposition of multivariate polynomials by powers</h2><span id='topic+series'></span><span id='topic+taylor'></span><span id='topic+trunc'></span><span id='topic+trunc1'></span><span id='topic+truncall'></span><span id='topic+print.series'></span><span id='topic+mvp_taylor_allvars'></span><span id='topic+mvp_taylor_onevar'></span><span id='topic+mvp_taylor_onepower_onevar'></span><span id='topic+mvp_to_series'></span><span id='topic+onevarpow'></span>

<h3>Description</h3>

<p>Power series of multivariate polynomials, in
various forms</p>


<h3>Usage</h3>

<pre><code class='language-R'>trunc(S,n)
truncall(S,n)
trunc1(S,...)
series(S,v,showsymb=TRUE)
## S3 method for class 'series'
print(x,...)
onevarpow(S,...)
taylor(S,vx,va,debug=FALSE)
mvp_taylor_onevar(allnames,allpowers,coefficients, v, n)
mvp_taylor_allvars(allnames,allpowers,coefficients, n)
mvp_taylor_onepower_onevar(allnames, allpowers, coefficients, v, n)
mvp_to_series(allnames, allpowers, coefficients, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="series_+3A_s">S</code></td>
<td>
<p>Object of class <code>mvp</code></p>
</td></tr>
<tr><td><code id="series_+3A_n">n</code></td>
<td>
<p>Non-negative integer specifying highest order to be retained</p>
</td></tr>
<tr><td><code id="series_+3A_v">v</code></td>
<td>
<p>Variable to take Taylor series with respect to.   If missing,
total power of each term is used (except for <code>series()</code> where
it is mandatory)</p>
</td></tr>
<tr><td><code id="series_+3A_x">x</code>, <code id="series_+3A_...">...</code></td>
<td>
<p>Object of class <code>series</code> and further arguments,
passed to the print method; in <code>trunc1()</code> a list of variables
to truncate</p>
</td></tr>
<tr><td><code id="series_+3A_showsymb">showsymb</code></td>
<td>
<p>In function <code>series()</code>, Boolean, with default
<code>TRUE</code> meaning to substitute variables like <code>x_m_foo</code> with
<code>(x-foo)</code> for readability reasons; see the vignette for a
discussion</p>
</td></tr>
<tr><td><code id="series_+3A_vx">vx</code>, <code id="series_+3A_va">va</code>, <code id="series_+3A_debug">debug</code></td>
<td>
<p>In function <code>taylor()</code>, names of variables to
take series with respect to; and a Boolean with default <code>FALSE</code>
meaning to return the mvp and <code>TRUE</code> meaning to return
the string that is passed to <code>eval()</code></p>
</td></tr>
<tr><td><code id="series_+3A_allnames">allnames</code>, <code id="series_+3A_allpowers">allpowers</code>, <code id="series_+3A_coefficients">coefficients</code></td>
<td>
<p>Components of <code>mvp</code>
objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>onevarpow()</code> returns just the terms in which the
symbols corresponding to the named arguments have powers equal to the
arguments' powers.  Thus:
</p>
<pre>
 onevarpow(as.mvp("x*y*z + 3*x*y^2 + 7*x*y^2*z^6 + x*y^3"),x=1,y=2)
mvp object algebraically equal to
3  +  7 z^6
</pre>
<p>Above, we see that only the terms with <code>x^1*y^2</code> have been
extracted, corresponding to arguments <code>x=1,y=2</code>.
</p>
<p>Function <code>series()</code> returns a power series expansion of powers of
variable <code>v</code>.  The value returned is a list of three elements
named <code>mvp</code>, <code>varpower</code>, and <code>variablename</code>.  The first
element is a list of <code>mvp</code> objects and the second is an integer
vector of powers of variable <code>v</code> (element <code>variablename</code> is
a character string holding the variable name, argument <code>v</code>).
</p>
<p>Function <code>trunc(S,n)</code> returns the terms of <code>S</code> with the sum
of the powers of the variables <code class="reqn">\leq n</code>.  Alternatively, it
discards all terms with total power <code class="reqn">&gt;n</code>.
</p>
<p>Function <code>trunc1()</code> is similar to <code>trunc()</code>.  It takes a
<code>mvp</code> object and an arbitrary number of named arguments, with
names corresponding to variables and their values corresponding to the
highest power in that variable to be retained.  Thus
<code>trunc1(S,x=2,y=4)</code> will discard any term with variable <code>x</code>
raised to the power 3 or above, and also any term with variable
<code>y</code> raised to the power 5 or above.  The highest power of
<code>x</code> will be 2 and the highest power of <code>y</code> will be 4.
</p>
<p>Function <code>truncall(S,n)</code> discards any term of <code>S</code> with any
variable raised to a power greater than <code>n</code>.  
</p>
<p>Function <code>series()</code> returns an object of class <code>series</code>; the
print method for <code>series</code> objects is sensitive to the value of
<code>getOption("mvp_mult_symbol")</code>; set this to <code>"*"</code> to get
<code>mpoly</code>-compatible output.
</p>
<p>Function <code>taylor()</code> is a convenience wrapper for <code>series()</code>.
</p>
<p>Functions <code>mvp_taylor_onevar()</code>, <code>mvp_taylor_allvars()</code> and
<code>mvp_to_series()</code> are low-level helper functions that are not
intended for the user.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+deriv">deriv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>trunc(as.mvp("1+x")^6,2)

trunc(as.mvp("1+x+y")^3,2)      # discards all terms with total power&gt;2
trunc1(as.mvp("1+x+y")^3,x=2)   # terms like y^3 are treated as constants

trunc(as.mvp("1+x+y^2")^3,3)    # discards x^2y^2 term (total power=4&gt;3)
truncall(as.mvp("1+x+y^2")^3,3) # retains  x^2y^2 term (all vars to power 2)

onevarpow(as.mvp("1+x+x*y^2  + z*y^2*x"),x=1,y=2)

(p2 &lt;- rmvp(10))
series(p2,"a")

# Works well with pipes:

f &lt;- function(n){as.mvp(sub('n',n,'1+x^n*y'))}
Reduce(`*`,lapply(1:6,f)) %&gt;% series('y')
Reduce(`*`,lapply(1:6,f)) %&gt;% series('x')


(p &lt;- horner("x+y",1:4))
onevarpow(p,x=2)   # coefficient of x^2
onevarpow(p,x=3)   # coefficient of x^3


p %&gt;% trunc(2)
p %&gt;% trunc1(x=2)
(p %&gt;% subs(x="x+dx") -p) %&gt;% trunc1(dx=2)

# Nice example of Horner's method:
(p &lt;- as.mvp("x + y + 3*x*y"))
trunc(horner(p,1:5)*(1-p)^2,4)  # should be 1


## Third order taylor expansion of f(x)=sin(x+y) for x=1.1, about x=1:
(sinxpy &lt;- horner("x+y",c(0,1,0,-1/6,0,+1/120,0,-1/5040,0,1/362880)))  # sin(x+y)
dx &lt;- as.mvp("dx")
t3 &lt;- sinxpy  + aderiv(sinxpy,x=1)*dx + aderiv(sinxpy,x=2)*dx^2/2 + aderiv(sinxpy,x=3)*dx^3/6
t3 %&lt;&gt;% subs(x=1,dx=0.1)  # t3 = Taylor expansion of sin(y+1.1)
t3 %&gt;% subs(y=0.3)  - sin(1.4)  # numeric; should be small
</code></pre>

<hr>
<h2 id='special'>Various functions to create simple multivariate polynomials</h2><span id='topic+special'></span><span id='topic+product'></span><span id='topic+homog'></span><span id='topic+linear'></span><span id='topic+xyz'></span><span id='topic+numeric_to_mvp'></span>

<h3>Description</h3>

<p>Various functions to create simple <code>mvp</code> objects such as single-term,
homogeneous, and constant multivariate polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product(v,symbols=letters)
homog(d,power=1,symbols=letters)
linear(x,power=1,symbols=letters)
xyz(n,symbols=letters)
numeric_to_mvp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="special_+3A_d">d</code>, <code id="special_+3A_n">n</code></td>
<td>
<p>An integer; generally, the dimension or arity of the
resulting <code>mvp</code> object</p>
</td></tr>
<tr><td><code id="special_+3A_v">v</code>, <code id="special_+3A_power">power</code></td>
<td>
<p>Integer vector of powers</p>
</td></tr>
<tr><td><code id="special_+3A_x">x</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
<tr><td><code id="special_+3A_symbols">symbols</code></td>
<td>
<p>Character vector for the symbols</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions documented here return a <code>mvp</code> object</p>


<h3>Note</h3>

<p>The functions here are related to their equivalents in the multipol and
spray packages, but are not exactly the same.
</p>
<p>Function <code>constant()</code> is documented at <code>constant.Rd</code>, but is listed
below for convenience.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code>, <code><a href="#topic+zero">zero</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>product(1:3)        #      a * b^2 * c^3
homog(3)            #      a + b + c
homog(3,2)          #      a^2  + a b + a c + b^2 + b c + c^2
linear(1:3)         #      1*a + 2*b + 3*c
constant(5)         #      5
xyz(5)              #      a*b*c*d*e
</code></pre>

<hr>
<h2 id='subs'>Substitution</h2><span id='topic+subs'></span><span id='topic+subsy'></span><span id='topic+subvec'></span><span id='topic+substitute'></span><span id='topic+subsmvp'></span><span id='topic+subs_mvp'></span><span id='topic+mvp_subs_mvp'></span><span id='topic+varchange'></span><span id='topic+varchange_formal'></span><span id='topic+namechanger'></span>

<h3>Description</h3>

<p>Substitute symbols in an <code>mvp</code> object for numbers or other
multivariate polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(S, ..., lose = TRUE)
subsy(S, ..., lose = TRUE)
subvec(S, ...)
subsmvp(S,v,X)
varchange(S,...)
varchange_formal(S,old,new)
namechanger(x,old,new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subs_+3A_s">S</code>, <code id="subs_+3A_x">X</code></td>
<td>
<p>Multivariate polynomials</p>
</td></tr>
<tr><td><code id="subs_+3A_...">...</code></td>
<td>
<p>named arguments corresponding to variables to substitute</p>
</td></tr>
<tr><td><code id="subs_+3A_lose">lose</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to return a
scalar (the constant) in place of a constant <code>mvp</code> object</p>
</td></tr>
<tr><td><code id="subs_+3A_v">v</code></td>
<td>
<p>A string corresponding to the variable to substitute</p>
</td></tr>
<tr><td><code id="subs_+3A_old">old</code>, <code id="subs_+3A_new">new</code>, <code id="subs_+3A_x">x</code></td>
<td>
<p>The old and new variable names respectively; <code>x</code>
is a character vector</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function <code>subs()</code> substitutes variables for <code>mvp</code> objects,
using a natural R idiom.  Observe that this type of substitution is
sensitive to order:
</p>
<pre>
&gt; p &lt;- as.mvp("a b^2")
&gt; subs(p,a="b",b="x")
mvp object algebraically equal to
x^3
&gt; subs(p,b="x",a="b")  # same arguments, different order
mvp object algebraically equal to
b x^2
</pre>
<p>Functions <code>subsy()</code> and <code>subsmvp()</code> are lower-level functions,
not really intended for the end-user.  Function <code>subsy()</code>
substitutes variables for numeric values (order matters if a variable is
substituted more than once).  Function <code>subsmpv()</code> takes a
<code>mvp</code> object and substitutes another <code>mvp</code> object for a
specific symbol.
</p>
<p>Function <code>subvec()</code> substitutes the symbols of <code>S</code> with
numerical values.  It is vectorised in its ellipsis arguments with
recycling rules and names behaviour inherited from <code>cbind()</code>.
However, if the first element of <code>...</code> is a matrix, then this is
interpreted by rows, with symbol names given by the matrix column names;
further arguments are ignored.  Unlike <code>subs()</code>, this function is
generally only useful if all symbols are given a value; unassigned
symbols take a value of zero.
</p>
<p>Function <code>varchange()</code> makes a <em>formal</em> variable substitution.
It is useful because it can take non-standard variable names such as
&ldquo;<code>(a-b)</code>&rdquo; or &ldquo;<code>?</code>&rdquo;, and is used in
<code>taylor()</code>.  Function <code>varchange_formal()</code> does the same task,
but takes two character vectors, <code>old</code> and <code>new</code>, which might
be more convenient than passing named arguments.  Remember that
non-standard names might need to be quoted; also you might need to
escape some characters, see the examples.  Function <code>namechanger()</code>
is a low-level helper function that uses regular expression idiom to
substitute variable names.
</p>


<h3>Value</h3>

<p>Functions <code>subs()</code>, <code>subsy()</code> and <code>subsmvp()</code> return a
multivariate polynomial unless <code>lose</code> is <code>TRUE</code> in which
case a length one numeric vector is returned.  Function
<code>subvec()</code> returns a numeric vector (sic! the output inherits its
order from the arguments).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+lose">lose</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- rmvp(6,2,2,letters[1:3])
p
subs(p,a=1)
subs(p,a=1,b=2)

subs(p,a="1+b x^3",b="1-y")
subs(p,a=1,b=2,c=3,lose=FALSE)

do.call(subs,c(list(as.mvp("z")),rep(c(z="C+z^2"),5)))

subvec(p,a=1,b=2,c=1:5)   # supply a named list of vectors

M &lt;- matrix(sample(1:3,26*3,replace=TRUE),ncol=26)
colnames(M) &lt;- letters
rownames(M) &lt;- c("Huey", "Dewie", "Louie")
subvec(kahle(r=3,p=1:3),M)  # supply a matrix

varchange(as.mvp("1+x+xy + x*y"),x="newx") # variable xy unchanged

kahle(5,3,1:3) %&gt;% subs(a="a + delta")

varchange(p,a="]")  # nonstandard variable names OK

varchange_formal(p,"\\]","a")

</code></pre>

<hr>
<h2 id='summary'>Summary methods for mvp objects</h2><span id='topic+summary'></span><span id='topic+nterms'></span><span id='topic+summary.mvp'></span><span id='topic+print.summary.mvp'></span><span id='topic+rtypical'></span>

<h3>Description</h3>

<p>Summary methods for mvp objects and extraction of typical terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvp'
summary(object, ...)
## S3 method for class 'summary.mvp'
print(x, ...)
rtypical(object,n=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_x">x</code>, <code id="summary_+3A_object">object</code></td>
<td>
<p>Multivariate polynomial, class <code>mvp</code></p>
</td></tr>
<tr><td><code id="summary_+3A_n">n</code></td>
<td>
<p>In <code>rtypical()</code>, number of terms (in addition to the
constant) to select</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary method prints out a list of interesting facts about an
<code>mvp</code> object such as the longest term or highest power.  Function
<code>rtypical()</code> extracts the constant if present, and a <em>random</em>
selection of terms of its argument.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(rmvp(40))
rtypical(rmvp(1000))
</code></pre>

<hr>
<h2 id='zero'>The zero polynomial</h2><span id='topic+zero'></span><span id='topic+zero.mvp'></span><span id='topic+is.zero'></span><span id='topic+is.zero.mvp'></span>

<h3>Description</h3>

<p>Test for a multivariate polynomial being zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>is.zero()</code> returns <code>TRUE</code> if <code>x</code> is indeed
the zero polynomial.  It is defined as <code>length(vars(x))==0</code> for
reasons of efficiency, but conceptually it returns
<code>x==constant(0)</code>.
</p>
<p>(Use <code>constant(0)</code> to create the zero polynomial).
</p>


<h3>Note</h3>

<p>I would have expected the zero polynomial to be problematic (cf the
<a href="https://CRAN.R-project.org/package=freegroup"><span class="pkg">freegroup</span></a> and <a href="https://CRAN.R-project.org/package=permutations"><span class="pkg">permutations</span></a> packages, where similar
issues require extensive special case treatment).  But it seems to work
fine, which is a testament to the robust coding in the STL.
</p>
<p>A general <code>mvp</code> object is something like
</p>
<p><code>{{"x" -&gt; 3, "y" -&gt; 5} -&gt; 6, {"x" -&gt; 1, "z" -&gt; 8} -&gt; -7}}</code>
</p>
<p>which would be <code class="reqn">6x^3y^5-7xz^8</code>.  The zero
polynomial is just <code>{}</code>.  Neat, eh?
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
constant(0)

t1 &lt;- as.mvp("x+y")
t2 &lt;- as.mvp("x-y")

stopifnot(is.zero(t1*t2-as.mvp("x^2-y^2")))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
