<!DOCTYPE html><html><head><title>Help for package RRPP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RRPP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RRPP-package'><p>RRPP: Linear Model Evaluation with Randomized Residuals in a Permutation Procedure</p></a></li>
<li><a href='#add.trajectories'><p>Plot Function for RRPP</p></a></li>
<li><a href='#add.tree'><p>Plot tool to add phylogenetic trees to ordination plots</p></a></li>
<li><a href='#anova.lm.rrpp'><p>ANOVA for lm.rrpp model fits</p></a></li>
<li><a href='#anova.measurement.error'><p>ANOVA for lm.rrpp model fits used in measurement.error</p></a></li>
<li><a href='#classify'><p>Deprecated functions in RRPP</p></a></li>
<li><a href='#coef.lm.rrpp'><p>coef for lm.rrpp model fits</p></a></li>
<li><a href='#convert2ggplot'><p>Convert RRPP plots to ggplot objects</p></a></li>
<li><a href='#effect.size'><p>Obtain Effect-size from a vector of values</p></a></li>
<li><a href='#fishy'><p>Simulated fish data for measurement error analysis</p></a></li>
<li><a href='#fitted.lm.rrpp'><p>Extract fitted values</p></a></li>
<li><a href='#focusMEonSubjects'><p>Plot Function for RRPP</p></a></li>
<li><a href='#getANOVAStats'><p>Utility Function for RRPP</p></a></li>
<li><a href='#getModelCov'><p>Utility Function for RRPP</p></a></li>
<li><a href='#getModels'><p>Utility Function for RRPP</p></a></li>
<li><a href='#getPermInfo'><p>Utility Function for RRPP</p></a></li>
<li><a href='#getResCov'><p>Utility Function for RRPP</p></a></li>
<li><a href='#getTerms'><p>Utility Function for RRPP</p></a></li>
<li><a href='#ICCstats'><p>Intraclass correlation statistics from an lm.rrpp model fits</p></a></li>
<li><a href='#interSubVar'><p>Reveal the inter-subject variability from a measurement error analysis</p></a></li>
<li><a href='#lm.rrpp'><p>Linear Model Evaluation with a Randomized Residual Permutation Procedure</p></a></li>
<li><a href='#lm.rrpp.ws'><p>Linear Model Evaluation with RRPP performed within subjects</p></a></li>
<li><a href='#logLik.lm.rrpp'><p>Calculate the log-likelihood of a lm.rrpp fit</p></a></li>
<li><a href='#looCV'><p>Diagnostic cross-validation tool for ordination based on fitted values</p></a></li>
<li><a href='#lr_test'><p>Likelihood ratio test for a linear model, based on RRPP</p></a></li>
<li><a href='#manova.update'><p>MANOVA update for lm.rrpp model fits</p></a></li>
<li><a href='#measurement.error'><p>Evaluation of measurement error for two or more multivariate measurements,</p>
for common research subjects</a></li>
<li><a href='#model.comparison'><p>Model Comparisons, in terms of the log-likelihood, covariance trace,</p>
or Z-score.</a></li>
<li><a href='#model.frame.lm.rrpp'><p>Extract model frame from a lm.rrpp object</p></a></li>
<li><a href='#model.matrix.lm.rrpp'><p>Extract the model design matrix from an lm.rrpp object</p></a></li>
<li><a href='#motionpaths'><p>Simulated motion paths</p></a></li>
<li><a href='#na.omit.rrpp.data.frame'><p>Handle missing values in rrpp.data.frame objects</p></a></li>
<li><a href='#ordinate'><p>Ordination tool for data aligned to another matrix</p></a></li>
<li><a href='#pairwise'><p>Pairwise comparisons of lm.rrpp fits</p></a></li>
<li><a href='#PlethMorph'><p>Plethodon comparative morphological data</p></a></li>
<li><a href='#plot.interSubVar'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.lm.rrpp'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.looCV'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.measurement.error'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.model.comparison'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.ordinate'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.predict.lm.rrpp'><p>Plot Function for RRPP</p></a></li>
<li><a href='#plot.trajectory.analysis'><p>Plot Function for RRPP</p></a></li>
<li><a href='#predict.lm.rrpp'><p>predict for lm.rrpp model fits</p></a></li>
<li><a href='#prep.lda'><p>Linear discriminant function for lm.rrpp model fits</p></a></li>
<li><a href='#print.anova.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.coef.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.ICCstats'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.looCV'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.lr_test'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.measurement.error'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.model.comparison'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.ordinate'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.pairwise'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.predict.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.summary.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.summary.manova.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.summary.ordinate'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.summary.pairwise'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.summary.trajectory.analysis'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#print.trajectory.analysis'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#Pupfish'><p>Landmarks on pupfish</p></a></li>
<li><a href='#PupfishHeads'><p>Landmarks on pupfish heads</p></a></li>
<li><a href='#pval'><p>Obtain P-value from a vector of values</p></a></li>
<li><a href='#residuals.lm.rrpp'><p>Extract residuals</p></a></li>
<li><a href='#reveal.model.designs'><p>Reveal model designs used in lm.rrpp fit</p></a></li>
<li><a href='#rrpp.data.frame'><p>Create a data frame for lm.rrpp analysis</p></a></li>
<li><a href='#scaleCov'><p>Scaling of a Covariance Matrix</p></a></li>
<li><a href='#summary.anova.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.coef.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.ICCstats'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.looCV'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.lr_test'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.manova.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.measurement.error'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.model.comparison'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.ordinate'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.pairwise'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.predict.lm.rrpp'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#summary.trajectory.analysis'><p>Print/Summary Function for RRPP</p></a></li>
<li><a href='#terms.lm.rrpp'><p>Extract the terms from an lm.rrpp object</p></a></li>
<li><a href='#trajectory.analysis'><p>Quantify and compare shape change trajectories</p></a></li>
<li><a href='#vec.cor.matrix'><p>Support function for RRPP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Linear Model Evaluation with Randomized Residuals in a
Permutation Procedure</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Linear model calculations are made for many random versions of data.  
    Using residual randomization in a permutation procedure, sums of squares are 
    calculated over many permutations to generate empirical probability distributions 
    for evaluating model effects.  This packaged is described by 
    Collyer &amp; Adams (2018).  Additionally, coefficients, statistics, fitted values, and residuals generated over many 
    permutations can be used for various procedures including pairwise tests, prediction, classification, and
    model comparison.  This package should provide most tools one could need for the analysis of
    high-dimensional data, especially in ecology and evolutionary biology, but certainly other fields, as well.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlcollyer/RRPP">https://github.com/mlcollyer/RRPP</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, ape, ggplot2, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.2.0), dplyr, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 13:54:34 UTC; m.collyer</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Collyer <a href="https://orcid.org/0000-0003-0238-2201"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dean Adams <a href="https://orcid.org/0000-0001-9172-7894"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Collyer &lt;mlcollyer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 14:30:03 UTC</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
</table>
<hr>
<h2 id='RRPP-package'>RRPP: Linear Model Evaluation with Randomized Residuals in a Permutation Procedure</h2><span id='topic+RRPP-package'></span><span id='topic+RRPP'></span>

<h3>Description</h3>

<p>Linear model calculations are made for many random versions of data. Using residual randomization in a permutation procedure, sums of squares are calculated over many permutations to generate empirical probability distributions for evaluating model effects. This packaged is described by Collyer &amp; Adams (2018). Additionally, coefficients, statistics, fitted values, and residuals generated over many permutations can be used for various procedures including pairwise tests, prediction, classification, and model comparison. This package should provide most tools one could need for the analysis of high-dimensional data, especially in ecology and evolutionary biology, but certainly other fields, as well.
</p>
<p>Functions in this package allow one to evaluate linear models 
with residual randomization.
The name, &quot;RRPP&quot;, is an acronym for, &quot;Randomization of Residuals in a 
Permutation Procedure.&quot;  Through
the various functions in this package, one can use randomization of 
residuals to generate empirical probability
distributions for linear model effects, for high-dimensional data or 
distance matrices.
</p>
<p>An especially useful option of this package is to fit models with 
either ordinary or generalized
least squares estimation (OLS or GLS, respectively), using theoretic 
covariance matrices.  Mixed linear
effects can also be evaluated.
</p>


<h3>Value</h3>

<p>Key functions for this package:
</p>
<table>
<tr><td><code>\link{lm.rrpp}</code></td>
<td>
<p>Fits linear models, using RRPP.
plus model comparisons.</p>
</td></tr>
<tr><td><code>\link{coef.lm.rrpp}</code></td>
<td>
<p>Extract coefficients or perform test 
on coefficients, using RRPP.</p>
</td></tr>
<tr><td><code>\link{predict.lm.rrpp}</code></td>
<td>
<p>Predict values from lm.rrpp fits 
and generate bootstrapped confidence intervals.</p>
</td></tr>
<tr><td><code>\link{pairwise}</code></td>
<td>
<p>Perform pairwise tests, based on lm.rrpp 
model fits.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Collyer <a href="mailto:mlcollyer@gmail.com">mlcollyer@gmail.com</a> (<a href="https://orcid.org/0000-0003-0238-2201">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Dean Adams (<a href="https://orcid.org/0000-0001-9172-7894">ORCID</a>)
</p>
</li></ul>

<p>Michael Collyer and Dean Adams
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlcollyer/RRPP">https://github.com/mlcollyer/RRPP</a>
</p>
</li></ul>


<hr>
<h2 id='add.trajectories'>Plot Function for RRPP</h2><span id='topic+add.trajectories'></span>

<h3>Description</h3>

<p>Function adds trajectories to a principal component plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.trajectories(
  TP,
  traj.pch = 21,
  traj.col = 1,
  traj.lty = 1,
  traj.lwd = 1,
  traj.cex = 1.5,
  traj.bg = 1,
  start.bg = 3,
  end.bg = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.trajectories_+3A_tp">TP</code></td>
<td>
<p>plot object (from <code><a href="#topic+plot.trajectory.analysis">plot.trajectory.analysis</a></code>)</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_traj.pch">traj.pch</code></td>
<td>
<p>Plotting &quot;character&quot; for trajectory points.
Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for pch.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_traj.col">traj.col</code></td>
<td>
<p>The color of trajectory lines.
Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for col.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_traj.lty">traj.lty</code></td>
<td>
<p>Trajectory line type.  Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for lty.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_traj.lwd">traj.lwd</code></td>
<td>
<p>Trajectory line width.  Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for lwd.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_traj.cex">traj.cex</code></td>
<td>
<p>Trajectory point character expansion.  Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for cex.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_traj.bg">traj.bg</code></td>
<td>
<p>Trajectory point background.  Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for bg.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_start.bg">start.bg</code></td>
<td>
<p>Trajectory point background, just the start points.
Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for bg.  Green start points are the default.</p>
</td></tr>
<tr><td><code id="add.trajectories_+3A_end.bg">end.bg</code></td>
<td>
<p>Trajectory point background, just the end points.
Can be a single value or vector 
of length equal to the number of trajectories.  
See <code><a href="graphics.html#topic+par">par</a></code> and its description 
for bg.  Red end points are the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function adds trajectories to a plot made by 
<code><a href="#topic+plot.trajectory.analysis">plot.trajectory.analysis</a></code>.
This function has a restricted set of plot parameters 
based on the number of trajectories
to be added to the plot.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Adams, D. C., and M. M. Cerney. 2007. 
Quantifying biomechanical motion using Procrustes 
motion analysis. J. Biomech. 40:437-444.
</p>
<p>Adams, D. C., and M. L. Collyer. 2007. 
The analysis of character divergence along environmental 
gradients and other covariates. Evolution 61:510-515.
</p>
<p>Adams, D. C., and M. L. Collyer. 2009. 
A general framework for the analysis of phenotypic 
trajectories in evolutionary studies. Evolution 63:1143-1154.
</p>
<p>Collyer, M. L., and D. C. Adams. 2007. 
Analysis of two-state multivariate phenotypic change 
in ecological studies. Ecology 88:683-692.
</p>
<p>Collyer, M. L., and D. C. Adams. 2013. 
Phenotypic trajectory analysis: comparison of shape change patterns 
in evolution and ecology. Hystrix 24: 75-83.
</p>
<p>Collyer, M.L., D.J. Sekora, and D.C. Adams. 2015. 
A method for analysis of phenotypic change for phenotypes described 
by high-dimensional data. Heredity. 115:357-365.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code>
</p>

<hr>
<h2 id='add.tree'>Plot tool to add phylogenetic trees to ordination plots</h2><span id='topic+add.tree'></span>

<h3>Description</h3>

<p>Function adds a tree based on a description of edges from a class phylo object 
to an existing plot made from an ordinate object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.tree(
  OP,
  tree,
  edge.col = 1,
  edge.lty = 1,
  edge.lwd = 1,
  anc.pts = FALSE,
  return.ancs = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.tree_+3A_op">OP</code></td>
<td>
<p>An object with class <code><a href="#topic+plot.ordinate">plot.ordinate</a></code>.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_tree">tree</code></td>
<td>
<p>An object of class phylo.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_edge.col">edge.col</code></td>
<td>
<p>A single value or vector equal to the number of edges for edge colors.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_edge.lty">edge.lty</code></td>
<td>
<p>A single value or vector equal to the number of edges for edge line type</p>
</td></tr>
<tr><td><code id="add.tree_+3A_edge.lwd">edge.lwd</code></td>
<td>
<p>A single value or vector equal to the number of edges for edge line weight.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_anc.pts">anc.pts</code></td>
<td>
<p>A logical value for whether to add points for ancestral values.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_return.ancs">return.ancs</code></td>
<td>
<p>A logical value for whether ancestral values should be printed.</p>
</td></tr>
<tr><td><code id="add.tree_+3A_...">...</code></td>
<td>
<p>Arguments passed onto <code><a href="graphics.html#topic+points">points</a></code>, used only for ancestral points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With some <code><a href="#topic+ordinate">ordinate</a></code> plots, it might be desirable to add a tree 
connecting points in a prescribed way, which would be tedious using 
<code><a href="graphics.html#topic+points">points</a></code> or <code><a href="graphics.html#topic+lines">lines</a></code>.  This function will project a 
tree from an object of class phylo into a plot with class, 
<code><a href="#topic+plot.ordinate">plot.ordinate</a></code>.  Using an edges matrix from a phylo object, 
this function will systematically connect plot points with lines that pass 
through estimated ancestral character points in the same plot space.  
Ancestral states are estimated assuming a Brownian motion model 
of evolutionary divergence.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+points">points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Examples use residuals from a regression of salamander morphological 
# traits against body size (snout to vent length, SVL).
# Observations are species means and a phylogenetic covariance matrix
# describes the relatedness among observations.

data("PlethMorph")
Y &lt;- as.data.frame(PlethMorph[c("TailLength", "HeadLength", 
"Snout.eye", "BodyWidth", 
"Forelimb", "Hindlimb")])
Y &lt;- as.matrix(Y)
R &lt;- lm.rrpp(Y ~ SVL, data = PlethMorph, 
iter = 0, print.progress = FALSE)$LM$residuals

PCA &lt;- ordinate(R, scale. = TRUE)
pc.plot &lt;- plot(PCA, pch = 19, col = "blue")

add.tree(pc.plot, tree = PlethMorph$tree, anc.pts = TRUE, 
pch = 19, cex = 0.5, col = "red")

</code></pre>

<hr>
<h2 id='anova.lm.rrpp'>ANOVA for lm.rrpp model fits</h2><span id='topic+anova.lm.rrpp'></span>

<h3>Description</h3>

<p>Computes an analysis of variance (ANOVA) table using 
distributions of random statistics from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.  
ANOVA can be performed on one model or multiple models.  
If the latter, the first model is considered a null model for 
comparison to other models.  The ANOVA is functionally similar to a 
non-parametric likelihood ratio test for all null-full model comparisons
Residuals from the null model will be used to generate random pseudo-values 
via RRPP for evaluation of subsequent models. The permutation schedule from 
the null model will be used for random permutations.
This function does not correct for improper null models.  One must assure 
that the null model is nested within the other models.  Illogical results 
can be generated if this is not the case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
anova(
  object,
  ...,
  effect.type = c("F", "cohenf", "SS", "MS", "Rsq"),
  error = NULL,
  print.progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="anova.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Additional lm.rrpp model fits or other arguments passed to anova.</p>
</td></tr>
<tr><td><code id="anova.lm.rrpp_+3A_effect.type">effect.type</code></td>
<td>
<p>One of &quot;F&quot;, &quot;cohenf&quot;, &quot;SS&quot;, &quot;MS&quot;, &quot;Rsq&quot; to choose from 
which distribution of statistics to calculate effect sizes (Z).  
See <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
<tr><td><code id="anova.lm.rrpp_+3A_error">error</code></td>
<td>
<p>An optional character string to define MS error term for 
calculation of F values. See <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> for examples.</p>
</td></tr>
<tr><td><code id="anova.lm.rrpp_+3A_print.progress">print.progress</code></td>
<td>
<p>A logical argument if multiple models are used and 
one wishes to view progress for sums of squares (SS) calculations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See examples for lm.rrpp to see how anova.lm.rrpp works in conjunction
# with other functions

data(Pupfish)
names(Pupfish)
Pupfish$logSize &lt;- log(Pupfish$CS) # better to not have functions in formulas

# Single-Model ANOVA

fit &lt;- lm.rrpp(coords ~ logSize + Sex*Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 999) 
anova(fit)
anova(fit, effect.type = "MS")
anova(fit, effect.type = "Rsq")
anova(fit, effect.type = "cohenf")

# Multi-Model ANOVA (like a Likelihood Ratio Test)
fit.size &lt;- lm.rrpp(coords ~ logSize, SS.type = "I", data = Pupfish, 
print.progress = FALSE, iter = 999) 
fit.sex &lt;- lm.rrpp(coords ~ logSize + Sex, SS.type = "I", data = Pupfish, 
print.progress = FALSE, iter = 999) 
fit.pop &lt;- lm.rrpp(coords ~ logSize + Pop, SS.type = "I", data = Pupfish, 
print.progress = FALSE, iter = 999) 
anova(fit.size, fit.sex, fit.pop, 
print.progress = FALSE) # compares two models to the first

# see lm.rrpp examples for mixed model ANOVA example and how to vary SS type

## End(Not run)

</code></pre>

<hr>
<h2 id='anova.measurement.error'>ANOVA for lm.rrpp model fits used in measurement.error</h2><span id='topic+anova.measurement.error'></span>

<h3>Description</h3>

<p>Computes an analysis of variance (ANOVA) table using 
distributions of random statistics from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.  
This function is the same as <code><a href="#topic+anova.lm.rrpp">anova.lm.rrpp</a></code> but includes statistics
specific to <code><a href="#topic+measurement.error">measurement.error</a></code>, and with restrictions on
how P-values and effect.sizes are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measurement.error'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.measurement.error_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="anova.measurement.error_+3A_...">...</code></td>
<td>
<p>Additional lm.rrpp model fits or other arguments passed to anova.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See measurement.error help file examples for use.

</code></pre>

<hr>
<h2 id='classify'>Deprecated functions in RRPP</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>The following function has been deprecated in RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify()
</code></pre>


<h3>Details</h3>

<p>This function has been deprecated. Use <code><a href="#topic+prep.lda">prep.lda</a></code> instead.
</p>

<hr>
<h2 id='coef.lm.rrpp'>coef for lm.rrpp model fits</h2><span id='topic+coef.lm.rrpp'></span>

<h3>Description</h3>

<p>Computes ordinary or generalized least squares coefficients
over the permutations of an <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> model fit with predefined 
random permutations.
For each coefficient vector, the Euclidean distance is calculated as an 
estimate of
the amount of change in Y, the n x p matrix of dependent variables; larger 
distances mean more change 
in location in the data space associated with a one unit change in the model 
design, for the parameter
described.  Random coefficients are based on either RRPP or FRPP, as defined 
by the 
<code><a href="#topic+lm.rrpp">lm.rrpp</a></code> model fit.  
</p>
<p>This function can be used to test the specific coefficients of an 
lm.rrpp fit.  The test
statistics are the distances (d), which are also standardized (Z-scores).  
The Z-scores might be easier to compare,
as the expected values for random distances can vary among coefficient 
vectors.
</p>
<p>If RRPP is used, all distributions of coefficient vector distances are 
based on appropriate null models, as defined by SS type.  Please be aware that this 
can result in two seemingly strange but reasonable phenomena.  First, if type II or
type III SS is used, the intercept will not appear in test results (because the function
seeks model parameter differences to know for which coefficients to calculate Euclidean 
distances).  Even if it appears for type I SS, this is merely an artifact of sequential
model building and there really is no meaningful test of intercept = 0.  Second, 
Euclidean distances might not always be logical, especially when viewing univariate
coefficients, in which case the expected d is |b|.  Coefficients without a test are
based on the full model; tests are based on the estimates of coefficients (b), 
given a null model.  For example, for a model, y ~ b1 + b2 + b3, with type I SS,
b2 will be estimated and tested, using a null model, y ~ b1 and a full model, 
y ~ b1 + b2.  The estimate for b2 might not be the same in the test as when estimated 
from the model, y ~ b1 + b2 + b3.  Therefore, the d statistic might not reflect what one
would expect from the full model (like when using type III SS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
coef(object, SE = FALSE, test = FALSE, confidence = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="coef.lm.rrpp_+3A_se">SE</code></td>
<td>
<p>Whether to include standard errors of coefficients.  Standard
errors are muted if test = TRUE.</p>
</td></tr>
<tr><td><code id="coef.lm.rrpp_+3A_test">test</code></td>
<td>
<p>Logical argument that if TRUE, performs hypothesis tests 
(Null hypothesis is vector distance = 0)
for the observed coefficients.  If FALSE, only the observed coefficients 
are returned.</p>
</td></tr>
<tr><td><code id="coef.lm.rrpp_+3A_confidence">confidence</code></td>
<td>
<p>The desired confidence limit to print with a table of 
summary statistics,
if test = TRUE.  Because distances are directionless, confidence limits 
are one-tailed.</p>
</td></tr>
<tr><td><code id="coef.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments (currently none)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See examples for lm.rrpp to see how anova.lm.rrpp works in conjunction
# with other functions

data(Pupfish)
names(Pupfish)
Pupfish$logSize &lt;- log(Pupfish$CS)

fit &lt;- lm.rrpp(coords ~ logSize + Sex*Pop, 
SS.type = "I", data = Pupfish, verbose = TRUE) 

coef(fit) # Just coefficients
coef(fit, SE = TRUE) # Coefficients with SE
coef(fit, test = TRUE, 
confidence = 0.99) # Test of coefficients

## End(Not run)
</code></pre>

<hr>
<h2 id='convert2ggplot'>Convert RRPP plots to ggplot objects</h2><span id='topic+convert2ggplot'></span>

<h3>Description</h3>

<p>Function attempts to coerce plot information from an RRPP plot object to an 
amenable ggplot object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2ggplot(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert2ggplot_+3A_object">object</code></td>
<td>
<p>A plot object produced from <code><a href="#topic+plot.lm.rrpp">plot.lm.rrpp</a></code> and type 
equals either &quot;PC&quot; or &quot;regression, <code><a href="#topic+plot.predict.lm.rrpp">plot.predict.lm.rrpp</a></code>, or 
<code><a href="#topic+plot.ordinate">plot.ordinate</a></code>.  Essentially, any RRPP plot except a series of diagnostic
plots should work.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will attempt to use the plot arguments from an RRPP plot object 
to make a ggplot that can be additionally updated, as desired.  Not all plot 
characteristics can be converted.  For example, text arguments are not currently
passed to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, as the <code><a href="graphics.html#topic+text">text</a></code> function and geom_text
arguments do not easily align.  However, one can use text arguments produced by
a RRPP plot object and geom_text to augment a ggplot object the way they like.
</p>
<p>This function assumes no responsibility for arguments made by <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
It merely produces a ggplot object that should resemble an RRPP plot default.  Any 
augmentation of ggplot objects can be done either by direct intervention of the ggplot 
produced or reformatting the initial RRPP plot produced.  One should not expect direct
correspondence between R base plot parameters and ggplot parameters.  For example,
error bars will generally appear as different widths, without an easy way to control them,
changing from one format to the other.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Linear Model Example

data(Pupfish)
fit &lt;- lm.rrpp(coords ~ log(CS) + Sex*Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE) 

# Predictions (holding alternative effects constant)

shapeDF &lt;- expand.grid(Sex = levels(Pupfish$Sex), 
Pop = levels(Pupfish$Pop))
rownames(shapeDF) &lt;- paste(shapeDF$Sex, shapeDF$Pop, sep = ".")

shapePreds &lt;- predict(fit, shapeDF)
summary(shapePreds, PC = TRUE)

# Plot prediction

P &lt;- plot(shapePreds, PC = TRUE, ellipse = TRUE)
convert2ggplot(P)

### Ordination Example

data("PlethMorph")

Y &lt;- as.data.frame(PlethMorph[c("TailLength", "HeadLength", 
                               "Snout.eye", "BodyWidth", 
                               "Forelimb", "Hindlimb")])
Y &lt;- as.matrix(Y)
R &lt;- lm.rrpp(Y ~ SVL, data = PlethMorph, 
             print.progress = FALSE)$LM$residuals

# PCA (on correlation matrix)


PCA.ols &lt;- ordinate(R, scale. = TRUE)
PCA.ols$rot
prcomp(R, scale. = TRUE)$rotation # should be the same


PCA.gls &lt;- ordinate(R, scale. = TRUE, 
                   transform. = FALSE, 
                   Cov = PlethMorph$PhyCov)
               
P &lt;- plot(PCA.gls)
convert2ggplot(P)                   

## End(Not run)
</code></pre>

<hr>
<h2 id='effect.size'>Obtain Effect-size from a vector of values</h2><span id='topic+effect.size'></span>

<h3>Description</h3>

<p>A function to find the effect size (Z-score) of a target,
from a vector of values presumably obtained in random permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect.size(x, center = TRUE, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect.size_+3A_x">x</code></td>
<td>
<p>The vector of data to use.</p>
</td></tr>
<tr><td><code id="effect.size_+3A_center">center</code></td>
<td>
<p>Logical value for whether to center x.</p>
</td></tr>
<tr><td><code id="effect.size_+3A_target">target</code></td>
<td>
<p>The value to target in the distribution.  (If null, the first value
in the vector is used.).  If the target exists outside the range of x,
very small or very large z-scores are possible.  Additionally, if the target
is excessively outside of the range of x, it could affect the Box-Cox transformation 
used to transform x.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='fishy'>Simulated fish data for measurement error analysis</h2><span id='topic+fishy'></span>

<h3>Description</h3>

<p>Simulated fish data for measurement error analysis
</p>


<h3>Details</h3>

<p>Data as simulated in Collyer and Adams (2024),
resembling a fish shape, comprising Procrustes coordinates
for 11 anatomical landmarks.  Data represent 120 
configurations for 60 subjects, each with two replicates of
measurement.  The 60 subjects represent 20 subjects each 
from three groups.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Collyer, M.L, and D.C. Adams. 2024. 
Interrogating random and systematic measurement 
error in morphometric data. Evolutionary Biology. 
In press.
</p>

<hr>
<h2 id='fitted.lm.rrpp'>Extract fitted values</h2><span id='topic+fitted.lm.rrpp'></span>

<h3>Description</h3>

<p>Extract fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lm.rrpp_+3A_object">object</code></td>
<td>
<p>plot object (from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="fitted.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for lm.rrpp
</code></pre>

<hr>
<h2 id='focusMEonSubjects'>Plot Function for RRPP</h2><span id='topic+focusMEonSubjects'></span>

<h3>Description</h3>

<p>Reduces a plot.measurement.error to a single research subject.  This can be 
for cases when many overlapping subjects in a plot obscure interpretation 
for specific subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focusMEonSubjects(x, subjects = NULL, shadow = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focusMEonSubjects_+3A_x">x</code></td>
<td>
<p>Plot from <code><a href="#topic+plot.measurement.error">plot.measurement.error</a></code></p>
</td></tr>
<tr><td><code id="focusMEonSubjects_+3A_subjects">subjects</code></td>
<td>
<p>The specific subject to plot</p>
</td></tr>
<tr><td><code id="focusMEonSubjects_+3A_shadow">shadow</code></td>
<td>
<p>A logical value for whether to show other subject values as
shadows of their locations.</p>
</td></tr>
<tr><td><code id="focusMEonSubjects_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='getANOVAStats'>Utility Function for RRPP</h2><span id='topic+getANOVAStats'></span>

<h3>Description</h3>

<p>A function mostly for internal processing but can be used to extract
ANOVA statistics for other uses, such as plotting histograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getANOVAStats(fit, stat = c("SS", "MS", "Rsq", "F", "cohenf", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getANOVAStats_+3A_fit">fit</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
<tr><td><code id="getANOVAStats_+3A_stat">stat</code></td>
<td>
<p>The ANOVA statistic to extract.  Returns every RRPP permutation of 
the statistic.  If &quot;all&quot;, a list of each statistic is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Pupfish)
fit &lt;- lm.rrpp(coords ~ log(CS) + Sex*Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 999) 
anova(fit)
Fstats &lt;- getANOVAStats(fit, stat = "F")
par(mfrow = c(2, 2))
hist(Fstats$Fs[1,], breaks = 50, main = "log(CS)", xlab = "F")
abline(v = Fstats$Fs[1, 1])
hist(Fstats$Fs[2,], breaks = 50, main = "Sex", xlab = "F")
abline(v = Fstats$Fs[2, 1])
hist(Fstats$Fs[3,], breaks = 50, main = "Pop", xlab = "F")
abline(v = Fstats$Fs[3, 1])
hist(Fstats$Fs[4,], breaks = 50, main = "Sex:Pop", xlab = "F")
abline(v = Fstats$Fs[4, 1])

## End(Not run)
</code></pre>

<hr>
<h2 id='getModelCov'>Utility Function for RRPP</h2><span id='topic+getModelCov'></span>

<h3>Description</h3>

<p>A function mostly for internal processing but can be used to extract either
the model covariance matrix (Cov) or the projection matrix for transformations made 
from the covariance matrix (Pcov), which is basically the square-root of 
the covariance matrix.  This matrix is the model covariance used for estimation,
not the residual covariance matrix (see <code><a href="#topic+getResCov">getResCov</a></code>). 
There are also options for S3 or S4 format versions, or
a forcing of symmetry for Pcov.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelCov(
  fit,
  type = c("Cov", "Pcov"),
  format = c("S3", "S4"),
  forceSym = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModelCov_+3A_fit">fit</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="getModelCov_+3A_type">type</code></td>
<td>
<p>Whether the Cov or Pcov matrix is returned</p>
</td></tr>
<tr><td><code id="getModelCov_+3A_format">format</code></td>
<td>
<p>Whether an S3 or S4 format is returned</p>
</td></tr>
<tr><td><code id="getModelCov_+3A_forcesym">forceSym</code></td>
<td>
<p>Logical value for whether a symmetric matrix should 
be returned for Pcov, even if Pcov was triangular as a solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='getModels'>Utility Function for RRPP</h2><span id='topic+getModels'></span>

<h3>Description</h3>

<p>A function mostly for internal processing but can be used to obtain terms,
design matrices, or QR decompositions used for each reduced or full
model that is fitted in an <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModels(fit, attribute = c("terms", "X", "qr", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModels_+3A_fit">fit</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="getModels_+3A_attribute">attribute</code></td>
<td>
<p>The various attributes that are used to extract RRPP
permutation schedules.  If there are n observations, each iteration has
some randomization of 1:n, restricted by the arguments that match attributes
provided by this function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='getPermInfo'>Utility Function for RRPP</h2><span id='topic+getPermInfo'></span>

<h3>Description</h3>

<p>A function mostly for internal processing but can be used to extract
RRPP permutation information for other reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPermInfo(
  fit,
  attribute = c("perms", "perm.method", "block", "perm.seed", "perm.schedule", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPermInfo_+3A_fit">fit</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="getPermInfo_+3A_attribute">attribute</code></td>
<td>
<p>The various attributes that are used to generate RRPP
permutation schedules.  If there are n observations, each iteration has
some randomization of 1:n, restricted by the arguments that match attributes
provided by this function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='getResCov'>Utility Function for RRPP</h2><span id='topic+getResCov'></span>

<h3>Description</h3>

<p>A function mostly for internal processing but can be used to extract the residual
covariance matrix.  This matrix is the residual covariance matrix,
not the model covariance matrix used for estimation (see <code><a href="#topic+getModelCov">getModelCov</a></code>). 
Options for averaging over degrees of freedom or number of
observations, plus standardization, are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResCov(fit, useDf = TRUE, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResCov_+3A_fit">fit</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="getResCov_+3A_usedf">useDf</code></td>
<td>
<p>Logical value for whether the degrees of freedom from the linear model
fit should be used (if TRUE), as opposed to the number of observations (if FALSE).</p>
</td></tr>
<tr><td><code id="getResCov_+3A_standardize">standardize</code></td>
<td>
<p>Logical value for whether residuals should be standardized.  If TRUE,
a correlation matrix is produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='getTerms'>Utility Function for RRPP</h2><span id='topic+getTerms'></span>

<h3>Description</h3>

<p>A function mostly for internal processing but can be used to extract
The terms for each reduced and full model used in an <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTerms(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTerms_+3A_fit">fit</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='ICCstats'>Intraclass correlation statistics from an lm.rrpp model fits</h2><span id='topic+ICCstats'></span>

<h3>Description</h3>

<p>Function performs analyses concerned with the repeatability (reliability) of multivariate data 
(measurements) collected from the same research subjects.  Although there is no
requirement for repeated measurements on all research subjects, the analysis assumes
that multiple observations are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICCstats(
  fit,
  subjects = NULL,
  with_in = NULL,
  groups = NULL,
  multivariate = FALSE,
  print.AOV = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICCstats_+3A_fit">fit</code></td>
<td>
<p>The <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>, previously evaluated.</p>
</td></tr>
<tr><td><code id="ICCstats_+3A_subjects">subjects</code></td>
<td>
<p>A single character value indicating which term in an ANOVA table
corresponds to research subjects.</p>
</td></tr>
<tr><td><code id="ICCstats_+3A_with_in">with_in</code></td>
<td>
<p>One or more character values indicating which terms in an ANOVA table
are measured within subjects (replications, plus maybe interactions).  If NULL,
the only replication within-subject will be considered as residuals.</p>
</td></tr>
<tr><td><code id="ICCstats_+3A_groups">groups</code></td>
<td>
<p>An optional character value to indicate if a factor in the 
model frame of the <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit that could account for subject variation.
Using this argument might minimize the importance of subject variation, if subjects
have disparate values that could inflate ICC.  Note that this name could be different
than what is shown in the ANOVA table, if <code><a href="#topic+measurement.error">measurement.error</a></code>
was used.  Use names(fit$LM$data), substituting fit with the name assigned
to the <code><a href="#topic+measurement.error">measurement.error</a></code> object, to know the groups factor, 
if used.</p>
</td></tr>
<tr><td><code id="ICCstats_+3A_multivariate">multivariate</code></td>
<td>
<p>Logical value for whether to include to calculate ICC matrix 
generalizations and perform eigenanalysis.</p>
</td></tr>
<tr><td><code id="ICCstats_+3A_print.aov">print.AOV</code></td>
<td>
<p>Logical value for whether to include ANOVA table as screen 
output, when calculating ISS statistics.
</p>
<p>Note that this function can return ICC statistics, even if they do not make sense.
It is possible to generate ICC stats with any ANOVA table, with at least one
term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function uses ANOVA statistics or SSCP matrices to find the ratio of among-subject
to within-subject variance.  The former is a dispersion-based approach and the latter
is a multivariate generalization of the ICC statistic (as a matrix product).  The
multivariate generalizations of the statistics
described by Liljequist et al. (2019) are used to find matrix products, 
from which eigenanalysis is performed, providing ICC statistics by eigenvectors.  
</p>
<p>Three statistics describe the ICC for the population,
agreement of measurements among subjects, and consistency between measurements.  
The last statistic does not necessarily measure the sameness 
between measurements but the consistency of change between measurements,
which might be indicative of a systematic measurement error.  
If groups are used, these three statistics are 
repeated, using the SSCP for groups-adjusted data.  
This approach accounts for group differences,
which would avoid large subject variation compared to measurement error 
inflating ICC values.  If there are 
inherently disparate groups from which subjects are sampled, 
this approach can elucidate better agreement and 
consistency in light of group differences.
</p>
<p>This function is most useful for analyses performed with 
<code><a href="#topic+measurement.error">measurement.error</a></code>, but any <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit can be used,
so long as research subjects can be defined. 
</p>
<p>It is essential that all arguments are terms that can be found in the model frame
of the model fit, as provoke by ANOVA.  Using anova(fit) will elucidate the row
names of the ANOVA that could be used.
</p>


<h3>Value</h3>

<p>Objects of class &quot;ICCstats&quot; return the following:
</p>
<table>
<tr><td><code>ICC_disp</code></td>
<td>
<p>The intraclass correlation coefficient (ICC) based on the dispersion of values.</p>
</td></tr>
<tr><td><code>ICC_mult</code></td>
<td>
<p>The eigenvalues of ICC matrices</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Liljequist, D., Elfving, B., &amp; Skavberg Roaldsen, K. (2019). Intraclass correlationâ€“A discussion 
and demonstration of basic features. PloS one, 14(7), e0219854.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Measurement error analysis on simulated data of fish shapes

data(fishy)

# Analysis unconcerned with groups 

ME1 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  data = fishy)

anova(ME1)
ICCstats(ME1, subjects = "Subjects", with_in = "Systematic ME")

# Analysis concerned with groups 

ME2 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  groups = "groups",
  data = fishy)

anova(ME2)
ICCstats(ME2, subjects = "Subjects", 
  with_in = "Systematic ME", groups = "groups")
ICCstats(ME2, subjects = "Subjects", 
  with_in = c("Systematic ME", "Systematic ME:Groups"), 
  groups = "groups")
  
## End(Not run)
  
</code></pre>

<hr>
<h2 id='interSubVar'>Reveal the inter-subject variability from a measurement error analysis</h2><span id='topic+interSubVar'></span>

<h3>Description</h3>

<p>Function produces both a list of inter-subject Euclidean distance matrices, 
based on replicate measurements of the same subjects, and one matrix that 
summarizes the variability among the inter-subject distances, across subjects.  
This function can be considered a tool for the evaluation of subject 
estimate precision.  The function, <code><a href="#topic+plot.interSubVar">plot.interSubVar</a></code> can produce a 
heat map of the inter-subject variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interSubVar(ME, type = c("range", "sd", "var", "cv"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interSubVar_+3A_me">ME</code></td>
<td>
<p>A measurement error object</p>
</td></tr>
<tr><td><code id="interSubVar_+3A_type">type</code></td>
<td>
<p>A value to indicate the type of variability (statistic)
to measure, which can be
one of range (the maximum value minus the minimum value, not the two values),
standard deviation (sd), variance (var), or coefficient of variation (cv).  No 
attempt is made to assure the distribution of values is appropriate for the 
statistics.  For example, if only two replicates are available, using sd, var, or
cv might not be wise.  Or if the replicated values are exact, cv 
will be NA (and other stats will be 0).  Choice of statistic should consider
the distribution of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>interSubVar</code> is a list containing the 
following
</p>
<table>
<tr><td><code>var.map</code></td>
<td>
<p>A distance matrix object with values that map the variability
statistic used for inter-subject Euclidean distances.</p>
</td></tr>
<tr><td><code>distance.mats</code></td>
<td>
<p>The inter-subject distance matrices for every replicate.</p>
</td></tr>
<tr><td><code>subject.order</code></td>
<td>
<p>A vector of subject levels in the order that was used to
guarantee consistent sorting across distance matrices.</p>
</td></tr>
<tr><td><code>var.map</code></td>
<td>
<p>The variability type (statistic) that was used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Measurement error analysis on simulated data of fish shapes

data(fishy)

# Analysis unconcerned with groups 

ME1 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  data = fishy)

anova(ME1)
ICCstats(ME1, subjects = "Subjects", with_in = "Systematic ME")
plot(ME1)

# Analysis concerned with groups 

ME2 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  groups = "groups",
  data = fishy)

anova(ME2)
ICCstats(ME2, subjects = "Subjects", 
  with_in = "Systematic ME", groups = "groups")
P &lt;- plot(ME2)
focusMEonSubjects(P, subjects = 18:20, shadow = TRUE)
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='lm.rrpp'>Linear Model Evaluation with a Randomized Residual Permutation Procedure</h2><span id='topic+lm.rrpp'></span>

<h3>Description</h3>

<p>Function performs a linear model fit over many random permutations of 
data, using a randomized residual permutation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.rrpp(
  f1,
  iter = 999,
  turbo = FALSE,
  seed = NULL,
  int.first = FALSE,
  RRPP = TRUE,
  full.resid = FALSE,
  block = NULL,
  SS.type = c("I", "II", "III"),
  data = NULL,
  Cov = NULL,
  print.progress = FALSE,
  Parallel = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.rrpp_+3A_f1">f1</code></td>
<td>
<p>A formula for the linear model (e.g., y~x1+x2).  Can also 
be a linear model fit
from <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for significance testing</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_turbo">turbo</code></td>
<td>
<p>A logical value that if TRUE, suppresses coefficient estimation 
in every random permutation.  This will affect subsequent analyses that 
require random coefficients (see <code><a href="#topic+coef.lm.rrpp">coef.lm.rrpp</a></code>)
but might be useful for large data sets for which only ANOVA is needed.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_seed">seed</code></td>
<td>
<p>An optional argument for setting the seed for random 
permutations of the resampling procedure.
If left NULL (the default), the exact same P-values will be found 
for repeated runs of the analysis (with the same number of iterations).
If seed = &quot;random&quot;, a random seed will be used, and P-values will vary.  
One can also specify an integer for specific seed values,
which might be of interest for advanced users.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_int.first">int.first</code></td>
<td>
<p>A logical value to indicate if interactions of first 
main effects should precede subsequent main effects</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_rrpp">RRPP</code></td>
<td>
<p>A logical value indicating whether residual randomization 
should be used for significance testing</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_full.resid">full.resid</code></td>
<td>
<p>A logical value for whether to use the full model residuals, only 
(sensu ter Braak, 1992). This only works if RRPP = TRUE and SS.type = III.  
Rather than permuting reduced model residuals,
this option permutes only the full model residuals in every random permutation of RRPP.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_block">block</code></td>
<td>
<p>An optional factor for blocks within which to restrict resampling
permutations.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_ss.type">SS.type</code></td>
<td>
<p>A choice between type I (sequential), type II 
(hierarchical), or type III (marginal)
sums of squares and cross-products computations.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_data">data</code></td>
<td>
<p>A data frame for the function environment, see 
<code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code></p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_cov">Cov</code></td>
<td>
<p>An optional argument for including a covariance matrix 
to address the non-independence
of error in the estimation of coefficients (via GLS).  If included, 
any weights are ignored.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_print.progress">print.progress</code></td>
<td>
<p>A logical value to indicate whether a progress 
bar should be printed to the screen.
This is helpful for long-running analyses.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_parallel">Parallel</code></td>
<td>
<p>Either a logical value to indicate whether parallel processing 
should be used, a numeric value to indicate the number of cores to use, or a predefined
socket cluster.  This argument defines parallel processing via the <code>parallel</code> library. 
If TRUE, this argument invokes forking or socket cluster assignment of all processor cores, 
except one.  If FALSE, only one core is used. A numeric value directs the number of cores to 
use, but one core will always be spared.  If a predefined socket cluster (Windows) is provided,
the cluster information will be passed to <code>parallel</code>.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_verbose">verbose</code></td>
<td>
<p>A logical value to indicate if all possible output from an analysis 
should be retained.  Generally this should be FALSE, unless one wishes to extract, e.g.,
all possible terms, model matrices, QR decomposition, or random permutation schemes.</p>
</td></tr>
<tr><td><code id="lm.rrpp_+3A_...">...</code></td>
<td>
<p>Arguments typically used in <code><a href="stats.html#topic+lm">lm</a></code>, such as 
weights or offset, passed on to
<code>LM.fit</code> (an internal RRPP function) for estimation of coefficients.  
If both weights and 
a covariance matrix are included,
weights are ignored (since inverses of weights are the diagonal elements 
of weight matrix, used in lieu
of a covariance matrix.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a linear model using ordinary least squares (OLS) or 
generalized least squares (GLS) estimation of coefficients over any 
number of random permutations of the data.  A permutation procedure that 
randomizes vectors of residuals is employed.  This
procedure can randomize two types of residuals: residuals from null 
models or residuals from
an intercept model.  The latter is the same as randomizing full values, 
and is referred to as
as a full randomization permutation procedure (FRPP); the former uses 
the residuals from null
models, which are defined by the type of sums of squares and cross-products 
(SSCP) sought in an
analysis of variance (ANOVA), and is referred to as a randomized residual 
permutation procedure (RRPP).
Types I, II, and III SSCPs are supported.
</p>
<p>Users define the SSCP type, the permutation procedure type, whether a 
covariance matrix is included
(GLS estimation), and a few arguments related to computations.   
Results comprise observed linear model
results (coefficients, fitted values, residuals, etc.), random sums of 
squares (SS) across permutation iterations,
and other parameters for performing ANOVA and other hypothesis tests, 
using empirically-derived probability distributions.
</p>
<p><code>lm.rrpp</code> emphasizes estimation of standard deviates of observed 
statistics as effect sizes
from distributions of random outcomes.  When performing ANOVA, using 
the <code><a href="stats.html#topic+anova">anova</a></code> function,
the effect type (statistic choice) can be varied.  See 
<code><a href="#topic+anova.lm.rrpp">anova.lm.rrpp</a></code> for more details.  Please
recognize that the type of SS must be chosen prior to running 
<code>lm.rrpp</code> and not when applying <code><a href="stats.html#topic+anova">anova</a></code>
to the <code>lm.rrpp</code> fit, as design matrices for the linear model 
must be created first.  Therefore, SS.type
is an argument for <code>lm.rrpp</code> and effect.type is an argument for 
<code><a href="#topic+anova.lm.rrpp">anova.lm.rrpp</a></code>.  If MANOVA
statistics are preferred, eigenvalues can be added with 
<code><a href="#topic+manova.update">manova.update</a></code> and statistics summarized with
<code><a href="#topic+summary.manova.lm.rrpp">summary.manova.lm.rrpp</a></code>.  See <code><a href="#topic+manova.update">manova.update</a></code> 
for examples.
</p>
<p>The <code><a href="#topic+coef.lm.rrpp">coef.lm.rrpp</a></code> function can be used to test the specific 
coefficients of an lm.rrpp fit.  The test
statistics are the distances (d), which are also standardized (Z-scores).  
The Z-scores might be easier to compare,
as the expected values for random distances can vary among coefficient 
vectors (Adams and Collyer 2016).
</p>


<h4>ANOVA vs. MANOVA</h4>

 
<p>Two SSCP matrices are calculated for each linear model effect, for 
every random permutation: R (Residuals or Random effects) and
H, the difference between SSCPs for &quot;full&quot; and &quot;reduced&quot; models. 
(Full models contain and reduced models lack
the effect tested; SSCPs are hypothesized to be the same under a 
null hypothesis, if there is no effect.  The 
difference, H, would have a trace of 0 if the null hypothesis were 
true.)  In RRPP, ANOVA and MANOVA correspond to
two different ways to calculate statistics from R and H matrices.
</p>
<p>ANOVA statistics are those that find the trace of R and H SSCP 
matrices before calculating subsequent statistics,
including sums of squares (SS), mean squares (MS), and F-values.  
These statistics can be calculated with univariate data
and provide univariate-like statistics for multivariate data.  
These statistics are dispersion measures only (covariances
among variables do not contribute) and are the same as &quot;distance-based&quot; 
stats proposed by Goodall (1991) and Anderson (2001).
MANOVA stats require multivariate data and are implicitly affected 
by variable covariances.  For MANOVA, the inverse of R times
H (invR.H) is first calculated for each effect, then eigenanalysis 
is performed on these matrix products.  Multivariate
statistics are calculated from the positive, real eigenvalues.  In 
general, inferential
conclusions will be similar with either approach, but effect sizes 
might differ.
</p>
<p>ANOVA tables are generated by <code><a href="#topic+anova.lm.rrpp">anova.lm.rrpp</a></code> on lm.rrpp 
fits and MANOVA tables are generated
by <code><a href="#topic+summary.manova.lm.rrpp">summary.manova.lm.rrpp</a></code>, after running manova.update 
on lm.rrpp fits.
</p>
<p>Currently, mixed model effects are only possible with $ANOVA statistics, 
not $MANOVA.
</p>
<p>More detail is found in the vignette, ANOVA versus MANOVA.
</p>



<h4>Notes for RRPP 0.5.0 and subsequent versions</h4>

 
<p>The output from lm.rrpp has changed, compared to previous versions.  
First, the $LM
component of output no longer includes both OLS and GLS statistics, 
when GLS fits are 
performed.  Only GLS statistics (coefficients, residuals, fitted values) 
are provided 
and noted with a &quot;gls.&quot; tag.  GLS statistics can include those calculated
when weights are input (similar to the <code><a href="stats.html#topic+lm">lm</a></code> argument).  
Unlike previous 
versions, GLS and weighted LS statistics are not labeled differently, 
as weighted
LS is one form of generalized LS estimation.  Second, a new object, 
$Models, is included
in output, which contains the linear model fits (<code><a href="stats.html#topic+lm">lm</a></code> 
attributes ) for
all reduced and full models that are possible to estimate fits.
</p>



<h4>Notes for RRPP 0.3.1 and subsequent versions</h4>

 
<p>F-values via RRPP are calculated with residual SS (RSS) found uniquely 
for any model terms, as per
Anderson and ter Braak (2003).  This method uses the random pseudo-data 
generated by each term's
null (reduced) model, meaning RSS can vary across terms.  Previous 
versions used an intercept-only 
model for generating random pseudo-data.  This generally has appropriate 
type I error rates but can have
elevated type I error rates if the observed RSS is small relative 
to total SS.  Allowing term by term
unique RSS alleviates this concern.
</p>



<h3>Value</h3>

<p>An object of class <code>lm.rrpp</code> is a list containing the 
following
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>LM</code></td>
<td>
<p>Linear Model objects, including data (Y), coefficients, 
design matrix (X), sample size
(n), number of dependent variables (p), dimension of data space (p.prime),
QR decomposition of the design matrix, fitted values, residuals,
weights, offset, model terms, data (model) frame, random coefficients 
(through permutations),
random vector distances for coefficients (through permutations), 
whether OLS or GLS was performed, 
and the mean for OLS and/or GLS methods. Note that the data returned 
resemble a model frame rather than 
a data frame; i.e., it contains the values used in analysis, which 
might have been transformed according to 
the formula.  The response variables are always labeled Y.1, Y.2, ..., 
in this frame.</p>
</td></tr>
<tr><td><code>ANOVA</code></td>
<td>
<p>Analysis of variance objects, including the SS type, 
random SS outcomes, random MS outcomes,
random R-squared outcomes, random F outcomes, random Cohen's f-squared 
outcomes, P-values based on random F
outcomes, effect sizes for random outcomes, sample size (n), number of 
variables (p), and degrees of freedom for
model terms (df).  These objects are used to construct ANOVA tables.</p>
</td></tr>
<tr><td><code>PermInfo</code></td>
<td>
<p>Permutation procedure information, including the number 
of permutations (perms), The method
of residual randomization (perm.method), and each permutation's sampling 
frame (perm.schedule), which
is a list of reordered sequences of 1:n, for how residuals were 
randomized.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Reduced and full model fits for every possible model 
combination, based on terms
of the entire model, plus the method of SS estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Anderson MJ. 2001. A new method for non-parametric 
multivariate analysis of variance.
Austral Ecology 26: 32-46.
</p>
<p>Anderson MJ. and C.J.F. ter Braak. 2003. Permutation 
tests for multi-factorial analysis of variance. Journal of Statistical 
Computation and Simulation 73: 85-113.
</p>
<p>Collyer, M.L., D.J. Sekora, and D.C. Adams. 2015. A method 
for analysis of phenotypic change for phenotypes described
by high-dimensional data. Heredity. 115:357-365.
</p>
<p>Adams, D.C. and M.L. Collyer. 2016.  On the comparison of 
the strength of morphological integration across morphometric
datasets. Evolution. 70:2623-2631.
</p>
<p>Adams, D.C and M.L. Collyer. 2018. Multivariate phylogenetic 
anova: group-clade aggregation, biological 
challenges, and a refined permutation procedure. Evolution. 72:1204-1215.
</p>
<p>ter Braak, C.J.F. 1992. Permutation versus bootstrap significance tests in 
multiple regression and ANOVA. pp .79â€“86 In Bootstrapping and Related Techniques. eds K-H. Jockel, 
G. Rothe &amp; W. Sendler.Springer-Verlag, Berlin.
<code><a href="stats.html#topic+lm">lm</a></code> for more on linear model fits.
</p>


<h3>See Also</h3>

<p><code>procD.lm</code> and <code>procD.pgls</code> within <code>geomorph</code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Examples use geometric morphometric data
# See the package, geomorph, for details about obtaining such data

data("PupfishHeads")
names(PupfishHeads)

# Head Size Analysis (Univariate)-------------------------------------------------------

fit &lt;- lm.rrpp(log(headSize) ~ sex + locality/year, SS.type = "I", 
data = PupfishHeads, print.progress = FALSE, iter = 999)
summary(fit)
anova(fit, effect.type = "F") # Maybe not most appropriate
anova(fit, effect.type = "Rsq") # Change effect type, but still not 
# most appropriate

# Mixed-model approach (most appropriate, as year sampled is a random 
# effect:

anova(fit, effect.type = "F", error = c("Residuals", "locality:year", 
"Residuals"))

# Change to Type III SS

fit &lt;- lm.rrpp(log(headSize) ~ sex + locality/year, SS.type = "III", 
data = PupfishHeads, print.progress = FALSE, iter = 999,
verbose = TRUE)
summary(fit)
anova(fit, effect.type = "F", error = c("Residuals", "locality:year", 
"Residuals"))

# Coefficients Test

coef(fit, test = TRUE)

# Predictions (holding alternative effects constant)

sizeDF &lt;- data.frame(sex = c("Female", "Male"))
rownames(sizeDF) &lt;- c("Female", "Male")
sizePreds &lt;- predict(fit, sizeDF)
summary(sizePreds)
plot(sizePreds)

# Diagnostics plots of residuals

plot(fit)

# Body Shape Analysis (Multivariate) -----------

data(Pupfish)
names(Pupfish)

# Note:

dim(Pupfish$coords) # highly multivariate!
fit &lt;- lm.rrpp(coords ~ log(CS) + Sex*Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 999,
verbose = TRUE) 
summary(fit, formula = FALSE)
anova(fit) 
coef(fit, test = TRUE)

# Predictions (holding alternative effects constant)

shapeDF &lt;- expand.grid(Sex = levels(Pupfish$Sex), 
Pop = levels(Pupfish$Pop))
rownames(shapeDF) &lt;- paste(shapeDF$Sex, shapeDF$Pop, sep = ".")
shapeDF

shapePreds &lt;- predict(fit, shapeDF)
summary(shapePreds)
summary(shapePreds, PC = TRUE)

# Plot prediction

plot(shapePreds, PC = TRUE)
plot(shapePreds, PC = TRUE, ellipse = TRUE)

# Diagnostics plots of residuals

plot(fit)

# PC-plot of fitted values

groups &lt;- interaction(Pupfish$Sex, Pupfish$Pop)
plot(fit, type = "PC", pch = 19, col = as.numeric(groups))

# Regression-like plot

plot(fit, type = "regression", reg.type = "PredLine", 
    predictor = log(Pupfish$CS), pch=19,
    col = as.numeric(groups))

# Body Shape Analysis (Distances) ----------

D &lt;- dist(Pupfish$coords) # inter-observation distances
length(D)
Pupfish$D &lt;- D

fitD &lt;- lm.rrpp(D ~ log(CS) + Sex*Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 999) 

# These should be the same:
summary(fitD, formula = FALSE)
summary(fit, formula = FALSE) 

# GLS Example (Univariate) -----------

data(PlethMorph)
fitOLS &lt;- lm.rrpp(TailLength ~ SVL, data = PlethMorph, 
print.progress = FALSE, iter = 999)
fitGLS &lt;- lm.rrpp(TailLength ~ SVL, data = PlethMorph, Cov = PlethMorph$PhyCov, 
print.progress = FALSE, iter = 999)

anova(fitOLS)
anova(fitGLS)

sizeDF &lt;- data.frame(SVL = sort(PlethMorph$SVL))

# Prediction plots

# By specimen
plot(predict(fitOLS, sizeDF)) # Correlated error
plot(predict(fitGLS, sizeDF)) # Independent error

# With respect to independent variable (using abscissa)
plot(predict(fitOLS, sizeDF), abscissa = sizeDF) # Correlated error
plot(predict(fitGLS, sizeDF), abscissa = sizeDF) # Independent error


# GLS Example (Multivariate) -----------

Y &lt;- as.matrix(cbind(PlethMorph$TailLength,
PlethMorph$HeadLength,
PlethMorph$Snout.eye,
PlethMorph$BodyWidth,
PlethMorph$Forelimb,
PlethMorph$Hindlimb))
PlethMorph$Y &lt;- Y
fitOLSm &lt;- lm.rrpp(Y ~ SVL, data = PlethMorph, 
print.progress = FALSE, iter = 999)
fitGLSm &lt;- lm.rrpp(Y ~ SVL, data = PlethMorph, 
Cov = PlethMorph$PhyCov,
print.progress = FALSE, iter = 999)

anova(fitOLSm)
anova(fitGLSm)

# Prediction plots

# By specimen
plot(predict(fitOLSm, sizeDF)) # Correlated error
plot(predict(fitGLSm, sizeDF)) # Independent error

# With respect to independent variable (using abscissa)
plot(predict(fitOLSm, sizeDF), abscissa = sizeDF) # Correlated error
plot(predict(fitGLSm, sizeDF), abscissa = sizeDF) # Independent error

## End(Not run)
</code></pre>

<hr>
<h2 id='lm.rrpp.ws'>Linear Model Evaluation with RRPP performed within subjects</h2><span id='topic+lm.rrpp.ws'></span>

<h3>Description</h3>

<p>Function performs a linear model fit over many random permutations of 
data, using a randomized residual permutation procedure restricted to
subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.rrpp.ws(
  f1,
  subjects,
  iter = 999,
  turbo = FALSE,
  seed = NULL,
  int.first = FALSE,
  RRPP = TRUE,
  data,
  Cov = NULL,
  delta = 0.001,
  gamma = c("sample", "equal"),
  print.progress = FALSE,
  verbose = FALSE,
  Parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.rrpp.ws_+3A_f1">f1</code></td>
<td>
<p>A formula for the linear model (e.g., y~x1+x2).</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_subjects">subjects</code></td>
<td>
<p>A variable that can be found in the data frame indicating the research subjects
for the analysis.  This variable must be in the data frame.  Is can be either numeric 
(if its slot in the data frame is known) or a character, e.g., &quot;sub_id&quot;.  It is imperative that
it is ordered the same as the data but that the data do not have row names the same as subjects.
For example, the subjects variable in the data frame might be sub_id: sub1, sub1, sub1, sub2,
sub2, sub2, ... and the row names of the data might be obs1, obs2, obs3, obs4, obs5, obs6, ...  
The data do not need to have row names but the subjects variable has to be provided.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for significance testing</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_turbo">turbo</code></td>
<td>
<p>A logical value that if TRUE, suppresses coefficient estimation 
in every random permutation.  This will affect subsequent analyses that 
require random coefficients (see <code><a href="#topic+coef.lm.rrpp">coef.lm.rrpp</a></code>)
but might be useful for large data sets for which only ANOVA is needed.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_seed">seed</code></td>
<td>
<p>An optional argument for setting the seed for random 
permutations of the resampling procedure.
If left NULL (the default), the exact same P-values will be found 
for repeated runs of the analysis (with the same number of iterations).
If seed = &quot;random&quot;, a random seed will be used, and P-values will vary.  
One can also specify an integer for specific seed values,
which might be of interest for advanced users.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_int.first">int.first</code></td>
<td>
<p>A logical value to indicate if interactions of first 
main effects should precede subsequent main effects</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_rrpp">RRPP</code></td>
<td>
<p>A logical value indicating whether residual randomization 
should be used for significance testing</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_data">data</code></td>
<td>
<p>A data frame for the function environment, see 
<code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code>.  A data frame is required for this analysis.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_cov">Cov</code></td>
<td>
<p>An optional argument for including a covariance matrix 
to address the non-independence
of error in the estimation of coefficients (via GLS).  If included, 
any weights are ignored.  This matrix must math in dimensions either
the number of subjects or the number of observations.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_delta">delta</code></td>
<td>
<p>A within-subject scaling parameter for covariances, ranging from 
0 to 1.  If delta = 0, a sight value (0.001) is added to assure variances of the 
covariance matrix are 0.1 percent larger than covariances.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_gamma">gamma</code></td>
<td>
<p>A sample-size scaling parameter that is adjusted to be 1 (&quot;equal&quot;)
scaling or the square-root of the sample size for subject observations (&quot;sample&quot;).</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_print.progress">print.progress</code></td>
<td>
<p>A logical value to indicate whether a progress 
bar should be printed to the screen.
This is helpful for long-running analyses.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_verbose">verbose</code></td>
<td>
<p>A logical value to indicate if all possible output from an analysis 
should be retained. Generally this should be FALSE, unless one wishes to extract, 
e.g., all possible terms, model matrices, QR decomposition, or random permutation 
schemes.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_parallel">Parallel</code></td>
<td>
<p>Either a logical value to indicate whether parallel processing 
should be used, a numeric value to indicate the number of cores to use, or a predefined
socket cluster.  This argument defines parallel processing via the <code>parallel</code> library. 
If TRUE, this argument invokes forking or socket cluster assignment of all processor cores, 
except one.  If FALSE, only one core is used. A numeric value directs the number of cores to 
use, but one core will always be spared.  If a predefined socket cluster (Windows) is provided,
the cluster information will be passed to <code>parallel</code>.</p>
</td></tr>
<tr><td><code id="lm.rrpp.ws_+3A_...">...</code></td>
<td>
<p>Arguments typically used in <code><a href="stats.html#topic+lm">lm</a></code>, such as 
weights or offset, passed on to
<code>lm.rrpp</code> for estimation of coefficients.  If both weights and 
a covariance matrix are included,
weights are ignored (since inverses of weights are the diagonal elements 
of weight matrix, used in lieu
of a covariance matrix.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a linear model using ordinary least squares (OLS) or 
generalized least squares (GLS) estimation of coefficients over any 
number of random permutations of the data, but the permutations are mostly 
restricted to occur with subject blocks for any model terms other than subjects.  
All functionality should resemble that of <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.  However, 
an argument for research subjects is also required.  The purpose of this function 
is to account for the non-independence among observations of research subjects 
(due to sampling within subjects), while also allowing for the non-independence 
among subjects to be considered (Adams and Collyer, submitted).  
</p>
<p>By comparison, the covariance matrix option in <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> must have a
one-to-one match to observations, which can be matched by the row names of the data.
In this function, the covariance matrix can be the same one used in <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>
but the number of observations can be greater.  For example, if subjects are
species or some other level of taxonomic organization, data can comprise measurements
on individuals.  Users have the option to expand the covariance matrix for subjects
or input one they have generated.
</p>
<p>Irrespective of covariance matrix type, the row names of the data matrix must match the
subjects.  This step assures that the analysis can proceed in <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.  It
is also best to make sure to use an <code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code>, so that the subjects
can be a name in that data frame.  For example, if research subjects are species and
data (observations) are collected from individuals within species, then a procedure like 
the following should produce results:
</p>
<p>rownames(Y) &lt;- species
</p>
<p>rdf &lt;- rrpp.data.frame(Y = Y, subjects = species, x = x)
</p>
<p>fit &lt;- lm.rrpp.ws(Y ~ species * x, subject = species, data = rdf, Cov = myCov, ...)
</p>
<p>where ... means other arguments.  The covariances in the the Covariance matrix can be 
sorted by the subjects factor but data will not be sorted.  Therefore, names matching
the subjects is essential.  Additionally, subjects must be a factor in the data frame
or a factor in the global environment.  It cannot be part of a list.  Something like
subjects &lt;- mylist$species will not work.  Assuring that data and subjects are in the 
same <code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code> object as data is the best way to avoid errors.
</p>
<p>Most attributes for this analysis are explained with <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.  
The notable different attributes for this function are that: (1) a covariance 
matrix for the non-independence of subjects can be either a symmetric matrix 
that matches in dimensions the number of subjects or the number of observations; 
(2) a parameter (delta) that can range between near 0 and 1 to calibrate the 
covariances between observations of different subjects; and (3) a 
parameter (gamma) that is either 1 (equal) or the square-root of the subject 
sample size (sample) to calibrate the covariances among observations 
within subjects.  If delta = 0, it is expected that the covariance between
individual observations, between subjects, is the same as expected from the
covariance matrix, as if observations were the single observations made on subjects.
As delta approaches 1, the observations become more independent, as if it is 
expected that the many observations would not be expected to be
as correlated as if from one observation.  Increasing delta might be useful, if, 
for example, many individuals are sampled within species, from different locations,
different age groups, etc.  Alternatively, the sample size (n_i) for subject i 
can also influence the trend of inter-subject covariances.  If more individual
observations are sampled, the correlation between subjects might be favored
to be smaller compared to fewer observations.  The covariances can be adjusted
to allow for greater independence among observations to be assumed for larger samples.
</p>
<p>A design matrix, <b>X</b>, is constructed with 0s and 1s to indicate subjects association,
and it is used to expand the covariance matrix (<b>C</b>) by <b>XCt(X)</b>, where <b>t(X)</b>
is the matrix transpose.  The parameters in <b>X</b> are multiplied by exp(-delta * gamma)
to scale the covariances.  (If delta = 0 and gamma = 1, they are unscaled.)  
</p>
<p>These options for scaling covariances could be important for data with 
hierarchical organization.
For example, data sampled from multiple species with expected covariances 
among species based on phylogenetic distances, might be expected to not covary as
strongly if sampling encounters other strata like population, sex, and age.
An a priori expectation is that covariances among observations would be expected to
be smaller than between species, if only one observation per species were made.
</p>
<p>If one wishes to have better control over between-subject and within-subject
covariances, based on either a model or empirical knowledge, a covariance matrix should 
be generated prior to analysis.  One can input a covariance matrix with dimensions 
the same as <b>XCt(X)</b>, if they prefer to define covariances in an alternative way.
A function to generate such matrices based on separate
inter-subject and intra-subject covariance matrices is forthcoming.
</p>
<p>IMPORTANT.  It is assumed that either the levels of the covariance matrix (if 
subject by subject) match the subject levels in the subject argument, or that
the order of the covariance matrix (if observation by observation) matches the order
of the observations in the data.  
No attempt is made to reorder a covariance matrix by observations
and row-names of data are not used to re-order the covariance matrix.  If the
covariance matrix is small (same in dimension as the number of subject levels), the function
will compile a large covariance matrix that is correct in terms of order, but
this is based on the subjects argument, only.
</p>
<p>The covariance matrix is important for describing the expected covariances
among observations, especially knowing observations between and within subjects 
are not independent.  However, the randomization of residuals in a permutation
procedure (RRPP) is also important for testing inter-subject and 
intra-subject effects.  There are two RRPP philosophies used.  If the
variable for subjects is part of the formula, the subject effect is evaluated with
type III sums of squares and cross-products (estimates SSCPs between a model with all
terms and a model lacking subject term), and RRPP performed for all residuals of the
reduced model.  Effects for all other terms are evaluated with type II SSCPs and RRPP
restricted to randomization of reduced model residuals, within subject blocks.  This
assures that subject effects are held constant across permutations, so that intra-subject
effects are not confounded by inter-subject effects.
</p>
<p>More details will be made and examples provided after publication of articles introducing 
the novel RRPP approach.
</p>
<p>The <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> arguments not available for this function include: 
full.resid, block, and SS.type.  These arguments are fixed because of
the within-subject blocking for tests, plus the requirement for type II SS
for within-subject effects.
</p>


<h3>Value</h3>

<p>An object of class <code>lm.rrpp.ws</code> is a list containing the 
following
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>LM</code></td>
<td>
<p>Linear Model objects, including data (Y), coefficients, 
design matrix (X), sample size
(n), number of dependent variables (p), dimension of data space (p.prime),
QR decomposition of the design matrix, fitted values, residuals,
weights, offset, model terms, data (model) frame, random coefficients 
(through permutations),
random vector distances for coefficients (through permutations), 
whether OLS or GLS was performed, 
and the mean for OLS and/or GLS methods. Note that the data returned 
resemble a model frame rather than 
a data frame; i.e., it contains the values used in analysis, which 
might have been transformed according to 
the formula.  The response variables are always labeled Y.1, Y.2, ..., 
in this frame.</p>
</td></tr>
<tr><td><code>ANOVA</code></td>
<td>
<p>Analysis of variance objects, including the SS type, 
random SS outcomes, random MS outcomes,
random R-squared outcomes, random F outcomes, random Cohen's f-squared 
outcomes, P-values based on random F
outcomes, effect sizes for random outcomes, sample size (n), number of 
variables (p), and degrees of freedom for
model terms (df).  These objects are used to construct ANOVA tables.</p>
</td></tr>
<tr><td><code>PermInfo</code></td>
<td>
<p>Permutation procedure information, including the number 
of permutations (perms), The method
of residual randomization (perm.method), and each permutation's sampling 
frame (perm.schedule), which
is a list of reordered sequences of 1:n, for how residuals were 
randomized.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Reduced and full model fits for every possible model 
combination, based on terms
of the entire model, plus the method of SS estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Adams, D.C and M.L Collyer. (submitted) Extended phylogenetic regression models for 
comparing within-species patterns across the Tree of Life. 
Methods in Ecology and Evolution
</p>
<p>ter Braak, C.J.F. 1992. Permutation versus bootstrap significance tests in 
multiple regression and ANOVA. pp .79â€“86 In Bootstrapping and Related Techniques. eds K-H. Jockel, 
G. Rothe &amp; W. Sendler.Springer-Verlag, Berlin.
<code><a href="stats.html#topic+lm">lm</a></code> for more on linear model fits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.rrpp">lm.rrpp</a></code>; <code><a href="#topic+measurement.error">measurement.error</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fishy)

suppressWarnings(fit &lt;- lm.rrpp.ws(coords ~ subj + groups * reps,
  subjects = "subj", 
  data = fishy))

anova(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.lm.rrpp'>Calculate the log-likelihood of a lm.rrpp fit</h2><span id='topic+logLik.lm.rrpp'></span>

<h3>Description</h3>

<p><code>logLik.lm.rrpp</code> returns the log-likelihood of
an <code>lm.rrpp</code> object.  Ridge regularization will be performed for 
ill-conditioned or singular residual covariance matrices, but dimension
reduction could be augmented via projection, using the arguments, tol
and pc.no.  See <code><a href="#topic+ordinate">ordinate</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
logLik(object, tol = NULL, pc.no = NULL, Z = TRUE, gls.null = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="logLik.lm.rrpp_+3A_tol">tol</code></td>
<td>
<p>A value indicating the magnitude below which 
components should be omitted, following projection.  See <code><a href="#topic+ordinate">ordinate</a></code> 
for details.</p>
</td></tr>
<tr><td><code id="logLik.lm.rrpp_+3A_pc.no">pc.no</code></td>
<td>
<p>Optionally, a number specifying the maximal number of 
principal components, passed onto <code><a href="#topic+ordinate">ordinate</a></code>, as argument, rank.</p>
</td></tr>
<tr><td><code id="logLik.lm.rrpp_+3A_z">Z</code></td>
<td>
<p>A logical value for whether to calculate Z scores based on RRPP.</p>
</td></tr>
<tr><td><code id="logLik.lm.rrpp_+3A_gls.null">gls.null</code></td>
<td>
<p>A logical value for if a fit has a GLS estimation, should
the null model (intercept) also have a GLS estimation, for estimating Z.  
Should be FALSE if the log-likelihood is measured to compare different GLS
estimations for a covariance matrices</p>
</td></tr>
<tr><td><code id="logLik.lm.rrpp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='looCV'>Diagnostic cross-validation tool for ordination based on fitted values</h2><span id='topic+looCV'></span>

<h3>Description</h3>

<p>Function performs a leave-one-out cross-validation estimate of ordination
scores, which is helpful for determining if apparent &quot;group differences&quot;
in ordination plots arise merely from data dimensionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>looCV(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="looCV_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit.</p>
</td></tr>
<tr><td><code id="looCV_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+ordinate">ordinate</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the strategy of Thioulouse et al. (2021) to perform N
ordinations for N observations, in which each of the N observations are left
out of the estimation of linear model coefficients, but the vector of data for
the left-out observation is projected on the eigenvectors of the fitted values 
obtained from the leave-one-out cross-validation (jackknife) strategy.
The purpose of this diagnostic tool is to determine whether apparent &quot;group differences&quot;
in an ordination plot (using the function, <code><a href="#topic+ordinate">ordinate</a></code>) are
because of high-dimensional data (number of variables exceed number of observations)
rather than real differences.  An apparent group difference is common for high-dimensional
data, when variables are far greater in number than observations (Cardini et al., 2019).
However, leave-one-out cross-validation can help elucidate whether an observed visual 
difference is spurious.
</p>
<p>This function differs from the strategy of Thioulouse et al. (2021) in two important 
ways.  First, this function uses the linear model design from a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>
fit, and can contain any number of independent variables, rather than a single factor 
for groups.  Second, after obtaining leave-one-out cross-validated scores, a Procrustes
alignment between cross-validated scores and &quot;observed&quot; (real) scores is performed, which 
minimizes summed squared distances between the alternative ordinations.  This latter
step assures comparisons are appropriate.
</p>
<p>The type = &quot;PC&quot; plot from <code><a href="#topic+plot.lm.rrpp">plot.lm.rrpp</a></code> has the same scores as obtained
from ordinate(Y, A = H), using the <code><a href="#topic+ordinate">ordinate</a></code> function, where H is a hat
matrix (that can be calculated from <code><a href="#topic+plot.lm.rrpp">plot.lm.rrpp</a></code> output), and Y is a matrix 
of data.  This function updates H for every possible case that one row of Y is left out
(meaning the rotation matrix from <code><a href="#topic+ordinate">ordinate</a></code> is updated N times).  If
the H matrix is robust in spite of dropped data and design matrix parameters, the result
will be similar to the original ordination.  If apparent group differences are spurious,
H will tend to change, as will data projections.
</p>
<p>The functions <code><a href="#topic+summary.looCV">summary.looCV</a></code> and <code><a href="#topic+plot.looCV">plot.looCV</a></code> are essential for 
evaluating results.  These support functions compare eigenvalues and 
projected scores, between observed and cross-validated cases.  
</p>
<p>This function should be viewed as a diagnostic tool and not as a data transformation tool!
The cross-validated scores will not retain Euclidean distances among observations.  This
could cause problems in analyses that substitute cross-validated scores as data.
</p>


<h3>Value</h3>

<p>An object of class <code>looCV</code> is a list containing 
the following
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>List of eigenvalues, for observed and cross-validated cases.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>List of principal component scores, 
for observed and cross-validated cases.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Thioulouse, J., Renaud, S., Dufour, A. B., &amp; Dray, S. (2021). 
Overcoming the Spurious Groups Problem in Between-Group PCA. 
Evolutionary Biology, In press.
</p>
<p>Cardini, A., Oâ€™Higgins, P., &amp; Rohlf, F. J. (2019). Seeing distinct groups 
where there are none: spurious patterns from between-group PCA. 
Evolutionary Biology, 46(4), 303-316.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.looCV">summary.looCV</a></code>, <code><a href="#topic+plot.looCV">plot.looCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with real group differences

data(Pupfish)
fit &lt;- lm.rrpp(coords ~ Pop*Sex, data = Pupfish, iter = 0)
CV1 &lt;- looCV(fit)
summary(CV1)
group &lt;- interaction(Pupfish$Pop, Pupfish$Sex)
plot(CV1, flip = 1, pch = 19, col = group)

# Example with apparent but not real group differences

n &lt;- NROW(Pupfish$coords)
p &lt;- NCOL(Pupfish$coords)
set.seed(1001)
Yr &lt;- matrix(rnorm(n * p), n, p) # random noise

fit2 &lt;-lm.rrpp(Yr ~ Pop*Sex, data = Pupfish, iter = 0)
CV2 &lt;- looCV(fit2)
summary(CV2)
group &lt;- interaction(Pupfish$Pop, Pupfish$Sex)
plot(CV2, pch = 19, col = group) 

</code></pre>

<hr>
<h2 id='lr_test'>Likelihood ratio test for a linear model, based on RRPP</h2><span id='topic+lr_test'></span>

<h3>Description</h3>

<p>Function performs likelihood ratio tests on an lm.rrpp fit, using 
RRPP or FRPP.  Likelihood ratio statistics are calculated for every random 
permutation, and the effect size is estimated from the distribution of 
random statistics.  The likelihood ratio tests has some resemblance to
MANOVA, especially using Wilks' lambda.  Sums of squares and cross-products 
(SSCP) matrices are calculated over the random permutations of 
a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit.  SSCP matrices are 
computed, as are the inverse of R times H (invR.H), where R is a SSCP 
for the residuals or random effects and H is
the difference between SSCP matrices of full and reduced models 
(see <code><a href="#topic+manova.update">manova.update</a></code>).   From invR.H, Wilks lambda is first estimated, and the 
likelihood ratio stat is then estimated as -n * log(Wilks).
</p>
<p>This function does one of two things.  It either performs an update using
<code><a href="#topic+manova.update">manova.update</a></code>, using Wilks' lambda as the test statistic, converting 
Wilks' lambda to likelihood ratio statistics or it uses the results from
a previously performed update to calculate new statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr_test(fit, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr_test_+3A_fit">fit</code></td>
<td>
<p>Linear model fit from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> or a fit
that has already been updated with <code><a href="#topic+manova.update">manova.update</a></code>.</p>
</td></tr>
<tr><td><code id="lr_test_+3A_verbose">verbose</code></td>
<td>
<p>Logical value for whether to include all random 
Wilks' lambda and likelihood ratio statistics from random permutations.</p>
</td></tr>
<tr><td><code id="lr_test_+3A_...">...</code></td>
<td>
<p>Arguments passed onto <code><a href="#topic+manova.update">manova.update</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Adams, D. C., and M. L. Collyer. 2024. Extended phylogenetic 
regression models for comparing within-species patterns across the 
tree of life. Methods in Ecology and Evolution. In review.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Body Shape Analysis (Multivariate) ----------------

## Not run: 
data(Pupfish)

# Although not recommended as a practice, this example will use only
# three principal components of body shape for demonstration.  
# A larger number of random permutations should also be used.

Pupfish$shape &lt;- ordinate(Pupfish$coords)$x[, 1:3]


fit &lt;- lm.rrpp(shape ~ log(CS) + Sex, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 499) 
summary(fit, formula = FALSE)
anova(fit) # ANOVA table

# MANOVA

fit.m &lt;- manova.update(fit, print.progress = FALSE, tol = 0.001)
summary(fit.m, test = "Roy")
summary(fit.m, test = "Wilks")


# Likelihood Ratio Test

LRT &lt;- lr_test(fit.m)
summary(LRT)


## End(Not run)
</code></pre>

<hr>
<h2 id='manova.update'>MANOVA update for lm.rrpp model fits</h2><span id='topic+manova.update'></span>

<h3>Description</h3>

<p>Function updates a lm.rrpp fit to add $MANOVA, which like 
$ANOVA, provides statistics
or matrices typically associated with multivariate analysis 
of variance (MANOVA).
</p>
<p>MANOVA statistics or sums of squares and cross-products (SSCP) matrices
are calculated over the random permutations of a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> 
fit.  SSCP matrices are 
computed, as are the inverse of R times H (invR.H), where R is a SSCP 
for the residuals or random effects and H is
the difference between SSCP matrices of full and reduced models 
(see below).   From invR.H,
MANOVA statistics are calculated, including Roy's maximum root 
(eigenvalue), Pillai trace, Hotelling-Lawley trace,
and Wilks lambda (via <code><a href="#topic+summary.manova.lm.rrpp">summary.manova.lm.rrpp</a></code>).
</p>
<p>The manova.update to add $MANOVA to <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fits 
requires more computation time than the $ANOVA
statistics that are computed automatically in <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.  
Generally, the same inferential conclusions will
be found with either approach, when observations outnumber response 
variables.  For high-dimensional data (more variables
than observations) data are projected into a Euclidean space of 
appropriate dimensions (rank of residual covariance matrix).  
One can vary the tolerance for eigenvalue decay or specify the number 
of PCs, if a smaller set of PCs than the maximum is desired.  
This is advised if there is strong correlation among variables 
(the data space could be simplified to fewer dimensions), as spurious
results are possible.  Because distributions of MANOVA stats 
can be generated from the random permutations,
there is no need to approximate F-values, like with parametric MANOVA. 
By restricting analysis to the real, positive eigenvalues calculated,
all statistics can be calculated (but Wilks lambda, as a product but 
not a trace, might be less reliable as variable number approaches
the number of observations).
</p>


<h4>ANOVA vs. MANOVA</h4>

 
<p>Two SSCP matrices are calculated for each linear model effect, for 
every random permutation: R (Residuals or Random effects) and
H, the difference between SSCPs for &quot;full&quot; and &quot;reduced&quot; models. 
(Full models contain and reduced models lack
the effect tested; SSCPs are hypothesized to be the same under 
a null hypothesis, if there is no effect.  The 
difference, H, would have a trace of 0 if the null hypothesis 
were true.)  In RRPP, ANOVA and MANOVA correspond to
two different ways to calculate statistics from R and H matrices.
</p>
<p>ANOVA statistics are those that find the trace of R and H SSCP 
matrices before calculating subsequent statistics,
including sums of squares (SS), mean squares (MS), and F-values.  
These statistics can be calculated with univariate data
and provide univariate-like statistics for multivariate data.  
These statistics are dispersion measures only (covariances
among variables do not contribute) and are the same as &quot;distance-based&quot; 
stats proposed by Goodall (1991) and Anderson (2001).
MANOVA stats require multivariate data and are implicitly 
affected by variable covariances.  For MANOVA, the inverse of R times
H (invR.H) is first calculated for each effect, then eigen-analysis 
is performed on these matrix products.  Multivariate
statistics are calculated from the positive, real eigenvalues.  
In general, inferential
conclusions will be similar with either approach, but effect 
sizes might differ.
</p>
<p>Two important differences between manova.update and 
<code><a href="stats.html#topic+summary.manova">summary.manova</a></code> (for <code><a href="stats.html#topic+lm">lm</a></code> objects) 
are that manova.update
does not attempt to normalize residual SSCP matrices (unneeded 
for non-parametric statistical solutions) and (2) uses a generalized
inverse of the residual SSCP, if needed, when the number of 
variables could render eigen-analysis problematic.  This approach 
is consistent
with covariance regularization methods that attempt to make covariance 
matrices positive-definite for calculating model likelihoods or
multivariate statistics.  If the number of observations far exceeds 
the number of response variables, observed statistics from 
manova.update and 
<code><a href="stats.html#topic+summary.manova">summary.manova</a></code> will be quite similar.  If the 
number of response variables approaches or exceeds the number 
of observations, manova.update
statistics will be much more reliable.
</p>
<p>ANOVA tables are generated by <code><a href="#topic+anova.lm.rrpp">anova.lm.rrpp</a></code> on 
lm.rrpp fits and MANOVA tables are generated
by <code><a href="#topic+summary.manova.lm.rrpp">summary.manova.lm.rrpp</a></code>, after running 
manova.update on lm.rrpp fits.
</p>
<p>Currently, mixed model effects are only possible with 
$ANOVA statistics, not $MANOVA.
</p>
<p>More detail is found in the vignette, ANOVA versus MANOVA.  
</p>



<h3>Usage</h3>

<pre><code class='language-R'>manova.update(
  fit,
  error = NULL,
  tol = 1e-07,
  PC.no = NULL,
  print.progress = TRUE,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manova.update_+3A_fit">fit</code></td>
<td>
<p>Linear model fit from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="manova.update_+3A_error">error</code></td>
<td>
<p>An optional character string to define R matrices 
used to calculate invR.H.
(Currently only Residuals can be used and this argument defaults 
to NULL.  Future versions
will update this argument.)</p>
</td></tr>
<tr><td><code id="manova.update_+3A_tol">tol</code></td>
<td>
<p>A tolerance value for culling data dimensions to 
prevent spurious results.  The distribution
of eigenvalues for the data will be examined and if the decay 
becomes less than the tolerance,
the data will be truncated to principal components ahead of this 
point.  This will possibly prevent spurious results
calculated from eigenvalues near 0.  If tol = 0, all possible 
PC axes are used, which is likely
not a problem if observations outnumber variables.  If tol = 0 
and the number of variables exceeds the number of observations,
the value of tol will be made slightly positive to prevent problems 
with eigen-analysis.</p>
</td></tr>
<tr><td><code id="manova.update_+3A_pc.no">PC.no</code></td>
<td>
<p>A value that, if not NULL, can override the tolerance 
argument, and forces a desired number of 
data PCs to use for analysis.  If a value larger than the possible 
number of PCs is chosen, the full compliment of PCs
(the full data space) will be used.  If a number larger than tol 
would permit is chosen, the minimum number of PCs between the tol
argument and PC.no argument is returned.</p>
</td></tr>
<tr><td><code id="manova.update_+3A_print.progress">print.progress</code></td>
<td>
<p>A logical value to indicate whether a 
progress bar should be printed to the screen.
This is helpful for long-running analyses.</p>
</td></tr>
<tr><td><code id="manova.update_+3A_verbose">verbose</code></td>
<td>
<p>Either a NULL or logical value for whether to retain
all MANOVA result (if TRUE).  If NULL, the verbose argument used for
the <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> is retained for MANOVA update.  Essentially,
verbose indicates whether to retain all SSCP matrices and all invR.H matrices,
for every model effect, in every RRPP iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lm.rrpp</code> is updated to include 
class <code>manova.lm.rrpp</code>, and the object,
$MANOVA, which includes
</p>
<table>
<tr><td><code>SSCP</code></td>
<td>
<p>Terms and Model SSCP matrices.</p>
</td></tr>
<tr><td><code>invR.H</code></td>
<td>
<p>The inverse of the residuals SSCP times the H SSCP.</p>
</td></tr>
<tr><td><code>eigs</code></td>
<td>
<p>The eigenvalues of invR.H.</p>
</td></tr>
<tr><td><code>e.rank</code></td>
<td>
<p>Rank of the error (residuals) covariance matrix.  
Currently NULL only.</p>
</td></tr>
<tr><td><code>PCA</code></td>
<td>
<p>Principal component analysis of data, using either tol 
or PC.no.</p>
</td></tr>
<tr><td><code>manova.pc.dims</code></td>
<td>
<p>Resulting number of PC vectors in the 
analysis.</p>
</td></tr>
<tr><td><code>e.rank</code></td>
<td>
<p>Rank of the residual (error) covariance matrix, 
irrespective of the number of dimensions 
used for analysis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Goodall, C.R. 1991. Procrustes methods in the 
statistical analysis of shape. Journal of the Royal Statistical 
Society B 53:285-339.
</p>
<p>Anderson MJ. 2001. A new method for non-parametric 
multivariate analysis of variance.
Austral Ecology 26: 32-46.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Body Shape Analysis (Multivariate) ----------------

data(Pupfish)

# Although not recommended as a practice, this example will use only
# three principal components of body shape for demonstration.  
# A larger number of random permutations should also be used.

Pupfish$shape &lt;- ordinate(Pupfish$coords)$x[, 1:3]

Pupfish$logSize &lt;- log(Pupfish$CS) 

fit &lt;- lm.rrpp(shape ~ logSize + Sex, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 499) 
summary(fit, formula = FALSE)
anova(fit) # ANOVA table

# MANOVA

fit.m &lt;- manova.update(fit, print.progress = FALSE, tol = 0.001)
summary(fit.m, test = "Roy")
summary(fit.m, test = "Pillai")

fit.m$MANOVA$eigs$obs # observed eigenvalues
fit.m$MANOVA$SSCP$obs # observed SSCP
fit.m$MANOVA$invR.H$obs # observed invR.H 

# Distributions of test statistics

summ.roy &lt;- summary(fit.m, test = "Roy")
dens &lt;- apply(summ.roy$rand.stats, 1, density)
par(mfcol = c(1, length(dens)))
for(i in 1:length(dens)) {
     plot(dens[[i]], xlab = "Roy max root", ylab = "Density",
     type = "l", main = names(dens)[[i]])
     abline(v = summ.roy$rand.stats[1, i], col = "red")
}
par(mfcol = c(1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='measurement.error'>Evaluation of measurement error for two or more multivariate measurements, 
for common research subjects</h2><span id='topic+measurement.error'></span>

<h3>Description</h3>

<p>Function performs analyses concerned with the repeatability (reliability) of multivariate data 
(measurements) collected from the same research subjects.  Although there is no
requirement for repeated measurements on all research subjects, the analysis assumes
that multiple observations are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurement.error(
  Y,
  subjects,
  replicates,
  groups = NULL,
  data,
  iter = 999,
  seed = NULL,
  multivariate = FALSE,
  use.PCs = TRUE,
  tol = 0.001,
  Parallel = FALSE,
  turbo = TRUE,
  print.progress = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurement.error_+3A_y">Y</code></td>
<td>
<p>A matrix (n x p) of data for n observations and p variables.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_subjects">subjects</code></td>
<td>
<p>A vector or factor of research subjects (each subject should occur twice or more).
The length of the vector must equal the number of observations and will be coerced into a factor.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_replicates">replicates</code></td>
<td>
<p>A vector or factor for replicate measurements for research subjects.
The length of the vector must equal the number of observations and will be coerced into a factor.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_groups">groups</code></td>
<td>
<p>An optional vector, coercible to factor, to be included in the linear model
(as an interaction with replicates)..
This would be of interest if one were concerned with systematic ME occurring perhaps differently among 
certain strata within the data.  For example, systematic ME because of an observer bias might
only be observed with females or males.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_data">data</code></td>
<td>
<p>An optional data frame, either of class <code><a href="base.html#topic+data.frame">data.frame</a></code> or
class <code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for significance testing</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_seed">seed</code></td>
<td>
<p>An optional argument for setting the seed for random 
permutations of the resampling procedure.
If left NULL (the default), the exact same P-values will be found 
for repeated runs of the analysis (with the same number of iterations).
If seed = &quot;random&quot;, a random seed will be used, and P-values will vary.  
One can also specify an integer for specific seed values,
which might be of interest for advanced users.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_multivariate">multivariate</code></td>
<td>
<p>Logical value for whether to include multivariate analyses.  Intraclass correlation 
matrices and relative eigenanalysis are based on products of sums of squares and cross-products (SSCP)
matrices, some of which must be inverted and potentially require
significant computation time.  If FALSE, only statistics based on dispersion of values are calculated.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_use.pcs">use.PCs</code></td>
<td>
<p>A logical argument for whether to use the principal components of the data.
This might be helpful for relative eigenanalysis, and if p &gt; n, 
in which case inverting singular covariance matrices would not be possible.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_tol">tol</code></td>
<td>
<p>A value indicating the magnitude below which 
components should be omitted., if use.PCs is TRUE. (Components are omitted if their 
standard deviations are less than or equal to tol times the 
standard deviation of the first component.)  See <code><a href="#topic+ordinate">ordinate</a></code> for more details.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_parallel">Parallel</code></td>
<td>
<p>The same argument as in <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> to govern parallel processing (
either a logical vale &ndash; TRUE or FALSE &ndash; or the number of threaded cores to use).  See <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> 
for additional details.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_turbo">turbo</code></td>
<td>
<p>Logical value for whether to suppress coefficient estimation in RRPP iteration,
thus turbo-charging RRPP.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_print.progress">print.progress</code></td>
<td>
<p>A logical value to indicate whether a progress 
bar should be printed to the screen.</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_verbose">verbose</code></td>
<td>
<p>A logical value to indicate if all the output from an
<code><a href="#topic+lm.rrpp">lm.rrpp</a></code> analysis should be retained.  If FALSE, only the needed
output for summaries and plotting is retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs analyses as described in Collyer and Adams (in press)
to assess systematic and random components of 
measurement error (ME).  It basically performs ANOVA with RRPP,
but with different restricted randomization strategies.  The reliability of research subject variation 
can be considered by restricting randomization within replicates; the consistency of replicate measures
can be considered by restricting randomization within subjects.
Inter-subject variation remains constant across all random permutations within subjects and 
inter-replicate variation remains constant across all random permutations within replicates.  Type II
sums of squares and cross-products (SSCP) are calculated to assure conditional estimation.
</p>
<p>The results include univariate-like statistics based on dispersion of values and
eigenanalysis performed on a signal to noise matrix product of SSCP matrices 
(sensu Bookstein and Mitteroecker, 2014) 
including the inverse of the random component of ME and the systematic
component of ME.  The multivariate test is a form of multivariate ANOVA (MANOVA), using
RRPP to generate sampling distributions of the major eigenvalue (Roy's maximum root).
Intraclass correlation coefficients (ICC) can also be calculated (using <code><a href="#topic+ICCstats">ICCstats</a></code>), 
both based on dispersion of values and 
covariance matrices, as descriptive statistics.  Details are provided in <code><a href="#topic+ICCstats">ICCstats</a></code>.
</p>
<p>Examples TBD
</p>


<h3>Value</h3>

<p>Objects of class &quot;measurement.error&quot; return the same objects
as a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit, plus a list of the following:
</p>
<table>
<tr><td><code>AOV</code></td>
<td>
<p>Analysis of variance to test for systematic error, based on dispersion of values.</p>
</td></tr>
<tr><td><code>mAOV</code></td>
<td>
<p>Multivariate AOV based on product of the inverse of the random component (SSCP) of ME
times the systematic component of ME.</p>
</td></tr>
<tr><td><code>SSCP</code></td>
<td>
<p>The sums of squares and cross-products matrices for model effects.</p>
</td></tr>
<tr><td><code>SSCP.ME.product</code></td>
<td>
<p>The products of the inverse of the random ME SSCP and the SSCP matrices
for systematic ME,.  These are the same matrix products used for eigenanalysis.  
This is the observed matrix.</p>
</td></tr>
<tr><td><code>SSCP.ME.product.std</code></td>
<td>
<p>A list of the symmetric forms of standardized SSCP.ME.products 
that yield orthogonal eigenvectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Collyer, M.L. and D.C. Adams.  2024. Interrogating Random and Systematic Measurement Error 
in Morphometric Data. Evolutionary Biology.
</p>
<p>Bookstein, F.L., &amp; Mitteroecker, P. (2014). Comparing covariance matrices by relative eigenanalysis, 
with applications to organismal biology. Evolutionary biology, 41(2), 336-350.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.rrpp.ws">lm.rrpp.ws</a></code>, <code><a href="#topic+manova.update">manova.update</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Measurement error analysis on simulated data of fish shapes

data(fishy)

# Example two digitization replicates of the same research subjects
rep1 &lt;- matrix(fishy$coords[1,], 11, 2, byrow = TRUE)
rep2 &lt;- matrix(fishy$coords[61,], 11, 2, byrow = TRUE)
plot(rep1, pch = 16, col = gray(0.5, alpha = 0.5), cex = 2, asp = 1)
points(rep2, pch = 16, col = gray(0.2, alpha = 0.5), cex = 2, asp = 1)

# Analysis unconcerned with groups 

ME1 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  data = fishy)

anova(ME1)
ICCstats(ME1, subjects = "Subjects", with_in = "Systematic ME")
plot(ME1)

# Analysis concerned with groups 

ME2 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  groups = "groups",
  data = fishy)

anova(ME2)
ICCstats(ME2, subjects = "Subjects", 
  with_in = "Systematic ME", groups = "groups")
P &lt;- plot(ME2)
focusMEonSubjects(P, subjects = 18:20, shadow = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='model.comparison'>Model Comparisons, in terms of the log-likelihood, covariance trace,
or Z-score.</h2><span id='topic+model.comparison'></span>

<h3>Description</h3>

<p>Function calculates either log-likelihoods or traces of covariance 
matrices for comparison with 
respect to parameter penalties, or calculates Z-scores from RRPP, which
can be profiled across a gradient (predictor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.comparison(
  ...,
  type = c("cov.trace", "logLik", "Z"),
  predictor = NULL,
  tol = NULL,
  pc.no = NULL,
  gls.null = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.comparison_+3A_...">...</code></td>
<td>
<p>Any number of lm.rrpp class objects for model fits 
to be compared.</p>
</td></tr>
<tr><td><code id="model.comparison_+3A_type">type</code></td>
<td>
<p>An argument to choose between log-likelihood, 
covariance trace, or Z results.  If Z is chosen, Z-scores are calculated, the same log-likelihoods
are calculated as with the log-likelihood type, but also in every RRPP permutation,
as describe for the initial mode fits, with choice of null model (below).</p>
</td></tr>
<tr><td><code id="model.comparison_+3A_predictor">predictor</code></td>
<td>
<p>An optional vector that can be used to profile the results based on type
across a range of numerical values described by the predictor.  A spline will also be fit, which
will reveal estimated values of the predictor that yield maximum and minimum values of model
comparison metric.</p>
</td></tr>
<tr><td><code id="model.comparison_+3A_tol">tol</code></td>
<td>
<p>If type = logLik or Z, tol is a tolerance value between 0 and 1, 
indicating the magnitude below which 
components should be omitted (if standard deviations of 
components are less than the eigenvalue of the first 
component times the tolerance), for calculating the log-likelihood.</p>
</td></tr>
<tr><td><code id="model.comparison_+3A_pc.no">pc.no</code></td>
<td>
<p>If type = logLik or Z, an optional value to indicate the 
number of principal components (maximum rank) to use 
for calculating the log-likelihood.</p>
</td></tr>
<tr><td><code id="model.comparison_+3A_gls.null">gls.null</code></td>
<td>
<p>A logical value indicating whether GLS estimation should be
used with the null (intercept) model, for calculating Z scores via RRPP of 
log-likelihoods.  This should be FALSE if comparing different GLS estimations
of covariance matrices.  It should be TRUE if comparing different model fits
with the same GLS-estimated covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates either log-likelihoods or traces of (residual) 
covariance matrices, plus parameter 
penalties, to assist in comparative model evaluation or selection.  
Because high-dimensional data often
produce singular or ill-conditioned residual covariance matrices, 
this function does one of two things: 1) uses 
the trace of a covariance matrix rather than its determinant; or 2) 
provides a ridge-regularization (Warton, 2008)
of the covariance matrix, only if it is determined that it is 
ill-conditioned.  Regardless of implementation,
covariance matrices are projected into a principal component (PC) 
space of appropriate dimensions.
</p>
<p>The parameter penalty is based on that proposed by Bedrick and Tsai 
(1994), equal to 2(pk + p(p + 1)/2), where 
p is the appropriate dimension (not number of variables) of the 
covariance matrix.  The parameter, k,
is the rank of the model design matrix.
</p>
<p>In the case that &quot;logLik&quot; is chosen for the argument, type, 
AIC scores are calculated.  These scores
may not perfectly match other packages or software that 
calculate AIC for multivariate data, if ridge regularization
was used (and if other packages require p = the number of 
data variables).  When choosing logLik as the type of comparison,
it might be a good idea to adjust the tolerance or number of data 
principal components.  The default (NULL) values will
use all data dimensions to calculate log-likelihoods, which 
might cause problems if the number of variables exceeds the number 
of observations (producing singular residual covariance matrices).  
However, one should not reduce data dimensions haphazardly,
as this can lead to poor estimates of log-likelihood.  Furthermore, 
using the tolerance argument could result in different
numbers of principal components used for each model to calculate 
log-likelihoods, which might be a concern for comparing models.  
If both tol and pc.no arguments are used, the solution will use 
the fewest PCs produced by either argument.  Because the trace
of a covariance matrix is not sensitive to matrix singularity, 
no PC adjustment is used for the cov.trace argument.
</p>
<p>This function can also calculate Z-scores from RRPP on model log-likelihoods, 
which can be compared directly or profiled along a gradient (predictor).  
This might be useful for for comparing generalized least-squares (GLS) models, 
for example, along a gradient of a parameter used to scale the covariance 
matrix for GLS estimation. See Collyer et al. 2022 for an example of using
RRPP on log-likelihoods with different covariance matrices.
</p>
<p>Users can construct their own tables 
from the results but this function does not attempt to 
summarize results, as interpreting results requires 
some arbitrary decisions.  The <code><a href="stats.html#topic+anova">anova</a></code> function 
explicitly tests multiple models and can be used for nested 
model comparisons.
</p>
<p>Results can also be plotted using the generic <code><a href="graphics.html#topic+plot">plot</a></code> 
function.
</p>
<p>Caution: For models with GLS estimation, the number of 
parameters used to estimate the covariance matrix
is not taken into consideration.  A generalized information 
criterion is currently in development.
</p>


<h3>Value</h3>

<p>An object of class <code>model.comparison</code> is a data 
frame with either log-likelihoods
or covariance traces, plus parameter penalties.  AIC scores 
might be include, if applicable
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Bedrick, E.J., and C.L. Tsai. 1994. Model selection 
for multivariate regression in small samples. 
Biometrics, 226-231.
</p>
<p>Warton, D.I., 2008. Penalized normal likelihood and 
ridge regularization of correlation and covariance matrices. 
Journal of the American Statistical Association. 103: 340-349.
</p>
<p>Collyer,  M.L., E.K. Baken, &amp; D.C. Adams.  A standardized 
effect size for evaluating and comparing the strength of phylogenetic 
signal. Methods in Ecology and Evolution. 13: 367â€“382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Pupfish)
Pupfish$logSize &lt;- log(Pupfish$CS)
fit1 &lt;- lm.rrpp(coords ~ logSize, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit2 &lt;- lm.rrpp(coords ~ Pop, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit3 &lt;- lm.rrpp(coords ~ Sex, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit4 &lt;- lm.rrpp(coords ~ logSize + Sex, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit5 &lt;- lm.rrpp(coords ~ logSize + Pop, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit6 &lt;- lm.rrpp(coords ~ logSize + Sex * Pop, data = Pupfish, iter = 0, 
print.progress = FALSE)

modComp1 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, 
fit6, type = "cov.trace")
modComp2 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, 
fit6, type = "logLik", tol = 0.01)

summary(modComp1)
summary(modComp2)

par(mfcol = c(1,2))
plot(modComp1)
plot(modComp2)

# Comparing fits with covariance matrices
# an example for scaling a phylogenetic covariance matrix with
# the scaling parameter, lambda

data("PlethMorph")
Cov &lt;- PlethMorph$PhyCov
lambda &lt;- seq(0, 1, 0.1)

Cov1 &lt;- scaleCov(Cov, scale. = lambda[1])
Cov2 &lt;- scaleCov(Cov, scale. = lambda[2])
Cov3 &lt;- scaleCov(Cov, scale. = lambda[3])
Cov4 &lt;- scaleCov(Cov, scale. = lambda[4])
Cov5 &lt;- scaleCov(Cov, scale. = lambda[5])
Cov6 &lt;- scaleCov(Cov, scale. = lambda[6])
Cov7 &lt;- scaleCov(Cov, scale. = lambda[7])
Cov8 &lt;- scaleCov(Cov, scale. = lambda[8])
Cov9 &lt;- scaleCov(Cov, scale. = lambda[9])
Cov10 &lt;- scaleCov(Cov, scale. = lambda[10])
Cov11 &lt;- scaleCov(Cov, scale. = lambda[11])


fit1 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov1)
fit2 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov2)
fit3 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov3)
fit4 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov4)
fit5 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov5)
fit6 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov6)
fit7 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov7)
fit8 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov8)
fit9 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov9)
fit10 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov10)
fit11 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov11)

par(mfrow = c(1,1))

MC1 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, fit6,
fit7, fit8, fit9, fit10, fit11,
type = "logLik")
MC1
plot(MC1)

MC2 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, fit6,
fit7, fit8, fit9, fit10, fit11,
type = "logLik", predictor = lambda)
MC2
plot(MC2)


MC3 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, fit6,
fit7, fit8, fit9, fit10, fit11,
type = "Z", predictor = lambda)
MC3
plot(MC3)

## End(Not run)
</code></pre>

<hr>
<h2 id='model.frame.lm.rrpp'>Extract model frame from a lm.rrpp object</h2><span id='topic+model.frame.lm.rrpp'></span>

<h3>Description</h3>

<p><code>model.frame.lm.rrpp</code> returns the model frame constructed for 
an <code>lm.rrpp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.lm.rrpp_+3A_formula">formula</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="model.frame.lm.rrpp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='model.matrix.lm.rrpp'>Extract the model design matrix from an lm.rrpp object</h2><span id='topic+model.matrix.lm.rrpp'></span>

<h3>Description</h3>

<p><code>model.matrix.lm.rrpp</code> returns the design matrix constructed for 
an <code>lm.rrpp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="model.matrix.lm.rrpp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='motionpaths'>Simulated motion paths</h2><span id='topic+motionpaths'></span>

<h3>Description</h3>

<p>Simulated motion paths
</p>


<h3>Author(s)</h3>

<p>Dean Adams
</p>


<h3>References</h3>

<p>Adams, D. C., and M. L. Collyer. 2009. A general framework for 
the analysis of phenotypic
trajectories in evolutionary studies. Evolution 63:1143-1154.
</p>

<hr>
<h2 id='na.omit.rrpp.data.frame'>Handle missing values in rrpp.data.frame objects</h2><span id='topic+na.omit.rrpp.data.frame'></span>

<h3>Description</h3>

<p>Handle missing values in rrpp.data.frame objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rrpp.data.frame'
na.omit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.omit.rrpp.data.frame_+3A_object">object</code></td>
<td>
<p>object (from <code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code>)</p>
</td></tr>
<tr><td><code id="na.omit.rrpp.data.frame_+3A_...">...</code></td>
<td>
<p>further arguments (currently not used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- matrix(rnorm(15), 5, 3)
x &lt;- rnorm(5)
rdf &lt;- rrpp.data.frame(x = x, y = y, d = dist(y))
rdf$x[1] &lt;- NA # create missing data
rdf

ndf &lt;- na.omit(rdf)
ndf
</code></pre>

<hr>
<h2 id='ordinate'>Ordination tool for data aligned to another matrix</h2><span id='topic+ordinate'></span>

<h3>Description</h3>

<p>Function performs a singular value decomposition of ordinary 
least squares (OLS) or 
generalized least squares (GLS) residuals, aligned to an alternative 
matrix, plus projection of 
data onto vectors obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinate(
  Y,
  A = NULL,
  Cov = NULL,
  transform. = TRUE,
  scale. = FALSE,
  tol = NULL,
  rank. = NULL,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinate_+3A_y">Y</code></td>
<td>
<p>An n x p data matrix.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_a">A</code></td>
<td>
<p>An optional n x n symmetric matrix or an n x k data 
matrix, where k is the number of variables that could
be associated with the p variables of Y.  If NULL, an n x n 
identity matrix will be used.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_cov">Cov</code></td>
<td>
<p>An optional n x n covariance matrix to describe 
the non-independence among
observations in Y, and provide a GLS-centering of data.  
Note that Cov and A can be the same, if one
wishes to align GLS residuals to the same matrix used to 
obtain them.  Note also that no explicit GLS-centering
is performed on A.  If this is desired, A should be 
GLS-centered beforehand.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_transform.">transform.</code></td>
<td>
<p>An optional argument if a covariance matrix 
is provided to transform GLS-centered residuals, if TRUE.  If FALSE, 
only GLS-centering is performed.  Only if transform = TRUE 
(the default) can one expect the variances of ordinate scores 
in a principal component analysis to match eigenvalues.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_scale.">scale.</code></td>
<td>
<p>a logical value indicating whether the variables 
should be scaled to have unit variance before the analysis 
takes place. The default is FALSE.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_tol">tol</code></td>
<td>
<p>A value indicating the magnitude below which 
components should be omitted. (Components are omitted if their 
standard deviations are less than or equal to tol times the 
standard deviation of the first component.) 
With the default null setting, no components are omitted 
(unless rank. is provided). 
Other settings for tol could be tol = sqrt(.Machine$double.eps), 
which would omit essentially constant components, or tol = 0,
to retain all components, even if redundant.
This argument is exactly the same as in <code><a href="stats.html#topic+prcomp">prcomp</a></code></p>
</td></tr>
<tr><td><code id="ordinate_+3A_rank.">rank.</code></td>
<td>
<p>Optionally, a number specifying the maximal rank, 
i.e., maximal number of aligned components to be used. 
This argument can be set as alternative or in addition to tol, 
useful notably when the desired rank is considerably 
smaller than the dimensions of the matrix.  This argument is 
exactly the same as in <code><a href="stats.html#topic+prcomp">prcomp</a></code></p>
</td></tr>
<tr><td><code id="ordinate_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame of values for the same 
variables of Y to be projected onto 
aligned components.  This is only possible with OLS 
(transform. = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs a singular value decomposition, 
<b>t(A)Z</b> = <b>UDt(V)</b>, where
<b>Z</b> is a matrix of residuals (obtained from <b>Y</b>; 
see below) and <b>A</b>
is an alignment matrix with the same number of rows as <b>Z</b>.  
(<b>t</b> indicates matrix transposition.)  <b>U</b>  and <b>V</b>
are the matrices of left and right singular vectors, and <b>D</b> 
is a diagonal matrix of singular
values. <b>V</b> are the vectors that describe maximized 
covariation between <b>Y</b> and <b>A</b>. 
If <b>A</b> = <b>I</b>, an n x n identity matrix, <b>V</b> are the
eigen vectors (principal components) of <b>Y</b>.
</p>
<p><b>Z</b> represents a centered and potentially standardized 
form of <b>Y</b>.  This
function can center data via OLS or GLS means (the latter if 
a covariance matrix to describe
the non-independence among observations is provided).  If 
standardizing variables is preferred,
then <b>Z</b> both centers and scales the vectors of <b>Y</b> 
by their standard deviations.  
</p>
<p>Data are projected onto aligned vectors, <b>ZV</b>.  If a 
GLS computation is made, the option to transform centered values 
(residuals) before projection is 
available.  This is required for orthogonal projection, but 
from a transformed data space.  Not transforming
residuals maintains the Euclidean distances among observations 
and the OLS multivariate variance, but
the projection is oblique (scores can be correlated).
</p>
<p>The versatility of using an alignment approach is that 
alternative data space rotations are possible.
Principal components are thus the vectors that maximize 
variance with respect to the data, themselves,
but &quot;components&quot; of (co)variation can be described for any 
inter-matrix relationship, including
phylogenetic signal, ecological signal, ontogenetic signal, 
size allometry, etc.
More details are provided in Collyer and Adams (2021).
</p>
<p>Much of this function is consistent with the <code><a href="stats.html#topic+prcomp">prcomp</a></code> 
function, except that centering data
is not an option (it is required).
</p>
<p>SUMMARY STATISTICS: For principal component plots, the traditional 
statistics to summarize the analysis include
eigenvalues (variance by component), proportion of variance by 
component, and cumulative proportion of variance. 
When data are aligned to an alternative matrix, the statistics 
are less straightforward.  A summary of
of such an analysis (performed with <code><a href="#topic+summary.ordinate">summary.ordinate</a></code>) 
will produce these additional statistics:
</p>

<dl>
<dt><b>Singular Value</b></dt><dd><p>  Rather than eigenvalues, the 
singular values from singular value decomposition of the 
cross-product of the scaled alignment matrix and the data.</p>
</dd>
<dt><b>Proportion of Covariance</b></dt><dd><p>  Each component's 
singular value divided by the sum of singular values.  The cumulative
proportion is also returned.  Note that these values do not 
explain the amount of covariance between the alignment matrix 
and data, but
explain the distribution of the covariance.  Large proportions 
can be misleading.</p>
</dd>
<dt><b>RV by Component</b></dt><dd><p>  The partial RV statistic by 
component.  Cumulative values are also returned.  The sum of partial
RVs is Escoffier's RV statistic, which measures the amount of 
covariation between the alignment matrix and data.  Caution should
be used in interpreting these values, which can vary with the 
number of observations and number of variables.  However,
the RV is more reliable than proportion of singular value for 
interpretation of the strength of linear association for 
aligned components.  (It is most analogous to proportion of 
variance for principal components.)</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>ordinate</code> is a list containing 
the following
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Aligned component scores for all observations</p>
</td></tr>
<tr><td><code>xn</code></td>
<td>
<p>Optional projection of new data onto components.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The portion of the squared singular values attributed to 
the aligned components.</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>Standard deviations of d; i.e., the scale of the components.</p>
</td></tr>
<tr><td><code>rot</code></td>
<td>
<p>The matrix of variable loadings, i.e. the singular 
vectors, <b>V</b>.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>The OLS or GLS means vector used for centering.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p>Whether GLS transformation was used in projection 
of residuals 
(only possible in conjunction with GLS-centering).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling used, or FALSE.</p>
</td></tr>
<tr><td><code>alignment</code></td>
<td>
<p>Whether data were aligned to principal axes or 
the name of another matrix.</p>
</td></tr>
<tr><td><code>GLS</code></td>
<td>
<p>A logical value to indicate if GLS-centering and 
projection was used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Collyer, M.L. and D.C. Adams.  2021. 
Phylogenetically-aligned Component Analysis. Methods 
in Ecology and evolution. In press.
</p>
<p>Revell, L. J.  2009. Size-correction and principal 
components for interspecific comparative 
studies. Evolution, 63:3258-3268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ordinate">plot.ordinate</a></code>, <code><a href="stats.html#topic+prcomp">prcomp</a></code>, 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>,
<code>gm.prcomp</code> within <code>geomorph</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Examples use residuals from a regression of salamander 
# morphological traits against body size (snout to vent length, SVL).
# Observations are species means and a phylogenetic covariance matrix
# describes the relatedness among observations.

data("PlethMorph")
Y &lt;- as.data.frame(PlethMorph[c("TailLength", "HeadLength", 
"Snout.eye", "BodyWidth", 
"Forelimb", "Hindlimb")])
Y &lt;- as.matrix(Y)
R &lt;- lm.rrpp(Y ~ SVL, data = PlethMorph, 
iter = 0, print.progress = FALSE)$LM$residuals

# PCA (on correlation matrix)

PCA.ols &lt;- ordinate(R, scale. = TRUE)
PCA.ols$rot
prcomp(R, scale. = TRUE)$rotation # should be the same

# phyPCA (sensu Revell, 2009)
# with projection of untransformed residuals (Collyer &amp; Adams 2020)

PCA.gls &lt;- ordinate(R, scale. = TRUE, 
transform. = FALSE, 
Cov = PlethMorph$PhyCov)

# phyPCA with transformed residuals (orthogonal projection, 
# Collyer &amp; Adams 2020)

PCA.t.gls &lt;- ordinate(R, scale. = TRUE, 
transform. = TRUE, 
Cov = PlethMorph$PhyCov)
 
 # Align to phylogenetic signal (in each case)
 
 PaCA.ols &lt;- ordinate(R, A = PlethMorph$PhyCov, scale. = TRUE)
 
 PaCA.gls &lt;- ordinate(R, A = PlethMorph$PhyCov, 
 scale. = TRUE,
 transform. = FALSE, 
 Cov = PlethMorph$PhyCov)
 
 PaCA.t.gls &lt;- ordinate(R, A = PlethMorph$PhyCov, 
 scale. = TRUE,
 transform. = TRUE, 
 Cov = PlethMorph$PhyCov)
 
 # Summaries
 
 summary(PCA.ols)
 summary(PCA.gls)
 summary(PCA.t.gls)
 summary(PaCA.ols)
 summary(PaCA.gls)
 summary(PaCA.t.gls)
 
 # Plots
 
 par(mfrow = c(2,3))
 plot(PCA.ols, main = "PCA OLS")
 plot(PCA.gls, main = "PCA GLS")
 plot(PCA.t.gls, main = "PCA t-GLS")
 plot(PaCA.ols, main = "PaCA OLS")
 plot(PaCA.gls, main = "PaCA GLS")
 plot(PaCA.t.gls, main = "PaCA t-GLS")
 par(mfrow = c(1,1))
 
 # Changing some plot aesthetics (the arguments in plot.ordinate and 
 # plot.default are important for changing plot parameters)
 
 P1 &lt;- plot(PaCA.gls, main = "PaCA GLS", include.axes = TRUE)
 
 P2 &lt;- plot(PaCA.gls, main = "PaCA GLS", include.axes = TRUE, 
 frame.plot = FALSE, col = 4, pch = 21, bg = PlethMorph$group)
 add.tree(P2, PlethMorph$tree, edge.col = 4)

 P3 &lt;- plot(PaCA.gls, main = "PaCA GLS", include.axes = TRUE, 
 frame.plot = FALSE, col = 4, pch = 21, bg = PlethMorph$group,
 flip = 1)
 add.tree(P3, PlethMorph$tree, edge.col = 4)
 
 
</code></pre>

<hr>
<h2 id='pairwise'>Pairwise comparisons of lm.rrpp fits</h2><span id='topic+pairwise'></span>

<h3>Description</h3>

<p>Function generates distributions of pairwise statistics for a lm.rrpp fit and
returns important statistics for hypothesis tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(
  fit,
  fit.null = NULL,
  groups,
  covariate = NULL,
  print.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_fit">fit</code></td>
<td>
<p>A linear model fit using <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_fit.null">fit.null</code></td>
<td>
<p>An alternative linear model fit to use as a null 
model for RRPP, if the null model
of the fit is not desired.  Note, for FRPP this argument should 
remain NULL and FRPP
must be established in the lm.rrpp fit (RRPP = FALSE).  If the 
null model is uncertain, 
using <code><a href="#topic+reveal.model.designs">reveal.model.designs</a></code> will help elucidate the 
inherent null model used.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_groups">groups</code></td>
<td>
<p>A factor or vector that is coercible into a factor, 
describing the levels of
the groups for which to find LS means or slopes.  Normally this 
factor would be part of the 
model fit, but it is not necessary for that to be the case in order 
to obtain results.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_covariate">covariate</code></td>
<td>
<p>A numeric vector for which to calculate slopes for 
comparison  If NULL, 
LS means will be calculated instead of slopes.  Normally this variable 
would be part of the 
model fit, but it is not necessary for that to be the case in order 
to obtain results.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_print.progress">print.progress</code></td>
<td>
<p>If a null model fit is provided, a logical 
value to indicate whether analytical 
results progress should be printed on screen.  Unless large data 
sets are analyzed, this argument 
is probably not helpful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on an lm.rrpp fit, this function will find fitted values over all 
permutations and based 
on a grouping factor, calculate either least squares (LS) means or 
slopes, and pairwise statistics among
them.  Pairwise statistics have multiple flavors, related to vector attributes: 
</p>

<dl>
<dt><b>Distance between vectors, &quot;dist&quot;</b></dt><dd><p> Vectors for LS means or 
slopes originate at the origin and point to some location, having both a 
magnitude
and direction.  A distance between two vectors is the inner-product of of 
the vector difference, i.e., the distance between their endpoints.  For
LS means, this distance is the difference between means.  For multivariate 
slope vectors, this is the difference in location between estimated change 
for the dependent variables, per one-unit change of the covariate considered.
For univariate slopes, this is the absolute difference between slopes.</p>
</dd>
<dt><b>Vector correlation, &quot;VC&quot;</b></dt><dd><p> If LS mean or slope vectors are 
scaled to unit size, the vector correlation is the inner-product of the 
scaled vectors.
The arccosine (acos) of this value is the angle between vectors, which can 
be expressed in radians or degrees.  Vector correlation indicates the 
similarity of 
vector orientation, independent of vector length.</p>
</dd>
<dt><b>Difference in vector lengths, &quot;DL&quot;</b></dt><dd><p>  If the length of a vector 
is an important attribute &ndash; e.g., the amount of multivariate change per 
one-unit
change in a covariate &ndash; then the absolute value of the difference in 
vector lengths is a practical statistic to compare vector lengths.  Let 
d1 and
d2 be the distances (length) of vectors.  Then |d1 - d2| is a statistic 
that compares their lengths.  For slope vectors, this is a comparison of rates.</p>
</dd>
<dt><b>Variance, &quot;var</b></dt><dd><p>  Vectors of residuals from a linear model 
indicate can express the distances of observed values from fitted values.  
Mean
squared distances of values (variance), by group, can be used to measure 
the amount of dispersion around estimated values for groups.  Absolute
differences between variances are used as test statistics to compare mean 
dispersion of values among groups.  Variance degrees of freedom equal n, 
the group size, rather than n-1, as the purpose is to compare mean dispersion 
in the sample.  (Additionally, tests with one subject in a group are 
possible, or at least not a hindrance to the analysis.)</p>
</dd>
</dl>

<p>The <code><a href="#topic+summary.pairwise">summary.pairwise</a></code> function is used to select a test 
statistic for the statistics described above, as
&quot;dist&quot;, &quot;VC&quot;, &quot;DL&quot;, and &quot;var&quot;, respectively.  If vector correlation is tested, the <code>angle.type</code> argument can be used to choose between radians and
degrees.
</p>
<p>The null model is defined via <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>, but one can 
also use an alternative null model as an optional argument.
In this case, residual randomization in the permutation procedure 
(RRPP) will be performed using the alternative null model 
to generate fitted values.  If full randomization of values (FRPP) 
is preferred,
it must be established in the lm.rrpp fit and an alternative model 
should not be chosen. If one is unsure about the inherent
null model used if an alternative is not specified as an argument, 
the function <code><a href="#topic+reveal.model.designs">reveal.model.designs</a></code> can be used.
</p>
<p>Observed statistics, effect sizes, P-values, and one-tailed confidence 
limits based on the confidence requested will
be summarized with the <code><a href="#topic+summary.pairwise">summary.pairwise</a></code> function.  
Confidence limits are inherently one-tailed as
the statistics are similar to absolute values.  For example, a 
distance is analogous to an absolute difference.  Therefore,
the one-tailed confidence limits are more akin to two-tailed 
hypothesis tests.  (A comparable example is to use the absolute 
value of a t-statistic, in which case the distribution has a lower 
bound of 0.)  
</p>


<h4>Notes for RRPP 0.6.2 and subsequent versions</h4>

 
<p>In previous versions of pairwise, <code><a href="#topic+summary.pairwise">summary.pairwise</a></code> had three 
test types: &quot;dist&quot;, &quot;VC&quot;, and &quot;var&quot;.  When one chose &quot;dist&quot;, for LS mean 
vectors, the statistic was the inner-product of the vector difference.  
For slope vectors, &quot;dist&quot; returned the absolute value  of the difference 
between vector lengths, which is &quot;DL&quot; in 0.6.2 and subsequent versions.  This
update uses the same calculation, irrespective of vector types.  Generally,
&quot;DL&quot; is the same as a contrast in rates for slope vectors, but might not have
much meaning for LS means.  Likewise, &quot;dist&quot; is the distance between vector
endpoints, which might make more sense for LS means than slope vectors.  
Nevertheless, the user has more control over these decisions with version 0.6.2
and subsequent versions.
</p>



<h3>Value</h3>

<p>An object of class <code>pairwise</code> is a list containing the following
</p>
<table>
<tr><td><code>LS.means</code></td>
<td>
<p>LS means for groups, across permutations.</p>
</td></tr>
<tr><td><code>slopes</code></td>
<td>
<p>Slopes for groups, across permutations.</p>
</td></tr>
<tr><td><code>means.dist</code></td>
<td>
<p>Pairwise distances between means, across permutations.</p>
</td></tr>
<tr><td><code>means.vec.cor</code></td>
<td>
<p>Pairwise vector correlations between 
means, across permutations.</p>
</td></tr>
<tr><td><code>means.lengths</code></td>
<td>
<p>LS means vector lengths, by group, across permutations.</p>
</td></tr>
<tr><td><code>means.diff.length</code></td>
<td>
<p>Pairwise absolute differences between 
mean vector lengths, across permutations.</p>
</td></tr>
<tr><td><code>slopes.dist</code></td>
<td>
<p>Pairwise distances between slopes (end-points), 
across permutations.</p>
</td></tr>
<tr><td><code>slopes.vec.cor</code></td>
<td>
<p>Pairwise vector correlations between slope 
vectors, across permutations.</p>
</td></tr>
<tr><td><code>slopes.lengths</code></td>
<td>
<p>Slope vector lengths, by group, across permutations.</p>
</td></tr>
<tr><td><code>slopes.diff.length</code></td>
<td>
<p>Pairwise absolute differences between 
slope vector lengths, across permutations.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Data dimensions; i.e., variable number</p>
</td></tr>
<tr><td><code>PermInfo</code></td>
<td>
<p>Information for random permutations, passed on 
from lm.rrpp fit and possibly
modified if an alternative null model was used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Collyer, M.L., D.J. Sekora, and D.C. Adams. 2015. A 
method for analysis of phenotypic change for phenotypes described
by high-dimensional data. Heredity. 115:357-365.
</p>
<p>Adams, D.C and M.L. Collyer. 2018. Multivariate 
phylogenetic ANOVA: group-clade aggregation, biological 
challenges, and a refined permutation procedure. Evolution. In press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.rrpp">lm.rrpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples use geometric morphometric data on pupfishes
# See the package, geomorph, for details about obtaining such data

# Body Shape Analysis (Multivariate) --------------

data("Pupfish")

# Note:

dim(Pupfish$coords) # highly multivariate!

Pupfish$logSize &lt;- log(Pupfish$CS) 

# Note: one should use all dimensions of the data but with this 
# example, there are many.  Thus, only three principal components 
# will be used for demonstration purposes.

Pupfish$Y &lt;- ordinate(Pupfish$coords)$x[, 1:3]

## Pairwise comparisons of LS means

# Note: one should increase RRPP iterations but a 
# smaller number is used here for demonstration 
# efficiency.  Generally, iter = 999 will take less
# than 1s for these examples with a modern computer.

fit1 &lt;- lm.rrpp(Y ~ logSize + Sex * Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 199) 
summary(fit1, formula = FALSE)
anova(fit1) 

pup.group &lt;- interaction(Pupfish$Sex, Pupfish$Pop)
pup.group
PW1 &lt;- pairwise(fit1, groups = pup.group)
PW1

# distances between means
summary(PW1, confidence = 0.95, test.type = "dist") 
summary(PW1, confidence = 0.95, test.type = "dist", stat.table = FALSE)

# absolute difference between mean vector lengths
summary(PW1, confidence = 0.95, test.type = "DL") 

# correlation between mean vectors (angles in degrees)
summary(PW1, confidence = 0.95, test.type = "VC", 
   angle.type = "deg") 

# Can also compare the dispersion around means
summary(PW1, confidence = 0.95, test.type = "var")

## Pairwise comparisons of slopes

fit2 &lt;- lm.rrpp(Y ~ logSize * Sex * Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 199) 
summary(fit2, formula = FALSE)
anova(fit1, fit2)

# Using a null fit that excludes all factor-covariate 
# interactions, not just the last one  

PW2 &lt;- pairwise(fit2, fit.null = fit1, groups = pup.group, 
covariate = Pupfish$logSize, print.progress = FALSE) 
PW2

# distances between slope vectors (end-points)
summary(PW2, confidence = 0.95, test.type = "dist") 
summary(PW2, confidence = 0.95, test.type = "dist", stat.table = FALSE)

# absolute difference between slope vector lengths
summary(PW2, confidence = 0.95, test.type = "DL") 

# correlation between slope vectors (and angles)
summary(PW2, confidence = 0.95, test.type = "VC",
   angle.type = "deg") 
   
# Can also compare the dispersion around group slopes
summary(PW2, confidence = 0.95, test.type = "var")

## End(Not run)

</code></pre>

<hr>
<h2 id='PlethMorph'>Plethodon comparative morphological data</h2><span id='topic+PlethMorph'></span>

<h3>Description</h3>

<p>Data for 37 species of plethodontid salamanders.  
Variables include snout to vent length
(SVL) as species size, tail length, head length, snout to eye length, 
body width, forelimb length,
and hind limb length, all measured in mm.  A grouping variable is also 
included for functional guild size.  A variable for species names is also 
included.
The data set also includes a phylogenetic covariance matrix based on a 
Brownian model of evolution, to assist in 
generalized least squares (GLS) estimation.
</p>


<h3>Details</h3>

<p>The covariance matrix was estimated with the vcv.phylo function 
of the R package, ape, based on the tree
described in Adams and Collyer (2018).
</p>


<h3>Author(s)</h3>

<p>Michael Collyer and Dean Adams
</p>


<h3>References</h3>

<p>Adams, D.C and Collyer, M.L. 2018. Multivariate phylogenetic 
anova: group-clade aggregation, biological 
challenges, and a refined permutation procedure. Evolution, 72: 1204-1215.
</p>

<hr>
<h2 id='plot.interSubVar'>Plot Function for RRPP</h2><span id='topic+plot.interSubVar'></span>

<h3>Description</h3>

<p>This function produces a heat map for inter-subject variability, based on 
results from a <code><a href="#topic+measurement.error">measurement.error</a></code> object.  The function, 
<code><a href="#topic+interSubVar">interSubVar</a></code>, must first be used on the <code><a href="#topic+measurement.error">measurement.error</a></code> 
object to obtain variability statistics.  This function use the <code><a href="Matrix.html#topic+image">image</a></code>
function to produce plots.  It does little to manipulate such plots, but any
argument for <code><a href="Matrix.html#topic+image">image</a></code> can be manipulated here, as well as the graphical
parameters that can be adjusted within <code><a href="Matrix.html#topic+image">image</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interSubVar'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.interSubVar_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+interSubVar">interSubVar</a></code></p>
</td></tr>
<tr><td><code id="plot.interSubVar_+3A_...">...</code></td>
<td>
<p>Arguments passed onto <code><a href="Matrix.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='plot.lm.rrpp'>Plot Function for RRPP</h2><span id='topic+plot.lm.rrpp'></span>

<h3>Description</h3>

<p>Plot Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
plot(
  x,
  type = c("diagnostics", "regression", "PC"),
  resid.type = c("p", "n"),
  fitted.type = c("o", "t"),
  predictor = NULL,
  reg.type = c("PredLine", "RegScore"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lm.rrpp_+3A_x">x</code></td>
<td>
<p>plot object (from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="plot.lm.rrpp_+3A_type">type</code></td>
<td>
<p>Indicates which type of plot, choosing among diagnostics,
regression, or principal component plots.  Diagnostic plots are similar to 
<code><a href="stats.html#topic+lm">lm</a></code> diagnostic plots, but for multivariate data.  Regression plots
plot multivariate dispersion in some fashion against predictor values. PC plots
project data onto the eigenvectors of the covariance matrix for fitted values.</p>
</td></tr>
<tr><td><code id="plot.lm.rrpp_+3A_resid.type">resid.type</code></td>
<td>
<p>If type = &quot;diagnostics&quot;, an optional argument for whether Pearson (&quot;p&quot;) or normalized (&quot;n&quot;)
residuals should be used.  These residuals are the same for ordinary least-squares (OLS) estimation
but differ for generalized least-squares (GLS) estimation.  For the latter, normalizing residuals
requires multiplying them by the transformation matrix obtained for GLS estimation.</p>
</td></tr>
<tr><td><code id="plot.lm.rrpp_+3A_fitted.type">fitted.type</code></td>
<td>
<p>As with resid.type, whether fitted values use observed (&quot;o&quot;) or transformed (&quot;t&quot;)
values.</p>
</td></tr>
<tr><td><code id="plot.lm.rrpp_+3A_predictor">predictor</code></td>
<td>
<p>An optional vector if &quot;regression&quot; plot type is chosen, 
and is a variable likely used in <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.
This vector is a vector of covariate values equal to the number of observations.</p>
</td></tr>
<tr><td><code id="plot.lm.rrpp_+3A_reg.type">reg.type</code></td>
<td>
<p>If &quot;regression&quot; is chosen for plot type, this argument
indicates whether prediction line 
(PredLine) or regression score (RegScore) plotting is performed.  
For explanation of prediction line,
see Adams and Nistri (2010).  For explanation of regression score, see 
Drake and Klingenberg (2008).</p>
</td></tr>
<tr><td><code id="plot.lm.rrpp_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot (helpful to employ
different colors or symbols for different groups).  See
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Drake, A. G., and C. P. Klingenberg. 2008. 
The pace of morphological change: Historical 
transformation of skull shape in St Bernard dogs. Proc. R. Soc. B. 275:71-76.
</p>
<p>Adams, D. C., and A. Nistri. 2010. Ontogenetic convergence 
and evolution of foot morphology 
in European cave salamanders (Family: Plethodontidae). BMC Evol. Biol. 10:1-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Univariate example
data(PlethMorph)
fitGLS &lt;- lm.rrpp(TailLength ~ SVL, data = PlethMorph, Cov = PlethMorph$PhyCov, 
 print.progress = FALSE, iter = 0)
 
 par(mfrow = c(2, 2))
 plot(fitGLS)
 plot(fitGLS, resid.type = "n") # use normalized (transformed) residuals
 plot(fitGLS, resid.type = "n", fitted.type = "t") # use also transformed fitted values
 
 # Multivariate example
 
Y &lt;- as.matrix(cbind(PlethMorph$TailLength,
PlethMorph$HeadLength,
PlethMorph$Snout.eye,
PlethMorph$BodyWidth,
PlethMorph$Forelimb,
PlethMorph$Hindlimb))
PlethMorph$Y &lt;- Y
fitGLSm &lt;- lm.rrpp(Y ~ SVL, data = PlethMorph, 
Cov = PlethMorph$PhyCov,
print.progress = FALSE, iter = 0)

par(mfrow = c(2, 2))
 plot(fitGLSm)
 plot(fitGLSm, resid.type = "n") # use normalized (transformed) residuals
 plot(fitGLSm, resid.type = "n", fitted.type = "t") # use also transformed fitted values
 par(mfrow = c(1, 1))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.looCV'>Plot Function for RRPP</h2><span id='topic+plot.looCV'></span>

<h3>Description</h3>

<p>Plot Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'looCV'
plot(x, axis1 = 1, axis2 = 2, flip = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.looCV_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+looCV">looCV</a></code></p>
</td></tr>
<tr><td><code id="plot.looCV_+3A_axis1">axis1</code></td>
<td>
<p>A value indicating which component should be 
displayed as the X-axis (default = C1)</p>
</td></tr>
<tr><td><code id="plot.looCV_+3A_axis2">axis2</code></td>
<td>
<p>A value indicating which component should be 
displayed as the Y-axis (default = C2)</p>
</td></tr>
<tr><td><code id="plot.looCV_+3A_flip">flip</code></td>
<td>
<p>An argument that if not NULL can be used to flip 
components in the plot.  
The values need to match axis1 or axis2.  For example, if axis1 = 3 
and axis2 = 4, flip = 1 will not
change either axis; flip = 3 will flip only the horizontal axis; 
flip = c(3, 4) will flip both axes.  Axis will only be flipped in first
plot.</p>
</td></tr>
<tr><td><code id="plot.looCV_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot (helpful to employ
different colors or symbols for different groups).  See</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='plot.measurement.error'>Plot Function for RRPP</h2><span id='topic+plot.measurement.error'></span>

<h3>Description</h3>

<p>This function produces multivariate signal-to-noise ratio plots for  
<code><a href="#topic+measurement.error">measurement.error</a></code> objects.  See the function, 
<code><a href="#topic+plot.interSubVar">plot.interSubVar</a></code> for plotting the inter-subject variability
from a <code><a href="#topic+measurement.error">measurement.error</a></code> object, after applying the function, 
<code><a href="#topic+interSubVar">interSubVar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measurement.error'
plot(
  x,
  separate.by.groups = TRUE,
  add.connectors = TRUE,
  add.labels = FALSE,
  use.std.vectors = FALSE,
  titles = NULL,
  add.legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.measurement.error_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+measurement.error">measurement.error</a></code></p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_separate.by.groups">separate.by.groups</code></td>
<td>
<p>A logical value for whether to make separate plots
for each group, if different groups are available.  If FALSE, groups
are still represented by different symbols in the plot, unless overridden
by plot arguments.</p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_add.connectors">add.connectors</code></td>
<td>
<p>A logical value for whether to add connectors, like
vectors, between replicate observations of the same subjects.</p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_add.labels">add.labels</code></td>
<td>
<p>A logical value for whether to label subjects.
Labels are either subject name (if available) or number of occurrence
in the data set.</p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_use.std.vectors">use.std.vectors</code></td>
<td>
<p>A logical value for whether to use vectors obtained from
a standardized matrix, which are orthogonal.  This is not strictly necessary.</p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_titles">titles</code></td>
<td>
<p>An optional vector or list for augmenting the titles of plots produced.
The length of the vector or list should match the number of plots produced by 
other arguments.</p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_add.legend">add.legend</code></td>
<td>
<p>A logical value for whether to add a legend to plots.  If
separate.by.groups is TRUE, adding a legend to plots will be slightly redundant. If
certain parameters are augmented by user (point characters, colors), add.legend
will be made to be FALSE to prevent misinterpretation of intended plotting scheme.</p>
</td></tr>
<tr><td><code id="plot.measurement.error_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='plot.model.comparison'>Plot Function for RRPP</h2><span id='topic+plot.model.comparison'></span>

<h3>Description</h3>

<p>Plot Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model.comparison'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.model.comparison_+3A_x">x</code></td>
<td>
<p>plot object (from <code><a href="#topic+model.comparison">model.comparison</a></code>)</p>
</td></tr>
<tr><td><code id="plot.model.comparison_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot (helpful to employ
different colors or symbols for different groups).  See
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='plot.ordinate'>Plot Function for RRPP</h2><span id='topic+plot.ordinate'></span>

<h3>Description</h3>

<p>Plot Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinate'
plot(x, axis1 = 1, axis2 = 2, flip = NULL, include.axes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ordinate_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ordinate">ordinate</a></code></p>
</td></tr>
<tr><td><code id="plot.ordinate_+3A_axis1">axis1</code></td>
<td>
<p>A value indicating which component should be 
displayed as the X-axis (default = C1)</p>
</td></tr>
<tr><td><code id="plot.ordinate_+3A_axis2">axis2</code></td>
<td>
<p>A value indicating which component should be 
displayed as the Y-axis (default = C2)</p>
</td></tr>
<tr><td><code id="plot.ordinate_+3A_flip">flip</code></td>
<td>
<p>An argument that if not NULL can be used to flip 
components in the plot.  
The values need to match axis1 or axis2.  For example, if axis1 = 3 
and axis2 = 4, flip = 1 will not
change either axis; flip = 3 will flip only the horizontal axis; 
flip = c(3, 4) will flip both axes.</p>
</td></tr>
<tr><td><code id="plot.ordinate_+3A_include.axes">include.axes</code></td>
<td>
<p>A logical argument for whether axes should be shown at x = 0 and y = 0.
This is different than the axes argument in the generic <code><a href="graphics.html#topic+plot.default">plot.default</a></code> function, which
controls the edges of the plot (providing a box effect or not).  Using include.axes = TRUE does not 
allow aesthetic control of the axes.  If desired, it is better to use include.axes = FALSE and augment
the plot object with <code><a href="graphics.html#topic+abline">abline</a></code> (choosing h = 0 and v = 0 in separate applications).</p>
</td></tr>
<tr><td><code id="plot.ordinate_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot (helpful to employ
different colors or symbols for different groups).  See</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;plot.ordinate&quot; is a list with components
that can be used in other plot functions, such as the type of plot, points, 
a group factor, and other information depending on the plot parameters used.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='plot.predict.lm.rrpp'>Plot Function for RRPP</h2><span id='topic+plot.predict.lm.rrpp'></span>

<h3>Description</h3>

<p>Plot Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.lm.rrpp'
plot(x, PC = FALSE, ellipse = FALSE, abscissa = NULL, label = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.predict.lm.rrpp_+3A_x">x</code></td>
<td>
<p>plot object (from <code><a href="#topic+predict.lm.rrpp">predict.lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="plot.predict.lm.rrpp_+3A_pc">PC</code></td>
<td>
<p>A logical argument for whether the data space should be 
rotated to its 
principal components</p>
</td></tr>
<tr><td><code id="plot.predict.lm.rrpp_+3A_ellipse">ellipse</code></td>
<td>
<p>A logical argument to change error bars to ellipses 
in multivariate plots.  
It has no function for univariate plots or is abscissa is not NULL.</p>
</td></tr>
<tr><td><code id="plot.predict.lm.rrpp_+3A_abscissa">abscissa</code></td>
<td>
<p>An optional vector (numeric of factor) equal in length 
to predictions to use for 
plotting as the abscissa (x-axis), in which case predictions are the 
ordinate (y-axis).  This might be 
helpful if predictions are made for a continuous independent variable.  
The abscissa would be the
same variable used to make predictions (and can be the data.frame used 
for 
newdata in <code><a href="#topic+predict.lm.rrpp">predict.lm.rrpp</a></code>).</p>
</td></tr>
<tr><td><code id="plot.predict.lm.rrpp_+3A_label">label</code></td>
<td>
<p>A logical argument for whether points should be labeled 
(in multivariate plots).</p>
</td></tr>
<tr><td><code id="plot.predict.lm.rrpp_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot, arrows, points, or text (helpful 
to employ
different colors or symbols for different groups).  See
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>,  <code><a href="graphics.html#topic+arrows">arrows</a></code>, <code><a href="graphics.html#topic+points">points</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>, and <code><a href="graphics.html#topic+text">text</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See lm.rrpp help file for examples.
</code></pre>

<hr>
<h2 id='plot.trajectory.analysis'>Plot Function for RRPP</h2><span id='topic+plot.trajectory.analysis'></span>

<h3>Description</h3>

<p>Function generates a principal component plot for trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory.analysis'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.trajectory.analysis_+3A_x">x</code></td>
<td>
<p>plot object (from <code><a href="#topic+trajectory.analysis">trajectory.analysis</a></code>)</p>
</td></tr>
<tr><td><code id="plot.trajectory.analysis_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot (helpful to employ
different colors or symbols for different groups).  See
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates and plots principal components of fitted values from 
<code><a href="#topic+lm.rrpp">lm.rrpp</a></code> that are passed onto <code><a href="#topic+trajectory.analysis">trajectory.analysis</a></code>, 
and projects
data onto them.  This function is a set.up, and <code><a href="#topic+add.trajectories">add.trajectories</a></code> 
is needed to 
add trajectories to the plot.  By having two stages of control, the plotting 
functions are more 
flexible.  This function also returns plotting information that can be 
valuable for making
individualized plots, if <code><a href="#topic+add.trajectories">add.trajectories</a></code> is not preferred.
</p>


<h3>Value</h3>

<p>If an object is assigned, it will return:
</p>
<table>
<tr><td><code>pca</code></td>
<td>
<p>Principal component analysis performed using <code><a href="stats.html#topic+prcomp">prcomp</a></code>.</p>
</td></tr>
<tr><td><code>pc.points</code></td>
<td>
<p>Principal component scores for all data.</p>
</td></tr>
<tr><td><code>trajectory.analysis</code></td>
<td>
<p>Trajectory analysis passed on.</p>
</td></tr>
<tr><td><code>trajectories</code></td>
<td>
<p>pca Observed trajectories projected onto principal 
components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Adams, D. C., and M. M. Cerney. 2007. 
Quantifying biomechanical motion using Procrustes 
motion analysis. J. Biomech. 40:437-444.
</p>
<p>Adams, D. C., and M. L. Collyer. 2007. 
The analysis of character divergence along environmental 
gradients and other covariates. Evolution 61:510-515.
</p>
<p>Adams, D. C., and M. L. Collyer. 2009. 
A general framework for the analysis of phenotypic 
trajectories in evolutionary studies. Evolution 63:1143-1154.
</p>
<p>Collyer, M. L., and D. C. Adams. 2007. 
Analysis of two-state multivariate phenotypic change 
in ecological studies. Ecology 88:683-692.
</p>
<p>Collyer, M. L., and D. C. Adams. 2013. 
Phenotypic trajectory analysis: comparison of shape change patterns 
in evolution and ecology. Hystrix 24: 75-83.
</p>
<p>Collyer, M.L., D.J. Sekora, and D.C. Adams. 2015. 
A method for analysis of phenotypic change for phenotypes described 
by high-dimensional data. Heredity. 115:357-365.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code> and <code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See trajectory.analysis help file for examples
</code></pre>

<hr>
<h2 id='predict.lm.rrpp'>predict for lm.rrpp model fits</h2><span id='topic+predict.lm.rrpp'></span>

<h3>Description</h3>

<p>Computes predicted values from an <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> 
model fit, using bootstrapped residuals
to generate confidence intervals.  (Residuals are the residuals of 
the lm.rppp fit, not its null model.  The bootstrap
procedure resamples residual vectors with replacement.)
The bootstrap permutations use the same number of iterations and 
seed as used
in the <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> model fit. A <code><a href="#topic+predict.lm.rrpp">predict.lm.rrpp</a></code> 
object can be plotted using various options.
See <code><a href="#topic+plot.predict.lm.rrpp">plot.predict.lm.rrpp</a></code>.
</p>
<p>Note that if data offsets are used (if the offset argument is used 
when fitting a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> model),
they are ignored for estimating coefficients over iterations.  
Offsets are subtracted from data in <code><a href="stats.html#topic+lm">lm</a></code> and 
added to predicted values in <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, 
effectively adjusted the intercept and then un-adjusting
it for predictions.  This causes problems if the newdata have a 
different number of observations than the original
model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
predict(object, newdata = NULL, block = NULL, confidence = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
<tr><td><code id="predict.lm.rrpp_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of either class <code><a href="base.html#topic+data.frame">data.frame</a></code> 
or <code><a href="#topic+rrpp.data.frame">rrpp.data.frame</a></code>.  If null,
the data frame from the lm.rrpp fit will be used, effectively calculating 
all fitted values and
their confidence intervals.  If a numeric variable is missing from newdata, 
an attempt to average the values
will be made in prediction; i.e., least squares means for factor levels 
can be found.  All factors used in the
<code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit should be represented in the newdata data frame, 
with appropriate factor levels.</p>
</td></tr>
<tr><td><code id="predict.lm.rrpp_+3A_block">block</code></td>
<td>
<p>An optional factor for blocks within which to restrict resampling
permutations.</p>
</td></tr>
<tr><td><code id="predict.lm.rrpp_+3A_confidence">confidence</code></td>
<td>
<p>The desired confidence interval level for prediction.</p>
</td></tr>
<tr><td><code id="predict.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments (currently none)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See examples for lm.rrpp to see how predict.lm.rrpp works in conjunction
# with other functions

data(Pupfish)

# CS is centroid (fish) size
fit &lt;- lm.rrpp(coords ~ log(CS)  + Sex*Pop, 
SS.type = "I", data = Pupfish, iter = 999) 

# Predictions (holding alternative effects constant)

shapeDF &lt;- expand.grid(Sex = levels(Pupfish$Sex), Pop = levels(Pupfish$Pop))
rownames(shapeDF) &lt;- paste(shapeDF$Sex, shapeDF$Pop, sep = ".")
shapeDF

shapePreds &lt;- predict(fit, shapeDF)
summary(shapePreds)
summary(shapePreds, PC = TRUE)

shapePreds99 &lt;- predict(fit, shapeDF, confidence = 0.99)
summary(shapePreds99, PC = TRUE)

# Plot prediction

plot(shapePreds, PC = TRUE)
plot(shapePreds, PC = TRUE, ellipse = TRUE)
plot(shapePreds99, PC = TRUE)
plot(shapePreds99, PC = TRUE, ellipse = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='prep.lda'>Linear discriminant function for lm.rrpp model fits</h2><span id='topic+prep.lda'></span>

<h3>Description</h3>

<p>Function creates arguments for <code><a href="MASS.html#topic+lda">lda</a></code> 
or <code><a href="MASS.html#topic+qda">qda</a></code> from a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.lda(
  fit,
  tol = 1e-07,
  PC.no = NULL,
  newdata = NULL,
  inherent.groups = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep.lda_+3A_fit">fit</code></td>
<td>
<p>A linear model fit using <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
<tr><td><code id="prep.lda_+3A_tol">tol</code></td>
<td>
<p>A tolerance used to decide if the matrix of data is singular.
This value is passed onto both
<code><a href="MASS.html#topic+lda">lda</a></code> and <code><a href="stats.html#topic+prcomp">prcomp</a></code>, internally.</p>
</td></tr>
<tr><td><code id="prep.lda_+3A_pc.no">PC.no</code></td>
<td>
<p>An optional argument to define the specific number of 
principal components (PC) used in analysis.
The minimum of this value or the number of PCs resulting from the tol 
argument will be used.</p>
</td></tr>
<tr><td><code id="prep.lda_+3A_newdata">newdata</code></td>
<td>
<p>An optional matrix (or object coercible to a matrix) for 
classification.  If NULL,
all observed data are used.</p>
</td></tr>
<tr><td><code id="prep.lda_+3A_inherent.groups">inherent.groups</code></td>
<td>
<p>A logical argument in case one wishes to have the 
inherent groups in the model fit revealed.  If 
TRUE, no other analysis will be done than to reveal the groups.  This 
argument should always be FALSE to perform 
a classification analysis.</p>
</td></tr>
<tr><td><code id="prep.lda_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="MASS.html#topic+lda">lda</a></code>.
See <code><a href="MASS.html#topic+lda">lda</a></code> for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit to produce the 
data and the groups to use in <code><a href="MASS.html#topic+lda">lda</a></code> or
<code><a href="MASS.html#topic+qda">qda</a></code>.There are two general purposes of this 
function that are challenging when using <code><a href="MASS.html#topic+lda">lda</a></code>, directly.
First, this function finds the inherent groups in the <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> 
fit, based on factor levels.  Second,
this function find pseudodata - rather than the observed data - 
that involve either or both a principal component projection
with appropriate (or user-prescribed) dimensions and a transformation.  
The principal component projection incorporates GLS 
mean-centering, where appropriate.  Transformation involves holding 
non-grouping model terms constant.  This is accomplished by using
the fitted values from the <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit and the residuals 
of a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit with grouping factors, alone.  When,
the <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit contains only grouping factors, this 
function produces raw data projected on principal components.
</p>
<p>Regardless of variables input, data are projected onto PCs.  The 
purpose of this function is to predict 
group association, and working in PC space facilitates this objective.
</p>
<p>This is a new function and not all limits and scenarios have been 
tested before its release.  Please report 
any issues or limitations or strange results to the maintainer.  
</p>


<h4>Notes for RRPP 0.5.0 and subsequent versions</h4>

 
<p>Prior to version 0.5.0, the function, <code><a href="#topic+classify">classify</a></code>, was 
available.  This function has been deprecated.
It mimicked <code><a href="MASS.html#topic+lda">lda</a></code> with added features that are 
largely retained with <code>prep.lda</code>.  However,
<code>prep.lda</code> facilitates the much more diverse options available 
with <code><a href="MASS.html#topic+lda">lda</a></code>.
</p>



<h3>Value</h3>

<p>A list of arguments that can be passed to <code><a href="MASS.html#topic+lda">lda</a></code>.  
As a minimum, these arguments include
$x, $grouping, and $tol.  If newdata is not NULL, $newdata, using the same 
transformation and PCs as for the data,
will also be included.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+lda">lda</a></code>, <code><a href="MASS.html#topic+predict.lda">predict.lda</a></code>, 
<code><a href="MASS.html#topic+qda">qda</a></code>,
<code><a href="MASS.html#topic+predict.qda">predict.qda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the Pupfish data (see lm.rrpp help for more detail)

data(Pupfish)
Pupfish$logSize &lt;- log(Pupfish$CS) 
fit &lt;- lm.rrpp(coords ~ logSize + Sex * Pop, SS.type = "I", 
data = Pupfish, print.progress = FALSE, iter = 0)

prep.lda(fit, inherent.groups = TRUE) # see groups available
lda.args &lt;- prep.lda(fit, CV = TRUE, PC.no = 6)
lda.args$x
lda.args$grouping

# not run:
# library(MASS)
# LDA &lt;- do.call(lda, lda.args)
# LDA$posterior
# table(lda.args$grouping, LDA$class)

</code></pre>

<hr>
<h2 id='print.anova.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+print.anova.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova.lm.rrpp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.anova.lm.rrpp_+3A_x">x</code></td>
<td>
<p>print/summary object (from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="print.anova.lm.rrpp_+3A_...">...</code></td>
<td>
<p>other arguments passed to print/summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.coef.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+print.coef.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.lm.rrpp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coef.lm.rrpp_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+coef.lm.rrpp">coef.lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="print.coef.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto coef.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.ICCstats'>Print/Summary Function for RRPP</h2><span id='topic+print.ICCstats'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICCstats'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ICCstats_+3A_x">x</code></td>
<td>
<p>print/summary object (from <code><a href="#topic+ICCstats">ICCstats</a></code>)</p>
</td></tr>
<tr><td><code id="print.ICCstats_+3A_...">...</code></td>
<td>
<p>other arguments passed to print/summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+print.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lm.rrpp_+3A_x">x</code></td>
<td>
<p>print/summary object (from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="print.lm.rrpp_+3A_...">...</code></td>
<td>
<p>other arguments passed to print/summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.looCV'>Print/Summary Function for RRPP</h2><span id='topic+print.looCV'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'looCV'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.looCV_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+looCV">looCV</a></code></p>
</td></tr>
<tr><td><code id="print.looCV_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.looCV</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.lr_test'>Print/Summary Function for RRPP</h2><span id='topic+print.lr_test'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lr_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lr_test_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+lr_test">lr_test</a></code></p>
</td></tr>
<tr><td><code id="print.lr_test_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.lr_test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.measurement.error'>Print/Summary Function for RRPP</h2><span id='topic+print.measurement.error'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measurement.error'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.measurement.error_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+measurement.error">measurement.error</a></code></p>
</td></tr>
<tr><td><code id="print.measurement.error_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto measurement.error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Measurement error analysis on simulated data of fish shapes

data(fishy)

# Analysis unconcerned with groups 

ME1 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  data = fishy)

anova(ME1)
ICCstats(ME1, subjects = "Subjects", with_in = "Systematic ME")
plot(ME1)

# Analysis concerned with groups 

ME2 &lt;- measurement.error(
  Y = "coords",
  subjects = "subj",
  replicates = "reps",
  groups = "groups",
  data = fishy)

anova(ME2)
ICCstats(ME2, subjects = "Subjects", 
  with_in = "Systematic ME", groups = "groups")
P &lt;- plot(ME2)
focusMEonSubjects(P, subjects = 18:20, shadow = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.model.comparison'>Print/Summary Function for RRPP</h2><span id='topic+print.model.comparison'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model.comparison'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.model.comparison_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+model.comparison">model.comparison</a></code></p>
</td></tr>
<tr><td><code id="print.model.comparison_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto model.comparison</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.ordinate'>Print/Summary Function for RRPP</h2><span id='topic+print.ordinate'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ordinate_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+ordinate">ordinate</a></code></p>
</td></tr>
<tr><td><code id="print.ordinate_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.ordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.pairwise'>Print/Summary Function for RRPP</h2><span id='topic+print.pairwise'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwise'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pairwise_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+pairwise">pairwise</a></code></p>
</td></tr>
<tr><td><code id="print.pairwise_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto pairwise</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.predict.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+print.predict.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.lm.rrpp'
print(x, PC = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.predict.lm.rrpp_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+predict.lm.rrpp">predict.lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="print.predict.lm.rrpp_+3A_pc">PC</code></td>
<td>
<p>Logical argument for whether to use predicted values 
rotated to their PCs</p>
</td></tr>
<tr><td><code id="print.predict.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto predict.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.summary.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+print.summary.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lm.rrpp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.lm.rrpp_+3A_x">x</code></td>
<td>
<p>print/summary object (from <code><a href="#topic+summary.lm.rrpp">summary.lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="print.summary.lm.rrpp_+3A_...">...</code></td>
<td>
<p>other arguments passed to print/summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.summary.manova.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+print.summary.manova.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.manova.lm.rrpp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.manova.lm.rrpp_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+summary.manova.lm.rrpp">summary.manova.lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="print.summary.manova.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto summary.manova.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.summary.ordinate'>Print/Summary Function for RRPP</h2><span id='topic+print.summary.ordinate'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ordinate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ordinate_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+summary.ordinate">summary.ordinate</a></code></p>
</td></tr>
<tr><td><code id="print.summary.ordinate_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.ordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.summary.pairwise'>Print/Summary Function for RRPP</h2><span id='topic+print.summary.pairwise'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pairwise'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pairwise_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+summary.pairwise">summary.pairwise</a></code></p>
</td></tr>
<tr><td><code id="print.summary.pairwise_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto summary.pairwise</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.summary.trajectory.analysis'>Print/Summary Function for RRPP</h2><span id='topic+print.summary.trajectory.analysis'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.trajectory.analysis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.trajectory.analysis_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+summary.trajectory.analysis">summary.trajectory.analysis</a></code></p>
</td></tr>
<tr><td><code id="print.summary.trajectory.analysis_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto summary.trajectory.analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='print.trajectory.analysis'>Print/Summary Function for RRPP</h2><span id='topic+print.trajectory.analysis'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory.analysis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.trajectory.analysis_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+trajectory.analysis">trajectory.analysis</a></code></p>
</td></tr>
<tr><td><code id="print.trajectory.analysis_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='Pupfish'>Landmarks on pupfish</h2><span id='topic+Pupfish'></span>

<h3>Description</h3>

<p>Landmark data from Cyprinodon pecosensis body shapes, with 
indication of Sex and
Population from which fish were sampled (Marsh or Sinkhole).
</p>


<h3>Details</h3>

<p>These data were previously aligned with GPA.  Centroid size (CS) 
is also provided.  
See the <span class="pkg">geomorph</span> package for details.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Collyer, M.L., D.J. Sekora, and D.C. Adams. 2015. A method for 
analysis of phenotypic
change for phenotypes described by high-dimensional data. Heredity. 113: 
doi:10.1038/hdy.2014.75.
</p>

<hr>
<h2 id='PupfishHeads'>Landmarks on pupfish heads</h2><span id='topic+PupfishHeads'></span>

<h3>Description</h3>

<p>Landmark data from Cyprinodon pecosensis head shapes, with 
variables for 
sex, month and year sampled, locality, head size, and coordinates of 
landmarks for head shape,
per specimen.  These data are a subset of a larger data set.
</p>


<h3>Details</h3>

<p>The variable, &quot;coords&quot;, are data that were previously aligned
with GPA.  The variable, &quot;headSize&quot;, is the Centroid size of each vector 
of coordinates.
See the <span class="pkg">geomorph</span> package for details.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>References</h3>

<p>Gilbert, M.C. 2016. Impacts of habitat fragmentation on the 
cranial morphology of a 
threatened desert fish (Cyprinodon pecosensis). Masters Thesis, 
Western Kentucky University.
</p>

<hr>
<h2 id='pval'>Obtain P-value from a vector of values</h2><span id='topic+pval'></span>

<h3>Description</h3>

<p>A function to find the probability of values greater or lesser than target,
from a vector of values presumably obtained in random permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval(s, target = NULL, greater = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval_+3A_s">s</code></td>
<td>
<p>The sampling distribution vector to use.</p>
</td></tr>
<tr><td><code id="pval_+3A_target">target</code></td>
<td>
<p>The value to target in the distribution.  (If null, the first value
in the vector is used.).  If the target exists outside the range of s,
a probability of 0 or 1 is certain.</p>
</td></tr>
<tr><td><code id="pval_+3A_greater">greater</code></td>
<td>
<p>Logical value for whether the probability should be &quot;greater than 
or equal to&quot;.  Change to greater = FALSE for &quot;less than or equal to&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='residuals.lm.rrpp'>Extract residuals</h2><span id='topic+residuals.lm.rrpp'></span>

<h3>Description</h3>

<p>Extract residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.lm.rrpp_+3A_object">object</code></td>
<td>
<p>plot object (from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="residuals.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for lm.rrpp
</code></pre>

<hr>
<h2 id='reveal.model.designs'>Reveal model designs used in lm.rrpp fit</h2><span id='topic+reveal.model.designs'></span>

<h3>Description</h3>

<p>Function returns every full and reduced model for model terms used in 
lm.rrpp fits.  This function is useful for revealing 
the null and full model that would be used in the pairwise function, 
if a specific null model is not declared as an argument
(fit.null in the <code><a href="#topic+pairwise">pairwise</a></code> function).
It also helps to demonstrate how sums of squares and cross-products 
(SSCP) are calculated in lm.rrpp permutations (iterations),
from the difference between fitted values for null and full designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal.model.designs(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal.model.designs_+3A_fit">fit</code></td>
<td>
<p>A linear model fit from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Pupfish)
fit1 &lt;- lm.rrpp(coords~ Pop*Sex, data = Pupfish, 
SS.type = "I", print.progress = FALSE, iter = 0)
fit2 &lt;- lm.rrpp(coords~ Pop*Sex, data = Pupfish, 
SS.type = "II", print.progress = FALSE, iter = 0)
fit3 &lt;- lm.rrpp(coords~ Pop*Sex, data = Pupfish, 
SS.type = "III", print.progress = FALSE, iter = 0)

reveal.model.designs(fit1)
reveal.model.designs(fit2)
reveal.model.designs(fit3)

</code></pre>

<hr>
<h2 id='rrpp.data.frame'>Create a data frame for lm.rrpp analysis</h2><span id='topic+rrpp.data.frame'></span>

<h3>Description</h3>

<p>Create a data frame for lm.rrpp analysis, when covariance or distance 
matrices are used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrpp.data.frame(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrpp.data.frame_+3A_...">...</code></td>
<td>
<p>Components (objects) to combine in the data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not much different than <code><a href="base.html#topic+data.frame">data.frame</a></code> but is 
more flexible to allow
distance matrices and covariance matrices to be included.  Essentially, 
this function creates a list,
much like an object of class <code>data.frame</code> is also a list.  However, 
<code>rrpp.data.frame</code> is
less concerned with coercing the list into a matrix and more concerned 
with matching the number of observations (n).
It is wise to use this function with any <code>lm.rrpp</code> analysis so that 
<code><a href="#topic+lm.rrpp">lm.rrpp</a></code> does not have to search
the global environment for needed data.
</p>
<p>It is assumed that multiple data sets for the same subjects are in the 
same order.
</p>
<p>See <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> for examples.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Why use a rrpp.data.frame?
y &lt;- matrix(rnorm(30), 10, 3)
x &lt;- rnorm(10)
df &lt;- data.frame(x = x, y = y)
df
rdf &lt;- rrpp.data.frame(x = x, y = y)
rdf # looks more like a list

is.list(df)
is.list(rdf)

d &lt;- dist(y) # distance matrix as data

# One can try this but it will result in an error
# df &lt;- data.frame(df, d = d) 
rdf &lt;- rrpp.data.frame(rdf, d = d) # works

fit &lt;- lm.rrpp(d ~ x, data = rdf, iter = 99)
summary(fit)
</code></pre>

<hr>
<h2 id='scaleCov'>Scaling of a Covariance Matrix</h2><span id='topic+scaleCov'></span>

<h3>Description</h3>

<p>Function performs linear and exponential scaling of a covariance, 
either including or excluding diagonals or off-diagonal elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleCov(
  Cov,
  scale. = 1,
  exponent = 1,
  scale.diagonal = FALSE,
  scale.only.diagonal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleCov_+3A_cov">Cov</code></td>
<td>
<p>Square matrix to be scaled.</p>
</td></tr>
<tr><td><code id="scaleCov_+3A_scale.">scale.</code></td>
<td>
<p>The linear scaling parameter.  Values are multiplied by this numeric value.</p>
</td></tr>
<tr><td><code id="scaleCov_+3A_exponent">exponent</code></td>
<td>
<p>The exponentiation scaling parameter.  Values are raised to this power.</p>
</td></tr>
<tr><td><code id="scaleCov_+3A_scale.diagonal">scale.diagonal</code></td>
<td>
<p>Logical to indicate if diagonal should be included.</p>
</td></tr>
<tr><td><code id="scaleCov_+3A_scale.only.diagonal">scale.only.diagonal</code></td>
<td>
<p>Logical to indicate if only the diagonal should be scaled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function scales covariances as scale * cov ^exponent, where cov is any 
covariance or variance in the covariance matrix.  Arguments allow inclusion
or exclusion or either the diagonal or off-diagonal elements to be scaled.  It is 
assumed that a covariance matrix is scaled, but any square matrix will work.
</p>


<h3>Value</h3>

<p>A square matrix.
</p>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Pupfish)
Pupfish$logSize &lt;- log(Pupfish$CS)
fit1 &lt;- lm.rrpp(coords ~ logSize, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit2 &lt;- lm.rrpp(coords ~ Pop, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit3 &lt;- lm.rrpp(coords ~ Sex, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit4 &lt;- lm.rrpp(coords ~ logSize + Sex, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit5 &lt;- lm.rrpp(coords ~ logSize + Pop, data = Pupfish, iter = 0, 
print.progress = FALSE)
fit6 &lt;- lm.rrpp(coords ~ logSize + Sex * Pop, data = Pupfish, iter = 0, 
print.progress = FALSE)

modComp1 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, 
fit6, type = "cov.trace")
modComp2 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, 
fit6, type = "logLik", tol = 0.01)

summary(modComp1)
summary(modComp2)

par(mfcol = c(1,2))
plot(modComp1)
plot(modComp2)

# Comparing fits with covariance matrices
# an example for scaling a phylogenetic covariance matrix with
# the scaling parameter, lambda

data("PlethMorph")
Cov &lt;- PlethMorph$PhyCov
lambda &lt;- seq(0, 1, 0.1)

Cov1 &lt;- scaleCov(Cov, scale. = lambda[1])
Cov2 &lt;- scaleCov(Cov, scale. = lambda[2])
Cov3 &lt;- scaleCov(Cov, scale. = lambda[3])
Cov4 &lt;- scaleCov(Cov, scale. = lambda[4])
Cov5 &lt;- scaleCov(Cov, scale. = lambda[5])
Cov6 &lt;- scaleCov(Cov, scale. = lambda[6])
Cov7 &lt;- scaleCov(Cov, scale. = lambda[7])
Cov8 &lt;- scaleCov(Cov, scale. = lambda[8])
Cov9 &lt;- scaleCov(Cov, scale. = lambda[9])
Cov10 &lt;- scaleCov(Cov, scale. = lambda[10])
Cov11 &lt;- scaleCov(Cov, scale. = lambda[11])


fit1 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov1)
fit2 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov2)
fit3 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov3)
fit4 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov4)
fit5 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov5)
fit6 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov6)
fit7 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov7)
fit8 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov8)
fit9 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov9)
fit10 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov10)
fit11 &lt;- lm.rrpp(SVL ~ 1, data = PlethMorph, Cov = Cov11)

par(mfrow = c(1,1))

MC1 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, fit6,
fit7, fit8, fit9, fit10, fit11,
type = "logLik")
MC1
plot(MC1)

MC2 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, fit6,
fit7, fit8, fit9, fit10, fit11,
type = "logLik", predictor = lambda)
MC2
plot(MC2)


MC3 &lt;- model.comparison(fit1, fit2, fit3, fit4, fit5, fit6,
fit7, fit8, fit9, fit10, fit11,
type = "Z", predictor = lambda)
MC3
plot(MC3)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.anova.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+summary.anova.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova.lm.rrpp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.anova.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+predict.lm.rrpp">predict.lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="summary.anova.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto predict.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.coef.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+summary.coef.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.lm.rrpp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.coef.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+coef.lm.rrpp">coef.lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="summary.coef.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto coef.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.ICCstats'>Print/Summary Function for RRPP</h2><span id='topic+summary.ICCstats'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICCstats'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ICCstats_+3A_object">object</code></td>
<td>
<p>print/summary object (from <code><a href="#topic+ICCstats">ICCstats</a></code>)</p>
</td></tr>
<tr><td><code id="summary.ICCstats_+3A_...">...</code></td>
<td>
<p>other arguments passed to print/summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+summary.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
summary(object, formula = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lm.rrpp_+3A_object">object</code></td>
<td>
<p>print/summary object (from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>)</p>
</td></tr>
<tr><td><code id="summary.lm.rrpp_+3A_formula">formula</code></td>
<td>
<p>Logical argument for whether to include formula in summary table</p>
</td></tr>
<tr><td><code id="summary.lm.rrpp_+3A_...">...</code></td>
<td>
<p>other arguments passed to print/summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.looCV'>Print/Summary Function for RRPP</h2><span id='topic+summary.looCV'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'looCV'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.looCV_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+looCV">looCV</a></code></p>
</td></tr>
<tr><td><code id="summary.looCV_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.looCV</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.lr_test'>Print/Summary Function for RRPP</h2><span id='topic+summary.lr_test'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lr_test'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lr_test_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lr_test">lr_test</a></code></p>
</td></tr>
<tr><td><code id="summary.lr_test_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.lr_test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.manova.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+summary.manova.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'manova.lm.rrpp'
summary(object, test = c("Roy", "Pillai", "Hotelling-Lawley", "Wilks"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.manova.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>, updated with 
<code><a href="#topic+manova.update">manova.update</a></code></p>
</td></tr>
<tr><td><code id="summary.manova.lm.rrpp_+3A_test">test</code></td>
<td>
<p>Type of multivariate test statistic to use.</p>
</td></tr>
<tr><td><code id="summary.manova.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto manova.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.measurement.error'>Print/Summary Function for RRPP</h2><span id='topic+summary.measurement.error'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measurement.error'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.measurement.error_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+measurement.error">measurement.error</a></code></p>
</td></tr>
<tr><td><code id="summary.measurement.error_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto measurement.error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.model.comparison'>Print/Summary Function for RRPP</h2><span id='topic+summary.model.comparison'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model.comparison'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.model.comparison_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+model.comparison">model.comparison</a></code></p>
</td></tr>
<tr><td><code id="summary.model.comparison_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto model.comparison</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.ordinate'>Print/Summary Function for RRPP</h2><span id='topic+summary.ordinate'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinate'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ordinate_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+ordinate">ordinate</a></code></p>
</td></tr>
<tr><td><code id="summary.ordinate_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto print.ordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.pairwise'>Print/Summary Function for RRPP</h2><span id='topic+summary.pairwise'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+pairwise">pairwise</a></code> for further description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwise'
summary(
  object,
  stat.table = TRUE,
  test.type = c("dist", "VC", "DL", "var"),
  angle.type = c("rad", "deg"),
  confidence = 0.95,
  show.vectors = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pairwise_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+pairwise">pairwise</a></code></p>
</td></tr>
<tr><td><code id="summary.pairwise_+3A_stat.table">stat.table</code></td>
<td>
<p>Logical argument for whether results should be 
returned in one table 
(if TRUE) or separate pairwise tables (if FALSE)</p>
</td></tr>
<tr><td><code id="summary.pairwise_+3A_test.type">test.type</code></td>
<td>
<p>the type of statistic to test.  See below
should be used in the test.</p>
</td></tr>
<tr><td><code id="summary.pairwise_+3A_angle.type">angle.type</code></td>
<td>
<p>If test.type = &quot;VC&quot;, whether angle results are 
expressed in radians or degrees.</p>
</td></tr>
<tr><td><code id="summary.pairwise_+3A_confidence">confidence</code></td>
<td>
<p>Confidence level to use for upper confidence 
limit; default = 0.95 (alpha = 0.05)</p>
</td></tr>
<tr><td><code id="summary.pairwise_+3A_show.vectors">show.vectors</code></td>
<td>
<p>Logical value to indicate whether vectors 
should be printed.</p>
</td></tr>
<tr><td><code id="summary.pairwise_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto pairwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following summarize the test that can be performed: 
</p>
<p>#' </p>

<dl>
<dt><b>Distance between vectors, &quot;dist&quot;</b></dt><dd><p> Vectors for LS means or 
slopes originate at the origin and point to some location, having both a 
magnitude
and direction.  A distance between two vectors is the inner-product of of 
the vector difference, i.e., the distance between their endpoints.  For
LS means, this distance is the difference between means.  For multivariate 
slope vectors, this is the difference in location between estimated change 
for the dependent variables, per one-unit change of the covariate considered.  
For univariate slopes, this is the absolute difference between slopes.</p>
</dd>
<dt><b>Vector correlation, &quot;VC&quot;</b></dt><dd><p> If LS mean or slope vectors are 
scaled to unit size, the vector correlation is the inner-product of the 
scaled vectors.
The arccosine (acos) of this value is the angle between vectors, which 
can be expressed in radians or degrees.  Vector correlation indicates 
the similarity of 
vector orientation, independent of vector length.</p>
</dd>
<dt><b>Difference in vector lengths, &quot;DL&quot;</b></dt><dd><p>  If the length of a 
vector is an important attribute &ndash; e.g., the amount of multivariate 
change per one-unit
change in a covariate &ndash; then the absolute value of the difference in 
vector lengths is a practical statistic to compare vector lengths.  
Let d1 and
d2 be the distances (length) of vectors.  Then |d1 - d2| is a statistic 
that compares their lengths.</p>
</dd>
<dt><b>Variance, &quot;var&quot;</b></dt><dd><p>  Vectors of residuals from a linear 
model indicate can express the distances of observed values from 
fitted values.  Mean
squared distances of values (variance), by group, can be used to 
measure the amount of dispersion around estimated values for groups.  
Absolute
differences between variances are used as test statistics to compare 
mean dispersion of values among groups.  Variance degrees of freedom 
equal n, 
the group size, rather than n-1, as the purpose is to compare mean 
dispersion 
in the sample.  (Additionally, tests with one subject in a group 
are possible, or at least not a hindrance to the analysis.)</p>
</dd>
</dl>

<p>The argument, <code>test.type</code> is used to select one of the tests 
above.  See <code><a href="#topic+pairwise">pairwise</a></code> for examples.
</p>


<h4>Notes for RRPP 0.6.2 and subsequent versions</h4>

 
<p>In previous versions of pairwise, <code><a href="#topic+summary.pairwise">summary.pairwise</a></code> had three 
test types: &quot;dist&quot;, &quot;VC&quot;, and &quot;var&quot;.  When one chose &quot;dist&quot;, for LS mean 
vectors, the statistic was the inner-product of the vector difference.  
For slope vectors, &quot;dist&quot; returned the absolute value  of the difference 
between vector lengths, which is &quot;DL&quot; in 0.6.2 and subsequent versions.  This
update uses the same calculation, irrespective of vector types.  Generally,
&quot;DL&quot; is the same as a contrast in rates for slope vectors, but might not have
much meaning for LS means.  Likewise, &quot;dist&quot; is the distance between vector
endpoints, which might make more sense for LS means than slope vectors.  
Nevertheless, the user has more control over these decisions with version 0.6.2
and subsequent versions.
</p>



<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.predict.lm.rrpp'>Print/Summary Function for RRPP</h2><span id='topic+summary.predict.lm.rrpp'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.lm.rrpp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.predict.lm.rrpp_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+predict.lm.rrpp">predict.lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="summary.predict.lm.rrpp_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto predict.lm.rrpp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='summary.trajectory.analysis'>Print/Summary Function for RRPP</h2><span id='topic+summary.trajectory.analysis'></span>

<h3>Description</h3>

<p>Print/Summary Function for RRPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory.analysis'
summary(
  object,
  stat.table = TRUE,
  attribute = c("MD", "TC", "SD"),
  angle.type = c("rad", "deg"),
  confidence = 0.95,
  show.trajectories = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.trajectory.analysis_+3A_object">object</code></td>
<td>
<p>Object from <code><a href="#topic+trajectory.analysis">trajectory.analysis</a></code></p>
</td></tr>
<tr><td><code id="summary.trajectory.analysis_+3A_stat.table">stat.table</code></td>
<td>
<p>Logical argument for whether results should be 
returned in one table 
(if TRUE) or separate pairwise tables (if FALSE)</p>
</td></tr>
<tr><td><code id="summary.trajectory.analysis_+3A_attribute">attribute</code></td>
<td>
<p>Whether magnitude differences (MD, absolute difference 
in trajectory path lengths), 
trajectory correlations (TC), or trajectory shape differences (SD) are 
summarized.</p>
</td></tr>
<tr><td><code id="summary.trajectory.analysis_+3A_angle.type">angle.type</code></td>
<td>
<p>If attribute = &quot;TC&quot;, whether angle results are 
expressed in radians or degrees.</p>
</td></tr>
<tr><td><code id="summary.trajectory.analysis_+3A_confidence">confidence</code></td>
<td>
<p>Confidence level to use for upper confidence limit; 
default = 0.95 (alpha = 0.05)</p>
</td></tr>
<tr><td><code id="summary.trajectory.analysis_+3A_show.trajectories">show.trajectories</code></td>
<td>
<p>Logical value to indicate whether trajectories 
should be printed.</p>
</td></tr>
<tr><td><code id="summary.trajectory.analysis_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto trajectory.analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='terms.lm.rrpp'>Extract the terms from an lm.rrpp object</h2><span id='topic+terms.lm.rrpp'></span>

<h3>Description</h3>

<p><code>terms.lm.rrpp</code> returns the terms constructed for an <code>lm.rrpp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.rrpp'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.lm.rrpp_+3A_x">x</code></td>
<td>
<p>Object from <code><a href="#topic+lm.rrpp">lm.rrpp</a></code></p>
</td></tr>
<tr><td><code id="terms.lm.rrpp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

<hr>
<h2 id='trajectory.analysis'>Quantify and compare shape change trajectories</h2><span id='topic+trajectory.analysis'></span>

<h3>Description</h3>

<p>Function estimates attributes of multivariate trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectory.analysis(
  fit,
  fit.null = NULL,
  groups,
  traj.pts,
  pca = TRUE,
  print.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectory.analysis_+3A_fit">fit</code></td>
<td>
<p>A linear model fit using <code><a href="#topic+lm.rrpp">lm.rrpp</a></code>.</p>
</td></tr>
<tr><td><code id="trajectory.analysis_+3A_fit.null">fit.null</code></td>
<td>
<p>An alternative linear model fit to use as a null model for 
RRPP, if the null model
of the fit is not desired.  Note, if RRPP = FALSE (FRPP rather than RRPP), 
then the null model has only an intercept.
If the null model is uncertain, using <code><a href="#topic+reveal.model.designs">reveal.model.designs</a></code> 
will help elucidate the inherent null model used.</p>
</td></tr>
<tr><td><code id="trajectory.analysis_+3A_groups">groups</code></td>
<td>
<p>A factor or vector coercible to factor that defines trajectories.</p>
</td></tr>
<tr><td><code id="trajectory.analysis_+3A_traj.pts">traj.pts</code></td>
<td>
<p>Either a single value or a vector coercible to factor to 
define trajectory points.  If only a single value, 
it is assumed that the data are already in the form, 
y1p1, y2p1, y3p1, ...., y2p2, y2p2, y3p2, ..., yjp1, yjp2, yjp3, ..., yjpk, 
for j variables comprising k trajectory points;
i.e., traj.pts = k.  If a factor, then a group * traj.pt factorial model 
is assumed, where traj.pts defines the levels for points within groups.</p>
</td></tr>
<tr><td><code id="trajectory.analysis_+3A_pca">pca</code></td>
<td>
<p>A logical value to optionally project group:point means onto 
principal components (perform PCA on a covariance matrix of the means)
This option only applies to factorial designs (traj.pts is a factor).</p>
</td></tr>
<tr><td><code id="trajectory.analysis_+3A_print.progress">print.progress</code></td>
<td>
<p>A logical value to indicate whether a progress bar 
should be printed to the screen.  
This is helpful for long-running analyses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function quantifies multivariate trajectories from a set 
of observations, and assesses variation 
in attributes of the trajectories via RRPP. A trajectory is defined 
by a sequence 
of points in the data space. These trajectories can be quantified for 
various attributes (their size, orientation, 
and shape), and comparisons of these attribute enable the statistical 
comparison of shape change 
trajectories (Collyer and Adams 2007; Adams and Collyer 2007; 
Adams and Collyer 2009; Turner et al. 2010; Collyer and Adams 2013). 
</p>
<p>This function is a modified version of <code><a href="#topic+pairwise">pairwise</a></code>, retaining 
the least squares (LS) means as trajectory points.
Analysis starts with a <code><a href="#topic+lm.rrpp">lm.rrpp</a></code> fit (but a procD.lm fit from 
geomorph can also be used).  LS means are calculated using a grouping
variable.  Data can be trajectories, as a start(sensu Adams and Cerney 2007), 
or trajectories can be calculated from data using a factorial model 
(in which case
trajectory points are defined by factor levels).  
</p>
<p>This function produces statistics that can be summarized with the 
<code><a href="#topic+summary.trajectory.analysis">summary.trajectory.analysis</a></code> function.  The summaries
are consistent with those in the <code><a href="#topic+summary.pairwise">summary.pairwise</a></code> 
function, pertaining to trajectory attributes including,
magnitude difference (MD), the difference in path lengths of trajectories; 
trajectory correlations (TC), better
thought of as angular differences between trajectory principal axes; and if 
trajectories have three or more points,
shape difference (SD), the square root of summed squared point differences, 
after scaling, centering, and rotating trajectories.  The SD is
the &quot;Procrustes&quot; distance between trajectories (Adams and Collyer 2009), 
much the same way as the shape difference between anatomical landmark
configurations in geometric morphometrics.  If attribute = &quot;TC&quot; is chosen 
for the summary, then the angle type (&quot;rad&quot; or &quot;deg&quot;,
can be chosen for either radians and degrees, respectively, to return 
angles between principal axes.)
</p>
<p>Plotting can be performed with <code><a href="#topic+plot.trajectory.analysis">plot.trajectory.analysis</a></code> and 
<code><a href="#topic+add.trajectories">add.trajectories</a></code>.  The former
plots all principal component scores for the data, and allows point-by-point 
control of plot parameters.  The later
adds trajectories points and lines, with constrained control.  By saving the 
plot.trajectory.analysis
object, plotting information can be retained and advanced plotting can be 
performed.  See examples below.
</p>


<h3>Value</h3>

<p>An object of class &quot;trajectory.analysis&quot; returns a list of the 
following:
</p>
<table>
<tr><td><code>LS.means</code></td>
<td>
<p>LS.means from pairwise function.</p>
</td></tr>
<tr><td><code>trajectories</code></td>
<td>
<p>Trajectories from every permutation.</p>
</td></tr>
<tr><td><code>PD</code></td>
<td>
<p>Path distances of trajectories from every permutation.</p>
</td></tr>
<tr><td><code>MD</code></td>
<td>
<p>Magnitude differences between trajectories from every permutation.</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>Trajectory correlations from every permutation.</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p>Trajectory shape differences from every permutation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dean Adams and Michael Collyer
</p>


<h3>References</h3>

<p>Adams, D. C., and M. M. Cerney. 2007. Quantifying biomechanical 
motion using Procrustes 
motion analysis. J. Biomech. 40:437-444.
</p>
<p>Adams, D. C., and M. L. Collyer. 2007. The analysis of 
character divergence along environmental 
gradients and other covariates. Evolution 61:510-515.
</p>
<p>Adams, D. C., and M. L. Collyer. 2009. A general framework 
for the analysis of phenotypic 
trajectories in evolutionary studies. Evolution 63:1143-1154.
</p>
<p>Collyer, M. L., and D. C. Adams. 2007. Analysis of two-state 
multivariate phenotypic change 
in ecological studies. Ecology 88:683-692.
</p>
<p>Collyer, M. L., and D. C. Adams. 2013. Phenotypic trajectory 
analysis: comparison of shape change patterns 
in evolution and ecology. Hystrix 24: 75-83.
</p>
<p>Collyer, M.L., D.J. Sekora, and D.C. Adams. 2015. A method for 
analysis of phenotypic change for phenotypes described 
by high-dimensional data. Heredity. 115:357-365.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Analysis of sexual dimorphism vectors (factorial approach)
data(Pupfish)
fit &lt;- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 199)
reveal.model.designs(fit)
TA &lt;- trajectory.analysis(fit, groups = Pupfish$Pop, 
traj.pts = Pupfish$Sex, print.progress = FALSE)

# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD") 

# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg") 

# No shape differences between vectors
summary(TA, attribute = "SD") 

# Retain results
TA.summary &lt;- summary(TA, attribute = "MD")
TA.summary$summary.table

# Plot results
TP &lt;- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)

### Analysis when data are already trajectories (motion paths)

# data are planar Cartesian coordinates (x, y) across 5 points (10 variables)
data(motionpaths)
fit &lt;- lm.rrpp(trajectories ~ groups, data = motionpaths, iter = 199)
TA &lt;- trajectory.analysis(fit, groups = motionpaths$groups, traj.pts = 5)

# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD") 

# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg") 

# Shape differences between trajectories 
summary(TA, attribute = "SD") 

TP &lt;- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)

## End(Not run)
</code></pre>

<hr>
<h2 id='vec.cor.matrix'>Support function for RRPP</h2><span id='topic+vec.cor.matrix'></span>

<h3>Description</h3>

<p>Calculate vector correlations for a matrix (by rows).  
Used for pairwise comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec.cor.matrix(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec.cor.matrix_+3A_m">M</code></td>
<td>
<p>Matrix for vector correlations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Collyer
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
