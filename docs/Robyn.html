<!DOCTYPE html><html lang="en"><head><title>Help for package Robyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Robyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Robyn'><p>Robyn MMM Project from Meta Marketing Science</p></a></li>
<li><a href='#adstock_geometric'><p>Adstocking Transformation (Geometric and Weibull)</p></a></li>
<li><a href='#dt_prophet_holidays'><p>Robyn Dataset: Holidays by Country</p></a></li>
<li><a href='#dt_simulated_weekly'><p>Robyn Dataset: MMM Demo Data</p></a></li>
<li><a href='#fit_spend_exposure'><p>Fit a nonlinear model for media spend and exposure</p></a></li>
<li><a href='#hyper_limits'><p>Check hyperparameter limits</p></a></li>
<li><a href='#hyper_names'><p>Get correct hyperparameter names</p></a></li>
<li><a href='#mic_men'><p>Michaelis-Menten Transformation</p></a></li>
<li><a href='#prophet_decomp'><p>Conduct prophet decomposition</p></a></li>
<li><a href='#robyn_allocator'><p>Budget Allocator</p></a></li>
<li><a href='#robyn_clusters'><p>Clustering to Reduce Number of Models based on ROI and Errors</p></a></li>
<li><a href='#robyn_converge'><p>Check Models Convergence</p></a></li>
<li><a href='#robyn_inputs'><p>Input Data Check &amp; Transformation</p></a></li>
<li><a href='#robyn_mmm'><p>Core MMM Function</p></a></li>
<li><a href='#robyn_outputs'><p>Evaluate Models and Output Results into Local Files</p></a></li>
<li><a href='#robyn_refresh'><p>Build Refresh Model</p></a></li>
<li><a href='#robyn_response'><p>Response and Saturation Curves</p></a></li>
<li><a href='#robyn_run'><p>Robyn Modelling Function</p></a></li>
<li><a href='#robyn_save'><p>Export Robyn Model to Local File [DEPRECATED]</p></a></li>
<li><a href='#robyn_train'><p>Train Robyn Models</p></a></li>
<li><a href='#robyn_update'><p>Update Robyn Version</p></a></li>
<li><a href='#robyn_write'><p>Import and Export Robyn JSON files</p></a></li>
<li><a href='#saturation_hill'><p>Hill Saturation Transformation</p></a></li>
<li><a href='#set_holidays'><p>Detect and set date variable interval</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Semi-Automated Marketing Mix Modeling (MMM) from Meta Marketing
Science</td>
</tr>
<tr>
<td>Version:</td>
<td>3.11.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernardo Lares &lt;laresbernardo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Semi-Automated Marketing Mix Modeling (MMM) aiming to reduce human bias by means of ridge regression and evolutionary algorithms, enables actionable decision making providing a budget allocation and diminishing returns curves and allows ground-truth calibration to account for causation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, doRNG, dplyr, foreach, ggplot2, ggridges, glmnet,
jsonlite, lares, lubridate, minpack.lm, nloptr, patchwork,
prophet, reticulate, stringr, tidyr</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "nevergrad",
pip = TRUE) ) )</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/facebookexperimental/Robyn">https://github.com/facebookexperimental/Robyn</a>,
<a href="https://facebookexperimental.github.io/Robyn/">https://facebookexperimental.github.io/Robyn/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/facebookexperimental/Robyn/issues">https://github.com/facebookexperimental/Robyn/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 07:12:58 UTC; bernardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Gufeng Zhou [aut],
  Bernardo Lares [cre, aut],
  Leonel Sentana [aut],
  Igor Skokan [aut],
  Meta Platforms, Inc. [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-27 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Robyn'>Robyn MMM Project from Meta Marketing Science</h2><span id='topic+Robyn'></span><span id='topic+Robyn-package'></span>

<h3>Description</h3>

<p>Robyn is an automated Marketing Mix Modeling (MMM) code. It aims to reduce human
bias by means of ridge regression and evolutionary algorithms, enables actionable
decision making providing a budget allocator and diminishing returns curves and
allows ground-truth calibration to account for causation.
</p>


<h3>Author(s)</h3>

<p>Gufeng Zhou (gufeng@meta.com)
</p>
<p>Leonel Sentana (leonelsentana@meta.com)
</p>
<p>Igor Skokan (igorskokan@meta.com)
</p>
<p>Bernardo Lares (bernardolares@meta.com)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/facebookexperimental/Robyn">https://github.com/facebookexperimental/Robyn</a>
</p>
</li>
<li> <p><a href="https://facebookexperimental.github.io/Robyn/">https://facebookexperimental.github.io/Robyn/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/facebookexperimental/Robyn/issues">https://github.com/facebookexperimental/Robyn/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adstock_geometric'>Adstocking Transformation (Geometric and Weibull)</h2><span id='topic+adstock_geometric'></span><span id='topic+adstock_weibull'></span><span id='topic+transform_adstock'></span><span id='topic+plot_adstock'></span>

<h3>Description</h3>

<p><code>adstock_geometric()</code> for Geometric Adstocking is the classic one-parametric
adstock function.
</p>
<p><code>adstock_weibull()</code> for Weibull Adstocking is a two-parametric adstock
function that allows changing decay rate over time, as opposed to the fixed
decay rate over time as in Geometric adstock. It has two options, the cumulative
density function &quot;CDF&quot; or the probability density function &quot;PDF&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adstock_geometric(x, theta)

adstock_weibull(x, shape, scale, windlen = length(x), type = "cdf")

transform_adstock(
  x,
  adstock,
  theta = NULL,
  shape = NULL,
  scale = NULL,
  windlen = length(x)
)

plot_adstock(plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adstock_geometric_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="adstock_geometric_+3A_theta">theta</code></td>
<td>
<p>Numeric. Theta is the only parameter on Geometric Adstocking and means
fixed decay rate. Assuming TV spend on day 1 is 100€ and theta = 0.7, then day 2 has
100 x 0.7 = 70€ worth of effect carried-over from day 1, day 3 has 70 x 0.7 = 49€
from day 2 etc. Rule-of-thumb for common media genre: TV c(0.3, 0.8), OOH/Print/
Radio c(0.1, 0.4), digital c(0, 0.3).</p>
</td></tr>
<tr><td><code id="adstock_geometric_+3A_shape">shape</code>, <code id="adstock_geometric_+3A_scale">scale</code></td>
<td>
<p>Numeric. Check &quot;Details&quot; section for more details.</p>
</td></tr>
<tr><td><code id="adstock_geometric_+3A_windlen">windlen</code></td>
<td>
<p>Integer. Length of modelling window. By default, same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="adstock_geometric_+3A_type">type</code></td>
<td>
<p>Character. Accepts &quot;CDF&quot; or &quot;PDF&quot;. CDF, or cumulative density
function of the Weibull function allows changing decay rate over time in both
C and S shape, while the peak value will always stay at the first period,
meaning no lagged effect. PDF, or the probability density function, enables
peak value occurring after the first period when shape &gt;=1, allowing lagged
effect.</p>
</td></tr>
<tr><td><code id="adstock_geometric_+3A_adstock">adstock</code></td>
<td>
<p>Character. One of: &quot;geometric&quot;, &quot;weibull_cdf&quot;, &quot;weibull_pdf&quot;.</p>
</td></tr>
<tr><td><code id="adstock_geometric_+3A_plot">plot</code></td>
<td>
<p>Boolean. Do you wish to return the plot?</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Weibull's CDF (Cumulative Distribution Function)</dt><dd><p>has
two parameters, shape &amp; scale, and has flexible decay rate, compared to Geometric
adstock with fixed decay rate. The shape parameter controls the shape of the decay
curve. Recommended bound is c(0.0001, 2). The larger the shape, the more S-shape. The
smaller, the more L-shape. Scale controls the inflexion point of the decay curve. We
recommend very conservative bounce of c(0, 0.1), because scale increases the adstock
half-life greatly.</p>
</dd>
<dt>Weibull's PDF (Probability Density Function)</dt><dd><p>also shape &amp; scale as parameter
and also has flexible decay rate as Weibull CDF. The difference is that Weibull PDF
offers lagged effect. When shape &gt; 2, the curve peaks after x = 0 and has NULL slope at
x = 0, enabling lagged effect and sharper increase and decrease of adstock, while the
scale parameter indicates the limit of the relative position of the peak at x axis; when
1 &lt; shape &lt; 2, the curve peaks after x = 0 and has infinite positive slope at x = 0,
enabling lagged effect and slower increase and decrease of adstock, while scale has the
same effect as above; when shape = 1, the curve peaks at x = 0 and reduces to exponential
decay, while scale controls the inflexion point; when 0 &lt; shape &lt; 1, the curve peaks at
x = 0 and has increasing decay, while scale controls the inflexion point. When all
possible shapes are relevant, we recommend c(0.0001, 10) as bounds for shape; when only
strong lagged effect is of interest, we recommend c(2.0001, 10) as bound for shape. In
all cases, we recommend conservative bound of c(0, 0.1) for scale. Due to the great
flexibility of Weibull PDF, meaning more freedom in hyperparameter spaces for Nevergrad
to explore, it also requires larger iterations to converge.</p>
</dd>
</dl>

<p>Run <code>plot_adstock()</code> to see the difference visually.
</p>


<h3>Value</h3>

<p>Numeric values. Transformed values.
</p>


<h3>See Also</h3>

<p>Other Transformations: 
<code><a href="#topic+mic_men">mic_men</a>()</code>,
<code><a href="#topic+saturation_hill">saturation_hill</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adstock_geometric(rep(100, 5), theta = 0.5)
adstock_weibull(rep(100, 5), shape = 0.5, scale = 0.5, type = "CDF")
adstock_weibull(rep(100, 5), shape = 0.5, scale = 0.5, type = "PDF")

# Wrapped function for either adstock
transform_adstock(rep(100, 10), "weibull_pdf", shape = 1, scale = 0.5)
</code></pre>

<hr>
<h2 id='dt_prophet_holidays'>Robyn Dataset: Holidays by Country</h2><span id='topic+dt_prophet_holidays'></span>

<h3>Description</h3>

<p>Contains <code>prophet</code>'s &quot;new&quot; default holidays by country.
When using own holidays, please keep the header
<code>c("ds", "holiday", "country", "year")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dt_prophet_holidays)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>

<dl>
<dt>ds</dt><dd><p>Date</p>
</dd>
<dt>holiday</dt><dd><p>Name of celebrated holiday</p>
</dd>
<dt>country</dt><dd><p>Code for the country (Alpha-2)</p>
</dd>
<dt>year</dt><dd><p>Year of <code>ds</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>data.frame
</p>
<p>Dataframe. Contains <code>prophet</code>'s default holidays by country.
</p>


<h3>See Also</h3>

<p>Other Dataset: 
<code><a href="#topic+dt_simulated_weekly">dt_simulated_weekly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dt_prophet_holidays)
head(dt_prophet_holidays)
</code></pre>

<hr>
<h2 id='dt_simulated_weekly'>Robyn Dataset: MMM Demo Data</h2><span id='topic+dt_simulated_weekly'></span>

<h3>Description</h3>

<p>Simulated MMM data. Input time series should be daily, weekly or monthly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dt_simulated_weekly)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>

<dl>
<dt>DATE</dt><dd><p>Date</p>
</dd>
<dt>revenue</dt><dd><p>Daily total revenue</p>
</dd>
<dt>tv_S</dt><dd><p>Television</p>
</dd>
<dt>ooh_S</dt><dd><p>Out of home</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
</dl>



<h3>Value</h3>

<p>data.frame
</p>
<p>Dataframe. Contains simulated dummy dataset to test and run demo.
</p>


<h3>See Also</h3>

<p>Other Dataset: 
<code><a href="#topic+dt_prophet_holidays">dt_prophet_holidays</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dt_simulated_weekly)
head(dt_simulated_weekly)
</code></pre>

<hr>
<h2 id='fit_spend_exposure'>Fit a nonlinear model for media spend and exposure</h2><span id='topic+fit_spend_exposure'></span>

<h3>Description</h3>

<p>This function is called in <code>robyn_engineering()</code>. It uses
the Michaelis-Menten function to fit the nonlinear model. Fallback
model is the simple linear model <code>lm()</code> in case the nonlinear
model is fitting worse. A bad fit here might result in unreasonable
model results. Two options are recommended: Either splitting the
channel into sub-channels to achieve better fit, or just use
spend as <code>paid_media_vars</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_spend_exposure(dt_spendModInput, mediaCostFactor, paid_media_var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_spend_exposure_+3A_dt_spendmodinput">dt_spendModInput</code></td>
<td>
<p>data.frame. Containing channel spends and
exposure data.</p>
</td></tr>
<tr><td><code id="fit_spend_exposure_+3A_mediacostfactor">mediaCostFactor</code></td>
<td>
<p>Numeric vector. The ratio between raw media
exposure and spend metrics.</p>
</td></tr>
<tr><td><code id="fit_spend_exposure_+3A_paid_media_var">paid_media_var</code></td>
<td>
<p>Character. Paid media variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Containing the all spend-exposure model results.
</p>

<hr>
<h2 id='hyper_limits'>Check hyperparameter limits</h2><span id='topic+hyper_limits'></span>

<h3>Description</h3>

<p>Reference data.frame that shows the upper and lower bounds valid
for each hyperparameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_limits()
</code></pre>


<h3>Value</h3>

<p>Dataframe. Contains upper and lower bounds for each hyperparameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hyper_limits()
</code></pre>

<hr>
<h2 id='hyper_names'>Get correct hyperparameter names</h2><span id='topic+hyper_names'></span>

<h3>Description</h3>

<p>Output all hyperparameter names and help specifying the list of
hyperparameters that is inserted into <code>robyn_inputs(hyperparameters = ...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_names(adstock, all_media, all_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_names_+3A_adstock">adstock</code></td>
<td>
<p>Character. Default to <code>InputCollect$adstock</code>.
Accepts &quot;geometric&quot;, &quot;weibull_cdf&quot; or &quot;weibull_pdf&quot;</p>
</td></tr>
<tr><td><code id="hyper_names_+3A_all_media">all_media</code></td>
<td>
<p>Character vector. Default to <code>InputCollect$all_media</code>.
Includes <code>InputCollect$paid_media_spends</code> and <code>InputCollect$organic_vars</code>.</p>
</td></tr>
<tr><td><code id="hyper_names_+3A_all_vars">all_vars</code></td>
<td>
<p>Used to check the penalties inputs, especially for refreshing models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector. Names of hyper-parameters that should be defined.
</p>


<h3>Guide to setup hyperparameters</h3>


<ol>
<li><p> Get correct hyperparameter names:
All variables in <code>paid_media_vars</code> or <code>organic_vars</code> require hyperprameters
and will be transformed by adstock &amp; saturation. Difference between <code>paid_media_vars</code>
and <code>organic_vars</code> is that <code>paid_media_vars</code> has spend that
needs to be specified in <code>paid_media_spends</code> specifically. Run <code>hyper_names()</code>
to get correct hyperparameter names. All names in hyperparameters must
equal names from <code>hyper_names()</code>, case sensitive.
</p>
</li>
<li><p> Get guidance for setting hyperparameter bounds:
For geometric adstock, use theta, alpha &amp; gamma. For both weibull adstock options,
use shape, scale, alpha, gamma.
</p>

<ul>
<li><p> Theta: In geometric adstock, theta is decay rate. guideline for usual media genre:
TV c(0.3, 0.8), OOH/Print/Radio c(0.1, 0.4), digital c(0, 0.3)
</p>
</li>
<li><p> Shape: In weibull adstock, shape controls the decay shape. Recommended c(0.0001, 2).
The larger, the more S-shape. The smaller, the more L-shape. Channel-type specific
values still to be investigated
</p>
</li>
<li><p> Scale: In weibull adstock, scale controls the decay inflexion point. Very conservative
recommended bounce c(0, 0.1), because scale can increase adstocking half-life greatly.
Channel-type specific values still to be investigated
</p>
</li>
<li><p> Gamma: In s-curve transformation with hill function, gamma controls the inflexion point.
Recommended bounce c(0.3, 1). The larger the gamma, the later the inflection point
in the response curve
</p>
</li></ul>

</li>
<li><p> Set each hyperparameter bounds. They either contains two values e.g. c(0, 0.5),
or only one value (in which case you've &quot;fixed&quot; that hyperparameter)
</p>
</li></ol>



<h3>Helper plots</h3>


<dl>
<dt>plot_adstock</dt><dd><p>Get adstock transformation example plot,
helping you understand geometric/theta and weibull/shape/scale transformation</p>
</dd>
<dt>plot_saturation</dt><dd><p>Get saturation curve transformation example plot,
helping you understand hill/alpha/gamma transformation</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
media &lt;- c("facebook_S", "print_S", "tv_S")
hyper_names(adstock = "geometric", all_media = media)

hyperparameters &lt;- list(
  facebook_S_alphas = c(0.5, 3), # example bounds for alpha
  facebook_S_gammas = c(0.3, 1), # example bounds for gamma
  facebook_S_thetas = c(0, 0.3), # example bounds for theta
  print_S_alphas = c(0.5, 3),
  print_S_gammas = c(0.3, 1),
  print_S_thetas = c(0.1, 0.4),
  tv_S_alphas = c(0.5, 3),
  tv_S_gammas = c(0.3, 1),
  tv_S_thetas = c(0.3, 0.8)
)

# Define hyper_names for weibull adstock
hyper_names(adstock = "weibull", all_media = media)

hyperparameters &lt;- list(
  facebook_S_alphas = c(0.5, 3), # example bounds for alpha
  facebook_S_gammas = c(0.3, 1), # example bounds for gamma
  facebook_S_shapes = c(0.0001, 2), # example bounds for shape
  facebook_S_scales = c(0, 0.1), # example bounds for scale
  print_S_alphas = c(0.5, 3),
  print_S_gammas = c(0.3, 1),
  print_S_shapes = c(0.0001, 2),
  print_S_scales = c(0, 0.1),
  tv_S_alphas = c(0.5, 3),
  tv_S_gammas = c(0.3, 1),
  tv_S_shapes = c(0.0001, 2),
  tv_S_scales = c(0, 0.1)
)

</code></pre>

<hr>
<h2 id='mic_men'>Michaelis-Menten Transformation</h2><span id='topic+mic_men'></span>

<h3>Description</h3>

<p>The Michaelis-Menten <code>mic_men()</code> function is used to fit the spend
exposure relationship for paid media variables, when exposure metrics like
impressions, clicks or GRPs are provided in <code>paid_media_vars</code> instead
of spend metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_men(x, Vmax, Km, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mic_men_+3A_x">x</code></td>
<td>
<p>Numeric value or vector. Input media spend when
<code>reverse = FALSE</code>. Input media exposure metrics (impression, clicks,
GRPs, etc.) when <code>reverse = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mic_men_+3A_vmax">Vmax</code></td>
<td>
<p>Numeric Indicates maximum rate achieved by the system.</p>
</td></tr>
<tr><td><code id="mic_men_+3A_km">Km</code></td>
<td>
<p>Numeric. The Michaelis constant.</p>
</td></tr>
<tr><td><code id="mic_men_+3A_reverse">reverse</code></td>
<td>
<p>Boolean. Input media spend when <code>reverse = FALSE</code>.
Input media exposure metrics (impression, clicks, GRPs etc.) when <code>reverse = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric values. Transformed values.
</p>


<h3>See Also</h3>

<p>Other Transformations: 
<code><a href="#topic+adstock_geometric">adstock_geometric</a>()</code>,
<code><a href="#topic+saturation_hill">saturation_hill</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mic_men(x = 5:10, Vmax = 5, Km = 0.5)
</code></pre>

<hr>
<h2 id='prophet_decomp'>Conduct prophet decomposition</h2><span id='topic+prophet_decomp'></span>

<h3>Description</h3>

<p>When <code>prophet_vars</code> in <code>robyn_inputs()</code> is specified, this
function decomposes trend, season, holiday and weekday from the
dependent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_decomp(
  dt_transform,
  dt_holidays,
  prophet_country,
  prophet_vars,
  prophet_signs,
  factor_vars,
  context_vars,
  organic_vars,
  paid_media_spends,
  intervalType,
  dayInterval,
  custom_params
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prophet_decomp_+3A_dt_transform">dt_transform</code></td>
<td>
<p>A data.frame with all model features.
Must contain <code>ds</code> column for time variable values and
<code>dep_var</code> column for dependent variable values.</p>
</td></tr>
<tr><td><code id="prophet_decomp_+3A_dt_holidays">dt_holidays</code></td>
<td>
<p>data.frame. Raw input holiday data. Load standard
Prophet holidays using <code>data("dt_prophet_holidays")</code></p>
</td></tr>
<tr><td><code id="prophet_decomp_+3A_context_vars">context_vars</code>, <code id="prophet_decomp_+3A_paid_media_spends">paid_media_spends</code>, <code id="prophet_decomp_+3A_intervaltype">intervalType</code>, <code id="prophet_decomp_+3A_dayinterval">dayInterval</code>, <code id="prophet_decomp_+3A_prophet_country">prophet_country</code>, <code id="prophet_decomp_+3A_prophet_vars">prophet_vars</code>, <code id="prophet_decomp_+3A_prophet_signs">prophet_signs</code>, <code id="prophet_decomp_+3A_factor_vars">factor_vars</code></td>
<td>
<p>As included in <code>InputCollect</code></p>
</td></tr>
<tr><td><code id="prophet_decomp_+3A_organic_vars">organic_vars</code></td>
<td>
<p>Character vector. Typically newsletter sendings,
push-notifications, social media posts etc. Compared to <code>paid_media_vars</code>
<code>organic_vars</code> are often marketing activities without clear spends.</p>
</td></tr>
<tr><td><code id="prophet_decomp_+3A_custom_params">custom_params</code></td>
<td>
<p>List. Custom parameters passed to <code>prophet()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all prophet decomposition output.
</p>

<hr>
<h2 id='robyn_allocator'>Budget Allocator</h2><span id='topic+robyn_allocator'></span><span id='topic+print.robyn_allocator'></span><span id='topic+plot.robyn_allocator'></span>

<h3>Description</h3>

<p><code>robyn_allocator()</code> function returns a new split of media
variable spends that maximizes the total media response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_allocator(
  robyn_object = NULL,
  select_build = 0,
  InputCollect = NULL,
  OutputCollect = NULL,
  select_model = NULL,
  json_file = NULL,
  scenario = "max_response",
  total_budget = NULL,
  target_value = NULL,
  date_range = "all",
  channel_constr_low = NULL,
  channel_constr_up = NULL,
  channel_constr_multiplier = 3,
  optim_algo = "SLSQP_AUGLAG",
  maxeval = 1e+05,
  constr_mode = "eq",
  plots = TRUE,
  plot_folder = NULL,
  plot_folder_sub = NULL,
  export = TRUE,
  quiet = FALSE,
  ui = FALSE,
  ...
)

## S3 method for class 'robyn_allocator'
print(x, ...)

## S3 method for class 'robyn_allocator'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_allocator_+3A_robyn_object">robyn_object</code></td>
<td>
<p>Character or List. Path of the <code>Robyn.RDS</code> object
that contains all previous modeling information or the imported list.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_select_build">select_build</code></td>
<td>
<p>Integer. Default to the latest model build. <code>select_build = 0</code>
selects the initial model. <code>select_build = 1</code> selects the first refresh model.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_inputcollect">InputCollect</code></td>
<td>
<p>List. Contains all input parameters for the model.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_outputcollect">OutputCollect</code></td>
<td>
<p>List. Containing all model result.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_select_model">select_model</code></td>
<td>
<p>Character. A model <code>SolID</code>. When <code>robyn_object</code>
is provided, <code>select_model</code> defaults to the already selected <code>SolID</code>. When
<code>robyn_object</code> is not provided, <code>select_model</code> must be provided with
<code>InputCollect</code> and <code>OutputCollect</code>, and must be one of
<code>OutputCollect$allSolutions</code>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_json_file">json_file</code></td>
<td>
<p>Character. JSON file to import previously exported inputs or
recreate a model. To generate this file, use <code>robyn_write()</code>.
If you didn't export your data in the json file as &quot;raw_data&quot;,
<code>dt_input</code> must be provided; <code>dt_holidays</code> input is optional.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_scenario">scenario</code></td>
<td>
<p>Character. Accepted options are: <code>"max_response"</code>, <code>"target_efficiency"</code>.
Scenario <code>"max_response"</code> answers the question:
&quot;What's the potential revenue/conversions lift with the same (or custom) spend level
in <code>date_range</code> and what is the allocation and expected response mix?&quot;
Scenario <code>"target_efficiency"</code> optimizes ROAS or CPA and answers the question:
&quot;What's the potential revenue/conversions lift and spend levels based on a
<code>target_value</code> for CPA/ROAS and what is the allocation and expected response mix?&quot;
Deprecated scenario: <code>"max_response_expected_spend"</code>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_total_budget">total_budget</code></td>
<td>
<p>Numeric. Total marketing budget for all paid channels for the
period in <code>date_range</code>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_target_value">target_value</code></td>
<td>
<p>Numeric. When using the scenario <code>"target_efficiency"</code>,
target_value is the desired ROAS or CPA with no upper spend limit. Default is set to 80% of
initial ROAS or 120% of initial CPA, when <code>"target_value = NULL"</code>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_date_range">date_range</code></td>
<td>
<p>Character. Date(s) to apply adstocked transformations and pick mean spends
per channel. Set one of: &quot;all&quot;, &quot;last&quot;, or &quot;last_n&quot; (where
n is the last N dates available), date (i.e. &quot;2022-03-27&quot;), or date range
(i.e. <code>c("2022-01-01", "2022-12-31")</code>). Default to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_channel_constr_low">channel_constr_low</code>, <code id="robyn_allocator_+3A_channel_constr_up">channel_constr_up</code></td>
<td>
<p>Numeric vectors. The lower and upper bounds
for each paid media variable when maximizing total media response. For example,
<code>channel_constr_low = 0.7</code> means minimum spend of the variable is 70
average, using non-zero spend values, within <code>date_min</code> and <code>date_max</code> date range.
Both constrains must be length 1 (same for all values) OR same length and order as
<code>paid_media_spends</code>. It's not recommended to 'exaggerate' upper bounds, especially
if the new level is way higher than historical level. Lower bound must be &gt;=0.01,
and upper bound should be &lt; 5.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_channel_constr_multiplier">channel_constr_multiplier</code></td>
<td>
<p>Numeric. Default to 3. For example, if
<code>channel_constr_low</code> and <code>channel_constr_up</code> are 0.8 to 1.2, the range is 0.4.
The allocator will also show the optimum solution for a larger constraint range of
0.4 x 3 = 1.2, or 0.4 to 1.6, to show the optimization potential to support allocation
interpretation and decision.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_optim_algo">optim_algo</code></td>
<td>
<p>Character. Default to <code>"SLSQP_AUGLAG"</code>, short for &quot;Sequential Least-Squares
Quadratic Programming&quot; and &quot;Augmented Lagrangian&quot;. Alternatively, &quot;<code>"MMA_AUGLAG"</code>,
short for &quot;Methods of Moving Asymptotes&quot;. More details see the documentation of
NLopt <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/">here</a>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_maxeval">maxeval</code></td>
<td>
<p>Integer. The maximum iteration of the global optimization algorithm.
Defaults to 100000.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_constr_mode">constr_mode</code></td>
<td>
<p>Character. Options are <code>"eq"</code> or <code>"ineq"</code>,
indicating constraints with equality or inequality.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_plots">plots</code></td>
<td>
<p>Boolean. Generate plots?</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_plot_folder">plot_folder</code></td>
<td>
<p>Character. Path for saving plots and files. Default
to <code>robyn_object</code> and saves plot in the same directory as <code>robyn_object</code>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_plot_folder_sub">plot_folder_sub</code></td>
<td>
<p>Character. Sub path for saving plots. Will overwrite the
default path with timestamp or, for refresh and allocator, simply overwrite files.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_export">export</code></td>
<td>
<p>Boolean. Export outcomes into local files?</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_ui">ui</code></td>
<td>
<p>Boolean. Save additional outputs for UI usage. List outcome.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>robyn_outputs()</code>.</p>
</td></tr>
<tr><td><code id="robyn_allocator_+3A_x">x</code></td>
<td>
<p><code>robyn_allocator()</code> output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing allocator result.
</p>
<p>List. Contains optimized allocation results and plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Having InputCollect and OutputCollect results
AllocatorCollect &lt;- robyn_allocator(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = "1_2_3",
  scenario = "max_response",
  channel_constr_low = 0.7,
  channel_constr_up = c(1.2, 1.5, 1.5, 1.5, 1.5),
  channel_constr_multiplier = 4,
  date_range = "last_26",
  export = FALSE
)
# Print a summary
print(AllocatorCollect)
# Plot the allocator one-pager
plot(AllocatorCollect)

## End(Not run)
</code></pre>

<hr>
<h2 id='robyn_clusters'>Clustering to Reduce Number of Models based on ROI and Errors</h2><span id='topic+robyn_clusters'></span>

<h3>Description</h3>

<p><code>robyn_clusters()</code> uses output from <code>robyn_run()</code>,
to reduce the number of models and create bootstrapped confidence
interval and help the user pick up the best (lowest combined error)
of the most different kinds (clusters) of models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_clusters(
  input,
  dep_var_type,
  cluster_by = "hyperparameters",
  all_media = NULL,
  k = "auto",
  wss_var = 0.06,
  max_clusters = 10,
  limit = 1,
  weights = rep(1, 3),
  dim_red = "PCA",
  quiet = FALSE,
  export = FALSE,
  seed = 123,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_clusters_+3A_input">input</code></td>
<td>
<p><code>robyn_export()</code>'s output or <code>pareto_aggregated.csv</code> results.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_dep_var_type">dep_var_type</code></td>
<td>
<p>Character. For dep_var_type 'revenue', ROI is used for clustering.
For conversion', CPA is used for clustering.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_cluster_by">cluster_by</code></td>
<td>
<p>Character. Any of: &quot;performance&quot; or &quot;hyperparameters&quot;.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_all_media">all_media</code></td>
<td>
<p>Character vector. Default to <code>InputCollect$all_media</code>.
Includes <code>InputCollect$paid_media_spends</code> and <code>InputCollect$organic_vars</code>.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_k">k</code></td>
<td>
<p>Integer. Number of clusters</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_wss_var">wss_var</code></td>
<td>
<p>Numeric. Used to pick automatic <code>k</code> value,
when <code>k</code> is <code>NULL</code> based on WSS variance while considering
<code>limit</code> clusters. Values between (0, 1). Default value could be
0.05 to consider convergence.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_max_clusters">max_clusters</code></td>
<td>
<p>Integer. Maximum number of clusters.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_limit">limit</code></td>
<td>
<p>Integer. Top N results per cluster. If kept in &quot;auto&quot;, will select k
as the cluster in which the WSS variance was less than 5%.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_weights">weights</code></td>
<td>
<p>Vector, size 3. How much should each error weight?
Order: nrmse, decomp.rssd, mape. The highest the value, the closer it will be scaled
to origin. Each value will be normalized so they all sum 1.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_dim_red">dim_red</code></td>
<td>
<p>Character. Select dimensionality reduction technique.
Pass any of: <code>c("PCA", "tSNE", "all", "none")</code>.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep quiet? If not, print messages.</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_export">export</code></td>
<td>
<p>Export plots into local files?</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_seed">seed</code></td>
<td>
<p>Numeric. Seed for reproducibility</p>
</td></tr>
<tr><td><code id="robyn_clusters_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>lares::clusterKmeans()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Clustering results as labeled data.frames and plots.
</p>


<h3>Author(s)</h3>

<p>Bernardo Lares (bernardolares@meta.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Having InputCollect and OutputCollect results
cls &lt;- robyn_clusters(
  input = OutputCollect,
  all_media = InputCollect$all_media,
  k = 3, limit = 2,
  weights = c(1, 1, 1.5)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='robyn_converge'>Check Models Convergence</h2><span id='topic+robyn_converge'></span>

<h3>Description</h3>

<p><code>robyn_converge()</code> consumes <code>robyn_run()</code> outputs
and calculate convergence status and builds convergence plots.
Convergence is calculated by default using the following criteria
(having kept the default parameters: sd_qtref = 3 and med_lowb = 2):
</p>

<dl>
<dt>Criteria #1:</dt><dd><p>Last quantile's standard deviation &lt; first 3
quantiles' mean standard deviation</p>
</dd>
<dt>Criteria #2:</dt><dd><p>Last quantile's absolute median &lt; absolute first
quantile's absolute median - 2 * first 3 quantiles' mean standard
deviation</p>
</dd>
</dl>

<p>Both mentioned criteria have to be satisfied to consider MOO convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_converge(
  OutputModels,
  n_cuts = 20,
  sd_qtref = 3,
  med_lowb = 2,
  nrmse_win = c(0, 0.998),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_converge_+3A_outputmodels">OutputModels</code></td>
<td>
<p>List. Output from <code>robyn_run()</code>.</p>
</td></tr>
<tr><td><code id="robyn_converge_+3A_n_cuts">n_cuts</code></td>
<td>
<p>Integer. Default to 20 (5% cuts each).</p>
</td></tr>
<tr><td><code id="robyn_converge_+3A_sd_qtref">sd_qtref</code></td>
<td>
<p>Integer. Reference quantile of the error convergence rule
for standard deviation (Criteria #1). Defaults to 3.</p>
</td></tr>
<tr><td><code id="robyn_converge_+3A_med_lowb">med_lowb</code></td>
<td>
<p>Integer. Lower bound distance of the error convergence rule
for median. (Criteria #2). Default to 3.</p>
</td></tr>
<tr><td><code id="robyn_converge_+3A_nrmse_win">nrmse_win</code></td>
<td>
<p>Numeric vector. Lower and upper quantiles thresholds to
winsorize NRMSE. Set values within [0,1]; default: c(0, 0.998) which is 1/500.</p>
</td></tr>
<tr><td><code id="robyn_converge_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Plots and MOO convergence results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Having OutputModels results
MOO &lt;- robyn_converge(
  OutputModels,
  n_cuts = 10,
  sd_qtref = 3,
  med_lowb = 3
)

## End(Not run)
</code></pre>

<hr>
<h2 id='robyn_inputs'>Input Data Check &amp; Transformation</h2><span id='topic+robyn_inputs'></span><span id='topic+print.robyn_inputs'></span>

<h3>Description</h3>

<p><code>robyn_inputs()</code> is the function to input all model parameters and
check input correctness for the initial model build. It includes the
engineering process results that conducts trend, season,
holiday &amp; weekday decomposition using Facebook's time-series forecasting
library <code>prophet</code> and fit a nonlinear model to spend and exposure
metrics in case exposure metrics are used in <code>paid_media_vars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_inputs(
  dt_input = NULL,
  dep_var = NULL,
  dep_var_type = NULL,
  date_var = "auto",
  paid_media_spends = NULL,
  paid_media_vars = NULL,
  paid_media_signs = NULL,
  organic_vars = NULL,
  organic_signs = NULL,
  context_vars = NULL,
  context_signs = NULL,
  factor_vars = NULL,
  dt_holidays = Robyn::dt_prophet_holidays,
  prophet_vars = NULL,
  prophet_signs = NULL,
  prophet_country = NULL,
  adstock = NULL,
  hyperparameters = NULL,
  window_start = NULL,
  window_end = NULL,
  calibration_input = NULL,
  json_file = NULL,
  InputCollect = NULL,
  ...
)

## S3 method for class 'robyn_inputs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_inputs_+3A_dt_input">dt_input</code></td>
<td>
<p>data.frame. Raw input data. Load simulated
dataset using <code>data("dt_simulated_weekly")</code></p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_dep_var">dep_var</code></td>
<td>
<p>Character. Name of dependent variable. Only one allowed</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_dep_var_type">dep_var_type</code></td>
<td>
<p>Character. Type of dependent variable
as &quot;revenue&quot; or &quot;conversion&quot;. Will be used to calculate ROI or CPI,
respectively. Only one allowed and case sensitive.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_date_var">date_var</code></td>
<td>
<p>Character. Name of date variable. Daily, weekly
and monthly data supported.
<code>date_var</code> must have format &quot;2020-01-01&quot; (YYY-MM-DD).
Default to automatic date detection.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_paid_media_spends">paid_media_spends</code></td>
<td>
<p>Character vector. Names of the paid media variables.
The values on each of these variables must be numeric. Also,
<code>paid_media_spends</code> must have same order and length as
<code>paid_media_vars</code> respectively.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_paid_media_vars">paid_media_vars</code></td>
<td>
<p>Character vector. Names of the paid media variables'
exposure level metrics (impressions, clicks, GRP etc) other than spend.
The values on each of these variables must be numeric. These variables are not
being used to train the model but to check relationship and recommend to
split media channels into sub-channels (e.g. fb_retargeting, fb_prospecting,
etc.) to gain more variance. <code>paid_media_vars</code> must have same
order and length as <code>paid_media_spends</code> respectively and is not required.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_paid_media_signs">paid_media_signs</code></td>
<td>
<p>Character vector. Choose any of
<code>c("default", "positive", "negative")</code>. Control
the signs of coefficients for <code>paid_media_vars</code>. Must have same
order and same length as <code>paid_media_vars</code>. By default, all values are
set to 'positive'.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_organic_vars">organic_vars</code></td>
<td>
<p>Character vector. Typically newsletter sendings,
push-notifications, social media posts etc. Compared to <code>paid_media_vars</code>
<code>organic_vars</code> are often marketing activities without clear spends.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_organic_signs">organic_signs</code></td>
<td>
<p>Character vector. Choose any of
&quot;default&quot;, &quot;positive&quot;, &quot;negative&quot;. Control
the signs of coefficients for <code>organic_vars</code> Must have same
order and same length as <code>organic_vars</code>. By default, all values are
set to &quot;positive&quot;.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_context_vars">context_vars</code></td>
<td>
<p>Character vector. Typically competitors,
price &amp; promotion, temperature, unemployment rate, etc.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_context_signs">context_signs</code></td>
<td>
<p>Character vector. Choose any of
<code>c("default", "positive", "negative")</code>. Control
the signs of coefficients for context_vars. Must have same
order and same length as <code>context_vars</code>. By default it's
set to 'defualt'.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_factor_vars">factor_vars</code></td>
<td>
<p>Character vector. Specify which of the provided
variables in organic_vars or context_vars should be forced as a factor.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_dt_holidays">dt_holidays</code></td>
<td>
<p>data.frame. Raw input holiday data. Load standard
Prophet holidays using <code>data("dt_prophet_holidays")</code></p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_prophet_vars">prophet_vars</code></td>
<td>
<p>Character vector. Include any of &quot;trend&quot;,
&quot;season&quot;, &quot;weekday&quot;, &quot;monthly&quot;, &quot;holiday&quot; or NULL. Highly recommended
to use all for daily data and &quot;trend&quot;, &quot;season&quot;, &quot;holiday&quot; for
weekly and above cadence. Set to NULL to skip prophet's functionality.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_prophet_signs">prophet_signs</code></td>
<td>
<p>Character vector. Choose any of
&quot;default&quot;, &quot;positive&quot;, &quot;negative&quot;. Control
the signs of coefficients for <code>prophet_vars</code>. Must have same
order and same length as <code>prophet_vars</code>. By default, all values are
set to &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_prophet_country">prophet_country</code></td>
<td>
<p>Character. Only one country allowed.
Includes national holidays for all countries, whose list can
be found loading <code>data("dt_prophet_holidays")</code>.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_adstock">adstock</code></td>
<td>
<p>Character. Choose any of &quot;geometric&quot;, &quot;weibull_cdf&quot;,
&quot;weibull_pdf&quot;. Weibull adstock is a two-parametric function and thus more
flexible, but takes longer time than the traditional geometric one-parametric
function. CDF, or cumulative density function of the Weibull function allows
changing decay rate over time in both C and S shape, while the peak value will
always stay at the first period, meaning no lagged effect. PDF, or the
probability density function, enables peak value occurring after the first
period when shape &gt;=1, allowing lagged effect. Run <code>plot_adstock()</code> to
see the difference visually. Time estimation: with geometric adstock, 2000
iterations * 5 trials on 8 cores, it takes less than 30 minutes. Both Weibull
options take up to twice as much time.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>List. Contains hyperparameter lower and upper bounds.
Names of elements in list must be identical to output of <code>hyper_names()</code>.
To fix hyperparameter values, provide only one value.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_window_start">window_start</code>, <code id="robyn_inputs_+3A_window_end">window_end</code></td>
<td>
<p>Character. Set start and end dates of modelling
period. Recommended to not start in the first date in dataset to gain adstock
effect from previous periods. Also, columns to rows ratio in the input data
to be &gt;=10:1, or in other words at least 10 observations to 1 independent variable.
This window will determine the date range of the data period within your dataset
you will be using to specifically regress the effects of media, organic and
context variables on your dependent variable. We recommend using a full
<code>dt_input</code> dataset with a minimum of 1 year of history, as it will be used
in full for the model calculation of trend, seasonality and holidays effects.
Whereas the window period will determine how much of the full data set will be
used for media, organic and context variables.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_calibration_input">calibration_input</code></td>
<td>
<p>data.frame. Optional. Provide experimental results to
calibrate. Your input should include the following values for each experiment:
channel, liftStartDate, liftEndDate, liftAbs, spend, confidence, metric.
You can calibrate any spend or organic variable with a well designed experiment.
You can also use experimental results from multiple channels; to do so,
provide concatenated channel value, i.e. &quot;channel_A+channel_B&quot;.
Check &quot;Guide for calibration source&quot; section.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_json_file">json_file</code></td>
<td>
<p>Character. JSON file to import previously exported inputs or
recreate a model. To generate this file, use <code>robyn_write()</code>.
If you didn't export your data in the json file as &quot;raw_data&quot;,
<code>dt_input</code> must be provided; <code>dt_holidays</code> input is optional.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_inputcollect">InputCollect</code></td>
<td>
<p>Default to NULL. <code>robyn_inputs</code>'s output when
<code>hyperparameters</code> are not yet set.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>prophet</code> functions.</p>
</td></tr>
<tr><td><code id="robyn_inputs_+3A_x">x</code></td>
<td>
<p><code>robyn_inputs()</code> output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Contains all input parameters and modified results
using <code>Robyn:::robyn_engineering()</code>. This list is ready to be
used on other functions like <code>robyn_run()</code> and <code>print()</code>.
Class: <code>robyn_inputs</code>.
</p>


<h3>Guide for calibration source</h3>


<ol>
<li><p> We strongly recommend to use experimental and causal results
that are considered ground truth to calibrate MMM. Usual experiment
types are people-based (e.g. Facebook conversion lift) and
geo-based (e.g. Facebook GeoLift).
</p>
</li>
<li><p> Currently, Robyn only accepts point-estimate as calibration
input. For example, if 10k$ spend is tested against a hold-out
for channel A, then input the incremental return as point-estimate
as the example below.
</p>
</li>
<li><p> The point-estimate has to always match the spend in the variable.
For example, if channel A usually has 100k$ weekly spend and the
experimental HO is 70
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Using dummy simulated data
InputCollect &lt;- robyn_inputs(
  dt_input = Robyn::dt_simulated_weekly,
  dt_holidays = Robyn::dt_prophet_holidays,
  date_var = "DATE",
  dep_var = "revenue",
  dep_var_type = "revenue",
  prophet_vars = c("trend", "season", "holiday"),
  prophet_country = "DE",
  context_vars = c("competitor_sales_B", "events"),
  paid_media_spends = c("tv_S", "ooh_S", "print_S", "facebook_S", "search_S"),
  paid_media_vars = c("tv_S", "ooh_S", "print_S", "facebook_I", "search_clicks_P"),
  organic_vars = "newsletter",
  factor_vars = "events",
  window_start = "2016-11-23",
  window_end = "2018-08-22",
  adstock = "geometric",
  # To be defined separately
  hyperparameters = NULL,
  calibration_input = NULL
)
print(InputCollect)
</code></pre>

<hr>
<h2 id='robyn_mmm'>Core MMM Function</h2><span id='topic+robyn_mmm'></span>

<h3>Description</h3>

<p><code>robyn_mmm()</code> function activates Nevergrad to generate samples of
hyperparameters, conducts media transformation within each loop, fits the
Ridge regression, calibrates the model optionally, decomposes responses
and collects the result. It's an inner function within <code>robyn_run()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_mmm(
  InputCollect,
  hyper_collect,
  iterations,
  cores,
  nevergrad_algo,
  intercept = TRUE,
  intercept_sign,
  ts_validation = TRUE,
  add_penalty_factor = FALSE,
  objective_weights = NULL,
  dt_hyper_fixed = NULL,
  rssd_zero_penalty = TRUE,
  refresh = FALSE,
  trial = 1L,
  seed = 123L,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_mmm_+3A_inputcollect">InputCollect</code></td>
<td>
<p>List. Contains all input parameters for the model.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_hyper_collect">hyper_collect</code></td>
<td>
<p>List. Containing hyperparameter bounds. Defaults to
<code>InputCollect$hyperparameters</code>.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Number of iterations to run.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_cores">cores</code></td>
<td>
<p>Integer. Default to <code>parallel::detectCores() - 1</code> (all cores
except one). Set to 1 if you want to turn parallel computing off.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_nevergrad_algo">nevergrad_algo</code></td>
<td>
<p>Character. Default to &quot;TwoPointsDE&quot;. Options are
<code>c("DE","TwoPointsDE", "OnePlusOne", "DoubleFastGADiscreteOnePlusOne",
"DiscreteOnePlusOne", "PortfolioDiscreteOnePlusOne", "NaiveTBPSA",
"cGA", "RandomSearch")</code>.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_intercept">intercept</code></td>
<td>
<p>Boolean. Should intercept(s) be fitted (default=TRUE) or
set to zero (FALSE).</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_intercept_sign">intercept_sign</code></td>
<td>
<p>Character. Choose one of &quot;non_negative&quot; (default) or
&quot;unconstrained&quot;. By default, if intercept is negative, Robyn will drop intercept
and refit the model. Consider changing intercept_sign to &quot;unconstrained&quot; when
there are <code>context_vars</code> with large positive values.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_ts_validation">ts_validation</code></td>
<td>
<p>Boolean. When set to <code>TRUE</code>, Robyn will split data
by test, train, and validation partitions to validate the time series. By
default the &quot;train_size&quot; range is set to <code>c(0.5, 0.8)</code>, but it can be
customized or set to a fixed value using the hyperparameters input. For example,
if <code>train_size = 0.7</code>, validation size and test size will both be 0.15
and 0.15. When <code>ts_validation = FALSE</code>, nrmse_train is the
objective function; when <code>ts_validation = TRUE</code>, nrmse_val is the objective
function.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_add_penalty_factor">add_penalty_factor</code></td>
<td>
<p>Boolean. Add penalty factor hyperparameters to
glmnet's penalty.factor to be optimized by nevergrad. Use with caution, because
this feature might add too much hyperparameter space and probably requires
more iterations to converge.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_objective_weights">objective_weights</code></td>
<td>
<p>Numeric vector. Default to NULL to give equal weights
to all objective functions. Order: NRMSE, DECOMP.RSSD, MAPE (when calibration
data is provided). When you are not calibrating, only the first 2 values for
<code>objective_weights</code> must be defined, i.e. set c(2, 1) to give double weight
to the 1st (NRMSE). This is an experimental feature. There's no research on
optimal weight setting. Subjective weights might strongly bias modeling results.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_dt_hyper_fixed">dt_hyper_fixed</code></td>
<td>
<p>data.frame or named list. Only provide when loading
old model results. It consumes hyperparameters from saved csv
<code>pareto_hyperparameters.csv</code> or JSON file to replicate a model.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_rssd_zero_penalty">rssd_zero_penalty</code></td>
<td>
<p>Boolean. When TRUE, the objective function
DECOMP.RSSD will penalize models with more 0 media effects additionally.
In other words, given the same DECOMP.RSSD score, a model with 50% 0-coef
variables will get penalized by DECOMP.RSSD * 1.5 (larger error), while
another model with no 0-coef variables gets un-penalized with DECOMP.RSSD * 1.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_refresh">refresh</code></td>
<td>
<p>Boolean. Set to <code>TRUE</code> when used in <code>robyn_refresh()</code>.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_trial">trial</code></td>
<td>
<p>Integer. Which trial are we running? Used to ID each model.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_seed">seed</code></td>
<td>
<p>Integer. For reproducible results when running nevergrad.</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_mmm_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>robyn_outputs()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. MMM results with hyperparameters values.
</p>

<hr>
<h2 id='robyn_outputs'>Evaluate Models and Output Results into Local Files</h2><span id='topic+robyn_outputs'></span><span id='topic+print.robyn_outputs'></span><span id='topic+robyn_csv'></span><span id='topic+robyn_plots'></span><span id='topic+robyn_onepagers'></span><span id='topic+ts_validation'></span><span id='topic+decomp_plot'></span>

<h3>Description</h3>

<p>Pack <code>robyn_plots()</code>, <code>robyn_csv()</code>, and <code>robyn_clusters()</code>
outcomes on <code>robyn_run()</code> results. When <code>UI=TRUE</code>, enriched
<code>OutputModels</code> results with additional plots and objects.
</p>
<p>Create a plot to visualize the convergence for each of the datasets
when running <code>robyn_run()</code>, especially useful for when using ts_validation.
As a reference, the closer the test and validation convergence points are,
the better, given the time-series wasn't overfitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_outputs(
  InputCollect,
  OutputModels,
  pareto_fronts = "auto",
  calibration_constraint = 0.1,
  plot_folder = NULL,
  plot_folder_sub = NULL,
  plot_pareto = TRUE,
  csv_out = "pareto",
  clusters = TRUE,
  select_model = "clusters",
  ui = FALSE,
  export = TRUE,
  all_sol_json = FALSE,
  quiet = FALSE,
  refresh = FALSE,
  ...
)

## S3 method for class 'robyn_outputs'
print(x, ...)

robyn_csv(
  InputCollect,
  OutputCollect,
  csv_out = NULL,
  export = TRUE,
  calibrated = FALSE
)

robyn_plots(
  InputCollect,
  OutputCollect,
  export = TRUE,
  plot_folder = OutputCollect$plot_folder,
  ...
)

robyn_onepagers(
  InputCollect,
  OutputCollect,
  select_model = NULL,
  quiet = FALSE,
  export = TRUE,
  plot_folder = OutputCollect$plot_folder,
  baseline_level = 0,
  ...
)

ts_validation(OutputModels, quiet = FALSE, ...)

decomp_plot(
  InputCollect,
  OutputCollect,
  solID = NULL,
  exclude = NULL,
  baseline_level = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_outputs_+3A_inputcollect">InputCollect</code>, <code id="robyn_outputs_+3A_outputmodels">OutputModels</code></td>
<td>
<p><code>robyn_inputs()</code> and <code>robyn_run()</code>
outcomes.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_pareto_fronts">pareto_fronts</code></td>
<td>
<p>Integer. Number of Pareto fronts for the output.
<code>pareto_fronts = 1</code> returns the best models trading off <code>NRMSE</code> &amp;
<code>DECOMP.RSSD</code>. Increase <code>pareto_fronts</code> to get more model choices.
<code>pareto_fronts = "auto"</code> selects the min fronts that include at least 100
candidates. To customize this threshold, set value with <code>min_candidates</code>.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_calibration_constraint">calibration_constraint</code></td>
<td>
<p>Numeric. Default to 0.1 and allows 0.01-0.1. When
calibrating, 0.1 means top 10
selection. Lower <code>calibration_constraint</code> increases calibration accuracy.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_plot_folder">plot_folder</code></td>
<td>
<p>Character. Path for saving plots and files. Default
to <code>robyn_object</code> and saves plot in the same directory as <code>robyn_object</code>.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_plot_folder_sub">plot_folder_sub</code></td>
<td>
<p>Character. Sub path for saving plots. Will overwrite the
default path with timestamp or, for refresh and allocator, simply overwrite files.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_plot_pareto">plot_pareto</code></td>
<td>
<p>Boolean. Set to <code>FALSE</code> to deactivate plotting
and saving model one-pagers. Used when testing models.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_csv_out">csv_out</code></td>
<td>
<p>Character. Accepts &quot;pareto&quot; or &quot;all&quot;. Default to &quot;pareto&quot;. Set
to &quot;all&quot; will output all iterations as csv. Set NULL to skip exports into CSVs.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_clusters">clusters</code></td>
<td>
<p>Boolean. Apply <code>robyn_clusters()</code> to output models?</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_select_model">select_model</code></td>
<td>
<p>Character vector. Which models (by <code>solID</code>) do you
wish to plot the one-pagers and export? Default will take top
<code>robyn_clusters()</code> results.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_ui">ui</code></td>
<td>
<p>Boolean. Save additional outputs for UI usage. List outcome.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_export">export</code></td>
<td>
<p>Boolean. Export outcomes into local files?</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_all_sol_json">all_sol_json</code></td>
<td>
<p>Logical. Add all pareto solutions to json export?</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_refresh">refresh</code></td>
<td>
<p>Boolean. Refresh mode</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>robyn_clusters()</code></p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_x">x</code></td>
<td>
<p><code>robyn_outputs()</code> output.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_outputcollect">OutputCollect</code></td>
<td>
<p><code>robyn_run(..., export = FALSE)</code> output.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_calibrated">calibrated</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_baseline_level">baseline_level</code></td>
<td>
<p>Integer, from 0 to 5. Aggregate baseline variables,
depending on the level of aggregation you need. Default is 0 for no
aggregation. 1 for Intercept only. 2 adding trend. 3 adding all prophet
decomposition variables. 4. Adding contextual variables. 5 Adding organic
variables. Results will be reflected on the waterfall chart.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_solid">solID</code></td>
<td>
<p>Character vector. Model IDs to plot.</p>
</td></tr>
<tr><td><code id="robyn_outputs_+3A_exclude">exclude</code></td>
<td>
<p>Character vector. Manually exclude variables from plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(Invisible) list. Class: <code>robyn_outputs</code>. Contains processed
results based on <code>robyn_run()</code> results.
</p>
<p>Invisible <code>NULL</code>.
</p>
<p>Invisible list with <code>ggplot</code> plots.
</p>
<p>Invisible list with <code>patchwork</code> plot(s).
</p>
<p>Invisible list with <code>ggplot</code> plots.
</p>

<hr>
<h2 id='robyn_refresh'>Build Refresh Model</h2><span id='topic+robyn_refresh'></span><span id='topic+print.robyn_refresh'></span><span id='topic+plot.robyn_refresh'></span>

<h3>Description</h3>

<p><code>robyn_refresh()</code> builds updated models based on
the previously built models saved in the <code>Robyn.RDS</code> object specified
in <code>robyn_object</code>. For example, when updating the initial build with 4
weeks of new data, <code>robyn_refresh()</code> consumes the selected model of
the initial build, sets lower and upper bounds of hyperparameters for the
new build around the selected hyperparameters of the previous build,
stabilizes the effect of baseline variables across old and new builds, and
regulates the new effect share of media variables towards the latest
spend level. It returns the aggregated results with all previous builds for
reporting purposes and produces reporting plots.
</p>
<p>You must run <code>robyn_save()</code> to select and save an initial model first,
before refreshing.
</p>
<p><strong>When should <code>robyn_refresh()</code> NOT be used:</strong>
The <code>robyn_refresh()</code> function is suitable for
updating within &quot;reasonable periods&quot;. Two situations are considered better
to rebuild model instead of refreshing:
</p>
<p>1. Most data is new: If initial model was trained with 100 weeks worth of
data but we add +50 weeks of new data.
</p>
<p>2. New variables are added: If initial model had less variables than the ones
we want to start using on new refresh model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_refresh(
  json_file = NULL,
  robyn_object = NULL,
  dt_input = NULL,
  dt_holidays = Robyn::dt_prophet_holidays,
  refresh_steps = 4,
  refresh_mode = "manual",
  refresh_iters = 1000,
  refresh_trials = 3,
  bounds_freedom = NULL,
  plot_folder = NULL,
  plot_pareto = TRUE,
  version_prompt = FALSE,
  export = TRUE,
  calibration_input = NULL,
  objective_weights = NULL,
  ...
)

## S3 method for class 'robyn_refresh'
print(x, ...)

## S3 method for class 'robyn_refresh'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_refresh_+3A_json_file">json_file</code></td>
<td>
<p>Character. JSON file to import previously exported inputs or
recreate a model. To generate this file, use <code>robyn_write()</code>.
If you didn't export your data in the json file as &quot;raw_data&quot;,
<code>dt_input</code> must be provided; <code>dt_holidays</code> input is optional.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_robyn_object">robyn_object</code></td>
<td>
<p>Character or List. Path of the <code>Robyn.RDS</code> object
that contains all previous modeling information or the imported list.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_dt_input">dt_input</code></td>
<td>
<p>data.frame. Should include all previous data and newly added
data for the refresh.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_dt_holidays">dt_holidays</code></td>
<td>
<p>data.frame. Raw input holiday data. Load standard
Prophet holidays using <code>data("dt_prophet_holidays")</code>.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_refresh_steps">refresh_steps</code></td>
<td>
<p>Integer. It controls how many time units the refresh
model build move forward. For example, <code>refresh_steps = 4</code> on weekly data
means the <code>InputCollect$window_start</code> &amp; <code>InputCollect$window_end</code>
move forward 4 weeks. If <code>refresh_steps</code> is smaller than the number of
newly provided data points, then Robyn would only use the first N steps of the
new data.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_refresh_mode">refresh_mode</code></td>
<td>
<p>Character. Options are &quot;auto&quot; and &quot;manual&quot;. In auto mode,
the <code>robyn_refresh()</code> function builds refresh models with given
<code>refresh_steps</code> repeatedly until there's no more data available. I
manual mode, the <code>robyn_refresh()</code> only moves forward <code>refresh_steps</code>
only once. &quot;auto&quot; mode has been deprecated when using <code>json_file</code> input.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_refresh_iters">refresh_iters</code></td>
<td>
<p>Integer. Iterations per refresh. Rule of thumb is, the
more new data added, the more iterations needed. More reliable recommendation
still needs to be investigated.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_refresh_trials">refresh_trials</code></td>
<td>
<p>Integer. Trials per refresh. Defaults to 5 trials.
More reliable recommendation still needs to be investigated.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_bounds_freedom">bounds_freedom</code></td>
<td>
<p>Numeric. Percentage of freedom we'd like to allow for the
new hyperparameters values compared with the model to be refreshed.
If set to NULL (default) the value will be calculated as
refresh_steps / rollingWindowLength. Applies to all hyperparameters.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_plot_folder">plot_folder</code></td>
<td>
<p>Character. Path for saving plots and files. Default
to <code>robyn_object</code> and saves plot in the same directory as <code>robyn_object</code>.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_plot_pareto">plot_pareto</code></td>
<td>
<p>Boolean. Set to <code>FALSE</code> to deactivate plotting
and saving model one-pagers. Used when testing models.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_version_prompt">version_prompt</code></td>
<td>
<p>Logical. If FALSE, the model refresh version will be
selected based on the smallest combined error of normalized NRMSE, DECOMP.RSSD, MAPE.
If <code>TRUE</code>, a prompt will be presented to the user to select one of the refreshed
models (one-pagers and Pareto CSV files will already be generated).</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_export">export</code></td>
<td>
<p>Boolean. Export outcomes into local files?</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_calibration_input">calibration_input</code></td>
<td>
<p>data.frame. Optional. Provide experimental results to
calibrate. Your input should include the following values for each experiment:
channel, liftStartDate, liftEndDate, liftAbs, spend, confidence, metric.
You can calibrate any spend or organic variable with a well designed experiment.
You can also use experimental results from multiple channels; to do so,
provide concatenated channel value, i.e. &quot;channel_A+channel_B&quot;.
Check &quot;Guide for calibration source&quot; section.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_objective_weights">objective_weights</code></td>
<td>
<p>Numeric vector. Default to NULL to give equal weights
to all objective functions. Order: NRMSE, DECOMP.RSSD, MAPE (when calibration
data is provided). When you are not calibrating, only the first 2 values for
<code>objective_weights</code> must be defined, i.e. set c(2, 1) to give double weight
to the 1st (NRMSE). This is an experimental feature. There's no research on
optimal weight setting. Subjective weights might strongly bias modeling results.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_...">...</code></td>
<td>
<p>Additional parameters to overwrite original custom parameters
passed into initial model.</p>
</td></tr>
<tr><td><code id="robyn_refresh_+3A_x">x</code></td>
<td>
<p><code>robyn_refresh()</code> output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. The Robyn object, class <code>robyn_refresh</code>.
</p>
<p>List. Same as <code>robyn_run()</code> but with refreshed models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loading dummy data
data("dt_simulated_weekly")
data("dt_prophet_holidays")
# Set the (pre-trained and exported) Robyn model JSON file
json_file &lt;- "~/Robyn_202208081444_init/RobynModel-2_55_4.json"

# Run \code{robyn_refresh()} with 13 weeks cadence in auto mode
Robyn &lt;- robyn_refresh(
  json_file = json_file,
  dt_input = dt_simulated_weekly,
  dt_holidays = Robyn::dt_prophet_holidays,
  refresh_steps = 13,
  refresh_mode = "auto",
  refresh_iters = 200,
  refresh_trials = 5
)

# Run \code{robyn_refresh()} with 4 weeks cadence in manual mode
json_file2 &lt;- "~/Robyn_202208081444_init/Robyn_202208090847_rf/RobynModel-1_2_3.json"
Robyn &lt;- robyn_refresh(
  json_file = json_file2,
  dt_input = dt_simulated_weekly,
  dt_holidays = Robyn::dt_prophet_holidays,
  refresh_steps = 4,
  refresh_mode = "manual",
  refresh_iters = 200,
  refresh_trials = 5
)

## End(Not run)
</code></pre>

<hr>
<h2 id='robyn_response'>Response and Saturation Curves</h2><span id='topic+robyn_response'></span>

<h3>Description</h3>

<p><code>robyn_response()</code> returns the response for a given
spend level of a given <code>paid_media_vars</code> from a selected model
result and selected model build (initial model, refresh model, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_response(
  InputCollect = NULL,
  OutputCollect = NULL,
  json_file = NULL,
  robyn_object = NULL,
  select_build = NULL,
  select_model = NULL,
  metric_name = NULL,
  metric_value = NULL,
  date_range = NULL,
  dt_hyppar = NULL,
  dt_coef = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_response_+3A_inputcollect">InputCollect</code></td>
<td>
<p>List. Contains all input parameters for the model.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_outputcollect">OutputCollect</code></td>
<td>
<p>List. Containing all model result.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_json_file">json_file</code></td>
<td>
<p>Character. JSON file to import previously exported inputs or
recreate a model. To generate this file, use <code>robyn_write()</code>.
If you didn't export your data in the json file as &quot;raw_data&quot;,
<code>dt_input</code> must be provided; <code>dt_holidays</code> input is optional.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_robyn_object">robyn_object</code></td>
<td>
<p>Character or List. Path of the <code>Robyn.RDS</code> object
that contains all previous modeling information or the imported list.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_select_build">select_build</code></td>
<td>
<p>Integer. Default to the latest model build. <code>select_build = 0</code>
selects the initial model. <code>select_build = 1</code> selects the first refresh model.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_select_model">select_model</code></td>
<td>
<p>Character. A model <code>SolID</code>. When <code>robyn_object</code>
is provided, <code>select_model</code> defaults to the already selected <code>SolID</code>. When
<code>robyn_object</code> is not provided, <code>select_model</code> must be provided with
<code>InputCollect</code> and <code>OutputCollect</code>, and must be one of
<code>OutputCollect$allSolutions</code>.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_metric_name">metric_name</code></td>
<td>
<p>A character. Selected media variable for the response.
Must be one value from paid_media_spends, paid_media_vars or organic_vars</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_metric_value">metric_value</code></td>
<td>
<p>Numeric. Desired metric value to return a response for.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_date_range">date_range</code></td>
<td>
<p>Character. Date(s) to apply adstocked transformations and pick mean spends
per channel. Set one of: &quot;all&quot;, &quot;last&quot;, or &quot;last_n&quot; (where
n is the last N dates available), date (i.e. &quot;2022-03-27&quot;), or date range
(i.e. <code>c("2022-01-01", "2022-12-31")</code>). Default to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_dt_hyppar">dt_hyppar</code></td>
<td>
<p>A data.frame. When <code>robyn_object</code> is not provided, use
<code>dt_hyppar = OutputCollect$resultHypParam</code>. It must be provided along
<code>select_model</code>, <code>dt_coef</code> and <code>InputCollect</code>.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_dt_coef">dt_coef</code></td>
<td>
<p>A data.frame. When <code>robyn_object</code> is not provided, use
<code>dt_coef = OutputCollect$xDecompAgg</code>. It must be provided along
<code>select_model</code>, <code>dt_hyppar</code> and <code>InputCollect</code>.</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_response_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>robyn_outputs()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Response value and plot. Class: <code>robyn_response</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Having InputCollect and OutputCollect objects
## Recreate original saturation curve
Response &lt;- robyn_response(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = select_model,
  metric_name = "facebook_S"
)
Response$plot

## Or you can call a JSON file directly (a bit slower)
# Response &lt;- robyn_response(
#   json_file = "your_json_path.json",
#   dt_input = dt_simulated_weekly,
#   dt_holidays = dt_prophet_holidays,
#   metric_name = "facebook_S"
# )

## Get the "next 100 dollar" marginal response on Spend1
Spend1 &lt;- 20000
Response1 &lt;- robyn_response(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = select_model,
  metric_name = "facebook_S",
  metric_value = Spend1, # total budget for date_range
  date_range = "last_1" # last two periods
)
Response1$plot

Spend2 &lt;- Spend1 + 100
Response2 &lt;- robyn_response(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = select_model,
  metric_name = "facebook_S",
  metric_value = Spend2,
  date_range = "last_1"
)
# ROAS for the 100$ from Spend1 level
(Response2$response_total - Response1$response_total) / (Spend2 - Spend1)

## Get response from for a given budget and date_range
Spend3 &lt;- 100000
Response3 &lt;- robyn_response(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = select_model,
  metric_name = "facebook_S",
  metric_value = Spend3, # total budget for date_range
  date_range = "last_5" # last 5 periods
)
Response3$plot

## Example of getting paid media exposure response curves
imps &lt;- 10000000
response_imps &lt;- robyn_response(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = select_model,
  metric_name = "facebook_I",
  metric_value = imps
)
response_imps$response_total / imps * 1000
response_imps$plot

## Example of getting organic media exposure response curves
sendings &lt;- 30000
response_sending &lt;- robyn_response(
  InputCollect = InputCollect,
  OutputCollect = OutputCollect,
  select_model = select_model,
  metric_name = "newsletter",
  metric_value = sendings
)
# response per 1000 sendings
response_sending$response_total / sendings * 1000
response_sending$plot

## End(Not run)
</code></pre>

<hr>
<h2 id='robyn_run'>Robyn Modelling Function</h2><span id='topic+robyn_run'></span><span id='topic+print.robyn_models'></span>

<h3>Description</h3>

<p><code>robyn_run()</code> consumes <code>robyn_input()</code> outputs,
runs <code>robyn_mmm()</code>, and collects all modeling results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_run(
  InputCollect = NULL,
  dt_hyper_fixed = NULL,
  json_file = NULL,
  ts_validation = FALSE,
  add_penalty_factor = FALSE,
  refresh = FALSE,
  seed = 123L,
  quiet = FALSE,
  cores = NULL,
  trials = 5,
  iterations = 2000,
  rssd_zero_penalty = TRUE,
  objective_weights = NULL,
  nevergrad_algo = "TwoPointsDE",
  intercept = TRUE,
  intercept_sign = "non_negative",
  lambda_control = NULL,
  outputs = FALSE,
  ...
)

## S3 method for class 'robyn_models'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_run_+3A_inputcollect">InputCollect</code></td>
<td>
<p>List. Contains all input parameters for the model.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_dt_hyper_fixed">dt_hyper_fixed</code></td>
<td>
<p>data.frame or named list. Only provide when loading
old model results. It consumes hyperparameters from saved csv
<code>pareto_hyperparameters.csv</code> or JSON file to replicate a model.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_json_file">json_file</code></td>
<td>
<p>Character. JSON file to import previously exported inputs or
recreate a model. To generate this file, use <code>robyn_write()</code>.
If you didn't export your data in the json file as &quot;raw_data&quot;,
<code>dt_input</code> must be provided; <code>dt_holidays</code> input is optional.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_ts_validation">ts_validation</code></td>
<td>
<p>Boolean. When set to <code>TRUE</code>, Robyn will split data
by test, train, and validation partitions to validate the time series. By
default the &quot;train_size&quot; range is set to <code>c(0.5, 0.8)</code>, but it can be
customized or set to a fixed value using the hyperparameters input. For example,
if <code>train_size = 0.7</code>, validation size and test size will both be 0.15
and 0.15. When <code>ts_validation = FALSE</code>, nrmse_train is the
objective function; when <code>ts_validation = TRUE</code>, nrmse_val is the objective
function.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_add_penalty_factor">add_penalty_factor</code></td>
<td>
<p>Boolean. Add penalty factor hyperparameters to
glmnet's penalty.factor to be optimized by nevergrad. Use with caution, because
this feature might add too much hyperparameter space and probably requires
more iterations to converge.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_refresh">refresh</code></td>
<td>
<p>Boolean. Set to <code>TRUE</code> when used in <code>robyn_refresh()</code>.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_seed">seed</code></td>
<td>
<p>Integer. For reproducible results when running nevergrad.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_cores">cores</code></td>
<td>
<p>Integer. Default to <code>parallel::detectCores() - 1</code> (all cores
except one). Set to 1 if you want to turn parallel computing off.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_trials">trials</code></td>
<td>
<p>Integer. Recommended 5 for default
<code>nevergrad_algo = "TwoPointsDE"</code>.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Recommended 2000 for default when using
<code>nevergrad_algo = "TwoPointsDE"</code>.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_rssd_zero_penalty">rssd_zero_penalty</code></td>
<td>
<p>Boolean. When TRUE, the objective function
DECOMP.RSSD will penalize models with more 0 media effects additionally.
In other words, given the same DECOMP.RSSD score, a model with 50% 0-coef
variables will get penalized by DECOMP.RSSD * 1.5 (larger error), while
another model with no 0-coef variables gets un-penalized with DECOMP.RSSD * 1.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_objective_weights">objective_weights</code></td>
<td>
<p>Numeric vector. Default to NULL to give equal weights
to all objective functions. Order: NRMSE, DECOMP.RSSD, MAPE (when calibration
data is provided). When you are not calibrating, only the first 2 values for
<code>objective_weights</code> must be defined, i.e. set c(2, 1) to give double weight
to the 1st (NRMSE). This is an experimental feature. There's no research on
optimal weight setting. Subjective weights might strongly bias modeling results.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_nevergrad_algo">nevergrad_algo</code></td>
<td>
<p>Character. Default to &quot;TwoPointsDE&quot;. Options are
<code>c("DE","TwoPointsDE", "OnePlusOne", "DoubleFastGADiscreteOnePlusOne",
"DiscreteOnePlusOne", "PortfolioDiscreteOnePlusOne", "NaiveTBPSA",
"cGA", "RandomSearch")</code>.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_intercept">intercept</code></td>
<td>
<p>Boolean. Should intercept(s) be fitted (default=TRUE) or
set to zero (FALSE).</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_intercept_sign">intercept_sign</code></td>
<td>
<p>Character. Choose one of &quot;non_negative&quot; (default) or
&quot;unconstrained&quot;. By default, if intercept is negative, Robyn will drop intercept
and refit the model. Consider changing intercept_sign to &quot;unconstrained&quot; when
there are <code>context_vars</code> with large positive values.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_lambda_control">lambda_control</code></td>
<td>
<p>Deprecated in v3.6.0.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_outputs">outputs</code></td>
<td>
<p>Boolean. If set to TRUE, will run <code>robyn_run()</code> and
<code>robyn_outputs()</code>, returning a list with OutputModels and
OutputCollect results.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>robyn_outputs()</code>.</p>
</td></tr>
<tr><td><code id="robyn_run_+3A_x">x</code></td>
<td>
<p><code>robyn_models()</code> output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Class: <code>robyn_models</code>. Contains the results of all trials
and iterations modeled.
</p>
<p>List. Contains all trained models. Class: <code>robyn_models</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Having InputCollect results
OutputModels &lt;- robyn_run(
  InputCollect = InputCollect,
  cores = 2,
  iterations = 200,
  trials = 1
)

## End(Not run)
</code></pre>

<hr>
<h2 id='robyn_save'>Export Robyn Model to Local File [DEPRECATED]</h2><span id='topic+robyn_save'></span><span id='topic+print.robyn_save'></span><span id='topic+plot.robyn_save'></span><span id='topic+robyn_load'></span>

<h3>Description</h3>

<p>Use <code>robyn_save()</code> to select and save as .RDS file the initial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_save(
  InputCollect,
  OutputCollect,
  robyn_object = NULL,
  select_model = NULL,
  dir = OutputCollect$plot_folder,
  quiet = FALSE,
  ...
)

## S3 method for class 'robyn_save'
print(x, ...)

## S3 method for class 'robyn_save'
plot(x, ...)

robyn_load(robyn_object, select_build = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_save_+3A_inputcollect">InputCollect</code></td>
<td>
<p>List. Contains all input parameters for the model.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_outputcollect">OutputCollect</code></td>
<td>
<p>List. Containing all model result.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_robyn_object">robyn_object</code></td>
<td>
<p>Character or List. Path of the <code>Robyn.RDS</code> object
that contains all previous modeling information or the imported list.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_select_model">select_model</code></td>
<td>
<p>Character. A model <code>SolID</code>. When <code>robyn_object</code>
is provided, <code>select_model</code> defaults to the already selected <code>SolID</code>. When
<code>robyn_object</code> is not provided, <code>select_model</code> must be provided with
<code>InputCollect</code> and <code>OutputCollect</code>, and must be one of
<code>OutputCollect$allSolutions</code>.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_dir">dir</code></td>
<td>
<p>Character. Existing directory to export JSON file to.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>robyn_outputs()</code>.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_x">x</code></td>
<td>
<p><code>robyn_save()</code> output.</p>
</td></tr>
<tr><td><code id="robyn_save_+3A_select_build">select_build</code></td>
<td>
<p>Integer. Default to the latest model build. <code>select_build = 0</code>
selects the initial model. <code>select_build = 1</code> selects the first refresh model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(Invisible) list with filename and summary. Class: <code>robyn_save</code>.
</p>
<p>(Invisible) list with imported results
</p>

<hr>
<h2 id='robyn_train'>Train Robyn Models</h2><span id='topic+robyn_train'></span>

<h3>Description</h3>

<p><code>robyn_train()</code> consumes output from <code>robyn_input()</code>
and runs the <code>robyn_mmm()</code> on each trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_train(
  InputCollect,
  hyper_collect,
  cores,
  iterations,
  trials,
  intercept_sign,
  intercept,
  nevergrad_algo,
  dt_hyper_fixed = NULL,
  ts_validation = TRUE,
  add_penalty_factor = FALSE,
  objective_weights = NULL,
  rssd_zero_penalty = TRUE,
  refresh = FALSE,
  seed = 123,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_train_+3A_inputcollect">InputCollect</code></td>
<td>
<p>List. Contains all input parameters for the model.
Required when <code>robyn_object</code> is not provided.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_hyper_collect">hyper_collect</code></td>
<td>
<p>List. Containing hyperparameter bounds. Defaults to
<code>InputCollect$hyperparameters</code>.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_cores">cores</code></td>
<td>
<p>Integer. Default to <code>parallel::detectCores() - 1</code> (all cores
except one). Set to 1 if you want to turn parallel computing off.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Recommended 2000 for default when using
<code>nevergrad_algo = "TwoPointsDE"</code>.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_trials">trials</code></td>
<td>
<p>Integer. Recommended 5 for default
<code>nevergrad_algo = "TwoPointsDE"</code>.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_intercept_sign">intercept_sign</code></td>
<td>
<p>Character. Choose one of &quot;non_negative&quot; (default) or
&quot;unconstrained&quot;. By default, if intercept is negative, Robyn will drop intercept
and refit the model. Consider changing intercept_sign to &quot;unconstrained&quot; when
there are <code>context_vars</code> with large positive values.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_intercept">intercept</code></td>
<td>
<p>Boolean. Should intercept(s) be fitted (default=TRUE) or
set to zero (FALSE).</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_nevergrad_algo">nevergrad_algo</code></td>
<td>
<p>Character. Default to &quot;TwoPointsDE&quot;. Options are
<code>c("DE","TwoPointsDE", "OnePlusOne", "DoubleFastGADiscreteOnePlusOne",
"DiscreteOnePlusOne", "PortfolioDiscreteOnePlusOne", "NaiveTBPSA",
"cGA", "RandomSearch")</code>.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_dt_hyper_fixed">dt_hyper_fixed</code></td>
<td>
<p>data.frame or named list. Only provide when loading
old model results. It consumes hyperparameters from saved csv
<code>pareto_hyperparameters.csv</code> or JSON file to replicate a model.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_ts_validation">ts_validation</code></td>
<td>
<p>Boolean. When set to <code>TRUE</code>, Robyn will split data
by test, train, and validation partitions to validate the time series. By
default the &quot;train_size&quot; range is set to <code>c(0.5, 0.8)</code>, but it can be
customized or set to a fixed value using the hyperparameters input. For example,
if <code>train_size = 0.7</code>, validation size and test size will both be 0.15
and 0.15. When <code>ts_validation = FALSE</code>, nrmse_train is the
objective function; when <code>ts_validation = TRUE</code>, nrmse_val is the objective
function.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_add_penalty_factor">add_penalty_factor</code></td>
<td>
<p>Boolean. Add penalty factor hyperparameters to
glmnet's penalty.factor to be optimized by nevergrad. Use with caution, because
this feature might add too much hyperparameter space and probably requires
more iterations to converge.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_objective_weights">objective_weights</code></td>
<td>
<p>Numeric vector. Default to NULL to give equal weights
to all objective functions. Order: NRMSE, DECOMP.RSSD, MAPE (when calibration
data is provided). When you are not calibrating, only the first 2 values for
<code>objective_weights</code> must be defined, i.e. set c(2, 1) to give double weight
to the 1st (NRMSE). This is an experimental feature. There's no research on
optimal weight setting. Subjective weights might strongly bias modeling results.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_rssd_zero_penalty">rssd_zero_penalty</code></td>
<td>
<p>Boolean. When TRUE, the objective function
DECOMP.RSSD will penalize models with more 0 media effects additionally.
In other words, given the same DECOMP.RSSD score, a model with 50% 0-coef
variables will get penalized by DECOMP.RSSD * 1.5 (larger error), while
another model with no 0-coef variables gets un-penalized with DECOMP.RSSD * 1.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_refresh">refresh</code></td>
<td>
<p>Boolean. Set to <code>TRUE</code> when used in <code>robyn_refresh()</code>.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_seed">seed</code></td>
<td>
<p>Integer. For reproducible results when running nevergrad.</p>
</td></tr>
<tr><td><code id="robyn_train_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Iteration results to include in <code>robyn_run()</code> results.
</p>

<hr>
<h2 id='robyn_update'>Update Robyn Version</h2><span id='topic+robyn_update'></span>

<h3>Description</h3>

<p>Update Robyn version from
<a href="https://github.com/facebookexperimental/Robyn">Github repository</a>
for latest &quot;dev&quot; version or from
<a href="https://CRAN.R-project.org/package=Robyn">CRAN</a>
for latest &quot;stable&quot; version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_update(dev = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_update_+3A_dev">dev</code></td>
<td>
<p>Boolean. Dev version? If not, CRAN version.</p>
</td></tr>
<tr><td><code id="robyn_update_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code>remotes::install_github</code>
or <code>utils::install.packages</code>, depending on <code>dev</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code>.
</p>

<hr>
<h2 id='robyn_write'>Import and Export Robyn JSON files</h2><span id='topic+robyn_write'></span><span id='topic+print.robyn_write'></span><span id='topic+robyn_read'></span><span id='topic+print.robyn_read'></span><span id='topic+robyn_recreate'></span>

<h3>Description</h3>

<p><code>robyn_write()</code> generates light JSON files with all the information
required to replicate Robyn models. Depending on user inputs, there are
3 use cases: only the inputs data, input data + modeling results data,
and input data, modeling results + specifics of a single selected model.
To replicate a model, you must provide InputCollect, OutputCollect, and,
if OutputCollect contains more than one model, the select_model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robyn_write(
  InputCollect,
  OutputCollect = NULL,
  select_model = NULL,
  dir = OutputCollect$plot_folder,
  add_data = TRUE,
  export = TRUE,
  quiet = FALSE,
  pareto_df = NULL,
  ...
)

## S3 method for class 'robyn_write'
print(x, ...)

robyn_read(json_file = NULL, step = 1, quiet = FALSE, ...)

## S3 method for class 'robyn_read'
print(x, ...)

robyn_recreate(json_file, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robyn_write_+3A_inputcollect">InputCollect</code></td>
<td>
<p><code>robyn_inputs()</code> output.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_outputcollect">OutputCollect</code></td>
<td>
<p><code>robyn_run(..., export = FALSE)</code> output.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_select_model">select_model</code></td>
<td>
<p>Character. Which model ID do you want to export
into the JSON file?</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_dir">dir</code></td>
<td>
<p>Character. Existing directory to export JSON file to.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_add_data">add_data</code></td>
<td>
<p>Boolean. Include raw dataset. Useful to recreate models
with a single file containing all the required information (no need of CSV).</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_export">export</code></td>
<td>
<p>Boolean. Export outcomes into local files?</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_quiet">quiet</code></td>
<td>
<p>Boolean. Keep messages off?</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_pareto_df">pareto_df</code></td>
<td>
<p>Dataframe. Save all pareto solutions to json file.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_...">...</code></td>
<td>
<p>Additional parameters to export into a custom Extras element.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_x">x</code></td>
<td>
<p><code>robyn_read()</code> or <code>robyn_write()</code> output.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_json_file">json_file</code></td>
<td>
<p>Character. JSON file name to read and import.</p>
</td></tr>
<tr><td><code id="robyn_write_+3A_step">step</code></td>
<td>
<p>Integer. 1 for import only and 2 for import and output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(invisible) List. Contains all inputs and outputs of exported model.
Class: <code>robyn_write</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
InputCollectJSON &lt;- robyn_inputs(
  dt_input = Robyn::dt_simulated_weekly,
  json_file = "~/Desktop/RobynModel-1_29_12.json"
)
print(InputCollectJSON)

## End(Not run)
</code></pre>

<hr>
<h2 id='saturation_hill'>Hill Saturation Transformation</h2><span id='topic+saturation_hill'></span><span id='topic+plot_saturation'></span>

<h3>Description</h3>

<p><code>saturation_hill</code> is a two-parametric version of the Hill
function that allows the saturation curve to flip between S and C shape.
</p>
<p>Produce example plots for the Hill saturation curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saturation_hill(x, alpha, gamma, x_marginal = NULL)

plot_saturation(plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saturation_hill_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="saturation_hill_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Alpha controls the shape of the saturation curve.
The larger the alpha, the more S-shape. The smaller, the more C-shape.</p>
</td></tr>
<tr><td><code id="saturation_hill_+3A_gamma">gamma</code></td>
<td>
<p>Numeric. Gamma controls the inflexion point of the
saturation curve. The larger the gamma, the later the inflexion point occurs.</p>
</td></tr>
<tr><td><code id="saturation_hill_+3A_x_marginal">x_marginal</code></td>
<td>
<p>Numeric. When provided, the function returns the
Hill-transformed value of the x_marginal input.</p>
</td></tr>
<tr><td><code id="saturation_hill_+3A_plot">plot</code></td>
<td>
<p>Boolean. Do you wish to return the plot?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric values. Transformed values.
</p>


<h3>See Also</h3>

<p>Other Transformations: 
<code><a href="#topic+adstock_geometric">adstock_geometric</a>()</code>,
<code><a href="#topic+mic_men">mic_men</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>saturation_hill(c(100, 150, 170, 190, 200), alpha = 3, gamma = 0.5)
</code></pre>

<hr>
<h2 id='set_holidays'>Detect and set date variable interval</h2><span id='topic+set_holidays'></span>

<h3>Description</h3>

<p>Robyn only accepts daily, weekly and monthly data. This function
is only called in <code>robyn_engineering()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_holidays(dt_transform, dt_holidays, intervalType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_holidays_+3A_dt_transform">dt_transform</code></td>
<td>
<p>A data.frame. Transformed input data.</p>
</td></tr>
<tr><td><code id="set_holidays_+3A_dt_holidays">dt_holidays</code></td>
<td>
<p>A data.frame. Raw input holiday data.</p>
</td></tr>
<tr><td><code id="set_holidays_+3A_intervaltype">intervalType</code></td>
<td>
<p>A character. Accepts one of the values:
<code>c("day","week","month")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. Containing the all spend-exposure model results.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
