<!DOCTYPE html><html lang="en"><head><title>Help for package nbody</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nbody}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nbody-package'><p>Gravitational N-Body Simulation</p></a></li>
<li><a href='#.nbody.env'><p>Package environment</p></a></li>
<li><a href='#default.code'><p>Set a default external simulation code</p></a></li>
<li><a href='#energy'><p>Mechanical energy of an N-body system</p></a></li>
<li><a href='#plot.simulation'><p>Visualize an N-body simulation</p></a></li>
<li><a href='#reset.cm'><p>Move center of mass to the origin</p></a></li>
<li><a href='#run.simulation'><p>Run a direct N-body simulation</p></a></li>
<li><a href='#setup'><p>Initialize N-body simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gravitational N-Body Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.41</td>
</tr>
<tr>
<td>Description:</td>
<td>Run simple direct gravitational N-body simulations. The package can access different external N-body simulators (e.g. GADGET-4 by Springel et al. (2021) &lt;<a href="https://doi.org/10.48550%2FarXiv.2010.03567">doi:10.48550/arXiv.2010.03567</a>&gt;), but also has a simple built-in simulator. This default simulator uses a variable block time step and lets the user choose between a range of integrators, including 4th and 6th order integrators for high-accuracy simulations. Basic top-hat smoothing is available as an option. The code also allows the definition of background particles that are fixed or in uniform motion, not subject to acceleration by other particles.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magicaxis, Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-01 09:32:53 UTC; 00077389</td>
</tr>
<tr>
<td>Author:</td>
<td>Danail Obreschkow <a href="https://orcid.org/0000-0002-1527-0762"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Danail Obreschkow &lt;danail.obreschkow@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-20 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='nbody-package'>Gravitational N-Body Simulation</h2><span id='topic+nbody'></span><span id='topic+nbody-package'></span>

<h3>Description</h3>

<p>Run simple direct gravitational N-body simulations. The package can access different external N-body simulators (e.g. GADGET-4 by Springel et al., 2021), but also has a simple built-in simulator. This default simulator uses a variable block time step and lets the user choose between a range of integrators, including 4th and 6th order integrators for high-accuracy simulations. Basic top-hat smoothing is available as an option. The code also allows the definition of background particles that are fixed or in uniform motion, not subject to acceleration by other particles.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow &lt;danail.obreschkow@gmail.com&gt;
</p>

<hr>
<h2 id='.nbody.env'>Package environment</h2><span id='topic+.nbody.env'></span>

<h3>Description</h3>

<p>Environment used to store paths and options for external code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.nbody.env
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 0.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+default.code">default.code</a></code>
</p>

<hr>
<h2 id='default.code'>Set a default external simulation code</h2><span id='topic+default.code'></span>

<h3>Description</h3>

<p>Set a default external simulation code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.code(code = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default.code_+3A_code">code</code></td>
<td>
<p>structured list specifying the default external simulation code used when calling <code><a href="#topic+run.simulation">run.simulation</a></code>. This list has exactly the same format as the sub-list 'code' described in the documentation of <code><a href="#topic+run.simulation">run.simulation</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the current list 'code'. If no such last has been set and 'default.code()' is called without argument, an error is produced.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='energy'>Mechanical energy of an N-body system</h2><span id='topic+energy'></span>

<h3>Description</h3>

<p>Computes the instantaneous potential and kinetic energies of all particles in an N-body system. Here, the potential energy of a particle i means the potential energy it has with all other particles (sum_j -G*m[i]*[j]/rij). Hence the total potential energy of the system is half the sum of the individual potential energies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>energy(m, x, v, rsmooth = 0, G = 6.67408e-11, cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="energy_+3A_m">m</code></td>
<td>
<p>N-vector with the masses of the N particles. Negative masses are treated as positive masses of same magnitude, since negative masses normally represent positive background masses in the nbody package.</p>
</td></tr>
<tr><td><code id="energy_+3A_x">x</code></td>
<td>
<p>N-by-3 matrix specifying the initial position in Cartesian coordinates</p>
</td></tr>
<tr><td><code id="energy_+3A_v">v</code></td>
<td>
<p>N-by-3 matrix specifying the initial velocities</p>
</td></tr>
<tr><td><code id="energy_+3A_rsmooth">rsmooth</code></td>
<td>
<p>top-hat smoothing radius.</p>
</td></tr>
<tr><td><code id="energy_+3A_g">G</code></td>
<td>
<p>gravitational constant. The default is the measured value in SI units.</p>
</td></tr>
<tr><td><code id="energy_+3A_cpp">cpp</code></td>
<td>
<p>logical flag. If TRUE (default), the computation is performed efficiently in C++.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with vector items <code>Ekin</code>, <code>Epot</code>, <code>Emec=Ekin+Epot</code>; and the associated total quantities <code>Ekin.tot</code>, <code>Epot.tot</code>, <code>Emec=Ekin+Epot.tot</code>.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='plot.simulation'>Visualize an N-body simulation</h2><span id='topic+plot.simulation'></span>

<h3>Description</h3>

<p>Basic routine to visualise the result of an N-body simulation, projected onto a plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simulation'
plot(
  x,
  y,
  units = 1,
  index1 = 1,
  index2 = 2,
  xlim = NULL,
  ylim = NULL,
  center = c(0, 0, 0),
  cex = 0.3,
  pch = 20,
  title = "",
  asp = 1,
  pty = "m",
  col = "black",
  alpha.orbits = 1,
  alpha.snapshots = 1,
  lwd = 1,
  show.orbits = TRUE,
  show.snapshots = TRUE,
  show.ics = TRUE,
  show.fcs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simulation_+3A_x">x</code></td>
<td>
<p>is a simulation-object as produced by <code>run.simulation</code></p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_y">y</code></td>
<td>
<p>deprecated argument included for consistency with generic <code><a href="graphics.html#topic+plot">plot</a></code> function</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_units">units</code></td>
<td>
<p>length unit in SI units</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_index1">index1</code></td>
<td>
<p>index of the dimension plotted on the x-axis</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_index2">index2</code></td>
<td>
<p>index of the dimension plotted on the y-axis</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_xlim">xlim</code></td>
<td>
<p>2-vector specifying the plotting range along the x-axis</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_ylim">ylim</code></td>
<td>
<p>2-vector specifying the plotting range along the y-axis</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_center">center</code></td>
<td>
<p>3-vector specifying the plotting center in the specified units</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_pch">pch</code></td>
<td>
<p>point type</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_title">title</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x and y axes</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_pty">pty</code></td>
<td>
<p>character specifying the type of plot region to be used; &quot;s&quot; generates a square plotting region and &quot;m&quot; generates the maximal plotting region.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_col">col</code></td>
<td>
<p>either (1) a single color, (2) a n-element vector of colors for each particle or (3) a function(n,...) producing n colors, e.g. 'rainbow'</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_alpha.orbits">alpha.orbits</code></td>
<td>
<p>opacity (0...1) of orbital lines.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_alpha.snapshots">alpha.snapshots</code></td>
<td>
<p>opacity (0...1) of snapshot points.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_lwd">lwd</code></td>
<td>
<p>line width of orbital lines.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_show.orbits">show.orbits</code></td>
<td>
<p>logical flag. If TRUE (default), the orbits are shown as straight lines between snapshots.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_show.snapshots">show.snapshots</code></td>
<td>
<p>logical flag. If TRUE (default), points are shown for each snapshot.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_show.ics">show.ics</code></td>
<td>
<p>logical flag. If TRUE (default), the initial positions are highlighted.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_show.fcs">show.fcs</code></td>
<td>
<p>logical flag. If TRUE (default), the final positions are highlighted.</p>
</td></tr>
<tr><td><code id="plot.simulation_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='reset.cm'>Move center of mass to the origin</h2><span id='topic+reset.cm'></span>

<h3>Description</h3>

<p>Routine, designed to reset the center of mass (CM) of the initial conditions (ICs) of an N-body simulation. The CM position and velocity are both shifted to (0,0,0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset.cm(sim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reset.cm_+3A_sim">sim</code></td>
<td>
<p>list of m, x, v or list with a sublist &quot;ics&quot;, made of m, x, v, where
<code>m</code> = N-vector with the masses of the N particles. Negative masses are treated as positive masses of same magnitude, since negative masses normally represent positive background masses in the nbody package.<br />
<code>x</code> = N-by-3 matrix specifying the initial position in cartesian coordinates<br />
<code>v</code> = N-by-3 matrix specifying the initial velocities<br /><br /></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a structure of the same format as the input argument, but with re-centered positions and velocities.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='run.simulation'>Run a direct N-body simulation</h2><span id='topic+run.simulation'></span>

<h3>Description</h3>

<p>Run direct N-body simulations using an adaptive block timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.simulation(sim, measure.time = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.simulation_+3A_sim">sim</code></td>
<td>
<p>structured list of simulation settings, which must contain the following sublists:<br /><br />
</p>
<p><code>ics</code> is the sublist of initial conditions. It must contain the items:<br />
<code>m</code> = N-vector with the masses of the N particles. Negative mass values are considered as positive masses belonging to a background field, which is not subject to any forces. Therefore particles with negative mass will have a normal effect on particles with positive masses, but they will not, themselves, be accelerated by any other particle.<br />
<code>x</code> = N-by-3 matrix specifying the initial position in Cartesian coordinates<br />
<code>v</code> = N-by-3 matrix specifying the initial velocities<br />
</p>
<p><code>para</code> is an optional sublist of optional simulation parameters. It contains the items:<br />
<code>t.max</code> = final simulation time in simulation units (see details). If not given, a characteristic time is computed as <code>t.max = 2*pi*sqrt(R^3/GM)</code>, where <code>R</code> is the RMS radius and <code>M</code> is the total mass.<br />
<code>dt.max</code> = maximum time step. If not given, no maximum time step is imposed, meaning that the maximum time step is either equal to <code>dt.out</code> or the adaptive time step, whichever is smaller.<br />
<code>dt.min</code> = minimum time step used, unless a smaller time step is required to save an output or to land precisely on the final time <code>t.max</code>.
<code>dt.out</code> = output time step, i.e. time step between successive snapshots in the <code>output</code> sublist returned by <code>run.simulation</code>. If not given, <code>dt.max=t.max/100</code> is assumed.<br />
<code>eta</code> = accuracy parameter of adaptive time step. Smaller values lead to proportionally smaller adaptive time steps. Typical values range between 0.001 and 0.1. If not given, a default value of 0.01 is assumed. To use fixed time steps, set <code>eta=1e99</code> and set a time step <code>dt.max</code>.<br />
<code>integrator</code> = character string specifying the integrator to be used. Currently implemented integrators are 'euler' (1st order), 'leapfrog' (2nd order), 'yoshida' (4th order), 'yoshida6' (6th order). If not given, 'leapfrog' is the default integrator.<br />
<code>rsmooth</code> = optional smoothing radius. If not given, no smoothing is assumed.<br />
<code>afield</code> = a function(x,t) of positions <code>x</code> (N-by-3 matrix) and time <code>t</code> (scalar), specifying the external acceleration field. It must return an N-by-3 matrix. If not given, no external field is assumed. If the external code &quot;nbodyx&quot; is used, then afield should be a vector of the parameters p1, p2, ... for the external acceleration field of &quot;nbodyx&quot;.<br />
<code>G</code> = gravitational constant in simulation units (see details). If not given, the measured value in SI units is used.<br />
<code>box.size</code> = scalar&gt;=0. If 0, open boundary conditions are adopted. If &gt;0, the simulation is run in a cubic box of side length box.size with periodic boundary conditions. In this case, the cubic box is contained in the interval [0,box.size) in all three Cartesian coordinates, and all initial positions must be contained in this interval. For periodic boundary conditions, the force between any two particles is always calculated along their shortest separation, which may cross 0-3 boundaries. The exception is GADGET-4, which also evaluates the forces from the periodic repetitions.<br />
<code>include.bg</code> = logical argument. If FALSE (default), only foreground particles, i.e. particles with masses &gt;=0, are contained in the output vectors <code>x</code> and <code>v</code>. If TRUE, all particles are included.<br />
</p>
<p><code>code</code> is an optional sublist to force the use of an external simulation code (see details). It contains the items:<br />
<code>name</code> = character string specifying the name of the code, currently available options are &quot;R&quot; (default), &quot;nbodyx&quot; (a simple, but fast N-body simulator in Fortran) and &quot;gadget4&quot; (a powerful N-body+SPH simulator, not very adequate for small direct N-body simulations).<br />
<code>file</code> = character string specifying the path+filename of the external compiled simulation code.<br />
<code>interface</code> = optional character string specifying a temporary working path used as interface with external codes. NOTE: All existing files in this directory are deleted! If not given, the current working directory is used by default.<br />
<code>kind</code> = optional number of bytes per floating-point number used in nbodyx output files (has no bearing on computation accuracy)<br />
<code>gadget.np</code> = number of processors used with GADGET-4 (defaults to 1, which is normally best for small direct N-body runs)<br /></p>
</td></tr>
<tr><td><code id="run.simulation_+3A_measure.time">measure.time</code></td>
<td>
<p>logical flag that determines whether time computation time will be measured and displayed.</p>
</td></tr>
<tr><td><code id="run.simulation_+3A_verbose">verbose</code></td>
<td>
<p>logical flag indicating whether to show console outputs from external codes. Ignored when using the in-built simulator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>UNITS: The initial conditions (in the sublist <code>ics</code>) can be provided in any units. The units of mass, length and velocity then fix the other units.
For instance, [unit of time in seconds] = [unit of length in meters] / [unit of velocity in m/s]. E.g., if initial positions are given in units of 1AU=1.49598e11m and velocities in units of 1km/s, one unit of time is 1.49598e8s=4.74yrs.
Likewise, units of the gravitational constant <code>G</code> are given via [unit of G in m^3*kg^(-1)*s^(-2)] = [unit of length in meters] * [unit of velocity in m/s]^2 / [unit of mass in kg]. E.g., for length units of 1AU=1.49598e11m, velocity units of 1km/s=1e3m/s and mass units of 1Msun=1.98847e30kg, a unit of G is
7.523272e-14 m^3*kg^(-1)*s^(-2). In these units the true value of G is about 887.154.<br /><br />
</p>
<p>NBODYX simulator:<br />
Can be downloaded from github via<br />
<code>git clone https://github.com/obreschkow/nbodyx</code><br />
Details on installing, compiling and running the code are given in the README file.<br />
Note: To run very high-accuracy simulations, such as the Pythagorean three-body problem, you can use 128-bit floating-point numbers by compiling the code as<br />
<code>make kind=16</code><br /><br />
</p>
<p>GADGET-4 simulator:<br />
This his a very powerful N-body+SPH simulator used primarily for large astrophysical simulations. GADGET-4 is not particularly suitable for small direct N-body problems, but it can nonetheless be used for such simulations for the sake of comparison, at least if not too much accuracy is needed and if a massively increased computational overhead is acceptable.
Please refer to https://wwwmpa.mpa-garching.mpg.de/gadget4 for details on how to download and compile the code. In order to use GADGET-4 with this R-package, it must be compiled with the following compile-time options (in the file Config.sh):<br />
<code>NTYPES=2</code><br />
<code>GADGET2_HEADER</code><br />
<code>SELFGRAVITY</code><br />
<code>ALLOW_DIRECT_SUMMATION</code><br />
<code>HIERARCHICAL_GRAVITY</code><br />
<code>DOUBLEPRECISION=1</code><br />
<code>ENLARGE_DYNAMIC_RANGE_IN_TIME</code><br />
If and only if periodic boundary conditions are used, you also need to add the option<br />
<code>PERIODIC</code><br />
If you plan to often switch between runs with open and periodic boundaries, it may be advisable to compile two versions of GADGET-4, with and without this option. To do so, one needs to create two sub-directories with the respective Config.sh files and compile them via<br />
<code>make -j [number of cores] DIR=[path containing Config.sh with PERIODIC]</code><br />
<code>make -j [number of cores] DIR=[path containing Config.sh without PERIODIC]</code><br />
The runtime parameter file (param.txt) needed by GADGET-4 is written automatically when calling <code>run.simulation</code>. The gravitational softening length in GADGET-4 is computed as sim$para$rsmooth/2.8, which ensures that the particles behave like point masses at separations beyond sim$para$rsmooth. If rsmooth is not provided, it is computed as <code>stats::sd(apply(sim$ics$x,2,sd))*1e-5</code>. The accuracy parameter ErrTolIntAccuracy is set equal to sim$para$eta/sim$para$rsmooth*1e-3, which gives roughly comparable accuracy to in-built simulator for the Leapfrog integrator.
</p>


<h3>Value</h3>

<p>The routine returns the structured list of the input argument, with one sublist <code>output</code> added. This sublist contains the items:
</p>
<table role = "presentation">
<tr><td><code>t</code></td>
<td>
<p>k-vector with the simulation times of the k snapshots.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>k-by-N-by-3 array giving the 3D coordinates of the N particles in k snapshots.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>k-by-N-by-3 array giving the 3D velocities of the N particles in k snapshots.</p>
</td></tr>
<tr><td><code>n.snapshots</code></td>
<td>
<p>total number of snapshots.</p>
</td></tr>
<tr><td><code>n.iterations</code></td>
<td>
<p>total number of iterations used to run the simulation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = setup.halley()
sim = run.simulation(sim)
AU = 149597870700 # Astronomical unit in meters
plot(sim, units=AU, xlim=c(-20,60), ylim=c(-40,40), xlab='[AU]', ylab='[AU]')
cat(sprintf('This simulation was run with %d iterations.\n',sim$output$n.iterations))

</code></pre>

<hr>
<h2 id='setup'>Initialize N-body simulation</h2><span id='topic+setup'></span><span id='topic+setup.halley'></span><span id='topic+setup.earth'></span><span id='topic+setup.ellipse'></span><span id='topic+setup.3body.periodic'></span><span id='topic+setup.pythagoras'></span><span id='topic+setup.sunearth'></span><span id='topic+setup.periodic.3body'></span>

<h3>Description</h3>

<p>Routines to generate the structured lists of initial conditions and simulation parameters required to run an N-body simulation with <code><a href="#topic+run.simulation">run.simulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup()

setup.halley(
  t.max = NULL,
  nperiods = 1,
  dt.out = 1e+07,
  e = 0.96714,
  s = 2.667928e+12,
  ...
)

setup.sunearth(t.max = 31557600, dt.out = 86400 * 7, ...)

setup.ellipse(t.max = NULL, nperiods = 1, e = 0.9, s = 1, f = 0.5, ...)

setup.periodic.3body(
  v1 = 0.347112813567242,
  v2 = 0.532726851767674,
  t.max = 6.325,
  m3 = 1,
  ...
)

setup.pythagoras(t.max = 68, integrator = "yoshida6", eta = 0.002, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_+3A_t.max">t.max</code></td>
<td>
<p>final simulation time</p>
</td></tr>
<tr><td><code id="setup_+3A_nperiods">nperiods</code></td>
<td>
<p>number of orbital periods to be computed; ignored if <code>t.max</code> is specified.</p>
</td></tr>
<tr><td><code id="setup_+3A_dt.out">dt.out</code></td>
<td>
<p>time step for simulation output</p>
</td></tr>
<tr><td><code id="setup_+3A_e">e</code></td>
<td>
<p>eccentricity in setup.ellipse()</p>
</td></tr>
<tr><td><code id="setup_+3A_s">s</code></td>
<td>
<p>semi-major axis in setup.ellipse()</p>
</td></tr>
<tr><td><code id="setup_+3A_...">...</code></td>
<td>
<p>other simulation parameters used by <code><a href="#topic+run.simulation">run.simulation</a></code></p>
</td></tr>
<tr><td><code id="setup_+3A_f">f</code></td>
<td>
<p>mass-ratio in setup.ellipse()</p>
</td></tr>
<tr><td><code id="setup_+3A_v1">v1</code></td>
<td>
<p>first velocity parameter in setup.3body.periodic()</p>
</td></tr>
<tr><td><code id="setup_+3A_v2">v2</code></td>
<td>
<p>second velocity parameter in setup.3body.periodic()</p>
</td></tr>
<tr><td><code id="setup_+3A_m3">m3</code></td>
<td>
<p>mass of third body in setup.3body.periodic()</p>
</td></tr>
<tr><td><code id="setup_+3A_integrator">integrator</code></td>
<td>
<p>integrator used for N-body simulation, see <code><a href="#topic+run.simulation">run.simulation</a></code> for details.</p>
</td></tr>
<tr><td><code id="setup_+3A_eta">eta</code></td>
<td>
<p>accuracy parameter of adaptive time step, see <code><a href="#topic+run.simulation">run.simulation</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calling <code>setup()</code> is identical to calling setup.halley()
</p>
<p><code>setup.halley()</code> sets up a 2-body simulation of Halley's Comet around the Sun.
</p>
<p><code>setup.sunearth()</code> sets up a simple 2-body simulation of the Earth around the Sun, using only approximate orbital specifications.
</p>
<p><code>setup.ellipse()</code> sets up an elliptical Keplerian orbit in natural units
</p>
<p><code>setup.periodic.3body()</code> can be used to set up a planar zero angular momentum stable 3-body problem with two unit masses and a third mass m3 (maybe equal of different from unity). Such situations can be parameterized with two parameters v1 and v2, following the publications found at https://arxiv.org/abs/1709.04775 and https://arxiv.org/abs/1705.00527.<br />
The default is the famous figure-of-eight, but try, for example, setup.3body.periodic(0.2034916865234370, 0.5181128588867190, 32.850, dt.out=0.02), setup.3body.periodic(0.2009656237, 0.2431076328, 19.0134164290, 0.5, dt.out=0.01) or setup.3body.periodic(0.991198122, 0.711947212, 17.650780784, 4, eta=0.005, dt.out=0.002).<br /><br />
</p>
<p><code>setup.pythagoras()</code> sets up the Pythagorean three-body problem consisting of three unit masses placed at the vertices of a right triangle with side lengths 3, 4 and 5. The masses are initially at rest and the gravitational constant is unity.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim = setup.halley()
sim = run.simulation(sim)
plot(sim)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
