<!DOCTYPE html><html lang="en"><head><title>Help for package discSurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {discSurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#discSurv-package'><p>Discrete Survival Analysis</p></a></li>
<li><a href='#adjDevResid'><p>Adjusted Deviance Residuals in short format</p></a></li>
<li><a href='#calibrationPlot'><p>Calibration Plots</p></a></li>
<li><a href='#cIndex'><p>Concordance index</p></a></li>
<li><a href='#cIndexCompRisks'><p>Discrete concordance index for competing risks</p></a></li>
<li><a href='#compRisksGEE'><p>GEE model for discrete competing risks</p></a></li>
<li><a href='#contToDisc'><p>Continuous to Discrete Transformation</p></a></li>
<li><a href='#covarGEE'><p>GEE covariance of all events for discrete competing risks</p></a></li>
<li><a href='#crash2'><p>Crash 2 competing risk data</p></a></li>
<li><a href='#dataCensoring'><p>Data Censoring Transformation for short formats</p></a></li>
<li><a href='#dataLong'><p>Data Long Transformation</p></a></li>
<li><a href='#dataLongCompRisks'><p>Data Long Competing Risks Transformation</p></a></li>
<li><a href='#dataLongCompRisksTimeDep'><p>Data Long Competing Risks Time Dependent Covariates Transformation</p></a></li>
<li><a href='#dataLongMultiSpell'><p>Data long transformation for multi spell analysis</p></a></li>
<li><a href='#dataLongSubDist'><p>Data Matrix and Weights for Discrete Subdistribution Hazard Models</p></a></li>
<li><a href='#dataLongTimeDep'><p>Data Long Time Dependent Covariates</p></a></li>
<li><a href='#devResid'><p>Deviance Residuals</p></a></li>
<li><a href='#estCumInz'><p>Estimates Cumulative Incidence Function for Discrete Time Competing Risks Models</p></a></li>
<li><a href='#estMargProb'><p>Estimated Marginal Probabilities</p></a></li>
<li><a href='#estMargProbCompRisks'><p>Estimated Marginal Probabilities for Competing Risks</p></a></li>
<li><a href='#estRecal'><p>Logistic recalibration based on linear predictors</p></a></li>
<li><a href='#estSurv'><p>Estimated Survival Function</p></a></li>
<li><a href='#estSurvCens'><p>Estimated Survival Function of Censoring Process</p></a></li>
<li><a href='#estSurvCompRisks'><p>Estimated Survival Function for Competing Risks</p></a></li>
<li><a href='#gumbel'><p>Gumbel Link Function</p></a></li>
<li><a href='#intPredErr'><p>Integrated prediction error</p></a></li>
<li><a href='#intPredErrCompRisks'><p>Integrated Prediction Error for Competing Risks</p></a></li>
<li><a href='#lifeTable'><p>Life Table Construction and Estimates</p></a></li>
<li><a href='#martingaleResid'><p>Martingale Residuals</p></a></li>
<li><a href='#minNodePruning'><p>Minimal Node Size Pruning</p></a></li>
<li><a href='#minNodePruningCompRisks'><p>Minimal Node Size Pruning in the Presence of Competing Risks</p></a></li>
<li><a href='#plotCumInc'><p>Plot Estimated Cumulative Incidence Function</p></a></li>
<li><a href='#plotSurv'><p>Plot Estimated Survival Function</p></a></li>
<li><a href='#predErrCompRisks'><p>Prediction Error Curves for Competing Risks</p></a></li>
<li><a href='#print.discSurvPredErrDisc'><p>Prediction Error Curves</p></a></li>
<li><a href='#survTreeLaplaceHazard'><p>Laplace Hazards for a Competing Risk Survival Tree Object</p></a></li>
<li><a href='#survTreeLaplaceHazardRanger'><p>Laplace Hazards for a Competing Risk Survival Tree Object</p></a></li>
<li><a href='#unempMultiSpell'><p>Multiple Spell employment data</p></a></li>
<li><a href='#weightsLtoT'><p>Compute Subdistribution Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Discrete Time Survival Analysis</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Welchowski &lt;welchow@imbie.meb.uni-bonn.de&gt; and Moritz Berger &lt;moritz.berger@imbie.uni-bonn.de&gt; and David Koehler &lt;koehler@imbie.uni-bonn.de&gt; and Matthias Schmid &lt;matthias.schmid@imbie.uni-bonn.de&gt; </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Welchowski &lt;welchow@imbie.meb.uni-bonn.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides data transformations, estimation utilities,
    predictive evaluation measures and simulation functions for discrete time
    survival analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), treeClust</td>
</tr>
<tr>
<td>Imports:</td>
<td>functional, mvtnorm, mgcv, data.table, Rdpack, VGAM, geepack,
rpart, ranger, mvnfast</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, matrixcalc, numDeriv, caret, Ecdat, pec, survival,
nnet</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-02 14:19:28 UTC; welchow</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-02 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='discSurv-package'>Discrete Survival Analysis</h2><span id='topic+discSurv-package'></span>

<h3>Description</h3>

<p>Includes functions for data transformations, estimation, evaluation and
simulation of discrete survival analysis. The most important functions are listed below: </p>

<ul>
<li><p><code><a href="#topic+contToDisc">contToDisc</a></code>: Discretizes continuous time variable into a
specified grid of censored data for discrete survival analysis.
</p>
</li>
<li><p><code><a href="#topic+dataLong">dataLong</a></code>: Transform data from short format into long
format for discrete survival analysis and right censoring.
</p>
</li>
<li><p><code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>: Transforms short data format to long
format for discrete survival modelling in the case of competing risks with
right censoring. </p>
</li>
<li><p><code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>: Transforms short data
format to long format for discrete survival modelling of single event
analysis with right censoring. </p>
</li>
<li><p><code><a href="#topic+cIndex">cIndex</a></code>: Calculates
the concordance index for discrete survival models (independent measure of
time). </p>
</li>
<li><p><code><a href="#topic+dataLongSubDist">dataLongSubDist</a></code>: Converts
the data to long format suitable for applying discrete subdistribution
hazard modelling (competing risks). </p>
</li></ul>



<h3>Details</h3>

<p>&quot;DataShort&quot; format is defined as data without repeated measurements. 
&quot;DataSemiLong&quot; format consists of repeated measurements, but there are gaps between 
the discrete time intervals. &quot;DataLong&quot; format is expanded to include all time 
intervals up to the last observation per individual.
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> discSurv </td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;"> Version:
</td><td style="text-align: left;"> 2.0.0 </td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2022-03-02 </td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>
<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> 
</p>
<p>David Koehler <a href="mailto:koehler@imbie.uni-bonn.de">koehler@imbie.uni-bonn.de</a>
</p>
<p>Matthias Schmid <a href="mailto:matthias.schmid@imbie.uni-bonn.de">matthias.schmid@imbie.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Berger M, Schmid M (2018).
&ldquo;Semiparametric regression for discrete time-to-event data.&rdquo;
<em>Statistical Modelling</em>, <b>18</b>, 322&ndash;345. <br /><br />
Berger M, Welchowski T, Schmitz-Valckenberg S, Schmid M (2019).
&ldquo;A classification tree approach for the modeling of competing risks in discrete time.&rdquo;
<em>Advances in Data Analysis and Classification</em>, <b>13</b>, 965-990. <br /><br />
Berger M, Schmid M, Welchowski T, Schmitz-Valckenberg S, Beyersmann J (2020).
&ldquo;Subdistribution Hazard Models for Competing Risks in Discrete Time.&rdquo;
<em>Biostatistics</em>, <b>21</b>, 449-466. <br /><br />
Schmid M, Tutz G, Welchowski T (2018).
&ldquo;Discrimination Measures for Discrete Time-to-Event Predictions.&rdquo;
<em>Econometrics and Statistics</em>, <b>7</b>, 153-164. <br /><br />
Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>

<hr>
<h2 id='adjDevResid'>Adjusted Deviance Residuals in short format</h2><span id='topic+adjDevResid'></span>

<h3>Description</h3>

<p>Calculates the adjusted deviance residuals for arbitrary prediction models.
The adjusted deviance residuals should be approximately normal distributed,
in the case of a well fitting model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjDevResid(dataLong, hazards)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjDevResid_+3A_datalong">dataLong</code></td>
<td>
<p>Data set in long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="adjDevResid_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazards of the data in long format(&quot;numeric vector&quot;). Hazard
rates are probabilities and therefore restricted to the interval [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

 <ul>
<li><p>Output List with objects: </p>

<ul>
<li><p>AdjDevResid Adjusted deviance residuals as numeric vector </p>
</li></ul>

</li>
<li><p>Input A list of given argument input values (saved for reference) </p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Tutz G (2012).
<em>Regression for Categorical Data</em>.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intPredErr">intPredErr</a></code>, <code><a href="#topic+predErrCurve">predErrCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)

# Transform data to long format
heart[, "stop"] &lt;- ceiling(heart[, "stop"])
set.seed(0)
Indizes &lt;- sample(unique(heart$id), 25)
randSample &lt;- heart[unlist(sapply(1:length(Indizes), 
function(x) which(heart$id == Indizes[x]))),]
heartLong &lt;- dataLongTimeDep(dataSemiLong = randSample, 
timeColumn = "stop", eventColumn = "event", idColumn = "id", timeAsFactor = FALSE)

# Fit a generalized, additive model and predict discrete hazards on data in long format
library(mgcv)
gamFit &lt;- gam(y ~ timeInt + surgery + transplant + s(age), data = heartLong, family = "binomial")
hazPreds &lt;- predict(gamFit, type = "response")

# Calculate adjusted deviance residuals
devResiduals &lt;- adjDevResid(dataLong = heartLong, hazards = hazPreds)$Output$AdjDevResid
devResiduals

</code></pre>

<hr>
<h2 id='calibrationPlot'>Calibration Plots</h2><span id='topic+calibrationPlot'></span>

<h3>Description</h3>

<p>Calibration plot based on predictions. Overall root mean squared error (RMSE) of 
predicted and observed discrete hazards is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrationPlot(
  testPreds,
  testDataLong,
  weights = NULL,
  K = 10,
  event = "e1",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrationPlot_+3A_testpreds">testPreds</code></td>
<td>
<p>Predictions on the validation data with model fitted on training data (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="calibrationPlot_+3A_testdatalong">testDataLong</code></td>
<td>
<p>Validation data set in long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="calibrationPlot_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights (&quot;numeric vector&quot;). The length of weights must be equal to the number of observations 
of the validation data set.</p>
</td></tr>
<tr><td><code id="calibrationPlot_+3A_k">K</code></td>
<td>
<p>Number of subsets for plotting (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="calibrationPlot_+3A_event">event</code></td>
<td>
<p>Column names of the event to be considered for plotting (only in case of cause-specific hazards) (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="calibrationPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calibration plot
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Berger M, Schmid M (2018).
&ldquo;Semiparametric regression for discrete time-to-event data.&rdquo;
<em>Statistical Modelling</em>, <b>18</b>, 322&ndash;345. <br /><br /> Heyard R, Timsit J, Held L, COMBACTE-MAGNET,consortium (2019).
&ldquo;Validation of discrete time-to-event prediction models in the presence of competing risks.&rdquo;
<em>Biometrical Journal</em>, <b>62</b>, 643-657. <br /><br /> Berger M, Schmid M (2020).
&ldquo;Assessing the calibration of subdistribution hazard models in discrete time.&rdquo;
<em>arXiv:2001.11240</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estRecal">estRecal</a></code>, <code><a href="#topic+dataLong">dataLong</a></code>, <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>, <code><a href="#topic+dataLongSubDist">dataLongSubDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################
# Data preprocessing

# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
selectInd1 &lt;- 1:100
selectInd2 &lt;- 101:200
trainSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd1], ]
valSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd2], ]

####################
# One event

# Convert to long format
trainSet_long &lt;- dataLong(dataShort = trainSet, timeColumn = "spell", eventColumn = "censor1")
valSet_long &lt;- dataLong(dataShort = valSet, timeColumn = "spell", eventColumn = "censor1")

# Estimate continuation ratio model with logit link
glmFit &lt;- glm(formula = y ~ timeInt + age + logwage, data = trainSet_long, family = binomial())

# Calculate predicted hazards
predHazards &lt;- predict(glmFit, newdata = valSet_long, type = "response")

# Calibration plot
calibrationPlot(predHazards, testDataLong = valSet_long)

############################
# Two cause specific hazards 

# Convert to long format
trainSet_long &lt;- dataLongCompRisks(dataShort = trainSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"))
valSet_long &lt;- dataLongCompRisks(dataShort = valSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"))

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula = cbind(e0, e1, e2) ~ timeInt + age + logwage, data = trainSet_long, 
family = VGAM::multinomial(refLevel = "e0"))

# Calculate predicted hazards
predHazards &lt;- VGAM::predictvglm(vglmFit, newdata = valSet_long, type = "response")

# Calibration plots
calibrationPlot(predHazards, testDataLong = valSet_long)
calibrationPlot(predHazards, testDataLong = valSet_long, event = "e2")

###############################
# Subdistribution hazards model

# Convert to long format
trainSet_long &lt;- dataLongSubDist(dataShort = trainSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")
valSet_long &lt;- dataLongSubDist(dataShort = valSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")

# Estimate continuation ratio model with logit link
glmFit &lt;- glm(formula = y ~ timeInt + age + logwage, data = trainSet_long, 
family = binomial(), weights = trainSet_long$subDistWeights)

# Calculate predicted  hazards 
predHazards &lt;- predict(glmFit, newdata = valSet_long, type = "response")

# Calibration plot 
calibrationPlot(predHazards, testDataLong = valSet_long, weights = valSet_long$subDistWeights)

</code></pre>

<hr>
<h2 id='cIndex'>Concordance index</h2><span id='topic+cIndex'></span>

<h3>Description</h3>

<p>Calculates the concordance index for discrete survival models, which does not depend on time. 
This is the probability that, for a pair of randomly chosen comparable samples, the sample with the higher risk prediction will
experience an event before the other sample or belongs to a higher binary class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cIndex(marker, testTime, testEvent, trainTime, trainEvent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cIndex_+3A_marker">marker</code></td>
<td>
<p>Gives the predicted values of the linear predictor of a
regression model (&quot;numeric vector&quot;). May also be on the response scale.</p>
</td></tr>
<tr><td><code id="cIndex_+3A_testtime">testTime</code></td>
<td>
<p>New time intervals in the test data (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="cIndex_+3A_testevent">testEvent</code></td>
<td>
<p>Event indicators in the test data (&quot;binary vector&quot;).</p>
</td></tr>
<tr><td><code id="cIndex_+3A_traintime">trainTime</code></td>
<td>
<p>Time intervals in the training data (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="cIndex_+3A_trainevent">trainEvent</code></td>
<td>
<p>Event indicators in the training data (&quot;binary vector&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of discrete concordance index between zero and one (&quot;numeric
vector&quot;).
</p>


<h3>Note</h3>

<p>It is assumed that all time points up to the last observed interval
[a_q-1, a_q) are available.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Schmid M, Tutz G, Welchowski T (2018).
&ldquo;Discrimination Measures for Discrete Time-to-Event Predictions.&rdquo;
<em>Econometrics and Statistics</em>, <b>7</b>, 153-164. <br /><br />
Uno H, Cai T, Tian L, Wei LJ (2012).
&ldquo;Evaluating Prediction Rules fort-Year Survivors With Censored Regression Models.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>102</b>, 527-537. <br /><br />
Heagerty PJ, Zheng Y (2005).
&ldquo;Survival Model Predictive Accuracy and ROC Curves.&rdquo;
<em>Biometrics</em>, <b>61</b>, 92-105.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##################################################
# Example with unemployment data and prior fitting

library(Ecdat)
library(caret)
library(mgcv)
data(UnempDur)
summary(UnempDur$spell)
# Extract subset of data
set.seed(635)
IDsample &lt;- sample(1:dim(UnempDur)[1], 100)
UnempDurSubset &lt;- UnempDur [IDsample, ]
set.seed(-570)
TrainingSample &lt;- sample(1:100, 75)
UnempDurSubsetTrain &lt;- UnempDurSubset [TrainingSample, ]
UnempDurSubsetTest &lt;- UnempDurSubset [-TrainingSample, ]

# Convert to long format
UnempDurSubsetTrainLong &lt;- dataLong(dataShort = UnempDurSubsetTrain, 
timeColumn = "spell", eventColumn = "censor1")

# Estimate gam with smooth baseline
gamFit &lt;- gam(formula = y ~ s(I(as.numeric(as.character(timeInt)))) + 
s(age) + s(logwage), data = UnempDurSubsetTrainLong, family = binomial())
gamFitPreds &lt;- predict(gamFit, newdata = cbind(UnempDurSubsetTest, 
timeInt = UnempDurSubsetTest$spell))

# Evaluate C-Index based on short data format
cIndex(marker = gamFitPreds, 
testTime = UnempDurSubsetTest$spell, 
testEvent = UnempDurSubsetTest$censor1, 
trainTime = UnempDurSubsetTrain$spell, 
trainEvent = UnempDurSubsetTrain$censor1)

#####################################
# Example National Wilm's Tumor Study

library(survival)
head(nwtco)
summary(nwtco$rel)

# Select subset
set.seed(-375)
Indices &lt;- sample(1:dim(nwtco)[1], 500)
nwtcoSub &lt;- nwtco [Indices, ]

# Convert time range to 30 intervals
intLim &lt;- quantile(nwtcoSub$edrel, prob = seq(0, 1, length.out = 30))
intLim [length(intLim)] &lt;- intLim [length(intLim)] + 1
nwtcoSubTemp &lt;- contToDisc(dataShort = nwtcoSub, timeColumn = "edrel", intervalLimits = intLim)
nwtcoSubTemp$instit &lt;- factor(nwtcoSubTemp$instit)
nwtcoSubTemp$histol &lt;- factor(nwtcoSubTemp$histol)
nwtcoSubTemp$stage &lt;- factor(nwtcoSubTemp$stage)

# Split in training and test sample
set.seed(-570)
TrainingSample &lt;- sample(1:dim(nwtcoSubTemp)[1], round(dim(nwtcoSubTemp)[1]*0.75))
nwtcoSubTempTrain &lt;- nwtcoSubTemp [TrainingSample, ]
nwtcoSubTempTest &lt;- nwtcoSubTemp [-TrainingSample, ]

# Convert to long format
nwtcoSubTempTrainLong &lt;- dataLong(dataShort = nwtcoSubTempTrain, 
timeColumn = "timeDisc", eventColumn = "rel", timeAsFactor=TRUE)

# Estimate glm
inputFormula &lt;- y ~ timeInt + histol + instit + stage
glmFit &lt;- glm(formula = inputFormula, data = nwtcoSubTempTrainLong, family = binomial())
linPreds &lt;- predict(glmFit, newdata = cbind(nwtcoSubTempTest, 
timeInt = factor(nwtcoSubTempTest$timeDisc, levels=levels(nwtcoSubTempTrainLong$timeInt))))

# Evaluate C-Index based on short data format
cIndex(marker = linPreds, 
testTime = as.numeric(as.character(nwtcoSubTempTest$timeDisc)), 
testEvent = nwtcoSubTempTest$rel, 
trainTime = as.numeric(as.character(nwtcoSubTempTrain$timeDisc)), 
trainEvent = nwtcoSubTempTrain$rel) 


</code></pre>

<hr>
<h2 id='cIndexCompRisks'>Discrete concordance index for competing risks</h2><span id='topic+cIndexCompRisks'></span>

<h3>Description</h3>

<p>Estimates the discrete concordance index in the case of competing risks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cIndexCompRisks(markers, testTime, testEvents, trainTime, trainEvents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cIndexCompRisks_+3A_markers">markers</code></td>
<td>
<p>Predictions on the test data with model fitted on training data (&quot;numeric matrix&quot;).
Predictions are stored in the rows and the number of columns equal to the number of events.</p>
</td></tr>
<tr><td><code id="cIndexCompRisks_+3A_testtime">testTime</code></td>
<td>
<p>New time intervals in the test data (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="cIndexCompRisks_+3A_testevents">testEvents</code></td>
<td>
<p>New event indicators (0 or 1) in the test data (&quot;binary matrix&quot;). Number of columns are
equal to the number of events.</p>
</td></tr>
<tr><td><code id="cIndexCompRisks_+3A_traintime">trainTime</code></td>
<td>
<p>Time intervals in the training data (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="cIndexCompRisks_+3A_trainevents">trainEvents</code></td>
<td>
<p>Event indicators (0 or 1) in the training data (&quot;binary matrix&quot;). Number of columns are
equal to the number of events.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of discrete concordance index between zero and one (&quot;numeric vector&quot;).
</p>


<h3>Note</h3>

<p>It is assumed that all time points up to the last observed interval
[a_q-1, a_q) are available.
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Heyard R, Timsit J, Held L, COMBACTE-MAGNET,consortium (2019).
&ldquo;Validation of discrete time-to-event prediction models in the presence of competing risks.&rdquo;
<em>Biometrical Journal</em>, <b>62</b>, 643-657.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cIndex">cIndex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##################################################
# Example with unemployment data and prior fitting

library(Ecdat)
data(UnempDur)
summary(UnempDur$spell)
# Extract subset of data
set.seed(635)
IDsample &lt;- sample(1:dim(UnempDur)[1], 100)
UnempDurSubset &lt;- UnempDur [IDsample, ]
set.seed(-570)
TrainingSample &lt;- sample(1:100, 75)
UnempDurSubsetTrain &lt;- UnempDurSubset [TrainingSample, ]
UnempDurSubsetTest &lt;- UnempDurSubset [-TrainingSample, ]

# Convert to long format
UnempDurSubsetTrainLong &lt;- dataLongCompRisks(dataShort = UnempDurSubsetTrain, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), timeAsFactor = TRUE)

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula = cbind(e0, e1, e2) ~ timeInt + age + logwage, 
data = UnempDurSubsetTrainLong, family=VGAM::multinomial(refLevel = "e0"))

gamFitPreds &lt;- VGAM::predictvglm(vglmFit , newdata = cbind(UnempDurSubsetTest, 
timeInt = as.factor(UnempDurSubsetTest$spell)))

# Evaluate C-Index based on short data format
cIndexCompRisks(markers = gamFitPreds, 
testTime = UnempDurSubsetTest$spell, 
testEvents = UnempDurSubsetTest[, c("censor1", "censor4")], 
trainTime = UnempDurSubsetTrain$spell, 
trainEvents = UnempDurSubsetTrain[, c("censor1", "censor4")])

</code></pre>

<hr>
<h2 id='compRisksGEE'>GEE model for discrete competing risks</h2><span id='topic+compRisksGEE'></span><span id='topic+predict.dCRGEE'></span>

<h3>Description</h3>

<p>Estimates generalized estimation equation model for each competing event separately. 
Dependence within person IDs is accounted for by assuming a working covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compRisksGEE(
  datShort,
  dataTransform = "dataLongCompRisks",
  corstr = "independence",
  formulaVariable = ~timeInt,
  ...
)

## S3 method for class 'dCRGEE'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compRisksGEE_+3A_datshort">datShort</code></td>
<td>
<p>Original data set in short format with each row corresponding to one independent 
observation(&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="compRisksGEE_+3A_datatransform">dataTransform</code></td>
<td>
<p>Specification of the data transformation function from short to long format(&quot;character vector&quot;). 
There are two available options: Without time dependent covariates (&quot;dataLongCompRisks&quot;) and with 
time dependent covariates (&quot;dataLongCompRisksTimeDep&quot;). The default is set to the former.</p>
</td></tr>
<tr><td><code id="compRisksGEE_+3A_corstr">corstr</code></td>
<td>
<p>Assumption of correlation structure (&quot;character vector&quot;). The following are 
permitted: '&quot;independence&quot;', '&quot;exchangeable&quot;', '&quot;ar1&quot;', '&quot;unstructured&quot;' and '&quot;userdefined&quot;.</p>
</td></tr>
<tr><td><code id="compRisksGEE_+3A_formulavariable">formulaVariable</code></td>
<td>
<p>Specifies the right hand side of the regression formula (&quot;class formula&quot;).
The default is to use the discrete time variable, which corresponds to a covariate free hazard. 
It is recommended to always include the discrete time variable &quot;timeInt&quot;.</p>
</td></tr>
<tr><td><code id="compRisksGEE_+3A_...">...</code></td>
<td>
<p>Additional arguments to data transformation (compRisksGEE) or prediction function (predict).
Preprocessing function argument responseAsFactor has to be set to FALSE (Default).</p>
</td></tr>
<tr><td><code id="compRisksGEE_+3A_object">object</code></td>
<td>
<p>Discrete time competing risks GEE model prediction model (&quot;class dCRGEE&quot;).</p>
</td></tr>
<tr><td><code id="compRisksGEE_+3A_newdata">newdata</code></td>
<td>
<p>(&quot;class data.set&quot;) New data set to be used for prediction (class data.frame).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables in argument <em>formulaVariable</em> need to be separated by &quot;+ &quot;. 
For example if the two variables <em>timeInt</em> and <em>X1</em> should be included the formula would be
&quot;~ timeInt + X1&quot;. The variable <em>timeInt</em> is constructed before estimation of the model.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;geeglm&quot;.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Lee M, Feuer EJ, Fine JP (2018).
&ldquo;On the analysis of discrete time competing risks data.&rdquo;
<em>Biometrics</em>, <b>74</b>, 1468-1481.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covarGEE">covarGEE</a></code>, <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>, <code><a href="#topic+dataLongCompRisksTimeDep">dataLongCompRisksTimeDep</a></code>, 
<code><a href="geepack.html#topic+geeglm">geeglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
SubUnempDur &lt;- UnempDur [1:100, ]

# Estimate GEE models for all events
estGEE &lt;- compRisksGEE(datShort = SubUnempDur, dataTransform = "dataLongCompRisks", 
corstr = "independence", formulaVariable =~ timeInt + age + ui + logwage * ui, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell")
names(estGEE)
estGEE[[1]]

# Predictions
SubUnempDurLong &lt;- dataLongCompRisks(dataShort = SubUnempDur, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell")
preds &lt;- predict(estGEE, newdata = SubUnempDurLong)
head(preds)

</code></pre>

<hr>
<h2 id='contToDisc'>Continuous to Discrete Transformation</h2><span id='topic+contToDisc'></span>

<h3>Description</h3>

<p>Discretizes continuous time variable into a specified grid of censored data
for discrete survival analysis. It is a data preprocessing step, before the
data can be extendend in long format and further analysed with discrete
survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contToDisc(
  dataShort,
  timeColumn,
  intervalLimits,
  equi = FALSE,
  timeAsFactor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contToDisc_+3A_datashort">dataShort</code></td>
<td>
<p>Original data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="contToDisc_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Name of the column of discrete survival times (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="contToDisc_+3A_intervallimits">intervalLimits</code></td>
<td>
<p>Right interval borders (&quot;numeric vector&quot;), e. g. if
the intervals are [0, a_1), [a_1, a_2), [a_2, a_max), then intervalLimits =
c(a_1, a_2, a_max)</p>
</td></tr>
<tr><td><code id="contToDisc_+3A_equi">equi</code></td>
<td>
<p>Specifies if argument <em>intervalLimits</em> should be interpreted as
number of equidistant intervals (&quot;logical vector&quot;).</p>
</td></tr>
<tr><td><code id="contToDisc_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Specifies if the computed discrete time intervals should be 
converted to a categorical variable (&quot;logical vector&quot;). Default is FALSE. 
In the default settings the discret time intervals are treated 
as quantitative (&quot;numeric vector&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gives the data set expanded with a first column &quot;timeDisc&quot;. This
column includes the discrete time intervals (&quot;class factor&quot;).
</p>


<h3>Note</h3>

<p>In discrete survival analysis the survival times have to be
categorized in time intervals. Therefore this function is required, if there
are observed continuous survival times.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataLong">dataLong</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>,
<code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example copenhagen stroke study data
library(pec)
data(cost)
head(cost)

# Convert observed times to months
# Right borders of intervals [0, a_1), [a_1, a_2), ... , [a_{\max-1}, a_{\max})
IntBorders &lt;- 1:ceiling(max(cost$time)/30)*30

# Select subsample
subCost &lt;- cost [1:100, ]
CostMonths &lt;- contToDisc(dataShort=subCost, timeColumn = "time", intervalLimits = IntBorders)
head(CostMonths)

# Select subsample giving number of equidistant intervals
CostMonths &lt;- contToDisc(dataShort = subCost, timeColumn = "time", intervalLimits = 10, equi = TRUE)
head(CostMonths)

</code></pre>

<hr>
<h2 id='covarGEE'>GEE covariance of all events for discrete competing risks</h2><span id='topic+covarGEE'></span>

<h3>Description</h3>

<p>Estimates covariance of estimated parameters of all competing events generalized estimation equation models using sandwich approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covarGEE(modelEst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covarGEE_+3A_modelest">modelEst</code></td>
<td>
<p>Discrete time competing risks GEE model prediction model (&quot;class dCRGEE&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns symmetric matrix of rows and columns dimension &quot;number of competing risks&quot; * &quot;number of regression parameters&quot; (&quot;numeric matrix&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Lee M, Feuer EJ, Fine JP (2018).
&ldquo;On the analysis of discrete time competing risks data.&rdquo;
<em>Biometrics</em>, <b>74</b>, 1468-1481.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compRisksGEE">compRisksGEE</a></code>, <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>, <code><a href="#topic+dataLongCompRisksTimeDep">dataLongCompRisksTimeDep</a></code>, 
<code><a href="geepack.html#topic+geeglm">geeglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
SubUnempDur &lt;- UnempDur [1:100, ]

# Estimate GEE models for all events
estGEE &lt;- compRisksGEE(datShort = SubUnempDur, dataTransform = "dataLongCompRisks", 
corstr = "independence", formulaVariable =~ timeInt + age + ui + logwage * ui, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell")

## Not run: 
# Estimate covariance matrix of estimated parameters and competing events
estCovar &lt;- covarGEE(modelEst=estGEE)
estCovar

# Covariances of estimated parameters of one event equal the diagonal blocks
lengthParameters &lt;- length(estGEE[[1]]$coefficients)
noCompEvents &lt;- length(estGEE)
meanAbsError &lt;- rep(NA, noCompEvents)
for( k in 1:noCompEvents ){
  
  relInd &lt;- (1 + (k-1) * lengthParameters) : (k * lengthParameters)
  meanAbsError[k] &lt;- mean(abs(estCovar[relInd, relInd] - estGEE[[k]]$geese$vbeta))
  
}
mean(meanAbsError) 
# -&gt; Covariance estimates within each event are equal to diagonal blocks in 
# complete covariance matrix with very small differences due to numerical accuracy.

## End(Not run)

</code></pre>

<hr>
<h2 id='crash2'>Crash 2 competing risk data</h2><span id='topic+crash2'></span>

<h3>Description</h3>

<p>Adapted version of the crash2 trial data as availlable in the package Hmisc. Both death or survival and main cause of death are included. 
Death times are discretized into days. Included covariates are sex and age of patient, elapsed time between injury and 
hospitalization, type of injury, systolic blood pressure, heart rate, respiratory rate, central capillary 
refill time and total glascow coma score.
#' </p>

<ul>
<li><p> Column &quot;time&quot; is time until death or hospital discharge/transfer in weeks.
</p>
</li></ul>


<ul>
<li><p> Column &quot;Status&quot; denotes type of death</p>

<ul>
<li><p> bleeding
</p>
</li>
<li><p> head injury
</p>
</li>
<li><p> vascular occlusion 
</p>
</li>
<li><p> multi organ failure
</p>
</li>
<li><p> other
</p>
</li>
<li><p> NA if patient is not dead (see &quot;statusSE&quot;)
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;statusSE&quot; denotes death or discharge/transfer from hospital</p>

<ul>
<li><p> 0 - Transfer/Discharge
</p>
</li>
<li><p> 1 - Death
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;sex&quot; denotes sex of the patient.
</p>
</li></ul>


<ul>
<li><p> Column &quot;age&quot; denotes age of the patient in years.
</p>
</li></ul>


<ul>
<li><p> Column &quot;injurytime&quot; gives time in hours between injury and hospitalization.
</p>
</li></ul>


<ul>
<li><p> Column &quot;injurytype&quot; denotes type of injury, one in </p>

<ul>
<li><p> blunt
</p>
</li>
<li><p> penetrating
</p>
</li>
<li><p> blunt and penetrating
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;sbp&quot; denotes systolic blood pressure in mmHg.
</p>
</li></ul>


<ul>
<li><p> Column &quot;rr&quot; denotes respiratory rate per minute.
</p>
</li></ul>


<ul>
<li><p> Column &quot;cc&quot; denotes central capillary refill time in seconds.
</p>
</li></ul>


<ul>
<li><p> Column &quot;hr&quot; denotes heart rate per minute.
</p>
</li></ul>


<ul>
<li><p> Column &quot;gcs&quot; denotes total Glascow Coma Score.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(crash2)
</code></pre>


<h3>Author(s)</h3>

<p>David Koehler <a href="mailto:koehler@imbie.uni-bonn.de">koehler@imbie.uni-bonn.de</a>
</p>


<h3>Source</h3>

<p><a href="Hmisc.html#topic+getHdata">getHdata</a>
</p>

<hr>
<h2 id='dataCensoring'>Data Censoring Transformation for short formats</h2><span id='topic+dataCensoring'></span>

<h3>Description</h3>

<p>Function for transformation of discrete survival times in censoring
encoding. The original data is expanded to include the censoring process. 
Alternatively the long data format can also be augmented. With the new 
generated variable &quot;yCens&quot;, the discrete censoring process can be analyzed 
instead of the discrete survival process. In discrete survival analysis this 
information is used to constructs weights for predictive evaluation measures. 
It is applicable in single event survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataCensoring(dataShort, eventColumns, timeColumn, shortFormat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataCensoring_+3A_datashort">dataShort</code></td>
<td>
<p>Original data set in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataCensoring_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Name of event columns (&quot;character vector&quot;). The
event columns have to be in binary format. If the sum of all events equals
zero in a row, then this observation is interpreted as censored.</p>
</td></tr>
<tr><td><code id="dataCensoring_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Name of column with discrete time intervals (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="dataCensoring_+3A_shortformat">shortFormat</code></td>
<td>
<p>Is the supplied data set <em>dataShort</em> not preprocessed 
with function dataLong() (&quot;logical vector&quot;)? Default is TRUE. If shortFormat=FALSE 
then it is assumed that the data set was augmented with function dataLong().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original data set as argument <em>dataShort</em>, but with added censoring
process as first variable in column &quot;yCens&quot;.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Fahrmeir L (2005).
&ldquo;Discrete Survival-Time Models.&rdquo;
In <em>Encyclopedia of Biostatistics</em>, chapter Survival Analysis.
John Wiley \&amp; Sons. <br /><br />
Thompson Jr. WA (1977).
&ldquo;On the Treatment of Grouped Observations in Life Studies.&rdquo;
<em>Biometrics</em>, <b>33</b>, 463-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contToDisc">contToDisc</a></code>,
<code><a href="#topic+dataLong">dataLong</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>,
<code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pec)
data(cost)
head(cost)
IntBorders &lt;- 1:ceiling(max(cost$time)/30)*30
subCost &lt;- cost [1:100, ]

# Convert from days to months
CostMonths &lt;- contToDisc(dataShort=subCost, timeColumn="time", intervalLimits=IntBorders)
head(CostMonths)

# Generate censoring process variable in short format
CostMonthsCensorShort &lt;- dataCensoring (dataShort = CostMonths, 
eventColumns = "status", timeColumn = "time", shortFormat = TRUE)
head(CostMonthsCensorShort)

################################
# Example with long data format
library(pec)
data(cost)
head(cost)
IntBorders &lt;- 1:ceiling(max(cost$time)/30)*30
subCost &lt;- cost [1:100, ]

# Convert from days to months
CostMonths &lt;- contToDisc(dataShort = subCost, timeColumn = "time", intervalLimits = IntBorders)
head(CostMonths)

# Convert to long format based on months
CostMonthsLong &lt;- dataLong(dataShort = CostMonths, timeColumn = "timeDisc", eventColumn = "status")
head(CostMonthsLong, 20)

# Generate censoring process variable
CostMonthsCensor &lt;- dataCensoring (dataShort = CostMonthsLong, timeColumn = "timeInt", 
shortFormat = FALSE)
head(CostMonthsCensor)
tail(CostMonthsCensor [CostMonthsCensor$obj==1, ], 10)
tail(CostMonthsCensor [CostMonthsCensor$obj==3, ], 10)

</code></pre>

<hr>
<h2 id='dataLong'>Data Long Transformation</h2><span id='topic+dataLong'></span>

<h3>Description</h3>

<p>Transform data from short format into long format for discrete survival
analysis and right censoring. Data is assumed to include no time varying
covariates, e. g. no follow up visits are allowed. It is assumed that the
covariates stay constant over time, in which no information is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLong(
  dataShort,
  timeColumn,
  eventColumn,
  timeAsFactor = FALSE,
  remLastInt = FALSE,
  aggTimeFormat = FALSE,
  lastTheoInt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataLong_+3A_datashort">dataShort</code></td>
<td>
<p>Original data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataLong_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times. It
is required that the observed times are discrete (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLong_+3A_eventcolumn">eventColumn</code></td>
<td>
<p>Column name of the event indicator (&quot;character vector&quot;).
It is required that this is a binary variable with 1==&quot;event&quot; and
0==&quot;censored&quot;.</p>
</td></tr>
<tr><td><code id="dataLong_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Should the time intervals be coded as factor (&quot;logical vector&quot;)? 
Default is FALSE. In the default settings the column is treated as quantitative variable (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLong_+3A_remlastint">remLastInt</code></td>
<td>
<p>Should the last theoretical interval be removed in long
format (&quot;logical vector&quot;)? Default setting (FALSE) is no deletion. This is only important, if the short format
data includes the last theoretic interval [a_q, Inf). There are only events
in the last theoretic interval, so the discrete hazard is always one and these
observations have to be excluded for estimation.</p>
</td></tr>
<tr><td><code id="dataLong_+3A_aggtimeformat">aggTimeFormat</code></td>
<td>
<p>Instead of the usual long format, should every
observation have all time intervals (&quot;logical vector&quot;)? Default is standard
long format (FALSE). In the case of nonlinear risk score models, the time effect has
to be integrated out before these can be applied to the C-index.</p>
</td></tr>
<tr><td><code id="dataLong_+3A_lasttheoint">lastTheoInt</code></td>
<td>
<p>Gives the number of the last theoretic interval (&quot;integer vector&quot;). 
Only used, if argument <em>aggTimeFormat</em> is set to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data has continuous survival times, the response may be transformed
to discrete intervals using function <code><a href="#topic+contToDisc">contToDisc</a></code>. If the data
set has time varying covariates the function <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>
should be used instead. In the case of competing risks and no time varying
covariates see function <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>.
</p>


<h3>Value</h3>

<p>Original data.frame with three additional columns: </p>
 <ul>
<li>
<p>obj Index of persons as integer vector </p>
</li>
<li> <p>timeInt Index of time
intervals (factor) </p>
</li>
<li> <p>y Response in long format as binary vector.
1==&quot;event happens in period timeInt&quot; and zero otherwise. 
If argument <em>responseAsFactor</em> is set to TRUE, then responses will be coded as factor 
in one column.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>
<p>Matthias Schmid <a href="mailto:matthias.schmid@imbie.uni-bonn.de">matthias.schmid@imbie.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Fahrmeir L (2005).
&ldquo;Discrete Survival-Time Models.&rdquo;
In <em>Encyclopedia of Biostatistics</em>, chapter Survival Analysis.
John Wiley \&amp; Sons. <br /><br />
Thompson Jr. WA (1977).
&ldquo;On the Treatment of Grouped Observations in Life Studies.&rdquo;
<em>Biometrics</em>, <b>33</b>, 463-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contToDisc">contToDisc</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>,
<code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]
head(subUnempDur)

# Convert to long format
UnempLong &lt;- dataLong (dataShort = subUnempDur, timeColumn = "spell", eventColumn = "censor1")
head(UnempLong, 20)

# Is there exactly one observed event of y for each person?
splitUnempLong &lt;- split(UnempLong, UnempLong$obj)
all(sapply(splitUnempLong, function (x) sum(x$y))==subUnempDur$censor1) # TRUE

# Second example: Acute Myelogenous Leukemia survival data
library(survival)
head(leukemia)
leukLong &lt;- dataLong(dataShort = leukemia, timeColumn = "time", 
eventColumn = "status", timeAsFactor=TRUE)
head(leukLong, 30)

# Estimate discrete survival model
estGlm &lt;- glm(formula = y ~ timeInt + x, data=leukLong, family = binomial())
summary(estGlm)

# Estimate survival curves for non-maintained chemotherapy
newDataNonMaintained &lt;- data.frame(timeInt = factor(1:161), x = rep("Nonmaintained"))
predHazNonMain &lt;- predict(estGlm, newdata = newDataNonMaintained, type = "response")
predSurvNonMain &lt;- cumprod(1-predHazNonMain)

# Estimate survival curves for maintained chemotherapy
newDataMaintained &lt;- data.frame(timeInt = factor(1:161), x = rep("Maintained"))
predHazMain &lt;- predict(estGlm, newdata = newDataMaintained, type = "response")
predSurvMain &lt;- cumprod(1-predHazMain)

# Compare survival curves
plot(x = 1:50, y = predSurvMain [1:50], xlab = "Time", ylab = "S(t)", las = 1, 
type = "l", main = "Effect of maintained chemotherapy on survival of leukemia patients")
lines(x = 1:161, y = predSurvNonMain, col = "red")
legend("topright", legend = c("Maintained chemotherapy", "Non-maintained chemotherapy"), 
col = c("black", "red"), lty = rep(1, 2))
# The maintained therapy has clearly a positive effect on survival over the time range

##############################################
# Simulation
# Single event in case of right-censoring

# Simulate multivariate normal distribution
library(discSurv)
library(mvnfast)
set.seed(-1980)
X &lt;- mvnfast::rmvn(n = 1000, mu = rep(0, 10), sigma = diag(10))


# Specification of discrete hazards with 11 theoretical intervals
betaCoef &lt;- seq(-1, 1, length.out = 11)[-6]
timeInt &lt;- seq(-1, 1, length.out = 10)
linPred &lt;- c(X %*% betaCoef)
hazTimeX &lt;- cbind(sapply(1:length(timeInt), 
                        function(x) exp(linPred+timeInt[x]) / (1+exp(linPred+timeInt[x])) ), 1)


# Simulate discrete survival and censoring times in 10 observed intervals
discT &lt;- rep(NA, dim(hazTimeX)[1])
discC &lt;- rep(NA, dim(hazTimeX)[1])
for( i in 1:dim(hazTimeX)[1] ){
 
 discT[i] &lt;- sample(1:11, size = 1, prob = estMargProb(haz=hazTimeX[i, ]))
 discC[i] &lt;- sample(1:11, size = 1, prob = c(rep(1/11, 11)))
}


# Calculate observed times, event indicator and specify short data format
eventInd &lt;- discT &lt;= discC
obsT &lt;- ifelse(eventInd, discT, discC)
eventInd[obsT == 11] &lt;- 0
obsT[obsT == 11] &lt;- 10
simDatShort &lt;- data.frame(obsT = obsT, event = as.numeric(eventInd), X)


# Convert data to discrete data long format
simDatLong &lt;- dataLong(dataShort = simDatShort, timeColumn = "obsT", eventColumn = "event",
timeAsFactor=TRUE)


# Estimate discrete-time continuation ratio model
formSpec &lt;- as.formula(paste("y ~ timeInt + ", 
                            paste(paste("X", 1:10, sep=""), collapse = " + "), sep = ""))
modelFit &lt;- glm(formula = formSpec, data = simDatLong, family = binomial(link = "logit"))
summary(modelFit)


# Compare estimated to true coefficients
coefModel &lt;- coef(modelFit)
MSE_covariates &lt;- mean((coefModel[11:20]-timeInt)^2)
MSE_covariates
# -&gt; Estimated coefficients are near true coefficients

</code></pre>

<hr>
<h2 id='dataLongCompRisks'>Data Long Competing Risks Transformation</h2><span id='topic+dataLongCompRisks'></span>

<h3>Description</h3>

<p>Transforms short data format to long format for discrete survival modelling
in the case of competing risks with right censoring. It is assumed that the
covariates are not time varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLongCompRisks(
  dataShort,
  timeColumn,
  eventColumns,
  eventColumnsAsFactor = FALSE,
  timeAsFactor = FALSE,
  aggTimeFormat = FALSE,
  lastTheoInt = NULL,
  responseAsFactor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataLongCompRisks_+3A_datashort">dataShort</code></td>
<td>
<p>Original data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times (&quot;character vector&quot;). It
is required that the observed times are discrete (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector giving the column names of the event
indicators (excluding censoring column)(&quot;character vector&quot;). It is required that all events are
binary encoded. If the sum of all event indicators is zero, then this is
interpreted as a censored observation. Alternatively a column name of a
factor representing competing events can be given. In this case the argument
<em>eventColumnsAsFactor</em> has to be set TRUE and the first level is assumed to
represent censoring.</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_eventcolumnsasfactor">eventColumnsAsFactor</code></td>
<td>
<p>Should the argument <em>eventColumns</em> be interpreted
as column name of a factor variable (&quot;logical vector&quot;)? Default is FALSE.</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Should the time intervals be coded as factor (&quot;logical vector&quot;)? 
Default is FALSE. In the default settings the discrete time variable are treated as quantitative.</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_aggtimeformat">aggTimeFormat</code></td>
<td>
<p>Instead of the usual long format, should every
observation have all time intervals (&quot;logical vector&quot;)? Default is standard
long format. In the case of nonlinear risk score models, the time effect has
to be integrated out before these can be applied to the C-index.</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_lasttheoint">lastTheoInt</code></td>
<td>
<p>Gives the number of the last theoretic interval (&quot;integer
vector&quot;). Only used, if <em>aggTimeFormat</em> is set to TRUE.</p>
</td></tr>
<tr><td><code id="dataLongCompRisks_+3A_responseasfactor">responseAsFactor</code></td>
<td>
<p>Should the response columns be given as factor (&quot;logical vector&quot;)? 
Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed, that only one event happens at a specific time point
(competing risks). Either the observation is censored or one of the possible
events takes place.
</p>
<p>In contrast to continuous survival (see e. g. <code><a href="survival.html#topic+Surv">Surv</a></code>) 
the start and stop time notation is not used here. In discrete time survival analysis the only relevant
information is to use the stop time. Start time does not matter, because all discrete intervals need to be  
included in the long data set format to ensure consistent estimation. It is assumed that the supplied 
data set <em>dataShort</em> contains all repeated measurements of each cluster (e. g. persons). 
For further information see example <em>Start-stop notation</em>.
</p>


<h3>Value</h3>

<p>Original data set in long format with additional columns </p>

<ul>
<li> <p>obj Gives identification number of objects (row index in short
format) (integer) </p>
</li>
<li> <p>timeInt Gives number of discrete time intervals
(factor) </p>
</li>
<li> <p>responses Columns with dimension count of events + 1
(censoring) </p>
 <ul>
<li> <p>e0 No event (observation censored in specific
interval) </p>
</li>
<li> <p>e1 Indicator of first event, 1 if event takes place and 0
otherwise </p>
</li>
<li><p> ... ...  </p>
</li>
<li> <p>ek Indicator of last k-th event, 1 if event
takes place and zero otherwise</p>
</li></ul>

<p>If argument responseAsFactor=TRUE, then responses will be coded as factor in one column.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Steele F, Goldstein H, Browne W (2004).
&ldquo;A general multilevel multistate competing risks model for event history data, with an application to a study of contraceptive use dynamics.&rdquo;
<em>Statistical Modelling</em>, <b>4</b>, 145-159. <br /><br />
Narendranathan W, Stewart MB (1993).
&ldquo;Modelling the Probability of Leaving Unemployment: Competing Risks Models with Flexible Base-Line Hazards.&rdquo;
<em>Journal of the Royal Statistical Society Series C</em>, <b>42</b>, 63-83.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contToDisc">contToDisc</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>,
<code><a href="#topic+dataLongCompRisksTimeDep">dataLongCompRisksTimeDep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
SubUnempDur &lt;- UnempDur [1:100, ]

# Convert competing risk data to long format
SubUnempDurLong &lt;- dataLongCompRisks (dataShort = SubUnempDur, timeColumn = "spell", 
eventColumns = c("censor1", "censor2", "censor3", "censor4"))
head(SubUnempDurLong, 20)

# Fit multinomial logit model with VGAM package
# with one coefficient per response
library(VGAM)
multLogitVGM &lt;- vgam(cbind(e0, e1, e2, e3, e4) ~ timeInt + ui + age + logwage,
                    family = multinomial(refLevel = 1), 
                    data = SubUnempDurLong)
coef(multLogitVGM)

# Alternative: Use nnet
# Convert response to factor
rawResponseMat &lt;- SubUnempDurLong[, c("e0", "e1", "e2", "e3", "e4")]
NewFactor &lt;- factor(unname(apply(rawResponseMat, 1, function(x) which(x == 1))), 
                    labels = colnames(rawResponseMat))

# Include recoded response in data
SubUnempDurLong &lt;- cbind(SubUnempDurLong, NewResp = NewFactor)

# Construct formula of mlogit model
mlogitFormula &lt;- formula(NewResp ~ timeInt + ui + age + logwage)

# Fit multinomial logit model
# with one coefficient per response
library(nnet)
multLogitNNET &lt;- multinom(formula = mlogitFormula, data = SubUnempDurLong)
coef(multLogitNNET)

###########################################################
# Simulation
# Cause specific competing risks in case of right-censoring
# Discrete subdistribution hazards model

# Simulate covariates as multivariate normal distribution
library(mvnfast)
set.seed(1980)
X &lt;- mvnfast::rmvn(n = 1000, mu = rep(0, 4), sigma = diag(4))

# Specification of two discrete cause specific hazards with four intervals
# Event 1
theoInterval &lt;- 4
betaCoef_event1 &lt;- seq(-1, 1, length.out = 5)[-3]
timeInt_event1 &lt;- seq(0.1, -0.1, length.out = theoInterval-1)
linPred_event1 &lt;- c(X %*% betaCoef_event1)
# Event 2
betaCoef_event2 &lt;- seq(-0.5, 0.5, length.out = 5)[-3]
timeInt_event2 &lt;- seq(-0.1, 0.1, length.out = theoInterval-1)
linPred_event2 &lt;- c(X %*% betaCoef_event2)
# Discrete cause specific hazards in last theoretical interval
theoHaz_event1 &lt;- 0.5
theoHaz_event2 &lt;- 0.5

haz_event1_X &lt;- cbind(sapply(1:length(timeInt_event1), 
               function(x) exp(linPred_event1 + timeInt_event1[x]) / 
               (1 + exp(linPred_event1 + timeInt_event1[x]) + 
               exp(linPred_event2 + timeInt_event2[x])) ), theoHaz_event1)

haz_event2_X &lt;- cbind(sapply(1:length(timeInt_event2), 
               function(x) exp(linPred_event2 + timeInt_event2[x]) / 
               (1 + exp(linPred_event1 + timeInt_event1[x]) + 
               exp(linPred_event2 + timeInt_event2[x]) ) ), theoHaz_event2)
allCauseHaz_X &lt;- haz_event1_X + haz_event2_X


pT_X &lt;- t(sapply(1:dim(allCauseHaz_X)[1], function(i) estMargProb(allCauseHaz_X[i, ]) ))


pR_T_X_event1 &lt;- haz_event1_X / (haz_event1_X + haz_event2_X)


survT &lt;- sapply(1:dim(pT_X)[1], function(i) sample(x = 1:(length(timeInt_event1) + 1), 
                                                  size = 1, prob = pT_X[i, ]) )
censT &lt;- sample(x = 1:(length(timeInt_event1)+1), size = dim(pT_X)[1], 
               prob = rep(1/(length(timeInt_event1) + 1), (length(timeInt_event1) + 1)), 
               replace = TRUE)


obsT &lt;- ifelse(survT &lt;= censT, survT, censT)
obsEvent &lt;- rep(0, length(obsT))
obsEvent &lt;- sapply(1:length(obsT), 
                  function(i) if(survT[i] &lt;= censT[i]){
                    return(sample(x = c(1, 2), size=1, 
                    prob = c(pR_T_X_event1[i, obsT[i]  ], 
                    1 - pR_T_X_event1[i, obsT[i]  ]) ))
                  } else{
                    
                    return(0)
                  }
)


# Recode last interval to censored
lastInterval &lt;- obsT == theoInterval
obsT[lastInterval] &lt;- theoInterval - 1
obsEvent[lastInterval] &lt;- 0
obsT &lt;- factor(obsT)
obsEvent &lt;- factor(obsEvent)

datShort &lt;- data.frame(event = factor(obsEvent), time = obsT, X)
datLong &lt;- dataLongCompRisks(dataShort = datShort, timeColumn = "time", 
                            eventColumns = "event", responseAsFactor = TRUE, 
                            eventColumnsAsFactor = TRUE, timeAsFactor = TRUE)


# Estimate discrete cause specific hazard model
library(VGAM)
estModel &lt;- vglm(formula=responses ~ timeInt + X1 + X2 + X3 + X4, data=datLong, 
                family = multinomial(refLevel = 1))


# Mean squared errors per event
coefModels &lt;- coef(estModel)
mean((coefModels[seq(7, length(coefModels), 2)] - betaCoef_event1)^2) # Event 1
mean((coefModels[seq(8, length(coefModels), 2)] - betaCoef_event2)^2) # Event 2
# -&gt; Estimated coefficients are near true coefficients for each event type

</code></pre>

<hr>
<h2 id='dataLongCompRisksTimeDep'>Data Long Competing Risks Time Dependent Covariates Transformation</h2><span id='topic+dataLongCompRisksTimeDep'></span>

<h3>Description</h3>

<p>Transforms short data format to long format for discrete survival modelling
in the case of competing risks with right censoring. Covariates may vary
over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLongCompRisksTimeDep(
  dataSemiLong,
  timeColumn,
  eventColumns,
  eventColumnsAsFactor = FALSE,
  idColumn,
  timeAsFactor = FALSE,
  responseAsFactor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataLongCompRisksTimeDep_+3A_datasemilong">dataSemiLong</code></td>
<td>
<p>Original data in semi-long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataLongCompRisksTimeDep_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times(&quot;logical vector&quot;). It
is required that the observed times are discrete (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongCompRisksTimeDep_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector giving the column names of the event
indicators (excluding censoring column)(&quot;character vector&quot;). It is required that all events are
binary encoded. If the sum of all event indicators is zero, then this is
interpreted as a censored observation. Alternatively a column name of a
factor representing competing events can be given. In this case the argument
<em>eventColumnsAsFactor</em> has to be set TRUE and the first level is assumed to
represent censoring.</p>
</td></tr>
<tr><td><code id="dataLongCompRisksTimeDep_+3A_eventcolumnsasfactor">eventColumnsAsFactor</code></td>
<td>
<p>Should the argument eventColumns be intepreted
as column name of a factor variable (&quot;logical vector&quot;)? Default is FALSE.</p>
</td></tr>
<tr><td><code id="dataLongCompRisksTimeDep_+3A_idcolumn">idColumn</code></td>
<td>
<p>Name of column of identification number of persons as
character(&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongCompRisksTimeDep_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Should the time intervals be coded as factor (&quot;logical vector&quot;)? Default is
FALSE. In the default settings the discrete time intervals 
are treated as quantitative (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongCompRisksTimeDep_+3A_responseasfactor">responseAsFactor</code></td>
<td>
<p>Should the response columns be given as factor (&quot;logical vector&quot;)? 
Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There may be some intervals, where no additional information on the
covariates is observed (e. g. observed values in interval one and three but
two is missing). In this case it is assumed, that the values from the last
observation stay constant over time until a new measurement was done.
</p>
<p>In contrast to continuous survival (see e. g. <code><a href="survival.html#topic+Surv">Surv</a></code>) 
the start and stop time notation is not used here. In discrete time survival analysis the only relevant
information is to use the stop time. Start time does not matter, because all discrete intervals need to be  
included in the long data set format to ensure consistent estimation. It is assumed that the supplied 
data set <em>dataSemiLong</em> contains all repeated measurements of each cluster in semi-long format (e. g. persons). 
For further information see example <em>Start-stop notation</em>.
</p>


<h3>Value</h3>

<p>Original data set in long format with additional columns </p>

<ul>
<li> <p>obj Gives identification number of objects (row index in short
format) (integer) </p>
</li>
<li> <p>timeInt Gives number of discrete time intervals
(factor) </p>
</li>
<li> <p>responses Columns with dimension count of events + 1
(censoring) </p>
 <ul>
<li> <p>e0 No event (observation censored in specific
interval) </p>
</li>
<li> <p>e1 Indicator of first event, 1 if event takes place and 0
otherwise </p>
</li>
<li><p> ... ...  </p>
</li>
<li> <p>ek Indicator of last k-th event, 1 if event
takes place and 0 otherwise</p>
</li></ul>

<p>If argument responseAsFactor=TRUE, then responses will be coded as factor in one column.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Fahrmeir L (2005).
&ldquo;Discrete Survival-Time Models.&rdquo;
In <em>Encyclopedia of Biostatistics</em>, chapter Survival Analysis.
John Wiley \&amp; Sons. <br /><br />
Thompson Jr. WA (1977).
&ldquo;On the Treatment of Grouped Observations in Life Studies.&rdquo;
<em>Biometrics</em>, <b>33</b>, 463-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contToDisc">contToDisc</a></code>, <code><a href="#topic+dataLong">dataLong</a></code>,
<code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example Primary Biliary Cirrhosis data
library(survival)
pbcseq_example &lt;- pbcseq

# Convert to months
pbcseq_example$day &lt;- ceiling(pbcseq_example$day/30) + 1
names(pbcseq_example)[7] &lt;- "month"
pbcseq_example$status &lt;- factor(pbcseq_example$status)

# Convert to long format for time varying effects
pbcseq_exampleLong &lt;- dataLongCompRisksTimeDep(dataSemiLong = pbcseq_example, timeColumn = "month", 
eventColumns = "status", eventColumnsAsFactor = TRUE, idColumn = "id", 
timeAsFactor = TRUE)
head(pbcseq_exampleLong)

#####################
# Start-stop notation

library(survival)
?pbcseq

# Choose subset of patients
subsetID &lt;- unique(pbcseq$id)[1:100]
pbcseq_mod &lt;- pbcseq[pbcseq$id %in% subsetID, ]

# Convert to start stop notation
pbcseq_mod_split &lt;- split(pbcseq_mod, pbcseq_mod$id)
pbcseq_mod_split &lt;- lapply(1:length(pbcseq_mod_split), function(x) {

 cbind(pbcseq_mod_split[[x]], 
 start_time=c(0, pbcseq_mod_split[[x]][ - dim(pbcseq_mod_split[[x]])[1], "day"]),
 stop_time=pbcseq_mod_split[[x]][, "day"])
 
})
pbcseq_mod &lt;- do.call(rbind, pbcseq_mod_split)

# Convert stop time to months
intervalDef &lt;- c(quantile(pbcseq_mod$stop_time, probs = seq(0.1, 0.9, by=0.1)), Inf)
names(pbcseq_mod)
pbcseq_mod &lt;- contToDisc(dataShort = pbcseq_mod, timeColumn = "stop_time", 
                         intervalLimits = intervalDef, equi = FALSE)
pbcseq_mod$status &lt;- factor(pbcseq_mod$status)

# Conversion to data long format
pbcseq_mod_long &lt;- dataLongCompRisksTimeDep(dataSemiLong = pbcseq_mod, timeColumn = "timeDisc", 
                                           eventColumns = "status",
                                          idColumn = "id", 
                                           eventColumnsAsFactor = TRUE, 
                                          responseAsFactor = TRUE,
                                          timeAsFactor = TRUE)
head(pbcseq_mod_long)

</code></pre>

<hr>
<h2 id='dataLongMultiSpell'>Data long transformation for multi spell analysis</h2><span id='topic+dataLongMultiSpell'></span>

<h3>Description</h3>

<p>Transform data from short format into long format for discrete multi spell
survival analysis and right censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLongMultiSpell(
  dataSemiLong,
  timeColumn,
  eventColumn,
  idColumn,
  timeAsFactor = FALSE,
  spellAsFactor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataLongMultiSpell_+3A_datasemilong">dataSemiLong</code></td>
<td>
<p>Original data in semi-long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataLongMultiSpell_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times. It
is required that the observed times are discrete (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongMultiSpell_+3A_eventcolumn">eventColumn</code></td>
<td>
<p>Column name of the event status (&quot;character vector&quot;). The
events can take multiple values on a discrete scale (0, 1, 2, ...) and
repetition of events is allowed (integer vector or class factor). 
It is assumed that the number zero corresponds to censoring and all number &gt; 0 
represent the observed states between transitions.</p>
</td></tr>
<tr><td><code id="dataLongMultiSpell_+3A_idcolumn">idColumn</code></td>
<td>
<p>Name of column of identification number of persons as
character(&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongMultiSpell_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Should the time intervals be coded as factor (&quot;logical vector&quot;)? Default is FALSE. 
In the default settings the discrete time intervals are treated as quantitative (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongMultiSpell_+3A_spellasfactor">spellAsFactor</code></td>
<td>
<p>Should the spells be coded as factor (&quot;logical vector&quot;)? Default is
not to use factor. If the argument is false, the column is coded as numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data has continuous survival times, the response may be transformed
to discrete intervals using function <code><a href="#topic+contToDisc">contToDisc</a></code>. The discrete
time variable needs to be strictly increasing for each person, because
otherwise the order of the events is not distinguishable. Here is an example
data structure in short format prior augmentation with three possible
states: \ idColumn=1, 1, ... , 1, 2, 2, ... , n \ timeColumn= t_ID1_1 &lt;
t_ID1_1 &lt; ... &lt; t_ID1_k, t_ID2_1 &lt; t_ID2_2 &lt; ... &lt; t_ID2_k, ... \
eventColumn = 0, 1, ... , 2, 1, 0, ... , 0
</p>
<p>The starting state of each individual is assumed to given with time interval
equals zero. For example in an illness-death model with three states (&quot;healthy&quot;, &quot;illness&quot;, &quot;death&quot;)
if an individual was healthy at the beginning of the study this has to be encoded with
discrete time interval set to zero and event state &quot;healthy&quot;.
</p>


<h3>Value</h3>

<p>Original data.frame with three additional columns: </p>
 <ul>
<li>
<p>obj Index of persons as integer vector </p>
</li>
<li> <p>timeInt Index of time
intervals (factor or integer vector) </p>
</li>
<li> <p>spell The spell gives the actual 
state of each individual within a given discrete interval.
</p>
</li>
<li> <p>e0 Response transition in long format as binary vector. Column <em>e0</em> represents censoring. 
If <em>e0</em> is coded one in the in the last observed time interval <em>timeInt</em> of a person, 
then this observation was censored. </p>
</li>
<li> <p>e1 Response in long format as binary vector. 
The column <em>e1</em> represents the transition to the first event state. 
</p>
</li>
<li> <p>eX Response in long format as binary vector. 
The column <em>eX</em> represents the transition to the last event state out of the set of possible states 
&quot;1, 2, 3, ..., X&quot;. </p>
</li>
<li><p> ... Expanded columns of original data set.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Fahrmeir L (2005).
&ldquo;Discrete Survival-Time Models.&rdquo;
In <em>Encyclopedia of Biostatistics</em>, chapter Survival Analysis.
John Wiley \&amp; Sons. <br /><br />
Thompson Jr. WA (1977).
&ldquo;On the Treatment of Grouped Observations in Life Studies.&rdquo;
<em>Biometrics</em>, <b>33</b>, 463-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contToDisc">contToDisc</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>,
<code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>, <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################
# Example with unemployment data
data(unempMultiSpell)

# Select subsample of first 500 persons
unempSub &lt;- unempMultiSpell[unempMultiSpell$id %in% 1:250,]

# Expansion from semi-long to long format
unempLong &lt;- dataLongMultiSpell(dataSemiLong=unempSub, timeColumn = "year",
                                eventColumn="spell", idColumn="id", 
                                spellAsFactor=TRUE, timeAsFactor=FALSE)

head(unempLong, 25)

# Fit discrete multi-state model regression model
library(VGAM)

model &lt;- vgam(cbind(e0, e1, e2, e3, e4) ~ 0 + s(timeInt) + age:spell, 
data = unempLong, family = multinomial(refLevel="e0"))
             
############################
# Example with artificial data

# Seed specification
set.seed(-2578)

# Construction of data set
# Censoring and three possible states (0, 1, 2, 3)
# Discrete time intervals (1, 2, ... , 10)
# Noninfluential variable x ~ N(0, 1)
datFrame &lt;- data.frame(
 ID = c(rep(1, 6), rep(2, 4), rep(3, 3), rep(4, 2), rep(5, 4), 
      rep(6, 5), rep(7, 7), rep(8, 8)),
 time = c(c(0, 2, 5, 6, 8, 10), c(0, 1, 6, 7), c(0, 9, 10), c(0, 6), c(0, 2, 3, 4), 
        c(0, 3, 4, 7, 9), c(0, 2, 3, 5, 7, 8, 10), c(0, 1, 3, 4, 6, 7, 8, 9) ),
 state = c(c(2, 1, 3, 2, 1, 0), c(3, 1, 2, 2), c(2, 2, 1), c(1, 2), c(3, 2, 2, 0), 
         c(1, 3, 2, 1, 3), c(1, 1, 2, 3, 2, 1, 3), c(3, 2, 3, 2, 1, 1, 2, 3) ),
 x = rnorm(n=6+4+3+2+4+5+7+8) )

# Transformation to long format
datFrameLong &lt;- dataLongMultiSpell(dataSemiLong=datFrame, timeColumn="time",
                                   eventColumn="state", idColumn="ID", 
                                   spellAsFactor=TRUE)
head(datFrameLong, 25)
library(VGAM)
cRm &lt;- vglm(cbind(e0, e1, e2, e3) ~ 0 + timeInt + x:spell, 
data = datFrameLong, family = "multinomial")
summary(cRm)

</code></pre>

<hr>
<h2 id='dataLongSubDist'>Data Matrix and Weights for Discrete Subdistribution Hazard Models</h2><span id='topic+dataLongSubDist'></span>

<h3>Description</h3>

<p>Generates the augmented data matrix and the weights required for discrete
subdistribution hazard modeling with right censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLongSubDist(
  dataShort,
  timeColumn,
  eventColumns,
  eventColumnsAsFactor = FALSE,
  eventFocus,
  timeAsFactor = FALSE,
  aggTimeFormat = FALSE,
  lastTheoInt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataLongSubDist_+3A_datashort">dataShort</code></td>
<td>
<p>Original data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character specifying the column name of the observed event
times (&quot;logical vector&quot;). It is required that the observed times are discrete (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector specifying the column names of the
event indicators (excluding censoring events) (&quot;logical vector&quot;). It is required that a 0-1
coding is used for all events. The algorithm treats row sums of zero of all
event columns as censored.</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_eventcolumnsasfactor">eventColumnsAsFactor</code></td>
<td>
<p>Should the argument <em>eventColumns</em> be interpreted
as column name of a factor variable (&quot;logical vector&quot;)? Default is FALSE.</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_eventfocus">eventFocus</code></td>
<td>
<p>Column name of the event of interest (type 1 event) (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Logical indicating whether time should be coded as a
factor in the augmented data matrix(&quot;logical vector&quot;). If FALSE, a numeric coding will be
used.</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_aggtimeformat">aggTimeFormat</code></td>
<td>
<p>Instead of the usual long format, should every
observation have all time intervals? (&quot;logical vector&quot;) Default is standard
long format. In the case of nonlinear risk score models, the time effect has
to be integrated out before these can be applied to the C-index.</p>
</td></tr>
<tr><td><code id="dataLongSubDist_+3A_lasttheoint">lastTheoInt</code></td>
<td>
<p>Gives the number of the last theoretic interval (&quot;integer vector&quot;). Only used, if aggTimeFormat==TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets up the augmented data matrix and the weights that are
needed for weighted maximum likelihood (ML) estimation of the discrete
subdistribution model proposed by Berger et al. (2018). The model is a
discrete-time extension of the original subdistribution model proposed by
Fine and Gray (1999).
</p>


<h3>Value</h3>

<p>Data frame with additional column &quot;subDistWeights&quot;. The latter
column contains the weights that are needed for fitting a weighted binary
regression model, as described in Berger et al. (2018). The weights are
calculated by a life table estimator for the censoring event.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Berger M, Schmid M, Welchowski T, Schmitz-Valckenberg S, Beyersmann J (2020).
&ldquo;Subdistribution Hazard Models for Competing Risks in Discrete Time.&rdquo;
<em>Biostatistics</em>, <b>21</b>, 449-466. <br /><br />
Fine JP, Gray RJ (2012).
&ldquo;A Proportional Hazards Model for the Subdistribution of a Competing Risk.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>94</b>, 496-509.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataLong">dataLong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Generate subsample, reduce number of intervals to k = 5
SubUnempDur &lt;- UnempDur [1:500, ]
SubUnempDur$time &lt;- as.numeric(cut(SubUnempDur$spell, c(0,4,8,16,28)))

# Convert competing risks data to long format
# The event of interest is re-employment at full job
SubUnempDurLong &lt;- dataLongSubDist (dataShort=SubUnempDur, timeColumn = "time", 
eventColumns=c("censor1", "censor2", "censor3"), eventFocus="censor1")
head(SubUnempDurLong)

# Fit discrete subdistribution hazard model with logistic link function
logisticSubDistr &lt;- glm(y ~ timeInt + ui + age + logwage,
                    family=binomial(), data = SubUnempDurLong, 
                    weights = SubUnempDurLong$subDistWeights)
summary(logisticSubDistr)

########################################
# Simulation 
# Discrete subdistribution hazards model

# Simulate covariates as multivariate normal distribution
library(mvnfast)
set.seed(1980)
X &lt;- mvnfast::rmvn(n = 1000, mu = rep(0, 4), sigma = diag(4))

# Specification of two discrete cause specific hazards with four intervals
# Event 1
theoInterval &lt;- 4
betaCoef_event1 &lt;- seq(-1, 1, length.out = 5)[-3]
timeInt_event1 &lt;- seq(0.1, -0.1, length.out = theoInterval-1)
linPred_event1 &lt;- c(X %*% betaCoef_event1)
# Event 2
betaCoef_event2 &lt;- seq(-0.5, 0.5, length.out = 5)[-3]
timeInt_event2 &lt;- seq(-0.1, 0.1, length.out = theoInterval-1)
linPred_event2 &lt;- c(X %*% betaCoef_event2)
# Discrete cause specific hazards in last theoretical interval
theoHaz_event1 &lt;- 0.5
theoHaz_event2 &lt;- 0.5

# Derive discrete all cause hazard
haz_event1_X &lt;- cbind(sapply(1:length(timeInt_event1), 
                            function(x) exp(linPred_event1 + timeInt_event1[x]) / 
                              (1 + exp(linPred_event1 + timeInt_event1[x]) + 
                              exp(linPred_event2 + timeInt_event2[x])) ), 
                     theoHaz_event1)

haz_event2_X &lt;- cbind(sapply(1:length(timeInt_event2), 
                            function(x) exp(linPred_event2 + timeInt_event2[x]) / 
                              (1 + exp(linPred_event1 + timeInt_event1[x]) + 
                              exp(linPred_event2 + timeInt_event2[x]) ) ),
                     theoHaz_event2)
allCauseHaz_X &lt;- haz_event1_X + haz_event2_X

# Derive discrete cumulative incidence function of event 1 given covariates
p_T_event1_X &lt;- haz_event1_X * cbind(1, (1-allCauseHaz_X)[, -dim(allCauseHaz_X)[2]])
cumInc_event1_X &lt;-  t(sapply(1:dim(p_T_event1_X)[1], function(x) cumsum(p_T_event1_X[x, ])))

# Calculate all cause probability P(T=t | X)
pT_X &lt;- t(sapply(1:dim(allCauseHaz_X)[1], function(i) estMargProb(allCauseHaz_X[i, ]) ))

# Calculate event probability given time interval P(R=r | T=t, X)
pR_T_X_event1 &lt;- haz_event1_X / (haz_event1_X + haz_event2_X)

# Simulate discrete survival times
survT &lt;- sapply(1:dim(pT_X)[1], function(i) sample(x = 1:(length(timeInt_event1)+1), 
                                                   size = 1, prob = pT_X[i, ]) )
censT &lt;- sample(x = 1:(length(timeInt_event1)+1), size = dim(pT_X)[1], 
               prob = rep(1/(length(timeInt_event1) + 1), (length(timeInt_event1) + 1)), 
               replace = TRUE)

# Calculate observed times
obsT &lt;- ifelse(survT &lt;= censT, survT, censT)
obsEvent &lt;- rep(0, length(obsT))
obsEvent &lt;- sapply(1:length(obsT), 
                  function(i) if(survT[i] &lt;= censT[i]){
                    return(sample(x = c(1, 2), size = 1, 
                    prob = c(pR_T_X_event1[i, obsT[i]  ], 
                    1 - pR_T_X_event1[i, obsT[i]  ]) ))
                  } else{
                    
                    return(0)
                  }
)

# Recode last interval to censored
lastInterval &lt;- obsT == theoInterval
obsT[lastInterval] &lt;- theoInterval-1
obsEvent[lastInterval] &lt;- 0
obsT &lt;- factor(obsT)
obsEvent &lt;- factor(obsEvent)

# Data preparation
datShort &lt;- data.frame(event = factor(obsEvent), time=obsT, X)

# Conversion to long data format
datLongSub &lt;- dataLongSubDist(dataShort = datShort, timeColumn = "time",
                             eventColumns = "event", eventFocus = 1, eventColumnsAsFactor = TRUE)

# Estimate discrete subdistribution hazard model
estSubModel &lt;- glm(formula = y ~ timeInt + X1 + X2 + X3 + X4, data = datLongSub,
                  family = binomial(link = "logit"), weights = datLongSub$subDistWeights)

# Predict cumulative incidence function of first event
predSubHaz1 &lt;- predict(estSubModel, newdata = datLongSub[datLongSub$obj == 2, ], type = "response")
mean(((1 - estSurv(predSubHaz1)) - cumInc_event1_X[2, 1:3])^2)

</code></pre>

<hr>
<h2 id='dataLongTimeDep'>Data Long Time Dependent Covariates</h2><span id='topic+dataLongTimeDep'></span>

<h3>Description</h3>

<p>Transforms short data format to long format for discrete survival modelling
of single event analysis with right censoring. Covariates may vary over
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataLongTimeDep(
  dataSemiLong,
  timeColumn,
  eventColumn,
  idColumn,
  timeAsFactor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataLongTimeDep_+3A_datasemilong">dataSemiLong</code></td>
<td>
<p>Original data in semi-long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="dataLongTimeDep_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times (&quot;character vector&quot;). 
It is required that the observed times are discrete (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongTimeDep_+3A_eventcolumn">eventColumn</code></td>
<td>
<p>Column name of the event indicator (&quot;character vector&quot;).
It is required that this is a binary variable with 1==&quot;event&quot; and
0==&quot;censored&quot;.</p>
</td></tr>
<tr><td><code id="dataLongTimeDep_+3A_idcolumn">idColumn</code></td>
<td>
<p>Name of column of identification number of persons (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="dataLongTimeDep_+3A_timeasfactor">timeAsFactor</code></td>
<td>
<p>Should the time intervals be coded as factor (&quot;logical vector&quot;)? Default is
FALSE. In case of default settings the discrete time intervals are treated as quantitative (&quot;numeric vector&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There may be some intervals, where no additional information on the
covariates is observed (e. g. observed values in interval one and three but
two is missing). In this case it is assumed, that the values from the last
observation stay constant over time until a new measurement was done.
</p>
<p>In contrast to continuous survival (see e. g. <code><a href="survival.html#topic+Surv">Surv</a></code>) 
the start and stop time notation is not used here. In discrete time survival analysis the only relevant
information is to use the stop time. Start time does not matter, because all discrete intervals need to be  
included in the long data set format to ensure consistent estimation. It is assumed that the supplied 
data set &quot;dataSemiLong&quot; contains all repeated measurements of each cluster in semi-long format (e. g. persons). 
For further information see example <em>Start-stop notation</em>.
</p>


<h3>Value</h3>

<p>Original data in long format with three additional columns: </p>
 <ul>
<li>
<p>obj Index of persons as integer vector </p>
</li>
<li> <p>timeInt Index of time
intervals (factor) </p>
</li>
<li> <p>y Response in long format as binary vector.
1==&quot;event happens in period timeInt&quot; and zero otherwise </p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Fahrmeir L (2005).
&ldquo;Discrete Survival-Time Models.&rdquo;
In <em>Encyclopedia of Biostatistics</em>, chapter Survival Analysis.
John Wiley \&amp; Sons. <br /><br />
Thompson Jr. WA (1977).
&ldquo;On the Treatment of Grouped Observations in Life Studies.&rdquo;
<em>Biometrics</em>, <b>33</b>, 463-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contToDisc">contToDisc</a></code>, <code><a href="#topic+dataLong">dataLong</a></code>,
<code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example Primary Biliary Cirrhosis data
library(survival)
dataSet1 &lt;- pbcseq

# Only event death is of interest
dataSet1$status [dataSet1$status == 1] &lt;- 0
dataSet1$status [dataSet1$status == 2] &lt;- 1
table(dataSet1$status)

# Convert to months
dataSet1$day &lt;- ceiling(dataSet1$day/30) + 1
names(dataSet1) [7] &lt;- "month"

# Convert to long format for time varying effects
pbcseqLong &lt;- dataLongTimeDep (dataSemiLong = dataSet1, timeColumn = "month", 
eventColumn = "status", idColumn = "id")
pbcseqLong [pbcseqLong$obj == 1, ]

#####################
# Start-stop notation

library(survival)
?survival::heart

# Assume that time was measured on a discrete scale.
# Discrete interval lengths are assumed to vary.
intervalLimits &lt;- quantile(heart$stop, probs = seq(0.1, 1, by=0.1))
intervalLimits[length(intervalLimits)] &lt;- intervalLimits[length(intervalLimits)] + 1
heart_disc &lt;- contToDisc(dataShort = heart, timeColumn = "stop", 
intervalLimits = intervalLimits, equi = FALSE)
table(heart_disc$timeDisc)

# Conversion to long format
heart_disc_long &lt;- dataLongTimeDep(dataSemiLong = heart_disc, timeColumn = "timeDisc", 
eventColumn = "event", idColumn = "id")
head(heart_disc_long)

</code></pre>

<hr>
<h2 id='devResid'>Deviance Residuals</h2><span id='topic+devResid'></span>

<h3>Description</h3>

<p>Computes the root of the deviance residuals for evaluation of performance in
discrete survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devResid(dataLong, hazards)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="devResid_+3A_datalong">dataLong</code></td>
<td>
<p>Original data in long format (&quot;class data.frame&quot;).
The correct format can be specified with data preparation, see e. g.
<code><a href="#topic+dataLong">dataLong</a></code>.</p>
</td></tr>
<tr><td><code id="devResid_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazards of the data in long format(&quot;numeric vector&quot;). Discrete
discrete hazards are probabilities and therefore restricted to the interval [0,
1].</p>
</td></tr>
</table>


<h3>Value</h3>

 <ul>
<li><p>Output List with objects: </p>
 <ul>
<li><p>DevResid
Square root of deviance residuals as numeric vector.  </p>
</li></ul>
 </li>
<li><p>Input A list
of given argument input values (saved for reference) </p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Tutz G (2012).
<em>Regression for Categorical Data</em>.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjDevResid">adjDevResid</a></code>, <code><a href="#topic+predErrCurve">predErrCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)

# Transform data to long format
heart[, "stop"] &lt;- ceiling(heart[, "stop"])
set.seed(0)
Indizes &lt;- sample(unique(heart$id), 25)
randSample &lt;- heart[unlist(sapply(1:length(Indizes), 
function(x) which(heart$id == Indizes[x]))),]
heartLong &lt;- dataLongTimeDep(dataSemiLong = randSample, 
timeColumn = "stop", eventColumn = "event", idColumn = "id", timeAsFactor = FALSE)

# Fit a generalized, additive model and predict discrete hazards on data in long format
library(mgcv)
gamFit &lt;- gam(y ~ timeInt + surgery + transplant + s(age), data = heartLong, family = "binomial")
hazPreds &lt;- predict(gamFit, type = "response")

# Calculate the deviance residuals
devResiduals &lt;- devResid (dataLong = heartLong, hazards = hazPreds)$Output$DevResid

# Compare with estimated normal distribution
plot(density(devResiduals), 
main = "Empirical density vs estimated normal distribution", 
las = 1, ylim = c(0, 0.5))
tempFunc &lt;- function (x) dnorm(x, mean = mean(devResiduals), sd = sd(devResiduals))
curve(tempFunc, xlim = c(-10, 10), add = TRUE, col = "red")
# The empirical density seems like a mixture distribution, 
# but is not too far off in with values greater than 3 and less than 1

</code></pre>

<hr>
<h2 id='estCumInz'>Estimates Cumulative Incidence Function for Discrete Time Competing Risks Models</h2><span id='topic+estCumInz'></span>

<h3>Description</h3>

<p>Estimates the cumulative incidence function of a discrete time competing risks model 
given covariates P(T &lt;= t, event = k | x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCumInz(hazards, eventFocus)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estCumInz_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazard rates of all events (&quot;numeric matrix&quot;). 
Each column represents one event. The first column is assumed to contain the censoring case 
and the discrete hazards should only vary over time in each row.</p>
</td></tr>
<tr><td><code id="estCumInz_+3A_eventfocus">eventFocus</code></td>
<td>
<p>Column that represent the discrete hazards of the primary event (&quot;integer vector&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariates set is required to be constant across rows.
</p>


<h3>Value</h3>

<p>Returns cumulative incidence function of the primary event. 
If argument <em>nonparCI</em> is set to TRUE, then a list is returned: 
The first element includes the cumulative incidence function. 
The second list element contains the lower and the third list element the upper bound of
the pointwise confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Lee M, Feuer EJ, Fine JP (2018).
&ldquo;On the analysis of discrete time competing risks data.&rdquo;
<em>Biometrics</em>, <b>74</b>, 1468-1481.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compRisksGEE">compRisksGEE</a></code>, <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>, 
<code><a href="#topic+dataLongCompRisksTimeDep">dataLongCompRisksTimeDep</a></code>, <code><a href="geepack.html#topic+geeglm">geeglm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
SubUnempDur &lt;- UnempDur [1:100, ]

# Estimate GEE models for all events
estGEE &lt;- compRisksGEE(datShort = SubUnempDur, dataTransform = "dataLongCompRisks", 
corstr = "independence", formulaVariable =~ timeInt + age + ui + logwage * ui, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell")

# Estimate hazards of all events given the covariates of third person
SubUnempDurLong &lt;- dataLongCompRisks(dataShort = SubUnempDur, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell") 
preds &lt;- predict(estGEE, subset(SubUnempDurLong, obj == 3))

# Estimate cumulative incidence function
cumInzGEE &lt;- estCumInz(preds, eventFocus = 2)
cumInzGEE

</code></pre>

<hr>
<h2 id='estMargProb'>Estimated Marginal Probabilities</h2><span id='topic+estMargProb'></span>

<h3>Description</h3>

<p>Estimates the marginal probability P(T=t|x) based on estimated discrete hazards.
The discrete hazards may or may not depend on covariates. The covariates have to
be equal across all estimated hazard rates. Therefore the given discrete hazards
should only vary over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estMargProb(hazards)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estMargProb_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazards (&quot;numeric vector&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <em>hazards</em> must be given for all intervals [a_0, a_1), [a_1,
a_2), ..., [a_q-1, a_q), [a_q, Inf).
</p>


<h3>Value</h3>

<p>Estimated marginal probabilities (&quot;numeric vector&quot;)
</p>


<h3>Note</h3>

<p>It is assumed that all time points up to the last interval [a_q, Inf)
are available. If not already present, these can be added manually.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSurv">estSurv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]

# Convert to long format
UnempLong &lt;- dataLong(dataShort = subUnempDur, timeColumn = "spell", eventColumn = "censor1")
head(UnempLong)

# Estimate binomial model with logit link
Fit &lt;- glm(formula = y ~ timeInt + age + logwage, data = UnempLong, family = binomial())

# Estimate discrete survival function given age, logwage of first person
hazard &lt;- predict(Fit, newdata = subset(UnempLong, obj == 1), type = "response")

# Estimate marginal probabilities given age, logwage of first person
MarginalProbCondX &lt;- estMargProb (c(hazard, 1))
MarginalProbCondX
sum(MarginalProbCondX)==1 # TRUE: Marginal probabilities must sum to 1!

</code></pre>

<hr>
<h2 id='estMargProbCompRisks'>Estimated Marginal Probabilities for Competing Risks</h2><span id='topic+estMargProbCompRisks'></span>

<h3>Description</h3>

<p>Estimates the marginal probability P(T = t,R = r|x) based on estimated discrete hazards of a competing risks model.
The discrete hazards may or may not depend on covariates. The covariates have to
be equal across all estimated discrete hazards. Therefore the given discrete hazards
should only vary over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estMargProbCompRisks(hazards)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estMargProbCompRisks_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazards (&quot;numeric matrix&quot;). 
Discrete hazards of each time interval are stored in the rows and the number of columns equal to the number of events.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <em>hazards</em> must be given for all intervals [a_0, a_1), [a_1,
a_2), ..., [a_q-1, a_q), [a_q, Inf).
</p>


<h3>Value</h3>

<p>Estimated marginal probabilities (&quot;numeric matrix&quot;)
</p>


<h3>Note</h3>

<p>It is assumed that all time points up to the last interval [a_q, Inf)
are available. If not already present, these can be added manually. 
In competing risk settings the marginal probabilities of the last theoretical interval 
depend on the assumptions on the discrete hazards in the last theoretical interval. 
However the estimation of all previous discrete intervals is not affected by those assumptions.
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estMargProb">estMargProb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]

# Convert to long format
UnempLong &lt;- dataLongCompRisks(dataShort = subUnempDur, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"))
head(UnempLong)

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula = cbind(e0, e1, e2) ~ timeInt + age + logwage, data = UnempLong,
family = VGAM::multinomial(refLevel = "e0"))

# Estimate discrete survival function given age, logwage of first person
hazards &lt;- VGAM::predictvglm(vglmFit, newdata = subset(UnempLong, obj == 1), type = "response")[,-1]

# Estimate marginal probabilities given age, logwage of first person
# Example 1
# Assumption: Discrete hazards in last theoretical interval are equal for both event types
MarginalProbCondX &lt;- estMargProbCompRisks(rbind(hazards, 0.5))
MarginalProbCondX
all.equal(sum(MarginalProbCondX), 1) # TRUE: Marginal probabilities must sum to 1!

# Example 2
# Assumption: Discrete hazards in last theoretical interval are event1=, event2=
MarginalProbCondX2 &lt;- estMargProbCompRisks(rbind(hazards, c(0.75, 0.25)))
MarginalProbCondX2
all.equal(sum(MarginalProbCondX2), 1) # TRUE: Marginal probabilities must sum to 1!

# Compare marginal probabilities given X
all.equal(MarginalProbCondX[1:5, ], MarginalProbCondX2[1:5, ])
all.equal(MarginalProbCondX[6, ], MarginalProbCondX2[6, ])

</code></pre>

<hr>
<h2 id='estRecal'>Logistic recalibration based on linear predictors</h2><span id='topic+estRecal'></span>

<h3>Description</h3>

<p>Fits a logistic recalibration model to independent test data. It updates the intercept and slope parameters. 
It is assumed that the factor levels of time are equal in both training and validation data. 
Time dependent covariates, discrete cause specific competing risks and subdistribution hazards are also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estRecal(testLinPred, testDataLong, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estRecal_+3A_testlinpred">testLinPred</code></td>
<td>
<p>Calculated linear predictor on the validation data with model fitted on training data (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="estRecal_+3A_testdatalong">testDataLong</code></td>
<td>
<p>Validation data set in long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="estRecal_+3A_weights">weights</code></td>
<td>
<p>Weights used in estimation of the logistic recalibration model (&quot;numeric vector&quot;). 
Default is no weighting (NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Updates estimated hazards of discrete survival models to better adapt to a different environment. 
If there are substantial environment changes the predicted probabilities will differ between two environments.
Logistic recalibration may be used to improve the calibration of predicted probabilities by 
incorperating information from the existing model and data from the environment. This approach works 
for any survival prediction model with one event that provides linear predictors.
</p>


<h3>Value</h3>

<p>Continuation ratio model that calibrates estimated discrete hazards to new validation environment (&quot;class glm, lm&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Heyard R, Timsit J, Held L, COMBACTE-MAGNET,consortium (2019).
&ldquo;Validation of discrete time-to-event prediction models in the presence of competing risks.&rdquo;
<em>Biometrical Journal</em>, <b>62</b>, 643-657.
</p>


<h3>See Also</h3>

<p>(Calibration plots links) <code><a href="#topic+dataLong">dataLong</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>, <code><a href="#topic+dataLongCompRisks">dataLongCompRisks</a></code>, 
<code><a href="#topic+dataLongCompRisksTimeDep">dataLongCompRisksTimeDep</a></code>, <code><a href="#topic+dataLongSubDist">dataLongSubDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####################
# Data preprocessing

# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
selectInd1 &lt;- 1:100
selectInd2 &lt;- 101:200
trainSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd1], ]
valSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd2], ]

####################
# One event

# Convert to long format
trainSet_long &lt;- dataLong(dataShort = trainSet, timeColumn = "spell", eventColumn = "censor1")
valSet_long &lt;- dataLong(dataShort = valSet, timeColumn = "spell", eventColumn = "censor1")

# Estimate continuation ratio model with logit link
glmFit &lt;- glm(formula = y ~ timeInt + age + logwage, data = trainSet_long, family = binomial())

# Calculate linear predictors on validation set
linPred &lt;- predict(glmFit, newdata = valSet_long, type = "link")

# Estimate logistic recalibration model
recalModel &lt;- estRecal(testLinPred = linPred, testDataLong = valSet_long)
summary(recalModel)

# Calibration plots
hazOrg &lt;- predict(glmFit, newdata = valSet_long, type = "response")
hazRecal &lt;- predict(recalModel, newdata = data.frame(linPred), type = "response")

# Before logistic recalibration
calibrationPlot(hazOrg, testDataLong = valSet_long)
# After logistic recalibration
calibrationPlot(hazRecal, testDataLong = valSet_long)

############################
# Two cause specific hazards 
library(VGAM)

# Convert to long format
trainSet_long &lt;- dataLongCompRisks(dataShort = trainSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"))
valSet_long &lt;- dataLongCompRisks(dataShort = valSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"))

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula = cbind(e0, e1, e2) ~ timeInt + age + logwage, data = trainSet_long, 
family = VGAM::multinomial(refLevel = "e0"))

# Calculate linear predictors on training and test set
linPred &lt;- VGAM::predictvglm(vglmFit, newdata = valSet_long, type = "link")

# Estimate logistic recalibration model
recalModel &lt;- estRecal(testLinPred = linPred, testDataLong = valSet_long)
recalModel

# Calibration plots
hazOrg &lt;- predict(vglmFit, newdata = valSet_long, type = "response")
predDat &lt;- as.data.frame(linPred)
names(predDat) &lt;- recalModel@misc$colnames.x[-1]
hazRecal &lt;- predictvglm(recalModel, newdata = predDat, type = "response")

# Before logistic recalibration
calibrationPlot(hazOrg, testDataLong = valSet_long, event = "e1")
calibrationPlot(hazOrg, testDataLong = valSet_long, event = "e2")
# After logistic recalibration
calibrationPlot(hazRecal, testDataLong = valSet_long, event = "e1")
calibrationPlot(hazRecal, testDataLong = valSet_long, event = "e2")

###############################
# Subdistribution hazards model

# Convert to long format
trainSet_long &lt;- dataLongSubDist(dataShort = trainSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")
valSet_long &lt;- dataLongSubDist(dataShort = valSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")

# Estimate continuation ratio model with logit link
glmFit &lt;- glm(formula = y ~ timeInt + age + logwage, data = trainSet_long, 
family = binomial(), weights = trainSet_long$subDistWeights)

# Calculate linear predictors on training and test set
linPred &lt;- predict(glmFit, newdata = valSet_long, type = "link")

# Estimate logistic recalibration model
recalModel &lt;- estRecal(testLinPred = linPred, testDataLong = valSet_long, 
weights = valSet_long$subDistWeights)
recalModel

# Calibration plots
hazOrg &lt;- predict(glmFit, newdata = valSet_long, type = "response",
weights = valSet_long$subDistWeights)
hazRecal &lt;- predict(recalModel, newdata = data.frame(linPred), type = "response",
weights = valSet_long$subDistWeights)

# Before logistic recalibration
calibrationPlot(hazOrg, testDataLong = valSet_long,
weights=valSet_long$subDistWeights)
# After logistic recalibration
calibrationPlot(hazRecal, testDataLong = valSet_long,
weights=valSet_long$subDistWeights)

</code></pre>

<hr>
<h2 id='estSurv'>Estimated Survival Function</h2><span id='topic+estSurv'></span>

<h3>Description</h3>

<p>Estimates the survival function S(T = t|x) based on estimated hazard rates.
The hazard rates may or may not depend on covariates. The covariates have to
be equal across all estimated hazard rates. Therefore the given hazard rates
should only vary over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estSurv(haz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estSurv_+3A_haz">haz</code></td>
<td>
<p>Estimated hazard rates (&quot;numeric vector&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <em>haz</em> must be given for all intervals [a_0, a_1), [a_1,
a_2), ..., [a_q-1, a_q), [a_q, Inf).
</p>


<h3>Value</h3>

<p>Estimated probabilities of survival (&quot;numeric vector&quot;)
</p>


<h3>Note</h3>

<p>It is assumed that all time points up to the last 
theoretical interval [a_q, Inf) are available. If not already present, 
these can be added manually.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estMargProb">estMargProb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]

# Convert to long format
UnempLong &lt;- dataLong(dataShort = subUnempDur, timeColumn = "spell", eventColumn = "censor1")
head(UnempLong)

# Estimate binomial model with logit link
Fit &lt;- glm(formula = y ~ timeInt + age + logwage, data=UnempLong, family = binomial())

# Estimate discrete survival function given age, logwage of first person
hazard &lt;- predict(Fit, newdata = subset(UnempLong, obj == 1), type = "response")
SurvivalFuncCondX &lt;- estSurv(c(hazard, 1))
SurvivalFuncCondX

</code></pre>

<hr>
<h2 id='estSurvCens'>Estimated Survival Function of Censoring Process</h2><span id='topic+estSurvCens'></span>

<h3>Description</h3>

<p>Estimates the marginal survival function G(T=t) of the censoring process based on 
a life table estimator. Compatible with single event and competing risks data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estSurvCens(dataShort, timeColumn, eventColumns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estSurvCens_+3A_datashort">dataShort</code></td>
<td>
<p>Data in original short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="estSurvCens_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Name of column with discrete time intervals (&quot;character
vector&quot;).</p>
</td></tr>
<tr><td><code id="estSurvCens_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Names of the event columns of <code>dataShort</code>(&quot;character vector&quot;). In the
competing risks case the event columns have to be in dummy encoding format
(&quot;numeric vector&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of estimated survival function of the censoring process
for all time points except the last theoretical interval.
</p>


<h3>Note</h3>

<p>In the censoring survival function the last time interval [a_q, Inf)
has the probability of zero.
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSurv">estSurv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]

######################
# Single event example

# Estimate censoring survival function G(t)
estG &lt;- estSurvCens(dataShort = subUnempDur, timeColumn = "spell", 
eventColumns = "censor1")
estG

#########################
# Competing risks example

# Estimate censoring survival function G(t)
estG &lt;- estSurvCens(dataShort = subUnempDur, timeColumn = "spell", 
eventColumns = c("censor1", "censor2", "censor3", "censor4"))
estG


</code></pre>

<hr>
<h2 id='estSurvCompRisks'>Estimated Survival Function for Competing Risks</h2><span id='topic+estSurvCompRisks'></span>

<h3>Description</h3>

<p>Computes the survival function S(T&gt;t|x) based on estimated hazards of a competing risks model.
The discrete hazards may or may not depend on covariates. The covariates have to
be equal across all estimated hazards. Therefore the given discrete hazards
should only vary over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estSurvCompRisks(hazards)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estSurvCompRisks_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazards (&quot;numeric matrix&quot;). 
Discrete hazards of each time interval are stored in the rows and the number of columns equal to the number of events.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <em>hazards</em> must be given for all intervals [a_0, a_1), [a_1,
a_2), ..., [a_q-1, a_q), [a_q, Inf).
</p>


<h3>Value</h3>

<p>Estimated survival probabilities (&quot;numeric vector&quot;)
</p>


<h3>Note</h3>

<p>It is assumed that all time points up to the last interval [a_q, Inf)
are available. If not already present, these can be added manually.
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSurv">estSurv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]

# Convert to long format
UnempLong &lt;- dataLongCompRisks(dataShort = subUnempDur, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"))
head(UnempLong)

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula = cbind(e0, e1, e2) ~ timeInt + age + logwage, data = UnempLong,
family = VGAM::multinomial(refLevel = "e0"))

# Estimate discrete survival function given age, logwage of first person
hazards &lt;- VGAM::predictvglm(vglmFit, newdata = subset(UnempLong, obj == 1), type = "response")[,-1]
SurvivalFuncCondX &lt;- estSurvCompRisks(rbind(hazards, 0.5))
SurvivalFuncCondX


</code></pre>

<hr>
<h2 id='gumbel'>Gumbel Link Function</h2><span id='topic+gumbel'></span>

<h3>Description</h3>

<p>Constructs the link function with gumbel distribution in approriate format
for use in generalized, linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gumbel()
</code></pre>


<h3>Details</h3>

<p>Insert this function into a binary regression model
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>
<p>Matthias Schmid <a href="mailto:matthias.schmid@imbie.uni-bonn.de">matthias.schmid@imbie.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with copenhagen stroke study
library(pec)
data(cost)
head(cost)

# Take subsample and convert time to months
costSub &lt;- cost [1:50, ]
costSub$time &lt;- ceiling(costSub$time/30)
costLong &lt;- dataLong(dataShort = costSub, timeColumn = "time", eventColumn = "status",
timeAsFactor=TRUE)
gumbelModel &lt;- glm(formula = y ~ timeInt + diabetes, data = costLong, 
family = binomial(link = gumbel()))

# Estimate hazard given prevStroke and no prevStroke
hazPrevStroke &lt;- predict(gumbelModel, newdata=data.frame(timeInt = factor(1:143), 
diabetes = factor(rep("yes", 143), levels = c("no", "yes"))), type = "response")
hazWoPrevStroke &lt;- predict(gumbelModel, newdata = data.frame(timeInt = factor(1:143), 
diabetes=factor(rep("no", 143), levels = c("no", "yes"))), type = "response")

# Estimate survival function
SurvPrevStroke &lt;- cumprod(1 - hazPrevStroke)
SurvWoPrevStroke &lt;- cumprod(1 - hazWoPrevStroke)

# Example graphics of survival curves with and without diabetes
plot(x = 1:143, y = SurvWoPrevStroke, type = "l", xlab = "Months", 
ylab = "S (t|x)", las = 1, lwd = 2, ylim = c(0,1))
lines(x = 1:143, y = SurvPrevStroke, col = "red", lwd = 2)
legend("topright", legend = c("Without diabetes", "Diabetes"), 
lty = 1, lwd =2, col = c("black", "red"))

</code></pre>

<hr>
<h2 id='intPredErr'>Integrated prediction error</h2><span id='topic+intPredErr'></span>

<h3>Description</h3>

<p>Computes the integrated prediction error curve for discrete survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intPredErr(
  hazards,
  testTime,
  testEvent,
  trainTime,
  trainEvent,
  testDataLong,
  tmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intPredErr_+3A_hazards">hazards</code></td>
<td>
<p>Predicted discrete hazards in the test data (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="intPredErr_+3A_testtime">testTime</code></td>
<td>
<p>Discrete time intervals in short format of the test set
(&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="intPredErr_+3A_testevent">testEvent</code></td>
<td>
<p>Events in short format in the test set (&quot;binary vector&quot;).</p>
</td></tr>
<tr><td><code id="intPredErr_+3A_traintime">trainTime</code></td>
<td>
<p>Discrete time intervals in short format of the
training data set (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="intPredErr_+3A_trainevent">trainEvent</code></td>
<td>
<p>Events in short format in the training set (&quot;binary
vector&quot;).</p>
</td></tr>
<tr><td><code id="intPredErr_+3A_testdatalong">testDataLong</code></td>
<td>
<p>Test data in long format(&quot;class data.frame&quot;). The discrete survival function is
calculated based on the predicted hazards. It is assumed that the data was
preprocessed with a function with prefix &quot;dataLong&quot;, see e. g.
<code><a href="#topic+dataLong">dataLong</a></code>, <code><a href="#topic+dataLongTimeDep">dataLongTimeDep</a></code>.</p>
</td></tr>
<tr><td><code id="intPredErr_+3A_tmax">tmax</code></td>
<td>
<p>Gives the maximum time interval for which prediction errors are
calculated (&quot;integer vector&quot;). It must be smaller than the maximum observed time in the
training data of the object produced by function. The default setting NULL means, that all observed intervals are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integrated prediction error (&quot;numeric vector&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Gneiting T, Raftery AE (2007).
&ldquo;Strictly Proper Scoring Rules, Prediction, and Estimation.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>102</b>, 359-378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predErrCurve">predErrCurve</a></code>, <code><a href="stats.html#topic+aggregate">aggregate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########################
# Example with cancer data

library(survival)
head(cancer)

# Data preparation and convertion to 30 intervals
cancerPrep &lt;- cancer
cancerPrep$status &lt;- cancerPrep$status-1
intLim &lt;- quantile(cancerPrep$time, prob = seq(0, 1, length.out = 30))
intLim [length(intLim)] &lt;- intLim [length(intLim)] + 1

# Cut discrete time in smaller number of intervals
cancerPrep &lt;- contToDisc(dataShort = cancerPrep, timeColumn = "time", intervalLimits = intLim)

# Generate training and test data
set.seed(753)
TrainIndices &lt;- sample (x = 1:dim(cancerPrep) [1], size = dim(cancerPrep) [1] * 0.75)
TrainCancer &lt;- cancerPrep [TrainIndices, ]
TestCancer &lt;- cancerPrep [-TrainIndices, ]
TrainCancer$timeDisc &lt;- as.numeric(as.character(TrainCancer$timeDisc))
TestCancer$timeDisc &lt;- as.numeric(as.character(TestCancer$timeDisc))

# Convert to long format
LongTrain &lt;- dataLong(dataShort = TrainCancer, timeColumn = "timeDisc", eventColumn = "status",
timeAsFactor=FALSE)
LongTest &lt;- dataLong(dataShort = TestCancer, timeColumn = "timeDisc", eventColumn = "status",
timeAsFactor=FALSE)
# Convert factors
LongTrain$timeInt &lt;- as.numeric(as.character(LongTrain$timeInt))
LongTest$timeInt &lt;- as.numeric(as.character(LongTest$timeInt))
LongTrain$sex &lt;- factor(LongTrain$sex)
LongTest$sex &lt;- factor(LongTest$sex)

# Estimate, for example, a generalized, additive model in discrete survival analysis
library(mgcv)
gamFit &lt;- gam (formula = y ~ s(timeInt) + s(age) + sex + ph.ecog, data = LongTrain, 
family = binomial())
summary(gamFit)

# 1. Specification of predicted discrete hazards
# Estimate survival function of each person in the test data
testPredHaz &lt;- predict(gamFit, newdata = LongTest, type = "response")

# 2. Calculate integrated prediction error
intPredErr(hazards = testPredHaz, 
testTime = TestCancer$timeDisc, testEvent = TestCancer$status, 
trainTime = TrainCancer$timeDisc, trainEvent = TrainCancer$status, 
testDataLong = LongTest)

</code></pre>

<hr>
<h2 id='intPredErrCompRisks'>Integrated Prediction Error for Competing Risks</h2><span id='topic+intPredErrCompRisks'></span>

<h3>Description</h3>

<p>Estimates integrated prediction errors of arbitrary prediction models in the case of competing risks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intPredErrCompRisks(
  testPreds,
  testDataShort,
  trainDataShort,
  timeColumn,
  eventColumns,
  tmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intPredErrCompRisks_+3A_testpreds">testPreds</code></td>
<td>
<p>Predictions on the test data with model fitted on training data. Must be a matrix, 
with the predictions in the rows and the number of columns equal to the number of events.</p>
</td></tr>
<tr><td><code id="intPredErrCompRisks_+3A_testdatashort">testDataShort</code></td>
<td>
<p>Test data in short format.</p>
</td></tr>
<tr><td><code id="intPredErrCompRisks_+3A_traindatashort">trainDataShort</code></td>
<td>
<p>Train data in short format.</p>
</td></tr>
<tr><td><code id="intPredErrCompRisks_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times.</p>
</td></tr>
<tr><td><code id="intPredErrCompRisks_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector giving the column names of the event indicators (excluding censoring column).</p>
</td></tr>
<tr><td><code id="intPredErrCompRisks_+3A_tmax">tmax</code></td>
<td>
<p>Gives the maximum time interval for which prediction errors are
calculated. It must not be higher than the maximum observed time in the
training data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integrated prediction errors for each competing event. Matrix, with the integrated predictions in the rows 
and the number of columns equal to the number of events.
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Heyard R, Timsit J, Held L, COMBACTE-MAGNET,consortium (2019).
&ldquo;Validation of discrete time-to-event prediction models in the presence of competing risks.&rdquo;
<em>Biometrical Journal</em>, <b>62</b>, 643-657.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predErrCompRisks">predErrCompRisks</a></code>, <code><a href="#topic+predErrCurve">predErrCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###########################
# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
selectInd1 &lt;- 1:200
selectInd2 &lt;- 201:400
trainSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd1], ]
testSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd2], ]

# Convert to long format 
trainSet_long &lt;- dataLongCompRisks(dataShort=trainSet, timeColumn="spell", 
eventColumns=c("censor1", "censor4"), timeAsFactor=TRUE)
tmax          &lt;- max(trainSet$spell)
testSet_long &lt;- dataLongCompRisks(dataShort=testSet, timeColumn="spell", 
eventColumns=c("censor1", "censor4"), aggTimeFormat = TRUE, lastTheoInt=tmax,
timeAsFactor=TRUE)

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula=cbind(e0, e1, e2) ~ timeInt + age + logwage, 
data=trainSet_long, family=VGAM::multinomial(refLevel="e0"))

# Calculate predicted hazards
predHazards &lt;- VGAM::predictvglm(vglmFit, newdata=testSet_long, type="response")

# Compute integrated prediction error 
intPredErrCompRisks(testPreds=predHazards[,-1], testSet, trainSet, "spell", 
c("censor1", "censor4"), tmax)


</code></pre>

<hr>
<h2 id='lifeTable'>Life Table Construction and Estimates</h2><span id='topic+lifeTable'></span><span id='topic+print.discSurvLifeTable'></span>

<h3>Description</h3>

<p>Constructs a life table and estimates discrete hazards, survival
functions, discrete cumulative hazards and their standard errors without
covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lifeTable(dataShort, timeColumn, eventColumn, intervalLimits = NULL)

## S3 method for class 'discSurvLifeTable'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lifeTable_+3A_datashort">dataShort</code></td>
<td>
<p>Original data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="lifeTable_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Name of the column with discrete survival times (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="lifeTable_+3A_eventcolumn">eventColumn</code></td>
<td>
<p>Gives the column name of the event indicator (1=observed,
0=censored) (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="lifeTable_+3A_intervallimits">intervalLimits</code></td>
<td>
<p>Optional names of the intervals for each row, e. g.
[a_0, a_1), [a_1, a_2), ..., [a_q-1, a_q) (&quot;character vector&quot;)</p>
</td></tr>
<tr><td><code id="lifeTable_+3A_x">x</code></td>
<td>
<p>Object of class &quot;discSurvLifeTable&quot;(&quot;class discSurvLifeTable&quot;)</p>
</td></tr>
<tr><td><code id="lifeTable_+3A_...">...</code></td>
<td>
<p>Additional arguments to the print function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing an object of class &quot;data.frame&quot; with following
columns </p>
 <ul>
<li><p>n Number of individuals at risk in a given time
interval (integer) </p>
</li>
<li><p>events Observed number of events in a given time
interval (integer) </p>
</li>
<li><p>dropouts Observed number of dropouts in a given
time interval (integer) </p>
</li>
<li><p>atRisk Estimated number of individuals at
risk, corrected by dropouts (numeric) </p>
</li>
<li><p>hazard Estimated risk of death
(without covariates) in a given time interval </p>
</li>
<li><p>seHazard Estimated
standard deviation of estimated hazard </p>
</li>
<li><p>S Estimated survival curve
</p>
</li>
<li><p>seS Estimated standard deviation of estimated survival function
</p>
</li>
<li><p>cumHazard Estimated cumulative hazard function </p>
</li>
<li><p>seCumHazard
Estimated standard deviation of the estimated cumulative hazard function
</p>
</li>
<li><p>margProb Estimated marginal probability of event in time interval </p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>
<p>Matthias Schmid <a href="mailto:matthias.schmid@imbie.uni-bonn.de">matthias.schmid@imbie.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Lawless JF (2002).
<em>Statistical Models and Methods for Lifetime Data, 2nd edition</em>.
Wiley series in probability and statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Extract subset of all persons smaller or equal the median of age
UnempDurSubset &lt;- subset(UnempDur, age &lt;= median(UnempDur$age))
LifeTabUnempDur &lt;- lifeTable(dataShort = UnempDurSubset, timeColumn = "spell", 
eventColumn = "censor1")
LifeTabUnempDur

# Example with monoclonal gammapothy data
library(survival)
head(mgus)

# Extract subset of mgus
subMgus &lt;- mgus [mgus$futime&lt;=median(mgus$futime), ]

# Transform time in days to intervals [0, 1), [1, 2), [2, 3), ... , [12460, 12461)
mgusInt &lt;- subMgus
mgusInt$futime &lt;- mgusInt$futime + 1
LifeTabGamma &lt;- lifeTable(dataShort = mgusInt, timeColumn= "futime", eventColumn = "death")
head(LifeTabGamma$Output, 25)
plot(x = 1:dim(LifeTabGamma$Output)[1], y = LifeTabGamma$Output$hazard, type = "l", 
xlab = "Time interval", ylab = "Hazard", las = 1, 
main = "Life table estimated marginal discrete hazards")

</code></pre>

<hr>
<h2 id='martingaleResid'>Martingale Residuals</h2><span id='topic+martingaleResid'></span><span id='topic+plot.discSurvMartingaleResid'></span>

<h3>Description</h3>

<p>Estimates the martingale residuals of discrete survival model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>martingaleResid(hazards, dataSetLong)

## S3 method for class 'discSurvMartingaleResid'
plot(x, covariates, dataSetLong, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="martingaleResid_+3A_hazards">hazards</code></td>
<td>
<p>Predicted hazards from a discrete survival model (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="martingaleResid_+3A_datasetlong">dataSetLong</code></td>
<td>
<p>Data in long format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="martingaleResid_+3A_x">x</code></td>
<td>
<p>Object of class &quot;discSurvMartingaleResid&quot;(&quot;class discSurvMartingaleResid&quot;)</p>
</td></tr>
<tr><td><code id="martingaleResid_+3A_covariates">covariates</code></td>
<td>
<p>Names of covariates to plot (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="martingaleResid_+3A_...">...</code></td>
<td>
<p>Additional arguments to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gives a different plot of each marginal covariate against the martingale
residuals. Additionally a nonparametric <code><a href="stats.html#topic+loess">loess</a></code> estimation is
done.
</p>


<h3>Value</h3>

<p>Martingale residuals for each observation in long format (&quot;numeric vector&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics. <br /><br />
Therneau TM, Grambsch PM, Fleming TR (1990).
&ldquo;Martingale-Based Residuals for Survival Models.&rdquo;
<em>Biometrika</em>, <b>70</b>, 147-160.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with cross validation and unemployment data 
library(Ecdat)
data(UnempDur)
summary(UnempDur$spell)

# Extract subset of data
set.seed(635)
IDsample &lt;- sample(1:dim(UnempDur)[1], 100)
UnempDurSubset &lt;- UnempDur [IDsample, ]

# Conversion to long format
UnempDurSubsetLong &lt;- dataLong(dataShort = UnempDurSubset,
timeColumn = "spell", eventColumn = "censor1")

# Estimate discrete survival continuation ratio model
contModel &lt;- glm(y ~ timeInt + age + logwage, data = UnempDurSubsetLong,
family = binomial(link = "logit"))

# Fit hazards to the data set in long format
hazPreds &lt;- predict(contModel, type = "response")

# Calculate martingale residuals for the unemployment data subset
MartResid &lt;- martingaleResid (hazards = hazPreds, dataSetLong = UnempDurSubsetLong)
MartResid
sum(MartResid)

# Plot martingale residuals vs each covariate in the event interval
# Dotted line represents the loess estimate
plot(MartResid, covariates = c("age", "logwage"), dataSetLong = UnempDurSubsetLong)

</code></pre>

<hr>
<h2 id='minNodePruning'>Minimal Node Size Pruning</h2><span id='topic+minNodePruning'></span>

<h3>Description</h3>

<p>Computes optimal minimal node size of a discrete survival tree from a given vector 
of possible node sizes by cross-validation. Laplace-smoothing can be applied to the 
estimated hazards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minNodePruning(
  formula,
  data,
  treetype = "rpart",
  splitruleranger = "hellinger",
  sizes,
  indexList,
  timeColumn,
  eventColumn,
  lambda = 1,
  logOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minNodePruning_+3A_formula">formula</code></td>
<td>
<p>Model formula for tree fitting(&quot;class formula&quot;)</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_data">data</code></td>
<td>
<p>Discrete survival data in short format for which a survival tree is
to be fitted (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_treetype">treetype</code></td>
<td>
<p>Type of tree to be fitted (&quot;character vector&quot;). Possible values are &quot;rpart&quot; or &quot;ranger&quot;. The default
is to fit an rpart tree; when &quot;ranger&quot; is chosen, a ranger forest with a single tree is fitted.</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_splitruleranger">splitruleranger</code></td>
<td>
<p>String specifying the splitting rule of the ranger tree(&quot;character vector&quot;). 
Possible values are either &quot;gini&quot;, &quot;extratrees&quot; or &quot;hellinger&quot;. Default is &quot;hellinger&quot;.</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_sizes">sizes</code></td>
<td>
<p>Vector of different node sizes to try (&quot;integer vector&quot;). 
Values should be non-negative.</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_indexlist">indexList</code></td>
<td>
<p>List of data partitioning indices for cross-validation (&quot;class list&quot;).
Each element represents the test indices of one fold (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times in
the <em>data</em> argument (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_eventcolumn">eventColumn</code></td>
<td>
<p>Character giving the column name of the event indicator in
the <em>data</em> argument (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_lambda">lambda</code></td>
<td>
<p>Parameter for laplace-smoothing. A value of 0 corresponds to 
no laplace-smoothing (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruning_+3A_logout">logOut</code></td>
<td>
<p>Logical value (&quot;logical vector&quot;). If the argument is set to TRUE, 
then computation progress will be written to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the out-of-sample log likelihood for all data partitionings
for each node size in <em>sizes</em> and returns the node size for which the log 
likelihood was minimal. Also returns an rpart tree with the optimal minimal 
node size using the entire data set.
</p>


<h3>Value</h3>

<p>A list containing the two items
</p>

<ul>
<li><p> Optimal minimal node size - Node size with lowest out-of-sample log-likelihood
</p>
</li>
<li><p> tree - a tree object with type corresponding to <em>treetype</em> argument with the optimal minimal node size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(pec)
library(caret)
data(cost)
# Take subsample and convert time to years
cost$time &lt;- ceiling(cost$time / 365)
costSub &lt;- cost[1:50, ]
# Specify column names for data augmentation
timeColumn &lt;- "time"
eventColumn &lt;- "status"
# Create data partition for cross validation
indexList &lt;- createFolds(costSub$status * max(costSub$time) + costSub$time, k = 5)
# specify function arguments and perform node size pruning
formula &lt;- y ~ timeInt + prevStroke + age + sex
sizes &lt;- 1:10
optiTree &lt;- minNodePruning(formula, costSub, treetype = "rpart", sizes = sizes, 
indexList = indexList, timeColumn =  timeColumn, eventColumn = eventColumn, 
lambda = 1, logOut = TRUE)
</code></pre>

<hr>
<h2 id='minNodePruningCompRisks'>Minimal Node Size Pruning in the Presence of Competing Risks</h2><span id='topic+minNodePruningCompRisks'></span>

<h3>Description</h3>

<p>Computes optimal minimal node size of a discrete survival tree 
from a given vector of possible node sizes by cross-validation. 
Laplace-smoothing can be applied to the estimated hazards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minNodePruningCompRisks(
  formula,
  data,
  treetype = "rpart",
  splitruleranger = "gini",
  sizes,
  indexList,
  timeColumn,
  eventColumns,
  lambda = 1,
  logOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minNodePruningCompRisks_+3A_formula">formula</code></td>
<td>
<p>Model formula for tree fitting(&quot;class formula&quot;)</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_data">data</code></td>
<td>
<p>Discrete survival data in short format for which a survival tree is
to be fitted (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_treetype">treetype</code></td>
<td>
<p>Type of tree to be fitted. Possible values are &quot;rpart&quot; or &quot;ranger&quot; (&quot;character vector&quot;). The default
is to fit an rpart tree; when &quot;ranger&quot; is chosen, a ranger forest with a single tree is fitted.</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_splitruleranger">splitruleranger</code></td>
<td>
<p>String specifying the splitting rule of the ranger tree (&quot;character vector&quot;). 
Possible values are either &quot;gini&quot; or &quot;extratrees&quot;. Default is &quot;gini&quot;.</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_sizes">sizes</code></td>
<td>
<p>Vector of different node sizes to try (&quot;integer vector&quot;). 
Values need to be non-negative.</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_indexlist">indexList</code></td>
<td>
<p>List of data partitioning indices for cross-validation (&quot;class list&quot;).
Each element represents the test indices of one fold (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times in
the &quot;data&quot;-argument(&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector giving the column names of the event
indicators (excluding censoring column) in the &quot;data&quot;-argument(&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_lambda">lambda</code></td>
<td>
<p>Parameter for laplace-smoothing. A value of 0 corresponds to 
no laplace-smoothing (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="minNodePruningCompRisks_+3A_logout">logOut</code></td>
<td>
<p>Logical value(&quot;logical vector&quot;). If True, computation progress will be written to
console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the out-of-sample log likelihood for all data partitionings
for each node size in <em>sizes</em> and returns the node size for which the log 
likelihood was minimal. Also returns an rpart tree with the optimal minimal 
node size using the entire data set.
</p>


<h3>Value</h3>

<p>A list containing the two items
</p>

<ul>
<li><p> Optimal minimal node size - Node size with lowest out-of-sample log-likelihood
</p>
</li>
<li><p> tree - a tree object with type corresponding to <em>treetype</em> argument with the optimal minimal node size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example unemployment data
library(Ecdat)
library(caret)
data(UnempDur)
# Select training and testing subsample
subUnempDur &lt;- UnempDur[which(UnempDur$spell &lt; 10),]
subUnempDur &lt;- subUnempDur[1:250,]
#creating status variable for data partitioning
subUnempDur$status &lt;- ifelse(subUnempDur$censor1, 1, 
ifelse(subUnempDur$censor2, 2, ifelse(
subUnempDur$censor3, 3, ifelse(subUnempDur$censor4, 4, 0))))
indexList &lt;- createFolds(subUnempDur$status*max(subUnempDur$spell) + subUnempDur$spell, k = 5)
# performing minimal node size pruning
formula &lt;- responses ~ timeInt + age + logwage
sizes &lt;- 1:10
timeColumn &lt;- "spell"
eventColumns &lt;- c("censor1", "censor2", "censor3","censor4")
optiTree &lt;- minNodePruningCompRisks(formula, subUnempDur, treetype = "rpart", sizes = sizes, 
indexList = indexList, timeColumn = timeColumn, eventColumns = eventColumns, lambda = 1, 
logOut = TRUE)
</code></pre>

<hr>
<h2 id='plotCumInc'>Plot Estimated Cumulative Incidence Function</h2><span id='topic+plotCumInc'></span>

<h3>Description</h3>

<p>Generates a plot of an estimated cumulative incidence function P(T &lt;= t, event=k | x) based on estimated hazards
of a discrete competing risks model or a discrete subdistribution hazard model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCumInc(hazards, eventFocus = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCumInc_+3A_hazards">hazards</code></td>
<td>
<p>Numeric matrix (where each column represents one event) or vector of estimated hazards(&quot;numeric matrix&quot;).</p>
</td></tr>
<tr><td><code id="plotCumInc_+3A_eventfocus">eventFocus</code></td>
<td>
<p>Column that represent the primary event (&quot;integer vector&quot;). 
Only applicable in the case of competing risks.</p>
</td></tr>
<tr><td><code id="plotCumInc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSurv">estSurv</a></code>, <code><a href="#topic+estCumInz">estCumInz</a></code>, <code><a href="#topic+compRisksGEE">compRisksGEE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
SubUnempDur &lt;- UnempDur [1:100, ]

################################
# Competing risks model 

# Estimate GEE models for all events
estGEE &lt;- compRisksGEE(datShort = SubUnempDur, dataTransform = "dataLongCompRisks", 
corstr = "independence", formulaVariable =~ timeInt + age + ui + logwage * ui, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell")

# Estimate hazards of all events given the covariates of third person
SubUnempDurLong &lt;- dataLongCompRisks(dataShort = SubUnempDur, 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), timeColumn = "spell") 
preds &lt;- predict(estGEE, subset(SubUnempDurLong, obj == 3))

plotCumInc(preds, eventFocus = 3)


###############################
# Subdistribution hazards model

# Convert to long format
SubUnempDurLong &lt;- dataLongSubDist(dataShort = SubUnempDur, timeColumn = "spell", 
eventColumns = c("censor1", "censor2", "censor3", "censor4"), eventFocus = "censor1")

# Estimate continuation ratio model with logit link
glmFit &lt;- glm(formula = y ~ timeInt + age + ui + logwage * ui, data = SubUnempDurLong, 
family = binomial(), weights = SubUnempDurLong$subDistWeights)

# Estimated subdistribution hazard given the covariates of the third person
preds &lt;- predict(glmFit, type = "response", newdata = subset(SubUnempDurLong, obj == 3))

plotCumInc(preds)

</code></pre>

<hr>
<h2 id='plotSurv'>Plot Estimated Survival Function</h2><span id='topic+plotSurv'></span>

<h3>Description</h3>

<p>Generates a plot of an estimated survival function S(T&gt;t|x) based on estimated discrete hazards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSurv(hazards, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSurv_+3A_hazards">hazards</code></td>
<td>
<p>Estimated discrete hazards (&quot;numeric vector&quot;)</p>
</td></tr>
<tr><td><code id="plotSurv_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Tutz G, Schmid M (2016).
<em>Modeling discrete time-to-event data</em>.
Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSurv">estSurv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
subUnempDur &lt;- UnempDur [1:100, ]

# Convert to long format
UnempLong &lt;- dataLong(dataShort = subUnempDur, timeColumn = "spell", eventColumn = "censor1")
head(UnempLong)

# Estimate binomial model with logit link
Fit &lt;- glm(formula = y ~ timeInt + age + logwage, data = UnempLong, family = binomial())

# Estimate discrete survival function given age, logwage of first person
Tmax   &lt;- max(subUnempDur$spell)
UnempEval &lt;- dataLong(dataShort = UnempDur[1,], timeColumn = "spell", eventColumn = "censor1", 
aggTimeFormat = TRUE, lastTheoInt = Tmax)
hazard &lt;- predict(Fit, newdata = UnempEval, type = "response")

plotSurv(hazard)



</code></pre>

<hr>
<h2 id='predErrCompRisks'>Prediction Error Curves for Competing Risks</h2><span id='topic+predErrCompRisks'></span>

<h3>Description</h3>

<p>Estimates prediction error curves for discrete survival competing risks models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predErrCompRisks(
  testPreds,
  testDataShort,
  trainDataShort,
  timeColumn,
  eventColumns,
  tmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predErrCompRisks_+3A_testpreds">testPreds</code></td>
<td>
<p>Predictions on the test data with model fitted on training data (&quot;numeric matrix&quot;).
Predictions are stored in the rows and the number of columns equal the number of events.</p>
</td></tr>
<tr><td><code id="predErrCompRisks_+3A_testdatashort">testDataShort</code></td>
<td>
<p>Test data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="predErrCompRisks_+3A_traindatashort">trainDataShort</code></td>
<td>
<p>Train data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="predErrCompRisks_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character giving the column name of the observed times(&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="predErrCompRisks_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector giving the column names of the event indicators (excluding censoring column) (&quot;character vector&quot;).</p>
</td></tr>
<tr><td><code id="predErrCompRisks_+3A_tmax">tmax</code></td>
<td>
<p>Gives the maximum time interval for which prediction errors are
calculated (&quot;integer vector&quot;). It must not be higher than the maximum observed time in the
training data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculated prediction errors for each competing event. Array with one matrix per competing event, 
with the predictions in the rows and the time points in the columns.
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Heyard R, Timsit J, Held L, COMBACTE-MAGNET,consortium (2019).
&ldquo;Validation of discrete time-to-event prediction models in the presence of competing risks.&rdquo;
<em>Biometrical Journal</em>, <b>62</b>, 643-657.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intPredErrCompRisks">intPredErrCompRisks</a></code>, <code><a href="#topic+predErrCurve">predErrCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###########################
# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
selectInd1 &lt;- 1:200
selectInd2 &lt;- 201:400
trainSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd1], ]
testSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd2], ]

# Convert to long format 
trainSet_long &lt;- dataLongCompRisks(dataShort=trainSet, timeColumn="spell", 
eventColumns=c("censor1", "censor4"), timeAsFactor=TRUE)
tmax          &lt;- max(trainSet$spell)
testSet_long &lt;- dataLongCompRisks(dataShort=testSet, timeColumn="spell", 
eventColumns=c("censor1", "censor4"), aggTimeFormat = TRUE, lastTheoInt=tmax,
timeAsFactor=TRUE)

# Estimate continuation ratio model with logit link
vglmFit &lt;- VGAM::vglm(formula=cbind(e0, e1, e2) ~ timeInt + age + logwage, 
data=trainSet_long, family=VGAM::multinomial(refLevel="e0"))

# Calculate predicted hazards
predHazards &lt;- VGAM::predictvglm(vglmFit, newdata=testSet_long, type="response")

# Compute prediction error 
predErrCompRisks(testPreds=predHazards[,-1], testSet, trainSet, "spell", 
c("censor1", "censor4"), tmax)


</code></pre>

<hr>
<h2 id='print.discSurvPredErrDisc'>Prediction Error Curves</h2><span id='topic+print.discSurvPredErrDisc'></span><span id='topic+plot.discSurvPredErrDisc'></span><span id='topic+predErrCurve'></span>

<h3>Description</h3>

<p>Estimates prediction error curves of arbitrary discrete survival prediction models. 
In prediction error curves the estimated and observed survival functions are
compared adjusted by weights at given timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discSurvPredErrDisc'
print(x, ...)

## S3 method for class 'discSurvPredErrDisc'
plot(x, ...)

predErrCurve(
  timepoints,
  estSurvList,
  testTime,
  testEvent,
  trainTime,
  trainEvent
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.discSurvPredErrDisc_+3A_x">x</code></td>
<td>
<p>Object of class &quot;discSurvPredErrDisc&quot;(&quot;class discSurvPredErrDisc&quot;)</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_...">...</code></td>
<td>
<p>Additional arguments to S3 methods.</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_timepoints">timepoints</code></td>
<td>
<p>Vector of the number of discrete time intervals (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_estsurvlist">estSurvList</code></td>
<td>
<p>List of persons in the test data (&quot;class list&quot;). Each element contains a
estimated survival functions of all given time points (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_testtime">testTime</code></td>
<td>
<p>Discrete survival times in the test data (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_testevent">testEvent</code></td>
<td>
<p>Univariate event indicator in the test data (&quot;binary vector&quot;).</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_traintime">trainTime</code></td>
<td>
<p>Numeric vector of discrete survival times in the training
data (&quot;numeric vector&quot;).</p>
</td></tr>
<tr><td><code id="print.discSurvPredErrDisc_+3A_trainevent">trainEvent</code></td>
<td>
<p>Integer vector of univariate event indicator in the
training data(&quot;integer vector&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction error curves should be smaller than 0.25 for all time points,
because this is equivalent to a random assignment error.
</p>


<h3>Value</h3>

 <ul>
<li><p>List List with objects: </p>
 <ul>
<li><p>Output List
with two components </p>
 <ul>
<li><p>predErr Numeric vector with estimated
prediction error values.  Names give the evaluation time point.
</p>
</li>
<li><p>weights List of weights used in the estimation. Each list component
gives the weights of a person in the test data.  </p>
</li></ul>
 </li>
<li><p>Input A list of
given argument input values (saved for reference) </p>
</li></ul>
 </li></ul>



<h3>Author(s)</h3>

<p>Thomas Welchowski <a href="mailto:welchow@imbie.meb.uni-bonn.de">welchow@imbie.meb.uni-bonn.de</a>
</p>


<h3>References</h3>

<p>Van der Laan MJ, Robins JM (2003).
<em>Unified Methods for Censored Longitudinal Data and Causality</em>.
Springer Series in Statistics. <br /><br />
Gerds TA, Schumacher M (2006).
&ldquo;Consistent estimation of the expected Brier Score in general survival models with right-censored event times.&rdquo;
<em>Biometrical Journal</em>, <b>48</b>, 1029-1040.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+gam">gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with cross validation and unemployment data 
library(Ecdat)
library(mgcv)
data(UnempDur)
summary(UnempDur$spell)

# Extract subset of data
set.seed(635)
IDsample &lt;- sample(1:dim(UnempDur)[1], 100)
UnempDurSubset &lt;- UnempDur [IDsample, ]
head(UnempDurSubset)
range(UnempDurSubset$spell)

# Generate training and test data
set.seed(7550)
TrainIndices &lt;- sample (x = 1:dim(UnempDurSubset) [1], size = 75)
TrainUnempDur &lt;- UnempDurSubset [TrainIndices, ]
TestUnempDur &lt;- UnempDurSubset [-TrainIndices, ]

# Convert to long format
LongTrain &lt;- dataLong(dataShort = TrainUnempDur, timeColumn = "spell", eventColumn = "censor1")
LongTest &lt;- dataLong(dataShort = TestUnempDur, timeColumn = "spell", eventColumn = "censor1")
# Convert factor to numeric for smoothing
LongTrain$timeInt &lt;- as.numeric(as.character(LongTrain$timeInt))
LongTest$timeInt &lt;- as.numeric(as.character(LongTest$timeInt))

######################################################################
# Estimate a generalized, additive model in discrete survival analysis

gamFit &lt;- gam (formula = y ~ s(timeInt) + age + logwage, data = LongTrain, family = binomial())

# Estimate survival function of each person in the test data
oneMinusPredHaz &lt;- 1 - predict(gamFit, newdata = LongTest, type = "response")
predSurv &lt;- aggregate(oneMinusPredHaz ~ obj, data = LongTest, FUN = cumprod)

# Prediction error in first interval
tryPredErrDisc1 &lt;- predErrCurve (timepoints = 1, 
estSurvList = predSurv [[2]], testTime = TestUnempDur$spell,
testEvent=TestUnempDur$censor1, trainTime = TrainUnempDur$spell,
 trainEvent=TrainUnempDur$censor1)
tryPredErrDisc1

# Prediction error of the 2. to 10. interval
tryPredErrDisc2 &lt;- predErrCurve (timepoints = 2:10,
estSurvList = predSurv [[2]], testTime = TestUnempDur$spell,
testEvent = TestUnempDur$censor1, trainTime = TrainUnempDur$spell,
trainEvent = TrainUnempDur$censor1)
tryPredErrDisc2
plot(tryPredErrDisc2)

########################################
# Fit a random discrete survival forest

library(ranger)
LongTrainRF &lt;- LongTrain
LongTrainRF$y &lt;- factor(LongTrainRF$y)
rfFit &lt;- ranger(formula = y ~ timeInt + age + logwage, data = LongTrainRF,
probability = TRUE)

# Estimate survival function of each person in the test data
oneMinusPredHaz &lt;- 1 - predict(rfFit, data = LongTest)$predictions[, 2]
predSurv &lt;- aggregate(oneMinusPredHaz ~ obj, data = LongTest, FUN = cumprod)

# Prediction error in first interval
tryPredErrDisc1 &lt;- predErrCurve (timepoints = 1, 
estSurvList = predSurv [[2]], testTime = TestUnempDur$spell,
testEvent = TestUnempDur$censor1, trainTime = TrainUnempDur$spell,
 trainEvent = TrainUnempDur$censor1)
tryPredErrDisc1

# Prediction error of the 2. to 10. interval
tryPredErrDisc2 &lt;- predErrCurve (timepoints = 2:10,
estSurvList = predSurv [[2]], testTime = TestUnempDur$spell,
testEvent = TestUnempDur$censor1, trainTime = TrainUnempDur$spell,
trainEvent = TrainUnempDur$censor1)
tryPredErrDisc2
plot(tryPredErrDisc2)

</code></pre>

<hr>
<h2 id='survTreeLaplaceHazard'>Laplace Hazards for a Competing Risk Survival Tree Object</h2><span id='topic+survTreeLaplaceHazard'></span>

<h3>Description</h3>

<p>Predicts the laplace-smoothed hazards of discrete survival tree. 
Can be used for single-risk or competing risk discrete survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survTreeLaplaceHazard(treeModel, newdata, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survTreeLaplaceHazard_+3A_treemodel">treeModel</code></td>
<td>
<p>Fitted tree object as generated by &quot;rpart&quot; (&quot;class rpart&quot;).</p>
</td></tr>
<tr><td><code id="survTreeLaplaceHazard_+3A_newdata">newdata</code></td>
<td>
<p>Data in long format for which hazards are to be computed. Must 
contain the same columns that were used for tree fitting(&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="survTreeLaplaceHazard_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter for laplace-smoothing. Must be a non-negative 
number. A value of 0 corresponds to no smoothing (&quot;numeric vector&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A m by k matrix with m being the length of newdata and k being the 
number of classes in treeModel. Each row corresponds to the smoothed hazard 
of the respective observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pec)
library(caret)
# Example data
data(cost)
# Convert time to years and select training and testing subsample
cost$time &lt;- ceiling(cost$time/365)
costTrain &lt;- cost[1:100, ]
costTest  &lt;- cost[101:120, ]
# Convert to long format
timeColumn &lt;- "time"
eventColumn &lt;- "status"
costTrainLong &lt;- dataLong(dataShort=costTrain, timeColumn = "time", 
                          eventColumn = "status")
costTestLong  &lt;- dataLong(dataShort=costTest, timeColumn = "time", 
                          eventColumn = "status")
head(costTrainLong)
# Fit a survival tree
costTree &lt;- rpart(formula = y ~ timeInt + prevStroke + age + sex, data = costTrainLong, 
                  method = "class")
# Compute smoothed hazards for test data
predictedhazards &lt;- survTreeLaplaceHazard(costTree, costTestLong, 1)
predictedhazards
</code></pre>

<hr>
<h2 id='survTreeLaplaceHazardRanger'>Laplace Hazards for a Competing Risk Survival Tree Object</h2><span id='topic+survTreeLaplaceHazardRanger'></span>

<h3>Description</h3>

<p>Predicts the laplace-smoothed hazards of discrete survival data based
on a survival tree from class &quot;ranger&quot;. Currently only single-risk data is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survTreeLaplaceHazardRanger(treeModel, rangerdata, newdata, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survTreeLaplaceHazardRanger_+3A_treemodel">treeModel</code></td>
<td>
<p>Fitted tree object as generated by &quot;ranger&quot; (&quot;class data.frame&quot;). Must be a single ranger tree.</p>
</td></tr>
<tr><td><code id="survTreeLaplaceHazardRanger_+3A_rangerdata">rangerdata</code></td>
<td>
<p>Original training data with which <em>treeModel</em> was fitted (&quot;class data.frame&quot;). Must be in
long format.</p>
</td></tr>
<tr><td><code id="survTreeLaplaceHazardRanger_+3A_newdata">newdata</code></td>
<td>
<p>Data in long format for which hazards are to be computed (&quot;class data.frame&quot;). Must 
contain the same columns that were used for tree fitting.</p>
</td></tr>
<tr><td><code id="survTreeLaplaceHazardRanger_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter for laplace-smoothing (&quot;class data.frame&quot;). Must be a non-negative 
number. A value of zero corresponds to no smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A m by k matrix with m being the length of newdata and k being the 
number of classes in <em>treeModel</em>. Each row corresponds to the smoothed hazard 
of the respective observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pec)
library(caret)
library(ranger)
data(cost)
# Take subsample and convert time to years
cost$time &lt;- ceiling(cost$time/365)
costSubTrain &lt;- cost[1:50,]
costSubTest &lt;- cost[51:70,]
# Specify column names for data augmentation
timeColumn&lt;-"time"
eventColumn&lt;-"status"
costSubTrainLong &lt;- dataLong(costSubTrain, timeColumn, eventColumn)
costSubTestLong &lt;- dataLong(costSubTest, timeColumn, eventColumn)
#create tree
formula &lt;- y ~ timeInt + diabetes + prevStroke + age + sex
rangerTree &lt;- ranger(formula, costSubTrainLong, num.trees = 1, mtry = 5, 
classification = TRUE, splitrule = "hellinger", replace = FALSE, 
sample.fraction = 1, max.depth = 5)
#compute laplace-smoothed hazards
laplHaz &lt;- survTreeLaplaceHazardRanger(rangerTree, costSubTrainLong, 
costSubTestLong, lambda = 1)
laplHaz
</code></pre>

<hr>
<h2 id='unempMultiSpell'>Multiple Spell employment data</h2><span id='topic+unempMultiSpell'></span>

<h3>Description</h3>

<p>Subsample of 1000 persons from the national longitudinal survey of youth 1979 data. 
Included covariates are age, children, ethnicity, marital status and sex. 
The bivariate responses current state (spell) and discrete time interval (year) are 
the last two columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(unempMultiSpell)
</code></pre>


<h3>Details</h3>


<ul>
<li><p> Column &quot;id&quot; is defined as identification number for each person.
</p>
</li></ul>


<ul>
<li><p> Column &quot;age&quot; represents the time-varying age of each person in years.
</p>
</li></ul>


<ul>
<li><p> Column &quot;child&quot; consists of values </p>

<ul>
<li><p> 0 - No children
</p>
</li>
<li><p> 1 - Individual has child/children
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;ethnicity&quot; consists of values </p>

<ul>
<li><p> 1 - Hispanic
</p>
</li>
<li><p> 2 - Black
</p>
</li>
<li><p> 3 - Other
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;marriage&quot; consists of values </p>

<ul>
<li><p> 1 - Never Married
</p>
</li>
<li><p> 2 - Currently married
</p>
</li>
<li><p> 3 - Other/Divorced
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;sex&quot; consists of values </p>

<ul>
<li><p> 1 - Male
</p>
</li>
<li><p> 2 - Female
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;spell&quot; represents the time-varying employment status of each person. 
Possible values are </p>

<ul>
<li><p> 1 - Employed
</p>
</li>
<li><p> 2 - Unemployed
</p>
</li>
<li><p> 3 - Out of labor force
</p>
</li>
<li><p> 4 - In active forces
</p>
</li>
<li><p> 0 - Censored
</p>
</li></ul>

</li></ul>


<ul>
<li><p> Column &quot;year&quot; represents the discrete time intervals in years.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David Koehler <a href="mailto:koehler@imbie.uni-bonn.de">koehler@imbie.uni-bonn.de</a>
</p>


<h3>Source</h3>

<p><a href="https://www.nlsinfo.org/content/cohorts/NLSY97">National Longitudinal Survey of Youth</a>
</p>

<hr>
<h2 id='weightsLtoT'>Compute Subdistribution Weights</h2><span id='topic+weightsLtoT'></span>

<h3>Description</h3>

<p>Function to compute new subdistribution weights for a test data set based on the estimated 
censoring survival function from a learning data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsLtoT(
  dataShortTrain,
  dataShortTest,
  timeColumn,
  eventColumns,
  eventFocus
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightsLtoT_+3A_datashorttrain">dataShortTrain</code></td>
<td>
<p>Learning data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="weightsLtoT_+3A_datashorttest">dataShortTest</code></td>
<td>
<p>Test data in short format (&quot;class data.frame&quot;).</p>
</td></tr>
<tr><td><code id="weightsLtoT_+3A_timecolumn">timeColumn</code></td>
<td>
<p>Character specifying the column name of the observed event times (&quot;character vector&quot;). 
It is required that the observed times are discrete (&quot;integer vector&quot;).</p>
</td></tr>
<tr><td><code id="weightsLtoT_+3A_eventcolumns">eventColumns</code></td>
<td>
<p>Character vector specifying the column names of the event indicators (&quot;logical vector&quot;)(excluding censoring events). 
It is required that a 0-1 coding is used for all events. The algorithm treats row sums of zero of all event columns as censored.</p>
</td></tr>
<tr><td><code id="weightsLtoT_+3A_eventfocus">eventFocus</code></td>
<td>
<p>Column name of the event of interest, which corresponds to the type 1 event (&quot;character vector&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subdstribution weights for the test data in long format using the estimated 
censoring survival function from the learning data (&quot;numeric vector&quot;). The length of the 
vector is equal to the number of observations of the long test data.
</p>


<h3>Author(s)</h3>

<p>Moritz Berger <a href="mailto:moritz.berger@imbie.uni-bonn.de">moritz.berger@imbie.uni-bonn.de</a> <br /> <a href="https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/">https://www.imbie.uni-bonn.de/personen/dr-moritz-berger/</a>
</p>


<h3>References</h3>

<p>Berger M, Schmid M, Welchowski T, Schmitz-Valckenberg S, Beyersmann J (2020).
&ldquo;Subdistribution Hazard Models for Competing Risks in Discrete Time.&rdquo;
<em>Biostatistics</em>, <b>21</b>, 449-466.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataLongSubDist">dataLongSubDist</a></code>, <code><a href="#topic+calibrationPlot">calibrationPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################
# Data preprocessing

# Example unemployment data
library(Ecdat)
data(UnempDur)

# Select subsample
selectInd1 &lt;- 1:100
selectInd2 &lt;- 101:200
trainSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd1], ]
valSet &lt;- UnempDur[which(UnempDur$spell %in% (1:10))[selectInd2], ]  

# Convert to long format
trainSet_long &lt;- dataLongSubDist(dataShort = trainSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")
valSet_long &lt;- dataLongSubDist(dataShort = valSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")

# Compute new weights of the validation data set 
valSet_long$subDistWeights &lt;- weightsLtoT(trainSet, valSet, timeColumn = "spell", 
eventColumns = c("censor1", "censor4"), eventFocus = "censor1")

# Estimate continuation ratio model with logit link
glmFit &lt;- glm(formula = y ~ timeInt + age + logwage, data = trainSet_long, 
family = binomial(), weights = trainSet_long$subDistWeights)

# Calculate predicted discrete hazards 
predHazards &lt;- predict(glmFit, newdata = valSet_long, type = "response")

# Calibration plot 
calibrationPlot(predHazards, testDataLong = valSet_long, weights = valSet_long$subDistWeights)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
