<!DOCTYPE html><html lang="en"><head><title>Help for package msma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {msma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#msma-package'><p>Multiblock Sparse Matrix Analysis Package</p></a></li>
<li><a href='#cvmsma'><p>Cross-Validation</p></a></li>
<li><a href='#hcmsma'><p>Hierarchical cluster analysis</p></a></li>
<li><a href='#msma'><p>Multiblock Sparse Partial Least Squares</p></a></li>
<li><a href='#msma_OneComp'><p>Internal functions</p></a></li>
<li><a href='#ncompsearch'><p>Search for Number of Components</p></a></li>
<li><a href='#optparasearch'><p>Parameters Search</p></a></li>
<li><a href='#plot.msma'><p>Plot msma</p></a></li>
<li><a href='#predict.msma'><p>Prediction</p></a></li>
<li><a href='#regparasearch'><p>Regularized Parameters Search</p></a></li>
<li><a href='#simdata'><p>Simulate Data sets</p></a></li>
<li><a href='#strsimdata'><p>Structured Simulate Data sets</p></a></li>
<li><a href='#summary.msma'><p>Summarizing Fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiblock Sparse Multivariable Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Atsushi Kawaguchi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Atsushi Kawaguchi &lt;kawa_a24@yahoo.co.jp&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Description:</td>
<td>Several functions can be used to analyze multiblock multivariable data. If the input is a single matrix, then principal components analysis (PCA) is implemented. If the input is a list of matrices, then multiblock PCA is implemented. If the input is two matrices, for exploratory and objective variables, then partial least squares (PLS) analysis is implemented. If the input is two lists of matrices, for exploratory and objective variables, then multiblock PLS analysis is implemented. Additionally, if an extra outcome variable is specified, then a supervised version of the methods above is implemented. For each method, sparse modeling is also incorporated. Functions for selecting the number of components and regularized parameters are also provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 01:14:15 UTC; kawaa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 05:30:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='msma-package'>Multiblock Sparse Matrix Analysis Package</h2><span id='topic+msma-package'></span>

<h3>Description</h3>

<p>A Package for Implementation of the method
</p>


<h3>Author(s)</h3>

<p>Atsushi Kawaguchi. <a href="mailto:kawa_a24@yahoo.co.jp">kawa_a24@yahoo.co.jp</a>
</p>


<h3>References</h3>

<p>Kawaguchi A, Yamashita F (2017). Supervised Multiblock Sparse Multivariable Analysis with Application to Multimodal Brain Imaging Genetics. Biostatistics, 18(4) 651-665.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msma">msma</a></code>
</p>

<hr>
<h2 id='cvmsma'>Cross-Validation</h2><span id='topic+cvmsma'></span>

<h3>Description</h3>

<p>cross-validated method to evaluate the fit of &quot;msma&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvmsma(
  X,
  Y = NULL,
  Z = NULL,
  comp = 1,
  lambdaX,
  lambdaY = NULL,
  lambdaXsup = NULL,
  lambdaYsup = NULL,
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  inXsup = NULL,
  inYsup = NULL,
  muX = 0,
  muY = 0,
  nfold = 5,
  seed = 1,
  intseed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvmsma_+3A_x">X</code></td>
<td>
<p>a (list of) matrix, explanatory variable(s).</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_y">Y</code></td>
<td>
<p>a (list of) matrix, objective variable(s).</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_z">Z</code></td>
<td>
<p>a (list of) matrix, response variable(s).</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_comp">comp</code></td>
<td>
<p>numeric scalar for the maximum number of componets to be considered.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_lambdax">lambdaX</code></td>
<td>
<p>numeric vector of regularized parameters for X with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_lambday">lambdaY</code></td>
<td>
<p>numeric vector of regularized parameters for Y with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_lambdaxsup">lambdaXsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of X with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_lambdaysup">lambdaYsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of Y with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_eta">eta</code></td>
<td>
<p>numeric scalar the parameter indexing the penalty family.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_type">type</code></td>
<td>
<p>a character.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_inx">inX</code></td>
<td>
<p>a (list of) numeric vector to specify the variables of X which are always in the model.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_iny">inY</code></td>
<td>
<p>a (list of) numeric vector to specify the variables of X which are always in the model.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_inxsup">inXsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of X which are always in the model.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_inysup">inYsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of Y which are always in the model.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_mux">muX</code></td>
<td>
<p>a numeric scalar for the weight of X for the supervised.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_muy">muY</code></td>
<td>
<p>a numeric scalar for the weight of Y for the supervised.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_nfold">nfold</code></td>
<td>
<p>number of folds - default is 5.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_seed">seed</code></td>
<td>
<p>number of seed for the random number.</p>
</td></tr>
<tr><td><code id="cvmsma_+3A_intseed">intseed</code></td>
<td>
<p>seed number for the random number in the parameter estimation algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>k-fold cross-validation for <code>msma</code>
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>err</code></td>
<td>
<p>The mean cross-validated errors which has three elements consisting of the mean of errors for X and Y, the errors for X and for Y.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### One Component CV #####
cv1 = cvmsma(X, Y, comp = 1, lambdaX=2, lambdaY=1:3, nfold=5, seed=1)
cv1

##### Two Component CV #####
cv2 = cvmsma(X, Y, comp = 2, lambdaX=2, lambdaY=1:3, nfold=5, seed=1)
cv2

</code></pre>

<hr>
<h2 id='hcmsma'>Hierarchical cluster analysis</h2><span id='topic+hcmsma'></span>

<h3>Description</h3>

<p>This is a function for performing a hierarchical cluster analysis using scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcmsma(
  object,
  nclust = 4,
  graph = FALSE,
  hmethod = "ward.D2",
  axes = c(1, 2),
  block = "block",
  XY = "X"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcmsma_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>msma</code>&quot;, usually, a result of a call to <code><a href="#topic+msma">msma</a></code></p>
</td></tr>
<tr><td><code id="hcmsma_+3A_nclust">nclust</code></td>
<td>
<p>a numeric scalar, number of clusters.</p>
</td></tr>
<tr><td><code id="hcmsma_+3A_graph">graph</code></td>
<td>
<p>a numeric vector, numbers of columns for Y. The length of vector corresponds to the number of blocks.</p>
</td></tr>
<tr><td><code id="hcmsma_+3A_hmethod">hmethod</code></td>
<td>
<p>the agglomeration method to be used in the function &quot;<code>hclust</code>&quot;.</p>
</td></tr>
<tr><td><code id="hcmsma_+3A_axes">axes</code></td>
<td>
<p>a numeric (or vector), specifying the component(s) to analyze.</p>
</td></tr>
<tr><td><code id="hcmsma_+3A_block">block</code></td>
<td>
<p>a character, indicating which the &quot;block&quot; or &quot;super&quot; is used.</p>
</td></tr>
<tr><td><code id="hcmsma_+3A_xy">XY</code></td>
<td>
<p>a character, indicating &quot;X&quot; or &quot;Y&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a hierarchical cluster analysis using scores.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>hcout</code></td>
<td>
<p>An object of class hclust</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>a vector with group memberships</p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>an object of class &quot;<code>msma</code>&quot;, usually, a result of a call to <code><a href="#topic+msma">msma</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='msma'>Multiblock Sparse Partial Least Squares</h2><span id='topic+msma'></span><span id='topic+msma.default'></span><span id='topic+print.msma'></span>

<h3>Description</h3>

<p>This is a function for a matrix decomposition method incorporating sparse and supervised modeling for a multiblock multivariable data analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msma(X, ...)

## Default S3 method:
msma(
  X,
  Y = NULL,
  Z = NULL,
  comp = 2,
  lambdaX = NULL,
  lambdaY = NULL,
  lambdaXsup = NULL,
  lambdaYsup = NULL,
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  inXsup = NULL,
  inYsup = NULL,
  muX = 0,
  muY = 0,
  defmethod = "canonical",
  scaling = TRUE,
  verbose = FALSE,
  intseed = 1,
  ceps = 1e-04,
  ...
)

## S3 method for class 'msma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msma_+3A_x">X</code></td>
<td>
<p>a matrix or list of matrices indicating the explanatory variable(s). This parameter is required.</p>
</td></tr>
<tr><td><code id="msma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="msma_+3A_y">Y</code></td>
<td>
<p>a matrix or list of matrices indicating objective variable(s). This is optional. If there is no input for Y, then PCA is implemented.</p>
</td></tr>
<tr><td><code id="msma_+3A_z">Z</code></td>
<td>
<p>a vector, response variable(s) for implementing the supervised version of (multiblock) PCA or PLS. This is optional. The length of Z is the number of subjects. If there is no input for Z, then unsupervised PLS/PCA is implemented.</p>
</td></tr>
<tr><td><code id="msma_+3A_comp">comp</code></td>
<td>
<p>numeric scalar for the maximum number of componets to be considered.</p>
</td></tr>
<tr><td><code id="msma_+3A_lambdax">lambdaX</code></td>
<td>
<p>numeric vector of regularized parameters for X, with a length equal to the number of blocks. If lambdaX is omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="msma_+3A_lambday">lambdaY</code></td>
<td>
<p>numeric vector of regularized parameters for Y, with a length equal to the number of blocks. If lambdaY is omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="msma_+3A_lambdaxsup">lambdaXsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of X with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="msma_+3A_lambdaysup">lambdaYsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of Y with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="msma_+3A_eta">eta</code></td>
<td>
<p>numeric scalar indicating the parameter indexing the penalty family. This version contains only choice 1.</p>
</td></tr>
<tr><td><code id="msma_+3A_type">type</code></td>
<td>
<p>a character, indicating the penalty family. In this version, only one choice is available: &quot;lasso.&quot;</p>
</td></tr>
<tr><td><code id="msma_+3A_inx">inX</code></td>
<td>
<p>a vector or list of numeric vectors specifying the variables in X, always included in the model</p>
</td></tr>
<tr><td><code id="msma_+3A_iny">inY</code></td>
<td>
<p>a vector or list of numeric vectors specifying the variables in Y, always included in the model</p>
</td></tr>
<tr><td><code id="msma_+3A_inxsup">inXsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of X which are always in the model.</p>
</td></tr>
<tr><td><code id="msma_+3A_inysup">inYsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of Y which are always in the model.</p>
</td></tr>
<tr><td><code id="msma_+3A_mux">muX</code></td>
<td>
<p>a numeric scalar for the weight of X for the supervised case. 0 &lt;= muX &lt;= 1.</p>
</td></tr>
<tr><td><code id="msma_+3A_muy">muY</code></td>
<td>
<p>a numeric scalar for the weight of Y for the supervised case. 0 &lt;= muY &lt;= 1.</p>
</td></tr>
<tr><td><code id="msma_+3A_defmethod">defmethod</code></td>
<td>
<p>a character representing the deflation method. This version has only the choice &quot;canonical.&quot;</p>
</td></tr>
<tr><td><code id="msma_+3A_scaling">scaling</code></td>
<td>
<p>a logical, indicating whether or not data scaling is performed. The default is TRUE.</p>
</td></tr>
<tr><td><code id="msma_+3A_verbose">verbose</code></td>
<td>
<p>information</p>
</td></tr>
<tr><td><code id="msma_+3A_intseed">intseed</code></td>
<td>
<p>seed number for the random number in the parameter estimation algorithm.</p>
</td></tr>
<tr><td><code id="msma_+3A_ceps">ceps</code></td>
<td>
<p>a numeric scalar for the convergence condition of the algorithm</p>
</td></tr>
<tr><td><code id="msma_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>msma</code>&quot;, usually, a result of a call to <code><a href="#topic+msma">msma</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>msma</code> requires at least one input X (a matrix or list). In this case, (multiblock) PCA is conducted. If Y is also specified, then a PLS is conducted using X as explanatory variables and Y as objective variables. This function scales each data matrix to a mean of 0 and variance of 1 in the default. The block structure can be represented as a list. If Z is also specified, a supervised version is implemented, and the degree is controlled by muX or muY, where 0 &lt;= muX &lt;= 1, 0 &lt;= muY &lt;= 1, and 0 &lt;= muX + muY &lt; 1. If a positive lambdaX or lambdaY is specified, then a sparse estimation based on the L1 penalty is implemented.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dmode</code></td>
<td>
<p>Which modes &quot;PLS&quot; or &quot;PCA&quot;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Scaled X which has a list form.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Scaled Y which has a list form.</p>
</td></tr>
<tr><td><code>Xscale</code></td>
<td>
<p>Scaling information for X. The means and standard deviations for each block of X are returned.</p>
</td></tr>
<tr><td><code>Yscale</code></td>
<td>
<p>Scaling information for Y. The means and standard deviations for each block of Y are returned.</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>the number of componets</p>
</td></tr>
<tr><td><code>wbX</code></td>
<td>
<p>block loading for X</p>
</td></tr>
<tr><td><code>sbX</code></td>
<td>
<p>block score for X</p>
</td></tr>
<tr><td><code>wbY</code></td>
<td>
<p>block loading for Y</p>
</td></tr>
<tr><td><code>sbY</code></td>
<td>
<p>block score for Y</p>
</td></tr>
<tr><td><code>ssX</code></td>
<td>
<p>super score for X</p>
</td></tr>
<tr><td><code>wsX</code></td>
<td>
<p>super loading for X</p>
</td></tr>
<tr><td><code>ssY</code></td>
<td>
<p>super score for Y</p>
</td></tr>
<tr><td><code>wsY</code></td>
<td>
<p>super loading for Y</p>
</td></tr>
<tr><td><code>nzwbX</code></td>
<td>
<p>number of nonzeros in block loading for X</p>
</td></tr>
<tr><td><code>nzwbY</code></td>
<td>
<p>number of nonzeros in block loading for Y</p>
</td></tr>
<tr><td><code>nzwsX</code></td>
<td>
<p>number of nonzeros in super loading for X</p>
</td></tr>
<tr><td><code>nzwsY</code></td>
<td>
<p>number of nonzeros in super loading for Y</p>
</td></tr>
<tr><td><code>selectXnames</code></td>
<td>
<p>names of selected variables for X</p>
</td></tr>
<tr><td><code>selectYnames</code></td>
<td>
<p>names of selected variables for Y</p>
</td></tr>
<tr><td><code>avX</code></td>
<td>
<p>the adjusted variance of the score for X</p>
</td></tr>
<tr><td><code>avY</code></td>
<td>
<p>the adjusted variance of the score for Y</p>
</td></tr>
<tr><td><code>cpevX</code></td>
<td>
<p>the cumulative percentage of the explained variance for X</p>
</td></tr>
<tr><td><code>cpevY</code></td>
<td>
<p>the cumulative percentage of the explained variance for Y</p>
</td></tr>
<tr><td><code>reproduct</code></td>
<td>
<p>Predictivity. Correlation between Y and the predicted Y</p>
</td></tr>
<tr><td><code>predictiv</code></td>
<td>
<p>Reproductivity. Correlation between the score for Y and the outcome Z</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### One Component #####
fit1 = msma(X, Y, comp=1, lambdaX=2, lambdaY=1:3)
fit1

##### Two Component #####
fit2 = msma(X, Y, comp=2, lambdaX=2, lambdaY=1:3)
fit2

##### Sparse Principal Component Analysis #####
fit3 = msma(X, comp=5, lambdaX=2.5)
summary(fit3)

</code></pre>

<hr>
<h2 id='msma_OneComp'>Internal functions</h2><span id='topic+msma_OneComp'></span><span id='topic+normvec'></span><span id='topic+sparse'></span><span id='topic+cand4lambda'></span><span id='topic+searchseq'></span><span id='topic+project'></span><span id='topic+matserr'></span><span id='topic+ginv'></span><span id='topic+rmnorm'></span>

<h3>Description</h3>

<p>These are internal functions for <code>msma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msma_OneComp(
  X,
  Y,
  Z = NULL,
  lambdaX = NULL,
  lambdaY = NULL,
  lambdaXsup = NULL,
  lambdaYsup = NULL,
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  inXsup = NULL,
  inYsup = NULL,
  muX = 0,
  muY = 0,
  dmode = "PLS",
  verbose = FALSE,
  intseed = 1,
  ceps = 1e-04
)

normvec(a)

sparse(x, lam, eta = 1, type = "lasso", inidx = NULL)

cand4lambda(x, len)

searchseq(orgseq, opt)

project(x, y)

matserr(X1, X2)

ginv(X, tol = sqrt(.Machine$double.eps))

rmnorm(
  n,
  mean = rep(0, nrow(sigma)),
  sigma = diag(length(mean)),
  method = c("eigen", "svd", "chol"),
  pre0.9_9994 = FALSE,
  checkSymmetry = TRUE
)
</code></pre>


<h3>Details</h3>

<p>These are not intended for use by users.
</p>

<hr>
<h2 id='ncompsearch'>Search for Number of Components</h2><span id='topic+ncompsearch'></span><span id='topic+print.ncompsearch'></span><span id='topic+plot.ncompsearch'></span>

<h3>Description</h3>

<p>Determination of the number of components based on cross-validated method or Bayesian information criterion (BIC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncompsearch(
  X,
  Y = NULL,
  Z = NULL,
  comps = 1:3,
  lambdaX = NULL,
  lambdaY = NULL,
  lambdaXsup = NULL,
  lambdaYsup = NULL,
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  inXsup = NULL,
  inYsup = NULL,
  muX = 0,
  muY = 0,
  nfold = 5,
  regpara = FALSE,
  maxrep = 3,
  minpct = 0,
  maxpct = 1,
  criterion = c("CV", "BIC")[1],
  whichselect = NULL,
  intseed = 1
)

## S3 method for class 'ncompsearch'
print(x, ...)

## S3 method for class 'ncompsearch'
plot(x, cidx = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncompsearch_+3A_x">X</code></td>
<td>
<p>a matrix or list of matrices indicating the explanatory variable(s). This parameter is required.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_y">Y</code></td>
<td>
<p>a matrix or list of matrices indicating objective variable(s). This is optional. If there is no input for Y, then PCA is implemented.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_z">Z</code></td>
<td>
<p>a vector, response variable(s) for implementing the supervised version of (multiblock) PCA or PLS. This is optional. The length of Z is the number of subjects. If there is no input for Z, then unsupervised PLS/PCA is implemented.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_comps">comps</code></td>
<td>
<p>numeric vector for the maximum numbers of componets to be considered.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_lambdax">lambdaX</code></td>
<td>
<p>numeric vector of regularized parameters for X, with a length equal to the number of blocks. If lambdaX is omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_lambday">lambdaY</code></td>
<td>
<p>numeric vector of regularized parameters for Y, with a length equal to the number of blocks. If lambdaY is omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_lambdaxsup">lambdaXsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of X with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_lambdaysup">lambdaYsup</code></td>
<td>
<p>numeric vector of regularized parameters for the super weight of Y with length equal to the number of blocks. If omitted, no regularization is conducted.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_eta">eta</code></td>
<td>
<p>numeric scalar indicating the parameter indexing the penalty family. This version contains only choice 1.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_type">type</code></td>
<td>
<p>a character, indicating the penalty family. In this version, only one choice is available: &quot;lasso.&quot;</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_inx">inX</code></td>
<td>
<p>a (list of) numeric vector to specify the variables of X which are always in the model.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_iny">inY</code></td>
<td>
<p>a (list of) numeric vector to specify the variables of X which are always in the model.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_inxsup">inXsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of X which are always in the model.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_inysup">inYsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of Y which are always in the model.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_mux">muX</code></td>
<td>
<p>a numeric scalar for the weight of X for the supervised case. 0 &lt;= muX &lt;= 1.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_muy">muY</code></td>
<td>
<p>a numeric scalar for the weight of Y for the supervised case. 0 &lt;= muY &lt;= 1.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_nfold">nfold</code></td>
<td>
<p>number of folds - default is 5.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_regpara">regpara</code></td>
<td>
<p>logical, If TRUE, the regularized parameters search is also conducted simultaneously.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_maxrep">maxrep</code></td>
<td>
<p>numeric scalar for the number of iteration.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_minpct">minpct</code></td>
<td>
<p>minimum candidate parameters defined as a percentile of automatically determined (possible) candidates.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_maxpct">maxpct</code></td>
<td>
<p>maximum candidate parameters defined as a percentile of automatically determined (possible) candidates.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_criterion">criterion</code></td>
<td>
<p>a character, the evaluation criterion, &quot;CV&quot; for cross-validation, based on a matrix element-wise error, and &quot;BIC&quot; for Bayesian information criteria. The &quot;BIC&quot; is the default.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_whichselect">whichselect</code></td>
<td>
<p>which blocks selected.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_intseed">intseed</code></td>
<td>
<p>seed number for the random number in the parameter estimation algorithm.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>ncompsearch</code>&quot;, usually, a result of a call to <code><a href="#topic+ncompsearch">ncompsearch</a></code></p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="ncompsearch_+3A_cidx">cidx</code></td>
<td>
<p>Parameters used in the plot function to specify whether block or super is used. 1=block (default), 2=super.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function searches for the optimal number of components.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>comps</code></td>
<td>
<p>numbers of components</p>
</td></tr>
<tr><td><code>mincriterion</code></td>
<td>
<p>minimum criterion values</p>
</td></tr>
<tr><td><code>criterions</code></td>
<td>
<p>criterion values</p>
</td></tr>
<tr><td><code>optncomp</code></td>
<td>
<p>optimal number of components based on minimum cross-validation error</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### number of components search #####
ncomp1 = ncompsearch(X, Y, comps = c(1, 5, 10*(1:2)), nfold=5)
#plot(ncomp1)

</code></pre>

<hr>
<h2 id='optparasearch'>Parameters Search</h2><span id='topic+optparasearch'></span><span id='topic+print.optparasearch'></span>

<h3>Description</h3>

<p>Combined method for optimizing the number of components and regularized parameters for &quot;msma&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparasearch(
  X,
  Y = NULL,
  Z = NULL,
  search.method = c("ncomp1st", "regpara1st", "regparaonly", "simultaneous")[1],
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  muX = 0,
  muY = 0,
  comp = 10,
  nfold = 5,
  maxrep = 3,
  minpct = 0,
  maxpct = 1,
  maxpct4ncomp = NULL,
  criterion = c("BIC", "CV")[1],
  criterion4ncomp = NULL,
  whichselect = NULL,
  homo = NULL,
  intseed = 1
)

## S3 method for class 'optparasearch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optparasearch_+3A_x">X</code></td>
<td>
<p>a matrix or list of matrices indicating the explanatory variable(s). This parameter is required.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_y">Y</code></td>
<td>
<p>a matrix or list of matrices indicating objective variable(s). This is optional. If there is no input for Y, then PCA is implemented.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_z">Z</code></td>
<td>
<p>a vector, response variable(s) for implementing the supervised version of (multiblock) PCA or PLS. This is optional. The length of Z is the number of subjects. If there is no input for Z, then unsupervised PLS/PCA is implemented.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_search.method">search.method</code></td>
<td>
<p>a character indicationg search methods, see Details. Default is &quot;ncomp1st&quot; (this is version 3.0 or later).</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_eta">eta</code></td>
<td>
<p>numeric scalar indicating the parameter indexing the penalty family. This version contains only choice 1.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_type">type</code></td>
<td>
<p>a character, indicating the penalty family. In this version, only one choice is available: &quot;lasso.&quot;</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_inx">inX</code></td>
<td>
<p>a vector or list of numeric vectors specifying the variables in X, always included in the model</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_iny">inY</code></td>
<td>
<p>a vector or list of numeric vectors specifying the variables in Y, always included in the model</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_mux">muX</code></td>
<td>
<p>a numeric scalar for the weight of X for the supervised case. 0 &lt;= muX &lt;= 1.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_muy">muY</code></td>
<td>
<p>a numeric scalar for the weight of Y for the supervised case. 0 &lt;= muY &lt;= 1.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_comp">comp</code></td>
<td>
<p>numeric scalar for the number of components to be considered or the maximum canditate number of components.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_nfold">nfold</code></td>
<td>
<p>number of folds - default is 5.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_maxrep">maxrep</code></td>
<td>
<p>numeric scalar for the number of iteration.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_minpct">minpct</code></td>
<td>
<p>minimum candidate parameters defined as a percentile of automatically determined (possible) candidates.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_maxpct">maxpct</code></td>
<td>
<p>maximum candidate parameters defined as a percentile of automatically determined (possible) candidates.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_maxpct4ncomp">maxpct4ncomp</code></td>
<td>
<p>maximum candidate parameters defined as a percentile of automatically determined (possible) candidates.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_criterion">criterion</code></td>
<td>
<p>a character, the evaluation criterion, &quot;CV&quot; for cross-validation, based on a matrix element-wise error, and &quot;BIC&quot; for Bayesian information criteria. The &quot;BIC&quot; is the default.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_criterion4ncomp">criterion4ncomp</code></td>
<td>
<p>a character, the evaluation criterion for the selection of the number of components, &quot;CV&quot; for cross-validation, based on a matrix element-wise error, and &quot;BIC&quot; for Bayesian information criteria.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_whichselect">whichselect</code></td>
<td>
<p>which blocks selected.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_homo">homo</code></td>
<td>
<p>same parameters.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_intseed">intseed</code></td>
<td>
<p>seed number for the random number in the parameter estimation algorithm.</p>
</td></tr>
<tr><td><code id="optparasearch_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>optparasearch</code>&quot;, usually, a result of a call to <code>optparasearch</code></p>
</td></tr>
<tr><td><code id="optparasearch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function for identifying the regularized sparseness parameters lambdaX and lambdaY and the number of components for <code>msma</code>. Four search methods are available. The &quot;simultaneous&quot; method identifies the number of components by searching the regularized parameters in each component. The &quot;regpara1st&quot; identifies the regularized parameters by fixing the number of components, then searching for the number of components with the selected regularized parameters. The &quot;ncomp1st&quot; method identifies the number of components with a regularized parameter of 0, then searches for the regularized parameters with the selected number of components. The &quot;regparaonly&quot; method searches for the regularized parameters with a fixed number of components.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>optncomp</code></td>
<td>
<p>Optimal number of components</p>
</td></tr>
<tr><td><code>optlambdaX</code></td>
<td>
<p>Optimal parameters for X</p>
</td></tr>
<tr><td><code>optlambdaY</code></td>
<td>
<p>Optimal parameters for Y</p>
</td></tr>
<tr><td><code>mincriterion</code></td>
<td>
<p>Minimum criterion value</p>
</td></tr>
<tr><td><code>criteria</code></td>
<td>
<p>All resulting criterion values in the process</p>
</td></tr>
<tr><td><code>pararange</code></td>
<td>
<p>Range of candidates parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### Regularized parameters search #####
opt1 = optparasearch(X, Y, search.method = "regparaonly", comp=1, nfold=5, maxrep=2)
opt1
fit4 = msma(X, Y, comp=opt1$optncomp, lambdaX=opt1$optlambdaX, lambdaY=opt1$optlambdaY)
fit4
summary(fit4)

##### Restrict search range #####
opt2 = optparasearch(X, Y, comp=3, nfold=5, maxrep=2, minpct=0.5)
opt2

</code></pre>

<hr>
<h2 id='plot.msma'>Plot msma</h2><span id='topic+plot.msma'></span>

<h3>Description</h3>

<p>plot method for class &quot;msma&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msma'
plot(
  x,
  v = c("weight", "score", "cpev")[1],
  axes = 1,
  axes2 = 1,
  block = c("block", "super")[1],
  plottype = c("bar", "scatter")[1],
  XY = c("X", "Y", "XY")[1],
  col = NULL,
  signflip = FALSE,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.msma_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>msma</code>.&quot; Usually, a result of a call to <code><a href="#topic+msma">msma</a></code></p>
</td></tr>
<tr><td><code id="plot.msma_+3A_v">v</code></td>
<td>
<p>a character, &quot;weight&quot; for the weight, &quot;score&quot; for the score, and &quot;cpev&quot; for the cumulative percentage of explained variance (CPEV) .</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_axes">axes</code></td>
<td>
<p>a numeric (or vector), specifying the root component(s) to plot.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_axes2">axes2</code></td>
<td>
<p>a numeric (or vector), specifying the nested component(s) to plot.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_block">block</code></td>
<td>
<p>a character, indicating which the &quot;block&quot; or &quot;super&quot; is used.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_plottype">plottype</code></td>
<td>
<p>a character, indicating the plot type. &quot;bar&quot; for the bar plot, &quot;scatter&quot; for the scatter plot.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_xy">XY</code></td>
<td>
<p>a character, indicating &quot;X&quot; or &quot;Y&quot;. &quot;XY&quot; for the scatter plots using X and Y scores from PLS.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_col">col</code></td>
<td>
<p>a color vector.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_signflip">signflip</code></td>
<td>
<p>a numeric vector if the sign in the block is flipped to pose the super as possitive.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_xlim">xlim</code></td>
<td>
<p>a numeric vector x coordinate ranges.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vector y coordinate ranges.</p>
</td></tr>
<tr><td><code id="plot.msma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a plot of results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

fit1 = msma(X, Y, comp=1, lambdaX=2, lambdaY=1:3)
#plot(fit1)

</code></pre>

<hr>
<h2 id='predict.msma'>Prediction</h2><span id='topic+predict.msma'></span>

<h3>Description</h3>

<p>predict method for class &quot;msma&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msma'
predict(object, newX, newY = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.msma_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>msma</code>&quot;, usually, a result of a call to <code><a href="#topic+msma">msma</a></code></p>
</td></tr>
<tr><td><code id="predict.msma_+3A_newx">newX</code></td>
<td>
<p>a matrix in which to look for variables with which to predict X.</p>
</td></tr>
<tr><td><code id="predict.msma_+3A_newy">newY</code></td>
<td>
<p>a matrix in which to look for variables with which to predict Y.</p>
</td></tr>
<tr><td><code id="predict.msma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a prediction from new data based on <code><a href="#topic+msma">msma</a></code> fit. It is mainly used in cross-validation
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>predicted X</p>
</td></tr>
<tr><td><code>sbX</code></td>
<td>
<p>block score for X</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>predicted Y</p>
</td></tr>
<tr><td><code>sbY</code></td>
<td>
<p>block score for Y</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### Two Component #####
fit2 = msma(X, Y, comp=2, lambdaX=2, lambdaY=1:3)
summary(fit2)

##### Predict #####
test = predict(fit2, newX=X, newY=Y)

</code></pre>

<hr>
<h2 id='regparasearch'>Regularized Parameters Search</h2><span id='topic+regparasearch'></span><span id='topic+print.regparasearch'></span>

<h3>Description</h3>

<p>Regularized parameters search method for &quot;msma&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regparasearch(
  X,
  Y = NULL,
  Z = NULL,
  eta = 1,
  type = "lasso",
  inX = NULL,
  inY = NULL,
  inXsup = NULL,
  inYsup = NULL,
  muX = 0,
  muY = 0,
  comp = 1,
  nfold = 5,
  maxrep = 3,
  minpct = 0,
  maxpct = 1,
  criterion = c("CV", "BIC")[1],
  whichselect = NULL,
  homo = NULL,
  intseed = 1
)

## S3 method for class 'regparasearch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regparasearch_+3A_x">X</code></td>
<td>
<p>a matrix or list of matrices indicating the explanatory variable(s). This parameter is required.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_y">Y</code></td>
<td>
<p>a matrix or list of matrices indicating objective variable(s). This is optional. If there is no input for Y, then PCA is implemented.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_z">Z</code></td>
<td>
<p>a vector, response variable(s) for implementing the supervised version of (multiblock) PCA or PLS. This is optional. The length of Z is the number of subjects. If there is no input for Z, then unsupervised PLS/PCA is implemented.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_eta">eta</code></td>
<td>
<p>numeric scalar indicating the parameter indexing the penalty family. This version contains only choice 1.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_type">type</code></td>
<td>
<p>a character, indicating the penalty family. In this version, only one choice is available: &quot;lasso.&quot;</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_inx">inX</code></td>
<td>
<p>a (list of) numeric vector to specify the variables of X which are always in the model.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_iny">inY</code></td>
<td>
<p>a (list of) numeric vector to specify the variables of X which are always in the model.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_inxsup">inXsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of X which are always in the model.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_inysup">inYsup</code></td>
<td>
<p>a (list of) numeric vector to specify the blocks of Y which are always in the model.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_mux">muX</code></td>
<td>
<p>a numeric scalar for the weight of X for the supervised case. 0 &lt;= muX &lt;= 1.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_muy">muY</code></td>
<td>
<p>a numeric scalar for the weight of Y for the supervised case. 0 &lt;= muY &lt;= 1.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_comp">comp</code></td>
<td>
<p>numeric scalar for the maximum number of componets to be considered.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_nfold">nfold</code></td>
<td>
<p>number of folds. Default is 5.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_maxrep">maxrep</code></td>
<td>
<p>numeric scalar for the number of iteration.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_minpct">minpct</code></td>
<td>
<p>percent of minimum candidate parameters.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_maxpct">maxpct</code></td>
<td>
<p>percent of maximum candidate parameters.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_criterion">criterion</code></td>
<td>
<p>a character, the evaluation criterion, &quot;CV&quot; for cross-validation, based on a matrix element-wise error, and &quot;BIC&quot; for Bayesian information criteria. The &quot;BIC&quot; is the default.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_whichselect">whichselect</code></td>
<td>
<p>which blocks selected.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_homo">homo</code></td>
<td>
<p>same parameters.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_intseed">intseed</code></td>
<td>
<p>seed number for the random number in the parameter estimation algorithm.</p>
</td></tr>
<tr><td><code id="regparasearch_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>regparasearch</code>&quot;, usually, a result of a call to <code><a href="#topic+regparasearch">regparasearch</a></code></p>
</td></tr>
<tr><td><code id="regparasearch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function for identifying the regularized parameters of sparseness lambdaX and lambdaY for <code>msma</code>. The initial range of candidates is computed based on fit, with regularized parameter values of 0. A binary search is conducted for dividing the parameter range into two regions. The representative value for the region is a median value, and the optimal region is selected using the minimum criteria obtained from the fit with that median value. The CV error or BIC can be used as criteria. The selected region is also divided into two region and the same process is iterated by maxrep times. Thus, the final median value in the selected region is set to be the optimal regularized parameter. The search is conducted with combinations of parameters for X and Y. The range of candidates for regularized parameters can be restricted, with a percentile of the limit (minimum or maximum) for the range.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>optlambdaX</code></td>
<td>
<p>Optimal parameters for X</p>
</td></tr>
<tr><td><code>optlambdaY</code></td>
<td>
<p>Optimal parameters for Y</p>
</td></tr>
<tr><td><code>mincriterion</code></td>
<td>
<p>Minimum of criterion values</p>
</td></tr>
<tr><td><code>criterions</code></td>
<td>
<p>Resulting criterion value</p>
</td></tr>
<tr><td><code>pararange</code></td>
<td>
<p>Range of candidates parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = c(20, 15), seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### Regularized parameters search #####
opt1 = regparasearch(X, Y, comp=1, criterion="BIC", maxrep=2, 
whichselect=c("X", "Y", "Xsup", "Ysup"))
opt1
fit4 = msma(X, Y, comp=1, lambdaX=opt1$optlambdaX, lambdaY=opt1$optlambdaY, 
lambdaXsup=opt1$optlambdaXsup, lambdaYsup=opt1$optlambdaYsup)
fit4
summary(fit4)

</code></pre>

<hr>
<h2 id='simdata'>Simulate Data sets</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p>This is a function for generating multiblock data based on the multivariable normal distribusion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata(n = 100, rho = 0.8, Yps = c(100, 120, 150), Xps = 500, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdata_+3A_n">n</code></td>
<td>
<p>a numeric scalar, sample size.</p>
</td></tr>
<tr><td><code id="simdata_+3A_rho">rho</code></td>
<td>
<p>a numeric scalar, correlation coefficient.</p>
</td></tr>
<tr><td><code id="simdata_+3A_yps">Yps</code></td>
<td>
<p>a numeric vector, numbers of columns for Y. The length of vector corresponds to the number of blocks.</p>
</td></tr>
<tr><td><code id="simdata_+3A_xps">Xps</code></td>
<td>
<p>a numeric vector, numbers of columns for X. The length of vector corresponds to the number of blocks.</p>
</td></tr>
<tr><td><code id="simdata_+3A_seed">seed</code></td>
<td>
<p>a seed number for generating random numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is a list of matrics.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Simulated X which has a list form</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Simulated Y which has a list form</p>
</td></tr>
</table>

<hr>
<h2 id='strsimdata'>Structured Simulate Data sets</h2><span id='topic+strsimdata'></span>

<h3>Description</h3>

<p>This is a function for generating multiblock data based on the multivariable normal distribusion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsimdata(
  n = 100,
  WX = NULL,
  ncomp = 5,
  Xps = 10,
  Yps = FALSE,
  rho = 0.8,
  Ztype = c("none", "binary", "prob")[1],
  cz = c(1, 1),
  cwx = c(0.1, 0.1),
  cwy = c(0.1, 0.1),
  seed = 1,
  minpct = 0.25,
  maxpct = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strsimdata_+3A_n">n</code></td>
<td>
<p>a numeric scalar, sample size.</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_wx">WX</code></td>
<td>
<p>a matrix or a list, weights.</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_ncomp">ncomp</code></td>
<td>
<p>number of components</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_xps">Xps</code></td>
<td>
<p>a numeric vector, numbers of columns for X. The length of vector corresponds to the number of blocks.</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_yps">Yps</code></td>
<td>
<p>a numeric vector, numbers of columns for Y. The length of vector corresponds to the number of blocks.</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_rho">rho</code></td>
<td>
<p>a numeric, correlation</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_ztype">Ztype</code></td>
<td>
<p>a character, outcome type (&quot;none&quot;, &quot;binary&quot;, &quot;prob&quot;).</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_cz">cz</code></td>
<td>
<p>a numeric vector, scale for outcome</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_cwx">cwx</code></td>
<td>
<p>a numeric vector, scale for weights of X</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_cwy">cwy</code></td>
<td>
<p>a numeric vector, scale for weights of Y</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_seed">seed</code></td>
<td>
<p>a seed number for generating random numbers.</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_minpct">minpct</code></td>
<td>
<p>minimum percent of nonzero</p>
</td></tr>
<tr><td><code id="strsimdata_+3A_maxpct">maxpct</code></td>
<td>
<p>maximum percent of nonzero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is a list of matrics.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>Simulated X which has a list form</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Simulated Y which has a list form</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Simulated Z which has a vector form</p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
</td></tr>
<tr><td><code>Xps</code></td>
<td>
</td></tr>
<tr><td><code>nZeroX</code></td>
<td>
</td></tr>
<tr><td><code>idxZeroX</code></td>
<td>
</td></tr>
<tr><td><code>Yps</code></td>
<td>
</td></tr>
<tr><td><code>nZeroY</code></td>
<td>
</td></tr>
<tr><td><code>idxZeroY</code></td>
<td>
</td></tr>
<tr><td><code>WX</code></td>
<td>
</td></tr>
<tr><td><code>WY</code></td>
<td>
</td></tr>
<tr><td><code>ZcoefX</code></td>
<td>
</td></tr>
<tr><td><code>ZcoefY</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='summary.msma'>Summarizing Fits</h2><span id='topic+summary.msma'></span><span id='topic+print.summary.msma'></span>

<h3>Description</h3>

<p>summary method for class &quot;msma&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msma'
summary(object, ...)

## S3 method for class 'summary.msma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.msma_+3A_object">object</code>, <code id="summary.msma_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>msma</code>&quot;, usually, a result of a call to <code><a href="#topic+msma">msma</a></code></p>
</td></tr>
<tr><td><code id="summary.msma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provide the summary of results .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### data #####
tmpdata = simdata(n = 50, rho = 0.8, Yps = c(10, 12, 15), Xps = 20, seed=1)
X = tmpdata$X; Y = tmpdata$Y 

##### One Component #####
fit1 = msma(X, Y, comp=1, lambdaX=2, lambdaY=1:3)
summary(fit1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
