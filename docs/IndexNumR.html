<!DOCTYPE html><html lang="en"><head><title>Help for package IndexNumR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IndexNumR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IndexNumR-package'><p>IndexNumR: A package for computing index numbers</p></a></li>
<li><a href='#CES_sigma_2'><p>Dataset of prices and quantities on four products</p></a></li>
<li><a href='#CESData'><p>Generate data assuming CES preferences</p></a></li>
<li><a href='#dominicksData'><p>Get data from the Dominicks dataset</p></a></li>
<li><a href='#DominicksWeeks'><p>Date information for the Dominicks data</p></a></li>
<li><a href='#elasticity'><p>Computes the elasticity of substitution</p></a></li>
<li><a href='#evaluateMatched'><p>Evaluate product overlap between periods</p></a></li>
<li><a href='#GEKSIndex'><p>Compute a GEKS multilateral index</p></a></li>
<li><a href='#GKIndex'><p>Compute the Geary-Khamis index</p></a></li>
<li><a href='#groupIndexes'><p>Calculate price indexes for product groups</p></a></li>
<li><a href='#imputeCarryPrices'><p>Fill all missing prices with carry forward/backward prices</p></a></li>
<li><a href='#imputeQuantities'><p>Impute quantities when only prices are available</p></a></li>
<li><a href='#maximumSimilarityLinks'><p>Finds periods to link using minimum dissimilarity.</p></a></li>
<li><a href='#mixScaleDissimilarity'><p>Computes mix, scale and absolute dissimilarity measures</p></a></li>
<li><a href='#monthIndex'><p>Generate an index of months</p></a></li>
<li><a href='#predictedShares'><p>Predicted shares for predicted share relative price dissimilarity</p></a></li>
<li><a href='#priceIndex'><p>Computes a bilateral price index</p></a></li>
<li><a href='#priceIndicator'><p>Calculate a price indicator</p></a></li>
<li><a href='#productChanges'><p>Product ID's for appearing/disappearing products</p></a></li>
<li><a href='#quantityIndex'><p>Computes a bilateral quantity index</p></a></li>
<li><a href='#quantityIndicator'><p>Compute a quantity indicator</p></a></li>
<li><a href='#quarterIndex'><p>Generate an index of quarters</p></a></li>
<li><a href='#relativeDissimilarity'><p>Computes measures of relative dissimilarity between all periods</p></a></li>
<li><a href='#shares'><p>Compute expenditure shares for each product and time period</p></a></li>
<li><a href='#unitValues'><p>Aggregates prices to unit values and quantities to sums</p></a></li>
<li><a href='#valueDecomposition'><p>valueDecomposition</p></a></li>
<li><a href='#values'><p>Compute values (price x quantity)</p></a></li>
<li><a href='#weekIndex'><p>Generate an index of weeks</p></a></li>
<li><a href='#WTPDIndex'><p>Compute a weighted time-product-dummy multilateral index</p></a></li>
<li><a href='#yearIndex'><p>Generate an index of years</p></a></li>
<li><a href='#yearOverYearIndexes'><p>Estimate year-over-year indexes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Index Number Calculation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Graham White</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Graham White &lt;g.white@unswalumni.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes bilateral and multilateral index numbers. 
    It has support for many standard bilateral indexes as well as
    multilateral index number methods such as GEKS, GEKS-Tornqvist 
    (or CCDI), Geary-Khamis and the weighted time product dummy
    (for details on these methods see Diewert and Fox (2020) 
    &lt;<a href="https://doi.org/10.1080%2F07350015.2020.1816176">doi:10.1080/07350015.2020.1816176</a>&gt;). 
    It also supports updating of multilateral indexes using 
    several splicing methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/grahamjwhite/IndexNumR">https://github.com/grahamjwhite/IndexNumR</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-10 10:59:13 UTC; Graham</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-10 23:33:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='IndexNumR-package'>IndexNumR: A package for computing index numbers</h2><span id='topic+IndexNumR'></span><span id='topic+IndexNumR-package'></span>

<h3>Description</h3>

<p>IndexNumR is a package for computing bilateral and multilateral index numbers.
The package has been designed with performance in mind, to enable computing
index numbers on large datasets within a reasonable timeframe. It also aims
to make a large number of index number methods available, along with access to datasets
to enable research and experimentation.
</p>


<h3>Author</h3>

<p>Graham White
</p>


<h3>Notes</h3>

<p>I'd like to thank all those that have commented on, or tested the code so that
it could be improved. In particular, I'd like to thank Professor Kevin
Fox at the University of New South Wales for his support and input.
</p>
<p>Some function parameters can have a considerable impact on the outputs, so it is
recommended that the user read the documentation for these functions carefully.
</p>


<h3>Vignettes</h3>

<p>There is very detailed information about the functions in the package vignette, which
can be accessed with,
</p>
<p><code>browseVignettes("IndexNumR")</code>.
</p>


<h3>Bilateral index functions</h3>

<p>Compute bilateral indexes
</p>

<ul>
<li> <p><code><a href="#topic+priceIndex">priceIndex</a></code>
</p>
</li>
<li> <p><code><a href="#topic+quantityIndex">quantityIndex</a></code>
</p>
</li></ul>



<h3>Similarity chain linking</h3>

<p>Compute dissimilarity measures or chain links.
</p>

<ul>
<li> <p><code><a href="#topic+relativeDissimilarity">relativeDissimilarity</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mixScaleDissimilarity">mixScaleDissimilarity</a></code>
</p>
</li>
<li> <p><code><a href="#topic+maximumSimilarityLinks">maximumSimilarityLinks</a></code>
</p>
</li></ul>



<h3>Multilateral index functions</h3>

<p>Compute multilateral indexes
</p>

<ul>
<li> <p><code><a href="#topic+GEKSIndex">GEKSIndex</a></code>
</p>
</li>
<li> <p><code><a href="#topic+GKIndex">GKIndex</a></code>
</p>
</li>
<li> <p><code><a href="#topic+WTPDIndex">WTPDIndex</a></code>
</p>
</li></ul>



<h3>Other index number functions</h3>


<ul>
<li><p><code><a href="#topic+groupIndexes">groupIndexes</a></code>
</p>
</li>
<li><p><code><a href="#topic+yearOverYearIndexes">yearOverYearIndexes</a></code>
</p>
</li></ul>



<h3>Data preparation functions</h3>

<p>Perform various operations on the data before
using other functions, such as index number functions.
</p>

<ul>
<li><p><code><a href="#topic+unitValues">unitValues</a></code>
</p>
</li>
<li><p><code><a href="#topic+imputeCarryPrices">imputeCarryPrices</a></code>
</p>
</li>
<li><p><code><a href="#topic+imputeQuantities">imputeQuantities</a></code>
</p>
</li></ul>



<h3>Data exploration functions</h3>

<p>Learn more about the characteristics of your dataset.
</p>

<ul>
<li><p><code><a href="#topic+evaluateMatched">evaluateMatched</a></code>
</p>
</li>
<li><p><code><a href="#topic+values">values</a></code>
</p>
</li></ul>



<h3>Sample data</h3>

<p>IndexNumR has one sample dataset,
</p>

<ul>
<li><p><code><a href="#topic+CES_sigma_2">CES_sigma_2</a></code>,
</p>
</li></ul>

<p>and a function for generating small datasets,
</p>

<ul>
<li><p><code><a href="#topic+CESData">CESData</a></code>,
</p>
</li></ul>

<p>and a function for accessing the Dominicks Finer Foods scanner data,
</p>

<ul>
<li><p><code><a href="#topic+dominicksData">dominicksData</a></code>.
</p>
</li></ul>



<h3>Differences approach to index numbers</h3>

<p>These functions are referred to as indicators, to distinguish them
from the bilateral and multilateral index functions which use the
ratio approach.
</p>

<ul>
<li><p><code><a href="#topic+priceIndicator">priceIndicator</a></code>
</p>
</li>
<li><p><code><a href="#topic+quantityIndicator">quantityIndicator</a></code>
</p>
</li></ul>



<h3>Time index functions</h3>

<p>Index functions in IndexNumR generally need a time period variable.
These functions will compute the required time period variable,
depending on the frequency required.
</p>

<ul>
<li><p><code><a href="#topic+weekIndex">weekIndex</a></code>
</p>
</li>
<li><p><code><a href="#topic+monthIndex">monthIndex</a></code>
</p>
</li>
<li><p><code><a href="#topic+quarterIndex">quarterIndex</a></code>
</p>
</li>
<li><p><code><a href="#topic+yearIndex">yearIndex</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/grahamjwhite/IndexNumR">https://github.com/grahamjwhite/IndexNumR</a>
</p>
</li></ul>


<hr>
<h2 id='CES_sigma_2'>Dataset of prices and quantities on four products</h2><span id='topic+CES_sigma_2'></span>

<h3>Description</h3>

<p>A constructed dataset containing the prices and quantities of
four products over a twelve month period, assuming CES preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CES_sigma_2
</code></pre>


<h3>Format</h3>

<p>A data frame with 48 rows and 4 columns:
</p>

<dl>
<dt>time</dt><dd><p>time period</p>
</dd>
<dt>prices</dt><dd><p>constructed prices</p>
</dd>
<dt>quantities</dt><dd><p>constructed quantities</p>
</dd>
<dt>prodID</dt><dd><p>product identifier</p>
</dd>
</dl>



<h3>Source</h3>

<p>Computed using procedure in W.E. Diewert and K.J. Fox (2017),
&quot;Substitution Bias in Multilateral Methods for CPI Construction Using
Scanner Data&quot;, Discussion Paper 17-02, Vancouver School of Economics,
The University of British Columbia.
</p>

<hr>
<h2 id='CESData'>Generate data assuming CES preferences</h2><span id='topic+CESData'></span>

<h3>Description</h3>

<p>This function is useful for generating datasets that can be used for
testing where the 'true' price index is known. The data are constructed
using assumed prices and total expenditure in each period. Expenditure
shares and quantities are then computed assuming CES preferences. For
further details, see the references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CESData(sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CESData_+3A_sigma">sigma</code></td>
<td>
<p>the elasticity of substitution parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing time period, prices, quantities and
product identifier.
</p>


<h3>References</h3>

<p>W.E. Diewert and K.J. Fox (2017),
&quot;Substitution Bias in Multilateral Methods for CPI Construction Using
Scanner Data&quot;, Discussion Paper 17-02, Vancouver School of Economics,
The University of British Columbia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate data assuming the elasticity of substitution is 2
CESData(2)

## End(Not run)
</code></pre>

<hr>
<h2 id='dominicksData'>Get data from the Dominicks dataset</h2><span id='topic+dominicksData'></span>

<h3>Description</h3>

<p>The Dominicks Scanner data, provided by the University of Chicago Booth School of Business,
contains around 5 years of product-level
data from over 100 stores, collected from 1989-1994. The data consist
of a UPC file that contains information on the products, and a
movement file that contains the information on prices and sales. For
a complete description of the data, see
<a href="https://www.chicagobooth.edu/research/kilts/research-data/dominicks">Dominicks data website</a>
and the
<a href="https://www.chicagobooth.edu/-/media/enterprise/centers/kilts/datasets/dominicks-dataset/dominicks-manual-and-codebook_kiltscenter">Dominicks data user manual</a>.
This function downloads and merges the movement and UPC files, then merges the
result with data detailing the dates of each of the weeks in the movement file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominicksData(x, movementcsv = NULL, UPCcsv = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dominicksData_+3A_x">x</code></td>
<td>
<p>the name of the category to retrieve, see details for list.</p>
</td></tr>
<tr><td><code id="dominicksData_+3A_movementcsv">movementcsv</code></td>
<td>
<p>the path to the movement csv file for one product category. The default is NULL,
which downloads the file from the website.</p>
</td></tr>
<tr><td><code id="dominicksData_+3A_upccsv">UPCcsv</code></td>
<td>
<p>the path to the UPC csv file for one product category. The default is NULL,
which downloads the file from the website.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following transformations are performed on the data:
</p>

<ul>
<li><p> The quantity variable is set to MOVE, which is the number of individual units sold
</p>
</li>
<li><p> The price variable is set to PRICE/QTY, which is the unit price. This accounts
for the fact that sometimes products are sold in bundles (e.g., two-for-one promotions).
</p>
</li>
<li><p> expenditure is given by PRICE*MOVE/QTY.
</p>
</li>
<li><p> All observations where the variable OK equals 0, or price is less than or equal to 0, are dropped.
</p>
</li></ul>

<p>If you have already downloaded the movement and UPC csv files for a category from
the website, then you can pass the file paths of those files to the function
and just have it combine them with the weeks dataset. The default is to download
the files for you from the website.
</p>
<p>The products available are:
</p>

<ul>
<li><p> Analgesics
</p>
</li>
<li><p> Bath Soap
</p>
</li>
<li><p> Beer
</p>
</li>
<li><p> Bottled Juices
</p>
</li>
<li><p> Cereals
</p>
</li>
<li><p> Cheeses
</p>
</li>
<li><p> Cigarettes
</p>
</li>
<li><p> Cookies
</p>
</li>
<li><p> Crackers
</p>
</li>
<li><p> Canned Soup
</p>
</li>
<li><p> Dish Detergent
</p>
</li>
<li><p> Front-end-candies
</p>
</li>
<li><p> Frozen Dinners
</p>
</li>
<li><p> Frozen Entrees
</p>
</li>
<li><p> Frozen Juices
</p>
</li>
<li><p> Fabric Softeners
</p>
</li>
<li><p> Grooming Products
</p>
</li>
<li><p> Laundry Detergents
</p>
</li>
<li><p> Oatmeal
</p>
</li>
<li><p> Paper Towels
</p>
</li>
<li><p> Refrigerated Juices (not currently available)
</p>
</li>
<li><p> Soft Drinks
</p>
</li>
<li><p> Shampoos
</p>
</li>
<li><p> Snack Crackers
</p>
</li>
<li><p> Soaps
</p>
</li>
<li><p> Toothbrushes
</p>
</li>
<li><p> Canned Tuna
</p>
</li>
<li><p> Toothpastes
</p>
</li>
<li><p> Bathroom Tissues
</p>
</li></ul>



<h3>References</h3>

<p>James M. Kilts Center, University of Chicago Booth School of Business
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
analgesics &lt;- dominicksData("Analgesics")

## End(Not run)
</code></pre>

<hr>
<h2 id='DominicksWeeks'>Date information for the Dominicks data</h2><span id='topic+DominicksWeeks'></span>

<h3>Description</h3>

<p>Table from the <a href="https://www.chicagobooth.edu/-/media/enterprise/centers/kilts/datasets/dominicks-dataset/dominicks-manual-and-codebook_kiltscenter">Dominicks Data Manual</a>,
that gives the start and end date of each of the weeks in the movement
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DominicksWeeks
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 4 columns:
</p>

<dl>
<dt>week</dt><dd><p>the number of the week</p>
</dd>
<dt>start</dt><dd><p>date the week started</p>
</dd>
<dt>end</dt><dd><p>date the week ended</p>
</dd>
<dt>specialEvents</dt><dd><p>special events, such as Halloween, that occurred during the week</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dominicks Data Manual, Chicago Booth Kilts Center for Marketing, 2018, pages 21-28.
</p>

<hr>
<h2 id='elasticity'>Computes the elasticity of substitution</h2><span id='topic+elasticity'></span>

<h3>Description</h3>

<p>A function to estimate the elasticity of substitution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elasticity(
  x,
  pvar,
  qvar,
  pervar,
  prodID,
  compIndex = "ces",
  lower = -20,
  upper = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elasticity_+3A_x">x</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="elasticity_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="elasticity_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="elasticity_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="elasticity_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="elasticity_+3A_compindex">compIndex</code></td>
<td>
<p>The index number with which the CES index will be equated
to calculate the elasticity. Acceptable options are lloydmoulton, fisher
or satovartia. The lloydmoulton option equates the 'base period' lloyd-moulton
index with the 'current period' lloyd-moulton index.</p>
</td></tr>
<tr><td><code id="elasticity_+3A_lower">lower</code></td>
<td>
<p>lower limit to search for sigma.</p>
</td></tr>
<tr><td><code id="elasticity_+3A_upper">upper</code></td>
<td>
<p>upper limit to search for sigma.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements: sigma (the average elasticity
over all time periods); allsigma (a T-1 by 1 matrix of the estimated
elasticities for each time period, except period one); and diff
(the value of the difference between the two indexes, check this is zero
for all time periods).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elasticity(CES_sigma_2,pvar="prices",qvar="quantities",pervar="time",
prodID = "prodID")
</code></pre>

<hr>
<h2 id='evaluateMatched'>Evaluate product overlap between periods</h2><span id='topic+evaluateMatched'></span>

<h3>Description</h3>

<p>Evaluate the counts and expenditure for each period with and without
matching items across periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateMatched(x, pvar, qvar, pervar, prodID, output = "chained")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluateMatched_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="evaluateMatched_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="evaluateMatched_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="evaluateMatched_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="evaluateMatched_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="evaluateMatched_+3A_output">output</code></td>
<td>
<p>A character string specifying whether the matching should be
done assuming a chained index or a fixed base index. No index is actually computed,
but the matching needs to know which periods are being compared. Default is chained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two matrices, one for expenditures and one for counts.
The first four columns present the base period information
base_index (the base time period), base (base period expenditure or count),
base_matched (the expenditure or count of the base period after matching),
base_share (share of total expenditure in the base period that remains after
matching). Columns 5-8 are defined analogously for the current period. The matched
numbers for the base period should be interpreted as the count or expenditure
that remains after removal of products that exist in the base period, but not
in the current period. That is, products that existed in the base period but no
longer exist in the current period are removed by the matching. If new products
exist in the current period that were not available in the base period, this
does not affect the matched base period expenditure or count. The appearance
of new products is captured in the current period matched expenditure and counts.
Therefore, a base period share that is less than 1 indicates that products have
disappeared, while a current period share less than 1 indicates that new products
have appeared.
</p>
<p>The count matrix has two additional columns, &quot;new&quot; and &quot;leaving&quot;. The new column
gives the number of products that exist in the current period but not the base period.
The leaving column gives the count of products that exist in the base period
but not the current period. Matching removes both of these types of products.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create CES_sigma_2 dataset removing the observation in time period 4
# on product 1
df &lt;- CES_sigma_2[!(CES_sigma_2$time==4 &amp; CES_sigma_2$prodID==1),]
# evaluate the overlap between periods for this dataset assuming
# a chained index
evaluateMatched(df, pvar="prices", qvar="quantities", pervar="time",
prodID = "prodID", output="chained")
</code></pre>

<hr>
<h2 id='GEKSIndex'>Compute a GEKS multilateral index</h2><span id='topic+GEKSIndex'></span>

<h3>Description</h3>

<p>A function to calculate a GEKS multilateral price index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEKSIndex(
  x,
  pvar,
  qvar,
  pervar,
  indexMethod = "tornqvist",
  prodID,
  sample = "matched",
  window = 13,
  splice = "mean",
  biasAdjust = FALSE,
  weights = "average",
  intGEKS = FALSE,
  imputePrices = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GEKSIndex_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_indexmethod">indexMethod</code></td>
<td>
<p>A character string to select the index number method. Valid index
number methods are fisher, tornqvist, tpd, jevons or walsh. The default is tornqvist.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_sample">sample</code></td>
<td>
<p>A character string specifying whether matching is to be performed.
The default is to use matching.
If sample=matched then any products that are not present in comparison periods
are removed prior to estimating the index for those periods.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_window">window</code></td>
<td>
<p>An integer specifying the length of the window.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_splice">splice</code></td>
<td>
<p>A character string specifying the splicing method. Valid methods are
window, movement, half, mean, fbew or fbmw, wisp, hasp or mean_pub. The default is mean.
See details for important considerations when using fbew and fbmw.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_biasadjust">biasAdjust</code></td>
<td>
<p>whether to adjust for bias in the coefficients of the bilateral TPD index.
The default is FALSE because making this adjustment will break transitivity of the
GEKS index.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_weights">weights</code></td>
<td>
<p>the type of weighting for the bilateral TPD index. Options are
&quot;unweighted&quot; to use ordinary least squares, &quot;shares&quot; to use weighted least squares
with expenditure share weights, and &quot;average&quot; to use weighted least squares
with the average of the expenditure shares over the two periods. See details for more
information</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_intgeks">intGEKS</code></td>
<td>
<p>whether to estimate the intersection GEKS method. This method performs
additional product matching over the sample = &quot;matched&quot; option. See Lamboray and Krsinich
2015 for more information.</p>
</td></tr>
<tr><td><code id="GEKSIndex_+3A_imputeprices">imputePrices</code></td>
<td>
<p>the type of price imputation to use for missing prices.
Currently only &quot;carry&quot; is supported to used carry-forward/carry-backward prices.
Default is NULL to not impute missing prices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The splicing methods are used to update the price index when new data become
available without changing prior index values. The window, movement, half and mean splices
use the most recent index value as the base period, which is multiplied by a price movement
computed using new data. The fbew (Fixed Base Expanding Window) and fbmw (Fixed Base Moving
Window) use a fixed base onto which the price movement using new data is applied. The base
period is updated periodically. IndexNumR calculates which periods are the base periods using
<code>seq(from = 1, to = n, by = window - 1)</code>, so the data must be set up correctly and the
right window length chosen. For example, if you have monthly data and want December
of each year to be the base period, then the first period in the data must be December
and the window must be set to 13.
</p>


<h3>References</h3>

<p>Ivancic, L., W.E. Diewert and K.J. Fox (2011), &quot;Scanner Data,
Time Aggregation and the Construction of Price Indexes&quot;, Journal of
Econometrics 161, 24-35.
</p>
<p>Lamboray, C. and F. Krsinich (2015), &quot;A Modification of the GEKS Index When
Product Turnover is High&quot;, Paper presented at the fourteenth Ottawa Group
meeting, 20-22 May 2015, Tokyo, Japan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a GEKS mutlilateral index with mean splicing
GEKSIndex(CES_sigma_2, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", indexMethod = "tornqvist", window=11, splice = "mean")

# compute a GEKS multilateral index with window splicing and the Fisher index method
GEKSIndex(CES_sigma_2, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", indexMethod = "fisher", window=11, splice = "mean")

</code></pre>

<hr>
<h2 id='GKIndex'>Compute the Geary-Khamis index</h2><span id='topic+GKIndex'></span>

<h3>Description</h3>

<p>Compute the Geary-Khamis index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GKIndex(
  x,
  pvar,
  qvar,
  pervar,
  prodID,
  sample = "",
  window,
  splice = "mean",
  imputePrices = NULL,
  solveMethod = "inverse",
  tolerance = 1/1000000000000,
  maxIter = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GKIndex_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_sample">sample</code></td>
<td>
<p>set to &quot;matched&quot; to only use products that occur
across all periods in a given window. Default is not to match.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_window">window</code></td>
<td>
<p>An integer specifying the length of the window.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_splice">splice</code></td>
<td>
<p>the splicing method to use to extend the index. Valid methods are
window, movement, half, mean, fbew, fbmw, wisp, hasp or mean_pub. The default is mean.
See details for important considerations when using fbew and fbmw.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_imputeprices">imputePrices</code></td>
<td>
<p>the type of price imputation to use for missing prices.
Currently only &quot;carry&quot; is supported to used carry-forward/carry-backward prices.
Default is NULL to not impute missing prices.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_solvemethod">solveMethod</code></td>
<td>
<p>the method to use to solve for the quality adjustment factors
and the price levels. &quot;inverse&quot; uses a matrix inverse operation, is much more efficient, but
may not work if there are many missing observations.
&quot;iterative&quot; iterates between the equations for the quality adjustment factors and price levels
and is much slower, but can be used even when there are a large number of missing observations.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_tolerance">tolerance</code></td>
<td>
<p>the tolerance for the iterative solving method. Smaller numbers will produce more
accurate results, but take more iterations. Default is 1/1e12, which may be a little larger
than machine precision, given by .Machine$double.eps.</p>
</td></tr>
<tr><td><code id="GKIndex_+3A_maxiter">maxIter</code></td>
<td>
<p>the maximum number of iterations for the iterative solving method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The splicing methods are used to update the price index when new data become
available without changing prior index values. The window, movement, half and mean splices
use the most recent index value as the base period, which is multiplied by a price movement
computed using new data. The fbew (Fixed Base Expanding Window) and fbmw (Fixed Base Moving
Window) use a fixed base onto which the price movement using new data is applied. The base
period is updated periodically. IndexNumR calculates which periods are the base periods using
<code>seq(from = 1, to = n, by = window - 1)</code>, so the data must be set up correctly and the
right window length chosen. For example, if you have monthly data and want December
of each year to be the base period, then the first period in the data must be December
and the window must be set to 13.
</p>
<p>It is recommended to use the matrix inverse method of solving the GK equations (the default)
because the performance difference can be significant. If the matrix inverse method does
not work then switch to the iterative method. The tolerance and maximum number of iterations
in the iterative method can be adjusted to balance performance and precision.
</p>


<h3>References</h3>

<p>Ivancic, L., W.E. Diewert and K.J. Fox (2011), &quot;Scanner Data,
Time Aggregation and the Construction of Price Indexes&quot;, Journal of
Econometrics 161, 24-35.
</p>
<p>Geary, R. G. 1958. “A Note on Comparisons of Exchange Rates and Purchasing Power Between
Countries.” Journal of the Royal Statistical Society Series A 121: 97–99.
</p>
<p>Khamis, S. H. 1970. “Properties and Conditions for the Existence of a New Type of Index Number.”
Sankhya: The Indian Journal of Statistics, Series B (1960-2002) 32: 81–98.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a Geary-Khamis index with mean splicing
GKIndex(CES_sigma_2, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", window=11, splice = "mean")
</code></pre>

<hr>
<h2 id='groupIndexes'>Calculate price indexes for product groups</h2><span id='topic+groupIndexes'></span>

<h3>Description</h3>

<p>Calculate price indexes for product groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupIndexes(group, indexFunction, indexArgs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupIndexes_+3A_group">group</code></td>
<td>
<p>the name of the variable containing the group ID. This
must be a factor variable, or a variable coercible to a factor.</p>
</td></tr>
<tr><td><code id="groupIndexes_+3A_indexfunction">indexFunction</code></td>
<td>
<p>the name of the function to use to calculate the
index as a string. Available options are 'priceIndex', 'GEKSIndex',
'GKIndex', 'WTPDIndex'.</p>
</td></tr>
<tr><td><code id="groupIndexes_+3A_indexargs">indexArgs</code></td>
<td>
<p>arguments for the price index function as a named list.
All arguments must be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of indexes, one for each group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- CES_sigma_2
df$groupID &lt;- c(rep(1, 24), rep(2, 24))

argsList &lt;- list(x = df, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", indexMethod = "fisher", output = "chained")

groupIndexes("groupID", "priceIndex", argsList)

</code></pre>

<hr>
<h2 id='imputeCarryPrices'>Fill all missing prices with carry forward/backward prices</h2><span id='topic+imputeCarryPrices'></span>

<h3>Description</h3>

<p>If a missing product has a previous price then that previous price
is carried forward until the next real observation. If there is
no previous price then the next real observation is found and
carried backward. If a price observation is filled, and a quantity
variable is specified, then the corresponding quantity is set to zero.
Prices can be filled with no quantity variable by specifying
qvar = &quot;&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeCarryPrices(x, pvar, qvar, pervar, prodID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeCarryPrices_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="imputeCarryPrices_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="imputeCarryPrices_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable.
If there is no quantity variable you must specify qvar = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="imputeCarryPrices_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="imputeCarryPrices_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input data frame with missing observations filled
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a dataset with missing prices for products 1 and 2
df &lt;- CES_sigma_2[-c(1,2,14,15),]
imputeCarryPrices(df, "prices", "quantities", "time", "prodID")
</code></pre>

<hr>
<h2 id='imputeQuantities'>Impute quantities when only prices are available</h2><span id='topic+imputeQuantities'></span>

<h3>Description</h3>

<p>This procedure calculates quantities in such a way that
the expenditure shares on all products are equal in each
period. It is used to compute quantities for the predicted
share measure of relative price dissimilarity when there are
none available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeQuantities(x, pvar, pervar, prodID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeQuantities_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="imputeQuantities_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="imputeQuantities_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="imputeQuantities_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
</table>

<hr>
<h2 id='maximumSimilarityLinks'>Finds periods to link using minimum dissimilarity.</h2><span id='topic+maximumSimilarityLinks'></span>

<h3>Description</h3>

<p>Function to compute the maximum similarity chain links from
a measure of dissimilarity. The procedure works as described in
Diewert and Fox (2017). It first links period 2 to period 1.
Then for each period t, from periods 3,...,T it searches
among the periods 1,...,t-1 for the period that is most
similar (least dissimilar) to period t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximumSimilarityLinks(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maximumSimilarityLinks_+3A_x">x</code></td>
<td>
<p>a matrix containing a dissimilarity measure where
the first two columns are the indices and the third column
is the dissimilarity measure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># find the linking periods in the CES_sigma_2 dataset that maximise
# the similarity between periods, using the absolute dissimilarity measure.
disMat &lt;- mixScaleDissimilarity(CES_sigma_2, pvar = "prices", qvar = "quantities",
pervar = "time", prodID = "prodID", measure = "absolute",
combine = "geomean")
maximumSimilarityLinks(disMat)
</code></pre>

<hr>
<h2 id='mixScaleDissimilarity'>Computes mix, scale and absolute dissimilarity measures</h2><span id='topic+mixScaleDissimilarity'></span>

<h3>Description</h3>

<p>This is a function to compute the Fox, Hill and Diewert 2004
dissimilarity measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixScaleDissimilarity(
  x,
  pvar,
  qvar,
  prodID,
  pervar,
  measure = "absolute",
  combine = "geomean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixScaleDissimilarity_+3A_x">x</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="mixScaleDissimilarity_+3A_pvar">pvar</code></td>
<td>
<p>string identifying the price variable in x</p>
</td></tr>
<tr><td><code id="mixScaleDissimilarity_+3A_qvar">qvar</code></td>
<td>
<p>string identifying the quantity variable in x</p>
</td></tr>
<tr><td><code id="mixScaleDissimilarity_+3A_prodid">prodID</code></td>
<td>
<p>string identifying the product id variable in x</p>
</td></tr>
<tr><td><code id="mixScaleDissimilarity_+3A_pervar">pervar</code></td>
<td>
<p>string identifying the time period variable in x</p>
</td></tr>
<tr><td><code id="mixScaleDissimilarity_+3A_measure">measure</code></td>
<td>
<p>choice of dissimilarity measure. Valid options
are mix, scale or absolute.</p>
</td></tr>
<tr><td><code id="mixScaleDissimilarity_+3A_combine">combine</code></td>
<td>
<p>specifies how to combine the price and quantity vectors.
&quot;stack&quot; stacks the price and quantity vectors, &quot;geomean&quot; computes
separate dissimilarity measures for prices and quantities then takes
the geometric mean of these.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where the first two columns are the possible combinations
of periods and the third column is the dissimilarity measure.
</p>


<h3>References</h3>

<p>Fox, K.J., R.J. Hill and W.E. Diewert (2004),
&quot;Identifying outliers in multi-output models&quot;, Journal of
Productivity Analysis, 22, 73-94, 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># estimate the dissimilarity between periods in the CES_sigma_2 dataset
# using the absolute measure of dissimilarity and the geometric mean
# to combine price and quantity information.
mixScaleDissimilarity(CES_sigma_2, pvar = "prices", qvar = "quantities",
pervar = "time", prodID = "prodID", measure = "absolute",
combine = "geomean")
</code></pre>

<hr>
<h2 id='monthIndex'>Generate an index of months</h2><span id='topic+monthIndex'></span>

<h3>Description</h3>

<p>A function to create a month index variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthIndex(x, overlapWeeks = "naive")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monthIndex_+3A_x">x</code></td>
<td>
<p>A vector or column of dates</p>
</td></tr>
<tr><td><code id="monthIndex_+3A_overlapweeks">overlapWeeks</code></td>
<td>
<p>Tells monthIndex how to deal with weeks that
cross over two adjacent months. Options are &quot;naive&quot;, &quot;majority&quot;, &quot;wholeOnly&quot; or &quot;fourWeek&quot;.
&quot;naive&quot; simply takes the month number of the observation, ignoring where
the week of that observation falls. &quot;majority&quot; will allocate the observation
to the month that owns the majority of days in that week, assuming
that Monday is day one of the week. &quot;fourWeek&quot; first calculates a week index,
then calculates the month index assuming that there are four weeks in each month.
&quot;wholeOnly&quot; will return NA for any dates falling inside a week that overlaps two
adjacent months; that is, only weeks that are wholly within a month
are given an index value. The default is &quot;naive&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># given a vector of dates
df &lt;- data.frame(date = as.Date(c("2017-01-01","2017-02-01","2017-03-01","2017-04-01"),
format = "%Y-%m-%d"))
# calculate the time period variable
df$period &lt;- monthIndex(df$date, overlapWeeks = "naive")
df
</code></pre>

<hr>
<h2 id='predictedShares'>Predicted shares for predicted share relative price dissimilarity</h2><span id='topic+predictedShares'></span>

<h3>Description</h3>

<p>You should not need to call this function directly unless the shares
themselves are of interest. Other functions will call this function internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictedShares(x, pvar, qvar, pervar, prodID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictedShares_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="predictedShares_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="predictedShares_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable. For
elementary indexes a quantity variable is not required for the calculations
and you must specify qvar = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="predictedShares_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="predictedShares_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of matrices
</p>

<hr>
<h2 id='priceIndex'>Computes a bilateral price index</h2><span id='topic+priceIndex'></span>

<h3>Description</h3>

<p>A function to compute a price index given data on products over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priceIndex(
  x,
  pvar,
  qvar,
  pervar,
  indexMethod = "laspeyres",
  prodID,
  sample = "matched",
  output = "pop",
  chainMethod = "pop",
  sigma = 1.0001,
  basePeriod = 1,
  biasAdjust = TRUE,
  weights = "average",
  loweYoungBase = 1,
  imputePrices = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="priceIndex_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable. For
elementary indexes a quantity variable is not required for the calculations
and you must specify qvar = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_indexmethod">indexMethod</code></td>
<td>
<p>A character string to select the index number method. Valid index
number methods are dutot, carli, jevons, laspeyres, paasche, fisher, cswd,
harmonic, tornqvist, satovartia, walsh, CES, geomLaspeyres, geomPaasche, tpd,
Geary-Khamis (gk), drobish, palgrave, stuvel, marshalledgeworth.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_sample">sample</code></td>
<td>
<p>A character string specifying whether a matched sample
should be used.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_output">output</code></td>
<td>
<p>A character string specifying whether a chained (output=&quot;chained&quot;)
, fixed base (output=&quot;fixedbase&quot;) or period-on-period (output=&quot;pop&quot;)
price index numbers should be returned. Default is period-on-period.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_chainmethod">chainMethod</code></td>
<td>
<p>A character string specifying the method of chain linking
to use if the output option is set to &quot;chained&quot;.
Valid options are &quot;pop&quot; for period-on-period, and similarity chain linked
options &quot;plspread&quot; for the Paasche-Laspeyres spread, &quot;asymplinear&quot; for
weighted asymptotically linear, &quot;logquadratic&quot; for the weighted log-quadratic,
and &quot;mixScale&quot; for the mix, scale or absolute dissimilarity measures,
or &quot;predictedshare&quot; for the predicted share relative price dissimilarity.
The default is period-on-period. Additional parameters can be passed to the
mixScaleDissimilarity function using <code>...</code></p>
</td></tr>
<tr><td><code id="priceIndex_+3A_sigma">sigma</code></td>
<td>
<p>The elasticity of substitution for the CES index method.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_baseperiod">basePeriod</code></td>
<td>
<p>The period to be used as the base when 'fixedbase' output is
chosen. Default is 1 (the first period).</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_biasadjust">biasAdjust</code></td>
<td>
<p>whether to adjust for bias in the coefficients in the bilateral
TPD index. The default is TRUE.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_weights">weights</code></td>
<td>
<p>the type of weighting for the bilateral TPD index. Options are
&quot;unweighted&quot; to use ordinary least squares, &quot;shares&quot; to use weighted least squares
with expenditure share weights, and &quot;average&quot; to use weighted least squares
with the average of the expenditure shares over the two periods.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_loweyoungbase">loweYoungBase</code></td>
<td>
<p>the period used as the base for the lowe or
young type indexes. The default is period 1. This can be a vector of values to
use multiple periods. For example, if the data are monthly and start in January, specifying
1:12 will use the first twelve months as the base.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_imputeprices">imputePrices</code></td>
<td>
<p>the type of price imputation to use for missing prices.
Currently only &quot;carry&quot; is supported to used carry-forward/carry-backward prices.
Default is NULL to not impute missing prices.</p>
</td></tr>
<tr><td><code id="priceIndex_+3A_...">...</code></td>
<td>
<p>this is used to pass additional parameters to the mixScaleDissimilarity
function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># period-on-period Laspeyres index for the CES_sigma_2 dataset
priceIndex(CES_sigma_2, pvar="prices", qvar="quantities", pervar="time",
prodID = "prodID", indexMethod = "laspeyres")

# chained Fisher index
priceIndex(CES_sigma_2, pvar="prices", qvar="quantities", pervar="time",
prodID = "prodID", indexMethod = "fisher", output="chained")

# chained Tornqvist index, with linking periods chosen by the
# weighted log-quadratic dissimilarity measure
priceIndex(CES_sigma_2, pvar="prices", qvar="quantities", pervar="time",
prodID = "prodID", indexMethod = "tornqvist", output="chained",
chainMethod = "logquadratic")
</code></pre>

<hr>
<h2 id='priceIndicator'>Calculate a price indicator</h2><span id='topic+priceIndicator'></span>

<h3>Description</h3>

<p>This calculates a price indicator. This is calculated using the
differences approach to index number theory, where the change
in prices and quantities from one period to the next is additive.
Therefore, the change in total value is the sum of the change
in prices and the change in quantities. Such a value decomposition
can be obtained using <code>valueDecomposition</code>.
</p>
<p>See the vignette for more information on the calculations.
</p>
<p><code>vignette(topic = "indexnumr", package = "IndexNumR")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priceIndicator(x, pvar, qvar, pervar, prodID, method, sample = "matched")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="priceIndicator_+3A_x">x</code></td>
<td>
<p>data frame with input data</p>
</td></tr>
<tr><td><code id="priceIndicator_+3A_pvar">pvar</code></td>
<td>
<p>character string for the name of the price column</p>
</td></tr>
<tr><td><code id="priceIndicator_+3A_qvar">qvar</code></td>
<td>
<p>character string for the name of the quantity column</p>
</td></tr>
<tr><td><code id="priceIndicator_+3A_pervar">pervar</code></td>
<td>
<p>character string for the name of the time period variable</p>
</td></tr>
<tr><td><code id="priceIndicator_+3A_prodid">prodID</code></td>
<td>
<p>character string for the name of the product ID column</p>
</td></tr>
<tr><td><code id="priceIndicator_+3A_method">method</code></td>
<td>
<p>character string for the indicator method. Valid options
are &quot;laspeyres&quot;, &quot;paasche&quot;, &quot;bennet&quot;, or &quot;montgomery&quot;.</p>
</td></tr>
<tr><td><code id="priceIndicator_+3A_sample">sample</code></td>
<td>
<p>whether to use a matched sample (sample = &quot;matched&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an nx1 matrix containing the indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a price indicator using the Montgomery method
priceIndicator(CES_sigma_2, pvar = "prices", qvar = "quantities",
prodID = "prodID", pervar = "time", method = "montgomery")
</code></pre>

<hr>
<h2 id='productChanges'>Product ID's for appearing/disappearing products</h2><span id='topic+productChanges'></span>

<h3>Description</h3>

<p>This function will give the product ID's of products that appear
or disappear in each period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>productChanges(x, pervar, prodID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="productChanges_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="productChanges_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="productChanges_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one element for each time period, each element of
which contains two vectors (one for appearing products, and one for disappearing products)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a dataset with some missing products
df &lt;- CES_sigma_2[-c(3,4,15),]

# show the products that changed
productChanges(df, "time", "prodID")

</code></pre>

<hr>
<h2 id='quantityIndex'>Computes a bilateral quantity index</h2><span id='topic+quantityIndex'></span>

<h3>Description</h3>

<p>A function to compute a quantity index given data on products over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantityIndex(
  x,
  pvar,
  qvar,
  pervar,
  indexMethod = "laspeyres",
  prodID,
  sample = "matched",
  output = "pop",
  chainMethod = "pop",
  sigma = 1.0001,
  basePeriod = 1,
  biasAdjust = TRUE,
  weights = "average",
  loweYoungBase = 1,
  imputePrices = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantityIndex_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable. For
elementary indexes a quantity variable is not required for the calculations
and you must specify qvar = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_indexmethod">indexMethod</code></td>
<td>
<p>A character string to select the index number method. Valid index
number methods are dutot, carli, jevons, laspeyres, paasche, fisher, cswd,
harmonic, tornqvist, satovartia, walsh, CES, geomLaspeyres, geomPaasche, tpd,
Geary-Khamis (gk), drobish, palgrave, stuvel, marshalledgeworth.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_sample">sample</code></td>
<td>
<p>A character string specifying whether a matched sample
should be used.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_output">output</code></td>
<td>
<p>A character string specifying whether a chained (output=&quot;chained&quot;)
, fixed base (output=&quot;fixedbase&quot;) or period-on-period (output=&quot;pop&quot;)
price index numbers should be returned. Default is period-on-period.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_chainmethod">chainMethod</code></td>
<td>
<p>A character string specifying the method of chain linking
to use if the output option is set to &quot;chained&quot;.
Valid options are &quot;pop&quot; for period-on-period, and similarity chain linked
options &quot;plspread&quot; for the Paasche-Laspeyres spread, &quot;asymplinear&quot; for
weighted asymptotically linear, &quot;logquadratic&quot; for the weighted log-quadratic,
and &quot;mixScale&quot; for the mix, scale or absolute dissimilarity measures,
or &quot;predictedshare&quot; for the predicted share relative price dissimilarity.
The default is period-on-period. Additional parameters can be passed to the
mixScaleDissimilarity function using <code>...</code></p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_sigma">sigma</code></td>
<td>
<p>The elasticity of substitution for the CES index method.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_baseperiod">basePeriod</code></td>
<td>
<p>The period to be used as the base when 'fixedbase' output is
chosen. Default is 1 (the first period).</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_biasadjust">biasAdjust</code></td>
<td>
<p>whether to adjust for bias in the coefficients in the bilateral
TPD index. The default is TRUE.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_weights">weights</code></td>
<td>
<p>the type of weighting for the bilateral TPD index. Options are
&quot;unweighted&quot; to use ordinary least squares, &quot;shares&quot; to use weighted least squares
with expenditure share weights, and &quot;average&quot; to use weighted least squares
with the average of the expenditure shares over the two periods.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_loweyoungbase">loweYoungBase</code></td>
<td>
<p>the period used as the base for the lowe or
young type indexes. The default is period 1. This can be a vector of values to
use multiple periods. For example, if the data are monthly and start in January, specifying
1:12 will use the first twelve months as the base.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_imputeprices">imputePrices</code></td>
<td>
<p>the type of price imputation to use for missing prices.
Currently only &quot;carry&quot; is supported to used carry-forward/carry-backward prices.
Default is NULL to not impute missing prices.</p>
</td></tr>
<tr><td><code id="quantityIndex_+3A_...">...</code></td>
<td>
<p>this is used to pass additional parameters to the mixScaleDissimilarity
function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># chained Fisher quantity index for the CES_sigma_2 dataset
quantityIndex(CES_sigma_2, pvar="prices", qvar="quantities", pervar="time",
prodID = "prodID", indexMethod = "fisher", output="chained")
</code></pre>

<hr>
<h2 id='quantityIndicator'>Compute a quantity indicator</h2><span id='topic+quantityIndicator'></span>

<h3>Description</h3>

<p>This calculates a quantity indicator. This is calculated using the
differences approach to index number theory, where the change
in prices and quantities from one period to the next is additive.
Therefore, the change in total value is the sum of the change
in prices and the change in quantities. Such a value decomposition
can be obtained using <code>valueDecomposition</code>.
</p>
<p>See the vignette for more information on the calculations.
</p>
<p><code>vignette(topic = "indexnumr", package = "IndexNumR")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantityIndicator(x, pvar, qvar, pervar, prodID, method, sample = "matched")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantityIndicator_+3A_x">x</code></td>
<td>
<p>data frame with input data</p>
</td></tr>
<tr><td><code id="quantityIndicator_+3A_pvar">pvar</code></td>
<td>
<p>character string for the name of the price column</p>
</td></tr>
<tr><td><code id="quantityIndicator_+3A_qvar">qvar</code></td>
<td>
<p>character string for the name of the quantity column</p>
</td></tr>
<tr><td><code id="quantityIndicator_+3A_pervar">pervar</code></td>
<td>
<p>character string for the name of the time period variable</p>
</td></tr>
<tr><td><code id="quantityIndicator_+3A_prodid">prodID</code></td>
<td>
<p>character string for the name of the product ID column</p>
</td></tr>
<tr><td><code id="quantityIndicator_+3A_method">method</code></td>
<td>
<p>character string for the quantity indicator method. Valid options
are &quot;laspeyres&quot;, &quot;paasche&quot;, &quot;bennet&quot;, or &quot;montgomery&quot;.</p>
</td></tr>
<tr><td><code id="quantityIndicator_+3A_sample">sample</code></td>
<td>
<p>whether to use a matched sample (sample = &quot;matched&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an nx1 matrix containing the indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a quantity indicator using the Bennet method
quantityIndicator(CES_sigma_2, pvar = "prices", qvar = "quantities",
prodID = "prodID", pervar = "time", method = "bennet")
</code></pre>

<hr>
<h2 id='quarterIndex'>Generate an index of quarters</h2><span id='topic+quarterIndex'></span>

<h3>Description</h3>

<p>A function to create a quarter index variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quarterIndex(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quarterIndex_+3A_x">x</code></td>
<td>
<p>A vector or column of dates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># given a vector of dates
df &lt;- data.frame(date = as.Date(c("2017-01-01","2017-04-01","2017-07-01","2017-08-01"),
format = "%Y-%m-%d"))
# calculate the time period variable
df$period &lt;- quarterIndex(df$date)
df
</code></pre>

<hr>
<h2 id='relativeDissimilarity'>Computes measures of relative dissimilarity between all periods</h2><span id='topic+relativeDissimilarity'></span>

<h3>Description</h3>

<p>A function to compute the relative price dissimilarity
between two vectors of prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relativeDissimilarity(
  x,
  pvar,
  qvar,
  pervar,
  prodID,
  indexMethod = "fisher",
  similarityMethod = "logquadratic"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relativeDissimilarity_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantities, a time
period index and a product identifier.</p>
</td></tr>
<tr><td><code id="relativeDissimilarity_+3A_pvar">pvar</code></td>
<td>
<p>A string identifying the price variable.</p>
</td></tr>
<tr><td><code id="relativeDissimilarity_+3A_qvar">qvar</code></td>
<td>
<p>A string identifying the quantity variable.</p>
</td></tr>
<tr><td><code id="relativeDissimilarity_+3A_pervar">pervar</code></td>
<td>
<p>A string identifying the time index variable.</p>
</td></tr>
<tr><td><code id="relativeDissimilarity_+3A_prodid">prodID</code></td>
<td>
<p>A string identifying the product ID.</p>
</td></tr>
<tr><td><code id="relativeDissimilarity_+3A_indexmethod">indexMethod</code></td>
<td>
<p>A string identifying the index method to
use in the calculation. Not relevant for similarityMethod = PLSpread.
Supported methods are fisher and tornqvist. Default is Fisher.</p>
</td></tr>
<tr><td><code id="relativeDissimilarity_+3A_similaritymethod">similarityMethod</code></td>
<td>
<p>A string specifying the formula for calculating
the relative dissimilarity. Valid options are logquadratic, asymplinear,
PLSpread and predictedshare. Default is logquadratic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dissimilarity measures.
The first two columns are the possible combinations of bilateral
comparisons and the third column is the dissimilarity measure.
</p>


<h3>References</h3>

<p>Diewert, W.E. (2002). &quot;Similarity and Dissimilarity Indexes:
An Axiomatic Approach&quot; Discussion Paper No. 0210, Department of Economics,
University of British Columbia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># estimate the dissimilarity between periods in the CES_sigma_2 dataset
# using the log quadratic measure of dissimilarity
relativeDissimilarity(CES_sigma_2, pvar = "prices", qvar="quantities",
pervar = "time", prodID = "prodID", indexMethod="fisher",
similarityMethod = "logquadratic")
</code></pre>

<hr>
<h2 id='shares'>Compute expenditure shares for each product and time period</h2><span id='topic+shares'></span>

<h3>Description</h3>

<p>Compute expenditure shares for each product and time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shares(x, pvar, qvar, pervar, prodID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shares_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="shares_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="shares_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable. For
elementary indexes a quantity variable is not required for the calculations
and you must specify qvar = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="shares_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="shares_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an n by p data frame of expenditure shares
</p>

<hr>
<h2 id='unitValues'>Aggregates prices to unit values and quantities to sums</h2><span id='topic+unitValues'></span>

<h3>Description</h3>

<p>A function to aggregate price and quantity data to unit values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitValues(x, pvar, qvar, pervar, prodID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitValues_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="unitValues_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="unitValues_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="unitValues_+3A_pervar">pervar</code></td>
<td>
<p>character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="unitValues_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing columns for product identifier, time period,
quantities, and unit values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># suppose the CES_sigma_2 dataset contains 12 monthly observations
# and suppose we want quarterly unit values.
df &lt;- CES_sigma_2
# convert the monthly time variable into quarterly
df$time &lt;- ceiling(CES_sigma_2$time/3)
# compute unit values using the quarterly time variable
unitValues(df,pvar="prices",qvar="quantities",pervar="time",prodID="prodID")
</code></pre>

<hr>
<h2 id='valueDecomposition'>valueDecomposition</h2><span id='topic+valueDecomposition'></span>

<h3>Description</h3>

<p>Perform a decomposition of value change using price
and quantity indicators. This is an additive decomposition
so that change due to price plus change due to quantity
equals the total value change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valueDecomposition(
  x,
  pvar,
  qvar,
  pervar,
  prodID,
  priceMethod,
  sample = "matched"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valueDecomposition_+3A_x">x</code></td>
<td>
<p>data frame with input data</p>
</td></tr>
<tr><td><code id="valueDecomposition_+3A_pvar">pvar</code></td>
<td>
<p>character string for the name of the price column</p>
</td></tr>
<tr><td><code id="valueDecomposition_+3A_qvar">qvar</code></td>
<td>
<p>character string for the name of the quantity column</p>
</td></tr>
<tr><td><code id="valueDecomposition_+3A_pervar">pervar</code></td>
<td>
<p>character string for the name of the time period variable</p>
</td></tr>
<tr><td><code id="valueDecomposition_+3A_prodid">prodID</code></td>
<td>
<p>character string for the name of the product ID column</p>
</td></tr>
<tr><td><code id="valueDecomposition_+3A_pricemethod">priceMethod</code></td>
<td>
<p>character string for the price indicator method. Valid options
are &quot;laspeyres&quot;, &quot;paasche&quot;, &quot;bennet&quot;, or &quot;montgomery&quot;. This parameter also
determines the method used for the quantity indicator. If a laspeyres price
indicator is chosen, then a paasche quantity indicator is used.
If a paasche price indicator is used then a laspeyres quantity indicator
is used. For bennet and montgomery indicators, the same method is
used for both the price and quantity indicators.</p>
</td></tr>
<tr><td><code id="valueDecomposition_+3A_sample">sample</code></td>
<td>
<p>whether to use a matched sample (sample = &quot;matched&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the price indicator, quantity indicator
the value change and the value level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># decompose the value changes in the CES_sigma_2 dataset using the Bennet method
valueDecomposition(CES_sigma_2, pvar = "prices", qvar = "quantities",
prodID = "prodID", pervar = "time", priceMethod = "bennet")
</code></pre>

<hr>
<h2 id='values'>Compute values (price x quantity)</h2><span id='topic+values'></span>

<h3>Description</h3>

<p>Compute the total value (expenditure), for each time period in
the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values(
  x,
  pvar,
  qvar,
  pervar,
  prodID,
  sample = "matched",
  matchPeriod = "previous"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="values_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="values_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="values_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="values_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="values_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="values_+3A_sample">sample</code></td>
<td>
<p>A character string specifying whether a matched sample
should be used.</p>
</td></tr>
<tr><td><code id="values_+3A_matchperiod">matchPeriod</code></td>
<td>
<p>A character string specifying which period is used
to determine the set of products used for matching. Options are
&quot;following&quot; or &quot;previous&quot;. &quot;following&quot; calculates the expenditures in the current period,
filtering out any products that do not appear in the following period.
&quot;previous&quot; is calculated similarly, using the set of products in the
previous period to filter the current period sample.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>values(CES_sigma_2, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", matchPeriod = "previous")

</code></pre>

<hr>
<h2 id='weekIndex'>Generate an index of weeks</h2><span id='topic+weekIndex'></span>

<h3>Description</h3>

<p>Function to create a week index variable with weeks
determined as defined in ISO 8601.
If the week (starting on Monday) containing 1 January has four
or more days in the new year, then it is considered week 1.
Otherwise, it is the 53rd week of the previous year, and the
next week is week 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weekIndex(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weekIndex_+3A_x">x</code></td>
<td>
<p>A vector of dates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># given a vector of dates
df &lt;- data.frame(date = as.Date(c("2016-12-20","2016-12-27","2017-01-01","2017-01-07"),
format = "%Y-%m-%d"))
# calculate the time period variable
df$period &lt;- weekIndex(df$date)
df
</code></pre>

<hr>
<h2 id='WTPDIndex'>Compute a weighted time-product-dummy multilateral index</h2><span id='topic+WTPDIndex'></span>

<h3>Description</h3>

<p>A function to calculate a weighted-time-product-dummy multilateral index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WTPDIndex(
  x,
  pvar,
  qvar,
  pervar,
  prodID,
  sample = "",
  window = 13,
  splice = "mean",
  imputePrices = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WTPDIndex_+3A_x">x</code></td>
<td>
<p>A dataframe containing price, quantity, a time period identifier
and a product identifier. It must have column names.</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_pvar">pvar</code></td>
<td>
<p>A character string for the name of the price variable</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_qvar">qvar</code></td>
<td>
<p>A character string for the name of the quantity variable</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_pervar">pervar</code></td>
<td>
<p>A character string for the name of the time variable. This variable
must contain integers starting at period 1 and increasing in increments of 1 period.
There may be observations on multiple products for each time period.</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_prodid">prodID</code></td>
<td>
<p>A character string for the name of the product identifier</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_sample">sample</code></td>
<td>
<p>set to &quot;matched&quot; to only use products that occur
across all periods in a given window. Default is not to match.</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_window">window</code></td>
<td>
<p>An integer specifying the length of the window.</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_splice">splice</code></td>
<td>
<p>A character string specifying the splicing method. Valid methods are
window, movement, half, mean, fbew, fbmw, wisp, hasp or mean_pub. The default is mean.
See details for important considerations when using fbew and fbmw.</p>
</td></tr>
<tr><td><code id="WTPDIndex_+3A_imputeprices">imputePrices</code></td>
<td>
<p>the type of price imputation to use for missing prices.
Currently only &quot;carry&quot; is supported to used carry-forward/carry-backward prices.
Default is NULL to not impute missing prices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When there are missing values in the dataset (e.g., from new or disappearing
products), the default option is to treat the missing prices and quantities
as zero. An alternative is to use a matched sample, where only products that
appear throughout each window in the calculation are kept.
</p>
<p>The splicing methods are used to update the price index when new data become
available without changing prior index values. The window, movement, half and mean splices
use the most recent index value as the base period, which is multiplied by a price movement
computed using new data. The fbew (Fixed Base Expanding Window) and fbmw (Fixed Base Moving
Window) use a fixed base onto which the price movement using new data is applied. The base
period is updated periodically. IndexNumR calculates which periods are the base periods using
<code>seq(from = 1, to = n, by = window - 1)</code>, so the data must be set up correctly and the
right window length chosen. For example, if you have monthly data and want December
of each year to be the base period, then the first period in the data must be December
and the window must be set to 13.
</p>


<h3>References</h3>

<p>Ivancic, L., W.E. Diewert and K.J. Fox (2011), &quot;Scanner Data,
Time Aggregation and the Construction of Price Indexes&quot;, Journal of
Econometrics 161, 24-35.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a wtpd index with mean splicing
WTPDIndex(CES_sigma_2, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", window=11, splice = "mean")
</code></pre>

<hr>
<h2 id='yearIndex'>Generate an index of years</h2><span id='topic+yearIndex'></span>

<h3>Description</h3>

<p>Function to create a year index variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearIndex(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yearIndex_+3A_x">x</code></td>
<td>
<p>A vector or column of dates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># given a vector of dates
df &lt;- data.frame(date = as.Date(c("2017-01-01","2018-04-01","2019-07-01","2019-08-01"),
format = "%Y-%m-%d"))
# calculate the time period variable
df$period &lt;- yearIndex(df$date)
df
</code></pre>

<hr>
<h2 id='yearOverYearIndexes'>Estimate year-over-year indexes</h2><span id='topic+yearOverYearIndexes'></span>

<h3>Description</h3>

<p>Year-over-year indexes are indexes where the months or quarters of the
year are split in separate datasets and an index estimated on each.
Therefore, year-over-year indexes estimated on a dataset with five full years
of observations at a monthly frequency will have 12 separate indexes,
each with 5 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearOverYearIndexes(freq, indexFunction, indexArgs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yearOverYearIndexes_+3A_freq">freq</code></td>
<td>
<p>the frequency of the data. Either &quot;monthly&quot; or &quot;quarterly&quot;.</p>
</td></tr>
<tr><td><code id="yearOverYearIndexes_+3A_indexfunction">indexFunction</code></td>
<td>
<p>the name of the function to use to calculate the
index as a string. Available options are 'priceIndex', 'GEKSIndex',
'GKIndex', 'WTPDIndex'.</p>
</td></tr>
<tr><td><code id="yearOverYearIndexes_+3A_indexargs">indexArgs</code></td>
<td>
<p>arguments for the price index function as a named list.
All arguments must be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of indexes with one element for each month or quarter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>argsList &lt;- list(x = CES_sigma_2, pvar = "prices", qvar = "quantities", pervar = "time",
prodID = "prodID", indexMethod = "fisher", output = "chained")

yearOverYearIndexes("quarterly", "priceIndex", argsList)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
