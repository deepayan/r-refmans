<!DOCTYPE html><html lang="en"><head><title>Help for package CvmortalityMult</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CvmortalityMult}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fitLCmulti'><p>Function to fit multi-population mortality models</p></a></li>
<li><a href='#forecast.fitLCmulti'><p>Function to forecast multi-population mortality model</p></a></li>
<li><a href='#MeasureAccuracy'><p>Measures of Accuracy</p></a></li>
<li><a href='#multipopulation_cv'><p>Function to apply cross-validation techniques for testing the forecasting accuracy</p>
of multi-population mortality models</a></li>
<li><a href='#plot.fitLCmulti'><p>Function to plot the parameters of the multi-population mortality models</p></a></li>
<li><a href='#plot.forLCmulti'><p>Function to plot the parameters of the multi-population mortality models</p></a></li>
<li><a href='#regions'><p>regions</p></a></li>
<li><a href='#residSVD2'><p>Function to extract the resid from SVD</p></a></li>
<li><a href='#SpainMap'><p>Spain National map information</p></a></li>
<li><a href='#SpainNat'><p>Spain National Mortality data</p></a></li>
<li><a href='#SpainRegions'><p>Spain Regions Mortality data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cross-Validation for Multi-Population Mortality Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of cross-validation method for testing the forecasting accuracy of several multi-population mortality models. The family of multi-population includes several multi-population mortality models proposed through the actuarial and demography literature. The package includes functions for fitting and forecast the mortality rates of several populations. Additionally, we include functions for testing the forecasting accuracy of different multi-population models.
  References.
  Atance, D., Debon, A., and Navarro, E. (2020) &lt;<a href="https://doi.org/10.3390%2Fmath8091550">doi:10.3390/math8091550</a>&gt;.
  Bergmeir, C. &amp; Benitez, J.M. (2012) &lt;<a href="https://doi.org/10.1016%2Fj.ins.2011.12.028">doi:10.1016/j.ins.2011.12.028</a>&gt;.
  Debon, A., Montes, F., &amp; Martinez-Ruiz, F. (2011) &lt;<a href="https://doi.org/10.1007%2Fs13385-011-0043-z">doi:10.1007/s13385-011-0043-z</a>&gt;.
  Lee, R.D. &amp; Carter, L.R. (1992) &lt;<a href="https://doi.org/10.1080%2F01621459.1992.10475265">doi:10.1080/01621459.1992.10475265</a>&gt;.
  Russolillo, M., Giordano, G., &amp; Haberman, S. (2011) &lt;<a href="https://doi.org/10.1080%2F03461231003611933">doi:10.1080/03461231003611933</a>&gt;.
  Santolino, M. (2023) &lt;<a href="https://doi.org/10.3390%2Frisks11100170">doi:10.3390/risks11100170</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/davidAtance/CvmortalityMult">https://github.com/davidAtance/CvmortalityMult</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidAtance/CvmortalityMult/issues">https://github.com/davidAtance/CvmortalityMult/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.50)</td>
</tr>
<tr>
<td>Imports:</td>
<td>StMoMo, forecast, gnm (&ge; 1.1-2), tmap, sf, graphics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-13 12:33:58 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Atance <a href="https://orcid.org/0000-0001-5860-0584"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ana Deb√≥n <a href="https://orcid.org/0000-0002-5116-289X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Atance &lt;david.atance@uah.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 13:22:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='fitLCmulti'>Function to fit multi-population mortality models</h2><span id='topic+fitLCmulti'></span>

<h3>Description</h3>

<p>R function for fitting additive, multiplicative, common-factor (CFM), augmented-common-factor (ACFM), or joint-k multi-population mortality model developed by: Debon et al. (2011), Russolillo et al. (2011), Carter and Lee (1992), LI and Lee (2005), and Carter and Lee (1992), respectively.
These models follow the structure of the well-known Lee-Carter model (Lee and Carter, 1992) but include different parameter(s) to capture the behavior of each population considered in different ways.
In case, you want to understand in depth each model, please see Villegas et al. (2017).
It should be mentioned that this function is developed for fitting several populations.
However, in case you only consider one population, the function will fit the single population version of the Lee-Carter model, the classical one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitLCmulti(
  model = c("additive", "multiplicative", "CFM", "joint-K", "ACFM"),
  qxt,
  periods,
  ages,
  nPop,
  lxt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitLCmulti_+3A_model">model</code></td>
<td>
<p>multi-population mortality model chosen to fit the mortality rates c(&quot;<code>additive</code>&quot;, &quot;<code>multiplicative</code>&quot;, &quot;<code>CFM</code>&quot;,&quot;<code>ACFM</code>&quot;, &quot;<code>joint-K</code>&quot;). In case you do not provide any value, the function will apply the &quot;<code>additive</code>&quot; option.</p>
</td></tr>
<tr><td><code id="fitLCmulti_+3A_qxt">qxt</code></td>
<td>
<p>mortality rates used to fit the additive multipopulation mortality model. This rates cn be provided in matrix or in data.frame.</p>
</td></tr>
<tr><td><code id="fitLCmulti_+3A_periods">periods</code></td>
<td>
<p>number of years considered in the fitting in a vector way c(<code>minyear</code>:<code>maxyear</code>).</p>
</td></tr>
<tr><td><code id="fitLCmulti_+3A_ages">ages</code></td>
<td>
<p>vector with the ages considered in the fitting. If the mortality rates provide from an abridged life tables, it is necessary to provide a vector with the ages, see the example.</p>
</td></tr>
<tr><td><code id="fitLCmulti_+3A_npop">nPop</code></td>
<td>
<p>number of population considered for fitting. If you consider 1 the model selected will be the singel version of the Lee-Carter model.</p>
</td></tr>
<tr><td><code id="fitLCmulti_+3A_lxt">lxt</code></td>
<td>
<p>survivor function considered for every population, not necessary to provide.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>"LCmulti"</code> including different components of the fitting process:
</p>

<ul>
<li> <p><code>ax</code> parameter that captures the average shape of the mortality curve in all considered populations.
</p>
</li>
<li> <p><code>bx</code> parameter that explains the age effect x with respect to the general trend <code>kt</code> in the mortality rates of all considered populations.
</p>
</li>
<li> <p><code>kt</code> represent the national tendency of multi-mortality populations during the period.
</p>
</li>
<li> <p><code>Ii</code> gives an idea of the differences in the pattern of mortality in any region i with respect to Region 1.
</p>
</li>
<li> <p><code>formula</code> additive multi-population mortality formula used to fit the mortality rates.
</p>
</li>
<li> <p><code>model</code> provided the model selected in every case.
</p>
</li>
<li> <p><code>data.used</code> mortality rates used to fit the data.
</p>
</li>
<li> <p><code>qxt.crude</code> corresponds to the crude mortality rates. These crude rate are directly obtained by dividing the number of registered deaths by the number of those initially exposed to the risk for age x, period t and in each region i.
</p>
</li>
<li> <p><code>qxt.fitted</code> fitted mortality rates using the additive multi-population mortality model.
</p>
</li>
<li> <p><code>logit.qxt.fitted</code> fitted mortality rates in logit way.
</p>
</li>
<li> <p><code>Ages</code> provided ages to fit the data.
</p>
</li>
<li> <p><code>Periods</code> provided periods to fit the periods.
</p>
</li>
<li> <p><code>nPop</code> provided number of populations to fit the periods.
</p>
</li>
<li> <p><code>warn_msgs </code> vector with the populations where the model has not converged.
</p>
</li></ul>



<h3>References</h3>

<p>Carter, L.R. and Lee, R.D. (1992).
Modeling and forecasting US sex differentials in mortality.
International Journal of Forecasting, 8(3), 393‚Äì411.
</p>
<p>Debon, A., Montes, F., and Martinez-Ruiz, F. (2011).
Statistical methods to compare mortality for a group with non-divergent populations: an application to Spanish regions.
European Actuarial Journal, 1, 291-308.
</p>
<p>Lee, R.D. and Carter, L.R. (1992).
Modeling and forecasting US mortality.
Journal of the American Statistical Association, 87(419), 659‚Äì671.
</p>
<p>Li, N. and Lee, R.D. (2005).
Coherent mortality forecasts for a group of populations: An extension of the Lee-Carter method.
Demography, 42(3), 575‚Äì594.
</p>
<p>Russolillo, M., Giordano, G., &amp; Haberman, S. (2011).
Extending the Lee‚ÄìCarter model: a three-way decomposition.
Scandinavian Actuarial Journal, 2011(2), 96-117.
</p>
<p>Villegas, A. M., Haberman, S., Kaishev, V. K., &amp; Millossovich, P. (2017).
A comparative study of two-population models for the assessment of basis risk in longevity hedges.
ASTIN Bulletin, 47(3), 631-679.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.fitLCmulti">forecast.fitLCmulti</a></code>,
<code><a href="#topic+multipopulation_cv">multipopulation_cv</a></code>, <code><a href="#topic+plot.fitLCmulti">plot.fitLCmulti</a></code>,
<code><a href="#topic+plot.forLCmulti">plot.forLCmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#First, we present the data that we are going to use
SpainRegions
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)

#Charge some libraries needed for executing the function
library(gnm)
library(forecast)
#There are some model that we can fit using this function:
#1. ADDITIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the additive multi-population mortality model
additive_Spainmales &lt;- fitLCmulti(model = "additive",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

additive_Spainmales

#If the user does not provide the model inside the function fitLCmult()
#the multi-population mortality model applied will be additive one.

#Once, we have fit the data, it is possible to see the ax, bx, kt, and Ii
#provided parameters for the fitting.
plot(additive_Spainmales)

#2. MULTIPLICATIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the multiplicative multi-population mortality model
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

multiplicative_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(multiplicative_Spainmales)

#3. COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the common-factor multi-population mortality model
cfm_Spainmales &lt;- fitLCmulti(model = "CFM",
                             qxt = SpainRegions$qx_male,
                             periods = c(1991:2020),
                             ages = c(ages),
                             nPop = 18,
                             lxt = SpainRegions$lx_male)

cfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(cfm_Spainmales)

#4. JOINT-K MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the augmented-common-factor multi-population mortality model
jointk_Spainmales &lt;- fitLCmulti(model = "joint-K",
                                qxt = SpainRegions$qx_male,
                                periods = c(1991:2020),
                                ages = c(ages),
                                nPop = 18,
                                lxt = SpainRegions$lx_male)

jointk_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(jointk_Spainmales)

#5. AUGMENTED-COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the augmented-common-factor multi-population mortality model
acfm_Spainmales &lt;- fitLCmulti(model = "ACFM",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

acfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(acfm_Spainmales)

#6. LEE-CARTER FOR SINGLE-POPULATION
#As we mentioned in the details of the function, if we only provide the data
#from one-population the function fitLCmulti()
#will fit the Lee-Carter model for single populations.
LC_Spainmales &lt;- fitLCmulti(qxt = SpainNat$qx_male,
                              periods = c(1991:2020),
                              ages = ages,
                              model = "additive",
                              nPop = 1)

LC_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, and kt
#parameters provided for the single version of the LC.
plot(LC_Spainmales)

</code></pre>

<hr>
<h2 id='forecast.fitLCmulti'>Function to forecast multi-population mortality model</h2><span id='topic+forecast.fitLCmulti'></span>

<h3>Description</h3>

<p>R function for forecasting additive, multiplicative, common-factor (CFM), augmented-common-factor (ACFM), or joint-k multi-population mortality model developed by: Debon et al. (2011), Russolillo et al. (2011), Carter and Lee (1992), LI and Lee (2005), and Carter and Lee (2011), respectively.
These models follow the structure of the well-known Lee-Carter model (Lee and Carter, 1992) but include different parameter(s) to capture the behavior of each population considered in different ways.
This parameter seeks to capture the individual behavior of every population considered.
In case, you want to understand in depth each model, please see Villegas et al. (2017).
It should be mentioned that this function is developed for fitting several populations.
However, in case you only consider one population, the function will fit the single population version of the Lee-Carter model, the classical one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitLCmulti'
forecast(object, nahead, ktmethod = c("Arimapdq", "arima010"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.fitLCmulti_+3A_object">object</code></td>
<td>
<p>object <code>"fitLCmulti"</code> developed using function <code>fitLCmulti()</code>. With this object the function will determine the multi-population fitted with the function <code>fitLCmulti()</code>.</p>
</td></tr>
<tr><td><code id="forecast.fitLCmulti_+3A_nahead">nahead</code></td>
<td>
<p>number of periods ahead to forecast.</p>
</td></tr>
<tr><td><code id="forecast.fitLCmulti_+3A_ktmethod">ktmethod</code></td>
<td>
<p>method used to forecast the value of <code>kt</code> Arima(p,d,q) or ARIMA(0,1,0); c(&quot;<code>Arimapdq</code>&quot;, &quot;<code>arima010</code>&quot;).</p>
</td></tr>
<tr><td><code id="forecast.fitLCmulti_+3A_...">...</code></td>
<td>
<p>other arguments for <code><a href="StMoMo.html#topic+iarima">iarima</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>"forLCmulti"</code> including different components of the forecasting process:
</p>

<ul>
<li> <p><code>ax</code> parameter that captures the average shape of the mortality curve in all considered populations.
</p>
</li>
<li> <p><code>bx</code> parameter that explains the age effect x with respect to the general trend <code>kt</code> in the mortality rates of all considered populations.
</p>
</li>
<li> <p><code>arimakt</code> the arima selected for the <code>kt</code> time series.
</p>
</li>
<li> <p><code>kt.fitted</code> obtained values for the tendency behavior captured by <code>kt</code>.
</p>
</li>
<li> <p><code>kt.fut</code> projected values of <code>kt</code> for the nahead periods ahead.
</p>
</li>
<li> <p><code>kt.futintervals</code> arima selected and future values of <code>kt</code> with the different intervals, lower and upper, 80\
</p>
</li>
<li> <p><code>Ii</code> parameter that captures the differences in the pattern of mortality in any region i with respect to Region 1.
</p>
</li>
<li> <p><code>ktmethod</code> method selected to forecast the value of <code>kt</code> Arima(p,d,q) or ARIMA(0,1,0); c(&quot;<code>Arimapdq</code>&quot;, &quot;<code>arima010</code>&quot;).
</p>
</li>
<li> <p><code>formula</code> additive multi-population mortality formula used to fit the mortality rates.
</p>
</li>
<li> <p><code>model</code> provided the model selected in every case.
</p>
</li>
<li> <p><code>qxt.crude</code> corresponds to the crude mortality rates. These crude rate are directly obtained by dividing the number of registered deaths by the number of those initially exposed to the risk for age x, period t and in each region i.
</p>
</li>
<li> <p><code>qxt.fitted</code> fitted mortality rates using the additive multi-population mortality model.
</p>
</li>
<li> <p><code>logit.qxt.fitted</code> fitted mortality rates in logit way estimated with the additive multi-population mortality model.
</p>
</li>
<li> <p><code>qxt.future</code> future mortality rates estimated with the additive multi-population mortality model.
</p>
</li>
<li> <p><code>logit.qxt.future</code> future mortality rates in logit way estimated with the additive multi-population mortality model.
</p>
</li>
<li> <p><code>nPop</code> provided number of populations to fit the periods.
</p>
</li></ul>



<h3>References</h3>

<p>Carter, L.R. and Lee, R.D. (1992).
Modeling and forecasting US sex differentials in mortality.
International Journal of Forecasting, 8(3), 393‚Äì411.
</p>
<p>Debon, A., Montes, F., &amp; Martinez-Ruiz, F. (2011).
Statistical methods to compare mortality for a group with non-divergent populations: an application to Spanish regions.
European Actuarial Journal, 1, 291-308.
</p>
<p>Lee, R.D. &amp; Carter, L.R. (1992).
Modeling and forecasting US mortality.
Journal of the American Statistical Association, 87(419), 659‚Äì671.
</p>
<p>Li, N. and Lee, R.D. (2005).
Coherent mortality forecasts for a group of populations: An extension of the Lee-Carter method.
Demography, 42(3), 575‚Äì594.
</p>
<p>Russolillo, M., Giordano, G., &amp; Haberman, S. (2011).
Extending the Lee‚ÄìCarter model: a three-way decomposition.
Scandinavian Actuarial Journal, 2011(2), 96-117.
</p>
<p>Villegas, A. M., Haberman, S., Kaishev, V. K., &amp; Millossovich, P. (2017).
A comparative study of two-population models for the assessment of basis risk in longevity hedges.
ASTIN Bulletin, 47(3), 631-679.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLCmulti">fitLCmulti</a></code>,
<code><a href="#topic+plot.fitLCmulti">plot.fitLCmulti</a></code>, <code><a href="#topic+plot.forLCmulti">plot.forLCmulti</a></code>,
<code><a href="#topic+multipopulation_cv">multipopulation_cv</a></code>, <a href="StMoMo.html#topic+iarima">iarima</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#First, we present the data that we are going to use
SpainRegions
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)

library(gnm)
library(forecast)
#1. ADDITIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the additive multi-population mortality model
additive_Spainmales &lt;- fitLCmulti(model = "additive",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

additive_Spainmales

#If the user does not provide the model inside the function fitLCmult()
#the multi-population mortality model applied will be additive one.

#Once, we have fit the data, it is possible to see the ax, bx, kt, and Ii
#provided parameters for the fitting.
plot(additive_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_additive_Spainmales &lt;- forecast(object = additive_Spainmales, nahead = 10,
                                    ktmethod = "Arimapdq")

fut_additive_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_additive_Spainmales)

#2. MULTIPLICATIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the multiplicative multi-population mortality model
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

multiplicative_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(multiplicative_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_multi_Spainmales &lt;- forecast(object = multiplicative_Spainmales, nahead = 10,
                                 ktmethod = "Arimapdq")

fut_multi_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_multi_Spainmales)

#3. COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the common-factor multi-population mortality model
cfm_Spainmales &lt;- fitLCmulti(model = "CFM",
                             qxt = SpainRegions$qx_male,
                             periods = c(1991:2020),
                             ages = c(ages),
                             nPop = 18,
                             lxt = SpainRegions$lx_male)

cfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(cfm_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_cfm_Spainmales &lt;- forecast(object = cfm_Spainmales, nahead = 10,
                               ktmethod = "Arimapdq")

fut_cfm_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_cfm_Spainmales)

#4. JOINT-K MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the joint-K multi-population mortality model
jointk_Spainmales &lt;- fitLCmulti(model = "joint-K",
                                qxt = SpainRegions$qx_male,
                                periods = c(1991:2020),
                                ages = c(ages),
                                nPop = 18,
                                lxt = SpainRegions$lx_male)

jointk_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(jointk_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_jointk_Spainmales &lt;- forecast(object = jointk_Spainmales, nahead = 10,
                               ktmethod = "Arimapdq")

fut_jointk_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_jointk_Spainmales)

#5. AUGMENTED-COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the augmented-common-factor multi-population mortality model
acfm_Spainmales &lt;- fitLCmulti(model = "ACFM",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

acfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(acfm_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_acfm_Spainmales &lt;- forecast(object = acfm_Spainmales, nahead = 10,
                               ktmethod = "Arimapdq")

fut_acfm_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_acfm_Spainmales)

#6. LEE-CARTER FOR SINGLE-POPULATION
#As we mentioned in the details of the function, if we only provide the data
#from one-population the function fitLCmulti()
#will fit the Lee-Carter model for single populations.
LC_Spainmales &lt;- fitLCmulti(qxt = SpainNat$qx_male,
                              periods = c(1991:2020),
                              ages = ages,
                              model = "additive",
                              nPop = 1)

LC_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, and kt
#parameters provided for the single version of the LC.
plot(LC_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_LC_Spainmales &lt;- forecast(object = LC_Spainmales, nahead = 10,
                              ktmethod = "Arimapdq")

#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_LC_Spainmales)



</code></pre>

<hr>
<h2 id='MeasureAccuracy'>Measures of Accuracy</h2><span id='topic+MeasureAccuracy'></span>

<h3>Description</h3>

<p>R function to estimate different measures of accuracy.
</p>

<ol>
<li><p> the sum of squared errors (SSE) for the mortality rates:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{x}^{} \sum_{t} \left( qxt1 - qxt2 \right)^{2}</code>
</p>

<p>where qxt1 is the real mortality rates <code>qxt_crude</code>, and qxt2 is the adjusted mortality rates <code>qxt_aju</code>.
</p>
</li>
<li><p> The mean squared errors (MSE) for the mortality rates:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{x} \sum_{t} \left( qxt1 - qxt2 \right)^2 = \frac{1}{n} SSE</code>
</p>

<p>where qxt1 is the real mortality rates <code>qxt_crude</code>, and qxt2 is the adjusted mortality rates <code>qxt_aju</code>.
</p>
</li>
<li><p> The mean absolute errors (MAE) for the mortality rates:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{x} \sum_{t} \left| qx1 - qxt2 \right|</code>
</p>
<p>.
where qxt1 is the real mortality rates <code>qxt_crude</code>, and qxt2 is the adjusted mortality rates <code>qxt_aju</code>.
</p>
</li>
<li><p> The mean absolute percentage error (MAPE) for the mortality rates:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{x} \sum_{t}\left| \frac{\left(qxt1 - qxt2\right) }{qxt2} \right|</code>
</p>

<p>where qxt1 is the real mortality rates <code>qxt_crude</code>, and qxt2 is the adjusted mortality rates <code>qxt_aju</code>.
You only have to provide the real value, the fitted or forecasted value for your mortality rates and the measure of accuracy chosen.
However, the function is constructed to provide the real value and the fitted or forecasted value of your independent variable.
These variables must have the same dimensions to be compared.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>MeasureAccuracy(
  measure = c("SSE", "MSE", "MAE", "MAPE", "All"),
  qxt_crude,
  qxt_aju,
  wxt
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeasureAccuracy_+3A_measure">measure</code></td>
<td>
<p>choose the non-penalized measure of accuracy that you want to use; c(&quot;<code>SSE</code>&quot;, &quot;<code>MSE</code>&quot;, &quot;<code>MAE</code>&quot;, &quot;<code>MAPE</code>&quot;, &quot;<code>All</code>&quot;). Check the function. In case you do not provide any value, the function will apply the &quot;<code>SSE</code>&quot; as measure of forecasting accuracy.</p>
</td></tr>
<tr><td><code id="MeasureAccuracy_+3A_qxt_crude">qxt_crude</code></td>
<td>
<p>corresponds to the crude mortality rates. These crude rate are directly obtained by dividing the number of registered deaths by the number of those initially exposed to the risk for age x, period t and in each region i.</p>
</td></tr>
<tr><td><code id="MeasureAccuracy_+3A_qxt_aju">qxt_aju</code></td>
<td>
<p>adjusted mortality rates using a specific mode.</p>
</td></tr>
<tr><td><code id="MeasureAccuracy_+3A_wxt">wxt</code></td>
<td>
<p>weights of the mortality rates or data provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"MoA"</code> including the value of the measure of accuracy for the data provided.
</p>


<h3>References</h3>

<p>Atance, D., Deb√≥n, A., &amp; Navarro, E. (2020).
A comparison of forecasting mortality models using resampling methods.
Mathematics, 8(9), 1550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLCmulti">fitLCmulti</a></code>, <code><a href="#topic+forecast.fitLCmulti">forecast.fitLCmulti</a></code>,
<code><a href="#topic+multipopulation_cv">multipopulation_cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#To show how the function works, we need to provide fitted or forecasted data and the real data.
#In this case, we employ the following data of the library:
SpainRegions

library(gnm)
library(forecast)
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)
#In this case, we fit for males providing the lxt
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

multiplicative_Spainmales
plot(multiplicative_Spainmales)

#Once, we have the fitted data, we will obtain different measures of accuracy
#for the first population.
#We need to obtain wxt (weight of the mortality rates or data provided) using a
library(StMoMo)
wxt_1pop &lt;- genWeightMat(ages = ages, years = c(1991:2020), clip = 0)

##########################
#SSE#
##########################
SSE_multSpmales &lt;- MeasureAccuracy(measure = "SSE",
                       qxt_crude = multiplicative_Spainmales$qxt.crude$pop1,
                       qxt_aju = multiplicative_Spainmales$qxt.fitted$pop1,
                       wxt = wxt_1pop)
SSE_multSpmales
##########################
#MSE#
##########################
MSE_multSpmales &lt;- MeasureAccuracy(measure = "MSE",
                       qxt_crude = multiplicative_Spainmales$qxt.crude$pop1,
                       qxt_aju = multiplicative_Spainmales$qxt.fitted$pop1,
                       wxt = wxt_1pop)
MSE_multSpmales
##########################
#MAE#
##########################
MAE_multSpmales &lt;- MeasureAccuracy(measure = "MSE",
                       qxt_crude = multiplicative_Spainmales$qxt.crude$pop1,
                       qxt_aju = multiplicative_Spainmales$qxt.fitted$pop1,
                       wxt = wxt_1pop)
MAE_multSpmales
##########################
#MAPE#
##########################
MAPE_multSpmales &lt;- MeasureAccuracy(measure = "MSE",
                        qxt_crude = multiplicative_Spainmales$qxt.crude$pop1,
                        qxt_aju = multiplicative_Spainmales$qxt.fitted$pop1,
                        wxt = wxt_1pop)
MAPE_multSpmales



</code></pre>

<hr>
<h2 id='multipopulation_cv'>Function to apply cross-validation techniques for testing the forecasting accuracy
of multi-population mortality models</h2><span id='topic+multipopulation_cv'></span>

<h3>Description</h3>

<p>R function for testing the accuracy out-of-sample using different cross-validation techniques. The multi-population mortality models used by the package are: additive (Debon et al., 2011), multiplicative (Russolillo et al., 2011), common-factor (CFM) (Carter and Lee, 1992), joint-k (Carter and Lee, 2011), and augmented-common-factor (ACFM) (Li and Lee, 2005).
We provide a R function that employ the cross-validation techniques for three-way-array, following the preliminary idea for panel-time series, specifically for testing the forecasting ability of single mortality models (Atance et al. 2020).
These techniques consist on split the database in two parts: training set (to run the model) and test set (to check the forecasting accuracy of the model).
This procedure is repeated several times trying to check the forecasting accuracy in different ways.
With this function, the user can provide its own mortality rates for different populations and apply different cross-validation techniques.
The user must specify three main inputs in the function (<code>nahead</code>, <code>trainset1</code>, and <code>fixed_train_origin</code>) to apply a specific cross-validation technique between the different options.
Indeed, you can apply the next time-series cross-validation techniques, following the terminology employed by Bergmeir et al. (2012):
</p>

<ol>
<li><p> Fixed-Origin.
The technique chronologically splits the data set into two parts, first for training the model, and second for testing the forecasting accuracy.
This process predicts only once for different forecast horizons which are evaluated to assess the accuracy of the multi-population model, as can be seen in the next Figure.
<img src="../help/figures/FIXED-ORIGIN.jpg" width="100%" alt="Figure: mai.png" />
</p>
</li></ol>

<p>The function &quot;<code>multipopulation_cv()</code>&quot; understands FIXED-ORIGIN when <code>trainset1</code> + <code>nahead</code> = number of provided periods and <code>fixed_train_origin</code> = <code>TRUE</code> (default value).
As an example, data set with periods from 1991 to 2020, <code>trainset1</code> = 25 and <code>nahead</code>= 5, with a total of 30, equals to length of the periods 1991:2020.
</p>

<ol>
<li><p> Rolling-Origin recalibration (RO-recalibration) evaluation.
In this technique, the data set is spitted into 'k' sub-sets of data, keeping chronologically order.
The first set of data corresponds to the training set where the model is fitted and the forecast are evaluated with a fixed horizon.
In every iteration, the model is enlarged and recalibrated adding the test-set periods (<code>nahead</code> in the function) to the training set and forecasting the next fixed horizon.
The idea is to keep the origin fixed and move the forecast origin in every iteration, as can be seen in the next Figure
</p>
</li></ol>

<p><img src="../help/figures/RO_RECALIBRATION.jpg" width="100%" alt="Figure: mai.png" />
</p>
<p>In the package, to apply this technique the users must provided a value of <code>trainset1</code> higher than two (to meet with the minimum time-series size), and <code>fixed_train_origin</code> = <code>TRUE</code> (default value), independently of the assigned value of <code>nahead</code>.
There are different resampling techniques that can be applied based on the values of <code>trainset1</code> and <code>nahead</code>.
Indeed, when <code>nahead</code> = 1 &mdash; Leave-One-Out-Cross-Validation (LOOCV) with RO-recalibration will be applied.
Independently, of the number of periods in the first train set (<code>trainset1</code>).
When, <code>nahead</code> and <code>trainset1</code> are equal &mdash; K-Fold-Cross-Validation (LOOCV) with RO-recalibration will be applied.
For the rest values of <code>nahead</code> and <code>trainset1</code> a standard time-series CV technique will be implemented.
</p>

<ol>
<li><p> Rolling-Window (RW) evaluation
The approach is very similar to the RO-recalibration, but maintaining the training set size constant at each forecast/iteration.
Maintaining the chronological order in each forecast, the training set adds the previous. projected periods of the test set and discards the earliest observations, as can be seen in the next Figure.
</p>
</li></ol>

<p><img src="../help/figures/RW_RECALIBRATION" width="100%" alt="Figure: mai.png" />
</p>
<p>To apply this technique, the <code>multipopulation_cv()</code> function requires that <code>fixed_train_origin</code> = c(&quot;<code>FALSE</code>&quot;, &quot;<code>1</code>&quot;), regardless of the values of <code>nahead</code> and <code>trainset1</code>.
Equally as in RO-recalibration, LOOCV, and k-fold can be applied with <code>nahead</code> = 1, or <code>nahead</code> equals to <code>trainset1</code>, respectively, but keeping the training set constant through the iterations.
Additionally, the common time-series CV approach can be applied for different values of <code>nahead</code> and <code>trainset1</code>.
When <code>fixed_train_origin</code> = &quot;<code>FALSE</code>&quot;, at each iteration the training set adds the next <code>nahead</code> periods and discards the oldest keeping the training set size constant.
While <code>fixed_train_origin</code> = &quot;<code>1</code>&quot;, at every iteration the training set only incorporates the next period ahead and discards only the latest period; maintaining the length of the training set constant and allowing to assess the forecasting accuracy of the mortality models in the long and medium term with different periods.
</p>
<p>It should be mentioned that this function is developed for cross-validation the forecasting accuracy of several populations.
However, in case you only consider one population, the function will forecast the Lee-Carter model for one population.
To test the forecasting accuracy of the selected model, the function provides five different measures: SSE, MSE, MAE, MAPE or All.
This measure of accuracy will be provided in different ways: a total measure, among ages considered, among populations and among projected blocked (periods).
Depending on how you want to check the forecasting accuracy of the model you could select one or other.
In this case, the measures will be obtained using the mortality rates in the normal scale as recommended by Santolino (2023) against the log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipopulation_cv(
  qxt,
  model = c("additive", "multiplicative", "CFM", "joint-K", "ACFM"),
  periods,
  ages,
  nPop,
  lxt = NULL,
  ktmethod = c("Arimapdq", "arima010"),
  nahead,
  trainset1,
  fixed_train_origin = TRUE,
  measures = c("SSE", "MSE", "MAE", "MAPE", "All"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multipopulation_cv_+3A_qxt">qxt</code></td>
<td>
<p>mortality rates used to fit the multi-population mortality models. This rates can be provided in matrix or in data.frame.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_model">model</code></td>
<td>
<p>multi-population mortality model chosen to fit the mortality rates c(&quot;<code>additive</code>&quot;, &quot;<code>multiplicative</code>&quot;, &quot;<code>CFM</code>&quot;, &quot;<code>joint-K</code>&quot;, &quot;<code>ACFM</code>&quot;). In case you do not provide any value, the function will apply the &quot;<code>additive</code>&quot; option.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_periods">periods</code></td>
<td>
<p>number of years considered in the fitting in a vector way c(<code>minyear</code>:<code>maxyear</code>).</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_ages">ages</code></td>
<td>
<p>vector with the ages considered in the fitting. If the mortality rates provide from an abridged life tables, it is necessary to provide a vector with the ages, see the example.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_npop">nPop</code></td>
<td>
<p>number of population considered for fitting.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_lxt">lxt</code></td>
<td>
<p>survivor function considered for every population, not necessary to provide.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_ktmethod">ktmethod</code></td>
<td>
<p>method used to forecast the value of <code>kt</code> Arima(p,d,q) or ARIMA(0,1,0); c(&quot;<code>Arimapdq</code>&quot;, &quot;<code>arima010</code>&quot;).</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_nahead">nahead</code></td>
<td>
<p>is a vector specifying the number of periods to forecast <code>nahead</code> periods ahead. It should be noted that when <code>nahead</code> is equal to <code>trainset1</code> a k-fold CV will be applied. Whereas when <code>nahead</code> is equal to 1, the CV process will be a Leave-One-Out CV.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_trainset1">trainset1</code></td>
<td>
<p>is a vector with the periods for the first training set.  This value must be greater than 2 to meet the minimum time series size (Hyndman and Khandakar, 2008).</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_fixed_train_origin">fixed_train_origin</code></td>
<td>
<p>option to select whether the origin in the first train set is fixed or not. The default value is <code>TRUE</code> where the origin of the first training sets is fixed. The alternatives are: <code>FALSE</code> when the first train set is moved in every iteration according to the provided <code>nahead</code> value, and 2. <code>1</code> when the train set is moved one period ahead in every repetition keeping constant the amount of data, and incorporating the next period observation, and discarding the last available period.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_measures">measures</code></td>
<td>
<p>choose the non-penalized measure of forecasting accuracy that you want to use; c(&quot;<code>SSE</code>&quot;, &quot;<code>MSE</code>&quot;, &quot;<code>MAE</code>&quot;, &quot;<code>MAPE</code>&quot;, &quot;<code>All</code>&quot;). Check the function. In case you do not provide any value, the function will apply the &quot;<code>SSE</code>&quot; as measure of forecasting accuracy.</p>
</td></tr>
<tr><td><code id="multipopulation_cv_+3A_...">...</code></td>
<td>
<p>other arguments for <code><a href="StMoMo.html#topic+iarima">iarima</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>"MultiCv"</code> including a <code>list()</code> with different components of the cross-validation process:
</p>

<ul>
<li> <p><code>ax</code> parameter that captures the average shape of the mortality curve in all considered populations.
</p>
</li>
<li> <p><code>bx</code> parameter that explains the age effect x with respect to the general trend <code>kt</code> in the mortality rates of all considered populations.
</p>
</li>
<li> <p><code>kt.fitted</code> obtained values for the tendency behavior captured by <code>kt</code> .
</p>
</li>
<li> <p><code>kt.future</code> future values of <code>kt</code> for every iteration in the cross-validation.
</p>
</li>
<li> <p><code>kt.arima</code>  the arima selected for each <code>kt</code> time series.
</p>
</li>
<li> <p><code>Ii</code> parameter that captures the differences in the pattern of mortality in any region i with respect to Region 1.
</p>
</li>
<li> <p><code>formula</code> multi-population mortality formula used to fit the mortality rates.
</p>
</li>
<li> <p><code>model</code> provided the model selected in every case.
</p>
</li>
<li> <p><code>nPop</code> provided number of populations to fit the periods.
</p>
</li>
<li> <p><code>qxt.crude</code> corresponds to the crude mortality rates. These crude rate are directly obtained by dividing the number of registered deaths by the number of those initially exposed to the risk for age x, period t and in each region i.
</p>
</li>
<li> <p><code>qxt.future</code> future mortality rates estimated with the multi-population mortality model.
</p>
</li>
<li> <p><code>logit.qxt.future</code> future mortality rates in logit way estimated with the multi-population mortality model.
</p>
</li>
<li> <p><code>meas_ages</code> measure of forecasting accuracy through the ages of the study.
</p>
</li>
<li> <p><code>meas_periodsfut</code> measure of forecasting accuracy in every forecasting period(s) of the study.
</p>
</li>
<li> <p><code>meas_pop</code> measure of forecasting accuracy through the populations considered in the study.
</p>
</li>
<li> <p><code>meas_total</code> a global measure of forecasting accuracy through the ages, periods and populations of the study.
</p>
</li>
<li> <p><code>warn_msgs </code> vector with the populations where the model has not converged.
</p>
</li></ul>



<h3>References</h3>

<p>Atance, D., Debon, A., and Navarro, E. (2020).
A comparison of forecasting mortality models using resampling methods.
Mathematics 8(9): 1550.
</p>
<p>Bergmeir, C. &amp; Benitez, J.M. (2012)
On the use of cross-validation for time series predictor evaluation.
Information Sciences, 191, 192‚Äì
</p>
<p>Carter, L.R. and Lee, R.D. (1992).
Modeling and forecasting US sex differentials in mortality.
International Journal of Forecasting, 8(3), 393‚Äì411.
</p>
<p>Debon, A., &amp; Atance, D. (2022).
Two multi-population mortality models: A comparison of the forecasting accuracy with resampling methods.
in Contributions to Risk Analysis: Risk 2022. Fundacion Mapfre
</p>
<p>Debon, A., Montes, F., &amp; Martinez-Ruiz, F. (2011).
Statistical methods to compare mortality for a group with non-divergent populations: an application to Spanish regions.
European Actuarial Journal, 1, 291-308.
</p>
<p>Lee, R.D. &amp; Carter, L.R. (1992).
Modeling and forecasting US mortality.
Journal of the American Statistical Association, 87(419), 659‚Äì671.
</p>
<p>Li, N. and Lee, R.D. (2005).
Coherent mortality forecasts for a group of populations: An extension of the Lee-Carter method.
Demography, 42(3), 575‚Äì594.
</p>
<p>Russolillo, M., Giordano, G., &amp; Haberman, S. (2011).
Extending the Lee‚ÄìCarter model: a three-way decomposition.
Scandinavian Actuarial Journal, 96-117.
</p>
<p>Santolino, M. (2023).
Should Selection of the Optimum Stochastic Mortality Model Be Based on the Original or the Logarithmic Scale of the Mortality Rate?.
Risks, 11(10), 170.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLCmulti">fitLCmulti</a></code>, <code><a href="#topic+forecast.fitLCmulti">forecast.fitLCmulti</a></code>,
<code><a href="#topic+plot.fitLCmulti">plot.fitLCmulti</a></code>, <code><a href="#topic+plot.forLCmulti">plot.forLCmulti</a></code>,
<code><a href="#topic+MeasureAccuracy">MeasureAccuracy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#The example takes more than 5 seconds because they include
#several cross-validation methods and hence all the processes are included in "donttest".

#We present a cross-validation method for spanish male regions using:

ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40,
         45, 50, 55, 60, 65, 70, 75, 80, 85, 90)
library(gnm)
library(forecast)
library(StMoMo)

#1. FIXED-ORIGIN -- using the ACFM nahead + trainset1 = periods;
#fixed_train_origin = TRUE (defualt value)
ho_Spainmales_addit &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("ACFM"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 5,
                                         trainset1 = 25,
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))
ho_Spainmales_addit

#Once, we have run the function we can check the result in different ways:
ho_Spainmales_addit$meas_ages
ho_Spainmales_addit$meas_periodsfut
ho_Spainmales_addit$meas_pop
ho_Spainmales_addit$meas_total

#2. Let's continue with a RO-recalibration,
#(fixed_train_origin = TRUE (defualt value))
#where we have implemented three main CV techniques:
#2.1. Leave-One-Out-Cross-Validation (LOOCV) RO-recalibration when nahead = 1;
#(independently the number of periods blocked for the first train set; trainset1"
loocv_Spainmales_addit &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 1, trainset1 = 10,
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))
loocv_Spainmales_addit

#Once, we have run the function we can check the result in different ways:
loocv_Spainmales_addit$meas_ages
loocv_Spainmales_addit$meas_periodsfut
loocv_Spainmales_addit$meas_pop
loocv_Spainmales_addit$meas_total

#2.2. K-Fold-CV RO-recalibration when nahead = trainset1
kfoldcv_Spainmales_addit &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 5, trainset1 = 5,
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))
kfoldcv_Spainmales_addit

#Once, we have run the function we can check the result in different ways:
kfoldcv_Spainmales_addit$meas_ages
kfoldcv_Spainmales_addit$meas_periodsfut
kfoldcv_Spainmales_addit$meas_pop
kfoldcv_Spainmales_addit$meas_total

#2.3. standard time-series CV
cv_Spainmales_addit &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 5, trainset1 = 10,
                                         fixed_train_origin = "TRUE",
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))

cv_Spainmales_addit
#Once, we have run the function we can check the result in different ways:
cv_Spainmales_addit$meas_ages
cv_Spainmales_addit$meas_periodsfut
cv_Spainmales_addit$meas_pop
cv_Spainmales_addit$meas_total

#3. RW-evaluation (fixed_train_origin = c("FALSE", "1"))
#3.1. fixed_train_origin == "TRUE" (The default value)
#In this case, the previous processes (Fixed-Origin or RO-recalibration)
#3.2. fixed_train_origin == "FALSE"
#where the origin in the training set is moved "nahead" period ahead in every iteration.
#This process allows to test the forecasting accuracy of "nahead" periods ahead
#keeping constant the size of the training and test set. As an example, we present
#three methods
#3.2.1. LOOCV
loocv_Spainmales_addit_rw &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 1, trainset1 = 10,
                                         fixed_train_origin = "FALSE",
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))

loocv_Spainmales_addit_rw

#Once, we have run the function we can check the result in different ways:
loocv_Spainmales_addit_rw$meas_ages
loocv_Spainmales_addit_rw$meas_periodsfut
loocv_Spainmales_addit_rw$meas_pop
loocv_Spainmales_addit_rw$meas_total

#3.2.2. K-Fold-CV
kfoldcv_Spainmales_addit_rw &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 5, trainset1 = 5,
                                         fixed_train_origin = "FALSE",
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))

kfoldcv_Spainmales_addit_rw

#Once, we have run the function we can check the result in different ways:
kfoldcv_Spainmales_addit$meas_ages
kfoldcv_Spainmales_addit$meas_periodsfut
kfoldcv_Spainmales_addit$meas_pop
kfoldcv_Spainmales_addit$meas_total

#3.2.3. standard time-series CV
cv_Spainmales_addit_rw &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 5, trainset1 = 10,
                                         fixed_train_origin = "FALSE",
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))

cv_Spainmales_addit_rw

#Once, we have run the function we can check the result in different ways:
cv_Spainmales_addit_rw$meas_ages
cv_Spainmales_addit_rw$meas_periodsfut
cv_Spainmales_addit_rw$meas_pop
cv_Spainmales_addit_rw$meas_total

#3.3  RW-evaluation (fixed_train_origin = c("1"))
#where the origin in the training set is moved 1 period ahead in every iteration.
#This process allows to test the forecasting accuracy of "nahead" periods ahead
#modifying the origin in the training set by 1.
#When "nahead" = 1 --- we will have a loocv equally as in the previous process,
#while using a different value of 1 for "nahead" we will test the forecasting
#accuracy of the model in "nahead" periods:
cv_Spainmales_addit_rw1 &lt;- multipopulation_cv(qxt = SpainRegions$qx_male,
                                         model = c("additive"),
                                         periods =  c(1991:2020), ages = c(ages),
                                         nPop = 18, lxt = SpainRegions$lx_male,
                                         nahead = 5, trainset1 = 15,
                                         fixed_train_origin = "1",
                                         ktmethod = c("Arimapdq"),
                                         measures = c("SSE"))
cv_Spainmales_addit_rw1

#Once, we have run the function we can check the result in different ways:
cv_Spainmales_addit_rw1$meas_ages
cv_Spainmales_addit_rw1$meas_periodsfut
cv_Spainmales_addit_rw1$meas_pop
cv_Spainmales_addit_rw1$meas_total


</code></pre>

<hr>
<h2 id='plot.fitLCmulti'>Function to plot the parameters of the multi-population mortality models</h2><span id='topic+plot.fitLCmulti'></span>

<h3>Description</h3>

<p>R function to plot the parameters for the additive (Debon et al., 2011), multiplicative (Russolillo et al., 2011), common-factor (CFM) (Carter and Lee, 1992), Joint-k (Carter and Lee, 1992), and augmented-common factor (ACFM) (Li and Lee, 2005) multi-Population mortality model.
It should be mentioned that in case that this function is developed for fitting several populations.
However, in case you only consider one population, the function will fit the one-population Lee-Carter model (Lee and Carter, 1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitLCmulti'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fitLCmulti_+3A_x">x</code></td>
<td>
<p><code>x</code> developed using function <code>fitLCmulti()</code> which are objects of the <code>fitLCmulti</code> class.</p>
</td></tr>
<tr><td><code id="plot.fitLCmulti_+3A_...">...</code></td>
<td>
<p>additional arguments to show in the plot appearance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot the different parameters for the multi-population mortality models <code>ax</code>, <code>bx</code>, <code>kt</code> and <code>Ii</code>. This function is valid for both approaches Additive and Multiplicative multi-population mortality models.
</p>


<h3>References</h3>

<p>Carter, L.R. and Lee, R.D. (1992).
Modeling and forecasting US sex differentials in mortality.
International Journal of Forecasting, 8(3), 393‚Äì411.
</p>
<p>Debon, A., Montes, F., &amp; Martinez-Ruiz, F. (2011).
Statistical methods to compare mortality for a group with non-divergent populations: an application to Spanish regions.
European Actuarial Journal, 1, 291-308.
</p>
<p>Lee, R.D. &amp; Carter, L.R. (1992).
Modeling and forecasting US mortality.
Journal of the American Statistical Association, 87(419), 659‚Äì671.
</p>
<p>Li, N. and Lee, R.D. (2005).
Coherent mortality forecasts for a group of populations: An extension of the Lee-Carter method.
Demography, 42(3), 575‚Äì594.
</p>
<p>Multi-population mortality model developed by:
Russolillo, M., Giordano, G., &amp; Haberman, S. (2011).
Extending the Lee‚ÄìCarter model: a three-way decomposition.
Scandinavian Actuarial Journal, 2011(2), 96-117.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLCmulti">fitLCmulti</a></code>, <code><a href="#topic+forecast.fitLCmulti">forecast.fitLCmulti</a></code>,
<code><a href="#topic+plot.forLCmulti">plot.forLCmulti</a></code>, <code><a href="#topic+multipopulation_cv">multipopulation_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#First, we present the data that we are going to use
SpainRegions
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)

library(gnm)
library(forecast)
#1. ADDITIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the additive multi-population mortality model
additive_Spainmales &lt;- fitLCmulti(model = "additive",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

additive_Spainmales

#If the user does not provide the model inside the function fitLCmult()
#the multi-population mortality model applied will be additive one.

#Once, we have fit the data, it is possible to see the ax, bx, kt, and Ii
#provided parameters for the fitting.
plot(additive_Spainmales)

#2. MULTIPLICATIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the multiplicative multi-population mortality model
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

multiplicative_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(multiplicative_Spainmales)

#3. COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the common-factor multi-population mortality model
cfm_Spainmales &lt;- fitLCmulti(model = "CFM",
                             qxt = SpainRegions$qx_male,
                             periods = c(1991:2020),
                             ages = c(ages),
                             nPop = 18,
                             lxt = SpainRegions$lx_male)

cfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(cfm_Spainmales)

#4. JOINT-K MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the augmented-common-factor multi-population mortality model
jointk_Spainmales &lt;- fitLCmulti(model = "joint-K",
                                qxt = SpainRegions$qx_male,
                                periods = c(1991:2020),
                                ages = c(ages),
                                nPop = 18,
                                lxt = SpainRegions$lx_male)

jointk_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(jointk_Spainmales)

#5. AUGMENTED-COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the augmented-common-factor multi-population mortality model
acfm_Spainmales &lt;- fitLCmulti(model = "ACFM",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

acfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(acfm_Spainmales)

#6. LEE-CARTER FOR SINGLE-POPULATION
#As we mentioned in the details of the function, if we only provide the data
#from one-population the function fitLCmulti()
#will fit the Lee-Carter model for single populations.
LC_Spainmales &lt;- fitLCmulti(qxt = SpainNat$qx_male,
                              periods = c(1991:2020),
                              ages = ages,
                              model = "additive",
                              nPop = 1)

LC_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, and kt
#parameters provided for the single version of the LC.
plot(LC_Spainmales)


</code></pre>

<hr>
<h2 id='plot.forLCmulti'>Function to plot the parameters of the multi-population mortality models</h2><span id='topic+plot.forLCmulti'></span>

<h3>Description</h3>

<p>Function to plot different results of the forecasting process of multi-population mortality models, the additive (Debon et al., 2011) and the multiplicative (Russolillo et al., 2011), obtained using the <code>forecast.fitLCmulti</code> function which are xs of the <code>forecastLCmulti</code> class.
In fact, the function will show the trend parameter kt fitted for the in-sample periods and its forecast results. Similarly, the behavior of the logit mortality rate for the mean in-sample age and the out-of-sample forecast will be shown for all the populations considered.
It should be mentioned that this function is developed for fitting several populations.
However, in case you only consider one population, the function will show the single population version of the Lee-Carter model, the classical one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forLCmulti'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.forLCmulti_+3A_x">x</code></td>
<td>
<p><code>x</code> developed using function <code>forecast.fitLCmulti()</code> which are objects of the <code>fortLCmulti</code> class.</p>
</td></tr>
<tr><td><code id="plot.forLCmulti_+3A_...">...</code></td>
<td>
<p>additional arguments to show in the plot appearance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot the trend parameter kt fitted for the in-sample periods and its forecast results for the multi-population mortality models. Similarly, the behavior of the logit mortality rate for the mean in-sample age and the out-of-sample forecast will be shown for all the populations considered.
</p>


<h3>References</h3>

<p>Debon, A., Montes, F., &amp; Martinez-Ruiz, F. (2011).
Statistical methods to compare mortality for a group with non-divergent populations: an application to Spanish regions.
European Actuarial Journal, 1, 291-308.
</p>
<p>Lee, R.D. &amp; Carter, L.R. (1992).
Modeling and forecasting US mortality.
Journal of the American Statistical Association, 87(419), 659‚Äì671.
</p>
<p>Multi-population mortality model developed by:
Russolillo, M., Giordano, G., &amp; Haberman, S. (2011).
Extending the Lee‚ÄìCarter model: a three-way decomposition.
Scandinavian Actuarial Journal, 2011(2), 96-117.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLCmulti">fitLCmulti</a></code>, <code><a href="#topic+forecast.fitLCmulti">forecast.fitLCmulti</a></code>,
<code><a href="#topic+plot.fitLCmulti">plot.fitLCmulti</a></code>,
<code><a href="#topic+multipopulation_cv">multipopulation_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#First, we present the data that we are going to use
SpainRegions
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)

library(gnm)
library(forecast)
#1. ADDITIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the additive multi-population mortality model
additive_Spainmales &lt;- fitLCmulti(model = "additive",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

additive_Spainmales

#If the user does not provide the model inside the function fitLCmult()
#the multi-population mortality model applied will be additive one.

#Once, we have fit the data, it is possible to see the ax, bx, kt, and Ii
#provided parameters for the fitting.
plot(additive_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_additive_Spainmales &lt;- forecast(object = additive_Spainmales, nahead = 10,
                                    ktmethod = "Arimapdq")

fut_additive_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_additive_Spainmales)

#2. MULTIPLICATIVE MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the multiplicative multi-population mortality model
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

multiplicative_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(multiplicative_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_multi_Spainmales &lt;- forecast(object = multiplicative_Spainmales, nahead = 10,
                                 ktmethod = "Arimapdq")

fut_multi_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_multi_Spainmales)

#3. COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the common-factor multi-population mortality model
cfm_Spainmales &lt;- fitLCmulti(model = "CFM",
                             qxt = SpainRegions$qx_male,
                             periods = c(1991:2020),
                             ages = c(ages),
                             nPop = 18,
                             lxt = SpainRegions$lx_male)

cfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(cfm_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_cfm_Spainmales &lt;- forecast(object = cfm_Spainmales, nahead = 10,
                               ktmethod = "Arimapdq")

fut_cfm_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_cfm_Spainmales)

#4. AUGMENTED-COMMON-FACTOR MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the augmented-common-factor multi-population mortality model
acfm_Spainmales &lt;- fitLCmulti(model = "ACFM",
                              qxt = SpainRegions$qx_male,
                              periods = c(1991:2020),
                              ages = c(ages),
                              nPop = 18,
                              lxt = SpainRegions$lx_male)

acfm_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(acfm_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_acfm_Spainmales &lt;- forecast(object = acfm_Spainmales, nahead = 10,
                               ktmethod = "Arimapdq")

fut_acfm_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_acfm_Spainmales)

#5. JOINT-K MULTI-POPULATION MORTALITY MODEL
#In the case, the user wants to fit the joint-K multi-population mortality model
jointk_Spainmales &lt;- fitLCmulti(model = "joint-K",
                                qxt = SpainRegions$qx_male,
                                periods = c(1991:2020),
                                ages = c(ages),
                                nPop = 18,
                                lxt = SpainRegions$lx_male)

jointk_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, kt, and It
#provided parameters for the fitting.
plot(jointk_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_jointk_Spainmales &lt;- forecast(object = jointk_Spainmales, nahead = 10,
                               ktmethod = "Arimapdq")

fut_jointk_Spainmales
#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_jointk_Spainmales)

#6. LEE-CARTER FOR SINGLE-POPULATION
#As we mentioned in the details of the function, if we only provide the data
#from one-population the function fitLCmulti()
#will fit the Lee-Carter model for single populations.
LC_Spainmales &lt;- fitLCmulti(qxt = SpainNat$qx_male,
                              periods = c(1991:2020),
                              ages = ages,
                              model = "additive",
                              nPop = 1)

LC_Spainmales

#Once, we have fit the data, it is possible to see the ax, bx, and kt
#parameters provided for the single version of the LC.
plot(LC_Spainmales)

#Once, we have fit the data, it is possible to forecast the multipopulation
#mortality model several years ahead, for example 10, as follows:
fut_LC_Spainmales &lt;- forecast(object = LC_Spainmales, nahead = 10,
                              ktmethod = "Arimapdq")

#Once the data have been adjusted, it is possible to display the fitted kt and
#its out-of-sample forecasting. In addition, the function shows
#the logit mortality adjusted in-sample and projected out-of-sample
#for the mean age of the data considered in all populations.
plot(fut_LC_Spainmales)


</code></pre>

<hr>
<h2 id='regions'>regions</h2><span id='topic+regions'></span>

<h3>Description</h3>

<p>Data from the Spanish region of Spain which are provided to plot an indicator.
This dataset contains a plot with the information of Spain regions (geometry and name of every region).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regions
</code></pre>


<h3>Format</h3>

<p>A data frame with 600 rows and 9 columns with class <code>"SpainRegionsData"</code> including the following information
</p>

<ul>
<li> <p><code>Codigo</code> a vector containing the code of every region of Spain.
</p>
</li>
<li> <p><code>Texto</code> a vector containing the name of every region of Spain.
</p>
</li>
<li> <p><code>Texto_Alt</code> a vector containing the long name of every region of Spain.
</p>
</li>
<li> <p><code>Ii</code> a vector containing a possible value of one indicator to be shown.
</p>
</li>
<li> <p><code>geometry</code> the dimension of every region of Spain. This vector allows to plot the regions of Spain.
</p>
</li></ul>



<h3>Value</h3>

<p>a plot with the Spain regions colored by the indicator provided.
</p>


<h3>References</h3>

<p>Spanish National Institute of Statistics (INE) (2023). Tablas de mortalidad, metodologia.
Technical report, Instituto Nacional de Estadistica
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#In this case, we show the region dataset applying it to a multipopulation model.
#First, we present the dataset

regions

ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)

#Then, we fit the multiplicative model
library(gnm)
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                                        qxt = SpainRegions$qx_male,
                                        periods = c(1991:2020),
                                        ages = c(ages),
                                        nPop = 18,
                                        lxt = SpainRegions$lx_male)

multiplicative_Spainmales
library(sf)
#To show the values of the population indicator in the Spanish map.
SpainMap(regionvalue = multiplicative_Spainmales$Ii[2:18],
         main = c("Multiplicative for males"),
         name = c("Ii"))

</code></pre>

<hr>
<h2 id='residSVD2'>Function to extract the resid from SVD</h2><span id='topic+residSVD2'></span>

<h3>Description</h3>

<p>This function uses the first <code>d</code> components of the singular value
decomposition in order to approximate a vector of model residuals by a
sum of <code>d</code> multiplicative terms, with the multiplicative
structure determined by two specified factors follows the SVD function by Turner et al. (2023).
For <code>glm</code> and <code>gnm</code> models from the <code>gnm</code> R-packages,
the matrix entries are weighted working residuals.  The primary use of <code>residSVD</code> is to
generate good starting values for the parameters in <a href="gnm.html#topic+Mult">Mult</a> terms
in models to be fitted using <a href="gnm.html#topic+gnm">gnm</a>. In this case, we modified the function
in order to obtain good starting values for the multi-population mortality models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residSVD2(model, fac1, fac2, d = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residSVD2_+3A_model">model</code></td>
<td>
<p>object with <a href="stats.html#topic+na.action">na.action</a>, <a href="stats.html#topic+residuals">residuals</a>, and <a href="stats.html#topic+weights">weights</a> methods, e.g. objects inheriting from class <code>"gnm"</code>.</p>
</td></tr>
<tr><td><code id="residSVD2_+3A_fac1">fac1</code></td>
<td>
<p>first factor.</p>
</td></tr>
<tr><td><code id="residSVD2_+3A_fac2">fac2</code></td>
<td>
<p>second factor.</p>
</td></tr>
<tr><td><code id="residSVD2_+3A_d">d</code></td>
<td>
<p>integer, the number of multiplicative terms to use in the approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>d = 1</code>, a numeric vector; otherwise a numeric matrix with <code>d</code> columns.
</p>


<h3>References</h3>

<p>Turner, H., &amp; Firth, D. (2023).
Generalized nonlinear models in R: An overview of the gnm package.
R package version 1.1-5. https://CRAN.R-project.org/package=gnm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitLCmulti">fitLCmulti</a></code>, <code><a href="#topic+forecast.fitLCmulti">forecast.fitLCmulti</a></code>
<code><a href="#topic+multipopulation_cv">multipopulation_cv</a></code>, <code><a href="#topic+plot.fitLCmulti">plot.fitLCmulti</a></code>
<code><a href="#topic+plot.forLCmulti">plot.forLCmulti</a></code>
</p>

<hr>
<h2 id='SpainMap'>Spain National map information</h2><span id='topic+SpainMap'></span>

<h3>Description</h3>

<p>This data contains information to plot the percentiles plot in Spanish regions. Therefore, the users only have to provide a specific variable to show in regions of Spain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpainMap(regionvalue, main, name, bigred = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpainMap_+3A_regionvalue">regionvalue</code></td>
<td>
<p>vector with the values that you want to plot in percentiles in the Spain map.</p>
</td></tr>
<tr><td><code id="SpainMap_+3A_main">main</code></td>
<td>
<p>the specific title of the map plot</p>
</td></tr>
<tr><td><code id="SpainMap_+3A_name">name</code></td>
<td>
<p>the assigned name for the legend in map plot.</p>
</td></tr>
<tr><td><code id="SpainMap_+3A_bigred">bigred</code></td>
<td>
<p>if the user wants red color for bigger values in the regions <code>bigred</code> == <code>'TRUE'</code> (default value). However if the user wants to modify the colors and assign red to lower values <code>bigred</code> == <code>'FALSE'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a map from the regions of Spain colored with the variable provided by the user.
</p>


<h3>References</h3>

<p>Spanish National Institute of Statistics (INE) (2023). Tablas de mortalidad, metodologia.
Technical report, Instituto Nacional de Estadistica
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name &lt;- c("Ii")
main &lt;- c("Multiplicative for males")
regionvalue &lt;- c(0.131867619, -0.063994652,  0.088094096,
                 0.019685552,  0.064671498,   0.012212161,
                -0.088864474, -0.146079884, -0.017703536,
                 0.050376721,  0.052476852, -0.022871202,
                -0.093952332,  0.049266816, -0.101224890,
                 0.001481333, -0.078523511)

library(sf)

SpainMap(regionvalue, main, name)

</code></pre>

<hr>
<h2 id='SpainNat'>Spain National Mortality data</h2><span id='topic+SpainNat'></span>

<h3>Description</h3>

<p>Data from the Spanish national of Spain from the Spanish National Institute of Statistics (INE) for both genders years 1991-2020 and abridged ages from 0 to 90.
This dataset contains mortality rates for the total national population of Spain.
Additionally, the dataset includes the number of people alive (lxt) for each age and period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpainNat
</code></pre>


<h3>Format</h3>

<p>A data frame with 600 rows and 9 columns with class <code>"CVmortalityData"</code> including the following information
</p>

<ul>
<li> <p><code>ccaa</code> a vector containing all the regions of Spain. Indeed, the column takes the following information: Spain.
</p>
</li>
<li> <p><code>years</code> a vector containing the periods of the dataset from 1991 to 2020.
</p>
</li>
<li> <p><code>ages</code> a vector containing the abridged ages considered in the dataset, 0, &lt;1, 1-4, 5-9, 10-14, 15-19, 20-24, 25-29, 30-34, 35-39, 40-44, 45-49, 50-54, 55-59, 60-64, 65-69, 70-74, 75-79, 80-84, 85-89, and 90-94.
</p>
</li>
<li> <p><code>qx_male</code> mortality rates for the males in the Spain Nation.
</p>
</li>
<li> <p><code>qx_female</code> mortality rates for the females in the Spain Nation.
</p>
</li>
<li> <p><code>lx_male</code> survivor function considered for the males of Spain Nation.
</p>
</li>
<li> <p><code>lx_female</code> survivor function considered for the females of Spain Nation.
</p>
</li>
<li> <p><code>series</code> information for the series of data provided.
</p>
</li>
<li> <p><code>label</code> the assigned tag to the data frame.
</p>
</li></ul>



<h3>References</h3>

<p>Spanish National Institute of Statistics (INE) (2023). Tablas de mortalidad, metodologia.
Technical report, Instituto Nacional de Estadistica
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#In this case, we show the region dataset applying it to a multipopulation model.
#First, we present the dataset
SpainNat
#An example to how the additive multi-population model fits the data
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)
library(gnm)
LC_Spainmales &lt;- fitLCmulti(qxt = SpainNat$qx_male,
                            periods = c(1991:2020),
                            ages = ages,
                            model = "additive",
                            nPop = 1)

LC_Spainmales

</code></pre>

<hr>
<h2 id='SpainRegions'>Spain Regions Mortality data</h2><span id='topic+SpainRegions'></span>

<h3>Description</h3>

<p>Data from the Spanish region of Spain from the Spanish National Institute of Statistics (INE) for both genders years 1991-2020 and abridged ages from 0 to 90.
This dataset contains mortality rates (qxt) from 18 different regions of Spain.
Additionally, the dataset includes the number of people alive (lxt) for each age and period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpainRegions
</code></pre>


<h3>Format</h3>

<p>A data frame with 10800 rows and 9 columns with class <code>"CVmortalityData"</code> including the following information
</p>

<ul>
<li> <p><code>ccaa</code> a vector containing all the regions of Spain. Indeed, the column takes the following information: Spain, Andalucia, Aragon, Asturias, Baleares, Canarias, Cantabria, Castillayla Mancha, CastillayLeon, Cataluna, ComunidadValenciana, Extremadura, Galicia, Madrid, Murcia, Navarra, PaisVasco, and LaRioja.
</p>
</li>
<li> <p><code>periods</code> a vector containing the periods of the dataset from 1991 to 2020.
</p>
</li>
<li> <p><code>ages</code> a vector containing the abridged ages considered in the dataset, 0, &lt;1, 1-4, 5-9, 10-14, 15-19, 20-24, 25-29, 30-34, 35-39, 40-44, 45-49, 50-54, 55-59, 60-64, 65-69, 70-74, 75-79, 80-84, 85-89, and 90-94.
</p>
</li>
<li> <p><code>qx_male</code> mortality rates for the males in every region of Spain including Nation data.
</p>
</li>
<li> <p><code>qx_female</code> mortality rates for the females in every region of Spain including Nation data.
</p>
</li>
<li> <p><code>lx_male</code> survivor function considered for the males in every region of Spain including Nation data.
</p>
</li>
<li> <p><code>lx_female</code> survivor function considered for the females in every region of Spain including Nation data.
</p>
</li>
<li> <p><code>series</code> information for the series of data provided.
</p>
</li>
<li> <p><code>label</code> the assigned tag to the data frame.
</p>
</li></ul>



<h3>References</h3>

<p>Spanish National Institute of Statistics (INE) (2023). Tablas de mortalidad, metodologia.
Technical report, Instituto Nacional de Estadistica
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example takes more than 5 seconds because it includes
#several fitting and forecasting process and hence all
#the process is included in donttest

#In this case, we show the region dataset applying it to a multipopulation model.
#First, we present the dataset
SpainRegions

#An example to how the additive multi-population model fits the data
ages &lt;- c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90)

library(gnm)
multiplicative_Spainmales &lt;- fitLCmulti(model = "multiplicative",
                                        qxt = SpainRegions$qx_male,
                                        periods = c(1991:2020),
                                        ages = c(ages),
                                        nPop = 18,
                                        lxt = SpainRegions$lx_male)

multiplicative_Spainmales

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
