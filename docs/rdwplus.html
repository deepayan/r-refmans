<!DOCTYPE html><html><head><title>Help for package rdwplus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rdwplus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#burn_in'><p>Burn in streams to a digital elevation model</p></a></li>
<li><a href='#check_running'><p>Check whether a valid GRASS session is running</p></a></li>
<li><a href='#clear_mask'><p>Clear current raster mask</p></a></li>
<li><a href='#compute_iFLO_weights'><p>Compute iFLO weights</p></a></li>
<li><a href='#compute_iFLS_weights'><p>Compute iFLS weights</p></a></li>
<li><a href='#compute_metrics'><p>Compute spatially explicit watershed attributes for survey sites on streams</p></a></li>
<li><a href='#compute_metrics_precomputed'><p>Compute spatially explicit watershed attributes for survey sites on streams</p></a></li>
<li><a href='#convert_to_integer'><p>Convert a raster to integer format</p></a></li>
<li><a href='#coord_to_raster'><p>Turn coordinates of outlets into rasters</p></a></li>
<li><a href='#derive_flow'><p>Obtain flow direction and accumulation over a digital elevation model (DEM)</p></a></li>
<li><a href='#derive_streams'><p>Extract streams from a flow accumulation raster</p></a></li>
<li><a href='#fill_sinks'><p>Fill sinks in a digital elevation model (DEM)</p></a></li>
<li><a href='#get_distance'><p>Compute Euclidean distance to a survey site or stream line within a watershed</p></a></li>
<li><a href='#get_flow_length'><p>Derive a flow length to streams and outlets</p></a></li>
<li><a href='#get_watersheds'><p>Delineate watersheds for survey sites</p></a></li>
<li><a href='#install_extensions'><p>Install required extension(s)</p></a></li>
<li><a href='#plot_GRASS'><p>A function to plot a raster from the current GRASS mapset</p></a></li>
<li><a href='#point_to_raster'><p>Convert outlet of a watershed from shapefile format into raster format</p></a></li>
<li><a href='#rast_calc'><p>Raster calculator (wrapper for &quot;r.mapcalc&quot;)</p></a></li>
<li><a href='#raster_to_mapset'><p>Import rasters into GRASS mapset</p></a></li>
<li><a href='#rasterise_stream'><p>Turn a shapefile of stream edges into a raster</p></a></li>
<li><a href='#rdwplus-package'><p>An Implementation of IDW-PLUS (Inverse Distance Weighted Percent Land Use for Streams) in R</p></a></li>
<li><a href='#reclassify_streams'><p>Reclassify streams into various formats</p></a></li>
<li><a href='#report_mapset'><p>Identify current mapset or list all possible mapsets</p></a></li>
<li><a href='#retrieve_raster'><p>Write a raster layer from the current GRASS mapset to file</p></a></li>
<li><a href='#retrieve_vector'><p>Write a vector layer from the current GRASS mapset to file</p></a></li>
<li><a href='#search_for_grass'><p>Find GRASS installations</p></a></li>
<li><a href='#set_envir'><p>Set projection and computation region from a raster file.</p></a></li>
<li><a href='#set_mask'><p>Set a raster mask</p></a></li>
<li><a href='#silence'><p>Function to suppress messages, warnings, errors from GRASS commands</p></a></li>
<li><a href='#snap_sites'><p>A function to snap survey sites to a stream raster and a flow accumulation raster</p></a></li>
<li><a href='#toggle_silence'><p>Toggle between silence on and silence off</p></a></li>
<li><a href='#vector_to_mapset'><p>Import rasters into GRASS mapset</p></a></li>
<li><a href='#vibe_check'><p>A function to summarise the computation region, vectors and rasters in the mapset.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Date:</td>
<td>2023-08-04</td>
</tr>
<tr>
<td>Title:</td>
<td>An Implementation of IDW-PLUS</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Pearse [aut, cre],
  Grace Heron [aut],
  Erin Peterson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Pearse &lt;arp320@uowmail.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute spatially explicit land-use metrics for stream survey sites in GRASS GIS and R as an open-source implementation of IDW-PLUS (Inverse Distance Weighted Percent Land Use for Streams). The package includes functions for preprocessing digital elevation and streams data, and one function to compute all the spatially explicit land use metrics described in Peterson et al. (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1365-2427.2010.02507.x">doi:10.1111/j.1365-2427.2010.02507.x</a>&gt; and previously implemented by Peterson and Pearse (2017) &lt;<a href="https://doi.org/10.1111%2F1752-1688.12558">doi:10.1111/1752-1688.12558</a>&gt; in ArcGIS-Python as IDW-PLUS. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), rgrass</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, stars, sf, stringr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 15:37:07 UTC; aryou</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 00:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='burn_in'>Burn in streams to a digital elevation model</h2><span id='topic+burn_in'></span>

<h3>Description</h3>

<p>Burning-in streams (also called 'drainage reinforcement') ensures flow direction and accumulation grids based on the digital elevation model will correctly identify the stream path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>burn_in(dem, stream, out, burn = 10, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="burn_in_+3A_dem">dem</code></td>
<td>
<p>Digital elevation model raster in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="burn_in_+3A_stream">stream</code></td>
<td>
<p>Binary stream raster in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="burn_in_+3A_out">out</code></td>
<td>
<p>Name of output to be created in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="burn_in_+3A_burn">burn</code></td>
<td>
<p>The magnitude of the drainage reinforcement in elevation units. Defaults to <code>10</code> elevation units.</p>
</td></tr>
<tr><td><code id="burn_in_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the file <code>out</code> should be overwritten in the mapset and on disk. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A raster with the name <code>out</code> will be written to the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if a GRASS session is initialised
if(check_running()){
# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")
set_envir(dem)
raster_to_mapset(dem)
vector_to_mapset(stream_shp)

# Create binary stream
rasterise_stream("streams", "streams_rast")
reclassify_streams("streams_rast", "streams_binary", out_type = "binary")

# Burn dem 
burn_in(dem = "dem.tif", stream = "streams_binary", 
out = "dem_burn", burn = 10, overwrite = FALSE)

# Plot
plot_GRASS("dem_burn", col = topo.colors(10))
}
</code></pre>

<hr>
<h2 id='check_running'>Check whether a valid GRASS session is running</h2><span id='topic+check_running'></span>

<h3>Description</h3>

<p>This function is mostly used internally by other functions in the package. However, users may call this function to check whether they have correctly established a GRASS session prior to using the other functions in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_running()
</code></pre>


<h3>Value</h3>

<p>A logical. The logical indicates whether a valid GRASS session is currently running.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
check_running()

</code></pre>

<hr>
<h2 id='clear_mask'>Clear current raster mask</h2><span id='topic+clear_mask'></span>

<h3>Description</h3>

<p>This function has no parameters. It can be used to clear an existing raster mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_mask()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()) clear_mask()
</code></pre>

<hr>
<h2 id='compute_iFLO_weights'>Compute iFLO weights</h2><span id='topic+compute_iFLO_weights'></span>

<h3>Description</h3>

<p>Compute an iFLO weight raster outside of the <code>compute_metrics()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_iFLO_weights(
  pour_point,
  watershed,
  null_streams,
  flow_dir,
  out_flow_length,
  out_iFLO,
  out_iFLO_no_stream,
  idwp = -1,
  remove_streams = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_iFLO_weights_+3A_pour_point">pour_point</code></td>
<td>
<p>Pour point raster containing a single pour point (i.e., the outlet).</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_watershed">watershed</code></td>
<td>
<p>Watershed raster to use as a mask for the flow-path calculations.</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_null_streams">null_streams</code></td>
<td>
<p>A streams raster with NoData for the stream cells and 1s everywhere else</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_flow_dir">flow_dir</code></td>
<td>
<p>A flow direction raster.</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_out_flow_length">out_flow_length</code></td>
<td>
<p>Name of the output flow length raster.</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_out_iflo">out_iFLO</code></td>
<td>
<p>Name of the output weights raster.</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_out_iflo_no_stream">out_iFLO_no_stream</code></td>
<td>
<p>Name of the output weights raster excluding cells on the stream line (ignored inf <code>remove_streams = FALSE</code>).</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_idwp">idwp</code></td>
<td>
<p>An inverse distance weighting power. This should be negative. The value <code>idwp = -1</code> is the default.</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_remove_streams">remove_streams</code></td>
<td>
<p>A logical indicating whether cells corresponding to the stream line should be removed from the weights raster. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compute_iFLO_weights_+3A_...">...</code></td>
<td>
<p>Optional extra arguments to <code>get_flow_length()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Recode streams
reclassify_streams("new_stm.tif", "null_stm.tif", "none")

# Snap sites to streams and flow accumulation
snap_sites("site", "new_stm.tif", "fa.tif", 2, "snapsite", T)

# Get watersheds
get_watersheds("snapsite", "fd.tif", "wshed.tif", T)

#  Get pour points
coord_to_raster("snapsite", which = 1, out = "pour_point")

# Get iFLO weights
compute_iFLO_weights(
"pour_point", 
"wshed.tif", 
"null_stm.tif", 
"fd.tif", 
"fl_outlet.tif", 
"iFLO_weights.tif", 
idwp = -1, 
remove_streams = FALSE
)
plot_GRASS("iFLO_weights.tif", col = topo.colors(12))
}
</code></pre>

<hr>
<h2 id='compute_iFLS_weights'>Compute iFLS weights</h2><span id='topic+compute_iFLS_weights'></span>

<h3>Description</h3>

<p>Compute an iFLO weight raster outside of the <code>compute_metrics()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_iFLS_weights(
  streams,
  null_streams,
  flow_dir,
  out_flow_length,
  out_iFLS,
  out_iFLS_no_stream,
  watershed,
  idwp,
  remove_streams,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_iFLS_weights_+3A_streams">streams</code></td>
<td>
<p>Pour point raster containing a single pour point (i.e., the outlet).</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_null_streams">null_streams</code></td>
<td>
<p>A streams raster with NoData for the stream cells and 1s everywhere else</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_flow_dir">flow_dir</code></td>
<td>
<p>A flow direction raster.</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_out_flow_length">out_flow_length</code></td>
<td>
<p>Name of the output flow length raster.</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_out_ifls">out_iFLS</code></td>
<td>
<p>Name of the output weights raster.</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_out_ifls_no_stream">out_iFLS_no_stream</code></td>
<td>
<p>Name of the output weights raster excluding cells on the stream line (ignored inf <code>remove_streams = FALSE</code>).</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_watershed">watershed</code></td>
<td>
<p>Watershed raster to use as a mask for the flow-path calculations. This is optional for the iFLS weight calculations.</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_idwp">idwp</code></td>
<td>
<p>An inverse distance weighting power. This should be negative. The value <code>idwp = -1</code> is the default.</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_remove_streams">remove_streams</code></td>
<td>
<p>A logical indicating whether cells corresponding to the stream line should be removed from the weights raster. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compute_iFLS_weights_+3A_...">...</code></td>
<td>
<p>Optional extra arguments to <code>get_flow_length()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Recode streams
reclassify_streams("new_stm.tif", "null_stm.tif", "none")

# Snap sites to streams and flow accumulation
snap_sites("site", "new_stm.tif", "fa.tif", 2, "snapsite", T)

# Get watersheds
get_watersheds("snapsite", "fd.tif", "wshed.tif", T)

# Get iFLS weights
compute_iFLS_weights(
"new_stm.tif", 
"null_stm.tif", 
"fd.tif", 
"fl_streams.tif", 
"iFLS_weights.tif", 
idwp = -1, 
watershed = "wshed.tif", 
remove_streams = FALSE, 
overwrite = T
)
plot_GRASS("iFLS_weights.tif", col = topo.colors(12))
}
</code></pre>

<hr>
<h2 id='compute_metrics'>Compute spatially explicit watershed attributes for survey sites on streams</h2><span id='topic+compute_metrics'></span>

<h3>Description</h3>

<p>Workhorse function for <code>rdwplus</code>. This function computes the spatially explicit landuse metrics in IDW-Plus (Peterson and Pearse, 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_metrics(
  metrics = c("lumped", "iFLO", "iFLS", "HAiFLO", "HAiFLS"),
  landuse,
  sites,
  out_fields,
  watersheds,
  flow_dir,
  flow_acc,
  streams,
  idwp = -1,
  percentage = TRUE,
  remove_streams = TRUE,
  max_memory = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_metrics_+3A_metrics">metrics</code></td>
<td>
<p>A character vector. This vector specifies which metric(s) should be calculated. Your options are lumped, iFLO, iFLS, iEDO, iEDS, HAiFLO and HAiFLS. The default is to calculate the lumped, iFLO, iFLS, HAiFLO, and HAiFLS metrics.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_landuse">landuse</code></td>
<td>
<p>Names of landuse or landcover rasters in the current GRASS mapset. These can be continuous (e.g., percentage cover or NDVI) or binary, with a value of 1 for cells with a particular land use category and a value of 0 otherwise.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_sites">sites</code></td>
<td>
<p>A set of survey sites in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_out_fields">out_fields</code></td>
<td>
<p>A character vector of output field names to store the metrics. Note that <code>length(out_fields)</code> must be the same as <code>length(landuse) * length(metrics)</code>.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_watersheds">watersheds</code></td>
<td>
<p>A vector of watershed raster names in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_flow_dir">flow_dir</code></td>
<td>
<p>Name of a flow direction raster produced by <code>derive_flow</code> in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_flow_acc">flow_acc</code></td>
<td>
<p>Name of a flow accumulation raster produced by <code>derive_flow</code> in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_streams">streams</code></td>
<td>
<p>Name of a streams raster in the current GRASS mapset. The stream raster must have NoData values in cells that do not fall along the stream line. Optional if you are not asking for the iFLS, iEDS, and/or HAiFLS metrics.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_idwp">idwp</code></td>
<td>
<p>The inverse distance weighting parameter. Default is <code>-1</code>.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_percentage">percentage</code></td>
<td>
<p>A logical indicating whether the result should be expressed as a percentage. Defaults to <code>TRUE</code>. Set to <code>FALSE</code> if the landuse/landcover raster is continuous.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_remove_streams">remove_streams</code></td>
<td>
<p>A logical indicating whether cells falling on the stream line should be removed from iEDS, iFLS, and HAiFLS metrics. Defaults to <code>TRUE</code>, which is in line with the behaviour of IDWPLUS.</p>
</td></tr>
<tr><td><code id="compute_metrics_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object of the snapped survey sites that also contains the computed landscape metrics.
</p>


<h3>References</h3>

<p>Peterson, E.E. &amp; Pearse, A.R. (2017). IDW-Plus: An ArcGIS toolset for calculating spatially explicit watershed attributes for survey sites. <em>JAWRA</em>, <em>53</em>(5), 1241-1249.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
# You should load rdwplus and initialise GRASS via the initGRASS function
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment 
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Snap sites to streams and flow accumulation
snap_sites("site", "new_stm.tif", "fa.tif", 2, "snapsite", T)

# Get watersheds
get_watersheds("snapsite", "fd.tif", "wshed.tif", T)

compute_metrics(
  metrics = c("lumped", "iFLO", "iEDO", "HAiFLO", "iFLS", "iEDS", "HAiFLS"),
  landuse = "landuse.tif",
  sites = "snapsite",
  out_fields = c("lumped", "iFLO", "iEDO", "HAiFLO", "iFLS", "iEDS", "HAiFLS"),
  watersheds = "wshed.tif",
  flow_dir = "fd.tif",
  flow_acc = "fa.tif",
  streams = "new_stm.tif",
  idwp = -1
)
}
</code></pre>

<hr>
<h2 id='compute_metrics_precomputed'>Compute spatially explicit watershed attributes for survey sites on streams</h2><span id='topic+compute_metrics_precomputed'></span>

<h3>Description</h3>

<p>Workhorse function for <code>rdwplus</code>. This function computes the spatially explicit landuse metrics in IDW-Plus (Peterson and Pearse, 2017). In contrast to <code>compute_metrics()</code>, this version of the function assumes most of the intermediate data layers (i.e., flow path distance and inverse-distance weight rasters) have been precomputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_metrics_precomputed(
  metrics = c("lumped", "iFLO", "iFLS", "HAiFLO", "HAiFLS"),
  landuse,
  sites,
  out_fields,
  watersheds,
  flow_dir,
  flow_acc,
  iEDO_weights,
  iFLO_weights,
  HAiFLO_weights,
  iEDS_weights,
  iFLS_weights,
  HAiFLS_weights,
  percentage = TRUE,
  max_memory = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_metrics_precomputed_+3A_metrics">metrics</code></td>
<td>
<p>A character vector. This vector specifies which metric(s) should be calculated. Your options are lumped, iFLO, iFLS, iEDO, iEDS, HAiFLO and HAiFLS. The default is to calculate the lumped, iFLO, iFLS, HAiFLO, and HAiFLS metrics.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_landuse">landuse</code></td>
<td>
<p>Names of landuse or landcover rasters in the current GRASS mapset. These can be continuous (e.g., percentage cover or NDVI) or binary, with a value of 1 for cells with a particular land use category and a value of 0 otherwise.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_sites">sites</code></td>
<td>
<p>A set of survey sites in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_out_fields">out_fields</code></td>
<td>
<p>A character vector of output field names to store the metrics. Note that <code>length(out_fields)</code> must be the same as <code>length(landuse) * length(metrics)</code>.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_watersheds">watersheds</code></td>
<td>
<p>A vector of watershed raster names in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_flow_dir">flow_dir</code></td>
<td>
<p>Name of a flow direction raster produced by <code>derive_flow</code> in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_flow_acc">flow_acc</code></td>
<td>
<p>Name of a flow accumulation raster produced by <code>derive_flow</code> in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_iedo_weights">iEDO_weights</code></td>
<td>
<p>A vector of names of iEDO weight rasters in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_iflo_weights">iFLO_weights</code></td>
<td>
<p>A vector of names of iFLO weight rasters in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_haiflo_weights">HAiFLO_weights</code></td>
<td>
<p>A vector of names of HAiFLO weight rasters in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_ieds_weights">iEDS_weights</code></td>
<td>
<p>A vector of names of iEDS weight rasters in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_ifls_weights">iFLS_weights</code></td>
<td>
<p>A vector of names of iFLS weight rasters in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_haifls_weights">HAiFLS_weights</code></td>
<td>
<p>A vector of names of HAiFLS weight rasters in the GRASS mapset.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_percentage">percentage</code></td>
<td>
<p>A logical indicating whether the result should be expressed as a percentage. Defaults to <code>TRUE</code>. Set to <code>FALSE</code> if the landuse/landcover raster is continuous.</p>
</td></tr>
<tr><td><code id="compute_metrics_precomputed_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object of the snapped survey sites that also contains the computed landscape metrics.
</p>


<h3>References</h3>

<p>Peterson, E.E. &amp; Pearse, A.R. (2017). IDW-Plus: An ArcGIS toolset for calculating spatially explicit watershed attributes for survey sites. <em>JAWRA</em>, <em>53</em>(5), 1241-1249.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
# You should load rdwplus and initialise GRASS via the initGRASS function
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Recode streams
reclassify_streams("new_stm.tif", "null_stm.tif", "none")

# Snap sites to streams and flow accumulation
snap_sites("site", "new_stm.tif", "fa.tif", 2, "snapsite", T)

# Get watersheds
get_watersheds("snapsite", "fd.tif", "wshed.tif", T)

#  Get pour points
coord_to_raster("snapsite", which = 1, out = "pour_point")

# Get iFLO weights
compute_iFLO_weights(
"pour_point", 
"wshed.tif", 
"null_stm.tif", 
"fd.tif", 
"fl_outlet.tif", 
"iFLO_weights.tif", 
idwp = -1, 
remove_streams = FALSE
)

# Get iFLS weights
compute_iFLS_weights(
"new_stm.tif", 
"null_stm.tif", 
"fd.tif", 
"fl_streams.tif", 
"iFLS_weights.tif", 
idwp = -1, 
watershed = "wshed.tif", 
remove_streams = FALSE, 
overwrite = T
)

# Compute metrics for this site
compute_metrics_precomputed(
  metrics = c("iFLO", "iFLS"),
  landuse = "landuse.tif",
  sites = "snapsite",
  out_fields = c("iFLO", "iFLS"),
  watersheds = "wshed.tif",
  iFLO_weights = "iFLO_weights.tif",
  iFLS_weights = "iFLS_weights.tif",
  flow_dir = "fd.tif",
  flow_acc = "fa.tif"
)
}
</code></pre>

<hr>
<h2 id='convert_to_integer'>Convert a raster to integer format</h2><span id='topic+convert_to_integer'></span>

<h3>Description</h3>

<p>Given a raster in float, double or any other format, this function will convert it to integer format. This can be important because it is often an unstated requirement of GRASS modules such as the one for zonal statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_integer(x, out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_integer_+3A_x">x</code></td>
<td>
<p>A raster layer in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="convert_to_integer_+3A_out">out</code></td>
<td>
<p>Name of the output raster. Avoid names with hyphens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A raster with the name <code>out</code> will be added to the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")

# Set environment 
set_envir(dem)

# Make an integer-valued version of 'dem.tif'
convert_to_integer("dem.tif", "int_dem.tif")

# Compare
plot_GRASS("dem.tif")
plot_GRASS("int_dem.tif")

}
</code></pre>

<hr>
<h2 id='coord_to_raster'>Turn coordinates of outlets into rasters</h2><span id='topic+coord_to_raster'></span>

<h3>Description</h3>

<p>Given a set of x-y coordinates, this function will return a raster with a single cell at those coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_to_raster(outlets, which, out, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_to_raster_+3A_outlets">outlets</code></td>
<td>
<p>The name of a set of sites in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="coord_to_raster_+3A_which">which</code></td>
<td>
<p>A numeric identifier for the site to convert to raster.</p>
</td></tr>
<tr><td><code id="coord_to_raster_+3A_out">out</code></td>
<td>
<p>The file name of the output outlet raster in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="coord_to_raster_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether the output files should be allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is exposed to the user, and users are welcome to use if convenient for them, this function is intended for internal use in other functions.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "sites.shp", packages = "rdwplus")

# Set environment parameters
set_envir(dem)

# Read in sites
vector_to_mapset(sts)

# Convert first site to raster
coord_to_raster("site", 1, "coords", overwrite = TRUE)
}
</code></pre>

<hr>
<h2 id='derive_flow'>Obtain flow direction and accumulation over a digital elevation model (DEM)</h2><span id='topic+derive_flow'></span>

<h3>Description</h3>

<p>This function computes flow direction and accumulation (among other things) from a DEM. This is done using the <code>r.watershed</code> tool in GRASS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_flow(
  dem,
  flow_dir,
  flow_acc,
  d8 = TRUE,
  overwrite = FALSE,
  max_memory = 300,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_flow_+3A_dem">dem</code></td>
<td>
<p>A digital elevation model that has been hydrologically corrected.</p>
</td></tr>
<tr><td><code id="derive_flow_+3A_flow_dir">flow_dir</code></td>
<td>
<p>The name of the output flow direction file in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="derive_flow_+3A_flow_acc">flow_acc</code></td>
<td>
<p>The name of the output flow accumulation file in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="derive_flow_+3A_d8">d8</code></td>
<td>
<p>A logical indicating whether D8 flow direction should be used. If <code>FALSE</code>, multiple flow direction is allowed. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="derive_flow_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether any of the outputs should be allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="derive_flow_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
<tr><td><code id="derive_flow_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>r.watershed</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Files are written in the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()){
# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
vector_to_mapset(vectors = c(stream_shp))

# Create binary stream
out_name &lt;- paste0(tempdir(), "/streams_rast.tif")
rasterise_stream("streams", out_name, overwrite = TRUE)
reclassify_streams("streams_rast.tif", "streams_binary.tif", 
out_type = "binary", overwrite = TRUE)

# Burn dem 
burn_in(dem = "dem.tif", stream = "streams_binary.tif", out = "dem_burn.tif",
 burn = 10, overwrite = TRUE)

# Fill sinks
fill_sinks(dem = "dem_burn.tif", out_dem =  "dem_fill.tif", out_fd = "fd1.tif", overwrite = TRUE)

# Derive flow accumulation and direction grids
derive_flow(dem = "dem_fill.tif", 
flow_dir = "fdir.tif", 
flow_acc = "facc.tif", 
overwrite = TRUE)

# Plot
plot_GRASS("fdir.tif", col = topo.colors(6))
plot_GRASS("facc.tif", col = topo.colors(6))
}
</code></pre>

<hr>
<h2 id='derive_streams'>Extract streams from a flow accumulation raster</h2><span id='topic+derive_streams'></span>

<h3>Description</h3>

<p>Derive a raster and a vector layer of stream lines from a flow accumulation raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_streams(
  dem,
  flow_acc,
  out_rast,
  out_vect,
  min_acc = 1000,
  min_length = 0,
  overwrite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_streams_+3A_dem">dem</code></td>
<td>
<p>Name of an elevation raster in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_flow_acc">flow_acc</code></td>
<td>
<p>Name of a flow accumulation raster in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_out_rast">out_rast</code></td>
<td>
<p>Name of the output raster dataset of stream lines. File extensions should not matter.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_out_vect">out_vect</code></td>
<td>
<p>Name of the output vector dataset of stream lines. Should be WITHOUT .shp extension.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_min_acc">min_acc</code></td>
<td>
<p>The minimum accumulation value that a cell needs to be classified as a stream. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_min_length">min_length</code></td>
<td>
<p>The minimum length of a stream segment in cells. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output should be allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="derive_streams_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>r.stream.extract</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A vector dataset with the name <code>basename(out)</code> will appear in the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Will only run if GRASS is running
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)
}
</code></pre>

<hr>
<h2 id='fill_sinks'>Fill sinks in a digital elevation model (DEM)</h2><span id='topic+fill_sinks'></span>

<h3>Description</h3>

<p>Remove sinks in a DEM (see the 'Details' section)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_sinks(dem, out_dem, out_fd, out_sinks, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_sinks_+3A_dem">dem</code></td>
<td>
<p>The name of a DEM in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="fill_sinks_+3A_out_dem">out_dem</code></td>
<td>
<p>Name of the output DEM, which is a hydrologically corrected (sink-filled) DEM.</p>
</td></tr>
<tr><td><code id="fill_sinks_+3A_out_fd">out_fd</code></td>
<td>
<p>Name of the output flow direction map for the sink-filled DEM.</p>
</td></tr>
<tr><td><code id="fill_sinks_+3A_out_sinks">out_sinks</code></td>
<td>
<p>Optional argument giving the name of the output sinks raster. Leave this missing to skip the output.</p>
</td></tr>
<tr><td><code id="fill_sinks_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output should be allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fill_sinks_+3A_...">...</code></td>
<td>
<p>Optional additional parameters to <code>r.fill.dir</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sink is a depression in a DEM. Water flows into these depressions but does not flow out of them. These depressions, although often real features of landscapes, are problematic for flow direction and accumulation algorithms. Therefore, it is common practice to remove these depressions.
</p>


<h3>Value</h3>

<p>Nothing. A file with the name <code>out</code> will be created in the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)
}
</code></pre>

<hr>
<h2 id='get_distance'>Compute Euclidean distance to a survey site or stream line within a watershed</h2><span id='topic+get_distance'></span>

<h3>Description</h3>

<p>This function is needed to compute Euclidean distance from a feature of interest in a watershed raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance(target, out, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_distance_+3A_target">target</code></td>
<td>
<p>File name of the watershed outlet or streams (as a raster) in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="get_distance_+3A_out">out</code></td>
<td>
<p>File path for the result to be written.</p>
</td></tr>
<tr><td><code id="get_distance_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the outputs of this function should be allowed to overwrite existing files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A file with the name <code>basename(out)</code> will be created in the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()){

# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Get distances
get_distance("new_stm.tif", "dist_from_stream.tif", T)

}
</code></pre>

<hr>
<h2 id='get_flow_length'>Derive a flow length to streams and outlets</h2><span id='topic+get_flow_length'></span>

<h3>Description</h3>

<p>Given a (hydrologically corrected, see <code><a href="#topic+fill_sinks">fill_sinks</a></code>) DEM, this function produces a flow accumulation grid which shows the upstream area that flows into each cell in the DEM. Note that this function calls <code>r.stream.distance</code>, which is a GRASS GIS add-on. It can be installed through the GRASS GUI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_flow_length(
  str_rast,
  flow_dir,
  out,
  to_outlet = FALSE,
  overwrite = FALSE,
  max_memory = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_flow_length_+3A_str_rast">str_rast</code></td>
<td>
<p>Rasterized unary streams file.</p>
</td></tr>
<tr><td><code id="get_flow_length_+3A_flow_dir">flow_dir</code></td>
<td>
<p>Flow direction raster.</p>
</td></tr>
<tr><td><code id="get_flow_length_+3A_out">out</code></td>
<td>
<p>A file name for the output raster of flow lengths.</p>
</td></tr>
<tr><td><code id="get_flow_length_+3A_to_outlet">to_outlet</code></td>
<td>
<p>Calculate parameters for outlets flag. Defaults to <code>FALSE</code> for streams.</p>
</td></tr>
<tr><td><code id="get_flow_length_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite flag. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_flow_length_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A file with the name <code>out</code> will be written to GRASS's current workspace.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
sites &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
raster_to_mapset(rasters = dem, as_integer = FALSE)
vector_to_mapset(vectors = c(sites, stream_shp))

# Create binary stream
rasterise_stream("streams", "streams_rast.tif", overwrite = TRUE)

# Burn dem
burn_in(dem = "dem.tif", stream = "streams_binary.tif",
        out = "dem_burn.tif", burn = 10, overwrite = TRUE)

# Fill sinks
fill_sinks(dem = "dem_burn.tif", out_dem = "dem_fill.tif", out_fd = "fd1.tif", overwrite = TRUE)

# Derive flow accumulation and direction grids
derive_flow(dem = "dem_fill.tif", flow_dir = "fdir.tif",
            flow_acc = "facc.tif", overwrite = TRUE)

# Derive watershed
get_watersheds(sites = "site", flow_dir = "fdir.tif", out = "wshed.tif", overwrite = T)

# Set mask
set_mask("wshed.tif")

# Get flow length
get_flow_length(
  str_rast = "streams_rast.tif",
  flow_dir = "fdir.tif",
  out = "flowlength.tif",
  to_outlet = TRUE,
  overwrite = TRUE
)

# Plot
plot_GRASS("flowlength.tif", col = topo.colors(15))
}
</code></pre>

<hr>
<h2 id='get_watersheds'>Delineate watersheds for survey sites</h2><span id='topic+get_watersheds'></span>

<h3>Description</h3>

<p>This function delineates watersheds around a set of survey sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_watersheds(sites, flow_dir, out, overwrite = FALSE, lessmem = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_watersheds_+3A_sites">sites</code></td>
<td>
<p>A file path to a shapefile of points.</p>
</td></tr>
<tr><td><code id="get_watersheds_+3A_flow_dir">flow_dir</code></td>
<td>
<p>The name of a flow direction grid in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="get_watersheds_+3A_out">out</code></td>
<td>
<p>The names of the output watershed rasters.</p>
</td></tr>
<tr><td><code id="get_watersheds_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output should be allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_watersheds_+3A_lessmem">lessmem</code></td>
<td>
<p>A logical indicating whether to use the less memory modified watershed module. Defaults to <code>FALSE</code>. If set to <code>TRUE</code>, the <code>r.wateroutlet.lessmem</code> extension module must be installed. It can be installed using the GRASS GUI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A raster file with the name <code>out</code> may be written to file if you have set the <code>write_file</code> argument accordingly. A raster with the name <code>basename(out)</code> will be imported into the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Recode streams
reclassify_streams("new_stm.tif", "null_stm.tif", "none")

# Snap sites to streams and flow accumulation
snap_sites("site", "new_stm.tif", "fa.tif", 2, "snapsite", T)

# Get watersheds
get_watersheds("snapsite", "fd.tif", "wshed.tif", T)
}
</code></pre>

<hr>
<h2 id='install_extensions'>Install required extension(s)</h2><span id='topic+install_extensions'></span>

<h3>Description</h3>

<p>Some functions in the <code>rdwplus</code> package rely on GRASS extensions that need to be installed prior to use. This function installs those extensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_extensions()
</code></pre>


<h3>Details</h3>

<p>This function has no arguments. Simply run it and it will install a pre-set list of GRASS extensions.
</p>
<p>Currently, the GRASS extension required are <code>r.stream.snap</code>, <code>r.stream.distance</code>, and <code>r.wateroutlet.lessmem</code>.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
    install_extensions()
}
</code></pre>

<hr>
<h2 id='plot_GRASS'>A function to plot a raster from the current GRASS mapset</h2><span id='topic+plot_GRASS'></span>

<h3>Description</h3>

<p>Given the name of a raster in the current GRASS mapset, this function will plot it as a <code>stars</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_GRASS(x, colours, out_x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_GRASS_+3A_x">x</code></td>
<td>
<p>The name of an object in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="plot_GRASS_+3A_colours">colours</code></td>
<td>
<p>Optional. A colour scale. If not supplied, the default settings in <code>plot.stars</code> is used. If supplied, <code>length(colours)</code> must be less than or equal to the number of unique values in the raster.</p>
</td></tr>
<tr><td><code id="plot_GRASS_+3A_out_x">out_x</code></td>
<td>
<p>Optional. If supplied, the function makes a call to <code><a href="#topic+retrieve_raster">retrieve_raster</a></code> and writes out the raster to the file path <code>out_x</code>. Otherwise the function will write the layer to <code>tempdir</code>.</p>
</td></tr>
<tr><td><code id="plot_GRASS_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot.stars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
# You should load rdwplus and initialise GRASS via the initGRASS function
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")

# Set environment 
set_envir(dem)

# Plot
plot_GRASS("dem.tif") # argument must match name of data set in the mapset
plot_GRASS("dem.tif", heat.colors(10)) # with different colour scale

}
</code></pre>

<hr>
<h2 id='point_to_raster'>Convert outlet of a watershed from shapefile format into raster format</h2><span id='topic+point_to_raster'></span>

<h3>Description</h3>

<p>Given a shapefile of outlet(s), this function will convert its contents into a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_to_raster(outlets, out, overwrite = FALSE, max_memory = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_to_raster_+3A_outlets">outlets</code></td>
<td>
<p>A shapefile of outlets in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="point_to_raster_+3A_out">out</code></td>
<td>
<p>The name of the output raster.</p>
</td></tr>
<tr><td><code id="point_to_raster_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output should be allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="point_to_raster_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A file called <code>out</code> will be created in the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
sites &lt;- system.file("extdata", "site.shp", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
vector_to_mapset(vectors = sites)

# Point to raster
point_to_raster(outlets = "site", out = "sites_rast.tif", overwrite = TRUE)

# Check conversion success
vibe_check()

}
</code></pre>

<hr>
<h2 id='rast_calc'>Raster calculator (wrapper for &quot;r.mapcalc&quot;)</h2><span id='topic+rast_calc'></span>

<h3>Description</h3>

<p>Raster calculator (wrapper for &quot;r.mapcalc&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rast_calc(ex, overwrite = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rast_calc_+3A_ex">ex</code></td>
<td>
<p>A valid raster calculator expression for GRASS.</p>
</td></tr>
<tr><td><code id="rast_calc_+3A_overwrite">overwrite</code></td>
<td>
<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='raster_to_mapset'>Import rasters into GRASS mapset</h2><span id='topic+raster_to_mapset'></span>

<h3>Description</h3>

<p>GRASS can only deal with raster and vector data in a GRASS mapset. This function takes external rasters and imports them into the current GRASS mapset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_mapset(
  rasters,
  as_integer = rep(FALSE, length(rasters)),
  overwrite = FALSE,
  max_memory = 300,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_to_mapset_+3A_rasters">rasters</code></td>
<td>
<p>A character vector of filenames of rasters to import.</p>
</td></tr>
<tr><td><code id="raster_to_mapset_+3A_as_integer">as_integer</code></td>
<td>
<p>A logical vector indicating whether each raster should be imported strictly in integer format. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="raster_to_mapset_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the overwrite flag should be used. If <code>FALSE</code>, then the corresponding raster is allowed to retain its original format. Defaults to <code>FALSE</code>. May cause value truncation if improperly used.</p>
</td></tr>
<tr><td><code id="raster_to_mapset_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
<tr><td><code id="raster_to_mapset_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>r.import</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of raster layer names in the GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Will only run if a GRASS session is initialised
if(check_running()){
   dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
   raster_to_mapset(dem)
}
</code></pre>

<hr>
<h2 id='rasterise_stream'>Turn a shapefile of stream edges into a raster</h2><span id='topic+rasterise_stream'></span>

<h3>Description</h3>

<p>Given a shapefile of lines representing the channels of a stream network, this function will return a rasterised version of the shapefile. The raster will have the parameters of the current GRASS mapset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterise_stream(streams, out, overwrite = FALSE, max_memory = 300, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterise_stream_+3A_streams">streams</code></td>
<td>
<p>A file name for a shapefile of stream edges in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="rasterise_stream_+3A_out">out</code></td>
<td>
<p>The filename of the output.</p>
</td></tr>
<tr><td><code id="rasterise_stream_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output is allowed to overwrite existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rasterise_stream_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory used in memory swap mode (MB). Defaults to <code>300</code>.</p>
</td></tr>
<tr><td><code id="rasterise_stream_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>v.to.rast</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. A file will be written to <code>out</code>. Note that <code>out</code> can be a full file path to any location in your file system. A raster with the name <code>basename(out)</code> will be written to the current GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
vector_to_mapset(vectors = stream_shp)

# Create rasterised stream
rasterise_stream("streams", "streams_rast.tif", overwrite = TRUE)

# Plot
plot_GRASS("streams_rast.tif")

}
</code></pre>

<hr>
<h2 id='rdwplus-package'>An Implementation of IDW-PLUS (Inverse Distance Weighted Percent Land Use for Streams) in R</h2><span id='topic+rdwplus'></span><span id='topic+rdwplus-package'></span>

<h3>Description</h3>

<p>Use R to call the hydrological toolboxes and functions in GRASS GIS to compute spatially explicit land-use metrics for stream survey sites. The package includes functions for preprocessing digital elevation and streams data, and one function to compute all the spatially explicit land use metrics described in Peterson et al. (2011) Freshwater Biology, 56(3), 590-610.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alan Pearse <a href="mailto:arp320@uowmail.edu.au">arp320@uowmail.edu.au</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Grace Heron <a href="mailto:g.heron@qut.edu.au">g.heron@qut.edu.au</a>
</p>
</li>
<li><p> Erin Peterson <a href="mailto:erin@peterson-consulting.com">erin@peterson-consulting.com</a>
</p>
</li></ul>


<hr>
<h2 id='reclassify_streams'>Reclassify streams into various formats</h2><span id='topic+reclassify_streams'></span>

<h3>Description</h3>

<p>Re-format a stream raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclassify_streams(stream, out, out_type = "binary", overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclassify_streams_+3A_stream">stream</code></td>
<td>
<p>Name of a streams raster in the current GRASS mapset. This can be the output from <code>rasterise_stream</code>. The raster should have NoData values for all non-stream cells. Stream cells can have any other value.</p>
</td></tr>
<tr><td><code id="reclassify_streams_+3A_out">out</code></td>
<td>
<p>The output file.</p>
</td></tr>
<tr><td><code id="reclassify_streams_+3A_out_type">out_type</code></td>
<td>
<p>Either 'zeros_to_nodata', 'binary', 'unary', or 'none'. See Details below</p>
</td></tr>
<tr><td><code id="reclassify_streams_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output should be allowed to overwrite any existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a streams raster, this function will either create a binary streams raster (0 for non-stream cells and 1 for stream cells) or a unary streams raster (1 for stream cells and NoData for all other cells). Another option is to reclassify the streams raster such that stream cells are given the value NoData and non-stream cells are given the value 1.
</p>
<p>Do not use raster names containing dashes/hyphens. The underlying call to <code>r.calc</code> will crash if the raster name contains these symbols because they are misinterpreted as math symbols.
</p>


<h3>Value</h3>

<p>Nothing. A file with the name <code>out</code> will be written to the current GRASS mapset. This raster will be in unsigned integer format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment 
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)
}
</code></pre>

<hr>
<h2 id='report_mapset'>Identify current mapset or list all possible mapsets</h2><span id='topic+report_mapset'></span>

<h3>Description</h3>

<p>GRASS GIS uses a system of mapsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_mapset(which = "current")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_mapset_+3A_which">which</code></td>
<td>
<p>One of either 'current' (the default), which causes the function to return the current mapset, or 'possible', which causes the function to list all possible mapsets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='retrieve_raster'>Write a raster layer from the current GRASS mapset to file</h2><span id='topic+retrieve_raster'></span>

<h3>Description</h3>

<p>This function writes a GRASS mapset raster to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_raster(layer, out_layer, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieve_raster_+3A_layer">layer</code></td>
<td>
<p>The name of the raster in the GRASS mapset that is to be written out.</p>
</td></tr>
<tr><td><code id="retrieve_raster_+3A_out_layer">out_layer</code></td>
<td>
<p>The name of the file to be created, with the relevant file extension.</p>
</td></tr>
<tr><td><code id="retrieve_raster_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output from this function should be allowed to overwrite any existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="retrieve_raster_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>r.out.gdal</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
raster_to_mapset(rasters = dem, as_integer = FALSE)

# Retrieve raster 
out_name &lt;- paste0(tempdir(), "/retrieved_dem.tif")
retrieve_raster("dem.tif", out_layer = out_name, overwrite = TRUE)

}
</code></pre>

<hr>
<h2 id='retrieve_vector'>Write a vector layer from the current GRASS mapset to file</h2><span id='topic+retrieve_vector'></span>

<h3>Description</h3>

<p>This function writes a GRASS mapset vector layer (like a shapefile) to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_vector(layer, out_layer, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieve_vector_+3A_layer">layer</code></td>
<td>
<p>The name of the vector layer in the GRASS mapset that is to be written out.</p>
</td></tr>
<tr><td><code id="retrieve_vector_+3A_out_layer">out_layer</code></td>
<td>
<p>The name of the shapefile to be created (with .shp file extension).</p>
</td></tr>
<tr><td><code id="retrieve_vector_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the output from this function should be allowed to overwrite any existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="retrieve_vector_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>v.out.ogr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
vector_to_mapset(vectors = stream_shp)

# Retrieve raster 
out_name &lt;- paste0(tempdir(), "/", "retrieved_streams.shp")
retrieve_vector("streams", out_layer = out_name, overwrite = TRUE)

}
</code></pre>

<hr>
<h2 id='search_for_grass'>Find GRASS installations</h2><span id='topic+search_for_grass'></span>

<h3>Description</h3>

<p>This function finds the path to potential GRASS installations. It does so in a very crude way; that is, by searching for directories that match the string <code>'GRASS'</code>.  
</p>
<p>Warning: this function works by brute force, so it may take a few minutes to find potential GRASS installations.
</p>
<p>Note: This is not guaranteed to work. It is not hard to find the path to your computer's GRASS installation yourself. This is the preferred course of action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_for_grass(guide)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_for_grass_+3A_guide">guide</code></td>
<td>
<p>Optional. A specific folder to search in for the GRASS installation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of file paths to potential GRASS installations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

my_grass &lt;- search_for_grass()
my_grass


</code></pre>

<hr>
<h2 id='set_envir'>Set projection and computation region from a raster file.</h2><span id='topic+set_envir'></span>

<h3>Description</h3>

<p>This function simplifies the process of setting up a GRASS environment with parameters such as cell snapping, size and mapset extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_envir(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_envir_+3A_file">file</code></td>
<td>
<p>The file path to a raster that should be used to set environment parameters such as the projection, cell size, extent, etc. The <code>file</code> argument will automatically be imported into the mapset as <code>basename(file)</code>.</p>
</td></tr>
<tr><td><code id="set_envir_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code>raster_to_mapset()</code>. The main argument of interest for most users will be <code>overwrite</code>, which should be set to true if an object of name <code>basename(file)</code> already exists in the mapset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Displays current environment settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
# You should load rdwplus and initialise GRASS with initGRASS
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")

# Set environment 
set_envir(dem)

}
</code></pre>

<hr>
<h2 id='set_mask'>Set a raster mask</h2><span id='topic+set_mask'></span>

<h3>Description</h3>

<p>Set a raster mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_mask(x, inverse = FALSE, overwrite = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_mask_+3A_x">x</code></td>
<td>
<p>Raster to use as a mask</p>
</td></tr>
<tr><td><code id="set_mask_+3A_inverse">inverse</code></td>
<td>
<p>Whether the inverse of the raster should be used as the mask. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="set_mask_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether the existing mask should be overwritten. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="set_mask_+3A_...">...</code></td>
<td>
<p>Optional. Additional parameters for r.mask.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()){
# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
sites &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment parameters and import data to GRASS
set_envir(dem)
raster_to_mapset(rasters = dem, as_integer = FALSE)
vector_to_mapset(vectors = c(sites, stream_shp))

# Create binary stream
rasterise_stream("streams", "streams_rast.tif", overwrite = TRUE)

# Burn dem
burn_in(dem = "dem.tif", stream = "streams_binary.tif",
        out = "dem_burn.tif", burn = 10, overwrite = TRUE)

# Fill sinks
fill_sinks(dem = "dem_burn.tif", out_dem = "dem_fill.tif", out_fd = "fd1.tif", overwrite = TRUE)

# Derive flow accumulation and direction grids
derive_flow(dem = "dem_fill.tif", flow_dir = "fdir.tif",
            flow_acc = "facc.tif", overwrite = TRUE)

# Derive watershed
get_watersheds(sites = "site", flow_dir = "fdir.tif", out = "wshed.tif", overwrite = T)

# Set mask
set_mask("wshed.tif")

# Get flow length
get_flow_length(
  str_rast = "streams_rast.tif",
  flow_dir = "fdir.tif",
  out = "flowlength.tif",
  to_outlet = TRUE,
  overwrite = TRUE
)

# Plot
plot_GRASS("flowlength.tif", col = topo.colors(15))
}
</code></pre>

<hr>
<h2 id='silence'>Function to suppress messages, warnings, errors from GRASS commands</h2><span id='topic+silence'></span>

<h3>Description</h3>

<p>Prevents the printing GRASS warnings, etc. Use with extreme caution. This is only helpful IF AND ONLY IF you are SURE that any printed messages, warnings, and errors are spurious.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silence(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="silence_+3A_value">value</code></td>
<td>
<p>A logical indicating whether GRASS messages, warnings, errors should be suppressed. Can be missing, and it is missing by default. Choose &quot;TRUE&quot; or &quot;FALSE&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating the current status of the option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>silence(TRUE)
silence(FALSE)
</code></pre>

<hr>
<h2 id='snap_sites'>A function to snap survey sites to a stream raster and a flow accumulation raster</h2><span id='topic+snap_sites'></span>

<h3>Description</h3>

<p>This function takes a set of survey site locations and snaps them to the highest-value cell within a flow accumulation raster, within a specified distance. Note that this function calls <code>r.stream.snap</code>, which is a GRASS GIS add-on. It can be installed through the GRASS GUI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snap_sites(
  sites,
  stream,
  flow_acc,
  max_move,
  out,
  overwrite = FALSE,
  max_memory = 300,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snap_sites_+3A_sites">sites</code></td>
<td>
<p>File name for a shapefile containing the locations of the survey sites in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_stream">stream</code></td>
<td>
<p>Name of a stream raster in the current GRASS mapset. This can either be formatted to have NoData in non-stream cells or 0s in non-stream cells.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_flow_acc">flow_acc</code></td>
<td>
<p>Name of a flow accumulation raster in the current GRASS mapset.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_max_move">max_move</code></td>
<td>
<p>The maximum distance in cells that any site can be moved to snap it to the flow accumulation grid.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_out">out</code></td>
<td>
<p>Name of the output in the current GRASS mapset. Note that this function will add a column called <code>snap_dist</code> to the attribute table of the input sites, which indicates how far each site was snapped.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether the output should be allowed to overwrite any existing files. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_max_memory">max_memory</code></td>
<td>
<p>Max memory (in) used in memory swap mode. Defaults to <code>300</code> Mb.</p>
</td></tr>
<tr><td><code id="snap_sites_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>r.stream.snap</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
# You should load rdwplus and initialise GRASS via the initGRASS function
if(check_running()){
# Retrieve paths to data sets
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
lus &lt;- system.file("extdata", "landuse.tif", package = "rdwplus")
sts &lt;- system.file("extdata", "site.shp", package = "rdwplus")
stm &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment 
set_envir(dem)

# Get other data sets (stream layer, sites, land use, etc.)
raster_to_mapset(lus)
vector_to_mapset(c(stm, sts))

# Reclassify streams
out_stream &lt;- paste0(tempdir(), "/streams.tif")
rasterise_stream("streams", out_stream, TRUE)
reclassify_streams("streams.tif", "streams01.tif", overwrite = TRUE)

# Burn in the streams to the DEM
burn_in("dem.tif", "streams01.tif", "burndem.tif", overwrite = TRUE)

# Fill dem
fill_sinks("burndem.tif", "filldem.tif", "fd1.tif", "sinks.tif", overwrite = TRUE)

# Derive flow direction and accumulation grids
derive_flow("dem.tif", "fd.tif", "fa.tif", overwrite = T)

# Derive a new stream raster from the FA grid
derive_streams("dem.tif", "fa.tif", "new_stm.tif", "new_stm", min_acc = 200, overwrite = T)

# Snap sites to streams and flow accumulation
snap_sites("site", "new_stm.tif", "fa.tif", 2, "snapsite", T)
}
</code></pre>

<hr>
<h2 id='toggle_silence'>Toggle between silence on and silence off</h2><span id='topic+toggle_silence'></span>

<h3>Description</h3>

<p>This function detects whether output suppression is on or off, and switches it to its opposite state. Under one setting, this function can be used as an off-switch for the GRASS message/warning/error suppression enforced via the use of <code>silence(value = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toggle_silence(stay_off = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toggle_silence_+3A_stay_off">stay_off</code></td>
<td>
<p>A logical indicating whether output suppression should be kept off once it is turned off. That is, if this function is called but output suppression is already off, then for <code>stay_off=TRUE</code> output suppression will simply remain off. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether output suppression is active.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Even if silence is currently off, silence will stay off
toggle_silence(TRUE) 

# If silence is currently off, silence will be turned on.
toggle_silence(FALSE)

</code></pre>

<hr>
<h2 id='vector_to_mapset'>Import rasters into GRASS mapset</h2><span id='topic+vector_to_mapset'></span>

<h3>Description</h3>

<p>GRASS can only deal with raster and vector data in a GRASS mapset. This function takes external vectors and imports them into the current GRASS mapset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_to_mapset(vectors, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_to_mapset_+3A_vectors">vectors</code></td>
<td>
<p>A character vector of filenames of shapefiles to import.</p>
</td></tr>
<tr><td><code id="vector_to_mapset_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical indicating whether the overwrite flag should be used. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vector_to_mapset_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>v.import</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of vector layer names in the GRASS mapset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run if GRASS is running
if(check_running()){

# Load data set
dem &lt;- system.file("extdata", "dem.tif", package = "rdwplus")
stream_shp &lt;- system.file("extdata", "streams.shp", package = "rdwplus")

# Set environment parameters
set_envir(dem)

# Import vector data to mapset
vector_to_mapset(vectors = stream_shp)

}
</code></pre>

<hr>
<h2 id='vibe_check'>A function to summarise the computation region, vectors and rasters in the mapset.</h2><span id='topic+vibe_check'></span>

<h3>Description</h3>

<p>This function takes no inputs. It prints a list of data sets in the current GRASS mapset, as well as the parameters of the current computation region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vibe_check()
</code></pre>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(check_running()) vibe_check()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
