<!DOCTYPE html><html lang="en"><head><title>Help for package Arothron</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Arothron}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Arothron-package'><p>eometric Morphometric Methods and Virtual Anthropology Tools</p></a></li>
<li><a href='#Altapic'><p>example dataset</p></a></li>
<li><a href='#aro.clo.points'><p>aro.clo.points</p></a></li>
<li><a href='#arraytolist'><p>arraytolist</p></a></li>
<li><a href='#bary.mesh'><p>bary.mesh</p></a></li>
<li><a href='#compare_check.set'><p>compare_check.set</p></a></li>
<li><a href='#CScorreffect'><p>CScorreffect</p>
Plot showing the correlation in the shape space between original and combined dataset omitting or including the normalization factors calculated with Arothron and MLECScorrection</a></li>
<li><a href='#dec.curve'><p>dec.curve</p></a></li>
<li><a href='#DM_base_sur'><p>example dataset</p></a></li>
<li><a href='#DM_face_sur'><p>example dataset</p></a></li>
<li><a href='#DM_set'><p>example dataset</p></a></li>
<li><a href='#dta'><p>dta</p></a></li>
<li><a href='#endo_set'><p>example dataset</p></a></li>
<li><a href='#endomaker'><p>endomaker</p></a></li>
<li><a href='#endomaker_dir'><p>endomaker_dir</p></a></li>
<li><a href='#export_amira'><p>export_amira</p></a></li>
<li><a href='#export_amira.path'><p>export_amira.path</p></a></li>
<li><a href='#ext.int.mesh'><p>ext.int.mesh</p></a></li>
<li><a href='#ext.mesh.rai'><p>ext.mesh.rai</p></a></li>
<li><a href='#femsets'><p>example dataset</p></a></li>
<li><a href='#grid_pov'><p>grid_pov</p></a></li>
<li><a href='#human_skull'><p>example dataset</p></a></li>
<li><a href='#image2palettes'><p>image2palettes</p></a></li>
<li><a href='#krd1_tooth'><p>example dataset</p></a></li>
<li><a href='#landmark_frm2amira'><p>landmark_frm2amira</p></a></li>
<li><a href='#listtoarray'><p>listtoarray</p>
convert a list into an array</a></li>
<li><a href='#localmeshdiff'><p>localmeshdiff</p>
Calculate and Visualize local differences between two meshes</a></li>
<li><a href='#Lset2D_list'><p>example dataset</p></a></li>
<li><a href='#Lset3D_array'><p>example dataset</p></a></li>
<li><a href='#malleus_bone'><p>example dataset</p></a></li>
<li><a href='#MAs_sets'><p>example dataset</p></a></li>
<li><a href='#MLECScorrection'><p>MLECScorrection</p>
Maximum Likelihood Estimation of the normalization factor to be applied to optimize the correlation between two landmark configurations to be combined by using twodviews and</a></li>
<li><a href='#noise.mesh'><p>noise.mesh</p></a></li>
<li><a href='#out.inn.mesh'><p>out.inn.mesh</p></a></li>
<li><a href='#patches_frm2amira'><p>patches_frm2amira</p></a></li>
<li><a href='#PCscoresCorr'><p>PCscoresCorr</p>
Perform a correlation test between two matrices of PCscores</a></li>
<li><a href='#permutangle'><p>permutangle</p></a></li>
<li><a href='#pov_selecter'><p>pov_selecter</p></a></li>
<li><a href='#primendoR'><p>example dataset</p></a></li>
<li><a href='#read.amira.dir'><p>read.amira.dir</p></a></li>
<li><a href='#read.amira.set'><p>read.amira.set</p></a></li>
<li><a href='#read.path.amira'><p>read.path.amira</p></a></li>
<li><a href='#repmat'><p>repmat</p></a></li>
<li><a href='#RMs_sets'><p>example dataset</p></a></li>
<li><a href='#SCP1.mesh'><p>example dataset</p></a></li>
<li><a href='#sinus_set'><p>example dataset</p></a></li>
<li><a href='#SM_set'><p>example dataset</p></a></li>
<li><a href='#spherical.flipping'><p>spherical.flipping</p></a></li>
<li><a href='#trasf.mesh'><p>trasf.mesh</p></a></li>
<li><a href='#twodvarshape'><p>twodvarshape</p>
Calculates the shape variation associated to a value of PC scores associated to a specific combined landmark configuration or view</a></li>
<li><a href='#twodviews'><p>twodviews</p>
Combine and calculate the PCscores matrix from a list of different landmark configurations to be combined</a></li>
<li><a href='#volendo'><p>volendo</p></a></li>
<li><a href='#yoda_set'><p>example dataset</p></a></li>
<li><a href='#yoda_sur'><p>example dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometric Morphometric Methods and Virtual Anthropology Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Profico, Costantino Buzi, Silvia Castiglione, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Profico &lt;antonio.profico@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for geometric morphometric analysis. The package includes tools of virtual anthropology to align two not articulated parts belonging to the same specimen, to build virtual cavities as endocast (Profico et al, 2021 &lt;<a href="https://doi.org/10.1002%2Fajpa.24340">doi:10.1002/ajpa.24340</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind (&ge; 1.4), alphashape3d (&ge; 1.3), compositions (&ge;
1.40-1), doParallel (&ge; 1.0.11), foreach (&ge; 1.4.4), geometry
(&ge; 0.3-6), graphics(&ge; 3.4.0), grDevices(&ge; 3.4.0), methods
(&ge; 3.5), Morpho (&ge; 2.5.0), parallel (&ge; 1.0), rgl (&ge; 1.0.1),
Rvcg (&ge; 0.17), stats (&ge; 3.4.0), stats4 (&ge; 4.0), stringr (&ge;
1.3.0), utils (&ge; 3.4.0), vegan (&ge; 2.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-01 10:42:11 UTC; anton</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-01 12:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='Arothron-package'>eometric Morphometric Methods and Virtual Anthropology Tools</h2><span id='topic+Arothron-package'></span><span id='topic+Arothron'></span>

<h3>Description</h3>

<p>Tools for geometric morphometric analysis. The package includes tools of virtual anthropology to align two not articulated parts belonging to the same specimen, to build virtual cavities as endocast (Profico et al, 2021 &lt;doi:10.1002/ajpa.24340&gt;).
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Silvia Castiglione, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='Altapic'>example dataset</h2><span id='topic+Altapic'></span>

<h3>Description</h3>

<p>2D image of the Altamura man fossil
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Altapic)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico
</p>

<hr>
<h2 id='aro.clo.points'>aro.clo.points</h2><span id='topic+aro.clo.points'></span>

<h3>Description</h3>

<p>Find the closest matches between a reference (2D or 3D matrix) and a target matrix (2D/3D) or mesh returning row indices and distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aro.clo.points(target, reference)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aro.clo.points_+3A_target">target</code></td>
<td>
<p>kxm matrix or object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="aro.clo.points_+3A_reference">reference</code></td>
<td>
<p>numeric: a kxm matrix (coordinates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>position numeric: a vector of the row indices
</p>
<p>distances numeric: a vector of the coordinates distances
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load an example: mesh, and L set
data(yoda_sur)
data(yoda_set)
sur&lt;-yoda_sur
set&lt;-yoda_set
ver_pos&lt;-aro.clo.points(target=sur,reference=set) 
</code></pre>

<hr>
<h2 id='arraytolist'>arraytolist</h2><span id='topic+arraytolist'></span>

<h3>Description</h3>

<p>converts an array in a list storing each element of the third dimension of the array (specimen) as element of the list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arraytolist(array)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arraytolist_+3A_array">array</code></td>
<td>
<p>a kx3xn array with landmark coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the landmark configurations stored as separated elements
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='bary.mesh'>bary.mesh</h2><span id='topic+bary.mesh'></span>

<h3>Description</h3>

<p>This function calculates the barycenter of a matrix or a 3D mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bary.mesh(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bary.mesh_+3A_mesh">mesh</code></td>
<td>
<p>matrix mesh vertex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>barycenter numeric: x,y,z coordinates of the barycenter of the mesh
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load an example: mesh, and L set
data(SCP1.mesh)
sur&lt;-SCP1.mesh
bary&lt;-bary.mesh(mesh=sur)
</code></pre>

<hr>
<h2 id='compare_check.set'>compare_check.set</h2><span id='topic+compare_check.set'></span>

<h3>Description</h3>

<p>This function applyes the Digital Alignment Tool (DTA) on a disarticulated model using a reference landmark configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_check.set(RM_set_1, RM_set_2, DM_set_1, DM_set_2, DM_mesh_1, DM_mesh_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_check.set_+3A_rm_set_1">RM_set_1</code></td>
<td>
<p>matrix: 3D landmark set of the first module acquired on the reference model</p>
</td></tr>
<tr><td><code id="compare_check.set_+3A_rm_set_2">RM_set_2</code></td>
<td>
<p>matrix: 3D landmark set of the second module acquired on the reference model</p>
</td></tr>
<tr><td><code id="compare_check.set_+3A_dm_set_1">DM_set_1</code></td>
<td>
<p>matrix: 3D landmark set of the first module acquired on the disarticulated model</p>
</td></tr>
<tr><td><code id="compare_check.set_+3A_dm_set_2">DM_set_2</code></td>
<td>
<p>matrix: 3D landmark set of the second module acquired on the disarticulated model</p>
</td></tr>
<tr><td><code id="compare_check.set_+3A_dm_mesh_1">DM_mesh_1</code></td>
<td>
<p>mesh3d: mesh of the disarticulated model (first module)</p>
</td></tr>
<tr><td><code id="compare_check.set_+3A_dm_mesh_2">DM_mesh_2</code></td>
<td>
<p>mesh3d: mesh of the disarticulated model (second module)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SF1 numeric: scale factor used to scale the reference set (first module)
</p>
<p>SF2 numeric: scale factor used to scale the reference set (second module)
</p>
<p>RM_set_1_sc matrix: scaled 3D reference set (first module)
</p>
<p>RM_set_2_sc matrix: scaled 3D reference set (second module)
</p>
<p>AM_model list: output of the Morpho::rotmesh.onto function
</p>
<p>dist_from_mesh numeric: mesh distance between the aligned model and the scaled reference set
</p>
<p>eucl_dist_1 numeric: euclidean distance between the landmark configuration of the disarticulated and reference model (first module)
</p>
<p>eucl_dist_2 numeric: euclidean distance between the landmark configuration of the disarticulated and reference model (second module)
</p>
<p>procr_dist numeric: procrustes distance between the landmark configuration of the aligned and reference model
</p>
<p>procr_dist_1 numeric: procrustes distance between the landmark configuration of the disarticulated and reference model (first module)
</p>
<p>procr_dist_2 numeric: procrustes distance between the landmark configuration of the disarticulated and reference model (second module)
</p>
<p>eucl_dist numeric: euclidean distance between the landmark configuration of the aligned and reference model
</p>
<p>single_l_1 numeric: euclidean distance between the landmark configuration of the disarticulated and reference model (first module)
</p>
<p>single_l_2 numeric: euclidean distance between the landmark configuration of the disarticulated and reference model (second module)
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='CScorreffect'>CScorreffect
Plot showing the correlation in the shape space between original and combined dataset omitting or including the normalization factors calculated with Arothron and MLECScorrection</h2><span id='topic+CScorreffect'></span>

<h3>Description</h3>

<p>CScorreffect
Plot showing the correlation in the shape space between original and combined dataset omitting or including the normalization factors calculated with Arothron and MLECScorrection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CScorreffect(
  array1,
  array2,
  nPCs = c(1:3),
  from = 0.02,
  to = 0.9,
  length.out = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CScorreffect_+3A_array1">array1</code></td>
<td>
<p>array: first set of landmark configuration</p>
</td></tr>
<tr><td><code id="CScorreffect_+3A_array2">array2</code></td>
<td>
<p>array: second set of landmark configuration</p>
</td></tr>
<tr><td><code id="CScorreffect_+3A_npcs">nPCs</code></td>
<td>
<p>numeric vector: specify which PC scores will be selected in the correlation test</p>
</td></tr>
<tr><td><code id="CScorreffect_+3A_from">from</code></td>
<td>
<p>numeric: the lower interval of the normalization factor distribution</p>
</td></tr>
<tr><td><code id="CScorreffect_+3A_to">to</code></td>
<td>
<p>numeric: the lower interval of the normalization factor distribution</p>
</td></tr>
<tr><td><code id="CScorreffect_+3A_length.out">length.out</code></td>
<td>
<p>numeric: number of values ranged between from and to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PCscores PCscores matrix of the combined dataset applying the normalization factor calculated by using the maximum likelihood estimation
</p>
<p>PCs PCs matrix of the combined dataset applying the normalization factor calculated by using the maximum likelihood estimation
</p>
<p>corr mean correlation between original and combined dataset
</p>
<p>CSratios normalization factor calculated by using the maximum likelihood estimation
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Femora case study
data(femsets)
all_pois&lt;-matrix(1:(200*61),nrow=61,ncol=200,byrow = FALSE)
set_ext_100&lt;-femsets[all_pois[,1:100],,]

set_int_100&lt;-femsets[all_pois[,101:200],,]
set_int_50&lt;-set_int_100[c(matrix(1:6100,ncol=61)[seq(1,100,2),]),,]
set_int_20&lt;-set_int_100[c(matrix(1:6100,ncol=61)[seq(1,100,5),]),,]
set.seed(123)
sel&lt;-sample(1:100,10)
set_int_10r&lt;-set_int_100[c(matrix(1:6100,ncol=61)[sel,]),,]

CScorreffect(set_ext_100,set_int_50,nPCs=1:3)
CScorreffect(set_ext_100,set_int_20,nPCs=1:3)
CScorreffect(set_ext_100,set_int_10r,nPCs=1:3)

## End(Not run)
</code></pre>

<hr>
<h2 id='dec.curve'>dec.curve</h2><span id='topic+dec.curve'></span>

<h3>Description</h3>

<p>This function computes the order of points on a open 3D curve and finds intermediate points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dec.curve(mat_input, mag, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dec.curve_+3A_mat_input">mat_input</code></td>
<td>
<p>numeric: a kx3 matrix</p>
</td></tr>
<tr><td><code id="dec.curve_+3A_mag">mag</code></td>
<td>
<p>numeric: how many times will be divided by the number of initial points</p>
</td></tr>
<tr><td><code id="dec.curve_+3A_plot">plot</code></td>
<td>
<p>logical: if TRUE will be plotted the starting and final point matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matt numeric: a kx3 matrix with points coordinates
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Create and plot a 3D curve
require(compositions)
require(rgl)
curve_3D&lt;-cbind(1:10,seq(1,5,length=10),rnorm(10,sd = 0.2))
plot3D(curve_3D,bbox=FALSE)
close3d()
## Create and plot the new 3D curve (with intermediate points)
dec_curve_3D&lt;-dec.curve(curve_3D, 2, plot = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='DM_base_sur'>example dataset</h2><span id='topic+DM_base_sur'></span>

<h3>Description</h3>

<p>3D mesh of the first part of the Homo sapiens disarticulated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DM_base_sur)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='DM_face_sur'>example dataset</h2><span id='topic+DM_face_sur'></span>

<h3>Description</h3>

<p>3D mesh of the second part of the Homo sapiens disarticulated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DM_face_sur)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='DM_set'>example dataset</h2><span id='topic+DM_set'></span>

<h3>Description</h3>

<p>Landmark configurations of the two part of the disarticulated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DM_set)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='dta'>dta</h2><span id='topic+dta'></span>

<h3>Description</h3>

<p>This function applyes the Digital Alignment Tool (DTA) on a disarticulated model using a reference sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dta(
  RM_sample,
  mod_1,
  mod_2,
  pairs_1,
  pairs_2,
  DM_mesh_1,
  DM_mesh_2,
  DM_set_1,
  DM_set_2,
  method = c("euclidean")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dta_+3A_rm_sample">RM_sample</code></td>
<td>
<p>3D array: 3D landmark configurations of the reference sample</p>
</td></tr>
<tr><td><code id="dta_+3A_mod_1">mod_1</code></td>
<td>
<p>numeric vector: vector containing the position of which landmarks belong to the first module</p>
</td></tr>
<tr><td><code id="dta_+3A_mod_2">mod_2</code></td>
<td>
<p>numeric vector: vector containing the position of which landmarks belong to the second module</p>
</td></tr>
<tr><td><code id="dta_+3A_pairs_1">pairs_1</code></td>
<td>
<p>matrix: a X x 2 matrix containing the indices of right and left landmarks of the first module</p>
</td></tr>
<tr><td><code id="dta_+3A_pairs_2">pairs_2</code></td>
<td>
<p>matrix: a X x 2 matrix containing the indices of right and left landmarks of the second module</p>
</td></tr>
<tr><td><code id="dta_+3A_dm_mesh_1">DM_mesh_1</code></td>
<td>
<p>mesh3d: mesh of the disarticulated model (first module)</p>
</td></tr>
<tr><td><code id="dta_+3A_dm_mesh_2">DM_mesh_2</code></td>
<td>
<p>mesh3d: mesh of the disarticulated model (second module)</p>
</td></tr>
<tr><td><code id="dta_+3A_dm_set_1">DM_set_1</code></td>
<td>
<p>matrix: 3D landmark set of the first module acquired on the disarticulated model</p>
</td></tr>
<tr><td><code id="dta_+3A_dm_set_2">DM_set_2</code></td>
<td>
<p>matrix: 3D landmark set of the second module acquired on the disarticulated model</p>
</td></tr>
<tr><td><code id="dta_+3A_method">method</code></td>
<td>
<p>character: specify method to be used to individuate the best DTA (&quot;euclidean&quot; or &quot;procrustes&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AM_mesh mesh3d: mesh of the aligned model
</p>
<p>AM_set matrix: landmark configuration of the aligned model
</p>
<p>AM_id character: name of the item of the reference sample resulted as best DTA
</p>
<p>AM_SF_1 numeric: scale factor used to scale the reference set (first module)
</p>
<p>AM_SF_2 numeric: scale factor used to scale the reference set (second module)
</p>
<p>distance numeric: distance between the landmark configuration of the aligned and the reference model
</p>
<p>tot_proc numeric vector: procrustes distances between aligned and reference models (all DTAs)
</p>
<p>tot_eucl numeric vector: euclidean distances between aligned and reference models (all DTAs)
</p>
<p>setarray 3D array: landmark configurations of the disarticulated model aligned on each item of the reference sample
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Buzi, C., Davis, C., Melchionna, M., Veneziano, A., Raia, P., &amp; Manzi, G. (2019). 
A new tool for digital alignment in Virtual Anthropology. The Anatomical Record, 302(7), 1104-1115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load and plot the disarticulated model of the Homo sapiens case study
library(compositions)
library(rgl)
data(DM_base_sur)
data(DM_face_sur)
open3d()
wire3d(DM_base_sur,col="white")
wire3d(DM_face_sur,col="white")
## Load the landmark configurations associated to the DM 
data(DM_set)
## Load the reference sample 
data(RMs_sets)
## Define the landmarks belonging to the first and second module
mod_1&lt;-c(1:17) #cranial base
mod_2&lt;-c(18:32) #facial complex
## Define the paired landmarks for each module (optional symmetrization process)
pairs_1&lt;-cbind(c(4,6,8,10,12,14,16),c(5,7,9,11,13,15,17))
pairs_2&lt;-cbind(c(23,25,27,29,31),c(24,26,28,30,32))
## Run DTA
ex.dta&lt;-dta(RM_sample=RMs_sets, mod_1=mod_1, mod_2=mod_2, pairs_1=pairs_1, pairs_2=pairs_2,
DM_mesh_1=DM_base_sur,DM_mesh_2=DM_face_sur, DM_set_1= DM_set[mod_1,], DM_set_2=DM_set[mod_2,])
## Print the name of the best RM 
ex.dta$AM_id
## Save the mesh and the landmark set of the AM
AM_mesh&lt;-ex.dta$AM_mesh
AM_set&lt;-ex.dta$AM_set
## Plot the aligned 3D model
library(compositions)
library(rgl)
open3d()
wire3d(AM_mesh,col="white")
plot3D(AM_set,bbox=FALSE,add=TRUE)
</code></pre>

<hr>
<h2 id='endo_set'>example dataset</h2><span id='topic+endo_set'></span>

<h3>Description</h3>

<p>POVs defined inside the endocranial cavity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(endo_set)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='endomaker'>endomaker</h2><span id='topic+endomaker'></span>

<h3>Description</h3>

<p>Build endocast from a skull 3D mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endomaker(
  mesh = NULL,
  path_in = NULL,
  param1_endo = 1,
  npovs = 50,
  volume = TRUE,
  alpha_vol = 100,
  nVoxels = 1e+05,
  decmesh = 20000,
  alpha_ext = 30,
  ncells = 50000,
  npovs_calse = 50,
  param1_calse = 2,
  param1_ast = 1.3,
  decendo = 20000,
  scalendo = 0.5,
  alpha_end = 100,
  mpovdist = 10,
  plot = FALSE,
  colmesh = "orange",
  save = FALSE,
  outpath = tempdir(),
  num.cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="endomaker_+3A_mesh">mesh</code></td>
<td>
<p>mesh3d: 3D model of the skull</p>
</td></tr>
<tr><td><code id="endomaker_+3A_path_in">path_in</code></td>
<td>
<p>character: path of the skull where is stored</p>
</td></tr>
<tr><td><code id="endomaker_+3A_param1_endo">param1_endo</code></td>
<td>
<p>numeric: parameter for spherical flipping</p>
</td></tr>
<tr><td><code id="endomaker_+3A_npovs">npovs</code></td>
<td>
<p>numeric: number of Points of View used in the endocast construction</p>
</td></tr>
<tr><td><code id="endomaker_+3A_volume">volume</code></td>
<td>
<p>logical: if TRUE the calculation of the volume (expressed in cc) through concave is returned</p>
</td></tr>
<tr><td><code id="endomaker_+3A_alpha_vol">alpha_vol</code></td>
<td>
<p>numeric: alpha shape for volume calculation</p>
</td></tr>
<tr><td><code id="endomaker_+3A_nvoxels">nVoxels</code></td>
<td>
<p>numeric: number of voxels for estimation endocranial volume</p>
</td></tr>
<tr><td><code id="endomaker_+3A_decmesh">decmesh</code></td>
<td>
<p>numeric: decmesh</p>
</td></tr>
<tr><td><code id="endomaker_+3A_alpha_ext">alpha_ext</code></td>
<td>
<p>numeric: alpha shape for construction external cranial mesh</p>
</td></tr>
<tr><td><code id="endomaker_+3A_ncells">ncells</code></td>
<td>
<p>numeric: approximative number of cell for 3D grid construction</p>
</td></tr>
<tr><td><code id="endomaker_+3A_npovs_calse">npovs_calse</code></td>
<td>
<p>numeric: number of Points of View for construction of skull shell</p>
</td></tr>
<tr><td><code id="endomaker_+3A_param1_calse">param1_calse</code></td>
<td>
<p>numeric: parameter for calse (construction shell)</p>
</td></tr>
<tr><td><code id="endomaker_+3A_param1_ast">param1_ast</code></td>
<td>
<p>numeric: parameter for ast3d (construction row endocast)</p>
</td></tr>
<tr><td><code id="endomaker_+3A_decendo">decendo</code></td>
<td>
<p>numeric: desired number of triangles (row endocast)</p>
</td></tr>
<tr><td><code id="endomaker_+3A_scalendo">scalendo</code></td>
<td>
<p>numeric: scale factor row endocast (for definition of POVs)</p>
</td></tr>
<tr><td><code id="endomaker_+3A_alpha_end">alpha_end</code></td>
<td>
<p>numeric: alpha shape value for concave hull (row endocast)</p>
</td></tr>
<tr><td><code id="endomaker_+3A_mpovdist">mpovdist</code></td>
<td>
<p>numeric: mean value between POVs and mesh</p>
</td></tr>
<tr><td><code id="endomaker_+3A_plot">plot</code></td>
<td>
<p>logical: if TRUE the endocast is plotted</p>
</td></tr>
<tr><td><code id="endomaker_+3A_colmesh">colmesh</code></td>
<td>
<p>character: color of the mesh to be plotted</p>
</td></tr>
<tr><td><code id="endomaker_+3A_save">save</code></td>
<td>
<p>logical: if TRUE the mesh of the endocast is saved</p>
</td></tr>
<tr><td><code id="endomaker_+3A_outpath">outpath</code></td>
<td>
<p>character: path where save the endocast</p>
</td></tr>
<tr><td><code id="endomaker_+3A_num.cores">num.cores</code></td>
<td>
<p>numeric: numbers of cores to be used in parallel elaboration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>endocast mesh3d: mesh of the endocast
</p>
<p>volume numeric: volume of the endocast expressed in cc
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Buzi, C., Melchionna, M., Veneziano, A., &amp; Raia, P. (2020). 
Endomaker, a new algorithm for fully automatic extraction of cranial endocasts and the calculation of their volumes. American Journal of Physical Anthropology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rgl)
data(human_skull)
sapendo&lt;-endomaker(human_skull,param1_endo = 1.0,decmesh = 20000, num.cores=NULL)
open3d()
wire3d(sapendo$endocast,col="violet")
ecv&lt;-sapendo$volume

## End(Not run)
</code></pre>

<hr>
<h2 id='endomaker_dir'>endomaker_dir</h2><span id='topic+endomaker_dir'></span>

<h3>Description</h3>

<p>Build library of endocasts from skull 3D meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endomaker_dir(
  dir_path,
  param1_endo = 1.5,
  npovs = 50,
  volume = TRUE,
  alpha_vol = 50,
  nVoxels = 1e+05,
  decmesh = 20000,
  alpha_ext = 30,
  ncells = 50000,
  npovs_calse = 50,
  param1_calse = 3,
  param1_ast = 1.3,
  decendo = 20000,
  scalendo = 0.5,
  alpha_end = 100,
  mpovdist = 10,
  plotall = FALSE,
  colmesh = "orange",
  save = FALSE,
  outpath = tempdir(),
  num.cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="endomaker_dir_+3A_dir_path">dir_path</code></td>
<td>
<p>character: path of the folder where the skull meshes are stored</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_param1_endo">param1_endo</code></td>
<td>
<p>numeric vector: parameter for spherical flipping</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_npovs">npovs</code></td>
<td>
<p>numeric: number of Points of View used in the endocast construction</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_volume">volume</code></td>
<td>
<p>logical: if TRUE the volume of the endocast (ECV) is estimated</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_alpha_vol">alpha_vol</code></td>
<td>
<p>numeric: alpha shape for volume calculation</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_nvoxels">nVoxels</code></td>
<td>
<p>numeric: number of voxels for estimation endocranial volume</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_decmesh">decmesh</code></td>
<td>
<p>numeric: decmesh</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_alpha_ext">alpha_ext</code></td>
<td>
<p>numeric: alpha shape for construction external cranial mesh</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_ncells">ncells</code></td>
<td>
<p>numeric: approximative number of cell for 3D grid construction</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_npovs_calse">npovs_calse</code></td>
<td>
<p>numeric: number of Points of View for construction of skull shell</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_param1_calse">param1_calse</code></td>
<td>
<p>numeric: parameter for calse (construction shell)</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_param1_ast">param1_ast</code></td>
<td>
<p>numeric: parameter for ast3d (construction row endocast)</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_decendo">decendo</code></td>
<td>
<p>numeric: desired number of triangles (row endocast)</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_scalendo">scalendo</code></td>
<td>
<p>numeric: scale factor row endocast (for definition of POVs)</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_alpha_end">alpha_end</code></td>
<td>
<p>numeric: alpha shape value for concave hull (row endocast)</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_mpovdist">mpovdist</code></td>
<td>
<p>numeric vector: mean value between POVs and mesh</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_plotall">plotall</code></td>
<td>
<p>logical: if TRUE the endocasts are plotted</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_colmesh">colmesh</code></td>
<td>
<p>character: color of the mesh to be plotted</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_save">save</code></td>
<td>
<p>logical: if TRUE the mesh of the endocast is saved</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_outpath">outpath</code></td>
<td>
<p>character: path where save the endocast</p>
</td></tr>
<tr><td><code id="endomaker_dir_+3A_num.cores">num.cores</code></td>
<td>
<p>numeric: number of cores to be used in parallel elaboration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>endocasts mesh3d: list of meshes of the extracted endocasts
</p>
<p>volumes numeric: volumes of the endocasts expressed in cc
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Buzi, C., Melchionna, M., Veneziano, A., &amp; Raia, P. (2020). 
Endomaker, a new algorithm for fully automatic extraction of cranial endocasts and the calculation of their volumes. American Journal of Physical Anthropology.
</p>

<hr>
<h2 id='export_amira'>export_amira</h2><span id='topic+export_amira'></span>

<h3>Description</h3>

<p>This function exports a list of 3D landmark set in separate files (format landmarkAscii)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_amira(lista, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_amira_+3A_lista">lista</code></td>
<td>
<p>list containing 3D landmark sets</p>
</td></tr>
<tr><td><code id="export_amira_+3A_path">path</code></td>
<td>
<p>character: path of the folder where saving the Amira landmark sets</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c(1:20)
y&lt;-seq(1,3,length=20)
z&lt;-rnorm(20,0.01)
vertices&lt;-cbind(x,y,z)
set&lt;-list(vertices)
example&lt;-export_amira(set,path=tempdir()) 
</code></pre>

<hr>
<h2 id='export_amira.path'>export_amira.path</h2><span id='topic+export_amira.path'></span>

<h3>Description</h3>

<p>Convert and save a 3D matrix into a AmiraMesh ASCII Lineset (.am) object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_amira.path(
  vertices,
  filename,
  Lines = c(1:(dim(vertices)[1] - 1) - 1, -1),
  path
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_amira.path_+3A_vertices">vertices</code></td>
<td>
<p>numeric: a kx3 matrix</p>
</td></tr>
<tr><td><code id="export_amira.path_+3A_filename">filename</code></td>
<td>
<p>character: name of the requested output</p>
</td></tr>
<tr><td><code id="export_amira.path_+3A_lines">Lines</code></td>
<td>
<p>numeric: sequence of the vertices that defines the line</p>
</td></tr>
<tr><td><code id="export_amira.path_+3A_path">path</code></td>
<td>
<p>character: folder path</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c(1:20)
y&lt;-seq(1,3,length=20)
z&lt;-rnorm(20,0.01)
vertices&lt;-cbind(x,y,z)
export_amira.path(vertices=vertices,filename="example_line",path=tempdir())
</code></pre>

<hr>
<h2 id='ext.int.mesh'>ext.int.mesh</h2><span id='topic+ext.int.mesh'></span>

<h3>Description</h3>

<p>This function finds the vertices visible from a set of points of view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ext.int.mesh(
  mesh,
  views = 20,
  dist.sphere = 3,
  param1 = 2.5,
  param2 = 10,
  default = TRUE,
  import_pov,
  matrix_pov,
  expand = 1,
  scale.factor,
  method = "ast3d",
  start.points = 250,
  num.cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext.int.mesh_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_views">views</code></td>
<td>
<p>numeric: number of points of view</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_dist.sphere">dist.sphere</code></td>
<td>
<p>numeric: scale factor. This parameter the distance betweem the barycenter of the mesh and the radius of the sphere used to define set of points of view</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_param1">param1</code></td>
<td>
<p>numeric: first parameter for spherical flipping (usually ranged from 0.5 to 5, try!)</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_param2">param2</code></td>
<td>
<p>numeric second paramter for spherical flipping (don't change it!)</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_default">default</code></td>
<td>
<p>logical: if TRUE the points of views are defined automatically, if FALSE define the matrix_pov</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_import_pov">import_pov</code></td>
<td>
<p>logical: if NULL an interactive 3D plot for the definition of the points of view is returned</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_matrix_pov">matrix_pov</code></td>
<td>
<p>matrix: external set of points of view</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_expand">expand</code></td>
<td>
<p>numeric: scale factor for the grid for the interactive 3D plot</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric: scale factor for sphere inscribed into the mesh</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_method">method</code></td>
<td>
<p>character: select &quot;a&quot; or &quot;c&quot;</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_start.points">start.points</code></td>
<td>
<p>numeric: number of POVs available</p>
</td></tr>
<tr><td><code id="ext.int.mesh_+3A_num.cores">num.cores</code></td>
<td>
<p>numeric: number of cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>position numeric: a vector with vertex number nearest the landmark set
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Schlager, S., Valoriani, V., Buzi, C., Melchionna, M., Veneziano, A., ... &amp; Manzi, G. (2018). 
Reproducing the internal and external anatomy of fossil bones: Two new automatic digital tools. American Journal of Physical Anthropology, 166(4), 979-986.
</p>

<hr>
<h2 id='ext.mesh.rai'>ext.mesh.rai</h2><span id='topic+ext.mesh.rai'></span>

<h3>Description</h3>

<p>This function returns a 3D mesh with colours based on the vertices visibile from each point of view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ext.mesh.rai(scans, mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext.mesh.rai_+3A_scans">scans</code></td>
<td>
<p>an ext.int.mesh</p>
</td></tr>
<tr><td><code id="ext.mesh.rai_+3A_mesh">mesh</code></td>
<td>
<p>matrix mesh vertex (the same of the ext.int.mesh object)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='femsets'>example dataset</h2><span id='topic+femsets'></span>

<h3>Description</h3>

<p>3D semilandmark configurations of 21 human femora
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(femsets)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='grid_pov'>grid_pov</h2><span id='topic+grid_pov'></span>

<h3>Description</h3>

<p>This function creates a grid for an interactive way to define the set of the points of view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_pov(mesh, expand = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_pov_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="grid_pov_+3A_expand">expand</code></td>
<td>
<p>numeric: scale factor for the grid for the interactive 3D plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrice matrix: matrix with the x,y,z coordinates of the points of view
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='human_skull'>example dataset</h2><span id='topic+human_skull'></span>

<h3>Description</h3>

<p>3D mesh of a human skull
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(human_skull)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='image2palettes'>image2palettes</h2><span id='topic+image2palettes'></span>

<h3>Description</h3>

<p>Create palettes from an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image2palettes(
  array,
  resize = 4,
  unique = FALSE,
  scale = F,
  k = 3,
  lcols = 7,
  plsaxis = 1,
  cex = 5,
  cext = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image2palettes_+3A_array">array</code></td>
<td>
<p>array: rgb array</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_resize">resize</code></td>
<td>
<p>numeric: desidered resize factor</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_unique">unique</code></td>
<td>
<p>logical: if TRUE each color is counted once</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_scale">scale</code></td>
<td>
<p>logical: if TRUE (color) variables are scaled</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_k">k</code></td>
<td>
<p>numeric: desidered number of clusters (i.e., number of palettes)</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_lcols">lcols</code></td>
<td>
<p>numeric: length of the color vector of each palette</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_plsaxis">plsaxis</code></td>
<td>
<p>numeric: desidered PLS axis</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_cex">cex</code></td>
<td>
<p>numeric: size of colored squares</p>
</td></tr>
<tr><td><code id="image2palettes_+3A_cext">cext</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paletteslist list: color palettes arranged in a list
</p>


<h3>Author(s)</h3>

<p>Antonio Profico
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(jpeg)
require(Morpho)
data("Altapic")
image2palettes(Altapic,resize=1,unique=T,scale=T,k=3,lcols=5,plsaxis=1,cext=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='krd1_tooth'>example dataset</h2><span id='topic+krd1_tooth'></span>

<h3>Description</h3>

<p>3D mesh of a decidous Neanderthal tooth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(krd1_tooth)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='landmark_frm2amira'>landmark_frm2amira</h2><span id='topic+landmark_frm2amira'></span>

<h3>Description</h3>

<p>This function converts the .frm files, from Evan Toolbox, stored in a folder into the format landmarkAscii
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmark_frm2amira(path_folder_frm, path_amira_folder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landmark_frm2amira_+3A_path_folder_frm">path_folder_frm</code></td>
<td>
<p>character: path of the folder where the .frm files are stored</p>
</td></tr>
<tr><td><code id="landmark_frm2amira_+3A_path_amira_folder">path_amira_folder</code></td>
<td>
<p>character: path folder to store the landmarkAscii configurations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='listtoarray'>listtoarray
convert a list into an array</h2><span id='topic+listtoarray'></span>

<h3>Description</h3>

<p>listtoarray
convert a list into an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listtoarray(mylist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listtoarray_+3A_mylist">mylist</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a kx3xn array with landmark coordinates
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='localmeshdiff'>localmeshdiff
Calculate and Visualize local differences between two meshes</h2><span id='topic+localmeshdiff'></span>

<h3>Description</h3>

<p>localmeshdiff
Calculate and Visualize local differences between two meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmeshdiff(
  mesh1,
  mesh2,
  ploton = 1,
  diffarea = ((area_shape1 - area_shape2)/area_shape2) * 100,
  paltot = rainbow(200),
  from = NULL,
  to = NULL,
  n.int = 200,
  out.rem = TRUE,
  fact = 1.5,
  visual = 1,
  scale01 = TRUE,
  colwire = "pink"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localmeshdiff_+3A_mesh1">mesh1</code></td>
<td>
<p>reference mesh: object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_mesh2">mesh2</code></td>
<td>
<p>target mesh: object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_ploton">ploton</code></td>
<td>
<p>numeric: define which mesh will be used to visualize local differences</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_diffarea">diffarea</code></td>
<td>
<p>formula: define how calculating differences in area. area_shape1 refers to mesh1, area_shape2 refers to mesh2</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_paltot">paltot</code></td>
<td>
<p>character vector: specify the colors which are used to create a color palette</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_from">from</code></td>
<td>
<p>numeric: minimum distance to be colorised</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_to">to</code></td>
<td>
<p>numeric: maximum distance to be colorised</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_n.int">n.int</code></td>
<td>
<p>numeric: determines break points for color palette</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_out.rem">out.rem</code></td>
<td>
<p>logical: if TRUE outliers will be removed</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_fact">fact</code></td>
<td>
<p>numeric: factor k of the interquartile range</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_visual">visual</code></td>
<td>
<p>numeric: if equals to 1 the mesh is plotted without a wireframe, if set on 2 a wireframe is added</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_scale01">scale01</code></td>
<td>
<p>logical: if TRUE the vector of distances is scaled from 0 to 1</p>
</td></tr>
<tr><td><code id="localmeshdiff_+3A_colwire">colwire</code></td>
<td>
<p>character: color of the wireframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vect numeric vector containing local differeces in area between the reference and the target mesh
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Silvia Castiglione, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Melchionna, M., Profico, A., Castiglione, S., Sansalone, G., Serio, C., Mondanaro, A., ... &amp; Manzi, G. (2020). 
From smart apes to human brain boxes. A uniquely derived brain shape in late hominins clade. Frontiers in Earth Science, 8, 273.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Arothron)
library(rgl)
data("primendoR")
neaset&lt;-primendoR$sets[,,11]
sapset&lt;-primendoR$sets[,,14]
#defining a mesh for the neanderthal right hemisphere
neasur&lt;-list("vb"=t(cbind(neaset,1)),"it"=primendoR$sur$it)
class(neasur)&lt;-"mesh3d"
#defining a mesh for the modern human right hemisphere
sapsur&lt;-list("vb"=t(cbind(sapset,1)),"it"=primendoR$sur$it)
class(neasur)&lt;-"mesh3d"
layout3d(t(c(1,2)),sharedMouse = TRUE)
localmeshdiff(sapsur,neasur,1,scale01 = TRUE,
paltot=c("darkred","red","orange","white","lightblue","blue","darkblue"))
next3d()
localmeshdiff(neasur,sapsur,1,scale01 = TRUE,
paltot=c("darkred","red","orange","white","lightblue","blue","darkblue"))

## End(Not run)
</code></pre>

<hr>
<h2 id='Lset2D_list'>example dataset</h2><span id='topic+Lset2D_list'></span>

<h3>Description</h3>

<p>List containing five 2D-landmark configurations acquired along five different anatomical views
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Lset2D_list)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='Lset3D_array'>example dataset</h2><span id='topic+Lset3D_array'></span>

<h3>Description</h3>

<p>Array containing a cranial 3D-landmark configuration acquired on a Primate sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Lset3D_array)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='malleus_bone'>example dataset</h2><span id='topic+malleus_bone'></span>

<h3>Description</h3>

<p>3D mesh of a human malleus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(malleus_bone)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='MAs_sets'>example dataset</h2><span id='topic+MAs_sets'></span>

<h3>Description</h3>

<p>Landmark configurations of the manual alignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MAs_sets)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='MLECScorrection'>MLECScorrection
Maximum Likelihood Estimation of the normalization factor to be applied to optimize the correlation between two landmark configurations to be combined by using twodviews and</h2><span id='topic+MLECScorrection'></span>

<h3>Description</h3>

<p>MLECScorrection
Maximum Likelihood Estimation of the normalization factor to be applied to optimize the correlation between two landmark configurations to be combined by using twodviews and
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLECScorrection(array1, array2, scale = TRUE, nPCs = 1:5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLECScorrection_+3A_array1">array1</code></td>
<td>
<p>array: first set of landmark configuration</p>
</td></tr>
<tr><td><code id="MLECScorrection_+3A_array2">array2</code></td>
<td>
<p>array: second set of landmark configuration</p>
</td></tr>
<tr><td><code id="MLECScorrection_+3A_scale">scale</code></td>
<td>
<p>logical: if FALSE the analysis is performed in the shape space, if TRUE the analysis is performed in the size and shape space (gpa without scaling)</p>
</td></tr>
<tr><td><code id="MLECScorrection_+3A_npcs">nPCs</code></td>
<td>
<p>numeric vector: specify which PC scores will be selected in the correlation test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PCscores PCscores matrix of the combined dataset applying the normalization factor calculated by using the maximum likelihood estimation
</p>
<p>PCs PCs matrix of the combined dataset applying the normalization factor calculated by using the maximum likelihood estimation
</p>
<p>corr mean correlation between original and combined dataset
</p>
<p>CSratios normalization factor calculated by using the maximum likelihood estimation
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='noise.mesh'>noise.mesh</h2><span id='topic+noise.mesh'></span>

<h3>Description</h3>

<p>This function adds noise to a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise.mesh(mesh, noise = 0.025, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise.mesh_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh stored as object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="noise.mesh_+3A_noise">noise</code></td>
<td>
<p>sd deviation to define vertex noise</p>
</td></tr>
<tr><td><code id="noise.mesh_+3A_seed">seed</code></td>
<td>
<p>seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mesh_n a 3D model of class &quot;mesh3d&quot; with noise
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load mesh
library(compositions)
library(rgl)
data("SCP1.mesh")
mesh&lt;-SCP1.mesh
#add noise
noised&lt;-noise.mesh(mesh,noise=0.05)
#plot original and mesh with noise added
open3d()
shade3d(mesh,col=3)
shade3d(noised,col=2,add=TRUE)
</code></pre>

<hr>
<h2 id='out.inn.mesh'>out.inn.mesh</h2><span id='topic+out.inn.mesh'></span>

<h3>Description</h3>

<p>This function separates a 3D mesh subjected to the ext.int.mesh into two 3D models: the visible mesh and the not visible one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>out.inn.mesh(scans, mesh, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="out.inn.mesh_+3A_scans">scans</code></td>
<td>
<p>an ext.int.mesh</p>
</td></tr>
<tr><td><code id="out.inn.mesh_+3A_mesh">mesh</code></td>
<td>
<p>matrix mesh vertex (the same of the ext.int.mesh object)</p>
</td></tr>
<tr><td><code id="out.inn.mesh_+3A_plot">plot</code></td>
<td>
<p>logical: if TRUE the wireframe of the mesh with the visible vertices is plotted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#CA-LSE tool on Neanderthal tooth
#load a mesh
data(krd1_tooth)
library(rgl)
library(Rvcg)
library(compositions)
ca_lse_krd1&lt;-ext.int.mesh(mesh= krd1_tooth, views=50, param1=3, default=TRUE, 
import_pov = NULL,expand=1, scale.factor=1,num.cores = NULL)
vis_inv_krd1&lt;-out.inn.mesh(ca_lse_krd1, krd1_tooth, plot=TRUE)
inv_mesh&lt;-vcgIsolated(vis_inv_krd1$invisible)
open3d()
shade3d(inv_mesh,col=2)
open3d()
shade3d(vis_inv_krd1$visible, col=3)
#CA-LSE tool on human malleus
#load a mesh
data(malleus_bone)
ca_lse_malleus&lt;-ext.int.mesh(mesh= malleus_bone, views=50, param1=3, 
default=TRUE, import_pov = NULL, expand=1, scale.factor=1)
vis_inv_malleus&lt;-out.inn.mesh(ca_lse_malleus, malleus_bone, plot=TRUE)
inv_mesh&lt;- vis_inv_malleus$invisible
inv_mesh&lt;-ca_lse_malleus$invisible

#AST-3D tool
#load a mesh
data(human_skull)
data(endo_set)
ast3d_endocast&lt;-ext.int.mesh(mesh=human_skull, views=50, param1=0.6, default=FALSE, 
import_pov = TRUE,expand=1, matrix_pov =endo_set, scale.factor=1,num.cores = NULL)
vis_inv_endo&lt;-out.inn.mesh(ast3d_endocast,human_skull,plot=TRUE)
vis_mesh&lt;-vcgIsolated(vis_inv_endo$visible)
open3d()
shade3d(vis_mesh,col=3)
open3d()
shade3d(vis_inv_endo$invisible, col=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='patches_frm2amira'>patches_frm2amira</h2><span id='topic+patches_frm2amira'></span>

<h3>Description</h3>

<p>This function converts the .frm files, from Evan Toolbox, stored in a folder into the format landmarkAscii (semilandmark patches)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patches_frm2amira(path_folder_frm, path_amira_folder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patches_frm2amira_+3A_path_folder_frm">path_folder_frm</code></td>
<td>
<p>character: path of the folder where the .frm files are stored</p>
</td></tr>
<tr><td><code id="patches_frm2amira_+3A_path_amira_folder">path_amira_folder</code></td>
<td>
<p>character: path folder to store the landmarkAscii configurations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='PCscoresCorr'>PCscoresCorr
Perform a correlation test between two matrices of PCscores</h2><span id='topic+PCscoresCorr'></span>

<h3>Description</h3>

<p>PCscoresCorr
Perform a correlation test between two matrices of PCscores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCscoresCorr(matrix1, matrix2, nPCs = 1:5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCscoresCorr_+3A_matrix1">matrix1</code></td>
<td>
<p>matrix: first set of PC scores</p>
</td></tr>
<tr><td><code id="PCscoresCorr_+3A_matrix2">matrix2</code></td>
<td>
<p>matrix: second set of PC scores</p>
</td></tr>
<tr><td><code id="PCscoresCorr_+3A_npcs">nPCs</code></td>
<td>
<p>numeric vector: specify which PC scores will be selected in the correlation test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corr the correlation values associated to each pair of PC scores
</p>
<p>p.values p-values associated to the correlation test
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='permutangle'>permutangle</h2><span id='topic+permutangle'></span>

<h3>Description</h3>

<p>Create palettes from an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutangle(
  mat,
  var,
  group1,
  group2,
  scale = FALSE,
  iter = 100,
  cex1 = range01(var[group1] + 1),
  cex2 = range01(var[group2] + 1),
  cex3 = 0.7,
  cex4 = 1.2,
  labels = c("stgr1", "stgr2", "endgr1", "endgr2"),
  pch1 = 19,
  pch2 = 19,
  pch3 = 19,
  col1 = "red",
  col2 = "blue"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutangle_+3A_mat">mat</code></td>
<td>
<p>array: rgb array</p>
</td></tr>
<tr><td><code id="permutangle_+3A_var">var</code></td>
<td>
<p>numeric: desidered resize factor</p>
</td></tr>
<tr><td><code id="permutangle_+3A_group1">group1</code></td>
<td>
<p>logical: if TRUE each color is counted once</p>
</td></tr>
<tr><td><code id="permutangle_+3A_group2">group2</code></td>
<td>
<p>logical: if TRUE (color) variables are scaled</p>
</td></tr>
<tr><td><code id="permutangle_+3A_scale">scale</code></td>
<td>
<p>numeric: desidered number of clusters (i.e., number of palettes)</p>
</td></tr>
<tr><td><code id="permutangle_+3A_iter">iter</code></td>
<td>
<p>numeric: length of the color vector of each palette</p>
</td></tr>
<tr><td><code id="permutangle_+3A_cex1">cex1</code></td>
<td>
<p>numeric: desidered PLS axis</p>
</td></tr>
<tr><td><code id="permutangle_+3A_cex2">cex2</code></td>
<td>
<p>numeric: size of colored squares</p>
</td></tr>
<tr><td><code id="permutangle_+3A_cex3">cex3</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_cex4">cex4</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_labels">labels</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_pch1">pch1</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_pch2">pch2</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_pch3">pch3</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_col1">col1</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
<tr><td><code id="permutangle_+3A_col2">col2</code></td>
<td>
<p>numeric: size of color names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle list: color palettes arranged in a list
</p>
<p>permangles list: color palettes arranged in a list
</p>
<p>angle list: color palettes arranged in a list
</p>
<p>iterangles list: color palettes arranged in a list
</p>
<p>p-value list: color palettes arranged in a list
</p>
<p>PCA_angle list: color palettes arranged in a list
</p>
<p>PCA_interangles list: color palettes arranged in a list
</p>
<p>PCA_p-value list: color palettes arranged in a list
</p>


<h3>Author(s)</h3>

<p>Antonio Profico
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(shapes)
require(Morpho)
data("gorf.dat")
data("gorm.dat")
Array&lt;-bindArr(gorf.dat,gorm.dat,along=3)
CS&lt;-apply(Array,3,cSize)
Sex&lt;-c(rep("F",dim(gorf.dat)[3]),rep("M",dim(gorm.dat)[3]))

#Shape and size space
AllTrajFB&lt;-permutangle(procSym(Array,scale=FALSE,CSinit = FALSE)$PCscores,
var=CS,group1=which(Sex=="F"),group2=which(Sex=="M"),scale=FALSE,iter=50)
hist(AllTrajFB$iterangles,breaks = 100,xlim=c(0,90))
abline(v=AllTrajFB$angle,lwd=2,col="red")
hist(AllTrajFB$PCA_iterangles,breaks = 100,xlim=c(0,90))
abline(v=AllTrajFB$PCA_angle,lwd=2,col="red")

#Shape space
AllTrajFB&lt;-permutangle(procSym(Array)$PCscores,
var=CS,group1=which(Sex=="F"),group2=which(Sex=="M"),scale=FALSE,iter=50)
hist(AllTrajFB$iterangles,breaks = 100,xlim=c(0,90))
abline(v=AllTrajFB$angle,lwd=2,col="red")
hist(AllTrajFB$PCA_iterangles,breaks = 100,xlim=c(0,90))
abline(v=AllTrajFB$PCA_angle,lwd=2,col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='pov_selecter'>pov_selecter</h2><span id='topic+pov_selecter'></span>

<h3>Description</h3>

<p>Internal function to define the points of view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pov_selecter(mesh, grid, start.points = 250, method = "ast3d")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pov_selecter_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="pov_selecter_+3A_grid">grid</code></td>
<td>
<p>matrix: a 3D grid</p>
</td></tr>
<tr><td><code id="pov_selecter_+3A_start.points">start.points</code></td>
<td>
<p>numeric: number of center to be found</p>
</td></tr>
<tr><td><code id="pov_selecter_+3A_method">method</code></td>
<td>
<p>character: select &quot;a&quot; or &quot;c&quot; for respectively AST-3D and CA-LSE method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selection numeric: positioning vector of the selected points of the grid
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='primendoR'>example dataset</h2><span id='topic+primendoR'></span>

<h3>Description</h3>

<p>right brain hemisphere of 19 primate species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primendoR)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='read.amira.dir'>read.amira.dir</h2><span id='topic+read.amira.dir'></span>

<h3>Description</h3>

<p>This function reads and stores in an array the coordinated allocated in a folder in separate files (format landmarkAscii)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.amira.dir(path.dir, nland)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.amira.dir_+3A_path.dir">path.dir</code></td>
<td>
<p>character: path of the folder</p>
</td></tr>
<tr><td><code id="read.amira.dir_+3A_nland">nland</code></td>
<td>
<p>numeric: number of landmark sampled in Amira</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array.set numeric: a kx3xn array with landmark coordinates
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='read.amira.set'>read.amira.set</h2><span id='topic+read.amira.set'></span>

<h3>Description</h3>

<p>This function converts a landmarkAscii file set in a kx3x1 array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.amira.set(name.file, nland)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.amira.set_+3A_name.file">name.file</code></td>
<td>
<p>character: path of a landmarkAscii file</p>
</td></tr>
<tr><td><code id="read.amira.set_+3A_nland">nland</code></td>
<td>
<p>numeric: number of landmark sampled in Amira, if is set on &quot;auto&quot; it will be automatically recognized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array.set numeric: a kx3x1 array with landmark coordinates
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='read.path.amira'>read.path.amira</h2><span id='topic+read.path.amira'></span>

<h3>Description</h3>

<p>This function extracts and orders the coordinate matrix from a surface path file from Amira
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.path.amira(path.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.path.amira_+3A_path.name">path.name</code></td>
<td>
<p>character: path of surface path .ascii extension file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data numeric: a kxd matrix with xyz coordinates
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='repmat'>repmat</h2><span id='topic+repmat'></span>

<h3>Description</h3>

<p>This function repeats copies of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmat(X, m, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repmat_+3A_x">X</code></td>
<td>
<p>numeric: a matrix</p>
</td></tr>
<tr><td><code id="repmat_+3A_m">m</code></td>
<td>
<p>numeric: number of times to repeat the X matrix in row and column dimension</p>
</td></tr>
<tr><td><code id="repmat_+3A_n">n</code></td>
<td>
<p>numeric: repetition factor for each dimesion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrice: repeated matrix
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='RMs_sets'>example dataset</h2><span id='topic+RMs_sets'></span>

<h3>Description</h3>

<p>Array containing the landmark coordinates of the reference sample for Digital Alignment Tool example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RMs_sets)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='SCP1.mesh'>example dataset</h2><span id='topic+SCP1.mesh'></span>

<h3>Description</h3>

<p>Mesh of the Saccopastore 1 Neanderthal skull
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SCP1.mesh)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='sinus_set'>example dataset</h2><span id='topic+sinus_set'></span>

<h3>Description</h3>

<p>POVs sampled inside the maxillary sinus cavity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sinus_set)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='SM_set'>example dataset</h2><span id='topic+SM_set'></span>

<h3>Description</h3>

<p>Landmark configuration associated to the starting model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SM_set)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='spherical.flipping'>spherical.flipping</h2><span id='topic+spherical.flipping'></span>

<h3>Description</h3>

<p>Internal spherical flippping function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherical.flipping(C, mesh, param1, param2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherical.flipping_+3A_c">C</code></td>
<td>
<p>numeric: coordinates of the point of view</p>
</td></tr>
<tr><td><code id="spherical.flipping_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="spherical.flipping_+3A_param1">param1</code></td>
<td>
<p>numeric: first parameter for spherical flipping (usually ranged from 0.1 to 3, try!)</p>
</td></tr>
<tr><td><code id="spherical.flipping_+3A_param2">param2</code></td>
<td>
<p>numeric second paramter for spherical flipping (don't change it!)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Schlager, S., Valoriani, V., Buzi, C., Melchionna, M., Veneziano, A., ... &amp; Manzi, G. (2018). 
Reproducing the internal and external anatomy of fossil bones: Two new automatic digital tools. American Journal of Physical Anthropology, 166(4), 979-986.#' @export
</p>
<p>Katz, S., Tal, A., &amp; Basri, R. (2007). Direct visibility of point sets. In ACM SIGGRAPH 2007 papers (pp. 24-es).
</p>

<hr>
<h2 id='trasf.mesh'>trasf.mesh</h2><span id='topic+trasf.mesh'></span>

<h3>Description</h3>

<p>This function centers a mesh on the barycenter coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trasf.mesh(mesh, barycenter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trasf.mesh_+3A_mesh">mesh</code></td>
<td>
<p>a 3D mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="trasf.mesh_+3A_barycenter">barycenter</code></td>
<td>
<p>numeric: coordinates of the center</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mesh a 3D mesh of class &quot;mesh3d&quot;
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='twodvarshape'>twodvarshape 
Calculates the shape variation associated to a value of PC scores associated to a specific combined landmark configuration or view</h2><span id='topic+twodvarshape'></span>

<h3>Description</h3>

<p>twodvarshape 
Calculates the shape variation associated to a value of PC scores associated to a specific combined landmark configuration or view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twodvarshape(twodviews_ob, scores, PC, view)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twodvarshape_+3A_twodviews_ob">twodviews_ob</code></td>
<td>
<p>object from twodviews()</p>
</td></tr>
<tr><td><code id="twodvarshape_+3A_scores">scores</code></td>
<td>
<p>numeric: the values of the PC scores for which the visualization is called</p>
</td></tr>
<tr><td><code id="twodvarshape_+3A_pc">PC</code></td>
<td>
<p>PC chosen</p>
</td></tr>
<tr><td><code id="twodvarshape_+3A_view">view</code></td>
<td>
<p>numeric: which landmark configuration will be used to build the shape variation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mat matrix of coordinates associated to the called shape variation
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Piras, P., Buzi, C., Del Bove, A., Melchionna, M., Senczuk, G., ... &amp; Manzi, G. (2019). 
Seeing the wood through the trees. Combining shape information from different landmark configurations. Hystrix, 157-165.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Arothron)
#load the 2D primate dataset
data("Lset2D_list")
#combine the 2D datasets and PCA
combin2D&lt;-twodviews(Lset2D_list,scale=TRUE,vector=c(1:5))
#calculate the shape variation associated to the negative extreme value of PC1
min_PC1&lt;-twodvarshape(combin2D,min(combin2D$PCscores[,1]),1,5)
plot(min_PC1,asp=1)
#calculate the shape variation associated to the positive extreme value of PC1
max_PC1&lt;-twodvarshape(combin2D,max(combin2D$PCscores[,1]),1,5)
plot(max_PC1,asp=1)
</code></pre>

<hr>
<h2 id='twodviews'>twodviews
Combine and calculate the PCscores matrix from a list of different landmark configurations to be combined</h2><span id='topic+twodviews'></span>

<h3>Description</h3>

<p>twodviews
Combine and calculate the PCscores matrix from a list of different landmark configurations to be combined
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twodviews(twodlist, scale = TRUE, vector = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twodviews_+3A_twodlist">twodlist</code></td>
<td>
<p>a list containing the landmark configurations of each anatomical view stored as separated lists</p>
</td></tr>
<tr><td><code id="twodviews_+3A_scale">scale</code></td>
<td>
<p>logical: TRUE for shape-space, FALSE for form-space</p>
</td></tr>
<tr><td><code id="twodviews_+3A_vector">vector</code></td>
<td>
<p>numeric vector: defines which views are to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PCscores PC scores
</p>
<p>PCs Pricipal Components (eigenvector matrix)
</p>
<p>Variance table of the explained variance by the PCs
</p>
<p>size vector containing the Centroid Size of each configuration
</p>
<p>mshapes a list containing the mean shape of each landmark configuration
</p>
<p>dims number of landmarks of each configuration
</p>
<p>dimm dimension (2D or 3D) of each combined landmark configuration
</p>
<p>twodlist the list used as input
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>References</h3>

<p>Profico, A., Piras, P., Buzi, C., Del Bove, A., Melchionna, M., Senczuk, G., ... &amp; Manzi, G. (2019). 
Seeing the wood through the trees. Combining shape information from different landmark configurations. Hystrix, 157-165.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Morpho)
#load the 2D primate dataset
data("Lset2D_list")
length(Lset2D_list)
#combine the 2D datasets and PCA
combin2D&lt;-twodviews(Lset2D_list,scale=TRUE,vector=c(1:5))
combin2D$size
#plot of the first two Principal Components
plot(combin2D$PCscores)
text(combin2D$PCscores,labels=rownames(combin2D$PCscores))
#load the 3D primate dataset
data("Lset3D_array")
#GPA and PCA
GPA_3D&lt;-procSym(Lset3D_array)
#plot of the first two Principal Components
plot(GPA_3D$PCscores)
text(GPA_3D$PCscores,labels=rownames(GPA_3D$PCscores))
</code></pre>

<hr>
<h2 id='volendo'>volendo</h2><span id='topic+volendo'></span>

<h3>Description</h3>

<p>Calculate the volume of a mesh by using a voxel-based method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volendo(mesh, alpha_vol = 100, ncells = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volendo_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="volendo_+3A_alpha_vol">alpha_vol</code></td>
<td>
<p>numeric: alpha shape for construction external concave hull</p>
</td></tr>
<tr><td><code id="volendo_+3A_ncells">ncells</code></td>
<td>
<p>numeric: approximative number of cell for 3D grid construction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vol numeric: volume of the mesh expressed in cc
</p>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#load the human skull
library(rgl)
data(human_skull)
sapendo&lt;-endomaker(human_skull,param1_endo = 1.0,vol=FALSE, num.cores=NULL)
volsap&lt;-volendo(sapendo$endocast)

## End(Not run)
</code></pre>

<hr>
<h2 id='yoda_set'>example dataset</h2><span id='topic+yoda_set'></span>

<h3>Description</h3>

<p>Landmark set on Yoda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(yoda_set)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

<hr>
<h2 id='yoda_sur'>example dataset</h2><span id='topic+yoda_sur'></span>

<h3>Description</h3>

<p>Mesh of Yoda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(yoda_sur)
</code></pre>


<h3>Author(s)</h3>

<p>Antonio Profico, Costantino Buzi, Marina Melchionna, Paolo Piras, Pasquale Raia, Alessio Veneziano
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
