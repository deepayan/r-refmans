<!DOCTYPE html><html><head><title>Help for package nhppp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nhppp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nhppp-package'><p>nhppp: Simulating Nonhomogeneous Poisson Point Processes</p></a></li>
<li><a href='#check_ppp_sample_validity'><p>Check the validity of a ppp vector.</p></a></li>
<li><a href='#compare_ppp_vectors'><p>Check that two ppp vectors Q-Q agree</p></a></li>
<li><a href='#draw'><p>Generic function for simulating from NHPPPs given the intensity function</p>
or the cumulative intensity function.</a></li>
<li><a href='#draw_cumulative_intensity_inversion'><p>Simulate from a non homogeneous Poisson Point Process (NHPPP) from</p>
(t_min, t_max) (inversion method)</a></li>
<li><a href='#draw_cumulative_intensity_orderstats'><p>Simulate from a non homogeneous Poisson Point Process (NHPPP) from</p>
(t_min, t_max) (order statistics method)</a></li>
<li><a href='#draw_intensity'><p>Simulate from a non homogeneous Poisson Point Process (NHPPP) from</p>
(t0, t_max) (thinning method)</a></li>
<li><a href='#draw_intensity_step'><p>Simulate from a non homogeneous Poisson Point Process (NHPPP) from</p>
(t0, t_max) (thinning method) with piecewise constant_majorizer</a></li>
<li><a href='#draw_sc_linear'><p>Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from</p>
(t_min, t_max) with linear intensity function (inversion method)</a></li>
<li><a href='#draw_sc_loglinear'><p>Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from</p>
(t_min, t_max) with log-linear intensity function (inversion method)</a></li>
<li><a href='#draw_sc_step'><p>Simulate a piecewise constant-rate Poisson Point Process over <code style="white-space: pre;">&#8288;(t_min, t_max]&#8288;</code> (inversion method)</p>
The intervals need not have the same length.</a></li>
<li><a href='#draw_sc_step_regular'><p>Sampling from NHPPPs with piecewise constant intensities</p>
with same interval lengths (non-vectorized)</a></li>
<li><a href='#expect_no_error'><p>Helper functions</p></a></li>
<li><a href='#get_step_majorizer'><p>Piecewise constant (step) majorizer for K-Lipschitz functions over an interval</p></a></li>
<li><a href='#inverse_with_uniroot'><p>Numerically evaluate the inverse of a function at a specific point</p></a></li>
<li><a href='#inverse_with_uniroot_sorted'><p>Numerically evaluate the inverse of a monotonically increasing continuous</p>
function from R to R at specific points.</a></li>
<li><a href='#Lambda_exp_form'><p>Definite integral of <code>l = exp(alpha + beta*t)</code> at time <code>t</code></p>
with <code>L(t0) = 0</code></a></li>
<li><a href='#Lambda_inv_exp_form'><p>Inverse of the definite integral of <code>l = exp(alpha + beta*t)</code> at time <code>t</code></p></a></li>
<li><a href='#Lambda_inv_linear_form'><p>Inverse of the definite integral of <code>l = alpha + beta*t</code> at time <code>t</code></p></a></li>
<li><a href='#Lambda_linear_form'><p>Definite integral of <code>l = alpha + beta*t</code> at time <code>t</code></p>
with <code>L(t0) = 0</code></a></li>
<li><a href='#mat_cumsum_columns'><p>Return matrix with column-wise cumulative sum</p>
No checks for arguments is done.</a></li>
<li><a href='#mat_cumsum_columns_with_scalar_ceiling'><p>Return matrix with column-wise cumulative sum</p>
replacing cells larger than <code>ceil</code> with <code>NA</code>.
No checks for arguments is done.</a></li>
<li><a href='#mat_cumsum_columns_with_vector_ceiling'><p>Return matrix with column-wise cumulative sum</p>
replacing cells larger than <code>ceil</code> with <code>NA</code>.
No checks for arguments is done.</a></li>
<li><a href='#ppp_n'><p>Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max]</p></a></li>
<li><a href='#ppp_next_n'><p>Simulate n events from a homogeneous Poisson Point Process.</p></a></li>
<li><a href='#ppp_orderstat'><p>Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method)</p></a></li>
<li><a href='#ppp_sequential'><p>Simulate a homogeneous Poisson Point Process over (t_min, t_max]</p></a></li>
<li><a href='#read_code'><p>Read code from text file as string</p></a></li>
<li><a href='#rng_stream_rexp'><p>Exponential random samples from <code>rstream</code> objects</p></a></li>
<li><a href='#rng_stream_rpois'><p>Poisson random samples from <code>rstream</code> objects</p></a></li>
<li><a href='#rng_stream_runif'><p>Uniform random samples from <code>rstream</code> objects</p></a></li>
<li><a href='#rng_stream_rztpois'><p>Zero-truncated Poisson random samples from <code>rstream</code> objects</p></a></li>
<li><a href='#simpson_num_integr'><p>Simpson's method to integrate a univariate function.</p></a></li>
<li><a href='#vdraw_sc_step_regular'><p>Vectorized sampling from NHPPPs with piecewise constant intensities</p>
with same interval lengths</a></li>
<li><a href='#ztdraw_cumulative_intensity'><p>Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from</p>
(t_min, t_max) (order statistics method)</a></li>
<li><a href='#ztdraw_intensity'><p>Simulate <code>size</code> samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from</p>
(t0, t_max) (thinning method)</a></li>
<li><a href='#ztdraw_intensity_step'><p>Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from</p>
(t0, t_max) (thinning method) with piecewise constant_majorizer</a></li>
<li><a href='#ztdraw_sc_linear'><p>Simulate <code>size</code> samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from</p>
(t_min, t_max) with linear intensity function</a></li>
<li><a href='#ztdraw_sc_loglinear'><p>Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from</p>
(t_min, t_max) with a log-linear intensity function (inversion method)</a></li>
<li><a href='#ztppp'><p>Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max]</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulating Nonhomogeneous Poisson Point Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates events from one dimensional nonhomogeneous Poisson point processes (NHPPPs). Functions are based on three algorithms that provably sample from a target NHPPP: the time-transformation of a homogeneous Poisson process (of intensity one) via the inverse of the integrated intensity function (Cinlar E, "Theory of stochastic processes" (1975, ISBN:0486497996)); the generation of a Poisson number of order statistics from a fixed density function; and the thinning of a majorizing NHPPP via an acceptance-rejection scheme (Lewis PAW, Shedler, GS (1979) &lt;<a href="https://doi.org/10.1002%2Fnav.3800260304">doi:10.1002/nav.3800260304</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>lifecycle, rstream</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>es</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, withr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bladder-ca/nhppp-fast">https://github.com/bladder-ca/nhppp-fast</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bladder-ca/nhppp-fast/issues">https://github.com/bladder-ca/nhppp-fast/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 12:41:54 UTC; tom</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Trikalinos <a href="https://orcid.org/0000-0002-3990-1848"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Yuliia Sereda <a href="https://orcid.org/0000-0002-4017-4561"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Trikalinos &lt;thomas_trikalinos@brown.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 19:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='nhppp-package'>nhppp: Simulating Nonhomogeneous Poisson Point Processes</h2><span id='topic+nhppp'></span><span id='topic+nhppp-package'></span>

<h3>Description</h3>

<p>Simulates events from one dimensional nonhomogeneous Poisson point processes (NHPPPs). Functions are based on three algorithms that provably sample from a target NHPPP: the time-transformation of a homogeneous Poisson process (of intensity one) via the inverse of the integrated intensity function (Cinlar E, &quot;Theory of stochastic processes&quot; (1975, ISBN:0486497996)); the generation of a Poisson number of order statistics from a fixed density function; and the thinning of a majorizing NHPPP via an acceptance-rejection scheme (Lewis PAW, Shedler, GS (1979) <a href="https://doi.org/10.1002/nav.3800260304">doi:10.1002/nav.3800260304</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Trikalinos <a href="mailto:thomas_trikalinos@brown.edu">thomas_trikalinos@brown.edu</a> (<a href="https://orcid.org/0000-0002-3990-1848">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Yuliia Sereda <a href="mailto:sereda_yuliia@brown.edu">sereda_yuliia@brown.edu</a> (<a href="https://orcid.org/0000-0002-4017-4561">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bladder-ca/nhppp-fast">https://github.com/bladder-ca/nhppp-fast</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bladder-ca/nhppp-fast/issues">https://github.com/bladder-ca/nhppp-fast/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_ppp_sample_validity'>Check the validity of a ppp vector.</h2><span id='topic+check_ppp_sample_validity'></span>

<h3>Description</h3>

<p>Standard checks for a vector of ordered times. Check
that the <code>times</code> vector is sorted, has unique values, has all values
in <code style="white-space: pre;">&#8288;[t_min, t_max]&#8288;</code>, and has length <code>size</code> (if applicable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ppp_sample_validity(
  times,
  t_min,
  t_max = NULL,
  size = NULL,
  atmost1 = FALSE,
  atleast1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ppp_sample_validity_+3A_times">times</code></td>
<td>
<p>(vector, double) the times to be checked</p>
</td></tr>
<tr><td><code id="check_ppp_sample_validity_+3A_t_min">t_min</code></td>
<td>
<p>(double) the start of the time nterval</p>
</td></tr>
<tr><td><code id="check_ppp_sample_validity_+3A_t_max">t_max</code></td>
<td>
<p>(double) optional: the end of the time interval</p>
</td></tr>
<tr><td><code id="check_ppp_sample_validity_+3A_size">size</code></td>
<td>
<p>(double) optional: the size of the vector</p>
</td></tr>
<tr><td><code id="check_ppp_sample_validity_+3A_atmost1">atmost1</code></td>
<td>
<p>(boolean) optional: at most one sample returned</p>
</td></tr>
<tr><td><code id="check_ppp_sample_validity_+3A_atleast1">atleast1</code></td>
<td>
<p>(boolean) optional: at least one sample returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='compare_ppp_vectors'>Check that two ppp vectors Q-Q agree</h2><span id='topic+compare_ppp_vectors'></span>

<h3>Description</h3>

<p>Compare that the deciles of two vectors have absolute difference
over average ratios less than <code>threshold</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_ppp_vectors(ppp1, ppp2, threshold = 0.15, showQQ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_ppp_vectors_+3A_ppp1">ppp1</code></td>
<td>
<p>(vector, double) the first vector</p>
</td></tr>
<tr><td><code id="compare_ppp_vectors_+3A_ppp2">ppp2</code></td>
<td>
<p>(vector, double) the second vector</p>
</td></tr>
<tr><td><code id="compare_ppp_vectors_+3A_threshold">threshold</code></td>
<td>
<p>(double) optional: the cutoff for a large absolute threshold</p>
</td></tr>
<tr><td><code id="compare_ppp_vectors_+3A_showqq">showQQ</code></td>
<td>
<p>(boolean) optional: show the QQ plot if the absolute value of the
Difference vs Average ratio in any decile is bigger than the <code>threshold</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='draw'>Generic function for simulating from NHPPPs given the intensity function
or the cumulative intensity function.</h2><span id='topic+draw'></span>

<h3>Description</h3>

<p>This is a wrapper to the package's specific functions, and thus somewhat slower.
For time-intensive simulations prefer one of the specific functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(
  lambda = NULL,
  lambda_maj = NULL,
  Lambda = NULL,
  Lambda_inv = NULL,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE,
  atleast1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_lambda">lambda</code></td>
<td>
<p>(function) the instantaneous rate of the NHPPP.
A continuous function of time.</p>
</td></tr>
<tr><td><code id="draw_+3A_lambda_maj">lambda_maj</code></td>
<td>
<p>(double, vector) the intercept and optional slope of the majorizing
linear (if <code>exp_maj = FALSE</code>) or log-linear (if <code>exp_maj = TRUE</code>) function in <code>range_t</code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_lambda">Lambda</code></td>
<td>
<p>(function, double vector) a continuous increasing R to R map
which is the integrated rate of the NHPPP</p>
</td></tr>
<tr><td><code id="draw_+3A_lambda_inv">Lambda_inv</code></td>
<td>
<p>(function, double vector) the inverse of <code>Lambda()</code></p>
</td></tr>
<tr><td><code id="draw_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval.</p>
</td></tr>
<tr><td><code id="draw_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
<tr><td><code id="draw_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
<tr><td><code id="draw_+3A_atleast1">atleast1</code></td>
<td>
<p>boolean, draw at least 1 event time in interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times
</p>

<hr>
<h2 id='draw_cumulative_intensity_inversion'>Simulate from a non homogeneous Poisson Point Process (NHPPP) from
(t_min, t_max) (inversion method)</h2><span id='topic+draw_cumulative_intensity_inversion'></span>

<h3>Description</h3>

<p>Sample NHPPP times using the inversion method,
optionally using an <code>rstream</code> generator object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_cumulative_intensity_inversion(
  Lambda,
  Lambda_inv = NULL,
  range_t = c(0, 10),
  range_L = c(Lambda(range_t[1]), Lambda(range_t[2])),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_cumulative_intensity_inversion_+3A_lambda">Lambda</code></td>
<td>
<p>(function, double vector) a continuous increasing R to R map
which is the integrated rate of the NHPPP</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_inversion_+3A_lambda_inv">Lambda_inv</code></td>
<td>
<p>(function, double vector) the inverse of <code>Lambda()</code></p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_inversion_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_inversion_+3A_range_l">range_L</code></td>
<td>
<p>(vector, double) min and max of the transformed time interval</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_inversion_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object.</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_inversion_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_); if no events realize,
a vector of length 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_cumulative_intensity_inversion(Lambda = function(t) t + cos(t) - 1)
</code></pre>

<hr>
<h2 id='draw_cumulative_intensity_orderstats'>Simulate from a non homogeneous Poisson Point Process (NHPPP) from
(t_min, t_max) (order statistics method)</h2><span id='topic+draw_cumulative_intensity_orderstats'></span>

<h3>Description</h3>

<p>Sample NHPPP times using the order statistics method,
optionally using an <code>rstream</code> generator object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_cumulative_intensity_orderstats(
  Lambda,
  Lambda_inv = NULL,
  range_t = c(0, 10),
  range_L = c(Lambda(range_t[1]), Lambda(range_t[2])),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_cumulative_intensity_orderstats_+3A_lambda">Lambda</code></td>
<td>
<p>(function, double vector) a continuous increasing R to R map
which is the integrated rate of the NHPPP</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_orderstats_+3A_lambda_inv">Lambda_inv</code></td>
<td>
<p>(function, double vector) the inverse of <code>Lambda()</code></p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_orderstats_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_orderstats_+3A_range_l">range_L</code></td>
<td>
<p>(vector, double) min and max of the transformed time interval</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_orderstats_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="draw_cumulative_intensity_orderstats_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_); if no events realize,
a vector of length 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_cumulative_intensity_orderstats(Lambda = function(t) t + cos(t) - 1)
</code></pre>

<hr>
<h2 id='draw_intensity'>Simulate from a non homogeneous Poisson Point Process (NHPPP) from
(t0, t_max) (thinning method)</h2><span id='topic+draw_intensity'></span>

<h3>Description</h3>

<p>Sample NHPPP times using the thinning method, optionally using
an <code>rstream</code> generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_intensity(
  lambda,
  lambda_maj = NULL,
  exp_maj = FALSE,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_intensity_+3A_lambda">lambda</code></td>
<td>
<p>(function) the instantaneous rate of the NHPPP.
A continuous function of time.</p>
</td></tr>
<tr><td><code id="draw_intensity_+3A_lambda_maj">lambda_maj</code></td>
<td>
<p>(double, vector) the intercept and optional slope of the majorizing
linear (if <code>exp_maj = FALSE</code>) or log-linear (if <code>exp_maj = TRUE</code>) function in <code>range_t</code>.</p>
</td></tr>
<tr><td><code id="draw_intensity_+3A_exp_maj">exp_maj</code></td>
<td>
<p>(boolean) if <code>TRUE</code> the majorizer is <code>exp(alpha + beta * t)</code></p>
</td></tr>
<tr><td><code id="draw_intensity_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval.</p>
</td></tr>
<tr><td><code id="draw_intensity_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
<tr><td><code id="draw_intensity_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_); if no events realize,
a vector of length 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_intensity(lambda = function(t) 1 + sin(t))
</code></pre>

<hr>
<h2 id='draw_intensity_step'>Simulate from a non homogeneous Poisson Point Process (NHPPP) from
(t0, t_max) (thinning method) with piecewise constant_majorizer</h2><span id='topic+draw_intensity_step'></span>

<h3>Description</h3>

<p>Sample NHPPP times using the thinning method, optionally using
an <code>rstream</code> generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_intensity_step(
  lambda,
  lambda_maj_vector = lambda(1:10),
  times_vector = 0:10,
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_intensity_step_+3A_lambda">lambda</code></td>
<td>
<p>(function) the instantaneous rate of the NHPPP.
A continuous function of time.</p>
</td></tr>
<tr><td><code id="draw_intensity_step_+3A_lambda_maj_vector">lambda_maj_vector</code></td>
<td>
<p>(scalar, double) <code>K</code> constant majorizing rates, one per interval</p>
</td></tr>
<tr><td><code id="draw_intensity_step_+3A_times_vector">times_vector</code></td>
<td>
<p>(vector, double) <code>K+1</code> time points defining <code>K</code> intervals
of constant rates:
<code style="white-space: pre;">&#8288;[t_1 = range_t[1],       t_2)&#8288;</code>: the first interval
<code style="white-space: pre;">&#8288;[t_k,                t_{k+1})&#8288;</code>: the <code>k</code>-th interval
<code style="white-space: pre;">&#8288;[t_{K}, t_{K+1} = range_t[2])&#8288;</code>: the <code>K</code>-th (last) interval</p>
</td></tr>
<tr><td><code id="draw_intensity_step_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
<tr><td><code id="draw_intensity_step_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_); if no events realize,
a vector of length 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_intensity_step(lambda = function(t) exp(.02 * t))
</code></pre>

<hr>
<h2 id='draw_sc_linear'>Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from
(t_min, t_max) with linear intensity function (inversion method)</h2><span id='topic+draw_sc_linear'></span>

<h3>Description</h3>

<p>Sample NHPPP times from a linear intensity function
using the inversion method, optionally using an <code>rstream</code>
generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_sc_linear(
  alpha = 1,
  beta = 0,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_sc_linear_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept</p>
</td></tr>
<tr><td><code id="draw_sc_linear_+3A_beta">beta</code></td>
<td>
<p>(double) the slope</p>
</td></tr>
<tr><td><code id="draw_sc_linear_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="draw_sc_linear_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object.</p>
</td></tr>
<tr><td><code id="draw_sc_linear_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_); if no events realize,
a vector of length 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_sc_linear(alpha = 0, beta = 0.2)

</code></pre>

<hr>
<h2 id='draw_sc_loglinear'>Special case: Simulate from a non homogeneous Poisson Point Process (NHPPP) from
(t_min, t_max) with log-linear intensity function (inversion method)</h2><span id='topic+draw_sc_loglinear'></span>

<h3>Description</h3>

<p>Sample NHPPP times from an log linear intensity function
using the inversion method, optionally using an <code>rstream</code>
generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_sc_loglinear(
  alpha = 1,
  beta = 0,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_sc_loglinear_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept in the exponent</p>
</td></tr>
<tr><td><code id="draw_sc_loglinear_+3A_beta">beta</code></td>
<td>
<p>(double) the slope in the exponent</p>
</td></tr>
<tr><td><code id="draw_sc_loglinear_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="draw_sc_loglinear_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object.</p>
</td></tr>
<tr><td><code id="draw_sc_loglinear_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_); if no events realize,
a vector of length 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_sc_loglinear(alpha = 0, beta = 0.2)

</code></pre>

<hr>
<h2 id='draw_sc_step'>Simulate a piecewise constant-rate Poisson Point Process over <code style="white-space: pre;">&#8288;(t_min, t_max]&#8288;</code> (inversion method)
The intervals need not have the same length.</h2><span id='topic+draw_sc_step'></span>

<h3>Description</h3>

<p>Simulate a piecewise constant-rate Poisson Point Process over <code style="white-space: pre;">&#8288;(t_min, t_max]&#8288;</code> (inversion method)
The intervals need not have the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_sc_step(
  lambda_vector = rep(1, 5),
  times_vector = c(0:5),
  rng_stream = NULL,
  atmost1 = FALSE,
  atleast1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_sc_step_+3A_lambda_vector">lambda_vector</code></td>
<td>
<p>(scalar, double) <code>K</code> constant rates, one per interval</p>
</td></tr>
<tr><td><code id="draw_sc_step_+3A_times_vector">times_vector</code></td>
<td>
<p>(vector, double) <code>K+1</code> time points defining <code>K</code> intervals
of constant rates:
<code style="white-space: pre;">&#8288;[t_1 = range_t[1],       t_2)&#8288;</code>: the first interval
<code style="white-space: pre;">&#8288;[t_k,                t_{k+1})&#8288;</code>: the <code>k</code>-th interval
<code style="white-space: pre;">&#8288;[t_{K}, t_{K+1} = range_t[2])&#8288;</code>: the <code>K</code>-th (last) interval</p>
</td></tr>
<tr><td><code id="draw_sc_step_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
<tr><td><code id="draw_sc_step_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
<tr><td><code id="draw_sc_step_+3A_atleast1">atleast1</code></td>
<td>
<p>boolean, draw at least 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times t
if no events realize, it will have 0 length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_sc_step(lambda_vector = rep(1, 5), times_vector = c(0:5))
</code></pre>

<hr>
<h2 id='draw_sc_step_regular'>Sampling from NHPPPs with piecewise constant intensities
with same interval lengths (non-vectorized)</h2><span id='topic+draw_sc_step_regular'></span>

<h3>Description</h3>

<p>Sampling from NHPPPs with piecewise constant intensities
with same interval lengths (non-vectorized)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_sc_step_regular(
  Lambda_vector = NULL,
  lambda_vector = NULL,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE,
  atleast1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_sc_step_regular_+3A_lambda_vector">Lambda_vector</code></td>
<td>
<p>(scalar, double) <code>K</code> integrated intensity rates at the end of each interval</p>
</td></tr>
<tr><td><code id="draw_sc_step_regular_+3A_lambda_vector">lambda_vector</code></td>
<td>
<p>(scalar, double) <code>K</code> constant intensity rates, one per interval</p>
</td></tr>
<tr><td><code id="draw_sc_step_regular_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) <code>t_min</code> and <code>t_max</code></p>
</td></tr>
<tr><td><code id="draw_sc_step_regular_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
<tr><td><code id="draw_sc_step_regular_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
<tr><td><code id="draw_sc_step_regular_+3A_atleast1">atleast1</code></td>
<td>
<p>boolean, draw at least 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times t
if no events realize, it will have 0 length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- draw_sc_step_regular(Lambda_vector = 1:5, range_t = c(0, 5))
</code></pre>

<hr>
<h2 id='expect_no_error'>Helper functions</h2><span id='topic+expect_no_error'></span>

<h3>Description</h3>

<p>helper function that augments
<code>test_that::expect_no_error()</code> to expect no error.
Copied from the <code>R6</code> source code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_no_error(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_no_error_+3A_expr">expr</code></td>
<td>
<p>Expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Small utility functions. Not to be exported to the user.
</p>

<hr>
<h2 id='get_step_majorizer'>Piecewise constant (step) majorizer for K-Lipschitz functions over an interval</h2><span id='topic+get_step_majorizer'></span>

<h3>Description</h3>

<p>Return a piecewise constant (step) majorizer for K-Lipschitz functions
over an interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_step_majorizer(fun, breaks, is_monotone = TRUE, K = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_step_majorizer_+3A_fun">fun</code></td>
<td>
<p>A function object with a single argument <code>x</code></p>
</td></tr>
<tr><td><code id="get_step_majorizer_+3A_breaks">breaks</code></td>
<td>
<p>(vector) The set of <code>M+1</code> boundaries for the <code>M</code> subintervals in <code>x</code></p>
</td></tr>
<tr><td><code id="get_step_majorizer_+3A_is_monotone">is_monotone</code></td>
<td>
<p>(boolean) Is the function monotone? (Default is <code>TRUE</code>.)</p>
</td></tr>
<tr><td><code id="get_step_majorizer_+3A_k">K</code></td>
<td>
<p>(double) A non-negative number for the Lipschitz cone. (Default is 0.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>M</code> with the values of the piecewise constant majorizer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_step_majorizer(fun = abs, breaks = -5:5, is_monotone = FALSE, K = 1)
</code></pre>

<hr>
<h2 id='inverse_with_uniroot'>Numerically evaluate the inverse of a function at a specific point</h2><span id='topic+inverse_with_uniroot'></span>

<h3>Description</h3>

<p>Numerically evaluate the inverse of a function at a specific point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_with_uniroot(
  f = f,
  y,
  min_x = 0,
  max_x = 1,
  min_y = f(min_x),
  max_y = f(max_x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_with_uniroot_+3A_f">f</code></td>
<td>
<p>(function) the function to be inverted; must be continuous
and increasing</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_+3A_y">y</code></td>
<td>
<p>(scalar, double) the f(x)=y value in which to evaluate the inverse</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_+3A_min_x">min_x</code></td>
<td>
<p>(scalar, double) the min of the domain of f()</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_+3A_max_x">max_x</code></td>
<td>
<p>(scalar, double) the max of the domain of f()</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_+3A_min_y">min_y</code></td>
<td>
<p>(scalar, double) the min in the range of f()</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_+3A_max_y">max_y</code></td>
<td>
<p>(scalar, double) the max in the range of f()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(scalar, double) vector of x=f^(-1)(y): the inverted value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inverse_with_uniroot(f = function(x) {
  2 * x
}, y = 0.5)
</code></pre>

<hr>
<h2 id='inverse_with_uniroot_sorted'>Numerically evaluate the inverse of a monotonically increasing continuous
function from R to R at specific points.</h2><span id='topic+inverse_with_uniroot_sorted'></span>

<h3>Description</h3>

<p>Numerically evaluate the inverse of a monotonically increasing continuous
function from R to R at specific points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_with_uniroot_sorted(
  f,
  y,
  range_x = c(0, 10),
  range_y = c(f(range_x[1]), f(range_x[2]))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_with_uniroot_sorted_+3A_f">f</code></td>
<td>
<p>(function) the function to be inverted; must be continuous
and increasing</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_sorted_+3A_y">y</code></td>
<td>
<p>(vector, double) the f(x)=y values in which to evaluate the inverse;
must be in ascending order</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_sorted_+3A_range_x">range_x</code></td>
<td>
<p>(vector, double) the min and max of the domain of f()</p>
</td></tr>
<tr><td><code id="inverse_with_uniroot_sorted_+3A_range_y">range_y</code></td>
<td>
<p>(vector, double) the min and max in the range of f()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(vector, double) vector of x=f^(-1)(y): the inverted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inverse_with_uniroot_sorted(f = function(x) {
  2 * x
}, y = c(0, 0.5))
</code></pre>

<hr>
<h2 id='Lambda_exp_form'>Definite integral of <code>l = exp(alpha + beta*t)</code> at time <code>t</code>
with <code>L(t0) = 0</code></h2><span id='topic+Lambda_exp_form'></span>

<h3>Description</h3>

<p>Definite integral of <code>l = exp(alpha + beta*t)</code> starting at
<code>t0</code> &ndash; only for <code style="white-space: pre;">&#8288;l+&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lambda_exp_form(t, alpha, beta, t0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lambda_exp_form_+3A_t">t</code></td>
<td>
<p>(double) the time point</p>
</td></tr>
<tr><td><code id="Lambda_exp_form_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept</p>
</td></tr>
<tr><td><code id="Lambda_exp_form_+3A_beta">beta</code></td>
<td>
<p>(double) the slope</p>
</td></tr>
<tr><td><code id="Lambda_exp_form_+3A_t0">t0</code></td>
<td>
<p>(double) the starting time</p>
</td></tr>
</table>

<hr>
<h2 id='Lambda_inv_exp_form'>Inverse of the definite integral of <code>l = exp(alpha + beta*t)</code> at time <code>t</code></h2><span id='topic+Lambda_inv_exp_form'></span>

<h3>Description</h3>

<p>Inverse of the definite integral of <code>l = exp(alpha + beta*t)</code> only for <code style="white-space: pre;">&#8288;l+&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lambda_inv_exp_form(z, alpha, beta, t0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lambda_inv_exp_form_+3A_z">z</code></td>
<td>
<p>(double) the value of integrated rate for which you want to find the time</p>
</td></tr>
<tr><td><code id="Lambda_inv_exp_form_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept</p>
</td></tr>
<tr><td><code id="Lambda_inv_exp_form_+3A_beta">beta</code></td>
<td>
<p>(double) the slope</p>
</td></tr>
<tr><td><code id="Lambda_inv_exp_form_+3A_t0">t0</code></td>
<td>
<p>(double) the starting time</p>
</td></tr>
</table>

<hr>
<h2 id='Lambda_inv_linear_form'>Inverse of the definite integral of <code>l = alpha + beta*t</code> at time <code>t</code></h2><span id='topic+Lambda_inv_linear_form'></span>

<h3>Description</h3>

<p>Inverse of the definite integral of <code>l = alpha + beta*t</code> only for <code style="white-space: pre;">&#8288;l+&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lambda_inv_linear_form(z, alpha, beta, t0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lambda_inv_linear_form_+3A_z">z</code></td>
<td>
<p>(double) the value of integrated rate for which you want to find the time</p>
</td></tr>
<tr><td><code id="Lambda_inv_linear_form_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept</p>
</td></tr>
<tr><td><code id="Lambda_inv_linear_form_+3A_beta">beta</code></td>
<td>
<p>(double) the slope</p>
</td></tr>
<tr><td><code id="Lambda_inv_linear_form_+3A_t0">t0</code></td>
<td>
<p>(double) the starting time</p>
</td></tr>
</table>

<hr>
<h2 id='Lambda_linear_form'>Definite integral of <code>l = alpha + beta*t</code> at time <code>t</code>
with <code>L(t0) = 0</code></h2><span id='topic+Lambda_linear_form'></span>

<h3>Description</h3>

<p>Definite integral of <code>l = alpha + beta*t</code> starting at
<code>t0</code> &ndash; only for <code style="white-space: pre;">&#8288;l+&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lambda_linear_form(t, alpha, beta, t0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lambda_linear_form_+3A_t">t</code></td>
<td>
<p>(double) the time point</p>
</td></tr>
<tr><td><code id="Lambda_linear_form_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept</p>
</td></tr>
<tr><td><code id="Lambda_linear_form_+3A_beta">beta</code></td>
<td>
<p>(double) the slope</p>
</td></tr>
<tr><td><code id="Lambda_linear_form_+3A_t0">t0</code></td>
<td>
<p>(double) the starting time</p>
</td></tr>
</table>

<hr>
<h2 id='mat_cumsum_columns'>Return matrix with column-wise cumulative sum
No checks for arguments is done.</h2><span id='topic+mat_cumsum_columns'></span>

<h3>Description</h3>

<p>Return matrix with column-wise cumulative sum
No checks for arguments is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_cumsum_columns(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_cumsum_columns_+3A_x">X</code></td>
<td>
<p>(matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='mat_cumsum_columns_with_scalar_ceiling'>Return matrix with column-wise cumulative sum
replacing cells larger than <code>ceil</code> with <code>NA</code>.
No checks for arguments is done.</h2><span id='topic+mat_cumsum_columns_with_scalar_ceiling'></span>

<h3>Description</h3>

<p>Return matrix with column-wise cumulative sum
replacing cells larger than <code>ceil</code> with <code>NA</code>.
No checks for arguments is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_cumsum_columns_with_scalar_ceiling(X, ceil = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_cumsum_columns_with_scalar_ceiling_+3A_x">X</code></td>
<td>
<p>(matrix)</p>
</td></tr>
<tr><td><code id="mat_cumsum_columns_with_scalar_ceiling_+3A_ceil">ceil</code></td>
<td>
<p>(double or Inf) the ceiling to be applied</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='mat_cumsum_columns_with_vector_ceiling'>Return matrix with column-wise cumulative sum
replacing cells larger than <code>ceil</code> with <code>NA</code>.
No checks for arguments is done.</h2><span id='topic+mat_cumsum_columns_with_vector_ceiling'></span>

<h3>Description</h3>

<p>Return matrix with column-wise cumulative sum
replacing cells larger than <code>ceil</code> with <code>NA</code>.
No checks for arguments is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_cumsum_columns_with_vector_ceiling(X, ceil = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_cumsum_columns_with_vector_ceiling_+3A_x">X</code></td>
<td>
<p>(matrix)</p>
</td></tr>
<tr><td><code id="mat_cumsum_columns_with_vector_ceiling_+3A_ceil">ceil</code></td>
<td>
<p>(vector or Inf) the set of ceilings to be applied, per row of <code>X</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='ppp_n'>Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max]</h2><span id='topic+ppp_n'></span>

<h3>Description</h3>

<p>Simulate specific number of points from a homogeneous Poisson Point Process over (t_min, t_max]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppp_n(size, range_t = c(0, 10), rng_stream = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppp_n_+3A_size">size</code></td>
<td>
<p>(int) the number of points to be simulated</p>
</td></tr>
<tr><td><code id="ppp_n_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ppp_n_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times of size <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ppp_n(size = 10, range_t = c(0, 10))
</code></pre>

<hr>
<h2 id='ppp_next_n'>Simulate n events from a homogeneous Poisson Point Process.</h2><span id='topic+ppp_next_n'></span>

<h3>Description</h3>

<p>Simulate n events from a homogeneous Poisson Point Process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppp_next_n(n = 1, rate = 1, t_min = 0, rng_stream = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppp_next_n_+3A_n">n</code></td>
<td>
<p>scalar number of samples</p>
</td></tr>
<tr><td><code id="ppp_next_n_+3A_rate">rate</code></td>
<td>
<p>scalar instantaneous rate</p>
</td></tr>
<tr><td><code id="ppp_next_n_+3A_t_min">t_min</code></td>
<td>
<p>scalar for the starting time value</p>
</td></tr>
<tr><td><code id="ppp_next_n_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with event times t (starting from t_min)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ppp_next_n(n = 10, rate = 1, t_min = 0)
</code></pre>

<hr>
<h2 id='ppp_orderstat'>Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method)</h2><span id='topic+ppp_orderstat'></span>

<h3>Description</h3>

<p>Simulate a homogeneous Poisson Point Process over (t_min, t_max] (order statistics method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppp_orderstat(range_t = c(0, 10), rate = 1, rng_stream = NULL, atmost1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppp_orderstat_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ppp_orderstat_+3A_rate">rate</code></td>
<td>
<p>(scalar, double) constant instantaneous rate</p>
</td></tr>
<tr><td><code id="ppp_orderstat_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
<tr><td><code id="ppp_orderstat_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times t
if no events realize, it will have 0 length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ppp_orderstat(range_t = c(0, 10), rate = 1)
</code></pre>

<hr>
<h2 id='ppp_sequential'>Simulate a homogeneous Poisson Point Process over (t_min, t_max]</h2><span id='topic+ppp_sequential'></span>

<h3>Description</h3>

<p>Simulate a homogeneous Poisson Point Process over (t_min, t_max]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppp_sequential(
  range_t = c(0, 10),
  rate = 1,
  tol = 10^-6,
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppp_sequential_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ppp_sequential_+3A_rate">rate</code></td>
<td>
<p>(scalar, double) constant instantaneous rate</p>
</td></tr>
<tr><td><code id="ppp_sequential_+3A_tol">tol</code></td>
<td>
<p>the probability that we will have more than
the drawn events in (t_min, t_max]</p>
</td></tr>
<tr><td><code id="ppp_sequential_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
<tr><td><code id="ppp_sequential_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times t
if no events realize, it will have 0 length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ppp_sequential(range_t = c(0, 10), rate = 1, tol = 10^-6)
</code></pre>

<hr>
<h2 id='read_code'>Read code from text file as string</h2><span id='topic+read_code'></span>

<h3>Description</h3>

<p>Read code from text file as string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_code(codeFile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_code_+3A_codefile">codeFile</code></td>
<td>
<p>Path to file</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>codeFile</code> contents as a character string
</p>

<hr>
<h2 id='rng_stream_rexp'>Exponential random samples from <code>rstream</code> objects</h2><span id='topic+rng_stream_rexp'></span>

<h3>Description</h3>

<p>Sample from <code>rstream</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng_stream_rexp(size = 1, rate = 1, rng_stream = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng_stream_rexp_+3A_size">size</code></td>
<td>
<p>Integer, number of samples</p>
</td></tr>
<tr><td><code id="rng_stream_rexp_+3A_rate">rate</code></td>
<td>
<p>Positive number, the rate (i.e., 1/mean)</p>
</td></tr>
<tr><td><code id="rng_stream_rexp_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of exponential variates of size <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rng_stream_rexp(10)
</code></pre>

<hr>
<h2 id='rng_stream_rpois'>Poisson random samples from <code>rstream</code> objects</h2><span id='topic+rng_stream_rpois'></span>

<h3>Description</h3>

<p>Sample from <code>rstream</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng_stream_rpois(size = 1, lambda = 1, rng_stream = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng_stream_rpois_+3A_size">size</code></td>
<td>
<p>Integer, number of samples</p>
</td></tr>
<tr><td><code id="rng_stream_rpois_+3A_lambda">lambda</code></td>
<td>
<p>Positive number, the mean</p>
</td></tr>
<tr><td><code id="rng_stream_rpois_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of counts of size <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rng_stream_rpois(10)
</code></pre>

<hr>
<h2 id='rng_stream_runif'>Uniform random samples from <code>rstream</code> objects</h2><span id='topic+rng_stream_runif'></span>

<h3>Description</h3>

<p>Sample from <code>rstream</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng_stream_runif(size = 1, minimum = 0, maximum = 1, rng_stream = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng_stream_runif_+3A_size">size</code></td>
<td>
<p>Integer, number of samples</p>
</td></tr>
<tr><td><code id="rng_stream_runif_+3A_minimum">minimum</code></td>
<td>
<p>Lower bound</p>
</td></tr>
<tr><td><code id="rng_stream_runif_+3A_maximum">maximum</code></td>
<td>
<p>Upper bound</p>
</td></tr>
<tr><td><code id="rng_stream_runif_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of uniform variates of size <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rng_stream_runif(10)
</code></pre>

<hr>
<h2 id='rng_stream_rztpois'>Zero-truncated Poisson random samples from <code>rstream</code> objects</h2><span id='topic+rng_stream_rztpois'></span>

<h3>Description</h3>

<p>Sample from <code>rstream</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng_stream_rztpois(size = 1, lambda = 1, rng_stream = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng_stream_rztpois_+3A_size">size</code></td>
<td>
<p>Integer, number of samples</p>
</td></tr>
<tr><td><code id="rng_stream_rztpois_+3A_lambda">lambda</code></td>
<td>
<p>Positive number, the mean of the original
(untruncated) Poisson distribution</p>
</td></tr>
<tr><td><code id="rng_stream_rztpois_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of non zero counts of size <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rng_stream_rztpois(10)
</code></pre>

<hr>
<h2 id='simpson_num_integr'>Simpson's method to integrate a univariate function.</h2><span id='topic+simpson_num_integr'></span>

<h3>Description</h3>

<p>Simpson's method to integrate a univariate continuous function.
Faster that R's <code>integrate()</code> and precise enough, but does not do any checks.
The error is at most <code style="white-space: pre;">&#8288;M (b-a)^5/(180 n^4)&#8288;</code> where <code>M</code> is the maximum of
the fourth derivative of the integrand in the interval <code style="white-space: pre;">&#8288;[a, b]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpson_num_integr(f, a, b, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpson_num_integr_+3A_f">f</code></td>
<td>
<p>function that takes a single argument</p>
</td></tr>
<tr><td><code id="simpson_num_integr_+3A_a">a</code></td>
<td>
<p>the lower limit of integration</p>
</td></tr>
<tr><td><code id="simpson_num_integr_+3A_b">b</code></td>
<td>
<p>the upper limit of integration</p>
</td></tr>
<tr><td><code id="simpson_num_integr_+3A_n">n</code></td>
<td>
<p>integer, number of integration points with a and b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the integration value
examples
#expect 1
simpson_num_integr(sin, 0, pi/2, 100)
#max error for simpson_num_integr(sin, 0, pi/2, 100) is 5.312842e-10
1 * (pi/2 - 0)^5/(180 * 100^4)
</p>

<hr>
<h2 id='vdraw_sc_step_regular'>Vectorized sampling from NHPPPs with piecewise constant intensities
with same interval lengths</h2><span id='topic+vdraw_sc_step_regular'></span>

<h3>Description</h3>

<p>Simulate a piecewise constant-rate Poisson Point Process over <code style="white-space: pre;">&#8288;(t_min, t_max]&#8288;</code> (inversion method)
where the intervals have the same length (are &quot;regular&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdraw_sc_step_regular(
  Lambda_matrix = NULL,
  lambda_matrix = NULL,
  range_t = c(0, 10),
  tol = 10^-6,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdraw_sc_step_regular_+3A_lambda_matrix">Lambda_matrix</code></td>
<td>
<p>(matrix) integrated intensity rates at the end of each interval</p>
</td></tr>
<tr><td><code id="vdraw_sc_step_regular_+3A_lambda_matrix">lambda_matrix</code></td>
<td>
<p>(matrix) intensity rates, one per interval</p>
</td></tr>
<tr><td><code id="vdraw_sc_step_regular_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) <code>t_min</code> and <code>t_max</code></p>
</td></tr>
<tr><td><code id="vdraw_sc_step_regular_+3A_tol">tol</code></td>
<td>
<p>(scalar, double) tolerance for the number of events</p>
</td></tr>
<tr><td><code id="vdraw_sc_step_regular_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times t
if no events realize, it will have 0 length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- vdraw_sc_step_regular(Lambda_matrix = matrix(1:5, nrow = 1))
</code></pre>

<hr>
<h2 id='ztdraw_cumulative_intensity'>Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from
(t_min, t_max) (order statistics method)</h2><span id='topic+ztdraw_cumulative_intensity'></span>

<h3>Description</h3>

<p>Sample zero-truncated NHPPP times using the order statistics method,
optionally using an <code>rstream</code> generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztdraw_cumulative_intensity(
  Lambda,
  Lambda_inv = NULL,
  range_t = c(0, 10),
  range_L = c(Lambda(range_t[1]), Lambda(range_t[2])),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztdraw_cumulative_intensity_+3A_lambda">Lambda</code></td>
<td>
<p>(function, double vector) a continuous increasing R to R map
which is the integrated rate of the NHPPP</p>
</td></tr>
<tr><td><code id="ztdraw_cumulative_intensity_+3A_lambda_inv">Lambda_inv</code></td>
<td>
<p>(function, double vector) the inverse of <code>Lambda()</code></p>
</td></tr>
<tr><td><code id="ztdraw_cumulative_intensity_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ztdraw_cumulative_intensity_+3A_range_l">range_L</code></td>
<td>
<p>(vector, double) min and max of the transformed time interval</p>
</td></tr>
<tr><td><code id="ztdraw_cumulative_intensity_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ztdraw_cumulative_intensity_+3A_atmost1">atmost1</code></td>
<td>
<p>(boolean) draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of at least 1 event times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ztdraw_cumulative_intensity(Lambda = function(t) t + cos(t) - 1)
</code></pre>

<hr>
<h2 id='ztdraw_intensity'>Simulate <code>size</code> samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from
(t0, t_max) (thinning method)</h2><span id='topic+ztdraw_intensity'></span>

<h3>Description</h3>

<p>Sample zero-truncated NHPPP intensity times using the thinning method, optionally using
an <code>rstream</code> generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztdraw_intensity(
  lambda,
  lambda_maj = NULL,
  exp_maj = FALSE,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztdraw_intensity_+3A_lambda">lambda</code></td>
<td>
<p>(function) the instantaneous rate of the NHPPP.
A continuous function of time.</p>
</td></tr>
<tr><td><code id="ztdraw_intensity_+3A_lambda_maj">lambda_maj</code></td>
<td>
<p>(double, vector) the intercept and optional slope of the majorizing
linear (if <code>exp_maj = FALSE</code>) or log-linear (if <code>exp_maj = TRUE</code>) function in <code>range_t</code>.</p>
</td></tr>
<tr><td><code id="ztdraw_intensity_+3A_exp_maj">exp_maj</code></td>
<td>
<p>(boolean) if <code>TRUE</code> the majorizer is <code>exp(alpha + beta * t)</code></p>
</td></tr>
<tr><td><code id="ztdraw_intensity_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval.</p>
</td></tr>
<tr><td><code id="ztdraw_intensity_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
<tr><td><code id="ztdraw_intensity_+3A_atmost1">atmost1</code></td>
<td>
<p>(boolean) draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of at least 1 event times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ztdraw_intensity(lambda = function(t) 1 + sin(t))
</code></pre>

<hr>
<h2 id='ztdraw_intensity_step'>Simulate from a zero-truncated non homogeneous Poisson Point Process (NHPPP) from
(t0, t_max) (thinning method) with piecewise constant_majorizer</h2><span id='topic+ztdraw_intensity_step'></span>

<h3>Description</h3>

<p>Sample zero-truncated NHPPP times using the thinning method, optionally using
an <code>rstream</code> generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztdraw_intensity_step(
  lambda,
  lambda_maj_vector = lambda(1:10),
  times_vector = 0:10,
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztdraw_intensity_step_+3A_lambda">lambda</code></td>
<td>
<p>(function) the instantaneous rate of the NHPPP.
A continuous function of time.</p>
</td></tr>
<tr><td><code id="ztdraw_intensity_step_+3A_lambda_maj_vector">lambda_maj_vector</code></td>
<td>
<p>(scalar, double) <code>K</code> constant majorizing rates, one per interval</p>
</td></tr>
<tr><td><code id="ztdraw_intensity_step_+3A_times_vector">times_vector</code></td>
<td>
<p>(vector, double) <code>K+1</code> time points defining <code>K</code> intervals
of constant rates:
<code style="white-space: pre;">&#8288;[t_1 = range_t[1],       t_2)&#8288;</code>: the first interval
<code style="white-space: pre;">&#8288;[t_k,                t_{k+1})&#8288;</code>: the <code>k</code>-th interval
<code style="white-space: pre;">&#8288;[t_{K}, t_{K+1} = range_t[2])&#8288;</code>: the <code>K</code>-th (last) interval</p>
</td></tr>
<tr><td><code id="ztdraw_intensity_step_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object or <code>NULL</code></p>
</td></tr>
<tr><td><code id="ztdraw_intensity_step_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times (t_) with at least one element
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ztdraw_intensity_step(lambda = function(t) exp(.02 * t))
</code></pre>

<hr>
<h2 id='ztdraw_sc_linear'>Simulate <code>size</code> samples from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from
(t_min, t_max) with linear intensity function</h2><span id='topic+ztdraw_sc_linear'></span>

<h3>Description</h3>

<p>Sample zero-truncated NHPPP times from a linear intensity function
using the inversion method, optionally using an <code>rstream</code>
generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztdraw_sc_linear(
  alpha = 1,
  beta = 0,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztdraw_sc_linear_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept</p>
</td></tr>
<tr><td><code id="ztdraw_sc_linear_+3A_beta">beta</code></td>
<td>
<p>(double) the slope</p>
</td></tr>
<tr><td><code id="ztdraw_sc_linear_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ztdraw_sc_linear_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object</p>
</td></tr>
<tr><td><code id="ztdraw_sc_linear_+3A_atmost1">atmost1</code></td>
<td>
<p>(boolean) draw 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of at least 1 event times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ztdraw_sc_linear(alpha = 0, beta = 0.2)

</code></pre>

<hr>
<h2 id='ztdraw_sc_loglinear'>Simulate from a zero-truncated non homogeneous Poisson Point Process (zt-NHPPP) from
(t_min, t_max) with a log-linear intensity function (inversion method)</h2><span id='topic+ztdraw_sc_loglinear'></span>

<h3>Description</h3>

<p>Sample zt-NHPPP times from an log-linear intensity function
using the inversion method, optionally using an <code>rstream</code>
generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztdraw_sc_loglinear(
  alpha = 1,
  beta = 0,
  range_t = c(0, 10),
  rng_stream = NULL,
  atmost1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztdraw_sc_loglinear_+3A_alpha">alpha</code></td>
<td>
<p>(double) the intercept in the exponent</p>
</td></tr>
<tr><td><code id="ztdraw_sc_loglinear_+3A_beta">beta</code></td>
<td>
<p>(double) the slope in the exponent</p>
</td></tr>
<tr><td><code id="ztdraw_sc_loglinear_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ztdraw_sc_loglinear_+3A_rng_stream">rng_stream</code></td>
<td>
<p>(<code>rstream</code>) an <code>rstream</code> object.</p>
</td></tr>
<tr><td><code id="ztdraw_sc_loglinear_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of at least 1 event times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ztdraw_sc_loglinear(alpha = 0, beta = 0.2)

</code></pre>

<hr>
<h2 id='ztppp'>Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max]</h2><span id='topic+ztppp'></span>

<h3>Description</h3>

<p>Simulate a zero-truncated homogeneous Poisson Point Process over (t_min, t_max]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ztppp(range_t = c(0, 10), rate = 1, rng_stream = NULL, atmost1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ztppp_+3A_range_t">range_t</code></td>
<td>
<p>(vector, double) min and max of the time interval</p>
</td></tr>
<tr><td><code id="ztppp_+3A_rate">rate</code></td>
<td>
<p>(scalar, double) constant instantaneous rate</p>
</td></tr>
<tr><td><code id="ztppp_+3A_rng_stream">rng_stream</code></td>
<td>
<p>an <code>rstream</code> object</p>
</td></tr>
<tr><td><code id="ztppp_+3A_atmost1">atmost1</code></td>
<td>
<p>boolean, draw at most 1 event time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of event times of size <code>size</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ztppp(range_t = c(0, 10), rate = 0.001)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
