<!DOCTYPE html><html><head><title>Help for package coalitions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coalitions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#as_survey'><p>Creates basic survey table from votes in percent</p></a></li>
<li><a href='#calculate_prob'><p>Calculate coalition probability from majority table</p></a></li>
<li><a href='#calculate_probs'><p>Calculate coalition probabilities for multiple coalitions</p></a></li>
<li><a href='#collapse_parties'><p>Transform surveys in long format</p></a></li>
<li><a href='#dHondt'><p>Seat Distribution by D'Hondt</p></a></li>
<li><a href='#draw_from_posterior'><p>Draw random numbers from posterior distribution</p></a></li>
<li><a href='#effective_samplesize'><p>Calculate the effective sample size</p></a></li>
<li><a href='#extract_num'><p>Extract numerics from string or character</p></a></li>
<li><a href='#filter_superior'><p>Remove rows from table for which superior coalitions are possible</p></a></li>
<li><a href='#get_eligible'><p>Extract surveys from institutes within a specified time-window</p></a></li>
<li><a href='#get_entryprobability'><p>Get probabilities to enter the parliament.</p></a></li>
<li><a href='#get_meta'><p>Extract &quot;meta&quot; information from survey data base</p></a></li>
<li><a href='#get_n'><p>Total number of survey participants from surveys eligible for pooling.</p></a></li>
<li><a href='#get_pooled'><p>Extract effective sample size for pooled sample</p></a></li>
<li><a href='#get_probabilities'><p>Wrapper for calculation of coalition probabilities from survey</p></a></li>
<li><a href='#get_seats'><p>Calculate seat distribution from draws from posterior</p></a></li>
<li><a href='#get_superior'><p>Extract superior coalitions from coalition string or vector</p></a></li>
<li><a href='#get_surveys'><p>Scrape surveys from all pollsters</p></a></li>
<li><a href='#gg_survey'><p>Plot voter shares observed in one survey</p></a></li>
<li><a href='#hare_niemeyer'><p>Seat Distribution by Hare/Niemeyer</p></a></li>
<li><a href='#has_majority'><p>Does a coalition have a majority</p></a></li>
<li><a href='#have_majority'><p>Do coalitions have a majority</p></a></li>
<li><a href='#party_colors_de'><p>Colors for German parties</p></a></li>
<li><a href='#party_labels_de'><p>Labels for German parties</p></a></li>
<li><a href='#paste_coalitions'><p>Transform list of coalitions to vector by combining party names</p></a></li>
<li><a href='#pool_austria'><p>Pool surveys from different pollsters</p></a></li>
<li><a href='#pool_surveys'><p>Obtain pooled survey during specified period</p></a></li>
<li><a href='#prettify_strings'><p>Replace/prettify matching words/terms in one vector by another</p></a></li>
<li><a href='#redistribute'><p>Calculate percentage of votes/seats after excluding parties with</p>
<code>votes &lt; hurdle</code></a></li>
<li><a href='#sanitize_colnames'><p>Sanitize column names</p></a></li>
<li><a href='#sanitize_strings'><p>Sanitize character vector</p></a></li>
<li><a href='#scrape_austria'><p>Import Austrian survey results</p></a></li>
<li><a href='#scrape_wahlrecht'><p>Scrape surveys for German general election</p></a></li>
<li><a href='#sls'><p>Seat Distribution by Sainte-Lague/Schepers</p></a></li>
<li><a href='#surveys_sample'><p>Sample of selected surveys</p></a></li>
<li><a href='#try_readHTML'><p>Try call of read_html that throws an error if the url cannot be resolved</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian "Now-Cast" Estimation of Event Probabilities in
Multi-Party Democracies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.24</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Bender &lt;bender.at.R@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of a Bayesian framework for the opinion poll
    based estimation of event probabilities in multi-party electoral systems
    (Bender and Bauer (2018) &lt;<a href="https://doi.org/10.21105%2Fjoss.00606">doi:10.21105/joss.00606</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, gtools, rvest, xml2, jsonlite, RCurl, rlang,
magrittr, lubridate, stringr, tidyr (&ge; 1.0.0), purrr (&gt;
0.2.2), dplyr (&gt; 0.5.0), ggplot2, tibble (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr,</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://adibender.github.io/coalitions/">https://adibender.github.io/coalitions/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adibender/coalitions/issues">https://github.com/adibender/coalitions/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-17 12:17:16 UTC; ab</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Bender <a href="https://orcid.org/0000-0001-5628-8611"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alexander Bauer <a href="https://orcid.org/0000-0003-3495-5131"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rebekka Schade [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-17 13:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='as_survey'>Creates basic survey table from votes in percent</h2><span id='topic+as_survey'></span>

<h3>Description</h3>

<p>This functions takes votes in percent (per party) obtained from a survey,
and returns a table containing votes (in percent) and party names. Conducts
sanity checks along the way, such as checking that percentages add up to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_survey(
  percent,
  samplesize,
  parties = c("cdu", "spd", "gruene", "fdp", "linke", "piraten", "afd", "fw",
    "sonstige"),
  epsilon = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_survey_+3A_percent">percent</code></td>
<td>
<p>Votes in percent each party received in the survey
of interest. Can be set to <code>NA</code>, if parties are specified that are not
mentioned in the specific survey (otherwise the <code>parties</code> argument has
to be modified).</p>
</td></tr>
<tr><td><code id="as_survey_+3A_samplesize">samplesize</code></td>
<td>
<p>Number of respondents in survey.</p>
</td></tr>
<tr><td><code id="as_survey_+3A_parties">parties</code></td>
<td>
<p>Vector of same length and in the same order as <code>percent</code></p>
</td></tr>
<tr><td><code id="as_survey_+3A_epsilon">epsilon</code></td>
<td>
<p>The parameter <code>percent</code> should add up to one.
This parameter controls the maximal numerical divergence allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing input and absolute number of votes
in survey per party.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+redistribute">redistribute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>forsa &lt;- as_survey(
 percent    = c(0.41, 0.24, 0.13, 0.04, 0.08, 0.03, 0.03, 0.04),
 samplesize = 2508,
 parties    = c("cdu/csu", "spd", "gruene", "fdp", "linke", "piraten", "afd", "others"))
forsa
</code></pre>

<hr>
<h2 id='calculate_prob'>Calculate coalition probability from majority table</h2><span id='topic+calculate_prob'></span>

<h3>Description</h3>

<p>Given a table with simulations in the rows and coalitions in the columns,
this function returns the coalition probabilities for a specified coalition,
by default excluding superior coalitions first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_prob(majority_df, coalition, exclude_superior = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_prob_+3A_majority_df">majority_df</code></td>
<td>
<p>A data frame containing logical values indicating
if the coalitions (columns) have a majority (rows).</p>
</td></tr>
<tr><td><code id="calculate_prob_+3A_coalition">coalition</code></td>
<td>
<p>The coalition of interest for which superior coalitions
will be obtained by <code><a href="#topic+get_superior">get_superior</a></code>.</p>
</td></tr>
<tr><td><code id="calculate_prob_+3A_exclude_superior">exclude_superior</code></td>
<td>
<p>Logical. If <code>TRUE</code>, superior coalitions will
be excluded, otherwise total coalition probabilities will be returned.
Usually it makes sense to exclude superior coalitions.</p>
</td></tr>
<tr><td><code id="calculate_prob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+get_superior">get_superior</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>test_df &lt;- data.frame(
 cdu            = c(rep(FALSE, 9), TRUE),
 cdu_fdp        = c(rep(FALSE, 8), TRUE, TRUE),
 cdu_fdp_greens = c(TRUE, TRUE, rep(FALSE, 6), TRUE, TRUE))
calculate_prob(test_df, "cdu_fdp_greens") # exclude_superior defaults to TRUE
calculate_prob(test_df, "cdu_fdp_greens", exclude_superior=FALSE)
</code></pre>

<hr>
<h2 id='calculate_probs'>Calculate coalition probabilities for multiple coalitions</h2><span id='topic+calculate_probs'></span>

<h3>Description</h3>

<p>Given a table with simulations in the rows and coalitions in the columns,
this function returns the coalition probabilities for a specified coalition,
by default excluding superior coalitions first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_probs(majority_df, coalitions, exclude_superior = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_probs_+3A_majority_df">majority_df</code></td>
<td>
<p>A data frame containing logical values indicating
if the coalitions (columns) have a majority (rows).</p>
</td></tr>
<tr><td><code id="calculate_probs_+3A_coalitions">coalitions</code></td>
<td>
<p>A list of coalitions for which coalition probabilities should
be calculated. Each list entry must be a vector of party names. Those names
need to correspond to the names in <code>majority_df</code>.</p>
</td></tr>
<tr><td><code id="calculate_probs_+3A_exclude_superior">exclude_superior</code></td>
<td>
<p>Logical. If <code>TRUE</code>, superior coalitions will
be excluded, otherwise total coalition probabilities will be returned.
Usually it makes sense to exclude superior coalitions.</p>
</td></tr>
<tr><td><code id="calculate_probs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+get_superior">get_superior</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_prob">calculate_prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_df &lt;- data.frame(
 cdu            = c(rep(FALSE, 9), TRUE),
 cdu_fdp        = c(rep(FALSE, 8), TRUE, TRUE),
 cdu_fdp_greens = c(TRUE, TRUE, rep(FALSE, 6), TRUE, TRUE))
calculate_probs(test_df, list("cdu", "cdu_fdp", "cdu_fdp_greens"))
calculate_probs(test_df, list("cdu", "cdu_fdp", "cdu_fdp_greens"), exclude_superior=FALSE)
</code></pre>

<hr>
<h2 id='collapse_parties'>Transform surveys in long format</h2><span id='topic+collapse_parties'></span>

<h3>Description</h3>

<p>Given a data frame containing multiple surveys (one row per survey), transforms
the data into long format with one row per party.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_parties(
  surveys,
  parties = c("cdu", "spd", "greens", "fdp", "left", "pirates", "fw", "afd", "others")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_parties_+3A_surveys">surveys</code></td>
<td>
<p>A data frame with one survey per row.</p>
</td></tr>
<tr><td><code id="collapse_parties_+3A_parties">parties</code></td>
<td>
<p>A character vector containing names of parties to collapse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame in long format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
emnid &lt;- scrape_wahlrecht()
emnid.long &lt;- collapse_parties(emnid)

## End(Not run)
</code></pre>

<hr>
<h2 id='dHondt'>Seat Distribution by D'Hondt</h2><span id='topic+dHondt'></span>

<h3>Description</h3>

<p>Calculates number of seats for the respective parties according to the
method of d'Hondt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHondt(votes, parties, n_seats = 183)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dHondt_+3A_votes">votes</code></td>
<td>
<p>Number of votes per party.</p>
</td></tr>
<tr><td><code id="dHondt_+3A_parties">parties</code></td>
<td>
<p>Names of parties (must be same length as votes).</p>
</td></tr>
<tr><td><code id="dHondt_+3A_n_seats">n_seats</code></td>
<td>
<p>Number of seats in parliament. Defaults to 183 (seats in
Austrian parliament).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the seats of all parties after
redistribution via D'Hondt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sls">sls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample) %&gt;% tidyr::unnest("survey")
# calculate the seat distribution based on D'Hondt for a parliament with 300 seats
dHondt(surveys$votes, surveys$party, n_seats = 300)
</code></pre>

<hr>
<h2 id='draw_from_posterior'>Draw random numbers from posterior distribution</h2><span id='topic+draw_from_posterior'></span>

<h3>Description</h3>

<p>Draw random numbers from posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_from_posterior(
  survey,
  nsim = 10000,
  seed = as.numeric(now()),
  prior = NULL,
  correction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_from_posterior_+3A_survey">survey</code></td>
<td>
<p>survey object as returned by <code>as_survey</code> or <code>getSurveys</code></p>
</td></tr>
<tr><td><code id="draw_from_posterior_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="draw_from_posterior_+3A_seed">seed</code></td>
<td>
<p>sets seed</p>
</td></tr>
<tr><td><code id="draw_from_posterior_+3A_prior">prior</code></td>
<td>
<p>optional prior information. Defaults to 1/2 (Jeffrey's prior).</p>
</td></tr>
<tr><td><code id="draw_from_posterior_+3A_correction">correction</code></td>
<td>
<p>A positive number. If not <code>NULL</code>, each sample from the
Dirichlet distribution will be additionally &quot;corrected&quot; by a random number
from U(-1*correction, 1*correction). This can be used to introduce extra
variation which might be useful due to rounding errors from reported survey
results (or add an additional source of variation in general).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing random draws from Dirichlet distribution
which can be interpreted as election results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_survey">as_survey</a></code>
</p>

<hr>
<h2 id='effective_samplesize'>Calculate the effective sample size</h2><span id='topic+effective_samplesize'></span>

<h3>Description</h3>

<p>This is the work horse function that calculates the effective sample size.
Should usually not be called by the user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective_samplesize(size, share, corr = 0.5, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effective_samplesize_+3A_size">size</code></td>
<td>
<p>A vector of sample sizes from different surveys (from different
pollsters) for one party.</p>
</td></tr>
<tr><td><code id="effective_samplesize_+3A_share">share</code></td>
<td>
<p>The relative share of votes for party of interest ([0-1])</p>
</td></tr>
<tr><td><code id="effective_samplesize_+3A_corr">corr</code></td>
<td>
<p>Assumed correlation between surveys (of different pollsters).
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="effective_samplesize_+3A_weights">weights</code></td>
<td>
<p>Additional weights for individual surveys.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_num'>Extract numerics from string or character</h2><span id='topic+extract_num'></span>

<h3>Description</h3>

<p>Removes all characters that are not in [0-9].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_num(x, decimal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_num_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="extract_num_+3A_decimal">decimal</code></td>
<td>
<p>Logical flag, indicating if x has a decimal separator</p>
</td></tr>
</table>

<hr>
<h2 id='filter_superior'>Remove rows from table for which superior coalitions are possible</h2><span id='topic+filter_superior'></span>

<h3>Description</h3>

<p>Given a table with simulations in the rows and coalitions in the columns,
this function returns the coalition probabilities for a specified coalition,
by default excluding superior coalitions first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_superior(majority_df, coalition, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_superior_+3A_majority_df">majority_df</code></td>
<td>
<p>A data frame containing logical values indicating
if the coalitions (columns) have a majority (rows).</p>
</td></tr>
<tr><td><code id="filter_superior_+3A_coalition">coalition</code></td>
<td>
<p>The coalition of interest for which superior coalitions
will be obtained by <code><a href="#topic+get_superior">get_superior</a></code>.</p>
</td></tr>
<tr><td><code id="filter_superior_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+get_superior">get_superior</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_superior">get_superior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_df &lt;- data.frame(
 cdu            = c(rep(FALSE, 9), TRUE),
 cdu_fdp        = c(rep(FALSE, 8), TRUE, TRUE),
 cdu_fdp_greens = c(TRUE, TRUE, rep(FALSE, 6), TRUE, TRUE))
calculate_prob(test_df, "cdu_fdp_greens") # exclude_superior defaults to TRUE
calculate_prob(test_df, "cdu_fdp_greens", exclude_superior=FALSE)
</code></pre>

<hr>
<h2 id='get_eligible'>Extract surveys from institutes within a specified time-window</h2><span id='topic+get_eligible'></span>

<h3>Description</h3>

<p>Extract surveys from institutes within a specified time-window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eligible(
  surveys,
  pollsters,
  last_date = Sys.Date(),
  period = 14,
  period_extended = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eligible_+3A_surveys">surveys</code></td>
<td>
<p>A <code>tibble</code> containing survey results for multiple
pollsters as returned by <code><a href="#topic+get_surveys">get_surveys</a></code>.</p>
</td></tr>
<tr><td><code id="get_eligible_+3A_pollsters">pollsters</code></td>
<td>
<p>Character vector of pollsters that should be considered
for pooling.</p>
</td></tr>
<tr><td><code id="get_eligible_+3A_last_date">last_date</code></td>
<td>
<p>Only surveys in the time-window from <code>last_date</code> to
<code>last_date</code> - period will be considered for each pollster. Defaults
to current date.</p>
</td></tr>
<tr><td><code id="get_eligible_+3A_period">period</code></td>
<td>
<p>See <code>last_date</code> argument.</p>
</td></tr>
<tr><td><code id="get_eligible_+3A_period_extended">period_extended</code></td>
<td>
<p>Optional. If specified, all surveys in the time-window
from <code>last_date</code> - period_extended to <code>last_date</code> - period will
also be considered for each pollster, but only after down-weighting them by
halving their true sample size.</p>
</td></tr>
</table>

<hr>
<h2 id='get_entryprobability'>Get probabilities to enter the parliament.</h2><span id='topic+get_entryprobability'></span>

<h3>Description</h3>

<p>Get probabilities to enter the parliament.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_entryprobability(dirichlet.draws, hurdle = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_entryprobability_+3A_dirichlet.draws">dirichlet.draws</code></td>
<td>
<p>Matrix or data frame containing draws from
the posterior (see <code><a href="#topic+draw_from_posterior">draw_from_posterior</a></code>).</p>
</td></tr>
<tr><td><code id="get_entryprobability_+3A_hurdle">hurdle</code></td>
<td>
<p>The percentage threshold which has to be reached by a party
to enter the parliament. Any party called &quot;ssw&quot; will be exempt from the hurdle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of (named) entry probabilities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_from_posterior">draw_from_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample)
# use 100 simulations for a fast runtime
surveys &lt;- surveys %&gt;% mutate(draws = purrr::map(survey, draw_from_posterior, nsim = 100),
                              entryProbs = purrr::map(draws, get_entryprobability))
surveys$entryProbs
</code></pre>

<hr>
<h2 id='get_meta'>Extract &quot;meta&quot; information from survey data base</h2><span id='topic+get_meta'></span>

<h3>Description</h3>

<p>Extract &quot;meta&quot; information from survey data base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meta(surveys_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_meta_+3A_surveys_df">surveys_df</code></td>
<td>
<p>A data frame containing surveys from different survey
institutes as returned by <code><a href="#topic+get_surveys">get_surveys</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_n'>Total number of survey participants from surveys eligible for pooling.</h2><span id='topic+get_n'></span>

<h3>Description</h3>

<p>Total number of survey participants from surveys eligible for pooling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_n(eligible_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_n_+3A_eligible_df">eligible_df</code></td>
<td>
<p>A data frame containing surveys that should be used for
pooling as returned by <code>get_eligible</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_pooled'>Extract effective sample size for pooled sample</h2><span id='topic+get_pooled'></span>

<h3>Description</h3>

<p>Given a specified time window (defaults to current day - 14 days).
calculate the effective sample size of the pooled sample over multiple
pollsters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pooled(
  surveys,
  last_date = Sys.Date(),
  pollsters = c("allensbach", "emnid", "forsa", "fgw", "gms", "infratest", "dimap",
    "infratestdimap", "insa"),
  period = 14,
  period_extended = NA,
  corr = 0.5,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pooled_+3A_surveys">surveys</code></td>
<td>
<p>A <code>tibble</code> containing survey results for multiple
pollsters as returned by <code><a href="#topic+get_surveys">get_surveys</a></code>.</p>
</td></tr>
<tr><td><code id="get_pooled_+3A_last_date">last_date</code></td>
<td>
<p>Only surveys in the time-window from <code>last_date</code> to
<code>last_date</code> - period will be considered for each pollster. Defaults
to current date.</p>
</td></tr>
<tr><td><code id="get_pooled_+3A_pollsters">pollsters</code></td>
<td>
<p>Character vector of pollsters that should be considered
for pooling.</p>
</td></tr>
<tr><td><code id="get_pooled_+3A_period">period</code></td>
<td>
<p>See <code>last_date</code> argument.</p>
</td></tr>
<tr><td><code id="get_pooled_+3A_period_extended">period_extended</code></td>
<td>
<p>Optional. If specified, all surveys in the time-window
from <code>last_date</code> - period_extended to <code>last_date</code> - period will
also be considered for each pollster, but only after down-weighting them by
halving their true sample size.</p>
</td></tr>
<tr><td><code id="get_pooled_+3A_corr">corr</code></td>
<td>
<p>Assumed correlation between surveys (of different pollsters).
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="get_pooled_+3A_weights">weights</code></td>
<td>
<p>Additional weights for individual surveys.</p>
</td></tr>
</table>

<hr>
<h2 id='get_probabilities'>Wrapper for calculation of coalition probabilities from survey</h2><span id='topic+get_probabilities'></span>

<h3>Description</h3>

<p>Given a table with simulations in the rows and coalitions in the columns,
this function returns the coalition probabilities for a specified coalition,
by default excluding superior coalitions first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_probabilities(
  x,
  coalitions = list(c("cdu"), c("cdu", "fdp"), c("cdu", "fdp", "greens"), c("spd"),
    c("spd", "left"), c("spd", "left", "greens")),
  nsim = 1e+05,
  distrib.fun = sls,
  seats_majority = 300L,
  seed = as.numeric(now()),
  correction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_probabilities_+3A_x">x</code></td>
<td>
<p>A table containing one row per survey and survey information in
long format in a separate column named <code>survey</code>.</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_coalitions">coalitions</code></td>
<td>
<p>A list of coalitions for which coalition probabilities should
be calculated. Each list entry must be a vector of party names. Those names
need to correspond to the names in <code>majority_df</code>.</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_distrib.fun">distrib.fun</code></td>
<td>
<p>Function to calculate seat distribution. Defaults to
<code><a href="#topic+sls">sls</a></code> (Sainte-Lague/Schepers).</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_seats_majority">seats_majority</code></td>
<td>
<p>The number of seats needed to obtain majority.</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_seed">seed</code></td>
<td>
<p>sets seed</p>
</td></tr>
<tr><td><code id="get_probabilities_+3A_correction">correction</code></td>
<td>
<p>A positive number. If not <code>NULL</code>, each sample from the
Dirichlet distribution will be additionally &quot;corrected&quot; by a random number
from U(-1*correction, 1*correction). This can be used to introduce extra
variation which might be useful due to rounding errors from reported survey
results (or add an additional source of variation in general).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_prob">calculate_prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample)
# calculate probabilities for two coalitions
probs &lt;- get_probabilities(surveys,
                           coalitions = list(c("cdu", "fdp"),
                                             c("spd", "left", "greens")),
                           nsim = 100) # ensure fast runtime with only 100 simulations
probs %&gt;% tidyr::unnest("probabilities")
</code></pre>

<hr>
<h2 id='get_seats'>Calculate seat distribution from draws from posterior</h2><span id='topic+get_seats'></span>

<h3>Description</h3>

<p>Calculate seat distribution from draws from posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_seats(
  dirichlet.draws,
  survey,
  distrib.fun = sls,
  samplesize = NULL,
  hurdle = 0.05,
  others = "others",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_seats_+3A_dirichlet.draws">dirichlet.draws</code></td>
<td>
<p>Matrix containing random draws from posterior.</p>
</td></tr>
<tr><td><code id="get_seats_+3A_survey">survey</code></td>
<td>
<p>The actual survey results on which <code>dirichlet.draws</code>
were based on.</p>
</td></tr>
<tr><td><code id="get_seats_+3A_distrib.fun">distrib.fun</code></td>
<td>
<p>Function to calculate seat distribution. Defaults to
<code><a href="#topic+sls">sls</a></code> (Sainte-Lague/Schepers).</p>
</td></tr>
<tr><td><code id="get_seats_+3A_samplesize">samplesize</code></td>
<td>
<p>Number of individuals participating in the <code>survey</code>.</p>
</td></tr>
<tr><td><code id="get_seats_+3A_hurdle">hurdle</code></td>
<td>
<p>The percentage threshold which has to be reached by a party
to enter the parliament. Any party called &quot;ssw&quot; will be exempt from the hurdle.</p>
</td></tr>
<tr><td><code id="get_seats_+3A_others">others</code></td>
<td>
<p>A string indicating the name under which parties not listed
explicitly are subsumed.</p>
</td></tr>
<tr><td><code id="get_seats_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>distrib.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing seat distributions for each simulation in
<code>dirichlet.draws</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_from_posterior">draw_from_posterior</a></code>, <code><a href="#topic+sls">sls</a></code>,
<code><a href="#topic+dHondt">dHondt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample)
# simulate 100 seat distributions
surveys &lt;- surveys %&gt;% mutate(draws = purrr::map(survey, draw_from_posterior, nsim = 100),
                              seats = purrr::map2(draws, survey, get_seats))
surveys$seats
</code></pre>

<hr>
<h2 id='get_superior'>Extract superior coalitions from coalition string or vector</h2><span id='topic+get_superior'></span>

<h3>Description</h3>

<p>Extract superior coalitions from coalition string or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_superior(string, pattern = "_", collapse = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_superior_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for (regular expression).</p>
</td></tr>
<tr><td><code id="get_superior_+3A_collapse">collapse</code></td>
<td>
<p>string that will be used to concatenate multiple elements
obtained by splitting <code>string</code> to one string.</p>
</td></tr>
<tr><td><code id="get_superior_+3A_stirng">stirng</code></td>
<td>
<p>A character.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>stringr str_split
</p>

<hr>
<h2 id='get_surveys'>Scrape surveys from all pollsters</h2><span id='topic+get_surveys'></span><span id='topic+get_surveys_by'></span><span id='topic+get_surveys_rp'></span><span id='topic+get_surveys_nds'></span><span id='topic+get_surveys_saxony'></span><span id='topic+get_surveys_brb'></span><span id='topic+get_surveys_thuringen'></span><span id='topic+get_latest'></span>

<h3>Description</h3>

<p>Given a specific date, extract the survey from this date or the last one
before this date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_surveys(country = c("DE", "AT"))

get_surveys_by()

get_surveys_rp()

get_surveys_nds()

get_surveys_saxony()

get_surveys_brb()

get_surveys_thuringen()

get_latest(surveys = NULL, max_date = Sys.Date())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_surveys_+3A_country">country</code></td>
<td>
<p>Choose country from which surveys should be scraped.
Currently <code>"DE"</code> (Germany) and <code>"AT"</code> (Austria) are supported.</p>
</td></tr>
<tr><td><code id="get_surveys_+3A_surveys">surveys</code></td>
<td>
<p>If provided, latest survey will be obtained from this object,
otherwise calls <code><a href="#topic+get_surveys">get_surveys</a></code>.</p>
</td></tr>
<tr><td><code id="get_surveys_+3A_max_date">max_date</code></td>
<td>
<p>Specifies the date, relative to which latest survey will
be searched for. Defaults to <code>Sys.Date</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested tibble. When fully unnested, the dataset contains the following
columns:
</p>

<dl>
<dt>pollster</dt><dd><p>Character name of the polling institute.</p>
</dd>
<dt>date</dt><dd><p>Publication date of the poll.</p>
</dd>
<dt>start, end</dt><dd><p>Start and end date of the field period, i.e. the dates
during which the poll was conducted.</p>
</dd>
<dt>respondents</dt><dd><p>Number of respondents in the poll.</p>
</dd>
<dt>party</dt><dd><p>Character name of an individual party.</p>
</dd>
<dt>percent</dt><dd><p>Percentage of respondents that chose the party. Given in
percentage points, i.e. <code>38%</code> is given as <code>38</code>.</p>
</dd>
<dt>votes</dt><dd><p>Number of respondents that chose the party.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(coalitions)
# scrape data for the German federal election
# get_surveys()

## End(Not run)
library(coalitions)
### Scrape the newest poll for the German federal election
# Possibility 1: Calling get_latest without arguments scrapes surveys from the web
# Possibility 2: Use get_latest() on an already scraped dataset
surveys &lt;- get_latest(surveys_sample)
</code></pre>

<hr>
<h2 id='gg_survey'>Plot voter shares observed in one survey</h2><span id='topic+gg_survey'></span>

<h3>Description</h3>

<p>Bar chart of the raw voter shares observed in one survey.
Additionally to plotting positive voter shares,
the function can be used to plot party-specific differences (e.g. between
a survey and the election result), including negative numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_survey(data, colors = NULL, labels = NULL, annotate_bars = TRUE, hurdle = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_survey_+3A_data">data</code></td>
<td>
<p>Scraped dataset containing one row per party in the column
<code>party</code> and the observed voter share in the column <code>percent</code></p>
</td></tr>
<tr><td><code id="gg_survey_+3A_colors">colors</code></td>
<td>
<p>Named vector containing party colors. If <code>NULL</code>
(default) tries to guess color based on party names, gray otherwise.</p>
</td></tr>
<tr><td><code id="gg_survey_+3A_labels">labels</code></td>
<td>
<p>Named vector containing party labels. If <code>NULL</code> (default)
tries to guess party names from <code>data</code>.</p>
</td></tr>
<tr><td><code id="gg_survey_+3A_annotate_bars">annotate_bars</code></td>
<td>
<p>If <code>TRUE</code> (default) bars are annotated by the
respective vote share (percentage).</p>
</td></tr>
<tr><td><code id="gg_survey_+3A_hurdle">hurdle</code></td>
<td>
<p>Hurdle for single parties to get into the parliament, e.g. '5'
for '5%'. If set to NULL no horizontal line is plotted.
The horizontal line can be suppressed using <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyr)
library(dplyr)
library(coalitions)

survey &lt;- surveys_sample$surveys[[1]]$survey[[1]]

gg_survey(survey)
</code></pre>

<hr>
<h2 id='hare_niemeyer'>Seat Distribution by Hare/Niemeyer</h2><span id='topic+hare_niemeyer'></span>

<h3>Description</h3>

<p>Calculates number of seats for the respective parties that have received more
than <code>hurdle</code> percent of votes (according to the method of Hare/Niemeyer)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hare_niemeyer(votes, parties, n_seats = 183)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hare_niemeyer_+3A_votes">votes</code></td>
<td>
<p>Number of votes per party.</p>
</td></tr>
<tr><td><code id="hare_niemeyer_+3A_parties">parties</code></td>
<td>
<p>Names of parties (must be same length as votes).</p>
</td></tr>
<tr><td><code id="hare_niemeyer_+3A_n_seats">n_seats</code></td>
<td>
<p>Number of seats in parliament. Defaults to 183 (seats in
Austrian parliament).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing parties above the hurdle and the respective
seats/percentages after redistribution via Hare/Niemeyer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sls">sls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample) %&gt;% tidyr::unnest("survey")
# calculate the seat distribution based on Hare/Niemeyer for a parliament with 300 seats
hare_niemeyer(surveys$votes, surveys$party, n_seats = 300)
</code></pre>

<hr>
<h2 id='has_majority'>Does a coalition have a majority</h2><span id='topic+has_majority'></span>

<h3>Description</h3>

<p>Does a coalition have a majority
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_majority(seats_tab, coalition, seats_majority = 300L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_majority_+3A_seats_tab">seats_tab</code></td>
<td>
<p>A table containing information on how many seats each party
obtained.</p>
</td></tr>
<tr><td><code id="has_majority_+3A_coalition">coalition</code></td>
<td>
<p>The coalition of interest for which superior coalitions
will be obtained by <code><a href="#topic+get_superior">get_superior</a></code>.</p>
</td></tr>
<tr><td><code id="has_majority_+3A_seats_majority">seats_majority</code></td>
<td>
<p>The number of seats needed to obtain majority.</p>
</td></tr>
</table>

<hr>
<h2 id='have_majority'>Do coalitions have a majority</h2><span id='topic+have_majority'></span>

<h3>Description</h3>

<p>Do coalitions have a majority
</p>


<h3>Usage</h3>

<pre><code class='language-R'>have_majority(
  seats_tab,
  coalitions = list(c("cdu"), c("cdu", "fdp"), c("cdu", "fdp", "greens"), c("spd"),
    c("spd", "left"), c("spd", "left", "greens")),
  seats_majority = 300L,
  collapse = "_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="have_majority_+3A_seats_tab">seats_tab</code></td>
<td>
<p>A data frame containing number of seats obtained by a party.
Must have columns <code>party</code> and <code>seats</code>.</p>
</td></tr>
<tr><td><code id="have_majority_+3A_coalitions">coalitions</code></td>
<td>
<p>A list of coalitions for which coalition probabilities should
be calculated. Each list entry must be a vector of party names. Those names
need to correspond to the names in <code>majority_df</code>.</p>
</td></tr>
<tr><td><code id="have_majority_+3A_seats_majority">seats_majority</code></td>
<td>
<p>The number of seats needed to obtain majority.</p>
</td></tr>
<tr><td><code id="have_majority_+3A_collapse">collapse</code></td>
<td>
<p>Character string passed to <code>base::paste</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
library(purrr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample)
# check for majorities of two coalitions
coals &lt;- list(c("cdu", "fdp"),
              c("spd", "left", "greens"))
# only use 100 simulations for a fast runtime
surveys &lt;- surveys %&gt;% mutate(draws = map(survey, draw_from_posterior, nsim = 100),
                              seats = map2(draws, survey, get_seats),
                              majorities = map(seats, have_majority, coalitions = coals))
surveys$majorities
</code></pre>

<hr>
<h2 id='party_colors_de'>Colors for German parties</h2><span id='topic+party_colors_de'></span>

<h3>Description</h3>

<p>A vector of colors associated with German parties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>party_colors_de
</code></pre>


<h3>Format</h3>

<p>A named character vector. Names indicate parties. Values contain
color strings for the respective parties
</p>

<hr>
<h2 id='party_labels_de'>Labels for German parties</h2><span id='topic+party_labels_de'></span>

<h3>Description</h3>

<p>A vector of labels associated with German parties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>party_labels_de
</code></pre>


<h3>Format</h3>

<p>A named character vector. Names indicate parties. Values contain
party names suitable for plot labels.
</p>

<hr>
<h2 id='paste_coalitions'>Transform list of coalitions to vector by combining party names</h2><span id='topic+paste_coalitions'></span>

<h3>Description</h3>

<p>Transform list of coalitions to vector by combining party names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_coalitions(coalitions, collapse = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_coalitions_+3A_coalitions">coalitions</code></td>
<td>
<p>A list of coalitions for which coalition probabilities should
be calculated. Each list entry must be a vector of party names. Those names
need to correspond to the names in <code>majority_df</code>.</p>
</td></tr>
<tr><td><code id="paste_coalitions_+3A_collapse">collapse</code></td>
<td>
<p>Character string passed to <code>base::paste</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pool_austria'>Pool surveys from different pollsters</h2><span id='topic+pool_austria'></span>

<h3>Description</h3>

<p>Per default, pools surveys starting from current date and going 14 days back.
For each pollster within the defined time-frame, only the most recent survey
is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_austria(
  ...,
  pollsters = c("Market", "Research Affairs", "Unique Research", "OGM", "IMAS",
    "Hajek", "Gallup", "Karmasin")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_austria_+3A_pollsters">pollsters</code></td>
<td>
<p>Character vector of pollsters that should be considered
for pooling.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>pool_surveys
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
latest &lt;- get_latest(surveys_sample)
pool_surveys(surveys_sample, last_date=as.Date("2017-09-02"))
</code></pre>

<hr>
<h2 id='pool_surveys'>Obtain pooled survey during specified period</h2><span id='topic+pool_surveys'></span>

<h3>Description</h3>

<p>Per default, pools surveys starting from current date and going 14 days back.
For each pollster within the defined time-frame, only the most recent survey
is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_surveys(
  surveys,
  last_date = Sys.Date(),
  pollsters = c("allensbach", "emnid", "forsa", "fgw", "gms", "infratest", "dimap",
    "infratestdimap", "insa"),
  period = 14,
  period_extended = NA,
  corr = 0.5,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_surveys_+3A_surveys">surveys</code></td>
<td>
<p>A <code>tibble</code> containing survey results for multiple
pollsters as returned by <code><a href="#topic+get_surveys">get_surveys</a></code>.</p>
</td></tr>
<tr><td><code id="pool_surveys_+3A_last_date">last_date</code></td>
<td>
<p>Only surveys in the time-window from <code>last_date</code> to
<code>last_date</code> - period will be considered for each pollster. Defaults
to current date.</p>
</td></tr>
<tr><td><code id="pool_surveys_+3A_pollsters">pollsters</code></td>
<td>
<p>Character vector of pollsters that should be considered
for pooling.</p>
</td></tr>
<tr><td><code id="pool_surveys_+3A_period">period</code></td>
<td>
<p>See <code>last_date</code> argument.</p>
</td></tr>
<tr><td><code id="pool_surveys_+3A_period_extended">period_extended</code></td>
<td>
<p>Optional. If specified, all surveys in the time-window
from <code>last_date</code> - period_extended to <code>last_date</code> - period will
also be considered for each pollster, but only after down-weighting them by
halving their true sample size.</p>
</td></tr>
<tr><td><code id="pool_surveys_+3A_corr">corr</code></td>
<td>
<p>Assumed correlation between surveys (of different pollsters).
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="pool_surveys_+3A_weights">weights</code></td>
<td>
<p>Additional weights for individual surveys.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
latest &lt;- get_latest(surveys_sample)
pool_surveys(surveys_sample, last_date=as.Date("2017-09-02"))
</code></pre>

<hr>
<h2 id='prettify_strings'>Replace/prettify matching words/terms in one vector by another</h2><span id='topic+prettify_strings'></span><span id='topic+prettify_de'></span><span id='topic+prettify_en'></span>

<h3>Description</h3>

<p>The function searches for <code>x</code> values, that occur in <code>current</code>
and replaces them with entries in <code>new</code>. Useful for quick
renaming/translation of survey column names and by using internal object
<code>.trans_df</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettify_strings(
  x,
  current = .trans_df$english,
  new = .trans_df$english_pretty
)

prettify_de(x)

prettify_en(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettify_strings_+3A_x">x</code></td>
<td>
<p>A character vector (or factor) that should be renamed.</p>
</td></tr>
<tr><td><code id="prettify_strings_+3A_current">current</code></td>
<td>
<p>A vector of characters (possibly subset of <code>x</code>).
Entries in <code>x</code> that match entries in <code>current</code> will be renamed
according to entries in <code>new</code>.</p>
</td></tr>
<tr><td><code id="prettify_strings_+3A_new">new</code></td>
<td>
<p>A vector of characters that will replace entries in <code>x</code> which
have matches in <code>current</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# look at sample German federal election polls
surveys &lt;- surveys_sample %&gt;% tidyr::unnest("surveys") %&gt;% group_by(pollster) %&gt;% slice(1)
# prettify the polling agency names
prettify_strings(surveys$pollster)
prettify_en(surveys$pollster)
prettify_de(surveys$pollster)
</code></pre>

<hr>
<h2 id='redistribute'>Calculate percentage of votes/seats after excluding parties with
<code>votes &lt; hurdle</code></h2><span id='topic+redistribute'></span>

<h3>Description</h3>

<p>Calculate percentage of votes/seats after excluding parties with
<code>votes &lt; hurdle</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redistribute(survey, hurdle = 0.05, others = "others", epsilon = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redistribute_+3A_survey">survey</code></td>
<td>
<p>The actual survey results on which <code>dirichlet.draws</code>
were based on.</p>
</td></tr>
<tr><td><code id="redistribute_+3A_hurdle">hurdle</code></td>
<td>
<p>The percentage threshold which has to be reached by a party
to enter the parliament. Any party called &quot;ssw&quot; will be exempt from the hurdle.</p>
</td></tr>
<tr><td><code id="redistribute_+3A_others">others</code></td>
<td>
<p>A string indicating the name under which parties not listed
explicitly are subsumed.</p>
</td></tr>
<tr><td><code id="redistribute_+3A_epsilon">epsilon</code></td>
<td>
<p>Percentages should add up to 1. If they do not, within accuracy
of <code>epsilon</code>, an error is thrown.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_seats">get_seats</a></code>, <code><a href="#topic+sls">sls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample)
# redistribute the shares of 'others' parties and parties with a share of under 5\%
surveys &lt;- surveys %&gt;% mutate(survey_redist = purrr::map(survey, redistribute))
surveys$survey # results before redistribution
surveys$survey_redist # results after redistribution
</code></pre>

<hr>
<h2 id='sanitize_colnames'>Sanitize column names</h2><span id='topic+sanitize_colnames'></span>

<h3>Description</h3>

<p>Sanitize column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_colnames(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_colnames_+3A_df">df</code></td>
<td>
<p>A data frame with party names with special characters that need
to be sanitized.</p>
</td></tr>
</table>

<hr>
<h2 id='sanitize_strings'>Sanitize character vector</h2><span id='topic+sanitize_strings'></span>

<h3>Description</h3>

<p>Substitute all German &quot;Umlaute&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_strings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_strings_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='scrape_austria'>Import Austrian survey results</h2><span id='topic+scrape_austria'></span>

<h3>Description</h3>

<p>Reads JSON file from neuwal.com and performs some preprocessing to bring
data into standardized format. Returns a nested tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrape_austria(
  address = "https://neuwal.com/wahlumfragen/data/neuwal-wahlumfragen-user.json"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scrape_austria_+3A_address">address</code></td>
<td>
<p>URL of the JSON file.</p>
</td></tr>
</table>

<hr>
<h2 id='scrape_wahlrecht'>Scrape surveys for German general election</h2><span id='topic+scrape_wahlrecht'></span><span id='topic+scrape_by'></span><span id='topic+scrape_rp'></span><span id='topic+scrape_ltw'></span>

<h3>Description</h3>

<p>Scrapes survey tables and performs sanitation to output tidy data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrape_wahlrecht(
  address = "https://www.wahlrecht.de/umfragen/emnid.htm",
  parties = c("CDU", "SPD", "GRUENE", "FDP", "LINKE", "PIRATEN", "FW", "AFD",
    "SONSTIGE")
)

scrape_by(
  address = "https://www.wahlrecht.de/umfragen/landtage/bayern.htm",
  parties = c("CSU", "SPD", "GRUENE", "FDP", "LINKE", "PIRATEN", "FW", "AFD",
    "SONSTIGE")
)

scrape_rp(
  address = "https://www.wahlrecht.de/umfragen/landtage/rheinland-pfalz.htm",
  parties = c("CDU", "SPD", "GRUENE", "FDP", "LINKE", "AFD", "FW", "SONSTIGE"),
  ind_row_remove = -c(1:3)
)

scrape_ltw(
  address = "https://www.wahlrecht.de/umfragen/landtage/niedersachsen.htm",
  parties = c("CDU", "SPD", "GRUENE", "FDP", "LINKE", "PIRATEN", "FW", "AFD",
    "SONSTIGE"),
  ind_row_remove = -c(1:2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scrape_wahlrecht_+3A_address">address</code></td>
<td>
<p>http-address from which tables should be scraped.</p>
</td></tr>
<tr><td><code id="scrape_wahlrecht_+3A_parties">parties</code></td>
<td>
<p>A character vector containing names of parties to collapse.</p>
</td></tr>
<tr><td><code id="scrape_wahlrecht_+3A_ind_row_remove">ind_row_remove</code></td>
<td>
<p>Negative vector of rows that will be skipped at the beginning.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(coalitions)
library(dplyr)
# select a polling agency from .pollster_df that should be scraped ...
coalitions:::.pollster_df
# ... here we choose Forsa
address &lt;- coalitions:::.pollster_df %&gt;% filter(pollster == "forsa") %&gt;% pull(address)
scrape_wahlrecht(address = address) %&gt;% slice(1:5)

## End(Not run)
## Not run: 
# Niedersachsen
scrape_ltw() %&gt;% slice(1:5)
# Hessen
scrape_ltw("https://www.wahlrecht.de/umfragen/landtage/hessen.htm", ind_row_remove=-c(1)) %&gt;%
 slice(1:5)

## End(Not run)
</code></pre>

<hr>
<h2 id='sls'>Seat Distribution by Sainte-Lague/Schepers</h2><span id='topic+sls'></span>

<h3>Description</h3>

<p>Calculates number of seats for the respective parties that have received more
than 5% of votes (according to the method of Sainte-Lague/Schepers,
see https://www.wahlrecht.de/verfahren/rangmasszahlen.html).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sls(votes, parties, n_seats = 598L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sls_+3A_votes">votes</code></td>
<td>
<p>A numeric vector giving the redistributes votes</p>
</td></tr>
<tr><td><code id="sls_+3A_parties">parties</code></td>
<td>
<p>A character vector indicating the names of parties with
respective <code>votes</code>.</p>
</td></tr>
<tr><td><code id="sls_+3A_n_seats">n_seats</code></td>
<td>
<p>The total number of seats that can be assigned to the different
parties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the number of seats each party obtained.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dHondt">dHondt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coalitions)
library(dplyr)
# get the latest survey for a sample of German federal election polls
surveys &lt;- get_latest(surveys_sample) %&gt;% tidyr::unnest("survey")
# calculate the seat distribution based on Sainte-Lague/Schepers for a parliament with 300 seats
sls(surveys$votes, surveys$party, n_seats = 300)
</code></pre>

<hr>
<h2 id='surveys_sample'>Sample of selected surveys</h2><span id='topic+surveys_sample'></span>

<h3>Description</h3>

<p>A data set with surveys from seven different pollsters, three surveys per
pollster. Surveys report support for different parties in the running
for the German Bundestag prior to the 2017 election.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surveys_sample
</code></pre>


<h3>Format</h3>

<p>A nested data frame with 7 rows and 2 columns:
</p>

<dl>
<dt>institute</dt><dd><p>name of the pollster</p>
</dd>
<dt>surveys</dt><dd><p>a list of data frames, each containing one survey</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.wahlrecht.de/">https://www.wahlrecht.de/</a>
</p>

<hr>
<h2 id='try_readHTML'>Try call of read_html that throws an error if the url cannot be resolved</h2><span id='topic+try_readHTML'></span>

<h3>Description</h3>

<p>Try call of read_html that throws an error if the url cannot be resolved
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_readHTML(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_readHTML_+3A_url">url</code></td>
<td>
<p>http-address that should be scraped.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
