<!DOCTYPE html><html><head><title>Help for package rexpokit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rexpokit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rexpokit-package'><p>Matrix exponentiation with EXPOKIT in R</p></a></li>
<li><a href='#coo2mat'><p>Convert a COO-formated matrix to standard square format</p></a></li>
<li><a href='#expm'><p>Simple Interface</p></a></li>
<li><a href='#expokit_dgexpv_Qmat'><p>EXPOKIT dgexpv matrix exponentiation on Q matrix</p></a></li>
<li><a href='#expokit_dgpadm_Qmat'><p>EXPOKIT dgpadm matrix exponentiation on Q matrix</p></a></li>
<li><a href='#expokit_dmexpv_Qmat'><p>EXPOKIT dmexpv matrix exponentiation on Q matrix</p></a></li>
<li><a href='#expokit_itscale5_wrapper'><p>wrapper function for FORTRAN itscale5, for FD's maxent</p></a></li>
<li><a href='#expokit_wrapalldgexpv_tvals'><p>Run EXPOKIT's dgexpv on one or more t-values</p></a></li>
<li><a href='#expokit_wrapalldmexpv_tvals'><p>Run EXPOKIT's dmexpv on one or more t-values</p></a></li>
<li><a href='#mat2coo'><p>Convert matrix to COO format using SparseM function</p></a></li>
<li><a href='#mat2coo_forloop'><p>Convert matrix to COO format using nested for-loops</p></a></li>
<li><a href='#maxent'>
<p>Estimating Probabilities via Maximum Entropy: Improved Iterative Scaling</p></a></li>
<li><a href='#SparseM_coo_to_REXPOKIT_coo'><p>Convert a SparseM COO matrix to a plain matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Wrappers for EXPOKIT; Other Matrix Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.26.6.14</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas J. Matzke [aut, cre, cph],
  Roger B. Sidje [aut, cph],
  Drew Schmidt [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas J. Matzke &lt;nickmatzke.ncse@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See /inst/LAPACK_LICENSE.txt for code in /src.</td>
</tr>
<tr>
<td>Description:</td>
<td>Wraps some of the matrix exponentiation 
        utilities from EXPOKIT (<a href="http://www.maths.uq.edu.au/expokit/">http://www.maths.uq.edu.au/expokit/</a>), 
        a FORTRAN library that is widely recommended for matrix 
        exponentiation (Sidje RB, 1998. "Expokit: A Software Package
        for Computing Matrix Exponentials." ACM Trans. Math. Softw.
        24(1): 130-156).  EXPOKIT includes functions for 
        exponentiating both small, dense matrices, and large, sparse
        matrices (in sparse matrices, most of the cells have value 0).
        Rapid matrix exponentiation is useful in phylogenetics when we 
        have a large number of states (as we do when we are inferring 
        the history of transitions between the possible geographic 
        ranges of a species), but is probably useful in other ways as 
        well. NOTE: In case FORTRAN checks temporarily get rexpokit 
        archived on CRAN, see archived binaries at GitHub in: 
        nmatzke/Matzke_R_binaries (binaries install without compilation 
        of source code).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://phylo.wikidot.com/rexpokit">http://phylo.wikidot.com/rexpokit</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 22:53:42 UTC; nmat471</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-22 09:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='rexpokit-package'>Matrix exponentiation with EXPOKIT in R</h2><span id='topic+rexpokit'></span><span id='topic+rexpokit-package'></span>

<h3>Description</h3>

<p>Matrix exponentiation with EXPOKIT in R
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> rexpokit</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;">
  Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 0.26.6.13</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;">
  2023-10-31
  </td>
</tr>

</table>

<p>This package wraps some of the matrix exponentiation
utilities from EXPOKIT
(<a href="http://www.maths.uq.edu.au/expokit/">http://www.maths.uq.edu.au/expokit/</a>), a FORTRAN
library that is widely recommended for fast matrix
exponentiation (Sidje RB, 1998. &quot;Expokit: A Software
Package for Computing Matrix Exponentials.&quot; <em>ACM
Trans. Math. Softw.</em> 24(1): 130-156).
</p>
<p>The FORTRAN package was developed by Roger B. Sidje, see
<a href="http://www.maths.uq.edu.au/expokit/">http://www.maths.uq.edu.au/expokit/</a>. Nicholas J.
Matzke adapted the package for use with R and wrote the R
interface. Permission to distribute the EXPOKIT source
under GPL was obtained from Roger B. Sidje.
</p>
<p>EXPOKIT includes functions for exponentiating both small,
dense matrices, and large, sparse matrices (in sparse
matrices, most of the cells have value 0).  Rapid matrix
exponentiation is useful in phylogenetics when we have a
large number of states (as we do when we are inferring
the history of transitions between the possible
geographic ranges of a species), but is probably useful
in other ways as well.
</p>
<p><b>Help</b>
</p>
<p>For help with rexpokit or BioGeoBEARS, see (1) the 
PhyloWiki websites for rexpokit and BioGeoBEARS 
(<a href="http://phylo.wikidot.com/rexpokit">http://phylo.wikidot.com/rexpokit</a>, 
<a href="http://phylo.wikidot.com/biogeobears">http://phylo.wikidot.com/biogeobears</a>) and 
(2) the BioGeoBEARS Google Group 
(<a href="https://groups.google.com/forum/#!forum/biogeobears">https://groups.google.com/forum/#!forum/biogeobears</a>). 
Minor updates may get posted first to the rexpokit 
GitHub repository (<a href="https://github.com/nmatzke/rexpokit">https://github.com/nmatzke/rexpokit</a>)
</p>
<p><b>Background</b>
</p>
<p>Various messages on discussion boards have asked whether
or not there is an R package that uses EXPOKIT.  There
are only two as of this writing (January 2013) &ndash;
<code>diversitree</code> and
<code>ctarma</code>. However, diversitree's usage is nested
deeply in a series of dynamic functions and integrated
with additional libraries (e.g. deSolve) and so is very
difficult to extract for general usage, and <code>ctarma</code>
implements only ZEXPM via <code>ctarma</code>::<code>zexpm</code>.
Niels Richard Hansen <a href="mailto:Niels.R.Hansen@math.ku.dk">Niels.R.Hansen@math.ku.dk</a> is
also working on an implementation of certain EXPOKIT
functions.
</p>
<p>(See the additional notes file in the package &quot;inst&quot;
directory, 
EXPOKIT_For_Dummies_notes_v1.txt for additional notes on
wrappers for EXPOKIT in Python etc.)
</p>
<p>As it turns out, the EXPOKIT documentation and code is
far from trivial to figure out, since the code as
published does not run &quot;out of the box&quot; &ndash; in particular,
the Q transition matrix (&quot;matvec&quot;), which is the major
input into an exponentiation algorithm, is not input
directly, but rather via another function, which requires
the user to put together some FORTRAN code to do this and
make a wrapper for the core function.  I couldn't figure
it out in a short amount of time, but Stephen Smith did
for his &quot;LAGRANGE&quot; biogeography package, so I copied and
modified this chunk of his code to get started. <br /> <br />
<b>Installation hints</b><br /> <br /> Installing
<code>rexpokit</code> from source will require a gfortran
compiler to convert the FORTRAN code files in /src (*.f)
to object files (*.o), and g++ to compile and link the
C++ wrapper. <code>rexpokit</code> was developed on an Intel
Mac running OS X 10.7.  I (NJM, 2013) successfully compiled it
using g++ and gfortran from (gcc version 4.2.1). (Update
2017-08-13: repeated with gccgfortran version 7.1.0.) <br />
</p>
<p><b>Citation</b>
</p>
<p>This code was developed for the following publications.
Please cite if used: 
</p>
<p>Matzke, Nicholas J. (2014). &quot;Model Selection in 
Historical Biogeography Reveals that Founder-event 
Speciation is a Crucial Process in Island Clades.&quot; 
<em>Systematic Biology</em>, 63(6), 951-970. 
<a href="https://doi.org/10.1093/sysbio/syu056">doi:10.1093/sysbio/syu056</a>
</p>
<p>Matzke, Nicholas J. (2013). &quot;Probabilistic historical 
biogeography: new models for founder-event speciation, 
imperfect detection, and fossils allow improved 
accuracy and model-testing.&quot; <em>Frontiers of 
Biogeography</em>, 5(4), 242-248. 
<a href="https://escholarship.org/uc/item/44j7n141">https://escholarship.org/uc/item/44j7n141</a>
</p>
<p>Matzke, Nicholas J. (2012).
&quot;Founder-event speciation in BioGeoBEARS package
dramatically improves likelihoods and alters parameter
inference in Dispersal-Extinction-Cladogenesis (DEC)
analyses.&quot; <em>Frontiers of Biogeography</em> 4(suppl. 1):
210.  Link to abstract and PDF of poster:
<a href="http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster">http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster</a>.
(Poster abstract published in the Conference Program and
Abstracts of the International Biogeography Society 6th
Biannual Meeting, Miami, Florida. Poster Session P10:
Historical and Paleo-Biogeography. Poster 129B. January
11, 2013.)
</p>
<p>Please also cite Sidje (1998). <br /> <br />
<b>Acknowledgements/sources</b><br /> <br /> <b>1.</b> Niels
Richard Hansen <a href="mailto:Niels.R.Hansen@math.ku.dk">Niels.R.Hansen@math.ku.dk</a> helped
greatly with the initial setup of the package.  See his
<code>expoRkit</code> for another R
implementation of EXPOKIT routines.<br /> <br /> <b>2.</b>
EXPOKIT, original FORTRAN package, by Roger B. Sidje
<a href="mailto:rbs@maths.uq.edu.au">rbs@maths.uq.edu.au</a>, Department of Mathematics,
University of Queensland, Brisbane, QLD-4072, Australia,
(c) 1996-2013 All Rights Reserved<br /> <br /> Sidje has given
permission to include EXPOKIT code in this R package
under the usual GPL license for CRAN R packages. For the
full EXPOKIT copyright and license, see
<code>expokit_copyright.txt</code> under
<code>inst/notes</code>. <br /> <br /> 
EXPOKIT was published by Sidje in: Sidje RB (1998).
&quot;Expokit. A Software Package for Computing Matrix
Exponentials.&quot; <em>ACM-Transactions on Mathematical
Software</em>, 24(1):130-156.
<a href="http://tinyurl.com/bwa87rq">http://tinyurl.com/bwa87rq</a><br /> <br /> 
</p>
<p><b>3.</b> Revisions
for version 0.26, which fixed many issues with 
warnings about obsolescence in F77 code, were
aided by email help/discussions with: Kurt Hornik, 
Doug Nychka, Marcello Chiodi, Meabh McCurdy.  Also,
thanks to these incredibly helpful websites: 
&quot;On-Line Fortran F77 - F90 Converter&quot; 
(www.fortran.uk/plusfortonline.php), 
&quot;Building and checking R source packages for Windows&quot; 
(<a href="https://win-builder.r-project.org/">https://win-builder.r-project.org/</a>), 
&quot;Modernizing Old Fortran&quot; 
(fortranwiki.org/fortran/show/Modernizing+Old+Fortran), 
&quot;Registering the C++ and FORTRAN calls&quot; 
(stat.ethz.ch/pipermail/r-devel/2017-February/073755.html)
<br /> <br />
</p>
<p><b>4.</b> A small
amount of C++ code wrapping EXPOKIT was modified from a
file in LAGRANGE, C++ version by Stephen Smith:<br />
<a href="https://code.google.com/archive/p/lagrange/">https://code.google.com/archive/p/lagrange/</a><br />
<a href="https://github.com/blackrim/lagrange">https://github.com/blackrim/lagrange</a><br /> <br />
Specifically:<br /> <br /> <code> * RateMatrix.cpp</code><br /> <code> *
  </code><br /> <code> * Created on: Aug 14, 2009</code><br /> <code> *
  Author: smitty</code><br /> <code> *</code><br /> <br /> ...and the my_*.f
wrappers for the EXPOKIT *.f code files.<br /> <br /> 
</p>
<p><b>5.</b> Also copied in part (to get the .h file) from:<br /> <br />
Python package &quot;Pyprop&quot;:<br />
<a href="https://code.google.com/archive/p/archive">https://code.google.com/archive/p/archive</a><br />
(old URL) pyprop.googlecode.com/svn/trunk/core/krylov/expokit/expokitpropagator.cpp<br />
(old URL) www.koders.com/python/fidCA95B5A4B2FB77455A72B8A361CF684FFE48F4DC.aspx?s=fourier+transform<br />
<br /> Specifically:<br />
pyprop/core/krylov/expokit/f2c/expokit.h <br /> <br />
<b>6.</b> The EXPOKIT FORTRAN package is available at:<br />
<a href="http://www.maths.uq.edu.au/expokit/">http://www.maths.uq.edu.au/expokit/</a><br /> <br />
Copyright:<br />
<a href="http://www.maths.uq.edu.au/expokit/copyright">http://www.maths.uq.edu.au/expokit/copyright</a><br />
...or...<br /> expokit_copyright.txt in this install 
(see package &quot;inst&quot; directory)<br />
</p>
<p><b>7.</b> EXPOKIT included some LAPACK and BLAS code for 
portability. This has been slightly modified to pass 
new CRAN checks and compilers. The original copyright is
at: /inst/LAPACK_LICENSE.txt<br />
<br />
</p>
<p><b>8.</b> itscale.f was copied from the R package &quot;FD&quot; in
order to avoid an unnecessary dependency
(and associated issues with compilation, 
updates, etc.). See R function &quot;maxent&quot; for more details,
citations for package &quot;FD&quot;:<br />
<br />
Laliberte, E., and P. Legendre (2010) A distance-based 
framework for measuring functional diversity from 
multiple traits. <em>Ecology</em> 91:299-305.<br />
<br />
Laliberte, E., Legendre, P., and B. Shipley. (2014). 
FD: measuring functional diversity from multiple traits, 
and other tools for functional ecology. R package 
version 1.0-12. <a href="https://CRAN.R-project.org/package=FD">https://CRAN.R-project.org/package=FD</a><br />
<br />
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a>, Roger B.
Sidje <a href="mailto:roger.b.sidje@ua.edu">roger.b.sidje@ua.edu</a>, Drew Schmidt
<a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>References</h3>

<p><a href="http://www.maths.uq.edu.au/expokit/">http://www.maths.uq.edu.au/expokit/</a> <br />
<a href="http://www.maths.uq.edu.au/expokit/copyright">http://www.maths.uq.edu.au/expokit/copyright</a>
</p>
<p>Matzke, Nicholas J. (2014). &quot;Model Selection in 
Historical Biogeography Reveals that Founder-event 
Speciation is a Crucial Process in Island Clades.&quot; 
<em>Systematic Biology</em>, 63(6), 951-970. 
<a href="https://doi.org/10.1093/sysbio/syu056">doi:10.1093/sysbio/syu056</a>
</p>
<p>Matzke, Nicholas J. (2013). &quot;Probabilistic historical 
biogeography: new models for founder-event speciation, 
imperfect detection, and fossils allow improved 
accuracy and model-testing.&quot; <em>Frontiers of 
Biogeography</em>, 5(4), 242-248. 
<a href="https://escholarship.org/uc/item/44j7n141">https://escholarship.org/uc/item/44j7n141</a>
</p>
<p>Matzke N (2012). &quot;Founder-event speciation in BioGeoBEARS
package dramatically improves likelihoods and alters
parameter inference in Dispersal-Extinction-Cladogenesis
(DEC) analyses.&quot; _Frontiers of Biogeography_, *4*(suppl.
1), pp. 210. ISSN 1948-6596, Poster abstract published in
the Conference Program and Abstracts of the International
Biogeography Society 6th Biannual Meeting, Miami,
Florida. Poster Session P10: Historical and
Paleo-Biogeography. Poster 129B. January 11, 2013, &lt;URL:
<a href="http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster">http://phylo.wikidot.com/matzke-2013-international-biogeography-society-poster</a>&gt;.
</p>
<p>Sidje RB (1998). &quot;Expokit. A Software Package for
Computing Matrix Exponentials.&quot; _ACM Trans. Math.
Softw._, *24*(1), pp. 130-156. &lt;URL:
http://dx.doi.org/10.1145/285861.285868&gt;, &lt;URL:
<a href="https://dl.acm.org/doi/10.1145/285861.285868">https://dl.acm.org/doi/10.1145/285861.285868</a>&gt;.
</p>
<p>Eddelbuettel D and Francois R (2011). &quot;Rcpp: Seamless R
and C++ Integration.&quot; _Journal of Statistical Software_,
*40*(8), pp. 1-18. ISSN 1548-7660, See also: &lt;URL:
http://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-introduction.pdf&gt;,
&lt;URL:
http://cran.r-project.org/web/packages/Rcpp/index.html&gt;.
, &lt;URL: <a href="https://www.jstatsoft.org/v40/i08">https://www.jstatsoft.org/v40/i08</a>&gt;.
</p>
<p>Moler C and Loan CV (2003). &quot;Nineteen dubious ways to
compute the exponential of a matrix, twenty-five years
later.&quot; _SIAM review_, *45*(1), pp. 3-49. doi: 10.1137/S00361445024180.
</p>
<p>Foster PG (2001). &quot;The Idiot's Guide to the Zen of
Likelihood in a Nutshell in Seven Days for Dummies,
Unleashed.&quot; Online PDF, widely copied, &lt;URL:
https://joelvelasco.net/teaching/129/foster01-idiotslikelihood.pdf&gt;.
</p>


<h3>See Also</h3>

<p><code>expoRkit</code>
<code><a href="#topic+expokit_wrapalldmexpv_tvals">expokit_wrapalldmexpv_tvals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example code
# For background and basic principles, see rexpokit/notes/EXPOKIT_For_Dummies_notes_v1.txt

library(rexpokit)

# Make a square instantaneous rate matrix (Q matrix)
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,
# Unleashed" at:
# https://joelvelasco.net/teaching/129/foster01-idiotslikelihood.pdf
#
# The Q matrix includes the stationary base freqencies, which Pmat
# converges to as t becomes large.
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504,
0.168, 0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Make a series of t values
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)

# Exponentiate each with EXPOKIT's dgpadm (good for small dense matrices)
for (t in tvals)
	{
	Pmat = expokit_dgpadm_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)
	cat("\n\nTime=", t, "\n", sep="")
	print(Pmat)
	}

# Exponentiate each with EXPOKIT's dmexpv (should be fast for large sparse matrices)
for (t in tvals)
	{
	Pmat = expokit_dmexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)
	cat("\n\nTime=", t, "\n", sep="")
	print(Pmat)
	}

# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.

# DMEXPV, single t-value
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)
expokit_wrapalldmexpv_tvals(Qmat=Qmat, tvals=2)

# DGEXPV, single t-value
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)

# These functions runs the for-loop itself (sadly, we could not get mapply() to work
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.

# DMEXPV functions
list_of_P_matrices_dmexpv = expokit_wrapalldmexpv_tvals(Qmat=Qmat,
tvals=tvals, transpose_needed=TRUE)
list_of_P_matrices_dmexpv

# DGEXPV functions
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,
tvals=tvals, transpose_needed=TRUE)
list_of_P_matrices_dgexpv

# Check if there are differences in the results (might only happen for large problems)
cat("\n")
cat("Differences between dmexpv and dgexpv\n")

for (i in 1:length(list_of_P_matrices_dmexpv))
	{
	diffs = list_of_P_matrices_dmexpv[[i]] - list_of_P_matrices_dgexpv[[i]]
	print(diffs)
	cat("\n")
	}
</code></pre>

<hr>
<h2 id='coo2mat'>Convert a COO-formated matrix to standard square format</h2><span id='topic+coo2mat'></span>

<h3>Description</h3>

<p><code>EXPOKIT</code>'s <code>dmexp</code>-type functions deal with
sparse matrices. These have a lot of zeros, and thus can
be compressed into COO (coordinated list) format, which
is described here:<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coo2mat(coomat,
    n = max(max(coomat[, 1]), max(coomat[, 2])),
    transpose_needed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coo2mat_+3A_coomat">coomat</code></td>
<td>
<p>a 3-column matrix or data.frame (basically
<code>cbind(ia, ja, a)</code>)</p>
</td></tr>
<tr><td><code id="coo2mat_+3A_n">n</code></td>
<td>
<p>the order of the matrix</p>
</td></tr>
<tr><td><code id="coo2mat_+3A_transpose_needed">transpose_needed</code></td>
<td>
<p>If TRUE (default), matrix will be
transposed (apparently EXPOKIT needs the input matrix to
be transposed compared to normal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a><br />
</p>
<p>In <code>EXPOKIT</code> and its wrapper functions, a
COO-formated matrix is input as 3 vectors (first two
integer, the third double):<br />
</p>
<p>ia = row number<br /> ja = column number<br /> a = value of
that cell in the matrix (skipping 0 cells)<br />
</p>
<p>This function takes a 3-column matrix or data.frame
(basically <code>cbind(ia, ja, a)</code>) and the order of the
matrix, <code>n</code> (n = the order of the matrix, i.e.
number of rows/columns) and converts back to standard
square format.<br />
</p>


<h3>Value</h3>

<p>outmat
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example use:
ia = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4)
ja = c(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
a  = c(-1.218, 0.126, 0.168, 0.126, 0.504, -0.882, 0.504,
0.672, 0.336, 0.252, -1.050, 0.252, 0.378, 0.504, 0.378, -1.050)
coomat = cbind(ia, ja, a)
print(coomat)
n = 4
Qmat = coo2mat(coomat, n)
print(Qmat)
</code></pre>

<hr>
<h2 id='expm'>Simple Interface</h2><span id='topic+expm'></span>

<h3>Description</h3>

<p>A simple interface for matrix exponentiation, similar to that found
in the Matrix package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expm(x, t=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expm_+3A_x">x</code></td>
<td>
<p>A square matrix.</p>
</td></tr>
<tr><td><code id="expm_+3A_t">t</code></td>
<td>
<p>Time value; see details section below. Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine computes exp(t*x), where <code>t</code> in a single numeric value,
and x is a square matrix and exp refers to the matrix exponential.
Formally, the matrix exponential is given by the power series:
</p>
<p><code class="reqn">expm(x) = x/1! + x^2/2! + x^3/3! + \dots</code>
</p>
<p>where the powers on the matrix correspond to matrix-matrix multiplications.
</p>
<p><code>expm()</code> directly computes the matrix exponential of a dense 
matrix. The implementation uses an order 6 Pade' approximation with a 
scaling-and-squaring technique.
</p>


<h3>Value</h3>

<p>The matrix exponential.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt <a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>References</h3>

<p>Sidje RB (1998). &quot;Expokit. A Software Package for
Computing Matrix Exponentials.&quot; _ACM Trans. Math.
Softw._, *24*(1), pp. 130-156. &lt;URL:
http://dx.doi.org/10.1145/285861.285868&gt;, &lt;URL:
<a href="https://dl.acm.org/doi/10.1145/285861.285868">https://dl.acm.org/doi/10.1145/285861.285868</a>&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example use:
x &lt;- matrix(1:25, nrow=5)/100

expm(x)
</code></pre>

<hr>
<h2 id='expokit_dgexpv_Qmat'>EXPOKIT dgexpv matrix exponentiation on Q matrix</h2><span id='topic+expokit_dgexpv_Qmat'></span>

<h3>Description</h3>

<p>This function converts a matrix to COO format and
exponentiates it via the EXPOKIT dgexpv function
(designed for sparse matrices) and wrapper functions
<code>wrapalldgexpv_</code> around dgexpv.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expokit_dgexpv_Qmat(Qmat = NULL, t = 2.1,
    inputprobs_for_fast = NULL, transpose_needed = TRUE,
    transform_to_coo_TF = TRUE, coo_n = NULL, anorm = NULL,
    check_for_0_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_qmat">Qmat</code></td>
<td>
<p>an input Q transition matrix</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_t">t</code></td>
<td>
<p>a time value to exponentiate by</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_inputprobs_for_fast">inputprobs_for_fast</code></td>
<td>
<p>If NULL (default), the full
probability matrix (Pmat) is returned. However, the full
speed of EXPOKIT on sparse matrices will be exploited if
inputprobs_for_fast=c(starting probabilities). In this
case these starting probabilities are input to
<code>myDMEXPV</code> directly, as <code>v</code>, and <code>w</code>, the
output probabilities, are returned.</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_transpose_needed">transpose_needed</code></td>
<td>
<p>If TRUE (default), matrix will be
transposed (apparently EXPOKIT needs the input matrix to
be transposed compared to normal)</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_transform_to_coo_tf">transform_to_coo_TF</code></td>
<td>
<p>Should the matrix be tranposed
to COO?  COO format is required for EXPOKIT's
sparse-matrix functions (like dmexpv and unlike the
padm-related functions. Default TRUE; if FALSE, user must
put a COO-formated matrix in <code>Qmat</code>. Supplying the
coo matrix is probably faster for repeated calculations
on large matrices.</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_coo_n">coo_n</code></td>
<td>
<p>If a COO matrix is input, <code>coo_n</code>
specified the order (# rows, equals # columns) of the
matrix.</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_anorm">anorm</code></td>
<td>
<p><code>dgexpv</code> requires an initial guess at
the norm of the matrix. Using the R function
<code><a href="Matrix.html#topic+norm">norm</a></code> might get slow with large matrices. If
so, the user can input a guess manually (<code>Lagrange</code>
seems to just use 1 or 0, if I recall correctly).</p>
</td></tr>
<tr><td><code id="expokit_dgexpv_Qmat_+3A_check_for_0_rows">check_for_0_rows</code></td>
<td>
<p>If TRUE or a numeric value, the
input Qmat is checked for all-zero rows, since these will
crash the FORTRAN wrapalldmexpv function. A small nonzero
value set to check_for_0_rows or the default
(0.0000000000001) is input to off-diagonal cells in the
row (and the diagonal value is normalized), which should
fix the problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: DGEXPV vs. DMEXPV. According to the EXPOKIT
documentation, DGEXPV should be faster than DMEXPV,
however DMEXPV runs an accuracy check appropriate for
Markov chains, which is not done in DGEXPV.<br />
</p>
<p>From EXPOKIT:<br />
</p>
<p><code>* The method used is based on Krylov subspace
  projection</code><br /> <code>* techniques and the matrix under
  consideration interacts only</code><br /> <code>* via the external
  routine 'matvec' performing the matrix-vector</code> <br />
<code>* product (matrix-free method).</code><br /> <code>*</code><br />
<code>* This [DMEXPV, not DGEXPV -- NJM] is a customised
  version for Markov Chains. This means that a</code><br /> <code>*
  check is done within this code to ensure that the
  resulting vector </code><br /> <code>* w is a probability vector,
  i.e., w must have all its components </code><br /> <code>* in
  [0,1], with sum equal to 1. This check is done at some
  expense</code><br /> <code>* and the user may try DGEXPV which is
  cheaper since it ignores </code><br /> <code>* probability
  constraints.</code><br />
</p>
<p>I (NJM) have not noticed a difference between the outputs
of these two functions, but it might occur with large
matrices.
</p>
<p>COO (coordinated list) format is a compressed format that
is required for EXPOKIT's sparse-matrix functions (like
dgexpv and unlike EXPOKIT's padm-related functions. COO
format is described here:<br />
</p>
<p><a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a><br />
</p>
<p>If <code>Qmat</code> is NULL (default), a default matrix is
input.<br />
</p>


<h3>Value</h3>

<p><code>tmpoutmat</code> the output matrix. <code>wrapalldgexpv_</code>
produces additional output relating to accuracy of the
output matrix etc.; these can be by a direct call of
dgexpv.
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a> and Drew Schmidt
<a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2coo">mat2coo</a></code>
</p>
<p><code><a href="#topic+expokit_wrapalldgexpv_tvals">expokit_wrapalldgexpv_tvals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example:
# Make a square instantaneous rate matrix (Q matrix)
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,
# Unleashed" at:
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}
#
# The Q matrix includes the stationary base freqencies, which Pmat
# converges to as t becomes large.
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Make a series of t values
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)

# Exponentiate each with EXPOKIT's dgexpv (should be fast for large sparse matrices)
for (t in tvals)
	{
	Pmat = expokit_dgexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)
	cat("\n\nTime=", t, "\n", sep="")
	print(Pmat)
	}

# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.

# DGEXPV, single t-value
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)

# This function runs the for-loop itself (sadly, we could not get mapply() to work
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.

# DGEXPV functions
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,
tvals=tvals, transpose_needed=TRUE)
list_of_P_matrices_dgexpv
</code></pre>

<hr>
<h2 id='expokit_dgpadm_Qmat'>EXPOKIT dgpadm matrix exponentiation on Q matrix</h2><span id='topic+expokit_dgpadm_Qmat'></span>

<h3>Description</h3>

<p>This function exponentiates a matrix via the EXPOKIT padm
function (designed for small dense matrices) and wrapper
function <code>wrapalldgpadm_</code> around dmexpv.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expokit_dgpadm_Qmat(Qmat = NULL, t = 2.1,
    transpose_needed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expokit_dgpadm_Qmat_+3A_qmat">Qmat</code></td>
<td>
<p>an input Q transition matrix</p>
</td></tr>
<tr><td><code id="expokit_dgpadm_Qmat_+3A_t">t</code></td>
<td>
<p>one or more time values to exponentiate by</p>
</td></tr>
<tr><td><code id="expokit_dgpadm_Qmat_+3A_transpose_needed">transpose_needed</code></td>
<td>
<p>If TRUE (default), matrix will be
transposed (apparently EXPOKIT needs the input matrix to
be transposed compared to normal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From EXPOKIT:<br />
</p>
<p><code>* Computes exp(t*H), the matrix exponential of a
  general matrix in </code><br /> <code>* full, using the
  irreducible rational Pade approximation to the </code><br />
<code>* exponential function exp(x) = r(x) = (+/-)( I +
  2*(q(x)/p(x)) ), </code><br /> <code>* combined with
  scaling-and-squaring.  </code><br />
</p>
<p>If <code>Qmat</code> is NULL (default), a default matrix is
input.<br />
</p>


<h3>Value</h3>

<p><code>tmpoutmat</code> the output matrix. <code>wrapalldmexpv_</code>
produces additional output relating to accuracy of the
output matrix etc.; these can be obtained by a direct
call of wrapalldmexpv_.
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a> and Drew Schmidt
<a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2coo">mat2coo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example:
# Make a square instantaneous rate matrix (Q matrix)
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,
# Unleashed" at:
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}
#
# The Q matrix includes the stationary base freqencies, which Pmat
# converges to as t becomes large.
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Make a series of t values
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)

# Exponentiate each with EXPOKIT's dgpadm (good for small dense matrices)
for (t in tvals)
	{
	Pmat = expokit_dgpadm_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)
	cat("\n\nTime=", t, "\n", sep="")
	print(Pmat)
	}
</code></pre>

<hr>
<h2 id='expokit_dmexpv_Qmat'>EXPOKIT dmexpv matrix exponentiation on Q matrix</h2><span id='topic+expokit_dmexpv_Qmat'></span>

<h3>Description</h3>

<p>This function converts a matrix to COO format and
exponentiates it via the EXPOKIT dmexpv function
(designed for sparse matrices) and wrapper functions
<code>wrapalldmexpv_</code> around dmexpv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expokit_dmexpv_Qmat(Qmat = NULL, t = 2.1,
    inputprobs_for_fast = NULL, transpose_needed = TRUE,
    transform_to_coo_TF = TRUE, coo_n = NULL, anorm = NULL,
    check_for_0_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_qmat">Qmat</code></td>
<td>
<p>an input Q transition matrix</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_t">t</code></td>
<td>
<p>one or more time values to exponentiate by</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_inputprobs_for_fast">inputprobs_for_fast</code></td>
<td>
<p>If NULL (default), the full
probability matrix (Pmat) is returned. However, the full
speed of EXPOKIT on sparse matrices will be exploited if
inputprobs_for_fast=c(starting probabilities). In this
case these starting probabilities are input to
<code>myDMEXPV</code> directly, as <code>v</code>, and <code>w</code>, the
output probabilities, are returned.</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_transpose_needed">transpose_needed</code></td>
<td>
<p>If TRUE (default), matrix will be
transposed (apparently EXPOKIT needs the input matrix to
be transposed compared to normal)</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_transform_to_coo_tf">transform_to_coo_TF</code></td>
<td>
<p>Should the matrix be tranposed
to COO?  COO format is required for EXPOKIT's
sparse-matrix functions (like dmexpv and unlike the
padm-related functions. Default TRUE; if FALSE, user must
put a COO-formated matrix in <code>Qmat</code>. Supplying the
coo matrix is probably faster for repeated calculations
on large matrices.</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_coo_n">coo_n</code></td>
<td>
<p>If a COO matrix is input, <code>coo_n</code>
specified the order (# rows, equals # columns) of the
matrix.</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_anorm">anorm</code></td>
<td>
<p><code>dmexpv</code> requires an initial guess at
the norm of the matrix. Using the</p>
</td></tr>
<tr><td><code id="expokit_dmexpv_Qmat_+3A_check_for_0_rows">check_for_0_rows</code></td>
<td>
<p>If TRUE or a numeric value, the
input Qmat is checked for all-zero rows, since these will
crash the FORTRAN wrapalldmexpv function. A small nonzero
value set to check_for_0_rows or the default
(0.0000000000001) is input to off-diagonal cells in the
row (and the diagonal value is normalized), which should
fix the problem. R function <code><a href="Matrix.html#topic+norm">norm</a></code> might get
slow with large matrices. If so, the user can input a
guess manually (<code>Lagrange</code> seems to just use 1 or 0,
if I recall correctly).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From EXPOKIT:<br /> <code>* The method used is based on
  Krylov subspace projection</code><br /> <code>* techniques and the
  matrix under consideration interacts only</code><br /> <code>* via
  the external routine 'matvec' performing the
  matrix-vector</code> <br /> <code>* product (matrix-free
  method).</code><br /> <code>*</code><br /> <code>* This is a customised
  version for Markov Chains. This means that a</code><br /> <code>*
  check is done within this code to ensure that the
  resulting vector</code> <br /> <code>* w is a probability vector,
  i.e., w must have all its components </code><br /> <code>* in
  [0,1], with sum equal to 1. This check is done at some
  expense</code><br /> <code>* and the user may try DGEXPV which is
  cheaper since it ignores </code><br /> <code>* probability
  constraints.</code><br />
</p>
<p>COO (coordinated list) format is a compressed format that
is<br /> required for EXPOKIT's sparse-matrix functions
(like dmexpv and<br /> unlike EXPOKIT's padm-related
functions.<br />
</p>
<p>COO (coordinated list) format is described here:<br />
</p>
<p><a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a><br />
</p>
<p>If <code>Qmat</code> is NULL (default), a default matrix is
input.<br />
</p>


<h3>Value</h3>

<p><code>tmpoutmat</code> the output matrix. <code>wrapalldmexpv_</code>
produces additional output relating to accuracy of the
output matrix etc.; these can be by a direct call of
dmexpv.
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a> and Drew Schmidt
<a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2coo">mat2coo</a></code>
</p>
<p><code><a href="#topic+expokit_wrapalldmexpv_tvals">expokit_wrapalldmexpv_tvals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example:
# Make a square instantaneous rate matrix (Q matrix)
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,
# Unleashed" at:
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}
#
# The Q matrix includes the stationary base freqencies, which Pmat
# converges to as t becomes large.
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Make a series of t values
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)

# Exponentiate each with EXPOKIT's dmexpv (should be fast for large sparse matrices)
for (t in tvals)
	{
	Pmat = expokit_dmexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)
	cat("\n\nTime=", t, "\n", sep="")
	print(Pmat)
	}
</code></pre>

<hr>
<h2 id='expokit_itscale5_wrapper'>wrapper function for FORTRAN itscale5, for FD's maxent</h2><span id='topic+expokit_itscale5_wrapper'></span>

<h3>Description</h3>

<p>This function wraps the .C call to EXPOKIT for the itscale5 function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expokit_itscale5_wrapper(SXT, ngroups, ntraits, const, prior, 
    prob, entropy, niter, tol, denom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expokit_itscale5_wrapper_+3A_sxt">SXT</code></td>
<td>
<p>is a Groups (rows) X Traits (columns) matrix</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_ngroups">ngroups</code></td>
<td>
<p>is an integer (nb: NJM's interpretation)</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_ntraits">ntraits</code></td>
<td>
<p>is an integer (nb: NJM's interpretation)</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_const">const</code></td>
<td>
<p>is a vector of the constraint values (means, variances)</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_prior">prior</code></td>
<td>
<p>is the prior distribution</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_prob">prob</code></td>
<td>
<p>is the return vector of the maximum entropy</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_entropy">entropy</code></td>
<td>
<p>is the maximum entropy probabilities</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_niter">niter</code></td>
<td>
<p>is the number of iterations required</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_tol">tol</code></td>
<td>
<p>is the convergence tolerance value; tolerance is mean square difference</p>
</td></tr>
<tr><td><code id="expokit_itscale5_wrapper_+3A_denom">denom</code></td>
<td>
<p>are final moments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The itscale5 function is in the &quot;itscale5.f&quot; FORTRAN file.  itscale5 is used by
the FD::maxent function.<br />
</p>
<p>The maxent function is used by BioGeoBEARS, merely to provide a simple method 
of putting flat or skewed probability distributions on the ordered categorical variable
&quot;size of smaller daughter range&quot;).<br />
</p>
<p>As the package FD has a number of other dependencies, some of which cause problems on 
some machines, I am just including maxent and itscale5 here, in order to avoid 
&quot;dependency hell&quot;.<br />
</p>
<p>I am putting it in rexpokit rather than BioGeoBEARS, to make rexpokit the only
package using FORTRAN code (which has a list of its own issues).</p>


<h3>Value</h3>

<p><code>res</code> A list of outputs</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+maxent">maxent</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># See maxent() function
test=1</code></pre>

<hr>
<h2 id='expokit_wrapalldgexpv_tvals'>Run EXPOKIT's dgexpv on one or more t-values</h2><span id='topic+expokit_wrapalldgexpv_tvals'></span>

<h3>Description</h3>

<p>The function runs EXPOKIT's <code>dgexpv</code> function on a Q
matrix and <em>one or more</em> time values.  If
<code>Qmat</code> is NULL (default), a default matrix is
input.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expokit_wrapalldgexpv_tvals(Qmat = NULL, tvals = c(2.1),
    inputprobs_for_fast = NULL, transpose_needed = TRUE,
    transform_to_coo_TF = TRUE, coo_n = NULL,
    force_list_if_1_tval = FALSE, check_for_0_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_qmat">Qmat</code></td>
<td>
<p>an input Q transition matrix</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_tvals">tvals</code></td>
<td>
<p>one or more time values to exponentiate by
(doesn't have to literally be a time value, obviously)</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_inputprobs_for_fast">inputprobs_for_fast</code></td>
<td>
<p>If NULL (default), the full
probability matrix (Pmat) is returned. However, the full
speed of EXPOKIT on sparse matrices will be exploited if
inputprobs_for_fast=c(starting probabilities). In this
case these starting probabilities are input to
<code>myDMEXPV</code> directly, as <code>v</code>, and <code>w</code>, the
output probabilities, are returned.</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_transpose_needed">transpose_needed</code></td>
<td>
<p>If TRUE (default), matrix will be
transposed (apparently EXPOKIT needs the input matrix to
be transposed compared to normal)</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_transform_to_coo_tf">transform_to_coo_TF</code></td>
<td>
<p>Should the matrix be tranposed
to COO?  COO format is required for EXPOKIT's
sparse-matrix functions (like dmexpv and unlike the
padm-related functions. Default TRUE; if FALSE, user must
put a COO-formated matrix in <code>Qmat</code>. Supplying the
coo matrix is probably faster for repeated calculations
on large matrices.</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_coo_n">coo_n</code></td>
<td>
<p>If a COO matrix is input, <code>coo_n</code>
specified the order (# rows, equals # columns) of the
matrix.</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_force_list_if_1_tval">force_list_if_1_tval</code></td>
<td>
<p>Default FALSE, but set to
TRUE if you want a single matrix to be returned inside a
list</p>
</td></tr>
<tr><td><code id="expokit_wrapalldgexpv_tvals_+3A_check_for_0_rows">check_for_0_rows</code></td>
<td>
<p>If TRUE or a numeric value, the
input Qmat is checked for all-zero rows, since these will
crash the FORTRAN wrapalldmexpv function. A small nonzero
value set to check_for_0_rows or the default
(0.0000000000001) is input to off-diagonal cells in the
row (and the diagonal value is normalized), which should
fix the problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: DGEXPV vs. DMEXPV. According to the EXPOKIT
documentation, DGEXPV should be faster than DMEXPV,
however DMEXPV runs an accuracy check appropriate for
Markov chains, which is not done in DGEXPV.<br />
</p>


<h3>Value</h3>

<p><code>tmpoutmat</code> the output matrix, if 1 t-value is
input; <code>list_of_matrices_output</code>, if more than 1
t-value is input; to get a single output matrix in a
list, set <code>force_list_if_1_tval=TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a> and Drew Schmidt
<a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expokit_dgexpv_Qmat">expokit_dgexpv_Qmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example:
# Make a square instantaneous rate matrix (Q matrix)
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,
# Unleashed" at:
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}
#
# The Q matrix includes the stationary base freqencies, which Pmat
# converges to as t becomes large.
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Make a series of t values
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)

# Exponentiate each with EXPOKIT's dgexpv (should be fast for large sparse matrices)
for (t in tvals)
	{
	Pmat = expokit_dgexpv_Qmat(Qmat=Qmat, t=t, transpose_needed=TRUE)
	cat("\n\nTime=", t, "\n", sep="")
	print(Pmat)
	}

# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.

# DMEXPV, single t-value

# DGEXPV, single t-value
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)

# These functions runs the for-loop itself (sadly, we could not get mapply() to work
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.

# DGEXPV functions
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,
tvals=tvals, transpose_needed=TRUE)
list_of_P_matrices_dgexpv
</code></pre>

<hr>
<h2 id='expokit_wrapalldmexpv_tvals'>Run EXPOKIT's dmexpv on one or more t-values</h2><span id='topic+expokit_wrapalldmexpv_tvals'></span>

<h3>Description</h3>

<p>The function runs EXPOKIT's <code>dmexpv</code> function on a Q
matrix and <em>one or more</em> time values.  If
<code>Qmat</code> is NULL (default), a default matrix is input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expokit_wrapalldmexpv_tvals(Qmat = NULL, tvals = c(2.1),
    inputprobs_for_fast = NULL, transpose_needed = TRUE,
    transform_to_coo_TF = TRUE, coo_n = NULL,
    force_list_if_1_tval = FALSE, check_for_0_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_qmat">Qmat</code></td>
<td>
<p>an input Q transition matrix</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_tvals">tvals</code></td>
<td>
<p>one or more time values to exponentiate by
(doesn't have to literally be a time value, obviously)</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_inputprobs_for_fast">inputprobs_for_fast</code></td>
<td>
<p>If NULL (default), the full
probability matrix (Pmat) is returned. However, the full
speed of EXPOKIT on sparse matrices will be exploited if
inputprobs_for_fast=c(starting probabilities). In this
case these starting probabilities are input to
<code>myDMEXPV</code> directly, as <code>v</code>, and <code>w</code>, the
output probabilities, are returned.</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_transpose_needed">transpose_needed</code></td>
<td>
<p>If TRUE (default), matrix will be
transposed (apparently EXPOKIT needs the input matrix to
be transposed compared to normal)</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_transform_to_coo_tf">transform_to_coo_TF</code></td>
<td>
<p>Should the matrix be tranposed
to COO?  COO format is required for EXPOKIT's
sparse-matrix functions (like dmexpv and unlike the
padm-related functions. Default TRUE; if FALSE, user must
put a COO-formated matrix in <code>Qmat</code>. Supplying the
coo matrix is probably faster for repeated calculations
on large matrices.</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_coo_n">coo_n</code></td>
<td>
<p>If a COO matrix is input, <code>coo_n</code>
specified the order (# rows, equals # columns) of the
matrix.</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_force_list_if_1_tval">force_list_if_1_tval</code></td>
<td>
<p>Default FALSE, but set to
TRUE if you want a single matrix to be returned inside a
list</p>
</td></tr>
<tr><td><code id="expokit_wrapalldmexpv_tvals_+3A_check_for_0_rows">check_for_0_rows</code></td>
<td>
<p>If TRUE or a numeric value, the
input Qmat is checked for all-zero rows, since these will
crash the FORTRAN wrapalldmexpv function. A small nonzero
value set to check_for_0_rows or the default
(0.0000000000001) is input to off-diagonal cells in the
row (and the diagonal value is normalized), which should
fix the problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tmpoutmat</code> the output matrix, if 1 t-value is
input; <code>list_of_matrices_output</code>, if more than 1
t-value is input; to get a single output matrix in a
list, set <code>force_list_if_1_tval=TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a> and Drew Schmidt
<a href="mailto:schmidt@math.utk.edu">schmidt@math.utk.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expokit_dmexpv_Qmat">expokit_dmexpv_Qmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a square instantaneous rate matrix (Q matrix)
# This matrix is taken from Peter Foster's (2001) "The Idiot's Guide
# to the Zen of Likelihood in a Nutshell in Seven Days for Dummies,
# Unleashed" at:
# \url{http://www.bioinf.org/molsys/data/idiots.pdf}
#
# The Q matrix includes the stationary base freqencies, which Pmat
# converges to as t becomes large.
Qmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Make a series of t values
tvals = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5, 14)

# DMEXPV and DGEXPV are designed for large, sparse Q matrices (sparse = lots of zeros).
# DMEXPV is specifically designed for Markov chains and so may be slower, but more accurate.

# DGEXPV, single t-value
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=tvals[1], transpose_needed=TRUE)
expokit_wrapalldgexpv_tvals(Qmat=Qmat, tvals=2)

# This function runs the for-loop itself (sadly, we could not get mapply() to work
# on a function that calls dmexpv/dgexpv), returning a list of probability matrices.

# DGEXPV functions
list_of_P_matrices_dgexpv = expokit_wrapalldgexpv_tvals(Qmat=Qmat,
tvals=tvals, transpose_needed=TRUE)
list_of_P_matrices_dgexpv
</code></pre>

<hr>
<h2 id='mat2coo'>Convert matrix to COO format using SparseM function</h2><span id='topic+mat2coo'></span>

<h3>Description</h3>

<p>Converts a matrix to COO format using the SparseM
function, presumably this is faster than using a
for-loop.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mat2coo(tmpmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2coo_+3A_tmpmat">tmpmat</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>EXPOKIT</code>'s <code>dmexp</code>-type functions deal with
sparse matrices. These have a lot of zeros, and thus can
be compressed into COO (coordinated list) format, which
is described here:<br />
</p>
<p><a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a><br />
</p>
<p>In <code>EXPOKIT</code> and its wrapper functions, a
COO-formated matrix is input as 3 vectors (first two
integer, the third double):<br />
</p>
<p>ia = row number<br /> ja = column number<br /> a = value of
that cell in the matrix (skipping 0 cells)<br />
</p>


<h3>Value</h3>

<p>tmpmat_in_REXPOKIT_coo_fmt A <code>cbind</code> of <code>ia</code>,
<code>ja</code>, and <code>a</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2coo_forloop">mat2coo_forloop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example use:
</code></pre>

<hr>
<h2 id='mat2coo_forloop'>Convert matrix to COO format using nested for-loops</h2><span id='topic+mat2coo_forloop'></span>

<h3>Description</h3>

<p>Converts a matrix to COO format. This version of the
function uses for-loops, which is presumably less
efficient than <code><a href="#topic+mat2coo">mat2coo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mat2coo_forloop(tmpmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2coo_forloop_+3A_tmpmat">tmpmat</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tmpmat_in_REXPOKIT_coo_fmt A <code>cbind</code> of <code>ia</code>,
<code>ja</code>, and <code>a</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:nickmatzke.ncse@gmail.com">nickmatzke.ncse@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2coo">mat2coo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example use:
# Make a Q matrix
tmpmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Convert to REXPOKIT coo format
tmpmat_in_REXPOKIT_coo_fmt = mat2coo_forloop(tmpmat)
tmpmat_in_REXPOKIT_coo_fmt
</code></pre>

<hr>
<h2 id='maxent'>
Estimating Probabilities via Maximum Entropy: Improved Iterative Scaling
</h2><span id='topic+maxent'></span>

<h3>Description</h3>

<p>NOTE: This is a copy of the FD::maxent function, included in rexpokit to avoid the 
dependency on the package FD. <code>maxent</code> returns the probabilities that 
maximize the entropy conditional on a series of constraints that are linear 
in the features. It relies on the Improved Iterative Scaling algorithm of 
Della Pietra et al. (1997). It has been used to predict the relative abundances 
of a set of species given the trait values of each species and the 
community-aggregated trait values at a site (Shipley et al. 2006; 
Shipley 2009; Sonnier et al. 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxent(constr, states, prior, tol = 1e-07, lambda = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxent_+3A_constr">constr</code></td>
<td>

<p>vector of macroscopical constraints (e.g. community-aggregated trait values). Can also be a matrix or data frame, with constraints as columns and data sets (e.g. sites) as rows.
</p>
</td></tr>
<tr><td><code id="maxent_+3A_states">states</code></td>
<td>

<p>vector, matrix or data frame of states (columns) and their attributes (rows).
</p>
</td></tr>
<tr><td><code id="maxent_+3A_prior">prior</code></td>
<td>

<p>vector, matrix or data frame of prior probabilities of states (columns). Can be missing, in which case a maximally uninformative prior is assumed (i.e. uniform distribution).
</p>
</td></tr>
<tr><td><code id="maxent_+3A_tol">tol</code></td>
<td>

<p>tolerance threshold to determine convergence. See &lsquo;details&rsquo; section. 
</p>
</td></tr>
<tr><td><code id="maxent_+3A_lambda">lambda</code></td>
<td>

<p>Logical. Should <code class="reqn">\lambda</code>-values be returned? 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a copy of the FD::maxent function, included in rexpokit to avoid the dependency on the package FD.
Its authorship information is Authored by: Bill Shipley <a href="mailto:bill.shipley@usherbrooke.ca">bill.shipley@usherbrooke.ca</a> 
(http://pages.usherbrooke.ca/jshipley/recherche/); Ported to FD by Etienne Laliberte. It was 
copied to rexpokit by Nick Matzke (just in order to avoid the dependency on package &quot;FD&quot;).
</p>
<p>Having BioGeoBEARS depend on package &quot;FD&quot; was sometimes problematic, as it had a variety of FORTRAN
code and dependencies that could slow/stall installation, particularly on older Windows machines
or machines without appropriate compilers. The maxent function uses only the FORTRAN file itscale5.f,
so that code was included in rexpokit, in order to include all of the FORTRAN code in a single 
package (greatly simplifying the compilation and code-review process for BioGeoBEARS, which is 
pure R.)
</p>
<p>The function maxent is used in BioGeoBEARS only for the simple purpose of putting a probability 
distribution on the ordered variable &quot;number of areas in the smaller daughter range&quot; at cladogenesis.
For example, if mx01v = 0.0001 (the DEC model default), then the smaller daughter range will 
have a 100 percent probability of being of size 1 area during a vicariance event (thus, the &quot;v&quot; in 
&quot;mx01v&quot;). If mx01v = 0.5 (the DIVALIKE model default), then the smaller daughter range will 
have an equal chance of being any range of size less than the parent range. If mx01y = 0.9999 
(the BAYAREALIKE default), then the &quot;smaller&quot; daughter at sympatry (mx01y, y is sYmpatry) will 
have 100 percent probability of being the same size as its sister (i.e., the same range as the 
sister, i.e. &quot;perfect sympatry&quot; or &quot;sympatry across all areas&quot;).
</p>
<p>Original description from FD::maxent follows for completeness, but is not relevant for 
rexpokit/BioGeoBEARS.
</p>
<p>The biological model of community assembly through trait-based habitat
filtering (Keddy 1992) has been translated mathematically
via a maximum entropy (maxent) model by Shipley et al. (2006) and
Shipley (2009). A maxent model contains three components: (i) a set
of possible states and their attributes, (ii) a set of macroscopic empirical constraints,
and (iii) a prior probability distribution <code class="reqn">\mathbf{q}=[q_j]</code>.
</p>
<p>In the context of community assembly, states are species, macroscopic
empirical constraints are community-aggregated traits, and prior probabilities
<code class="reqn">\mathbf{q}</code> are the relative abundances of species of the regional
pool (Shipley et al. 2006, Shipley 2009). By default, these prior
probabilities <code class="reqn">\mathbf{q}</code> are maximally uninformative (i.e. a uniform distribution),
but can be specificied otherwise (Shipley 2009, Sonnier et al. 2009).
</p>
<p>To facilitate the link between the biological model and the mathematical
model, in the following description of the algorithm states are species and constraints are traits.
</p>
<p>Note that if <code>constr</code> is a matrix or data frame containing several sets (rows),
a maxent model is run on each individual set. In this case if <code>prior</code> is a vector,
the same prior is used for each set. A different prior can also be specified for each set.
In this case, the number of rows in <code>prior</code> must be equal to the number of rows in <code>constr</code>. 
</p>
<p>If <code class="reqn">\mathbf{q}</code> is not specified, set <code class="reqn">p_{j}=1/S</code> for each of the
<code class="reqn">S</code> species (i.e. a uniform distribution), where <code class="reqn">p_{j}</code> is the
probability of species <code class="reqn">j</code>, otherwise <code class="reqn">p_{j}=q_{j}</code>.
</p>
<p>Calulate a vector <code class="reqn">\mathbf{c=\left[\mathrm{\mathit{c_{i}}}\right]}=\{c_{1},\; c_{2},\;\ldots,\; c_{T}\}</code>,
where <code class="reqn">c_{i}={\displaystyle \sum_{j=1}^{S}t_{ij}}</code>; i.e. each <code class="reqn">c_{i}</code>
is the sum of the values of trait <code class="reqn">i</code> over all species, and <code class="reqn">T</code>
is the number of traits.
</p>
<p>Repeat for each iteration <code class="reqn">k</code> until convergence:
</p>
<p>1. For each trait <code class="reqn">t_{i}</code> (i.e. row of the constraint matrix) calculate:
</p>
<p style="text-align: center;"><code class="reqn">
\gamma_{i}(k)=ln\left(\frac{\bar{t}_{i}}{{\displaystyle \sum_{j=1}^{S}\left(p_{j}(k)\; t_{ij}\right)}}\right)\left(\frac{1}{c_{i}}\right)</code>
</p>

<p>This is simply the natural log of the known community-aggregated
trait value to the calculated community-aggregated trait value at
this step in the iteration, given the current values of the probabilities.
The whole thing is divided by the sum of the known values of the trait
over all species.
</p>
<p>2. Calculate the normalization term <code class="reqn">Z</code>:
</p>
<p style="text-align: center;"><code class="reqn">Z(k)=\left({\displaystyle \sum_{j=1}^{S}p_{j}(k)\; e^{\left({\displaystyle \sum_{i=1}^{T}\gamma_{i}(k)}\; t_{ij}\right)}}\right)</code>
</p>

<p>3. Calculate the new probabilities <code class="reqn">p_{j}</code> of each species at iteration <code class="reqn">k+1</code>:
</p>
<p style="text-align: center;"><code class="reqn">p_{j}(k+1)=\frac{{\displaystyle p_{j}(k)\; e^{\left({\displaystyle \sum_{i=1}^{T}\gamma_{i}(k)}\; t_{ij}\right)}}}{Z(k)}</code>
</p>

<p>4. If <code class="reqn">|max\left(p\left(k+1\right)-p\left(k\right)\right)|\leq</code> tolerance threshold (i.e. argument <code>tol</code>) then stop, else repeat steps 1 to 3.
</p>
<p>When convergence is achieved then the resulting probabilities (<code class="reqn">\hat{p}_{j}</code>)
are those that are as close as possible to <code class="reqn">q_j</code> while simultaneously maximize
the entropy conditional on the community-aggregated traits. The solution to this problem is
the Gibbs distribution:
</p>
<p style="text-align: center;"><code class="reqn">\hat{p}_{j}=\frac{q_{j}e^{\left({\displaystyle -}{\displaystyle \sum_{i=1}^{T}\lambda_{i}t_{ij}}\right)}}{{\displaystyle \sum_{j=1}^{S}q_{j}}e^{\left({\displaystyle -}{\displaystyle \sum_{i=1}^{T}\lambda_{i}t_{ij}}\right)}}=\frac{q_{j}e^{\left({\displaystyle -}{\displaystyle \sum_{i=1}^{T}\lambda_{i}t_{ij}}\right)}}{Z}</code>
</p>

<p>This means that one can solve for the Langrange multipliers (i.e.
weights on the traits, <code class="reqn">\lambda_{i}</code>) by solving the linear system
of equations:
</p>
<p style="text-align: center;"><code class="reqn">\left(\begin{array}{c}
ln\left(\hat{p}_{1}\right)\\
ln\left(\hat{p}_{2}\right)\\
\vdots\\
ln\left(\hat{p}_{S}\right)\end{array}\right)=\left(\lambda_{1},\;\lambda_{2},\;\ldots,\;\lambda_{T}\right)\left[\begin{array}{cccc}
t_{11} &amp; t_{12} &amp; \ldots &amp; t_{1S}-ln(Z)\\
t_{21} &amp; t_{22} &amp; \vdots &amp; t_{2S}-ln(Z)\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
t_{T1} &amp; t_{T2} &amp; \ldots &amp; t_{TS}-ln(Z)\end{array}\right]-ln(Z)</code>
</p>

<p>This system of linear equations has <code class="reqn">T+1</code> unknowns (the <code class="reqn">T</code> values
of <code class="reqn">\lambda</code> plus <code class="reqn">ln(Z)</code>) and <code class="reqn">S</code> equations. So long as the number
of traits is less than <code class="reqn">S-1</code>, this system is soluble. In fact, the
solution is the well-known least squares regression: simply regress
the values <code class="reqn">ln(\hat{p}_{j})</code> of each species on the trait values
of each species in a multiple regression.
</p>
<p>The intercept is the value of <code class="reqn">ln(Z)</code> and the slopes are the values
of <code class="reqn">\lambda_{i}</code> and these slopes (Lagrange multipliers) measure
by how much the <code class="reqn">ln(\hat{p}_{j})</code>, i.e. the <code class="reqn">ln</code>(relative abundances),
changes as the value of the trait changes.
</p>
<p><code>FD::maxent.test</code> provides permutation tests for maxent models (Shipley 2010).
</p>


<h3>Value</h3>

<table>
<tr><td><code>prob</code></td>
<td>
<p>vector of predicted probabilities</p>
</td></tr>
<tr><td><code>moments</code></td>
<td>
<p>vector of final moments</p>
</td></tr>
<tr><td><code>entropy</code></td>
<td>
<p>Shannon entropy of <code>prob</code></p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations required to reach convergence</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p><code class="reqn">\lambda</code>-values, only returned if <code>lambda = T</code></p>
</td></tr>
<tr><td><code>constr</code></td>
<td>
<p>macroscopical constraints</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>states and their attributes</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bill Shipley <a href="mailto:bill.shipley@usherbrooke.ca">bill.shipley@usherbrooke.ca</a>, original URL: pages.usherbrooke.ca/jshipley/recherche/
</p>
<p>Ported to <span class="pkg">FD</span> by Etienne Laliberte.
</p>


<h3>References</h3>

<p>Della Pietra, S., V. Della Pietra, and J. Lafferty (1997) Inducing features of random fields. <em>IEEE Transactions Pattern Analysis and Machine Intelligence</em> <b>19</b>:1-13.
</p>
<p>Keddy, P. A. (1992) Assembly and response rules: two goals for predictive community ecology. <em>Journal of Vegetation Science</em> <b>3</b>:157-164.
</p>
<p>Shipley, B., D. Vile, and E. Garnier (2006) From plant traits to plant communities: a statistical mechanistic approach to biodiversity. <em>Science</em> <b>314</b>: 812&ndash;814.
</p>
<p>Shipley, B. (2009) From Plant Traits to Vegetation Structure: Chance and Selection in the Assembly of Ecological Communities. Cambridge University Press, Cambridge, UK. 290 pages.
</p>
<p>Shipley, B. (2010) Inferential permutation tests for maximum entropy models in ecology. <em>Ecology</em> <b>in press</b>.
</p>
<p>Sonnier, G., Shipley, B., and M. L. Navas. 2009. Plant traits, species pools and the prediction of relative abundance in plant communities: a maximum entropy approach. <em>Journal of Vegetation Science</em> <b>in press</b>.
</p>


<h3>See Also</h3>

<p><code>FD::functcomp</code> to compute community-aggregated traits,
and <code>FD::maxent.test</code> for the permutation tests proposed by Shipley (2010).
</p>
<p>Another faster version of <code>maxent</code> for multicore processors called <code>maxentMC</code> is available from Etienne Laliberte (<a href="mailto:etiennelaliberte@gmail.com">etiennelaliberte@gmail.com</a>). It's exactly the same as <code>maxent</code> but makes use of the <span class="pkg">multicore</span>, <span class="pkg">doMC</span>, and <span class="pkg">foreach</span> packages. Because of this, <code>maxentMC</code> only works on POSIX-compliant OS's (essentially anything but Windows).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# an unbiased 6-sided dice, with mean = 3.5
# what is the probability associated with each side,
# given this constraint?

maxent(3.5, 1:6)

# a biased 6-sided dice, with mean = 4
maxent(4, 1:6)

## End(Not run)
</code></pre>

<hr>
<h2 id='SparseM_coo_to_REXPOKIT_coo'>Convert a SparseM COO matrix to a plain matrix</h2><span id='topic+SparseM_coo_to_REXPOKIT_coo'></span>

<h3>Description</h3>

<p>Converts a SparseM COO-formatted matrix (an S4 object) to
a plain matrix, with <br /> column #1 = ia = i index<br />
column #2 = ja = j index<br /> column #3 = a = nonzero
values of the matrix<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SparseM_coo_to_REXPOKIT_coo(tmpmat_in_SparseMcoo_fmt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseM_coo_to_REXPOKIT_coo_+3A_tmpmat_in_sparsemcoo_fmt">tmpmat_in_SparseMcoo_fmt</code></td>
<td>
<p>A square matrix S4 object
derived from SparseM's as.matrix.coo</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Background: COO (coordinated list) format, is described
here:<br />
</p>
<p><a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29</a><br />
</p>
<p>In <code>EXPOKIT</code> and its wrapper functions, a
COO-formated matrix is input as 3 vectors (first two
integer, the third double):<br />
</p>
<p>ia = row number<br /> ja = column number<br /> a = value of
that cell in the matrix (skipping 0 cells)<br />
</p>


<h3>Value</h3>

<p>tmpmat_in_REXPOKIT_coo_fmt A <code>cbind</code> of <code>ia</code>,
<code>ja</code>, and <code>a</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J. Matzke <a href="mailto:matzke@berkeley.edu">matzke@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2coo_forloop">mat2coo_forloop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example use:
# Make a Q matrix
tmpmat = matrix(c(-1.218, 0.504, 0.336, 0.378, 0.126, -0.882, 0.252, 0.504, 0.168,
0.504, -1.05, 0.378, 0.126, 0.672, 0.252, -1.05), nrow=4, byrow=TRUE)

# Covert to SparseM coo format
tmpmat_in_REXPOKIT_coo_fmt &lt;- mat2coo(tmpmat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
