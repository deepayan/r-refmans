<!DOCTYPE html><html lang="en"><head><title>Help for package Rlgt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rlgt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rlgt-package'><p>Getting started with the Rlgt package</p></a></li>
<li><a href='#blgt.multi.forecast'><p>Rlgt LSGT Gibbs run in parallel</p></a></li>
<li><a href='#forecast.rlgtfit'><p>Rlgt forecast</p></a></li>
<li><a href='#iclaims.example'><p>Weekly Initial Claims of US Unemployment Benefits &amp; Google Trends Queries</p></a></li>
<li><a href='#initModel'><p>Initialize a model from the Rlgt family</p></a></li>
<li><a href='#posterior_interval.rlgtfit'><p>rlgtfit posterior interval</p></a></li>
<li><a href='#print.rlgtfit'><p>Generic print function for rlgtfit models</p></a></li>
<li><a href='#rlgt'><p>Fit an Rlgt model</p></a></li>
<li><a href='#rlgt.control'><p>Sets and initializes the control parameters</p></a></li>
<li><a href='#rlgtfit'><p>rlgtfit class</p></a></li>
<li><a href='#umcsent.example'><p>University of Michigan Monthly Survey of Consumer Sentiment  &amp; Google Trends Queries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Exponential Smoothing Models with Trend Modifications</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cbergmeir/Rlgt">https://github.com/cbergmeir/Rlgt</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-16</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of a number of Global Trend models for time series forecasting 
    that are Bayesian generalizations and extensions of some Exponential Smoothing models. 
    The main differences/additions include 1) nonlinear global trend, 2) Student-t error 
    distribution, and 3) a function for the error size, so heteroscedasticity. The methods 
    are particularly useful for short time series. When tested on the well-known M3 dataset,
    they are able to outperform all classical time series algorithms. The models are fitted 
    with MCMC using the 'rstan' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp (&ge; 0.12.0), methods, rstantools, forecast,
truncnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.26.0), sn</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.26.0), rstan (&ge; 2.26.0), BH (&ge; 1.66.0),
Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0), RcppParallel (&ge;
5.0.2)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, foreach, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-16 12:54:16 UTC; bergmeir</td>
</tr>
<tr>
<td>Author:</td>
<td>Slawek Smyl [aut],
  Christoph Bergmeir [aut, cre],
  Erwin Wibowo [aut],
  To Wang Ng [aut],
  Xueying Long [aut],
  Alexander Dokumentov [aut],
  Daniel Schmidt [aut],
  Trustees of Columbia University [cph] (tools/make_cpp.R,
    R/stanmodels.R)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christoph Bergmeir &lt;christoph.bergmeir@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-16 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rlgt-package'>Getting started with the Rlgt package</h2><span id='topic+Rlgt-package'></span><span id='topic+Rlgt'></span>

<h3>Description</h3>

<p>An implementation of Bayesian ETS models named
LGT (for non-seasonal time series data) and SGT (for seasonal time series data).
These models have been tested on the M3 competition dataset in which they 
outperform all of the models originally participating in the competition.
</p>


<h3>Getting started</h3>

<p>The best way to get started with the package is to have a look at the vignettes and the various demos that ship with the package. 
There is a vignette with examples of how to use the various methods included in the package, and a vignette that discusses some of the
theoretical background.
</p>
<p>As to the demos, you can find their source code in the &quot;demo&quot; subfolder in the package sources (available on CRAN). 
There are some basic demos and other more advanced ones that run on subsets of the M3 dataset and run potentially for hours.
</p>
<p>The package contains models for seasonal and non-seasonal data, allows for external regressors, and different 
error distributions. In the following, we briefly also present some of the theoretical background of the methods.
</p>


<h3>LGT (Local and Global Trend)</h3>

<p>The LGT model is constructed based on Holt’s linear trend method. 
The model is designed to allow for a more general term of error by allowing 
for heteroscedasticity and an addition of constant &quot;global&quot; trend in the model.
</p>


<h4>Model Equations</h4>

<p>In terms of mathematical notation, the model can be fully represented as follows:
</p>
<p style="text-align: center;"><code class="reqn">y_{t+1} \sim Student (\nu,y_{t+1}, \sigma _{t+1}) \quad (eq.1.1)</code>
</p>
   
<p style="text-align: center;"><code class="reqn">\widehat{y}_{t+1}=l_{t}+ \gamma l_{t}^{ \rho }+ \lambda b_{t}  \quad  (eq. 1.2)</code>
</p>

<p style="text-align: center;"><code class="reqn">l_{t+1}= \alpha y_{t+1}+ \left( 1- \alpha  \right)  \left(  l_{t} \right) \quad (eq. 1.3)</code>
</p>
 
<p style="text-align: center;"><code class="reqn">b_{t+1}= \beta  \left( l_{t+1}-l_{t} \right) + \left( 1- \beta  \right) b_{t}  \quad  (eq. 1.4)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \widehat{\sigma}_{t+1}= \sigma l_{t}^{ \tau}+ \xi   \quad  (eq. 1.5) </code>
</p>




<h4>Notations</h4>


<dl>
<dt><code class="reqn">y_{t}</code></dt><dd><p>value of the dependent variable of interest at time t</p>
</dd>
<dt><code class="reqn">\widehat{y}_{t+1}</code></dt><dd><p>forecasted value of y at time t+1 given information up to time t</p>
</dd>
<dt><code class="reqn">\widehat{\sigma}_{t+1}</code></dt><dd><p>forecasted deviation at time t+1 given information up to time t</p>
</dd>
<dt><code class="reqn">l_{t}</code></dt><dd><p>level at time t</p>
</dd>
<dt><code class="reqn">b_{t}</code></dt><dd><p>local trend at time t</p>
</dd>
</dl>




<h4>Parameters</h4>


<dl>
<dt><code class="reqn">\nu</code></dt><dd><p>degrees of freedom of the t-distribution</p>
</dd>
<dt><code class="reqn">\gamma</code></dt><dd><p>coefficient of the global trend</p>
</dd>
<dt><code class="reqn">\rho</code></dt><dd><p>power coefficient of the global trend</p>
</dd>
<dt><code class="reqn">\lambda</code></dt><dd><p>damping coefficient of the local trend</p>
</dd>
<dt><code class="reqn">\alpha</code></dt><dd><p>smoothing parameter for the level term</p>
</dd>
<dt><code class="reqn">\beta</code></dt><dd><p>smoothing parameter for the local trend term</p>
</dd>
<dt><code class="reqn">\sigma</code></dt><dd><p>coefficient of the size of error function</p>
</dd>
<dt><code class="reqn">\tau</code></dt><dd><p>power coefficient of the size of error function</p>
</dd>
<dt><code class="reqn">\xi</code></dt><dd><p>base or minimum value of the size of error function</p>
</dd>
</dl>




<h3>SGT (Seasonal, Global Trend)</h3>

<p>The SGT model was designed as a seasonal counterpart to the LGT model. 
Similar to LGT, this model is devised to allow for a global trend term and heteroscedastic error.
</p>


<h4>Model Equations</h4>

<p style="text-align: center;"><code class="reqn"> y_{t+1} \sim Student \left( \nu,\widehat{y}_{t+1}, \sigma _{t+1} \right)  \quad (eq. 2.1) </code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \widehat{y}_{t+1}= \left( l_{t}+ \gamma l_{t}^{ \rho } \right)  s_{t+1} \quad (eq. 2.2)</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> l_{t+1}= \alpha  \frac{y_{t+1}}{s_{t+1}}+ \left( 1- \alpha  \right)  \left( l_{t} \right) \quad (eq. 2.3)</code>
</p>
  
<p style="text-align: center;"><code class="reqn"> s_{t+m+1}= \zeta  \frac{y_{t+1}}{l_{t+1}}+ \left( 1- \zeta  \right) s_{t+1}  \quad (eq. 2.4)</code>
</p>

<p style="text-align: center;"><code class="reqn"> \widehat{\sigma}_{t+1}= \sigma \widehat{y}_{t+1}^{ \tau}+ \xi \quad (eq. 2.5)</code>
</p>




<h4>Additional Notations</h4>


<dl>
<dt><code class="reqn">s_{t}</code></dt><dd><p>seasonality factor at time t</p>
</dd>
<dt><code class="reqn"> m </code></dt><dd><p>number of seasons in the data (e.g. 12 for monthly, 4 for quarterly)</p>
</dd>
</dl>




<h4>Additional Parameters</h4>


<dl>
<dt><code class="reqn">\zeta</code></dt><dd><p>smoothing parameter for the seasonality terms</p>
</dd>
</dl>




<h3>S2GT (Double Seasonal, Global Trend)</h3>

<p>S2GT is designed as an extension to SGT for time series data which exhibit two seasonality patterns. 
</p>


<h4>Model Equations</h4>

<p style="text-align: center;"><code class="reqn"> y_{t+1} \sim Student \left( \nu,\widehat{y}_{t+1}, \sigma _{t+1} \right) \quad (eq. 3.1)</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \widehat{y}_{t+1}=\left( l_{t}+ \gamma l_{t}^{ \rho } \right) s_{t+1}w_{t+1} \quad (eq. 3.2)</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> l_{t}= \alpha  \frac{y_{t}}{s_{t}w_{t}}+ \left( 1- \alpha  \right) \left( l_{t-1} \right)  \quad (eq. 3.3)</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> s_{t+m}= \zeta  \frac{y_{t}}{l_{t}w_{t}}+ \left( 1- \zeta  \right) s_{t} \quad (eq. 3.4)</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> w_{t+d}= \delta  \frac{y_{t}}{l_{t}s_{t}}+ \left( 1- \delta  \right) w_{t} \quad (eq. 3.5)</code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \widehat{\sigma} _{t+1}= \sigma y_{t+1}^{ \tau}+ \xi  \quad (eq. 3.6)</code>
</p>
 



<h4>Additional Notations</h4>


<dl>
<dt><code class="reqn">w_{t}</code></dt><dd><p>second seasonality factor prevailing at time t</p>
</dd>
<dt><code class="reqn">d</code></dt><dd><p>number of (second) seasons in a complete period (e.g. 12 for monthly, 4 for quarterly)</p>
</dd>
</dl>




<h4>Additional Parameters</h4>


<dl>
<dt><code class="reqn">\delta</code></dt><dd><p>smoothing parameters for the second seasonality factors</p>
</dd>
</dl>




<h3>NA</h3>

<p>The best way to get started with the package is to have a look at the vignettes and the various demos that ship with the package. 
There is a vignette with examples of how to use the various methods included in the package, and a vignette that discusses some of the
theoretical background.
</p>
<p>As to the demos, you can find their source code in the &quot;demo&quot; subfolder in the package sources (available on CRAN). 
There are some basic demos and other more advanced ones that run on subsets of the M3 dataset and run potentially for hours.
</p>
<p>The package contains models for seasonal and non-seasonal data, allows for external regressors, and different 
error distributions. In the following, we briefly also present some of the theoretical background of the methods.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Christoph Bergmeir <a href="mailto:christoph.bergmeir@monash.edu">christoph.bergmeir@monash.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Slawek Smyl <a href="mailto:slaweks@hotmail.co.uk">slaweks@hotmail.co.uk</a>
</p>
</li>
<li><p> Erwin Wibowo <a href="mailto:rwinwibowo@gmail.com">rwinwibowo@gmail.com</a>
</p>
</li>
<li><p> To Wang Ng <a href="mailto:edwinnglabs@gmail.com">edwinnglabs@gmail.com</a>
</p>
</li>
<li><p> Xueying Long <a href="mailto:xueying.long@monash.edu">xueying.long@monash.edu</a>
</p>
</li>
<li><p> Alexander Dokumentov <a href="mailto:alexander.dokumentov@gmail.com">alexander.dokumentov@gmail.com</a>
</p>
</li>
<li><p> Daniel Schmidt <a href="mailto:daniel.schmidt@monash.edu">daniel.schmidt@monash.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Trustees of Columbia University (tools/make_cpp.R, R/stanmodels.R) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cbergmeir/Rlgt">https://github.com/cbergmeir/Rlgt</a>
</p>
</li></ul>


<hr>
<h2 id='blgt.multi.forecast'>Rlgt LSGT Gibbs run in parallel</h2><span id='topic+blgt.multi.forecast'></span>

<h3>Description</h3>

<p>Fit a list of series and produce forecast, then calculate the accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blgt.multi.forecast(
  train,
  future,
  n.samples = 20000,
  burnin = 10000,
  parallel = T,
  m = 1,
  homoscedastic = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blgt.multi.forecast_+3A_train">train</code></td>
<td>
<p>A list of training series.</p>
</td></tr>
<tr><td><code id="blgt.multi.forecast_+3A_future">future</code></td>
<td>
<p>A list of corresponding future values of the series.</p>
</td></tr>
<tr><td><code id="blgt.multi.forecast_+3A_n.samples">n.samples</code></td>
<td>
<p>The number of samples to sample from the posterior (the default is 2e4).</p>
</td></tr>
<tr><td><code id="blgt.multi.forecast_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn in samples (the default is 1e4).</p>
</td></tr>
<tr><td><code id="blgt.multi.forecast_+3A_parallel">parallel</code></td>
<td>
<p>Whether run in parallel or not (Boolean value only, default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="blgt.multi.forecast_+3A_m">m</code></td>
<td>
<p>The seasonality period, with default <code>m=1</code>, i.e., no seasonality specified.</p>
</td></tr>
<tr><td><code id="blgt.multi.forecast_+3A_homoscedastic">homoscedastic</code></td>
<td>
<p>Run with homoscedastic or heteroscedastic version of the Gibbs sampler version. By default it is set to <code>FALSE</code>, i.e., run a heteroscedastic model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a forecast object compatible with the forecast package in R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: demo(exampleScript)
## Not run: 
## Build data and test
library(Mcomp)
M3.data &lt;- subset(M3,"yearly")

train.data = list()
future.data = list()
for (i in 1:645)
{
  train.data[[i]] = as.numeric(M3.data[[i]]$x)
  future.data[[i]] = as.numeric(M3.data[[i]]$xx)  
}

## Test -- change below to test more series
w.series = 1:20
# w.series = 1:645        # uncomment to test all series

# use 10,000 posterior samples; change n.samples to 20,000 to test that as well if you want
s = system.time({
  rv=blgt.multi.forecast(train.data[w.series], future.data[w.series], n.samples=1e4)
})

s                         # overall timing info
s[[3]] / length(w.series) # per series time

mean(rv$sMAPE)            # performance in terms of mean sMAPE
mean(rv$InCI)/6           # coverage of prediction intervals -- should be close to 95%

## End(Not run)
</code></pre>

<hr>
<h2 id='forecast.rlgtfit'>Rlgt forecast</h2><span id='topic+forecast.rlgtfit'></span>

<h3>Description</h3>

<p>produce forecasts from an <code><a href="#topic+rlgtfit">rlgtfit</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlgtfit'
forecast(
  object,
  xreg = NULL,
  h = ifelse(frequency(object$x) &gt; 1, 2 * frequency(object$x), 10),
  level = c(80, 95),
  NUM_OF_TRIALS = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.rlgtfit_+3A_object">object</code></td>
<td>
<p>rlgtfit object</p>
</td></tr>
<tr><td><code id="forecast.rlgtfit_+3A_xreg">xreg</code></td>
<td>
<p>input regression matrix</p>
</td></tr>
<tr><td><code id="forecast.rlgtfit_+3A_h">h</code></td>
<td>
<p>forecasting horizon (the default is 10 for annual and 2*periods otherwise)</p>
</td></tr>
<tr><td><code id="forecast.rlgtfit_+3A_level">level</code></td>
<td>
<p>confidence levels for prediction intervals a.k.a. coverage percentiles. Musat be between 0 and 100.</p>
</td></tr>
<tr><td><code id="forecast.rlgtfit_+3A_num_of_trials">NUM_OF_TRIALS</code></td>
<td>
<p>number of simulations to run. Suggested range is between (1000,5000), but it needs 
to be higher for good coverage for very high levels, e.g. 99.8.</p>
</td></tr>
<tr><td><code id="forecast.rlgtfit_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a forecast object compatible with the forecast package in R
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example that runs within a few seconds. To get good 
# fitting results the number of iterations should be set to at least 2000, and 
# 4 chains should be used (the default). To speed up computation the number of 
# cores should also be adjusted (default is 4).

rlgt_model &lt;- rlgt(lynx, 
       control=rlgt.control(MAX_NUM_OF_REPEATS=1, NUM_OF_ITER=50, NUM_OF_CHAINS = 1, 
                            NUM_OF_CORES = 1), verbose=TRUE)

# print the model details
print(rlgt_model)

# Produce Forecasts for the next 10 years
forecast_result &lt;- forecast(rlgt_model, h = 10, level=c(80, 95, 98))

plot(forecast_result,main="Forecasting lynx dataset with LGT model")

</code></pre>

<hr>
<h2 id='iclaims.example'>Weekly Initial Claims of US Unemployment Benefits &amp; Google Trends Queries</h2><span id='topic+iclaims.example'></span>

<h3>Description</h3>

<p>A dataset containing the weekly initial claims for US unemployment benefits against 
a few related Google trend queries from Jan 2010 - June 2018. 
This aims to mimick the dataset from Scott and Varian (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("iclaims.example")
</code></pre>


<h3>Format</h3>

<p>A data frame with 443 rows and 5 variables with log-transformation
</p>

<dl>
<dt>week</dt><dd><p>date of records starting by Mondays with US calendar format</p>
</dd>
<dt>claims</dt><dd><p>weekly initial claims of unemployment benefits in thousands</p>
</dd>
<dt>trend.unemploy</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
<dt>trend.filling</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
<dt>trend.job</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
</dl>



<h3>References</h3>

<p>U.S. Employment and Training Administration, Initial Claims [ICNSA], retrieved from FRED, Federal Reserve Bank of St. Louis; 
<a href="https://fred.stlouisfed.org/series/ICNSA">https://fred.stlouisfed.org/series/ICNSA</a>, October 27, 2018.
</p>
<p>Trend queries from Google search engine. 
<a href="https://trends.google.com/trends/?geo=US">https://trends.google.com/trends/?geo=US</a>
</p>
<p>An interface for retrieving and displaying the information returned online by Google Trends is provided. Trends (number of hits) over the time as well as geographic representation of the results can be displayed.
<a href="https://CRAN.R-project.org/package=gtrendsR">https://CRAN.R-project.org/package=gtrendsR</a>
</p>
<p>Scott, S. L. and Varian, H. R. (2014). Predicting the Present with Bayesian Structural Time Series.
International Journal of Mathematical Modeling and Optimization 5 4–23.
</p>

<hr>
<h2 id='initModel'>Initialize a model from the Rlgt family</h2><span id='topic+initModel'></span>

<h3>Description</h3>

<p>This is an internal function that usually won't be called by users directly. It validates the model type and generates the corresponding list of parameters for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initModel(
  model.type = NULL,
  use.regression = FALSE,
  seasonalityMethodId = 0,
  levelMethodId = 0,
  useSmoothingMethodForError = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initModel_+3A_model.type">model.type</code></td>
<td>
<p>type of the forecasting model selected, a character object</p>
</td></tr>
<tr><td><code id="initModel_+3A_use.regression">use.regression</code></td>
<td>
<p>binary parameter indicating whether additional regressors will be used for forecasting in multivariate settings.</p>
</td></tr>
<tr><td><code id="initModel_+3A_seasonalitymethodid">seasonalityMethodId</code></td>
<td>
<p>Seasonality method Id (0- HW, 1- generalized).</p>
</td></tr>
<tr><td><code id="initModel_+3A_levelmethodid">levelMethodId</code></td>
<td>
<p>Level method Id.</p>
</td></tr>
<tr><td><code id="initModel_+3A_usesmoothingmethodforerror">useSmoothingMethodForError</code></td>
<td>
<p>if the non-standard function for error size should be used, one based on smoothed innovations or surprises</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an Rlgt skeleton model
</p>

<hr>
<h2 id='posterior_interval.rlgtfit'>rlgtfit posterior interval</h2><span id='topic+posterior_interval.rlgtfit'></span>

<h3>Description</h3>

<p>This is a method of the <code>link{rlgtfit}</code> class to produce posterior intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlgtfit'
posterior_interval(object, prob = 0.9, type = "central", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_interval.rlgtfit_+3A_object">object</code></td>
<td>
<p>an object of class rlgtfit</p>
</td></tr>
<tr><td><code id="posterior_interval.rlgtfit_+3A_prob">prob</code></td>
<td>
<p>percentile level to be generated (multiple values can be accepted as a vector)</p>
</td></tr>
<tr><td><code id="posterior_interval.rlgtfit_+3A_type">type</code></td>
<td>
<p>currently only central is available</p>
</td></tr>
<tr><td><code id="posterior_interval.rlgtfit_+3A_...">...</code></td>
<td>
<p>currently not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>confidence interval
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example that runs within a few seconds. To get good 
# fitting results the number of iterations should be set to at least 2000, and 
# 4 chains should be used (the default). To speed up computation the number of 
# cores should also be adjusted (default is 4).

rlgt_model &lt;- rlgt(lynx, 
       control=rlgt.control(MAX_NUM_OF_REPEATS=1, NUM_OF_ITER=50, NUM_OF_CHAINS = 1, 
                            NUM_OF_CORES = 1), verbose=TRUE)

# print the model details
posterior_interval(rlgt_model)
</code></pre>

<hr>
<h2 id='print.rlgtfit'>Generic print function for rlgtfit models</h2><span id='topic+print.rlgtfit'></span><span id='topic+summary.rlgt'></span>

<h3>Description</h3>

<p>Print out some characteristics of an <code><a href="#topic+rlgtfit">rlgtfit</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlgtfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rlgtfit_+3A_x">x</code></td>
<td>
<p>an rlgtfit object</p>
</td></tr>
<tr><td><code id="print.rlgtfit_+3A_...">...</code></td>
<td>
<p>additional function parameters (currently not used)</p>
</td></tr>
</table>

<hr>
<h2 id='rlgt'>Fit an Rlgt model</h2><span id='topic+rlgt'></span>

<h3>Description</h3>

<p>The main function to fit an rlgt model. It fits the parameter values with MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlgt(
  y,
  seasonality = 1,
  seasonality2 = 1,
  seasonality.type = c("multiplicative", "generalized"),
  error.size.method = c("std", "innov"),
  level.method = c("HW", "seasAvg", "HW_sAvg"),
  xreg = NULL,
  control = rlgt.control(),
  verbose = FALSE,
  method = "Stan",
  experimental = "",
  homoscedastic = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlgt_+3A_y">y</code></td>
<td>
<p>time-series data for training (provided as a numeric vector, or a ts, or msts object).</p>
</td></tr>
<tr><td><code id="rlgt_+3A_seasonality">seasonality</code></td>
<td>
<p>This specification of seasonality will be overridden by frequency of y, if y is of ts or msts class. 
1 by default, i.e. no seasonality.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_seasonality2">seasonality2</code></td>
<td>
<p>Second seasonality. If larger than 1, a dual seasonality model will be used. 
However, this is experimental. If not specified and multiple seasonality time series (of msts class) is used,
a single seasonality model will be applied, one with seasonality equal to the largest of seasonalities of the time series. 
1 by default, i.e. no seasonality or single seasonality.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_seasonality.type">seasonality.type</code></td>
<td>
<p>Either &quot;multiplicative&quot; (default) or &quot;generalized&quot;. 
The latter seasonality generalizes additive and multiplicative seasonality types.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_error.size.method">error.size.method</code></td>
<td>
<p>Function providing size of the error. Either &quot;std&quot; (monotonically, but slower than proportionally, growing with the series values) or 
&quot;innov&quot; (proportional to a smoothed abs size of innovations, i.e. surprises)</p>
</td></tr>
<tr><td><code id="rlgt_+3A_level.method">level.method</code></td>
<td>
<p>&quot;HW&quot;,  &quot;seasAvg&quot;, &quot;HW_sAvg&quot;. Here, &quot;HW&quot; follows Holt-Winters approach. 
&quot;seasAvg&quot; calculates level as a smoothed average of the last seasonality number of points (or seasonality2 of them for the dual seasonality model),
and HW_sAvg is an weighted average of HW and seasAvg methods.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_xreg">xreg</code></td>
<td>
<p>Optionally, a vector or matrix of external regressors, which must have the same number of rows as y.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_control">control</code></td>
<td>
<p>list of control parameters, e.g. hyperparameter values for the model's prior distributions, number of fitting interations etc.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_verbose">verbose</code></td>
<td>
<p>whether verbose information should be printed (Boolean value only), default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_method">method</code></td>
<td>
<p>Sampling method, default <code>Stan</code>.</p>
</td></tr>
<tr><td><code id="rlgt_+3A_experimental">experimental</code></td>
<td>
<p>Run different versions (&quot;nostudent&quot;, &quot;noglobal&quot;, &quot;nohet&quot;, &quot;ets&quot;) for ablation studies</p>
</td></tr>
<tr><td><code id="rlgt_+3A_homoscedastic">homoscedastic</code></td>
<td>
<p>Run with homoscedastic or heteroscedastic version of the Gibbs sampler version. By default it is set to <code>FALSE</code>, i.e., run a heteroscedastic model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+rlgtfit">rlgtfit</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example that runs within a few seconds. To get good 
# fitting results the number of iterations should be set to at least 2000, and 
# 4 chains should be used (the default). To speed up computation the number of 
# cores should also be adjusted (default is 4).

rlgt_model &lt;- rlgt(lynx, 
       control=rlgt.control(MAX_NUM_OF_REPEATS=1, NUM_OF_ITER=50, NUM_OF_CHAINS = 1, 
                            NUM_OF_CORES = 1), verbose=TRUE)

# print the model details
print(rlgt_model)

## Not run: demo(exampleScript)

</code></pre>

<hr>
<h2 id='rlgt.control'>Sets and initializes the control parameters</h2><span id='topic+rlgt.control'></span>

<h3>Description</h3>

<p>This function initializes and sets the control parameters, i.e. 
hyperparameter values which control the prior distribution of the <code><a href="#topic+rlgtfit">rlgtfit</a></code> model. 
The purpose of this function is mainly to provide a default value for each of the hyperparameters. 
The function also accepts a customised set of values of the parameters as provided in the input of this function. 
This function is used in conjunction with the <code><a href="#topic+rlgt">rlgt</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlgt.control(
  ADAPT_DELTA = 0.9,
  MAX_TREE_DEPTH = 12,
  NUM_OF_CHAINS = 4,
  NUM_OF_CORES = 4,
  ADD_JITTER = TRUE,
  CAUCHY_SD_DIV = 150,
  NUM_OF_ITER = 5000,
  MAX_NUM_OF_REPEATS = 2,
  MAX_RHAT_ALLOWED = 1.006,
  NUM_OF_SEASON_INIT_CYCLES = 3,
  MIN_NU = 2,
  MAX_NU = 20,
  MIN_POW_TREND = -0.5,
  MAX_POW_TREND = 1,
  POW_TREND_ALPHA = 1,
  POW_TREND_BETA = 1,
  POW_SEASON_ALPHA = 1,
  POW_SEASON_BETA = 1,
  MIN_SIGMA = 1e-10,
  MIN_VAL = 1e-30,
  MAX_VAL = 1e+38
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlgt.control_+3A_adapt_delta">ADAPT_DELTA</code></td>
<td>
<p>Target Metropolis acceptance rate. See Stan manual. Suggested range is between (0.85-0.97).</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_max_tree_depth">MAX_TREE_DEPTH</code></td>
<td>
<p>NUTS maximum tree depth. See Stan manual for more details. Suggested range is between (10-15), defaut is 12.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_num_of_chains">NUM_OF_CHAINS</code></td>
<td>
<p>Number of MCMC chains. Suggested range is 3 to 4. Default is 4.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_num_of_cores">NUM_OF_CORES</code></td>
<td>
<p>Number of cores used for calculations. It can be smaller than NUM_OF_CHAINS, 
but for best computational speed, it should be equal to NUM_OF_CHAINS. Default is 4.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_add_jitter">ADD_JITTER</code></td>
<td>
<p>Whether to add a very small amount (sd=min(y)*0.0001) of jitter to the input series. 
It is sometimes useful in cases of series with some perfectly flat sections. Default is TRUE.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_cauchy_sd_div">CAUCHY_SD_DIV</code></td>
<td>
<p>Cauchy distribution is used for some parameters with non-obvious range. The error size hyperparameter 
of this distribution is calculated by dividing the max value of the time series by this constant. 
Suggested range is between (100,300). Default 150.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_num_of_iter">NUM_OF_ITER</code></td>
<td>
<p>Starting number of iterations for each chain. Suggested range is between (2000,10000). Default is 5000.
Generally, the longer the series, the smaller is the value to reach convergence. 
Some models e.g. those with &quot;innov&quot; error size method are more difficult to fit and require more iterations.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_max_num_of_repeats">MAX_NUM_OF_REPEATS</code></td>
<td>
<p>Maximum number of the sampling procedure repeats if the fit is unsatisfactorily, i.e. avgRHat&gt;MAX_RHAT_ALLOWED.
Each round will double the number of iterations which could potentially double the running time. 
Suggested range is between (2,4). Default is 2.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_max_rhat_allowed">MAX_RHAT_ALLOWED</code></td>
<td>
<p>Maximum average value of Rhat's that suggests a good fit, i.e. the treshold 
below which the fit is considered as acceptable. Consult Stan's manual for more details on Rhat. 
Suggested range is between (1.005,1.02). Default is 1.006.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_num_of_season_init_cycles">NUM_OF_SEASON_INIT_CYCLES</code></td>
<td>
<p>For seasonal models, number of seasonality periods used for establishing initial seasonality coefficients. Default is 3.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_min_nu">MIN_NU</code></td>
<td>
<p>Minimum degrees of freedom of the Student's distribution that is used in most models. Suggested range(1.2, 5). Default 2.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_max_nu">MAX_NU</code></td>
<td>
<p>Maximum degrees of freedom of the Student's distribution. Suggested range is between (15,30). Default 20.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_min_pow_trend">MIN_POW_TREND</code></td>
<td>
<p>Minimum value of the global trend power coefficient. Suggested range is between (-1,0). Default -.5</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_max_pow_trend">MAX_POW_TREND</code></td>
<td>
<p>Maximum value of the global trend power coefficient. It should be 1 to allow the model to approach exponential growth when needed.
Default is 1.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_pow_trend_alpha">POW_TREND_ALPHA</code></td>
<td>
<p>Alpha parameter of Beta prior distribution.
To make the forecast more upward curved, so to nudge it towards larger values, make the parameter larger. Suggested range is between (1,6)
Default 1.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_pow_trend_beta">POW_TREND_BETA</code></td>
<td>
<p>Beta parameter of  Beta prior distribution for the global trend power coefficient. 1 by default, see also above.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_pow_season_alpha">POW_SEASON_ALPHA</code></td>
<td>
<p>Alpha parameter of Beta distribution that is the prior of the power coefficient in the formula of the generalized seasonality in gSGT model. 
1 by default, increasing it (say, to 3 or 5) will push the seasonality towards multiplicative behavior.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_pow_season_beta">POW_SEASON_BETA</code></td>
<td>
<p>Beta parameter of Beta distribution that is the prior of the power coefficient in the formula of the generalized seasonality in gSGT model. 
1 by default.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_min_sigma">MIN_SIGMA</code></td>
<td>
<p>Minimum size of the fitted sigma, applied for numerical stability. Must be positive. 1e-10 by default.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_min_val">MIN_VAL</code></td>
<td>
<p>Minimum value that forecast can take. Must be positive. 1e-30 by default.</p>
</td></tr>
<tr><td><code id="rlgt.control_+3A_max_val">MAX_VAL</code></td>
<td>
<p>Maximum value the forecast can take. 1e38 by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of control parameters
</p>

<hr>
<h2 id='rlgtfit'>rlgtfit class</h2><span id='topic+rlgtfit'></span>

<h3>Description</h3>

<p>A constructor function for objects of class <code>rlgtfit</code>, the main class of the package. Objects of this class 
are output from the <code><a href="#topic+rlgt">rlgt</a></code> function. This constructor will usually not be called by users directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlgtfit(
  y,
  model.type,
  use.regression,
  seasonalityMethodId,
  levelMethodId,
  useSmoothingMethodForError = FALSE,
  seasonality,
  seasonality2,
  rlgtmodel,
  params,
  control,
  samples
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlgtfit_+3A_y">y</code></td>
<td>
<p>time series data for training (provided as a vector or a ts object).</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_model.type">model.type</code></td>
<td>
<p>the type of rlgt model, one of: &quot;LGT&quot;, &quot;SGT&quot;, &quot;S2GT&quot;</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_use.regression">use.regression</code></td>
<td>
<p>whether the data has any additional variables to be used with forecasting, i.e. multivariate time-series.</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_seasonalitymethodid">seasonalityMethodId</code></td>
<td>
<p>Seasonality method Id (0- HW, 1- generalized).</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_levelmethodid">levelMethodId</code></td>
<td>
<p>Level method Id.</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_usesmoothingmethodforerror">useSmoothingMethodForError</code></td>
<td>
<p>if the non-standard function for error size should be used, one based on smoothed innovations or surprises</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_seasonality">seasonality</code></td>
<td>
<p>This specification of seasonality will be overridden by frequency of y, if y is of ts or msts class. 
1 by default, i.e. no seasonality.</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_seasonality2">seasonality2</code></td>
<td>
<p>Second seasonality. If larger than 1, a dual seasonality model will be used. 
This specification of seasonality will be overridden by the second seasonality of y, if y is of msts class. 
1 by default, i.e. no seasonality or single seasonality.</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_rlgtmodel">rlgtmodel</code></td>
<td>
<p>an rlgt model.</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_params">params</code></td>
<td>
<p>list of parameters of the model (to be fitted).</p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_control">control</code></td>
<td>
<p>list of control parameters, i.e. hyperparameter values 
for the model's prior distribution. See <code><a href="#topic+rlgt.control">rlgt.control</a></code></p>
</td></tr>
<tr><td><code id="rlgtfit_+3A_samples">samples</code></td>
<td>
<p>stanfit object representing the MCMC samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an rlgtfit instance
</p>

<hr>
<h2 id='umcsent.example'>University of Michigan Monthly Survey of Consumer Sentiment  &amp; Google Trends Queries</h2><span id='topic+umcsent.example'></span>

<h3>Description</h3>

<p>A dataset containing monthly University of Michigan survey of Consumer Sentiment
along a few related google trend queries Jan from 2014 - June 2018. 
This aims to mimick the dataset from Scott and Varian (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("umcsent.example")
</code></pre>


<h3>Format</h3>

<p>A data frame with 174 rows and 8 variables with log-transformation
</p>

<dl>
<dt>date</dt><dd><p>first date of each month in US calendar format</p>
</dd>
<dt>consumer.sent</dt><dd><p>monthly initial claims of University of Michigan: Consumer Sentiment</p>
</dd>
<dt>search.engine</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
<dt>financial.planning</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
<dt>bus.news</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
<dt>investing</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
<dt>energy.utilities</dt><dd><p>normalized trend queries retreived from gtrendsR API</p>
</dd>
</dl>



<h3>References</h3>

<p>University of Michigan, University of Michigan: Consumer Sentiment [UMCSENT], retrieved from FRED, Federal Reserve Bank of St. Louis; 
<a href="https://fred.stlouisfed.org/series/UMCSENT">https://fred.stlouisfed.org/series/UMCSENT</a>, November 17, 2018.
</p>
<p>Trends queries from google search engine. 
<a href="https://trends.google.com/trends/?geo=US">https://trends.google.com/trends/?geo=US</a>
</p>
<p>An interface for retrieving and displaying the information returned online by Google Trends is provided. Trends (number of hits) over the time as well as geographic representation of the results can be displayed.
<a href="https://CRAN.R-project.org/package=gtrendsR">https://CRAN.R-project.org/package=gtrendsR</a>
</p>
<p>Scott, S. L. and Varian, H. R. (2012). Bayesian Variable Selection for Nowcasting Economic Time Series.
<a href="https://www.aeaweb.org/conference/2013/retrieve.php?pdfid=447">https://www.aeaweb.org/conference/2013/retrieve.php?pdfid=447</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
