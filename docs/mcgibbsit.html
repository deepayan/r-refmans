<!DOCTYPE html><html><head><title>Help for package mcgibbsit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcgibbsit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcgibbsit'><p>Warnes and Raftery's MCGibbsit MCMC diagnostic</p></a></li>
<li><a href='#read.mcmc'><p>Read in data from a set of MCMC runs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Warnes and Raftery's 'MCGibbsit' MCMC Run Length and Convergence
Diagnostic</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory R. Warnes &lt;greg@warnes.net&gt;, Robert Burrows</td>
</tr>
<tr>
<td>Depends:</td>
<td>coda</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Implementation of Warnes &amp; Raftery's MCGibbsit run-length and 
  convergence diagnostic for a set of (not-necessarily independent) 
  Markov Chain Monte Carlo (MCMC) samplers.  It combines the quantile 
  estimate error-bounding approach of the Raftery and Lewis MCMC run
  length diagnostic 'gibbsit' with the between verses within chain 
  approach of the Gelman and Rubin MCMC convergence diagnostic.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory R. Warnes &lt;greg@warnes.net&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-gregmisc/mcgibbsit">https://github.com/r-gregmisc/mcgibbsit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-gregmisc/mcgibbsit/issues">https://github.com/r-gregmisc/mcgibbsit/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-24 21:53:49 UTC; warnes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-25 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcgibbsit'>Warnes and Raftery's MCGibbsit MCMC diagnostic</h2><span id='topic+mcgibbsit'></span><span id='topic+print.mcgibbsit'></span>

<h3>Description</h3>

<p><code>mcgibbsit</code> provides an implementation of Warnes &amp; Raftery's MCGibbsit
run-length diagnostic for a set of (not-necessarily independent) MCMC
samplers.  It combines the estimate error-bounding approach of Raftery and
Lewis with the between chain variance verses within chain variance approach
of Gelman and Rubin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcgibbsit(
  data,
  q = 0.025,
  r = 0.0125,
  s = 0.95,
  converge.eps = 0.001,
  correct.cor = TRUE
)

## S3 method for class 'mcgibbsit'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcgibbsit_+3A_data">data</code></td>
<td>
<p>an &lsquo;mcmc&rsquo; object.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_q">q</code></td>
<td>
<p>quantile(s) to be estimated.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_r">r</code></td>
<td>
<p>the desired margin of error of the estimate.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_s">s</code></td>
<td>
<p>the probability of obtaining an estimate in the interval</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_converge.eps">converge.eps</code></td>
<td>
<p>Precision required for estimate of time to convergence.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_correct.cor">correct.cor</code></td>
<td>
<p>should the between-chain correlation correction (R) be
computed and applied.  Set to false for independent MCMC chains.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="mcgibbsit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcgibbsit</code> computes the minimum run length <code class="reqn">N_{min}</code>,
required burn in <code class="reqn">M</code>, total run length <code class="reqn">N</code>, run length inflation due
to <em>auto-correlation</em>, <code class="reqn">I</code>, and the run length inflation due to
<em>between-chain</em> correlation, <code class="reqn">R</code> for a set of exchangeable MCMC
simulations which need not be independent.
</p>
<p>The normal usage is to perform an initial MCMC run of some pre-determined
length (e.g., 300 iterations) for each of a set of <code class="reqn">k</code> (e.g.,
<code class="reqn">k=20</code>) MCMC samplers.  The output from these samplers is then read in
to create an <code>mcmc.list</code> object and <code>mcgibbsit</code> is run specifying
the desired accuracy of estimation for quantiles of interest.  This will
return the minimum number of iterations to achieve the specified error
bound.  The set of MCMC samplers is now run so that the total number of
iterations exceeds this minimum, and <code>mcgibbsit</code> is again called.  This
should continue until the number of iterations already complete is less than
the minimum number computed by <code>mcgibbsit</code>.
</p>
<p>If the initial number of iterations in <code>data</code> is too small to perform
the calculations, an error message is printed indicating the minimum pilot
run length.
</p>
<p>The parameters <code>q</code>, <code>r</code>, <code>s</code>, <code>converge.eps</code>, and
<code>correct.cor</code> can be supplied as vectors.  This will cause
<code>mcgibbsit</code> to produce a list of results, with one element produced for
each set of values.  I.e., setting <code>q=(0.025,0.975), r=(0.0125,0.005)</code>
will yield a list containing two <code>mcgibbsit</code> objects, one computed with
parameters <code>q=0.025, r=0.0125</code>, and the other with <code>q=0.975,
r=0.005</code>.
</p>


<h3>Value</h3>

<p>An <code>mcgibbsit</code> object with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>parameters used to call 'mcgibbsit'</p>
</td></tr> <tr><td><code>params</code></td>
<td>
<p>values of r,
s, and q used</p>
</td></tr> <tr><td><code>resmatrix</code></td>
<td>
<p>a matrix with 6 columns: </p>

<dl>
<dt>Nmin</dt><dd><p>The minimum required sample size for a chain with no correlation
between consecutive samples. Positive autocorrelation will increase the
required sample size above this minimum value.</p>
</dd> <dt>M</dt><dd><p>The number of <code style="white-space: pre;">&#8288;burn in' iterations to be discarded (total over all chains).} \item{N}{The number of iterations after burn in required to estimate the quantile q to within an accuracy of +/- r with probability p (total over all chains).} \item{Total}{Overall number of iterations required (M + N).} \item{I}{An estimate (the &#8288;</code>dependence factor') of the extent to which auto-correlation
inflates the required sample size.  Values of <code style="white-space: pre;">&#8288;I' larger than 5 indicate strong autocorrelation which may be due to a poor choice of starting value, high posterior correlations, or &#8288;</code>stickiness' of the MCMC algorithm.</p>
</dd>
<dt>R</dt><dd><p>An estimate of the extent to which between-chain correlation
inflates the required sample size.  Large values of 'R' indicate that there
is significant correlation between the chains and may be indicative of a
lack of convergence or a poor multi-chain algorithm.</p>
</dd> </dl>
 </td></tr> <tr><td><code>nchains</code></td>
<td>
<p>the
number of MCMC chains in the data</p>
</td></tr> <tr><td><code>len</code></td>
<td>
<p>the length of each chain</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> based on the the R
function <code>raftery.diag</code> which is part of the 'CODA' library.
<code>raftery.diag</code>, in turn, is based on the FORTRAN program &lsquo;gibbsit&rsquo;
written by Steven Lewis which is available from the Statlib archive.
</p>


<h3>References</h3>

<p>Warnes, G.W. (2004). The Normal Kernel Coupler: An adaptive MCMC method for
efficiently sampling from multi-modal distributions,
<a href="https://stat.uw.edu/sites/default/files/files/reports/2001/tr395.pdf">https://stat.uw.edu/sites/default/files/files/reports/2001/tr395.pdf</a>
</p>
<p>Warnes, G.W. (2000).  Multi-Chain and Parallel Algorithms for Markov Chain
Monte Carlo. Dissertation, Department of Biostatistics, University of
Washington,
<a href="https://digital.lib.washington.edu/researchworks/handle/1773/9541">https://digital.lib.washington.edu/researchworks/handle/1773/9541</a>
</p>
<p>Raftery, A.E. and Lewis, S.M. (1992).  One long run with diagnostics:
Implementation strategies for Markov chain Monte Carlo. Statistical Science,
7, 493-497.
</p>
<p>Raftery, A.E. and Lewis, S.M. (1995).  The number of iterations, convergence
diagnostics and generic Metropolis algorithms.  In Practical Markov Chain
Monte Carlo (W.R. Gilks, D.J. Spiegelhalter and S. Richardson, eds.).
London, U.K.: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mcmc">read.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
# Create example data files for 20 independent chains
# with serial correlation of 0.25
###

set.seed(42)
tmpdir &lt;- tempdir()

nsamples &lt;- 1000

for(i in 1:20){
  x &lt;- matrix(nrow = nsamples+1, ncol=4)
  colnames(x) &lt;- c("alpha","beta","gamma", "nu")
  
  x[,"alpha"] &lt;- rnorm (nsamples+1, mean=0.025, sd=0.0025)^2
  x[,"beta"]  &lt;- rnorm (nsamples+1, mean=53,    sd=12)
  x[,"gamma"] &lt;- rbinom(nsamples+1, 20,         p=0.25) + 1
  x[,"nu"]    &lt;- rnorm (nsamples+1, mean=x[,"alpha"] * x[,"beta"], sd=1/x[,"gamma"])

  # induce serial correlation of 0.25
  x &lt;- 0.75 * x[2:(nsamples+1),] + 0.25 * x[1:nsamples,]
  
  
  write.table(
    x,
    file = file.path(
      tmpdir,
      paste("mcmc", i, "csv", sep=".")
      ),
    sep = ",",
    row.names = FALSE
  )
}

# Read them back in as an mcmc.list object
data &lt;- read.mcmc(
  20, 
  file.path(tmpdir, "mcmc.#.csv"), 
  sep=",",
  col.names=c("alpha","beta","gamma", "nu")
  )

# Summary statistics
summary(data)

# Trace and Density Plots
plot(data)

# And check the necessary run length 
mcgibbsit(data)


</code></pre>

<hr>
<h2 id='read.mcmc'>Read in data from a set of MCMC runs</h2><span id='topic+read.mcmc'></span>

<h3>Description</h3>

<p>Read in data from a set of MCMC runs and create an <code>mcmc.list</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mcmc(
  nc,
  sourcepattern,
  ...,
  col.names,
  start = 1,
  end = nrow(tmp)/numComponents * thin,
  thin = 1,
  numComponents = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mcmc_+3A_nc">nc</code></td>
<td>
<p>Number of MCMC sampler files to read</p>
</td></tr>
<tr><td><code id="read.mcmc_+3A_sourcepattern">sourcepattern</code></td>
<td>
<p>MCMC data file name pattern.</p>
</td></tr>
<tr><td><code id="read.mcmc_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>read.table</code> when loading MCMC
sampler data.</p>
</td></tr>
<tr><td><code id="read.mcmc_+3A_col.names">col.names</code></td>
<td>
<p>Data file column names (optional)</p>
</td></tr>
<tr><td><code id="read.mcmc_+3A_start">start</code>, <code id="read.mcmc_+3A_end">end</code>, <code id="read.mcmc_+3A_thin">thin</code></td>
<td>
<p>See documentation for <code>mcmc</code></p>
</td></tr>
<tr><td><code id="read.mcmc_+3A_numcomponents">numComponents</code></td>
<td>
<p>Number of component samplers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads in the states output from one or more MCMC samplers and
creates a single <code>mcmc.list</code> object.  <code>sourcepattern</code> will be used
as a filename pattern with <code>#</code> replaced by the sampler number.  EG,
<code>sourcepattern="MCMC.#.csv"</code> will be converted to &quot;MCMC.1.csv&quot;,
&quot;MCMC.2.csv&quot;, etc.
</p>
<p>The function <code>read.table</code> is used to read in the data.  Options for
<code>read.table</code> may be included as part of the call to <code>read.mcmc</code>.
</p>
<p>The <code>start</code>, <code>end</code>, and <code>thin</code> arguments can be used to
annotate the MCMC samplers with additional information.
</p>


<h3>Value</h3>

<p>An mcmc.list object containing <code>nc</code> component <code>mcmc</code>
objects.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+mcmc">mcmc</a></code>, <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>,
<code><a href="utils.html#topic+read.table">read.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
# Create example data files for 20 independent chains
# with serial correlation of 0.
###

set.seed(42)
tmpdir &lt;- tempdir()

for(i in 1:20){
  x &lt;- matrix(rnorm(1000), ncol=4)
  
  x[,4] &lt;- x[,4] + 1/3 * (x[,1] + x[,2] + x[,3])
  
  colnames(x) &lt;- c("alpha","beta","gamma", "nu")
  
  write.table(
    x,
    file = file.path(
      tmpdir,
      paste("mcmc", i, "csv", sep=".")
      ),
    sep = ",",
    row.names=FALSE
  )
}

# Read them back in as an mcmc.list object
data &lt;- read.mcmc(20, file.path(tmpdir, "mcmc.#.csv"), sep=",")

summary(data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
