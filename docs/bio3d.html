<!DOCTYPE html><html><head><title>Help for package bio3d</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bio3d}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bio3d-package'><p> Biological Structure Analysis</p></a></li>
<li><a href='#aa.index'><p> AAindex: Amino Acid Index Database</p></a></li>
<li><a href='#aa.table'><p> Table of Relevant Amino Acids</p></a></li>
<li><a href='#aa123'><p> Convert Between 1-letter and 3-letter Aminoacid Codes</p></a></li>
<li><a href='#aa2index'><p> Convert an Aminoacid Sequence to AAIndex Values</p></a></li>
<li><a href='#aa2mass'><p> Amino Acid Residues to Mass Converter</p></a></li>
<li><a href='#aanma'><p>All Atom Normal Mode Analysis</p></a></li>
<li><a href='#aanma.pdbs'><p>Ensemble Normal Mode Analysis with All-Atom ENM</p></a></li>
<li><a href='#aln2html'><p> Create a HTML Page For a Given Alignment</p></a></li>
<li><a href='#angle.xyz'><p> Calculate the Angle Between Three Atoms</p></a></li>
<li><a href='#as.fasta'><p> Alignment to FASTA object</p></a></li>
<li><a href='#as.pdb'><p> Convert to PDB format</p></a></li>
<li><a href='#as.select'><p> Convert Atomic Indices to a Select Object</p></a></li>
<li><a href='#atom.index'><p> Atom Names/Types</p></a></li>
<li><a href='#atom.select'><p> Atom Selection from PDB and PRMTOP Structure Objects</p></a></li>
<li><a href='#atom2ele'><p> Atom Names/Types to Atomic Symbols Converter</p></a></li>
<li><a href='#atom2mass'><p> Atom Names/Types to Mass Converter</p></a></li>
<li><a href='#atom2xyz'><p> Convert Between Atom and xyz Indices</p></a></li>
<li><a href='#basename.pdb'>
<p>Manipulate PDB File Names</p></a></li>
<li><a href='#bhattacharyya'><p> Bhattacharyya Coefficient</p></a></li>
<li><a href='#binding.site'><p> Binding Site Residues</p></a></li>
<li><a href='#biounit'><p>Biological Units Construction</p></a></li>
<li><a href='#blast.pdb'><p> NCBI BLAST Sequence Search and Summary Plot of Hit Statistics</p></a></li>
<li><a href='#bounds'><p> Bounds of a Numeric Vector</p></a></li>
<li><a href='#bounds.sse'><p>Obtain A SSE Object From An SSE Sequence Vector</p></a></li>
<li><a href='#bwr.colors'><p> Color Palettes</p></a></li>
<li><a href='#cat.pdb'><p> Concatenate Multiple PDB Objects</p></a></li>
<li><a href='#chain.pdb'><p> Find Possible PDB Chain Breaks</p></a></li>
<li><a href='#check.utility'><p> Check on Missing Utility Programs</p></a></li>
<li><a href='#clean.pdb'><p>Inspect And Clean Up A PDB Object</p></a></li>
<li><a href='#cmap'><p> Contact Map</p></a></li>
<li><a href='#cna'><p> Protein Dynamic Correlation Network Construction and Community Analysis.</p></a></li>
<li><a href='#cnapath'><p> Suboptimal Path Analysis for Correlation Networks</p></a></li>
<li><a href='#com'><p> Center of Mass</p></a></li>
<li><a href='#combine.select'><p> Combine Atom Selections From PDB Structure</p></a></li>
<li><a href='#community.aln'><p>Align communities from two or more networks</p></a></li>
<li><a href='#community.tree'><p> Reconstruction of the Girvan-Newman Community Tree for a CNA Class Object.</p></a></li>
<li><a href='#consensus'><p> Sequence Consensus for an Alignment</p></a></li>
<li><a href='#conserv'><p> Score Residue Conservation At Each Position in an Alignment</p></a></li>
<li><a href='#convert.pdb'><p>Renumber and Convert Between Various PDB formats</p></a></li>
<li><a href='#core.cmap'><p> Identification of Contact Map Core Positions</p></a></li>
<li><a href='#core.find'><p> Identification of Invariant Core Positions</p></a></li>
<li><a href='#cov.nma'><p> Calculate Covariance Matrix from Normal Modes</p></a></li>
<li><a href='#covsoverlap'><p> Covariance Overlap</p></a></li>
<li><a href='#dccm'><p> DCCM: Dynamical Cross-Correlation Matrix</p></a></li>
<li><a href='#dccm.enma'><p> Cross-Correlation for Ensemble NMA (eNMA)</p></a></li>
<li><a href='#dccm.gnm'><p>Dynamic Cross-Correlation from Gaussian Network Model</p></a></li>
<li><a href='#dccm.nma'><p> Dynamic Cross-Correlation from Normal Modes Analysis</p></a></li>
<li><a href='#dccm.pca'><p> Dynamical Cross-Correlation Matrix from Principal Component Analysis</p></a></li>
<li><a href='#dccm.xyz'><p> Dynamical Cross-Correlation Matrix from Cartesian Coordinates</p></a></li>
<li><a href='#deformation.nma'><p> Deformation Analysis</p></a></li>
<li><a href='#diag.ind'><p> Diagonal Indices of a Matrix</p></a></li>
<li><a href='#difference.vector'><p> Difference Vector</p></a></li>
<li><a href='#dist.xyz'><p>  Calculate the Distances Between the Rows of Two Matrices</p></a></li>
<li><a href='#dm'><p> Distance Matrix Analysis</p></a></li>
<li><a href='#dssp'><p> Secondary Structure Analysis with DSSP or STRIDE</p></a></li>
<li><a href='#elements'><p>Periodic Table of the Elements</p></a></li>
<li><a href='#entropy'><p> Shannon Entropy Score</p></a></li>
<li><a href='#example.data'><p>Bio3d Example Data</p></a></li>
<li><a href='#filter.cmap'><p> Contact Map Consensus Filtering</p></a></li>
<li><a href='#filter.dccm'><p> Filter for Cross-correlation Matrices (Cij)</p></a></li>
<li><a href='#filter.identity'><p> Percent Identity Filter</p></a></li>
<li><a href='#filter.rmsd'><p> RMSD Filter</p></a></li>
<li><a href='#fit.xyz'><p> Coordinate Superposition</p></a></li>
<li><a href='#fluct.nma'><p> NMA Fluctuations</p></a></li>
<li><a href='#formula2mass'><p>Chemical Formula to Mass Converter</p></a></li>
<li><a href='#gap.inspect'><p> Alignment Gap Summary</p></a></li>
<li><a href='#geostas'><p> GeoStaS Domain Finder</p></a></li>
<li><a href='#get.pdb'><p> Download PDB Coordinate Files</p></a></li>
<li><a href='#get.seq'><p> Download FASTA Sequence Files</p></a></li>
<li><a href='#gnm'><p>Gaussian Network Model</p></a></li>
<li><a href='#hclustplot'><p> Dendrogram with Clustering Annotation</p></a></li>
<li><a href='#hmmer'><p> HMMER Sequence Search</p></a></li>
<li><a href='#identify.cna'><p> Identify Points in a CNA Protein Structure Network Plot</p></a></li>
<li><a href='#inner.prod'><p> Mass-weighted Inner Product</p></a></li>
<li><a href='#inspect.connectivity'><p> Check the Connectivity of Protein Structures</p></a></li>
<li><a href='#is.gap'><p> Gap Characters</p></a></li>
<li><a href='#is.mol2'><p> Is an Object of Class &lsquo;mol2&rsquo;?</p></a></li>
<li><a href='#is.pdb'><p> Is an Object of Class &lsquo;pdb(s)&rsquo;?</p></a></li>
<li><a href='#is.select'><p>Is an Object of Class &lsquo;select&rsquo;?</p></a></li>
<li><a href='#is.xyz'><p> Is an Object of Class &lsquo;xyz&rsquo;?</p></a></li>
<li><a href='#layout.cna'><p> Protein Structure Network Layout</p></a></li>
<li><a href='#lbio3d'><p> List all Functions in the bio3d Package</p></a></li>
<li><a href='#load.enmff'><p> ENM Force Field Loader</p></a></li>
<li><a href='#mask'><p> Mask a Subset of Atoms in a DCCM Object.</p></a></li>
<li><a href='#mktrj'><p> PCA / NMA Atomic Displacement Trajectory</p></a></li>
<li><a href='#motif.find'><p> Find Sequence Motifs.</p></a></li>
<li><a href='#mustang'><p> Structure-based Sequence Alignment with MUSTANG</p></a></li>
<li><a href='#network.amendment'><p> Amendment of a CNA Network According To A Input Community Membership Vector.</p></a></li>
<li><a href='#nma'><p> Normal Mode Analysis</p></a></li>
<li><a href='#nma.pdb'><p> Normal Mode Analysis</p></a></li>
<li><a href='#nma.pdbs'><p> Ensemble Normal Mode Analysis</p></a></li>
<li><a href='#normalize.vector'><p> Mass-Weighted Normalized Vector</p></a></li>
<li><a href='#orient.pdb'><p> Orient a PDB Structure</p></a></li>
<li><a href='#overlap'><p> Overlap analysis</p></a></li>
<li><a href='#pairwise'><p> Pair Indices</p></a></li>
<li><a href='#pca'><p> Principal Component Analysis</p></a></li>
<li><a href='#pca.array'><p> Principal Component Analysis of an array of matrices</p></a></li>
<li><a href='#pca.pdbs'><p> Principal Component Analysis</p></a></li>
<li><a href='#pca.tor'><p> Principal Component Analysis</p></a></li>
<li><a href='#pca.xyz'><p> Principal Component Analysis</p></a></li>
<li><a href='#pdb.annotate'><p> Get Customizable Annotations From PDB Or PFAM Databases</p></a></li>
<li><a href='#pdb2aln'><p> Align a PDB structure to an existing alignment</p></a></li>
<li><a href='#pdb2aln.ind'><p> Mapping from alignment positions to PDB atomic indices</p></a></li>
<li><a href='#pdb2sse'><p>Obtain An SSE Sequence Vector From A PDB Object</p></a></li>
<li><a href='#pdbaln'><p> Sequence Alignment of PDB Files</p></a></li>
<li><a href='#pdbfit'><p> PDB File Coordinate Superposition</p></a></li>
<li><a href='#pdbs2pdb'><p> PDBs to PDB Converter</p></a></li>
<li><a href='#pdbs2sse'><p> SSE annotation for a PDBs Object</p></a></li>
<li><a href='#pdbseq'><p> Extract The Aminoacid Sequence From A PDB Object</p></a></li>
<li><a href='#pdbsplit'><p> Split a PDB File Into Separate Files, One For Each Chain.</p></a></li>
<li><a href='#pfam'><p> Download Pfam FASTA Sequence Alignment</p></a></li>
<li><a href='#plot.bio3d'><p> Plots with marginal SSE annotation</p></a></li>
<li><a href='#plot.cmap'><p> Plot Contact Matrix</p></a></li>
<li><a href='#plot.cna'><p> Protein Structure Network Plots in 2D and 3D.</p></a></li>
<li><a href='#plot.core'><p> Plot Core Fitting Progress</p></a></li>
<li><a href='#plot.dccm'><p> DCCM Plot</p></a></li>
<li><a href='#plot.dmat'><p> Plot Distance Matrix</p></a></li>
<li><a href='#plot.enma'><p> Plot eNMA Results</p></a></li>
<li><a href='#plot.fasta'><p> Plot a Multiple Sequence Alignment</p></a></li>
<li><a href='#plot.fluct'><p> Plot Fluctuations</p></a></li>
<li><a href='#plot.geostas'><p> Plot Geostas Results</p></a></li>
<li><a href='#plot.hmmer'><p> Plot a Summary of HMMER Hit Statistics.</p></a></li>
<li><a href='#plot.matrix.loadings'><p>Plot Residue-Residue Matrix Loadings</p></a></li>
<li><a href='#plot.nma'><p> Plot NMA Results</p></a></li>
<li><a href='#plot.pca'><p> Plot PCA Results</p></a></li>
<li><a href='#plot.pca.loadings'><p>  Plot Residue Loadings along PC1 to PC3</p></a></li>
<li><a href='#plot.rmsip'><p> Plot RMSIP Results</p></a></li>
<li><a href='#print.cna'><p> Summarize and Print Features of a cna Network Graph</p></a></li>
<li><a href='#print.core'><p> Printing Core Positions and Returning Indices</p></a></li>
<li><a href='#print.fasta'><p> Printing Sequence Alignments</p></a></li>
<li><a href='#print.xyz'><p> Printing XYZ coordinates</p></a></li>
<li><a href='#project.pca'><p> Project Data onto Principal Components</p></a></li>
<li><a href='#prune.cna'><p> Prune A cna Network Object</p></a></li>
<li><a href='#pymol'><p> Biomolecular Visualization with PyMOL</p></a></li>
<li><a href='#read.all'><p> Read Aligned Structure Data</p></a></li>
<li><a href='#read.cif'><p> Read mmCIF File</p></a></li>
<li><a href='#read.crd'><p> Read Coordinate Data from Amber or Charmm</p></a></li>
<li><a href='#read.crd.amber'><p> Read AMBER Coordinate files</p></a></li>
<li><a href='#read.crd.charmm'><p> Read CRD File</p></a></li>
<li><a href='#read.dcd'><p> Read CHARMM/X-PLOR/NAMD Binary DCD files</p></a></li>
<li><a href='#read.fasta'><p> Read FASTA formated Sequences</p></a></li>
<li><a href='#read.fasta.pdb'><p> Read Aligned Structure Data</p></a></li>
<li><a href='#read.mol2'><p> Read MOL2 File</p></a></li>
<li><a href='#read.ncdf'><p> Read AMBER Binary netCDF files</p></a></li>
<li><a href='#read.pdb'><p> Read PDB File</p></a></li>
<li><a href='#read.pdcBD'><p> Read PQR output from pdcBD File</p></a></li>
<li><a href='#read.pqr'><p> Read PQR File</p></a></li>
<li><a href='#read.prmtop'><p> Read AMBER Parameter/Topology files</p></a></li>
<li><a href='#rgyr'><p> Radius of Gyration</p></a></li>
<li><a href='#rle2'><p>Run Length Encoding with Indices</p></a></li>
<li><a href='#rmsd'><p> Root Mean Square Deviation</p></a></li>
<li><a href='#rmsf'><p> Atomic RMS Fluctuations</p></a></li>
<li><a href='#rmsip'><p> Root Mean Square Inner Product</p></a></li>
<li><a href='#sdENM'><p> Index for the sdENM ff</p></a></li>
<li><a href='#seq2aln'><p> Add a Sequence to an Existing Alignmnet</p></a></li>
<li><a href='#seqaln'><p> Sequence Alignment with MUSCLE</p></a></li>
<li><a href='#seqaln.pair'><p> Sequence Alignment of Identical Protein Sequences</p></a></li>
<li><a href='#seqbind'><p> Combine Sequences by Rows Without Recycling</p></a></li>
<li><a href='#seqidentity'><p> Percent Identity</p></a></li>
<li><a href='#setup.ncore'><p> Setup for Running Bio3D Functions using Multiple CPU Cores</p></a></li>
<li><a href='#sip'><p> Square Inner Product</p></a></li>
<li><a href='#sse.bridges'><p> SSE Backbone Hydrogen Bonding</p></a></li>
<li><a href='#store.atom'><p> Store all-atom data from a PDB object</p></a></li>
<li><a href='#struct.aln'><p> Structure Alignment Of Two PDB Files</p></a></li>
<li><a href='#torsion.pdb'><p> Calculate Mainchain and Sidechain Torsion/Dihedral Angles</p></a></li>
<li><a href='#torsion.xyz'><p> Calculate Torsion/Dihedral Angles</p></a></li>
<li><a href='#trim'><p> Trim a PDB Object To A Subset of Atoms.</p></a></li>
<li><a href='#trim.mol2'><p> Trim a MOL2 Object To A Subset of Atoms.</p></a></li>
<li><a href='#trim.pdbs'><p> Filter or Trim a PDBs Object</p></a></li>
<li><a href='#trim.xyz'><p> Trim a XYZ Object of Cartesian Coordinates.</p></a></li>
<li><a href='#unbound'><p> Sequence Generation from a Bounds Vector</p></a></li>
<li><a href='#uniprot'><p> Fetch UniProt Entry Data.</p></a></li>
<li><a href='#var.xyz'><p> Pairwise Distance Variance in Cartesian Coordinates</p></a></li>
<li><a href='#vec2resno'><p> Replicate Per-residue Vector Values</p></a></li>
<li><a href='#vmd'><p> View CNA Protein Structure Network Community Output in VMD</p></a></li>
<li><a href='#vmd_colors'><p> VMD Color Palette</p></a></li>
<li><a href='#wrap.tor'><p> Wrap Torsion Angle Data</p></a></li>
<li><a href='#write.crd'><p> Write CRD File</p></a></li>
<li><a href='#write.fasta'><p> Write FASTA Formated Sequences</p></a></li>
<li><a href='#write.mol2'><p> Write MOL2 Format Coordinate File</p></a></li>
<li><a href='#write.ncdf'><p> Write AMBER Binary netCDF files</p></a></li>
<li><a href='#write.pdb'><p> Write PDB Format Coordinate File</p></a></li>
<li><a href='#write.pir'><p> Write PIR Formated Sequences</p></a></li>
<li><a href='#write.pqr'><p> Write PQR Format Coordinate File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Biological Structure Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4-4</td>
</tr>
<tr>
<td>Author:</td>
<td>Barry Grant [aut, cre],
  Xin-Qiu Yao [aut],
  Lars Skjaerven [aut],
  Julien Ide [aut]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, parallel, grid, graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>XML, RCurl, lattice, ncdf4, igraph, bigmemory, knitr,
rmarkdown, testthat (&ge; 0.9.1), httr, msa, Biostrings</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities to process, organize and explore protein structure,
    sequence and dynamics data. Features include the ability to read and write
    structure, sequence and dynamic trajectory data, perform sequence and structure
    database searches, data summaries, atom selection, alignment, superposition,
    rigid core identification, clustering, torsion analysis, distance matrix
    analysis, structure and sequence conservation analysis, normal mode analysis,
    principal component analysis of heterogeneous structure data, and correlation
    network analysis from normal mode and molecular dynamics data. In addition,
    various utility functions are provided to enable the statistical and graphical
    power of the R environment to work with biological sequence and structural data.
    Please refer to the URLs below for more information.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barry Grant &lt;bjgrant@ucsd.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://thegrantlab.org/bio3d/">http://thegrantlab.org/bio3d/</a>,
<a href="https://bitbucket.org/Grantlab/bio3d/">https://bitbucket.org/Grantlab/bio3d/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-20 23:59:12 UTC; xinqyao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-26 22:45:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bio3d-package'> Biological Structure Analysis </h2><span id='topic+bio3d-package'></span><span id='topic+bio3d'></span>

<h3>Description</h3>

<p>Utilities for the analysis of protein structure and sequence data.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bio3d</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.4-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-10-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL version 2 or newer</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> <a href="http://thegrantlab.org/bio3d/">http://thegrantlab.org/bio3d/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Features include the ability to read and write structure
(<code><a href="#topic+read.pdb">read.pdb</a></code>,  <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>),  sequence (<code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+write.fasta">write.fasta</a></code>) and dynamics trajectory data
(<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>, <code><a href="#topic+write.ncdf">write.ncdf</a></code>).
</p>
<p>Perform sequence and structure database searches (<code><a href="#topic+blast.pdb">blast.pdb</a></code>,
<code><a href="#topic+hmmer">hmmer</a></code>), atom summaries (<code><a href="#topic+summary.pdb">summary.pdb</a></code>),  atom selection
(<code><a href="#topic+atom.select">atom.select</a></code>), alignment (<code><a href="#topic+pdbaln">pdbaln</a></code>,  <code><a href="#topic+seqaln">seqaln</a></code>,
<code><a href="#topic+mustang">mustang</a></code>) superposition (<code><a href="#topic+rot.lsq">rot.lsq</a></code>,  <code><a href="#topic+fit.xyz">fit.xyz</a></code>),
<code><a href="#topic+pdbfit">pdbfit</a></code>), rigid core identification (<code><a href="#topic+core.find">core.find</a></code>,  <code><a href="#topic+plot.core">plot.core</a></code>,
<code><a href="#topic+fit.xyz">fit.xyz</a></code>), dynamic domain analysis (<code><a href="#topic+geostas">geostas</a></code>), torsion/dihedral analysis
(<code><a href="#topic+torsion.pdb">torsion.pdb</a></code>,  <code><a href="#topic+torsion.xyz">torsion.xyz</a></code>), clustering (via
<code><a href="stats.html#topic+hclust">hclust</a></code>), principal component analysis
(<code><a href="#topic+pca.xyz">pca.xyz</a></code>,  <code><a href="#topic+pca.pdbs">pca.pdbs</a></code>, <code><a href="#topic+pca.tor">pca.tor</a></code>,  <code><a href="#topic+plot.pca">plot.pca</a></code>,
<code><a href="#topic+plot.pca.loadings">plot.pca.loadings</a></code>,  <code><a href="#topic+mktrj.pca">mktrj.pca</a></code>), dynamical
cross-correlation analysis (<code><a href="#topic+dccm">dccm</a></code>, <code><a href="#topic+plot.dccm">plot.dccm</a></code>) and correlation network analysis (<code><a href="#topic+cna">cna</a></code>,  <code><a href="#topic+plot.cna">plot.cna</a></code>, <code><a href="#topic+cnapath">cnapath</a></code>) of structure data.
</p>
<p>Perform conservation analysis of sequence (<code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+conserv">conserv</a></code>,
<code><a href="#topic+seqidentity">seqidentity</a></code>,  <code><a href="#topic+entropy">entropy</a></code>,  <code><a href="#topic+consensus">consensus</a></code>)
and structural (<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+rmsd">rmsd</a></code>,
<code><a href="#topic+rmsf">rmsf</a></code>, <code><a href="#topic+core.find">core.find</a></code>) data.
</p>
<p>Perform normal mode analysis (<code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+build.hessian">build.hessian</a></code>), ensemble normal
mode analysis (<code><a href="#topic+nma.pdbs">nma.pdbs</a></code>), mode comparison
(<code><a href="#topic+rmsip">rmsip</a></code>) and (<code><a href="#topic+overlap">overlap</a></code>), atomic fluctuation
prediction (<code><a href="#topic+fluct.nma">fluct.nma</a></code>), cross-correlation analysis
(<code><a href="#topic+dccm.nma">dccm.nma</a></code>), cross-correlation visualization (<code><a href="#topic+pymol.dccm">pymol.dccm</a></code>),
deformation analysis (<code><a href="#topic+deformation.nma">deformation.nma</a></code>), and mode visualization
(<code><a href="#topic+pymol.modes">pymol.modes</a></code>, <code><a href="#topic+mktrj.nma">mktrj.nma</a></code>).
</p>
<p>In addition, various utility functions are provided to facilitate
manipulation and analysis of biological sequence and structural data
(e.g. <code><a href="#topic+get.pdb">get.pdb</a></code>, <code><a href="#topic+get.seq">get.seq</a></code>, <code><a href="#topic+aa123">aa123</a></code>,
<code><a href="#topic+aa321">aa321</a></code>, <code><a href="#topic+pdbseq">pdbseq</a></code>, <code><a href="#topic+aln2html">aln2html</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+rot.lsq">rot.lsq</a></code>,  <code><a href="#topic+fit.xyz">fit.xyz</a></code>, <code><a href="#topic+is.gap">is.gap</a></code>, <code><a href="#topic+gap.inspect">gap.inspect</a></code>,
<code><a href="#topic+orient.pdb">orient.pdb</a></code>, <code><a href="#topic+pairwise">pairwise</a></code>, <code><a href="#topic+plot.bio3d">plot.bio3d</a></code>, <code><a href="#topic+plot.nma">plot.nma</a></code>, <code><a href="#topic+plot.blast">plot.blast</a></code>, <code><a href="#topic+biounit">biounit</a></code>, etc.).
</p>


<h3>Note</h3>

<p>The latest version, package vignettes and documentation with worked example
outputs can be obtained from the bio3d website:<br />
<a href="http://thegrantlab.org/bio3d/">http://thegrantlab.org/bio3d/</a>.<br />
<a href="http://thegrantlab.org/bio3d/reference/">http://thegrantlab.org/bio3d/reference/</a>.<br />
<a href="https://bitbucket.org/Grantlab/bio3d/">https://bitbucket.org/Grantlab/bio3d/</a>.
</p>


<h3>Author(s)</h3>

<p>Barry Grant &lt;bjgrant@ucsd.edu&gt;
Xin-Qiu Yao &lt;xinqiu.yao@gmail.com&gt;
Lars Skjaerven &lt;larsss@gmail.com&gt;
Julien Ide &lt;julien.ide.fr@gmail.com&gt;
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2021) <em>Protein Science</em> <b>30</b>, 20&ndash;30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>help(package="bio3d")     # list the functions within the package
#lbio3d()                  # list bio3d function names only

## Or visit:
##   http://thegrantlab.org/bio3d/reference/

## See the individual functions for further documentation and examples, e.g.
#help(read.pdb)

## Or online:
##    http://thegrantlab.org/bio3d/reference/read.pdb.html

## Not run: 
##-- See the list of Bio3D demos
demo(package="bio3d")

## Try some out, e.g:
demo(pdb) # PDB Reading, Manipulation, Searching and Alignment
demo(pca) # Principal Component Analysis
demo(md)  # Molecular Dynamics Trajectory Analysis
demo(nma) # Normal Mode Analysis

## See package vignettes and tutorals online:
##   http://thegrantlab.org/bio3d/articles/

## End(Not run)
</code></pre>

<hr>
<h2 id='aa.index'> AAindex: Amino Acid Index Database </h2><span id='topic+aa.index'></span>

<h3>Description</h3>

<p>A collection of published indices, or scales, of numerous
physicochemical and biological properties of the 20 standard
aminoacids (Release 9.1, August 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aa.index)</code></pre>


<h3>Format</h3>

<p>A list of 544 named indeces each with the following components:
</p>

<ol>
<li><p>H character vector: Accession number. 
</p>
</li>
<li><p>D character vector: Data description. 
</p>
</li>
<li><p>R character vector: LITDB entry number. 
</p>
</li>
<li><p>A character vector: Author(s). 
</p>
</li>
<li><p>T character vector: Title of the article. 
</p>
</li>
<li><p>J character vector: Journal reference. 
</p>
</li>
<li><p>C named numeric vector: Correlation coefficients of similar
indeces (with coefficients of 0.8/-0.8 or more/less). The
correlation coefficient is calculated with zeros filled for missing
values. 
</p>
</li>
<li><p>I named numeric vector: Amino acid index data. 
</p>
</li></ol>



<h3>Source</h3>

<p>&lsquo;AAIndex&rsquo; was obtained from:<br />
<a href="https://www.genome.jp/aaindex/">https://www.genome.jp/aaindex/</a><br />
For a description of the &lsquo;AAindex&rsquo; database see:<br /> 
<a href="https://www.genome.jp/aaindex/aaindex_help.html">https://www.genome.jp/aaindex/aaindex_help.html</a>.
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;AAIndex&rsquo; is the work of Kanehisa and co-workers:<br />
Kawashima and Kanehisa (2000) <em>Nucleic Acids Res.</em> <b>28</b>, 374;<br />
Tomii and Kanehisa (1996) <em>Protein Eng.</em> <b>9</b>, 27&ndash;36;<br />
Nakai, Kidera and Kanehisa (1988) <em>Protein Eng.</em> <b>2</b>, 93&ndash;100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load AAindex data
data(aa.index)

## Find all indeces described as "volume"
ind &lt;- which(sapply(aa.index, function(x)
                    length(grep("volume", x$D, ignore.case=TRUE)) != 0))

## find all indeces with author "Kyte"
ind &lt;- which(sapply(aa.index, function(x) length(grep("Kyte", x$A)) != 0))

## examine the index
aa.index[[ind]]$I

## find indeces which correlate with it
all.ind &lt;- names(which(Mod(aa.index[[ind]]$C) &gt;= 0.88))

## examine them all
sapply(all.ind, function (x) aa.index[[x]]$I)
</code></pre>

<hr>
<h2 id='aa.table'> Table of Relevant Amino Acids </h2><span id='topic+aa.table'></span>

<h3>Description</h3>

<p>This data set provides the atomic masses of a selection of amino
acids regularly occuring in proteins. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa.table
</code></pre>


<h3>Format</h3>

<p>A data frame with the following components.
</p>

<dl>
<dt><code>aa3</code></dt><dd><p>a character vector containing three-letter amino
acid code.</p>
</dd>
<dt><code>aa1</code></dt><dd><p>a character vector containing one-letter amino
acid code.</p>
</dd>
<dt><code>mass</code></dt><dd><p>a numeric vector containing the mass of the
respective amino acids. </p>
</dd>
<dt><code>formula</code></dt><dd><p>a character vector containing the formula of
the amino acid in which the mass calculat was based. </p>
</dd>
<dt><code>name</code></dt><dd><p>a character vector containing the full names of
the respective amino acids. </p>
</dd>
</dl>



<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aa2mass">aa2mass</a></code>, <code><a href="#topic+aa.index">aa.index</a></code>,
<code><a href="#topic+atom.index">atom.index</a></code>, <code><a href="#topic+elements">elements</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aa.table)
aa.table

## table look up
aa.table["HIS", ]

## read PDB, and fetch residue masses
pdb &lt;- read.pdb(system.file("examples/1hel.pdb", package="bio3d"))
aa2mass(pdb)
</code></pre>

<hr>
<h2 id='aa123'> Convert Between 1-letter and 3-letter Aminoacid Codes </h2><span id='topic+aa123'></span><span id='topic+aa321'></span>

<h3>Description</h3>

<p>Convert between one-letter IUPAC aminoacid codes and three-letter PDB
style aminoacid codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa123(aa)
aa321(aa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa123_+3A_aa">aa</code></td>
<td>
<p> a character vector of individual aminoacid codes. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard conversions will map &lsquo;A&rsquo; to &lsquo;ALA&rsquo;, &lsquo;G&rsquo; to
&lsquo;GLY&rsquo;, etc.
Non-standard codes in <code>aa</code> will generate a warning and return
&lsquo;UNK&rsquo; or &lsquo;X&rsquo;.
</p>


<h3>Value</h3>

<p>A character vector of aminoacid codes.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of IUPAC one-letter codes see:<br />
<a href="https://www.insdc.org/documents/feature_table.html#7.4.3">https://www.insdc.org/documents/feature_table.html#7.4.3</a>
</p>
<p>For more information on PDB residue codes see:<br />
<a href="http://ligand-expo.rcsb.org/ld-search.html">http://ligand-expo.rcsb.org/ld-search.html</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+pdbseq">pdbseq</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple conversion
aa123(c("D","L","A","G","S","H"))
aa321(c("ASP", "LEU", "ALA", "GLY", "SER", "HIS"))

## Not run: 
# Extract sequence from a PDB file's ATOM and SEQRES cards
pdb &lt;- read.pdb("1BG2") 
s &lt;- aa321(pdb$seqres)                   # SEQRES
a &lt;- aa321(pdb$atom[pdb$calpha,"resid"]) # ATOM

# Write both sequences to a fasta file
write.fasta(alignment=seqbind(s,a), id=c("seqres","atom"), file="eg2.fa")

# Alternative approach for ATOM sequence extraction
pdbseq(pdb)
pdbseq(pdb, aa1=FALSE )

## End(Not run)
</code></pre>

<hr>
<h2 id='aa2index'> Convert an Aminoacid Sequence to AAIndex Values </h2><span id='topic+aa2index'></span>

<h3>Description</h3>

<p>Converts sequences to aminoacid indeces from the &lsquo;AAindex&rsquo; database. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa2index(aa, index = "KYTJ820101", window = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa2index_+3A_aa">aa</code></td>
<td>
<p> a protein sequence character vector. </p>
</td></tr>
<tr><td><code id="aa2index_+3A_index">index</code></td>
<td>
<p> an index name or number (default: &ldquo;KYTJ820101&rdquo;,
hydropathy index by Kyte-Doolittle, 1982). </p>
</td></tr>
<tr><td><code id="aa2index_+3A_window">window</code></td>
<td>
<p> a positive numeric value, indicating the window size
for smoothing with a sliding window average (default: 1, i.e. no
smoothing). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function simply returns the index values for each
amino acid in the sequence. It can also be set to perform a crude
sliding window average through the <code>window</code> argument. 
</p>


<h3>Value</h3>

<p>Returns a numeric vector.
</p>


<h3>Author(s)</h3>

<p> Ana Rodrigues </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;AAIndex&rsquo; is the work of Kanehisa and co-workers:
Kawashima and Kanehisa (2000) <em>Nucleic Acids Res.</em> <b>28</b>, 374;
Tomii and Kanehisa (1996) <em>Protein Eng.</em> <b>9</b>, 27&ndash;36;
Nakai, Kidera and Kanehisa (1988) <em>Protein Eng.</em> <b>2</b>, 93&ndash;100.
</p>
<p>For a description of the &lsquo;AAindex&rsquo; database see:<br /> 
<a href="https://www.genome.jp/aaindex/">https://www.genome.jp/aaindex/</a> or the <code><a href="#topic+aa.index">aa.index</a></code> documentation.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+aa.index">aa.index</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Residue hydropathy values
seq &lt;- c("R","S","D","X","-","X","R","H","Q","V","L")
aa2index(seq)

## Not run: 
## Use a sliding window average
aa2index(aa=seq, index=22, window=3)

## Use an alignment

aln  &lt;- read.fasta(system.file("examples/hivp_xray.fa",package="bio3d"))
prop &lt;- t(apply(aln$ali, 1, aa2index, window=1))

## find and use indices for volume calculations
i &lt;- which(sapply(aa.index,
       function(x) length(grep("volume", x$D, ignore.case=TRUE)) != 0))
sapply(i, function(x) aa2index(aa=seq, index=x, window=5)) 

## End(Not run)
</code></pre>

<hr>
<h2 id='aa2mass'> Amino Acid Residues to Mass Converter </h2><span id='topic+aa2mass'></span>

<h3>Description</h3>

<p>Convert a sequence of amino acid residue names to mass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa2mass(pdb, inds=NULL, mass.custom=NULL, addter=TRUE, mmtk=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa2mass_+3A_pdb">pdb</code></td>
<td>
<p> a character vector containing the atom names to convert
to atomic masses. Alternatively, a object of type <code>pdb</code> can be
provided. </p>
</td></tr>
<tr><td><code id="aa2mass_+3A_inds">inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from <code>atom.select</code>
that selects the elements of <code>pdb</code> upon which the calculation
should be based. </p>
</td></tr>
<tr><td><code id="aa2mass_+3A_mass.custom">mass.custom</code></td>
<td>
<p> a list of amino acid residue names and their
corresponding masses. </p>
</td></tr>
<tr><td><code id="aa2mass_+3A_addter">addter</code></td>
<td>
<p> logical, if TRUE terminal atoms are added to final
masses. </p>
</td></tr>
<tr><td><code id="aa2mass_+3A_mmtk">mmtk</code></td>
<td>
<p> logical, if TRUE use the exact aminoacid residue masses as
provided with the MMTK database (for testing purposes). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts amino acid residue names to their corresponding
masses. In the case of a non-standard amino acid residue name
<code>mass.custom</code> can be used to map the residue to the correct
mass. User-defined amino acid masses (with argument <code>mass.custom</code>)
will override mass entries obtained from the database. 
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of masses.
</p>


<h3>Note</h3>

<p>When object of type <code>pdb</code> is provided, non-calpha atom records
are omitted from the selection.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+atom.index">atom.index</a></code>, <code><a href="#topic+atom2mass">atom2mass</a></code>,
<code><a href="#topic+aa.index">aa.index</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>resi.names &lt;- c("LYS", "ALA", "CYS", "HIS")
masses &lt;- aa2mass(resi.names, addter=FALSE)

## Not run: 
## Fetch atomic masses in a PDB object
pdb &lt;- read.pdb("3dnd")
masses &lt;- aa2mass(pdb)

## or
masses &lt;- aa2mass(pdb$atom[1:10,"resid"])

## Dealing with unconventional residues
#pdb &lt;- read.pdb("1xj0")

#mass.cust &lt;- list("CSX"=122.166)
#masses &lt;- aa2mass(pdb, mass.custom=mass.cust)

## End(Not run)
</code></pre>

<hr>
<h2 id='aanma'>All Atom Normal Mode Analysis</h2><span id='topic+aanma'></span><span id='topic+aanma.pdb'></span><span id='topic+rtb'></span>

<h3>Description</h3>

<p>Perform all-atom elastic network model normal modes calculation of a protein
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aanma(...)

## S3 method for class 'pdb'
aanma(pdb, pfc.fun = NULL, mass = TRUE, temp = 300,
  keep = NULL, hessian = NULL, outmodes = "calpha", rm.wat = TRUE,
  reduced = FALSE, rtb = FALSE, nmer = 1, ...)

rtb(hessian, pdb, mass = TRUE, nmer = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aanma_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+build.hessian">build.hessian</a></code> and
<code><a href="#topic+aa2mass">aa2mass</a></code>. One useful option here for dealing with
unconventional residues is &lsquo;mass.custom&rsquo;, see the
<code><a href="#topic+aa2mass">aa2mass</a></code> function for details.</p>
</td></tr>
<tr><td><code id="aanma_+3A_pdb">pdb</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from function
<code><a href="#topic+read.pdb">read.pdb</a></code>.</p>
</td></tr>
<tr><td><code id="aanma_+3A_pfc.fun">pfc.fun</code></td>
<td>
<p>customized pair force constant (&lsquo;pfc&rsquo;) function. The
provided function should take a vector of distances as an argument to
return a vector of force constants. If NULL, the default function
&lsquo;aaenm2&rsquo; will be employed. (See details below).</p>
</td></tr>
<tr><td><code id="aanma_+3A_mass">mass</code></td>
<td>
<p>logical, if TRUE the Hessian will be mass-weighted.</p>
</td></tr>
<tr><td><code id="aanma_+3A_temp">temp</code></td>
<td>
<p>numerical, temperature for which the amplitudes for scaling the
atomic displacement vectors are calculated. Set &lsquo;temp=NULL&rsquo; to
avoid scaling.</p>
</td></tr>
<tr><td><code id="aanma_+3A_keep">keep</code></td>
<td>
<p>numerical, final number of modes to be stored. Note that all
subsequent analyses are limited to this subset of modes. This option is
useful for very large structures and cases where memory may be limited.</p>
</td></tr>
<tr><td><code id="aanma_+3A_hessian">hessian</code></td>
<td>
<p>hessian matrix as obtained from <code><a href="#topic+build.hessian">build.hessian</a></code>.
For internal purposes and generally not intended for public use.</p>
</td></tr>
<tr><td><code id="aanma_+3A_outmodes">outmodes</code></td>
<td>
<p>either a character (&lsquo;calpha&rsquo; or &lsquo;noh&rsquo;) or atom
indices as obtained from <code><a href="#topic+atom.select">atom.select</a></code> specifying the atoms to
include in the resulting mode object. (See details below).</p>
</td></tr>
<tr><td><code id="aanma_+3A_rm.wat">rm.wat</code></td>
<td>
<p>logical, if TRUE water molecules will be removed before
calculation.</p>
</td></tr>
<tr><td><code id="aanma_+3A_reduced">reduced</code></td>
<td>
<p>logical, if TRUE the coarse-grained (&lsquo;4-bead&rsquo;) ENM will
be employed. (See details below).</p>
</td></tr>
<tr><td><code id="aanma_+3A_rtb">rtb</code></td>
<td>
<p>logical, if TRUE the rotation-translation block based
approximate modes will be calculated. (See details below).</p>
</td></tr>
<tr><td><code id="aanma_+3A_nmer">nmer</code></td>
<td>
<p>numerical, defines the number of residues per block (used only
when <code>rtb=TRUE</code>).</p>
</td></tr>
<tr><td><code id="aanma_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE print detailed processing message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds an elastic network model (ENM) based on all
heavy atoms of input <code>pdb</code>, and performs subsequent normal mode
analysis (NMA) in various manners. By default, the &lsquo;aaenm2&rsquo; force
field (defining of the spring constants between atoms) is used, which was
obtained by fitting to a local energy minimum of a crambin model
derived from the AMBER99SB force field. It employs a pair force constant
function which falls as r^-6, and specific force constants for
covalent and intra-residue atom pairs. See also <code><a href="#topic+load.enmff">load.enmff</a></code>
for other force field options.
</p>
<p>The <code>outmodes</code> argument controls the type of output modes. There are
two standard types of output modes: &lsquo;noh&rsquo; and &lsquo;calpha&rsquo;.
<code>outmodes='noh'</code> invokes regular all-atom based ENM-NMA. When
<code>outmodes='calpha'</code>, an effective Hessian with respect to all C-alpha
atoms will be first calculated using the same formula as in Hinsen et al.
NMA is then performed on this effective C-alpha based Hessian. In addition,
users can provide their own atom selection (see <code><a href="#topic+atom.select">atom.select</a></code>)
as the value of <code>outmodes</code> for customized output modes generation.
</p>
<p>When <code>reduced=TRUE</code>, only a selection of all heavy atoms is used
to build the ENM. More specifically, three to five atoms per residue
constitute the model. Here the N, CA, C atoms represent the protein
backbone, and zero to two selected side chain atoms represent the side chain
(selected based on side chain size and the distance to CA). This
coarse-grained ENM has significantly improved computational efficiency and
similar prediction accuracy with respect to the all-atom ENM.
</p>
<p>When <code>rtb=TRUE</code>, rotation-translation block (RTB) based approximate
modes will be calculated. In this method, each residue is assumed to be a
rigid body (or &lsquo;block&rsquo;) that has only rotational and translational
degrees of freedom. Intra-residue deformation is thus ignored.
(See Durand et al 1994 and Tama et al. 2000 for more details). N residues per
block is also supported, where N=1, 2, 3, etc. (See argument <code>nmer</code>).
The RTB method has significantly improved computational efficiency and
similar prediction accuracy with respect to the all-atom ENM.
</p>
<p>By default the function will diagonalize the mass-weighted Hessian matrix.
The resulting mode vectors are moreover scaled by the thermal fluctuation
amplitudes.
</p>


<h3>Value</h3>

<p>Returns an object of class &lsquo;nma&rsquo; with the following
components:
</p>
<table>
<tr><td><code>modes</code></td>
<td>
<p> numeric matrix with columns containing the normal mode
vectors. Mode vectors are converted to unweighted Cartesian
coordinates  when <code>mass=TRUE</code>. Note that the 6 first trivial
eigenvectos appear in columns one to six. </p>
</td></tr>
<tr><td><code>frequencies</code></td>
<td>
<p> numeric vector containing the vibrational
frequencies corresponding to each mode (for <code>mass=TRUE</code>). </p>
</td></tr>
<tr><td><code>force.constants</code></td>
<td>
<p> numeric vector containing the force constants
corresponding to each mode (for <code>mass=FALSE)</code>). </p>
</td></tr>
<tr><td><code>fluctuations</code></td>
<td>
<p> numeric vector of atomic fluctuations. </p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p> numeric matrix with columns containing the raw
eigenvectors. Equals to the <code>modes</code> component when
<code>mass=FALSE</code> and <code>temp=NULL</code>. </p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> numeric vector containing the raw eigenvalues. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> numeric matrix of class <code>xyz</code> containing the
Cartesian coordinates in which the calculation was performed. </p>
</td></tr>
<tr><td><code>mass</code></td>
<td>
<p> numeric vector containing the residue masses used for the
mass-weighting. </p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p> numerical, temperature for which the amplitudes for
scaling the atomic displacement vectors are calculated. </p>
</td></tr>
<tr><td><code>triv.modes</code></td>
<td>
<p> number of trivial modes. </p>
</td></tr>
<tr><td><code>natoms</code></td>
<td>
<p> number of C-alpha atoms. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lars Skjaerven &amp; Xin-Qiu Yao
</p>


<h3>References</h3>

<p>Hinsen, K. et al. (2000) <em>Chem. Phys.</em> <b>261</b>, 25.
Durand, P. et al. (1994) <em>Biopolymers</em> <b>34</b>, 759.
Tama, F. et al. (2000) <em>Proteins</em> <b>41</b>, 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nma.pdb">nma.pdb</a></code> for C-alpha based NMA, <code><a href="#topic+aanma.pdbs">aanma.pdbs</a></code> for
ensemble all-atom NMA, <code><a href="#topic+load.enmff">load.enmff</a></code> for available ENM force
fields, and <code><a href="#topic+fluct.nma">fluct.nma</a></code>, <code><a href="#topic+mktrj.nma">mktrj.nma</a></code>, and
<code><a href="#topic+dccm.nma">dccm.nma</a></code> for various post-NMA calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # All-atom NMA takes relatively long time - Don't run by default.

   ## Fetch stucture
   pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

   ## Calculate all-atom normal modes
   modes.aa &lt;- aanma(pdb, outmodes='noh')

   ## Calculate all-atom normal modes with RTB approximation
   modes.aa.rtb &lt;- aanma(pdb, outmodes='noh', rtb=TRUE)

   ## Compare the two modes
   rmsip(modes.aa, modes.aa.rtb)

   ## Calculate C-alpha normal modes.
   modes &lt;- aanma(pdb)

   ## Calculate C-alpha normal modes with reduced ENM.
   modes.cg &lt;- aanma(pdb, reduced=TRUE)

   ## Calculate C-alpha normal modes with RTB approximation
   modes.rtb &lt;- aanma(pdb, rtb=TRUE)

   ## Compare modes
   rmsip(modes, modes.cg)
   rmsip(modes, modes.rtb)

   ## Print modes
   print(modes)

   ## Plot modes
   plot(modes)

   ## Visualize modes
   #m7 &lt;- mktrj.nma(modes, mode=7, file="mode_7.pdb", pdb=pdb)

## End(Not run)
</code></pre>

<hr>
<h2 id='aanma.pdbs'>Ensemble Normal Mode Analysis with All-Atom ENM</h2><span id='topic+aanma.pdbs'></span>

<h3>Description</h3>

<p>Perform normal mode analysis (NMA) on an ensemble of aligned protein
structures using all-atom elastic network model (aaENM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdbs'
aanma(pdbs, fit = TRUE, full = FALSE, subspace = NULL,
  rm.gaps = TRUE, ligand = FALSE, outpath = NULL, gc.first = TRUE,
  ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aanma.pdbs_+3A_pdbs">pdbs</code></td>
<td>
<p>an &lsquo;pdbs&rsquo; object as obtained from <code><a href="#topic+read.all">read.all</a></code>.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_fit">fit</code></td>
<td>
<p>logical, if TRUE C-alpha coordinate based superposition is 
performed prior to normal mode calculations.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_full">full</code></td>
<td>
<p>logical, if TRUE return the complete, full structure,
&lsquo;nma&rsquo; objects.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_subspace">subspace</code></td>
<td>
<p>number of eigenvectors to store for further analysis.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p>logical, if TRUE obtain the hessian matrices for only
atoms in the aligned positions (non-gap positions in all aligned
structures). Thus, gap positions are removed from output.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_ligand">ligand</code></td>
<td>
<p>logical, if TRUE ligand molecules are also included in the 
calculation.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_outpath">outpath</code></td>
<td>
<p>character string specifing the output directory to
which the PDB structures should be written.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_gc.first">gc.first</code></td>
<td>
<p>logical, if TRUE will call gc() first before mode calculation
for each structure. This is to avoid memory overload when 
<code>ncore &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_ncore">ncore</code></td>
<td>
<p>number of CPU cores used to do the calculation.</p>
</td></tr>
<tr><td><code id="aanma.pdbs_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+aanma">aanma</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds elastic network model (ENM) using all heavy 
atoms and performs subsequent normal mode analysis (NMA) on a set of 
aligned protein structures obtained with function <code><a href="#topic+read.all">read.all</a></code>.
The main purpose is to automate ensemble normal mode analysis using 
all-atom ENMs.
</p>
<p>By default, the effective Hessian for all C-alpha atoms is calculated 
based on the Hessian built from all heavy atoms (including ligand atoms if 
<code>ligand=TRUE</code>). Returned values include aligned mode vectors and 
(when <code>full=TRUE</code>) a list containing the full &lsquo;nma&rsquo; objects
one per each structure. When &lsquo;rm.gaps=TRUE&rsquo; the unaligned atoms 
are ommited from output. With default arguments &lsquo;rmsip&rsquo; provides 
RMSIP values for all pairwise structures.
</p>
<p>When <code>outmodes</code> is provided and is not &lsquo;calpha&rsquo; 
(e.g. &lsquo;noh&rsquo;. See <code><a href="#topic+aanma">aanma</a></code> for more details), the 
function simply returns a list of &lsquo;nma&rsquo; objects, one per each 
structure, and no aligned mode vector is returned. In this case, the 
arguments <code>full</code>, <code>subspace</code>, and <code>rm.gaps</code> are ignored. 
This is equivalent to a wrapper function repeatedly calling 
<code><a href="#topic+aanma">aanma</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list of &lsquo;nma&rsquo; objects (<code>outmodes</code> is provided 
and is not &lsquo;calpha&rsquo;) or an &lsquo;enma&rsquo; object with the following 
components:
</p>
<table>
<tr><td><code>fluctuations</code></td>
<td>
<p> a numeric matrix containing aligned atomic
fluctuations with one row per input structure. </p>
</td></tr>
<tr><td><code>rmsip</code></td>
<td>
<p> a numeric matrix of pair wise RMSIP values (only the ten
lowest frequency modes are included in the calculation). </p>
</td></tr>
<tr><td><code>U.subspace</code></td>
<td>
<p> a three-dimensional array with aligned
eigenvectors  (corresponding to the subspace defined by the first N
non-trivial eigenvectors (&lsquo;U&rsquo;) of the &lsquo;nma&rsquo; object). </p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> numeric matrix containing the raw eigenvalues with one row
per input structure. </p>
</td></tr>
<tr><td><code>full.nma</code></td>
<td>
<p> a list with a <code>nma</code> object for each input
structure (available only when <code>full=TRUE</code>). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Lars Skjaerven
</p>


<h3>See Also</h3>

<p>For normal mode analysis on single structure PDB:
<code><a href="#topic+aanma">aanma</a></code>
</p>
<p>For conventional C-alpha based normal mode analysis:
<code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+nma.pdbs">nma.pdbs</a></code>.
</p>
<p>For the analysis of the resulting &lsquo;eNMA&rsquo; object:
<code><a href="#topic+mktrj.enma">mktrj.enma</a></code>, <code><a href="#topic+dccm.enma">dccm.enma</a></code>,
<code><a href="#topic+plot.enma">plot.enma</a></code>, <code><a href="#topic+cov.enma">cov.enma</a></code>.
</p>
<p>Similarity measures:
<code><a href="#topic+sip">sip</a></code>, <code><a href="#topic+covsoverlap">covsoverlap</a></code>,
<code><a href="#topic+bhattacharyya">bhattacharyya</a></code>, <code><a href="#topic+rmsip">rmsip</a></code>.
</p>
<p>Related functionality:
<code><a href="#topic+read.all">read.all</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Needs MUSCLE installed - testing excluded
  if(check.utility("muscle")) {

    ## Fetch PDB files and split to chain A only PDB files
    ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
    files &lt;- get.pdb(ids, split = TRUE, path = tempdir())
    
    ## Sequence Alignement
    aln &lt;- pdbaln(files, outfile = tempfile())
    
    ## Read all pdb coordinates
    pdbs &lt;- read.all(aln)

    ## Normal mode analysis on aligned data
    modes &lt;- aanma(pdbs, rm.gaps=TRUE)
    
    ## Plot fluctuation data
    plot(modes, pdbs=pdbs)
    
    ## Cluster on Fluctuation similariy
    sip &lt;- sip(modes)
    hc &lt;- hclust(dist(sip))
    col &lt;- cutree(hc, k=3)
    
    ## Plot fluctuation data
    plot(modes, pdbs=pdbs, col=col)
    
    ## RMSIP is pre-calculated
    heatmap(1-modes$rmsip)
    
    ## Bhattacharyya coefficient
    bc &lt;- bhattacharyya(modes)
    heatmap(1-bc)

  }

</code></pre>

<hr>
<h2 id='aln2html'> Create a HTML Page For a Given Alignment </h2><span id='topic+aln2html'></span>

<h3>Description</h3>

<p>Renders a sequence alignment as coloured HTML suitable for viewing
with a web browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aln2html(aln, file="alignment.html", Entropy=0.5, append=TRUE,
         caption.css="color: gray; font-size: 9pt",
         caption="Produced by &lt;a href=http://thegrantlab.org/bio3d/&gt;Bio3D&lt;/a&gt;",
         fontsize="11pt", bgcolor=TRUE, colorscheme="clustal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aln2html_+3A_aln">aln</code></td>
<td>
<p>  an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_file">file</code></td>
<td>
<p>  name of output html file.  </p>
</td></tr>
<tr><td><code id="aln2html_+3A_entropy">Entropy</code></td>
<td>
<p> conservation &lsquo;cuttoff&rsquo; value below which
alignment columns are not coloured. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_append">append</code></td>
<td>
<p> logical, if TRUE output will be appended to
<code>file</code>; otherwise, it will overwrite the contents of
<code>file</code>. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_caption.css">caption.css</code></td>
<td>
<p> a character string of css options for rendering
&lsquo;caption&rsquo; text. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_caption">caption</code></td>
<td>
<p> a character string of text to act as a caption. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_fontsize">fontsize</code></td>
<td>
<p> the font size for alignment characters. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_bgcolor">bgcolor</code></td>
<td>
<p> background colour. </p>
</td></tr>
<tr><td><code id="aln2html_+3A_colorscheme">colorscheme</code></td>
<td>
<p> conservation colouring scheme, currently only
&ldquo;clustal&rdquo; is supported with alternative arguments resulting
in an entropy shaded alignment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>Your web browser should support style sheets.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+write.fasta">write.fasta</a></code>, <code><a href="#topic+seqaln">seqaln</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read an example alignment
aln &lt;- read.fasta(system.file("examples/hivp_xray.fa",package="bio3d"))

## Produce a HTML file for this alignment
aln2html(aln, append=FALSE, file=file.path("eg.html"))
aln2html(aln, colorscheme="ent", file="eg.html")
## View/open the file in your web browser
#browseURL("eg.html")

## End(Not run)
</code></pre>

<hr>
<h2 id='angle.xyz'> Calculate the Angle Between Three Atoms </h2><span id='topic+angle.xyz'></span>

<h3>Description</h3>

<p>A function for basic bond angle determination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle.xyz(xyz, atm.inc = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle.xyz_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector of Cartisean coordinates. </p>
</td></tr>
<tr><td><code id="angle.xyz_+3A_atm.inc">atm.inc</code></td>
<td>
<p> a numeric value indicating the number of atoms to
increment by between successive angle evaluations (see below). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of angles.
</p>


<h3>Note</h3>

<p>With <code>atm.inc=1</code>, angles are calculated for each set of
three successive atoms contained in <code>xyz</code> (i.e. moving along one
atom, or three elements of <code>xyz</code>, between sucessive
evaluations).  With <code>atm.inc=3</code>, angles are calculated for each set
of three successive non-overlapping atoms contained in <code>xyz</code>
(i.e. moving along three atoms, or nine elements of <code>xyz</code>, between
sucessive evaluations).
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+torsion.pdb">torsion.pdb</a></code>, <code><a href="#topic+torsion.xyz">torsion.xyz</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Angle between N-CA-C atoms of residue four
inds &lt;- atom.select(pdb, resno=4, elety=c("N","CA","C"))
angle.xyz(pdb$xyz[inds$xyz])

## Basic stats of all N-CA-C bound angles
inds &lt;- atom.select(pdb, elety=c("N","CA","C"))
summary( angle.xyz(pdb$xyz[inds$xyz]) )
#hist( angle.xyz(pdb$xyz[inds$xyz]), xlab="Angle" )

</code></pre>

<hr>
<h2 id='as.fasta'> Alignment to FASTA object </h2><span id='topic+as.fasta'></span>

<h3>Description</h3>

<p>Convert alignment/sequence in matrix/vector format to FASTA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.fasta(x, id=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.fasta_+3A_x">x</code></td>
<td>
<p> a sequence character matrix/vector (e.g obtained from
<code><a href="#topic+get.seq">get.seq</a></code> or <code><a href="#topic+seqbind">seqbind</a></code>). </p>
</td></tr>
<tr><td><code id="as.fasta_+3A_id">id</code></td>
<td>
<p> a vector of sequence names to serve as sequence
identifers. By default the function will use the row names of the
alignment if they exists, otherwise ids will be generated. </p>
</td></tr>
<tr><td><code id="as.fasta_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides basic functionality to convert a sequence
character matrix/vector to a FASTA object. 
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"fasta"</code> with the following components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.seq">get.seq</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>,
<code><a href="#topic+seqbind">seqbind</a></code>, <code><a href="#topic+pdbaln">pdbaln</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.fasta(c("A", "C", "D"))
</code></pre>

<hr>
<h2 id='as.pdb'> Convert to PDB format </h2><span id='topic+as.pdb'></span><span id='topic+as.pdb.mol2'></span><span id='topic+as.pdb.prmtop'></span><span id='topic+as.pdb.default'></span>

<h3>Description</h3>

<p>Convert Tripos Mol2 format, or Amber parameter/topology and coordinate data to PDB format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.pdb(...)

## S3 method for class 'mol2'
as.pdb(mol, ...)

## S3 method for class 'prmtop'
as.pdb(prmtop, crd=NULL, inds=NULL, inds.crd=inds, ncore=NULL, ...)

## Default S3 method:
as.pdb(pdb=NULL, xyz=NULL, type=NULL, resno=NULL,
                   resid=NULL, eleno=NULL, elety=NULL, chain=NULL, 
                   insert=NULL, alt=NULL, o=NULL, b=NULL, segid=NULL, 
                   elesy=NULL, charge=NULL, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.pdb_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_mol">mol</code></td>
<td>
<p> a list object of type <code>"mol2"</code> (obtained with
<code><a href="#topic+read.mol2">read.mol2</a></code>). </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_prmtop">prmtop</code></td>
<td>
<p> a list object of type <code>"prmtop"</code> (obtained with
<code><a href="#topic+read.prmtop">read.prmtop</a></code>). </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_crd">crd</code></td>
<td>
<p> a list object of type <code>"crd"</code> (obtained with
<code><a href="#topic+read.crd.amber">read.crd.amber</a></code>). </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_inds">inds</code></td>
<td>
<p> a list object of type <code>"select"</code> as obtained from
<code><a href="#topic+atom.select">atom.select</a></code>. The indices points to which atoms in the
PRMTOP object to convert. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_inds.crd">inds.crd</code></td>
<td>
<p> same as the &lsquo;inds&rsquo; argument, but pointing to
the atoms in CRD object to convert. By default, this argument equals
to &lsquo;inds&rsquo;, assuming the same number and sequence of atoms in the
PRMTOP and CRD objects. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_pdb">pdb</code></td>
<td>
<p> an object of class &lsquo;pdb&rsquo; as obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector/matrix of Cartesian coordinates. If
provided, the number of atoms in the new PDB object will be set to
<code>ncol(as.xyz(xyz))/3</code> (see <code><a href="#topic+as.xyz">as.xyz</a></code>).
</p>
<p>If <code>xyz</code> is not provided the number of atoms will be based on
the length of <code>eleno</code>, <code>resno</code>, or <code>resid</code> (in that
order). </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_type">type</code></td>
<td>
<p> a character vector of record types, i.e. &quot;ATOM&quot; or &quot;HETATM&quot;,
with length equal to <code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element
character vector can be provided which will be repeated to match
the number of atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_resno">resno</code></td>
<td>
<p> a numeric vector of residue numbers of length equal to
<code>ncol(as.xyz(xyz))/3</code>. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_resid">resid</code></td>
<td>
<p> a character vector of residue types/ids of length equal to
<code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element
character vector can be provided which will be repeated to match
the number of atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_eleno">eleno</code></td>
<td>
<p> a numeric vector of element/atom numbers of length equal to
<code>ncol(as.xyz(xyz))/3</code>. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_elety">elety</code></td>
<td>
<p> a character vector of element/atom types of length equal to
<code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element
character vector can be provided which will be repeated to match
the number of atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_chain">chain</code></td>
<td>
<p> a character vector of chain identifiers with length equal to
<code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element
character vector can be provided which will be repeated to match
the number of atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_insert">insert</code></td>
<td>
<p> a character vector of insertion code with length equal to
<code>ncol(as.xyz(xyz))/3</code>. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_alt">alt</code></td>
<td>
<p> a character vector of alternate record with length equal to
<code>ncol(as.xyz(xyz))/3</code>. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_o">o</code></td>
<td>
<p> a numeric vector of occupancy values of length equal to
<code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element
numeric vector can be provided which will be repeated for to match
the number of atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_b">b</code></td>
<td>
<p> a numeric vector of B-factors of length equal to <code>ncol(as.xyz(xyz))/3</code>.
Alternatively, a single element numeric vector can be provided
which will be repeated to match the number of atoms.</p>
</td></tr>
<tr><td><code id="as.pdb_+3A_segid">segid</code></td>
<td>
<p> a character vector of segment id of length equal to
<code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element character vector can
be provided which will be repeated to match the number of
atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_elesy">elesy</code></td>
<td>
<p> a character vector of element symbol of length equal to
<code>ncol(as.xyz(xyz))/3</code>. Alternatively, a single element character vector can
be provided which will be repeated to match the number of
atoms. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_charge">charge</code></td>
<td>
<p> a numeric vector of atomic charge of length equal to
<code>ncol(as.xyz(xyz))/3</code>. </p>
</td></tr>
<tr><td><code id="as.pdb_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the PDB generation process
is printed to screen. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts Tripos Mol2 format, Amber formatted parameter/topology
(PRMTOP) and coordinate objects, and vector data to a PDB object.
</p>
<p>While <code>as.pdb.mol2</code> and <code>as.pdb.prmtop</code> converts specific
objects to a PDB object, <code>as.pdb.default</code> provides basic
functionality to convert raw data such as vectors of e.g. residue numbers,
residue identifiers, Cartesian coordinates, etc to a PDB object. When
<code>pdb</code> is provided the returned PDB object is built from the input
object with fields replaced by any input vector arguments.
e.g. <code>as.pdb(pdb, xyz=crd)</code> will return the same PDB object, with
only the Cartesian coordinates changed to <code>crd</code>.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a data.frame containing all atomic coordinate ATOM data,
with a row per ATOM and a column per record type.  See below for details
of the record type naming convention (useful for accessing columns). </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of ATOM coordinate data of class <code>xyz</code>. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
<a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.crd">read.crd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Vector(s) to PDB object
pdb &lt;- as.pdb(resno=1:6, elety="CA", resid="ALA", chain="A")
pdb

## Not run: 
## Read a PRMTOP file
prmtop &lt;- read.prmtop(system.file("examples/crambin.prmtop", package="bio3d"))

## Read Amber coordinates
crds &lt;- read.crd(system.file("examples/crambin.inpcrd", package="bio3d"))

## Atom selection
ca.inds &lt;- atom.select(prmtop, "calpha")

## Convert to PDB format
pdb &lt;- as.pdb(prmtop, crds, inds=ca.inds)


## Read a single entry MOL2 file
## (returns a single object)
mol &lt;- read.mol2( system.file("examples/aspirin.mol2", package="bio3d") )

## Convert to PDB
pdb &lt;- as.pdb(mol)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.select'> Convert Atomic Indices to a Select Object </h2><span id='topic+as.select'></span>

<h3>Description</h3>

<p>Convert atomic indices to a select object with &lsquo;atom&rsquo; and
&lsquo;xyz&rsquo; components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.select(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.select_+3A_x">x</code></td>
<td>
<p> a numeric vector containing atomic indices to be converted
to a &lsquo;select&rsquo; object. Alternatively, a logical vector can be
provided. </p>
</td></tr>
<tr><td><code id="as.select_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert atomic indices to a select object with &lsquo;atom&rsquo; and
&lsquo;xyz&rsquo; components. 
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"select"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a numeric matrix of atomic indices. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of xyz indices. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.select(c(1,2,3))
</code></pre>

<hr>
<h2 id='atom.index'> Atom Names/Types </h2><span id='topic+atom.index'></span>

<h3>Description</h3>

<p>This data set gives for various atom names/types the corresponding
atomic symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom.index
</code></pre>


<h3>Format</h3>

<p>A data frame with the following components.
</p>

<dl>
<dt><code>name</code></dt><dd><p>a character vector containing atom names/types.</p>
</dd>
<dt><code>symb</code></dt><dd><p>a character vector containing atomic symbols.</p>
</dd>
</dl>



<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elements">elements</a></code>, <code><a href="#topic+atom.index">atom.index</a></code>,
<code><a href="#topic+atom2ele">atom2ele</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(atom.index)
atom.index

# Get the atomic symbol of some atoms
atom.names &lt;- c("CA", "O", "N", "OXT")
atom.index[match(atom.names, atom.index$name), "symb"]

</code></pre>

<hr>
<h2 id='atom.select'> Atom Selection from PDB and PRMTOP Structure Objects </h2><span id='topic+atom.select'></span><span id='topic+atom.select.pdb'></span><span id='topic+atom.select.pdbs'></span><span id='topic+atom.select.mol2'></span><span id='topic+atom.select.prmtop'></span><span id='topic+print.select'></span>

<h3>Description</h3>

<p>Return the &lsquo;atom&rsquo; and &lsquo;xyz&rsquo; coordinate indices of
&lsquo;pdb&rsquo; or &lsquo;prmtop&rsquo; structure objects corresponding to the
intersection of a hierarchical selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom.select(...)

## S3 method for class 'pdb'
atom.select(pdb, string = NULL,
                          type  = NULL, eleno = NULL, elety = NULL,
                          resid = NULL, chain = NULL, resno = NULL,
                          insert = NULL, segid = NULL, 
                          operator = "AND", inverse = FALSE,
                          value = FALSE, verbose=FALSE, ...)
## S3 method for class 'pdbs'
atom.select(pdbs, string = NULL, 
                           resno = NULL, chain = NULL, resid = NULL,
                           operator="AND", inverse = FALSE,
                           value = FALSE, verbose=FALSE, ...)
## S3 method for class 'mol2'
atom.select(mol, string=NULL,
                           eleno = NULL, elena = NULL, elety = NULL,
                           resid = NULL, chain = NULL, resno = NULL,
                           statbit = NULL,
			   operator = "AND", inverse = FALSE,
                           value = FALSE, verbose=FALSE,  ...)

## S3 method for class 'prmtop'
atom.select(prmtop, ...)

## S3 method for class 'select'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atom.select_+3A_...">...</code></td>
<td>
<p> arguments passed to <code>atom.select.pdb</code>,
<code>atom.select.prmtop</code>, or <code>print</code>. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_pdb">pdb</code></td>
<td>
<p> a structure object of class <code>"pdb"</code>, obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_pdbs">pdbs</code></td>
<td>
<p> a numeric matrix of aligned C-alpha xyz Cartesian
coordinates as obtained with <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or <code><a href="#topic+pdbaln">pdbaln</a></code>. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_string">string</code></td>
<td>
<p> a single selection keyword from <code>calpha</code>
<code>cbeta</code> <code>backbone</code> <code>sidechain</code> <code>protein</code>
<code>nucleic</code> <code>ligand</code> <code>water</code> <code>h</code> or <code>noh</code>. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_type">type</code></td>
<td>
<p> a single element character vector for selecting &lsquo;ATOM&rsquo;
or &lsquo;HETATM&rsquo; record types. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_eleno">eleno</code></td>
<td>
<p> a numeric vector of element numbers. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_elena">elena</code></td>
<td>
<p> a character vector of atom names. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_elety">elety</code></td>
<td>
<p> a character vector of atom names. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_resid">resid</code></td>
<td>
<p> a character vector of residue name identifiers. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_chain">chain</code></td>
<td>
<p> a character vector of chain identifiers. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_resno">resno</code></td>
<td>
<p> a numeric vector of residue numbers. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_insert">insert</code></td>
<td>
<p> a character vector of insert identifiers. Non-insert 
residues can be selected with <code>NA</code> or &lsquo;&rsquo; values. The default value 
of <code>NULL</code> will select both insert and non-insert residues. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_segid">segid</code></td>
<td>
<p> a character vector of segment identifiers. Empty segid
values can be selected with <code>NA</code> or &lsquo;&rsquo; values. The default value
of <code>NULL</code> will select both empty and non-empty segment identifiers. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_operator">operator</code></td>
<td>
<p> a single element character specifying either the AND
or OR operator by which individual selection components should be
combined. Allowed values are &lsquo;&quot;AND&quot;&rsquo; and &lsquo;&quot;OR&quot;&rsquo;. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the selection are printed. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_inverse">inverse</code></td>
<td>
<p> logical, if TRUE the inversed selection is retured
(i.e. all atoms NOT in the selection). </p>
</td></tr>
<tr><td><code id="atom.select_+3A_value">value</code></td>
<td>
<p> logical, if FALSE, vectors containing the (integer) indices of
the matches determined by <code>atom.select</code> are returned, and if TRUE,
a <code>pdb</code> object containing the matching atoms themselves is
returned. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_mol">mol</code></td>
<td>
<p> a structure object of class <code>"mol2"</code>, obtained from
<code><a href="#topic+read.mol2">read.mol2</a></code>. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_statbit">statbit</code></td>
<td>
<p> a character vector of statbit identifiers. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_prmtop">prmtop</code></td>
<td>
<p> a structure object of class <code>"prmtop"</code>, obtained from
<code><a href="#topic+read.prmtop">read.prmtop</a></code>. </p>
</td></tr>
<tr><td><code id="atom.select_+3A_x">x</code></td>
<td>
<p> a atom.select object as obtained from
<code><a href="#topic+atom.select">atom.select</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for the selection of atom and coordinate data
corresponding to the intersection of various input criteria.
</p>
<p>Input selection criteria include selection <code>string</code> keywords (such as
<code>"calpha"</code>, <code>"backbone"</code>, <code>"sidechain"</code>,  <code>"protein"</code>,
<code>"nucleic"</code>, <code>"ligand"</code>, etc.) and individual named
selection components (including &lsquo;chain&rsquo;,  &lsquo;resno&rsquo;,
&lsquo;resid&rsquo;, &lsquo;elety&rsquo; etc.).
</p>
<p>For example, <code>atom.select(pdb, "calpha")</code> will return indices for
all C-alpha (CA) atoms found in protein residues in the <code>pdb</code>
object, <code>atom.select(pdb, "backbone")</code> will return indices
for all protein N,CA,C,O atoms, and <code>atom.select(pdb, "cbeta")</code>
for all protein N,CA,C,O,CB atoms. 
</p>
<p>Note that keyword <code>string</code> shortcuts can be combined with individual
selection components, e.g. <code>atom.select(pdb, "protein", chain="A")</code>
will select all protein atoms found in chain A.
</p>
<p>Selection criteria are combined according to the provided
<code>operator</code> argument. The default operator <code>AND</code> (or <code>&amp;</code>) will
combine by intersection while <code>OR</code> (or <code>|</code>) will take the union.
</p>
<p>For example, <code>atom.select(pdb, "protein", elety=c("N", "CA", "C"),
  resno=65:103)</code> will select the N, CA, C atoms in the protein residues
65 through 103, while <code>atom.select(pdb, "protein", resid="ATP",
  operator="OR")</code> will select all protein atoms as well as any ATP
residue(s).
</p>
<p>Other <code>string</code> shortcuts include:
<code>"calpha"</code>, <code>"back"</code>, <code>"backbone"</code>, <code>"cbeta"</code>,
<code>"protein"</code>, <code>"notprotein"</code>, <code>"ligand"</code>,
<code>"water"</code>, <code>"notwater"</code>, <code>"h"</code>, <code>"noh"</code>,
<code>"nucleic"</code>, and <code>"notnucleic"</code>.
</p>
<p>In addition, the <code><a href="#topic+combine.select">combine.select</a></code> function can further combine atom
selections using &lsquo;AND&rsquo;, &lsquo;OR&rsquo;, or &lsquo;NOT&rsquo; logical
operations.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"select"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a numeric matrix of atomic indices. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of xyz indices. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Protein atoms are defined as any atom in a residue matching the
residue name in the attached <code>aa.table</code> data frame. See
<code>aa.table$aa3</code> for a complete list of residue names.
</p>
<p>Nucleic atoms are defined as all atoms found in residues with names A,
U, G, C, T, I, DA, DU, DG, DC, DT, or DI.
</p>
<p>Water atoms/residues are defined as those with residue names H2O, OH2,
HOH, HHO, OHH, SOL, WAT, TIP, TIP, TIP3, or TIP4.
</p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+as.select">as.select</a></code>,
<code><a href="#topic+combine.select">combine.select</a></code>, <code><a href="#topic+trim.pdb">trim.pdb</a></code>,
<code><a href="#topic+write.pdb">write.pdb</a></code>, <code><a href="#topic+read.prmtop">read.prmtop</a></code>,
<code><a href="#topic+read.crd">read.crd</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>,
<code><a href="#topic+read.ncdf">read.ncdf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##- PDB example
# Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

# Select protein atoms of chain A
atom.select(pdb, "protein", chain="A")

# Select all atoms except from the protein
atom.select(pdb, "protein", inverse=TRUE, verbose=TRUE)

# Select all C-alpha atoms with residues numbers between 43 and 54
sele &lt;- atom.select(pdb, "calpha", resno=43:54, verbose=TRUE)

# Access the PDB data with the selection indices
print( pdb$atom[ sele$atom, "resid" ] )
print( pdb$xyz[ sele$xyz ] )

# Trim PDB to selection
ca.pdb &lt;- trim.pdb(pdb, sele)

## Not run: 

##- PRMTOP example
prmtop &lt;- read.prmtop(system.file("examples/crambin.prmtop", package="bio3d"))

## Atom selection
ca.inds &lt;- atom.select(prmtop, "calpha")


## End(Not run)
</code></pre>

<hr>
<h2 id='atom2ele'> Atom Names/Types to Atomic Symbols Converter </h2><span id='topic+atom2ele'></span><span id='topic+atom2ele.default'></span><span id='topic+atom2ele.pdb'></span>

<h3>Description</h3>

<p>Convert atom names/types into atomic symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom2ele(...)

## Default S3 method:
atom2ele(x, elety.custom=NULL, rescue=TRUE, ...)

## S3 method for class 'pdb'
atom2ele(pdb, inds=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atom2ele_+3A_x">x</code></td>
<td>
<p>a character vector containing atom names/types to be converted.</p>
</td></tr>
<tr><td><code id="atom2ele_+3A_elety.custom">elety.custom</code></td>
<td>
<p>a customized data.frame containing atom
names/types and corresponding atomic symbols.</p>
</td></tr> 
<tr><td><code id="atom2ele_+3A_rescue">rescue</code></td>
<td>
<p>logical, if TRUE the atomic symbols will be converted 
based on matching with <code>bio3d::elements$symb</code>. </p>
</td></tr>
<tr><td><code id="atom2ele_+3A_pdb">pdb</code></td>
<td>
<p>an object of class &lsquo;pdb&rsquo; for which <code>elety</code> will
be converted.</p>
</td></tr> 
<tr><td><code id="atom2ele_+3A_inds">inds</code></td>
<td>
<p>an object of class &lsquo;select&rsquo; indicating a subset of
the <code>pdb</code> object to be used (see <code><a href="#topic+atom.select">atom.select</a></code> and
<code><a href="#topic+trim.pdb">trim.pdb</a></code>).</p>
</td></tr> 
<tr><td><code id="atom2ele_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The default method searchs for the atom names/types in the
<code><a href="#topic+atom.index">atom.index</a></code> data set and returns their corresponding atomic
symbols. If <code>elety.custom</code> is specified it is combined with
<code><a href="#topic+atom.index">atom.index</a></code> (using <code>rbind</code>) before
searching. Therefore, <code>elety.custom</code> must contains columns named
<code>name</code> and <code>symb</code>. 
</p>
<p>The S3 method for object of class &lsquo;pdb&rsquo;, pass
<code>pdb$atom[,"elety"]</code> to the default method. 
</p>


<h3>Value</h3>

<p>Return a character vector of atomic symbols</p>


<h3>Author(s)</h3>

<p>Julien Ide, Lars Skjaerven</p>


<h3>See Also</h3>

<p><code><a href="#topic+atom.index">atom.index</a></code>,  <code><a href="#topic+elements">elements</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+atom2mass">atom2mass</a></code>, <code><a href="#topic+formula2mass">formula2mass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>atom.names &lt;- c("CA", "O", "N", "OXT")
atom2ele(atom.names)


# PDB server connection required - testing excluded

## Get atomic symbols from a PDB object with a customized data set
pdb &lt;- read.pdb("3RE0",verbose=FALSE)
lig &lt;- trim(pdb, "ligand")

## maps PT1 to Pt, CL2 to Cl, C4A to C
atom2ele(lig)

## map atom name to element manually
myelety &lt;- data.frame(name = "CL2", symb = "Cl")
atom2ele(lig, elety.custom = myelety)


</code></pre>

<hr>
<h2 id='atom2mass'> Atom Names/Types to Mass Converter </h2><span id='topic+atom2mass'></span><span id='topic+atom2mass.default'></span><span id='topic+atom2mass.pdb'></span>

<h3>Description</h3>

<p>Convert atom names/types into atomic masses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom2mass(...)
## Default S3 method:
atom2mass(x, mass.custom=NULL, elety.custom=NULL,
                            grpby=NULL, rescue=TRUE, ...) 
## S3 method for class 'pdb'
atom2mass(pdb, inds=NULL, mass.custom=NULL,
                        elety.custom=NULL, grpby=NULL, rescue=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atom2mass_+3A_x">x</code></td>
<td>
<p> a character vector containing atom names/types to be
converted. </p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_mass.custom">mass.custom</code></td>
<td>
<p> a customized data.frame containing atomic symbols
and corresponding masses. </p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_elety.custom">elety.custom</code></td>
<td>
<p> a customized data.frame containing atom
names/types and corresponding atomic symbols.</p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_grpby">grpby</code></td>
<td>
<p>a &lsquo;factor&rsquo;, as returned by <code>as.factor</code>, used
to group the atoms.</p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_rescue">rescue</code></td>
<td>
<p> logical, if TRUE the atomic symbols will be mapped to
the first character of the atom names/types.</p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_pdb">pdb</code></td>
<td>
<p> an object of class &lsquo;pdb&rsquo; for which <code>elety</code> will
be converted.</p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_inds">inds</code></td>
<td>
<p> an object of class &lsquo;select&rsquo; indicating a subset of
the <code>pdb</code> object to be used (see <code><a href="#topic+atom.select">atom.select</a></code> and
<code><a href="#topic+trim.pdb">trim.pdb</a></code>).</p>
</td></tr> 
<tr><td><code id="atom2mass_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method first convert atom names/types into atomic symbols
using the <code><a href="#topic+atom2ele">atom2ele</a></code> function. Then, atomic symbols are
searched in the <code>elements</code> data set and their corresponding masses
are returned. If <code>mass.custom</code> is specified it is combined with
<code>elements</code> (using <code>rbind</code>) before searching. Therefore,
<code>mass.custom</code> must have columns named <code>symb</code> and <code>mass</code>
(see examples). If <code>grpby</code> is specified masses are splitted (using
<code>split</code>) to compute the mass of groups of atoms defined by
<code>grpby</code>. 
</p>
<p>The S3 method for object of class &lsquo;pdb&rsquo;, pass
<code>pdb$atom$elety</code> to the default method. 
</p>


<h3>Value</h3>

<p>Return a numeric vector of masses.</p>


<h3>Author(s)</h3>

<p>Julien Ide, Lars Skjaerven</p>


<h3>See Also</h3>

<p><code><a href="#topic+elements">elements</a></code>, <code><a href="#topic+atom.index">atom.index</a></code>,
<code><a href="#topic+atom2ele">atom2ele</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>atom.names &lt;- c("CA", "O", "N", "OXT")
atom2mass(atom.names)


# PDB server connection required - testing excluded

## Get atomic symbols from a PDB object with a customized data set
pdb &lt;- read.pdb("3RE0", verbose=FALSE)
inds &lt;- atom.select(pdb, resno=201, verbose=FALSE)

## selected atoms
print(pdb$atom$elety[inds$atom])

## default will map CL2 to C
atom2mass(pdb, inds)

## map element CL2 correctly to Cl
myelety  &lt;- data.frame(name = c("CL2","PT1","N1","N2"), symb = c("Cl","Pt","N","N"))
atom2mass(pdb, inds, elety.custom = myelety)

## custom masses
mymasses &lt;- data.frame(symb = c("Cl","Pt"), mass = c(35.45, 195.08))
atom2mass(pdb, inds, elety.custom = myelety, mass.custom = mymasses)


</code></pre>

<hr>
<h2 id='atom2xyz'> Convert Between Atom and xyz Indices </h2><span id='topic+atom2xyz'></span><span id='topic+xyz2atom'></span>

<h3>Description</h3>

<p>Basic functions to convert between xyz and their corresponding atom indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom2xyz(num)
xyz2atom(xyz.ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atom2xyz_+3A_num">num</code></td>
<td>
<p> a numeric vector of atom indices. </p>
</td></tr>
<tr><td><code id="atom2xyz_+3A_xyz.ind">xyz.ind</code></td>
<td>
<p> a numeric vector of xyz indices. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of either xyz or atom indices.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz.ind &lt;- atom2xyz(c(1,10,15))
xyz2atom( xyz.ind )
</code></pre>

<hr>
<h2 id='basename.pdb'>
Manipulate PDB File Names
</h2><span id='topic+basename.pdb'></span>

<h3>Description</h3>

<p>Removes all of the path up to and including the last 
path separator (if any) and the final &lsquo;.pdb&rsquo; extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basename.pdb(x, mk4 = FALSE, ext=".pdb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basename.pdb_+3A_x">x</code></td>
<td>
<p> character vector of PDB file names, containing path and extensions.</p>
</td></tr>
<tr><td><code id="basename.pdb_+3A_mk4">mk4</code></td>
<td>
<p> logical, if TRUE the output will be truncated to the first 4 
characters of the basename. This is frequently convenient for matching RCSB 
PDB identifier conventions (see examples below). </p>
</td></tr>
<tr><td><code id="basename.pdb_+3A_ext">ext</code></td>
<td>
<p> character, specifying the file extension,
e.g. &lsquo;.pdb&rsquo; or &lsquo;.mol2&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple utility function for the common task of PDB file name manipulation. It is used internally in several bio3d functions and van be thought of as basename for PDB files. 
</p>


<h3>Value</h3>

<p>A character vector of the same length as the input &lsquo;x&rsquo;.
</p>
<p>Paths not containing any separators are taken to be in the current directory.
</p>
<p>If an element of input is &lsquo;x&rsquo; is &lsquo;NA&rsquo;, so is the result.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+basename">basename</a></code>, <code><a href="base.html#topic+dirname">dirname</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	basename.pdb("/somedir/somewhere/1bg2_myfile.pdb")
	basename.pdb("/somedir/somewhere/1bg2_myfile.pdb", TRUE)
</code></pre>

<hr>
<h2 id='bhattacharyya'> Bhattacharyya Coefficient </h2><span id='topic+bhattacharyya'></span><span id='topic+bhattacharyya.nma'></span><span id='topic+bhattacharyya.pca'></span><span id='topic+bhattacharyya.enma'></span><span id='topic+bhattacharyya.array'></span><span id='topic+bhattacharyya.matrix'></span>

<h3>Description</h3>

<p>Calculate the Bhattacharyya Coefficient as a similarity between two
modes objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bhattacharyya(...)

## S3 method for class 'enma'
bhattacharyya(enma, covs=NULL, ncore=NULL, ...)

## S3 method for class 'array'
bhattacharyya(covs, ncore=NULL, ...)

## S3 method for class 'matrix'
bhattacharyya(a, b, q=90, n=NULL, ...)

## S3 method for class 'nma'
bhattacharyya(...)

## S3 method for class 'pca'
bhattacharyya(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bhattacharyya_+3A_enma">enma</code></td>
<td>
<p> an object of class <code>"enma"</code> obtained from function
<code>nma.pdbs</code>. </p>
</td></tr>
<tr><td><code id="bhattacharyya_+3A_covs">covs</code></td>
<td>
<p> an array of covariance matrices of equal dimensions. </p>
</td></tr>
<tr><td><code id="bhattacharyya_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="bhattacharyya_+3A_a">a</code></td>
<td>
<p> covariance matrix to be compared with <code>b</code>. </p>
</td></tr>
<tr><td><code id="bhattacharyya_+3A_b">b</code></td>
<td>
<p> covariance matrix to be compared with <code>a</code>. </p>
</td></tr>
<tr><td><code id="bhattacharyya_+3A_q">q</code></td>
<td>
<p> a numeric value (in percent) determining the number of modes
to be compared. </p>
</td></tr>
<tr><td><code id="bhattacharyya_+3A_n">n</code></td>
<td>
<p> the number of modes to be compared. </p>
</td></tr>
<tr><td><code id="bhattacharyya_+3A_...">...</code></td>
<td>
<p> arguments passed to associated functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bhattacharyya coefficient provides a means to compare two covariance
matrices derived from NMA or an ensemble of conformers
(e.g. simulation or X-ray conformers).  
</p>


<h3>Value</h3>

<p>Returns the similarity coefficient(s).
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.   
Fuglebakk, E. et al. (2013) <em>JCTC</em> <b>9</b>, 5618&ndash;5628.
</p>


<h3>See Also</h3>

<p>Other similarity measures:
<code><a href="#topic+sip">sip</a></code>, <code><a href="#topic+covsoverlap">covsoverlap</a></code>, <code><a href="#topic+rmsip">rmsip</a></code>.
</p>

<hr>
<h2 id='binding.site'> Binding Site Residues </h2><span id='topic+binding.site'></span>

<h3>Description</h3>

<p>Determines the interacting residues between two PDB entities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binding.site(a, b=NULL, a.inds=NULL, b.inds=NULL, cutoff=5,
            hydrogens=TRUE, byres=TRUE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binding.site_+3A_a">a</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="binding.site_+3A_b">b</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="binding.site_+3A_a.inds">a.inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from <code>atom.select</code>
that selects the elements of <code>a</code> upon which the calculation
should be based.</p>
</td></tr>
<tr><td><code id="binding.site_+3A_b.inds">b.inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from <code>atom.select</code>
that selects the elements of <code>b</code> upon which the calculation
should be based.</p>
</td></tr>
<tr><td><code id="binding.site_+3A_cutoff">cutoff</code></td>
<td>
<p> distance cutoff </p>
</td></tr>
<tr><td><code id="binding.site_+3A_hydrogens">hydrogens</code></td>
<td>
<p> logical, if FALSE hydrogen atoms are omitted from
the calculation. </p>
</td></tr>
<tr><td><code id="binding.site_+3A_byres">byres</code></td>
<td>
<p> logical, if TRUE all atoms in a contacting residue is
returned. </p>
</td></tr>
<tr><td><code id="binding.site_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the selection are printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reports the residues of <code>a</code> closer than a cutoff to
<code>b</code>. This is a wrapper function calling the underlying function
<code>dist.xyz</code>.
</p>
<p>If <code>b=NULL</code> then <code>b.inds</code> should be elements of <code>a</code>
upon which the calculation is based (typically chain A and B of the
same PDB file).
</p>
<p>If <code>b=a.inds=b.inds=NULL</code> the function will use
<code><a href="#topic+atom.select">atom.select</a></code> with arguments <code>"protein"</code> and
<code>"ligand"</code> to determine receptor and ligand, respectively.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>inds</code></td>
<td>
<p> object of class <code>select</code> with <code>atom</code> and
<code>xyz</code> components. </p>
</td></tr>
<tr><td><code>inds$atom</code></td>
<td>
<p> atom indices of <code>a</code>. </p>
</td></tr>
<tr><td><code>inds$xyz</code></td>
<td>
<p> xyz indices of <code>a</code>. </p>
</td></tr>
<tr><td><code>resnames</code></td>
<td>
<p> a character vector of interacting residues. </p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p> a numeric vector of interacting residues numbers. </p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p> a character vector of the associated chain identifiers
of <code>"resno"</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+dm">dm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   
    # PDB server connection required - testing excluded

     pdb &lt;- read.pdb('3dnd')

     ## automatically identify 'protein' and 'ligand'
     bs &lt;- binding.site(pdb)

     bs$resnames
     #pdb$atom[bs$inds$atom, ]

     # provide indices
     rec.inds &lt;- atom.select(pdb, chain="A", resno=1:350)
     lig.inds &lt;- atom.select(pdb, chain="A", resno=351)
     bs &lt;- binding.site(pdb, a.inds=rec.inds, b.inds=lig.inds)
   


   ## Not run:   
     # Interaction between peptide and protein
     rec.inds &lt;- atom.select(pdb, chain='A', resno=c(1:350))
     lig.inds &lt;- atom.select(pdb, chain='I', resno=c(5:24))
     bs &lt;- binding.site(pdb, a.inds=rec.inds, b.inds=lig.inds)
   
## End(Not run)

   
    # Redundant testing excluded

     # Interaction between two PDB entities   
     #rec &lt;- read.pdb("receptor.pdb")
     #lig &lt;- read.pdb("ligand.pdb")
     rec &lt;- trim.pdb(pdb, inds=rec.inds)
     lig &lt;- trim.pdb(pdb, inds=lig.inds)
     bs &lt;- binding.site(rec, lig, hydrogens=FALSE)
   
</code></pre>

<hr>
<h2 id='biounit'>Biological Units Construction</h2><span id='topic+biounit'></span>

<h3>Description</h3>

<p>Construct biological assemblies/units based on a 'pdb' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biounit(pdb, biomat = NULL, multi = FALSE, ncore = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biounit_+3A_pdb">pdb</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from
function <code><a href="#topic+read.pdb">read.pdb</a></code>.</p>
</td></tr>
<tr><td><code id="biounit_+3A_biomat">biomat</code></td>
<td>
<p>a list object as returned by <code>read.pdb</code> 
(pdb$remark$biomat), containing matrices for 
symmetry operation on individual chains to build biological units.
It will override the matrices stored in <code>pdb</code>.</p>
</td></tr>
<tr><td><code id="biounit_+3A_multi">multi</code></td>
<td>
<p>logical, if TRUE the biological unit is returned as a 
'multi-model' <code>pdb</code> object with each symmetric copy a distinct
structural 'MODEL'. Otherwise, all copies are represented 
as separated chains.</p>
</td></tr>
<tr><td><code id="biounit_+3A_ncore">ncore</code></td>
<td>
<p>number of CPU cores used to do the calculation. By default
(<code>ncore=NULL</code>), use all available CPU cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A valid structural/simulation study should be performed on the biological 
unit of a protein system. For example, the alpha2-beta2 tetramer form of
hemoglobin. However, canonical PDB files usually contain the asymmetric unit of 
the crystal cell, which can be:
</p>

<ol>
<li><p> One biological unit 
</p>
</li>
<li><p> A portion of a biological unit 
</p>
</li>
<li><p> Multiple biological units
</p>
</li></ol>

<p>The function performs symmetry operations to the coordinates based on the 
transformation matrices stored in a 'pdb' object returned by 
<code><a href="#topic+read.pdb">read.pdb</a></code>, and returns biological units stored as a list of
<code>pdb</code> objects.
</p>


<h3>Value</h3>

<p>a list of <code>pdb</code> objects with each representing an individual 
biological unit.
</p>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # PDB server connection required - testing excluded

   pdb &lt;- read.pdb("2dn1")
   biounit &lt;- biounit(pdb)
   pdb
   biounit

## Not run: 
   biounit &lt;- biounit(read.pdb("2bfu"), multi=TRUE)
   write.pdb(biounit[[1]], file="biounit.pdb")
   # open the pdb file in VMD to have a look on the biological unit

## End(Not run) 
</code></pre>

<hr>
<h2 id='blast.pdb'> NCBI BLAST Sequence Search and Summary Plot of Hit Statistics</h2><span id='topic+blast.pdb'></span><span id='topic+get.blast'></span><span id='topic+plot.blast'></span>

<h3>Description</h3>

<p>Run NCBI blastp, on a given sequence, against the PDB, NR and
swissprot sequence databases. Produce plots that facilitate hit selection
from the match statistics of a BLAST result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blast.pdb(seq, database = "pdb", time.out = NULL, chain.single=TRUE)

get.blast(urlget, time.out = NULL, chain.single=TRUE)

## S3 method for class 'blast'
plot(x, cutoff = NULL, cut.seed=NULL, cluster=TRUE, mar=c(2, 5, 1, 1), cex=1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blast.pdb_+3A_seq">seq</code></td>
<td>
<p> a single element or multi-element character vector
containing the query sequence. Alternatively a &lsquo;fasta&rsquo;
object from function <code>get.seq</code> or &lsquo;pdb&rsquo; object from 
function <code>read.pdb</code> can be provided. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_database">database</code></td>
<td>
<p> a single element character vector specifying the
database against which to search. Current options are &lsquo;pdb&rsquo;,
&lsquo;nr&rsquo; and &lsquo;swissprot&rsquo;. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_time.out">time.out</code></td>
<td>
<p> integer specifying the number of seconds to wait for
the blast reply before a time out occurs. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_urlget">urlget</code></td>
<td>
<p> the URL to retrieve BLAST results; Usually it is returned
by blast.pdb if time.out is set and met. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_chain.single">chain.single</code></td>
<td>
<p> logical, if TRUE double NCBI character PDB database  
chain identifiers are simplified to lowercase '1WF4_GG' &gt; '1WF4_g'. If 
FALSE no conversion to match RCSB PDB files is performed. </p>
</td></tr> 
<tr><td><code id="blast.pdb_+3A_x">x</code></td>
<td>
<p> BLAST results as obtained from the function
<code><a href="#topic+blast.pdb">blast.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_cutoff">cutoff</code></td>
<td>
<p> A numeric cutoff value, in terms of minus the log of
the evalue, for returned hits.  If null then the function will
try to find a suitable cutoff near &lsquo;cut.seed&rsquo; which can be used
as an initial guide (see below). </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_cut.seed">cut.seed</code></td>
<td>
<p> A numeric seed cutoff value, used for initial
cutoff estimation. If null then a seed position is set to the point of 
largest drop-off in normalized scores (i.e. the biggest jump in 
E-values). </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_cluster">cluster</code></td>
<td>
<p> Logical, if TRUE (and &lsquo;cutoff&rsquo; is null) a clustering 
of normalized scores is performed to partition hits in groups by 
similarity to query. If FALSE the partition point is set to the point of largest drop-off in normalized scores. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_mar">mar</code></td>
<td>
<p> A numerical vector of the form c(bottom, left, top, right)
which gives the number of lines of margin to be specified on the
four sides of the plot.</p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_cex">cex</code></td>
<td>
<p> a numerical single element vector giving the amount by
which plot labels should be magnified relative to the default. </p>
</td></tr>
<tr><td><code id="blast.pdb_+3A_...">...</code></td>
<td>
<p> extra plotting arguments. </p>
</td></tr>    
</table>


<h3>Details</h3>

<p>The <code>blast.pdb</code> function employs direct HTTP-encoded requests to the NCBI web
server to run BLASTP, the protein search algorithm of the BLAST
software package.
</p>
<p>BLAST, currently the most popular pairwise sequence comparison algorithm 
for database searching, performs gapped local alignments via a heuristic 
strategy: it identifies short nearly exact matches or hits, bidirectionally 
extends non-overlapping hits resulting in ungapped extended hits or 
high-scoring segment pairs(HSPs), and finally extends the highest scoring 
HSP in both directions via a gapped alignment (Altschul et al., 1997)
</p>
<p>For each pairwise alignment BLAST reports the raw score, bitscore
and an E-value that assess the statistical significance of the
raw score. Note that unlike the raw score E-values are normalized with
respect to both the substitution matrix and the query and database lengths.
</p>
<p>Here we also return a corrected normalized score (mlog.evalue) that in
our experience is easier to handle and store than conventional
E-values. In practice, this score is equivalent to minus the natural
log of the E-value. Note that, unlike the raw score, this score is
independent of the substitution matrix and and the query and database
lengths, and thus is comparable between BLASTP searches. 
</p>
<p>Examining plots of BLAST alignment lengths, scores, E-values and normalized
scores (-log(E-Value) from the <code>blast.pdb</code> function can aid in the
identification sensible hit similarity thresholds. This is facilitated by 
the <code>plot.blast</code> function.
</p>
<p>If a &lsquo;cutoff&rsquo; value is not supplied then a basic hierarchical
clustering of normalized scores is performed with initial group partitioning
implemented at a hopefully sensible point in the vicinity of
&lsquo;h=cut.seed&rsquo;. Inspection of the resultant plot can then be use
to refine the value of &lsquo;cut.seed&rsquo; or indeed
&lsquo;cutoff&rsquo;. As the &lsquo;cutoff&rsquo; value can vary depending on
the desired application and indeed the properties of the system under
study it is envisaged that &lsquo;plot.blast&rsquo; will be called multiple
times to aid selection of a suitable &lsquo;cutoff&rsquo; value. See the
examples below for further details.
</p>


<h3>Value</h3>

<p>The function <code>blast.pdb</code> returns a list with three components,
<code>hit.tbl</code>, <code>raw</code>, and <code>url</code>. 
The function <code>plot.blast</code> produces a plot on the 
active graphics device and returns a list object with four components,
<code>hits</code>, <code>pdb.id</code>, <code>acc</code>, and <code>inds</code>. See below:
</p>
<table>
<tr><td><code>hit.tbl</code></td>
<td>
<p> a data frame summarizing BLAST results for each
reported hit. It contains following major columns:
</p>

<ul>
<li> <p>&lsquo;bitscore&rsquo;, a numeric vector containing the raw score for each
alignment.
</p>
</li>
<li> <p>&lsquo;evalue&rsquo;, a numeric vector containing the E-value of the raw
score for each alignment. 
</p>
</li>
<li> <p>&lsquo;mlog.evalue&rsquo;, a numeric vector containing minus the natural log
of the E-value. 
</p>
</li>
<li> <p>&lsquo;acc&rsquo;, a character vector containing the accession database identifier of
each hit.  
</p>
</li>
<li> <p>&lsquo;pdb.id&rsquo;, a character vector containing the PDB database identifier of
each hit. 
</p>
</li></ul>
 
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p> a data frame containing the raw BLAST output. Note multiple
hits may appear in the same row. </p>
</td></tr>
<tr><td><code>url</code></td>
<td>
<p> a single element character vector with the NCBI result URL and 
RID code. This can be passed to the get.blast function. </p>
</td></tr>
<tr><td><code>hits</code></td>
<td>
<p> an ordered matrix detailing the subset of hits with a normalized
score above the chosen cutoff. Database identifiers are listed along
with their cluster group number. </p>
</td></tr>
<tr><td><code>pdb.id</code></td>
<td>
<p> a character vector containing the PDB database identifier of
each hit above the chosen threshold. </p>
</td></tr>
<tr><td><code>acc</code></td>
<td>
<p> a character vector containing the accession database identifier of
each hit above the chosen threshold. </p>
</td></tr>
<tr><td><code>inds</code></td>
<td>
<p> a numeric vector containing the indices of the hits
relative to the input blast object.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Online access is required to query NCBI blast services.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;BLAST&rsquo; is the work of Altschul et al.:
Altschul, S.F. et al. (1990) <em>J. Mol. Biol.</em> <b>215</b>, 403&ndash;410.
</p>
<p>Full details of the &lsquo;BLAST&rsquo; algorithm, along with download and
installation instructions can be obtained from:<br />
<a href="https://www.ncbi.nlm.nih.gov/BLAST/">https://www.ncbi.nlm.nih.gov/BLAST/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.blast">plot.blast</a></code>, <code><a href="#topic+hmmer">hmmer</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+get.pdb">get.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pdb &lt;- read.pdb("4q21")
blast &lt;- blast.pdb( pdbseq(pdb) )

head(blast$hit.tbl)
top.hits &lt;- plot(blast)
head(top.hits$hits)

## Use 'get.blast()' to retrieve results at a later time.
#x &lt;- get.blast(blast$url)
#head(x$hit.tbl)

# Examine and download 'best' hits
top.hits &lt;- plot.blast(blast, cutoff=188)
head(top.hits$hits)
#get.pdb(top.hits)

## End(Not run)
</code></pre>

<hr>
<h2 id='bounds'> Bounds of a Numeric Vector </h2><span id='topic+bounds'></span>

<h3>Description</h3>

<p>Find the &lsquo;bounds&rsquo; (i.e. start, end and length) of consecutive
numbers within a larger set of numbers in a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bounds(nums, dup.inds=FALSE, pre.sort=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_nums">nums</code></td>
<td>
<p> a numeric vector. </p>
</td></tr>
<tr><td><code id="bounds_+3A_dup.inds">dup.inds</code></td>
<td>
<p> logical, if TRUE the bounds of consecutive duplicated
elements are returned. </p>
</td></tr>
<tr><td><code id="bounds_+3A_pre.sort">pre.sort</code></td>
<td>
<p> logical, if TRUE the input vector is ordered prior to
bounds determination. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple utility function useful for summarizing the contents
of a numeric vector. For example: find the start position, end
position and lengths of secondary structure elements given a vector
of residue numbers obtained from a DSSP secondary structure
prediction.
</p>
<p>By setting &lsquo;dup.inds&rsquo; to TRUE then the indices of the first
(start) and last (end) duplicated elements of the vector are
returned. For example: find the indices of atoms belonging to a particular
residue given a vector of residue numbers (see below).
</p>


<h3>Value</h3>

<p>Returns a three column matrix listing starts, ends and lengths.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>,
2695&ndash;2696.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- c(seq(1,5,1),8,seq(10,15,1))
 bounds(test)

 test &lt;- rep(c(1,2,4), times=c(2,3,4))
 bounds(test, dup.ind=TRUE)
</code></pre>

<hr>
<h2 id='bounds.sse'>Obtain A SSE Object From An SSE Sequence Vector</h2><span id='topic+bounds.sse'></span>

<h3>Description</h3>

<p>Inverse process of the funciton <code><a href="#topic+pdb2sse">pdb2sse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds.sse(x, pdb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds.sse_+3A_x">x</code></td>
<td>
<p>a character vector indicating SSE for each amino acid residue.</p>
</td></tr>
<tr><td><code id="bounds.sse_+3A_pdb">pdb</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from
function <code><a href="#topic+read.pdb">read.pdb</a></code>. Can be ignored if <code>x</code> has 'names'
attribute for residue labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>call for its effects.
</p>


<h3>Value</h3>

<p>a 'sse' object.
</p>


<h3>Note</h3>

<p>In both <code>$helix</code> and <code>$sheet</code>, an additional 
<code>$id</code> component is added to indicate the original numbering of the sse.
This is particularly useful in e.g. <code>trim.pdb()</code> function.
</p>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Barry Grant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdb2sse">pdb2sse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # PDB server connection required - testing excluded

   pdb &lt;- read.pdb("1a7l")
   sse &lt;- pdb2sse(pdb)
   sse.ind &lt;- bounds.sse(sse)
   sse.ind 
 
</code></pre>

<hr>
<h2 id='bwr.colors'> Color Palettes </h2><span id='topic+bwr.colors'></span><span id='topic+mono.colors'></span>

<h3>Description</h3>

<p>Create a vector of &lsquo;n&rsquo; &ldquo;contiguous&rdquo; colors forming
either a Blue-White-Red or a White-Gray-Black color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwr.colors(n)
mono.colors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwr.colors_+3A_n">n</code></td>
<td>
<p> the number of colors in the palette (&gt;=1). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>bwr.colors</code> returns a vector of <code>n</code> color
names that range from blue through white to red.
</p>
<p>The function <code>mono.colors</code> returns color names ranging from
white to black.  Note: the first element of the returned vector
will be NA. 
</p>


<h3>Value</h3>

<p>Returns a character vector, <code>cv</code>, of color names.  This can be
used either to create a user-defined color palette for subsequent
graphics with <code>palette(cv)</code>, or as a <code>col=</code> specification in
graphics functions and <code>par</code>.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>The <code>bwr.colors</code> function is derived from the <code>gplots</code>
package function <code>colorpanel</code> by Gregory R. Warnes.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+vmd_colors">vmd_colors</a></code>, <code><a href="grDevices.html#topic+cm.colors">cm.colors</a></code>,
<code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="grDevices.html#topic+palette">palette</a></code>, <code><a href="grDevices.html#topic+hsv">hsv</a></code>,
<code><a href="grDevices.html#topic+rgb">rgb</a></code>, <code><a href="grDevices.html#topic+gray">gray</a></code>, <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redundant testing excluded

# Color a distance matrix
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
d &lt;- dm(pdb,"calpha")

plot(d, color.palette=bwr.colors)

plot(d,
     resnum.1 = pdb$atom[pdb$calpha,"resno"],
     color.palette = mono.colors,
     xlab="Residue Number", ylab="Residue Number")

</code></pre>

<hr>
<h2 id='cat.pdb'> Concatenate Multiple PDB Objects </h2><span id='topic+cat.pdb'></span>

<h3>Description</h3>

<p>Produce a new concatenated PDB object from two or more smaller PDB objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat.pdb(..., renumber=FALSE, rechain=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat.pdb_+3A_...">...</code></td>
<td>
<p> two or more PDB structure objects obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="cat.pdb_+3A_renumber">renumber</code></td>
<td>
<p> logical, if &lsquo;TRUE&rsquo; residues will be
renumbered. </p>
</td></tr>
<tr><td><code id="cat.pdb_+3A_rechain">rechain</code></td>
<td>
<p> logical, if &lsquo;TRUE&rsquo; molecules will be assigned
new chain identifiers. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic utility function for creating a concatenated PDB
object based on multipe smaller PDB objects. 
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"pdb"</code>. See <code><a href="#topic+read.pdb">read.pdb</a></code> for
further details. 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+write.pdb">write.pdb</a></code>, <code><a href="#topic+trim.pdb">trim.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read a PDB file from the RCSB online database
pdb1 &lt;- read.pdb("1etl")
pdb2 &lt;- read.pdb("1hel")

## Concat
new.pdb &lt;- cat.pdb(pdb1, pdb2, pdb1, rechain=TRUE, renumber=TRUE)

## Write to file
write.pdb(new.pdb, file="concat.pdb")

## End(Not run)
</code></pre>

<hr>
<h2 id='chain.pdb'> Find Possible PDB Chain Breaks </h2><span id='topic+chain.pdb'></span>

<h3>Description</h3>

<p>Find possible chain breaks based on connective Calpha or peptide
bond (C-N) atom separation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain.pdb(pdb, ca.dist = 4, bond=TRUE, bond.dist=1.5, blank = "X", rtn.vec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain.pdb_+3A_pdb">pdb</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="chain.pdb_+3A_ca.dist">ca.dist</code></td>
<td>
<p> the maximum distance that separates Calpha atoms
considered to be in the same chain. </p>
</td></tr>
<tr><td><code id="chain.pdb_+3A_bond">bond</code></td>
<td>
<p> logical, if TRUE inspect peptide bond (C-N) instead
of Calpha-Calpha distances whenever possible.</p>
</td></tr>
<tr><td><code id="chain.pdb_+3A_bond.dist">bond.dist</code></td>
<td>
<p> cutoff value for C-N distance separation. </p>
</td></tr>
<tr><td><code id="chain.pdb_+3A_blank">blank</code></td>
<td>
<p> a character to assign non-protein atoms. </p>
</td></tr>
<tr><td><code id="chain.pdb_+3A_rtn.vec">rtn.vec</code></td>
<td>
<p> logical, if TRUE then the one-letter chain vector
consisting of the 26 upper-case letters of the Roman alphabet is
returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic function for finding possible chain breaks in PDB
structure files, i.e. connective Calpha atoms that are further than
<code>ca.dist</code> apart or peptide bond (C-N) atoms separated by at 
least <code>bond.dist</code>.
</p>


<h3>Value</h3>

<p>Prints basic chain information and if <code>rtn.vec</code> is TRUE returns a
character vector of chain ids consisting of the 26 upper-case letters of the
Roman alphabet plus possible <code>blank</code> entries for non-protein atoms.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+trim.pdb">trim.pdb</a></code>,
<code><a href="#topic+write.pdb">write.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

full.pdb &lt;- read.pdb( get.pdb("5p21", URLonly=TRUE) )
inds &lt;- atom.select(full.pdb, resno=c(10:20,30:33))
cut.pdb &lt;- trim.pdb(full.pdb, inds)
chain.pdb(cut.pdb)

</code></pre>

<hr>
<h2 id='check.utility'> Check on Missing Utility Programs </h2><span id='topic+check.utility'></span>

<h3>Description</h3>

<p>Internally used in examples, tests, or vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  check.utility(x = c("muscle", "clustalo", "dssp", "stride", 
                "mustang", "makeup"), quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.utility_+3A_x">x</code></td>
<td>
<p> Names of one or more utility programs to check. </p>
</td></tr>
<tr><td><code id="check.utility_+3A_quiet">quiet</code></td>
<td>
<p> logical, if TRUE no warning or message printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if requested utility programs are availabe or not.
</p>


<h3>Value</h3>

<p>logical, TRUE if programs are available and FALSE if any one of 
them is missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   check.utility(c("muscle", "dssp"), quiet=FALSE)
   if(!check.utility("mustang")) 
      cat(" The utility program, MUSTANG, is missing on your system\n")
</code></pre>

<hr>
<h2 id='clean.pdb'>Inspect And Clean Up A PDB Object</h2><span id='topic+clean.pdb'></span>

<h3>Description</h3>

<p>Inspect alternative coordinates, chain breaks, bad residue
numbering, non-standard/unknow amino acids, etc. Return
a 'clean' pdb object with fixed residue numbering and optionally
relabeled chain IDs, corrected amino acid names, removed water,
ligand, or hydrogen atoms. All changes are recorded in a log in the 
returned object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.pdb(pdb, consecutive = TRUE, force.renumber = FALSE,
  fix.chain = FALSE, fix.aa = FALSE, rm.wat = FALSE, rm.lig = FALSE,
  rm.h = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean.pdb_+3A_pdb">pdb</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from
function <code><a href="#topic+read.pdb">read.pdb</a></code>.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_consecutive">consecutive</code></td>
<td>
<p>logical, if TRUE renumbering will result in
consecutive residue numbers spanning all chains. Otherwise new residue
numbers will begin at 1 for each chain.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_force.renumber">force.renumber</code></td>
<td>
<p>logical, if TRUE atom and residue records are renumbered 
even if no 'insert' code is found in the <code>pdb</code> object.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_fix.chain">fix.chain</code></td>
<td>
<p>logical, if TRUE chains are relabeled based on chain breaks detected.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_fix.aa">fix.aa</code></td>
<td>
<p>logical, if TRUE non-standard amino acid names are converted into 
equivalent standard names.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_rm.wat">rm.wat</code></td>
<td>
<p>logical, if TRUE water atoms are removed.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_rm.lig">rm.lig</code></td>
<td>
<p>logical, if TRUE ligand atoms are removed.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_rm.h">rm.h</code></td>
<td>
<p>logical, if TRUE hydrogen atoms are removed.</p>
</td></tr>
<tr><td><code id="clean.pdb_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE details of the conversion process are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>call for its effects.
</p>


<h3>Value</h3>

<p>a 'pdb' object with an additional <code>$log</code> component storing 
all the processing messages.
</p>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Barry Grant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # PDB server connection required - testing excluded

   pdb &lt;- read.pdb("1a7l")
   clean.pdb(pdb)
 
</code></pre>

<hr>
<h2 id='cmap'> Contact Map </h2><span id='topic+cmap'></span><span id='topic+cmap.default'></span><span id='topic+cmap.xyz'></span><span id='topic+cmap.pdb'></span><span id='topic+cmap.pdbs'></span>

<h3>Description</h3>

<p>Construct a Contact Map for Given Protein Structure(s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmap(...)

## Default S3 method:
cmap(...)

## S3 method for class 'xyz'
cmap(xyz, grpby = NULL, dcut = 4, scut = 3, pcut=1, binary=TRUE,
            mask.lower = TRUE, collapse=TRUE, gc.first=FALSE, ncore=1, nseg.scale=1, ...)

## S3 method for class 'pdb'
cmap(pdb, inds = NULL, verbose = FALSE, ...)

## S3 method for class 'pdbs'
cmap(pdbs, rm.gaps=FALSE, all.atom=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmap_+3A_xyz">xyz</code></td>
<td>
<p> numeric vector of xyz coordinates or a numeric matrix of
coordinates with a row per structure/frame. </p>
</td></tr>
<tr><td><code id="cmap_+3A_grpby">grpby</code></td>
<td>
<p> a vector counting connective duplicated elements that
indicate the elements of <code>xyz</code> that should be considered as a group
(e.g. atoms from a particular residue). </p>
</td></tr>  
<tr><td><code id="cmap_+3A_dcut">dcut</code></td>
<td>
<p> a cutoff distance value below which atoms are considered
in contact. </p>
</td></tr>
<tr><td><code id="cmap_+3A_scut">scut</code></td>
<td>
<p> a cutoff neighbour value which has the effect of
excluding atoms that are sequentially within this value. </p>
</td></tr>
<tr><td><code id="cmap_+3A_pcut">pcut</code></td>
<td>
<p> a cutoff probability of structures/frames showing a contact,
above which atoms are considered in contact with respect to the ensemble.
Ignored if <code>binary=FALSE</code>. </p>
</td></tr>
<tr><td><code id="cmap_+3A_binary">binary</code></td>
<td>
<p> logical, if FALSE the raw matrix containing fraction of frames that 
two residues are in contact is returned. </p>
</td></tr>
<tr><td><code id="cmap_+3A_mask.lower">mask.lower</code></td>
<td>
<p> logical, if TRUE the lower matrix elements
(i.e. those below the diagonal) are returned as NA.</p>
</td></tr>
<tr><td><code id="cmap_+3A_collapse">collapse</code></td>
<td>
<p> logical, if FALSE an array of contact maps for all frames is returned. </p>
</td></tr>
<tr><td><code id="cmap_+3A_gc.first">gc.first</code></td>
<td>
<p> logical, if TRUE will call gc() first before calculation of 
distance matrix. This is to solve the memory overload problem when <code>ncore &gt; 1</code>
and <code>xyz</code> has many rows, with a bit sacrifice on speed. </p>
</td></tr>
<tr><td><code id="cmap_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="cmap_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="cmap_+3A_pdb">pdb</code></td>
<td>
<p>  a structure object of class <code>"pdb"</code>, obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="cmap_+3A_inds">inds</code></td>
<td>
<p> a list object of ATOM and XYZ indices as obtained from
<code><a href="#topic+atom.select">atom.select</a></code>. </p>
</td></tr>
<tr><td><code id="cmap_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the selection are
printed. </p>
</td></tr>
<tr><td><code id="cmap_+3A_pdbs">pdbs</code></td>
<td>
<p> a &lsquo;pdbs&rsquo; object as returned by <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.all">read.all</a></code>, or <code><a href="#topic+pdbaln">pdbaln</a></code>. </p>
</td></tr>
<tr><td><code id="cmap_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE gapped positions are removed in the returned value. </p>
</td></tr>
<tr><td><code id="cmap_+3A_all.atom">all.atom</code></td>
<td>
<p> logical, if TRUE all-atom coordinates from <code><a href="#topic+read.all">read.all</a></code>
are used. </p>
</td></tr>
<tr><td><code id="cmap_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A contact map is a simplified distance matrix. See the distance matrix
function <code><a href="#topic+dm">dm</a></code> for further details.
</p>
<p>Function <code>"cmap.pdb"</code> is a wrapper for <code>"cmap.xyz"</code>
which selects all &lsquo;notwater&rsquo; atoms and calculates the contact
matrix grouped by residue number.
</p>


<h3>Value</h3>

<p>Returns a N by N numeric matrix composed of zeros and ones, where
one indicates a contact between selected atoms.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dm">dm</a></code>, <code><a href="#topic+dccm">dccm</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="#topic+dist.xyz">dist.xyz</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##- Read PDB file
pdb &lt;- read.pdb( system.file("examples/hivp.pdb", package="bio3d") )

## Atom Selection indices
inds &lt;- atom.select(pdb, "calpha")

## Reference contact map
ref.cont &lt;- cmap( pdb$xyz[inds$xyz], dcut=6, scut=3 )
plot.cmap(ref.cont)

## Not run: 
##- Read Traj file
trj &lt;- read.dcd( system.file("examples/hivp.dcd", package="bio3d") )
## For each frame of trajectory
sum.cont &lt;- NULL
for(i in 1:nrow(trj)) {

  ## Contact map for frame 'i'
  cont &lt;- cmap(trj[i,inds$xyz], dcut=6, scut=3)

  ## Product with reference
  prod.cont &lt;- ref.cont * cont
  sum.cont &lt;- c(sum.cont, sum(prod.cont,na.rm=TRUE))
}

plot(sum.cont, typ="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='cna'> Protein Dynamic Correlation Network Construction and Community Analysis.  </h2><span id='topic+cna'></span><span id='topic+cna.dccm'></span><span id='topic+cna.ensmb'></span>

<h3>Description</h3>

<p>This function builds both residue-based and community-based undirected weighted
network graphs from an input correlation matrix, as obtained from the
functions &lsquo;dccm&rsquo;, &lsquo;dccm.nma&rsquo;, and &lsquo;dccm.enma&rsquo;. Community
detection/clustering is performed on the initial residue based 
network to determine the community organization and network structure
of the community based network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cna(cij, ...)
  ## S3 method for class 'dccm'
cna(cij, cutoff.cij=0.4, cm=NULL,  vnames=colnames(cij),
      cluster.method="btwn", collapse.method="max", 
      cols=vmd_colors(), minus.log=TRUE, ...)
  ## S3 method for class 'ensmb'
cna(cij, ..., ncore = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cna_+3A_cij">cij</code></td>
<td>
<p> A numeric array with 2 dimensions (nXn) containing atomic
correlation values, where &quot;n&quot; is the residue number. The matrix
elements should be in between 0 and 1 (atomic correlations). Can be
also a set of correlation matrices for ensemble network analysis. See
&lsquo;dccm&rsquo; function in bio3d package for further details. </p>
</td></tr>
<tr><td><code id="cna_+3A_...">...</code></td>
<td>
<p>  Additional arguments passed to the methods
<code>cna.dccm</code> and <code>cna.ensmb</code>. </p>
</td></tr>
<tr><td><code id="cna_+3A_cutoff.cij">cutoff.cij</code></td>
<td>
<p> Numeric element specifying the cutoff on cij matrix
values. Coupling below cutoff.cij are set to 0. </p>
</td></tr>
<tr><td><code id="cna_+3A_cm">cm</code></td>
<td>
<p> (optinal) A numeric array with 2 dimensions (nXn)
containing binary contact values, where &quot;n&quot; is the residue
number. The matrix elements should be 1 if two residues are in
contact and 0 if not in contact. See the  &lsquo;cmap&rsquo; function in
bio3d package for further details. </p>
</td></tr>
<tr><td><code id="cna_+3A_vnames">vnames</code></td>
<td>
<p> A vector of names for each column in the input
cij. This will be used for referencing residues in a similar way
to residue numbers in later analysis. </p>
</td></tr>  
<tr><td><code id="cna_+3A_cluster.method">cluster.method</code></td>
<td>
<p> A character string specifying the method for
community determination. Supported methods are:<br />
btwn=&quot;Girvan-Newman betweenness&quot;<br />
walk=&quot;Random walk&quot;<br />
greed=&quot;Greedy algorithm for modularity optimization&quot;<br /> 
infomap=&quot;Infomap algorithm for community detection&quot;<br /> </p>
</td></tr>  
<tr><td><code id="cna_+3A_collapse.method">collapse.method</code></td>
<td>
<p> A single element character vector specifing
the &lsquo;cij&rsquo; collapse method, can be one of &lsquo;max&rsquo;, &lsquo;median&rsquo;,
&lsquo;mean&rsquo;, or &lsquo;trimmed&rsquo;. By defualt the &lsquo;max&rsquo; method is
used to collapse the input residue based &lsquo;cij&rsquo; matrix into a smaller
community based network by taking the maximium &lsquo;abs(cij)&rsquo; value between
communities as the comunity-to-community cij value for clustered
network construction. </p>
</td></tr>
<tr><td><code id="cna_+3A_cols">cols</code></td>
<td>
<p> A vector of colors assigned to network nodes. </p>
</td></tr>
<tr><td><code id="cna_+3A_minus.log">minus.log</code></td>
<td>
<p> Logical, indicating whether &lsquo;-log(abs(cij))&rsquo;
values should be used for network construction. </p>
</td></tr> 
<tr><td><code id="cna_+3A_ncore">ncore</code></td>
<td>
<p> Number of CPU cores used to do the calculation. By default,
use all available cores. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input to this function should be a correlation matrix as
obtained from the  &lsquo;dccm&rsquo;, &lsquo;dccm.mean&rsquo; or &lsquo;dccm.nma&rsquo;
and related functions. Optionally, a contact map &lsquo;cm&rsquo; may also given 
as input to filter the correlation matrix resulting in the exclusion of  
network edges between non-contacting atom pairs (as defined in the contact map).
</p>
<p>Internally this function calls the igraph package
functions &lsquo;graph.adjacency&rsquo;,
&lsquo;edge.betweenness.community&rsquo;, &lsquo;walktrap.community&rsquo;,
&lsquo;fastgreedy.community&rsquo;, and &lsquo;infomap.community&rsquo;. The first constructs an undirected
weighted network graph. The second performs Girvan-Newman style clustering by
calculating the edge betweenness of the graph, removing the edge with
the highest edge betweenness score, calculates modularity (i.e. the difference between
the current graph partition and the partition of a random graph, see Newman and Girvan,
Physical Review E (2004), Vol 69, 026113), then recalculating edge betweenness
of the edges and again removing the one with the highest score, etc. 
The returned community partition is the one with the highest overall modularity value.
&lsquo;walktrap.community&rsquo; implements the Pons and Latapy algorithm based on the idea that
random walks on a graph tend to get &quot;trapped&quot; into densely connected parts of it,
i.e. a community. The random walk process is used to determine a distance
between nodes. Nodes with low distance values are joined in the same community.
&lsquo;fastgreedy.community&rsquo; instead determines the community structure based on the
optimization of the modularity. In the starting state each node is isolated and 
belongs to a separated community. Communities are then joined together (according to the
network edges) in pairs and the modularity is calculated. At each step the join resulting
in the highest increase of modularity is chosen. This process is repeated until a single
community is obtained, then the partitioning with the highest modularity score is selected.
&lsquo;infomap.community&rsquo; finds community structure that minimizes the expected description
length of a random walker trajectory.
</p>


<h3>Value</h3>

<p>Returns a list object that includes igraph network and community
objects with the following components:
</p>
<table>
<tr><td><code>network</code></td>
<td>
<p> An igraph residue-wise graph object. See below
for more details.</p>
</td></tr>
<tr><td><code>communities</code></td>
<td>
<p> An igraph residue-wise community object. See
below for more details. </p>
</td></tr>
<tr><td><code>communitiy.network</code></td>
<td>
<p> An igraph community-wise graph object. See
below for more details. </p>
</td></tr>
<tr><td><code>community.cij</code></td>
<td>
<p> Numeric square matrix containing the absolute values of
the atomic correlation input matrix for each community as obtained
from &lsquo;cij&rsquo; via application of  &lsquo;collapse.method&rsquo;. </p>
</td></tr>
<tr><td><code>cij</code></td>
<td>
<p> Numeric square matrix containing the absolute values of
the atomic correlation input matrix. </p>
</td></tr>
</table>
<p>If an ensemble of correlation matrices is provided, a list of &lsquo;cna&rsquo; 
object, of the &lsquo;ecna&rsquo; class, will be returned.
</p>


<h3>Author(s)</h3>

<p> Guido Scarabelli and Barry Grant </p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cna">plot.cna</a></code>,  <code><a href="#topic+summary.cna">summary.cna</a></code>,
<code><a href="#topic+vmd.cna">vmd.cna</a></code>, <code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph.adjacency</a></code>,
<code><a href="igraph.html#topic+cluster_edge_betweenness">edge.betweenness.community</a></code>,
<code><a href="igraph.html#topic+cluster_walktrap">walktrap.community</a></code>, 
<code><a href="igraph.html#topic+cluster_fast_greedy">fastgreedy.community</a></code>,
<code><a href="igraph.html#topic+cluster_infomap">infomap.community</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

##-- Build a correlation network from NMA results
## Read example PDB
pdb &lt;- read.pdb("4Q21")

## Perform NMA
modes &lt;- nma(pdb)
#plot(modes, sse=pdb)

## Calculate correlations 
cij &lt;- dccm(modes)
#plot(cij, sse=pdb)

## Build, and betweenness cluster, a network graph
net &lt;- cna(cij, cutoff.cij=0.35)
#plot(net, pdb)

## within VMD set 'coloring method' to 'Chain' and 'Drawing method' to Tube
#vmd.cna(net, trim.pdb(pdb, atom.select(pdb,"calpha")), launch=TRUE )

##-- Build a correlation network from MD results
## Read example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## select residues 24 to 27 and 85 to 90 in both chains
inds &lt;- atom.select(pdb, resno=c(24:27,85:90), elety='CA')

## lsq fit of trj on pdb
xyz &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=inds$xyz, mobile.inds=inds$xyz)

## calculate dynamical cross-correlation matrix
cij &lt;- dccm(xyz)

## Build, and betweenness cluster, a network graph
net &lt;- cna(cij)

# Plot coarse grained network based on dynamically coupled communities
xy &lt;- plot.cna(net)
plot.dccm(cij, margin.segments=net$communities$membership)


##-- Begin to examine network structure - see CNA vignette for more details
net
summary(net)
attributes(net)
table( net$communities$members )

}

</code></pre>

<hr>
<h2 id='cnapath'> Suboptimal Path Analysis for Correlation Networks </h2><span id='topic+cnapath'></span><span id='topic+summary.cnapath'></span><span id='topic+print.cnapath'></span><span id='topic+plot.cnapath'></span><span id='topic+plot.ecnapath'></span>

<h3>Description</h3>

<p>Find k shortest paths between a pair of nodes, source and sink, in a correlation 
network. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnapath(cna, from, to=NULL, k=10, collapse=TRUE, ncore=NULL, ...)
## S3 method for class 'cnapath'
summary(object, ..., pdb = NULL, label = NULL, col = NULL,
   plot = FALSE, concise = FALSE, cutoff = 0.1, normalize = TRUE, weight = FALSE)
## S3 method for class 'cnapath'
print(x, ...)
## S3 method for class 'cnapath'
plot(x, ...)
## S3 method for class 'ecnapath'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnapath_+3A_cna">cna</code></td>
<td>
<p> A &lsquo;cna&rsquo; object or a list of &lsquo;cna&rsquo; objects obtained from 
<code><a href="#topic+cna">cna</a></code>. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_from">from</code></td>
<td>
<p> Integer vector or matrix indicating node id(s) of source. If is matrix
and <code>to</code> is NULL, the first column represents source and the second sink. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_to">to</code></td>
<td>
<p> Integer vector indicating node id(s) of sink. All combinations of 
<code>from</code> and <code>to</code> values will be used as source/sink pairs. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_k">k</code></td>
<td>
<p> Integer, number of suboptimal paths to identify. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_collapse">collapse</code></td>
<td>
<p> Logical, if TRUE results from all source/sink pairs are merged with
a single &lsquo;cnapath&rsquo; object returned. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_ncore">ncore</code></td>
<td>
<p> Number of CPU cores used to do the calculation. 
By default (NULL), use all detected CPU cores. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_object">object</code></td>
<td>
<p> A &lsquo;cnapath&rsquo; class of object obtained from 
<code>cnapath</code>. Multiple &lsquo;object&rsquo; input is allowed for 
comparing paths from different networks. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_pdb">pdb</code></td>
<td>
<p> A &lsquo;pdb&rsquo; class of object obtained from <code><a href="#topic+read.pdb">read.pdb</a></code> 
and is used as the reference for node residue ids (in <code>summary.cnapath</code>) or 
for molecular visulaization with VMD (in <code>vmd.cnapath</code>). </p>
</td></tr>
<tr><td><code id="cnapath_+3A_label">label</code></td>
<td>
<p> Character, label for paths identified from different networks. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_col">col</code></td>
<td>
<p> Colors for plotting statistical results for paths identified 
from different networks. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_plot">plot</code></td>
<td>
<p> Logical, if TRUE path length distribution and node degeneracy will be plotted. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_concise">concise</code></td>
<td>
<p> Logical, if TRUE only &lsquo;on path&rsquo; residues will be displayed in the
node degeneracy plot. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_cutoff">cutoff</code></td>
<td>
<p> Numeric, nodes with node degeneracy larger than <code>cutoff</code> are
shown in the output. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_normalize">normalize</code></td>
<td>
<p> Logical, if TRUE node degeneracy is divided by the total 
(weighted) number of paths. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_weight">weight</code></td>
<td>
<p> Logical, if TRUE each path is weighted by path length in calculating the
node degeneracty. </p>
</td></tr>
<tr><td><code id="cnapath_+3A_x">x</code></td>
<td>
<p> A 'cnapath' class object, or a list of such objects, as obtained from function <code>cnapath</code>.
</p>
</td></tr>
<tr><td><code id="cnapath_+3A_...">...</code></td>
<td>
<p> Additional arguments passed to igraph function 
<code><a href="igraph.html#topic+distances">get.shortest.paths</a></code> (in 
the function <code>cnapath</code>), passed to <code>summary.cnapath</code> 
(in <code>print.cnapath</code>), as additional paths for 
comparison (in <code>summary.cnapath</code>). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>cnapath</code> returns a (or a list of) &lsquo;cnapath&rsquo; 
class of list containing following three components:
</p>
<table>
<tr><td><code>path</code></td>
<td>
<p> a list object containing all identified suboptimal paths.  
Each entry of the list is a sequence of node ids for the path. </p>
</td></tr>
<tr><td><code>epath</code></td>
<td>
<p> a list object containing all identified suboptimal paths. 
Each entry of the list is a sequence of edge ids for the path. </p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p> a numeric vector of all path lengths. </p>
</td></tr>
</table>
<p>The function <code>summary.cnapath</code> returns a matrix of (normalized)
node degeneracy for &lsquo;on path&rsquo; residues. 
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao </p>


<h3>References</h3>

<p>Yen, J.Y. (1971) <em>Management Science</em> <b>17</b>, 712&ndash;716.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+cna.dccm">cna.dccm</a></code>,
<code><a href="#topic+vmd.cna">vmd.cna</a></code>, <code><a href="#topic+vmd.cnapath">vmd.cnapath</a></code>, 
<code><a href="igraph.html#topic+distances">get.shortest.paths</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redundant testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

attach(transducin)
inds = match(c("1TND_A", "1TAG_A"), pdbs$id)

npdbs &lt;- trim(pdbs, row.inds=inds)
gaps.res &lt;- gap.inspect(npdbs$ali)

modes &lt;- nma(npdbs)
cij &lt;- dccm(modes)
net &lt;- cna(cij, cutoff.cij=0.3)

# get paths
pa1 &lt;- cnapath(net[[1]], from = 314, to=172, k=50)
pa2 &lt;- cnapath(net[[2]], from = 314, to=172, k=50)

# print the information of a path
pa1

# print two paths simultaneously
pas &lt;- list(pa1, pa2)
names(pas) &lt;- c("GTP", "GDP")
print.cnapath(pas)

# Or, for the same effect,
# summary(pa1, pa2, label=c("GTP", "GDP"))

# replace node numbers with residue name and residue number in the PDB file
pdb &lt;- read.pdb("1tnd")
pdb &lt;- trim.pdb(pdb, atom.select(pdb, chain="A", resno=npdbs$resno[1, gaps.res$f.inds]))
print.cnapath(pas, pdb=pdb)

# plot path length distribution and node degeneracy
print.cnapath(pas, pdb = pdb, col=c("red", "darkgreen"), plot=TRUE)

# View paths in 3D molecular graphic with VMD
#vmd.cnapath(pa1, pdb, launch = TRUE)
#vmd.cnapath(pa1, pdb, colors = 7, launch = TRUE)
#vmd.cnapath(pa1, pdb, spline=TRUE, colors=c("pink", "red"), launch = TRUE)
#pdb2 &lt;- read.pdb("1tag")
#pdb2 &lt;- trim.pdb(pdb2, atom.select(pdb2, chain="A", resno=npdbs$resno[2, gaps.res$f.inds]))
#vmd.cnapath(pa2, pdb2, launch = TRUE)

detach(transducin)

}

</code></pre>

<hr>
<h2 id='com'> Center of Mass </h2><span id='topic+com'></span><span id='topic+com.pdb'></span><span id='topic+com.xyz'></span>

<h3>Description</h3>

<p>Calculate the center of mass of a PDB object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>com(...)

## S3 method for class 'pdb'
com(pdb, inds=NULL, use.mass=TRUE, ...)

## S3 method for class 'xyz'
com(xyz, mass=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="com_+3A_pdb">pdb</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="com_+3A_inds">inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from <code>atom.select</code>
that selects the elements of <code>pdb</code> upon which the calculation
should be based.</p>
</td></tr>
<tr><td><code id="com_+3A_use.mass">use.mass</code></td>
<td>
<p> logical, if TRUE the calculation will be mass
weighted (center of mass). </p>
</td></tr>
<tr><td><code id="com_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>atom2mass</code>. </p>
</td></tr>
<tr><td><code id="com_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector or matrix of Cartesian coordinates
(e.g. an object of type <code>xyz</code>). </p>
</td></tr>
<tr><td><code id="com_+3A_mass">mass</code></td>
<td>
<p> a numeric vector containing the masses of each atom in
<code>xyz</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the center of mass of the provided PDB
structure / Cartesian coordiantes. Atom names found in standard amino
acids in the PDB are mapped to atom elements and their corresponding
relative atomic masses.  
</p>
<p>In the case of an unknown atom name <code>elety.custom</code> and
<code>mass.custom</code> can be used to map an atom to the correct
atomic mass. See examples for more details.
</p>
<p>Alternatively, the atom name will be mapped automatically to the
element corresponding to the first character of the atom name. Atom
names starting with character <code>H</code> will be mapped to hydrogen
atoms.
</p>


<h3>Value</h3>

<p>Returns the Cartesian coordinates at the center of mass.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom2mass">atom2mass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

## Stucture of PKA:
pdb &lt;- read.pdb("3dnd")

## Center of mass:
com(pdb)

## Center of mass of a selection
inds &lt;- atom.select(pdb, chain="I")
com(pdb, inds)

## using XYZ Cartesian coordinates
xyz &lt;- pdb$xyz[, inds$xyz]
com.xyz(xyz)

## with mass weighting
com.xyz(xyz, mass=atom2mass(pdb$atom[inds$atom, "elety"]) )



## Not run: 
## Unknown atom names
pdb &lt;- read.pdb("3dnd")
inds &lt;- atom.select(pdb, resid="LL2")
mycom &lt;- com(pdb, inds, rescue=TRUE)
#warnings()


## Map atom names manually
pdb &lt;- read.pdb("3RE0")
inds &lt;- atom.select(pdb, resno=201)

myelety  &lt;- data.frame(name = c("CL2","PT1","N1","N2"), symb = c("Cl","Pt","N","N"))
mymasses &lt;- data.frame(symb = c("Cl","Pt"), mass = c(35.45, 195.08))
mycom    &lt;- com(pdb, inds, elety.custom=myelety, mass.custom=mymasses)

## End(Not run)
</code></pre>

<hr>
<h2 id='combine.select'> Combine Atom Selections From PDB Structure </h2><span id='topic+combine.select'></span>

<h3>Description</h3>

<p>Do &quot;and&quot;, &quot;or&quot;, or &quot;not&quot; set operations between two or more atom
selections made by <code><a href="#topic+atom.select">atom.select</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.select(sel1=NULL, sel2=NULL, ..., operator="AND", verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.select_+3A_sel1">sel1</code></td>
<td>
<p> an atom selection object of class <code>"select"</code>, obtained from
<code><a href="#topic+atom.select">atom.select</a></code>. </p>
</td></tr>
<tr><td><code id="combine.select_+3A_sel2">sel2</code></td>
<td>
<p> a second atom selection object of class <code>"select"</code>, obtained
from <code><a href="#topic+atom.select">atom.select</a></code>. </p>
</td></tr>
<tr><td><code id="combine.select_+3A_...">...</code></td>
<td>
<p> more select objects for the set operation. </p>
</td></tr>
<tr><td><code id="combine.select_+3A_operator">operator</code></td>
<td>
<p> name of the set operation. </p>
</td></tr>
<tr><td><code id="combine.select_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the selection combination are
printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of <code>operator</code> should be one of following:
(1) &quot;AND&quot;, &quot;and&quot;, or &quot;&amp;&quot; for set intersect,
(2) &quot;OR&quot;, &quot;or&quot;, &quot;|&quot;, or &quot;+&quot; for set union,
(3) &quot;NOT&quot;, &quot;not&quot;, &quot;!&quot;, or &quot;-&quot; for set difference <code>sel1 - sel2 - sel3 ...</code>.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"select"</code> with components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p>atom indices of selected atoms.</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p>xyz indices of selected atoms.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+as.select">as.select</a></code>
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+trim.pdb">trim.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## - Build atom selections to be operated
# Select C-alpha atoms of entire system
ca.global.inds &lt;- atom.select(pdb, "calpha")

# Select C-beta atoms of entire protein
cb.global.inds &lt;- atom.select(pdb, "protein", elety="CB")

# Select backbone atoms of entire system
bb.global.inds &lt;- atom.select(pdb, "backbone")

# Select all atoms with residue number from 46 to 50
aa.local.inds &lt;- atom.select(pdb, resno=46:50)


# Do set intersect:
# - Return C-alpha atoms with residue number from 46 to 50
ca.local.inds &lt;- combine.select(ca.global.inds, aa.local.inds)
print( pdb$atom[ ca.local.inds$atom, ] )

# Do set subtract:
# - Return side-chain atoms with residue number from 46 to 50
sc.local.inds &lt;- combine.select(aa.local.inds, bb.global.inds, operator="-")
print( pdb$atom[ sc.local.inds$atom, ] )

# Do set union:
# - Return C-alpha and side-chain atoms with residue number from 46 to 50
casc.local.inds &lt;- combine.select(ca.local.inds, sc.local.inds, operator="+")
print( pdb$atom[ casc.local.inds$atom, ] )

# More than two selections:
# - Return side-chain atoms (but not C-beta) with residue number from 46 to 50
sc2.local.inds &lt;- combine.select(aa.local.inds, bb.global.inds, cb.global.inds, operator="-")
print( pdb$atom[ sc2.local.inds$atom, ] )

</code></pre>

<hr>
<h2 id='community.aln'>Align communities from two or more networks</h2><span id='topic+community.aln'></span>

<h3>Description</h3>

<p>Find equivalent communities from two or more networks and re-assign colors
to them in a consistent way across networks. A &lsquo;new.membership&rsquo; vector is
also generated for each network, which maps nodes to community IDs that are 
renumbered according to the community equivalency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.aln(x, ..., aln = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.aln_+3A_x">x</code>, <code id="community.aln_+3A_...">...</code></td>
<td>
<p>two or more objects of class <code>cna</code> (if the numbers of
nodes are different, an alignment &lsquo;fasta&rsquo; object is required for 
the <code>aln</code> argument; See below) as obtained from function <code><a href="#topic+cna">cna</a></code>. 
Alternatively, a list of <code>cna</code> objects can be given to <code>x</code>.</p>
</td></tr>
<tr><td><code id="community.aln_+3A_aln">aln</code></td>
<td>
<p>alignment for comparing networks with different numbers of nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function facilitates the inspection on the variance of the community
partition in a group of similar networks. The original community numbering
(and so the colors of communities in the output of <code>plot.cna</code> and 
<code>vmd.cna</code>) can be inconsistent across networks, i.e. equivalent 
communities may display different colors, impeding network comparison. 
The function calculates the dissimilarity between all communities and 
clusters communities with &lsquo;hclust&rsquo; funciton. In each cluster, 0 or
1 community per network is included. The color attribute of communities is 
then re-assigned according to the clusters through all networks. In addition,
a &lsquo;new.membership&rsquo; vector is generated for each network, which mapps 
nodes to new community IDs that are numbered consistently across networks.
</p>


<h3>Value</h3>

<p>Returns a list of updated <code>cna</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+plot.cna">plot.cna</a></code>, <code><a href="#topic+vmd.cna">vmd.cna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Needs MUSCLE installed - testing excluded
  if(check.utility("muscle")) {

    if (!requireNamespace("igraph", quietly = TRUE)) {
      message('Need igraph installed to run this example')
    } else {

    ## Fetch PDB files and split to chain A only PDB files
    ids &lt;- c("1tnd_A", "1tag_A")
    files &lt;- get.pdb(ids, split = TRUE, path = tempdir())
    
    ## Sequence Alignement
    pdbs &lt;- pdbaln(files, outfile = tempfile())
    
    ## Normal mode analysis on aligned data
    modes &lt;- nma(pdbs, rm.gaps=TRUE)
    
    ## Dynamic Cross Correlation Matrix
    cijs &lt;- dccm(modes)$all.dccm
 
    ## Correlation Network
    nets &lt;- cna(cijs, cutoff.cij=0.3)

    ## Align network communities
    nets.aln &lt;- community.aln(nets)

    ## plot all-residue and coarse-grained (community) networks
    pdb &lt;- pdbs2pdb(pdbs, inds=1, rm.gaps=TRUE)[[1]]
    op &lt;- par(no.readonly=TRUE)

    # before alignment
    par(mar=c(0.1, 0.1, 0.1, 0.1), mfrow=c(2,2))
    invisible( lapply(nets, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3, full=TRUE)[, 1:2], 
               full=TRUE)) )
    invisible( lapply(nets, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3)[, 1:2])) )

    # after alignment
    par(mar=c(0.1, 0.1, 0.1, 0.1), mfrow=c(2,2))
    invisible( lapply(nets.aln, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3, full=TRUE)[, 1:2], 
               full=TRUE)) )
    invisible( lapply(nets.aln, function(x) 
       plot(x, layout=layout.cna(x, pdb=pdb, k=3)[, 1:2])) )

    par(op)     

    }
  }

</code></pre>

<hr>
<h2 id='community.tree'> Reconstruction of the Girvan-Newman Community Tree for a CNA Class Object.  </h2><span id='topic+community.tree'></span>

<h3>Description</h3>

<p>This function reconstructs the community tree of the community
clustering analysis performed by the &lsquo;cna&rsquo; function. 
It allows the user to explore different network community partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  community.tree(x, rescale=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.tree_+3A_x">x</code></td>
<td>
<p>  A protein network graph object as obtained from the
&lsquo;cna&rsquo; function. </p>
</td></tr>
<tr><td><code id="community.tree_+3A_rescale">rescale</code></td>
<td>
<p> Logical, indicating whether to rescale the community
names starting from 1. If FALSE, the community names will start from
N+1, where N is the number of nodes. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The input of this function should be a &lsquo;cna&rsquo; class object
containing &lsquo;network&rsquo; and &lsquo;communities&rsquo; attributes.
</p>
<p>This function reconstructs the community residue memberships for each
modularity value. The purpose is to facilitate inspection of alternate 
community partitioning points, which in practice often corresponds to a value 
close to the maximum of the modularity, but not the maximum value itself.
</p>


<h3>Value</h3>

<p>Returns a list object that includes the following components:
</p>
<table>
<tr><td><code>modularity</code></td>
<td>
<p> A numeric vector containing the modularity values. </p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p> A numeric matrix containing in each row the
community residue memberships corresponding to a modularity
value. The rows are ordered according to the &lsquo;modularity&rsquo; object. </p>
</td></tr>
<tr><td><code>num.of.comms</code></td>
<td>
<p> A numeric vector containing the number of
communities per modularity value. The vector elements are ordered according
to the &lsquo;modularity&rsquo; object. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Guido Scarabelli </p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+network.amendment">network.amendment</a></code>, <code><a href="#topic+summary.cna">summary.cna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

###-- Build a CNA object
pdb &lt;- read.pdb("4Q21")
modes &lt;- nma(pdb)
cij &lt;- dccm(modes)
net &lt;- cna(cij, cutoff.cij=0.2)


##-- Reconstruct the community membership vector for each clustering step.
tree &lt;- community.tree(net, rescale=TRUE)

## Plot modularity vs number of communities
plot( tree$num.of.comms, tree$modularity )

## Inspect the maximum modularity value partitioning
max.mod.ind &lt;- which.max(tree$modularity)

## Number of communities (k) at max modularity
tree$num.of.comms[ max.mod.ind ]

## Membership vector at this partition point 
tree$tree[max.mod.ind,]

# Should be the same as that contained in the original CNA network object
net$communities$membership == tree$tree[max.mod.ind,]

# Inspect a new membership partitioning (at k=7)
memb.k7 &lt;- tree$tree[ tree$num.of.comms == 7, ]

## Produce a new k=7 community network  
net.7 &lt;- network.amendment(net, memb.k7)
plot(net.7, pdb)
#view.cna(net.7, trim.pdb(pdb, atom.select(pdb,"calpha")), launch=TRUE )

}

</code></pre>

<hr>
<h2 id='consensus'> Sequence Consensus for an Alignment </h2><span id='topic+consensus'></span>

<h3>Description</h3>

<p>Determines the consensus sequence for a given alignment at a given
identity cutoff value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  consensus(alignment, cutoff = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_+3A_alignment">alignment</code></td>
<td>
<p> an <code>alignment</code> object created by the
<code><a href="#topic+read.fasta">read.fasta</a></code> function or an alignment character matrix. </p>
</td></tr>
<tr><td><code id="consensus_+3A_cutoff">cutoff</code></td>
<td>
<p> a numeric value beteen 0 and 1, indicating the minimum
sequence identity threshold for determining a consensus amino acid.
Default is 0.6, or 60 percent residue identity. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the consensus sequence, where &lsquo;-&rsquo; represents
positions with no consensus (i.e. under the <code>cutoff</code>)
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-- Read HIV protease alignment
aln &lt;- read.fasta(system.file("examples/hivp_xray.fa",package="bio3d"))

# Generate consensus
con &lt;- consensus(aln)
print(con$seq)

# Plot residue frequency matrix
##png(filename = "freq.png", width = 1500, height = 780)
col &lt;- mono.colors(32)
aa  &lt;- rev(rownames(con$freq))

image(x=1:ncol(con$freq),
      y=1:nrow(con$freq),
      z=as.matrix(rev(as.data.frame(t(con$freq)))),
      col=col, yaxt="n", xaxt="n",
      xlab="Alignment Position", ylab="Residue Type")

# Add consensus along the axis
axis(side=1, at=seq(0,length(con$seq),by=5))
axis(side=2, at=c(1:22), labels=aa)
axis(side=3, at=c(1:length(con$seq)), labels =con$seq)
axis(side=4, at=c(1:22), labels=aa)
grid(length(con$seq), length(aa))
box()

# Add consensus sequence
for(i in 1:length(con$seq)) {
  text(i, which(aa==con$seq[i]),con$seq[i],col="white")
}

# Add lines for residue type separation
abline(h=c(2.5,3.5, 4.5, 5.5, 3.5, 7.5, 9.5,
         12.5, 14.5, 16.5, 19.5), col="gray")


</code></pre>

<hr>
<h2 id='conserv'> Score Residue Conservation At Each Position in an Alignment </h2><span id='topic+conserv'></span>

<h3>Description</h3>

<p>Quantifies residue conservation in a given protein sequence alignment
by calculating the degree of amino acid variability in each column of
the alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conserv(x, method = c("similarity","identity","entropy22","entropy10"),
        sub.matrix = c("bio3d", "blosum62", "pam30", "other"),
        matrix.file = NULL, normalize.matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conserv_+3A_x">x</code></td>
<td>
<p> an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="conserv_+3A_method">method</code></td>
<td>
<p> the conservation assesment method. </p>
</td></tr>
<tr><td><code id="conserv_+3A_sub.matrix">sub.matrix</code></td>
<td>
<p> a matrix to score conservation. </p>
</td></tr>
<tr><td><code id="conserv_+3A_matrix.file">matrix.file</code></td>
<td>
<p> a file name of an arbitary user matrix. </p>
</td></tr>
<tr><td><code id="conserv_+3A_normalize.matrix">normalize.matrix</code></td>
<td>
<p> logical, if TRUE the matrix is normalized
pior to assesing conservation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>To assess the level of sequence conservation at each position in an
alignment, the &ldquo;similarity&rdquo;, &ldquo;identity&rdquo;, and
&ldquo;entropy&rdquo; per position can be calculated.
</p>
<p>The &ldquo;similarity&rdquo; is defined as the average of the similarity
scores of all pairwise residue comparisons for that position in the
alignment, where the similarity score between any two residues is the
score value between those residues in the chosen substitution matrix
&ldquo;sub.matrix&rdquo;.
</p>
<p>The &ldquo;identity&rdquo; i.e. the preference for a specific amino acid to
be found at a certain position, is assessed by averaging the identity
scores resulting from all possible pairwise comparisons at that position
in the alignment, where all identical residue comparisons are given a
score of 1 and all other comparisons are given a value of 0.
</p>
<p>&ldquo;Entropy&rdquo; is based on Shannons information entropy. See the
<code><a href="#topic+entropy">entropy</a></code> function for further details.
</p>
<p>Note that the returned scores are normalized so that conserved columns
score 1 and diverse columns score 0.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of scores
</p>


<h3>Note</h3>

<p>Each of these conservation scores has particular strengths and
weaknesses.  For example, entropy elegantly captures amino acid
diversity but fails to account for stereochemical similarities. By
employing a combination of scores and taking the union of their
respective conservation signals we expect to achieve a more
comprehensive analysis of sequence conservation (Grant, 2007).
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
Grant, B.J. et al. (2007) <em>J. Mol. Biol.</em> <b>368</b>, 1231&ndash;1248.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read an example alignment
aln &lt;- read.fasta(system.file("examples/hivp_xray.fa",package="bio3d"))

## Score conservation
conserv(x=aln$ali, method="similarity", sub.matrix="bio3d")
##conserv(x=aln$ali,method="entropy22", sub.matrix="other")

</code></pre>

<hr>
<h2 id='convert.pdb'>Renumber and Convert Between Various PDB formats</h2><span id='topic+convert.pdb'></span>

<h3>Description</h3>

<p>Renumber and convert between CHARMM, Amber, Gromacs and Brookhaven
PDB formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.pdb(pdb, type=c("original", "pdb", "charmm", "amber", "gromacs"),
                renumber = FALSE, first.resno = 1, first.eleno = 1,
                consecutive=TRUE, rm.h = TRUE, rm.wat = FALSE,
                verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.pdb_+3A_pdb">pdb</code></td>
<td>
<p> a structure object of class <code>"pdb"</code>, obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_type">type</code></td>
<td>
<p> output format, one of &lsquo;original&rsquo;, &lsquo;pdb&rsquo;, 
&lsquo;charmm&rsquo;, &lsquo;amber&rsquo;, or &lsquo;gromacs&rsquo;. The default 
option of &lsquo;original&rsquo; results in no conversion. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_renumber">renumber</code></td>
<td>
<p> logical, if TRUE atom and residue records are
renumbered using &lsquo;first.resno&rsquo; and &lsquo;first.eleno&rsquo;. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_first.resno">first.resno</code></td>
<td>
<p> first residue number to be used if
&lsquo;renumber&rsquo; is TRUE. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_first.eleno">first.eleno</code></td>
<td>
<p> first element number to be used if
&lsquo;renumber&rsquo; is TRUE. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_consecutive">consecutive</code></td>
<td>
<p> logical, if TRUE renumbering will result in 
consecutive residue numbers spanning all chains. Otherwise new residue  
numbers will begin at &lsquo;first.resno&rsquo; for each chain. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_rm.h">rm.h</code></td>
<td>
<p> logical, if TRUE hydrogen atoms are removed. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_rm.wat">rm.wat</code></td>
<td>
<p> logical, if TRUE water atoms are removed. </p>
</td></tr>
<tr><td><code id="convert.pdb_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the conversion process 
are printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert atom names and residue names, renumber atom and residue
records, strip water and hydrogen atoms from <code>pdb</code> objects.
</p>
<p>Format <code>type</code> can be one of &ldquo;ori&rdquo;, &ldquo;pdb&rdquo;, &ldquo;charmm&rdquo;,
&ldquo;amber&rdquo; or &ldquo;gromacs&rdquo;.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code>, with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a character matrix containing all atomic coordinate ATOM data,
with a row per ATOM and a column per record type.  See below for details
of the record type naming convention (useful for accessing columns). </p>
</td></tr>
<tr><td><code>het</code></td>
<td>
<p> a character matrix containing atomic coordinate records
for atoms within &ldquo;non-standard&rdquo; HET groups (see <code>atom</code>). </p>
</td></tr>
<tr><td><code>helix</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of H
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>sheet</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of E
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>seqres</code></td>
<td>
<p> sequence from SEQRES field. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric vector of ATOM coordinate data. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>For both <code>atom</code> and <code>het</code> list components the column names can be
used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo; ,
Atom type &ldquo;elety&rdquo;,
Alternate location indicator &ldquo;alt&rdquo;,
Residue name &ldquo;resid&rdquo;,
Chain identifier &ldquo;chain&rdquo;,
Residue sequence number &ldquo;resno&rdquo;,
Code for insertion of residues &ldquo;insert&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Occupancy &ldquo;o&rdquo;, and
Temperature factor &ldquo;b&rdquo;.
See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Read a PDB file
pdb &lt;- read.pdb("4q21")
pdb
head( pdb$atom[pdb$calpha,"resno"] )

# Convert to CHARMM format
new &lt;- convert.pdb(pdb, type="amber", renumber=TRUE, first.resno=22 )
head( new$atom[new$calpha,"resno"] )

# Write a PDB file
#write.pdb(new, file="tmp4amber.pdb")


## End(Not run)
</code></pre>

<hr>
<h2 id='core.cmap'> Identification of Contact Map Core Positions </h2><span id='topic+core.cmap'></span>

<h3>Description</h3>

<p>Find core positions that have the largest number
of contact with neighboring residues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>core.cmap(pdbs, write.pdb = FALSE, outfile="core.pdb",
          cutoff = NULL, refine = FALSE, ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="core.cmap_+3A_pdbs">pdbs</code></td>
<td>
<p> an alignment data structure of class &lsquo;pdbs&rsquo; 
as obtained with <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or <code><a href="#topic+pdbaln">pdbaln</a></code>, 
or a numeric matrix of aligned C-alpha xyz Cartesian coordinates. </p>
</td></tr>
<tr><td><code id="core.cmap_+3A_write.pdb">write.pdb</code></td>
<td>
<p> logical, if TRUE core coordinate files, containing
only core positions for each iteration, are written to a location
specified by <code>outpath</code>. </p>
</td></tr>
<tr><td><code id="core.cmap_+3A_outfile">outfile</code></td>
<td>
<p> character string specifying the output directory when
<code>write.pdb</code> is &lsquo;TRUE&rsquo;. </p>
</td></tr>  
<tr><td><code id="core.cmap_+3A_cutoff">cutoff</code></td>
<td>
<p> numeric value speciyfing the inclusion criteria for
core positions. </p>
</td></tr>
<tr><td><code id="core.cmap_+3A_refine">refine</code></td>
<td>
<p> logical, if TRUE explore core positions determined by
multiple eigenvectors. By default only the eigenvector describing
the largest variation is used. </p>
</td></tr>
<tr><td><code id="core.cmap_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
By default (<code>ncore=NULL</code>) use all cores detected. </p>
</td></tr>
<tr><td><code id="core.cmap_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates eigenvector centrality of the weighted
contact network built based on input structure data and uses it
to determine the core positions.
</p>
<p>In this context, core positions correspond to the most invariant
C-alpha atom positions across an aligned set of protein
structures. Traditionally one would use the <code>core.find</code>
function to for their identification and then use these positions as
the basis for improved structural superposition. This more recent
function utilizes a  much faster approach and is thus preferred in
time sensitive applications such as shiny apps.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"select"</code> containing &lsquo;atom&rsquo; and
&lsquo;xyz&rsquo; indices.
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+core.find">core.find</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, 
<code><a href="#topic+fit.xyz">fit.xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##-- Generate a small kinesin alignment and read corresponding structures
pdbfiles &lt;- get.pdb(c("1bg2","2ncd","1i6i","1i5s"), URLonly=TRUE)
pdbs &lt;- pdbaln(pdbfiles)

##-- Find 'core' positions
core &lt;- core.cmap(pdbs)
xyz &lt;- pdbfit(pdbs, core, outpath="corefit_structures")

## End(Not run)
</code></pre>

<hr>
<h2 id='core.find'> Identification of Invariant Core Positions </h2><span id='topic+core.find'></span><span id='topic+core.find.default'></span><span id='topic+core.find.pdbs'></span><span id='topic+core.find.pdb'></span>

<h3>Description</h3>

<p>Perform iterated rounds of structural superposition to identify the
most invariant region in an aligned set of protein structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>core.find(...)

## S3 method for class 'pdbs'
core.find(pdbs, shortcut = FALSE, rm.island = FALSE,
          verbose = TRUE, stop.at = 15, stop.vol = 0.5,
          write.pdbs = FALSE, outpath="core_pruned",
          ncore = 1, nseg.scale = 1, progress = NULL, ...)

## Default S3 method:
core.find(xyz, ...)

## S3 method for class 'pdb'
core.find(pdb, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="core.find_+3A_pdbs">pdbs</code></td>
<td>
<p> a numeric matrix of aligned C-alpha xyz Cartesian
coordinates. For example an alignment data structure obtained with
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or <code><a href="#topic+pdbaln">pdbaln</a></code>. </p>
</td></tr>
<tr><td><code id="core.find_+3A_shortcut">shortcut</code></td>
<td>
<p> if TRUE, remove more than one position at a time. </p>
</td></tr>
<tr><td><code id="core.find_+3A_rm.island">rm.island</code></td>
<td>
<p> remove isolated fragments of less than three
residues. </p>
</td></tr>
<tr><td><code id="core.find_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE a &ldquo;core_pruned&rdquo; directory
containing &lsquo;core structures&rsquo; for each iteraction is written 
to the current directory. </p>
</td></tr>
<tr><td><code id="core.find_+3A_stop.at">stop.at</code></td>
<td>
<p> minimal core size at which iterations should be
stopped. </p>
</td></tr>
<tr><td><code id="core.find_+3A_stop.vol">stop.vol</code></td>
<td>
<p> minimal core volume at which iterations should be
stopped. </p>
</td></tr>  
<tr><td><code id="core.find_+3A_write.pdbs">write.pdbs</code></td>
<td>
<p> logical, if TRUE core coordinate files, containing
only core positions for each iteration, are written to a location
specified by <code>outpath</code>. </p>
</td></tr>
<tr><td><code id="core.find_+3A_outpath">outpath</code></td>
<td>
<p> character string specifying the output directory when
<code>write.pdbs</code> is TRUE. </p>
</td></tr>  
<tr><td><code id="core.find_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="core.find_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>.</p>
</td></tr>
<tr><td><code id="core.find_+3A_progress">progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td></tr>
<tr><td><code id="core.find_+3A_xyz">xyz</code></td>
<td>
<p> a numeric matrix of xyz Cartesian coordinates,
e.g. obtained from <code><a href="#topic+read.dcd">read.dcd</a></code> or <code><a href="#topic+read.ncdf">read.ncdf</a></code>. </p>
</td></tr>
<tr><td><code id="core.find_+3A_pdb">pdb</code></td>
<td>
<p> an object of type <code>pdb</code> as obtained from function
<code><a href="#topic+read.pdb">read.pdb</a></code> with multiple frames (&gt;=4) stored in its
<code>xyz</code> component. Note that the function will attempt to
identify C-alpha and phosphate atoms (for protein and nucleic acids,
respectively) in which the calculation should be based. </p>
</td></tr>
<tr><td><code id="core.find_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to iteratively refine an initial structural
superposition determined from a multiple alignment.
This involves iterated rounds of superposition, where at each round the
position(s) displaying the largest differences is(are) excluded from the
dataset. 
The spatial variation at each aligned position is determined from the
eigenvalues of their Cartesian coordinates (i.e. the variance of the
distribution along its three principal directions). Inspired by the
work of Gerstein <em>et al.</em> (1991, 1995), an ellipsoid of
variance is determined from the eigenvalues, and its volume is taken as
a measure of structural variation at a given position.
</p>
<p>Optional &ldquo;core PDB files&rdquo; containing core positions, upon which
superposition is based, can be written to a location specified by
<code>outpath</code> by setting <code>write.pdbs=TRUE</code>.  These files are
useful for examining the core filtering process by visualising them in a
graphics program.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"core"</code> with the following components:
</p>
<table>
<tr><td><code>volume</code></td>
<td>
<p>total core volume at each fitting iteration/round.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>core length at each round.</p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p>residue number of core residues at each round (taken
from the first aligned structure) or, alternatively, the numeric
index of core residues at each round.</p>
</td></tr>
<tr><td><code>step.inds</code></td>
<td>
<p>atom indices of core atoms at each round.</p>
</td></tr>
<tr><td><code>atom</code></td>
<td>
<p>atom indices of core positions in the last round.</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p>xyz indices of core positions in the last round.</p>
</td></tr>
<tr><td><code>c1A.atom</code></td>
<td>
<p>atom indices of core positions with a total volume
under 1 Angstrom^3.</p>
</td></tr>
<tr><td><code>c1A.xyz</code></td>
<td>
<p>xyz indices of core positions with a total volume
under 1 Angstrom^3.</p>
</td></tr>
<tr><td><code>c1A.resno</code></td>
<td>
<p>residue numbers of core positions with a total volume
under 1 Angstrom^3.</p>
</td></tr>
<tr><td><code>c0.5A.atom</code></td>
<td>
<p>atom indices of core positions with a total volume
under 0.5 Angstrom^3.</p>
</td></tr>
<tr><td><code>c0.5A.xyz</code></td>
<td>
<p>xyz indices of core positions with a total volume
under 0.5 Angstrom^3.</p>
</td></tr>
<tr><td><code>c0.5A.resno</code></td>
<td>
<p>residue numbers of core positions with a total volume
under 0.5 Angstrom^3.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The relevance of the &lsquo;core positions&rsquo; identified by this
procedure is dependent upon the number of input structures and their
diversity.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Gerstein and Altman (1995) <em>J. Mol. Biol.</em>  <b>251</b>, 161&ndash;175.
</p>
<p>Gerstein and Chothia (1991) <em>J. Mol. Biol.</em> <b>220</b>, 133&ndash;149.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+plot.core">plot.core</a></code>,
<code><a href="#topic+fit.xyz">fit.xyz</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##-- Generate a small kinesin alignment and read corresponding structures
pdbfiles &lt;- get.pdb(c("1bg2","2ncd","1i6i","1i5s"), URLonly=TRUE)
pdbs &lt;- pdbaln(pdbfiles)

##-- Find 'core' positions
core &lt;- core.find(pdbs)
plot(core)

##-- Fit on these relatively invarient subset of positions 
#core.inds &lt;- print(core, vol=1)
core.inds &lt;- print(core, vol=0.5)
xyz &lt;- pdbfit(pdbs, core.inds, outpath="corefit_structures")

##-- Compare to fitting on all equivalent positions
xyz2 &lt;- pdbfit(pdbs)

## Note that overall RMSD will be higher but RMSF will
##  be lower in core regions, which may equate to a
##  'better fit' for certain applications
gaps &lt;- gap.inspect(pdbs$xyz)
rmsd(xyz[,gaps$f.inds])
rmsd(xyz2[,gaps$f.inds])

plot(rmsf(xyz[,gaps$f.inds]), typ="l", col="blue", ylim=c(0,9))
points(rmsf(xyz2[,gaps$f.inds]), typ="l", col="red")

## End(Not run)

## Not run: 
##-- Run core.find() on a multimodel PDB file
pdb &lt;- read.pdb('1d1d', multi=TRUE)
core &lt;- core.find(pdb)

##-- Run core.find() on a trajectory
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## select calpha coords from a manageable number of frames
ca.ind &lt;- atom.select(pdb, "calpha")$xyz
frames &lt;- seq(1, nrow(trj), by=10)

core &lt;- core.find( trj[frames, ca.ind], write.pdbs=TRUE )

## have a look at the various cores "vmd -m core_pruned/*.pdb"

## Lets use a 6A^3 core cutoff
inds &lt;- print(core, vol=6)
write.pdb(xyz=pdb$xyz[inds$xyz],resno=pdb$atom[inds$atom,"resno"], file="core.pdb")


##- Fit trj onto starting structure based on core indices
xyz &lt;- fit.xyz( fixed = pdb$xyz,
               mobile = trj,
               fixed.inds  = inds$xyz,
               mobile.inds = inds$xyz)

##write.pdb(pdb=pdb, xyz=xyz, file="new_trj.pdb")
##write.ncdf(xyz, "new_trj.nc")


## End(Not run)

</code></pre>

<hr>
<h2 id='cov.nma'> Calculate Covariance Matrix from Normal Modes </h2><span id='topic+cov.nma'></span><span id='topic+cov.enma'></span>

<h3>Description</h3>

<p>Calculate the covariance matrix from a normal mode object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma'
cov(nma)
## S3 method for class 'enma'
cov(enma, ncore=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.nma_+3A_nma">nma</code></td>
<td>
<p> an <code>nma</code> object as obtained from function
<code>nma.pdb</code>. </p>
</td></tr>
<tr><td><code id="cov.nma_+3A_enma">enma</code></td>
<td>
<p> an <code>enma</code> object as obtained from function
<code>nma.pdbs</code>. </p>
</td></tr>
<tr><td><code id="cov.nma_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function calculates the covariance matrix from a <code>nma</code>
object as obtained from function <code>nma.pdb</code> or covariance matrices
from a <code>enma</code> object as obtain from function <code>nma.pdbs</code>. 
</p>


<h3>Value</h3>

<p>Returns the calculated covariance matrix (function <code>cov.nma</code>), or
covariance matrices (function <code>cov.enma</code>). 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
Fuglebakk, E. et al. (2013) <em>JCTC</em> <b>9</b>, 5618&ndash;5628.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a></code> </p>

<hr>
<h2 id='covsoverlap'> Covariance Overlap </h2><span id='topic+covsoverlap'></span><span id='topic+covsoverlap.enma'></span><span id='topic+covsoverlap.nma'></span>

<h3>Description</h3>

<p>Calculate the covariance overlap obtained from NMA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covsoverlap(...)

## S3 method for class 'enma'
covsoverlap(enma, ncore=NULL, ...)

## S3 method for class 'nma'
covsoverlap(a, b, subset=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covsoverlap_+3A_enma">enma</code></td>
<td>
<p> an object of class <code>"enma"</code> obtained from function
<code>nma.pdbs</code>. </p>
</td></tr>
<tr><td><code id="covsoverlap_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="covsoverlap_+3A_a">a</code></td>
<td>
<p> a list object with elements &lsquo;U&rsquo; and &lsquo;L&rsquo;
(e.g. as obtained from function <code>nma</code>) containing the
eigenvectors and eigenvalues, respectively, to be 
compared with <code>b</code>. </p>
</td></tr>
<tr><td><code id="covsoverlap_+3A_b">b</code></td>
<td>
<p> a list object with elements &lsquo;U&rsquo; and &lsquo;L&rsquo;
(e.g. as obtained from function <code>nma</code>) containing the
eigenvectors and eigenvalues, respectively, to be 
compared with <code>a</code>. </p>
</td></tr>
<tr><td><code id="covsoverlap_+3A_subset">subset</code></td>
<td>
<p> the number of modes to consider. </p>
</td></tr>
<tr><td><code id="covsoverlap_+3A_...">...</code></td>
<td>
<p> arguments passed to associated functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance overlap is a measure for the similarity between two
covariance matrices, e.g. obtained from NMA. 
</p>


<h3>Value</h3>

<p>Returns the similarity coefficient(s).
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.   
Romo, T.D. et al. (2011) <em>Proteins</em> <b>79</b>, 23&ndash;34.
</p>


<h3>See Also</h3>

<p> Other similarity measures:
<code><a href="#topic+sip">sip</a></code>, <code><a href="#topic+covsoverlap">covsoverlap</a></code>, <code><a href="#topic+bhattacharyya">bhattacharyya</a></code>.
</p>

<hr>
<h2 id='dccm'> DCCM: Dynamical Cross-Correlation Matrix </h2><span id='topic+dccm'></span>

<h3>Description</h3>

<p>Determine the cross-correlations of atomic displacements. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dccm_+3A_x">x</code></td>
<td>
<p> a numeric matrix of Cartesian coordinates with a row per
structure/frame which will br passed to <code>dccm.xyz()</code>.
Alternatively, an object  of class <code>nma</code> as obtained from
function <code>nma</code> that will be passed to the <code>dccm.nma()</code>
function, see below for examples. </p>
</td></tr> 
<tr><td><code id="dccm_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the methods
<code>dccm.xyz</code>, <code>dccm.pca</code>, <code>dccm.nma</code>, and <code>dccm.enma</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dccm</code> is a generic function calling the corresponding function
determined by the class of the input argument <code>x</code>. Use
<code>methods("dccm")</code> to get all the methods for <code>dccm</code>
generic:
</p>
<p><code><a href="#topic+dccm.xyz">dccm.xyz</a></code> will be used when <code>x</code> is a numeric matrix
containing Cartesian coordinates (e.g. trajectory data).
</p>
<p><code><a href="#topic+dccm.pca">dccm.pca</a></code> will calculate the cross-correlations based on
an <code>pca</code> object.
</p>
<p><code><a href="#topic+dccm.nma">dccm.nma</a></code> will calculate the cross-correlations based on
an <code>nma</code> object. Similarly, <code><a href="#topic+dccm.enma">dccm.enma</a></code> will
calculate the correlation matrices based on an ensemble of <code>nma</code>
objects (as obtained from function <code>nma.pdbs</code>).
</p>
<p><code><a href="#topic+plot.dccm">plot.dccm</a></code> and <code><a href="#topic+pymol.dccm">pymol.dccm</a></code> provides
convenient functionality to plot a correlation map, and visualize the
correlations in the structure, respectively.
</p>
<p>See examples for each corresponding function for more details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dccm.xyz">dccm.xyz</a></code>, <code><a href="#topic+dccm.nma">dccm.nma</a></code>,
<code><a href="#topic+dccm.enma">dccm.enma</a></code>, <code><a href="#topic+dccm.pca">dccm.pca</a></code>, <code><a href="#topic+plot.dccm">plot.dccm</a></code>,
<code><a href="#topic+pymol.dccm">pymol.dccm</a></code>. </p>

<hr>
<h2 id='dccm.enma'> Cross-Correlation for Ensemble NMA (eNMA) </h2><span id='topic+dccm.enma'></span>

<h3>Description</h3>

<p>Calculate the cross-correlation matrices from an ensemble of NMA
objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'enma'
dccm(x, ncore = NULL, na.rm=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dccm.enma_+3A_x">x</code></td>
<td>
<p> an object of class <code>enma</code> as obtained from
function <code>nma.pdbs</code>. </p>
</td></tr>
<tr><td><code id="dccm.enma_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="dccm.enma_+3A_na.rm">na.rm</code></td>
<td>
<p> logical, if FALSE the DCCM might containt NA values
(applies only when the <code>enma</code> object is calculated with
argument &lsquo;rm.gaps=FALSE&rsquo;). </p>
</td></tr>
<tr><td><code id="dccm.enma_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>dccm.nma</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for calling <code>dccm.nma</code> on a collection
of &lsquo;nma&rsquo; objects as obtained from function <code>nma.pdbs</code>.
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>all.dccm</code></td>
<td>
<p> an array or list containing the correlation matrices
for each &lsquo;nma&rsquo; object. An array is returned when the
&lsquo;enma&rsquo; object is calculated with &lsquo;rm.gaps=TRUE&rsquo;, and a
list is used when &lsquo;rm.gaps=FALSE&rsquo;. </p>
</td></tr>
<tr><td><code>avg.dccm</code></td>
<td>
<p> a numeric matrix containing the average correlation
matrix. The average is only calculated when the &lsquo;enma&rsquo; object
is calculated with &lsquo;rm.gaps=TRUE&rsquo;. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Wynsberghe. A.W.V, Cui, Q. <em>Structure</em> <b>14</b>, 1647&ndash;1653.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+dccm.nma">dccm.nma</a></code>, <code><a href="#topic+plot.dccm">plot.dccm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Needs MUSCLE installed - testing excluded

if(check.utility("muscle")) {

## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
files &lt;- get.pdb(ids, split = TRUE, path = tempdir())

## Sequence/Structure Alignement
pdbs &lt;- pdbaln(files, outfile = tempfile())

## Normal mode analysis on aligned data
modes &lt;- nma(pdbs)

## Calculate all 6 correlation matrices
cij &lt;- dccm(modes)

## Plot correlations for first structure
plot.dccm(cij$all.dccm[,,1])

}


</code></pre>

<hr>
<h2 id='dccm.gnm'>Dynamic Cross-Correlation from Gaussian Network Model</h2><span id='topic+dccm.egnm'></span><span id='topic+dccm.gnm'></span>

<h3>Description</h3>

<p>Calculate the cross-correlation matrix from Gaussian network model normal 
modes analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
dccm(x, ...)

## S3 method for class 'egnm'
dccm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dccm.gnm_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;gnm&rsquo; or &lsquo;egnm&rsquo; as obtained from 
<code><a href="#topic+gnm">gnm</a></code>.</p>
</td></tr>
<tr><td><code id="dccm.gnm_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the cross-correlation matrix from Gaussian network
model (GNM) normal modes analysis (NMA) obtained from <code>gnm</code>. It returns 
a matrix of residue-wise cross-correlations whose elements, Cij, may be 
displayed in a graphical representation frequently termed a dynamical 
cross-correlation map, or DCCM. (See more details in <code>help(dccm.nma)</code>).
</p>


<h3>Value</h3>

<p>Returns a cross-correlation matrix.
</p>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Lars Skjaerven
</p>


<h3>References</h3>

<p>Bahar, I. et al. (1997) <em>Folding Des.</em> <b>2</b>, 173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="#topic+dccm.nma">dccm.nma</a></code>, <code><a href="#topic+dccm.enma">dccm.enma</a></code>,
<code><a href="#topic+plot.dccm">plot.dccm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
   
## Calculate normal modes
modes &lt;- gnm(pdb)
   
## Calculate correlation matrix
cm &lt;- dccm(modes)

## Plot correlation map
plot(cm, sse = pdb, contour = FALSE, col.regions = bwr.colors(20),
     at = seq(-1, 1, 0.1))

</code></pre>

<hr>
<h2 id='dccm.nma'> Dynamic Cross-Correlation from Normal Modes Analysis </h2><span id='topic+dccm.nma'></span>

<h3>Description</h3>

<p>Calculate the cross-correlation matrix from Normal Modes Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma'
dccm(x, nmodes = NULL, ncore = NULL, progress = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dccm.nma_+3A_x">x</code></td>
<td>
<p> an object of class <code>nma</code> as obtained from
function <code>nma</code>. </p>
</td></tr>
<tr><td><code id="dccm.nma_+3A_nmodes">nmodes</code></td>
<td>
<p> numerical, number of modes to consider. </p>
</td></tr>
<tr><td><code id="dccm.nma_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="dccm.nma_+3A_progress">progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td></tr>
<tr><td><code id="dccm.nma_+3A_...">...</code></td>
<td>
<p> additional arguments ? </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the cross-correlation matrix from Normal
Modes Analysis (NMA) obtained from <code>nma</code> of a protein
structure.  It returns a matrix of residue-wise cross-correlations
whose elements, Cij, may be displayed in a graphical
representation frequently termed a dynamical cross-correlation
map, or DCCM.
</p>
<p>If Cij = 1 the fluctuations of residues i and j are completely
correlated (same period and same phase), if Cij = -1 the
fluctuations of residues i and j are completely anticorrelated (same
period and opposite phase), and if Cij = 0 the fluctuations of i
and j are not correlated.
</p>


<h3>Value</h3>

<p>Returns a cross-correlation matrix.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Wynsberghe. A.W.V, Cui, Q. <em>Structure</em> <b>14</b>, 1647&ndash;1653.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+plot.dccm">plot.dccm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate normal modes
modes &lt;- nma(pdb)

## Calculate correlation matrix
cm &lt;- dccm.nma(modes)

## Plot correlation map
plot(cm, sse = pdb, contour = FALSE, col.regions = bwr.colors(20),
     at = seq(-1, 1, 0.1))
</code></pre>

<hr>
<h2 id='dccm.pca'> Dynamical Cross-Correlation Matrix from Principal Component Analysis </h2><span id='topic+dccm.pca'></span>

<h3>Description</h3>

<p>Calculate the cross-correlation matrix from principal component analysis (PCA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pca'
dccm(x, pc = NULL, method = c("pearson", "lmi"), ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dccm.pca_+3A_x">x</code></td>
<td>
<p> an object of class <code>pca</code> as obtained from
function <code>pca.xyz</code>. </p>
</td></tr>
<tr><td><code id="dccm.pca_+3A_pc">pc</code></td>
<td>
<p> numerical, indices of PCs to be included in the calculation.
If all negative, PCs complementary to <code>abs(pc)</code> are included. </p>
</td></tr>
<tr><td><code id="dccm.pca_+3A_method">method</code></td>
<td>
<p> method to calculate the cross-correlation. Currently supports
Pearson and linear mutual information (LMI). </p>
</td></tr>
<tr><td><code id="dccm.pca_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
By default (<code>ncore = NULL</code>), use all available cores detected. </p>
</td></tr>
<tr><td><code id="dccm.pca_+3A_...">...</code></td>
<td>
<p> Additional arguments to be passed (currently ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the cross-correlation matrix from principal 
component analysis (PCA) obtained from <code>pca.xyz</code> of a set of protein
structures. It is an alternative way to calculate correlation in addition
to the conventional way from xyz coordinates directly. But, in this new 
way one can freely chooses the PCs to be included in the 
calculation (e.g. for filtering out PCs with small eigenvalues).
</p>


<h3>Value</h3>

<p>Returns a cross-correlation matrix with values in a range from -1 to 1 (Pearson)
or from 0 to 1 (LMI).
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pca.xyz">pca.xyz</a></code>, <code><a href="#topic+plot.dccm">plot.dccm</a></code>, <code><a href="#topic+dccm">dccm</a></code>, 
<code><a href="#topic+dccm.xyz">dccm.xyz</a></code>, <code><a href="#topic+dccm.nma">dccm.nma</a></code>, <code><a href="#topic+dccm.enma">dccm.enma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##-- Read example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## Select residues 24 to 27 and 85 to 90 in both chains
inds &lt;- atom.select(pdb, resno=c(24:27,85:90), elety='CA')

## lsq fit of trj on pdb
xyz &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=inds$xyz, mobile.inds=inds$xyz)

## Do PCA
pca &lt;- pca.xyz(xyz)

## DCCM: only use first 10 PCs
cij &lt;- dccm(pca, pc = c(1:10))

## Plot DCCM
plot(cij)

## DCCM: remove first 10 PCs
cij &lt;- dccm(pca, pc = -c(1:10))

## Plot DCCM
plot(cij)


</code></pre>

<hr>
<h2 id='dccm.xyz'> Dynamical Cross-Correlation Matrix from Cartesian Coordinates </h2><span id='topic+dccm.xyz'></span>

<h3>Description</h3>

<p>Determine the cross-correlations of atomic displacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xyz'
dccm(x, reference = NULL, grpby=NULL, method=c("pearson", "lmi"),
                   ncore=1, nseg.scale=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dccm.xyz_+3A_x">x</code></td>
<td>
<p> a numeric matrix of Cartesian coordinates with a row per
structure/frame. </p>
</td></tr>
<tr><td><code id="dccm.xyz_+3A_reference">reference</code></td>
<td>
<p> The reference structure about which displacements are
analysed. </p>
</td></tr>
<tr><td><code id="dccm.xyz_+3A_grpby">grpby</code></td>
<td>
<p> a vector counting connective duplicated elements that
indicate the elements of <code>xyz</code> that should be considered as a group
(e.g. atoms from a particular residue). </p>
</td></tr>
<tr><td><code id="dccm.xyz_+3A_method">method</code></td>
<td>
<p> method to calculate the cross-correlation. Currently supports
Pearson and linear mutual information (LMI). </p>
</td></tr>
<tr><td><code id="dccm.xyz_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore=NULL</code> will use all the cores detected. </p>
</td></tr> 
<tr><td><code id="dccm.xyz_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="dccm.xyz_+3A_...">...</code></td>
<td>
<p> Additional arguments to be passed (currently ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extent to which the atomic fluctuations/displacements of a system are
correlated with one another can be assessed by examining the magnitude
of all pairwise cross-correlation coefficients (see McCammon and Harvey,
1986).
</p>
<p>This function returns a matrix of all atom-wise cross-correlations
whose elements, Cij, may be displayed in a graphical representation
frequently termed a dynamical cross-correlation map, or DCCM.
</p>
<p>If Cij = 1 the fluctuations of atoms i and j are completely correlated
(same period and same phase), if Cij = -1 the fluctuations of atoms i
and j are completely anticorrelated (same period and opposite phase),
and if Cij = 0 the fluctuations of i and j are not correlated.
</p>
<p>Typical characteristics of DCCMs include a line of strong
cross-correlation along the diagonal, cross-correlations emanating
from the diagonal, and off-diagonal cross-correlations. The high
diagonal values occur where i = j, where Cij is always equal to
1.00. Positive correlations emanating from the diagonal indicate
correlations between contiguous residues, typically within a secondary
structure element or other tightly packed unit of structure.
Typical secondary structure patterns include a triangular pattern for
helices and a plume for strands.  Off-diagonal positive and negative
correlations may indicate potentially interesting correlations between
domains of non-contiguous residues.
</p>
<p>If <code>method = "pearson"</code>, the conventional Pearson's inner-product 
correlaiton calculation will be invoked, in which only the diagnol of 
each atom-atom variance-covariance sub-matrix is considered. 
</p>
<p>If <code>method = "lmi"</code>, then the linear mutual information
cross-correlation will be calculated. &lsquo;LMI&rsquo; considers both
diagnol and off-diagnol entries in the sub-matrices, and so even captures 
the correlation of atoms moving in orthognal directions.
</p>


<h3>Value</h3>

<p>Returns a cross-correlation matrix with values in a range from -1 to 1 (Pearson)
or from 0 to 1 (LMI).
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao, Hongyang Li, Gisle Saelensminde, and Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>McCammon, A. J. and Harvey, S. C. (1986) <em>Dynamics of
Proteins and Nucleic Acids</em>, Cambridge University Press, Cambridge.
</p>
<p>Lange, O.F. and Grubmuller, H. (2006) <em>PROTEINS: Structure, Function, and Bioinformatics</em> <b>62</b>:1053&ndash;1061.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cor">cor</a></code> for examining xyz cross-correlations,
<code><a href="#topic+dccm">dccm</a></code>, <code><a href="#topic+dccm.nma">dccm.nma</a></code>,
<code><a href="#topic+dccm.pca">dccm.pca</a></code>, <code><a href="#topic+dccm.enma">dccm.enma</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>

##-- Read example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## select residues 24 to 27 and 85 to 90 in both chains
inds &lt;- atom.select(pdb, resno=c(24:27,85:90), elety='CA')

## lsq fit of trj on pdb
xyz &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=inds$xyz, mobile.inds=inds$xyz)

## DCCM (slow to run so restrict to Calpha)
cij &lt;- dccm(xyz)

## Plot DCCM
plot(cij)

## Or
library(lattice)
contourplot(cij, region = TRUE, labels=FALSE, col="gray40",
            at=c(-1, -0.75, -0.5, -0.25, 0.25, 0.5, 0.75, 1),
            xlab="Residue No.", ylab="Residue No.",
            main="DCCM: dynamic cross-correlation map")
            
## LMI matrix
cij &lt;- dccm(xyz, method='lmi')

## Plot LMI matrix
#plot(cij)
col.scale &lt;- colorRampPalette(c("gray95", "cyan"))(5)
plot(cij, at=seq(0.4,1, length=5), col.regions=col.scale)


</code></pre>

<hr>
<h2 id='deformation.nma'> Deformation Analysis </h2><span id='topic+deformation.nma'></span>

<h3>Description</h3>

<p>Calculate deformation energies from Normal Mode Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deformation.nma(nma, mode.inds = NULL, pfc.fun = NULL, ncore = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deformation.nma_+3A_nma">nma</code></td>
<td>
<p> a list object of class <code>"nma"</code> (obtained with
<code><a href="#topic+nma">nma</a></code>).</p>
</td></tr>
<tr><td><code id="deformation.nma_+3A_mode.inds">mode.inds</code></td>
<td>
<p> a numeric vector of mode indices in which the
calculation should be based. </p>
</td></tr>
<tr><td><code id="deformation.nma_+3A_pfc.fun">pfc.fun</code></td>
<td>
<p> customized pair force constant (&lsquo;pfc&rsquo;)
function. The provided function should take a vector of distances as
an argument to return a vector of force constants. See <code>nma</code>
for examples. </p>
</td></tr>
<tr><td><code id="deformation.nma_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deformation analysis provides a measure for the amount of local
flexibility of the protein structure - i.e. atomic motion relative to
neighbouring atoms. It differs from &lsquo;fluctuations&rsquo; (e.g. RMSF
values) which provide amplitudes of the absolute atomic motion.
</p>
<p>Deformation energies are calculated based on the <code>nma</code> object. By
default the first 20 non-trivial modes are included in the calculation.
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>ei</code></td>
<td>
<p> numeric matrix containing the energy contribution (E) from
each atom (i; row-wise) at each mode index (column-wise). </p>
</td></tr>
<tr><td><code>sums</code></td>
<td>
<p> deformation energies corresponding to each mode. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Hinsen, K. (1998) <em>Proteins</em> <b>33</b>, 417&ndash;429.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Running the example takes some time - testing excluded

## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Calculate deformation energies
def.energies &lt;- deformation.nma(modes)


## Not run: 
## Fluctuations of first non-trivial mode
def.energies &lt;- deformation.nma(modes, mode.inds=seq(7, 16))

write.pdb(pdb=NULL, xyz=modes$xyz,
          b=def.energies$ei[,1])

## End(Not run)
</code></pre>

<hr>
<h2 id='diag.ind'> Diagonal Indices of a Matrix </h2><span id='topic+diag.ind'></span>

<h3>Description</h3>

<p>Returns a matrix of logicals the same size of a given matrix with
entries 'TRUE' in the upper triangle close to the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.ind(x, n = 1, diag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag.ind_+3A_x">x</code></td>
<td>
<p> a matrix. </p>
</td></tr>
<tr><td><code id="diag.ind_+3A_n">n</code></td>
<td>
<p> the number of elements from the diagonal to include. </p>
</td></tr>
<tr><td><code id="diag.ind_+3A_diag">diag</code></td>
<td>
<p> logical. Should the diagonal be included? </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic function useful for masking elements close to the diagonal of a
given matrix.
</p>


<h3>Value</h3>

<p>Returns a matrix of logicals the same size of a given matrix with
entries 'TRUE' in the upper triangle close to the diagonal.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+diag">diag</a></code>,  <code><a href="base.html#topic+lower.tri">lower.tri</a></code>,
<code><a href="base.html#topic+upper.tri">upper.tri</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>diag.ind( matrix(,ncol=5,nrow=5), n=3 )
</code></pre>

<hr>
<h2 id='difference.vector'> Difference Vector </h2><span id='topic+difference.vector'></span>

<h3>Description</h3>

<p>Define a difference vector between two conformational states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference.vector(xyz, xyz.inds=NULL, normalize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference.vector_+3A_xyz">xyz</code></td>
<td>
<p> numeric matrix of Cartesian coordinates with a row per
structure. </p>
</td></tr> 
<tr><td><code id="difference.vector_+3A_xyz.inds">xyz.inds</code></td>
<td>
<p> a vector of indices that selects the elements of columns upon
which the calculation should be based. </p>
</td></tr>
<tr><td><code id="difference.vector_+3A_normalize">normalize</code></td>
<td>
<p> logical, if TRUE the difference vector is
normalized. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Squared overlap (or dot product) is used to measure the similiarity 
between a displacement vector (e.g. a difference vector between two 
conformational states) and mode vectors obtained from principal component 
or normal modes analysis. 
</p>


<h3>Value</h3>

<p>Returns a numeric vector of the structural difference (normalized if desired).
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+overlap">overlap</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(kinesin)
     
# Ignore gap containing positions
gaps.pos &lt;- gap.inspect(pdbs$xyz)
     
#-- Do PCA
pc.xray &lt;- pca.xyz(pdbs$xyz[, gaps.pos$f.inds])
     
# Define a difference vector between two structural states
diff.inds &lt;- c(grep("d1v8ka", pdbs$id), 
               grep("d1goja", pdbs$id))

## Calculate the difference vector
dv &lt;- difference.vector( pdbs$xyz[diff.inds,], gaps.pos$f.inds )

# Calculate the squared overlap between the PCs and the difference vector  
o &lt;- overlap(pc.xray, dv)

detach(kinesin)

</code></pre>

<hr>
<h2 id='dist.xyz'>  Calculate the Distances Between the Rows of Two Matrices </h2><span id='topic+dist.xyz'></span>

<h3>Description</h3>

<p>Compute the pairwise euclidean distances between the rows of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.xyz(a, b = NULL, all.pairs=TRUE, ncore=1, nseg.scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.xyz_+3A_a">a</code></td>
<td>
<p> a &lsquo;xyz&rsquo; object, numeric data matrix, or vector. </p>
</td></tr>
<tr><td><code id="dist.xyz_+3A_b">b</code></td>
<td>
<p> an optional second &lsquo;xyz&rsquo; object, data matrix, or vector. </p>
</td></tr>
<tr><td><code id="dist.xyz_+3A_all.pairs">all.pairs</code></td>
<td>
<p>  logical, if TRUE all pairwise distances between the
rows of &lsquo;a&rsquo; and all rows of &lsquo;b&rsquo; are computed, if FALSE
only the distances between coresponding rows of &lsquo;a&rsquo; and
&lsquo;b&rsquo; are computed. </p>
</td></tr>
<tr><td><code id="dist.xyz_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="dist.xyz_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a matrix of euclidean distances between each row
of &lsquo;a&rsquo; and all rows of &lsquo;b&rsquo;.  Input vectors are
coerced to three dimensional matrices (representing the Cartesian
coordinates x, y and z) prior to distance computation.  If &lsquo;b&rsquo; is
not provided then the pairwise distances between all rows of &lsquo;a&rsquo;
are computed.
</p>


<h3>Value</h3>

<p>Returns a matrix of pairwise euclidean distances between each row of
&lsquo;a&rsquo; and all rows of &lsquo;b&rsquo;.
</p>


<h3>Note</h3>

<p>This function will choke if &lsquo;b&rsquo; has too many rows.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dm">dm</a></code>, <code><a href="stats.html#topic+dist">dist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> dist.xyz( c(1,1,1, 3,3,3), c(3,3,3, 2,2,2, 1,1,1))
 dist.xyz( c(1,1,1, 3,3,3), c(3,3,3, 2,2,2, 1,1,1), all.pairs=FALSE)

</code></pre>

<hr>
<h2 id='dm'> Distance Matrix Analysis </h2><span id='topic+dm'></span><span id='topic+dm.pdb'></span><span id='topic+dm.xyz'></span><span id='topic+dm.pdbs'></span>

<h3>Description</h3>

<p>Construct a distance matrix for a given protein structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm(...)

## S3 method for class 'pdb'
dm(pdb, inds = NULL, grp = TRUE, verbose=TRUE, ...)
## S3 method for class 'pdbs'
dm(pdbs, rm.gaps=FALSE, all.atom=FALSE, 
                        aligned.atoms.only=NULL, ...)

## S3 method for class 'xyz'
dm(xyz, grpby = NULL, scut = NULL, mask.lower = TRUE, 
                  gc.first=FALSE, ncore=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_+3A_pdb">pdb</code></td>
<td>
<p> a <code>pdb</code> structure object as returned by
<code><a href="#topic+read.pdb">read.pdb</a></code> or a numeric vector of &lsquo;xyz&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="dm_+3A_inds">inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from <code>atom.select</code>
that selects the elements of <code>pdb</code> upon which the calculation
should be based. </p>
</td></tr>
<tr><td><code id="dm_+3A_grp">grp</code></td>
<td>
<p> logical, if TRUE atomic distances will be grouped according
to their residue membership. See &lsquo;grpby&rsquo;. </p>
</td></tr>
<tr><td><code id="dm_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE possible warnings are printed. </p>
</td></tr>
<tr><td><code id="dm_+3A_pdbs">pdbs</code></td>
<td>
<p> a &lsquo;pdbs&rsquo; object as returned by <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.all">read.all</a></code>, or <code><a href="#topic+pdbaln">pdbaln</a></code>. </p>
</td></tr>
<tr><td><code id="dm_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE gapped positions are removed in the returned value. </p>
</td></tr>
<tr><td><code id="dm_+3A_all.atom">all.atom</code></td>
<td>
<p> logical, if TRUE all-atom coordinates from <code><a href="#topic+read.all">read.all</a></code>
are used. </p>
</td></tr>
<tr><td><code id="dm_+3A_aligned.atoms.only">aligned.atoms.only</code></td>
<td>
<p> logical, if TRUE only equivalent (aligned) atoms are considered. 
Only meaningful when <code>all.atom=TRUE</code>. Default: FALSE. </p>
</td></tr> 
<tr><td><code id="dm_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector or matrix of Cartesian coordinates.</p>
</td></tr>
<tr><td><code id="dm_+3A_grpby">grpby</code></td>
<td>
<p> a vector counting connective duplicated elements that
indicate the elements of <code>xyz</code> that should be considered as a group
(e.g. atoms from a particular residue). </p>
</td></tr>
<tr><td><code id="dm_+3A_scut">scut</code></td>
<td>
<p> a cutoff neighbour value which has the effect of
excluding atoms, or groups, that are sequentially within this
value.</p>
</td></tr>
<tr><td><code id="dm_+3A_mask.lower">mask.lower</code></td>
<td>
<p> logical, if TRUE the lower matrix elements
(i.e. those below the diagonal) are returned as NA.</p>
</td></tr>
<tr><td><code id="dm_+3A_gc.first">gc.first</code></td>
<td>
<p> logical, if TRUE will call gc() first before calculation of 
distance matrix. This is to solve the memory overload problem when <code>ncore &gt; 1</code>
and <code>xyz</code> has many rows/columns, with a bit sacrifice on speed. </p>
</td></tr>
<tr><td><code id="dm_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="dm_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distance matrices, also called distance plots or distance maps, are an
established means of describing and comparing protein conformations
(e.g. Phillips, 1970; Holm, 1993).
</p>
<p>A distance matrix is a 2D representation of 3D structure that is
independent of the coordinate reference frame and, ignoring
chirality, contains enough information to reconstruct the 3D Cartesian
coordinates (e.g. Havel, 1983).
</p>


<h3>Value</h3>

<p>Returns a numeric matrix of class <code>"dmat"</code>, with all N by N
distances, where N is the number of selected atoms. With multiple
frames the output is provided in a three dimensional array. 
</p>


<h3>Note</h3>

<p>The input <code>selection</code> can be any character string or pattern
interpretable by the function <code><a href="#topic+atom.select">atom.select</a></code>.  For example,
shortcuts <code>"calpha"</code>, <code>"back"</code>, <code>"all"</code> and selection
strings of the form <code>/segment/chain/residue number/residue
    name/element number/element name/</code>; see <code><a href="#topic+atom.select">atom.select</a></code>
for details.
</p>
<p>If a coordinate vector is provided as input (rather than a <code>pdb</code>
object) the <code>selection</code> option is redundant and the input vector
should be pruned instead to include only desired positions. 
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Phillips (1970) <em>Biochem. Soc. Symp.</em> <b>31</b>, 11&ndash;28.
</p>
<p>Holm (1993) <em>J. Mol. Biol.</em> <b>233</b>, 123&ndash;138.
</p>
<p>Havel (1983) <em>Bull. Math. Biol.</em> <b>45</b>, 665&ndash;720.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.dmat">plot.dmat</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

##--- Distance Matrix Plot
pdb &lt;- read.pdb( "4q21" )
k &lt;- dm(pdb,inds="calpha")
filled.contour(k, nlevels = 10)

## NOTE: FOLLOWING EXAMPLE NEEDS MUSCLE INSTALLED
if(check.utility("muscle")) {

##--- DDM: Difference Distance Matrix
# Downlaod and align two PDB files
pdbs &lt;- pdbaln( get.pdb( c( "4q21", "521p"), path = tempdir() ), outfile = tempfile() )

# Get distance matrix
a &lt;- dm.xyz(pdbs$xyz[1,])
b &lt;- dm.xyz(pdbs$xyz[2,])

# Calculate DDM
c &lt;- a - b

# Plot DDM
plot(c,key=FALSE, grid=FALSE)

plot(c, axis.tick.space=10,
     resnum.1=pdbs$resno[1,],
     resnum.2=pdbs$resno[2,],
     grid.col="black",
     xlab="Residue No. (4q21)", ylab="Residue No. (521p)")
}


## Not run: 
##-- Residue-wise distance matrix based on the
##   minimal distance between all available atoms
l &lt;- dm.xyz(pdb$xyz, grpby=pdb$atom[,"resno"], scut=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='dssp'> Secondary Structure Analysis with DSSP or STRIDE </h2><span id='topic+dssp'></span><span id='topic+dssp.pdb'></span><span id='topic+dssp.pdbs'></span><span id='topic+dssp.xyz'></span><span id='topic+stride'></span><span id='topic+print.sse'></span>

<h3>Description</h3>

<p>Secondary structure assignment according to the method of Kabsch and Sander (DSSP)
or the method of Frishman and Argos (STRIDE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dssp(...)

## S3 method for class 'pdb'
dssp(pdb, exefile = "dssp", resno=TRUE, full=FALSE, verbose=FALSE, ...)

## S3 method for class 'pdbs'
dssp(pdbs, ...)

## S3 method for class 'xyz'
dssp(xyz, pdb, ...)

stride(pdb, exefile = "stride", resno=TRUE)

## S3 method for class 'sse'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dssp_+3A_pdb">pdb</code></td>
<td>
<p> a structure object of class <code>"pdb"</code>, obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="dssp_+3A_exefile">exefile</code></td>
<td>
<p> file path to the &lsquo;DSSP&rsquo; or &lsquo;STRIDE&rsquo; program 
on your system (i.e. how is &lsquo;DSSP&rsquo; or &lsquo;STRIDE&rsquo; invoked). </p>
</td></tr>
<tr><td><code id="dssp_+3A_resno">resno</code></td>
<td>
<p> logical, if TRUE output is in terms of residue numbers
rather than residue index (position in sequence). </p>
</td></tr>
<tr><td><code id="dssp_+3A_full">full</code></td>
<td>
<p> logical, if TRUE bridge pairs and hbonds columns are
parsed. </p>
</td></tr>
<tr><td><code id="dssp_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE &lsquo;DSSP&rsquo; warning and error
messages are printed. </p>
</td></tr>
<tr><td><code id="dssp_+3A_pdbs">pdbs</code></td>
<td>
<p> a list object of class <code>"pdbs"</code> (obtained with
<code><a href="#topic+pdbaln">pdbaln</a></code> or <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>). </p>
</td></tr>
<tr><td><code id="dssp_+3A_xyz">xyz</code></td>
<td>
<p> a trajectory object of class <code>"xyz"</code>, obtained from
<code><a href="#topic+read.ncdf">read.ncdf</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>,
<code><a href="#topic+read.crd">read.crd</a></code>. </p>
</td></tr>
<tr><td><code id="dssp_+3A_x">x</code></td>
<td>
<p> an <code>sse</code> object obtained from <code><a href="#topic+dssp.pdb">dssp.pdb</a></code> or 
<code><a href="#topic+stride">stride</a></code>. </p>
</td></tr>
<tr><td><code id="dssp_+3A_...">...</code></td>
<td>
<p> additional arguments to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the &lsquo;DSSP&rsquo; or &lsquo;STRIDE&rsquo; program to define 
secondary structure and psi and phi torsion angles.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>helix</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo;, &lsquo;length&rsquo;,
&lsquo;chain&rsquo; and &lsquo;type&rsquo; of helix, where start and end are
residue numbers or residue index positions depending on the value of
&ldquo;resno&rdquo; input argument. </p>
</td></tr>
<tr><td><code>sheet</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of E
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>turn</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of T
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p> a numeric vector of phi angles. </p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p> a numeric vector of psi angles. </p>
</td></tr>
<tr><td><code>acc</code></td>
<td>
<p> a numeric vector of solvent accessibility. </p>
</td></tr>
<tr><td><code>sse</code></td>
<td>
<p> a character vector of secondary structure type per residue. </p>
</td></tr>
<tr><td><code>hbonds</code></td>
<td>
<p> a 10 or 16 column matrix containing the bridge pair
records as well as backbone NH&ndash;&gt;O and O&ndash;&gt;NH H-bond records. 
(Only available for <code><a href="#topic+dssp">dssp</a></code> </p>
</td></tr>
</table>


<h3>Note</h3>

<p>A system call is made to the &lsquo;DSSP&rsquo; or &lsquo;STRIDE&rsquo; program, 
which must be installed on your system and in the search path for executables.
See <a href="http://thegrantlab.org/bio3d/articles/online/install_vignette/Bio3D_install.html">http://thegrantlab.org/bio3d/articles/online/install_vignette/Bio3D_install.html</a> for 
instructions of how to install these programs.
</p>
<p>For the <code>hbonds</code> list component the column names can be
used as a convenient means of data access, namely:<br />
Bridge pair 1            &ldquo;BP1&rdquo;,<br />
Bridge pair 2            &ldquo;BP2&rdquo;,<br />
Backbone H-bond (NH&ndash;&gt;O) &ldquo;NH-O.1&rdquo;,<br />
H-bond energy of NH&ndash;&gt;O  &ldquo;E1&rdquo;,<br />
Backbone H-bond (O&ndash;&gt;NH) &ldquo;O-HN.1&rdquo;,<br />
H-bond energy of O&ndash;&gt;NH  &ldquo;E2&rdquo;,<br />
Backbone H-bond (NH&ndash;&gt;O) &ldquo;NH-O.2&rdquo;,<br />
H-bond energy of NH&ndash;&gt;O  &ldquo;E3&rdquo;,<br />
Backbone H-bond (O&ndash;&gt;NH) &ldquo;O-HN.2&rdquo;,<br />
H-bond energy of O&ndash;&gt;NH  &ldquo;E4&rdquo;.<br />
</p>
<p>If &lsquo;resno=TRUE&rsquo; the following additional columns are included:<br />
Chain ID of resno &ldquo;BP1&rdquo;:    &ldquo;ChainBP1&rdquo;,<br />
Chain ID of resno &ldquo;BP2&rdquo;:    &ldquo;ChainBP2&rdquo;,<br />
Chain ID of resno &ldquo;O-HN.1&rdquo;: &ldquo;Chain1&rdquo;,<br />
Chain ID of resno &ldquo;NH-O.2&rdquo;: &ldquo;Chain2&rdquo;,<br />
Chain ID of resno &ldquo;O-HN.1&rdquo;: &ldquo;Chain3&rdquo;,<br />
Chain ID of resno &ldquo;NH-O.2&rdquo;: &ldquo;Chain4&rdquo;.
</p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven (dssp.pdbs) </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;DSSP&rsquo; is the work of Kabsch and Sander:
Kabsch and Sander (1983) <em>Biopolymers.</em>  <b>12</b>, 2577&ndash;2637.
</p>
<p>For information on obtaining &lsquo;DSSP&rsquo;, see:<br />
<a href="https://swift.cmbi.umcn.nl/gv/dssp/">https://swift.cmbi.umcn.nl/gv/dssp/</a>.
</p>
<p>&lsquo;STRIDE&rsquo; is the work of Frishman and Argos:
Frishman and Argos (1995) <em>Proteins.</em>  <b>3</b>, 566&ndash;579.
</p>
<p>For information on obtaining the &lsquo;STRIDE&rsquo; program, see:<br />
<a href="http://webclu.bio.wzw.tum.de/stride/">http://webclu.bio.wzw.tum.de/stride/</a>,
or copy it from an installation of VMD.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+torsion.pdb">torsion.pdb</a></code>, <code><a href="#topic+torsion.xyz">torsion.xyz</a></code>,
<code><a href="#topic+plot.bio3d">plot.bio3d</a></code>,
</p>
<p><code><a href="#topic+read.ncdf">read.ncdf</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>,
<code><a href="#topic+read.prmtop">read.prmtop</a></code>, <code><a href="#topic+read.crd">read.crd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##- PDB example
# Read a PDB file
pdb &lt;- read.pdb("1bg2")
sse &lt;- dssp(pdb)
sse2 &lt;- stride(pdb)

## Short summary
sse
sse2

# Helix data
sse$helix

# Precent SSE content
sum(sse$helix$length)/sum(pdb$calpha) * 100
sum(sse$sheet$length)/sum(pdb$calpha) * 100



##- PDBs example
aln  &lt;- read.fasta( system.file("examples/kif1a.fa",package="bio3d") )
pdbs &lt;- read.fasta.pdb( aln )

## Aligned PDB defined secondary structure
pdbs$sse

## Aligned DSSP defined secondary structure 
sse &lt;- dssp(pdbs)


##- XYZ Trajectory
pdb &lt;- read.pdb("2mda", multi=TRUE)
dssp.xyz(pdb$xyz, pdb)

## Note. for large MD trajectories you may want to skip some frames, e.g.
xyz &lt;- rbind(pdb$xyz, pdb$xyz)       ## dummy trajectory
frames &lt;- seq(1, to=nrow(xyz), by=4) ## frame numbers to examine
ss &lt;- dssp.xyz(xyz[frames, ], pdb)      ## matrix of sse frame x residue


## End(Not run)
</code></pre>

<hr>
<h2 id='elements'>Periodic Table of the Elements</h2><span id='topic+elements'></span>

<h3>Description</h3>

<p>This data set gives various information on chemical elements.</p>


<h3>Usage</h3>

<pre><code class='language-R'>elements</code></pre>


<h3>Format</h3>

<p>A data frame containing for each chemical element the following information.
</p>

<dl>
<dt><code>num</code></dt><dd><p>atomic number</p>
</dd>
<dt><code>symb</code></dt><dd><p>elemental symbol</p>
</dd>
<dt><code>areneg</code></dt><dd><p>Allred and Rochow electronegativity  (0.0 if unknown)</p>
</dd>
<dt><code>rcov</code></dt><dd><p>covalent radii (in Angstrom) (1.6 if unknown)</p>
</dd>
<dt><code>rbo</code></dt><dd><p>&quot;bond order&quot; radii</p>
</dd>
<dt><code>rvdw</code></dt><dd><p>van der Waals radii (in Angstrom) (2.0 if unknown)</p>
</dd>
<dt><code>maxbnd</code></dt><dd><p>maximum bond valence (6 if unknown)</p>
</dd>
<dt><code>mass</code></dt><dd><p>IUPAC recommended atomic masses (in amu)</p>
</dd>
<dt><code>elneg</code></dt><dd><p>Pauling electronegativity (0.0 if unknown)</p>
</dd>
<dt><code>ionization</code></dt><dd><p>ionization potential (in eV) (0.0 if unknown)</p>
</dd>
<dt><code>elaffinity</code></dt><dd><p>electron affinity (in eV) (0.0 if unknown)</p>
</dd>
<dt><code>red</code></dt><dd><p>red value for visualization</p>
</dd>
<dt><code>green</code></dt><dd><p>green value for visualization</p>
</dd>
<dt><code>blue</code></dt><dd><p>blue value for visualization</p>
</dd>
<dt><code>name</code></dt><dd><p>element name</p>
</dd>
</dl>



<h3>Source</h3>

<p>Open Babel (2.3.1) file: element.txt<br />
</p>
<p>Created from the Blue Obelisk Cheminformatics Data Repository<br />
Direct Source: http://www.blueobelisk.org/<br />
http://www.blueobelisk.org/repos/blueobelisk/elements.xml includes furhter bibliographic citation information<br />
</p>
<p>- Allred and Rochow Electronegativity from http://www.hull.ac.uk/chemistry/electroneg.php?type=Allred-Rochow<br />
- Covalent radii from http://dx.doi.org/10.1039/b801115j<br />
- Van der Waals radii from http://dx.doi.org/10.1021/jp8111556<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elements)
elements

# Get the mass of some elements
symb &lt;- c("C","O","H")
elements[match(symb,elements[,"symb"]),"mass"]

# Get the van der Waals radii of some elements
symb &lt;- c("C","O","H")
elements[match(symb,elements[,"symb"]),"rvdw"]

</code></pre>

<hr>
<h2 id='entropy'> Shannon Entropy Score </h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Calculate the sequence entropy score for every position in an alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(alignment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_alignment">alignment</code></td>
<td>
<p> sequence alignment returned from
<code><a href="#topic+read.fasta">read.fasta</a></code> or an alignment character matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shannon's information theoretic entropy (Shannon, 1948) is an
often-used measure of residue diversity and hence residue conservation.
</p>


<h3>Value</h3>

<p>Returns a list with five components:
</p>
<table>
<tr><td><code>H</code></td>
<td>
<p>standard entropy score for a 22-letter alphabet.</p>
</td></tr>
<tr><td><code>H.10</code></td>
<td>
<p>entropy score for a 10-letter alphabet (see below).</p>
</td></tr>
<tr><td><code>H.norm</code></td>
<td>
<p> normalized entropy score (for 22-letter alphabet), so that 
conserved (low entropy) columns (or positions) score 1, and diverse
(high entropy) columns score 0.</p>
</td></tr>
<tr><td><code>H.10.norm</code></td>
<td>
<p> normalized entropy score (for 10-letter alphabet),
so that conserved (low entropy) columns score 1 and diverse
(high entropy) columns score 0.</p>
</td></tr>  
<tr><td><code>freq</code></td>
<td>
<p>residue frequency matrix containing percent occurrence
values for each residue type.</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>In addition to the standard entropy score (based on a 22-letter
alphabet of the 20 standard amino-acids, plus a gap character &lsquo;-&rsquo;
and a mask character &lsquo;X&rsquo;), an entropy score, <code>H.10</code>, based on
a 10-letter alphabet is also returned.
</p>
<p>For <code>H.10</code>, residues from the 22-letter alphabet are classified
into one of 10 types, loosely following the convention of Mirny and
Shakhnovich (1999):
Hydrophobic/Aliphatic [V,I,L,M],
Aromatic [F,W,Y],
Ser/Thr [S,T],
Polar [N,Q],
Positive [H,K,R],
Negative [D,E],
Tiny [A,G],
Proline [P],
Cysteine [C], and
Gaps [-,X].
</p>
<p>The residue code &lsquo;X&rsquo; is useful for handling non-standard aminoacids.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Shannon (1948) <em>The System Technical J.</em> <b>27</b>, 379&ndash;422.
</p>
<p>Mirny and Shakhnovich (1999) <em>J. Mol. Biol.</em> <b>291</b>, 177&ndash;196.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+consensus">consensus</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read HIV protease alignment 
aln &lt;- read.fasta(system.file("examples/hivp_xray.fa",package="bio3d"))

# Entropy and consensus
h   &lt;- entropy(aln)
con &lt;- consensus(aln)

names(h$H)=con$seq
print(h$H)

# Entropy for sub-alignment (positions 1 to 20) 
h.sub &lt;- entropy(aln$ali[,1:20])

# Plot entropy and residue frequencies (excluding positions &gt;=60 percent gaps)
H &lt;- h$H.norm
H[ apply(h$freq[21:22,],2,sum)&gt;=0.6 ] = 0

col &lt;- mono.colors(32)
aa  &lt;- rev(rownames(h$freq))
oldpar &lt;- par(no.readonly=TRUE)
layout(matrix(c(1,2),2,1,byrow = TRUE), widths = 7, 
       heights = c(2, 8), respect = FALSE)

# Plot 1: entropy
par(mar = c(0, 4, 2, 2))
barplot(H, border="white", ylab = "Entropy",
        space=0, xlim=c(3.7, 97.3),yaxt="n" )
axis(side=2, at=c(0.2,0.4, 0.6, 0.8))
axis(side=3, at=(seq(0,length(con$seq),by=5)-0.5),
     labels=seq(0,length(con$seq),by=5))
box()

# Plot2: residue frequencies 
par(mar = c(5, 4, 0, 2))
image(x=1:ncol(con$freq),
      y=1:nrow(con$freq),
      z=as.matrix(rev(as.data.frame(t(con$freq)))),
      col=col, yaxt="n", xaxt="n",
      xlab="Alignment Position", ylab="Residue Type")
axis(side=1, at=seq(0,length(con$seq),by=5))
axis(side=2, at=c(1:22), labels=aa)
axis(side=3, at=c(1:length(con$seq)), labels =con$seq)
axis(side=4, at=c(1:22), labels=aa)
grid(length(con$seq), length(aa))
box()

for(i in 1:length(con$seq)) {
  text(i, which(aa==con$seq[i]),con$seq[i],col="white")
}
abline(h=c(3.5, 4.5, 5.5, 3.5, 7.5, 9.5,
         12.5, 14.5, 16.5, 19.5), col="gray")

par(oldpar)
</code></pre>

<hr>
<h2 id='example.data'>Bio3d Example Data</h2><span id='topic+example.data'></span><span id='topic+kinesin'></span><span id='topic+transducin'></span><span id='topic+pdbs'></span><span id='topic+core'></span><span id='topic+annotation'></span><span id='topic+hivp'></span>

<h3>Description</h3>

<p>These data sets contain the results of running various Bio3D
functions on example kinesin and transducin structural data, and on a short 
coarse-grained MD simulation data for HIV protease. The main 
purpose of including this data (which may be generated by the user by following the extended examples documented within the various Bio3D functions) is to
speed up example execution. It should allow users to more quickly
appreciate the capabilities of functions that would otherwise require
raw data download, input and processing before execution.
</p>
<p>Note that related datasets formed the basis of
the work described in (Grant, 2007) and (Yao &amp; Grant, 2013) for <code>kinesin</code>
and <code>transducin</code> examples, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kinesin)
data(transducin)
data(hivp)
</code></pre>


<h3>Format</h3>

<p>Three objects from analysis of the <code>kinesin</code> and <code>transducin</code> sequence and structure
data:
</p>

<ol>
<li><p>pdbs is a list of class <code>pdbs</code> containing aligned PDB
structure data.  In the case of transducin this is the output of running 
<code><a href="#topic+pdbaln">pdbaln</a></code> on a set of 53 G[alpha]i structures from the PDB database (see <code>pdbs$id</code> 
or <code>annotation</code> described below for details). The coordinates
are fitted onto the first structure based on <code>"core"</code> positions obtained from <code><a href="#topic+core.find">core.find</a></code> and superposed using the function <code><a href="#topic+pdbfit">pdbfit</a></code>. 
</p>
</li>
<li><p>core is a list of class <code>"core"</code> obtained by running the
function <code><a href="#topic+core.find">core.find</a></code> on the <code>pdbs</code> object as described above.
</p>
</li>
<li><p>annotation is a character matrix describing the nucleotide state and bound 
ligand species for each structure in <code>pdbs</code> as obtained from the function <code><a href="#topic+pdb.annotate">pdb.annotate</a></code>.
</p>
</li></ol>

<p>One object named <code>net</code> in the hivp example data stores the correlation 
network obtained from the analysis of the MD simulation trajectory of HIV 
protease using the <code>cna</code> function. The original trajectory file can be 
accessed by the command &lsquo;system.file(&quot;examples/hivp.dcd&quot;, package=&quot;bio3d&quot;)&rsquo;. 
</p>


<h3>Source</h3>

<p>A related but more extensive dataset formed the basis of
the work described in (Grant, 2007) and (Yao &amp; Grant, 2013) for <code>kinesin</code>
and <code>transducin</code> examples, respectively.
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Grant, B.J. et al. (2007) <em>J. Mol. Biol.</em> <b>368</b>, 1231&ndash;1248.
</p>
<p>Yao, X.Q. et al. (2013) <em>Biophys. J.</em> <b>105</b>, L08&ndash;L10.
</p>

<hr>
<h2 id='filter.cmap'> Contact Map Consensus Filtering </h2><span id='topic+filter.cmap'></span>

<h3>Description</h3>

<p>This function filters a tridimensional contact matrix (NxNxZ), where N is
the residue number and Z is the simulation number) selecting only
contacts present in at least P simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.cmap(cm, cutoff.sims = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.cmap_+3A_cm">cm</code></td>
<td>
<p> An array of dimensions NxNxZ or a list of NxN matrices
containing binary contact values as obtained from
<code>cmap</code>. Here, &lsquo;N&rsquo; is the residue number and &lsquo;Z&rsquo;
the simulation number. The matrix elements should be 1 if two
residues are in contact and 0 if they are not in contact. </p>
</td></tr>
<tr><td><code id="filter.cmap_+3A_cutoff.sims">cutoff.sims</code></td>
<td>
<p> A single element numeric vector corresponding to
the minimum number of simulations a contact between two residues
must be present. If not, it will be set to 0 in the output matrix. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output matrix is a nXn binary matrix (n = residue number). Elements
equal to 1 correspond to residues in contact, elements equal to 0 to
residues not in contact. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmap">cmap</a></code>, <code><a href="#topic+plot.cmap">plot.cmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
   ## load example data
  pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
  pdb &lt;- read.pdb(pdbfile)

  trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
  trj &lt;- read.dcd(trtfile, verbose=FALSE)

  ## split the trj example in two
  num.of.frames &lt;- dim(trj)[1]
  trj1 &lt;- trj[1:(num.of.frames/2),]
  trj2 &lt;- trj[((num.of.frames/2)+1):num.of.frames,]

  ## Lets work with Calpha atoms only
  ca.inds &lt;- atom.select(pdb, "calpha")
  #noh.inds &lt;- atom.select(pdb, "noh")

  ## calculate single contact map matrices
  cms &lt;- list()
  cms[[1]] &lt;- cmap(trj1[,ca.inds$xyz], pcut=0.3, scut=0, dcut=7, mask.lower=FALSE)
  cms[[2]] &lt;- cmap(trj1[,ca.inds$xyz], pcut=0.3, scut=0, dcut=7, mask.lower=FALSE)

  ## calculate average contact matrix
  cm.filter &lt;- filter.cmap(cms, cutoff.sims=2)

  ## plot the result
  par(pty="s", mfcol=c(1,3))
  plot.cmap(cms[[1]])
  plot.cmap(cms[[2]])
  plot.cmap(cm.filter)

## End(Not run)
</code></pre>

<hr>
<h2 id='filter.dccm'> Filter for Cross-correlation Matrices (Cij) </h2><span id='topic+filter.dccm'></span>

<h3>Description</h3>

<p>This function builds various cij matrix for correlation network analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  filter.dccm(x, cutoff.cij = NULL, cmap = NULL, xyz = NULL, fac = NULL, 
      cutoff.sims = NULL, collapse = TRUE, extra.filter = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.dccm_+3A_x">x</code></td>
<td>
<p> A matrix (nXn), a numeric array with 3 dimensions (nXnXm), 
a list with m cells each containing nXn matrix, or a list with
&lsquo;all.dccm&rsquo; component, containing atomic correlation values, 
where &quot;n&quot; is the number of residues and &quot;m&quot; the number of calculations. 
The matrix elements should be in between -1 and 1. See &lsquo;dccm&rsquo; 
function in bio3d package for further details. </p>
</td></tr>
<tr><td><code id="filter.dccm_+3A_cutoff.cij">cutoff.cij</code></td>
<td>
<p> Threshold for each individual correlation value. 
If NULL, a guessed value will be used. See below for details. </p>
</td></tr>
<tr><td><code id="filter.dccm_+3A_cmap">cmap</code></td>
<td>
<p> logical or numerical matrix indicating the contact map.
If logical and TRUE, contact map will be calculated with input
<code>xyz</code>. </p>
</td></tr> 
<tr><td><code id="filter.dccm_+3A_xyz">xyz</code></td>
<td>
<p> XYZ coordinates, or a &lsquo;pdbs&rsquo; object obtained from 
<code>pdbaln</code> or <code>read.fasta.pdb</code>, for contact map calculations. </p>
</td></tr>
<tr><td><code id="filter.dccm_+3A_fac">fac</code></td>
<td>
<p> factor indicating distinct categories of input correlation matrices. </p>
</td></tr>
<tr><td><code id="filter.dccm_+3A_cutoff.sims">cutoff.sims</code></td>
<td>
<p> Threshold for the number of simulations with observed correlation
value above <code>cutoff.cij</code> for the same residue/atomic pairs. See below for details. </p>
</td></tr>
<tr><td><code id="filter.dccm_+3A_collapse">collapse</code></td>
<td>
<p> logical, if TRUE the mean matrix will be returned. </p>
</td></tr>
<tr><td><code id="filter.dccm_+3A_extra.filter">extra.filter</code></td>
<td>
<p> Filter to apply in addition to the model chosen. </p>
</td></tr> 
<tr><td><code id="filter.dccm_+3A_...">...</code></td>
<td>
<p> extra arguments passed to function <code>cmap</code>. </p>
</td></tr> 
</table>


<h3>Details</h3>

 
<p>If cmap is TRUE or provided a numerical matrix, the function inspects
a set of cross-correlation matrices, or DCCM, and decides edges for 
correlation network analysis based on:
</p>
<p>1. min(abs(cij)) &gt;= cutoff.cij, or
2. max(abs(cij)) &gt;= cutoff.cij &amp;&amp; residues contact each other 
based on results from <code>cmap</code>.
</p>
<p>Otherwise, the function filters DCCMs with <code>cutoff.cij</code> and 
return the mean of correlations present in at least 
<code>cutoff.sims</code> calculated matrices.
</p>
<p>An internally guessed <code>cuoff.cij</code> is used if <code>cutoff.cij=NULL</code> is provided. 
By default, the cutoff is determined by keeping 5% of all residue pairs connected. 
</p>


<h3>Value</h3>

<p>Returns a matrix of class &quot;dccm&quot; or a 3D array of filtered cross-correlations.
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao, Guido Scarabelli &amp; Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+dccm">dccm</a></code>, <code><a href="#topic+dccm.nma">dccm.nma</a></code>, <code><a href="#topic+dccm.xyz">dccm.xyz</a></code>,
<code><a href="#topic+cmap">cmap</a></code>, <code><a href="#topic+plot.dccm">plot.dccm</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Example of transducin
attach(transducin)

gaps.pos &lt;- gap.inspect(pdbs$xyz)
modes &lt;- nma.pdbs(pdbs, ncore=NULL)
dccms &lt;- dccm.enma(modes, ncore=NULL)

cij &lt;- filter.dccm(dccms, xyz=pdbs)

# Example protein kinase
# Select Protein Kinase PDB IDs
ids &lt;- c("4b7t_A", "2exm_A", "1opj_A", "4jaj_A", "1a9u_A",
                 "1tki_A", "1csn_A", "1lp4_A")

# Download and split by chain ID
files &lt;- get.pdb(ids, path = "raw_pdbs", split=TRUE)

# Alignment of structures
pdbs &lt;- pdbaln(files) # Sequence identity
summary(c(seqidentity(pdbs)))

# NMA on all structures
modes &lt;- nma.pdbs(pdbs, ncore=NULL)

# Calculate correlation matrices for each structure
cij &lt;- dccm(modes)

# Set DCCM plot panel names for combined figure
dimnames(cij$all.dccm) = list(NULL, NULL, ids)
plot.dccm(cij$all.dccm)

# Filter to display only correlations present in all structures
cij.all &lt;- filter.dccm(cij, cutoff.sims = 8, cutoff.cij = 0)
plot.dccm(cij.all, main = "Consensus Residue Cross Correlation")

detach(transducin)

## End(Not run)

</code></pre>

<hr>
<h2 id='filter.identity'> Percent Identity Filter </h2><span id='topic+filter.identity'></span>

<h3>Description</h3>

<p>Identify and filter subsets of sequences at a given sequence identity cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.identity(aln = NULL, ide = NULL, cutoff = 0.6, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.identity_+3A_aln">aln</code></td>
<td>
<p> sequence alignment list, obtained from
<code><a href="#topic+seqaln">seqaln</a></code> or <code><a href="#topic+read.fasta">read.fasta</a></code>, or an alignment
character matrix. Not used if &lsquo;ide&rsquo; is given.</p>
</td></tr>
<tr><td><code id="filter.identity_+3A_ide">ide</code></td>
<td>
<p> an optional identity matrix obtained from
<code><a href="#topic+seqidentity">seqidentity</a></code>. </p>
</td></tr>
<tr><td><code id="filter.identity_+3A_cutoff">cutoff</code></td>
<td>
<p> a numeric identity cutoff value ranging between 0 and 1. </p>
</td></tr>
<tr><td><code id="filter.identity_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE print details of the clustering
process. </p>
</td></tr>
<tr><td><code id="filter.identity_+3A_...">...</code></td>
<td>
<p> additional arguments passed to and from functions. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function performs hierarchical cluster analysis of a given sequence
identity matrix &lsquo;ide&rsquo;, or the identity matrix calculated from a given
alignment &lsquo;aln&rsquo;, to identify sequences that fall below a given
identity cutoff value &lsquo;cutoff&rsquo;.  
</p>


<h3>Value</h3>

<p>Returns a list object with components:
</p>
<table>
<tr><td><code>ind</code></td>
<td>
<p>indices of the sequences below the cutoff value.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>an object of class <code>"hclust"</code>, which describes the
tree produced by the clustering process. </p>
</td></tr>
<tr><td><code>ide</code></td>
<td>
<p>a numeric matrix with all pairwise identity values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>,
<code><a href="#topic+seqidentity">seqidentity</a></code>, <code><a href="#topic+entropy">entropy</a></code>, <code><a href="#topic+consensus">consensus</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(kinesin)

ide.mat &lt;- seqidentity(pdbs)

# Histogram of pairwise identity values
op &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,1))
hist(ide.mat[upper.tri(ide.mat)], breaks=30,xlim=c(0,1),
     main="Sequence Identity", xlab="Identity")

k &lt;- filter.identity(ide=ide.mat, cutoff=0.6)
ide.cut &lt;- seqidentity(pdbs$ali[k$ind,])
hist(ide.cut[upper.tri(ide.cut)], breaks=10, xlim=c(0,1),
     main="Sequence Identity", xlab="Identity")

#plot(k$tree, axes = FALSE, ylab="Sequence Identity")
#print(k$ind) # selected
par(op)
detach(kinesin)
</code></pre>

<hr>
<h2 id='filter.rmsd'> RMSD Filter </h2><span id='topic+filter.rmsd'></span>

<h3>Description</h3>

<p>Identify and filter subsets of conformations at a given RMSD cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.rmsd(xyz = NULL, rmsd.mat = NULL, cutoff = 0.5,
            fit = TRUE, verbose = TRUE, inds = NULL, method = "complete",
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.rmsd_+3A_xyz">xyz</code></td>
<td>
<p> a numeric matrix or list object containing multiple
coordinates for pairwise comparison, such as that obtained from
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>. Not used if <code>rmsd.mat</code> is
given. </p>
</td></tr>
<tr><td><code id="filter.rmsd_+3A_rmsd.mat">rmsd.mat</code></td>
<td>
<p>  an optional matrix of RMSD values obtained from
<code><a href="#topic+rmsd">rmsd</a></code>. </p>
</td></tr> 
<tr><td><code id="filter.rmsd_+3A_cutoff">cutoff</code></td>
<td>
<p> a numeric rmsd cutoff value. </p>
</td></tr>
<tr><td><code id="filter.rmsd_+3A_fit">fit</code></td>
<td>
<p> logical, if TRUE coordinate superposition is performed
prior to RMSD calculation. </p>
</td></tr>
<tr><td><code id="filter.rmsd_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE progress details are printed. </p>
</td></tr>
<tr><td><code id="filter.rmsd_+3A_inds">inds</code></td>
<td>
<p> a vector of indices that selects the elements of
<code>xyz</code> upon which the calculation should be based. By default, 
all the non-gap sites in <code>xyz</code>. </p>
</td></tr>
<tr><td><code id="filter.rmsd_+3A_method">method</code></td>
<td>
<p> the agglomeration method to be used. See function 
<code><a href="stats.html#topic+hclust">hclust</a></code> for more information. </p>
</td></tr>
<tr><td><code id="filter.rmsd_+3A_...">...</code></td>
<td>
<p> additional arguments passed to and from functions. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function performs hierarchical cluster analysis of a given matrix of
RMSD values &lsquo;rmsd.mat&rsquo;, or an RMSD matrix calculated from a given
coordinate matrix &lsquo;xyz&rsquo;, to identify conformers that fall below a
given RMSD cutoff value &lsquo;cutoff&rsquo;.
</p>


<h3>Value</h3>

<p>Returns a list object with components:
</p>
<table>
<tr><td><code>ind</code></td>
<td>
<p>indices of the conformers (rows) below the cutoff value.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>an object of class <code>"hclust"</code>, which describes the
tree produced by the clustering process. </p>
</td></tr>
<tr><td><code>rmsd.mat</code></td>
<td>
<p>a numeric matrix with all pairwise RMSD values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmsd">rmsd</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
attach(kinesin)

k &lt;- filter.rmsd(xyz=pdbs,cutoff=0.5)
pdbs$id[k$ind]
hclustplot(k$tree, h=0.5, ylab="RMSD")
abline(h=0.5, col="gray")

detach(kinesin)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit.xyz'> Coordinate Superposition </h2><span id='topic+fit.xyz'></span><span id='topic+rot.lsq'></span>

<h3>Description</h3>

<p>Coordinate superposition with the Kabsch algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.xyz(fixed, mobile,
        fixed.inds  = NULL,
        mobile.inds = NULL,
        verbose=FALSE,
        prefix= "", pdbext = "",
        outpath = "fitlsq", full.pdbs=FALSE, 
        ncore = 1, nseg.scale = 1, ...)

rot.lsq(xx, yy,
        xfit = rep(TRUE, length(xx)), yfit = xfit,
        verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.xyz_+3A_fixed">fixed</code></td>
<td>
<p> numeric vector of xyz coordinates.</p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_mobile">mobile</code></td>
<td>
<p> numeric vector, numeric matrix, or an object with an
<code>xyz</code> component containing one or more coordinate sets. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_fixed.inds">fixed.inds</code></td>
<td>
<p> a vector of indices that selects the elements of
<code>fixed</code> upon which fitting should be based.</p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_mobile.inds">mobile.inds</code></td>
<td>
<p>  a vector of indices that selects the elements
of <code>mobile</code> upon which fitting should be based.</p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_full.pdbs">full.pdbs</code></td>
<td>
<p> logical, if TRUE &ldquo;full&rdquo; coordinate files
(i.e. all atoms) are written to the location specified by
<code>outpath</code>. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_prefix">prefix</code></td>
<td>
<p> prefix to mobile$id to locate &ldquo;full&rdquo; input PDB files.  Only
required if <code>full.pdbs</code> is TRUE. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_pdbext">pdbext</code></td>
<td>
<p> the file name extension of the input PDB files. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_outpath">outpath</code></td>
<td>
<p> character string specifing the output directory when
<code>full.pdbs</code> is TRUE. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_xx">xx</code></td>
<td>
<p> numeric vector corresponding to the moving &lsquo;subject&rsquo;
coordinate set. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_yy">yy</code></td>
<td>
<p> numeric vector corresponding to the fixed &lsquo;target&rsquo;
coordinate set. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_xfit">xfit</code></td>
<td>
<p> logical vector with the same length as <code>xx</code>,  with
TRUE elements corresponding to the subset of positions upon which
fitting is to be performed. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_yfit">yfit</code></td>
<td>
<p> logical vector with the same length as <code>yy</code>,  with
TRUE elements corresponding to the subset of positions upon which
fitting is to be performed. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE more details are printed. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_...">...</code></td>
<td>
<p> other parameters for <code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="fit.xyz_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="fit.xyz_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fit.xyz</code> is a wrapper for the function
<code>rot.lsq</code>, which performs the actual coordinate superposition.
The function <code>rot.lsq</code> is an implementation of the Kabsch
algorithm (Kabsch, 1978) and evaluates the optimal rotation matrix
to minimize the RMSD between two structures.
</p>
<p>Since the Kabsch algorithm assumes that the number of points are the
same in the two input structures, care should be taken to ensure that
consistent atom sets are selected with <code>fixed.inds</code> and
<code>mobile.inds</code>.
</p>
<p>Optionally, &ldquo;full&rdquo; PDB file superposition and output can be
accomplished by setting <br /> <code>full.pdbs=TRUE</code>.  In that case, the
input (<code>mobile</code>) passed to <code>fit.xyz</code> should be a list object
obtained with the function <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, since the
components <code>id</code>, <code>resno</code> and <code>xyz</code> are required to
establish correspondences.  See the examples below.
</p>
<p>In dealing with large vector and matrix, running on multiple
cores, especially when <code>ncore&gt;&gt;1</code>, may ask for a large portion
of system memory. To avoid the overuse of memory, input data is first
split into segments (for xyz matrix, the splitting is along the row). 
The number of data segments is equal to <code>nseg.scale*nseg.base</code>, where
<code>nseg.base </code> is an integer determined by the dimension of the data.
</p>


<h3>Value</h3>

<p>Returns moved coordinates.
</p>


<h3>Author(s)</h3>

<p> Barry Grant with <code>rot.lsq</code> contributions from Leo Caves </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Kabsch <em>Acta Cryst</em> (1978) <b>A34</b>, 827&ndash;828.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rmsd">rmsd</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

##--- Read an alignment &amp; Fit aligned structures
aln  &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))
pdbs &lt;- read.fasta.pdb(aln)

gaps &lt;- gap.inspect(pdbs$xyz)

xyz &lt;- fit.xyz( fixed  = pdbs$xyz[1,],
               mobile = pdbs$xyz,
               fixed.inds  = gaps$f.inds,
               mobile.inds = gaps$f.inds )

#rmsd( xyz[, gaps$f.inds] )
#rmsd( pdbs$xyz[, gaps$f.inds] )

## Not run: 
##-- Superpose again this time outputing PDBs
xyz &lt;- fit.xyz( fixed = pdbs$xyz[1,],
               mobile = pdbs,
               fixed.inds  = gaps$f.inds,
               mobile.inds = gaps$f.inds,
               outpath = "rough_fit",
               full.pdbs = TRUE)

## End(Not run)

##--- Fit two PDBs
A &lt;- read.pdb("1bg2")
A.ind &lt;- atom.select(A, resno=c(256:269), elety='CA')

B &lt;- read.pdb("2kin")
B.ind &lt;- atom.select(B, resno=c(257:270), elety='CA')

xyz &lt;- fit.xyz(fixed=A$xyz, mobile=B$xyz,
               fixed.inds=A.ind$xyz,
               mobile.inds=B.ind$xyz)

## Not run: 
# Write out moved PDB
C &lt;- B; C$xyz = xyz
write.pdb(pdb=C, file = "moved.pdb")

## End(Not run)
</code></pre>

<hr>
<h2 id='fluct.nma'> NMA Fluctuations </h2><span id='topic+fluct.nma'></span>

<h3>Description</h3>

<p>Calculates the atomic fluctuations from normal modes analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluct.nma(nma, mode.inds=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluct.nma_+3A_nma">nma</code></td>
<td>
<p> a list object of class <code>"nma"</code> (obtained with
<code><a href="#topic+nma">nma</a></code>).</p>
</td></tr>
<tr><td><code id="fluct.nma_+3A_mode.inds">mode.inds</code></td>
<td>
<p> a numeric vector containing the the mode numbers in
which the calculation should be based. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Atomic fluctuations are calculated based on the <code>nma</code> object. By
default all modes are included in the calculation.
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of atomic fluctuations.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Hinsen, K. et al. (2000) <em>Chemical Physics</em> <b>261</b>, 25&ndash;37.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Fluctuations
f &lt;- fluct.nma(modes)

## Fluctuations of first non-trivial mode
f &lt;- fluct.nma(modes, mode.inds=c(7,8))
</code></pre>

<hr>
<h2 id='formula2mass'>Chemical Formula to Mass Converter</h2><span id='topic+formula2mass'></span>

<h3>Description</h3>

<p>Compute the molar mass associated to a chemical formula.</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula2mass(form, sum.mass = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula2mass_+3A_form">form</code></td>
<td>
<p>a character string containing a chemical formula on the form: 'C3 H5 N O1'.</p>
</td></tr>
<tr><td><code id="formula2mass_+3A_sum.mass">sum.mass</code></td>
<td>
<p>logical, should the mass of each element be summed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the molar mass (in g.mol-1) associated to a chemical formula.
</p>


<h3>Value</h3>

<p>Return a single element numeric vector containing the mass corresponding to a given chemical formula.
</p>


<h3>Author(s)</h3>

<p>Lars Skjaerven</p>


<h3>See Also</h3>

<p><code><a href="#topic+atom2ele">atom2ele</a></code>, <code><a href="#topic+atom2mass">atom2mass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#formula2mass("C5 H6 N O3")
</code></pre>

<hr>
<h2 id='gap.inspect'> Alignment Gap Summary </h2><span id='topic+gap.inspect'></span>

<h3>Description</h3>

<p>Report the number of gaps per sequence and per position for a given alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gap.inspect(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gap.inspect_+3A_x">x</code></td>
<td>
<p> a matrix or an alignment data structure obtained from
<code><a href="#topic+read.fasta">read.fasta</a></code> or <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reports the number of gap characters per row (i.e. sequence) and
per column (i.e. position) for a given <code>alignment</code>. In addition,
the indices for gap and non-gap containing coloums are returned along
with a binary matrix indicating the location of gap positions. 
</p>


<h3>Value</h3>

<p>Returns a list object with the following components:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>a numeric vector detailing the number of gaps per row
(i.e. sequence).</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>a numeric vector detailing the number of gaps per column
(i.e. position).</p>
</td></tr>
<tr><td><code>t.inds</code></td>
<td>
<p> indices for gap containing coloums </p>
</td></tr>
<tr><td><code>f.inds</code></td>
<td>
<p> indices for non-gap containing coloums</p>
</td></tr>  
<tr><td><code>bin</code></td>
<td>
<p>a binary numeric matrix with the same dimensions as the
<code>alignment</code>, with 0 at non-gap positions and 1 at gap
positions.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>During alignment, gaps are introduced into sequences that are believed
to have undergone deletions or insertions with respect to other
sequences in the alignment.  These gaps, often referred to as
indels, can be represented with &lsquo;NA&rsquo;, a &lsquo;-&rsquo; or
&lsquo;.&rsquo; character.
</p>
<p>This function gives an overview of gap occurrence and may be useful
when considering positions or sequences that could/should be excluded
from further analysis.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aln &lt;- read.fasta( system.file("examples/hivp_xray.fa",
                   package = "bio3d") )

gap.stats &lt;- gap.inspect(aln$ali)
gap.stats$row # Gaps per sequence
gap.stats$col # Gaps per position
##gap.stats$bin # Binary matrix (1 for gap, 0 for aminoacid)
##aln[,gap.stats$f.inds] # Alignment without gap positions 

plot(gap.stats$col, typ="h", ylab="No. of Gaps") 
</code></pre>

<hr>
<h2 id='geostas'> GeoStaS Domain Finder </h2><span id='topic+geostas'></span><span id='topic+geostas.default'></span><span id='topic+geostas.xyz'></span><span id='topic+geostas.nma'></span><span id='topic+geostas.enma'></span><span id='topic+geostas.pdb'></span><span id='topic+geostas.pdbs'></span><span id='topic+amsm.xyz'></span><span id='topic+print.geostas'></span>

<h3>Description</h3>

<p>Identifies geometrically stable domains in biomolecules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geostas(...)

## Default S3 method:
geostas(...)

## S3 method for class 'xyz'
geostas(xyz, amsm = NULL, k = 3, pairwise = TRUE,
      clustalg = "kmeans", fit = TRUE, ncore = NULL, verbose=TRUE, ...)

## S3 method for class 'nma'
geostas(nma, m.inds = 7:11, verbose=TRUE, ...)

## S3 method for class 'enma'
geostas(enma, pdbs = NULL, m.inds = 1:5, verbose=TRUE, ...)

## S3 method for class 'pdb'
geostas(pdb, inds = NULL, verbose=TRUE, ...)

## S3 method for class 'pdbs'
geostas(pdbs, verbose=TRUE, ...)

amsm.xyz(xyz, ncore = NULL)

## S3 method for class 'geostas'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geostas_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions, such as
<code><a href="stats.html#topic+kmeans">kmeans</a></code>, and <code><a href="stats.html#topic+hclust">hclust</a></code> which are called
internally in <code>geostas.xyz</code>. </p>
</td></tr>
<tr><td><code id="geostas_+3A_xyz">xyz</code></td>
<td>
<p> numeric matrix of xyz coordinates as obtained e.g. by
<code><a href="#topic+read.ncdf">read.ncdf</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>, or
<code><a href="#topic+mktrj">mktrj</a></code>. </p>
</td></tr>
<tr><td><code id="geostas_+3A_amsm">amsm</code></td>
<td>
<p> a numeric matrix as obtained by
<code><a href="#topic+amsm.xyz">amsm.xyz</a></code> (convenient e.g. for re-doing only the
clustering analysis of the &lsquo;AMSM&rsquo; matrix). </p>
</td></tr>
<tr><td><code id="geostas_+3A_k">k</code></td>
<td>
<p> an integer scalar or vector with the desired number of
groups. </p>
</td></tr>
<tr><td><code id="geostas_+3A_pairwise">pairwise</code></td>
<td>
<p> logical, if TRUE use pairwise clustering of the atomic
movement similarity matrix (AMSM), else columnwise. </p>
</td></tr>
<tr><td><code id="geostas_+3A_clustalg">clustalg</code></td>
<td>
<p> a character string specifing the clustering
algorithm. Allowed values are &lsquo;kmeans&rsquo; and &lsquo;hclust&rsquo;. </p>
</td></tr>
<tr><td><code id="geostas_+3A_fit">fit</code></td>
<td>
<p> logical, if TRUE coordinate superposition on identified
core atoms is performed prior to the calculation of the AMS
matrix. </p>
</td></tr> 
<tr><td><code id="geostas_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="geostas_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the geostas calculations
are printed to screen. </p>
</td></tr>
<tr><td><code id="geostas_+3A_nma">nma</code></td>
<td>
<p> an &lsquo;nma&rsquo; object as obtained from function
<code><a href="#topic+nma">nma</a></code>. Function <code><a href="#topic+mktrj">mktrj</a></code> is used internally
to generate a trajectory based on the normal modes. </p>
</td></tr>
<tr><td><code id="geostas_+3A_m.inds">m.inds</code></td>
<td>
<p> the mode number(s) along which trajectory should be
made (see function <code><a href="#topic+mktrj">mktrj</a></code>). </p>
</td></tr>
<tr><td><code id="geostas_+3A_enma">enma</code></td>
<td>
<p> an &lsquo;enma&rsquo; object as obtained from function
<code><a href="#topic+nma.pdbs">nma.pdbs</a></code>. Function <code><a href="#topic+mktrj">mktrj</a></code> is used internally
to generate a trajectory based on the normal modes. </p>
</td></tr>
<tr><td><code id="geostas_+3A_pdbs">pdbs</code></td>
<td>
<p> a &lsquo;pdbs&rsquo; object as obtained from function
<code><a href="#topic+pdbaln">pdbaln</a></code> or <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="geostas_+3A_pdb">pdb</code></td>
<td>
<p> a &lsquo;pdb&rsquo; object as obtained from function
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="geostas_+3A_inds">inds</code></td>
<td>
<p> a &lsquo;select&rsquo; object as obtained from function
<code><a href="#topic+atom.select">atom.select</a></code> giving the atomic indices at which the
calculation should be based. By default the function will attempt to
locate C-alpha atoms using function <code><a href="#topic+atom.select">atom.select</a></code>. </p>
</td></tr>
<tr><td><code id="geostas_+3A_x">x</code></td>
<td>
<p> a &lsquo;geostas&rsquo; object as obtained from function
<code><a href="#topic+geostas">geostas</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to identify rigid domains in a protein (or
nucleic acid) structure based on an structural ensemble, e.g. obtained
from NMR experiments, molecular dynamics simulations, or normal mode
analysis.
</p>
<p>The algorithm is based on a geometric approach for comparing pairwise
traces of atomic motion and the search for their best superposition
using a quaternion representation of rotation. The result is stored in
a NxN atomic movement similarity matrix (AMSM) describing the
correspondence between all pairs of atom motion. Rigid domains are
obtained by clustering the elements of the AMS matrix
(<code>pairwise=TRUE</code>), or alternatively, the columns similarity
(<code>pairwise=FALSE</code>), using either K-means (<code><a href="stats.html#topic+kmeans">kmeans</a></code>)
or hierarchical (<code><a href="stats.html#topic+hclust">hclust</a></code>) clustering.
</p>
<p>Compared to the conventional cross-correlation matrix (see function
<code><a href="#topic+dccm">dccm</a></code>) the &ldquo;geostas&rdquo; approach provide
functionality to also detect domains involved in rotational
motions (i.e. two  atoms located on opposite sides of a rotating
domain will appear as anti-correlated in the cross-correlation matrix,
but should obtain a high similarity coefficient in the AMS matrix).
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a list object of type &lsquo;geostas&rsquo; with the following components:
</p>
<table>
<tr><td><code>amsm</code></td>
<td>
<p> a numeric matrix of atomic movement similarity (AMSM). </p>
</td></tr>
<tr><td><code>fit.inds</code></td>
<td>
<p> a numeric vector of xyz indices used for fitting. </p>
</td></tr>
<tr><td><code>grps</code></td>
<td>
<p> a numeric vector containing the domain assignment per
residue. </p>
</td></tr>
<tr><td><code>atomgrps</code></td>
<td>
<p> a numeric vector containing the domain assignment per
atom (only provided for <code>geostas.pdb</code>). </p>
</td></tr>
<tr><td><code>inds</code></td>
<td>
<p> a list of atom &lsquo;select&rsquo; objects with indices to
corresponding to the identified domains. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The current implementation in Bio3D uses a different fitting and
clustering approach than the original Java implementation. The results
will therefore differ.
</p>


<h3>Author(s)</h3>

<p> Julia Romanowska and Lars Skjaerven </p>


<h3>References</h3>

<p>Romanowska, J. et al. (2012) <em>JCTC</em> <b>8</b>, 2588&ndash;2599.
Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.geostas">plot.geostas</a></code>, 
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+mktrj">mktrj</a></code>,
<code><a href="#topic+read.ncdf">read.ncdf</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>,
<code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+dccm">dccm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

#### NMR-ensemble example
## Read a multi-model PDB file 
pdb &lt;- read.pdb("1d1d", multi=TRUE)

## Find domains and write PDB
gs  &lt;- geostas(pdb, fit=TRUE)

## Plot a atomic movement similarity matrix
plot.geostas(gs, contour=FALSE)

## Fit all frames to the 'first' domain
domain.inds &lt;- gs$inds[[1]]

xyz &lt;- pdbfit(pdb, inds=domain.inds)

#write.pdb(pdb, xyz=xyz, chain=gs$atomgrps)



## Not run: 
#### NMA example
## Fetch stucture
pdb &lt;- read.pdb("1crn")

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Find domains
gs &lt;- geostas(modes, k=2)

## Write NMA trajectory with domain assignment
mktrj(modes, mode=7, chain=gs$grps)

## Redo geostas domain clustering 
gs &lt;- geostas(modes, amsm=gs$amsm, k=5)




#### Trajectory example
## Read inn DCD trajectory file, fit coordinates
dcdfile &lt;- system.file("examples/hivp.dcd", package = "bio3d")
trj &lt;- read.dcd(dcdfile)
xyz &lt;- fit.xyz(trj[1,], trj)

## Find domains
gs &lt;- geostas(xyz, k=3, fit=FALSE)

## Principal component analysis 
pc.md &lt;- pca.xyz(xyz)

## Visualize PCs with colored domains (chain ID)
mktrj(pc.md, pc=1, chain=gs$grps)




#### X-ray ensemble GroEL subunits
# Define the ensemble PDB-ids
ids &lt;- c("1sx4_[A,B,H,I]", "1xck_[A-B]", "1sx3_[A-B]", "4ab3_[A-B]")

# Download and split PDBs by chain ID
raw.files &lt;- get.pdb(ids, path = "raw_pdbs", gzip = TRUE)
files &lt;- pdbsplit(raw.files, ids, path = "raw_pdbs/split_chain/")

# Align structures
pdbs &lt;- pdbaln(files)

# Find domains
gs &lt;- geostas(pdbs, k=4, fit=TRUE)

# Superimpose to core region
pdbs$xyz &lt;- pdbfit(pdbs, inds=gs$fit.inds)

# Principal component analysis 
pc.xray &lt;- pca(pdbs)

# Visualize PCs with colored domains (chain ID)
mktrj(pc.xray, pc=1, chain=gs$grps)


##- Same, but more manual approach 
gaps.pos &lt;- gap.inspect(pdbs$xyz)

# Find core region
core &lt;- core.find(pdbs)

# Fit to core region
xyz &lt;- fit.xyz(pdbs$xyz[1, gaps.pos$f.inds],
               pdbs$xyz[, gaps.pos$f.inds],
               fixed.inds=core$xyz,
               mobile.inds=core$xyz)

# Find domains
gs &lt;- geostas(xyz, k=4, fit=FALSE)

# Perform PCA
pc.xray &lt;- pca.xyz(xyz)

# Make trajectory
mktrj(pc.xray, pc=1, chain=gs$grps)


## End(Not run)
</code></pre>

<hr>
<h2 id='get.pdb'> Download PDB Coordinate Files </h2><span id='topic+get.pdb'></span>

<h3>Description</h3>

<p>Downloads PDB coordinate files from the RCSB Protein Data Bank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pdb(ids, path = ".", URLonly=FALSE, overwrite = FALSE, gzip = FALSE, 
     split = FALSE, format = "pdb", verbose = TRUE, ncore = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pdb_+3A_ids">ids</code></td>
<td>
<p> A character vector of one or more 4-letter PDB
codes/identifiers or 6-letter PDB-ID_Chain-ID of the files to be downloaded, or a &lsquo;blast&rsquo;
object containing &lsquo;pdb.id&rsquo;. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_path">path</code></td>
<td>
<p> The destination path/directory where files are to be
written. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_urlonly">URLonly</code></td>
<td>
<p> logical, if TRUE a character vector containing the URL
path to the online file is returned and files are not downloaded. If
FALSE the files are downloaded. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_overwrite">overwrite</code></td>
<td>
<p> logical, if FALSE the file will not be downloaded if
it alread exist. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_gzip">gzip</code></td>
<td>
<p> logical, if TRUE the gzipped PDB will be downloaded and
extracted locally. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_split">split</code></td>
<td>
<p> logical, if TRUE <code><a href="#topic+pdbsplit">pdbsplit</a></code> funciton will be called to split pdb files
into separated chains. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_format">format</code></td>
<td>
<p> format of the data file: &lsquo;pdb&rsquo; or
&lsquo;cif&rsquo; for PDB and mmCIF file formats, respectively. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_verbose">verbose</code></td>
<td>
<p> print details of the reading process. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="get.pdb_+3A_...">...</code></td>
<td>
<p> extra arguments passed to <code><a href="#topic+pdbsplit">pdbsplit</a></code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic function to automate file download from the PDB.
</p>


<h3>Value</h3>

<p>Returns a list of successfully downloaded files. Or optionally if URLonly
is TRUE a list of URLs for said files.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+pdbsplit">pdbsplit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

## PDB file paths
get.pdb( c("1poo", "1moo"), URLonly=TRUE )

## These URLs can be used by 'read.pdb'
pdb &lt;- read.pdb( get.pdb("5p21", URL=TRUE) )
summary(pdb)

## Download PDB file
## get.pdb("5p21")

</code></pre>

<hr>
<h2 id='get.seq'> Download FASTA Sequence Files </h2><span id='topic+get.seq'></span>

<h3>Description</h3>

<p>Downloads FASTA sequence files from the NCBI nr, SWISSPROT/UNIPROT,
OR RCSB PDB databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.seq(ids, outfile = "seqs.fasta", db = "nr", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.seq_+3A_ids">ids</code></td>
<td>
<p> A character vector of one or more appropriate database
codes/identifiers of the files to be downloaded. </p>
</td></tr>
<tr><td><code id="get.seq_+3A_outfile">outfile</code></td>
<td>
<p> A single element character vector specifying the name
of the local file to which sequences will be written. </p>
</td></tr>
<tr><td><code id="get.seq_+3A_db">db</code></td>
<td>
<p> A single element character vector specifying the database
from which sequences are to be obtained. </p>
</td></tr>
<tr><td><code id="get.seq_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE URL details of the download process
are printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic function to automate sequence file download from the 
databases including NCBI nr, SWISSPROT/UNIPROT, and RCSB PDB.
</p>


<h3>Value</h3>

<p>If all files are successfully downloaded a list object with two
components is returned:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p> sequence names as identifiers.</p>
</td></tr>
</table>
<p>This is similar to that returned by <code><a href="#topic+read.fasta">read.fasta</a></code>. However,
if some files were not successfully downloaded then a vector detailing
which ids were not found is returned.
</p>


<h3>Note</h3>

  
<p>For a description of FASTA format see:
<a href="https://www.ncbi.nlm.nih.gov/BLAST/blastcgihelp.shtml">https://www.ncbi.nlm.nih.gov/BLAST/blastcgihelp.shtml</a>.
When reading alignment files, the dash &lsquo;-&rsquo; is interpreted as
the gap character.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+blast.pdb">blast.pdb</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+get.pdb">get.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Sequence identifiers (GI or PDB codes e.g. from blast.pdb etc.)
get.seq( c("P01112", "Q61411", "P20171") )

#aa &lt;-get.seq( c("4q21", "5p21") )
#aa$id
#aa$ali

## End(Not run)
</code></pre>

<hr>
<h2 id='gnm'>Gaussian Network Model</h2><span id='topic+gnm'></span><span id='topic+gnm.pdb'></span><span id='topic+gnm.pdbs'></span>

<h3>Description</h3>

<p>Perform Gaussian network model (GNM) based normal mode analysis (NMA) for 
a protein structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnm(x, ...)

## S3 method for class 'pdb'
gnm(x, inds = NULL, temp = 300, keep = NULL,
  outmodes = NULL, gamma = 1, cutoff = 8, check.connect = TRUE, ...)

## S3 method for class 'pdbs'
gnm(x, fit = TRUE, full = FALSE, subspace = NULL,
  rm.gaps = TRUE, gc.first = TRUE, ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnm_+3A_x">x</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from function <code><a href="#topic+read.pdb">read.pdb</a></code>.</p>
</td></tr>
<tr><td><code id="gnm_+3A_...">...</code></td>
<td>
<p>(in <code>gnm.pdbs</code>) additional arguments passed to <code>gnm.pdb</code>.</p>
</td></tr>
<tr><td><code id="gnm_+3A_inds">inds</code></td>
<td>
<p>atom and xyz coordinate indices obtained from <code><a href="#topic+atom.select">atom.select</a></code> that 
selects the elements of <code>pdb</code> upon which the calculation should be based. 
If not provided the function will attempt to select all calpha atoms automatically.</p>
</td></tr>
<tr><td><code id="gnm_+3A_temp">temp</code></td>
<td>
<p>numerical, temperature for which the amplitudes for scaling the atomic 
displacement vectors are calculated. Set &lsquo;temp=NULL&rsquo; to avoid scaling.</p>
</td></tr>
<tr><td><code id="gnm_+3A_keep">keep</code></td>
<td>
<p>numerical, final number of modes to be stored. Note that all subsequent analyses 
are limited to this subset of modes. This option is useful for very large structures and 
cases where memory may be limited.</p>
</td></tr>
<tr><td><code id="gnm_+3A_outmodes">outmodes</code></td>
<td>
<p>atom indices as obtained from <code><a href="#topic+atom.select">atom.select</a></code> specifying the atoms 
to include in the resulting mode object.</p>
</td></tr>
<tr><td><code id="gnm_+3A_gamma">gamma</code></td>
<td>
<p>numerical, global scale of the force constant.</p>
</td></tr>
<tr><td><code id="gnm_+3A_cutoff">cutoff</code></td>
<td>
<p>numerical, distance cutoff for pair-wise interactions.</p>
</td></tr>
<tr><td><code id="gnm_+3A_check.connect">check.connect</code></td>
<td>
<p>logical, if TRUE check chain connectivity.</p>
</td></tr>
<tr><td><code id="gnm_+3A_fit">fit</code></td>
<td>
<p>logical, if TRUE C-alpha coordinate based superposition is 
performed prior to normal mode calculations.</p>
</td></tr>
<tr><td><code id="gnm_+3A_full">full</code></td>
<td>
<p>logical, if TRUE return the complete, full structure,
&lsquo;nma&rsquo; objects.</p>
</td></tr>
<tr><td><code id="gnm_+3A_subspace">subspace</code></td>
<td>
<p>number of eigenvectors to store for further analysis.</p>
</td></tr>
<tr><td><code id="gnm_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p>logical, if TRUE obtain the hessian matrices for only
atoms in the aligned positions (non-gap positions in all aligned
structures). Thus, gap positions are removed from output.</p>
</td></tr>
<tr><td><code id="gnm_+3A_gc.first">gc.first</code></td>
<td>
<p>logical, if TRUE will call gc() first before mode calculation
for each structure. This is to avoid memory overload when 
<code>ncore &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="gnm_+3A_ncore">ncore</code></td>
<td>
<p>number of CPU cores used to do the calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds a Gaussian network model (an isotropic elastic network 
model) for C-alpha atoms and performs subsequent normal mode analysis (NMA). 
The model employs a distance cutoff for the network construction: Atom pairs with 
distance falling  within the cutoff have a harmonic interaction with a uniform force constant; 
Otherwise atoms have no interaction. Output contains N-1 (N, the number of residues) 
non-trivial modes (i.e. the degree of freedom is N-1), which can then be used to 
calculate atomic fluctuations and covariance.
</p>


<h3>Value</h3>

<p>Returns an object of class &lsquo;gnm&rsquo; with the following components:
</p>
<table>
<tr><td><code>force.constants</code></td>
<td>
<p> numeric vector containing the force constants corresponding 
to each mode. </p>
</td></tr>
<tr><td><code>fluctuations</code></td>
<td>
<p> numeric vector of atomic fluctuations. </p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p> numeric matrix with columns containing the raw eigenvectors. </p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> numeric vector containing the raw eigenvalues. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> numeric matrix of class <code>xyz</code> containing the Cartesian coordinates 
in which the calculation was performed. </p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p> numerical, temperature for which the amplitudes for scaling the atomic 
displacement vectors are calculated. </p>
</td></tr>
<tr><td><code>triv.modes</code></td>
<td>
<p> number of trivial modes. </p>
</td></tr>
<tr><td><code>natoms</code></td>
<td>
<p> number of C-alpha atoms. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao &amp; Lars Skjaerven
</p>


<h3>References</h3>

<p>Bahar, I. et al. (1997) <em>Folding Des.</em> <b>2</b>, 173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm.pdbs">gnm.pdbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Fetch stucture
   pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
   
   ## Calculate normal modes
   modes &lt;- gnm(pdb)
   
   ## Print modes
   print(modes)
   
   ## Plot modes
   plot(modes)

</code></pre>

<hr>
<h2 id='hclustplot'> Dendrogram with Clustering Annotation </h2><span id='topic+hclustplot'></span>

<h3>Description</h3>

<p>Draw a standard dendrogram with clustering annotation in the marginal
regions and colored labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclustplot(hc, k = NULL, h = NULL, colors = NULL, labels = NULL,
             fillbox = FALSE, heights = c(1, .3), mar = c(1, 1, 0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclustplot_+3A_hc">hc</code></td>
<td>
<p> an object of the type produced by <code>hclust</code>. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_k">k</code></td>
<td>
<p> an integer scalar or vector with the desired number of
groups. Redirected to function <code>cutree</code>. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_h">h</code></td>
<td>
<p> numeric scalar or vector with heights where the tree should
be cut. Redirected to function <code>cutree</code>. At least one of &lsquo;k&rsquo;
or &lsquo;h&rsquo; must be specified. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_colors">colors</code></td>
<td>
<p> a numerical or character vector with the same length as
&lsquo;hc&rsquo; specifying the colors of the labels. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_labels">labels</code></td>
<td>
<p> a character vector with the same length as
&lsquo;hc&rsquo; containing the labels to be written. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_fillbox">fillbox</code></td>
<td>
<p> logical, if TRUE clustering annotation will be drawn
as filled boxes below the dendrogram. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_heights">heights</code></td>
<td>
<p> numeric vector of length two specifying the values for
the heights of rows on the device. See function <code>layout</code>. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_mar">mar</code></td>
<td>
<p> a numerical vector of the form &lsquo;c(bottom, left, top, right)&rsquo;
which gives the number of lines of margin to be specified on
the four sides of the plot. If left at default the margins will be
adjusted upon adding arguments &lsquo;main&rsquo;, &lsquo;ylab&rsquo;, etc. </p>
</td></tr>
<tr><td><code id="hclustplot_+3A_...">...</code></td>
<td>
<p> other graphical parameters passed to functions
<code>plot.dendrogram</code>, <code>mtext</code>, and <code>par</code>. Note that
certain arguments will be ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds extended visualization of cluster membership to a
standard dendrogram. If &lsquo;k&rsquo; or &lsquo;h&rsquo; is provided a call to
<code>cutree</code> will provide cluster membership
information. Alternatively a vector of colors or cluster membership
information can be provided through argument &lsquo;colors&rsquo;.
</p>
<p>See examples for further details on usage.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>Argument &lsquo;horiz=TRUE&rsquo; currently not supported.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.hclust">plot.hclust</a></code>, <code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redundant testing excluded

attach(transducin)

##- perform RMSD clustering
rd &lt;- rmsd(pdbs, fit=TRUE)
hc &lt;- hclust(as.dist(rd))

##- draw dendrogram 
hclustplot(hc, k=3)

##- draw dendrogram with manual clustering annotation
#hclustplot(hc, colors=annotation[, "color"], labels=pdbs$id)

detach(transducin)


</code></pre>

<hr>
<h2 id='hmmer'> HMMER Sequence Search </h2><span id='topic+hmmer'></span>

<h3>Description</h3>

<p>Perform a HMMER search against the PDB, NR, swissprot or other sequence
and structure databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmer(seq, type="phmmer", db = NULL, verbose = TRUE, timeout = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmmer_+3A_seq">seq</code></td>
<td>
<p> a multi-element character vector containing the query
sequence. Alternatively a &lsquo;fasta&rsquo; object as obtained
from functions <code>get.seq</code> or <code>read.fasta</code> can be
provided. </p>
</td></tr>
<tr><td><code id="hmmer_+3A_type">type</code></td>
<td>
<p> character string specifying the &lsquo;HMMER&rsquo; job
type. Current options are &lsquo;phmmer&rsquo;, &lsquo;hmmscan&rsquo;,
&lsquo;hmmsearch&rsquo;, and &lsquo;jackhmmer&rsquo;. </p>
</td></tr>
<tr><td><code id="hmmer_+3A_db">db</code></td>
<td>
<p> character string specifying the database to search.
Current options are &lsquo;pdb&rsquo;, &lsquo;nr&rsquo;, &lsquo;swissprot&rsquo;,
&lsquo;pfam&rsquo;, etc. See &lsquo;details&rsquo; for a complete list. </p>
</td></tr>
<tr><td><code id="hmmer_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the download process
is printed. </p>
</td></tr>
<tr><td><code id="hmmer_+3A_timeout">timeout</code></td>
<td>
<p> integer specifying the number of seconds to wait for
the blast reply before a time out occurs. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function employs direct HTTP-encoded requests to the HMMER web
server. HMMER can be used to search sequence databases for homologous
protein sequences. The HMMER server implements methods using
probabilistic models called profile hidden Markov models (profile
HMMs).
</p>
<p>There are currently four types of HMMER search to perform:
</p>
<p>- &lsquo;phmmer&rsquo;: protein sequence vs protein sequence database.<br />
(input argument <code>seq</code> must be a sequence). 
</p>
<p>Allowed options for <code>type</code> includes: 
&lsquo;env_nr&rsquo;, &lsquo;nr&rsquo;, &lsquo;refseq&rsquo;, &lsquo;pdb&rsquo;,
&lsquo;rp15&rsquo;, &lsquo;rp35&rsquo;, &lsquo;rp55&rsquo;, &lsquo;rp75&rsquo;,
&lsquo;swissprot&rsquo;, &lsquo;unimes&rsquo;, &lsquo;uniprotkb&rsquo;,
&lsquo;uniprotrefprot&rsquo;, &lsquo;pfamseq&rsquo;. 
</p>
<p>- &lsquo;hmmscan&rsquo;: protein sequence vs profile-HMM database.<br />
(input argument <code>seq</code> must be a sequence). 
</p>
<p>Allowed options for <code>type</code> includes:
&lsquo;pfam&rsquo;, &lsquo;gene3d&rsquo;,  &lsquo;superfamily&rsquo;, &lsquo;tigrfam&rsquo;.
</p>
<p>- &lsquo;hmmsearch&rsquo;: protein alignment/profile-HMM vs protein sequence
database.<br />
(input argument <code>seq</code> must be an alignment). 
</p>
<p>Allowed options for <code>type</code> includes:
&lsquo;pdb&rsquo;, &lsquo;swissprot&rsquo;.
</p>
<p>- &lsquo;jackhmmer&rsquo;: iterative search vs protein sequence database.<br />
(input argument <code>seq</code> must be an alignment).
&lsquo;jackhmmer&rsquo; functionality incomplete!!
</p>
<p>Allowed options for <code>type</code> includes:
&lsquo;env_nr&rsquo;, &lsquo;nr&rsquo;, &lsquo;refseq&rsquo;, &lsquo;pdb&rsquo;,
&lsquo;rp15&rsquo;, &lsquo;rp35&rsquo;, &lsquo;rp55&rsquo;, &lsquo;rp75&rsquo;,
&lsquo;swissprot&rsquo;, &lsquo;unimes&rsquo;, &lsquo;uniprotkb&rsquo;,
&lsquo;uniprotrefprot&rsquo;, &lsquo;pfamseq&rsquo;. 
</p>
<p>More information can be found at the HMMER website:<br />
<a href="http://hmmer.org">http://hmmer.org</a>
</p>


<h3>Value</h3>

<p>A list object with components &lsquo;hit.tbl&rsquo; and
&lsquo;url&rsquo;. &lsquo;hit.tbl&rsquo; is a data frame with multiple
components depending on the selected job &lsquo;type&rsquo;. Frequently
reported fields include: 
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p> a character vector containing the name of the target. </p>
</td></tr>
<tr><td><code>acc</code></td>
<td>
<p> a character vector containing the accession identifier of
the target. </p>
</td></tr>
<tr><td><code>acc2</code></td>
<td>
<p> a character vector containing secondary accession of the
target. </p>
</td></tr>
<tr><td><code>pdb.id</code></td>
<td>
<p> same as &lsquo;acc&rsquo;. </p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p> a character vector containing Identifier of the target </p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p> a character vector containing entry description. </p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p> a numeric vector containing bit score of the sequence (all
domains, without correction). </p>
</td></tr>
<tr><td><code>bitscore</code></td>
<td>
<p> same as &lsquo;score&rsquo;. </p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p> a numeric vector containing the P-value of the score. </p>
</td></tr>
<tr><td><code>evalue</code></td>
<td>
<p> a numeric vector containing the E-value of the score. </p>
</td></tr>
<tr><td><code>mlog.evalue</code></td>
<td>
<p> a numeric vector containing minus the natural log
of the E-value. </p>
</td></tr>
<tr><td><code>nregions</code></td>
<td>
<p> a numeric vector containing Number of regions
evaluated. </p>
</td></tr> 
<tr><td><code>nenvelopes</code></td>
<td>
<p> a numeric vector containing the number of envelopes
handed over for domain definition, null2, alignment, and scoring. </p>
</td></tr>
<tr><td><code>ndom</code></td>
<td>
<p> a numeric vector containing the total number of domains
identified in this sequence. </p>
</td></tr> 
<tr><td><code>nreported</code></td>
<td>
<p> a numeric vector containing the number of domains
satisfying reporting thresholding. </p>
</td></tr> 
<tr><td><code>nincluded</code></td>
<td>
<p> a numeric vector containing the number of domains
satisfying inclusion thresholding. </p>
</td></tr> 
<tr><td><code>taxid</code></td>
<td>
<p> a character vector containing The NCBI taxonomy identifier
of the target (if applicable). </p>
</td></tr> 
<tr><td><code>species</code></td>
<td>
<p> a character vector containing the species name. </p>
</td></tr>
<tr><td><code>kg</code></td>
<td>
<p> a character vector containing the kingdom of life that the
target belongs to - based on placing in the NCBI taxonomy tree. </p>
</td></tr>
</table>
<p>More details can be found at the HMMER website:<br />
<a href="https://www.ebi.ac.uk/Tools/hmmer/help/api">https://www.ebi.ac.uk/Tools/hmmer/help/api</a>
</p>


<h3>Note</h3>

<p>Note that the chained &lsquo;pdbs&rsquo; HMMER field (used for redundant
PDBs) is included directly into the result list (applies only when
<code>db='pdb'</code>). In this case, the &lsquo;name&rsquo; component of the
target contains the parent (non redundant) entry, and the &lsquo;acc&rsquo;
component the chained PDB identifiers. The search results will therefore
provide duplicated PDB identifiers for component <code>$name</code>, while
<code>$acc</code> should be unique. 
</p>


<h3>Note</h3>

<p>Online access is required to query HMMER services.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Finn, R.D. et al. (2011) <em>Nucl. Acids Res.</em> <b>39</b>, 29&ndash;37.
Eddy, S.R. (2011) <em>PLoS Comput Biol</em> <b>7</b>(10): e1002195.
</p>
<p>See also the &lsquo;HMMER&rsquo; website:<br />
<a href="http://hmmer.org">http://hmmer.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blast.pdb">blast.pdb</a></code>, <code><a href="#topic+plot.blast">plot.blast</a></code>, 
<code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+get.seq">get.seq</a></code>,
<code><a href="#topic+pfam">pfam</a></code>, <code><a href="#topic+uniprot">uniprot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# HMMER server connection required - testing excluded

##- PHMMER
seq &lt;- get.seq("2abl_A", outfile=tempfile())
res &lt;- hmmer(seq, db="pdb")

##- HMMSCAN
fam &lt;- hmmer(seq, type="hmmscan", db="pfam")
pfam.aln &lt;- pfam(fam$hit.tbl$acc[1])

##- HMMSEARCH
hmm &lt;- hmmer(pfam.aln, type="hmmsearch", db="pdb")
unique(hmm$hit.tbl$species)
hmm$hit.tbl$acc


## End(Not run)
</code></pre>

<hr>
<h2 id='identify.cna'> Identify Points in a CNA Protein Structure Network Plot </h2><span id='topic+identify.cna'></span>

<h3>Description</h3>

<p>&lsquo;identify.cna&rsquo; reads the position of the graphics pointer when the
(first) mouse button is pressed.  It then searches the coordinates given
in &lsquo;x&rsquo; for the point closest to the pointer.  If this point is 
close enough to the pointer, its index and community members will be
returned as part of the value of the call and the community members will 
be added as labels to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'cna'
identify(x, labels=NULL, cna=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.cna_+3A_x">x</code></td>
<td>
<p> A numeric matrix with Nx2 dimensions, where N is equal to
the number of objects in a 2D CNA plot such as obtained from the 
&lsquo;plot.cna&rsquo; and various &lsquo;layout&rsquo; functions. </p>
</td></tr>
<tr><td><code id="identify.cna_+3A_labels">labels</code></td>
<td>
<p> An optional character vector giving labels for the points.
Will be coerced using &lsquo;as.character&rsquo;, and recycled if
necessary to the length of &lsquo;x&rsquo;.  Excess labels will be
discarded, with a warning. </p>
</td></tr>
<tr><td><code id="identify.cna_+3A_cna">cna</code></td>
<td>
<p> A network object as returned from the &lsquo;cna&rsquo; function. </p>
</td></tr>
<tr><td><code id="identify.cna_+3A_...">...</code></td>
<td>
<p> Extra options passed to &lsquo;identify&rsquo; function. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function calls the &lsquo;identify&rsquo; and &lsquo;summary.cna&rsquo; functions to 
query and label 2D CNA protein structure network plots produced by the &lsquo;plot.cna&rsquo; function. Clicking with the mouse on plot points will add the corresponding  
labels and them to the plot and returned list object. A click with the right 
mouse button will stop the function.
</p>


<h3>Value</h3>

<p>If &lsquo;labels&rsquo; or &lsquo;cna&rsquo; inputs are provided then a membership vector 
will be returned with the selected community ids and their members. Otherwise a 
vector with the ids of the selected communities will be returned.
</p>


<h3>Author(s)</h3>

<p> Guido Scarabelli and Barry Grant </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cna">plot.cna</a></code>, 
<code><a href="graphics.html#topic+identify">identify</a></code>, 
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>, 
<code><a href="igraph.html#topic+communities">plot.communities</a></code>, 
<code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

attach(hivp)

# Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

# Plot the network
xy &lt;- plot.cna(net)

# Use identify.cna on the communities
d &lt;- identify.cna(xy, cna=net)

# Right click to end the function...
## d &lt;- identify(xy, summary(net)$members)

detach(hivp)

}

## End(Not run)
</code></pre>

<hr>
<h2 id='inner.prod'> Mass-weighted Inner Product </h2><span id='topic+inner.prod'></span>

<h3>Description</h3>

<p>Inner product of vectors (mass-weighted if requested).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner.prod(x, y, mass=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner.prod_+3A_x">x</code></td>
<td>
<p> a numeric vector or matrix. </p>
</td></tr>
<tr><td><code id="inner.prod_+3A_y">y</code></td>
<td>
<p> a numeric vector or matrix. </p>
</td></tr>
<tr><td><code id="inner.prod_+3A_mass">mass</code></td>
<td>
<p> a numeric vector containing the atomic masses for
weighting. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the inner product between two vectors, or
alternatively, the column-wise vector elements of matrices. If atomic
masses are provided, the dot products will be mass-weighted.
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns the inner product(s).
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a> </code>, <code><a href="#topic+normalize.vector">normalize.vector</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Matrix operations
x &lt;- 1:3
y &lt;- diag(x)
z &lt;- matrix(1:9, ncol = 3, nrow = 3)

inner.prod(x,y)
inner.prod(y,z)


## Application to normal modes
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Check for orthogonality 
inner.prod(modes$U[,7], modes$U[,8])

</code></pre>

<hr>
<h2 id='inspect.connectivity'> Check the Connectivity of Protein Structures </h2><span id='topic+inspect.connectivity'></span>

<h3>Description</h3>

<p>Investigate protein coordinates to determine if the structure
has missing residues. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect.connectivity(pdbs, cut=4.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect.connectivity_+3A_pdbs">pdbs</code></td>
<td>
<p> an object of class <code>3daling</code> as obtained from
function <code>pdbaln</code> or <code>read.fasta.pdb</code>; a xyz matrix
containing the cartesian coordinates of C-alpha atoms; or a
&lsquo;pdb&rsquo; object as obtained from function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="inspect.connectivity_+3A_cut">cut</code></td>
<td>
<p> cutoff value to determine residue connectvitiy. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utility function for checking if the PDB structures in a
&lsquo;pdbs&rsquo; object contains missing residues inside the
structure. 
</p>


<h3>Value</h3>

<p>Returns a vector. 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dm">dm</a></code>, <code><a href="#topic+gap.inspect">gap.inspect</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
raw.files &lt;- get.pdb(ids, path = "raw_pdbs")
files &lt;- pdbsplit(raw.files, ids, path = "raw_pdbs/split_chain")

## Sequence Alignement, and connectivity check
pdbs &lt;- pdbaln(files)

cons &lt;- inspect.connectivity(pdbs)

## omit files with missing residues
files = files[cons]

## End(Not run)
</code></pre>

<hr>
<h2 id='is.gap'> Gap Characters </h2><span id='topic+is.gap'></span>

<h3>Description</h3>

<p>Test for the presence of gap characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gap(x, gap.char = c("-", "."))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.gap_+3A_x">x</code></td>
<td>
<p> an R object to be tested. Typically a sequence vector or 
sequence/structure alignment object as returned from <code>seqaln</code>, 
<code>pdbaln</code> etc. </p>
</td></tr>
<tr><td><code id="is.gap_+3A_gap.char">gap.char</code></td>
<td>
<p> a character vector containing the gap character types
to test for. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical vector with the same length as the input vector, or 
the same length as the number of columns present in an alignment input 
object &lsquo;x&rsquo;. In the later case TRUE elements corresponding to 
&lsquo;gap.char&rsquo; matches in any alignment column (i.e. gap containing 
columns).
</p>


<h3>Note</h3>

<p>During alignment, gaps are introduced into sequences that are believed
to have undergone deletions or insertions with respect to other
sequences in the alignment.  These gaps, often referred to as
indels, can be represented with &lsquo;NA&rsquo;, &lsquo;-&rsquo; or
&lsquo;.&rsquo; characters.
</p>
<p>This function provides a simple test for the presence of such
characters, or indeed any set of user defined characters set by
the &lsquo;gap.char&rsquo; argument.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gap.inspect">gap.inspect</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+pdbaln">pdbaln</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.gap( c("G",".","X","-","G","K","S","T") )

## Not run: 
aln &lt;- read.fasta( system.file("examples/kif1a.fa",
                   package = "bio3d") )

##- Print only non-gap positions (i.e. no gaps in any sequence)
aln$ali[, !is.gap(aln) ]

##- Mask any existing gaps with an "X"
xaln &lt;- aln
xaln$ali[ is.gap(xaln$ali) ]="X"

##- Read a new PDB and align its sequence to the existing masked alignment
pdb &lt;- read.pdb( "1mkj" )
seq2aln(pdbseq(pdb), xaln, id = "1mkj")

## End(Not run)
</code></pre>

<hr>
<h2 id='is.mol2'> Is an Object of Class &lsquo;mol2&rsquo;?  </h2><span id='topic+is.mol2'></span>

<h3>Description</h3>

<p>Checks whether its argument is an object of class &lsquo;mol2&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.mol2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mol2_+3A_x">x</code></td>
<td>
<p> an R object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests if the object &lsquo;x&rsquo; is of class &lsquo;mol2&rsquo;
(<code>is.mol2</code>), i.e. if &lsquo;x&rsquo; has a
&ldquo;class&rdquo; attribute equal to <code>mol2</code>.
</p>


<h3>Value</h3>

<p>TRUE if x is an object of class &lsquo;mol2&rsquo; and FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mol2">read.mol2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a PDB file
mol &lt;- read.mol2( system.file("examples/aspirin.mol2", package="bio3d") )
is.mol2(mol)
</code></pre>

<hr>
<h2 id='is.pdb'> Is an Object of Class &lsquo;pdb(s)&rsquo;?  </h2><span id='topic+is.pdb'></span><span id='topic+is.pdbs'></span>

<h3>Description</h3>

<p>Checks whether its argument is an object of class &lsquo;pdb&rsquo; or &lsquo;pdbs&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.pdb(x)
  is.pdbs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pdb_+3A_x">x</code></td>
<td>
<p> an R object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests if the object &lsquo;x&rsquo; is of class &lsquo;pdb&rsquo;
(<code>is.pdb</code>) or &lsquo;pdbs&rsquo; (<code>is.pdbs</code>), i.e. if &lsquo;x&rsquo; has a
&ldquo;class&rdquo; attribute equal to <code>pdb</code> or <code>pdbs</code>.
</p>


<h3>Value</h3>

<p>TRUE if x is an object of class &lsquo;pdb(s)&rsquo; and FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+pdbaln">pdbaln</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
is.pdb(pdb)
</code></pre>

<hr>
<h2 id='is.select'>Is an Object of Class &lsquo;select&rsquo;?</h2><span id='topic+is.select'></span>

<h3>Description</h3>

<p>Checks whether its argument is an object of class &lsquo;select&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.select(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.select_+3A_x">x</code></td>
<td>
<p>an R object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests if x is an object of class &lsquo;select&rsquo;, i.e. if x has a &ldquo;class&rdquo; attribute equal to <code>select</code>.
</p>


<h3>Value</h3>

<p>TRUE if x is an object of class &lsquo;select&rsquo; and FALSE otherwise
</p>


<h3>Author(s)</h3>

<p>Julien Ide
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atom.select">atom.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

# Print structure summary
atom.select(pdb)

# Select all C-alpha atoms with residues numbers between 43 and 54
ca.inds &lt;- atom.select(pdb, "calpha", resno=43:54)
is.select(ca.inds)

</code></pre>

<hr>
<h2 id='is.xyz'> Is an Object of Class &lsquo;xyz&rsquo;?  </h2><span id='topic+is.xyz'></span><span id='topic+as.xyz'></span>

<h3>Description</h3>

<p>Checks whether its argument is an object of class &lsquo;xyz&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.xyz(x)
  as.xyz(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.xyz_+3A_x">x</code></td>
<td>

<p>an R object to be tested
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests if x is an object of class &lsquo;xyz&rsquo;, i.e. if x has a
&ldquo;class&rdquo; attribute equal to <code>xyz</code>. 
</p>


<h3>Value</h3>

<p>TRUE if x is an object of class &lsquo;xyz&rsquo; and FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
is.xyz(pdb$xyz)

</code></pre>

<hr>
<h2 id='layout.cna'> Protein Structure Network Layout </h2><span id='topic+layout.cna'></span>

<h3>Description</h3>

<p>Determine protein structure network layout in 2D and 3D from the geometric 
center of each community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  layout.cna(x, pdb, renumber=TRUE, k=2, full=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.cna_+3A_x">x</code></td>
<td>
<p> A protein structure network object as obtained from the &lsquo;cna&rsquo; 
function. </p>
</td></tr>
<tr><td><code id="layout.cna_+3A_pdb">pdb</code></td>
<td>
<p> A pdb class object as obtained from the &lsquo;read.pdb&rsquo; 
function. </p>
</td></tr>
<tr><td><code id="layout.cna_+3A_renumber">renumber</code></td>
<td>
<p> Logical, if TRUE the input &lsquo;pdb&rsquo; will be re-numbered 
starting at residue number one before community coordinate averages are 
calculated. </p>
</td></tr> 
<tr><td><code id="layout.cna_+3A_k">k</code></td>
<td>
<p> A single element numeric vector between 1 and 3 specifying the 
returned coordinate dimensions. </p>
</td></tr>
<tr><td><code id="layout.cna_+3A_full">full</code></td>
<td>
<p> Logical, if TRUE the full all-Calpha atom network coordinates will 
be returned rather than the default clustered network community coordinates. </p>
</td></tr>       
</table>


<h3>Details</h3>

<p>This function calculates the geometric center for each community from
the atomic position of it's Calpha atoms taken from a corresponding PDB 
file. Care needs to be taken to ensure the PDB residue numbers and the
community vector names/length match.
</p>
<p>The community residue membership are typically taken from the input network 
object but can be supplied as a list object with 'x$communities$membership'.
</p>


<h3>Value</h3>

<p>A numeric matrix of Nxk, where N is the number of communities and k the number of dimensions requested.
</p>


<h3>Author(s)</h3>

<p> Guido Scarabelli and Barry Grant </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cna">plot.cna</a></code>, <code><a href="igraph.html#topic+communities">plot.communities</a></code>,
<code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>, 
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

# Load the correlation network
attach(hivp)

# Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

# Plot will be slow
#xy &lt;- plot.cna(net)
#plot3d.cna(net, pdb)

layout.cna(net, pdb, k=3)
layout.cna(net, pdb)

# can be used as input to plot.cna and plot3d.cna....
# plot.cna( net, layout=layout.cna(net, pdb) )
# plot3d.cna(net, pdb, layout=layout.cna(net, pdb, k=3))

detach(hivp)

}
</code></pre>

<hr>
<h2 id='lbio3d'> List all Functions in the bio3d Package </h2><span id='topic+lbio3d'></span>

<h3>Description</h3>

<p>A simple shortcut for ls(&quot;package:bio3d&quot;). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbio3d()
</code></pre>


<h3>Value</h3>

<p>A character vector of function names from the bio3d package.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>

<hr>
<h2 id='load.enmff'> ENM Force Field Loader </h2><span id='topic+load.enmff'></span><span id='topic+ff.calpha'></span><span id='topic+ff.anm'></span><span id='topic+ff.pfanm'></span><span id='topic+ff.sdenm'></span><span id='topic+ff.reach'></span><span id='topic+ff.aaenm'></span><span id='topic+ff.aaenm2'></span>

<h3>Description</h3>

<p>Load force field for elastic network normal mode calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.enmff(ff = 'calpha')
ff.calpha(r, rmin=2.9, ...)
ff.anm(r, cutoff=15, gamma=1, ...)
ff.pfanm(r, cutoff=NULL, ...)
ff.sdenm(r, atom.id, pdb, ...)
ff.reach(r, atom.id, ...)
ff.aaenm(r, ...)
ff.aaenm2(r, atom.id, pdb, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.enmff_+3A_ff">ff</code></td>
<td>
<p> a character string specifying the force field to use:
&lsquo;calpha&rsquo;, &lsquo;anm&rsquo;, &lsquo;pfanm&rsquo;, 
&lsquo;reach&rsquo;, or  &lsquo;sdenm&rsquo;. </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_r">r</code></td>
<td>
<p> a numeric vector of c-alpha distances. </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_rmin">rmin</code></td>
<td>
<p> lowest allowed atom-atom distance for the force constant
calculation. The default of 2.9A is based on an evaluation of 24
high-resolution X-ray structures (&lt; 1A). </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_cutoff">cutoff</code></td>
<td>
<p> numerical, cutoff for pair-wise interactions. </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_gamma">gamma</code></td>
<td>
<p> numerical, global scaling factor. </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_atom.id">atom.id</code></td>
<td>
<p> atomic index. </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_pdb">pdb</code></td>
<td>
<p> a <code>pdb</code> object as obtained from function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="load.enmff_+3A_...">...</code></td>
<td>
<p> additional arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a collection of elastic network model (ENM)
force fields for normal modes analysis (NMA) of protein structures. It
returns a function for calculating the residue-residue spring force
constants.
</p>
<p>The &lsquo;calpha&rsquo; force field - originally developed by Konrad
Hinsen - is the recommended one for most applications. It employs a
spring force constant differentiating between nearest-neighbour pairs
along the backbone and all other pairs. The force constant function
was parameterized by fitting to a local minimum of a crambin model
using the AMBER94 force field.
</p>
<p>The implementation of the &lsquo;ANM&rsquo; (Anisotropic Network Model)
force field originates from the lab of Ivet Bahar. It uses a
simplified (step function) spring force constant based on the
pair-wise distance. A variant of this from the Jernigan lab is the
so-called &lsquo;pfANM&rsquo; (parameter free ANM) with interactions that
fall off with the square of the distance.
</p>
<p>The &lsquo;sdENM&rsquo; (by Dehouck and Mikhailov) employs residue specific
spring force constants. It has been parameterized through a
statistical analysis of a total of 1500 NMR ensembles.
</p>
<p>The &lsquo;REACH&rsquo; force field (by Moritsugu and Smith) is
parameterized based on variance-covariance matrices obtained from MD
simulations. It employs force constants that fall off exponentially
with distance for non-bonded pairs.
</p>
<p>The all-atom ENM force fields (&lsquo;aaenm&rsquo; and &lsquo;aaenm2&rsquo;) was
obtained by fitting to a local energy minimum of a crambin model
derived from the AMBER99SB force field (same approach as in Hinsen et
al 2000). It employs a pair force constant function which falls as
r^-6. &lsquo;aanma2&rsquo; employs additonally specific force constants for
covalent and intra-residue atom pairs. See also <code><a href="#topic+aanma">aanma</a></code>
for more details.
</p>
<p>See references for more details on the individual force fields.
</p>


<h3>Value</h3>

<p>&lsquo;load.enmff&rsquo; returns a function for calculating the spring 
force constants. The &lsquo;ff&rsquo; functions returns a numeric vector of
residue-residue spring force constants. 
</p>


<h3>Note</h3>

<p>The arguments &lsquo;atom.id&rsquo; and &lsquo;pdb&rsquo; are used
from within function &lsquo;build.hessian&rsquo; for functions that are not
simply a function of the pair-wise distance. e.g. the force constants
in the &lsquo;sdENM&rsquo; model computes the force constants based on a
function of the residue types and calpha distance. 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Hinsen, K. et al. (2000) <em>Chemical Physics</em> <b>261</b>, 25&ndash;37.
Atilgan, A.R. et al. (2001) <em>Biophysical Journal</em> <b>80</b>, 505&ndash;515.
Dehouck Y. &amp; Mikhailov A.S. (2013) <em>PLoS Comput Biol</em> <b>9</b>:e1003209.
Moritsugu K. &amp; Smith J.C. (2008) <em>Biophysical Journal</em> <b>95</b>, 1639&ndash;1648.
Yang, L. et al. (2009) <em>PNAS</em> <b>104</b>, 12347-52.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+build.hessian">build.hessian</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the c-alpha force field
pfc.fun &lt;- load.enmff('calpha')

## Calculate the pair force constant for a set of C-alpha distances
force.constants &lt;- pfc.fun( seq(4,8, by=0.5) )

## Calculate the complete spring force constant matrix
## Fetch PDB
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Fetch only c-alpha coordinates
ca.inds &lt;- atom.select(pdb, 'calpha')
xyz &lt;- pdb$xyz[ca.inds$xyz]

## Calculate distance matrix
dists &lt;- dm.xyz(xyz, mask.lower=FALSE)

## all pair-wise spring force constants
fc.matrix &lt;- apply(dists, 1, pfc.fun)
</code></pre>

<hr>
<h2 id='mask'> Mask a Subset of Atoms in a DCCM Object. </h2><span id='topic+mask'></span><span id='topic+mask.dccm'></span>

<h3>Description</h3>

<p>Produce a new DCCM object with selected atoms masked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask(...)

## S3 method for class 'dccm'
mask(dccm, pdb = NULL, a.inds = NULL, b.inds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_+3A_dccm">dccm</code></td>
<td>
<p> a DCCM structure object obtained from function
<code><a href="#topic+dccm">dccm</a></code>. </p>
</td></tr>
<tr><td><code id="mask_+3A_pdb">pdb</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. Must match the dimensions of <code>dccm</code>. </p>
</td></tr>
<tr><td><code id="mask_+3A_a.inds">a.inds</code></td>
<td>
<p> a numeric vector containing the indices of the elements
of the DCCM matrix in which should not be masked. Alternatively, if
<code>pdb</code> is provided a selection object (as
obtained from <code><a href="#topic+atom.select">atom.select</a></code>) can be provided. </p>
</td></tr>
<tr><td><code id="mask_+3A_b.inds">b.inds</code></td>
<td>
<p> a numeric vector containing the indices of the elements
of the DCCM matrix in which should not be masked. </p>
</td></tr>
<tr><td><code id="mask_+3A_...">...</code></td>
<td>
<p> arguments not passed anywhere. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic utility function for masking a DCCM object matrix to
highlight user-selected regions in the correlation network.
</p>
<p>When both <code>a.inds</code> and <code>b.inds</code> are provided only their
intersection is retained. When only <code>a.inds</code> is provided then
the corresponding region to everything else is retained.
</p>
<p>Note: The current version assumes that the input PDB corresponds to
the input DCCM. In many cases this will correspond to a PDB
object containing only CA atoms.
</p>


<h3>Value</h3>

<p>Returns a matrix list of class <code>"dccm"</code> with the indices/atoms
not corresponding to the selection masked.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dccm">dccm</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate DCCM
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
cij &lt;- dccm(nma(pdb))

## Mask DCCM matrix according to matrix indices
cijm &lt;- mask(cij, a.inds=40:50, b.inds=80:90)
plot(cijm)

## Retain only 40:50 to everything else
cijm &lt;- mask(cij, a.inds=40:50)
plot(cijm)


## Mask DCCM matrix according PDB selection
pdb.ca &lt;- trim(pdb, "calpha")
a.inds &lt;- atom.select(pdb.ca, resno=40:50)
b.inds &lt;- atom.select(pdb.ca, resno=80:90)

# Provide pdb object correspoding to input dccm
cijm &lt;- mask(cij, pdb.ca, a.inds, b.inds)
plot(cijm)
</code></pre>

<hr>
<h2 id='mktrj'> PCA / NMA Atomic Displacement Trajectory </h2><span id='topic+mktrj'></span><span id='topic+mktrj.pca'></span><span id='topic+mktrj.nma'></span><span id='topic+mktrj.enma'></span>

<h3>Description</h3>

<p>Make a trajectory of atomic displacments along a given principal
component / normal mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mktrj(...)

## S3 method for class 'pca'
mktrj(pca = NULL, pc = 1, mag = 1, step = 0.125, file =
NULL, pdb = NULL, rock=TRUE, ...)

## S3 method for class 'nma'
mktrj(nma = NULL, mode = 7, mag = 10, step = 1.25, file = NULL, 
      pdb = NULL, rock=TRUE,  ...)

## S3 method for class 'enma'
mktrj(enma = NULL, pdbs = NULL, s.inds = NULL, m.inds = NULL,
      mag = 10, step = 1.25, file = NULL, rock = TRUE, ncore = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mktrj_+3A_pca">pca</code></td>
<td>
<p> an object of class <code>"pca"</code> as obtained with
function <code><a href="#topic+pca.xyz">pca.xyz</a></code> or <code><a href="#topic+pca">pca</a></code>.</p>
</td></tr>
<tr><td><code id="mktrj_+3A_nma">nma</code></td>
<td>
<p> an object of class <code>"nma"</code> as obtained with
function <code><a href="#topic+nma.pdb">nma.pdb</a></code>.</p>
</td></tr>
<tr><td><code id="mktrj_+3A_enma">enma</code></td>
<td>
<p> an object of class <code>"enma"</code> as obtained with
function <code><a href="#topic+nma.pdbs">nma.pdbs</a></code>.</p>
</td></tr>
<tr><td><code id="mktrj_+3A_pc">pc</code></td>
<td>
<p> the PC number along which displacements should be made.</p>
</td></tr>
<tr><td><code id="mktrj_+3A_mag">mag</code></td>
<td>
<p> a magnification factor for scaling the displacements. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_step">step</code></td>
<td>
<p> the step size by which to increment along the pc/mode. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_file">file</code></td>
<td>
<p> a character vector giving the output PDB file name. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_pdb">pdb</code></td>
<td>
<p> an object of class <code>"pdb"</code> as obtained from 
<code><a href="#topic+read.pdb">read.pdb</a></code> or class <code>"pdbs"</code> as obtained from
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>. If not NULL, used as reference to write
the PDB file. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_rock">rock</code></td>
<td>
<p> logical, if TRUE the trajectory rocks. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_mode">mode</code></td>
<td>
<p> the mode number along which displacements should be made.</p>
</td></tr>
<tr><td><code id="mktrj_+3A_pdbs">pdbs</code></td>
<td>
<p> a list object of class <code>"pdbs"</code> (obtained with
<code><a href="#topic+pdbaln">pdbaln</a></code> or <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>) which
corresponds to the <code>"enma"</code> object.</p>
</td></tr>
<tr><td><code id="mktrj_+3A_s.inds">s.inds</code></td>
<td>
<p> index or indices pointing to the structure(s) in the
<code>enma</code> object for which the trajectory shall be generated. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_m.inds">m.inds</code></td>
<td>
<p> the mode number(s) along which displacements should be
made. </p>
</td></tr>
<tr><td><code id="mktrj_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="mktrj_+3A_...">...</code></td>
<td>
<p> additional arguments passed to and from functions
(e.g. to function <code><a href="#topic+write.pdb">write.pdb</a></code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trajectory frames are built from reconstructed Cartesian coordinates
produced by interpolating from the mean structure along a given
<code>pc</code> or <code>mode</code>, in increments of <code>step</code>.
</p>
<p>An optional magnification factor can be used to amplify
displacements.  This involves scaling by <code>mag</code>-times the standard
deviation of the conformer distribution along the given <code>pc</code>
(i.e. the square root of the associated eigenvalue).
</p>


<h3>Note</h3>

<p> Molecular graphics software such as VMD or PyMOL is useful
for viewing trajectories see e.g: <br />
<a href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>. </p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+nma">nma</a></code>,
<code><a href="#topic+nma.pdbs">nma.pdbs</a></code>,
<code><a href="#topic+pymol.modes">pymol.modes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##- PCA example
attach(transducin)

# Calculate principal components
pc.xray &lt;- pca(pdbs, fit=TRUE)

# Write PC trajectory of pc=1
outfile = tempfile()
a &lt;- mktrj(pc.xray, file = outfile)
outfile

detach(transducin)


##- NMA example
## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Visualize modes
outfile = file.path(tempdir(), "mode_7.pdb")
mktrj(modes, mode=7, pdb=pdb, file = outfile)
outfile


## End(Not run)
</code></pre>

<hr>
<h2 id='motif.find'> Find Sequence Motifs. </h2><span id='topic+motif.find'></span>

<h3>Description</h3>

<p>Return Position Indices of a Short Sequence Motif Within a Larger Sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>motif.find(motif, sequence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="motif.find_+3A_motif">motif</code></td>
<td>
<p> a character vector of the short sequence motif. </p>
</td></tr>
<tr><td><code id="motif.find_+3A_sequence">sequence</code></td>
<td>
<p> a character vector of the larger sequence. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence and the motif can be given as a either a multiple or
single element character vector. The dot character and other valid
<code>regexpr</code> characters are allowed in the motif, see examples.
</p>


<h3>Value</h3>

<p>Returns a vector of position indices within the sequence where the
motif was found, see examples.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+regexpr">regexpr</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+pdbseq">pdbseq</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

aa.seq &lt;- pdbseq( read.pdb( get.pdb("4q21", URLonly=TRUE) ) )
motif = c("G....GKS")
motif.find(motif, aa.seq)

</code></pre>

<hr>
<h2 id='mustang'> Structure-based Sequence Alignment with MUSTANG </h2><span id='topic+mustang'></span>

<h3>Description</h3>

<p>Create a multiple sequence alignment from a bunch of PDB files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mustang(files, exefile="mustang", outfile="aln.mustang.fa",
        cleanpdb=FALSE, cleandir="mustangpdbs", verbose=TRUE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mustang_+3A_files">files</code></td>
<td>
<p> a character vector of PDB file names. </p>
</td></tr>
<tr><td><code id="mustang_+3A_exefile">exefile</code></td>
<td>
<p> file path to the &lsquo;MUSTANG&rsquo; program on your system (i.e.
how is &lsquo;MUSTANG&rsquo; invoked). </p>
</td></tr>
<tr><td><code id="mustang_+3A_outfile">outfile</code></td>
<td>
<p> name of &lsquo;FASTA&rsquo; output file to which alignment
should be written. </p>
</td></tr>
<tr><td><code id="mustang_+3A_cleanpdb">cleanpdb</code></td>
<td>
<p> logical, if TRUE iterate over the PDB files and map
non-standard residues to standard residues (e.g. SEP-&gt;SER..) to
produce &lsquo;clean&rsquo; PDB files. </p>
</td></tr>
<tr><td><code id="mustang_+3A_cleandir">cleandir</code></td>
<td>
<p> character string specifying the directory in which
the &lsquo;clean&rsquo; PDB files should be written. </p>
</td></tr>
<tr><td><code id="mustang_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE &lsquo;MUSTANG&rsquo; warning and error
messages are printed. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Structure-based sequence alignment with &lsquo;MUSTANG&rsquo; attempts to
arrange and align the sequences of proteins based on their 3D
structure.
</p>
<p>This function calls the &lsquo;MUSTANG&rsquo; program, to perform a multiple
structure alignment, which MUST BE INSTALLED on your system and in the
search path for executables.
</p>
<p>Note that non-standard residues are mapped to &ldquo;Z&rdquo; in
MUSTANG. As a workaround the bio3d &lsquo;mustang&rsquo; function will
attempt to map any non-standard residues to standard residues
(e.g. SEP-&gt;SER, etc). To avoid this behaviour use
&lsquo;cleanpdb=FALSE&rsquo;.  
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid. </p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A system call is made to the &lsquo;MUSTANG&rsquo; program, which must be
installed on your system and in the search path for executables.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;MUSTANG&rsquo; is the work of Konagurthu et al:
Konagurthu, A.S. et al. (2006) <em>Proteins</em> <b>64</b>(3):559&ndash;74.
</p>
<p>More details of the &lsquo;MUSTANG&rsquo; algorithm, along with download and
installation instructions can be obtained from:<br />
<a href="https://lcb.infotech.monash.edu/mustang/">https://lcb.infotech.monash.edu/mustang/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+plot.fasta">plot.fasta</a></code>,
<code><a href="#topic+seqaln">seqaln</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

if(!check.utility('mustang')) {
   message('Need MUSTANG installed to run this example')
} else {

## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A")
files &lt;- get.pdb(ids, split = TRUE, path = tempdir())

##-- Or, read a folder/directory of existing PDB files
#pdb.path &lt;- "my_dir_of_pdbs"
#files  &lt;- list.files(path=pdb.path ,
#                     pattern=".pdb",
#                     full.names=TRUE)

##-- Align these PDB sequences
aln &lt;- mustang(files)

##-- Read Aligned PDBs storing coordinate data
pdbs &lt;- read.fasta.pdb(aln) 

}

## End(Not run)
</code></pre>

<hr>
<h2 id='network.amendment'> Amendment of a CNA Network According To A Input Community Membership Vector.  </h2><span id='topic+network.amendment'></span>

<h3>Description</h3>

<p>This function changes the &lsquo;communities&rsquo; attribute of a 
&lsquo;cna&rsquo; class object to match a given membership vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  network.amendment(x, membership, minus.log=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.amendment_+3A_x">x</code></td>
<td>
<p>  A protein network graph object as obtained from the
&lsquo;cna&rsquo; function. </p>
</td></tr>
<tr><td><code id="network.amendment_+3A_membership">membership</code></td>
<td>
<p> A numeric vector containing the new community
membership. </p>
</td></tr> 
<tr><td><code id="network.amendment_+3A_minus.log">minus.log</code></td>
<td>
<p> Logical. Whether to use the minus.log on the cij
values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful, in combination with &lsquo;community.tree&rsquo;, 
for inspecting different community partitioning options of a input 
&lsquo;cna&rsquo; object. See examples.
</p>


<h3>Value</h3>

<p>Returns a &lsquo;cna&rsquo; class object with the attributes changed
according to the membership vector provided.
</p>


<h3>Author(s)</h3>

<p> Guido Scarabelli </p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="#topic+community.tree">community.tree</a></code>, <code><a href="#topic+summary.cna">summary.cna</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

##-- Build a CNA object
pdb &lt;- read.pdb("4Q21")
modes &lt;- nma(pdb)
cij &lt;- dccm(modes)
net &lt;- cna(cij, cutoff.cij=0.2)

##-- Community membership vector for each clustering step
tree &lt;- community.tree(net, rescale=TRUE)

## Produce a new k=7 membership vector and CNA network
memb.k7 &lt;- tree$tree[ tree$num.of.comms == 7, ]
net.7 &lt;- network.amendment(net, memb.k7)

plot(net.7, pdb)

print(net)
print(net.7)

}

</code></pre>

<hr>
<h2 id='nma'> Normal Mode Analysis </h2><span id='topic+nma'></span>

<h3>Description</h3>

<p>Perform normal mode analysis (NMA) on either a single or an ensemble
of protein structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nma(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nma_+3A_...">...</code></td>
<td>
<p> arguments passed to the methods
<code><a href="#topic+nma.pdb">nma.pdb</a></code>, or <code><a href="#topic+nma.pdbs">nma.pdbs</a></code>.
</p>
<p>For function <code><a href="#topic+nma.pdb">nma.pdb</a></code> this will include an object of
class <code>pdb</code> as obtained from function <code><a href="#topic+read.pdb">read.pdb</a></code>.
</p>
<p>For function <code><a href="#topic+nma.pdbs">nma.pdbs</a></code> an object of class <code>pdbs</code> as
obtained from function <code><a href="#topic+pdbaln">pdbaln</a></code> or
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Normal mode analysis (NMA) is a computational approach for studying and
characterizing protein flexibility. Current functionality entails normal
modes calculation on either a single protein structure or an ensemble
of aligned protein structures. 
</p>
<p>This generic <code><a href="#topic+nma">nma</a></code> function calls the corresponding
methods for the actual calculation, which is determined by the class
of the input argument:
</p>
<p>Function <code><a href="#topic+nma.pdb">nma.pdb</a></code> will be used when the input argument is
of class <code>pdb</code>. The function calculates the normal modes of a
C-alpha model of a protein structure.
</p>
<p>Function <code><a href="#topic+nma.pdbs">nma.pdbs</a></code> will be used when the input argument is
of class <code>pdbs</code>. The function will perform normal mode analysis
of each PDB structure stored in the <code>pdbs</code> object
(&lsquo;ensemble NMA&rsquo;).
</p>
<p>See documentation and examples for each corresponding function for
more details. 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nma.pdb">nma.pdb</a></code>, <code><a href="#topic+nma.pdbs">nma.pdbs</a></code>,
<code><a href="#topic+pca">pca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##- Singe structure NMA
## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate normal modes
modes &lt;- nma(pdb)

## Print modes
print(modes)

## Plot modes
plot(modes)

## Visualize modes
#m7 &lt;- mktrj.nma(modes, mode=7, file="mode_7.pdb")


## Needs MUSCLE installed - testing excluded

##- Ensemble NMA
if(check.utility("muscle")) {

## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
files &lt;- get.pdb(ids, split = TRUE, path = tempdir())

## Sequence Alignement
pdbs &lt;- pdbaln(files, outfile = tempfile())

## Normal mode analysis on aligned data
modes &lt;- nma(pdbs, rm.gaps=FALSE)

## Plot fluctuation data
plot(modes, pdbs=pdbs)

}

</code></pre>

<hr>
<h2 id='nma.pdb'> Normal Mode Analysis </h2><span id='topic+nma.pdb'></span><span id='topic+build.hessian'></span><span id='topic+print.nma'></span>

<h3>Description</h3>

<p>Perform elastic network model (ENM) C-alpha normal modes calculation
of a protein structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdb'
nma(pdb, inds = NULL, ff = 'calpha', pfc.fun = NULL,
                  mass = TRUE, temp = 300.0, keep = NULL, hessian = NULL,
                  outmodes = NULL, ... )

build.hessian(xyz, pfc.fun, fc.weights = NULL, pdb = NULL, ...)

## S3 method for class 'nma'
print(x, nmodes=6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nma.pdb_+3A_pdb">pdb</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_inds">inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from
<code><a href="#topic+atom.select">atom.select</a></code> that selects the elements of <code>pdb</code>
upon which the calculation should be based. If not provided the
function will attempt to select the calpha atoms automatically
(based on function <code><a href="#topic+atom.select">atom.select</a></code>). </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_ff">ff</code></td>
<td>
<p> character string specifying the force field to use:
&lsquo;calpha&rsquo;, &lsquo;anm&rsquo;, &lsquo;pfanm&rsquo;, 
&lsquo;reach&rsquo;, or &lsquo;sdenm&rsquo;. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_pfc.fun">pfc.fun</code></td>
<td>
<p> customized pair force constant (&lsquo;pfc&rsquo;)
function. The provided function should take a vector of distances as
an argument to return a vector of force constants. If provided,
'pfc.fun' will override argument <code>ff</code>. See examples below. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_mass">mass</code></td>
<td>
<p> logical, if TRUE the Hessian will be mass-weighted. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_temp">temp</code></td>
<td>
<p> numerical, temperature for which the amplitudes for
scaling the atomic displacement vectors are calculated. Set
&lsquo;temp=NULL&rsquo; to avoid scaling. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_keep">keep</code></td>
<td>
<p> numerical, final number of modes to be stored. Note that
all subsequent analyses are limited to this subset of modes. This
option is useful for very large structures and cases where memory
may be limiting. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_hessian">hessian</code></td>
<td>
<p> hessian matrix as obtained from
<code><a href="#topic+build.hessian">build.hessian</a></code>. For internal purposes and generally not
intended for public use. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_outmodes">outmodes</code></td>
<td>
<p> atom indices as obtained from <code><a href="#topic+atom.select">atom.select</a></code>) 
specifying the atoms to include in the resulting mode object. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector of Cartesian coordinates. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_fc.weights">fc.weights</code></td>
<td>
<p> a numeric matrix of size NxN (where N is the number
of calpha atoms) containg scaling factors for the pariwise force
constants. See examples below. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_x">x</code></td>
<td>
<p> an <code>nma</code> object obtained from <code><a href="#topic+nma.pdb">nma.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_nmodes">nmodes</code></td>
<td>
<p> numeric, number of modes to be printed. </p>
</td></tr>
<tr><td><code id="nma.pdb_+3A_...">...</code></td>
<td>
<p> additional arguments to <code><a href="#topic+build.hessian">build.hessian</a></code>,
<code><a href="#topic+aa2mass">aa2mass</a></code>, <code>pfc.fun</code>, and <code><a href="base.html#topic+print">print</a></code>. One
useful option here for dealing with unconventional residues is
&lsquo;mass.custom&rsquo;, see the <code><a href="#topic+aa2mass">aa2mass</a></code> function for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the normal modes of a C-alpha model of a
protein structure. A number of force fields are implemented all of
whhich employ the elastic network model (ENM).
</p>
<p>The &lsquo;calpha&rsquo; force field - originally developed by Konrad
Hinsen - is the recommended one for most applications. It employs a
spring force constant differentiating between nearest-neighbour pairs
along the backbone and all other pairs. The force constant function
was parameterized by fitting to a local minimum of a crambin model
using the AMBER94 force field.
</p>
<p>See <code><a href="#topic+load.enmff">load.enmff</a></code> for details of the different force fields.
</p>
<p>By default <code><a href="#topic+nma.pdb">nma.pdb</a></code> will diagonalize the mass-weighted Hessian
matrix. The resulting mode vectors are moreover scaled by the thermal
fluctuation amplitudes.
</p>
<p>The implementation under default arguments reproduces the calculation
of normal modes (VibrationalModes) in the Molecular Modeling Toolkit
(MMTK) package. To reproduce ANM modes set <code>ff='anm'</code>,
<code>mass=FALSE</code>, and <code>temp=NULL</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class &lsquo;nma&rsquo; with the following components:
</p>
<table>
<tr><td><code>modes</code></td>
<td>
<p> numeric matrix with columns containing the normal mode
vectors. Mode vectors are converted to unweighted Cartesian
coordinates  when <code>mass=TRUE</code>. Note that the 6 first trivial
eigenvectos appear in columns one to six. </p>
</td></tr>
<tr><td><code>frequencies</code></td>
<td>
<p> numeric vector containing the vibrational
frequencies corresponding to each mode (for <code>mass=TRUE</code>). </p>
</td></tr>
<tr><td><code>force.constants</code></td>
<td>
<p> numeric vector containing the force constants
corresponding to each mode (for <code>mass=FALSE)</code>). </p>
</td></tr>
<tr><td><code>fluctuations</code></td>
<td>
<p> numeric vector of atomic fluctuations. </p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p> numeric matrix with columns containing the raw
eigenvectors. Equals to the <code>modes</code> component when
<code>mass=FALSE</code> and <code>temp=NULL</code>. </p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> numeric vector containing the raw eigenvalues. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> numeric matrix of class <code>xyz</code> containing the
Cartesian coordinates in which the calculation was performed. </p>
</td></tr>
<tr><td><code>mass</code></td>
<td>
<p> numeric vector containing the residue masses used for the
mass-weighting. </p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p> numerical, temperature for which the amplitudes for
scaling the atomic displacement vectors are calculated. </p>
</td></tr>
<tr><td><code>triv.modes</code></td>
<td>
<p> number of trivial modes. </p>
</td></tr>
<tr><td><code>natoms</code></td>
<td>
<p> number of C-alpha atoms. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The current version provides an efficent implementation of NMA with
execution time comparable to similar software (when the entire Hessian
is diagonalized).
</p>
<p>The main (speed related) bottleneck is currently the diagonalization
of the Hessian matrix which is performed with the core R function
<code><a href="base.html#topic+eigen">eigen</a></code>. For computing a few (5-20) approximate modes the user
can consult package &lsquo;irlba&rsquo;.
</p>
<p>NMA is memory extensive and users should be cautions when running
larger proteins (&gt;3000 residues). Use &lsquo;keep&rsquo; to reduce the
amount of memory needed to store the final &lsquo;nma&rsquo; object (the
full 3Nx3N Hessian matrix still needs to be allocated).
</p>
<p>We thank Edvin Fuglebakk for valuable discussions on the
implementation as well as for contributing with testing.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
Hinsen, K. et al. (2000) <em>Chemical Physics</em> <b>261</b>, 25&ndash;37.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fluct.nma">fluct.nma</a></code>, <code><a href="#topic+mktrj.nma">mktrj.nma</a></code>,
<code><a href="#topic+dccm.nma">dccm.nma</a></code>, <code><a href="#topic+overlap">overlap</a></code>, <code><a href="#topic+rmsip">rmsip</a></code>,
<code><a href="#topic+load.enmff">load.enmff</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate normal modes
modes &lt;- nma(pdb)

## Print modes
print(modes)

## Plot modes
plot(modes)

## Visualize modes
#m7 &lt;- mktrj.nma(modes, mode=7, file="mode_7.pdb")

## Not run: 
## Use Anisotropic Network Model
modes &lt;- nma(pdb, ff="anm", mass=FALSE, temp=NULL, cutoff=15)

## Use SSE information and SS-bonds
sse      &lt;- dssp(pdb, resno=FALSE, full=TRUE)
ss.bonds &lt;- matrix(c(76,94, 64,80, 30,115, 6,127),
                   ncol=2, byrow=TRUE)


## User defined energy function
## Note: Must take a vector of distances
"my.ff" &lt;- function(r) {
   ifelse( r&gt;15, 0, 1 )
}

## Modes with a user defined energy function
modes &lt;- nma(pdb, pfc.fun=my.ff)


## A more manual approach
sele &lt;- atom.select(pdb, chain='A', elety='CA')
xyz &lt;- pdb$xyz[sele$xyz]

hessian &lt;- build.hessian(xyz, my.ff)
modes &lt;- eigen(hessian)

## Dealing with unconventional residues
pdb &lt;- read.pdb("1xj0")

## nma(pdb)
#modes &lt;- nma(pdb, mass.custom=list(CSX=121.166))

## End(Not run)
</code></pre>

<hr>
<h2 id='nma.pdbs'> Ensemble Normal Mode Analysis </h2><span id='topic+nma.pdbs'></span><span id='topic+print.enma'></span>

<h3>Description</h3>

<p>Perform normal mode analysis (NMA) on an ensemble of aligned protein
structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdbs'
nma(pdbs, fit = TRUE, full = FALSE, subspace = NULL,
         rm.gaps = TRUE, varweight=FALSE, 
         outpath = NULL, ncore = 1, progress = NULL, ...)

## S3 method for class 'enma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nma.pdbs_+3A_pdbs">pdbs</code></td>
<td>
<p> a numeric matrix of aligned C-alpha xyz Cartesian
coordinates. For example an alignment data structure obtained with
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or <code><a href="#topic+pdbaln">pdbaln</a></code>. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_fit">fit</code></td>
<td>
<p> logical, if TRUE coordinate superposition is performed
prior to normal mode calculations. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_full">full</code></td>
<td>
<p> logical, if TRUE return the complete, full structure, 
&lsquo;nma&rsquo; objects. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_subspace">subspace</code></td>
<td>
<p> number of eigenvectors to store for further
analysis. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE obtain the hessian matrices for only
atoms in the aligned positions (non-gap positions in all aligned
structures). Thus, gap positions are removed from output. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_varweight">varweight</code></td>
<td>
<p> logical, if TRUE perform weighing of the pair force
constants. Alternatively, provide a NxN matrix containing the
weights. See function <code><a href="#topic+var.xyz">var.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_outpath">outpath</code></td>
<td>
<p> character string specifing the output directory to
which the PDB structures should be written. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_x">x</code></td>
<td>
<p> an <code>enma</code> object obtained from <code><a href="#topic+nma.pdbs">nma.pdbs</a></code>. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_progress">progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td></tr>
<tr><td><code id="nma.pdbs_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>nma</code>, <code><a href="#topic+aa2mass">aa2mass</a></code>, and
<code><a href="base.html#topic+print">print</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs normal mode analysis (NMA) on a set of aligned
protein structures obtained with function <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or
<code><a href="#topic+pdbaln">pdbaln</a></code>. The main purpose is to provide aligned atomic
fluctuations and mode vectors in an automated fashion. 
</p>
<p>The normal modes are calculated on the full structures as provided 
by object &lsquo;pdbs&rsquo;. With the input argument &lsquo;full=TRUE&rsquo;
the full &lsquo;nma&rsquo; objects are returned together with output
&lsquo;U.subs&rsquo; providing the aligned mode vectors. When
&lsquo;rm.gaps=TRUE&rsquo; the unaligned atoms are ommited from
output. With default arguments &lsquo;rmsip&rsquo; provides RMSIP
values for all pairwise structures.
</p>
<p>See examples for more details. 
</p>


<h3>Value</h3>

<p>Returns an &lsquo;enma&rsquo; object with the following components:
</p>
<table>
<tr><td><code>fluctuations</code></td>
<td>
<p> a numeric matrix containing aligned atomic
fluctuations with one row per input structure. </p>
</td></tr>
<tr><td><code>rmsip</code></td>
<td>
<p> a numeric matrix of pair wise RMSIP values (only the ten
lowest frequency modes are included in the calculation). </p>
</td></tr>
<tr><td><code>U.subspace</code></td>
<td>
<p> a three-dimensional array with aligned
eigenvectors  (corresponding to the subspace defined by the first N
non-trivial eigenvectors (&lsquo;U&rsquo;) of the &lsquo;nma&rsquo; object). </p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> numeric matrix containing the raw eigenvalues with one row
per input structure. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> an object of class &lsquo;xyz&rsquo; containing the Cartesian
coordinates in which the calculation was performed. Coordinates are
superimposed to the first structure of the <code>pdbs</code> object when
&lsquo;fit=TRUE&rsquo;. </p>
</td></tr>   
<tr><td><code>full.nma</code></td>
<td>
<p> a list with a <code>nma</code> object for each input
structure. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p>For normal mode analysis on single structure PDB:
<code><a href="#topic+nma.pdb">nma.pdb</a></code>
</p>
<p>For the analysis of the resulting &lsquo;eNMA&rsquo; object:
<code><a href="#topic+mktrj.enma">mktrj.enma</a></code>, <code><a href="#topic+dccm.enma">dccm.enma</a></code>,
<code><a href="#topic+plot.enma">plot.enma</a></code>, <code><a href="#topic+cov.enma">cov.enma</a></code>.
</p>
<p>Similarity measures:
<code><a href="#topic+sip">sip</a></code>, <code><a href="#topic+covsoverlap">covsoverlap</a></code>,
<code><a href="#topic+bhattacharyya">bhattacharyya</a></code>, <code><a href="#topic+rmsip">rmsip</a></code>.
</p>
<p>Related functionality:
<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Needs MUSCLE installed - testing excluded

if(check.utility("muscle")) {

## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
files &lt;- get.pdb(ids, split = TRUE, path = tempdir())

## Sequence Alignement
pdbs &lt;- pdbaln(files, outfile = tempfile())

## Normal mode analysis on aligned data
modes &lt;- nma(pdbs, rm.gaps=FALSE)

## Plot fluctuation data
plot(modes, pdbs=pdbs)

## Cluster on Fluctuation similariy
sip &lt;- sip(modes)
hc &lt;- hclust(dist(sip))
col &lt;- cutree(hc, k=3)

## Plot fluctuation data
plot(modes, pdbs=pdbs, col=col)

## Remove gaps from output
modes &lt;- nma(pdbs, rm.gaps=TRUE)

## RMSIP is pre-calculated
heatmap(1-modes$rmsip)

## Bhattacharyya coefficient
bc &lt;- bhattacharyya(modes)
heatmap(1-bc)

}

</code></pre>

<hr>
<h2 id='normalize.vector'> Mass-Weighted Normalized Vector </h2><span id='topic+normalize.vector'></span>

<h3>Description</h3>

<p>Normalizes a vector (mass-weighted if requested).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize.vector(x, mass=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize.vector_+3A_x">x</code></td>
<td>
<p> a numeric vector or matrix to be normalized. </p>
</td></tr>
<tr><td><code id="normalize.vector_+3A_mass">mass</code></td>
<td>
<p> a numeric vector containing the atomic masses for
weighting. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function normalizes a vector, or alternatively, the column-wise
vector elements of a matrix. If atomic masses are provided the vector
is mass-weigthed. 
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns the normalized vector(s).
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a> </code>, <code><a href="#topic+inner.prod">inner.prod</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- matrix(1:9, ncol = 3, nrow = 3)

normalize.vector(x)
normalize.vector(y)

## Application to normal modes
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate (vibrational) normal modes
modes &lt;- nma(pdb)

## Returns a vector
nv &lt;- normalize.vector(modes$modes[,7])

## Returns a matrix
nv &lt;- normalize.vector(modes$modes[,7:10])

## Mass-weighted
nv &lt;- normalize.vector(modes$modes[,7], mass=modes$mass)
</code></pre>

<hr>
<h2 id='orient.pdb'> Orient a PDB Structure </h2><span id='topic+orient.pdb'></span>

<h3>Description</h3>

<p>Center, to the coordinate origin, and orient, by principal axes, the
coordinates of a given PDB structure or xyz vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orient.pdb(pdb, atom.subset = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orient.pdb_+3A_pdb">pdb</code></td>
<td>
<p> a pdb data structure obtained from <code><a href="#topic+read.pdb">read.pdb</a></code>
or a vector of &lsquo;xyz&rsquo; coordinates. </p>
</td></tr>
<tr><td><code id="orient.pdb_+3A_atom.subset">atom.subset</code></td>
<td>
<p> a subset of atom positions to base orientation on. </p>
</td></tr>
<tr><td><code id="orient.pdb_+3A_verbose">verbose</code></td>
<td>
<p> print dimension details. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of re-oriented coordinates.
</p>


<h3>Note</h3>

<p>Centering and orientation can be restricted to a <code>atom.subset</code> of atoms.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+fit.xyz">fit.xyz</a></code>, <code><a href="#topic+rot.lsq">rot.lsq</a></code> , <code><a href="#topic+atom.select">atom.select</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

pdb &lt;- read.pdb( "1bg2" )
xyz &lt;- orient.pdb(pdb)
#write.pdb(pdb, xyz = xyz, file = "mov1.pdb")


# Based on C-alphas
inds &lt;- atom.select(pdb, "calpha")
xyz  &lt;- orient.pdb(pdb, atom.subset=inds$atom)
#write.pdb(pdb, xyz = xyz, file = "mov2.pdb")


# Based on a central Beta-strand
inds &lt;- atom.select(pdb, resno=c(224:232), elety='CA')
xyz  &lt;- orient.pdb(pdb, atom.subset=inds$atom)
#write.pdb(pdb, xyz = xyz, file = "mov3.pdb")

</code></pre>

<hr>
<h2 id='overlap'> Overlap analysis </h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>Calculate the squared overlap between sets of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(modes, dv, nmodes=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_modes">modes</code></td>
<td>
<p> an object of class <code>"pca"</code> or <code>"nma"</code> as obtained from
function <code>pca.xyz</code> or <code>nma</code>. Alternatively a 3NxM matrix
of eigenvectors can be provided. </p>
</td></tr> 
<tr><td><code id="overlap_+3A_dv">dv</code></td>
<td>
<p> a displacement vector of length 3N. </p>
</td></tr> 
<tr><td><code id="overlap_+3A_nmodes">nmodes</code></td>
<td>
<p> the number of modes in which the calculation should be based. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Squared overlap (or dot product) is used to measure the similiarity 
between a displacement vector (e.g. a difference vector between two 
conformational states) and mode vectors obtained from principal component 
or normal modes analysis. 
</p>
<p>By definition the cumulative sum of the overlap values equals to one. 
</p>
<p>Structure <code>modes$U</code> (or alternatively, the 3NxM matrix of eigenvectors)
should be of same length (3N) as <code>dv</code>. 
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>overlap</code></td>
<td>
<p> a numeric vector of the squared dot products (overlap values)
between the (normalized) vector (<code>dv</code>) and each mode in <code>mode</code>. </p>
</td></tr>
<tr><td><code>overlap.cum</code></td>
<td>
<p> a numeric vector of the cumulative squared overlap values. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2011) <em>Proteins</em> <b>79</b>, 232&ndash;243.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rmsip">rmsip</a></code>, <code><a href="#topic+pca.xyz">pca.xyz</a></code>, <code><a href="#topic+nma">nma</a></code>,
<code><a href="#topic+difference.vector">difference.vector</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(kinesin)
     
# Ignore gap containing positions
##gaps.res &lt;- gap.inspect(pdbs$ali)
gaps.pos &lt;- gap.inspect(pdbs$xyz)
     
#-- Do PCA
pc.xray &lt;- pca.xyz(pdbs$xyz[, gaps.pos$f.inds])
    
# Define a difference vector between two structural states
diff.inds &lt;- c(grep("d1v8ka", pdbs$id), 
               grep("d1goja", pdbs$id))

dv &lt;- difference.vector( pdbs$xyz[diff.inds,], gaps.pos$f.inds )

# Calculate the squared overlap between the PCs and the difference vector  
o &lt;- overlap(pc.xray, dv)
o &lt;- overlap(pc.xray$U, dv)

# Plot results
plot(o$overlap, type='h', ylim=c(0,1))
points(o$overlap)
lines(o$overlap.cum, type='b', col='red')


detach(kinesin)

## Not run: 
## Calculate overlap from NMA
pdb.a &lt;- read.pdb("1cmk")
pdb.b &lt;- read.pdb("3dnd")

## Fetch CA coordinates
sele.a &lt;- atom.select(pdb.a, chain='E', resno=c(15:350), elety='CA')
sele.b &lt;- atom.select(pdb.b, chain='A', resno=c(1:350), elety='CA')

xyz &lt;- rbind(pdb.a$xyz[sele.a$xyz],
             pdb.b$xyz[sele.b$xyz])

## Superimpose
xyz[2,] &lt;- fit.xyz(xyz[1,], xyz[2,], 1:ncol(xyz))

## The difference between the two conformations
dv &lt;- difference.vector( xyz )

## Calculate normal modes
modes &lt;- nma(pdb.a, inds=sele.a)

# Calculate the squared overlap between the normal modes 
# and the difference vector  
o &lt;- overlap(modes, dv)

## End(Not run)
</code></pre>

<hr>
<h2 id='pairwise'> Pair Indices </h2><span id='topic+pairwise'></span>

<h3>Description</h3>

<p>A utility function to determine indices for pairwise comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_n">N</code></td>
<td>
<p> a single numeric value representing the total number of
things to undergo pairwise comparison. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a two column numeric matrix giving the indices for all
pairs.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqidentity">seqidentity</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  pairwise(3)
  pairwise(20)
</code></pre>

<hr>
<h2 id='pca'> Principal Component Analysis </h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>Performs principal components analysis (PCA) on biomolecular structure data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pca(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p> arguments passed to the methods <code>pca.xyz</code>,
<code>pca.pdbs</code>, etc. Typically this includes either a numeric
matrix of Cartesian coordinates with a row per structure/frame (function
<code>pca.xyz()</code>), or an object  of class <code>pdbs</code> as obtained from
function <code>pdbaln</code> or <code>read.fasta.pdb</code> (function
<code>pca.pdbs()</code>). </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Principal component analysis can be performed on any structure dataset of equal or unequal sequence composition to capture and characterize inter-conformer relationships.
</p>
<p>This generic <code>pca</code> function calls the corresponding methods function for actual calculation, which is determined by the class of the input argument <code>x</code>. Use
<code>methods("pca")</code> to list all the current methods for <code>pca</code>
generic. These will include:
</p>
<p><code><a href="#topic+pca.xyz">pca.xyz</a></code>, which will be used when <code>x</code> is a numeric matrix
containing Cartesian coordinates (e.g. trajectory data).
</p>
<p><code><a href="#topic+pca.pdbs">pca.pdbs</a></code>, which will perform PCA on the 
Cartesian coordinates of a input <code>pdbs</code> object (as obtained from 
the &lsquo;read.fasta.pdb&rsquo; or &lsquo;pdbaln&rsquo; functions).
</p>
<p>Currently, function <code><a href="#topic+pca.tor">pca.tor</a></code> should be called explicitly as there
are currently no defined &lsquo;tor&rsquo; object classes.
</p>
<p>See the documentation and examples for each individual function for
more details and worked examples.
</p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca.xyz">pca.xyz</a></code>, <code><a href="#topic+pca.pdbs">pca.pdbs</a></code>,
<code><a href="#topic+pdbaln">pdbaln</a></code>. </p>

<hr>
<h2 id='pca.array'> Principal Component Analysis of an array of matrices </h2><span id='topic+pca.array'></span>

<h3>Description</h3>

<p>Calculate the principal components of an array of correlation or
covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
pca(x, use.svd = TRUE, rm.gaps=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.array_+3A_x">x</code></td>
<td>
<p> an array of matrices, e.g. correlation or covariance
matrices as obtained from functions <code>dccm</code> or <code>enma2covs</code>. </p>
</td></tr>
<tr><td><code id="pca.array_+3A_use.svd">use.svd</code></td>
<td>
<p> logical, if TRUE singular value decomposition (SVD) is 
called instead of eigenvalue decomposition. </p>
</td></tr>
<tr><td><code id="pca.array_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE gap cells (with missing
coordinate data in any input matrix) are removed before
calculation. This is equivalent to removing NA cells from x. </p>
</td></tr>
<tr><td><code id="pca.array_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs PCA of symmetric matrices, such as distance 
matrices from an ensemble of crystallographic structures, residue-residue 
cross-correlations or covariance matrices derived from ensemble NMA 
or MD simulation replicates, and so on. The &lsquo;upper triangular&rsquo; 
region of the matrix is regarded as a long vector of random variables. 
The function returns M eigenvalues and eigenvectors with each eigenvector 
having the dimension N(N-1)/2, where M is the number of matrices and N 
the number of rows/columns of matrices.
</p>


<h3>Value</h3>

<p>Returns a list with components equivalent to the output from
<code>pca.xyz</code>. 
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.   
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pca.xyz">pca.xyz</a></code> </p>

<hr>
<h2 id='pca.pdbs'> Principal Component Analysis </h2><span id='topic+pca.pdbs'></span>

<h3>Description</h3>

<p>Performs principal components analysis (PCA) on an ensemble of PDB structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdbs'
pca(pdbs, core.find = FALSE, fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.pdbs_+3A_pdbs">pdbs</code></td>
<td>
<p> an object of class <code>pdbs</code> as obtained from
function <code>pdbaln</code> or <code>read.fasta.pdb</code>. </p>
</td></tr>
<tr><td><code id="pca.pdbs_+3A_core.find">core.find</code></td>
<td>
<p> logical, if TRUE core.find() function will be called
to find core positions and coordinates of PDB structures will be
fitted based on cores.  </p>
</td></tr>
<tr><td><code id="pca.pdbs_+3A_fit">fit</code></td>
<td>
<p> logical, if TRUE coordinates of PDB structures will be
fitted based on all CA atoms.  </p>
</td></tr>
<tr><td><code id="pca.pdbs_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the method <code>pca.xyz</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pca.pdbs</code> is a wrapper for the function
<code><a href="#topic+pca.xyz">pca.xyz</a></code>, wherein more details of the PCA procedure
are documented. 
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>eigenvalues.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>eigenvectors (i.e. the variable loadings).</p>
</td></tr>
<tr><td><code>z.u</code></td>
<td>
<p>scores of the supplied <code>data</code> on the pcs.</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>the standard deviations of the pcs.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the means that were subtracted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>  Barry Grant, Lars Skjaerven and Xin-Qiu Yao</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+pca.xyz">pca.xyz</a></code>,
<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+nma">nma</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
attach(transducin)

#-- Do PCA ignoring gap containing positions
pc.xray &lt;- pca(pdbs)

# Plot results (conformer plots &amp; scree plot)
plot(pc.xray, col=annotation[, "color"])

detach(transducin)

</code></pre>

<hr>
<h2 id='pca.tor'> Principal Component Analysis </h2><span id='topic+pca.tor'></span>

<h3>Description</h3>

<p>Performs principal components analysis (PCA) on torsion angle <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tor'
pca(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.tor_+3A_data">data</code></td>
<td>
<p> numeric matrix of torsion angles with a row per structure. </p>
</td></tr>
<tr><td><code id="pca.tor_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the method <code>pca.xyz</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>eigenvalues.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>eigenvectors (i.e. the variable loadings).</p>
</td></tr>
<tr><td><code>z.u</code></td>
<td>
<p>scores of the supplied <code>data</code> on the pcs.</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>the standard deviations of the pcs.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the means that were subtracted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>  Barry Grant and Karim ElSawy </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+torsion.xyz">torsion.xyz</a></code>, <code><a href="#topic+plot.pca">plot.pca</a></code>,
<code><a href="#topic+plot.pca.loadings">plot.pca.loadings</a></code>, <code><a href="#topic+pca.xyz">pca.xyz</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##-- PCA on torsion data for multiple PDBs 
attach(kinesin)

gaps.pos &lt;- gap.inspect(pdbs$xyz)
tor &lt;- t(apply( pdbs$xyz[, gaps.pos$f.inds], 1, torsion.xyz, atm.inc=1))
pc.tor &lt;- pca.tor(tor[,-c(1,233,234,235)])
#plot(pc.tor)
plot.pca.loadings(pc.tor)

detach(kinesin)

## Not run: 
##-- PCA on torsion data from an MD trajectory
trj &lt;- read.dcd( system.file("examples/hivp.dcd", package="bio3d") )
tor &lt;- t(apply(trj, 1, torsion.xyz, atm.inc=1))
gaps &lt;- gap.inspect(tor)
pc.tor &lt;- pca.tor(tor[,gaps$f.inds])
plot.pca.loadings(pc.tor)

## End(Not run)
</code></pre>

<hr>
<h2 id='pca.xyz'> Principal Component Analysis </h2><span id='topic+pca.xyz'></span><span id='topic+print.pca'></span>

<h3>Description</h3>

<p>Performs principal components analysis (PCA) on a <code>xyz</code>
numeric data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xyz'
pca(xyz, subset = rep(TRUE, nrow(as.matrix(xyz))),
                 use.svd = FALSE, rm.gaps=FALSE, mass = NULL, ...)

## S3 method for class 'pca'
print(x, nmodes=6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.xyz_+3A_xyz">xyz</code></td>
<td>
<p> numeric matrix of Cartesian coordinates with a row per
structure. </p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_subset">subset</code></td>
<td>
<p> an optional vector of numeric indices that selects a
subset of rows (e.g. experimental structures vs molecular dynamics
trajectory structures) from the full <code>xyz</code> matrix. Note: the
full <code>xyz</code> is projected onto this subspace.</p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_use.svd">use.svd</code></td>
<td>
<p> logical, if TRUE singular value decomposition (SVD) is 
called instead of eigenvalue decomposition. </p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE gap positions (with missing
coordinate data in any input structure) are removed before
calculation. This is equivalent to removing NA cols from xyz. </p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_x">x</code></td>
<td>
<p> an object of class <code>pca</code>, as obtained from function
<code>pca.xyz</code>. </p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_nmodes">nmodes</code></td>
<td>
<p> numeric, number of modes to be printed. </p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_mass">mass</code></td>
<td>
<p> a &lsquo;pdb&rsquo; object or numeric vector of residue/atom masses. 
By default (<code>mass=NULL</code>), mass is ignored. If provided 
with a &lsquo;pdb&rsquo; object, masses of all amino acids obtained from 
<code><a href="#topic+aa2mass">aa2mass</a></code> are used. </p>
</td></tr>
<tr><td><code id="pca.xyz_+3A_...">...</code></td>
<td>
<p> additional arguments to <code><a href="#topic+fit.xyz">fit.xyz</a></code> 
(for <code>pca.xyz</code>) or to <code>print</code> (for <code>print.pca</code>). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>eigenvalues.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>eigenvectors (i.e. the x, y, and z variable loadings).</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>scores of the supplied <code>xyz</code> on the pcs.</p>
</td></tr>
<tr><td><code>au</code></td>
<td>
<p>atom-wise loadings (i.e. xyz normalized eigenvectors).</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>the standard deviations of the pcs.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the means that were subtracted.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>mass</code> is provided, mass weighted coordinates will be considered, 
and iteration of fitting onto the mean structure is performed internally. 
The extra fitting process is to remove external translation and rotation 
of the whole system. With this option, a direct comparison can be made 
between PCs from <code><a href="#topic+pca.xyz">pca.xyz</a></code> and vibrational modes from 
<code><a href="#topic+nma.pdb">nma.pdb</a></code>, with the fact that 
</p>
<p style="text-align: center;"><code class="reqn">A=k_BTF^{-1}</code>
</p>
<p>, 
where <code class="reqn">A</code> is the variance-covariance matrix, <code class="reqn">F</code> the Hessian 
matrix, <code class="reqn">k_B</code> the Boltzmann's constant, and <code class="reqn">T</code> the 
temperature.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+pca.pdbs">pca.pdbs</a></code>,
<code><a href="#topic+plot.pca">plot.pca</a></code>, <code><a href="#topic+mktrj.pca">mktrj.pca</a></code>,
<code><a href="#topic+pca.tor">pca.tor</a></code>, <code><a href="#topic+project.pca">project.pca</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#-- Read transducin alignment and structures
aln &lt;- read.fasta(system.file("examples/transducin.fa",package="bio3d"))
pdbs &lt;- read.fasta.pdb(aln)

# Find core
core &lt;- core.find(pdbs, 
                  #write.pdbs = TRUE,
                  verbose=TRUE)

rm(list=c("pdbs", "core"))

## End(Not run)

#-- OR for demo purposes just read previously saved transducin data
attach(transducin)

# Previously fitted coordinates based on sub 1.0A^3 core. See core.find() function.
xyz &lt;- pdbs$xyz
                
#-- Do PCA ignoring gap containing positions
pc.xray &lt;- pca.xyz(xyz, rm.gaps=TRUE)

# Plot results (conformer plots &amp; scree plot overview)
plot(pc.xray, col=annotation[, "color"])

# Plot a single conformer plot of PC1 v PC2
plot(pc.xray, pc.axes=1:2, col=annotation[, "color"])

## Plot atom wise loadings
plot.bio3d(pc.xray$au[,1], ylab="PC1 (A)")


# PDB server connection required - testing excluded

## Plot loadings in relation to reference structure 1TAG
pdb &lt;- read.pdb("1tag")
ind &lt;- grep("1TAG", pdbs$id)             ## location in alignment

resno &lt;- pdbs$resno[ind, !is.gap(pdbs)]  ## non-gap residues
tpdb &lt;- trim.pdb(pdb, resno=resno)

op &lt;- par(no.readonly=TRUE)
par(mfrow = c(3, 1), cex = 0.6, mar = c(3, 4, 1, 1))
plot.bio3d(pc.xray$au[,1], resno, ylab="PC1 (A)", sse=tpdb)
plot.bio3d(pc.xray$au[,2], resno, ylab="PC2 (A)", sse=tpdb)
plot.bio3d(pc.xray$au[,3], resno, ylab="PC3 (A)", sse=tpdb)
par(op)


## Not run: 
# Write PC trajectory
resno = pdbs$resno[1, !is.gap(pdbs)]
resid = aa123(pdbs$ali[1, !is.gap(pdbs)])

a &lt;- mktrj.pca(pc.xray, pc=1, file="pc1.pdb",
               resno=resno, resid=resid )

b &lt;- mktrj.pca(pc.xray, pc=2, file="pc2.pdb",
               resno=resno, resid=resid )

c &lt;- mktrj.pca(pc.xray, pc=3, file="pc3.pdb",
               resno=resno, resid=resid )

## End(Not run)

detach(transducin)
</code></pre>

<hr>
<h2 id='pdb.annotate'> Get Customizable Annotations From PDB Or PFAM Databases</h2><span id='topic+pdb.annotate'></span><span id='topic+pdb.pfam'></span>

<h3>Description</h3>

<p>Get customizable annotations for query results from PDB or PFAM.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb.annotate(ids, anno.terms = NULL, unique = FALSE, verbose = FALSE,
             extra.terms = NULL)
pdb.pfam(ids, best.only = TRUE, compact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb.annotate_+3A_ids">ids</code></td>
<td>
<p> A charater vector of one or more 4-letter PDB
codes/identifiers of the files for query, or a &lsquo;blast&rsquo;
object containing &lsquo;pdb.id&rsquo;. </p>
</td></tr>
<tr><td><code id="pdb.annotate_+3A_anno.terms">anno.terms</code></td>
<td>
<p> Terms can be used for query. The &quot;anno.terms&quot; can be
&quot;structureId&quot;, &quot;chainId&quot;, &quot;macromoleculeType&quot;, &quot;chainLength&quot;, 
&quot;experimentalTechnique&quot;,  &quot;resolution&quot;, &quot;scopDomain&quot;, &quot;pfam&quot;, &quot;ligandId&quot;, 
&quot;ligandName&quot;, &quot;source&quot;, &quot;structureTitle&quot;, &quot;citation&quot;, &quot;rObserved&quot;, 
&quot;rFree&quot;, &quot;rWork&quot;, and &quot;spaceGroup&quot;.
If anno.terms=NULL, all information would be returned. </p>
</td></tr>
<tr><td><code id="pdb.annotate_+3A_unique">unique</code></td>
<td>
<p> logical, if TRUE only unique PDB entries are
returned. Alternatively data for each chain ID is provided. </p>
</td></tr>
<tr><td><code id="pdb.annotate_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE more details are printed. </p>
</td></tr>
<tr><td><code id="pdb.annotate_+3A_extra.terms">extra.terms</code></td>
<td>
<p> Additional annotation terms to retrieve from PDB.
Currently not supported. </p>
</td></tr>
<tr><td><code id="pdb.annotate_+3A_best.only">best.only</code></td>
<td>
<p> logical, if TRUE only the lowest eValue match for a 
given input id will be reported. Otherwise all significant matches 
will be returned. </p>
</td></tr>
<tr><td><code id="pdb.annotate_+3A_compact">compact</code></td>
<td>
<p> logical, if TRUE only a subset of annotation terms 
are returned. Otherwise full match details are reported (see 
examples).</p>
</td></tr>      
</table>


<h3>Details</h3>

<p>Given a list of PDB IDs (and query terms for the pdb.annotate function),  
these functions will download annotation information from the RCSB PDB 
and PFAM databases.
</p>


<h3>Value</h3>

<p>Returns a data frame of query results with a row for each PDB record,
and annotation terms column-wise. 
</p>


<h3>Author(s)</h3>

<p> Hongyang Li, Barry Grant, Lars Skjaerven, Xin-Qiu Yao</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

# Fetch all annotation terms
ids &lt;- c("6Q21_B", "1NVW", "1P2U_A")
anno &lt;- pdb.annotate(ids)

# Access terms, e.g. ligand names:
anno$ligandName

## only unique PDB IDs
anno &lt;- pdb.annotate(ids, unique=TRUE)

# Fetch only specific terms
pdb.annotate(ids, anno.terms = c("pfam", "ligandId", "citation"))



## Not run: 
# PFAM server connection required - testing excluded

# Find PFAM annotations of PDB entries
pdb.pfam(c("6Q21_A", "1NVW", "1P2U_A"))

# More details and a not fond entry warning
pdb.pfam(c("1P2U_A", "6Q21_B"), compact=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='pdb2aln'> Align a PDB structure to an existing alignment </h2><span id='topic+pdb2aln'></span>

<h3>Description</h3>

<p>Extract sequence from a PDB object and align it to 
an existing multiple sequence alignment that you wish 
keep intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb2aln(aln, pdb, id="seq.pdb", aln.id=NULL, file="pdb2aln.fa", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb2aln_+3A_aln">aln</code></td>
<td>
<p> an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, and <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
<tr><td><code id="pdb2aln_+3A_pdb">pdb</code></td>
<td>
<p> the PDB object to be added to <code>aln</code>. </p>
</td></tr>
<tr><td><code id="pdb2aln_+3A_id">id</code></td>
<td>
<p> name for the PDB sequence in the generated new alignment. </p>
</td></tr>
<tr><td><code id="pdb2aln_+3A_aln.id">aln.id</code></td>
<td>
<p> id of the sequence in <code>aln</code> that is close to the 
sequence from <code>pdb</code>. </p>
</td></tr>
<tr><td><code id="pdb2aln_+3A_file">file</code></td>
<td>
<p> output file name for writing the generated new alignment. </p>
</td></tr>
<tr><td><code id="pdb2aln_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic effect of this function is to add a PDB sequence to an existing
alignement. In this case, the function is simply a wrapper of 
<code><a href="#topic+seq2aln">seq2aln</a></code>.
</p>
<p>The more advanced (and also more useful) effect is giving complete mappings
from the column indices of the original alignment (<code>aln$ali</code>) to 
atomic indices of equivalent C-alpha atoms in the <code>pdb</code>. These mappings
are stored in the output list (see below 'Value' section). This feature
is better illustrated in the function <code><a href="#topic+pdb2aln.ind">pdb2aln.ind</a></code>, which 
calls <code>pdb2aln</code> and directly returns atom selections given a set of 
alignment positions. (See <code><a href="#topic+pdb2aln.ind">pdb2aln.ind</a></code> for details. ) 
</p>
<p>When <code>aln.id</code> is provided, the function will do pairwise alignment 
between the sequence from <code>pdb</code> and the sequence in <code>aln</code> 
with id matching <code>aln.id</code>. This is the best way to use the
function if the protein has an identical or very similar sequence 
to one of the sequences in <code>aln</code>.
</p>


<h3>Value</h3>

<p>Return a list object of the class 'fasta' containing three components:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>ref</code></td>
<td>
<p> an integer 2xN matrix, where N is the number of columns of
the new alignment <code>ali</code>. The first row contains the column indices of 
the original alignment <code>aln$ali</code>. The second row contains atomic 
indices of equivalent C-alpha atoms in <code>pdb</code>. Gaps in the new 
alignement are indicated by NAs. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao &amp; Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+seq2aln">seq2aln</a></code>, 
<code><a href="#topic+seqaln.pair">seqaln.pair</a></code>, <code><a href="#topic+pdb2aln.ind">pdb2aln.ind</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##--- Read aligned PDB coordinates (CA only)
aln  &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))
pdbs &lt;- read.fasta.pdb(aln)

##--- Read PDB coordinate for a new structure (all atoms)
id &lt;- get.pdb("2kin", URLonly=TRUE)
pdb &lt;- read.pdb(id)

# add pdb to the alignment 
naln &lt;- pdb2aln(aln=pdbs, pdb=pdb, id=id)
naln


## End(Not run)

</code></pre>

<hr>
<h2 id='pdb2aln.ind'> Mapping from alignment positions to PDB atomic indices </h2><span id='topic+pdb2aln.ind'></span>

<h3>Description</h3>

<p>Find the best alignment between a PDB structure and an 
existing alignment. Then, given a set of column indices
of the original alignment, returns atom selections of 
equivalent C-alpha atoms in the PDB structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb2aln.ind(aln, pdb, inds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb2aln.ind_+3A_aln">aln</code></td>
<td>
<p> an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+pdbaln">pdbaln</a></code>, and 
<code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
<tr><td><code id="pdb2aln.ind_+3A_pdb">pdb</code></td>
<td>
<p> the PDB object to be aligned to <code>aln</code>. </p>
</td></tr>
<tr><td><code id="pdb2aln.ind_+3A_inds">inds</code></td>
<td>
<p> a numeric vector containing a subset of column indices of
<code>aln</code>. If NULL, non-gap positions of <code>aln$ali</code> are used. </p>
</td></tr>
<tr><td><code id="pdb2aln.ind_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code><a href="#topic+pdb2aln">pdb2aln</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Call <code><a href="#topic+pdb2aln">pdb2aln</a></code> to align the sequence of <code>pdb</code> to <code>aln</code>.
Then, find the atomic indices of C-alpha atoms in <code>pdb</code> that are 
equivalent to <code>inds</code>, the subset of column indices of <code>aln$ali</code>. 
</p>
<p>The function is a rountine utility in a combined analysis of 
molecular dynamics (MD) simulation trajectories and crystallographic 
structures. For example, a typical post-analysis of MD simulation is to 
compare the principal components (PCs) derived from simulation trajectories 
with those derived from crystallographic structures. The C-alpha atoms used
to fit trajectories and do PCA must be the same (or equivalent) to those
used in the analysis of crystallographic structures, e.g. the 'non-gap'  
alignment positions. Call <code>pdb2aln.ind</code> with providing relevant
alignment positions, one can easily get equivalent atom selections 
('select' class objects) for the simulation topology (PDB) file and then
do proper trajectory analysis. 
</p>


<h3>Value</h3>

<p>Returns a list containing two &quot;select&quot; objects:
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p> atom and xyz indices for the alignment. </p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p> atom and xyz indices for the PDB. </p>
</td></tr>
</table>
<p>Note that if any element of <code>inds</code> has no corresponding CA atom in the 
PDB, the output <code>a$atom</code> and <code>b$atom</code> will be shorter than 
<code>inds</code>, i.e. only indices having equivalent CA atoms are returned. 
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao, Lars Skjaerven &amp; Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seq2aln">seq2aln</a></code>, <code><a href="#topic+seqaln.pair">seqaln.pair</a></code>,
<code><a href="#topic+pdb2aln">pdb2aln</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##--- Read aligned PDB coordinates (CA only)
aln  &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))
pdbs &lt;- read.fasta.pdb(aln)

##--- Read the topology file of MD simulations
##--- For illustration, here we read another pdb file (all atoms)
pdb &lt;- read.pdb("2kin")

#--- Map the non-gap positions to PDB C-alpha atoms
#pc.inds &lt;- gap.inspect(pdbs$ali)
#npc.inds &lt;- pdb2aln.ind(aln=pdbs, pdb=pdb, inds=pc.inds$f.inds)

#npc.inds$a
#npc.inds$b

#--- Or, map the non-gap positions with a known close sequence in the alignment
#npc.inds &lt;- pdb2aln.ind(aln=pdbs, pdb=pdb, aln.id="1bg2", inds=pc.inds$f.inds)

#--- Map core positions
core &lt;- core.find(pdbs)
core.inds &lt;- pdb2aln.ind(aln=pdbs, pdb=pdb, inds = core$c1A.atom)

core.inds$a
core.inds$b

##--- Fit simulation trajectories to one of the X-ray structures based on
##--- core positions
#xyz &lt;- fit.xyz(pdbs$xyz[1,], pdb$xyz, core.inds$a$xyz, core.inds$b$xyz)

##--- Do PCA of trajectories based on non-gap positions
#pc.traj &lt;- pca(xyz[, npc.inds$b$xyz])


## End(Not run)

</code></pre>

<hr>
<h2 id='pdb2sse'>Obtain An SSE Sequence Vector From A PDB Object</h2><span id='topic+pdb2sse'></span>

<h3>Description</h3>

<p>Results are similar to that returned by stride(pdb)$sse and dssp(pdb)$sse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb2sse(pdb, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb2sse_+3A_pdb">pdb</code></td>
<td>
<p>an object of class <code>pdb</code> as obtained from
function <code><a href="#topic+read.pdb">read.pdb</a></code>.</p>
</td></tr>
<tr><td><code id="pdb2sse_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE warnings and other messages will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>call for its effects.
</p>


<h3>Value</h3>

<p>a character vector indicating SSE elements for each amino acide residue.
The 'names' attribute of the vector contains 'resno', 'chain', 'insert', and
'SSE segment number', seperated by the character '_'.
</p>


<h3>Author(s)</h3>

<p>Barry Grant &amp; Xin-Qiu Yao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code>, <code><a href="#topic+bounds.sse">bounds.sse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   #PDB server connection required - testing excluded

   pdb &lt;- read.pdb("1a7l")
   sse &lt;- pdb2sse(pdb)
   sse
 
</code></pre>

<hr>
<h2 id='pdbaln'> Sequence Alignment of PDB Files </h2><span id='topic+pdbaln'></span>

<h3>Description</h3>

<p>Create multiple sequences alignments from a list of PDB files
returning aligned sequence and structure records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdbaln(files, fit = FALSE, pqr = FALSE, ncore = 1,
       nseg.scale = 1, progress = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdbaln_+3A_files">files</code></td>
<td>
<p> a character vector of PDB file names. Alternatively, a
list of <code>pdb</code> objects can be provided. </p>
</td></tr>
<tr><td><code id="pdbaln_+3A_fit">fit</code></td>
<td>
<p> logical, if TRUE coordinate superposition is performed on
the input structures. </p>
</td></tr>
<tr><td><code id="pdbaln_+3A_pqr">pqr</code></td>
<td>
<p> logical, if TRUE the input structures are assumed to be in
PQR format. </p>
</td></tr>
<tr><td><code id="pdbaln_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="pdbaln_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="pdbaln_+3A_progress">progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td></tr>
<tr><td><code id="pdbaln_+3A_...">...</code></td>
<td>
<p> extra arguments passed to <code>seqaln</code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This wrapper function calls the underlying functions <code>read.pdb</code>,
<code>pdbseq</code>, <code>seqaln</code> and <code>read.fasta.pdb</code> returning a
list of class <code>"pdbs"</code> similar to that returned by
<code>read.fasta.pdb</code>.
</p>
<p>As these steps are often error prone it is recomended for most cases that
the individual underlying functions are called in sequence with checks
made on the valadity of their respective outputs to ensure sensible
results.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdbs"</code> with the following five
components:
</p>
<table>
<tr><td><code>xyz</code></td>
<td>
<p>numeric matrix of aligned C-alpha coordinates.</p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p>character matrix of aligned residue numbers.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric matrix of aligned B-factor values.</p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p>character matrix of aligned chain identifiers.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>character vector of PDB sequence/structure names.</p>
</td></tr>
<tr><td><code>ali</code></td>
<td>
<p>character matrix of aligned sequences.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> See recommendation in details section above. </p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+pdbseq">pdbseq</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code>,<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+core.find">core.find</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code>, <code><a href="#topic+read.all">read.all</a></code>,
<code><a href="#topic+pymol.pdbs">pymol.pdbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##- Align PDBs (from vector of filenames)
#files &lt;- get.pdb(c("4q21","5p21"), URLonly=TRUE)
files &lt;- get.pdb(c("4q21","5p21"), path=tempdir(), overwrite=TRUE)
pdbaln(files)


##- Align PDBs (from list of existing PDB objects)
pdblist &lt;- list(read.pdb(files[1]), read.pdb(files[2]))
pdbaln(pdblist)


## End(Not run)
</code></pre>

<hr>
<h2 id='pdbfit'> PDB File Coordinate Superposition </h2><span id='topic+pdbfit'></span><span id='topic+pdbfit.pdb'></span><span id='topic+pdbfit.pdbs'></span>

<h3>Description</h3>

<p> Protein Databank Bank file coordinate superposition with
the Kabsch algorithm. </p>


<h3>Usage</h3>

<pre><code class='language-R'>
pdbfit(...)

## S3 method for class 'pdb'
pdbfit(pdb, inds = NULL, ...)

## S3 method for class 'pdbs'
pdbfit(pdbs, inds = NULL, outpath = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdbfit_+3A_pdb">pdb</code></td>
<td>
<p> a multi-model pdb object of class <code>"pdb"</code>, as
obtained from <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="pdbfit_+3A_pdbs">pdbs</code></td>
<td>
<p> a list of class <code>"pdbs"</code> containing PDB file
data, as obtained from <code>read.fasta.pdb</code> or
<code>pdbaln</code>. </p>
</td></tr>
<tr><td><code id="pdbfit_+3A_inds">inds</code></td>
<td>
<p> a list object with a &lsquo;xyz&rsquo; component with indices
that selects the coordinate  positions (in terms of x, y and z
elements) upon which fitting should be based. This defaults to all
equivalent non-gap positions for function <code>pdbfit.pdbs</code>, and to
all calpha atoms for function <code>pdbfit.pdb</code>. </p>
</td></tr>
<tr><td><code id="pdbfit_+3A_outpath">outpath</code></td>
<td>
<p> character string specifing the output directory for
optional coordinate file output. Note that full files (i.e. all atom
files) are written, seebelow. </p>
</td></tr>
<tr><td><code id="pdbfit_+3A_...">...</code></td>
<td>
<p> extra arguments passed to <code>fit.xyz</code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pdbfit</code> is a wrapper for the function
<code>fit.xyz</code>, wherein full details of the superposition procedure
are documented.
</p>
<p>Input to <code>pdbfit.pdbs</code> should be a list object obtained with the
function <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or <code><a href="#topic+pdbaln">pdbaln</a></code>.  See
the examples below.
</p>
<p>For function <code>pdbfit.pdb</code> the input should be a multi-model
<code>pdb</code> object with multiple (&gt;1) frames in the &lsquo;xyz&rsquo;
component. 
</p>
<p>The reference frame for supperposition (i.e. the fixed structure to
which others are superposed) is the first entry in the input
<code>"pdbs"</code> object. For finer control use <code><a href="#topic+fit.xyz">fit.xyz</a></code>.
</p>


<h3>Value</h3>

<p>Returns moved coordinates.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>Kabsch <em>Acta Cryst</em> (1978) <b>A34</b>, 827&ndash;828.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+fit.xyz">fit.xyz</a></code>, <code><a href="#topic+rmsd">rmsd</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#files &lt;- get.pdb(c("4q21","5p21"), URLonly=TRUE)
files &lt;- get.pdb(c("4q21","5p21"), path=tempdir(), overwrite=TRUE)
pdbs &lt;- pdbaln(files)
xyz &lt;- pdbfit(pdbs)

# Superpose again this time outputing all-atom PDBs to disc
#xyz &lt;- pdbfit( pdbs, outpath="fitted" )

## End(Not run)
</code></pre>

<hr>
<h2 id='pdbs2pdb'> PDBs to PDB Converter </h2><span id='topic+pdbs2pdb'></span>

<h3>Description</h3>

<p>Convert a list of PDBs from an <code>"pdbs"</code> object to a list of
<code>pdb</code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdbs2pdb(pdbs, inds = NULL, rm.gaps = FALSE, all.atom=FALSE, ncore=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdbs2pdb_+3A_pdbs">pdbs</code></td>
<td>
<p> a list of class <code>"pdbs"</code> containing PDB file
data, as obtained from <code>read.fasta.pdb</code>,
<code>pdbaln</code>, or <code>read.all</code>. </p>
</td></tr>
<tr><td><code id="pdbs2pdb_+3A_inds">inds</code></td>
<td>
<p> a vector of indices that selects the PDB structures to
convert. </p>
</td></tr>
<tr><td><code id="pdbs2pdb_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE atoms in gap containing columns are
removed in the output <code>pdb</code> objects. </p>
</td></tr>
<tr><td><code id="pdbs2pdb_+3A_all.atom">all.atom</code></td>
<td>
<p> logical, if TRUE all atom data are converted (the 
&lsquo;pdbs&rsquo; object must be obtained from <code>read.all</code> or 
<code>pdbs$id</code> refers to existing PDB files). </p>
</td></tr>
<tr><td><code id="pdbs2pdb_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will generate a list of <code>pdb</code> objects from a
<code>"pdbs"</code> class.
</p>
<p>See examples for more details/
</p>


<h3>Value</h3>

<p>Returns a list of <code>pdb</code> objects.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+pdbaln">pdbaln</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Fetch PDBs
pdb.ids &lt;- c("1YX5_B", "3NOB", "1P3Q_U")
#outdir &lt;- paste(tempdir(), "/raw_pdbs", sep="")
outdir = "raw_pdbs"
raw.files &lt;- get.pdb(pdb.ids, path = outdir)

## Split PDBs by chain ID and multi-model records
all.files &lt;- pdbsplit(raw.files, pdb.ids, 
                path =paste(outdir, "/split_chain", sep=""))

## Align and fit
pdbs     &lt;- pdbaln(all.files, fit=TRUE)

## Convert back to PDB objects
all.pdbs &lt;- pdbs2pdb(pdbs)

## Access the first PDB object
## all.pdbs[[1]]

## Return PDB objects consisting of only
## atoms in non-gap positions
all.pdbs &lt;- pdbs2pdb(pdbs, rm.gaps=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='pdbs2sse'> SSE annotation for a PDBs Object </h2><span id='topic+pdbs2sse'></span>

<h3>Description</h3>

<p>Returns secondary structure element (SSE) annotation (<code>"sse"</code> object) for a structure in the provided <code>"pdbs"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdbs2sse(pdbs, ind = NULL, rm.gaps = TRUE, resno = TRUE, pdb = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdbs2sse_+3A_pdbs">pdbs</code></td>
<td>
<p> a list of class <code>"pdbs"</code> containing PDB file
data, as obtained from <code>read.fasta.pdb</code> or
<code>pdbaln</code>. </p>
</td></tr>
<tr><td><code id="pdbs2sse_+3A_ind">ind</code></td>
<td>
<p> numeric index pointing to the PDB in which the SSE should
be provided. If <code>ind=NULL</code>, then the consensus SSE is returned. </p>
</td></tr>
<tr><td><code id="pdbs2sse_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE SSEs spanning gap containing columns are
omitted from the output in the resulting <code>sse</code> object. </p>
</td></tr>
<tr><td><code id="pdbs2sse_+3A_resno">resno</code></td>
<td>
<p> logical, if TRUE output is in terms of residue numbers
rather than residue index (position in sequence). </p>
</td></tr>
<tr><td><code id="pdbs2sse_+3A_pdb">pdb</code></td>
<td>
<p> logical, if TRUE function <code>dssp</code> will be called on
the corresponding <code>pdb</code> object rather than to use <code>pdbs$sse</code> to
obtain the SSE object. </p>
</td></tr>
<tr><td><code id="pdbs2sse_+3A_...">...</code></td>
<td>
<p> arguments passed to function <code>dssp</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a <code>"sse"</code> list object containing
secondary structure elements (SSE) annotation data for a particular
structure in the provided <code>"pdbs"</code> object. Residue numbers are
provided relative to the alignment in the <code>"pdbs"</code> object.
</p>
<p>When <code>ind=NULL</code> the function will attemt to return the consensus
SSE annotation, i.e. where there are SSEs across all structures. This
will only work SSE data is found in the <code>"pdbs"</code> object.
</p>
<p>See examples for more details.
</p>


<h3>Value</h3>

<p>Returns a list object of class <code>sse</code>.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+pdbaln">pdbaln</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
attach(transducin)

## calculate RMSF
rf &lt;- rmsf(pdbs$xyz)

## Fetch SSE annotation, output in terms of alignment index
sse &lt;- pdbs2sse(pdbs, ind=1, rm.gaps=FALSE, resno=FALSE)

## Add SSE annotation to plot
plotb3(rf, sse=sse)


## Calculate RMSF only for non-gap columns
gaps.pos &lt;- gap.inspect(pdbs$xyz)
rf &lt;- rmsf(pdbs$xyz[, gaps.pos$f.inds])

## With gap columns removed, output in terms of residue number
sse &lt;- pdbs2sse(pdbs, ind=1, rm.gaps=TRUE, resno=TRUE)
gaps.res &lt;- gap.inspect(pdbs$ali)
plotb3(rf, sse=sse, resno=pdbs$resno[1, gaps.res$f.inds])

detach(transducin)

## End(Not run)
</code></pre>

<hr>
<h2 id='pdbseq'> Extract The Aminoacid Sequence From A PDB Object </h2><span id='topic+pdbseq'></span>

<h3>Description</h3>

<p>Return a vector of the one-letter IUPAC or three-letter PDB
style aminoacid codes from a given PDB object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdbseq(pdb, inds = NULL, aa1 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdbseq_+3A_pdb">pdb</code></td>
<td>
<p>a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="pdbseq_+3A_inds">inds</code></td>
<td>
<p> a list object of ATOM and XYZ indices as obtained from
<code><a href="#topic+atom.select">atom.select</a></code>. </p>
</td></tr>
<tr><td><code id="pdbseq_+3A_aa1">aa1</code></td>
<td>
<p> logical, if TRUE then the one-letter IUPAC sequence is
returned. IF FALSE then the three-letter PDB style sequence is
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the examples below and the functions <code><a href="#topic+atom.select">atom.select</a></code> and <code><a href="#topic+aa321">aa321</a></code>
for further details.
</p>


<h3>Value</h3>

<p>A character vector of aminoacid codes.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of IUPAC one-letter codes see:<br />
<a href="https://www.insdc.org/documents/feature_table.html#7.4.3">https://www.insdc.org/documents/feature_table.html#7.4.3</a>
</p>
<p>For more information on PDB residue codes see:<br />
<a href="http://ligand-expo.rcsb.org/ld-search.html">http://ligand-expo.rcsb.org/ld-search.html</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+aa321">aa321</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pdb &lt;- read.pdb( "5p21" )
pdbseq(pdb)

#pdbseq(pdb, inds=atom.select(pdb, resno=5:15, elety="CA"), aa1=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pdbsplit'> Split a PDB File Into Separate Files, One For Each Chain. </h2><span id='topic+pdbsplit'></span>

<h3>Description</h3>

<p>Split a Protein Data Bank (PDB) coordinate file into new separate
files with one file for each chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdbsplit(pdb.files, ids = NULL, path = "split_chain", overwrite=TRUE,
         verbose = FALSE, mk4=FALSE, ncore = 1, progress = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdbsplit_+3A_pdb.files">pdb.files</code></td>
<td>
<p> a character vector of PDB file names. </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_ids">ids</code></td>
<td>
<p> a character vector of PDB and chain identifiers
(of the form: &lsquo;pdbId_chainId&rsquo;, e.g. &lsquo;1bg2_A&rsquo;). 
Used for filtering chain IDs for output (in the above example only 
chain A would be produced). </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_path">path</code></td>
<td>
<p> output path for chain-split files. </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_overwrite">overwrite</code></td>
<td>
<p> logical, if FALSE the PDB structures will not be
read and written if split files already exist. </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the PDB header and
chain selections are printed. </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_mk4">mk4</code></td>
<td>
<p> logical, if TRUE output filenames will use only the first
four characters of the input filename (see <code>basename.pdb</code> for details).  </p>
</td></tr>   
<tr><td><code id="pdbsplit_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used for the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; be installed. </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_progress">progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td></tr>
<tr><td><code id="pdbsplit_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>read.pdb</code>. Useful e.g. for
parsing multi model PDB files, including ALT records etc. in the
output files. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will produce single chain PDB files from multi-chain
input files. By default all separate filenames are returned. To return 
only a subset of select chains the optional input &lsquo;ids&rsquo; can be 
provided to filter the output (e.g. to fetch only chain C, of a PDB 
object with additional chains A+B ignored). See examples section for 
further details.
</p>
<p>Note that multi model atom records will only split into individual 
PDB files if <code>multi=TRUE</code>, else they are omitted. See examples.
</p>


<h3>Value</h3>

<p>Returns a character vector of chain-split file names.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+write.pdb">write.pdb</a></code>, <code><a href="#topic+get.pdb">get.pdb</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## Save separate PDB files for each chain of a local or on-line file
  pdbsplit( get.pdb("2KIN", URLonly=TRUE) )


  ## Split several PDBs by chain ID and multi-model records
  raw.files &lt;- get.pdb( c("1YX5", "3NOB") , URLonly=TRUE)
  chain.files &lt;- pdbsplit(raw.files,  path=tempdir(), multi=TRUE)
  basename(chain.files)


  ## Output only desired pdbID_chainID combinations
  ## for the last entry (1f9j), fetch all chains
  ids &lt;- c("1YX5_A", "3NOB_B", "1F9J")
  raw.files &lt;- get.pdb( ids , URLonly=TRUE)
  chain.files &lt;- pdbsplit(raw.files, ids, path=tempdir())
  basename(chain.files)

## End(Not run)
</code></pre>

<hr>
<h2 id='pfam'> Download Pfam FASTA Sequence Alignment </h2><span id='topic+pfam'></span>

<h3>Description</h3>

<p>Downloads FASTA sequence alignment from the Pfam database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfam(id, alignment = "seed", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfam_+3A_id">id</code></td>
<td>
<p> the Pfam familiy identifier (e.g &lsquo;Piwi&rsquo;) or accession
(e.g. &lsquo;PF02171&rsquo;). </p>
</td></tr> 
<tr><td><code id="pfam_+3A_alignment">alignment</code></td>
<td>
<p> the alignment type. Allowed values are:
&lsquo;seed&rsquo;, &lsquo;ncbi&rsquo;, &lsquo;full&rsquo;,
&lsquo;metagenomics&rsquo;. </p>
</td></tr>
<tr><td><code id="pfam_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE details of the download process
is printed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic function to download a multiple sequence alignment for
a protein family from the Pfam database. 
</p>


<h3>Value</h3>

<p>A &lsquo;fasta&rsquo; object with the following components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p> sequence names as identifiers. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Full more information on the Pfam database:<br />
<a href="http://pfam.xfam.org">http://pfam.xfam.org</a>
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+hmmer">hmmer</a></code>, <code><a href="#topic+get.seq">get.seq</a></code>,
<code><a href="#topic+uniprot">uniprot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# PFAM server connection required - testing excluded

aln &lt;- pfam("piwi")
aln &lt;- pfam("PF02171")

seq &lt;- get.seq("1rx2_A", outfile = tempfile())
hmm &lt;- hmmer(seq, type="hmmscan", db="pfam")
aln &lt;- pfam(hmm$hit.tbl$acc[1])

# Or much more simply for RCSB PDB entries:
acc &lt;- pdb.pfam("1rx2_A", compact=FALSE)$pfamAcc
aln &lt;- pfam(acc)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bio3d'> Plots with marginal SSE annotation </h2><span id='topic+plot.bio3d'></span><span id='topic+plotb3'></span>

<h3>Description</h3>

<p>Draw a standard scatter plot with optional secondary structure in the
marginal regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotb3(x, resno = NULL, rm.gaps = FALSE, type = "h",
             main = "", sub = "",
             xlim = NULL, ylim = NULL, ylim2zero = TRUE,
             xlab = "Residue", ylab = NULL, 
             axes = TRUE, ann = par("ann"), col = par("col"),
             sse = NULL, sse.type="classic", sse.min.length=5,
             top = TRUE, bot = TRUE, 
             helix.col = "gray20", sheet.col = "gray80",
             sse.border = FALSE, ...)

             ## S3 method for class 'bio3d'
plot(...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bio3d_+3A_x">x</code></td>
<td>
<p> a numeric vector of values to be plotted.  Any reasonable way of
defining these plot coordinates is acceptable.  See the function
&lsquo;xy.coords&rsquo; for details. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_resno">resno</code></td>
<td>
<p> an optional vector with length equal to that of
&lsquo;x&rsquo; that will be used to annotate the xaxis. This is typically
a vector of residue numbers. If NULL residue positions from 1 to the
length of &lsquo;x&rsquo; will be used. See examples below. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_rm.gaps">rm.gaps</code></td>
<td>
<p> logical, if TRUE gaps in <code>x</code>, indicated by NA values,
will be removed from plot. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_type">type</code></td>
<td>
<p> one-character string giving the type of plot desired.  The
following values are possible, (for details, see &lsquo;plot&rsquo;): &lsquo;p&rsquo;
for points, &lsquo;l&rsquo; for lines, &lsquo;o&rsquo; for over-plotted points and
lines, &lsquo;b&rsquo;, &lsquo;c&rsquo;) for points joined by lines,
&lsquo;s&rsquo; and &lsquo;S&rsquo; for stair steps and &lsquo;h&rsquo; for
histogram-like vertical lines.  Finally, &lsquo;n&rsquo; does not produce
any points or lines. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_main">main</code></td>
<td>
<p> a main title for the plot, see also &lsquo;title&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_sub">sub</code></td>
<td>
<p> a sub-title for the plot. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_xlim">xlim</code></td>
<td>
<p> the x limits (x1,x2) of the plot.  Note that x1 &gt; x2 is
allowed and leads to a reversed axis. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_ylim">ylim</code></td>
<td>
<p> the y limits of the plot. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_ylim2zero">ylim2zero</code></td>
<td>
<p> logical, if TRUE the y-limits are forced to start at zero. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis, defaults to a description of &lsquo;x&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_ylab">ylab</code></td>
<td>
<p> a label for the y axis, defaults to a description of &lsquo;y&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_axes">axes</code></td>
<td>
<p> a logical value indicating whether both axes should be drawn
on the plot.  Use graphical parameter &lsquo;xaxt&rsquo; or
&lsquo;yaxt&rsquo; to suppress just one of the axes. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_ann">ann</code></td>
<td>
<p> a logical value indicating whether the default annotation
(title and x and y axis labels) should appear on the plot. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_col">col</code></td>
<td>
<p> The colors for lines and points.  Multiple colors can be
specified so that each point is given its own color.  If there are
fewer colors than points they are recycled in the standard fashion.
Lines are plotted in the first color specified. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_sse">sse</code></td>
<td>
<p> secondary structure object as returned from
<code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code> or in certain cases
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_sse.type">sse.type</code></td>
<td>
<p> single element character vector that determines the
type of secondary structure annotation drawn. The following values
are possible, &lsquo;classic&rsquo; and &lsquo;fancy&rsquo;. See details and 
examples below. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_sse.min.length">sse.min.length</code></td>
<td>
<p> a single numeric value giving the length below
which secondary structure elements will not be drawn. This is useful
for the exclusion of short helix and strand regions that can often crowd
these forms of plots. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_top">top</code></td>
<td>
<p> logical, if TRUE rectangles for each sse are drawn towards
the top of the plotting region.  </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_bot">bot</code></td>
<td>
<p> logical, if TRUE rectangles for each sse are drawn towards
the bottom of the plotting region. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_helix.col">helix.col</code></td>
<td>
<p> The colors for rectangles representing alpha helices. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_sheet.col">sheet.col</code></td>
<td>
<p> The colors for rectangles representing beta strands. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_sse.border">sse.border</code></td>
<td>
<p> The border color for all sse rectangles. </p>
</td></tr>
<tr><td><code id="plot.bio3d_+3A_...">...</code></td>
<td>
<p> other graphical parameters. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for plotting per-residue numeric vectors for a
given protein structure (e.g. results from RMSF, PCA, NMA etc.) along
with a schematic representation of major secondary structure elements.
</p>
<p>Two forms of secondary structure annotation are available: so called
&lsquo;classic&rsquo; and &lsquo;fancy&rsquo;. The former draws marginal
rectangles and has been available within Bio3D from version 0.1. The
later draws more &lsquo;fancy&rsquo; (and distracting) 3D like helices and
arrowed strands.
</p>
<p>See the functions &lsquo;plot.default&rsquo;, <code><a href="#topic+dssp">dssp</a></code> and <code><a href="#topic+stride">stride</a></code> 
for further details.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p> Be sure to check the correspondence of your &lsquo;sse&rsquo; object with the
&lsquo;x&rsquo; values being plotted as no internal checks are performed.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

## Plot of B-factor values along with secondary structure from PDB
pdb &lt;- read.pdb( "1bg2" )
bfac &lt;- pdb$atom[pdb$calpha,"b"]
plot.bio3d(bfac, sse=pdb, ylab="B-factor", col="gray")
points(bfac, typ="l")


## Not run: 
## Use PDB residue numbers and include short secondary structure elements
plot.bio3d(pdb$atom[pdb$calpha,"b"], sse=pdb, resno=pdb, ylab="B-factor",
  typ="l", lwd=1.5, col="blue", sse.min.length=0)


## Calculate secondary structure using stride() or dssp()
#sse &lt;- stride(pdb)
sse &lt;- dssp(pdb)

## Plot of B-factor values along with calculated secondary structure
plot.bio3d(pdb$atom[pdb$calpha,"b"], sse=sse, ylab="B-factor", typ="l",
col="blue", lwd=2)

## End(Not run)


# PDB server connection required - testing excluded

## Plot 'aligned' data respecting gap positions
attach(transducin)

pdb = read.pdb("1tnd") ## Reference PDB see: pdbs$id[1]
pdb = trim.pdb(pdb, inds=atom.select(pdb, chain="A"))

## Plot of B-factor values with gaps
plot.bio3d(pdbs$b, resno=pdb, sse=pdb, ylab="B-factor")

## Plot of B-factor values after removing all gaps 
plot.bio3d(pdbs$b, rm.gaps=TRUE, resno = pdb, sse=pdb, ylab="B-factor")

detach(transducin)


## Fancy secondary structure elements
##plot.bio3d(pdb$atom[pdb$calpha,"b"], sse=pdb, ssetype="fancy")
## Currently not implemented
</code></pre>

<hr>
<h2 id='plot.cmap'> Plot Contact Matrix </h2><span id='topic+plot.cmap'></span>

<h3>Description</h3>

<p>Plot a contact matrix with optional secondary structure in the
marginal regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmap'
plot(x, col=2, pch=16, main="Contact map", sub="",
           xlim=NULL, ylim=NULL, xlab = "Residue index", ylab = xlab, 
           axes=TRUE, ann=par("ann"), sse=NULL, sse.type="classic",
           sse.min.length=5, bot=TRUE, left=TRUE,
           helix.col="gray20", sheet.col="gray80", sse.border=FALSE,
           add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cmap_+3A_x">x</code></td>
<td>
<p> a numeric matrix of residue contacts as obtained from
function <code>cmap</code>. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_col">col</code></td>
<td>
<p> color code or name, see <code>par</code>. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_pch">pch</code></td>
<td>
<p> plotting &lsquo;character&rsquo;, i.e., symbol to use. This can
either be a single character or an integer code for one of a set of
graphics symbols. See <code>points</code>. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_main">main</code></td>
<td>
<p> a main title for the plot, see also &lsquo;title&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_sub">sub</code></td>
<td>
<p> a sub-title for the plot. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_xlim">xlim</code></td>
<td>
<p> the x limits (x1,x2) of the plot.  Note that x1 &gt; x2 is
allowed and leads to a reversed axis. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_ylim">ylim</code></td>
<td>
<p> the y limits of the plot. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis, defaults to a description of &lsquo;x&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_ylab">ylab</code></td>
<td>
<p> a label for the y axis, defaults to a description of &lsquo;y&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_axes">axes</code></td>
<td>
<p> a logical value indicating whether both axes should be drawn
on the plot.  Use graphical parameter &lsquo;xaxt&rsquo; or
&lsquo;yaxt&rsquo; to suppress just one of the axes. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_ann">ann</code></td>
<td>
<p> a logical value indicating whether the default annotation
(title and x and y axis labels) should appear on the plot. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_sse">sse</code></td>
<td>
<p> secondary structure object as returned from
<code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code> or in certain cases
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_sse.type">sse.type</code></td>
<td>
<p> single element character vector that determines the
type of secondary structure annotation drawn. The following values
are possible, &lsquo;classic&rsquo; and &lsquo;fancy&rsquo;. See details and 
examples below. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_sse.min.length">sse.min.length</code></td>
<td>
<p> a single numeric value giving the length below
which secondary structure elements will not be drawn. This is useful
for the exclusion of short helix and strand regions that can often crowd
these forms of plots. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_left">left</code></td>
<td>
<p> logical, if TRUE rectangles for each sse are drawn towards
the left of the plotting region.  </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_bot">bot</code></td>
<td>
<p> logical, if TRUE rectangles for each sse are drawn towards
the bottom of the plotting region. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_helix.col">helix.col</code></td>
<td>
<p> The colors for rectangles representing alpha helices. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_sheet.col">sheet.col</code></td>
<td>
<p> The colors for rectangles representing beta strands. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_sse.border">sse.border</code></td>
<td>
<p> The border color for all sse rectangles. </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_add">add</code></td>
<td>
<p> logical, specifying if the contact map should be added to an
already existing plot. Note that when &lsquo;TRUE&rsquo; only points are
plotted (no annotation). </p>
</td></tr>
<tr><td><code id="plot.cmap_+3A_...">...</code></td>
<td>
<p> other graphical parameters. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for plotting a residue-residue contact data
for a given protein structure along with a schematic representation of
major secondary structure elements. 
</p>
<p>Two forms of secondary structure annotation are available: so called
&lsquo;classic&rsquo; and &lsquo;fancy&rsquo;. The former draws marginal
rectangles and has been available within Bio3D from version 0.1. The
later draws more &lsquo;fancy&rsquo; (and distracting) 3D like helices and
arrowed strands.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p> Be sure to check the correspondence of your &lsquo;sse&rsquo; object with the
&lsquo;x&rsquo; values being plotted as no internal checks are performed.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven, Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmap">cmap</a></code>, <code><a href="#topic+dm">dm</a></code>,
<code><a href="#topic+plot.dmat">plot.dmat</a></code>, 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="#topic+plot.bio3d">plot.bio3d</a></code>,
<code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##- Read PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

##- Calcualte contact map
cm &lt;- cmap(pdb)

##- Plot contact map
plot.cmap(cm, sse=pdb)

##- Add to plot
plot.cmap(t(cm), col=3, pch=17, add=TRUE)

</code></pre>

<hr>
<h2 id='plot.cna'> Protein Structure Network Plots in 2D and 3D.  </h2><span id='topic+plot.cna'></span><span id='topic+plot.ecna'></span>

<h3>Description</h3>

<p>Plot a protein dynamic network as obtained from the <em>cna</em> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'cna'
plot(x, pdb = NULL, weights=NULL, vertex.size=NULL,
            layout=NULL, col=NULL, full=FALSE, scale=TRUE, color.edge = FALSE, 
            interactive=FALSE, ...)
  ## S3 method for class 'ecna'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cna_+3A_x">x</code></td>
<td>
<p> A protein network graph object (or a list of such objects) as obtained from the
&lsquo;cna&rsquo; function. </p>
</td></tr>
<tr><td><code id="plot.cna_+3A_pdb">pdb</code></td>
<td>
<p> A PDB structure object obtained from &lsquo;read.pdb&rsquo;. 
If supplied this will be used to guide the network plot &lsquo;layout&rsquo;, 
see &lsquo;layout.cna&rsquo; for details. </p>
</td></tr>    
<tr><td><code id="plot.cna_+3A_weights">weights</code></td>
<td>
<p> A numeric vector containing the edge weights for the
network. </p>
</td></tr>
<tr><td><code id="plot.cna_+3A_vertex.size">vertex.size</code></td>
<td>
<p> A numeric vector of node/community sizes. If NULL
the size will be taken from the input network graph object &lsquo;x&rsquo;. 
Typically for &lsquo;full=TRUE&rsquo; nodes will be of an equal size and 
for &lsquo;full=FALSE&rsquo; community node size will be proportional to 
the residue membership of each community. </p>
</td></tr>
<tr><td><code id="plot.cna_+3A_layout">layout</code></td>
<td>
<p> Either a function or a numeric matrix. It specifies how the
vertices will be placed on the plot. See &lsquo;layout.cna&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.cna_+3A_col">col</code></td>
<td>
<p> A vector of colors used for node/vertex rendering. If NULL
these values are taken from the input network
&lsquo;V(x$community.network)$color&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.cna_+3A_full">full</code></td>
<td>
<p> Logical, if TRUE the full all-atom network rather than the 
clustered community network will be plotted. </p>
</td></tr>    
<tr><td><code id="plot.cna_+3A_scale">scale</code></td>
<td>
<p> Logical, if TRUE weights are scaled with respect to the network. </p>
</td></tr>   
<tr><td><code id="plot.cna_+3A_color.edge">color.edge</code></td>
<td>
<p> Logical, if TRUE edges are colored with respect to their weights. </p>
</td></tr>   
<tr><td><code id="plot.cna_+3A_interactive">interactive</code></td>
<td>
<p> Logical, if TRUE interactive graph will be drawn where users
can manually adjust the network (positions of vertices, colors of edges, etc.).
Needs Tcl/Tk support in the installed R build. </p>
</td></tr>
<tr><td><code id="plot.cna_+3A_...">...</code></td>
<td>
<p> Additional graphical parameters for &lsquo;plot.igraph&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls &lsquo;plot.igraph&rsquo; from the igraph package to 
plot cna networks the way we like them.
</p>
<p>The plot layout is user settable, we like the options of: 
&lsquo;layout.cna&rsquo;, &lsquo;layout.fruchterman.reingold&rsquo;,  
&lsquo;layout.mds&rsquo; or &lsquo;layout.svd&rsquo;. Note that first of these 
uses PDB structure information to produce a more meaningful layout.
</p>
<p>Extensive plot modifications are possible by setting additional graphical 
parameters (...). These options are detailed in &lsquo;igraph.plotting&rsquo;. 
Common parameters to alter include:
</p>

<dl>
<dt>vertex.label:</dt><dd><p>Node labels, <code>V(x$network)$name</code>. Use NA to omit.</p>
</dd>
<dt>vertex.label.color:</dt><dd><p>Node label colors, see also <code>vertex.label.cex</code> etc. </p>
</dd>
<dt>edge.color:</dt><dd><p>Edge colors,  <code>E(x$network)$color</code>. </p>
</dd>
<dt>mark.groups:</dt><dd><p>Community highlighting, a community list object, see also <code>mark.col</code> etc.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Produces a network plot on the active graphics device.
Also returns the plot layout coordinates silently, which can be passed to the 
&lsquo;identify.cna&rsquo; function.
</p>


<h3>Note</h3>

<p> Be sure to check the correspondence of your &lsquo;pdb&rsquo; object with your
network object &lsquo;x&rsquo;, as few internal checks are currently performed by the 
&lsquo;layout.cna&rsquo; function.
</p>


<h3>Author(s)</h3>

<p> Barry Grant and Guido Scarabelli </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>, 
<code><a href="igraph.html#topic+communities">plot.communities</a></code>,
<code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

##-- Build a CNA object
pdb &lt;- read.pdb("4Q21")
modes &lt;- nma(pdb)
cij &lt;- dccm(modes)
net &lt;- cna(cij, cutoff.cij=0.2)

# Plot coarse grain network based on dynamically coupled communities
xy &lt;- plot.cna(net)
#plot.dccm(cij, margin.segments=net$communities$membership)

# Chose a different PDB informed layout for plot
plot.cna(net, pdb)

# Play with plot layout and colors...
plot.cna(net, layout=igraph::layout.mds(net$community.network), col=c("blue","green") ) 

# Plot full residue network colored by communities - will be slow due to number of edges!!
plot.cna(net, pdb, full=TRUE)

# Alter plot settings
plot.cna(net, pdb, full=TRUE, vertex.size=3, weights=1, vertex.label=NA)

}

</code></pre>

<hr>
<h2 id='plot.core'> Plot Core Fitting Progress </h2><span id='topic+plot.core'></span>

<h3>Description</h3>

<p>Plots the total ellipsoid volume of core positions versus core size at
each iteration of the core finding process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'core'
plot(x, y = NULL, type = "h", main = "", sub = "", 
   xlim = NULL, ylim = NULL, xlab = "Core Size (Number of Residues)", 
   ylab = "Total Ellipsoid Volume (Angstrom^3)", axes = TRUE, 
   ann = par("ann"), col = par("col"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.core_+3A_x">x</code></td>
<td>
<p>  a list object obtained with the function
<code><a href="#topic+core.find">core.find</a></code> from which the &lsquo;volume&rsquo;
component is taken as the x coordinates for the plot. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_y">y</code></td>
<td>
<p> the y coordinates for the plot. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_type">type</code></td>
<td>
<p> one-character string giving the type of plot desired. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_main">main</code></td>
<td>
<p> a main title for the plot, see also &lsquo;title&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_sub">sub</code></td>
<td>
<p> a sub-title for the plot. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_xlim">xlim</code></td>
<td>
<p> the x limits of the plot. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_ylim">ylim</code></td>
<td>
<p> the y limits of the plot. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_ylab">ylab</code></td>
<td>
<p> a label for the y axis. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_axes">axes</code></td>
<td>
<p> a logical value indicating whether both axes should be drawn. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_ann">ann</code></td>
<td>
<p> a logical value indicating whether the default annotation
(title and x and y axis labels) should appear on the plot. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_col">col</code></td>
<td>
<p> The colors for lines and points.  Multiple colours can be
specified so that each point is given its own color.  If there are
fewer colors than points they are recycled in the standard fashion. </p>
</td></tr>
<tr><td><code id="plot.core_+3A_...">...</code></td>
<td>
<p> extra plotting arguments. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>The produced plot can be useful for deciding on the core/non-core boundary.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+core.find">core.find</a></code>, <code><a href="#topic+print.core">print.core</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##-- Generate a small kinesin alignment and read corresponding structures
pdbfiles &lt;- get.pdb(c("1bg2","2ncd","1i6i","1i5s"), URLonly=TRUE)
pdbs &lt;- pdbaln(pdbfiles)

##-- Find 'core' positions
core &lt;- core.find(pdbs)
plot(core)

##-- Fit on these relatively invarient subset of positions 
core.inds &lt;- print(core)
xyz &lt;- pdbfit(pdbs, core.inds, outpath="corefit_structures")

##-- Compare to fitting on all equivalent positions
xyz2 &lt;- pdbfit(pdbs)

## Note that overall RMSD will be higher but RMSF will
##  be lower in core regions, which may equate to a
##  'better fit' for certain applications
gaps &lt;- gap.inspect(pdbs$xyz)
rmsd(xyz[,gaps$f.inds])
rmsd(xyz2[,gaps$f.inds])

plot(rmsf(xyz[,gaps$f.inds]), typ="l", col="blue", ylim=c(0,9))
points(rmsf(xyz2[,gaps$f.inds]), typ="l", col="red")


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.dccm'> DCCM Plot </h2><span id='topic+plot.dccm'></span>

<h3>Description</h3>

<p>Plot a dynamical cross-correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dccm'
plot(x, resno=NULL, sse=NULL, colorkey=TRUE,
                    at=c(-1, -0.75, -0.5,  -0.25, 0.25, 0.5, 0.75, 1),
                    main="Residue Cross Correlation",
                    helix.col = "gray20", sheet.col = "gray80",
                    inner.box=TRUE, outer.box=FALSE,
                    xlab="Residue No.", ylab="Residue No.",
                    margin.segments=NULL, segment.col=vmd_colors(), segment.min=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dccm_+3A_x">x</code></td>
<td>
<p> a numeric matrix of atom-wise cross-correlations as output by
the &lsquo;dccm&rsquo; function. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_resno">resno</code></td>
<td>
<p> an optional vector with length equal to that of
<code>x</code> that will be used to annotate the x- and y-axis. This is typically
a vector of residue numbers. Can be also provided with a &lsquo;pdb&rsquo; object,
in which &lsquo;resno&rsquo; of all C-alpha atoms will be used. If NULL residue 
positions from 1 to the length of <code>x</code> will be used. See examples below. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_sse">sse</code></td>
<td>
<p> secondary structure object as returned from
<code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code> or <code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_colorkey">colorkey</code></td>
<td>
<p> logical, if TRUE a key is plotted. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_at">at</code></td>
<td>
<p> numeric vector specifying the levels to be colored. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_main">main</code></td>
<td>
<p> a main title for the plot. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_helix.col">helix.col</code></td>
<td>
<p> The colors for rectangles representing alpha helices. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_sheet.col">sheet.col</code></td>
<td>
<p> The colors for rectangles representing beta strands. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_inner.box">inner.box</code></td>
<td>
<p> logical, if TRUE an outer box is drawn. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_outer.box">outer.box</code></td>
<td>
<p> logical, if TRUE an outer box is drawn. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis. </p>
</td></tr> 
<tr><td><code id="plot.dccm_+3A_ylab">ylab</code></td>
<td>
<p> a label for the y axis. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_margin.segments">margin.segments</code></td>
<td>
<p> a numeric vector of cluster membership as 
obtained from cutree() or other community detection method. This 
will be used for bottom and left margin annotation. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_segment.col">segment.col</code></td>
<td>
<p> a vector of colors used for each cluster group in 
margin.segments. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_segment.min">segment.min</code></td>
<td>
<p> a single element numeric vector that will cause 
margin.segments with a length below this value to be excluded from
the plot. </p>
</td></tr>
<tr><td><code id="plot.dccm_+3A_...">...</code></td>
<td>
<p> additional graphical parameters for contourplot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the &lsquo;contourplot&rsquo; function from the lattice package for plot customization options, and the functions <code><a href="#topic+dssp">dssp</a></code> and <code><a href="#topic+stride">stride</a></code> for further details.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p> Be sure to check the correspondence of your &lsquo;sse&rsquo; object with the
&lsquo;cij&rsquo; values being plotted as no internal checks are currently performed.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.bio3d">plot.bio3d</a></code>, <code><a href="#topic+plot.dmat">plot.dmat</a></code>,
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="graphics.html#topic+image">image</a></code> <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="#topic+dssp">dssp</a></code>,
<code><a href="#topic+stride">stride</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  ##-- Read example trajectory file
  trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
  trj &lt;- read.dcd(trtfile)

  ## Read reference PDB and trim it to match the trajectory
  pdb &lt;- trim(read.pdb("1W5Y"), 'calpha')

  ## select residues 24 to 27 and 85 to 90 in both chains
  inds &lt;- atom.select(pdb, resno=c(24:27,85:90))

  ## lsq fit of trj on pdb
  xyz &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=inds$xyz, mobile.inds=inds$xyz)

  ## Dynamic cross-correlations of atomic displacements
  cij &lt;- dccm(xyz)

  ## Default plot
  plot.dccm(cij)

  ## Change the color scheme and the range of colored data levels
  plot.dccm(cij, contour=FALSE, col.regions=bwr.colors(200), at=seq(-1,1,by=0.01) )

  ## Add secondary structure annotation to plot margins
  plot.dccm(cij, sse=pdb) 

  ## Add additional margin annotation for chains
  ## Also label x- and y-axis with PDB residue numbers
  ch &lt;- ifelse(pdb$atom$chain=="A", 1,2)
  plot.dccm(cij, resno=pdb, sse=pdb, margin.segments=ch)

  ## Plot with cluster annotation from dynamic network analysis
  #net &lt;- cna(cij)
  #plot.dccm(cij, margin.segments=net$raw.communities$membership)

  ## Focus on major communities (i.e. exclude those below a certain total length)
  #plot.dccm(cij, margin.segments=net$raw.communities$membership, segment.min=25)


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.dmat'> Plot Distance Matrix </h2><span id='topic+plot.dmat'></span>

<h3>Description</h3>

<p>Plot a distance matrix (DM) or a difference distance matrix (DDM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmat'
plot(x, key = TRUE, resnum.1 = c(1:ncol(x)), resnum.2 = resnum.1,
          axis.tick.space = 20, zlim = range(x, finite = TRUE),
          nlevels = 20, levels = pretty(zlim, nlevels),
          color.palette = bwr.colors,
          col = color.palette(length(levels) - 1),
          axes = TRUE, key.axes, xaxs = "i", yaxs = "i", las = 1,
          grid = TRUE, grid.col = "yellow", grid.nx = floor(ncol(x)/30),
          grid.ny = grid.nx, center.zero = TRUE, flip=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dmat_+3A_x">x</code></td>
<td>
<p> a numeric distance matrix generated by the function
<code><a href="#topic+dm">dm</a></code>. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_key">key</code></td>
<td>
<p> logical, if TRUE a color key is plotted. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_resnum.1">resnum.1</code></td>
<td>
<p> a vector of residue numbers for annotating the x axis. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_resnum.2">resnum.2</code></td>
<td>
<p> a vector of residue numbers for annotating the y axis. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_axis.tick.space">axis.tick.space</code></td>
<td>
<p> the separation between each axis tick mark. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_zlim">zlim</code></td>
<td>
<p> z limits for the distances to be plotted. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_nlevels">nlevels</code></td>
<td>
<p> if <code>levels</code> is not specified, the range of 'z' values
is divided into approximately this many levels. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_levels">levels</code></td>
<td>
<p> a set of levels used to partition the range of 'z'.
Must be *strictly* increasing (and finite).  Areas with 'z' values
between consecutive levels are painted with the same color. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_color.palette">color.palette</code></td>
<td>
<p> a color palette function, used to assign
colors in the plot. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_col">col</code></td>
<td>
<p> an explicit set of colors to be used in the plot. This
argument overrides any palette function specification. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_axes">axes</code></td>
<td>
<p> logical, if TRUE plot axes are drawn. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_key.axes">key.axes</code></td>
<td>
<p> statements which draw axes on the plot key. It
overrides the default axis. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_xaxs">xaxs</code></td>
<td>
<p> the x axis style.  The default is to use internal labeling. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_yaxs">yaxs</code></td>
<td>
<p> the y axis style.  The default is to use internal labeling. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_las">las</code></td>
<td>
<p> the style of labeling to be used.  The default is to use
horizontal labeling. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_grid">grid</code></td>
<td>
<p> logical, if TRUE overlaid grid is drawn. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_grid.col">grid.col</code></td>
<td>
<p> color of the overlaid grid. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_grid.nx">grid.nx</code></td>
<td>
<p> number of grid cells in the x direction.  </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_grid.ny">grid.ny</code></td>
<td>
<p> number of grid cells in the y direction.  </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_center.zero">center.zero</code></td>
<td>
<p> logical, if TRUE levels are forced to be
equidistant around zero, assuming that zlim ranges from less than to
more than zero. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_flip">flip</code></td>
<td>
<p> logical, indicating whether the second axis should be
fliped. </p>
</td></tr>
<tr><td><code id="plot.dmat_+3A_...">...</code></td>
<td>
<p> additional graphical parameters for image. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>This function is based on the <code>layout</code> and legend key code in the
function <code>filled.contour</code> by Ross Ihaka.  As with
<code>filled.contour</code> the output is a combination of two plots: the
legend and (in this case) <code>image</code> (rather than a contour plot).
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.T
</p>
<p>Much of this function is based on the <code>filled.contour</code> function
by Ross Ihaka.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dm">dm</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>,
<code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

# DM
d &lt;- dm(pdb,"calpha")

# Plot DM
##filled.contour(d, nlevels = 4)
##plot(d)
plot(d,
     resnum.1 = pdb$atom[pdb$calpha,"resno"],
     color.palette = mono.colors,
     xlab="Residue Number", ylab="Residue Number")

## Not run: 
# Download and align two PDB files
pdbs &lt;- pdbaln( get.pdb( c( "4q21", "521p"), path=tempdir(), overwrite=TRUE))

# Get distance matrix
a &lt;- dm.xyz(pdbs$xyz[1,])
b &lt;- dm.xyz(pdbs$xyz[2,])

# Calculate DDM
c &lt;- a - b

# Plot DDM
plot(c,key=FALSE, grid=FALSE)

plot(c, axis.tick.space=10,
     resnum.1=pdbs$resno[1,],
     resnum.2=pdbs$resno[2,],
     grid.col="black",
     xlab="Residue No. (4q21)", ylab="Residue No. (521p)")


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.enma'> Plot eNMA Results </h2><span id='topic+plot.enma'></span>

<h3>Description</h3>

<p>Produces a plot of atomic fluctuations of aligned normal modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'enma'
plot(x,
        pdbs = NULL,
        xlab = NULL,
        ylab="Fluctuations", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.enma_+3A_x">x</code></td>
<td>
<p> the results of ensemble NMA obtained with
<code><a href="#topic+nma.pdbs">nma.pdbs</a></code>. Alternatively, a matrix in the similar
format as <code>enma$fluctuations</code> can be provided. </p>
</td></tr>
<tr><td><code id="plot.enma_+3A_pdbs">pdbs</code></td>
<td>
<p> an object of class &lsquo;pdbs&rsquo; in which the
&lsquo;enma&rsquo; object <code>x</code> was obtained from. If provided SSE
data of the first structure of <code>pdbs</code> will drawn. </p>
</td></tr>
<tr><td><code id="plot.enma_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis. </p>
</td></tr>
<tr><td><code id="plot.enma_+3A_ylab">ylab</code></td>
<td>
<p> labels for the y axes. </p>
</td></tr>
<tr><td><code id="plot.enma_+3A_...">...</code></td>
<td>
<p> extra plotting arguments passed to <code>plot.fluct</code>
that effect the atomic fluctuations plot only. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.enma</code> produces a fluctuation plot of aligned <code>nma</code>
objects. If corresponding <code>pdbs</code> object is provided the plot
contains SSE annotation and appropriate resiude index numbering.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven, Barry Grant </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a></code>,
<code><a href="#topic+plotb3">plotb3</a></code>, <code><a href="#topic+plot.fluct">plot.fluct</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
raw.files &lt;- get.pdb(ids, path = "raw_pdbs")
files &lt;- pdbsplit(raw.files, ids, path = "raw_pdbs/split_chain")

## Sequence/structure alignement
pdbs &lt;- pdbaln(files)

## Normal mode analysis on aligned data
modes &lt;- nma(pdbs)

## Plot fluctuations
plot(modes, pdbs=pdbs)

## Group and spread fluctuation profiles
hc &lt;- hclust(as.dist(1-modes$rmsip))
col &lt;- cutree(hc, k=2)
plot(modes, pdbs=pdbs, col=col, spread=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fasta'> Plot a Multiple Sequence Alignment </h2><span id='topic+plot.fasta'></span>

<h3>Description</h3>

<p>Produces a schematic representation of a multiple sequence alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fasta'
plot(x, hc = TRUE, labels = x$id, cex.lab = 0.7,
                         xlab = "Alignment index",
                         main = "Sequence Alignment Overview",
                         mar4 = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fasta_+3A_x">x</code></td>
<td>
<p> multiple sequence alignement of class &lsquo;fasta&rsquo; as
obtained from  <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_hc">hc</code></td>
<td>
<p> logical, if TRUE plot a dendrogram on the left
side. Alternatively, an object obtained from <code><a href="stats.html#topic+hclust">hclust</a></code>
can be provided. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_labels">labels</code></td>
<td>
<p> labels corresponding to each row in the alignment. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_cex.lab">cex.lab</code></td>
<td>
<p> scaling factor for the labels. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_xlab">xlab</code></td>
<td>
<p> label for x-axis. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_main">main</code></td>
<td>
<p> a main title for the plot. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_mar4">mar4</code></td>
<td>
<p> margin size for the labels. </p>
</td></tr>
<tr><td><code id="plot.fasta_+3A_...">...</code></td>
<td>
<p> additional arguments passed to function <code><a href="stats.html#topic+hclust">hclust</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.fasta</code> is a utility function for producting a schematic
representation of a multiple sequence alignment.  
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+entropy">entropy</a></code>, <code><a href="#topic+aln2html">aln2html</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'># Read alignment
aln &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))

## alignment plot
plot(aln, labels=basename.pdb(aln$id))

## Works also for a 'pdbs' object
attach(transducin)
plot(pdbs)

detach(transducin)

## Not run: 
infile &lt;- "http://pfam.xfam.org/family/PF00071/alignment/seed/format?format=fasta"
aln &lt;- read.fasta( infile )
plot(aln)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fluct'> Plot Fluctuations </h2><span id='topic+plot.fluct'></span>

<h3>Description</h3>

<p>Produces a plot of atomic fluctuations obtained from ensemble normal mode analysis or
molecular dynamics simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fluct'
plot(x,
        col = NULL, label = rownames(x), signif = FALSE,
        p.cutoff = 0.005, q.cutoff = 0.04,
        s.cutoff = 5, n.cutoff = 2, mean = FALSE, polygon = FALSE,
        spread = FALSE, offset = 1,
        ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fluct_+3A_x">x</code></td>
<td>
<p> a numeric vector or matrix containing atomic fluctuation data obtained
from e.g. <code><a href="#topic+nma.pdbs">nma.pdbs</a></code> or <code><a href="#topic+rmsf">rmsf</a></code>. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_col">col</code></td>
<td>
<p> a character vector of plotting colors. Used also to group
fluctuation profiles. NA values in col will omit the corresponding fluctuation
profile in the plot. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_label">label</code></td>
<td>
<p> a character vector of plotting labels with length matching
<code>nrow(x)</code>. If <code>mean=TRUE</code>, the length of <code>label</code> can be equal to
the number of categories indicated by <code>col</code>. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_signif">signif</code></td>
<td>
<p> logical, if TRUE significance of fluctuation difference is calculated
and annotated for each atomic position. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_p.cutoff">p.cutoff</code></td>
<td>
<p> Cutoff of p-value to define significance. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_q.cutoff">q.cutoff</code></td>
<td>
<p> Cutoff of the mean fluctuation difference to define significance. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_s.cutoff">s.cutoff</code></td>
<td>
<p> Cutoff of sample size in each group to calculate the significance. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_n.cutoff">n.cutoff</code></td>
<td>
<p> Cutoff of consecutive residue positions with significant fluctuation
difference. If the actual number is less than the cutoff,
correponding postions will not be annotated. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_mean">mean</code></td>
<td>
<p> logical, if TRUE plot mean fluctuations of each group. Significance is
still calculated with the original data. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_polygon">polygon</code></td>
<td>
<p> logical, if TRUE a nicer plot with area under the line for the first
row of <code>x</code> are filled with polygons. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation. By default
(<code>ncore=NULL</code>), use all available CPU cores. The argument is only
used when <code>signif=TRUE</code>. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_spread">spread</code></td>
<td>
<p> logical, if TRUE the fluctuation profiles are spread -
i.e. not on top of each other. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_offset">offset</code></td>
<td>
<p> numerical offset value in use when
&lsquo;spread=TRUE&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.fluct_+3A_...">...</code></td>
<td>
<p> extra plotting arguments passed to <code>plot.bio3d</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The significance calculation is performed when <code>signif=TRUE</code> and there are at least
two groups with sample size larger than or equal to <code>s.cutoff</code>. A &quot;two-sided&quot;
student's t-test is performed for each atomic position (each
column of <code>x</code>).  If <code>x</code> contains gaps, indicated by <code>NA</code>s,
only non-gapped positions are considered. The position is considered significant if both
<code>p-value &lt;= p.cutoff</code> and the mean value difference of the two groups, q, satisfies
<code>q &gt;= q.cutoff</code>. If more than two groups are available, every pair of groups are
subjected to the t-test calculation and the minimal p-value along with the q-value
for the corresponding pair are used for the significance evaluation.
</p>


<h3>Value</h3>

<p>If significance is calculated, return a vector indicating significant positions.
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao, Lars Skjaerven, Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.bio3d">plot.bio3d</a></code>, <code><a href="#topic+rmsf">rmsf</a></code>, <code><a href="#topic+nma.pdbs">nma.pdbs</a></code>,
<code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load transducin example data
attach(transducin)

## subset of pdbs to analyze
inds = c(1:5, 16:20)
pdbs &lt;- trim(pdbs, row.inds=inds)
gaps.res = gap.inspect(pdbs$ali)

## reference RESNO and SSE for axis annotations
resno &lt;- pdbs$resno[1, gaps.res$f.inds]
sse &lt;- pdbs$sse[1, gaps.res$f.inds]

## eNMA calculation and obtain modes of motion including atomic fluctuations
modes &lt;- nma(pdbs, ncore=NULL)
x = modes$fluctuation

## simple line plot with SSE annotation
plot.fluct(x, sse=sse, resno=resno)

## group data by specifying colors of each fluctuation line; same color indicates
## same group. Also do significance calculation and annotation
col = c(rep('red', 5), rep('blue', 5))
plot.fluct(x, col=col, signif=TRUE, sse=sse, resno=resno)

## spread lines
plot.fluct(x, col=col, signif=TRUE, sse=sse, resno=resno, typ='l', spread=TRUE)

## show only line of mean values for each group. 
## Nicer plot with area shaded for the first group.
plot.fluct(x, col=col, signif=TRUE, sse=sse, resno=resno, mean=TRUE, 
           polygon=TRUE, label=c('GTP', 'GDI'))

detach(transducin)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.geostas'> Plot Geostas Results </h2><span id='topic+plot.geostas'></span>

<h3>Description</h3>

<p>Plot an atomic movement similarity matrix with domain annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geostas'
plot(x, at=seq(0, 1, 0.1), main="AMSM with Domain Assignment",
                         col.regions=rev(heat.colors(200)), 
                         margin.segments=x$grps, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.geostas_+3A_x">x</code></td>
<td>
<p> an object of type <code>geostas</code> as obtained by the
&lsquo;geostas&rsquo; function. </p>
</td></tr> 
<tr><td><code id="plot.geostas_+3A_at">at</code></td>
<td>
<p> numeric vector specifying the levels to be colored. </p>
</td></tr>
<tr><td><code id="plot.geostas_+3A_main">main</code></td>
<td>
<p> a main title for the plot. </p>
</td></tr>
<tr><td><code id="plot.geostas_+3A_col.regions">col.regions</code></td>
<td>
<p> color vector. See <code>contourplot</code> for more 
information. </p>
</td></tr>
<tr><td><code id="plot.geostas_+3A_margin.segments">margin.segments</code></td>
<td>
<p> a numeric vector of cluster membership as 
obtained from cutree() or other community detection method. This 
will be used for bottom and left margin annotation. </p>
</td></tr>
<tr><td><code id="plot.geostas_+3A_...">...</code></td>
<td>
<p> additional graphical parameters for
<code><a href="#topic+plot.dccm">plot.dccm</a></code> and <code>contourplot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for <code><a href="#topic+plot.dccm">plot.dccm</a></code> with appropriate
adjustments for plotting atomic movement similarity matrix obtained
from function <code><a href="#topic+geostas">geostas</a></code>. 
</p>
<p>See the <code><a href="#topic+plot.dccm">plot.dccm</a></code> for more details.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dccm">plot.dccm</a></code>, <code><a href="#topic+geostas">geostas</a></code>
</p>

<hr>
<h2 id='plot.hmmer'> Plot a Summary of HMMER Hit Statistics. </h2><span id='topic+plot.hmmer'></span>

<h3>Description</h3>

<p>Produces a number of basic plots that should facilitate hit selection
from the match statistics of a HMMER result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'hmmer'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hmmer_+3A_x">x</code></td>
<td>
<p> HMMER results as obtained from the function
<code><a href="#topic+hmmer">hmmer</a></code>. </p>
</td></tr>
<tr><td><code id="plot.hmmer_+3A_...">...</code></td>
<td>
<p> arguments passed to <code><a href="#topic+plot.blast">plot.blast</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+plot.blast">plot.blast</a></code> for details. 
</p>


<h3>Value</h3>

<p>Produces a plot on the active graphics device and returns a three
component list object:
</p>
<table>
<tr><td><code>hits</code></td>
<td>
<p> an ordered matrix detailing the subset of hits with a normalized
score above the chosen cutoff. Database identifiers are listed along
with their cluster group number. </p>
</td></tr>
<tr><td><code>acc</code></td>
<td>
<p> a character vector containing the database accession identifier of
each hit above the chosen threshold. </p>
</td></tr>
<tr><td><code>pdb.id</code></td>
<td>
<p> a character vector containing the database accession identifier of
each hit above the chosen threshold. </p>
</td></tr>
<tr><td><code>inds</code></td>
<td>
<p> a numeric vector containing the indices of the hits
relative to the input hmmer object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hmmer">hmmer</a></code>, <code><a href="#topic+blast.pdb">blast.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# HMMER server connection required - testing excluded

##- PHMMER
seq &lt;- get.seq("2abl_A", outfile = tempfile())
res &lt;- hmmer(seq, db="pdb")
plot.hmmer(res)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.matrix.loadings'>Plot Residue-Residue Matrix Loadings</h2><span id='topic+plot.matrix.loadings'></span>

<h3>Description</h3>

<p>Plot residue-residue matrix loadings of a particular PC that is obtained from a 
principal component analysis (PCA) of cross-correlation or distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix.loadings'
plot(x, pc = 1, resno = NULL, sse = NULL,
  mask.n = 0, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.matrix.loadings_+3A_x">x</code></td>
<td>
<p>the results of PCA as obtained from <code><a href="#topic+pca.array">pca.array</a></code>.</p>
</td></tr>
<tr><td><code id="plot.matrix.loadings_+3A_pc">pc</code></td>
<td>
<p>the principal component along which the loadings will be shown.</p>
</td></tr>
<tr><td><code id="plot.matrix.loadings_+3A_resno">resno</code></td>
<td>
<p>numerical vector or &lsquo;pdb&rsquo; object as obtained from <code><a href="#topic+read.pdb">read.pdb</a></code>
to show residue number on the x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot.matrix.loadings_+3A_sse">sse</code></td>
<td>
<p>a &lsquo;sse&rsquo; object as obtained from <code><a href="#topic+dssp">dssp</a></code> or <code><a href="#topic+stride">stride</a></code>, 
or a &lsquo;pdb&rsquo; object as obtained from <code><a href="#topic+read.pdb">read.pdb</a></code> to show secondary
structural elements along x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot.matrix.loadings_+3A_mask.n">mask.n</code></td>
<td>
<p>the number of elements from the diagonal to be masked from output.</p>
</td></tr>
<tr><td><code id="plot.matrix.loadings_+3A_plot">plot</code></td>
<td>
<p>logical, if FALSE no plot will be shown.</p>
</td></tr>
<tr><td><code id="plot.matrix.loadings_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+plot.dccm">plot.dccm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots loadings (the eigenvectors) of PCA performed on a set of matrices 
such as distance matrices from an ensemble of crystallographic structures 
and residue-residue cross-correlations or covariance matrices derived from 
ensemble NMA or MD simulation replicates (See <code><a href="#topic+pca.array">pca.array</a></code> for detail). 
Loadings are displayed as a matrix with dimension the same as the input matrices 
of the PCA. Each element of loadings represents the proportion that the corresponding 
residue pair contributes to the variance in a particular PC. The plot can be used 
to identify key regions that best explain the variance of underlying matrices.
</p>


<h3>Value</h3>

<p>Plot and also returns a numeric matrix containing the loadings.
</p>


<h3>Author(s)</h3>

<p>Xin-Qiu Yao
</p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dccm">plot.dccm</a></code>, <code><a href="#topic+pca.array">pca.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   attach(transducin)
   gaps.res &lt;- gap.inspect(pdbs$ali)
   sse &lt;- pdbs$sse[1, gaps.res$f.inds]

   # calculate modes
   modes &lt;- nma(pdbs, ncore=NULL)

   # calculate cross-correlation matrices from the modes
   cijs &lt;- dccm(modes, ncore=NULL)$all.dccm

   # do PCA on cross-correlation matrices
   pc &lt;- pca.array(cijs)

   # plot loadings
   l &lt;- plot.matrix.loadings(pc, sse=sse)
   l[1:10, 1:10]

   # plot loadings with elements 10-residue separated from diagonal masked
   plot.matrix.loadings(pc, sse=sse, mask.n=10)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.nma'> Plot NMA Results </h2><span id='topic+plot.nma'></span>

<h3>Description</h3>

<p>Produces eigenvalue/frequency spectrum plots and an atomic fluctuations plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma'
plot(x, pch = 16, col = par("col"), cex=0.8, mar=c(6, 4, 2, 2),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nma_+3A_x">x</code></td>
<td>
<p> the results of normal modes analysis obtained with
<code><a href="#topic+nma">nma</a></code>. </p>
</td></tr>
<tr><td><code id="plot.nma_+3A_pch">pch</code></td>
<td>
<p> a vector of plotting characters or symbols: see <code><a href="graphics.html#topic+points">points</a></code>. </p>
</td></tr>
<tr><td><code id="plot.nma_+3A_col">col</code></td>
<td>
<p> a character vector of plotting colors.  </p>
</td></tr>
<tr><td><code id="plot.nma_+3A_cex">cex</code></td>
<td>
<p> a numerical single element vector giving the amount by
which plotting text and symbols should be magnified relative to the
default. </p>
</td></tr>
<tr><td><code id="plot.nma_+3A_mar">mar</code></td>
<td>
<p> A numerical vector of the form c(bottom, left, top, right)
which gives the number of lines of margin to be specified on the
four sides of the plot.</p>
</td></tr>
<tr><td><code id="plot.nma_+3A_...">...</code></td>
<td>
<p> extra plotting arguments passed to <code><a href="#topic+plot.bio3d">plot.bio3d</a></code>
that effect the atomic fluctuations plot only. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.nma</code> produces an eigenvalue (or frequency) spectrum plot
together with a plot of the atomic fluctuations. 
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma">nma</a></code>, <code><a href="#topic+plot.bio3d">plot.bio3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fetch structure
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate modes
modes &lt;- nma(pdb)

plot(modes, sse=pdb)

</code></pre>

<hr>
<h2 id='plot.pca'> Plot PCA Results </h2><span id='topic+plot.pca'></span><span id='topic+plot.pca.score'></span><span id='topic+plot.pca.scree'></span>

<h3>Description</h3>

<p>Produces a z-score plot (conformer plot) and an eigen spectrum plot
(scree plot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pca'
plot(x, pc.axes=NULL, pch=16, col=par("col"), cex=0.8, mar=c(4, 4, 1, 1),...)

## S3 method for class 'pca.scree'
plot(x, y = NULL, type = "o", pch = 18,
         main = "", sub = "", xlim = c(0, 20), ylim = NULL,
         ylab = "Proportion of Variance (%)",
         xlab = "Eigenvalue Rank", axes = TRUE, ann = par("ann"),
         col = par("col"), lab = TRUE, ...)
## S3 method for class 'pca.score'
plot(x, inds=NULL, col=rainbow(nrow(x)), lab = "", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pca_+3A_x">x</code></td>
<td>
<p> the results of principal component analysis obtained with
<code><a href="#topic+pca.xyz">pca.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_pc.axes">pc.axes</code></td>
<td>
<p> an optional numeric vector of length two specifying the principal components to be plotted.  A NULL value will result in an overview plot of the first three PCs and a scree plot. See examples. </p>
</td></tr>    
<tr><td><code id="plot.pca_+3A_pch">pch</code></td>
<td>
<p> a vector of plotting characters or symbols: see &lsquo;points&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_col">col</code></td>
<td>
<p> a character vector of plotting colors.  </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_cex">cex</code></td>
<td>
<p> a numerical single element vector giving the amount by
which plotting text and symbols should be magnified relative to the
default. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_mar">mar</code></td>
<td>
<p> A numerical vector of the form c(bottom, left, top, right)
which gives the number of lines of margin to be specified on the
four sides of the plot.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_inds">inds</code></td>
<td>
<p> row indices of the conformers to label. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_lab">lab</code></td>
<td>
<p> a character vector of plot labels. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_y">y</code></td>
<td>
<p> the y coordinates for the scree plot. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_type">type</code></td>
<td>
<p> one-character string giving the type of plot desired.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_main">main</code></td>
<td>
<p> a main title for the plot, see also 'title'.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_sub">sub</code></td>
<td>
<p> a sub-title for the plot.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_xlim">xlim</code></td>
<td>
<p> the x limits of the plot. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_ylim">ylim</code></td>
<td>
<p> the y limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_ylab">ylab</code></td>
<td>
<p> a label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_axes">axes</code></td>
<td>
<p> a logical value indicating whether both axes should be drawn.</p>
</td></tr>
<tr><td><code id="plot.pca_+3A_ann">ann</code></td>
<td>
<p> a logical value indicating whether the default annotation
(title and x and y axis labels) should appear on the plot. </p>
</td></tr>
<tr><td><code id="plot.pca_+3A_...">...</code></td>
<td>
<p> extra plotting arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.pca</code> is a wrapper calling both <code>plot.pca.score</code> and
<code>plot.pca.scree</code> resulting in a 2x2 plot with three score plots
and one scree plot.
</p>


<h3>Value</h3>

<p>Produces a plot of PCA results in the active graphics device and invisibly 
returns the plotted &lsquo;z&rsquo; coordinates along the requested &lsquo;pc.axes&rsquo;. 
See examples section where these coordinates are used to identify plotted points.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pca.xyz">pca.xyz</a></code>, <code><a href="#topic+plot.bio3d">plot.bio3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(transducin)

pc.xray &lt;- pca(pdbs$xyz, rm.gaps=TRUE)
plot(pc.xray)

## Color plot by nucleotide state
vcolors &lt;- annotation[, "color"]
plot(pc.xray, col=vcolors)

## Focus on a single plot of PC1 vs PC2
x &lt;- plot(pc.xray, pc.axes=1:2, col=vcolors)

## Identify points interactively with mouse clicks
#identify(x, labels=basename.pdb(pdbs$id))

## Add labels to select points
inds &lt;- c(1,10,37)
text(x[inds,], labels=basename.pdb(pdbs$id[inds]), col="blue")

## Alternative labeling method
#labs &lt;- rownames(annotation)
#inds &lt;- c(2,7)
#plot.pca.score(pc.xray, inds=inds, col=vcolors, lab=labs)

## color by seq identity groupings
#ide &lt;- seqidentity(pdbs$ali)
#hc &lt;- hclust(as.dist(1-ide))
#grps &lt;- cutree(hc, h=0.2)
#vcolors &lt;- rainbow(max(grps))[grps]
#plot.pca.score(pc.xray, inds=inds, col=vcolors, lab=labs)

detach(transducin)
</code></pre>

<hr>
<h2 id='plot.pca.loadings'>  Plot Residue Loadings along PC1 to PC3 </h2><span id='topic+plot.pca.loadings'></span>

<h3>Description</h3>

<p>Plot residue loadings along PC1 to PC3 from a given xyz C-alpha matrix
of <code>loadings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pca.loadings'
plot(x, resnums = seq(1, (length(x[, 1])/3), 25), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pca.loadings_+3A_x">x</code></td>
<td>
<p> the results of principal component analysis obtained
from <code><a href="#topic+pca.xyz">pca.xyz</a></code>, or just the loadings returned from
<code><a href="#topic+pca.xyz">pca.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="plot.pca.loadings_+3A_resnums">resnums</code></td>
<td>
<p> a numeric vector of residue numbers. </p>
</td></tr>
<tr><td><code id="plot.pca.loadings_+3A_...">...</code></td>
<td>
<p> extra plotting arguments. </p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pca.xyz">pca.xyz</a></code>, <code><a href="#topic+plot.pca">plot.pca</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(transducin)

pc.xray &lt;- pca.xyz(pdbs$xyz[, gap.inspect(pdbs$xyz)$f.inds])
plot.pca.loadings(pc.xray$U)

detach(transducin)
</code></pre>

<hr>
<h2 id='plot.rmsip'> Plot RMSIP Results </h2><span id='topic+plot.rmsip'></span>

<h3>Description</h3>

<p>Produces a heat plot of RMSIP (Root mean square inner product) for the
visualization of modes similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rmsip'
plot(x, xlab = NULL, ylab = NULL, col = gray(50:0/50),
      zlim=c(0,1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rmsip_+3A_x">x</code></td>
<td>
<p> an object of class <code>rmsip</code>. </p>
</td></tr>
<tr><td><code id="plot.rmsip_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis, defaults to &lsquo;a&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.rmsip_+3A_ylab">ylab</code></td>
<td>
<p> a label for the y axis, defaults to &lsquo;b&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.rmsip_+3A_col">col</code></td>
<td>
<p> a vector of colors for the RMSIP map (or overlap values). </p>
</td></tr>
<tr><td><code id="plot.rmsip_+3A_zlim">zlim</code></td>
<td>
<p> the minimum and maximum &lsquo;z&rsquo; values for which
colors should be plotted. </p>
</td></tr>
<tr><td><code id="plot.rmsip_+3A_...">...</code></td>
<td>
<p> additional arguments to function <code>image</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.rmsip</code> produces a color image with the function
<code>image</code>. 
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rmsip">rmsip</a></code>, <code><a href="#topic+overlap">overlap</a></code>,
<code><a href="#topic+nma">nma</a></code>, <code><a href="graphics.html#topic+image">image</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read PDB structure
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Perform NMA
modes.a &lt;- nma(pdb, ff="calpha")
modes.b &lt;- nma(pdb, ff="anm")

## Calculate and plot RMSIP
r &lt;- rmsip(modes.a, modes.b)
plot(r)
</code></pre>

<hr>
<h2 id='print.cna'> Summarize and Print Features of a cna Network Graph </h2><span id='topic+print.cna'></span><span id='topic+summary.cna'></span>

<h3>Description</h3>

<p>These functions attempt to summarize and print a cna network graph to
the terminal in a human readable form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'cna'
print(x, ...)
  ## S3 method for class 'cna'
summary(object, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cna_+3A_x">x</code></td>
<td>
<p> A cna network and community object as obtained from the
function &lsquo;cna&rsquo;.</p>
</td></tr>
<tr><td><code id="print.cna_+3A_object">object</code></td>
<td>
<p> A cna network and community object as obtained from the
function &lsquo;cna&rsquo;.</p>
</td></tr>
<tr><td><code id="print.cna_+3A_verbose">verbose</code></td>
<td>
<p> Logical, if TRUE a community summary table is prited 
to screen.</p>
</td></tr> 
<tr><td><code id="print.cna_+3A_...">...</code></td>
<td>
<p> Extra arguments passed to the &lsquo;write.table&rsquo;
function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple summary and print methods for protein dynamic networks.
</p>


<h3>Value</h3>

<p>The function summary.cna returns a list with the following components:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p> A community number/identifier vector with an element for
each community. </p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p> A numeric community size vector, with elements giving
the number of nodes within each community. </p>
</td></tr>
<tr><td><code>members</code></td>
<td>
<p> A lst detailing the nodes within each community. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guido Scarabelli and Barry Grant
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>, <code><a href="igraph.html#topic+print.igraph">print.igraph</a></code>,
<code><a href="igraph.html#topic+print.igraph">str.igraph</a></code>, 
<code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

## Load the correlation network
attach(hivp)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## Examine network composition
print(net)
x&lt;- summary(net)
x$members[[2]]

detach(hivp)

}
</code></pre>

<hr>
<h2 id='print.core'> Printing Core Positions and Returning Indices </h2><span id='topic+print.core'></span>

<h3>Description</h3>

<p>Print method for core.find objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'core'
print(x, vol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.core_+3A_x">x</code></td>
<td>
<p> a list object obtained with the function
<code><a href="#topic+core.find">core.find</a></code>. </p>
</td></tr>
<tr><td><code id="print.core_+3A_vol">vol</code></td>
<td>
<p> the maximal cumulative volume value at which core positions
are detailed. </p>
</td></tr>
<tr><td><code id="print.core_+3A_...">...</code></td>
<td>
<p> additional arguments to &lsquo;print&rsquo;. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a three component list of indices:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p>atom indices of core positions</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p>xyz indices of core positions</p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p>residue numbers of core positions</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The produced <code><a href="#topic+plot.core">plot.core</a></code> function can be useful for deciding on the
core/non-core boundary.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+core.find">core.find</a></code>, <code><a href="#topic+plot.core">plot.core</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
##-- Generate a small kinesin alignment and read corresponding structures
pdbfiles &lt;- get.pdb(c("1bg2","2ncd","1i6i","1i5s"), URLonly=TRUE)
pdbs &lt;- pdbaln(pdbfiles)

##-- Find 'core' positions
core &lt;- core.find(pdbs)
plot(core)

##-- Fit on these relatively invarient subset of positions 
core.inds &lt;- print(core, vol=0.5)

print(core, vol=0.7)
print(core, vol=1.0)


## End(Not run)
</code></pre>

<hr>
<h2 id='print.fasta'> Printing Sequence Alignments </h2><span id='topic+print.fasta'></span><span id='topic+.print.fasta.ali'></span>

<h3>Description</h3>

<p>Print method for fasta and pdbs sequence alignment objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fasta'
print(x, alignment=TRUE, ...)
.print.fasta.ali(x, width = NULL, col.inds = NULL, numbers = TRUE,
         conservation=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fasta_+3A_x">x</code></td>
<td>
<p> a sequence alignment object as obtained from the functions  
<code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>, etc. </p>
</td></tr>
<tr><td><code id="print.fasta_+3A_alignment">alignment</code></td>
<td>
<p> logical, if TRUE the sequence alignment will be
printed to screen. </p>
</td></tr>
<tr><td><code id="print.fasta_+3A_width">width</code></td>
<td>
<p> a single numeric value giving the number of residues per 
printed sequence block. By default this is determined from considering 
alignment identifier widths given a standard 85 column terminal
window. </p>
</td></tr>
<tr><td><code id="print.fasta_+3A_col.inds">col.inds</code></td>
<td>
<p> an optional numeric vector that can be used to select 
subsets of alignment positions/columns for printing. </p>
</td></tr> 
<tr><td><code id="print.fasta_+3A_numbers">numbers</code></td>
<td>
<p> logical, if TRUE position numbers and a tick-mark every 
10 positions are printed above and below sequence blocks. </p>
</td></tr>
<tr><td><code id="print.fasta_+3A_conservation">conservation</code></td>
<td>
<p> logical, if TRUE conserved and semi-conserved
columns in the alignment are marked with an &lsquo;*&rsquo; and 
&lsquo;^&rsquo;, respectively. </p>
</td></tr>
<tr><td><code id="print.fasta_+3A_...">...</code></td>
<td>
<p> additional arguments to &lsquo;.print.fasta.ali&rsquo;. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called mostly for its effect but also silently returns block
divided concatenated sequence strings as a matrix.  
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+seqaln">seqaln</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     file &lt;- system.file("examples/kif1a.fa",package="bio3d")
     aln  &lt;- read.fasta(file)
     print(aln)

     # print(aln, col.inds=30:100, numbers=FALSE)
</code></pre>

<hr>
<h2 id='print.xyz'> Printing XYZ coordinates </h2><span id='topic+print.xyz'></span>

<h3>Description</h3>

<p>Print method for objects of class &lsquo;xyz&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xyz'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.xyz_+3A_x">x</code></td>
<td>
<p> a &lsquo;xyz&rsquo; object indicating 3-D coordinates of 
biological molecules. </p>
</td></tr>
<tr><td><code id="print.xyz_+3A_...">...</code></td>
<td>
<p> additional arguments passed to &lsquo;print&rsquo;. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.xyz">is.xyz</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
print(pdb$xyz)

</code></pre>

<hr>
<h2 id='project.pca'> Project Data onto Principal Components </h2><span id='topic+project.pca'></span><span id='topic+z2xyz.pca'></span><span id='topic+xyz2z.pca'></span>

<h3>Description</h3>

<p>Projects data onto principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project.pca(data, pca, angular = FALSE, fit = FALSE, ...)
z2xyz.pca(z.coord, pca)
xyz2z.pca(xyz.coord, pca)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project.pca_+3A_data">data</code></td>
<td>
<p> a numeric vector or row-wise matrix of data to be projected. </p>
</td></tr>
<tr><td><code id="project.pca_+3A_pca">pca</code></td>
<td>
<p> an object of class <code>"pca"</code> as obtained from
functions <code>pca.xyz</code> or <code>pca.tor</code>. </p>
</td></tr>
<tr><td><code id="project.pca_+3A_angular">angular</code></td>
<td>
<p> logical, if TRUE the data to be projected is treated
as torsion angle data. </p>
</td></tr>
<tr><td><code id="project.pca_+3A_fit">fit</code></td>
<td>
<p> logical, if TRUE the data is first fitted to <code>pca$mean</code>. </p>
</td></tr>
<tr><td><code id="project.pca_+3A_...">...</code></td>
<td>
<p> other parameters for <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="project.pca_+3A_xyz.coord">xyz.coord</code></td>
<td>
<p> a numeric vector or row-wise matrix of data to be projected. </p>
</td></tr>
<tr><td><code id="project.pca_+3A_z.coord">z.coord</code></td>
<td>
<p> a numeric vector or row-wise matrix of PC scores
(i.e. the z-scores which are centered and rotated versions of the
origional data projected onto the PCs) for conversion to xyz coordinates. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix of projected PC scores.
</p>


<h3>Author(s)</h3>

<p> Karim ElSawy and Barry Grant</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pca.xyz">pca.xyz</a></code>, <code><a href="#topic+pca.tor">pca.tor</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
attach(transducin)

gaps.pos &lt;- gap.inspect(pdbs$xyz)

#-- Do PCA without structures 2 and 7
pc.xray &lt;- pca.xyz(pdbs$xyz[-c(2,7), gaps.pos$f.inds])

#-- Project structures 2 and 7 onto the PC space
d &lt;- project.pca(pdbs$xyz[c(2,7), gaps.pos$f.inds], pc.xray)

plot(pc.xray$z[,1], pc.xray$z[,2],col="gray")
points(d[,1],d[,2], col="red")

detach(transducin)

## End(Not run)
</code></pre>

<hr>
<h2 id='prune.cna'> Prune A cna Network Object </h2><span id='topic+prune.cna'></span>

<h3>Description</h3>

<p>Remove nodes and their associated edges from a cna network graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune.cna(x, edges.min = 1, size.min = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune.cna_+3A_x">x</code></td>
<td>
<p> A protein network graph object as obtained from the
&lsquo;cna&rsquo; function.</p>
</td></tr>
<tr><td><code id="prune.cna_+3A_edges.min">edges.min</code></td>
<td>
<p> A single element numeric vector specifying the 
minimum number of edges that retained nodes should have. Nodes 
with less than &lsquo;edges.min&rsquo; will be pruned. </p>
</td></tr>
<tr><td><code id="prune.cna_+3A_size.min">size.min</code></td>
<td>
<p> A single element numeric vector specifying the 
minimum node size that retained nodes should have. Nodes 
with less composite residues than &lsquo;size.min&rsquo; will be 
pruned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for cleaning up cna network plots by removing, 
for example, small isolated nodes. The output is a new cna object minus 
the pruned nodes and their associated edges. Node naming is preserved.
</p>


<h3>Value</h3>

<p>A cna class object, see function <code><a href="#topic+cna">cna</a></code> for details.
</p>


<h3>Note</h3>

<p>Some improvements to this function are required, including a better effort 
to preserve the original community structure rather than calculating a 
new one. Also may consider removing nodes form the raw.network object 
that is returned also.
</p>


<h3>Author(s)</h3>

<p>Barry Grant
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cna">cna</a></code>,  <code><a href="#topic+summary.cna">summary.cna</a></code>,
<code><a href="#topic+vmd.cna">vmd.cna</a></code>, <code><a href="#topic+plot.cna">plot.cna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

# Load the correlation network
attach(hivp)

# Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

# Plot coarse grain network based on dynamically coupled communities
par(mfcol=c(1,2), mar=c(0,0,0,0))
plot.cna(net)

# Prune network
dnet &lt;- prune.cna(net, edges.min = 1)
plot(dnet)

detach(hivp)

}
</code></pre>

<hr>
<h2 id='pymol'> Biomolecular Visualization with PyMOL </h2><span id='topic+pymol'></span><span id='topic+pymol.pdbs'></span><span id='topic+pymol.nma'></span><span id='topic+pymol.pca'></span><span id='topic+pymol.modes'></span><span id='topic+pymol.dccm'></span>

<h3>Description</h3>

<p>Visualize Bio3D structure objects in PyMOL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pymol(...)

## S3 method for class 'pdbs'
pymol(pdbs, col=NULL, as="ribbon", file=NULL, type="script",
                     exefile="pymol", user.vec=NULL, ...)

## S3 method for class 'nma'
pymol(...)

## S3 method for class 'pca'
pymol(...)

## S3 method for class 'modes'
pymol(modes, mode=NULL, file=NULL, scale=5, dual=FALSE,
                     type="script", exefile="pymol", ...)

## S3 method for class 'dccm'
pymol(dccm, pdb, file=NULL,
                     step=0.2, omit=0.2, radius = 0.15,
                     type="script", exefile="pymol", ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pymol_+3A_pdbs">pdbs</code></td>
<td>
<p> aligned C-alpha Cartesian coordinates as obtained with 
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> or <code><a href="#topic+pdbaln">pdbaln</a></code>. </p>
</td></tr>
<tr><td><code id="pymol_+3A_col">col</code></td>
<td>
<p> a single element character vector specifying the coloring
of the structures. Options are: &lsquo;index&rsquo;, &lsquo;index2&rsquo;,
&lsquo;gaps&rsquo;, &lsquo;rmsf&rsquo;, &lsquo;user&rsquo;.
</p>
<p>Special cases: Provide a &lsquo;core&rsquo; object as obtained by
<code>core.find</code> to color on the invariant core. Alternatively,
provide a vector containing the color code for each structure in the
&lsquo;pdbs&rsquo; object. </p>
</td></tr>
<tr><td><code id="pymol_+3A_user.vec">user.vec</code></td>
<td>
<p> User defined vector for coloring. Only used if <code>col="user"</code>. </p>
</td></tr>
<tr><td><code id="pymol_+3A_as">as</code></td>
<td>
<p> show as &lsquo;ribbon&rsquo;, &lsquo;cartoon&rsquo;, &lsquo;lines&rsquo;, &lsquo;putty&rsquo;. </p>
</td></tr>
<tr><td><code id="pymol_+3A_file">file</code></td>
<td>
<p> a single element character vector specifying the file name
of the PyMOL session/script file. </p>
</td></tr>
<tr><td><code id="pymol_+3A_type">type</code></td>
<td>
<p> a single element character vector specifying the output
type: &lsquo;script&rsquo; generates a .pml script; &lsquo;session&rsquo;
generates a .pse session file; &lsquo;launch&rsquo; launches pymol. </p>
</td></tr>
<tr><td><code id="pymol_+3A_exefile">exefile</code></td>
<td>
<p> file path to the &lsquo;PYMOL&rsquo; program on your system (i.e.
how is &lsquo;PYMOL&rsquo; invoked). If <code>NULL</code>, use OS-dependent 
default path to the program. </p>
</td></tr>
<tr><td><code id="pymol_+3A_modes">modes</code></td>
<td>
<p> an object of class <code>nma</code> or <code>pca</code> as obtained
from functions <code>nma</code> or <code>pca.xyz</code>. </p>
</td></tr>
<tr><td><code id="pymol_+3A_mode">mode</code></td>
<td>
<p> the mode number for which the vector field should be
made. </p>
</td></tr> 
<tr><td><code id="pymol_+3A_scale">scale</code></td>
<td>
<p> global scaling factor. </p>
</td></tr>
<tr><td><code id="pymol_+3A_dual">dual</code></td>
<td>
<p> logical, if TRUE mode vectors are also drawn in both
direction. </p>
</td></tr>
<tr><td><code id="pymol_+3A_dccm">dccm</code></td>
<td>
<p> an object of class <code>dccm</code> as obtained from
function <code><a href="#topic+dccm">dccm</a></code>. </p>
</td></tr>
<tr><td><code id="pymol_+3A_pdb">pdb</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code>read.pdb</code> or a numerical vector of Cartesian
coordinates. </p>
</td></tr>
<tr><td><code id="pymol_+3A_step">step</code></td>
<td>
<p> binning interval of cross-correlation coefficents. </p>
</td></tr>
<tr><td><code id="pymol_+3A_omit">omit</code></td>
<td>
<p> correlation coefficents with values (0-omit, 0+omit) will
be omitted from visualization. </p>
</td></tr>
<tr><td><code id="pymol_+3A_radius">radius</code></td>
<td>
<p> numeric, radius of visualized correlation cylinders in
PyMol. Alternatively, a matrix with the same dimesions as
<code>dccm</code> can be provided, e.g. to draw cylinders with radii
associated to the pairwise correlation value. </p>
</td></tr>
<tr><td><code id="pymol_+3A_...">...</code></td>
<td>
<p> arguments passed to function <code>pymol.modes</code> for
&lsquo;nma&rsquo; and &lsquo;pca&rsquo; objects. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provides a convenient approach for the visualization of
Bio3D objects in PyMOL. See examples for more details.
</p>
<p>DCCM PyMOL visualization:
This function generates a PyMOL (python) script that will draw colored
lines between (anti)correlated residues. The PyMOL script file is
stored in the working directory with filename &ldquo;R.py&rdquo;.
PyMOL will only be launched (and opened)  when using argument
&lsquo;type='launch'&rsquo;. Alternatively a PDB file with CONECT records
will be generated (when argument <code>type='pdb'</code>). 
</p>
<p>For the PyMOL version, PyMOL CGO objects are generated - each object
representing a range of correlation values (corresponding to the
actual correlation values as found in the correlation
matrix). E.g. the PyMOL object with name &ldquo;cor_-1_-08&rdquo; would
display all pairs of correlations with values between -1 and -0.8.
</p>
<p>NMA / PCA PyMOL vector field visualization:
This function generates a PyMOL (python) script for drawing
mode vectors on a PDB structure. The PyMOL script file is stored in
the working directory with filename &ldquo;R.py&rdquo;. 
</p>


<h3>Value</h3>

<p>Called for its action
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code>view</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##- pymol with a 'pdbs' object
attach(transducin)

# build a pymol session containing all structures in the PDBs object
pymol(pdbs)

# color by invariant core (
# core &lt;- core.find(pdbs)
pymol(pdbs, col=core)

# color by RMSF
pymol(pdbs, col="rmsf")

# color by a user defined vector
# For example, colored by averaged contact density around each residue
cm &lt;- cmap(pdbs, binary=FALSE)
vec &lt;- rowSums(cm, na.rm=TRUE)
pymol(pdbs, col="user", user.vec=vec)

# color by clustering
rd &lt;- rmsd(pdbs$xyz)
hc &lt;- hclust(as.dist(rd))
grps &lt;- cutree(hc, k=3)
pymol(pdbs, col=grps)



##- pymol with a 'dccm' object
## Fetch stucture
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Calculate normal modes
modes &lt;- nma(pdb)

## Calculate correlation matrix
cm &lt;- dccm.nma(modes)

pymol(cm, modes$xyz)



##- pymol with a 'nma' or 'pca' object
pymol(modes, mode=7)

detach(transducin)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.all'> Read Aligned Structure Data</h2><span id='topic+read.all'></span>

<h3>Description</h3>

<p>Read aligned PDB structures and store their equalvalent atom data, including xyz
coordinates, residue numbers, residue type and B-factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.all(aln, prefix = "", pdbext = "", sel = NULL, rm.wat=TRUE, rm.ligand=FALSE,
         compact = TRUE, ncore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.all_+3A_aln">aln</code></td>
<td>
<p> an alignment data structure obtained with
<code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="read.all_+3A_prefix">prefix</code></td>
<td>
<p> prefix to aln$id to locate PDB files. </p>
</td></tr>
<tr><td><code id="read.all_+3A_pdbext">pdbext</code></td>
<td>
<p> the file name extention of the PDB files. </p>
</td></tr>
<tr><td><code id="read.all_+3A_sel">sel</code></td>
<td>
<p> a selection string detailing the atom type data to store
(see function store.atom) </p>
</td></tr>
<tr><td><code id="read.all_+3A_rm.wat">rm.wat</code></td>
<td>
<p>logical, if TRUE water atoms are removed. </p>
</td></tr>
<tr><td><code id="read.all_+3A_rm.ligand">rm.ligand</code></td>
<td>
<p>logical, if TRUE ligand atoms are removed. </p>
</td></tr>
<tr><td><code id="read.all_+3A_compact">compact</code></td>
<td>
<p> logical, if TRUE the number of atoms stored for each aligned
residue varies according to the amino acid type. If FALSE, the constant 
maximum possible number of atoms are stored for all aligned residues. </p>
</td></tr>
<tr><td><code id="read.all_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
By default (<code>ncore=NULL</code>) use all detected CPU cores. </p>
</td></tr>
<tr><td><code id="read.all_+3A_...">...</code></td>
<td>
<p> other parameters for <code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>   
</table>


<h3>Details</h3>

<p>The input <code>aln</code>, produced with <code><a href="#topic+read.fasta">read.fasta</a></code>, must
have identifers (i.e. sequence names) that match the PDB file
names. For example the sequence corresponding to the structure
file &ldquo;mypdbdir/1bg2.pdb&rdquo; should have the identifer
&lsquo;mypdbdir/1bg2.pdb&rsquo; or &lsquo;1bg2&rsquo; if input &lsquo;prefix&rsquo;
and &lsquo;pdbext&rsquo; equal &lsquo;mypdbdir/&rsquo; and &lsquo;pdb&rsquo;. See the
examples below.
</p>
<p>Sequence miss-matches will generate errors.  Thus, care should be taken
to ensure that the sequences in the alignment match the sequences in
their associated PDB files.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdbs"</code> with the following five
components:
</p>
<table>
<tr><td><code>xyz</code></td>
<td>
<p>numeric matrix of aligned C-alpha coordinates.</p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p>character matrix of aligned residue numbers.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric matrix of aligned B-factor values.</p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p>character matrix of aligned chain identifiers.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>character vector of PDB sequence/structure names.</p>
</td></tr>
<tr><td><code>ali</code></td>
<td>
<p>character matrix of aligned sequences.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>character matrix of aligned 3-letter residue names.</p>
</td></tr>
<tr><td><code>all</code></td>
<td>
<p>numeric matrix of aligned equalvelent atom coordinates. </p>
</td></tr>
<tr><td><code>all.elety</code></td>
<td>
<p>numeric matrix of aligned atom element types. </p>
</td></tr>
<tr><td><code>all.resid</code></td>
<td>
<p>numeric matrix of aligned three-letter residue codes. </p>
</td></tr>
<tr><td><code>all.resno</code></td>
<td>
<p>numeric matrix of aligned residue numbers. </p>
</td></tr>
<tr><td><code>all.grpby</code></td>
<td>
<p>numeric vector indicating the group of atoms belonging to
the same aligned residue. </p>
</td></tr>
<tr><td><code>all.hetatm</code></td>
<td>
<p>a list of &lsquo;pdb&rsquo; objects for non-protein atoms. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is still in development and is NOT part of the
offical bio3d package.
</p>
<p>The sequence character &lsquo;X&rsquo; is useful for masking unusual
or unknown residues, as it can match any other residue type.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+core.find">core.find</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'># still working on speeding this guy up
## Not run: 
## Read sequence alignment
file &lt;- system.file("examples/kif1a.fa",package="bio3d")
aln  &lt;- read.fasta(file)

## Read aligned PDBs storing all data for 'sel'
sel &lt;- c("N", "CA", "C", "O", "CB", "*G", "*D",  "*E", "*Z")
pdbs &lt;- read.all(aln, sel=sel)

atm &lt;- colnames(pdbs$all)
ca.ind  &lt;- which(atm == "CA")
core &lt;- core.find(pdbs)
core.ind &lt;- c( matrix(ca.ind, nrow=3)[,core$c0.5A.atom] )

## Fit structures
nxyz &lt;- fit.xyz(pdbs$all[1,], pdbs$all,
               fixed.inds  = core.ind,
               mobile.inds = core.ind)

ngap.col &lt;- gap.inspect(nxyz)

#npc.xray &lt;- pca.xyz(nxyz[ ,ngap.col$f.inds])

#a &lt;- mktrj.pca(npc.xray, pc=1, file="pc1-all.pdb",
#               elety=pdbs$all.elety[1,unique( ceiling(ngap.col$f.inds/3) )],
#               resid=pdbs$all.resid[1,unique( ceiling(ngap.col$f.inds/3) )],
#               resno=pdbs$all.resno[1,unique( ceiling(ngap.col$f.inds/3) )] )


## End(Not run)

</code></pre>

<hr>
<h2 id='read.cif'> Read mmCIF File</h2><span id='topic+read.cif'></span>

<h3>Description</h3>

<p>Read a Protein Data Bank (mmCIF) coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.cif(file, maxlines = -1, multi = FALSE,
         rm.insert = FALSE, rm.alt = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.cif_+3A_file">file</code></td>
<td>
<p> a single element character vector containing the name of
the mmCIF file to be read, or the four letter PDB identifier for
online file access. </p>
</td></tr>
<tr><td><code id="read.cif_+3A_maxlines">maxlines</code></td>
<td>
<p> the maximum number of lines to read before giving up
with large files. By default if will read up to the end of input on
the connection. </p>
</td></tr>
<tr><td><code id="read.cif_+3A_multi">multi</code></td>
<td>
<p> logical, if TRUE multiple ATOM records are read for all
models in multi-model files and their coordinates returned. </p>
</td></tr>
<tr><td><code id="read.cif_+3A_rm.insert">rm.insert</code></td>
<td>
<p> logical, if TRUE PDB insert records are ignored. </p>
</td></tr>
<tr><td><code id="read.cif_+3A_rm.alt">rm.alt</code></td>
<td>
<p> logical, if TRUE PDB alternate records are ignored. </p>
</td></tr>
<tr><td><code id="read.cif_+3A_verbose">verbose</code></td>
<td>
<p> print details of the reading process. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version of <code>read.cif</code> reads only ATOM/HETATM records
and creates a <code>pdb</code> object of the data.
</p>
<p>See <code>read.pdb</code> for more info.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a data.frame containing all atomic coordinate ATOM and 
HETATM data, with a row per ATOM/HETATM and a column per record type.  
See below for details of the record type naming convention (useful for 
accessing columns). </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of class <code>"xyz"</code> containing the
ATOM and HETATM coordinate data. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>
<code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+trim.pdb">trim.pdb</a></code>, <code><a href="#topic+cat.pdb">cat.pdb</a></code>, 
<code><a href="#topic+read.prmtop">read.prmtop</a></code>, <code><a href="#topic+as.pdb">as.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read a mmCIF file from the RCSB online database
# cif &lt;- read.cif("1hel")
</code></pre>

<hr>
<h2 id='read.crd'> Read Coordinate Data from Amber or Charmm </h2><span id='topic+read.crd'></span>

<h3>Description</h3>

<p>Read a CHARMM CARD (CRD) or AMBER coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.crd(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.crd_+3A_file">file</code></td>
<td>
<p> the name of the coordinate file to be read.  </p>
</td></tr>
<tr><td><code id="read.crd_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the methods
<code>read.crd.charmm</code> or <code>read.crd.amber</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.crd</code> is a generic function calling the corresponding function
determined by the class of the input argument <code>x</code>. Use
<code>methods("read.crd")</code> to get all the methods for <code>read.crd</code>
generic:
</p>
<p><code><a href="#topic+read.crd.charmm">read.crd.charmm</a></code> will be used for file extension
&lsquo;.crd&rsquo;.
</p>
<p><code><a href="#topic+read.crd.amber">read.crd.amber</a></code> will be used for file extension
&lsquo;.rst&rsquo; or &lsquo;.inpcrd&rsquo;.
</p>
<p>See examples for each corresponding function for more details.
</p>


<h3>Value</h3>

<p>See the &lsquo;value&rsquo; section for the corresponding functions for
more details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant and Lars Skjaerven</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.crd.amber">read.crd.amber</a></code>, <code><a href="#topic+read.crd.charmm">read.crd.charmm</a></code>,
<code><a href="#topic+write.crd">write.crd</a></code>, <code><a href="#topic+read.prmtop">read.prmtop</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read a PRMTOP file
prmtop &lt;- read.prmtop(system.file("examples/crambin.prmtop", package="bio3d"))
print(prmtop)

## Read a Amber CRD file
crds &lt;- read.crd(system.file("examples/crambin.inpcrd", package="bio3d"))

## Atom selection
ca.inds &lt;- atom.select(prmtop, "calpha")

## Convert to PDB format
pdb &lt;- as.pdb(prmtop, crds, inds=ca.inds)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.crd.amber'> Read AMBER Coordinate files </h2><span id='topic+read.crd.amber'></span>

<h3>Description</h3>

<p>Read coordinate data from an AMBER coordinate / restart file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amber'
read.crd(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.crd.amber_+3A_file">file</code></td>
<td>
<p> name of crd file to read. </p>
</td></tr>
<tr><td><code id="read.crd.amber_+3A_...">...</code></td>
<td>
<p> arguments passed to and from functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a AMBER Coordinate format file.
</p>


<h3>Value</h3>

<p>A list object of type &lsquo;amber&rsquo; and &lsquo;crd&rsquo; with the
following components:
</p>
<table>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of class &lsquo;xyz&rsquo; containing the
Cartesian coordinates. </p>
</td></tr>
<tr><td><code>velocities</code></td>
<td>
<p> a numeric vector containg the atom velocities. </p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p> numeric, length of the simulation (applies to Amber
restart coordinate files). </p>
</td></tr>
<tr><td><code>natoms</code></td>
<td>
<p> total number of atoms in the coordinate file. </p>
</td></tr>
<tr><td><code>box</code></td>
<td>
<p> dimensions of the box. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>See AMBER documentation for Coordinate format description.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
<a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.prmtop">read.prmtop</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>,
<code><a href="#topic+as.pdb">as.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.crd.charmm">read.crd.charmm</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read Amber PRMTOP and CRD files
prm &lt;- read.prmtop(system.file("examples/crambin.prmtop", package="bio3d"))
crd &lt;- read.crd(system.file("examples/crambin.inpcrd", package="bio3d"))

## Convert to PDB format
pdb &lt;- as.pdb(prm, crd)

## Atom selection
ca.inds &lt;- atom.select(prm, "calpha")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.crd.charmm'> Read CRD File </h2><span id='topic+read.crd.charmm'></span>

<h3>Description</h3>

<p>Read a CHARMM CARD (CRD) coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'charmm'
read.crd(file, ext = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.crd.charmm_+3A_file">file</code></td>
<td>
<p> the name of the CRD file to be read.  </p>
</td></tr>
<tr><td><code id="read.crd.charmm_+3A_ext">ext</code></td>
<td>
<p>logical, if TRUE assume expanded CRD format. </p>
</td></tr>
<tr><td><code id="read.crd.charmm_+3A_verbose">verbose</code></td>
<td>
<p> print details of the reading process. </p>
</td></tr>
<tr><td><code id="read.crd.charmm_+3A_...">...</code></td>
<td>
<p> arguments going nowhere. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the function <code><a href="#topic+read.pdb">read.pdb</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a character matrix containing all atomic coordinate data,
with a row per atom and a column per record type.  See below for details
of the record type naming convention (useful for accessing columns). </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric vector of coordinate data. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Similar to the output of <code><a href="#topic+read.pdb">read.pdb</a></code>, the column names of
<code>atom</code> can be used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo;,
Atom type &ldquo;elety&rdquo;,
Alternate location indicator &ldquo;alt&rdquo;,
Residue name &ldquo;resid&rdquo;,
Residue sequence number &ldquo;resno&rdquo;,
Code for insertion of residues &ldquo;insert&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Weighting factor &ldquo;b&rdquo;.
See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of CHARMM CARD (CRD) format see:<br />
<a href="https://www.charmm.org/wiki//index.php/CHARMM:The_Basics">https://www.charmm.org/wiki//index.php/CHARMM:The_Basics</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+write.crd">write.crd</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 pdb &lt;- read.pdb("1bg2")
 crdfile &lt;- paste(tempfile(), '.crd', sep='')
 write.crd(pdb, file=crdfile)
 crd &lt;- read.crd(crdfile, ext=FALSE)
 ca.inds &lt;- which(crd$calpha)
 crd$atom[ca.inds[1:20],c("x","y","z")]
# write.pdb(crd, file=tempfile())

## End(Not run)
</code></pre>

<hr>
<h2 id='read.dcd'> Read CHARMM/X-PLOR/NAMD Binary DCD files </h2><span id='topic+read.dcd'></span>

<h3>Description</h3>

<p>Read coordinate data from a binary DCD trajectory file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dcd(trjfile, big=FALSE, verbose = TRUE, cell = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dcd_+3A_trjfile">trjfile</code></td>
<td>
<p> name of trajectory file to read. A vector if 
treat a batch of files </p>
</td></tr>
<tr><td><code id="read.dcd_+3A_big">big</code></td>
<td>
<p> logical, if TRUE attempt to read large files into a
big.matrix object </p>
</td></tr>
<tr><td><code id="read.dcd_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE print details of the reading
process. </p>
</td></tr>
<tr><td><code id="read.dcd_+3A_cell">cell</code></td>
<td>
<p>logical, if TRUE return cell information only.
Otherwise, return coordinates.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Reads a CHARMM or X-PLOR/NAMD binary trajectory file with either big-
or little-endian storage formats.
</p>
<p>Reading is accomplished with two different sub-functions:
<code>dcd.header</code>, which reads header info, and <code>dcd.frame</code>, which
takes header information and reads atoms frame by frame producing an
nframes/natom*3 matrix of cartesian coordinates or an nframes/6 matrix
of cell parameters.
</p>


<h3>Value</h3>

<p>A numeric matrix of xyz coordinates with a frame/structure per row and
a Cartesian coordinate per column or a numeric matrix of cell information 
with a frame/structure per row and lengths and angles per column.
</p>


<h3>Note</h3>

<p>See CHARMM documentation for DCD format description.
</p>
<p>If you experience problems reading your trajectory file with read.dcd()
consider first reading your file into VMD and from there exporting a
new DCD trajectory file with the 'save coordinates' option. This new
file should be easily read with read.dcd().
</p>
<p>Error messages beginning 'cannot allocate vector of size' indicate a
failure to obtain memory, either because the size exceeded the
address-space limit for a process or, more likely, because the system
was unable to provide the memory. Note that on a 32-bit OS there may
well be enough free memory available, but not a large enough
contiguous block of address space into which to map it. In such cases
try setting the input option 'big' to TRUE. This is an experimental
option that results in a 'big.matrix' object.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redundant testing excluded

##-- Read cell parameters from example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile, cell = TRUE)
##-- Read coordinates from example trajectory file
trj &lt;- read.dcd(trtfile)

## Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

## select residues 24 to 27 and 85 to 90 in both chains
inds &lt;- atom.select(pdb, resno=c(24:27,85:90), elety='CA')

## lsq fit of trj on pdb
xyz &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=inds$xyz, mobile.inds=inds$xyz)

##-- RMSD of trj frames from PDB
r1 &lt;- rmsd(a=pdb, b=xyz)


## Not run: 
# Pairwise RMSD of trj frames for positions 47 to 54
flap.inds &lt;- atom.select(pdb, resno=c(47:54), elety='CA')
p &lt;- rmsd(xyz[,flap.inds$xyz])
# plot highlighting flap opening?
plot.dmat(p, color.palette = mono.colors)

## End(Not run)

</code></pre>

<hr>
<h2 id='read.fasta'> Read FASTA formated Sequences </h2><span id='topic+read.fasta'></span>

<h3>Description</h3>

<p>Read aligned or un-aligned sequences from a FASTA format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fasta(file, rm.dup = TRUE, to.upper = FALSE, to.dash=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fasta_+3A_file">file</code></td>
<td>
<p> input sequence file. </p>
</td></tr>
<tr><td><code id="read.fasta_+3A_rm.dup">rm.dup</code></td>
<td>
<p> logical, if TRUE duplicate sequences (with the same
names/ids) will be removed. </p>
</td></tr>
<tr><td><code id="read.fasta_+3A_to.upper">to.upper</code></td>
<td>
<p> logical, if TRUE residues are forced to uppercase. </p>
</td></tr>
<tr><td><code id="read.fasta_+3A_to.dash">to.dash</code></td>
<td>
<p> logical, if TRUE &lsquo;.&rsquo; gap characters are
converted to &lsquo;-&rsquo; gap characters. </p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

  
<p>For a description of FASTA format see:
<a href="https://www.ncbi.nlm.nih.gov/BLAST/blastcgihelp.shtml">https://www.ncbi.nlm.nih.gov/BLAST/blastcgihelp.shtml</a>.
When reading alignment files, the dash &lsquo;-&rsquo; is interpreted as
the gap character.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Read alignment
aln &lt;- read.fasta(system.file("examples/hivp_xray.fa",package="bio3d"))

# Print alignment overview
aln

# Sequence names/ids
head( aln$id )

# Alignment positions 335 to 339
head( aln$ali[,33:39] )

# Sequence d2a4f_b
aa123( aln$ali["d2a4f_b",] )

# Write out positions 33 to 45 only
#aln$ali=aln$ali[,30:45]
#write.fasta(aln, file="eg2.fa")

</code></pre>

<hr>
<h2 id='read.fasta.pdb'> Read Aligned Structure Data </h2><span id='topic+read.fasta.pdb'></span>

<h3>Description</h3>

<p>Read aligned PDB structures and store their C-alpha atom data, including xyz
coordinates, residue numbers, residue type and B-factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fasta.pdb(aln, prefix = "", pdbext = "", fix.ali = FALSE,
             pdblist=NULL, ncore = 1, nseg.scale = 1, progress = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fasta.pdb_+3A_aln">aln</code></td>
<td>
<p> an alignment data structure obtained with
<code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_prefix">prefix</code></td>
<td>
<p> prefix to aln$id to locate PDB files. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_pdbext">pdbext</code></td>
<td>
<p> the file name extention of the PDB files. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_fix.ali">fix.ali</code></td>
<td>
<p> logical, if TRUE check consistence between <code>$ali</code> 
and <code>$resno</code>, and correct <code>$ali</code> if they don't match. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_pdblist">pdblist</code></td>
<td>
<p> an optional list of <code>pdb</code> objects with sequence
corresponding to the alignments in <code>aln</code>. Primarily used
through function <code>pdbaln</code> when the PDB objects already exists
(avoids reading PDBs from file). </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_progress">progress</code></td>
<td>
<p> progress bar for use with shiny web app. </p>
</td></tr>
<tr><td><code id="read.fasta.pdb_+3A_...">...</code></td>
<td>
<p> other parameters for <code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The input <code>aln</code>, produced with <code><a href="#topic+read.fasta">read.fasta</a></code>, must
have identifers (i.e. sequence names) that match the PDB file
names. For example the sequence corresponding to the structure
&ldquo;1bg2.pdb&rdquo; should have the identifer &lsquo;1bg2&rsquo;. See
examples below.
</p>
<p>Sequence miss-matches will generate errors.  Thus, care should be taken
to ensure that the sequences in the alignment match the sequences in
their associated PDB files.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdbs"</code> with the following five
components:
</p>
<table>
<tr><td><code>xyz</code></td>
<td>
<p>numeric matrix of aligned C-alpha coordinates.</p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p>character matrix of aligned residue numbers.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric matrix of aligned B-factor values.</p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p>character matrix of aligned chain identifiers.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>character vector of PDB sequence/structure names.</p>
</td></tr>
<tr><td><code>ali</code></td>
<td>
<p>character matrix of aligned sequences.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>character matrix of aligned 3-letter residue names.</p>
</td></tr>
<tr><td><code>sse</code></td>
<td>
<p>character matrix of aligned helix and strand secondary
structure elements as defined in each PDB file.</p>
</td></tr>  
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The sequence character &lsquo;X&rsquo; is useful for masking unusual
or unknown residues, as it can match any other residue type.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+core.find">core.find</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code>,
<code><a href="#topic+read.all">read.all</a></code>, <code><a href="#topic+pymol.pdbs">pymol.pdbs</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redundant testing excluded

# Read sequence alignment
file &lt;- system.file("examples/kif1a.fa",package="bio3d")
aln  &lt;- read.fasta(file)

# Read aligned PDBs
pdbs &lt;- read.fasta.pdb(aln)

# Structure/sequence names/ids
basename( pdbs$id )

# Alignment positions 335 to 339
pdbs$ali[,335:339]
pdbs$resid[,335:339]
pdbs$resno[,335:339]
pdbs$b[,335:339]

# Alignment C-alpha coordinates for these positions
pdbs$xyz[, atom2xyz(335:339)]

# See 'fit.xyz()' function for actual coordinate superposition
#  e.g. fit to first structure
# xyz &lt;- fit.xyz(pdbs$xyz[1,], pdbs)
# xyz[, atom2xyz(335:339)]


</code></pre>

<hr>
<h2 id='read.mol2'> Read MOL2 File </h2><span id='topic+read.mol2'></span><span id='topic+print.mol2'></span>

<h3>Description</h3>

<p>Read a Tripos MOL2 file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mol2(file, maxlines = -1L)

## S3 method for class 'mol2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mol2_+3A_file">file</code></td>
<td>
<p> a single element character vector containing the name of
the MOL2 file to be read. </p>
</td></tr>
<tr><td><code id="read.mol2_+3A_maxlines">maxlines</code></td>
<td>
<p> the maximum number of lines to read before giving up
with large files. Default is all lines. </p>
</td></tr>
<tr><td><code id="read.mol2_+3A_x">x</code></td>
<td>
<p> an object as obtained from <code>read.mol2</code>. </p>
</td></tr>
<tr><td><code id="read.mol2_+3A_...">...</code></td>
<td>
<p> additional arguments to &lsquo;print&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic functionality to parse a MOL2 file. The current version reads
and stores &lsquo;@&lt;TRIPOS&gt;MOLECULE&rsquo;, &lsquo;@&lt;TRIPOS&gt;ATOM&rsquo;,
&lsquo;@&lt;TRIPOS&gt;BOND&rsquo; and &lsquo;@&lt;TRIPOS&gt;SUBSTRUCTURE&rsquo; records. 
</p>
<p>In the case of a multi-molecule MOL2 file, each molecule will be stored
as an individual &lsquo;mol2&rsquo; object in a list. Conversely, if the multi-molecule
MOL2 file contains identical molecules in different conformations
(typically from a docking run), then the output will be one object
with an <code>atom</code> and <code>xyz</code> component (xyz in
matrix representation; row-wise coordinates).
</p>
<p>See examples for further details.
</p>


<h3>Value</h3>

<p>Returns a list of molecules containing the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a data frame containing all atomic coordinate ATOM data, 
with a row per ATOM and a column per record type.  See below for details
of the record type naming convention (useful for accessing
columns). </p>
</td></tr>
<tr><td><code>bond</code></td>
<td>
<p> a data frame containing all atomic bond information. </p>
</td></tr>
<tr><td><code>substructure</code></td>
<td>
<p> a data frame containing all substructure information. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of ATOM coordinate data. </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p> a numeric vector of MOL2 info data. </p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p> a single element character vector containing the molecule name. </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>For <code>atom</code> list components the column names can be
used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo;,
Atom name &ldquo;elena&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Reisude number &ldquo;resno&rdquo;,
Atom type &ldquo;elety&rdquo;,
Residue name &ldquo;resid&rdquo;,
Atom charge &ldquo;charge&rdquo;,
Status bit &ldquo;statbit&rdquo;,
</p>
<p>For <code>bond</code> list components the column names are:
Bond identifier &ldquo;id&rdquo;,
number of the atom at one end of the bond&ldquo;origin&rdquo;,
number of the atom at the other end of the bond &ldquo;target&rdquo;,
the SYBYL bond type &ldquo;type&rdquo;.
</p>
<p>For <code>substructure</code> list components the column names are:
substructure identifier &ldquo;id&rdquo;,
substructure name &ldquo;name&rdquo;,
the ID number of the substructure's root atom &ldquo;root_atom&rdquo;,
the substructure type &ldquo;subst_type&rdquo;,
the type of dictionary associated with the substructure &ldquo;dict_type&rdquo;,
the chain to which the substructre belongs &ldquo;chain&rdquo;,
the subtype of the chain &ldquo;sub_type&rdquo;,
the number of inter bonds &ldquo;inter_bonds&rdquo;,
status bit &ldquo;status&rdquo;. 
</p>
<p>See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.mol2">write.mol2</a></code>, <code><a href="#topic+atom.select.mol2">atom.select.mol2</a></code>, 
<code><a href="#topic+trim.mol2">trim.mol2</a></code>, <code><a href="#topic+as.pdb.mol2">as.pdb.mol2</a></code>
<code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat("\n")
## Not run: 
## Read a single entry MOL2 file
## (returns a single object)
mol &lt;- read.mol2( system.file("examples/aspirin.mol2", package="bio3d") )

## Short summary of the molecule
print(mol)

## ATOM records
mol$atom

## BOND records
mol$bond

## Print some coordinate data
head(mol$atom[, c("x","y","z")])

## Or coordinates as a numeric vector
#head(mol$xyz)

## Print atom charges
head(mol$atom[, "charge"])

## Convert to PDB
pdb &lt;- as.pdb(mol)


## Read a multi-molecule MOL2 file
## (returns a list of objects)
#multi.mol &lt;- read.mol2("zinc.mol2")

## Number of molecules described in file
#length(multi.mol)

## Access ATOM records for the first molecule
#multi.mol[[1]]$atom

## Or coordinates for the second molecule
#multi.mol[[2]]$xyz



## Process output from docking (e.g. DOCK)
## (typically one molecule with many conformations)
## (returns one object, but xyz in matrix format)
#dock &lt;- read.mol2("dock.mol2")

## Reference PDB file (e.g. X-ray structure)
#pdb &lt;- read.pdb("dock_ref.pdb")

## Calculate RMSD of docking modes
#sele &lt;- atom.select(dock, "noh")
#rmsd(pdb$xyz, dock$xyz, b.inds=sele$xyz)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.ncdf'> Read AMBER Binary netCDF files </h2><span id='topic+read.ncdf'></span>

<h3>Description</h3>

<p>Read coordinate data from a binary netCDF trajectory file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ncdf(trjfile, headonly = FALSE, verbose = TRUE, time = FALSE,
          first = NULL, last = NULL, stride = 1, cell = FALSE,
          at.sel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ncdf_+3A_trjfile">trjfile</code></td>
<td>
<p> name of trajectory file to read. A vector if treat
a batch of files </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_headonly">headonly</code></td>
<td>
<p> logical, if TRUE only trajectory header information
is returned. If FALSE only trajectory coordinate data is returned. </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE print details of the reading process. </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_time">time</code></td>
<td>
<p> logical, if TRUE the <code>first</code> and <code>last</code> have the
time unit ps; Otherwise the unit is the frame number. </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_first">first</code></td>
<td>
<p> starting time or frame number to read; If NULL, start
from the begining of the file(s). </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_last">last</code></td>
<td>
<p> read data until <code>last</code> time or frame number; If NULL or
equal to -1, read until the end of the file(s). </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_stride">stride</code></td>
<td>
<p> take at every <code>stride</code> frame(s) </p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_cell">cell</code></td>
<td>
<p> logical, if TRUE and <code>headonly</code> is FALSE return cell 
information only. Otherwise, return header or coordinates.</p>
</td></tr>
<tr><td><code id="read.ncdf_+3A_at.sel">at.sel</code></td>
<td>
<p>an object of class &lsquo;select&rsquo; indicating a subset
of atomic coordinates to be read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads a AMBER netCDF format trajectory file with the help of David
W. Pierce's (UCSD) ncdf4 package available from CRAN.
</p>


<h3>Value</h3>

<p>A list of trajectory header data,  a numeric matrix of xyz
coordinates with a frame/structure per row and a Cartesian 
coordinate per column, or a numeric matrix of cell information 
with a frame/structure per row and lengths and angles per column.
If time=TRUE, row names of returned coordinates or cell are
set to be the physical time of corresponding frames.
</p>


<h3>Note</h3>

<p>See AMBER documentation for netCDF format description.
</p>
<p>NetCDF binary trajectory files are supported by the AMBER modules
sander, pmemd and ptraj. Compared to formatted trajectory files, the
binary trajectory files are smaller, higher precision and
significantly faster to read and write.
</p>
<p>NetCDF provides for file portability across architectures, allows for
backwards compatible extensibility of the format and enables the files
to be self-describing. Support for this format is available in VMD.
</p>
<p>If you experience problems reading your trajectory file with read.ncdf()
consider first reading your file into VMD and from there exporting a
new DCD trajectory file with the 'save coordinates' option. This new
file should be easily read with read.dcd().
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
<a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a>
<a href="https://cirrus.ucsd.edu/~pierce/ncdf/">https://cirrus.ucsd.edu/~pierce/ncdf/</a>
<a href="https://ambermd.org/FileFormats.php#netcdf">https://ambermd.org/FileFormats.php#netcdf</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+write.ncdf">write.ncdf</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##-- Read example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Write to netCDF format
write.ncdf(trj, "newtrj.nc")

## Read trj
trj &lt;- read.ncdf("newtrj.nc")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.pdb'> Read PDB File</h2><span id='topic+read.pdb'></span><span id='topic+read.pdb2'></span><span id='topic+print.pdb'></span><span id='topic+summary.pdb'></span>

<h3>Description</h3>

<p>Read a Protein Data Bank (PDB) coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pdb(file, maxlines = -1, multi = FALSE, rm.insert = FALSE,
         rm.alt = TRUE, ATOM.only = FALSE, hex = FALSE, verbose = TRUE)

read.pdb2(file, maxlines = -1, multi = FALSE, rm.insert = FALSE,
         rm.alt = TRUE, ATOM.only = FALSE, verbose = TRUE)

## S3 method for class 'pdb'
print(x, printseq=TRUE, ...)

## S3 method for class 'pdb'
summary(object, printseq=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.pdb_+3A_file">file</code></td>
<td>
<p> a single element character vector containing the name of
the PDB file to be read, or the four letter PDB identifier for
online file access. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_maxlines">maxlines</code></td>
<td>
<p> the maximum number of lines to read before giving up
with large files. By default if will read up to the end of input on
the connection. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_multi">multi</code></td>
<td>
<p> logical, if TRUE multiple ATOM records are read for all
models in multi-model files and their coordinates returned. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_rm.insert">rm.insert</code></td>
<td>
<p> logical, if TRUE PDB insert records are ignored. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_rm.alt">rm.alt</code></td>
<td>
<p> logical, if TRUE PDB alternate records are ignored. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_atom.only">ATOM.only</code></td>
<td>
<p> logical, if TRUE only ATOM/HETATM records are stored.
Useful for speed enhancements with large files where secondary structure, 
biological unit and other remark records are not required. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_hex">hex</code></td>
<td>
<p> logical, if TRUE enable parsing of hexadecimal atom
numbers (&gt; 99.999) and residue numbers (&gt; 9.999) (e.g. from VMD). Note
that numbering is assumed to be consecutive (with no missing numbers)
and the hexadecimals should start at atom number 100.000 and residue
number 10.000 and proceed to the end of file. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_verbose">verbose</code></td>
<td>
<p> print details of the reading process. </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_x">x</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>.  </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_object">object</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>.  </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_printseq">printseq</code></td>
<td>
<p> logical, if TRUE the PDB ATOM sequence will be printed
to the screen. See also <code><a href="#topic+pdbseq">pdbseq</a></code>.  </p>
</td></tr>
<tr><td><code id="read.pdb_+3A_...">...</code></td>
<td>
<p> additional arguments to &lsquo;print&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.pdb</code> is a re-implementation (using Rcpp) of the slower but
more tested R implementation of the same function (called
<code>read.pdb2</code> since bio3d-v2.3).
</p>
<p><code>maxlines</code> may be set so as to restrict the reading to a portion
of input files. Note that the preferred means of reading large 
multi-model files is via binary DCD or NetCDF format trajectory files 
(see the <code><a href="#topic+read.dcd">read.dcd</a></code> and <code><a href="#topic+read.ncdf">read.ncdf</a></code> functions).
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a data.frame containing all atomic coordinate ATOM and 
HETATM data, with a row per ATOM/HETATM and a column per record type.  
See below for details of the record type naming convention (useful for 
accessing columns). </p>
</td></tr>
<tr><td><code>helix</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of H
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>sheet</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of E
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>seqres</code></td>
<td>
<p> sequence from SEQRES field. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of class <code>"xyz"</code> containing the
ATOM and HETATM coordinate data. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
<tr><td><code>remark</code></td>
<td>
<p> a list object containing information taken from 'REMARK'
records of a <code>"pdb"</code>. It can be used for building biological units
(See <code><a href="#topic+biounit">biounit</a></code>). </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>For both <code>atom</code> and <code>het</code> list components the column names can be
used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo; ,
Atom type &ldquo;elety&rdquo;,
Alternate location indicator &ldquo;alt&rdquo;,
Residue name &ldquo;resid&rdquo;,
Chain identifier &ldquo;chain&rdquo;,
Residue sequence number &ldquo;resno&rdquo;,
Code for insertion of residues &ldquo;insert&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Occupancy &ldquo;o&rdquo;, and
Temperature factor &ldquo;b&rdquo;.
See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+trim.pdb">trim.pdb</a></code>, <code><a href="#topic+cat.pdb">cat.pdb</a></code>, 
<code><a href="#topic+read.prmtop">read.prmtop</a></code>, <code><a href="#topic+as.pdb">as.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>, 
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>, 
<code><a href="#topic+biounit">biounit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read a PDB file from the RCSB online database
#pdb &lt;- read.pdb("4q21")

## Read a PDB file from those included with the package
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )

## Print a brief composition summary
pdb

## Examine the storage format (or internal *str*ucture)
str(pdb)

## Print data for the first four atom
pdb$atom[1:4,]

## Print some coordinate data
head(pdb$atom[, c("x","y","z")])

## Or coordinates as a numeric vector
#head(pdb$xyz)

## Print C-alpha coordinates (can also use 'atom.select' function)
head(pdb$atom[pdb$calpha, c("resid","elety","x","y","z")])
inds &lt;- atom.select(pdb, elety="CA")
head( pdb$atom[inds$atom, ] )

## The atom.select() function returns 'indices' (row numbers)
## that can be used for accessing subsets of PDB objects, e.g.
inds &lt;- atom.select(pdb,"ligand")
pdb$atom[inds$atom,]
pdb$xyz[inds$xyz]

## See the help page for atom.select() function for more details.


## Not run: 
## Print SSE data for helix and sheet,
##  see also dssp() and stride() functions
print.sse(pdb)
pdb$helix
pdb$sheet$start
  
## Print SEQRES data
pdb$seqres

## SEQRES as one letter code
aa321(pdb$seqres)

## Where is the P-loop motif in the ATOM sequence
inds.seq &lt;- motif.find("G....GKT", pdbseq(pdb))
pdbseq(pdb)[inds.seq]

## Where is it in the structure
inds.pdb &lt;- atom.select(pdb,resno=inds.seq, elety="CA")
pdb$atom[inds.pdb$atom,]
pdb$xyz[inds.pdb$xyz]

## View in interactive 3D mode
#view(pdb)

## End(Not run)

</code></pre>

<hr>
<h2 id='read.pdcBD'> Read PQR output from pdcBD File </h2><span id='topic+read.pdcBD'></span>

<h3>Description</h3>

<p>Read a pdcBD PQR coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pdcBD(file, maxlines = 50000, multi = FALSE, rm.insert = FALSE,
         rm.alt = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.pdcBD_+3A_file">file</code></td>
<td>
<p> the name of the pdcBD PQR file to be read. </p>
</td></tr>
<tr><td><code id="read.pdcBD_+3A_maxlines">maxlines</code></td>
<td>
<p> the maximum number of lines to read before giving up
with large files. Default is 50,000 lines. </p>
</td></tr>
<tr><td><code id="read.pdcBD_+3A_multi">multi</code></td>
<td>
<p> logical, if TRUE multiple ATOM records are read for all
models in multi-model files. </p>
</td></tr>
<tr><td><code id="read.pdcBD_+3A_rm.insert">rm.insert</code></td>
<td>
<p> logical, if TRUE PDB insert records are ignored. </p>
</td></tr>
<tr><td><code id="read.pdcBD_+3A_rm.alt">rm.alt</code></td>
<td>
<p> logical, if TRUE PDB alternate records are ignored. </p>
</td></tr>
<tr><td><code id="read.pdcBD_+3A_verbose">verbose</code></td>
<td>
<p> print details of the reading process. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>maxlines</code> may require increasing for some large multi-model files.
The preferred means of reading such data is via binary DCD format 
trajectory files (see the <code><a href="#topic+read.dcd">read.dcd</a></code> function).
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a character matrix containing all atomic coordinate ATOM data, 
with a row per ATOM and a column per record type.  See below for details
of the record type naming convention (useful for accessing columns). </p>
</td></tr>
<tr><td><code>het</code></td>
<td>
<p> a character matrix containing atomic coordinate records
for atoms within &ldquo;non-standard&rdquo; HET groups (see <code>atom</code>). </p>
</td></tr>
<tr><td><code>helix</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of H
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>sheet</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of E
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>seqres</code></td>
<td>
<p> sequence from SEQRES field. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric vector of ATOM coordinate data. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>For both <code>atom</code> and <code>het</code> list components the column names can be
used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo; ,
Atom type &ldquo;elety&rdquo;,
Alternate location indicator &ldquo;alt&rdquo;,
Residue name &ldquo;resid&rdquo;,
Chain identifier &ldquo;chain&rdquo;,
Residue sequence number &ldquo;resno&rdquo;,
Code for insertion of residues &ldquo;insert&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Occupancy &ldquo;o&rdquo;, and
Temperature factor &ldquo;b&rdquo;.
See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

# Read a PDB file
pdb &lt;- read.pdb( "1bg2" )
  
# Print data for the first atom
pdb$atom[1,]
# Look at the first het atom
pdb$het[1,]
# Print some coordinate data
pdb$atom[1:20, c("x","y","z")]

# Print C-alpha coordinates (can also use 'atom.select')
##pdb$xyz[pdb$calpha, c("resid","x","y","z")]

# Print SSE data (for helix and sheet)
pdb$helix
pdb$sheet$start
  
# Print SEQRES data
pdb$seqres

# Renumber residues 
nums &lt;- as.numeric(pdb$atom[,"resno"])
pdb$atom[,"resno"] &lt;- nums - (nums[1] - 1)

# Write out renumbered PDB file
#write.pdb(pdb=pdb,file="eg.pdb")

</code></pre>

<hr>
<h2 id='read.pqr'> Read PQR File </h2><span id='topic+read.pqr'></span>

<h3>Description</h3>

<p>Read a PQR coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pqr(file, maxlines = -1, multi = FALSE, rm.insert = FALSE,
         rm.alt = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.pqr_+3A_file">file</code></td>
<td>
<p> the name of the PQR file to be read. </p>
</td></tr>
<tr><td><code id="read.pqr_+3A_maxlines">maxlines</code></td>
<td>
<p> the maximum number of lines to read before giving up
with large files. By default if will read up to the end of input on
the connection. </p>
</td></tr>
<tr><td><code id="read.pqr_+3A_multi">multi</code></td>
<td>
<p> logical, if TRUE multiple ATOM records are read for all
models in multi-model files. </p>
</td></tr>
<tr><td><code id="read.pqr_+3A_rm.insert">rm.insert</code></td>
<td>
<p> logical, if TRUE PDB insert records are ignored. </p>
</td></tr>
<tr><td><code id="read.pqr_+3A_rm.alt">rm.alt</code></td>
<td>
<p> logical, if TRUE PDB alternate records are ignored. </p>
</td></tr>
<tr><td><code id="read.pqr_+3A_verbose">verbose</code></td>
<td>
<p> print details of the reading process. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>PQR file format is basically the same as PDB format except for the fields of
<code>o</code> and <code>b</code>. In PDB, these two fields are filled with &lsquo;Occupancy&rsquo;
and &lsquo;B-factor&rsquo; values, respectively, with each field 6-column long.
In PQR, they are atomic &lsquo;partial charge&rsquo; and &lsquo;radii&rsquo;
values, respectively, with each field 8-column long.
</p>
<p><code>maxlines</code> may require increasing for some large multi-model files.
The preferred means of reading such data is via binary DCD format 
trajectory files (see the <code><a href="#topic+read.dcd">read.dcd</a></code> function).
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a data.frame containing all atomic coordinate ATOM and
HETATM data, with a row per ATOM/HETATM and a column per record type.
See below for details of the record type naming convention (useful for
accessing columns). </p>
</td></tr>
<tr><td><code>helix</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of H
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>sheet</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of E
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>seqres</code></td>
<td>
<p> sequence from SEQRES field. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of class <code>"xyz"</code> containing the
ATOM and HETATM coordinate data. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>For both <code>atom</code> and <code>het</code> list components the column names can be
used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo; ,
Atom type &ldquo;elety&rdquo;,
Alternate location indicator &ldquo;alt&rdquo;,
Residue name &ldquo;resid&rdquo;,
Chain identifier &ldquo;chain&rdquo;,
Residue sequence number &ldquo;resno&rdquo;,
Code for insertion of residues &ldquo;insert&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Occupancy &ldquo;o&rdquo;, and
Temperature factor &ldquo;b&rdquo;.
See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pqr">write.pqr</a></code>, 
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

# Read a PDB file and write it as a PQR file
pdb &lt;- read.pdb( "4q21" )
outfile = file.path(tempdir(), "eg.pqr")
write.pqr(pdb=pdb, file = outfile)

# Read the PQR file
pqr &lt;- read.pqr(outfile)

## Print a brief composition summary
pqr

## Examine the storage format (or internal *str*ucture)
str(pqr)

## Print data for the first four atom
pqr$atom[1:4,]

## Print some coordinate data
head(pqr$atom[, c("x","y","z")])

## Print C-alpha coordinates (can also use 'atom.select' function)
head(pqr$atom[pqr$calpha, c("resid","elety","x","y","z")])
inds &lt;- atom.select(pqr, elety="CA")
head( pqr$atom[inds$atom, ] )

## The atom.select() function returns 'indices' (row numbers)
## that can be used for accessing subsets of PDB objects, e.g.
inds &lt;- atom.select(pqr,"ligand")
pqr$atom[inds$atom,]
pqr$xyz[inds$xyz]

## See the help page for atom.select() function for more details.


</code></pre>

<hr>
<h2 id='read.prmtop'> Read AMBER Parameter/Topology files </h2><span id='topic+read.prmtop'></span><span id='topic+print.prmtop'></span>

<h3>Description</h3>

<p>Read parameter and topology data from an AMBER PrmTop file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.prmtop(file)

## S3 method for class 'prmtop'
print(x, printseq=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.prmtop_+3A_file">file</code></td>
<td>
<p> a single element character vector containing the name of
the PRMTOP file to be read. </p>
</td></tr>
<tr><td><code id="read.prmtop_+3A_x">x</code></td>
<td>
<p> a PRMTOP structure object obtained from
<code><a href="#topic+read.prmtop">read.prmtop</a></code>. </p>
</td></tr>
<tr><td><code id="read.prmtop_+3A_printseq">printseq</code></td>
<td>
<p> logical, if TRUE the residue sequence will be printed
to the screen. See also <code><a href="#topic+pdbseq">pdbseq</a></code>. </p>
</td></tr>
<tr><td><code id="read.prmtop_+3A_...">...</code></td>
<td>
<p> additional arguments to &lsquo;print&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides basic functionality to read and parse a AMBER
PrmTop file. The resulting &lsquo;prmtop&rsquo; object contains a complete
list object of the information stored in the PrmTop file.
</p>
<p>See examples for further details.
</p>


<h3>Value</h3>

<p>Returns a list of class &lsquo;prmtop&rsquo; (inherits class
&lsquo;amber&rsquo;) with components according to the flags present in the PrmTop
file. See the AMBER documentation for a complete list of
flags/components: <a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a>.
</p>
<p>Selected components:
</p>
<table>
<tr><td><code>ATOM_NAME</code></td>
<td>
<p> a character vector of atom names. </p>
</td></tr>
<tr><td><code>ATOMS_PER_MOLECULE</code></td>
<td>
<p> a numeric vector containing the number of
atoms per molecule. </p>
</td></tr>
<tr><td><code>MASS</code></td>
<td>
<p> a numeric vector of atomic masses. </p>
</td></tr>
<tr><td><code>RESIDUE_LABEL</code></td>
<td>
<p> a character vector of residue labels. </p>
</td></tr>
<tr><td><code>RESIDUE_RESIDUE_POINTER</code></td>
<td>
<p> a numeric vector of pointers to the
first atom in each residue. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>See AMBER documentation for PrmTop format description:<br />
<a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a>.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
<a href="http://ambermd.org/FileFormats.php">http://ambermd.org/FileFormats.php</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.crd">read.crd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>,
<code><a href="#topic+as.pdb">as.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read a PRMTOP file
prmtop &lt;- read.prmtop(system.file("examples/crambin.prmtop", package="bio3d"))
print(prmtop)

## Explore prmtop file
head(prmtop$MASS)
head(prmtop$ATOM_NAME)

## Read Amber coordinates
crds &lt;- read.crd(system.file("examples/crambin.inpcrd", package="bio3d"))

## Atom selection
ca.inds &lt;- atom.select(prmtop, "calpha")

## Convert to PDB format
pdb &lt;- as.pdb(prmtop, crds)
pdb.ca &lt;- as.pdb(prmtop, crds, inds=ca.inds)

## Trajectory processing
#trj &lt;- read.ncdf("traj.nc", at.sel=ca.inds)

## Convert to multimodel PDB format
#pdb &lt;- as.pdb(prmtop, trj[1:20,], inds=ca.inds, inds.crd=NULL)

## RMSD of trajectory
#rd &lt;- rmsd(crds$xyz[ca.inds$xyz], traj, fit=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rgyr'> Radius of Gyration</h2><span id='topic+rgyr'></span>

<h3>Description</h3>

<p>Calculate the radius of gyration of coordinate sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgyr(xyz, mass=NULL, ncore=1, nseg.scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgyr_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector, matrix or list object with an <code>xyz</code>
component, containing one or more coordinate sets.</p>
</td></tr>
<tr><td><code id="rgyr_+3A_mass">mass</code></td>
<td>
<p> a numeric vector of atomic masses (unit a.m.u.),
or a PDB object with masses stored in the &quot;B-factor&quot; column. 
If <code>mass==NULL</code>, all atoms are assumed carbon.</p>
</td></tr>
<tr><td><code id="rgyr_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="rgyr_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Radius of gyration is a standard measure of overall structural change of
macromolecules.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of radius of gyration.
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao &amp; Pete Kekenes-Huskey</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fit.xyz">fit.xyz</a></code>, <code><a href="#topic+rmsd">rmsd</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

# -- Calculate Rog of single structure
pdb &lt;- read.pdb("1bg2")
mass &lt;- rep(12, length(pdb$xyz)/3)
mass[substr(pdb$atom[,"elety"], 1, 1) == "N"] &lt;- 14
mass[substr(pdb$atom[,"elety"], 1, 1) == "H"] &lt;- 1
mass[substr(pdb$atom[,"elety"], 1, 1) == "O"] &lt;- 16 
mass[substr(pdb$atom[,"elety"], 1, 1) == "S"] &lt;- 32

rgyr(pdb, mass)


## Not run: 
# -- Calculate Rog of a trajectory
xyz &lt;- read.dcd(system.file("examples/hivp.dcd", package="bio3d"))
rg &lt;- rgyr(xyz)
rg[1:10]


## End(Not run)
</code></pre>

<hr>
<h2 id='rle2'>Run Length Encoding with Indices</h2><span id='topic+rle2'></span><span id='topic+print.rle2'></span>

<h3>Description</h3>

<p>Compute the lengths, values and indices of runs of equal values in a
vector. This is a modifed version of base function <code>rle()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rle2(x)

## S3 method for class 'rle2'
print(x, digits = getOption("digits"), prefix = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rle2_+3A_x">x</code></td>
<td>
<p>an atomic vector for <code>rle()</code>; an object of class
<code>"rle"</code> for <code>inverse.rle()</code>.</p>
</td></tr>
<tr><td><code id="rle2_+3A_...">...</code></td>
<td>
<p>further arguments; ignored here.</p>
</td></tr>
<tr><td><code id="rle2_+3A_digits">digits</code></td>
<td>
<p>number of significant digits for printing, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="rle2_+3A_prefix">prefix</code></td>
<td>
<p>character string, prepended to each printed line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are regarded as unequal to the previous value, even if
that is also missing.
</p>
<p><code>inverse.rle()</code> is the inverse function of <code>rle2()</code> and <code>rle()</code>,
reconstructing <code>x</code> from the runs.
</p>


<h3>Value</h3>

<p><code>rle()</code> returns an object of class <code>"rle"</code> which is a list
with components:
</p>
<table>
<tr><td><code>lengths</code></td>
<td>
<p>an integer vector containing the length of each run.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>a vector of the same length as <code>lengths</code> with the
corresponding values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rev(rep(6:10, 1:5))
rle(x)
## lengths [1:5]  5 4 3 2 1
## values  [1:5] 10 9 8 7 6
rle2(x)
## lengths: int [1:5] 5 4 3 2 1
## values : int [1:5] 10 9 8 7 6
## indices: int [1:5] 5 9 12 14 15
</code></pre>

<hr>
<h2 id='rmsd'> Root Mean Square Deviation </h2><span id='topic+rmsd'></span>

<h3>Description</h3>

<p>Calculate the RMSD between coordinate sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsd(a, b=NULL, a.inds=NULL, b.inds=NULL, fit=FALSE, ncore=1, nseg.scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsd_+3A_a">a</code></td>
<td>
<p> a numeric vector containing the reference coordinate set for
comparison with the coordinates in <code>b</code>.  Alternatively, if
<code>b=NULL</code> then <code>a</code> can be a matrix or list object
containing multiple coordinates for pairwise comparison. </p>
</td></tr>
<tr><td><code id="rmsd_+3A_b">b</code></td>
<td>
<p> a numeric vector, matrix or list object with an <code>xyz</code>
component, containing one or more coordinate sets to be compared with
<code>a</code>. </p>
</td></tr>
<tr><td><code id="rmsd_+3A_a.inds">a.inds</code></td>
<td>
<p> a vector of indices that selects the elements of
<code>a</code> upon which the calculation should be based. </p>
</td></tr>
<tr><td><code id="rmsd_+3A_b.inds">b.inds</code></td>
<td>
<p> a vector of indices that selects the elements of
<code>b</code> upon which the calculation should be based. </p>
</td></tr>
<tr><td><code id="rmsd_+3A_fit">fit</code></td>
<td>
<p>logical, if TRUE coordinate superposition is performed
prior to RMSD calculation. </p>
</td></tr>  
<tr><td><code id="rmsd_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="rmsd_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>RMSD is a standard measure of structural distance between
coordinate sets.
</p>
<p>Structure <code>a[a.inds]</code> and <code>b[b.inds]</code> should have the
same length.
</p>
<p>A least-squares fit is performed prior to RMSD calculation by setting
<code>fit=TRUE</code>.  See the function <code>fit.xyz</code> for more
details of the fitting process. 
</p>


<h3>Value</h3>

<p>Returns a numeric vector of RMSD value(s).
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fit.xyz">fit.xyz</a></code>, <code><a href="#topic+rot.lsq">rot.lsq</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redundant testing excluded

# -- Calculate RMSD between two or more structures
aln &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))
pdbs &lt;- read.fasta.pdb(aln)

# Gap positions
inds &lt;- gap.inspect(pdbs$xyz)

# Superposition before pairwise RMSD 
rmsd(pdbs$xyz, fit=TRUE)

# RMSD between structure 1 and structures 2 and 3
rmsd(a=pdbs$xyz[1,], b=pdbs$xyz[2:3,], a.inds=inds$f.inds, b.inds=inds$f.inds, fit=TRUE)

# RMSD between structure 1 and all structures in alignment
rmsd(a=pdbs$xyz[1,], b=pdbs, a.inds=inds$f.inds, b.inds=inds$f.inds, fit=TRUE)

# RMSD without superposition
rmsd(pdbs$xyz)



</code></pre>

<hr>
<h2 id='rmsf'> Atomic RMS Fluctuations </h2><span id='topic+rmsf'></span>

<h3>Description</h3>

<p>Calculate atomic root mean squared fluctuations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsf(xyz, grpby=NULL, average=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsf_+3A_xyz">xyz</code></td>
<td>
<p> numeric matrix of coordinates with each row corresponding
to an individual conformer. </p>
</td></tr>
<tr><td><code id="rmsf_+3A_grpby">grpby</code></td>
<td>
<p> a vector counting connective duplicated elements that
indicate the elements of 'xyz' that should be considered as a
group (e.g. atoms from a particular residue). If provided a
'pdb' object, grouping is automatically set by amino acid residues. </p>
</td></tr>
<tr><td><code id="rmsf_+3A_average">average</code></td>
<td>
<p> logical, if TRUE averaged over atoms. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>RMSF is an often used measure of conformational variance. It is calculated by
</p>
<p style="text-align: center;"><code class="reqn">f_i=\sqrt{\frac{1}{M-1}\sum_j \|r_i^j-r_i^0\|^2}</code>
</p>
<p>,
where <code class="reqn">f_i</code> is the RMSF value for the ith atom, M the total number of frames 
(total number of rows of <code>xyz</code>), <code class="reqn">r_i^j</code> the positional vector of the
ith atom in the jth frame, and <code class="reqn">r_i^0</code> the mean position of ith atom. 
||r|| denotes the Euclidean norm of the vector r.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of RMSF values. If <code>average=TRUE</code> a single numeric value
representing the averaged RMSF value over all atoms will be returned. 
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+fit.xyz">fit.xyz</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(transducin)

# Ignore Gaps
gaps &lt;- gap.inspect(pdbs$ali)

r &lt;- rmsf(pdbs$xyz)
plot(r[gaps$f.inds], typ="h", ylab="RMSF (A)")

detach(transducin)

## Not run: 

pdb &lt;- read.pdb("1d1d", multi=TRUE)
xyz &lt;- pdb$xyz

# superimpose trajectory
xyz &lt;- fit.xyz(xyz[1, ], xyz)

# select mainchain atoms
sele &lt;- atom.select(pdb, elety=c("CA", "C", "N", "O"))

# residue numbers to group by
resno &lt;- pdb$atom$resno[sele$atom]

# mean rmsf value of mainchain atoms of each residue
r &lt;- rmsf(xyz[, sele$xyz], grpby=resno)
plot.bio3d(r, resno=pdb, sse=pdb, ylab="RMSF (A)")


## End(Not run)

</code></pre>

<hr>
<h2 id='rmsip'> Root Mean Square Inner Product </h2><span id='topic+rmsip'></span><span id='topic+rmsip.default'></span><span id='topic+rmsip.enma'></span>

<h3>Description</h3>

<p>Calculate the RMSIP between two mode subspaces. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsip(...)

## S3 method for class 'enma'
rmsip(enma, ncore=NULL, subset=10, ...)

## Default S3 method:
rmsip(modes.a, modes.b, subset=10,
                        row.name="a", col.name="b", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsip_+3A_enma">enma</code></td>
<td>
<p> an object of class <code>"enma"</code> obtained from function
<code>nma.pdbs</code>. </p>
</td></tr>
<tr><td><code id="rmsip_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="rmsip_+3A_subset">subset</code></td>
<td>
<p> the number of modes to consider. </p>
</td></tr>   
<tr><td><code id="rmsip_+3A_modes.a">modes.a</code></td>
<td>
<p> an object of class <code>"pca"</code> or <code>"nma"</code> as
obtained from functions <code>pca.xyz</code> or <code>nma</code>. </p>
</td></tr>
<tr><td><code id="rmsip_+3A_modes.b">modes.b</code></td>
<td>
<p> an object of class <code>"pca"</code> or <code>"nma"</code> as
obtained from functions <code>pca.xyz</code> or <code>nma</code>. </p>
</td></tr>
<tr><td><code id="rmsip_+3A_row.name">row.name</code></td>
<td>
<p> prefix name for the rows. </p>
</td></tr>
<tr><td><code id="rmsip_+3A_col.name">col.name</code></td>
<td>
<p> prefix name for the columns. </p>
</td></tr>
<tr><td><code id="rmsip_+3A_...">...</code></td>
<td>
<p> arguments passed to associated functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>RMSIP is a measure for the similarity between two set of modes obtained
from principal component or normal modes analysis. 
</p>


<h3>Value</h3>

<p>Returns an <code>rmsip</code> object with the following components:
</p>
<table>
<tr><td><code>overlap</code></td>
<td>
<p> a numeric matrix containing pairwise (squared) dot products 
between the modes. </p>
</td></tr>
<tr><td><code>rmsip</code></td>
<td>
<p> a numeric RMSIP value. </p>
</td></tr>
</table>
<p>For function <code>rmsip.enma</code> a numeric matrix containing all
pairwise RMSIP values of the modes stored in the <code>enma</code> object.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.   
Amadei, A. et al. (1999) <em>Proteins</em> <b>36</b>, 19&ndash;424.   
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+nma">nma</a></code>,
<code><a href="#topic+overlap">overlap</a></code>.
</p>
<p>Other similarity measures:
<code><a href="#topic+sip">sip</a></code>, <code><a href="#topic+covsoverlap">covsoverlap</a></code>,
<code><a href="#topic+bhattacharyya">bhattacharyya</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load data for HIV example
trj &lt;- read.dcd(system.file("examples/hivp.dcd", package="bio3d"))
pdb &lt;- read.pdb(system.file("examples/hivp.pdb", package="bio3d"))

# Do PCA on simulation data
xyz.md &lt;- fit.xyz(pdb$xyz, trj, fixed.inds=1:ncol(trj))
pc.sim &lt;- pca.xyz(xyz.md)

# NMA 
modes &lt;- nma(pdb)

# Calculate the RMSIP between the MD-PCs and the NMA-MODEs
r &lt;- rmsip(modes, pc.sim, subset=10, row.name="NMA", col.name="PCA")

# Plot pairwise overlap values
plot(r, xlab="NMA", ylab="PCA")

## End(Not run)
</code></pre>

<hr>
<h2 id='sdENM'> Index for the sdENM ff </h2><span id='topic+sdENM'></span>

<h3>Description</h3>

<p>A dictonary of spring force constants for the sdENM force field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sdENM)
</code></pre>


<h3>Format</h3>

<p>An array of 27 matrices containg the spring force constants for the
&lsquo;sdENM&rsquo; force field (see Dehouch et al for more
information). Each matrix in the array holds the force constants for
all amino acid pairs for a specific distance range.
</p>
<p>See examples for more details.
</p>


<h3>Source</h3>

<p>Dehouck Y. &amp; Mikhailov A.S. (2013) <em>PLoS Comput Biol</em> <b>9</b>:e1003209.
</p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
Dehouck Y. et al. (2013) <em>PLoS Comput Biol</em> <b>9</b>:e1003209.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load force constant data
data(sdENM)

## force constants for amino acids A, C, D, E, and F
## in distance range [4, 4.5)
sdENM[1:5, 1:5, 1]

## and distance range [4.5, 5)
sdENM[1:5, 1:5, 2]

## amino acid pair A-P, at distance 4.2
sdENM["A", "P", 1]

## Not run: 
## for use in NMA
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
modes &lt;- nma(pdb, ff="sdenm")

## End(Not run)
</code></pre>

<hr>
<h2 id='seq2aln'> Add a Sequence to an Existing Alignmnet </h2><span id='topic+seq2aln'></span>

<h3>Description</h3>

<p>Add one or more sequences to an existing multiple alignment that you
wish to keep intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq2aln(seq2add, aln, id = "seq", file = "aln.fa", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq2aln_+3A_seq2add">seq2add</code></td>
<td>
<p> an sequence character vector or an alignment list
object with <code>id</code> and <code>ali</code> components, similar to that
generated by <code><a href="#topic+read.fasta">read.fasta</a></code> and <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
<tr><td><code id="seq2aln_+3A_aln">aln</code></td>
<td>
<p> an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>
and <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
<tr><td><code id="seq2aln_+3A_id">id</code></td>
<td>
<p> a vector of sequence names to serve as sequence
identifers. </p>
</td></tr>
<tr><td><code id="seq2aln_+3A_file">file</code></td>
<td>
<p> name of &lsquo;FASTA&rsquo; output file to which alignment
should be written. </p>
</td></tr>
<tr><td><code id="seq2aln_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the &lsquo;MUSCLE&rsquo; program, to perform a profile
profile alignment, which MUST BE INSTALLED on your system and in the
search path for executables.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A system call is made to the &lsquo;MUSCLE&rsquo; program, which must be
installed on your system and in the search path for executables.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;MUSCLE&rsquo; is the work of Edgar:
Edgar (2004) <em>Nuc. Acid. Res.</em> <b>32</b>, 1792&ndash;1797.
</p>
<p>Full details of the &lsquo;MUSCLE&rsquo; algorithm, along with download and
installation instructions can be obtained from:<br />
<a href="http://www.drive5.com/muscle/">http://www.drive5.com/muscle/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+seqbind">seqbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
aa.1 &lt;- pdbseq( read.pdb("1bg2") )
aa.2 &lt;- pdbseq( read.pdb("3dc4") )
aa.3 &lt;- pdbseq( read.pdb("1mkj") )

aln &lt;- seqaln( seqbind(aa.1,aa.2) )

seq2aln(aa.3, aln)

## End(Not run)

</code></pre>

<hr>
<h2 id='seqaln'> Sequence Alignment with MUSCLE</h2><span id='topic+seqaln'></span>

<h3>Description</h3>

<p>Create multiple alignments of amino acid or nucleotide sequences
according to the method of Edgar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqaln(aln, id=NULL, profile=NULL, exefile="muscle", outfile="aln.fa", 
       protein=TRUE, seqgroup=FALSE, refine=FALSE, extra.args="",
       verbose=FALSE, web.args = list(), ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqaln_+3A_aln">aln</code></td>
<td>
<p> a sequence character matrix, as obtained from
<code><a href="#topic+seqbind">seqbind</a></code>, or an alignment list object as obtained from
<code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_id">id</code></td>
<td>
<p> a vector of sequence names to serve as sequence
identifers. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_profile">profile</code></td>
<td>
<p> a profile alignment of class &lsquo;fasta&rsquo;
(e.g. obtained from <code><a href="#topic+read.fasta">read.fasta</a></code>). The alignment
<code>aln</code> will be added to the profile. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_exefile">exefile</code></td>
<td>
<p> file path to the &lsquo;MUSCLE&rsquo; program on your system (i.e.
how is &lsquo;MUSCLE&rsquo; invoked). Alternatively, &lsquo;CLUSTALO&rsquo; can
be used. Also supported is using the &lsquo;msa&rsquo; package from Bioconductor
(need to install packages using <code>BiocManager::install()</code>). To do so, simply
set <code>exefile="msa"</code>. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_outfile">outfile</code></td>
<td>
<p> name of &lsquo;FASTA&rsquo; output file to which alignment
should be written. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_protein">protein</code></td>
<td>
<p> logical, if TRUE the input sequences are assumed to be
protein not DNA or RNA. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_seqgroup">seqgroup</code></td>
<td>
<p> logical, if TRUE similar sequences are grouped
together in the output. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_refine">refine</code></td>
<td>
<p> logical, if TRUE the input sequences are assumed to already
be aligned, and only tree dependent refinement is performed. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_extra.args">extra.args</code></td>
<td>
<p> a single character string containing extra command
line arguments for the alignment program. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE &lsquo;MUSCLE&rsquo; warning and error
messages are printed. </p>
</td></tr>
<tr><td><code id="seqaln_+3A_web.args">web.args</code></td>
<td>
<p> a &lsquo;list&rsquo; object containing arguments to perform
online sequence alignment using EMBL-EBI Web Services. 
See below for details. </p>
</td></tr> 
<tr><td><code id="seqaln_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the function
<code>msa::msaMuscle()</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequence alignment attempts to arrange the sequences of protein,
DNA or RNA, to highlight regions of shared similarity that may
reflect functional, structural, and/or evolutionary relationships
between the sequences.
</p>
<p>Aligned sequences are represented as rows within a matrix. Gaps
(&lsquo;-&rsquo;) are inserted between the aminoacids or nucleotides so that
equivalent characters are positioned in the same column.
</p>
<p>This function calls the &lsquo;MUSCLE&rsquo; program to perform a multiple 
sequence alignment, which must be installed on your system and in the search 
path for executables. If local &lsquo;MUSCLE&rsquo; can not be found, alignment
can still be performed via online web services (see below) with limited
features. 
</p>
<p>If you have a large number of input sequences (a few thousand), or they are
very long, the default settings may be too slow for practical
use. A good compromise between speed and accuracy is to run just the
first two iterations of the &lsquo;MUSCLE&rsquo; algorithm by setting the
<code>extra.args</code> argument to &ldquo;-maxiters 2&rdquo;.
</p>
<p>You can set &lsquo;MUSCLE&rsquo; to improve an existing alignment by setting
<code>refine</code> to TRUE.
</p>
<p>To inspect the sequence clustering used by &lsquo;MUSCLE&rsquo; to produce
alignments, include &ldquo;-tree2 tree.out&rdquo; in the <code>extra.args</code>
argument. You can then load the &ldquo;tree.out&rdquo; file with the
&lsquo;read.tree&rsquo; function from the &lsquo;ape&rsquo; package.
</p>
<p>&lsquo;CLUSTALO&rsquo; can be used as an alternative to &lsquo;MUSCLE&rsquo; by
specifiying <code>exefile='clustalo'</code>. This might be useful e.g. when
adding several sequences to a profile alignment. 
</p>
<p>If local &lsquo;MUSCLE&rsquo; or &lsquo;CLUSTALO&rsquo; program is unavailable, the alignment
can be performed via the &lsquo;msa&rsquo; package from the Bioconductor repository.
To do so, set <code>exefile="msa"</code>. Note that both &lsquo;msa&rsquo; and 
&lsquo;Biostrings&rsquo; packages need to be installed properly using <code>BiocManager::install()</code>. 
</p>
<p>If the access to any method metioned above fails, 
the function will attempt to perform alignment via the EMBL-EBI Web Services 
(See <a href="https://www.ebi.ac.uk/">https://www.ebi.ac.uk/</a>). In this case, the argument <code>web.args</code> 
cannot be empty and must contain at least user's E-Mail address. 
Note that as stated by EBI, a fake email address may result 
in your jobs being killed and your IP, organisation or entire domain being 
black-listed (See FAQs on <a href="https://www.ebi.ac.uk/">https://www.ebi.ac.uk/</a>). 
Possible parameters to be passed via <code>web.args</code> include:
</p>

<dl>
<dt>email</dt><dd><p> a string containing a valid E-Mail address. Required. </p>
</dd>
<dt>title</dt><dd><p> a string for the title of the job to be submitted to
the remote server. Optional. </p>
</dd>
<dt>timeout</dt><dd><p> integer specifying the number of seconds to wait for
the response of the server before a time out occurs. Default: 90. </p>
</dd>
</dl>

<p>An example of usage is <code>web.args=list(email='user_id@email.provider')</code>.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"fasta"</code> with the following components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>A system call is made to the &lsquo;MUSCLE&rsquo; program, which must be
installed on your system and in the search path for executables.
See <a href="http://thegrantlab.org/bio3d/articles/online/install_vignette/Bio3D_install.html">http://thegrantlab.org/bio3d/articles/online/install_vignette/Bio3D_install.html</a> for 
instructions of how to install this program.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;MUSCLE&rsquo; is the work of Edgar:
Edgar (2004) <em>Nuc. Acid. Res.</em> <b>32</b>, 1792&ndash;1797.
</p>
<p>Full details of the &lsquo;MUSCLE&rsquo; algorithm, along with download and
installation instructions can be obtained from:<br />
<a href="http://www.drive5.com/muscle/">http://www.drive5.com/muscle/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+get.seq">get.seq</a></code>, <code><a href="#topic+seqbind">seqbind</a></code>, 
<code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+plot.fasta">plot.fasta</a></code>,
<code><a href="#topic+blast.pdb">blast.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##-- Basic sequence alignemnt
seqs &lt;- get.seq(c("4q21_A", "1ftn_A"))
aln &lt;- seqaln(seqs)

##-- add a sequence to the (profile) alignment
seq &lt;- get.seq("1tnd_A")
aln &lt;- seqaln(seq, profile=aln)


##-- Read a folder/directory of PDB files
#pdb.path &lt;- "my_dir_of_pdbs"
#files  &lt;- list.files(path=pdb.path ,
#                     pattern=".pdb",
#                     full.names=TRUE)

##-- Use online files
files &lt;- get.pdb(c("4q21","1ftn"), URLonly=TRUE)

##-- Extract and store sequences
raw &lt;- NULL
for(i in 1:length(files)) {
  pdb &lt;- read.pdb(files[i])
  raw &lt;- seqbind(raw, pdbseq(pdb) )
}

##-- Align these sequences
aln &lt;- seqaln(raw, id=files, outfile="seqaln.fa")

##-- Read Aligned PDBs storing coordinate data
pdbs &lt;- read.fasta.pdb(aln) 

## Sequence identity
seqidentity(aln)

## Note that all the above can be done with the pdbaln() function:
#pdbs &lt;- pdbaln(files)


##-- For identical sequences with masking use a custom matrix
aa &lt;- seqbind(c("X","C","X","X","A","G","K"),
              c("C","-","A","X","G","X","X","K"))

aln &lt;- seqaln(aln=aln, id=c("a","b"), outfile="temp.fas", protein=TRUE,
               extra.args= paste("-matrix",
                system.file("matrices/custom.mat", package="bio3d"),
                "-gapopen -3.0 ",
                "-gapextend -0.5",
                "-center 0.0") )

## End(Not run)
</code></pre>

<hr>
<h2 id='seqaln.pair'> Sequence Alignment of Identical Protein Sequences </h2><span id='topic+seqaln.pair'></span>

<h3>Description</h3>

<p>Create multiple alignments of amino acid sequences according to the
method of Edgar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqaln.pair(aln, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqaln.pair_+3A_aln">aln</code></td>
<td>
<p> a sequence character matrix, as obtained from
<code><a href="#topic+seqbind">seqbind</a></code>, or an alignment list object as obtained from
<code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="seqaln.pair_+3A_...">...</code></td>
<td>
<p> additional arguments for the function <code><a href="#topic+seqaln">seqaln</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for the alignment of identical sequences only.
For standard alignment see the related function <code><a href="#topic+seqaln">seqaln</a></code>.
</p>
<p>This function is useful for determining the equivalences between
sequences and structures. For example in aligning a PDB sequence to an
existing multiple sequence alignment, where one would first mask the
alignment sequences and then run the alignment to determine equivalences.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A system call is made to the &lsquo;MUSCLE&rsquo; program, which must be
installed on your system and in the search path for executables.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>&lsquo;MUSCLE&rsquo; is the work of Edgar:
Edgar (2004) <em>Nuc. Acid. Res.</em> <b>32</b>, 1792&ndash;1797.
</p>
<p>Full details of the &lsquo;MUSCLE&rsquo; algorithm, along with download and
installation instructions can be obtained from:<br />
<a href="http://www.drive5.com/muscle/">http://www.drive5.com/muscle/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+seqbind">seqbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## NOTE: FOLLOWING EXAMPLE NEEDS MUSCLE INSTALLED
if(check.utility("muscle")) {

##- Aligning a PDB sequence to an existing sequence alignment


##- Simple example
aln &lt;- seqbind(c("X","C","X","X","A","G","K"),
               c("C","-","A","X","G","X","X","K"))

seqaln.pair(aln, outfile = tempfile())

}
</code></pre>

<hr>
<h2 id='seqbind'> Combine Sequences by Rows Without Recycling </h2><span id='topic+seqbind'></span>

<h3>Description</h3>

<p>Take vectors and/or matrices arguments and combine them row-wise without
recycling them (as is the case with <code><a href="base.html#topic+rbind">rbind</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqbind(..., blank = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqbind_+3A_...">...</code></td>
<td>
<p> vectors, matrices, and/or alignment &lsquo;fasta&rsquo;
objects to combine. </p>
</td></tr>
<tr><td><code id="seqbind_+3A_blank">blank</code></td>
<td>
<p> a character to add to short arguments, to achieve the
same length as the longer argument. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>"fasta"</code> with the following components:
</p>
<table>
<tr><td><code>ali</code></td>
<td>
<p> an alignment character matrix with a row per sequence and
a column per equivalent aminoacid/nucleotide. </p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p> sequence names as identifers.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.fasta">write.fasta</a></code>, <code><a href="base.html#topic+rbind">rbind</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read two pdbs
a.pdb &lt;- read.pdb("1bg2")
b.pdb &lt;- read.pdb("1goj")

seqs &lt;- seqbind(aa321(a.pdb$atom[a.pdb$calpha,"resid"]),
                aa321(b.pdb$atom[b.pdb$calpha,"resid"]))

# seqaln(seqs)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqidentity'> Percent Identity</h2><span id='topic+seqidentity'></span>

<h3>Description</h3>

<p>Determine the percent identity scores for aligned sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqidentity(alignment, normalize=TRUE, similarity=FALSE, ncore=1, nseg.scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqidentity_+3A_alignment">alignment</code></td>
<td>
<p> sequence alignment obtained from
<code><a href="#topic+read.fasta">read.fasta</a></code> or an alignment character matrix. </p>
</td></tr>
<tr><td><code id="seqidentity_+3A_normalize">normalize</code></td>
<td>
<p> logical, if TRUE output is normalized to values
between 0 and 1 otherwise percent identity is returned. </p>
</td></tr>
<tr><td><code id="seqidentity_+3A_similarity">similarity</code></td>
<td>
<p> logical, if TRUE sequence similarity is calculated
instead of identity. </p>
</td></tr>
<tr><td><code id="seqidentity_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr> 
<tr><td><code id="seqidentity_+3A_nseg.scale">nseg.scale</code></td>
<td>
<p> split input data into specified number of segments
prior to running multiple core calculation. See <code><a href="#topic+fit.xyz">fit.xyz</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The percent identity value is a single numeric score determined for
each pair of aligned sequences.  It measures the number of identical
residues (&ldquo;matches&rdquo;) in relation to the length of the alignment.
</p>


<h3>Value</h3>

<p>Returns a numeric matrix with all pairwise identity values.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+filter.identity">filter.identity</a></code>,
<code><a href="#topic+entropy">entropy</a></code>, <code><a href="#topic+consensus">consensus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
attach(kinesin)

ide.mat &lt;- seqidentity(pdbs)

# Plot identity matrix
plot.dmat(ide.mat, color.palette=mono.colors,
          main="Sequence Identity", xlab="Structure No.",
          ylab="Structure No.")

# Histogram of pairwise identity values
hist(ide.mat[upper.tri(ide.mat)], breaks=30,xlim=c(0,1),
     main="Sequence Identity", xlab="Identity")

# Compare two sequences
seqidentity( rbind(pdbs$ali[1,], pdbs$ali[15,]) )

detach(kinesin)
</code></pre>

<hr>
<h2 id='setup.ncore'> Setup for Running Bio3D Functions using Multiple CPU Cores </h2><span id='topic+setup.ncore'></span>

<h3>Description</h3>

<p>Internally used in parallelized Bio3D functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setup.ncore(ncore, bigmem = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup.ncore_+3A_ncore">ncore</code></td>
<td>

<p>User set (or default) value of &lsquo;ncore&rsquo;.
</p>
</td></tr>
<tr><td><code id="setup.ncore_+3A_bigmem">bigmem</code></td>
<td>

<p>logical, if TRUE also check the availability of &lsquo;bigmemory&rsquo; package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check packages and set correct value of &lsquo;ncore&rsquo;.
</p>


<h3>Value</h3>

<p>The actual value of &lsquo;ncore&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   setup.ncore(NULL)
   setup.ncore(1)
#   setup.ncore(2)
</code></pre>

<hr>
<h2 id='sip'> Square Inner Product </h2><span id='topic+sip'></span><span id='topic+sip.default'></span><span id='topic+sip.nma'></span><span id='topic+sip.enma'></span>

<h3>Description</h3>

<p>Calculate the correlation between two atomic fluctuation vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sip(...)

## S3 method for class 'nma'
sip(a, b, ...)

## S3 method for class 'enma'
sip(enma, ncore=NULL, ...)

## Default S3 method:
sip(v, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sip_+3A_enma">enma</code></td>
<td>
<p> an object of class <code>"enma"</code> obtained from function
<code>nma.pdbs</code>. </p>
</td></tr>
<tr><td><code id="sip_+3A_ncore">ncore</code></td>
<td>
<p> number of CPU cores used to do the calculation.
<code>ncore&gt;1</code> requires package &lsquo;parallel&rsquo; installed. </p>
</td></tr>
<tr><td><code id="sip_+3A_a">a</code></td>
<td>
<p> an &lsquo;nma&rsquo; object as object from function <code>nma</code> to
be compared to <code>b</code>. </p>
</td></tr>
<tr><td><code id="sip_+3A_b">b</code></td>
<td>
<p> an &lsquo;nma&rsquo; object as object from function <code>nma</code> to
be compared to <code>a</code>. </p>
</td></tr>
<tr><td><code id="sip_+3A_v">v</code></td>
<td>
<p> a numeric vector containing the atomic fluctuation values. </p>
</td></tr>
<tr><td><code id="sip_+3A_w">w</code></td>
<td>
<p> a numeric vector containing the atomic fluctuation values. </p>
</td></tr>
<tr><td><code id="sip_+3A_...">...</code></td>
<td>
<p> arguments passed to associated functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>SIP is a measure for the similarity of atomic fluctuations of two
proteins, e.g. experimental b-factors, theroetical RMSF values, or 
atomic fluctuations obtained from NMA.
</p>


<h3>Value</h3>

<p>Returns the similarity coefficient(s).
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Skjaerven, L. et al. (2014) <em>BMC Bioinformatics</em> <b>15</b>, 399.
Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.   
Fuglebakk, E. et al. (2013) <em>JCTC</em> <b>9</b>, 5618&ndash;5628.
</p>


<h3>See Also</h3>

<p>Other similarity measures:
<code><a href="#topic+covsoverlap">covsoverlap</a></code>, <code><a href="#topic+bhattacharyya">bhattacharyya</a></code>,
<code><a href="#topic+rmsip">rmsip</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
a &lt;- nma(pdb)
b &lt;- nma(pdb, ff="anm")

sip(a$fluctuations, b$fluctuations)

</code></pre>

<hr>
<h2 id='sse.bridges'> SSE Backbone Hydrogen Bonding </h2><span id='topic+sse.bridges'></span>

<h3>Description</h3>

<p>Determine backbone C=O to N-H hydrogen bonding in secondary
structure elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse.bridges(sse, type="helix", hbond=TRUE, energy.cut=-1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sse.bridges_+3A_sse">sse</code></td>
<td>
<p> an sse object as obtained with <code>dssp</code>. </p>
</td></tr>
<tr><td><code id="sse.bridges_+3A_type">type</code></td>
<td>
<p> character string specifying &lsquo;helix&rsquo; or &lsquo;sheet&rsquo;. </p>
</td></tr>
<tr><td><code id="sse.bridges_+3A_hbond">hbond</code></td>
<td>
<p> use hbond records in the dssp output. </p>
</td></tr>
<tr><td><code id="sse.bridges_+3A_energy.cut">energy.cut</code></td>
<td>
<p> cutoff for the dssp hbond energy. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple functionality to parse the &lsquo;BP&rsquo; and &lsquo;hbond&rsquo;
records of the DSSP output.
</p>
<p>Requires input from function <code>dssp</code> with arguments
<code>resno=FALSE</code> and <code>full=TRUE</code>. 
</p>


<h3>Value</h3>

<p>Returns a numeric matrix of two columns containing the residue ids
of the paired residues.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+dssp">dssp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Read a PDB file
pdb &lt;- read.pdb( system.file("examples/1hel.pdb", package="bio3d") )
sse &lt;- dssp(pdb, resno=FALSE, full=TRUE)

sse.bridges(sse, type="helix")

## End(Not run)
</code></pre>

<hr>
<h2 id='store.atom'> Store all-atom data from a PDB object </h2><span id='topic+store.atom'></span>

<h3>Description</h3>

<p>Not intended for public usage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store.atom(pdb=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="store.atom_+3A_pdb">pdb</code></td>
<td>
<p> A pdb object as obtained from read.pdb </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was requested by a user and has not been extensively
tested.  Hence it is not yet recommended for public usage.
</p>


<h3>Value</h3>

<p>Returns a matrix of all-atom data. If <code>pdb=NULL</code>, returns the default 
atom names to be stored. 
</p>


<h3>Note</h3>

<p> This function is still in development and is NOT part of the
offical bio3d package
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pdb &lt;- read.pdb( get.pdb("5p21", URLonly=TRUE) )
a &lt;- store.atom(pdb)
a[,,1:2]

## End(Not run)
</code></pre>

<hr>
<h2 id='struct.aln'> Structure Alignment Of Two PDB Files </h2><span id='topic+struct.aln'></span>

<h3>Description</h3>

<p>Performs a sequence and structural alignment of two PDB entities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.aln(fixed, mobile, fixed.inds=NULL, mobile.inds=NULL, 
           write.pdbs=TRUE, outpath = "fitlsq", prefix=c("fixed",
           "mobile"), max.cycles=10, cutoff=0.5, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.aln_+3A_fixed">fixed</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="struct.aln_+3A_mobile">mobile</code></td>
<td>
<p> an object of class <code>pdb</code> as obtained from
function <code>read.pdb</code>. </p>
</td></tr>
<tr><td><code id="struct.aln_+3A_fixed.inds">fixed.inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from
<code>atom.select</code> that selects the elements of <code>fixed</code> upon
which the calculation should be based.</p>
</td></tr>
<tr><td><code id="struct.aln_+3A_mobile.inds">mobile.inds</code></td>
<td>
<p> atom and xyz coordinate indices obtained from
<code>atom.select</code> that selects the elements of <code>mobile</code> upon
which the calculation should be based.</p>
</td></tr>
<tr><td><code id="struct.aln_+3A_write.pdbs">write.pdbs</code></td>
<td>
<p> logical, if TRUE the aligned structures are written
to PDB files.</p>
</td></tr>
<tr><td><code id="struct.aln_+3A_outpath">outpath</code></td>
<td>
<p> character string specifing the output directory when
<code>write.pdbs</code> is TRUE. </p>
</td></tr>
<tr><td><code id="struct.aln_+3A_prefix">prefix</code></td>
<td>
<p> a character vector of length 2 containing the filename
prefix in which the fitted structures should be written. </p>
</td></tr>
<tr><td><code id="struct.aln_+3A_max.cycles">max.cycles</code></td>
<td>
<p> maximum number of refinement cycles.</p>
</td></tr>
<tr><td><code id="struct.aln_+3A_cutoff">cutoff</code></td>
<td>
<p> standard deviation of the pairwise distances for
aligned residues at which the fitting refinement stops.</p>
</td></tr>
<tr><td><code id="struct.aln_+3A_...">...</code></td>
<td>
<p> extra arguments passed to <code>seqaln</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a sequence alignment followed by a structural
alignment of the two PDB entities. Cycles of refinement steps of the
structural alignment are performed to improve the fit by removing
atoms with a high structural deviation. The primary purpose of the
function is to allow rapid structural alignment (and RMSD analysis)
for protein structures with unequal, but related sequences.
</p>
<p>The function reports the residues of <code>fixed</code> and <code>mobile</code>
included in the final structural alignment, as well as the related
RMSD values.
</p>
<p>This function makes use of the underlying functions <code>seqaln</code>,
<code>rot.lsq</code>, and <code>rmsd</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>a.inds</code></td>
<td>
<p> atom and xyz indices of <code>fixed</code>. </p>
</td></tr>
<tr><td><code>b.inds</code></td>
<td>
<p> atom and xyz indices of <code>mobile</code>. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> fitted xyz coordinates of <code>mobile</code>. </p>
</td></tr>
<tr><td><code>rmsd</code></td>
<td>
<p> a numeric vector of RMSD values after each cycle of
refinement. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjarven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rmsd">rmsd</a></code>, <code><a href="#topic+rot.lsq">rot.lsq</a></code>,
<code><a href="#topic+seqaln">seqaln</a></code>, <code><a href="#topic+pdbaln">pdbaln</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Needs MUSCLE installed - testing excluded

if(check.utility("muscle")) {

     ## Stucture of PKA:
     a &lt;- read.pdb("1cmk")

     ## Stucture of PKB:
     b &lt;- read.pdb("2jdo")

     ## Align and fit b on to a:
     path = file.path(tempdir(), "struct.aln")
     aln &lt;- struct.aln(a, b, outpath = path, outfile = tempfile())
     
     ## Should be the same as aln$rmsd (when using aln$a.inds and aln$b.inds)
     rmsd(a$xyz, b$xyz, aln$a.inds$xyz, aln$b.inds$xyz, fit=TRUE)
     
     invisible( cat("\nSee the output files:", list.files(path, full.names = TRUE), sep="\n") )
}


## Not run: 
     ## Align two subunits of GroEL (open and closed states)
     a &lt;- read.pdb("1sx4")
     b &lt;- read.pdb("1xck")

     ## Select chain A only
     a.inds &lt;- atom.select(a, chain="A")
     b.inds &lt;- atom.select(b, chain="A")

     ## Align and fit:
     aln &lt;- struct.aln(a,b, a.inds, b.inds)

## End(Not run)
</code></pre>

<hr>
<h2 id='torsion.pdb'> Calculate Mainchain and Sidechain Torsion/Dihedral Angles </h2><span id='topic+torsion.pdb'></span>

<h3>Description</h3>

<p>Calculate all torsion angles for a given protein PDB structure object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torsion.pdb(pdb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torsion.pdb_+3A_pdb">pdb</code></td>
<td>
<p> a PDB structure object as obtained from
function <code>read.pdb</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conformation of a polypeptide chain can be usefully described in
terms of angles of internal rotation around its constituent bonds. See
the related <code>torsion.xyz</code> function, which is called by this
function, for details.
</p>


<h3>Value</h3>

<p>Returns a list object with the following components:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p> main chain torsion angle for atoms C,N,CA,C. </p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p> main chain torsion angle for atoms N,CA,C,N. </p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p> main chain torsion angle for atoms CA,C,N,CA. </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p> virtual torsion angle between consecutive C-alpha atoms. </p>
</td></tr>
<tr><td><code>chi1</code></td>
<td>
<p> side chain torsion angle for atoms N,CA,CB,*G. </p>
</td></tr>
<tr><td><code>chi2</code></td>
<td>
<p> side chain torsion angle for atoms CA,CB,*G,*D. </p>
</td></tr>
<tr><td><code>chi3</code></td>
<td>
<p> side chain torsion angle for atoms CB,*G,*D,*E. </p>
</td></tr>
<tr><td><code>chi4</code></td>
<td>
<p> side chain torsion angle for atoms *G,*D,*E,*Z. </p>
</td></tr>
<tr><td><code>chi5</code></td>
<td>
<p> side chain torsion angle for atoms *D,*E,*Z, NH1. </p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p> numeric matrix of &lsquo;justified&rsquo; coordinates. </p>
</td></tr>
<tr><td><code>tbl</code></td>
<td>
<p> a numeric matrix of psi, phi and chi torsion angles. </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>For the protein backbone, or main-chain atoms, the partial double-bond
character of the peptide bond between &lsquo;C=N&rsquo; atoms severely restricts
internal rotations.  In contrast, internal rotations around the single
bonds between &lsquo;N-CA&rsquo; and &lsquo;CA-C&rsquo; are only restricted by
potential steric collisions. Thus, to a good approximation, the
backbone conformation of each residue in a given polypeptide chain can
be characterised by the two angles phi and psi.
</p>
<p>Sidechain conformations can also be described by angles of internal
rotation denoted chi1 up to chi5 moving out along the sidechain.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+torsion.xyz">torsion.xyz</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+dssp">dssp</a></code>, <code><a href="#topic+stride">stride</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

##-- PDB torsion analysis
pdb &lt;- read.pdb( "1bg2" )
tor &lt;- torsion.pdb(pdb)
head(tor$tbl)

## basic Ramachandran plot
plot(tor$phi, tor$psi)

## torsion analysis of a single coordinate vector 
#inds &lt;- atom.select(pdb,"calpha")
#tor.ca &lt;- torsion.xyz(pdb$xyz[inds$xyz], atm.inc=1)

##-- Compare two PDBs to highlight interesting residues
aln &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))
m &lt;- read.fasta.pdb(aln)
a &lt;- torsion.xyz(m$xyz[1,],1)
b &lt;- torsion.xyz(m$xyz[2,],1)
d &lt;- wrap.tor(a-b)
plot(m$resno[1,],d, typ="h")

</code></pre>

<hr>
<h2 id='torsion.xyz'> Calculate Torsion/Dihedral Angles </h2><span id='topic+torsion.xyz'></span>

<h3>Description</h3>

<p>Defined from the Cartesian coordinates of four successive atoms
(A-B-C-D) the torsion or dihedral angle is calculated about an axis
defined by the middle pair of atoms (B-C).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torsion.xyz(xyz, atm.inc = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torsion.xyz_+3A_xyz">xyz</code></td>
<td>
<p> a numeric vector of Cartisean coordinates. </p>
</td></tr>
<tr><td><code id="torsion.xyz_+3A_atm.inc">atm.inc</code></td>
<td>
<p> a numeric value indicating the number of atoms to
increment by between successive torsion evaluations (see below). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conformation of a polypeptide or nucleotide chain can be usefully
described in terms of angles of internal rotation around its
constituent bonds.
</p>
<p>If a system of four atoms A-B-C-D is projected onto a plane normal to
bond B-C, the angle between the projection of A-B and the projection
of C-D is described as the torsion angle of A and D about bond B-C.
</p>
<p>By convention angles are measured in the range -180 to +180, rather
than from 0 to 360, with positive values defined to be in the
clockwise direction.
</p>
<p>With <code>atm.inc=1</code>, torsion angles are calculated for each set of
four successive atoms contained in <code>xyz</code> (i.e. moving along one
atom, or three elements of <code>xyz</code>, between sucessive
evaluations).  With <code>atm.inc=4</code>, torsion angles are calculated
for each set of four successive non-overlapping atoms contained in
<code>xyz</code> (i.e. moving along four atoms, or twelve elements of
<code>xyz</code>, between sucessive evaluations).
</p>


<h3>Value</h3>

<p>A numeric vector of torsion angles.
</p>


<h3>Note</h3>

<p> Contributions from Barry Grant. </p>


<h3>Author(s)</h3>

<p> Karim ElSawy </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+torsion.pdb">torsion.pdb</a></code>, <code><a href="#topic+pca.tor">pca.tor</a></code>,
<code><a href="#topic+wrap.tor">wrap.tor</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calculate torsions for cis &amp; trans conformers
xyz &lt;- rbind(c(0,-0.5,0,1,0,0,1,1,0,0,1.5,0),
             c(0,-0.5,0,1,0,0,1,1,0,2,1.5,0)-3)
cis.tor   &lt;- torsion.xyz( xyz[1,] )
trans.tor &lt;- torsion.xyz( xyz[2,] )
apply(xyz, 1, torsion.xyz)


plot(range(xyz), range(xyz), xlab="", ylab="", typ="n", axes=FALSE)
  apply(xyz, 1, function(x){
    lines(matrix(x, ncol=3, byrow=TRUE), lwd=4)
    points(matrix(x, ncol=3, byrow=TRUE), cex=2.5,
           bg="white", col="black", pch=21) } )
  
  text( t(apply(xyz, 1, function(x){
    apply(matrix(x, ncol=3, byrow=TRUE)[c(2,3),], 2, mean) })),
       labels=c(0,180), adj=-0.5, col="red")


# PDB server connection required - testing excluded

##-- PDB torsion analysis
pdb &lt;- read.pdb("1bg2")
tor &lt;- torsion.pdb(pdb)
## basic Ramachandran plot
plot(tor$phi, tor$psi)

## torsion analysis of a single coordinate vector 
inds &lt;- atom.select(pdb,"calpha")
tor.ca &lt;- torsion.xyz(pdb$xyz[inds$xyz], atm.inc=3)

##-- Compare two PDBs to highlight interesting residues
aln &lt;- read.fasta(system.file("examples/kif1a.fa",package="bio3d"))
m &lt;- read.fasta.pdb(aln)
a &lt;- torsion.xyz(m$xyz[1,],1)
b &lt;- torsion.xyz(m$xyz[2,],1)
## Note the periodicity of torsion angles
d &lt;- wrap.tor(a-b)
plot(m$resno[1,],d, typ="h")



</code></pre>

<hr>
<h2 id='trim'> Trim a PDB Object To A Subset of Atoms. </h2><span id='topic+trim'></span><span id='topic+trim.pdb'></span>

<h3>Description</h3>

<p>Produce a new smaller PDB object, containing a subset of atoms, from a
given larger PDB object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(...)

## S3 method for class 'pdb'
trim(pdb, ..., inds = NULL, sse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_pdb">pdb</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code><a href="#topic+atom.select">atom.select</a></code>. If
<code>inds</code> is also provided, these arguments will be ignored. </p>
</td></tr>
<tr><td><code id="trim_+3A_inds">inds</code></td>
<td>
<p> a list object of ATOM and XYZ indices as obtained from
<code><a href="#topic+atom.select">atom.select</a></code>. If NULL, atom selection will be obtained
from calling <code>atom.select(pdb, ...)</code>. </p>
</td></tr>
<tr><td><code id="trim_+3A_sse">sse</code></td>
<td>
<p> logical, if &lsquo;FALSE&rsquo; helix and sheet components are
omitted from output. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic utility function for creating a new PDB object based
on a selection of atoms.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"pdb"</code> with the following components:
</p>
<table>
<tr><td><code>atom</code></td>
<td>
<p> a character matrix containing all atomic coordinate ATOM data, 
with a row per ATOM and a column per record type.  See below for details
of the record type naming convention (useful for accessing columns). </p>
</td></tr>
<tr><td><code>het</code></td>
<td>
<p> a character matrix containing atomic coordinate records
for atoms within &ldquo;non-standard&rdquo; HET groups (see <code>atom</code>). </p>
</td></tr>
<tr><td><code>helix</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of H
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>sheet</code></td>
<td>
 <p>&lsquo;start&rsquo;, &lsquo;end&rsquo; and &lsquo;length&rsquo; of E
type sse, where start and end are residue numbers &ldquo;resno&rdquo;. </p>
</td></tr>
<tr><td><code>seqres</code></td>
<td>
<p> sequence from SEQRES field. </p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric vector of ATOM coordinate data. </p>
</td></tr>
<tr><td><code>xyz.models</code></td>
<td>
<p> a numeric matrix of ATOM coordinate data for
multi-model PDB files. </p>
</td></tr>
<tr><td><code>calpha</code></td>
<td>
<p> logical vector with length equal to <code>nrow(atom)</code>
with TRUE values indicating a C-alpha &ldquo;elety&rdquo;. </p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>het</code> and <code>seqres</code> list components are returned unmodified.
</p>
<p>For both <code>atom</code> and <code>het</code> list components the column names can be
used as a convenient means of data access, namely:
Atom serial number &ldquo;eleno&rdquo;,
Atom type &ldquo;elety&rdquo;,
Alternate location indicator &ldquo;alt&rdquo;,
Residue name &ldquo;resid&rdquo;,
Chain identifier &ldquo;chain&rdquo;,
Residue sequence number &ldquo;resno&rdquo;,
Code for insertion of residues &ldquo;insert&rdquo;,
Orthogonal coordinates &ldquo;x&rdquo;,
Orthogonal coordinates &ldquo;y&rdquo;,
Orthogonal coordinates &ldquo;z&rdquo;,
Occupancy &ldquo;o&rdquo;, and
Temperature factor &ldquo;b&rdquo;.
See examples for further details.
</p>


<h3>Author(s)</h3>

<p> Barry Grant, Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim.pdbs">trim.pdbs</a></code>, <code><a href="#topic+trim.xyz">trim.xyz</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read a PDB file from the RCSB online database
pdb &lt;- read.pdb("1bg2")

## Select calpha atoms
sele &lt;- atom.select(pdb, "calpha")

## Trim PDB
new.pdb &lt;- trim.pdb(pdb, inds=sele)

## Or, simply
#new.pdb &lt;- trim.pdb(pdb, "calpha")

## Write to file
write.pdb(new.pdb, file="calpha.pdb")

## End(Not run)
</code></pre>

<hr>
<h2 id='trim.mol2'> Trim a MOL2 Object To A Subset of Atoms. </h2><span id='topic+trim.mol2'></span>

<h3>Description</h3>

<p>Produce a new smaller MOL2 object, containing a subset of atoms, from a
given larger MOL2 object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mol2'
trim(mol, ..., inds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.mol2_+3A_mol">mol</code></td>
<td>
<p> a MOL2 structure object obtained from
<code><a href="#topic+read.mol2">read.mol2</a></code>. </p>
</td></tr>
<tr><td><code id="trim.mol2_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code><a href="#topic+atom.select">atom.select</a></code>. If
<code>inds</code> is also provided, these arguments will be ignored. </p>
</td></tr>
<tr><td><code id="trim.mol2_+3A_inds">inds</code></td>
<td>
<p> a list object of ATOM and XYZ indices as obtained from
<code><a href="#topic+atom.select">atom.select</a></code>. If NULL, atom selection will be obtained
from calling <code>atom.select(mol, ...)</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic utility function for creating a new MOL2 object based
on a selection of atoms.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>"mol2"</code>.
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mol2">read.mol2</a></code>, <code><a href="#topic+atom.select.mol2">atom.select.mol2</a></code>,
<code><a href="#topic+as.pdb.mol2">as.pdb.mol2</a></code>, <code><a href="#topic+write.mol2">write.mol2</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read a MOL2 file from those included with the package
mol &lt;- read.mol2( system.file("examples/aspirin.mol2", package="bio3d"))

## Trim away H-atoms
mol &lt;- trim(mol, "noh")


## End(Not run)
</code></pre>

<hr>
<h2 id='trim.pdbs'> Filter or Trim a PDBs Object </h2><span id='topic+trim.pdbs'></span>

<h3>Description</h3>

<p>Trim residues and/or filter out structures from a PDBs object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdbs'
trim(pdbs, row.inds=NULL, col.inds=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.pdbs_+3A_pdbs">pdbs</code></td>
<td>
<p> an object of class <code>pdbs</code> as obtained from
function <code>pdbaln</code> or <code>read.fasta.pdb</code>; a xyz matrix
containing the cartesian coordinates of C-alpha atoms. </p>
</td></tr>
<tr><td><code id="trim.pdbs_+3A_row.inds">row.inds</code></td>
<td>
<p> a numeric vector of indices pointing to the PDB
structures to keep (rows in the <code>pdbs$ali</code> matrix). </p>
</td></tr>
<tr><td><code id="trim.pdbs_+3A_col.inds">col.inds</code></td>
<td>
<p> a numeric vector of indices pointing to the
alignment columns to keep (columns in the <code>pdbs$ali</code> matrix). </p>
</td></tr> 
<tr><td><code id="trim.pdbs_+3A_...">...</code></td>
<td>
<p> additional arguments passed to and from functions. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Utility function to remove structures, or trim off columns, in a   
&lsquo;pdbs&rsquo; object. 
</p>


<h3>Value</h3>

<p>Returns an updated &lsquo;pdbs&rsquo; object with the following
components:
</p>
<table>
<tr><td><code>xyz</code></td>
<td>
<p>numeric matrix of aligned C-alpha coordinates.</p>
</td></tr>
<tr><td><code>resno</code></td>
<td>
<p>character matrix of aligned residue numbers.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>numeric matrix of aligned B-factor values.</p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p>character matrix of aligned chain identifiers.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>character vector of PDB sequence/structure names.</p>
</td></tr>
<tr><td><code>ali</code></td>
<td>
<p>character matrix of aligned sequences.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdbaln">pdbaln</a></code>, <code><a href="#topic+gap.inspect">gap.inspect</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code>,<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+trim.pdb">trim.pdb</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Fetch PDB files and split to chain A only PDB files
ids &lt;- c("1a70_A", "1czp_A", "1frd_A", "1fxi_A", "1iue_A", "1pfd_A")
raw.files &lt;- get.pdb(ids, path = "raw_pdbs")
files &lt;- pdbsplit(raw.files, ids, path = "raw_pdbs/split_chain")

## Sequence Alignement, and connectivity check
pdbs &lt;- pdbaln(files)

cons &lt;- inspect.connectivity(pdbs)

## omit files with missing residues
trim.pdbs(pdbs, row.inds=which(cons))

## End(Not run)
</code></pre>

<hr>
<h2 id='trim.xyz'> Trim a XYZ Object of Cartesian Coordinates. </h2><span id='topic+trim.xyz'></span>

<h3>Description</h3>

<p>Produce a new smaller XYZ object, containing a subset of atoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xyz'
trim(xyz, row.inds = NULL, col.inds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.xyz_+3A_xyz">xyz</code></td>
<td>
<p> a XYZ object containing Cartesian coordinates,
e.g. obtained from <code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>. </p>
</td></tr>    
<tr><td><code id="trim.xyz_+3A_row.inds">row.inds</code></td>
<td>
<p> a numeric vector specifying which rows of the xyz
matrix to return. </p>
</td></tr>
<tr><td><code id="trim.xyz_+3A_col.inds">col.inds</code></td>
<td>
<p> a numeric vector specifying which columns of the xyz
matrix to return. </p>
</td></tr>
<tr><td><code id="trim.xyz_+3A_...">...</code></td>
<td>
<p> additional arguments passed to and from functions. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function provides basic functionality for subsetting a
matrix of class &lsquo;xyz&rsquo; while also maintaining the class
attribute. 
</p>


<h3>Value</h3>

<p>Returns an object of class <code>xyz</code> with the Cartesian coordinates
stored in a matrix object with dimensions M x 3N, where N is the
number of atoms, and M number of frames. 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+as.xyz">as.xyz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read a PDB file from the RCSB online database
pdb &lt;- read.pdb("1bg2")

## Select calpha atoms
sele &lt;- atom.select(pdb, "calpha")

## Trim XYZ
trim(pdb$xyz, col.inds=sele$xyz)

## Equals to
pdb$xyz[, sele$xyz, drop=FALSE]

## End(Not run)
</code></pre>

<hr>
<h2 id='unbound'> Sequence Generation from a Bounds Vector </h2><span id='topic+unbound'></span>

<h3>Description</h3>

<p>Generate a sequence of consecutive numbers from a <code><a href="#topic+bounds">bounds</a></code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbound(start, end = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbound_+3A_start">start</code></td>
<td>
<p> vector of starting values, or a matrix containing starting and 
end values such as that obtained from <code><a href="#topic+bounds">bounds</a></code>. </p>
</td></tr>
<tr><td><code id="unbound_+3A_end">end</code></td>
<td>
<p> vector of (maximal) end values, such as that obtained from 
<code><a href="#topic+bounds">bounds</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple utility function that does the opposite of the
<code><a href="#topic+bounds">bounds</a></code> function. If <code>start</code> is a vector, <code>end</code> must 
be a vector having the same length as <code>start</code>. If <code>start</code> is a 
matrix with column names contain 'start' and 'end', such as that returned 
from <code><a href="#topic+bounds">bounds</a></code>, <code>end</code> can be skipped and both starting and 
end values will be extracted from <code>start</code>.
</p>


<h3>Value</h3>

<p>Returns a numeric sequence vector.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bounds">bounds</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
test &lt;- c(seq(1,5,1),8,seq(10,15,1))
b &lt;- bounds(test)
unbound(b)

</code></pre>

<hr>
<h2 id='uniprot'> Fetch UniProt Entry Data. </h2><span id='topic+uniprot'></span>

<h3>Description</h3>

<p>Fetch protein sequence and functional information from the UniProt
database. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniprot(accid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniprot_+3A_accid">accid</code></td>
<td>
<p> UniProt accession id. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a basic utility function for downloading information from the
UniProt database. UniProt contains protein sequence and functional
information.
</p>


<h3>Value</h3>

<p>Returns a list object with the following components:
</p>
<table>
<tr><td><code>accession</code></td>
<td>
<p> a character vector with UniProt accession id's. </p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p> abbreviated name. </p>
</td></tr>
<tr><td><code>fullName</code></td>
<td>
<p> full recommended protein name. </p>
</td></tr>
<tr><td><code>shortName</code></td>
<td>
<p> short protein name. </p>
</td></tr>
<tr><td><code>sequence</code></td>
<td>
<p> protein sequence. </p>
</td></tr>
<tr><td><code>gene</code></td>
<td>
<p> gene names. </p>
</td></tr>
<tr><td><code>organism</code></td>
<td>
<p> organism. </p>
</td></tr>
<tr><td><code>taxon</code></td>
<td>
<p> taxonomic lineage. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>See also the UniProt web-site for more information:<br />
<a href="https://www.uniprot.org/">https://www.uniprot.org/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+blast.pdb">blast.pdb</a></code>, <code><a href="#topic+get.seq">get.seq</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# UNIPROT server connection required - testing excluded

prot &lt;- uniprot('PH4H_HUMAN')
prot$fullName
prot$sequence

## End(Not run)
</code></pre>

<hr>
<h2 id='var.xyz'> Pairwise Distance Variance in Cartesian Coordinates </h2><span id='topic+var.xyz'></span><span id='topic+var.pdbs'></span>

<h3>Description</h3>

<p>Calculate the variance of all pairwise distances in an ensemble of
Cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.xyz(xyz, weights=TRUE)
var.pdbs(pdbs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.xyz_+3A_xyz">xyz</code></td>
<td>
<p> an object of class <code>"xyz"</code> containing Cartesian
coordinates in a matrix. </p>
</td></tr>
<tr><td><code id="var.xyz_+3A_weights">weights</code></td>
<td>
<p> logical, if TRUE weights are calculated based on the
pairwise distance variance. </p>
</td></tr>
<tr><td><code id="var.xyz_+3A_pdbs">pdbs</code></td>
<td>
<p> a &lsquo;pdbs&rsquo; object as object from function
<code>pdbaln</code>. </p>
</td></tr>
<tr><td><code id="var.xyz_+3A_...">...</code></td>
<td>
<p> arguments passed to associated functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the variance of all pairwise distances in an
ensemble of Cartesian coordinates. The primary use of this function is
to calculate weights to scale the pair force constant for NMA. 
</p>


<h3>Value</h3>

<p>Returns the a matrix of the pairwise distance variance, formated as
weights if &lsquo;weights=TRUE&rsquo;. 
</p>


<h3>Author(s)</h3>

<p> Lars Skjaerven </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.   
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+nma.pdbs">nma.pdbs</a></code> </p>

<hr>
<h2 id='vec2resno'> Replicate Per-residue Vector Values </h2><span id='topic+vec2resno'></span>

<h3>Description</h3>

<p>Replicate values in one vector based on consecutive entries in a second
vector. Useful for adding per-residue data to all-atom PDB files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2resno(vec, resno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2resno_+3A_vec">vec</code></td>
<td>
<p> a vector of values to be replicated.</p>
</td></tr>
<tr><td><code id="vec2resno_+3A_resno">resno</code></td>
<td>
<p> a reference vector or a PDB structure object, obtained
from <code><a href="#topic+read.pdb">read.pdb</a></code>, upon which replication is based. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can aid in mapping data to PDB structure files. For
example, residue conservation per position (or any other one value per
residue data) can be replicated to fit the B-factor field of an all
atom PDB file which can then be rendered according to this field in a
molecular viewer.
</p>
<p>A basic check is made to ensure that the number of consecutively
unique entries in the reference vector equals the length of the vector
to be replicated.
</p>


<h3>Value</h3>

<p>Returns a vector of replicated values.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+atom.select">atom.select</a></code>,
<code><a href="#topic+write.pdb">write.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>vec2resno(c("a","b"), c(1,1,1,1,2,2))
</code></pre>

<hr>
<h2 id='vmd'> View CNA Protein Structure Network Community Output in VMD </h2><span id='topic+vmd'></span><span id='topic+vmd.cna'></span><span id='topic+vmd.ecna'></span><span id='topic+vmd.cnapath'></span><span id='topic+vmd.ecnapath'></span>

<h3>Description</h3>

<p>This function generates a VMD scene file and a PDB file that can be 
read and rendered by the VMD molecular viewer. Chose &lsquo;color by chain&rsquo; 
to see corresponding regions of structure colored by community along with 
the community protein structure network. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmd(...)

## S3 method for class 'cna'
vmd(x, pdb, layout = layout.cna(x, pdb, k=3), 
		col.sphere=NULL, col.lines = "silver", weights = NULL, 
		radius = table(x$communities$membership)/5, alpha = 1,
		vmdfile = "network.vmd", pdbfile = "network.pdb", 
                full = FALSE, launch = FALSE, exefile=NULL, ...)
## S3 method for class 'ecna'
vmd(x, n=1, ...)
## S3 method for class 'cnapath'
vmd(x, pdb, out.prefix = "vmd.cnapath", spline = FALSE, 
   colors = c("blue", "red"), launch = FALSE, exefile=NULL, mag=1.0, ...)
## S3 method for class 'ecnapath'
vmd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmd_+3A_x">x</code></td>
<td>
<p>A 'cna' or 'cnapath' class object, or a list of such objects, as 
obtained from functions <code>cna</code> or <code>cnapath</code>.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_n">n</code></td>
<td>
<p> The index to indicate which network or path to view with <code>vmd</code>. </p>
</td></tr>
<tr><td><code id="vmd_+3A_pdb">pdb</code></td>
<td>
<p>A 'pdb' class object such as obtained from &lsquo;read.pdb&rsquo; function.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_layout">layout</code></td>
<td>
<p> A numeric matrix of Nx3 XYZ coordinate matrix, where N is the 
number of community spheres to be drawn.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_col.sphere">col.sphere</code></td>
<td>
<p> A numeric vector containing the sphere colors.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_col.lines">col.lines</code></td>
<td>
<p> A character object specifying the color of the
edges (default 'silver'). Must use VMD colors names.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_weights">weights</code></td>
<td>
<p> A numeric vector specifying the edge width. Default is
taken from E(x$community.network)$weight.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_radius">radius</code></td>
<td>
<p> A numeric vector containing the sphere radii. Default
is taken from the number of community members divided by 5.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_alpha">alpha</code></td>
<td>
<p> A single element numeric vector specifying the VMD alpha
transparency parameter. Default is set to 1.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_vmdfile">vmdfile</code></td>
<td>
<p> A character element specifying the output VMD scene file 
name that will be loaded in VMD.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_pdbfile">pdbfile</code></td>
<td>
<p> A character element specifying the output pdb file name to be
loaded in VMD.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_full">full</code></td>
<td>
<p> Logical, if TRUE the full all-atom network rather than the
clustered community network will be drawn. Intra community edges are
colored according to the community membership, while inter community
edges are thicker and colored black.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_launch">launch</code></td>
<td>
<p> Logical. If TRUE, a VMD session will be started with
the output of &lsquo;vmd.cna&rsquo;.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_out.prefix">out.prefix</code></td>
<td>
<p> Prefix for the names of output files, &lsquo;vmd.cnapath.vmd&rsquo;
and &lsquo;vmd.cnapath.pdb&rsquo;.
</p>
</td></tr>
<tr><td><code id="vmd_+3A_spline">spline</code></td>
<td>
<p> Logical, if TRUE all paths are displayed as spline
curves. 
</p>
</td></tr>
<tr><td><code id="vmd_+3A_colors">colors</code></td>
<td>

<p>Character vector or integer scalar, define path colors. If a
character vector, passed to <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code> function to generate the 
color scales. If an integer, color all paths the same way with VMD color 
ID equal to the integer. </p>
</td></tr>
<tr><td><code id="vmd_+3A_exefile">exefile</code></td>
<td>
<p> file path to the &lsquo;VMD&rsquo; program on your system (i.e.
how is &lsquo;VMD&rsquo; invoked). If <code>NULL</code>, use OS-dependent
default path to the program. </p>
</td></tr>
<tr><td><code id="vmd_+3A_mag">mag</code></td>
<td>
<p> A numeric factor to scale the maximal thickness of paths. </p>
</td></tr>
<tr><td><code id="vmd_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the function
<code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code> (in <code>vmd.cnapath</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>This function generates a scaled sphere (communities) and stick (edges) 
representation of the community network along with the corresponding protein 
structure divided into chains, one chain for each community. The sphere radii 
are proportional to the number of community members and the edge widths correspond 
to network edge weights.
</p>


<h3>Value</h3>

<p>Two files are generated as output. A pdb file with the residue chains
assigned according to the community and a text file containing The
drawing commands for the community representation.
</p>


<h3>Author(s)</h3>

<p>Barry Grant</p>


<h3>References</h3>

<p> Humphrey, W., Dalke, A. and Schulten, K., &ldquo;VMD - Visual Molecular Dynamics&rdquo; J. Molec. Graphics 1996, 14.1, 33-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

if (!requireNamespace("igraph", quietly = TRUE)) {
   message('Need igraph installed to run this example')
} else {

# Load the correlation network from MD data
attach(hivp)

# Read the starting PDB file to determine atom correspondence
pdbfile &lt;- system.file("examples/hivp.pdb", package="bio3d")
pdb &lt;- read.pdb(pdbfile)

# View cna 
vmd.cna(net, pdb, launch=FALSE)
## within VMD set 'coloring method' to 'Chain' and 'Drawing method' to Tube


##-- From NMA
pdb.gdi = read.pdb("1KJY")
pdb.gdi = trim.pdb(pdb.gdi, inds=atom.select(pdb.gdi, chain="A", elety="CA")) 
modes.gdi = nma(pdb.gdi)
cij.gdi = dccm(modes.gdi)
net.gdi = cna(cij.gdi, cutoff.cij=0.35)
#vmd.cna(net.gdi, pdb.gdi, alpha = 0.7, launch=TRUE)

detach(hivp)

}

## End(Not run)
</code></pre>

<hr>
<h2 id='vmd_colors'> VMD Color Palette </h2><span id='topic+vmd_colors'></span>

<h3>Description</h3>

<p>This function creates a character vector of the colors used by the VMD
molecular graphics program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmd_colors(n=33, picker=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmd_colors_+3A_n">n</code></td>
<td>
<p> The number of desired colors chosen in sequence
from the VMD color palette (&gt;=1) </p>
</td></tr>
<tr><td><code id="vmd_colors_+3A_picker">picker</code></td>
<td>
<p> Logical, if TRUE a color wheel plot will be produced to
aid with color choice. </p>
</td></tr>
<tr><td><code id="vmd_colors_+3A_...">...</code></td>
<td>
<p> Extra arguments passed to the <code>rgb</code> function, including
alpha transparency. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the underlying 33 RGB color codes from VMD, See
<a href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>. Note that colors will be
recycled if &ldquo;n&rdquo; &gt; 33 with a warning issued. When &lsquo;picker&rsquo; is
set to &ldquo;TRUE&rdquo; a color wheel of the requested colors will be
plotted to the currently active device.
</p>


<h3>Value</h3>

<p>Returns a character vector with color names.
</p>


<h3>Author(s)</h3>

<p>Barry Grant
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p><a href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bwr.colors">bwr.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a vector of 10 colors
clrs &lt;- vmd_colors(10)
vmd_colors(4, picker=TRUE)
</code></pre>

<hr>
<h2 id='wrap.tor'> Wrap Torsion Angle Data </h2><span id='topic+wrap.tor'></span>

<h3>Description</h3>

<p>Adjust angular data so that the absolute difference of any of the
observations from its mean is not greater than 180 degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap.tor(data, wrapav=TRUE, avestruc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap.tor_+3A_data">data</code></td>
<td>
<p> a numeric vector or matrix of torsion angle data as
obtained from <code>torsion.xyz</code>. </p>
</td></tr>
<tr><td><code id="wrap.tor_+3A_wrapav">wrapav</code></td>
<td>
<p> logical, if TRUE average structure is also
&lsquo;wrapped&rsquo; </p>
</td></tr>
<tr><td><code id="wrap.tor_+3A_avestruc">avestruc</code></td>
<td>
<p> a numeric vector corresponding to the average
structure </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is a basic utility function for coping with the periodicity of 
torsion angle data, by &lsquo;wraping&rsquo; angular data such that the 
absolute difference of any of the observations from its column-wise 
mean is not greater than 180 degrees.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix of wrapped torsion angle data.
</p>


<h3>Author(s)</h3>

<p> Karim ElSawy </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+torsion.xyz">torsion.xyz</a></code> </p>

<hr>
<h2 id='write.crd'> Write CRD File </h2><span id='topic+write.crd'></span>

<h3>Description</h3>

<p>Write a CHARMM CARD (CRD) coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.crd(pdb = NULL, xyz = pdb$xyz, resno = NULL, resid = NULL, 
   eleno = NULL, elety = NULL, segid = NULL, resno2 = NULL, b = NULL, 
   verbose = FALSE, file = "R.crd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.crd_+3A_pdb">pdb</code></td>
<td>
<p> a structure object obtained from <code><a href="#topic+read.pdb">read.pdb</a></code> or
<code><a href="#topic+read.crd">read.crd</a></code>. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_xyz">xyz</code></td>
<td>
<p> Cartesian coordinates as a vector or 3xN matrix. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_resno">resno</code></td>
<td>
<p> vector of residue numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_resid">resid</code></td>
<td>
<p> vector of residue types/ids of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_eleno">eleno</code></td>
<td>
<p> vector of element/atom numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_elety">elety</code></td>
<td>
<p> vector of element/atom types of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_segid">segid</code></td>
<td>
<p> vector of segment identifiers with length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_resno2">resno2</code></td>
<td>
<p> vector of alternate residue numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_b">b</code></td>
<td>
<p> vector of weighting factors of length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE progress details are printed. </p>
</td></tr>
<tr><td><code id="write.crd_+3A_file">file</code></td>
<td>
<p> the output file name. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the <code>xyz</code> argument is strictly required.  Other arguments
assume a default poly-ALA C-alpha structure with a blank segid and
B-factors equal to 0.00.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>Check that <code>resno</code> and <code>eleno</code> do not exceed &ldquo;9999&rdquo;.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of CHARMM CARD (CRD) format see:<br />
<a href="https://www.charmm.org/wiki//index.php/CHARMM:The_Basics">https://www.charmm.org/wiki//index.php/CHARMM:The_Basics</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.crd">read.crd</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>,
<code><a href="#topic+read.fasta">read.fasta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Read a PDB file
pdb &lt;- read.pdb( "1bg2" )
summary(pdb)
# Convert to CHARMM format
new &lt;- convert.pdb(pdb, type="charmm")
summary(new)
# Write a CRD file
write.crd(new, file="4charmm.crd")

## End(Not run)
</code></pre>

<hr>
<h2 id='write.fasta'> Write FASTA Formated Sequences </h2><span id='topic+write.fasta'></span>

<h3>Description</h3>

<p>Write aligned or un-aligned sequences to a FASTA format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fasta(alignment=NULL, ids=NULL, seqs=alignment$ali, gap=TRUE, file, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fasta_+3A_alignment">alignment</code></td>
<td>
<p>  an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_ids">ids</code></td>
<td>
<p> a vector of sequence names to serve as sequence identifers </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_seqs">seqs</code></td>
<td>
<p> an sequence or alignment character matrix or vector with a row per sequence </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_gap">gap</code></td>
<td>
<p> logical, if FALSE gaps will be removed. </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_file">file</code></td>
<td>
<p> name of output file.  </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_append">append</code></td>
<td>
<p> logical, if TRUE output will be appended to
<code>file</code>; otherwise, it will overwrite the contents of
<code>file</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>For a description of FASTA format see:
<a href="https://www.ncbi.nlm.nih.gov/BLAST/blastcgihelp.shtml">https://www.ncbi.nlm.nih.gov/BLAST/blastcgihelp.shtml</a>.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

## Read a PDB file
pdb &lt;- read.pdb("1bg2")

## Extract sequence from PDB file
s &lt;- aa321(pdb$seqres)                   # SEQRES
a &lt;- aa321(pdb$atom[pdb$calpha,"resid"]) # ATOM

## Write simple fasta file
#write.fasta( seqs=seqbind(s,a), file="eg.fa")
#write.fasta( ids=c("seqres","atom"), seqs=seqbind(s,a), file="eg.fa" )

outfile1 = file.path(tempdir(), "eg.fa")
write.fasta(list( id=c("seqres"),ali=s ), file = outfile1)
write.fasta(list( id=c("atom"),ali=a ), file = outfile1, append=TRUE)

## Align seqres and atom records
#seqaln(seqbind(s,a))

## Read alignment
aln&lt;-read.fasta(system.file("examples/kif1a.fa",package="bio3d"))

## Cut all but positions 130 to 245
aln$ali=aln$ali[,130:245]

outfile2 = file.path(tempdir(), "eg2.fa")
write.fasta(aln, file = outfile2)

invisible( cat("\nSee the output files:", outfile1, outfile2, sep="\n") )

</code></pre>

<hr>
<h2 id='write.mol2'> Write MOL2 Format Coordinate File </h2><span id='topic+write.mol2'></span>

<h3>Description</h3>

<p>Write a Sybyl MOL2 file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.mol2(mol, file = "R.mol2",  append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mol2_+3A_mol">mol</code></td>
<td>
<p> a MOL2 structure object obtained from
<code><a href="#topic+read.mol2">read.mol2</a></code>. </p>
</td></tr>
<tr><td><code id="write.mol2_+3A_file">file</code></td>
<td>
<p> the output file name. </p>
</td></tr>
<tr><td><code id="write.mol2_+3A_append">append</code></td>
<td>
<p> logical, if TRUE output is appended to the bottom of an
existing file (used primarly for writing multi-model files). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples for further details.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Lars Skjaerven
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read MOL2 file
mol &lt;- read.mol2( system.file("examples/aspirin.mol2", package="bio3d") )

# Trim away H-atoms
mol &lt;- trim(mol, "noh")

# Write new MOL2 file
#write.mol2(mol)

</code></pre>

<hr>
<h2 id='write.ncdf'> Write AMBER Binary netCDF files </h2><span id='topic+write.ncdf'></span>

<h3>Description</h3>

<p>Write coordinate data to a binary netCDF trajectory file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.ncdf(x, trjfile = "R.ncdf", cell = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.ncdf_+3A_x">x</code></td>
<td>
<p> A numeric matrix of xyz coordinates with a frame/structure
per row and a Cartesian coordinate per column. </p>
</td></tr>
<tr><td><code id="write.ncdf_+3A_trjfile">trjfile</code></td>
<td>
<p> name of the output trajectory file. </p>
</td></tr>
<tr><td><code id="write.ncdf_+3A_cell">cell</code></td>
<td>
<p> A numeric matrix of cell information with a frame/structure
per row and a cell length or angle per column. If NULL cell will not
be written. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writes an AMBER netCDF (Network Common Data Form) format trajectory
file with the help of David W. Pierce's (UCSD) ncdf4 package available
from CRAN.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

 
<p>See AMBER documentation for netCDF format description.
</p>
<p>NetCDF binary trajectory files are supported by the AMBER modules
sander, pmemd and ptraj. Compared to formatted trajectory files, the
binary trajectory files are smaller, higher precision and
significantly faster to read and write.
</p>
<p>NetCDF provides for file portability across architectures, allows for
backwards compatible extensibility of the format and enables the files
to be self-describing. Support for this format is available in VMD.
</p>


<h3>Author(s)</h3>

<p> Barry Grant </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
<a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a>
<a href="https://cirrus.ucsd.edu/~pierce/ncdf/">https://cirrus.ucsd.edu/~pierce/ncdf/</a>
<a href="https://ambermd.org/FileFormats.php#netcdf">https://ambermd.org/FileFormats.php#netcdf</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.dcd">read.dcd</a></code>, <code><a href="#topic+read.ncdf">read.ncdf</a></code>,
<code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+write.pdb">write.pdb</a></code>,
<code><a href="#topic+atom.select">atom.select</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##-- Read example trajectory file
trtfile &lt;- system.file("examples/hivp.dcd", package="bio3d")
trj &lt;- read.dcd(trtfile)

## Write to netCDF format
write.ncdf(trj, "newtrj.nc")

## Read trj
trj &lt;- read.ncdf("newtrj.nc")

## End(Not run)
</code></pre>

<hr>
<h2 id='write.pdb'> Write PDB Format Coordinate File </h2><span id='topic+write.pdb'></span>

<h3>Description</h3>

<p>Write a Protein Data Bank (PDB) file for a given &lsquo;xyz&rsquo;
Cartesian coordinate vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pdb(pdb = NULL, file = "R.pdb", xyz = pdb$xyz, type = NULL, resno = NULL,
 resid = NULL, eleno = NULL, elety = NULL, chain = NULL, insert = NULL, 
 alt = NULL, o = NULL, b = NULL, segid = NULL, elesy = NULL, charge = NULL, 
 append = FALSE, verbose = FALSE, chainter = FALSE, end = TRUE, sse = FALSE, 
 print.segid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pdb_+3A_pdb">pdb</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_file">file</code></td>
<td>
<p> the output file name. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_xyz">xyz</code></td>
<td>
<p> Cartesian coordinates as a vector or 3xN matrix. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_type">type</code></td>
<td>
<p> vector of record types, i.e. &quot;ATOM&quot; or &quot;HETATM&quot;, 
with length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_resno">resno</code></td>
<td>
<p> vector of residue numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_resid">resid</code></td>
<td>
<p> vector of residue types/ids of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_eleno">eleno</code></td>
<td>
<p> vector of element/atom numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_elety">elety</code></td>
<td>
<p> vector of element/atom types of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_chain">chain</code></td>
<td>
<p> vector of chain identifiers with length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_insert">insert</code></td>
<td>
<p> vector of insertion code with length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_alt">alt</code></td>
<td>
<p> vector of alternate record with length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_o">o</code></td>
<td>
<p> vector of occupancy values of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_b">b</code></td>
<td>
<p> vector of B-factors of length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_segid">segid</code></td>
<td>
<p> vector of segment id of length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_elesy">elesy</code></td>
<td>
<p> vector of element symbol of length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_charge">charge</code></td>
<td>
<p> vector of atomic charge of length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_append">append</code></td>
<td>
<p> logical, if TRUE output is appended to the bottom of an
existing file (used primarly for writing multi-model files). </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE progress details are printed. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_chainter">chainter</code></td>
<td>
<p> logical, if TRUE a TER line is inserted at termination
of a chain. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_end">end</code></td>
<td>
<p> logical, if TRUE END line is written. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_sse">sse</code></td>
<td>
<p> logical, if TRUE secondary structure annotations are written. </p>
</td></tr>
<tr><td><code id="write.pdb_+3A_print.segid">print.segid</code></td>
<td>
<p> logical, if FALSE segid will not be written. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the <code>xyz</code> argument is strictly required.  Other arguments
assume a default poly-ALA C-alpha structure with a blank chain id,
occupancy values of 1.00 and B-factors equal to 0.00.
</p>
<p>If the input argument <code>xyz</code> is a matrix then each row is assumed
to be a different structure/frame to be written to a
&ldquo;multimodel&rdquo; PDB file, with frames separated by &ldquo;END&rdquo;
records.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>Check that:
(1) <code>chain</code> is one character long e.g. &ldquo;A&rdquo;, and 
(2) <code>resno</code> and <code>eleno</code> do not exceed &ldquo;9999&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Barry Grant
with contributions from Joao Martins.
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pdb">read.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

# Read a PDB file
pdb &lt;- read.pdb( "1bg2" )

# Renumber residues
nums &lt;- as.numeric(pdb$atom[,"resno"])
nums &lt;- nums - (nums[1] - 1)

# Write out renumbered PDB file
outfile = file.path(tempdir(), "eg.pdb")
write.pdb(pdb=pdb, resno = nums, file = outfile)

invisible( cat("\nSee the output file:", outfile, sep = "\n") )

</code></pre>

<hr>
<h2 id='write.pir'> Write PIR Formated Sequences </h2><span id='topic+write.pir'></span>

<h3>Description</h3>

<p>Write aligned or un-aligned sequences to a PIR format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pir(alignment=NULL, ids=NULL, seqs=alignment$ali, 
   pdb.file = NULL, chain.first = NULL, resno.first = NULL,
   chain.last = NULL, resno.last = NULL, file, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pir_+3A_alignment">alignment</code></td>
<td>
<p>  an alignment list object with <code>id</code> and <code>ali</code>
components, similar to that generated by <code><a href="#topic+read.fasta">read.fasta</a></code>. </p>
</td></tr>
<tr><td><code id="write.pir_+3A_ids">ids</code></td>
<td>
<p> a vector of sequence names to serve as sequence identifers </p>
</td></tr>
<tr><td><code id="write.pir_+3A_seqs">seqs</code></td>
<td>
<p> an sequence or alignment character matrix or vector with a row per sequence </p>
</td></tr>
<tr><td><code id="write.pir_+3A_pdb.file">pdb.file</code></td>
<td>
<p> a vector of pdb filenames; For sequence, provide &quot;&quot;. </p>
</td></tr>
<tr><td><code id="write.pir_+3A_chain.first">chain.first</code></td>
<td>
<p> a vector of chain id for the first residue. </p>
</td></tr>
<tr><td><code id="write.pir_+3A_resno.first">resno.first</code></td>
<td>
<p> a vector of residue number for the first residue. </p>
</td></tr>
<tr><td><code id="write.pir_+3A_chain.last">chain.last</code></td>
<td>
<p> a vector of chain id for the last residue. </p>
</td></tr>
<tr><td><code id="write.pir_+3A_resno.last">resno.last</code></td>
<td>
<p> a vector of residue number for the last residue. </p>
</td></tr>
<tr><td><code id="write.pir_+3A_file">file</code></td>
<td>
<p> name of output file.  </p>
</td></tr>
<tr><td><code id="write.pir_+3A_append">append</code></td>
<td>
<p> logical, if TRUE output will be appended to
<code>file</code>; otherwise, it will overwrite the contents of
<code>file</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>PIR is required format for input alignment file to use Modeller. 
For a description of PIR format see:
<a href="https://salilab.org/modeller/manual/node501.html">https://salilab.org/modeller/manual/node501.html</a>.
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, 
<code><a href="#topic+write.fasta">write.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Needs MUSCLE installed - testing excluded

if(check.utility("muscle")) {

## Generate an input file for structural modeling of 
## transducin G-alpha subunit using the template 3SN6_A

## Read transducin alpha subunit sequence
seq &lt;- get.seq("P04695", outfile = tempfile())

## Read structure template
path = tempdir()
pdb.file &lt;- get.pdb("3sn6_A", path = path, split = TRUE)
pdb &lt;- read.pdb(pdb.file)

## Build an alignment between template and target
aln &lt;- seqaln(seqbind(pdbseq(pdb), seq), id = c("3sn6_A", seq$id), outfile = tempfile())

## Write PIR format alignment file
outfile = file.path(tempdir(), "eg.pir")
write.pir(aln, pdb.file = c(pdb.file, ""), file = outfile)

invisible( cat("\nSee the output file:", outfile, sep = "\n") )

}

</code></pre>

<hr>
<h2 id='write.pqr'> Write PQR Format Coordinate File </h2><span id='topic+write.pqr'></span>

<h3>Description</h3>

<p>Write a PQR file for a given &lsquo;xyz&rsquo; Cartesian coordinate vector
or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pqr(pdb = NULL, xyz = pdb$xyz, resno = NULL, resid = NULL, eleno =
NULL, elety = NULL, chain = NULL, o = NULL, b = NULL,
append = FALSE, verbose = FALSE, chainter = FALSE, file = "R.pdb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pqr_+3A_pdb">pdb</code></td>
<td>
<p> a PDB structure object obtained from
<code><a href="#topic+read.pdb">read.pdb</a></code> or <code><a href="#topic+read.pqr">read.pqr</a></code>. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_xyz">xyz</code></td>
<td>
<p> Cartesian coordinates as a vector or 3xN matrix. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_resno">resno</code></td>
<td>
<p> vector of residue numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_resid">resid</code></td>
<td>
<p> vector of residue types/ids of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_eleno">eleno</code></td>
<td>
<p> vector of element/atom numbers of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_elety">elety</code></td>
<td>
<p> vector of element/atom types of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_chain">chain</code></td>
<td>
<p> vector of chain identifiers with length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_o">o</code></td>
<td>
<p> atomic partial charge values of length equal to
length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_b">b</code></td>
<td>
<p> atomic radii values of length equal to length(xyz)/3. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_append">append</code></td>
<td>
<p> logical, if TRUE output is appended to the bottom of an
existing file (used primarly for writing multi-model files). </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_verbose">verbose</code></td>
<td>
<p> logical, if TRUE progress details are printed. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_chainter">chainter</code></td>
<td>
<p> logical, if TRUE a TER line is inserted between
chains. </p>
</td></tr>
<tr><td><code id="write.pqr_+3A_file">file</code></td>
<td>
<p> the output file name. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>PQR file format is basically the same as PDB format except for the fields of 
<code>o</code> and <code>b</code>. In PDB, these two fields are filled with &lsquo;Occupancy&rsquo;
and &lsquo;B-factor&rsquo; values, respectively, with each field 6-column long. 
In PQR, they are atomic &lsquo;partial charge&rsquo; and &lsquo;radii&rsquo; 
values, respectively, with each field 8-column long.
</p>
<p>Only the <code>xyz</code> argument is strictly required.  Other arguments
assume a default poly-ALA C-alpha structure with a blank chain id,
atomic charge values of 0.00 and atomic radii equal to 1.00.
</p>
<p>If the input argument <code>xyz</code> is a matrix then each row is assumed
to be a different structure/frame to be written to a
&ldquo;multimodel&rdquo; PDB file, with frames separated by &ldquo;END&rdquo;
records.
</p>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Note</h3>

<p>Check that:
(1) <code>chain</code> is one character long e.g. &ldquo;A&rdquo;, and 
(2) <code>resno</code> and <code>eleno</code> do not exceed &ldquo;9999&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Barry Grant
with contributions from Joao Martins.
</p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>
<p>For a description of PDB format (version3.3) see:<br />
<a href="http://www.wwpdb.org/documentation/format33/v3.3.html">http://www.wwpdb.org/documentation/format33/v3.3.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.pqr">read.pqr</a></code>, <code><a href="#topic+read.pdb">read.pdb</a></code>, 
<code><a href="#topic+write.pdb">write.pdb</a></code>, <code><a href="#topic+read.dcd">read.dcd</a></code>,
<code><a href="#topic+read.fasta.pdb">read.fasta.pdb</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# PDB server connection required - testing excluded

# Read a PDB file
pdb &lt;- read.pdb( "1bg2" )

# Write out in PQR format 
outfile = file.path(tempdir(), "eg.pqr")
write.pqr(pdb=pdb, file = outfile)

invisible( cat("\nSee the output file:", outfile, sep = "\n") )


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
