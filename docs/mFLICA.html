<!DOCTYPE html><html><head><title>Help for package mFLICA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mFLICA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#followingNetwork'><p>followingNetwork function</p></a></li>
<li><a href='#followingRelation'><p>followingRelation</p></a></li>
<li><a href='#getADJNetDen'><p>getADJNetDen function</p></a></li>
<li><a href='#getDynamicFollNet'><p>getDynamicFollNet function</p></a></li>
<li><a href='#getFactions'><p>getFactions function</p></a></li>
<li><a href='#getFactionSizeRatio'><p>getFactionSizeRatio function</p></a></li>
<li><a href='#getReachableNodes'><p>getReachableNodes function</p></a></li>
<li><a href='#mFLICA'><p>mFLICA: leadership-inference framework for multivariate time series</p></a></li>
<li><a href='#plotMultipleTimeSeries'><p>plotMultipleTimeSeries</p></a></li>
<li><a href='#TS'><p>A simulation time series of movement coordination of 30 individuals</p></a></li>
<li><a href='#TSNANNearestNeighborPropagation'><p>TSNANNearestNeighborPropagation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Leadership-Inference Framework for Multivariate Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>A leadership-inference framework for multivariate time series. The framework for multiple-faction-leadership inference from coordinated activities or 'mFLICA' uses a notion of a leader as an individual who initiates collective patterns that everyone in a group follows. Given a set of time series of individual activities, our goal is to identify periods of coordinated activity, find factions of coordination if more than one exist, as well as identify leaders of each faction. For each time step, the framework infers following relations between individual time series, then identifying a leader of each faction whom many individuals follow but it follows no one. A faction is defined as a group of individuals that everyone follows the same leader. 'mFLICA' reports following relations, leaders of factions, and members of each faction for each time step. Please see Chainarong Amornbunchornvej and Tanya Berger-Wolf (2018) &lt;<a href="https://doi.org/10.1137%2F1.9781611975321.62">doi:10.1137/1.9781611975321.62</a>&gt; for methodology and Chainarong Amornbunchornvej (2021) &lt;<a href="https://doi.org/10.1016%2Fj.softx.2021.100781">doi:10.1016/j.softx.2021.100781</a>&gt; for software when referring to this package in publications.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DarkEyes/mFLICA">https://github.com/DarkEyes/mFLICA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DarkEyes/mFLICA/issues">https://github.com/DarkEyes/mFLICA/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), dtw</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-24 05:53:05 UTC; Zero</td>
</tr>
<tr>
<td>Author:</td>
<td>Chainarong Amornbunchornvej
    <a href="https://orcid.org/0000-0003-3131-0370"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chainarong Amornbunchornvej &lt;grandca@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-24 10:52:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='followingNetwork'>followingNetwork function</h2><span id='topic+followingNetwork'></span>

<h3>Description</h3>

<p>followingNetwork is a support function for calculating a following network of a set of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>followingNetwork(TS, timeLagWindow, lagWindow = 0.1, sigma = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="followingNetwork_+3A_ts">TS</code></td>
<td>
<p>is a set of time series where <code>TS[i,t,d]</code> is a numeric value of <code>i</code>th time series at time <code>t</code> and dimension <code>d</code>.</p>
</td></tr>
<tr><td><code id="followingNetwork_+3A_timelagwindow">timeLagWindow</code></td>
<td>
<p>is a maximum possible time delay in the term of time steps.</p>
</td></tr>
<tr><td><code id="followingNetwork_+3A_lagwindow">lagWindow</code></td>
<td>
<p>is a maximum possible time delay in the term of percentage of time length of <code>TS</code>.</p>
</td></tr>
<tr><td><code id="followingNetwork_+3A_sigma">sigma</code></td>
<td>
<p>is a threshold of following relation. It is used to discretize an adjacency matrix <code>adjWeightedMat</code> to be a binary matrix <code>adjBinMat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns adjacency matrices of a following network of <code>TS</code>.
</p>
<table>
<tr><td><code>adjWeightedMat</code></td>
<td>
<p> An adjacency matrix of a following network
s.t. if <code>adjWeightedMat[i,j]&gt;0</code>, then <code>TS[i,,]</code> follows  <code>TS[j,,]</code> with a degree <code>adjWeightedMat[i,j]</code>. </p>
</td></tr>
<tr><td><code>adjBinMat</code></td>
<td>
<p> A binary version of <code>adjWeightedMat</code> s.t. <code>adjBinMat[i,j] &lt;- (adjWeightedMat[i,j] &gt;=sigma)</code> for any <code>i,j</code>.  </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run the function

out&lt;-followingNetwork(TS=mFLICA::TS[,60:90,],sigma=0.5)

</code></pre>

<hr>
<h2 id='followingRelation'>followingRelation</h2><span id='topic+followingRelation'></span>

<h3>Description</h3>

<p>followingRelation is a function that infers whether <code>Y</code> follows <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>followingRelation(Y, X, timeLagWindow, lagWindow = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="followingRelation_+3A_y">Y</code></td>
<td>
<p>is a T-by-D matrix of numerical time series of a follower</p>
</td></tr>
<tr><td><code id="followingRelation_+3A_x">X</code></td>
<td>
<p>is a T-by-D matrix numerical time series of a leader</p>
</td></tr>
<tr><td><code id="followingRelation_+3A_timelagwindow">timeLagWindow</code></td>
<td>
<p>is a maximum possible time delay in the term of time steps.</p>
</td></tr>
<tr><td><code id="followingRelation_+3A_lagwindow">lagWindow</code></td>
<td>
<p>is a maximum possible time delay in the term of percentage of length(X).
If <code>timeLagWindow</code> is missing, then <code>timeLagWindow=ceiling(lagWindow*length(X))</code>. The default is 0.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of following relation variables below.
</p>
<table>
<tr><td><code>follVal</code></td>
<td>
<p> is a following-relation value s.t. if <code>follVal</code> is positive, then <code>Y</code> follows <code>X</code>. If  <code>follVal</code> is negative, then <code>X</code> follows <code>Y</code>.
Otherwise, if <code>follVal</code> is zero, there is no following relation between <code>X,Y</code>. </p>
</td></tr>
<tr><td><code>dtwIndexVec</code></td>
<td>
<p> is a numeric vector of index-warping difference: dtwIndexVec[k] = dtwOut$index1[k] - dtwOut$index2[k] where dtwOut is the output from dtw::dtw(x=Y,y=X) function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data

leader&lt;- mFLICA::TS[1,1:200,]
follower&lt;- mFLICA::TS[2,1:200,]

# Run the function

out&lt;-followingRelation(Y=follower,X=leader)

</code></pre>

<hr>
<h2 id='getADJNetDen'>getADJNetDen function</h2><span id='topic+getADJNetDen'></span>

<h3>Description</h3>

<p>getADJNetDen is a support function for calculating a network density of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getADJNetDen(adjMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getADJNetDen_+3A_adjmat">adjMat</code></td>
<td>
<p>is an adjacency matrix of a dominant-distribution network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a value of network density of of a network for a given adjMat.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Given an example of adjacency matrix
A&lt;-matrix(FALSE,5,5)
A[2,1]&lt;-TRUE
A[c(3,4),2]&lt;-TRUE

# Get a network density of an adjacency matrix

getADJNetDen(adjMat=A)

</code></pre>

<hr>
<h2 id='getDynamicFollNet'>getDynamicFollNet function</h2><span id='topic+getDynamicFollNet'></span>

<h3>Description</h3>

<p>getDynamicFollNet is a support function for calculating a dynamic following network of a set of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDynamicFollNet(
  TS,
  timeWindow,
  timeShift,
  sigma = 0.5,
  lagWindow = 0.1,
  silentFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDynamicFollNet_+3A_ts">TS</code></td>
<td>
<p>is a set of time series where <code>TS[i,t,d]</code> is a numeric value of <code>i</code>th time series at time <code>t</code> and dimension <code>d</code>.</p>
</td></tr>
<tr><td><code id="getDynamicFollNet_+3A_timewindow">timeWindow</code></td>
<td>
<p>is a time window parameter that limits a length of each sliding window. The default is 10 percent of time series length.</p>
</td></tr>
<tr><td><code id="getDynamicFollNet_+3A_timeshift">timeShift</code></td>
<td>
<p>is a number of time steps a sliding window shifts from a previous window to the next one. The default is 10 percent of <code>timeWindow</code>.</p>
</td></tr>
<tr><td><code id="getDynamicFollNet_+3A_sigma">sigma</code></td>
<td>
<p>is a threshold of following relation. The default is 0.5.</p>
</td></tr>
<tr><td><code id="getDynamicFollNet_+3A_lagwindow">lagWindow</code></td>
<td>
<p>is a maximum possible time delay in the term of percentage of time length of <code>timeWindow</code> supplying to the followingNetwork function.</p>
</td></tr>
<tr><td><code id="getDynamicFollNet_+3A_silentflag">silentFlag</code></td>
<td>
<p>is a flag that prohibit the function to print the current status of process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns adjacency matrices of a dynamic following network of <code>TS</code> as well as the corresponding time series of network densities.
</p>
<table>
<tr><td><code>dyNetWeightedMat</code></td>
<td>
<p> An adjacency matrix of a dynamic following network
s.t. if <code>dyNetWeightedMat[i,j,t]&gt;0</code>, then <code>TS[i,,]</code> follows  <code>TS[j,,]</code> at time <code>t</code> with a degree <code>dyNetWeightedMat[i,j,t]</code>. </p>
</td></tr>
<tr><td><code>dyNetBinMat</code></td>
<td>
<p> A binary version of <code>dyNetWeightedMat</code> s.t. <code>dyNetWeightedMat[i,j,t] &lt;- (dyNetWeightedMat[i,j,t] &gt;=sigma)</code> for any <code>i,j,t</code>.  </p>
</td></tr>
<tr><td><code>dyNetWeightedDensityVec</code></td>
<td>
<p>A time series of dynamic network densities of <code>dyNetWeightedMat</code></p>
</td></tr>
<tr><td><code>dyNetBinDensityVec</code></td>
<td>
<p>A time series of dynamic network densities of <code>dyNetBinDensityVec</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run the function
out&lt;-getDynamicFollNet(TS=mFLICA::TS[,1:10,],timeWindow=5,timeShift = 5,sigma=0.5)

</code></pre>

<hr>
<h2 id='getFactions'>getFactions function</h2><span id='topic+getFactions'></span>

<h3>Description</h3>

<p>getFactions is a support function for inferring faction leaders and their members as well as a faction size ratio of each faction.
Leaders are nodes that have zero outgoing degree. Members of leader A's faction are nodes that have some directed path to A in a following network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFactions(adjMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFactions_+3A_adjmat">adjMat</code></td>
<td>
<p>is an adjacency matrix of a following network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of leader IDs, a list of faction members, and network densities of factions.
</p>
<table>
<tr><td><code>leaders</code></td>
<td>
<p> is a list of faction leader IDs  </p>
</td></tr>
<tr><td><code>factionMembers</code></td>
<td>
<p> is a list of members of factions where <code>factionMembers[[i]]</code> is a list of faction members of a leader <code>leaders[i]</code>'s faction. </p>
</td></tr>
<tr><td><code>factionSizeRatio</code></td>
<td>
<p> is a vector of faction size ratio of each faction.
<code>factionSizeRatio[i]</code> is a number of edges within a leader <code>leaders[i]</code>'s faction divided by N choose 2 where N is a number of all nodes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Given an example of adjacency matrix
A&lt;-matrix(FALSE,5,5)
A[2,1]&lt;-TRUE
A[c(3,4),2]&lt;-TRUE
A[5,3]&lt;-TRUE
# Get faction leaders and their members as well as a network density of each faction.

out&lt;-getFactions(adjMat=A)

</code></pre>

<hr>
<h2 id='getFactionSizeRatio'>getFactionSizeRatio function</h2><span id='topic+getFactionSizeRatio'></span>

<h3>Description</h3>

<p>getFactionSizeRatio is a support function for calculating a faction size ratio of a given faction.
A faction size ratio is a number of edges that connect between faction-member nodes divided by a number of total nodes within a following network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFactionSizeRatio(adjMat, members)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFactionSizeRatio_+3A_adjmat">adjMat</code></td>
<td>
<p>is an adjacency matrix of a dominant-distribution network.</p>
</td></tr>
<tr><td><code id="getFactionSizeRatio_+3A_members">members</code></td>
<td>
<p>is a list of member IDs of a given faction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a faction size ratio of a given faction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Given an example of adjacency matrix
A&lt;-matrix(FALSE,5,5)
A[2,1]&lt;-TRUE
A[c(3,4),2]&lt;-TRUE

# Get a faction size ratio of a given faction

getFactionSizeRatio(adjMat=A,members=c(1,2,3,4))

</code></pre>

<hr>
<h2 id='getReachableNodes'>getReachableNodes function</h2><span id='topic+getReachableNodes'></span>

<h3>Description</h3>

<p>getReachableNodes is a support function for inferring reachable nodes that have some directed path to a node <code>targetNode</code>.
This function uses Breadth-first search (BFS) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReachableNodes(adjMat, targetNode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReachableNodes_+3A_adjmat">adjMat</code></td>
<td>
<p>is an adjacency matrix of a following network of which its elements are binary: zero for no edge, and one for having an edge.</p>
</td></tr>
<tr><td><code id="getReachableNodes_+3A_targetnode">targetNode</code></td>
<td>
<p>is a node in a graph that we want to find a set of nodes that can reach this target node via some paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a set of node IDs <code>followers</code> that have some directed path to a node <code>targetNode</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Given an example of adjacency matrix
A&lt;-matrix(FALSE,5,5)
A[2,1]&lt;-TRUE
A[c(3,4),2]&lt;-TRUE
A[5,3]&lt;-TRUE
# Get a set of reachable nodes of targetNode.

followers&lt;-getReachableNodes(adjMat=A,targetNode=1)$followers

</code></pre>

<hr>
<h2 id='mFLICA'>mFLICA: leadership-inference framework for multivariate time series</h2><span id='topic+mFLICA'></span>

<h3>Description</h3>

<p>A leadership-inference framework for multivariate time series. The framework uses a notion of a leader as an individual who initiates collective patterns that everyone in a group follows. Given a set of time series of individual activities, our goal is to identify periods of coordinated activity, find factions of coordination if more than one exist, as well as identify leaders of each faction. For each time step, the framework infers following relations between individual time series, then identifying a leader of each faction whom many individuals follow but it follows no one. A faction is defined as a group of individuals that everyone follows the same leader. mFLICA reports following relations, leaders of factions, and members of each faction for each time step. Please see Chainarong Amornbunchornvej and Tanya Berger-Wolf (2018) &lt;doi:10.1137/1.9781611975321.62&gt; when referring to this package in publications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFLICA(
  TS,
  timeWindow,
  timeShift,
  lagWindow = 0.1,
  sigma = 0.5,
  silentFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFLICA_+3A_ts">TS</code></td>
<td>
<p>is a set of time series where <code>TS[i,t,d]</code> is a numeric value of <code>i</code>th time series at time <code>t</code> and dimension <code>d</code>.</p>
</td></tr>
<tr><td><code id="mFLICA_+3A_timewindow">timeWindow</code></td>
<td>
<p>is a time window parameter that limits a length of each sliding window. The default is 10 percent of time series length.</p>
</td></tr>
<tr><td><code id="mFLICA_+3A_timeshift">timeShift</code></td>
<td>
<p>is a number of time steps a sliding window shifts from a previous window to the next one. The default is 10 percent of <code>timeWindow</code>.</p>
</td></tr>
<tr><td><code id="mFLICA_+3A_lagwindow">lagWindow</code></td>
<td>
<p>is a maximum possible time delay in the term of percentage of time length of <code>timeWindow</code> supplying to the getDynamicFollNet function.</p>
</td></tr>
<tr><td><code id="mFLICA_+3A_sigma">sigma</code></td>
<td>
<p>is a threshold of following relation. The default is 0.5. Note that if <code>sigma</code> is not one, an individual might be a member of multiple factions.</p>
</td></tr>
<tr><td><code id="mFLICA_+3A_silentflag">silentFlag</code></td>
<td>
<p>is a flag that prohibit the function to print the current status of process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns dynamic following networks, as well as leaders of factions, and members of each faction for each time step.
</p>
<table>
<tr><td><code>dyNetOut$dyNetWeightedMat</code></td>
<td>
<p> An adjacency matrix of a dynamic following network
s.t. if <code>dyNetWeightedMat[i,j,t]&gt;0</code>, then <code>TS[i,,]</code> follows  <code>TS[j,,]</code> at time <code>t</code> with a degree <code>dyNetWeightedMat[i,j,t]</code>. </p>
</td></tr>
<tr><td><code>dyNetOut$dyNetBinMat</code></td>
<td>
<p> A binary version of <code>dyNetWeightedMat</code> s.t. <code>dyNetWeightedMat[i,j,t] &lt;- (dyNetWeightedMat[i,j,t] &gt;=sigma)</code> for any <code>i,j,t</code>.  </p>
</td></tr>
<tr><td><code>dyNetOut$dyNetWeightedDensityVec</code></td>
<td>
<p>A time series of dynamic network densities of <code>dyNetWeightedMat</code></p>
</td></tr>
<tr><td><code>dyNetOut$dyNetBinDensityVec</code></td>
<td>
<p>A time series of dynamic network densities of <code>dyNetBinDensityVec</code></p>
</td></tr>
<tr><td><code>leadersTimeSeries</code></td>
<td>
<p>A time series of leaders of each faction where <code>leadersTimeSeries[[t]]</code> is a set of leaders at time <code>t</code>. A number of factions is the same as a number of leaders.</p>
</td></tr>
<tr><td><code>factionMembersTimeSeries</code></td>
<td>
<p>A time series of sets of faction members where <code>factionMembersTimeSeries[[t]][[k]]</code> is a set of faction-members at time <code>t</code> leading by a leader <code>leadersTimeSeries[[t]][k]</code>. </p>
</td></tr>
<tr><td><code>factionSizeRatioTimeSeries</code></td>
<td>
<p>A time series of faction-size ratios of all individuals. A faction size ratio is a number of edges that connect between faction-member nodes divided by a number of total nodes within a following network. If a leader has a higher faction-size ratio, then it has more followers than a leader with a lower faction-size ratio. A faction-size ratio has a value between 0 and 1.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chainarong Amornbunchornvej, <a href="mailto:chai@ieee.org">chai@ieee.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run the function

obj1&lt;-mFLICA(TS=mFLICA::TS[,60:90,],timeWindow=10,timeShift=10,sigma=0.5)

# Plot time series of faction size ratios of all leaders

plotMultipleTimeSeries(TS=obj1$factionSizeRatioTimeSeries, strTitle="Faction Size Ratios")

</code></pre>

<hr>
<h2 id='plotMultipleTimeSeries'>plotMultipleTimeSeries</h2><span id='topic+plotMultipleTimeSeries'></span>

<h3>Description</h3>

<p>plotMultipleTimeSeries is a function for visualizing time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMultipleTimeSeries(TS, strTitle = "Time Series Plot", TSnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMultipleTimeSeries_+3A_ts">TS</code></td>
<td>
<p>is a set of time series where <code>TS[i,t,d]</code> is a numeric value of <code>i</code>th time series at time <code>t</code> and dimension <code>d</code>.</p>
</td></tr>
<tr><td><code id="plotMultipleTimeSeries_+3A_strtitle">strTitle</code></td>
<td>
<p>is a string of the plot title</p>
</td></tr>
<tr><td><code id="plotMultipleTimeSeries_+3A_tsnames">TSnames</code></td>
<td>
<p>is a list of legend of <code>X,Y</code> where TSnames[1] is a legend of <code>X</code> and  TSnames[2] is a legend of <code>Y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of ggplot class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run the function
plotMultipleTimeSeries(TS=mFLICA::TS[1:5,1:60,1])

</code></pre>

<hr>
<h2 id='TS'>A simulation time series of movement coordination of 30 individuals</h2><span id='topic+TS'></span>

<h3>Description</h3>

<p>A dataset containing simulated trajectories of 30 individuals moving to form coordination in x-y coordinates.
In the interval [1,200], ID1 leads the group and everyone follows. ID2 leads the group during the interval [201,400].
Lastly, ID3 leads the group during the interval [401,600]. The interval [601,800] is the time when everyone trying to stop moving.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TS
</code></pre>


<h3>Format</h3>

<p>An array with 30 rows of individuals, 800 columns of time steps, and 2 dimensions of coordinate (x,y):
</p>

<dl>
<dt>TS</dt><dd><p> It is a set of time series where <code>TS[i,t,d]</code> is a numeric value of <code>i</code>th time series at time <code>t</code> and dimension <code>d</code>.</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='TSNANNearestNeighborPropagation'>TSNANNearestNeighborPropagation</h2><span id='topic+TSNANNearestNeighborPropagation'></span>

<h3>Description</h3>

<p>TSNANNearestNeighborPropagation is a function that fills NA values with nearest real values in the past ( or future if the first position of time series is NA), for time series <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSNANNearestNeighborPropagation(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSNANNearestNeighborPropagation_+3A_x">X</code></td>
<td>
<p>is a T-by-D matrix numerical time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of following relation variables below.
</p>
<table>
<tr><td><code>Xout</code></td>
<td>
<p> is a T-by-D matrix numerical time series that all NAN have been filled with nearest real values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data

z&lt;-1:20
z[2:5]&lt;-NA
z&lt;-TSNANNearestNeighborPropagation(z)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
