<!DOCTYPE html><html><head><title>Help for package pcoxtime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcoxtime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.pcoxtime'><p>Extract coefficient estimates of pcoxtime object</p></a></li>
<li><a href='#coef.pcoxtimecv'><p>Extract coefficient estimates of pcoxtimecv object</p></a></li>
<li><a href='#coefvimp.pcoxtime'><p>Coefficient variable importance</p></a></li>
<li><a href='#concordScore.pcoxtime'><p>Compute the concordance statistic for the pcoxtime model</p></a></li>
<li><a href='#extractoptimal.pcoxtimecv'><p>Extract optimal parameter values</p></a></li>
<li><a href='#getResponse'><p>Extract response from the formula</p></a></li>
<li><a href='#parseFormula'><p>Parse formula and return response variable.</p></a></li>
<li><a href='#pcoxsurvfit.pcoxtime'><p>Compute survival curve and cumulative hazard from a pcoxtime model</p></a></li>
<li><a href='#pcoxtheme'><p>Set theme for pcoxtime plots</p></a></li>
<li><a href='#pcoxtime'><p>Fit penalized Cox model</p></a></li>
<li><a href='#pcoxtimecv'><p>Cross-validation for pcoxtime</p></a></li>
<li><a href='#pkgsExport'><p>Import and export various functions from various packages</p></a></li>
<li><a href='#plot.pcoxsurvfit'><p>Plot survival and cumulative hazard curves</p></a></li>
<li><a href='#plot.pcoxtimecv'><p>Plot solution path for pcoxtimecv</p></a></li>
<li><a href='#plot.Score'><p>Prediction performance</p></a></li>
<li><a href='#plot.varimp'><p>Generic method for plotting variable importance</p></a></li>
<li><a href='#predict.pcoxtime'><p>Prediction for pcoxtime model</p></a></li>
<li><a href='#predictedHazard'><p>Compute predicted hazard</p></a></li>
<li><a href='#predictRisk.pcoxtime'><p>Extract predictions from pcoxtime model</p></a></li>
<li><a href='#predictSurvProb.pcoxtime'><p>Predict survival probabilities at various time points</p></a></li>
<li><a href='#print.pcoxbasehaz'><p>Print baseline hazard function data frame</p></a></li>
<li><a href='#print.pcoxsurvfit'><p>Print a short summary of survival function</p></a></li>
<li><a href='#print.pcoxtime'><p>Print coefficients from a pcoxtime object</p></a></li>
<li><a href='#print.pcoxtimecv'><p>Print cross-validated pcoxtime object</p></a></li>
<li><a href='#pvimp.pcoxtime'><p>Permutation variable importance</p></a></li>
<li><a href='#riskset'><p>Compute the risk set indicator</p></a></li>
<li><a href='#simtdc'><p>Simulate survival data for time-dependent covariates</p></a></li>
<li><a href='#unscale'><p>Unscale scaled predictors.</p></a></li>
<li><a href='#varimp.pcoxtime'><p>Compute variable or coefficient importance score</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalized Cox Proportional Hazard Model for Time-Dependent
Covariates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits penalized models for both time-independent and time-dependent survival data. It fully implements elastic net and uses proximal gradient descent to solve the optimization problem. The package is an implementation of Steve Cygu and Benjamin M. Bolker. (2021) &lt;<a href="https://arxiv.org/abs/2102.02297">arXiv:2102.02297</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), survival, doParallel, parallel, foreach,
ggplot2, prodlim, riskRegression, PermAlgo, pec</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CYGUBICKO/pcoxtime-pkg">https://github.com/CYGUBICKO/pcoxtime-pkg</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-12 19:45:47 UTC; steve</td>
</tr>
<tr>
<td>Author:</td>
<td>Bicko Cygu <a href="https://orcid.org/0000-0002-9284-8863"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Trevor Hastie [cph] (getmin function implementation copied from package
    glmnet)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bicko Cygu &lt;cygubicko@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-13 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.pcoxtime'>Extract coefficient estimates of pcoxtime object</h2><span id='topic+coef.pcoxtime'></span><span id='topic+coefficients.pcoxtime'></span>

<h3>Description</h3>

<p>This function extracts the estimates for all the coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
coef(object, ...)

## S3 method for class 'pcoxtime'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code> model object</p>
</td></tr>
<tr><td><code id="coef.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced <code><a href="#topic+pcoxtime">pcoxtime</a></code> is printed, followed by coefficient estimates.
</p>


<h3>Value</h3>

<p>A vector of coefficient estimates.
</p>
<p>A vector of coefficient estimates.
</p>

<hr>
<h2 id='coef.pcoxtimecv'>Extract coefficient estimates of pcoxtimecv object</h2><span id='topic+coef.pcoxtimecv'></span><span id='topic+coefficients.pcoxtimecv'></span>

<h3>Description</h3>

<p>This function extracts cross-validation estimates for a particular lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtimecv'
coef(object, lambda, ...)

## S3 method for class 'pcoxtimecv'
coefficients(object, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pcoxtimecv_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> object</p>
</td></tr>
<tr><td><code id="coef.pcoxtimecv_+3A_lambda">lambda</code></td>
<td>
<p>the value of lambda for which to return the coefficient estimates. It can be any of the character string, &quot;min&quot;, &quot;optimal&quot; or &quot;best&quot; for optimal lambda; &quot;1se&quot; for 1 standard error lambda; or any numeric value for lambda. See details.</p>
</td></tr>
<tr><td><code id="coef.pcoxtimecv_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the coefficient estimates for optimal lambda-alpha pair or based on specified the value of lambda for an optimal alpha. If the value of lambda specified is not exact (not in lambdas), the nearest value is used, based on <code>nearest &lt;- function(values, value){values[which(abs(values-value)==min(abs(values-value)))]}</code>. It requires that <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> is run with <code>refit = TRUE</code>.
</p>


<h3>Value</h3>

<p>A data frame of coefficient estimates.
</p>
<p>A vector of coefficient estimates.
</p>

<hr>
<h2 id='coefvimp.pcoxtime'>Coefficient variable importance</h2><span id='topic+coefvimp.pcoxtime'></span>

<h3>Description</h3>

<p>Coefficient variable importance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefvimp.pcoxtime(object, relative = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefvimp.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code>.</p>
</td></tr>
<tr><td><code id="coefvimp.pcoxtime_+3A_relative">relative</code></td>
<td>
<p>logical. If <code>TRUE</code> the scores are divided by the absolute sum of the coefficients.</p>
</td></tr>
<tr><td><code id="coefvimp.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absolute value of the coefficients (parameters) corresponding the tuned pcoxtime object.
</p>


<h3>Value</h3>

<p>a named vector of variable scores (<code>estimate = "mean"</code>) or a data frame (<code>estimate = "quantile"</code>).
</p>

<hr>
<h2 id='concordScore.pcoxtime'>Compute the concordance statistic for the pcoxtime model</h2><span id='topic+concordScore.pcoxtime'></span><span id='topic+concordScore'></span>

<h3>Description</h3>

<p>The function computes the agreement between the observed response and the predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
concordScore(fit, newdata = NULL, stats = FALSE, reverse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concordScore.pcoxtime_+3A_fit">fit</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code>.</p>
</td></tr>
<tr><td><code id="concordScore.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula.</p>
</td></tr>
<tr><td><code id="concordScore.pcoxtime_+3A_stats">stats</code></td>
<td>
<p>logical. If <code>TRUE</code> all the related concordance statistics are returned.</p>
</td></tr>
<tr><td><code id="concordScore.pcoxtime_+3A_reverse">reverse</code></td>
<td>
<p>if TRUE (default) then assume that larger x values predict smaller response values y; a proportional hazards model is the common example of this.</p>
</td></tr>
<tr><td><code id="concordScore.pcoxtime_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="survival.html#topic+concordance">concordance</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes Harrell's C index for predictions for <code><a href="#topic+pcoxtime">pcoxtime</a></code> object and takes into account censoring. See <code><a href="survival.html#topic+concordance">concordance</a></code>.
</p>


<h3>Value</h3>

<p>an object containing the concordance, followed by the number of pairs that agree, disagree, are tied, and are not comparable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (packageVersion("survival")&gt;="3.2.9") {
   data(cancer, package="survival")
} else {
   data(veteran, package="survival")
}
# Penalized
lam &lt;- 0.1
alp &lt;- 0.5
pfit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
c1 &lt;- concordScore(pfit1)
c1

# Unpenalized
lam &lt;- 0
alp &lt;- 1
pfit2 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
c2 &lt;- concordScore(pfit2)
c2

</code></pre>

<hr>
<h2 id='extractoptimal.pcoxtimecv'>Extract optimal parameter values</h2><span id='topic+extractoptimal.pcoxtimecv'></span><span id='topic+extractoptimal'></span>

<h3>Description</h3>

<p>Extract cross-validation summaries and data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtimecv'
extractoptimal(object, what = c("optimal", "cvm", "coefs"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractoptimal.pcoxtimecv_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> object</p>
</td></tr>
<tr><td><code id="extractoptimal.pcoxtimecv_+3A_what">what</code></td>
<td>
<p>the summary or data frame to extract. Currently, three options are available: <code>what = "optimal"</code> extracts a data frame showing optimal parameter values, <code>what = "cvm"</code> extracts the data frame containing the mean cross-validation error for various lambda-alpha combination, and <code>what = "coef"</code>, requires <code>refit = TRUE</code> in <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code>,  extracts a data frame containing the coefficient estimates for various lambda-alpha combination.</p>
</td></tr>
<tr><td><code id="extractoptimal.pcoxtimecv_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract cross-validation summaries based on the optimal parameters or data frames containing all the summaries for all the parameter values.
</p>


<h3>Value</h3>

<p>A data frame depending on the specification described above.
</p>

<hr>
<h2 id='getResponse'>Extract response from the formula</h2><span id='topic+getResponse'></span>

<h3>Description</h3>

<p>Extract response from the formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResponse(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResponse_+3A_model">model</code></td>
<td>
<p>formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string. The name of the response variable
</p>

<hr>
<h2 id='parseFormula'>Parse formula and return response variable.</h2><span id='topic+parseFormula'></span>

<h3>Description</h3>

<p>Parse formula and return response variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseFormula(formula, data, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseFormula_+3A_formula">formula</code></td>
<td>
<p>Object of class formula describing 
the model.</p>
</td></tr>
<tr><td><code id="parseFormula_+3A_data">data</code></td>
<td>
<p>optional data frame containing.
variables specified in the formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string. The name of the response variable
</p>

<hr>
<h2 id='pcoxsurvfit.pcoxtime'>Compute survival curve and cumulative hazard from a pcoxtime model</h2><span id='topic+pcoxsurvfit.pcoxtime'></span><span id='topic+pcoxsurvfit'></span><span id='topic+pcoxbasehaz.pcoxtime'></span><span id='topic+pcoxbasehaz'></span>

<h3>Description</h3>

<p>Compute the predicted survivor and cumulative hazard function for a penalized Cox proportional hazard model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
pcoxsurvfit(fit, newdata, ...)

## S3 method for class 'pcoxtime'
pcoxbasehaz(fit, centered = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoxsurvfit.pcoxtime_+3A_fit">fit</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code> object</p>
</td></tr>
<tr><td><code id="pcoxsurvfit.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula.</p>
</td></tr>
<tr><td><code id="pcoxsurvfit.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
<tr><td><code id="pcoxsurvfit.pcoxtime_+3A_centered">centered</code></td>
<td>
<p>if <code>TRUE</code> (default), return data from a predicted survival function at the mean values of the predictors, if <code>FALSE</code> returns prediction for all predictors equal to zero (baseline hazard).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pcoxsurvfit</code> and <code>pcoxbasehaz</code> functions produce survival curves and estimated cumulative hazard, respectively, for the fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code> model. They both return the estimated survival probability and the estimated cumulative hazard, which are both Breslow estimate.
</p>
<p>The <code>pcoxbasehaz</code> is an alias for <code>pcoxsurvfit</code> which simply computed the predicted survival estimates (baseline).
</p>
<p>If the <code>newdata</code> argument is missing, the &quot;average&quot; survival or cumulative hazard estimates are produced with the predictor values equal to means of the data set. See <code><a href="survival.html#topic+survfit.coxph">survfit.coxph</a></code> for warning against this. If the <code>newdata</code> is specified, then the returned object will contain a matrix of both survival and cumulative hazard estimates with each column for each row in the <code>newdata</code>.
</p>


<h3>Value</h3>

<p><code>pcoxsurvfit</code> and <code>pcoxbasehaz</code> return S3 objects of class <code><a href="#topic+pcoxsurvfit.pcoxtime">pcoxsurvfit.pcoxtime</a></code> and <code><a href="#topic+pcoxbasehaz.pcoxtime">pcoxbasehaz.pcoxtime</a></code>, respectively:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>number of observations used in the fit.</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>total number of events of interest in the fit.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time points defined by the risk set.</p>
</td></tr>
<tr><td><code>n.risk</code></td>
<td>
<p>the number of individuals at risk at time <code>t</code>.</p>
</td></tr>
<tr><td><code>n.event</code></td>
<td>
<p>the number of events that occur at time <code>t</code>.</p>
</td></tr>
<tr><td><code>n.censor</code></td>
<td>
<p>the number of subjects who exit the risk set, without an event, at time <code>t</code>.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>a vector or a matrix of estimated survival function.</p>
</td></tr>
<tr><td><code>cumhaz</code>, <code>hazard</code></td>
<td>
<p>a vector or a matrix of estimated cumulative hazard.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call that produced the object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pcoxtime">pcoxtime</a></code>, <code><a href="#topic+plot.pcoxsurvfit">plot.pcoxsurvfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(heart, package="survival")
lam &lt;- 0.1
alp &lt;- 0.8
pfit &lt;- pcoxtime(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, lambda = lam
	, alpha = alp
)

# Survival estimate
psurv &lt;- pcoxsurvfit(pfit)
print(psurv)

# Baseline survival estimate
bsurv &lt;- pcoxbasehaz(pfit, centered = FALSE)

</code></pre>

<hr>
<h2 id='pcoxtheme'>Set theme for pcoxtime plots</h2><span id='topic+pcoxtheme'></span>

<h3>Description</h3>

<p>Sets a theme for pcoxtime and other ggplot objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoxtheme()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects (setting pcotime plotting theme).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
pcoxtheme()
data(heart, package="survival")
lam &lt;- 0.02
alp &lt;- 1
pfit &lt;- pcoxtime(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, lambda = lam
	, alpha = alp
)

# Plot survival curves
psurv &lt;- pcoxsurvfit(pfit)
plot(psurv)
</code></pre>

<hr>
<h2 id='pcoxtime'>Fit penalized Cox model</h2><span id='topic+pcoxtime'></span>

<h3>Description</h3>

<p>Fits a Cox model with either lasso, ridge or elasticnet penalty 
for both time-independent and time-dependent (varying) covariates survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoxtime(
  formula,
  data,
  alpha = 1,
  lambda = 1,
  maxiter = 1e+05,
  tol = 1e-08,
  quietly = FALSE,
  lambmax = FALSE,
  origin_scale = TRUE,
  contrasts.arg = NULL,
  xlevs = NULL,
  na.action = na.omit,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoxtime_+3A_formula">formula</code></td>
<td>
<p>object of class formula describing
the model. The response is specified similar to
<code><a href="survival.html#topic+Surv">Surv</a></code> function from package 
<strong>survival</strong>. The terms (predictors) are specified
on the right of &quot;~&quot; in the formula.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_data">data</code></td>
<td>
<p>optional data frame containing
variables specified in the formula.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_alpha">alpha</code></td>
<td>
<p>elasticnet mixing parameter, with 
<code class="reqn">0 \le\alpha\le 1</code>. See details</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for the lasso
penalization, with <code class="reqn">\lambda \ge 0</code>. 
<code class="reqn">\lambda = 0</code> fits unpenalized Cox
model. See details</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations to
convergence. Default is <code class="reqn">1e4</code>. Consider
increasing it if the model does not converge.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_tol">tol</code></td>
<td>
<p>convergence threshold for proximal
gradient gradient descent. Each proximal update
continues until the relative change in all the 
coefficients 
(i.e. <code class="reqn">\sqrt{\sum(\beta_{k+1} - \beta_k)^2}</code>/stepsize)
is less than tol. The default value is <code class="reqn">1e-8</code>.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_quietly">quietly</code></td>
<td>
<p>logical. If TRUE, iteration progress 
printed.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_lambmax">lambmax</code></td>
<td>
<p>logical. Sufficiently large, 
<code class="reqn">\lambda_{\max}</code>, that sets <code class="reqn">\beta = 0</code>
for regularization path. If TRUE, <code class="reqn">\lambda_{\max}</code>
is returned.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_origin_scale">origin_scale</code></td>
<td>
<p>logical. If TRUE (default), 
the estimated coefficients are returned on the 
original covariate scale. Otherwise, FALSE, 
coefficients are standardized.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>an optional list. See
the contrasts.arg of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_xlevs">xlevs</code></td>
<td>
<p>a named list of character vectors
giving the full set of levels to be assumed
for each factor. See <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates
what should happen when the data contain NAs.
See <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="pcoxtime_+3A_...">...</code></td>
<td>
<p>additional arguments not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm estimates the coefficients based on observed
survival data, with either time-independent or time-dependent
covariates, through penalized partial log-likelihood
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{pen} ~ \mathit{\ell(\beta)_{\alpha, \lambda}} = -\mathit{\ell(\beta)} + P_{\alpha, \lambda}(\beta)</code>
</p>

<p>using elasticnet (which combines both lasso and ridge) penalty
</p>
<p style="text-align: center;"><code class="reqn">\lambda\left(\alpha\sum_{i=1}^p|\beta_i| + 0.5(1 - \alpha)\sum_{i=1}^p\beta_i^2 \right)</code>
</p>
<p>.
</p>
<p><code>alpha = 1</code> (<code class="reqn">\alpha</code>) is the lasso penalty, 
and <code>alpha = 0</code> is the ridge penalty. <code>lambda = 0</code> fits 
the standard Cox proportional hazard model.
</p>
<p>User can provide a particular lambda. Typical usage is to 
use the <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> to select the optimal 
lambda first.
</p>
<p>The routine to handle time-dependent covariates is similar
to that implemented in <code><a href="survival.html#topic+coxph">coxph</a></code>: if there
are tied event times, Breslow approximation is used.
</p>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+pcoxtime">pcoxtime</a></code>:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>a named vector of coefficients. If any of the coefficients violates KKT conditions, the model will print a warning but still return coefficient estimates.</p>
</td></tr>
<tr><td><code>min.nloglik</code></td>
<td>
<p>estimated log-likelihood at convergence.</p>
</td></tr>
<tr><td><code>min.dev</code></td>
<td>
<p>the deviation satisfying the <code>tol</code> stopping creteria.</p>
</td></tr>
<tr><td><code>iter.dev</code></td>
<td>
<p>deviations between previous and current coefficient estimate at each iteration.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence message containing the number of iterations</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations used in the fit.</p>
</td></tr>
<tr><td><code>n.risk</code></td>
<td>
<p>the number of individuals at risk at time <code>t</code>.</p>
</td></tr>
<tr><td><code>n.event</code></td>
<td>
<p>the number of events that occur at time <code>t</code>.</p>
</td></tr>
<tr><td><code>n.censor</code></td>
<td>
<p>the number of subjects who exit the risk set, without an event, at time <code>t</code>.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time points defined by the risk set.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Surv object defining the event times and event status.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data frame used.</p>
</td></tr>
<tr><td><code>timevarlabel</code>, <code>eventvarlabel</code></td>
<td>
<p>time and event variables, respectively.</p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p>a vector of predictors/covariates in the model.</p>
</td></tr>
<tr><td><code>lambda</code>, <code>alpha</code></td>
<td>
<p>lambda and alpha used, respectively.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>model formula used in the fit.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>vector of column means of the X matrix. Subsequent survival curves are adjusted to this value.</p>
</td></tr>
<tr><td><code>assign</code>, <code>xlevels</code>, <code>terms</code></td>
<td>
<p>See <code><a href="stats.html#topic+model.frame">model.frame</a></code> for <code>assign</code>, <code>xlevels</code>, <code>contrasts</code> and <code>terms</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Time-independent covariates
if (packageVersion("survival")&gt;="3.2.9") {
	data(cancer, package="survival")
} else {
	data(veteran, package="survival")
}
## Fit unpenalized Cox using pcoxtime
lam &lt;- 0 # Should fit unpenalized Cox model
pfit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam 
	, alpha = 1
)
print(pfit1)

## fit survival::coxph
cfit1 &lt;- coxph(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, method = 'breslow'
	, ties = "breslow"
)
print(cfit1)

## Penalized Cox model (pcoxtime) 
lam &lt;- 0.1
alp &lt;- 0.5
pfit2 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam 
	, alpha = alp
)
print(pfit2)

# Time-varying covariates
data(heart, package="survival")
lam &lt;- 0.1
alp &lt;- 0.8
pfit2 &lt;- pcoxtime(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, lambda = lam
	, alpha = alp
)
print(pfit2)

</code></pre>

<hr>
<h2 id='pcoxtimecv'>Cross-validation for pcoxtime</h2><span id='topic+pcoxtimecv'></span>

<h3>Description</h3>

<p>Performs <code>k</code>-fold cross-validation for pcoxtime, plots 
solution path plots, and returns optimal value of lambda
(and optimal alpha if more than one is given).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoxtimecv(
  formula,
  data,
  alphas = 1,
  lambdas = NULL,
  nlambdas = 100,
  lammin_fract = NULL,
  lamfract = 0.6,
  nfolds = 10,
  foldids = NULL,
  devtype = "vv",
  refit = FALSE,
  maxiter = 1e+05,
  tol = 1e-08,
  quietly = FALSE,
  seed = NULL,
  nclusters = 1,
  na.action = na.omit,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoxtimecv_+3A_formula">formula</code></td>
<td>
<p>object of class formula describing
the model. The response is specified similar to
<code><a href="survival.html#topic+Surv">Surv</a></code> function from package
<strong>survival</strong>. The terms (predictors) are specified
on the right of &quot;~&quot; in the formula.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_data">data</code></td>
<td>
<p>optional data frame containing
variables specified in the formula.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_alphas">alphas</code></td>
<td>
<p>elasticnet mixing parameter, with
<code>0 &lt;= alphas &lt;= 1</code>. If a vector of  <code>alphas</code> is supplied, cross-validation will be performed for each of the <code>alphas</code> and optimal value returned. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_lambdas">lambdas</code></td>
<td>
<p>optional user-supplied sequence. If <code>lambdas = NULL</code> (default &ndash; highly recommended), the algorithm chooses its own sequence.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_nlambdas">nlambdas</code></td>
<td>
<p>the default number of lambdas values. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_lammin_fract">lammin_fract</code></td>
<td>
<p>smallest value of <code>lambda</code>, as fraction of maximum <code>lambda</code>. If <code>NULL</code>, default, it depends on the number of observations (n) relative to the number of variables (p). If <code>n &gt; p</code>, the default is <code>0.0001</code>, otherwise <code>0.01</code>. Increasing this value may lead to faster convergence.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_lamfract">lamfract</code></td>
<td>
<p>proportion of regularization path to consider. If <code>lamfract = 1</code>, complete regularization path is considered. However, if <code>0.5 &lt;= lamfract &lt;1</code>, only a proportion of the <code>nlambdas</code> considered. Choosing a smaller <code>lamfract</code> reduces computational time and potentially stable estimates for model with large number of predictors. See details.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds. Default is <code>10</code>. The smallest allowable is <code>nfolds = 3</code>.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_foldids">foldids</code></td>
<td>
<p>an optional sequence of values between <code>1</code> and nfolds specifying what fold each observation is in. This is important when comparing performance across models. If specified, <code>nfolds</code> can be missing.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_devtype">devtype</code></td>
<td>
<p>loss to use for cross-validation. Currently, two options are available but versions will implement <code><a href="#topic+concordScore.pcoxtime">concordScore.pcoxtime</a></code> loss too. The two are, default <code>(devtype = "vv")</code> Verweij Van Houwelingen partial-likelihood deviance and basic cross-validated parial likelihood <code>devtype = "basic"</code>. See Dai, B., and Breheny, P. (2019) for details.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_refit">refit</code></td>
<td>
<p>logical. Whether to return solution path based on optimal lambda and alpha picked by the model. Default is <code>refit = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations to convergence. Default is <code class="reqn">1e5</code>. Consider increasing it if the model does not converge.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_tol">tol</code></td>
<td>
<p>convergence threshold for proximal gradient gradient descent. Each proximal update continues until the relative change in all the coefficients (i.e. <code class="reqn">\sqrt{\sum(\beta_{k+1} - \beta_k)^2}</code>/stepsize) is less than tol. The default value is <code class="reqn">1e-8</code>.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_quietly">quietly</code></td>
<td>
<p>logical. If TRUE, refit progress is printed.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_seed">seed</code></td>
<td>
<p>random seed. Default is <code>NULL</code>, which generated the seed internally.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_nclusters">nclusters</code></td>
<td>
<p>number of cores to use to run the cross-validation in parallel. Default is <code>nclusters = 1</code> which runs serial.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs.</p>
</td></tr>
<tr><td><code id="pcoxtimecv_+3A_...">...</code></td>
<td>
<p>additional arguments not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits <code><a href="#topic+pcoxtime">pcoxtime</a></code> <code>folds + 1</code> (if <code>refit = FALSE</code>) or <code>folds + 2</code> times  (if <code>refit = FALSE</code>). In the former case, the solution path to display using <code><a href="#topic+plot.pcoxtimecv">plot.pcoxtimecv</a></code> is randomly picked from all the cross-validation runs. However, in the later case, the solution path plot is based on the model refitted using the optimal parameters. In both cases, the function first runs  <code><a href="#topic+plot.pcoxtimecv">plot.pcoxtimecv</a></code> to compute the lambda sequence and then perform cross-validation on <code>nfolds</code>.
</p>
<p>If more than one <code>alphas</code> is specified, say code(0.2, 0.5, 1), the <code>pcoxtimecv</code> will search (experimental) for optimal values for alpha with respect to the corresponding lambda values. In this case, optimal alpha and lambda sequence will be returned, i.e., the <code>(alphas, lambdas)</code> pair that corresponds to the lowest predicted cross-validated error (likelihood deviance).
</p>
<p>For data sets with a very large number of predictors, it is recommended to only calculate partial paths by lowering the value of <code>lamfract</code>. In other words, for <code>p &gt; n</code> problems, the near <code>lambda = 0</code> solution is poorly behaved and this may account for over <code>99%</code> of the function's runtime. We therefore recommend always specifying <code>lamfract &lt; 1</code> and increase if the optimal lambda suggests lower values.
</p>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code>:
</p>
<table>
<tr><td><code>lambda.min</code></td>
<td>
<p>the value of lambda that gives minimum cross-validated error.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>largest value of lambda such that error is within <code>1</code> standard error of the minimum.</p>
</td></tr>
<tr><td><code>alpha.optimal</code></td>
<td>
<p>optimal alpha corresponding to <code>lambda.min</code>.</p>
</td></tr>
<tr><td><code>lambdas.optimal</code></td>
<td>
<p>the sequence of lambdas containing <code>lambda.min</code>.</p>
</td></tr>
<tr><td><code>foldids</code></td>
<td>
<p>the fold assignment used.</p>
</td></tr>
<tr><td><code>dfs</code></td>
<td>
<p>list of data frames containing mean cross-validated error summaries and estimated coefficients in each fold.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>if <code>refit = TRUE</code>, summaries corresponding to the optimal <code>alpha</code> and <code>lambdas</code>. This is used to plot solution path</p>
</td></tr></table>
<p>.
</p>


<h3>References</h3>

<p>Dai, B., and Breheny, P. (2019). <em>Cross validation approaches for penalized Cox regression</em>. <em>arXiv preprint arXiv:1905.10432</em>.
</p>
<p>Simon, N., Friedman, J., Hastie, T., Tibshirani, R. (2011) <em>Regularization Paths for Cox's Proportional Hazards Model via Coordinate Descent, Journal of Statistical Software, Vol. 39(5) 1-13</em> <a href="https://doi.org/10.18637/jss.v039.i05">doi:10.18637/jss.v039.i05</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pcoxtimecv">plot.pcoxtimecv</a></code>, <code><a href="#topic+pcoxtime">pcoxtime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Time-independent covariates
if (packageVersion("survival")&gt;="3.2.9") {
   data(cancer, package="survival")
} else {
   data(veteran, package="survival")
}

cv1 &lt;- pcoxtimecv(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, alphas = 1
	, refit = FALSE
	, lamfract = 0.6
)
print(cv1)

# Train model using optimal alpha and lambda
fit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, alpha = cv1$alpha.optimal
	, lambda = cv1$lambda.min
)
print(fit1)
# Time-varying covariates
data(heart, package="survival")
cv2 &lt;- pcoxtimecv(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, alphas = 1
	, refit = FALSE
	, lamfract = 0.6
)
print(cv2)

# Train model
fit2 &lt;- pcoxtime(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, alpha = cv2$alpha.optimal
	, lambda = cv2$lambda.min
)
print(fit2)

</code></pre>

<hr>
<h2 id='pkgsExport'>Import and export various functions from various packages</h2><span id='topic+pkgsExport'></span><span id='topic+Surv'></span><span id='topic+coxph'></span><span id='topic+concordance'></span><span id='topic+sindex'></span><span id='topic+Score'></span><span id='topic+permalgorithm'></span>

<h3>Description</h3>

<p>Import and export various functions from various packages
</p>
<p>Import and export Surv. See <code><a href="survival.html#topic+Surv">Surv</a></code>
</p>
<p>Import and export coxph. See <code><a href="survival.html#topic+coxph">coxph</a></code>
</p>
<p>Import and export concordance. See <code><a href="survival.html#topic+concordance">concordance</a></code>
</p>
<p>Import and export sindex. See <code><a href="prodlim.html#topic+sindex">sindex</a></code>
</p>
<p>Import and export Score. See <code><a href="riskRegression.html#topic+Score">Score</a></code>
</p>
<p>Import and export permalgorithm. See <code><a href="PermAlgo.html#topic+permalgorithm">permalgorithm</a></code>
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='plot.pcoxsurvfit'>Plot survival and cumulative hazard curves</h2><span id='topic+plot.pcoxsurvfit'></span>

<h3>Description</h3>

<p>Plot estimated survival and cumulative  hazard curves for <code>pcoxtime</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxsurvfit'
plot(
  x,
  ...,
  type = c("surv", "cumhaz"),
  lsize = 0.3,
  lcol = "black",
  compare = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pcoxsurvfit_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+pcoxsurvfit.pcoxtime">pcoxsurvfit.pcoxtime</a></code> or <code><a href="#topic+pcoxbasehaz.pcoxtime">pcoxbasehaz.pcoxtime</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.pcoxsurvfit_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
<tr><td><code id="plot.pcoxsurvfit_+3A_type">type</code></td>
<td>
<p>type of curve to generate. Either <code>type = "surv"</code> for survival curves or <code>type = "cumhaz"</code> for cumulative hazard curve.</p>
</td></tr>
<tr><td><code id="plot.pcoxsurvfit_+3A_lsize">lsize</code></td>
<td>
<p>line size for the curves.</p>
</td></tr>
<tr><td><code id="plot.pcoxsurvfit_+3A_lcol">lcol</code></td>
<td>
<p>colour for the curves.</p>
</td></tr>
<tr><td><code id="plot.pcoxsurvfit_+3A_compare">compare</code></td>
<td>
<p>logical. Whether to return plot with labels to add additional <code>geom</code> object for comparison. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the specification in <code><a href="#topic+pcoxsurvfit.pcoxtime">pcoxsurvfit.pcoxtime</a></code>, this function plots either average or individual survival or cumulative hazard curves. The plot is a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object, hence can be be customized further, see example below.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
data(heart, package="survival")
lam &lt;- 0.02
alp &lt;- 1
pfit &lt;- pcoxtime(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, lambda = lam
	, alpha = alp
)

# Plot survival curves
psurv &lt;- pcoxsurvfit(pfit)
plot(psurv)

# Baseline survival curve
bsurv &lt;- pcoxbasehaz(pfit, centered = FALSE)
plot(bsurv)

# Compare overall and baseline cumulative hazard
p1 &lt;- plot(psurv, type = "cumhaz", compare = TRUE)
df2 &lt;- data.frame(time = bsurv$time, cumhaz = bsurv$hazard)
p2 &lt;- (p1
	+ geom_step(data = df2, aes(x = time, y = cumhaz, group = 1, col = "baseline"))
	+ scale_colour_manual(name = "C. hazard"
		, values = c("#E41A1C", "#000000")
		, labels = c("baseline", "overall")
	)
)
print(p2)

</code></pre>

<hr>
<h2 id='plot.pcoxtimecv'>Plot solution path for pcoxtimecv</h2><span id='topic+plot.pcoxtimecv'></span>

<h3>Description</h3>

<p>Plots the cross-validation curve, and upper and lower standard deviation curves, as a function of the optimal lambdas. Also, plots the solution path as a function of optimal lambdas (or randomly picked fold, if <code>refit = FALSE</code>) or <code>l1</code>-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtimecv'
plot(
  x,
  ...,
  type = c("cve", "fit"),
  xvar = c("lambda", "l1"),
  show_nzero = FALSE,
  seed = 1234,
  geom = c("point", "line"),
  g.size = 0.2,
  g.col = "red",
  bar.col = g.col,
  scales = "free_x",
  show_min_cve = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pcoxtimecv_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_type">type</code></td>
<td>
<p>which plot to return. <code>type = "cve"</code> (default) return a cross-validation curve and <code>type = "fit"</code> returns coefficient profiles (solution path). See details.</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_xvar">xvar</code></td>
<td>
<p>only if <code>type = "fit"</code>. Plot coefficients a function of either lambda (<code>xvar = "lambda"</code>) or l1-norm (<code>xvar = "l1"</code>).</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_show_nzero">show_nzero</code></td>
<td>
<p>logical. Whether to show number of nonzero coefficients on the plot. Default is <code>show_nzero = FALSE</code>. Still experimental for <code>type = "cve"</code>.</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_seed">seed</code></td>
<td>
<p>random number generator. Important if <code>refit = FALSE</code> in <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_geom">geom</code></td>
<td>
<p>geom (&quot;point&quot; or &quot;line&quot;) for partial likelihood</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_g.size">g.size</code></td>
<td>
<p>size specification for points/lines</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_g.col">g.col</code></td>
<td>
<p>colour specification for points/lines</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_bar.col">bar.col</code></td>
<td>
<p>colour specification for error bars</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_scales">scales</code></td>
<td>
<p>should scales be &quot;fixed&quot;, &quot;free&quot;, &quot;free_x&quot; or &quot;free_y&quot;?</p>
</td></tr>
<tr><td><code id="plot.pcoxtimecv_+3A_show_min_cve">show_min_cve</code></td>
<td>
<p>whether or not to show the alpha which gives minimum cross-validation error. Ignored if a single <code>alpha</code> is specified. This replaced &quot;Optimal&quot; in the version <code>1.01.1</code> and below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To plot solution path corresponding to optimal alpha and lambda, set <code>refit = TRUE</code> in <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code>. The plot is a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object, hence can be be customized further.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
# Time-varying covariates
## Not run: 
data(heart, package="survival")
# Using a vector of alphas = (0.8, 1)
cv1 &lt;- pcoxtimecv(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, alphas = c(0.8, 1)
	, refit = TRUE
	, lamfract = 0.6
	, seed = 1234
)
# Plot cross-validation curves
plot(cv1, type = "cve")

# Plot 
plot(cv1, type = "fit")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.Score'>Prediction performance</h2><span id='topic+plot.Score'></span>

<h3>Description</h3>

<p>Plots predictive performance of <code>pcoxtime</code> in comparison to other models. It uses risk scoring from <code><a href="riskRegression.html#topic+Score">Score</a></code>. <code>pcoxtime</code> also supports performance measure scoring by R package <code>pec</code>. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Score'
plot(x, ..., type = c("roc", "auc", "brier"), pos = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Score_+3A_x">x</code></td>
<td>
<p><code><a href="riskRegression.html#topic+Score">Score</a></code> object. See examples.</p>
</td></tr>
<tr><td><code id="plot.Score_+3A_...">...</code></td>
<td>
<p>for future implementations.</p>
</td></tr>
<tr><td><code id="plot.Score_+3A_type">type</code></td>
<td>
<p>metric to return. Choices are <code>"roc", "auc", "brier"</code>.</p>
</td></tr>
<tr><td><code id="plot.Score_+3A_pos">pos</code></td>
<td>
<p>spacing between the lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements plot method for <code><a href="riskRegression.html#topic+Score">Score</a></code> for time-dependent Brier score, AUC and ROC. However, currently, no support for time-dependent covariate models.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (packageVersion("survival")&gt;="3.2.9") {
   data(cancer, package="survival")
} else {
   data(veteran, package="survival")
}
# pcoxtime
lam &lt;- 0.1
alp &lt;- 1
pfit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam 
	, alpha = alp
)

# coxph 
cfit1 &lt;- coxph(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, method = "breslow" 
	, x = TRUE
	, y = TRUE
)

# Evaluate model performance at 90, 180, 365 time points
score_obj &lt;- Score(list("coxph" = cfit1, "pcox" = pfit1)
	, Surv(time, status) ~ 1
	, data = veteran
	, plots = "roc"
	, metrics = c("auc", "brier")
	, B = 10
	, times = c(90, 180, 365)
)

# Plot AUC
plot(score_obj, type = "auc")
# Plot ROC
plot(score_obj, type = "roc")
# Plot brier
plot(score_obj, type = "brier")

# Prediction error using pec package
## Not run: 
	if (require("pec")) {
		pec_fit &lt;- pec(list("coxph" = cfit1, "pcox" = pfit1)
			, Surv(time, status) ~ 1
			, data = veteran
			, splitMethod = "Boot632plus"
			, keep.matrix = TRUE
		)
		plot(pec_fit)
	}

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.varimp'>Generic method for plotting variable importance</h2><span id='topic+plot.varimp'></span>

<h3>Description</h3>

<p>Plots variable importance for <code><a href="#topic+pcoxtime">pcoxtime</a></code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varimp'
plot(x, ..., pos = 0.5, drop_zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.varimp_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+varimp">varimp</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.varimp_+3A_...">...</code></td>
<td>
<p>for future implementations.</p>
</td></tr>
<tr><td><code id="plot.varimp_+3A_pos">pos</code></td>
<td>
<p>spacing between labels.</p>
</td></tr>
<tr><td><code id="plot.varimp_+3A_drop_zero">drop_zero</code></td>
<td>
<p>if <code>TRUE</code> only nonzero estimates are shown.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+varimp">varimp</a></code>
</p>

<hr>
<h2 id='predict.pcoxtime'>Prediction for pcoxtime model</h2><span id='topic+predict.pcoxtime'></span>

<h3>Description</h3>

<p>Compute fitted values and model terms for the pcoxtime model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
predict(
  object,
  ...,
  newdata = NULL,
  type = c("lp", "risk", "expected", "terms", "survival"),
  terms = object$predictors,
  na.action = na.pass
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code> object</p>
</td></tr>
<tr><td><code id="predict.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementations.</p>
</td></tr>
<tr><td><code id="predict.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>optional data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula. If absent, the predictions are for the data frame used in the original fit.</p>
</td></tr>
<tr><td><code id="predict.pcoxtime_+3A_type">type</code></td>
<td>
<p>the type of predicted value. Either linear predictor (<code>"lp"</code>), the risk score (<code>"risk"</code> equivalently <code>exp(lp)</code>), the expected number of events given the covariates and follow-up time (<code>"expected"</code>), the terms of linear predictor (<code>"terms"</code>) and the survival probability for each individual (<code>"survival"</code>).</p>
</td></tr>
<tr><td><code id="predict.pcoxtime_+3A_terms">terms</code></td>
<td>
<p>if <code>type = "terms"</code>, this argument can be used to specify which terms to be return. Default is all.</p>
</td></tr>
<tr><td><code id="predict.pcoxtime_+3A_na.action">na.action</code></td>
<td>
<p>defines the missing value action for the <code>newdata</code>. If <code>newdata</code> is absent, then the behavior of missing is dictated by the <code>na.action</code> option of the original fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of these predictions similar to those in <code><a href="survival.html#topic+predict.coxph">predict.coxph</a></code>. Our current implementation does not incorporate stratification.
</p>


<h3>Value</h3>

<p>a vector of predictions, depending on the <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(heart, package="survival")
lam &lt;- 0.1
alp &lt;- 0.8
pfit &lt;- pcoxtime(Surv(start, stop, event) ~ age + year + surgery + transplant
	, data = heart
	, lambda = lam
	, alpha = alp
)

predict(pfit, type = "lp")
predict(pfit, type = "expected")
predict(pfit, type = "risk")
predict(pfit, type = "survival")
predict(pfit, type = "terms")

</code></pre>

<hr>
<h2 id='predictedHazard'>Compute predicted hazard</h2><span id='topic+predictedHazard'></span>

<h3>Description</h3>

<p>This code is borrowed from internal function agsurv from survival package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictedHazard(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictedHazard_+3A_fit">fit</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of S3 objects.
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>number of observations used in the fit.</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>total number of events of interest in the fit.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time points defined by the risk set.</p>
</td></tr>
<tr><td><code>n.risk</code></td>
<td>
<p>the number of individuals at risk at time <code>t</code>.</p>
</td></tr>
<tr><td><code>n.event</code></td>
<td>
<p>the number of events that occur at time <code>t</code>.</p>
</td></tr>
<tr><td><code>n.censor</code></td>
<td>
<p>the number of subjects who exit the risk set, without an event, at time <code>t</code>.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>a vector or a matrix of estimated survival function.</p>
</td></tr>
<tr><td><code>chaz</code>, <code>hazard</code></td>
<td>
<p>a vector or a matrix of estimated cumulative hazard.</p>
</td></tr>
</table>

<hr>
<h2 id='predictRisk.pcoxtime'>Extract predictions from pcoxtime model</h2><span id='topic+predictRisk.pcoxtime'></span><span id='topic+predictRisk'></span>

<h3>Description</h3>

<p>Extract event probabilities from the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
predictRisk(object, newdata, times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictRisk.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code>.</p>
</td></tr>
<tr><td><code id="predictRisk.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula.</p>
</td></tr>
<tr><td><code id="predictRisk.pcoxtime_+3A_times">times</code></td>
<td>
<p>a vector of times in the range of the response, at which to return the survival probabilities.</p>
</td></tr>
<tr><td><code id="predictRisk.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For survival outcome, the function predicts the risk, <code class="reqn">1 - S(t|x)</code>, where <code class="reqn">S(t|x)</code> is the survival chance of an individual characterized by <code class="reqn">x</code>.
</p>


<h3>Value</h3>

<p>a matrix of probabilities with as many rows as the rows of the <code>newdata</code> and as many columns as number of time points (<code>times</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (packageVersion("survival")&gt;="3.2.9") {
   data(cancer, package="survival")
} else {
   data(veteran, package="survival")
}
# Penalized
lam &lt;- 0.1
alp &lt;- 0.5
pfit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
r1 &lt;- predictRisk(pfit1, newdata = veteran[1:80,], times = 10)

# Unpenalized
lam &lt;- 0
alp &lt;- 1
pfit2 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
r2 &lt;- predictRisk(pfit2, newdata = veteran[1:80,], times = 10)
plot(r1, r2, xlim=c(0,1), ylim=c(0,1)
	, xlab = "Penalized predicted survival chance at 10"
	, ylab="Unpenalized predicted survival chance at 10"
)

</code></pre>

<hr>
<h2 id='predictSurvProb.pcoxtime'>Predict survival probabilities at various time points</h2><span id='topic+predictSurvProb.pcoxtime'></span><span id='topic+predictSurvProb'></span>

<h3>Description</h3>

<p>The function extracts the survival probability predictions from a <code>pcoxtime</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
predictSurvProb(object, newdata, times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSurvProb.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code>.</p>
</td></tr>
<tr><td><code id="predictSurvProb.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula.</p>
</td></tr>
<tr><td><code id="predictSurvProb.pcoxtime_+3A_times">times</code></td>
<td>
<p>a vector of times in the range of the response, at which to return the survival probabilities.</p>
</td></tr>
<tr><td><code id="predictSurvProb.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of probabilities with as many rows as the rows of the <code>newdata</code> and as many columns as number of time points (<code>times</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (packageVersion("survival")&gt;="3.2.9") {
   data(cancer, package="survival")
} else {
   data(veteran, package="survival")
}
# Penalized
lam &lt;- 0.1
alp &lt;- 0.5
pfit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
p1 &lt;- predictSurvProb(pfit1, newdata = veteran[1:80,], times = 10)

# Unpenalized
lam &lt;- 0
alp &lt;- 1
pfit2 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
p2 &lt;- predictSurvProb(pfit2, newdata = veteran[1:80,], times = 10)
plot(p1, p2, xlim=c(0,1), ylim=c(0,1)
	, xlab = "Penalized predicted survival chance at 10"
	, ylab="Unpenalized predicted survival chance at 10"
)

</code></pre>

<hr>
<h2 id='print.pcoxbasehaz'>Print baseline hazard function data frame</h2><span id='topic+print.pcoxbasehaz'></span>

<h3>Description</h3>

<p>Print the head of baseline hazard function data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxbasehaz'
print(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pcoxbasehaz_+3A_x">x</code></td>
<td>
<p>the result of a call to the <code><a href="#topic+pcoxbasehaz.pcoxtime">pcoxbasehaz.pcoxtime</a></code> function.</p>
</td></tr>
<tr><td><code id="print.pcoxbasehaz_+3A_n">n</code></td>
<td>
<p>number of rows to print. Default is 5.</p>
</td></tr>
<tr><td><code id="print.pcoxbasehaz_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide a summary of <code><a href="#topic+pcoxbasehaz.pcoxtime">pcoxbasehaz.pcoxtime</a></code> object.
</p>


<h3>Value</h3>

<p>The call to the <code><a href="#topic+pcoxbasehaz.pcoxtime">pcoxbasehaz.pcoxtime</a></code> and the head of baseline hazard function data frame.
</p>

<hr>
<h2 id='print.pcoxsurvfit'>Print a short summary of survival function</h2><span id='topic+print.pcoxsurvfit'></span>

<h3>Description</h3>

<p>Print the number of observations and number of events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxsurvfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pcoxsurvfit_+3A_x">x</code></td>
<td>
<p>the result of a call to the <code><a href="#topic+pcoxsurvfit.pcoxtime">pcoxsurvfit.pcoxtime</a></code> function.</p>
</td></tr>
<tr><td><code id="print.pcoxsurvfit_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide a summary of <code><a href="#topic+pcoxsurvfit.pcoxtime">pcoxsurvfit.pcoxtime</a></code> object.
</p>


<h3>Value</h3>

<p>The call to the <code><a href="#topic+pcoxsurvfit.pcoxtime">pcoxsurvfit.pcoxtime</a></code> and the summary of the survival function.
</p>

<hr>
<h2 id='print.pcoxtime'>Print coefficients from a pcoxtime object</h2><span id='topic+print.pcoxtime'></span>

<h3>Description</h3>

<p>This function prints a summary of the pcoxtime object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
print(x, ..., nprint = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pcoxtime_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code> model object</p>
</td></tr>
<tr><td><code id="print.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
<tr><td><code id="print.pcoxtime_+3A_nprint">nprint</code></td>
<td>
<p>number of coefficients to print out</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced <code><a href="#topic+pcoxtime">pcoxtime</a></code> is printed, followed by coefficient estimates with their corresponding exponentiated values.
Depending on the number of coefficients, <code>nprint</code> can be used to specify the number of coefficients to print out.
</p>


<h3>Value</h3>

<p>A two column output, the first column is the coefficient estimate and the second column is the exponent of the coefficient estimate. Additonal summary about the number of nonzero coefficents, the number of observations and the number of event of interest are also printed.
</p>

<hr>
<h2 id='print.pcoxtimecv'>Print cross-validated pcoxtime object</h2><span id='topic+print.pcoxtimecv'></span>

<h3>Description</h3>

<p>Print the summary of the result of cross-validation for a pcoxtime object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtimecv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pcoxtimecv_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> object</p>
</td></tr>
<tr><td><code id="print.pcoxtimecv_+3A_...">...</code></td>
<td>
<p>for future implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A summary of optimal lambda and alpha for training pcoxtime model.
</p>


<h3>Value</h3>

<p>The call to the <code><a href="#topic+pcoxtimecv">pcoxtimecv</a></code> and the summary of the optimal alpha and lambdas.
</p>

<hr>
<h2 id='pvimp.pcoxtime'>Permutation variable importance</h2><span id='topic+pvimp.pcoxtime'></span>

<h3>Description</h3>

<p>Computes the relative importance based on random permutation of focal variable for pcoxtime model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvimp.pcoxtime(
  object,
  newdata,
  nrep = 50,
  parallelize = FALSE,
  nclusters = 1,
  estimate = c("mean", "quantile"),
  probs = c(0.025, 0.5, 0.975),
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvimp.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code>.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates for permutations. Default is <code>nrep = 50</code>.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_parallelize">parallelize</code></td>
<td>
<p>whether to run in parallel. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_nclusters">nclusters</code></td>
<td>
<p>number of cores to use if <code>parallelize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_estimate">estimate</code></td>
<td>
<p>character string specify which summary statistic to use for the estimates. Default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_seed">seed</code></td>
<td>
<p>a single value for for random number generation.</p>
</td></tr>
<tr><td><code id="pvimp.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given predictors <code>x_1, x_2, ..., x_n</code> used to predict the survival outcome, <code>y</code>. Suppose, for example, <code>x_1</code> has low predictive power for the response. Then, if we randomly permute the observed values for <code>x_1</code>, then the prediction for <code>y</code> will not change much. Conversely, if any of the predictors highly predicts the response, the permutation of that specific predictor will lead to a considerable change in the predictive measure of the model. In this case, we conclude that this predictor is important. In our implementation, Harrel's concordance index is used to measure the prediction accuracy.
</p>


<h3>Value</h3>

<p>a named vector of variable scores (<code>estimate = "mean"</code>) or a data frame (<code>estimate = "quantile"</code>).
</p>

<hr>
<h2 id='riskset'>Compute the risk set indicator</h2><span id='topic+riskset'></span>

<h3>Description</h3>

<p>Identify set of individuals at risk of 
experiencing the event before event time 
(failure time), <code class="reqn">t_i</code>. The risk set, 
<code class="reqn">R_i</code>, is the set of individuals, 
<code class="reqn">j</code>, who had not experienced the 
event or had been censored by time <code class="reqn">t_i</code>. 
This function identifies this set and 
computes event times satisfying this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskset(
  formula,
  data,
  contrasts.arg = NULL,
  xlevs = NULL,
  scaleX = TRUE,
  na.action = na.omit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskset_+3A_formula">formula</code></td>
<td>
<p>Object of class formula describing 
the model. The response and terms are specified 
similar to <code><a href="survival.html#topic+Surv">Surv</a></code> function.</p>
</td></tr>
<tr><td><code id="riskset_+3A_data">data</code></td>
<td>
<p>optional data frame containing 
variables specified in the formula.</p>
</td></tr>
<tr><td><code id="riskset_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>an optional list. See 
the contrasts.arg of
<code>[stats]{model.matrix.default}</code>.</p>
</td></tr>
<tr><td><code id="riskset_+3A_xlevs">xlevs</code></td>
<td>
<p>a named list of character vectors 
giving the full set of levels to be assumed 
for each factor. See <code>[stats]{model.frame}</code>.</p>
</td></tr>
<tr><td><code id="riskset_+3A_scalex">scaleX</code></td>
<td>
<p>logical. If TRUE (default), 
predictors are scaled/standardized. This is 
used internally.</p>
</td></tr>
<tr><td><code id="riskset_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates 
what should happen when the data contain NAs. 
See <code>[stats]{model.frame}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">t_1 &lt; t_2 &lt;, ..., t_m</code>, such
that <code class="reqn">m &lt; n</code> if there are not ties, 
otherwise <code class="reqn">m = n</code>. If covariates are 
time-independent the risk set, <code class="reqn">R_i</code>,
is the set of individuals who are still at risk
at time <code class="reqn">t_i</code>, i.e., individuals with
event/censoring time <code class="reqn">y_j\ge t_i</code>.
For time-dependent covariates risk set at time 
<code class="reqn">t_i</code> is now defined as 
<code class="reqn">R(t_i) = \{j : (y^{stop}_{j} \ge t_i) \wedge (y^{start}_{j} &lt; t_i)\}</code>.
The first condition, <code class="reqn">(y^{stop}_{j} \ge t_i)</code>, 
ensures that individual <code class="reqn">j</code> either experienced 
the event or was censored at a later time point than 
<code class="reqn">t_i</code>, while the second condition, 
<code class="reqn">(y^{start}_{j} &lt; t_i)</code>, ensures the start 
time was observed before the event.
</p>


<h3>Value</h3>

<p>A list of survival objects:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>Surv object defining the event times and event status.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>model matrix of model terms.</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>observed events.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>event times defined by risk set condition.</p>
</td></tr>
<tr><td><code>timevarlabel</code>, <code>eventvarlabel</code></td>
<td>
<p>time and event variables, respectively.</p>
</td></tr>
<tr><td><code>scale_sd</code>, <code>scale_mu</code></td>
<td>
<p>standard deviation and mean of each of the variable used in standardization.</p>
</td></tr>
</table>

<hr>
<h2 id='simtdc'>Simulate survival data for time-dependent covariates</h2><span id='topic+simtdc'></span><span id='topic+genX'></span>

<h3>Description</h3>

<p>This function uses the permutation algorithm to generate a dataset based on user specified list of covariates, of which some can be time-dependent. User can also specify distribution of event and censoring times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simtdc(
  nSubjects = 100,
  maxTime = 365,
  pfixed = 2,
  ptdc = 2,
  pbin = NULL,
  betas = NULL,
  tdcmat = NULL,
  xmat = NULL,
  rho = 0,
  eventRandom = NULL,
  rate = 0.012,
  censorRandom = NULL,
  groupByD = FALSE,
  x = FALSE
)

genX(
  nSubjects = 100,
  maxTime = 365,
  pfixed = 2,
  ptdc = 2,
  pbin = NULL,
  tdcmat = NULL,
  rho = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simtdc_+3A_nsubjects">nSubjects</code></td>
<td>
<p>number of subjects to simulate, default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_maxtime">maxTime</code></td>
<td>
<p>a non-zero integer specifying the maximum length of follow-up time, default is <code>365</code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_pfixed">pfixed</code></td>
<td>
<p>number of time-independent (fixed) covariates. They are randomly drawn from a normal distribution with <code>mean = 0</code> and <code>sd = 1</code>. The values are replicated for each subject upto the respective follow-up time.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_ptdc">ptdc</code></td>
<td>
<p>number of time-dependent covariates. By default, these are drawn from a normal distribution with <code>mean = 0</code> and <code>sd = 1</code> but the user can by-pass this option and specify a matrix of time-dependent covariates via <code>tdcmat</code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_pbin">pbin</code></td>
<td>
<p>optional. Number of binary covariates. This are treated as fixed covariates and are drawn form a binomial distribution with <code>p = 0.5</code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_betas">betas</code></td>
<td>
<p>a vector of 'true' effect sizes (regression coefficients) representing the magnitude of the relationship between the respective covariate and the risk of event. If <code>NULL</code>, the algorithm generates <code>betas</code> from a uniform distribution and then converts them to log hazard, i.e., <code>log(runif((pfixed+ptdc+pbin), 0, 2))</code>. The length of <code>betas</code> must be the same the total of covariates to generate.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_tdcmat">tdcmat</code></td>
<td>
<p>specify own time-dependent covariates. If specified (a matrix with nSubjects*maxTime rows), <code>ptdc</code> is ignored. This is important in mechanistic simulation of the time-dependent covariates.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_xmat">xmat</code></td>
<td>
<p>specify an entire matrix for all the covariates. If specified (a matrix with nSubjects*maxTime rows), all the previous specifications for number of covariates and <code>tdcmat</code> are ignored. This is important in mechanistic simulation of all the covariates or some specific distributional assumptions are required.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_rho">rho</code></td>
<td>
<p>specify the pairwise correlation between the time-independent covariates. The default <code>rho = 0</code> means no pairwise correlation between the covariates.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_eventrandom">eventRandom</code></td>
<td>
<p>a non-negative integers of length <code>nSubjects</code> which represent the subject's event times or a random generating function with <code>n</code> option specified. If <code>NULL</code>, the algorithm generates <code>nSubjects</code> random deviates from exponential distribution with <code>rate = rate</code>. See <code>rate</code> option.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_rate">rate</code></td>
<td>
<p>the rate for the exponential random deviates for <code>eventRandom</code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_censorrandom">censorRandom</code></td>
<td>
<p>a non-negative integers of length <code>nSubjects</code> which represent the subject's censoring times or a random generating function with <code>n</code> option specified. If <code>NULL</code>, the algorithm generates <code>nSubjects</code> random numbers based on uniform distribution, i.e., <code>runif(nSubjects, 1, maxTime)</code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_groupbyd">groupByD</code></td>
<td>
<p>see <code><a href="PermAlgo.html#topic+permalgorithm">permalgorithm</a></code>.</p>
</td></tr>
<tr><td><code id="simtdc_+3A_x">x</code></td>
<td>
<p>logical. Whether to return matrix of generated covariates in addition to the entire dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to the permutation algorithm implemented in <code><a href="PermAlgo.html#topic+permalgorithm">permalgorithm</a></code>. The user can fix the positive pairwise correlation between each pair of time-independent covariates by specify <code>0 &lt; rho &lt;= 1</code>.
</p>


<h3>Value</h3>

<p>a list of dataset, betas (and matrix of covariates). The covariates have a suffix depending on their type, xbin* for binary, xtf* for time-independent (fixed) and xtd* for time-dependent covariates.
</p>

<ul>
<li><p>datasimulated <code>data.frame</code> with the following columns
</p>

<ul>
<li><p>Idsubject id. Identifies each of the nSubjects individuals
</p>
</li>
<li><p>Eventevent indicator. <code>Event = 1</code> if the event occurs otherwise <code>0</code>.
</p>
</li>
<li><p>Fupindividual max follow-up time
</p>
</li>
<li><p>Startstart of each time interval
</p>
</li>
<li><p>Stopend of each time interval
</p>
</li>
<li><p>x*all generated covariates
</p>
</li></ul>

</li>
<li><p>betasnamed vector of coefficients specified in the function call. Otherwise, internally generated.
</p>
</li>
<li><p>xmatif <code>x = TRUE</code>, matrix of covariates
</p>
</li></ul>



<h3>References</h3>

<p>Sylvestre M.-P., Abrahamowicz M. (2008) <em>Comparison of algorithms to generate event times conditional on time-dependent covariates</em>. Statistics in Medicine 27(14):2618&ndash;34
</p>


<h3>See Also</h3>

<p><code><a href="PermAlgo.html#topic+permalgorithm">permalgorithm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
	library(PermAlgo)
	library(survival)
	library(ggplot2)
	pcoxtheme()

	set.seed(123407)
	# Simulate with default values
	df &lt;- simtdc()
	head(df$data)
	# Simulate for a number of times to check stability of the estimates
	nrep &lt;- 500
	betas &lt;- log(runif(6, 0, 2))
	beta_list &lt;- list()
	true_list &lt;- list()
	for (i in 1:nrep){
		sim &lt;- simtdc(pfixed = 3, ptdc = 2, pbin = 1, betas = betas)
		df &lt;- sim$data
		vnames &lt;- colnames(df)[!colnames(df) %in% c("Id", "Fup")]
		df &lt;- df[ ,vnames]
		# Estimate coefficients using coxph
		mod &lt;- coxph(Surv(Start, Stop, Event) ~ ., df)
		beta_list[[i]] &lt;- coef(mod)
		true_list[[i]] &lt;- sim$betas
	}
	beta_df &lt;- data.frame(do.call("rbind", beta_list))
	beta_df &lt;- stack(beta_df)

	true_df &lt;- data.frame(ind = names(true_list[[1]]), values = true_list[[1]])
	p1 &lt;- (ggplot(beta_df, aes(x = values))
		+ geom_histogram(alpha = 0.3)
		+ geom_vline(data = true_df, aes(xintercept = values), col = "blue")
		+ facet_wrap(~ind, scales = "free")
		+ labs(x = "Beta estimate", y = "")
	)
	print(p1)

## End(Not run)

</code></pre>

<hr>
<h2 id='unscale'>Unscale scaled predictors.</h2><span id='topic+unscale'></span>

<h3>Description</h3>

<p>Unscale scaled predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unscale(x, center, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unscale_+3A_x">x</code></td>
<td>
<p>a model matrix or data frame with numeric variables.</p>
</td></tr>
<tr><td><code id="unscale_+3A_center">center</code></td>
<td>
<p>a vector of means of predictors.</p>
</td></tr>
<tr><td><code id="unscale_+3A_scale">scale</code></td>
<td>
<p>a vector of standard deviation of predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (model.matrix) with the columns on the original scale.
</p>

<hr>
<h2 id='varimp.pcoxtime'>Compute variable or coefficient importance score</h2><span id='topic+varimp.pcoxtime'></span><span id='topic+varimp'></span>

<h3>Description</h3>

<p>Compute variable or coefficient importance score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcoxtime'
varimp(
  object,
  newdata,
  type = c("coef", "perm", "model"),
  relative = TRUE,
  nrep = 50,
  parallelize = FALSE,
  nclusters = 1,
  estimate = c("mean", "quantile"),
  probs = c(0.025, 0.5, 0.975),
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varimp.pcoxtime_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+pcoxtime">pcoxtime</a></code>.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the variables appearing on the right hand side of <code><a href="#topic+pcoxtime">pcoxtime</a></code> formula.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_type">type</code></td>
<td>
<p>if <code>type = "coef"</code> or <code>type = "model"</code> absolute value of estimated coefficients is computed. If <code>type = "perm"</code> variable level importance is computed using permutation.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_relative">relative</code></td>
<td>
<p>logical. If <code>TRUE</code> the scores are divided by the absolute sum of the coefficients.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates for permutations. Default is <code>nrep = 50</code>.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_parallelize">parallelize</code></td>
<td>
<p>whether to run in parallel. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_nclusters">nclusters</code></td>
<td>
<p>number of cores to use if <code>parallelize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_estimate">estimate</code></td>
<td>
<p>character string specify which summary statistic to use for the estimates. Default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_seed">seed</code></td>
<td>
<p>a single value for for random number generation.</p>
</td></tr>
<tr><td><code id="varimp.pcoxtime_+3A_...">...</code></td>
<td>
<p>for future implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absolute value of the coefficients (parameters) corresponding the <code><a href="#topic+pcoxtime">pcoxtime</a></code> object (<code>type = "coef"</code>). Otherwise, variable level importance is computed using permutation (<code>type = "perm"</code>).
In the case of permutation: given predictors <code>x_1, x_2, ..., x_n</code> used to predict the survival outcome, <code>y</code>. Suppose, for example, <code>x_1</code> has low predictive power for the response. Then, if we randomly permute the observed values for <code>x_1</code>, then the prediction for <code>y</code> will not change much. Conversely, if any of the predictors highly predicts the response, the permutation of that specific predictor will lead to a considerable change in the predictive measure of the model. In this case, we conclude that this predictor is important. In our implementation, Harrel's concordance index is used to measure the prediction accuracy.
</p>


<h3>Value</h3>

<p>a named vector of variable scores (<code>estimate = "mean"</code>) or a data frame (<code>estimate = "quantile"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (packageVersion("survival")&gt;="3.2.9") {
   data(cancer, package="survival")
} else {
   data(veteran, package="survival")
}
# Penalized
lam &lt;- 0.1
alp &lt;- 0.5
pfit1 &lt;- pcoxtime(Surv(time, status) ~ factor(trt) + karno + diagtime + age + prior
	, data = veteran
	, lambda = lam
	, alpha = alp
)
imp1 &lt;- varimp(pfit1, veteran)
plot(imp1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
