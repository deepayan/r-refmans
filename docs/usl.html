<!DOCTYPE html><html><head><title>Help for package usl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {usl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#usl-package'><p>Analyze system scalability with the Universal Scalability Law</p></a></li>
<li><a href='#+24+2CUSL-method'><p>Extract parts of a &quot;<code>USL</code>&quot; object</p></a></li>
<li><a href='#confint+2CUSL-method'><p>Confidence Intervals for USL model parameters</p></a></li>
<li><a href='#efficiency+2CUSL-method'><p>Efficiency of the system</p></a></li>
<li><a href='#gradient.usl'><p>Calculate gradient for the universal scalability function</p></a></li>
<li><a href='#initialize+2CUSL-method'><p>Generate an object from the &quot;<code>USL</code>&quot; class</p></a></li>
<li><a href='#limit.scalability+2CUSL-method'><p>Scalability limit of a USL model</p></a></li>
<li><a href='#optimal.scalability+2CUSL-method'><p>Point of optimal scalability of a USL model</p></a></li>
<li><a href='#oracledb'><p>Performance of an Oracle database used for online transaction processing</p></a></li>
<li><a href='#overhead+2CUSL-method'><p>Overhead method for Universal Scalability Law models</p></a></li>
<li><a href='#peak.scalability+2CUSL-method'><p>Point of peak scalability of a USL model</p></a></li>
<li><a href='#plot+2CUSL-method'><p>Plot the scalability function from a USL model</p></a></li>
<li><a href='#predict+2CUSL-method'><p>Predict method for Universal Scalability Law models</p></a></li>
<li><a href='#print+2CUSL-method'><p>Print objects of class &quot;<code>USL</code>&quot;</p></a></li>
<li><a href='#raytracer'><p>Performance of a ray-tracing software on different hardware configurations</p></a></li>
<li><a href='#scalability+2CUSL-method'><p>Scalability function of a USL model</p></a></li>
<li><a href='#show+2CUSL-method'><p>Show objects of class &quot;<code>USL</code>&quot;</p></a></li>
<li><a href='#sigma+2CUSL-method'><p>Extract Residual Standard Deviation 'Sigma'</p></a></li>
<li><a href='#specsdm91'><p>Performanced of a Sun SPARCcenter 2000 in the SPEC SDM91 benchmark</p></a></li>
<li><a href='#summary+2CUSL-method'><p>USL Object Summary</p></a></li>
<li><a href='#usl'><p>Create a model for the Universal Scalability Law</p></a></li>
<li><a href='#USL-class'><p>Class &quot;<code>USL</code>&quot; for Universal Scalability Law models</p></a></li>
<li><a href='#usl.solve.nls'><p>Solve a USL model using non linear regression</p></a></li>
<li><a href='#usl.solve.nlxb'><p>Solve a USL model using non linear regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyze System Scalability with the Universal Scalability Law</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-27</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/smoeding/usl/issues">https://github.com/smoeding/usl/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, nlsr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>The Universal Scalability Law (Gunther 2007)
    &lt;<a href="https://doi.org/10.1007%2F978-3-540-31010-5">doi:10.1007/978-3-540-31010-5</a>&gt; is a model to predict hardware and
    software scalability. It uses system capacity as a function of load to
    forecast the scalability for the system.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-27 16:22:36 UTC; stm</td>
</tr>
<tr>
<td>Author:</td>
<td>Neil J. Gunther [aut],
  Stefan Moeding [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Moeding &lt;stm@moeding.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-28 22:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='usl-package'>Analyze system scalability with the Universal Scalability Law</h2><span id='topic+usl-package'></span>

<h3>Description</h3>

<p>The Universal Scalability Law is a model to predict hardware and software
scalability. It uses system capacity as a function of load to forecast the
scalability for the system.
</p>


<h3>Details</h3>

<p>Use the function <code><a href="#topic+usl">usl</a></code> to create a model from a formula and
a data frame.
</p>
<p>The USL model produces two coefficients as result: <code>alpha</code> models the
contention and <code>beta</code> the coherency delay of the system.
</p>
<p>The Universal Scalability Law has been created by Dr. Neil J. Gunther.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>

<hr>
<h2 id='+24+2CUSL-method'>Extract parts of a &quot;<code>USL</code>&quot; object</h2><span id='topic++24+2CUSL-method'></span>

<h3>Description</h3>

<p>The operator extracts a part of a <code><a href="#topic+USL-class">USL-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24+2B2CUSL-method_+3A_x">x</code></td>
<td>
<p>Object from which to extract elements.</p>
</td></tr>
<tr><td><code id="+2B24+2B2CUSL-method_+3A_name">name</code></td>
<td>
<p>A literal character string or a <a href="base.html#topic+name">name</a> (possibly quoted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic method for the class used in the usl package.
</p>
<p>The operator is used internally by functions like <code><a href="stats.html#topic+coef">coef</a></code>, so
it is necessary to have a working implementation of the <code>coef</code>
function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+USL-class">USL-class</a></code>, <code><a href="base.html#topic+Extract">Extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## get coefficients from a usl model
usl.model$coefficients

## End(Not run)

</code></pre>

<hr>
<h2 id='confint+2CUSL-method'>Confidence Intervals for USL model parameters</h2><span id='topic+confint+2CUSL-method'></span>

<h3>Description</h3>

<p>Estimate confidence intervals for one or more parameters in a USL model.
The intervals are calculated from the parameter standard error using the
Student t distribution at the given level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
confint(object, parm, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
<tr><td><code id="confint+2B2CUSL-method_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence
intervals, either a vector of numbers or a vector of names. If missing,
all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint+2B2CUSL-method_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrapping is no longer used to estimate confidence intervals.
</p>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence
limits for each parameter. These will be labelled as (1-level)/2 and
1 - (1-level)/2 in % (by default 2.5% and 97.5%).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(specsdm91)

## Create USL model
usl.model &lt;- usl(throughput ~ load, specsdm91)

## Print confidence intervals
confint(usl.model)

</code></pre>

<hr>
<h2 id='efficiency+2CUSL-method'>Efficiency of the system</h2><span id='topic+efficiency+2CUSL-method'></span><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>The efficiency of a system expressed in terms of the deviation from
linear scalability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
efficiency(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a vector which contains the deviation from linearity
for every measurement of the model input.  A value of <code>1</code> indicates
linear scalability while values less than <code>1</code> correspond to the
fraction of the measurement compared to linear scalability.
</p>


<h3>Value</h3>

<p>A vector of numeric values.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Show the efficiency
efficiency(usl(throughput ~ processors, raytracer))

</code></pre>

<hr>
<h2 id='gradient.usl'>Calculate gradient for the universal scalability function</h2><span id='topic+gradient.usl'></span>

<h3>Description</h3>

<p>The implementation of this function has been adopted from the generated
output of the <code><a href="stats.html#topic+deriv">deriv</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient.usl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient.usl_+3A_x">x</code></td>
<td>
<p>The USL object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gradient matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>

<hr>
<h2 id='initialize+2CUSL-method'>Generate an object from the &quot;<code>USL</code>&quot; class</h2><span id='topic+initialize+2CUSL-method'></span>

<h3>Description</h3>

<p>Initialize the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
initialize(.Object, call, frame, regr, resp, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CUSL-method_+3A_.object">.Object</code></td>
<td>
<p>The object to initialize.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_call">call</code></td>
<td>
<p>The formula used to create the USL model.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_frame">frame</code></td>
<td>
<p>The model frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_regr">regr</code></td>
<td>
<p>The name of the regressor variable in the model.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_resp">resp</code></td>
<td>
<p>The name of the response variable in the model.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>The contention parameter of the model.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>The coherency delay parameter of the model.</p>
</td></tr>
<tr><td><code id="initialize+2B2CUSL-method_+3A_gamma">gamma</code></td>
<td>
<p>The slope of the ideal parallel scaling of the three parameter
model. This parameter corrsponds to the scale.factor parameter of the
two parameter model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the specific type.
</p>

<hr>
<h2 id='limit.scalability+2CUSL-method'>Scalability limit of a USL model</h2><span id='topic+limit.scalability+2CUSL-method'></span><span id='topic+limit.scalability'></span>

<h3>Description</h3>

<p>Calculate the scalability limit for a specific model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
limit.scalability(object, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limit.scalability+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
<tr><td><code id="limit.scalability+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="limit.scalability+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="limit.scalability+2B2CUSL-method_+3A_gamma">gamma</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalability limit is defined as:
</p>
<p style="text-align: center;"><code class="reqn">Xroof = \frac{\gamma}{\alpha}</code>
</p>

<p>This is the upper bound (Amdahl asymptote) of system capacity.
</p>
<p>The parameters <code>alpha</code>, <code>beta</code> and <code>gamma</code> are useful to do a
what-if analysis. Setting these parameters override the model parameters and
show how the system would behave with a different contention or coherency
delay parameter.
</p>
<p>The scalability limit is undefined if <code>alpha</code> is zero.
</p>
<p>This function accepts an argument for <code>beta</code> although the value is not
required to perform the calculation. This is on purpose to provide a
coherent interface.
</p>


<h3>Value</h3>

<p>A numeric value for the system capacity limit (e.g. throughput).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>,
<code><a href="#topic+peak.scalability+2CUSL-method">peak.scalability,USL-method</a></code>
<code><a href="#topic+optimal.scalability+2CUSL-method">optimal.scalability,USL-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(specsdm91)

limit.scalability(usl(throughput ~ load, specsdm91))
## The throughput limit is about 3245

</code></pre>

<hr>
<h2 id='optimal.scalability+2CUSL-method'>Point of optimal scalability of a USL model</h2><span id='topic+optimal.scalability+2CUSL-method'></span><span id='topic+optimal.scalability'></span>

<h3>Description</h3>

<p>Calculate the point of optimal scalability for a specific model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
optimal.scalability(object, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal.scalability+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
<tr><td><code id="optimal.scalability+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="optimal.scalability+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="optimal.scalability+2B2CUSL-method_+3A_gamma">gamma</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point of optimal scalability is defined as:
</p>
<p style="text-align: center;"><code class="reqn">Nopt = \frac{1}{\alpha}</code>
</p>

<p>Below this point the existing capacity is underutilized. Beyond that point
the effects of diminishing returns become visible more and more.
</p>
<p>The value can be constructed graphically by projecting the intersection of
the linear scalability bound and the Amdahl asymptote onto the x-axis.
</p>
<p>The parameters <code>alpha</code>, <code>beta</code> and <code>gamma</code> are useful to do a
what-if analysis. Setting these parameters override the model parameters and
show how the system would behave with a different contention or coherency
delay parameter.
</p>
<p>The point of optimal scalability is undefined if <code>alpha</code> is zero.
</p>
<p>This function accepts a arguments for <code>beta</code> and <code>gamma</code> although
the values are not required to perform the calculation. This is on purpose
to provide a coherent interface.
</p>


<h3>Value</h3>

<p>A numeric value for the load where optimal scalability will be
reached.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>,
<code><a href="#topic+peak.scalability+2CUSL-method">peak.scalability,USL-method</a></code>
<code><a href="#topic+limit.scalability+2CUSL-method">limit.scalability,USL-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(specsdm91)

optimal.scalability(usl(throughput ~ load, specsdm91))
## Optimal scalability will be reached at about 36 virtual users

</code></pre>

<hr>
<h2 id='oracledb'>Performance of an Oracle database used for online transaction processing</h2><span id='topic+oracledb'></span>

<h3>Description</h3>

<p>A dataset containing performance data for an Oracle OLTP database measured
between 8:00am and 8:00pm on January, 19th 2012. The measurements were
recorded for two minute intervals during this time and a timestamp indicates
the end of the measurement interval. The performance metrics were taken from
the <code>v$sysmetric</code> family of system performance views.
</p>


<h3>Format</h3>

<p>A data frame with 360 rows on 8 variables
</p>


<h3>Details</h3>

<p>The Oracle database was running on a 4-way server.
</p>
<p>The data frame contains different types of measurements:
</p>

<ul>
<li><p> Variables of the &quot;time&quot; type are expressed in seconds per second.
</p>
</li>
<li><p> Variables of the &quot;rate&quot; type are expressed in events per second.
</p>
</li>
<li><p> Variables of the &quot;util&quot; type are expressed as a percentage.
</p>
</li></ul>

<p>The data frame contains the following variables:
</p>

<ul>
<li> <p><code>timestamp</code> The end of the two minute interval for which the
remaining variables contain the measurements.
</p>
</li>
<li> <p><code>db_time</code> The time spent inside the database either working on
a CPU or waiting  (I/O, locks, buffer waits ...). This time is expressed
as seconds per second, so two sessions working for exactly one second
each will contribute a total of two seconds per second of <code>db_time</code>.
In Oracle this value is also known as <em>Average Active Sessions</em>
(AAS).
</p>
</li>
<li> <p><code>cpu_time</code> The CPU time used during the interval. This is also
expressed as seconds per second. A 4-way machine has a theoretical
capacity of four CPU seconds per second.
</p>
</li>
<li> <p><code>call_rate</code> The number of user calls (logins, parses, or
execute calls) per second.
</p>
</li>
<li> <p><code>exec_rate</code> The number of statement executions per second.
</p>
</li>
<li> <p><code>lio_rate</code> The number of logical I/Os per second. A logical
I/O is the Oracle term for a cache hit in the database buffer cache.
This metric does not indicate if an additional physical I/O was
necessary to load the buffer from disk.
</p>
</li>
<li> <p><code>txn_rate</code> The number of database transactions per second.
</p>
</li>
<li> <p><code>cpu_util</code> The CPU utilization of the database server in
percent. This was also measured from within the database.
</p>
</li></ul>


<hr>
<h2 id='overhead+2CUSL-method'>Overhead method for Universal Scalability Law models</h2><span id='topic+overhead+2CUSL-method'></span><span id='topic+overhead'></span>

<h3>Description</h3>

<p><code>overhead</code> calculates the overhead in processing time for a system
modeled with the Universal Scalability Law.
It evaluates the regression function in the frame <code>newdata</code> (which
defaults to <code>model.frame(object)</code>). The result contains the ideal
processing time and the additional overhead caused by contention and
coherency delays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
overhead(object, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overhead+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL model object for which the overhead will be calculated.</p>
</td></tr>
<tr><td><code id="overhead+2B2CUSL-method_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables
with which to calculate the overhead.
If omitted, the fitted values are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculated processing times are given as percentages of a
non-parallelized workload. So for a non-parallelized workload the ideal
processing time will always be given as <em>100%</em> while the overhead
for contention and coherency will always be zero.
</p>
<p>Doubling the capacity will cut the ideal processing time in half but
increase the overhead percentages. The increase of the overhead depends on
the values of the parameters <code>alpha</code> and <code>beta</code> estimated by
<code><a href="#topic+usl">usl</a></code>.
</p>
<p>The calculation is based on <em>A General Theory of Computational
Scalability Based on Rational Functions</em>, equation 26.
</p>


<h3>Value</h3>

<p><code>overhead</code> produces a matrix of overhead percentages based on
a non-parallelized workload. The column <code>ideal</code> contains the ideal
percentage of execution time. The columns <code>contention</code> and
<code>coherency</code> give the additional overhead percentage caused by
the respective effects.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>
<p>Neil J. Gunther. A General Theory of Computational Scalability
Based on Rational Functions. Computing Research Repository, 2008.
<code>http://arxiv.org/abs/0808.1431</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="#topic+USL-class">USL-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(specsdm91)

## Print overhead in processing time for demo dataset
overhead(usl(throughput ~ load, specsdm91))

</code></pre>

<hr>
<h2 id='peak.scalability+2CUSL-method'>Point of peak scalability of a USL model</h2><span id='topic+peak.scalability+2CUSL-method'></span><span id='topic+peak.scalability'></span>

<h3>Description</h3>

<p>Calculate the point of peak scalability for a specific model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
peak.scalability(object, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peak.scalability+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
<tr><td><code id="peak.scalability+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="peak.scalability+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="peak.scalability+2B2CUSL-method_+3A_gamma">gamma</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The peak scalability is the point where the throughput of the system starts
to go retrograde, i.e., starts to decrease with increasing load.
</p>
<p>The parameters <code>alpha</code>, <code>beta</code> and <code>gamma</code> are useful to do a
what-if analysis. Setting these parameters override the model parameters and
show how the system would behave with a different contention or coherency
delay parameter.
</p>
<p>See formula (4.33) in <em>Guerilla Capacity Planning</em>.
</p>
<p>This function accepts an argument for <code>gamma</code> although the value is
not required to perform the calculation. This is on purpose to provide a
coherent interface.
</p>


<h3>Value</h3>

<p>A numeric value for the point where peak scalability will be
reached.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>,
<code><a href="#topic+optimal.scalability+2CUSL-method">optimal.scalability,USL-method</a></code>
<code><a href="#topic+limit.scalability+2CUSL-method">limit.scalability,USL-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(specsdm91)

peak.scalability(usl(throughput ~ load, specsdm91))
## Peak scalability will be reached at about 96 virtual users

</code></pre>

<hr>
<h2 id='plot+2CUSL-method'>Plot the scalability function from a USL model</h2><span id='topic+plot+2CUSL-method'></span>

<h3>Description</h3>

<p>Create a line plot for the scalability functionh of a Universal
Scalability Law model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
plot(
  x,
  from = NULL,
  to = NULL,
  xlab = NULL,
  ylab = NULL,
  bounds = FALSE,
  alpha,
  beta,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CUSL-method_+3A_x">x</code></td>
<td>
<p>The USL object to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_from">from</code></td>
<td>
<p>The start of the range over which the scalability function
will be plotted.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_to">to</code></td>
<td>
<p>The end of the range over which the scalability function
will be plotted.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_bounds">bounds</code></td>
<td>
<p>Add the bounds of scalability to the plot. This always
includes the linear scalability bound for low loads. If the contention
coefficient <code>alpha</code> is a positive number, then the Amdahl asymptote
for high loads will also be plotted. If the coherency coefficient
<code>beta</code> is also a positive number, then the point of peak scalability
will also be indicated. All bounds are show using dotted lines. Some
bounds might not be shown using the default plot area. In this case the
parameter <code>ylim</code> can be used to increase the visible plot area and
include all bounds in the output.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="plot+2B2CUSL-method_+3A_...">...</code></td>
<td>
<p>Other graphical parameters passed to plot
(see <code><a href="graphics.html#topic+par">par</a></code>, <code><a href="graphics.html#topic+plot.function">plot.function</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot</code> creates a plot of the scalability function for the model
represented by the argument <code>x</code>.
</p>
<p>If <code>from</code> is not specified then the range starts at the minimum value
given to define the model. An unspecified value for <code>to</code> will lead
to plot ending at the maximum value from the model. For <code>add = TRUE</code>
the defaults are taken from the limits of the previous plot.
</p>
<p><code>xlab</code> and <code>ylab</code> can be used to set the axis titles. The defaults
are the names of the regressor and response variables used in the model.
</p>
<p>If the parameter <code>bounds</code> is set to <code>TRUE</code> then the plot also
shows dotted lines for the theoretical bounds of scalability. These are
the linear scalability for small loads and the Amdahl asymptote for the
limit of scalability as load approaches infinity.
</p>
<p>The parameters <code>alpha</code> or <code>beta</code> are useful to do a what-if
analysis. Setting these parameters override the model parameters and show
how the system would behave with a different contention or coherency delay
parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="graphics.html#topic+plot.function">plot.function</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(specsdm91)

## Plot result from USL model for demo dataset
plot(usl(throughput ~ load, specsdm91), bounds = TRUE, ylim = c(0, 3500))

</code></pre>

<hr>
<h2 id='predict+2CUSL-method'>Predict method for Universal Scalability Law models</h2><span id='topic+predict+2CUSL-method'></span>

<h3>Description</h3>

<p><code>predict</code> is a function for predictions of the scalability of a system
modeled with the Universal Scalability Law. It evaluates the regression
function in the frame <code>newdata</code> (which defaults to
<code>model.frame(object)</code>). Setting <code>interval</code> to &quot;<code>confidence</code>&quot;
requests the computation of confidence intervals at the specified
<code>level</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
predict(
  object,
  newdata,
  alpha,
  beta,
  interval = c("none", "confidence"),
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict+2B2CUSL-method_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables
with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="predict+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="predict+2B2CUSL-method_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation. Default is to calculate no
confidence interval.</p>
</td></tr>
<tr><td><code id="predict+2B2CUSL-method_+3A_level">level</code></td>
<td>
<p>Confidence level. Default is 0.95.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>alpha</code> or <code>beta</code> are useful to do a what-if
analysis. Setting these parameters override the model parameters and show
how the system would behave with a different contention or coherency delay
parameter.
</p>
<p><code>predict</code> internally uses the function returned by
<code><a href="#topic+scalability+2CUSL-method">scalability,USL-method</a></code> to calculate the result.
</p>


<h3>Value</h3>

<p><code>predict</code> produces a vector of predictions or a matrix of
predictions and bounds with column names <code>fit</code>, <code>lwr</code>, and
<code>upr</code> if <code>interval</code> is set to &quot;<code>confidence</code>&quot;.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="#topic+scalability+2CUSL-method">scalability,USL-method</a></code>,
<code><a href="#topic+USL-class">USL-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Print predicted result from USL model for demo dataset
predict(usl(throughput ~ processors, raytracer))

## The same prediction with confidence intervals at the 99% level
predict(usl(throughput ~ processors, raytracer),
        interval = "confidence", level = 0.99)

</code></pre>

<hr>
<h2 id='print+2CUSL-method'>Print objects of class &quot;<code>USL</code>&quot;</h2><span id='topic+print+2CUSL-method'></span>

<h3>Description</h3>

<p><code>print</code> prints its argument and returns it invisibly (via
<code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CUSL-method_+3A_x">x</code></td>
<td>
<p>An object from class <code>USL</code>.</p>
</td></tr>
<tr><td><code id="print+2B2CUSL-method_+3A_digits">digits</code></td>
<td>
<p>Minimal number of <em>significant</em> digits, see
<a href="base.html#topic+print.default">print.default</a>.</p>
</td></tr>
<tr><td><code id="print+2B2CUSL-method_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print</code> returns the object <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="#topic+USL-class">USL-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Print result from USL model for demo dataset
print(usl(throughput ~ processors, raytracer))

</code></pre>

<hr>
<h2 id='raytracer'>Performance of a ray-tracing software on different hardware configurations</h2><span id='topic+raytracer'></span>

<h3>Description</h3>

<p>A dataset containing performance data for a ray-tracing benchmark.
</p>


<h3>Format</h3>

<p>A data frame with 11 rows on 2 variables
</p>


<h3>Details</h3>

<p>The benchmark measured the number of ray-geometry intersections per second.
The data was gathered on an SGI Origin 2000 with 64 R12000 processors
running at 300 MHz.
</p>
<p>The data frame contains the following variables:
</p>

<ul>
<li> <p><code>processors</code> The number of CPUs used for the benchmark (1&ndash;64).
</p>
</li>
<li> <p><code>throughput</code> The number of operations per second.
</p>
</li></ul>



<h3>Source</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
Original dataset from <a href="https://sourceforge.net/projects/brlcad/">https://sourceforge.net/projects/brlcad/</a>
</p>

<hr>
<h2 id='scalability+2CUSL-method'>Scalability function of a USL model</h2><span id='topic+scalability+2CUSL-method'></span><span id='topic+scalability'></span>

<h3>Description</h3>

<p><code>scalability</code> is a higher order function and returns a function to
calculate the scalability for the specific USL model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
scalability(object, alpha, beta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalability+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
<tr><td><code id="scalability+2B2CUSL-method_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="scalability+2B2CUSL-method_+3A_beta">beta</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
<tr><td><code id="scalability+2B2CUSL-method_+3A_gamma">gamma</code></td>
<td>
<p>Optional parameter to be used for evaluation instead of the
parameter computed for the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned function can be used to calculate specific values once the
model for a system has been created.
</p>
<p>The parameters <code>alpha</code> and <code>beta</code> are useful to do a what-if
analysis. Setting these parameters override the model parameters and show
how the system would behave with a different contention or coherency delay
parameter.
</p>


<h3>Value</h3>

<p>A function with parameter <code>x</code> that calculates the
scalability value of the specific model.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>,
<code><a href="#topic+peak.scalability+2CUSL-method">peak.scalability,USL-method</a></code>
<code><a href="#topic+optimal.scalability+2CUSL-method">optimal.scalability,USL-method</a></code>
<code><a href="#topic+limit.scalability+2CUSL-method">limit.scalability,USL-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Compute the scalability function
scf &lt;- scalability(usl(throughput ~ processors, raytracer))

## Print scalability for 32 CPUs for the demo dataset
print(scf(32))

## Plot scalability for the range from 1 to 64 CPUs
plot(scf, from=1, to=64)

</code></pre>

<hr>
<h2 id='show+2CUSL-method'>Show objects of class &quot;<code>USL</code>&quot;</h2><span id='topic+show+2CUSL-method'></span>

<h3>Description</h3>

<p>Display the object by printing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>The object to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>show</code> returns an invisible <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="#topic+USL-class">USL-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Show USL model
show(usl(throughput ~ processors, raytracer))

</code></pre>

<hr>
<h2 id='sigma+2CUSL-method'>Extract Residual Standard Deviation 'Sigma'</h2><span id='topic+sigma+2CUSL-method'></span>

<h3>Description</h3>

<p><code>sigma</code> Extract Residual Standard Deviation 'Sigma'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>An object from class <code>USL</code>.</p>
</td></tr>
<tr><td><code id="sigma+2B2CUSL-method_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="#topic+USL-class">USL-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Print result from USL model for demo dataset
print(sigma(usl(throughput ~ processors, raytracer)))

</code></pre>

<hr>
<h2 id='specsdm91'>Performanced of a Sun SPARCcenter 2000 in the SPEC SDM91 benchmark</h2><span id='topic+specsdm91'></span>

<h3>Description</h3>

<p>A dataset containing performance data for a Sun SPARCcenter 2000 (16 CPUs)
</p>


<h3>Format</h3>

<p>A data frame with 7 rows on 2 variables
</p>


<h3>Details</h3>

<p>A Sun SPARCcenter 2000 with 16 CPUs was used for the SPEC SDM91 benchmark
in October 1994. The benchmark simulates a number of users working on the
UNIX server and measures the number of script executions per hour.
</p>
<p>The data frame contains the following variables:
</p>

<ul>
<li> <p><code>load</code> The number of simulated users (1&ndash;216).
</p>
</li>
<li> <p><code>throughput</code> The achieved throughput in scripts per hour.
</p>
</li></ul>



<h3>Source</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
Original dataset from
<a href="http://www.spec.org/osg/sdm91/results/results.html">http://www.spec.org/osg/sdm91/results/results.html</a>
</p>

<hr>
<h2 id='summary+2CUSL-method'>USL Object Summary</h2><span id='topic+summary+2CUSL-method'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;<code>USL</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'USL'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CUSL-method_+3A_object">object</code></td>
<td>
<p>A USL object.</p>
</td></tr>
<tr><td><code id="summary+2B2CUSL-method_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>, <code><a href="#topic+USL-class">USL-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Show summary for demo dataset
summary(usl(throughput ~ processors, raytracer))

## Extract model coefficients
summary(usl(throughput ~ processors, raytracer))$coefficients

</code></pre>

<hr>
<h2 id='usl'>Create a model for the Universal Scalability Law</h2><span id='topic+usl'></span>

<h3>Description</h3>

<p><code>usl</code> is used to create a model for the Universal Scalability Law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usl(formula, data, method = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usl_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that
can be coerced to that class): a symbolic description of the model to be
analyzed. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="usl_+3A_data">data</code></td>
<td>
<p>A data frame, list or environment (or object coercible by
as.data.frame to a data frame) containing the variables in the model.
If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>usl</code> is called.</p>
</td></tr>
<tr><td><code id="usl_+3A_method">method</code></td>
<td>
<p>Character value specifying the method to use. The possible
values are described under 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Universal Scalability Law is used to forcast the scalability of
either a hardware or a software system.
</p>
<p>The USL model works with one independent variable (e.g. virtual users,
processes, threads, ...) and one dependent variable (e.g. throughput, ...).
Therefore the model formula must be in the simple
&quot;<code>response ~ predictor</code>&quot; format.
</p>
<p>The model produces two main coefficients as result: <code>alpha</code> models the
contention and <code>beta</code> the coherency delay of the system. The third
coefficient <code>gamma</code> estimates the value of the dependent variable
(e.g. throughput) for the single user/process/thread case. It therefore
corresponds to the scale factor calculated in previous versions of the
<code>usl</code> package.
</p>
<p>The function <code><a href="stats.html#topic+coef">coef</a></code> extracts the coefficients from the model
object.
</p>
<p>The argument <code>method</code> selects which solver is used to solve the
model:
</p>

<ul>
<li><p> &quot;<code>nls</code>&quot; for a nonlinear regression model. This method
estimates all coefficients <code>alpha</code>, <code>beta</code> and <code>gamma</code>.
The R base function <code><a href="stats.html#topic+nls">nls</a></code> with the &quot;<code>port</code>&quot; algorithm
is used internally to solve the model. So all restrictions of the
&quot;<code>port</code>&quot; algorithm apply.
</p>
</li>
<li><p> &quot;<code>nlxb</code>&quot; for a nonliner regression model using the function
<code><a href="nlsr.html#topic+nlxb">nlxb</a></code> from the <code><a href="nlsr.html#topic+nlsr">nlsr</a></code> package. This method
also estimates all three coefficients. It is expected to be more robust
than the <code>nls</code> method.
</p>
</li>
<li><p> &quot;<code>default</code>&quot; for the default method using a transformation
into a 2nd degree polynom has been removed with the implementation
of the model using three coefficients in the <span class="pkg">usl</span> package 2.0.0.
Calling the &quot;<code>default</code>&quot; method will internally dispatch to the
&quot;<code>nlxb</code>&quot; solver instead.
</p>
</li></ul>

<p>The Universal Scalability Law can be expressed with following formula.
<code>C(N)</code> predicts the relative capacity of the system for a given
load <code>N</code>:
</p>
<p style="text-align: center;"><code class="reqn">C(N) = \frac{\gamma N}{1 + \alpha (N - 1) + \beta N (N - 1)}</code>
</p>



<h3>Value</h3>

<p>An object of class USL.
</p>


<h3>References</h3>

<p>Neil J. Gunther. Guerrilla Capacity Planning: A Tactical
Approach to Planning for Highly Scalable Applications and Services.
Springer, Heidelberg, Germany, 1st edition, 2007.
</p>
<p>John C. Nash. nlsr: Functions for nonlinear least squares
solutions, 2017. R package version 2017.6.18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+efficiency+2CUSL-method">efficiency,USL-method</a></code>,
<code><a href="#topic+scalability+2CUSL-method">scalability,USL-method</a></code>,
<code><a href="#topic+peak.scalability+2CUSL-method">peak.scalability,USL-method</a></code>,
<code><a href="#topic+optimal.scalability+2CUSL-method">optimal.scalability,USL-method</a></code>,
<code><a href="#topic+limit.scalability+2CUSL-method">limit.scalability,USL-method</a></code>,
<code><a href="#topic+summary+2CUSL-method">summary,USL-method</a></code>,
<code><a href="#topic+sigma+2CUSL-method">sigma,USL-method</a></code>
<code><a href="#topic+predict+2CUSL-method">predict,USL-method</a></code>,
<code><a href="#topic+overhead+2CUSL-method">overhead,USL-method</a></code>,
<code><a href="#topic+confint+2CUSL-method">confint,USL-method</a></code>,
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>,
<code><a href="stats.html#topic+df.residual">df.residual</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(usl)

data(raytracer)

## Create USL model for "throughput" by "processors"
usl.model &lt;- usl(throughput ~ processors, raytracer)

## Show summary of model parameters
summary(usl.model)

## Show complete list of efficiency parameters
efficiency(usl.model)

## Extract coefficients for model
coef(usl.model)

## Calculate point of peak scalability
peak.scalability(usl.model)

## Plot original data and scalability function
plot(raytracer)
plot(usl.model, add=TRUE)

</code></pre>

<hr>
<h2 id='USL-class'>Class &quot;<code>USL</code>&quot; for Universal Scalability Law models</h2><span id='topic+USL-class'></span>

<h3>Description</h3>

<p>This class encapsulates the Universal Scalability Law. Use the function
<code><a href="#topic+usl">usl</a></code> to create new objects from this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>frame</code></dt><dd><p>The model frame.</p>
</dd>
<dt><code>call</code></dt><dd><p>The call used to create the model.</p>
</dd>
<dt><code>regr</code></dt><dd><p>The name of the regressor variable.</p>
</dd>
<dt><code>resp</code></dt><dd><p>The name of the response variable.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>The coefficients alpha, beta and gamma of the model.</p>
</dd>
<dt><code>coef.std.err</code></dt><dd><p>The standard errors for the coefficients alpha and beta.</p>
</dd>
<dt><code>coef.names</code></dt><dd><p>A vector with the names of the coefficients.</p>
</dd>
<dt><code>fitted</code></dt><dd><p>The fitted values of the model. This is a vector.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>The residuals of the model. This is a vector.</p>
</dd>
<dt><code>df.residual</code></dt><dd><p>The degrees of freedom of the model.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The residual standard deviation of the model.</p>
</dd>
<dt><code>limit</code></dt><dd><p>The scalability limit as per Amdahl.</p>
</dd>
<dt><code>peak</code></dt><dd><p>A vector with the predictor and response values of the peak.</p>
</dd>
<dt><code>optimal</code></dt><dd><p>A vector with the optimal predictor and response values.</p>
</dd>
<dt><code>efficiency</code></dt><dd><p>The efficiency, e.g. speedup per processor.</p>
</dd>
<dt><code>na.action</code></dt><dd><p>The <code>na.action</code> used by the model.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>

<hr>
<h2 id='usl.solve.nls'>Solve a USL model using non linear regression</h2><span id='topic+usl.solve.nls'></span>

<h3>Description</h3>

<p>This function solves a USL model using non linear regression with least
squares. It uses the function <code><a href="stats.html#topic+nls">nls</a></code> with the &quot;<code>port</code>&quot;
algorithm to perform the calculation. All restrictions of the algorithm
apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usl.solve.nls(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usl.solve.nls_+3A_model">model</code></td>
<td>
<p>A data frame with two columns containing the values of the
predictor variable in the first column and the values of the response
variable in the second column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements: the model coefficients alpha,
beta and gamma.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>

<hr>
<h2 id='usl.solve.nlxb'>Solve a USL model using non linear regression</h2><span id='topic+usl.solve.nlxb'></span>

<h3>Description</h3>

<p>This function solves a USL model using non linear regression with least
squares. It uses the function <code><a href="nlsr.html#topic+nlxb">nlxb</a></code> from the <span class="pkg">nlsr</span>
package to perform the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usl.solve.nlxb(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usl.solve.nlxb_+3A_model">model</code></td>
<td>
<p>A data frame with two columns containing the values of the
predictor variable in the first column and the values of the response
variable in the second column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements: the model coefficients alpha,
beta and gamma.
</p>


<h3>References</h3>

<p>John C. Nash. nlsr: Functions for nonlinear least squares
solutions, 2017. R package version 2017.6.18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usl">usl</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
