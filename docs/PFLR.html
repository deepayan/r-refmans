<!DOCTYPE html><html lang="en"><head><title>Help for package PFLR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PFLR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FLiRTI'><p>FLiRTI Regression Model</p></a></li>
<li><a href='#ngr'><p>Nested Group Bridge Regression Model</p></a></li>
<li><a href='#ngr.data.generator.bsplines'><p>Generating random curves from B-Splines</p></a></li>
<li><a href='#PenS'><p>Penalized B-splines Regression Model</p></a></li>
<li><a href='#plot.flirti'><p>Plot Method for flirti Objects</p></a></li>
<li><a href='#plot.ngr'><p>Plot Method for ngr Objects</p></a></li>
<li><a href='#plot.ps'><p>Plot Method for Penalized B-splines Objects</p></a></li>
<li><a href='#plot.slos'><p>Plot Method for SLoS Objects</p></a></li>
<li><a href='#predict.flirti'><p>Predict Method for flirti Objects</p></a></li>
<li><a href='#predict.ngr'><p>Predict Method for ngr Objects</p></a></li>
<li><a href='#predict.ps'><p>Predict Method for Penalized B-splines objects</p></a></li>
<li><a href='#predict.slos'><p>Predict Method for SLoS objects</p></a></li>
<li><a href='#SLoS'><p>SLoS regression Model</p></a></li>
<li><a href='#summary.flirti'><p>Summary Method for flirti Objects</p></a></li>
<li><a href='#summary.ngr'><p>Summary Method for ngr Objects</p></a></li>
<li><a href='#summary.ps'><p>Summary Method for Penalized B-splines Objects</p></a></li>
<li><a href='#summary.slos'><p>Summary Method for SLoS Objects</p></a></li>
<li><a href='#truck'><p>Truck emissions data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Penalized Functional Linear Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of commonly used penalized functional linear regression models, including the Smooth and Locally Sparse (SLoS) method by Lin et al. (2016) &lt;<a href="https://doi.org/10.1080%2F10618600.2016.1195273">doi:10.1080/10618600.2016.1195273</a>&gt;, Nested Group bridge Regression (NGR) method by Guan et al. (2020) &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1713797">doi:10.1080/10618600.2020.1713797</a>&gt;, Functional Linear Regression That's interpretable (FLIRTI) by James et al. (2009) &lt;<a href="https://doi.org/10.1214%2F08-AOS641">doi:10.1214/08-AOS641</a>&gt;, and the Penalized B-spline regression method.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, MASS, flare, psych, glmnet, stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-21 19:50:05 UTC; shl20</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Author:</td>
<td>Tianyu Guan [aut],
  Haolun Shi [aut, cre, cph],
  Rob Cameron [aut],
  Zhenhua Lin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haolun Shi &lt;shl2003@connect.hku.hk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-22 06:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='FLiRTI'>FLiRTI Regression Model</h2><span id='topic+FLiRTI'></span>

<h3>Description</h3>

<p>Calculates functional regression that's interpretable using the FLiRTI method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLiRTI(
  Y,
  X,
  d,
  cons,
  domain,
  extra = list(Mf = 6:30, lambda = seq(5e-04, 100, length.out = 50))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLiRTI_+3A_y">Y</code></td>
<td>
<p>Vector of length n, centred response.</p>
</td></tr>
<tr><td><code id="FLiRTI_+3A_x">X</code></td>
<td>
<p>Matrix of n x p, covariate matrix, should be dense.</p>
</td></tr>
<tr><td><code id="FLiRTI_+3A_d">d</code></td>
<td>
<p>Integer, degree of the B-spline basis functions.</p>
</td></tr>
<tr><td><code id="FLiRTI_+3A_cons">cons</code></td>
<td>
<p>Divide subinterval into how many small ones.</p>
</td></tr>
<tr><td><code id="FLiRTI_+3A_domain">domain</code></td>
<td>
<p>The range over which the function X(t) is evaluated and the coefficient function <code class="reqn">\beta</code>(t) is expanded by the B-spline basis functions.</p>
</td></tr>
<tr><td><code id="FLiRTI_+3A_extra">extra</code></td>
<td>
<p>List containing parameters which have default values:
</p>

<ul>
<li><p> Mf: Mf+1 is the number of knots for the B-spline basis functions that expand <code class="reqn">\beta</code>(t), default is 6:30.
</p>
</li>
<li><p> lambda: Tuning parameter, default is seq(0.0005,100,length.out = 50).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>beta: Estimated <code class="reqn">\beta</code>(t) at discrete points.
</p>
<p>extra: List containing other values which may be of use:
</p>

<ul>
<li><p> X: Matrix of n x p used for model.
</p>
</li>
<li><p> Y: Vector of length n used for model.
</p>
</li>
<li><p> domain: The range over which the function X(t) was evaluated and the coefficient function <code class="reqn">\beta</code>(t) was expanded by the B-spline basis functions.
</p>
</li>
<li><p> delta: Estimated cutoff point.
</p>
</li>
<li><p> OptM: Optimal number of B-spline knots selected by BIC.
</p>
</li>
<li><p> Optlambda: Optimal shrinkage parameter selected by BIC.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 200
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)
lambda = seq(0.0005,0.01,length.out = 10)
Mf = 6:13
extra=list(Mf=Mf,lambda=lambda)

for(itersim in 1:nsim)
{
  dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=1)
 Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}


fltyfit = FLiRTI(Y=Y[1:n,1],(X[1:n,,1]),d=3,cons=4,domain=domain,extra=extra)


</code></pre>

<hr>
<h2 id='ngr'>Nested Group Bridge Regression Model</h2><span id='topic+ngr'></span>

<h3>Description</h3>

<p>Calculates a functional regression model using a nested group bridge approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngr(
  Y,
  X,
  M,
  d,
  domain,
  extra = list(alphaPS = 10^(-10:0), kappa = 10^(-(9:7)), tau = exp(seq(-50, -15, len =
    20)), gamma = 0.5, niter = 100)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ngr_+3A_y">Y</code></td>
<td>
<p>Vector of length n.</p>
</td></tr>
<tr><td><code id="ngr_+3A_x">X</code></td>
<td>
<p>Matrix of n x p, covariate matrix, should be dense.</p>
</td></tr>
<tr><td><code id="ngr_+3A_m">M</code></td>
<td>
<p>Integer, t1,..., tM are M equally spaced knots.</p>
</td></tr>
<tr><td><code id="ngr_+3A_d">d</code></td>
<td>
<p>Integer, the degree of B-Splines.</p>
</td></tr>
<tr><td><code id="ngr_+3A_domain">domain</code></td>
<td>
<p>The range over which the function X(t) is evaluated and the coefficient function <code class="reqn">\beta</code>(t) is expanded by the B-spline basis functions.</p>
</td></tr>
<tr><td><code id="ngr_+3A_extra">extra</code></td>
<td>
<p>List containing other parameters which have defaults:
</p>

<ul>
<li><p> alphaPs: Smoothing parameter for the Penalized B-splines method, default is 10^(-10:0).
</p>
</li>
<li><p> kappa: Tuning parameter for roughness penalty, default is 10^(-(9:7)).
</p>
</li>
<li><p> tau: Tuning parameter for the group bridge penalty, default is exp(seq(-50,-15,len = 20)).
</p>
</li>
<li><p> gamma: Real number, default is 0.5.
</p>
</li>
<li><p> niter: Integer, maximum number of iterations, default is 100.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>beta: Estimated <code class="reqn">\beta</code>(t) at discrete points.
</p>
<p>extra: List containing other values which may be of use:
</p>

<ul>
<li><p> b: Estimated b-hat.
</p>
</li>
<li><p> delta: Estimated cutoff point.
</p>
</li>
<li><p> Ymean: Estimated y-hat.
</p>
</li>
<li><p> Xmean: Estimated x-hat.
</p>
</li>
<li><p> Optkappa: Optimal roughness penalty selected.
</p>
</li>
<li><p> Opttau: Optimal group bridge penalty selected.
</p>
</li>
<li><p> M: Integer representing the number of knots used in the model calculation.
</p>
</li>
<li><p> d: Integer, degree of B-Splines used.
</p>
</li>
<li><p> domain: The range over which the function X(t) was evaluated and the coefficient function <code class="reqn">\beta</code>(t) was expanded by the B-spline basis functions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
norder   = d+1
nknots   = M+1
tobs = seq(domain[1],domain[2],length.out = p)
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
basismat = eval.basis(tobs, basis)
h = (domain[2]-domain[1])/M
cef = c(1, rep(c(4,2), (M-2)/2), 4, 1)

V = eval.penalty(basis,int2Lfd(2))
alphaPS = 10^(-(10:3))
kappa   = 10^(-(8:7))
tau     = exp(seq(-35,-28,len=20))
gamma   = 0.5


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

ngrfit = ngr(Y=Y[1:n,1],X=(X[1:n,,1]),M,d,domain,extra= list(alphaPS=alphaPS, kappa=kappa, tau=tau))

</code></pre>

<hr>
<h2 id='ngr.data.generator.bsplines'>Generating random curves from B-Splines</h2><span id='topic+ngr.data.generator.bsplines'></span>

<h3>Description</h3>

<p>Generating random curves from B-Splines
n,nknots,norder,p,domain=c(0,1),snr,betaind
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngr.data.generator.bsplines(
  n,
  nknots,
  norder,
  p,
  domain = c(0, 1),
  snr,
  betaind
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ngr.data.generator.bsplines_+3A_n">n</code></td>
<td>
<p>Number of curves</p>
</td></tr>
<tr><td><code id="ngr.data.generator.bsplines_+3A_nknots">nknots</code></td>
<td>
<p>Number of knots</p>
</td></tr>
<tr><td><code id="ngr.data.generator.bsplines_+3A_norder">norder</code></td>
<td>
<p>Degree</p>
</td></tr>
<tr><td><code id="ngr.data.generator.bsplines_+3A_p">p</code></td>
<td>
<p>Number of time points</p>
</td></tr>
<tr><td><code id="ngr.data.generator.bsplines_+3A_domain">domain</code></td>
<td>
<p>Domain of time</p>
</td></tr>
<tr><td><code id="ngr.data.generator.bsplines_+3A_snr">snr</code></td>
<td>
<p>Signal to noise ratio</p>
</td></tr>
<tr><td><code id="ngr.data.generator.bsplines_+3A_betaind">betaind</code></td>
<td>
<p>Numeric index for function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X: The generated X matrix of curve sampled at each timepoint
</p>
<p>Y: The generated dependent variable
</p>

<hr>
<h2 id='PenS'>Penalized B-splines Regression Model</h2><span id='topic+PenS'></span>

<h3>Description</h3>

<p>Calculates a functional regression model using the penalized B-splines method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PenS(Y, X, alpha, M, d, domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PenS_+3A_y">Y</code></td>
<td>
<p>Vector of length n.</p>
</td></tr>
<tr><td><code id="PenS_+3A_x">X</code></td>
<td>
<p>Matrix of n x p, covariate matrix, should be dense.</p>
</td></tr>
<tr><td><code id="PenS_+3A_alpha">alpha</code></td>
<td>
<p>Vector.</p>
</td></tr>
<tr><td><code id="PenS_+3A_m">M</code></td>
<td>
<p>Integer, t1,..., tM are M equally spaced knots.</p>
</td></tr>
<tr><td><code id="PenS_+3A_d">d</code></td>
<td>
<p>Integer, the degree of B-Splines.</p>
</td></tr>
<tr><td><code id="PenS_+3A_domain">domain</code></td>
<td>
<p>The range over which the function X(t) is evaluated and the coefficient function <code class="reqn">\beta</code>(t) is expanded by the B-spline basis functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta: Estimated <code class="reqn">\beta</code>(t) at discrete points.
</p>
<p>extra: List containing other values which may be of use:
</p>

<ul>
<li><p> b: Estimated B-spline coefficients.
</p>
</li>
<li><p> Ymean: Mean of the Y values.
</p>
</li>
<li><p> Xmean: Mean of all X values.
</p>
</li>
<li><p> Optalpha: Optimal alpha value chosen.
</p>
</li>
<li><p> M: Integer representing the number of knots used in the model calculation.
</p>
</li>
<li><p> d: Integer, degree of B-Splines used.
</p>
</li>
<li><p> domain: The range over which the function X(t) was evaluated and the coefficient function <code class="reqn">\beta</code>(t) was expanded by the B-spline basis functions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
alpha = 10^(-(10:3))


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

psfit = PenS(Y=Y[1:n,1],X=(X[1:n,,1]), alpha=alpha, M=M, d=d, domain=domain)



</code></pre>

<hr>
<h2 id='plot.flirti'>Plot Method for flirti Objects</h2><span id='topic+plot.flirti'></span>

<h3>Description</h3>

<p>Plots coefficient function of objects of class &quot;flirti&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flirti'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.flirti_+3A_x">x</code></td>
<td>
<p>An object of class &quot;flirti&quot;.</p>
</td></tr>
<tr><td><code id="plot.flirti_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line graph of the beta values versus time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 200
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)
lambda = seq(0.0005,0.01,length.out = 10)
Mf = 6:13
extra=list(Mf=Mf,lambda=lambda)

for(itersim in 1:nsim)
{
  dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=1)
 Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}


fltyfit = FLiRTI(Y=Y[1:n,1],(X[1:n,,1]),d=3,cons=4,domain=domain,extra=extra)

plot(fltyfit)

</code></pre>

<hr>
<h2 id='plot.ngr'>Plot Method for ngr Objects</h2><span id='topic+plot.ngr'></span>

<h3>Description</h3>

<p>Plots coefficient function for objects of the class &quot;ngr&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ngr'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ngr_+3A_x">x</code></td>
<td>
<p>An object of class &quot;ngr&quot;.</p>
</td></tr>
<tr><td><code id="plot.ngr_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line graph of the beta values over time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20 
d = 3
norder   = d+1
nknots   = M+1
tobs = seq(domain[1],domain[2],length.out = p)
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
basismat = eval.basis(tobs, basis) 
h = (domain[2]-domain[1])/M
cef = c(1, rep(c(4,2), (M-2)/2), 4, 1)

V = eval.penalty(basis,int2Lfd(2))
alphaPS = 10^(-(10:3))
kappa   = 10^(-(8:7))
tau     = exp(seq(-35,-28,len=20))
gamma   = 0.5


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

ngrfit = ngr(Y=Y[1:n,1],X=(X[1:n,,1]),M,d,domain,extra= list(alphaPS=alphaPS, kappa=kappa, tau=tau))

plot(ngrfit)

</code></pre>

<hr>
<h2 id='plot.ps'>Plot Method for Penalized B-splines Objects</h2><span id='topic+plot.ps'></span>

<h3>Description</h3>

<p>Plots coefficient function of objects of class &quot;ps&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ps_+3A_x">x</code></td>
<td>
<p>An object of class &quot;ps&quot;.</p>
</td></tr>
<tr><td><code id="plot.ps_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line graph of the beta values versus time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
alpha = 10^(-(10:3))


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

psfit = PenS(Y=Y[1:n,1],X=(X[1:n,,1]), alpha=alpha, M=M, d=d, domain=domain)

plot(psfit)

</code></pre>

<hr>
<h2 id='plot.slos'>Plot Method for SLoS Objects</h2><span id='topic+plot.slos'></span>

<h3>Description</h3>

<p>Plots coefficient function for objects of class &quot;slos&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slos'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.slos_+3A_x">x</code></td>
<td>
<p>An object of class &quot;slos&quot;.</p>
</td></tr>
<tr><td><code id="plot.slos_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line graph of the beta values versus time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
norder   = d+1
nknots   = M+1
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
V = eval.penalty(basis,int2Lfd(2))

extra=list(lambda=exp(seq(-18,-12, length.out = 10)),gamma=10^(-8:-6))

for(itersim in 1:nsim)
{
 dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
  Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}

slosfit = SLoS(Y=Y[1:n,1],(X[1:n,,1]),M=M,d=d,domain=domain,extra=extra)
plot(slosfit)


</code></pre>

<hr>
<h2 id='predict.flirti'>Predict Method for flirti Objects</h2><span id='topic+predict.flirti'></span>

<h3>Description</h3>

<p>Predicted values based on objects of the class &quot;flirti&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flirti'
predict(object, Xnew, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.flirti_+3A_object">object</code></td>
<td>
<p>An object of class &quot;flirti&quot;.</p>
</td></tr>
<tr><td><code id="predict.flirti_+3A_xnew">Xnew</code></td>
<td>
<p>New covariate matrix for prediction, should be dense, centred.</p>
</td></tr>
<tr><td><code id="predict.flirti_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 200
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)
lambda = seq(0.0005,0.01,length.out = 10)
Mf = 6:13
extra=list(Mf=Mf,lambda=lambda)

for(itersim in 1:nsim)
{
  dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=1)
 Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}


fltyfit = FLiRTI(Y=Y[1:n,1],(X[1:n,,1]),d=3,cons=4,domain=domain,extra=extra)

predict(fltyfit,(X[1:n,,1]))


</code></pre>

<hr>
<h2 id='predict.ngr'>Predict Method for ngr Objects</h2><span id='topic+predict.ngr'></span>

<h3>Description</h3>

<p>Predicted values based on &quot;ngr&quot; class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ngr'
predict(object, Xnew, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ngr_+3A_object">object</code></td>
<td>
<p>An object of class &quot;ngr&quot;.</p>
</td></tr>
<tr><td><code id="predict.ngr_+3A_xnew">Xnew</code></td>
<td>
<p>New covariate matrix for prediction, should be dense, centred.</p>
</td></tr>
<tr><td><code id="predict.ngr_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated Y hat value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20 
d = 3
norder   = d+1
nknots   = M+1
tobs = seq(domain[1],domain[2],length.out = p)
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
basismat = eval.basis(tobs, basis) 
h = (domain[2]-domain[1])/M
cef = c(1, rep(c(4,2), (M-2)/2), 4, 1)

V = eval.penalty(basis,int2Lfd(2))
alphaPS = 10^(-(10:3))
kappa   = 10^(-(8:7))
tau     = exp(seq(-35,-28,len=20))
gamma   = 0.5


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

ngrfit = ngr(Y=Y[1:n,1],X=(X[1:n,,1]),M,d,domain,extra= list(alphaPS=alphaPS, kappa=kappa, tau=tau))
predict(ngrfit,X[1:n,,1])

</code></pre>

<hr>
<h2 id='predict.ps'>Predict Method for Penalized B-splines objects</h2><span id='topic+predict.ps'></span>

<h3>Description</h3>

<p>Predicted values based on objects of class &quot;ps&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps'
predict(object, Xnew, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ps_+3A_object">object</code></td>
<td>
<p>An object of class &quot;ps&quot;.</p>
</td></tr>
<tr><td><code id="predict.ps_+3A_xnew">Xnew</code></td>
<td>
<p>New covariate matrix for prediction, should be dense, centred.</p>
</td></tr>
<tr><td><code id="predict.ps_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
alpha = 10^(-(10:3))


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

psfit = PenS(Y=Y[1:n,1],X=(X[1:n,,1]), alpha=alpha, M=M, d=d, domain=domain)

predict(psfit,X[1:n,,1])

</code></pre>

<hr>
<h2 id='predict.slos'>Predict Method for SLoS objects</h2><span id='topic+predict.slos'></span>

<h3>Description</h3>

<p>Predicted values based on objects of class &quot;slos&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slos'
predict(object, Xnew, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.slos_+3A_object">object</code></td>
<td>
<p>An object of class &quot;slos&quot;.</p>
</td></tr>
<tr><td><code id="predict.slos_+3A_xnew">Xnew</code></td>
<td>
<p>New covariate matrix for prediction, should be dense, centred.</p>
</td></tr>
<tr><td><code id="predict.slos_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
norder   = d+1
nknots   = M+1
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
V = eval.penalty(basis,int2Lfd(2))

extra=list(lambda=exp(seq(-18,-12, length.out = 10)),gamma=10^(-8:-6))

for(itersim in 1:nsim)
{
 dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
  Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}

slosfit = SLoS(Y=Y[1:n,1],(X[1:n,,1]),M=M,d=d,domain=domain,extra=extra)

predict(slosfit,(X[1:n,,1]))

</code></pre>

<hr>
<h2 id='SLoS'>SLoS regression Model</h2><span id='topic+SLoS'></span>

<h3>Description</h3>

<p>Calculates functional regression using the Smooth and Locally Sparse (SLoS) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLoS(
  Y,
  X,
  M,
  d,
  domain,
  extra = list(Maxiter = 100, lambda = exp(seq(-20, -12, length.out = 10)), gamma =
    10^(-9:0), absTol = 10^(-10), Cutoff = 10^(-6))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SLoS_+3A_y">Y</code></td>
<td>
<p>Vector, length n, centred response.</p>
</td></tr>
<tr><td><code id="SLoS_+3A_x">X</code></td>
<td>
<p>Matrix of n x p, covariate matrix, should be dense, centred.</p>
</td></tr>
<tr><td><code id="SLoS_+3A_m">M</code></td>
<td>
<p>Integer, t1,..., tM are M equally spaced knots.</p>
</td></tr>
<tr><td><code id="SLoS_+3A_d">d</code></td>
<td>
<p>Integer, the degree of B-Splines.</p>
</td></tr>
<tr><td><code id="SLoS_+3A_domain">domain</code></td>
<td>
<p>The range over which the function X(t) is evaluated and the coefficient function <code class="reqn">\beta</code>(t) is expanded by the B-spline basis functions.</p>
</td></tr>
<tr><td><code id="SLoS_+3A_extra">extra</code></td>
<td>
<p>List of parameters which have default values:
</p>

<ul>
<li><p> Maxiter: Maximum number of iterations for convergence of beta, default is 100.
</p>
</li>
<li><p> lambda: Positive number, tuning parameter for fSCAD penalty, default is exp(seq(-20,-12, length.out = 10)).
</p>
</li>
<li><p> gamma: Positive number, tuning parameter for the roughness penalty, default is 10^(-9:0).
</p>
</li>
<li><p> absTol: Number, if max(norm(bHat)) is smaller than absTol, we stop another iteration, default is 10^(-10).
</p>
</li>
<li><p> Cutoff: Number, if bHat is smaller than Cutoff, set it to zero to avoid being numerically unstable, default is 10^(-6).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>beta: Estimated <code class="reqn">\beta</code>(t) at discrete points.
</p>
<p>extra: List containing other values which may be of use:
</p>

<ul>
<li><p> X: Matrix of n x p used for model.
</p>
</li>
<li><p> Y: Vector of length n used for model.
</p>
</li>
<li><p> M: Integer representing the number of knots used in the model calculation.
</p>
</li>
<li><p> d: Integer, degree of B-Splines used.
</p>
</li>
<li><p> domain: The range over which the function X(t) was evaluated and the coefficient function <code class="reqn">\beta</code>(t) was expanded by the B-spline basis functions.
</p>
</li>
<li><p> b: Estimated b values.
</p>
</li>
<li><p> delta: Estimated cutoff point.
</p>
</li>
<li><p> Optgamma: Optimal smoothing parameter selected by BIC.
</p>
</li>
<li><p> Optlambda: Optimal shrinkage parameter selected by BIC.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
norder   = d+1
nknots   = M+1
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = fda::create.bspline.basis(knots,nbasis,norder)
V = eval.penalty(basis,int2Lfd(2))

extra=list(lambda=exp(seq(-18,-12, length.out = 10)),gamma=10^(-8:-6))

for(itersim in 1:nsim)
{
 dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
  Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}

slosfit = SLoS(Y=Y[1:n,1],(X[1:n,,1]),M=M,d=d,domain=domain,extra=extra)


</code></pre>

<hr>
<h2 id='summary.flirti'>Summary Method for flirti Objects</h2><span id='topic+summary.flirti'></span>

<h3>Description</h3>

<p>Summarizes the values of an object of class &quot;flirti&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flirti'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.flirti_+3A_object">object</code></td>
<td>
<p>An object of class &quot;flirti&quot;.</p>
</td></tr>
<tr><td><code id="summary.flirti_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a 5 number summary of the beta values, delta, OptM, and Optlambda
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 200
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)
lambda = seq(0.0005,0.01,length.out = 10)
Mf = 6:13
extra=list(Mf=Mf,lambda=lambda)

for(itersim in 1:nsim)
{
  dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=1)
 Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}


fltyfit = FLiRTI(Y=Y[1:n,1],(X[1:n,,1]),d=3,cons=4,domain=domain,extra=extra)

summary(fltyfit)


</code></pre>

<hr>
<h2 id='summary.ngr'>Summary Method for ngr Objects</h2><span id='topic+summary.ngr'></span>

<h3>Description</h3>

<p>Summarizes objects of class &quot;ngr&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ngr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ngr_+3A_object">object</code></td>
<td>
<p>An object of class &quot;ngr&quot;.</p>
</td></tr>
<tr><td><code id="summary.ngr_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the 5 number summaries of beta and b values. Prints delta, Optkappa, and Opttau values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20 
d = 3
norder   = d+1
nknots   = M+1
tobs = seq(domain[1],domain[2],length.out = p)
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
basismat = eval.basis(tobs, basis) 
h = (domain[2]-domain[1])/M
cef = c(1, rep(c(4,2), (M-2)/2), 4, 1)

V = eval.penalty(basis,int2Lfd(2))
alphaPS = 10^(-(10:3))
kappa   = 10^(-(8:7))
tau     = exp(seq(-35,-28,len=20))
gamma   = 0.5


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=1)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

ngrfit = ngr(Y=Y[1:n,1],X=(X[1:n,,1]),M,d,domain,extra= list(alphaPS=alphaPS, kappa=kappa, tau=tau))

summary(ngrfit)

</code></pre>

<hr>
<h2 id='summary.ps'>Summary Method for Penalized B-splines Objects</h2><span id='topic+summary.ps'></span>

<h3>Description</h3>

<p>Summarizes the values of an object of class &quot;ps&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ps_+3A_object">object</code></td>
<td>
<p>An object of class &quot;ps&quot;.</p>
</td></tr>
<tr><td><code id="summary.ps_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a 5 number summary of the beta values and coefficient values, and the optimal alpha.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
alpha = 10^(-(10:3))


for(itersim in 1:nsim)
{
dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
Y[,itersim]  = dat$Y
X[,,itersim] = dat$X
}

psfit = PenS(Y=Y[1:n,1],X=(X[1:n,,1]), alpha=alpha, M=M, d=d, domain=domain)

summary(psfit)

</code></pre>

<hr>
<h2 id='summary.slos'>Summary Method for SLoS Objects</h2><span id='topic+summary.slos'></span>

<h3>Description</h3>

<p>Summarizes values of an object of class &quot;slos&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slos'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.slos_+3A_object">object</code></td>
<td>
<p>An object of class &quot;slos&quot;.</p>
</td></tr>
<tr><td><code id="summary.slos_+3A_...">...</code></td>
<td>
<p>Not applicable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints five number summary of beta values, delta, Optgamma, and Optlambda.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
betaind = 1
snr  = 2
nsim = 1
n    = 50
p    = 21
Y = array(NA,c(n,nsim))
X = array(NA,c(n,p,nsim))
domain = c(0,1)

M = 20
d = 3
norder   = d+1
nknots   = M+1
knots    = seq(domain[1],domain[2],length.out = nknots)
nbasis   = nknots + norder - 2
basis    = create.bspline.basis(knots,nbasis,norder)
V = eval.penalty(basis,int2Lfd(2))

extra=list(lambda=exp(seq(-18,-12, length.out = 10)),gamma=10^(-8:-6))

for(itersim in 1:nsim)
{
 dat = ngr.data.generator.bsplines(n=n,nknots=64,norder=4,p=p,domain=domain,snr=snr,betaind=betaind)
  Y[,itersim]  = dat$Y
  X[,,itersim] = dat$X
}

slosfit = SLoS(Y=Y[1:n,1],(X[1:n,,1]),M=M,d=d,domain=domain,extra=extra)

summary(slosfit)


</code></pre>

<hr>
<h2 id='truck'>Truck emissions data</h2><span id='topic+truck'></span>

<h3>Description</h3>

<p>The particulate matter emissions data, taken from the Coordinating Research Councils
E55/E59 research project (Clark et al. 2007). In the project,
trucks were placed on the chassis dynamometer bed to mimic
inertia and particulate matter was measured by an emission analyzer on standard test cycles. The engine acceleration of diesel
trucks was also recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truck
</code></pre>


<h3>Format</h3>

<p>A data frame with 108 rows and 91 columns:
</p>

<dl>
<dt>Y</dt><dd><p>Emmission</p>
</dd>
<dt>X1-X90</dt><dd><p>Acceleration at each second</p>
</dd>
</dl>



<h3>Source</h3>

<p>Clark, N., Gautam, M., Wayne, W., Lyons, D., Thompson, G., and Zielinska,
B. (2007), “Heavy-Duty Vehicle Chassis Dynamometer Testing for Emissions Inventory, Air Quality Modeling, Source Apportionment and Air
Toxics Emissions Inventory: E55/59 All Phases,” Coordinating Research Council, Alpharetta
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
