<!DOCTYPE html><html><head><title>Help for package fPASS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fPASS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#Extract_Eigencomp_fDA'><p>Extract/estimate eigenfunction from a sparse functional or longitudinal design</p>
by simulating from a large number of subjects.</a></li>
<li><a href='#fPASS-package'><p><code>fPASS</code> package</p></a></li>
<li><a href='#fpca_sc'><p>Functional principal components analysis by smoothed covariance</p></a></li>
<li><a href='#PASS_Proj_Test_ufDA'><p>Power and Sample size (PASS) calculation of</p>
Two-Sample Projection-based test for sparsely observed univariate functional data.</a></li>
<li><a href='#pHotellingT'><p>CDF of Hotelling-<code class="reqn">T^2</code> statistic.</p></a></li>
<li><a href='#Power_Proj_Test_ufDA'><p>Power of the Two-sample Projection-based test for functional data with known (or estimated)</p>
eigencomponents.</a></li>
<li><a href='#Sim_HotellingT_unequal_var'><p>Samples from the non-null distribution of the Hotelling-<code class="reqn">T^2</code> statistic under unequal covariance.</p></a></li>
<li><a href='#Sum_of_Wishart_df'><p>The approximate degrees of freedom formula for sum of Wishart.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Power and Sample Size for Projection Test under Repeated
Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the power and sample size (PASS) required to test for the
    difference in the mean function between two groups under a repeatedly measured longitudinal 
    or sparse functional design. See the manuscript by Koner and Luo (2023) <a href="https://salilkoner.github.io/assets/PASS_manuscript.pdf">https://salilkoner.github.io/assets/PASS_manuscript.pdf</a> 
    for details of the PASS formula and computational details. The details of the testing
    procedure for univariate and multivariate response are presented in
    Wang (2021) &lt;<a href="https://doi.org/10.1214%2F21-EJS1802">doi:10.1214/21-EJS1802</a>&gt; and Koner and Luo (2023) 
    &lt;<a href="https://arxiv.org/abs/2302.05612">arXiv:2302.05612</a>&gt; respectively. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, purrr, face, magrittr, MASS, Matrix, nlme, testthat,
mgcv, lifecycle, expm, gamm4, gss, rlang, stringr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Hotelling, refund, foreach</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SalilKoner/fPASS">https://github.com/SalilKoner/fPASS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SalilKoner/fPASS/issues">https://github.com/SalilKoner/fPASS/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-18 16:57:50 UTC; salilkoner</td>
</tr>
<tr>
<td>Author:</td>
<td>Salil Koner <a href="https://orcid.org/0000-0003-1952-4210"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Sheng Luo [ctb, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Salil Koner &lt;salil.koner@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-19 11:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='Extract_Eigencomp_fDA'>Extract/estimate eigenfunction from a sparse functional or longitudinal design
by simulating from a large number of subjects.</h2><span id='topic+Extract_Eigencomp_fDA'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The function <code>Extract_Eigencomp_fDA()</code> computes the eigenfunctions and the
covariance of the shrinkage scores required to conduct
the projection-based test of mean function between two groups of longitudinal data
or sparsely observed functional data under a random irregular design, as developed by Wang (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extract_Eigencomp_fDA(
  nobs_per_subj,
  obs.design,
  mean_diff_fnm,
  cov.type = c("ST", "NS"),
  cov.par,
  sigma2.e,
  missing_type = c("nomiss", "constant"),
  missing_percent = 0,
  eval_SS = 5000,
  alloc.ratio = c(1, 1),
  fpca_method = c("fpca.sc", "face"),
  work.grid = NULL,
  nWgrid = ifelse(is.null(work.grid), 101, length(work.grid)),
  data.driven.scores = FALSE,
  mean_diff_add_args = list(),
  fpca_optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_nobs_per_subj">nobs_per_subj</code></td>
<td>
<p>The number of observations per subject. Each element of it must be greater than 3.
It could also be a vector to indicate that the number of observation for each is randomly varying
between the elements of the vector, or a scalar to ensure that the number of observations are same
for each subject. See examples.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_obs.design">obs.design</code></td>
<td>
<p>The sampling design of the observations. Must be provided as
a list with the following elements. If the design is longitudinal (e.g. a clinical trial
where there is pre-specified schedule of visit for the participants) it must be
a named list with elements <code>design</code>, <code>visit.schedule</code> and <code>visit.window</code>, where
<code>obs.design$design</code> must be specified as <code>'longitudinal'</code>, <code>visit.schedule</code>
specifying schedule of visits (in months or days or any unit of time), other than the baseline visit
and <code>visit.window</code> denoting the maximum time window for every visit.
For functional design (where the observation points are either densely observed within a
compact interval or under a sparse random design), the argument must be provided
as a named list with elements <code>design</code> and <code>fun.domain</code>, where
<code>obs.design$design</code> must be specified as <code>'functional'</code> and <code>obs.design$fun.domain</code>
must be specified as a two length vector indicating the domain of the function.
See Details on the specification of arguments section below more details.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_mean_diff_fnm">mean_diff_fnm</code></td>
<td>
<p>The name of the function that output of the difference of the mean between the
two groups at any given time. It must be supplied as character, so that <code>match.fun(mean_diff_fnm)</code>
returns a valid function, that takes a vector input, and returns a vector of the same length of the input.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_cov.type">cov.type</code></td>
<td>
<p>The type of the covariance structure of the data, must be either of 'ST' (stationary) or
'NS' (non-stationary). This argument along with the <code>cov.par</code> argument must be
specified compatibly to ensure that the function does not return an error. See the details
of <code>cov.par</code> argument.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_cov.par">cov.par</code></td>
<td>
<p>The covariance structure of the latent response trajectory.
If <code>cov.type == 'ST'</code> then, <code>cov.par</code>
must be specified a named list of two elements, <code>var</code> and <code>cor</code>,
where <code>var</code> is the common variance of the observations, which must be a
positive number; and <code>cor</code> specifies the correlation structure between
the observations. <code>cov.par$cor</code> must be specified in the form of the
<a href="nlme.html#topic+corClasses">nlme::corClasses</a> specified in R package <span class="pkg">nlme</span>.
Check the package documentation for more details for each of the correlation classes.
The <code>cov.par$cor</code> must be a <code>corStruct</code> class so it can be
passed onto the <code><a href="nlme.html#topic+corMatrix">nlme::corMatrix()</a></code> to extract the subject-specific covariance matrix.
If <code>cov.type='NS'</code> then, <code>cov.par</code>
must be a named list of two elements, <code>cov.obj</code> and <code>eigen.comp</code>,
where only one of the <code>cov.par$cov.obj</code> or <code>cov.par$eigen.comp</code>
must be non-null. This is to specify that the covariance structure of the
latent trajectory can be either provided in the form of covariance function or
in the form of eigenfunction and eigenvalues (Spectral decomposition).
If the <code>cov.par$cov.obj</code> is specified, then it must be a bivariate function,
with two arguments. Alternatively, if the true eigenfunctions  are known,
then the user can specify that by specifying <code>cov.par$eigen.comp</code>.
In this case, the <code>cov.par$eigen.comp</code> must be a named list with two elements,
<code>eig.obj</code> and <code>eig.val</code>, where <code>cov.par$eigen.comp$eig.val</code>
must be positive vector and <code>cov.par$eigen.comp$eig.obj</code>
must be a vectorized function so that its evaluation at a vector of time points
returns a matrix of dimension r by <code>length(cov.par$eigen.comp$eig.val)</code>,
with r being the length of time points.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_sigma2.e">sigma2.e</code></td>
<td>
<p>Measurement error variance, should be set as zero or a very small number
if the measurement error is not significant.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_missing_type">missing_type</code></td>
<td>
<p>The type of missing in the number of observations of the subjects. Can be one of
<code>'nomiss'</code> for no missing observations
or <code>'constant'</code> for constant
missing percentage at every time point. The current version of package only supports
<code>missing_type = 'constant'</code>.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_missing_percent">missing_percent</code></td>
<td>
<p>The percentage of missing at each observation points for each subject.
Must be supplied as number between [0, 0.8], as missing percentage more than 80% is not practical.
If <code>nobs_per_subj</code> is supplied as vector, then <code>missing_type</code>
is forced to set as <code>'nomiss'</code> and <code>missing_percent = 0</code>, because
the <code>missing_type = 'constant'</code> has no meaning if the number of observations are
varying between the subject at the first, typically considered in
the case of sparse random functional design.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_eval_ss">eval_SS</code></td>
<td>
<p>The sample size based on which the eigencomponents will be estimated from data.
To compute the theoretical power of the test we must make sure that we use a large enough sample size
to generate the data such that the estimated eigenfunctions are very close to the true eigenfunctions
and that the sampling design will not have much effect on the loss of precision. Default value 5000.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_alloc.ratio">alloc.ratio</code></td>
<td>
<p>The allocation ratio of samples in the each group. Note that the eigenfunctions
will still be estimated based on the total sample_size, however, the variance
of the <code>shrinkage</code> scores (which is required to compute the power function) will be
estimated based on the allocation of the samples in each group. Must be given as vector of
length 2. Default value is set at <code>c(1, 1)</code>, indicating equal sample size.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_fpca_method">fpca_method</code></td>
<td>
<p>The method by which the FPCA is computed. Must be one of
'fpca.sc' and 'face'. If <code>fpca_method == 'fpca.sc'</code> then the eigencomponents
are estimated using the function <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>. However, since the <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>
function fails to estimate the correct <code>shrinkage</code> scores, and throws <code>NA</code> values
when the measurement errors is estimated to be zero, we wrote out a similar function
where we corrected those error in current version of <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>. Check out
the <code><a href="#topic+fpca_sc">fpca_sc()</a></code> function for details. If <code>fpca_method == 'face'</code>, then
the eigencomponents are estimated using <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code> function.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_work.grid">work.grid</code></td>
<td>
<p>The working grid in the domain of the functions, where the eigenfunctions
and other covariance components will be estimated. Default is NULL, then, a equidistant
grid points of length <code>nWgrid</code> will be internally created to as the default <code>work.grid</code>.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_nwgrid">nWgrid</code></td>
<td>
<p>The length of the <code>work.grid</code> in the domain of the function based on which
the eigenfunctions will be estimated. Default value is 101. If <code>work.grid</code>
is specified, then <code>nWgrid</code> must be null, and vice-versa.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_data.driven.scores">data.driven.scores</code></td>
<td>
<p>Indicates whether the scores are estimated from the full data, WITHOUT
assuming the mean function is unknown, rather the mean function is estimated using
<code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> function.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_mean_diff_add_args">mean_diff_add_args</code></td>
<td>
<p>Additional arguments to be passed to group difference
function specified in the argument <code>mean_diff_fnm</code>.</p>
</td></tr>
<tr><td><code id="Extract_Eigencomp_fDA_+3A_fpca_optns">fpca_optns</code></td>
<td>
<p>Additional options to be passed onto either of <code><a href="#topic+fpca_sc">fpca_sc()</a></code>
or <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code> function in order
to estimate the eigencomponents. It must be a named list with elements
to be passed onto the respective function, depending on the <code>fpca_method</code>.
The names of the list must not match either of
<code>c('data', 'newdata', 'argvals.new')</code>
for <code>fpca_method == 'face'</code> and must not match either of
<code>c('ydata', 'Y.pred')</code> for  <code>fpca_method == 'fpca.sc'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can handle data from wide variety of covariance structure, can be parametric,
or non-parametric. Additional with traditional stationary structures assumed for longitudinal
data (see <a href="nlme.html#topic+corClasses">nlme::corClasses</a>), the user can specify any other non-stationary covariance
function in the form of either a covariance function or in terms of eigenfunctions and
eigenvalues. The user have a lot of flexibility into tweaking the arguments <code>nobs_per_subject</code>,
<code>obs.design</code>, and <code>cov.par</code> to compute the eigencomponents
under different sampling design and covariance process of the response trajectory, and
for any arbitrary mean difference function. Internally, using the sampling
design and the covariance structure specified, we generate a large data with
large number of subjects, and estimate the eigenfunctions and the covariance of the estimated
<code>shrinkage</code> scores by means of functional principal component analysis (fPCA). We put the option of using
two most commonly used softwares for fPCA in the functional data literature, <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>
and <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code>. However, since the <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code> do not compute the <code>shrinkage</code>
scores correctly, especially when the measurement error variance is estimated to be zero,
we made a duplicate version of that function in our package, where we write out
the scoring part on our own. The new function is named as <code><a href="#topic+fpca_sc">fpca_sc()</a></code>, please check it out.
</p>


<h3>Value</h3>

<p>A list with the elements listed below.
</p>

<ol>
<li> <p><code>mean_diff_vec</code> - The evaluation of the mean function at the working grid.
</p>
</li>
<li> <p><code>est_eigenfun</code> - The evaluation of the estimated eigenfunctions at the working grid.
</p>
</li>
<li> <p><code>est_eigenval</code> - Estimated eigen values.
</p>
</li>
<li> <p><code>working.grid</code> - The grid points at which <code>mean_diff_vec</code> and
<code>est_eigenfun</code> are evaluated.
</p>
</li>
<li> <p><code>fpcCall</code> - The exact call of either of the <code><a href="#topic+fpca_sc">fpca_sc()</a></code> or <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code>
used to compute the eigencomponents.
</p>
</li>
<li> <p><code>scores_var1</code> - Estimated covariance of the <code>shrinkage</code> scores for the treatment group.
</p>
</li>
<li> <p><code>scores_var2</code> - Estimated covariance of the <code>shrinkage</code> scores for the placebo group.
</p>
</li>
<li> <p><code>pooled_var</code>  - Pooled covariance of the scores combining both the groups. This is required
if the user wants to compute the power of Hotelling T statistic under equal variance assumption.
</p>
</li></ol>

<p>If <code>data.driven.scores ==  TRUE</code> additional components are returned
</p>

<ol>
<li> <p><code>scores_1</code> - Estimated <code>shrinkage</code> scores for all the subjects in treatment group.
</p>
</li>
<li> <p><code>scores_2</code> - Estimated <code>shrinkage</code> scores for all the subjects in placebo group.
</p>
</li></ol>

<p>The output of this function is designed such a way the
user can directly input the output obtained from this function into the arguments of
<code><a href="#topic+Power_Proj_Test_ufDA">Power_Proj_Test_ufDA()</a></code> function to obtain the power and the sample size right away. The function
<a href="#topic+PASS_Proj_Test_ufDA">PASS_Proj_Test_ufDA</a> does the same, it is essentially a wrapper of<code><a href="#topic+Extract_Eigencomp_fDA">Extract_Eigencomp_fDA()</a></code>
and <code><a href="#topic+Power_Proj_Test_ufDA">Power_Proj_Test_ufDA()</a></code> together.
</p>


<h3>Specification of key arguments</h3>

<p>If <code>obs.design$design == 'functional'</code> then a dense grid of length,
specified by ngrid (typically 101/201) is internally created, and
the observation points will be randomly chosen from them.
The time points could also randomly chosen between
any number between the interval, but then for large number of subject,
<code><a href="#topic+fpca_sc">fpca_sc()</a></code> function will take huge
time to estimate the eigenfunction. For dense design, the user must set
a large value of the argument <code>nobs_per_subj</code> and for sparse (random) design,
<code>nobs_per_subj</code> should be set small (and varying).
On the other hand, typical to longitudinal data, if the measurements are
taken at fixed time points (from baseline)
for each subject, then the user must set <code>obs.design$design == 'longitudinal'</code> and
the time points must be accordingly specified
in the argument <code>obs.design$visit.schedule</code>. The length of <code>obs.design$visit.schedule</code>
must match <code>length(nobs_per_subj)-1</code>. Internally, when
<code>obs.design$design == 'longitudinal'</code>, the function scale the visit times
so that it lies between [0, 1], so the user should not
specify any element named <code>fun.domain</code> in the
list for <code>obs.design$design == 'longitudinal'</code>. Make sure that
the mean function and the covariance function specified
in the <code>cov.par</code> and <code>mean_diff_fnm</code> parameter also scaled to
take argument between [0, 1]. Also, it is imperative to say that <code>nobs_per_subj</code> must
be of a scalar positive integer for <code>design == 'longitudinal'</code>.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br /> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Wang, Qiyao (2021)
<em>Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423</em> <br />
<a href="https://doi.org/10.1214/21-EJS1802">doi:10.1214/21-EJS1802</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+Power_Proj_Test_ufDA">Power_Proj_Test_ufDA()</a></code>, <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code> and <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Extract eigencomponents from stationary covariance.

set.seed(12345)
mean.diff &lt;- function(t) {t};
obs.design &lt;- list("design" = "longitudinal",
"visit.schedule" = seq(0.1, 0.9, length.out=7),
"visit.window" = 0.05)
cor.str &lt;- nlme::corExp(1, form = ~ time | Subject);
sigma2 &lt;- 1; sigma2.e &lt;- 0.25; nobs_per_subj &lt;- 8;
missing_type &lt;- "constant"; missing_percent &lt;- 0.01;
eigencomp  &lt;- Extract_Eigencomp_fDA(obs.design = obs.design,
mean_diff_fnm = "mean.diff", cov.type = "ST",
cov.par = list("var" = sigma2, "cor" = cor.str),
sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
missing_type = missing_type,
missing_percent = missing_percent, eval_SS = 1000,
alloc.ratio = c(1,1), nWgrid = 201,
fpca_method = "fpca.sc", data.driven.scores = FALSE,
mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))

# Example 2: Extract eigencomponents from non-stationary covariance.

alloc.ratio  &lt;- c(1,1)
mean.diff    &lt;- function(t) {1 * (t^3)};
eig.fun &lt;- function(t, k) { if (k==1) {
ef &lt;- sqrt(2)*sin(2*pi*t)
} else if (k==2) {ef &lt;- sqrt(2)*cos(2*pi*t)}
return(ef)}
eig.fun.vec  &lt;- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))}
eigen.comp   &lt;- list("eig.val" = c(1, 0.5), "eig.obj" = eig.fun.vec)
obs.design   &lt;- list(design = "functional", fun.domain = c(0,1))
cov.par      &lt;- list("cov.obj" = NULL, "eigen.comp" = eigen.comp)
sigma2.e     &lt;- 0.001; nobs_per_subj &lt;- 4:7;
missing_type &lt;- "nomiss"; missing_percent &lt;- 0;
fpca_method  &lt;- "fpca.sc"
eigencomp  &lt;- Extract_Eigencomp_fDA(obs.design = obs.design,
 mean_diff_fnm = "mean.diff",
 cov.type = "NS", cov.par = cov.par,
 sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
 missing_type = missing_type,
 missing_percent = missing_percent, eval_SS = 1000,
 alloc.ratio = alloc.ratio, nWgrid = 201,
 fpca_method = "fpca.sc", data.driven.scores = FALSE,
 mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))

</code></pre>

<hr>
<h2 id='fPASS-package'><code>fPASS</code> package</h2><span id='topic+fPASS'></span><span id='topic+fPASS-package'></span>

<h3>Description</h3>

<p>See the README on <a href="https://github.com/SalilKoner/fPASS/blob/main/README.md">https://github.com/SalilKoner/fPASS/blob/main/README.md</a>
</p>


<h3>Details</h3>

<p>R package <span class="pkg">fPASS</span> is designed to perform the power and sample size analysis
for functional under a dense and sparse (random) design and longitudinal data. The
function can handle data from wide variety of covariance structure, can be parametric,
or non-parametric. The user have a lot of flexibility into tweaking the arguments of the function
to assess the power function of the test under different sampling design and covariance process
of the response trajectory, and for any arbitrary mean difference function. Overall, the
functionality of the module is quite comprehensive and includes all the different cases
considered in the NCSS PASS software. We believe that this software can be an effective
clinical trial design tools when considering the projection-based test as the primary
decision making method.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Salil Koner <a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a> (<a href="https://orcid.org/0000-0003-1952-4210">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Sheng Luo <a href="mailto:sheng.luo@duke.edu">sheng.luo@duke.edu</a> [contributor, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/SalilKoner/fPASS">https://github.com/SalilKoner/fPASS</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SalilKoner/fPASS/issues">https://github.com/SalilKoner/fPASS/issues</a>
</p>
</li></ul>

<p>See the primary function <code><a href="#topic+PASS_Proj_Test_ufDA">PASS_Proj_Test_ufDA()</a></code> to compute
the power and sample size of the test.
</p>

<hr>
<h2 id='fpca_sc'>Functional principal components analysis by smoothed covariance</h2><span id='topic+fpca_sc'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This function computes a FPC decomposition for a set of observed curves,
which may be sparsely observed and/or measured with error. A mixed model
framework is used to estimate curve-specific scores and variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpca_sc(
  Y = NULL,
  ydata = NULL,
  Y.pred = NULL,
  argvals = NULL,
  random.int = FALSE,
  nbasis = 10,
  pve = 0.95,
  npc = NULL,
  useSymm = FALSE,
  makePD = FALSE,
  center = TRUE,
  cov.est.method = 2,
  integration = "trapezoidal"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpca_sc_+3A_y">Y</code>, <code id="fpca_sc_+3A_ydata">ydata</code></td>
<td>
<p>the user must supply either <code>Y</code>, a matrix of functions
observed on a regular grid, or a data frame <code>ydata</code> representing
irregularly observed functions. See Details.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_y.pred">Y.pred</code></td>
<td>
<p>if desired, a matrix of functions to be approximated using
the FPC decomposition.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_argvals">argvals</code></td>
<td>
<p>the argument values of the function evaluations in <code>Y</code>,
defaults to a equidistant grid from 0 to 1.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_random.int">random.int</code></td>
<td>
<p>If <code>TRUE</code>, the mean is estimated by
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code> with random intercepts. If <code>FALSE</code> (the
default), the mean is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code> treating all the
data as independent.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_nbasis">nbasis</code></td>
<td>
<p>number of B-spline basis functions used for estimation of the
mean function and bivariate smoothing of the covariance surface.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_pve">pve</code></td>
<td>
<p>proportion of variance explained: used to choose the number of
principal components.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_npc">npc</code></td>
<td>
<p>prespecified value for the number of principal components (if
given, this overrides <code>pve</code>).</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_usesymm">useSymm</code></td>
<td>
<p>logical, indicating whether to smooth only the upper
triangular part of the naive covariance (when <code>cov.est.method==2</code>).
This can save computation time for large data sets, and allows for
covariance surfaces that are very peaked on the diagonal.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_makepd">makePD</code></td>
<td>
<p>logical: should positive definiteness be enforced for the
covariance surface estimate?</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_center">center</code></td>
<td>
<p>logical: should an estimated mean function be subtracted from
<code>Y</code>? Set to <code>FALSE</code> if you have already demeaned the data using
your favorite mean function estimate.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_cov.est.method">cov.est.method</code></td>
<td>
<p>covariance estimation method. If set to <code>1</code>, a
one-step method that applies a bivariate smooth to the <code class="reqn">y(s_1)y(s_2)</code>
values. This can be very slow. If set to <code>2</code> (the default), a two-step
method that obtains a naive covariance estimate which is then smoothed.</p>
</td></tr>
<tr><td><code id="fpca_sc_+3A_integration">integration</code></td>
<td>
<p>quadrature method for numerical integration; only
<code>'trapezoidal'</code> is currently supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is emulated from the <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code> function
where the estimation of covariance surface and the eigenfunctions are
exactly as that of <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>, but it rectifies the computational
intricacies involved in the estimation of <code>shrinkage</code> scores, and fixes
the issue of NA values in the score estimation when the measurement error
variance is estimated to be zero. Moreover, since this function is written
purely for the purpose of using it in the <code><a href="#topic+Extract_Eigencomp_fDA">Extract_Eigencomp_fDA()</a></code>
function, where we do not need the usage of the arguments <code>var</code> and <code>simul</code>
and <code>sim.alpha</code> at all, we have deleted those arguments in the
<code><a href="#topic+fpca_sc">fpca_sc()</a></code> function.
</p>
<p>The functional data must be supplied as either </p>
 <ul>
<li><p> an <code class="reqn">n
\times d</code> matrix <code>Y</code>, each row of which is one functional observation,
with missing values allowed; or </p>
</li>
<li><p> a data frame <code>ydata</code>, with
columns <code>'.id'</code> (which curve the point belongs to, say <code class="reqn">i</code>),
<code>'.index'</code> (function argument such as time point <code class="reqn">t</code>), and
<code>'.value'</code> (observed function value <code class="reqn">Y_i(t)</code>).</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>fpca</code> containing:
</p>
<table>
<tr><td><code>Yhat</code></td>
<td>
<p>FPC approximation (projection onto leading components)
of <code>Y.pred</code> if specified, or else of <code>Y</code>.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the observed data</p>
</td></tr><tr><td><code>scores</code></td>
<td>
<p><code class="reqn">n
\times npc</code> matrix of estimated FPC scores.</p>
</td></tr> <tr><td><code>mu</code></td>
<td>
<p>estimated mean
function (or a vector of zeroes if <code>center==FALSE</code>).</p>
</td></tr> <tr><td><code>efunctions</code></td>
<td>
<p><code class="reqn">d \times npc</code> matrix of estimated eigenfunctions of the functional
covariance, i.e., the FPC basis functions.</p>
</td></tr> <tr><td><code>evalues</code></td>
<td>
<p>estimated
eigenvalues of the covariance operator, i.e., variances of FPC scores.</p>
</td></tr>
<tr><td><code>npc</code></td>
<td>
<p>number of FPCs: either the supplied <code>npc</code>, or the minimum
number of basis functions needed to explain proportion <code>pve</code> of the
variance in the observed curves.</p>
</td></tr> <tr><td><code>argvals</code></td>
<td>
<p>argument values of
eigenfunction evaluations</p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>estimated measurement error
variance.</p>
</td></tr> <tr><td><code>diag.var</code></td>
<td>
<p>diagonal elements of the covariance matrices for
each estimated curve.</p>
</td></tr> <tr><td><code>VarMats</code></td>
<td>
<p>a list containing the estimated
covariance matrices for each curve in <code>Y</code>.</p>
</td></tr> <tr><td><code>crit.val</code></td>
<td>
<p>estimated
critical values for constructing simultaneous confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Salil Koner <a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Di, C., Crainiceanu, C., Caffo, B., and Punjabi, N. (2009).
Multilevel functional principal component analysis. <em>Annals of Applied
Statistics</em>, 3, 458&ndash;488.
</p>
<p>Goldsmith, J., Greven, S., and Crainiceanu, C. (2013). Corrected confidence
bands for functional data using principal components. <em>Biometrics</em>,
69(1), 41&ndash;51.
</p>
<p>Staniswalis, J. G., and Lee, J. J. (1998). Nonparametric regression
analysis of longitudinal data. <em>Journal of the American Statistical
Association</em>, 93, 1403&ndash;1418.
</p>
<p>Yao, F., Mueller, H.-G., and Wang, J.-L. (2005). Functional data analysis
for sparse longitudinal data. <em>Journal of the American Statistical
Association</em>, 100, 577&ndash;590.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(rlang::is_installed("refund")){
  library(refund)
  data(cd4)
  Fit.MM = fpca_sc(refund::cd4, pve = 0.95)
}

# input a data frame instead of a matrix
nid &lt;- 20
nobs &lt;- sample(10:20, nid, rep=TRUE)
ydata &lt;- data.frame(
    .id = rep(1:nid, nobs),
    .index = round(runif(sum(nobs), 0, 1), 3))
ydata$.value &lt;- unlist(tapply(ydata$.index,
                              ydata$.id,
                              function(x)
                                  runif(1, -.5, .5) +
                                  dbeta(x, runif(1, 6, 8), runif(1, 3, 5))
                              )
                       )

Fit.MM = fpca_sc(ydata=ydata)


</code></pre>

<hr>
<h2 id='PASS_Proj_Test_ufDA'>Power and Sample size (PASS) calculation of
Two-Sample Projection-based test for sparsely observed univariate functional data.</h2><span id='topic+PASS_Proj_Test_ufDA'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The function <code>PASS_Proj_Test_ufDA()</code> computes the power and sample size (PASS) required to conduct
the projection-based test of mean function between two groups of longitudinal data
or sparsely observed functional data under a random irregular design, under
common covariance structure between the groups. See Wang (2021) for more details
of the testing procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PASS_Proj_Test_ufDA(
  sample_size,
  target.power,
  sig.level = 0.05,
  nobs_per_subj,
  obs.design,
  mean_diff_fnm,
  cov.type = c("ST", "NS"),
  cov.par,
  sigma2.e,
  missing_type = c("nomiss", "constant"),
  missing_percent = 0,
  eval_SS = 5000,
  alloc.ratio = c(1, 1),
  fpca_method = c("fpca.sc", "face"),
  mean_diff_add_args = list(),
  fpca_optns = list(pve = 0.95),
  nWgrid = 201,
  npc_to_use = NULL,
  return.eigencomp = FALSE,
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_sample_size">sample_size</code></td>
<td>
<p>Total sample size combining both the groups, must be a positive integer.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_target.power">target.power</code></td>
<td>
<p>Target power to achieve, must be a number between 0 and 1.
Only one of <code>sample_size</code> and <code>target.power</code> should be non-null. The
function will return sample size if <code>sample_size</code> is NULL, and
return power if <code>target.power</code> is NULL.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level of the test, default set at 0.05, must be less than 0.2.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_nobs_per_subj">nobs_per_subj</code></td>
<td>
<p>The number of observations per subject. Each element of it must be greater than 3.
It could also be a vector to indicate that the number of observation for each is randomly varying
between the elements of the vector, or a scalar to ensure that the number of observations are same
for each subject. See examples.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_obs.design">obs.design</code></td>
<td>
<p>The sampling design of the observations. Must be provided as
a list with the following elements. If the design is longitudinal (e.g. a clinical trial
where there is pre-specified schedule of visit for the participants) it must be
a named list with elements <code>design</code>, <code>visit.schedule</code> and <code>visit.window</code>, where
<code>obs.design$design</code> must be specified as <code>'longitudinal'</code>, <code>visit.schedule</code>
specifying schedule of visits (in months or days or any unit of time), other than the baseline visit
and <code>visit.window</code> denoting the maximum time window for every visit.
For functional design (where the observation points are either densely observed within a
compact interval or under a sparse random design), the argument must be provided
as a named list with elements <code>design</code> and <code>fun.domain</code>, where
<code>obs.design$design</code> must be specified as <code>'functional'</code> and <code>obs.design$fun.domain</code>
must be specified as a two length vector indicating the domain of the function.
See Details on the specification of arguments section below more details.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_mean_diff_fnm">mean_diff_fnm</code></td>
<td>
<p>The name of the function that output of the difference of the mean between the
two groups at any given time. It must be supplied as character, so that <code>match.fun(mean_diff_fnm)</code>
returns a valid function, that takes a vector input, and returns a vector of the same length of the input.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_cov.type">cov.type</code></td>
<td>
<p>The type of the covariance structure of the data, must be either of 'ST' (stationary) or
'NS' (non-stationary). This argument along with the <code>cov.par</code> argument must be
specified compatibly to ensure that the function does not return an error. See the details
of <code>cov.par</code> argument.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_cov.par">cov.par</code></td>
<td>
<p>The covariance structure of the latent response trajectory.
If <code>cov.type == 'ST'</code> then, <code>cov.par</code>
must be specified a named list of two elements, <code>var</code> and <code>cor</code>,
where <code>var</code> is the common variance of the observations, which must be a
positive number; and <code>cor</code> specifies the correlation structure between
the observations. <code>cov.par$cor</code> must be specified in the form of the
<a href="nlme.html#topic+corClasses">nlme::corClasses</a> specified in R package <span class="pkg">nlme</span>.
Check the package documentation for more details for each of the correlation classes.
The <code>cov.par$cor</code> must be a <code>corStruct</code> class so it can be
passed onto the <code><a href="nlme.html#topic+corMatrix">nlme::corMatrix()</a></code> to extract the subject-specific covariance matrix.
If <code>cov.type='NS'</code> then, <code>cov.par</code>
must be a named list of two elements, <code>cov.obj</code> and <code>eigen.comp</code>,
where only one of the <code>cov.par$cov.obj</code> or <code>cov.par$eigen.comp</code>
must be non-null. This is to specify that the covariance structure of the
latent trajectory can be either provided in the form of covariance function or
in the form of eigenfunction and eigenvalues (Spectral decomposition).
If the <code>cov.par$cov.obj</code> is specified, then it must be a bivariate function,
with two arguments. Alternatively, if the true eigenfunctions  are known,
then the user can specify that by specifying <code>cov.par$eigen.comp</code>.
In this case, the <code>cov.par$eigen.comp</code> must be a named list with two elements,
<code>eig.obj</code> and <code>eig.val</code>, where <code>cov.par$eigen.comp$eig.val</code>
must be positive vector and <code>cov.par$eigen.comp$eig.obj</code>
must be a vectorized function so that its evaluation at a vector of time points
returns a matrix of dimension r by <code>length(cov.par$eigen.comp$eig.val)</code>,
with r being the length of time points.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_sigma2.e">sigma2.e</code></td>
<td>
<p>Measurement error variance, should be set as zero or a very small number
if the measurement error is not significant.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_missing_type">missing_type</code></td>
<td>
<p>The type of missing in the number of observations of the subjects. Can be one of
<code>'nomiss'</code> for no missing observations
or <code>'constant'</code> for constant
missing percentage at every time point. The current version of package only supports
<code>missing_type = 'constant'</code>.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_missing_percent">missing_percent</code></td>
<td>
<p>The percentage of missing at each observation points for each subject.
Must be supplied as number between [0, 0.8], as missing percentage more than 80% is not practical.
If <code>nobs_per_subj</code> is supplied as vector, then <code>missing_type</code>
is forced to set as <code>'nomiss'</code> and <code>missing_percent = 0</code>, because
the <code>missing_type = 'constant'</code> has no meaning if the number of observations are
varying between the subject at the first, typically considered in
the case of sparse random functional design.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_eval_ss">eval_SS</code></td>
<td>
<p>The sample size based on which the eigencomponents will be estimated from data.
To compute the theoretical power of the test we must make sure that we use a large enough sample size
to generate the data such that the estimated eigenfunctions are very close to the true eigenfunctions
and that the sampling design will not have much effect on the loss of precision. Default value 5000.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_alloc.ratio">alloc.ratio</code></td>
<td>
<p>The allocation ratio of samples in the each group. Note that the eigenfunctions
will still be estimated based on the total sample_size, however, the variance
of the <code>shrinkage</code> scores (which is required to compute the power function) will be
estimated based on the allocation of the samples in each group. Must be given as vector of
length 2. Default value is set at <code>c(1, 1)</code>, indicating equal sample size.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_fpca_method">fpca_method</code></td>
<td>
<p>The method by which the FPCA is computed. Must be one of
'fpca.sc' and 'face'. If <code>fpca_method == 'fpca.sc'</code> then the eigencomponents
are estimated using the function <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>. However, since the <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>
function fails to estimate the correct <code>shrinkage</code> scores, and throws <code>NA</code> values
when the measurement errors is estimated to be zero, we wrote out a similar function
where we corrected those error in current version of <code><a href="refund.html#topic+fpca.sc">refund::fpca.sc()</a></code>. Check out
the <code><a href="#topic+fpca_sc">fpca_sc()</a></code> function for details. If <code>fpca_method == 'face'</code>, then
the eigencomponents are estimated using <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code> function.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_mean_diff_add_args">mean_diff_add_args</code></td>
<td>
<p>Additional arguments to be passed to group difference
function specified in the argument <code>mean_diff_fnm</code>.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_fpca_optns">fpca_optns</code></td>
<td>
<p>Additional options to be passed onto either of <code><a href="#topic+fpca_sc">fpca_sc()</a></code>
or <code><a href="face.html#topic+face.sparse">face::face.sparse()</a></code> function in order
to estimate the eigencomponents. It must be a named list with elements
to be passed onto the respective function, depending on the <code>fpca_method</code>.
The names of the list must not match either of
<code>c('data', 'newdata', 'argvals.new')</code>
for <code>fpca_method == 'face'</code> and must not match either of
<code>c('ydata', 'Y.pred')</code> for  <code>fpca_method == 'fpca.sc'</code>.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_nwgrid">nWgrid</code></td>
<td>
<p>The length of the working grid based in the domain of the function on which
the eigenfunctions will be estimated. The actual working grid will be calculated using
the <code><a href="gss.html#topic+gauss.quad">gss::gauss.quad()</a></code> function (so that it facilitates the numerical integration of
the eigenfunction with the mean function using gaussian quadrature rule)</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_npc_to_use">npc_to_use</code></td>
<td>
<p>Number of eigenfunctions to use to compute the power. Default is NULL, in
which case all the eigenfunctions estimated from the data will be used.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_return.eigencomp">return.eigencomp</code></td>
<td>
<p>Indicates whether to return the eigencomponents obtained from the fPCA
on the large data with sample size equal to <code>eval_SS</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="PASS_Proj_Test_ufDA_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to be generated from the alternate distribution of
Hotelling T statistic. Default value is 10000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is designed to perform the power and sample size analysis
for functional under a dense and sparse (random) design and longitudinal data. The
function can handle data from wide variety of covariance structure, can be parametric,
or non-parametric. Additional with traditional stationary structures assumed for longitudinal
data (see <a href="nlme.html#topic+corClasses">nlme::corClasses</a>), the user can specify any other non-stationary covariance
function in the form of either a covariance function or in terms of eigenfunctions and
eigenvalues. The user have a lot of flexibility into tweaking the arguments of the function
to assess the power function of the test under different sampling design and covariance process
of the response trajectory, and for any arbitrary mean difference function. Overall, the
functionality of the module is quite comprehensive and includes all the different cases
considered in the 'NCSS PASS (2023)' software. We believe that this software can be an effective
clinical trial design tools when considering the projection-based test as the primary
decision making method.
</p>


<h3>Value</h3>

<p>A list with following elements, <code>power_value</code> if <code>is.null(target.power)</code>
then returns the power of the test when n equal to <code>sample_size</code>, otherwise <code>required_SS</code>,
the sample size required to achieve the power of the test at <code>target.power</code>.
If <code>return.eigencomp == TRUE</code> then <code>est_eigencomp</code> is also returned, containing
the entire output obtained from internal call of <code><a href="#topic+Extract_Eigencomp_fDA">Extract_Eigencomp_fDA()</a></code>.
</p>


<h3>Specification of key arguments</h3>

<p>If <code>obs.design$design == 'functional'</code> then a dense grid of length,
specified by ngrid (typically 101/201) is internally created, and
the observation points will be randomly chosen from them.
The time points could also randomly chosen between
any number between the interval, but then for large number of subject,
<code><a href="#topic+fpca_sc">fpca_sc()</a></code> function will take huge
time to estimate the eigenfunction. For dense design, the user must set
a large value of the argument <code>nobs_per_subj</code> and for sparse (random) design,
<code>nobs_per_subj</code> should be set small (and varying).
On the other hand, typical to longitudinal data, if the measurements are
taken at fixed time points (from baseline)
for each subject, then the user must set <code>obs.design$design == 'longitudinal'</code> and
the time points must be accordingly specified
in the argument <code>obs.design$visit.schedule</code>. The length of <code>obs.design$visit.schedule</code>
must match <code>length(nobs_per_subj)-1</code>. Internally, when
<code>obs.design$design == 'longitudinal'</code>, the function scale the visit times
so that it lies between [0, 1], so the user should not
specify any element named <code>fun.domain</code> in the
list for <code>obs.design$design == 'longitudinal'</code>. Make sure that
the mean function and the covariance function specified
in the <code>cov.par</code> and <code>mean_diff_fnm</code> parameter also scaled to
take argument between [0, 1]. Also, it is imperative to say that <code>nobs_per_subj</code> must
be of a scalar positive integer for <code>design == 'longitudinal'</code>.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br /> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Wang, Qiyao (2021)
<em>Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423</em>
<a href="https://doi.org/10.1214/21-EJS1802">doi:10.1214/21-EJS1802</a>. <br /> <br />
PASS 2023 Power Analysis and Sample Size Software (2023). NCSS, LLC. Kaysville, Utah, USA, ncss.com/software/pass.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+Power_Proj_Test_ufDA">Power_Proj_Test_ufDA()</a></code> and <code><a href="#topic+Extract_Eigencomp_fDA">Extract_Eigencomp_fDA()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Power analysis for stationary exponential covariance.
# Should return a power same as the size because
# the true mean difference is zero.

set.seed(12345)
mean.diff &lt;- function(t) {0*t};
obs.design = list("design" = "longitudinal",
                  "visit.schedule" = seq(0.1, 0.9, length.out=7),
                   "visit.window" = 0.05)
cor.str &lt;- nlme::corExp(1, form = ~ time | Subject);
sigma2 &lt;- 1; sigma2.e &lt;- 0.25; nobs_per_subj &lt;- 8;
missing_type &lt;- "constant"; missing_percent &lt;- 0.01;
# Please increase `eval_SS` argument from 1000 to 5000 to get
# accurate precision on the estimated eigenfunctions.
pow  &lt;- PASS_Proj_Test_ufDA(sample_size = 100, target.power = NULL, sig.level = 0.05,
                            obs.design = obs.design,
                            mean_diff_fnm = "mean.diff", cov.type = "ST",
                            cov.par = list("var" = sigma2, "cor" = cor.str),
                            sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
                            missing_type = missing_type,
                            missing_percent = missing_percent, eval_SS = 1000,
                            alloc.ratio = c(1,1), nWgrid = 201,
                            fpca_method = "fpca.sc",
                            mean_diff_add_args = list(), fpca_optns = list("pve" = 0.95),
                            nsim = 1e3)

print(pow$power_value)

# Example 2: Sample size calculation for a non-stationary covariance:

alloc.ratio  &lt;- c(1,1)
mean.diff    &lt;- function(t) {3 * (t^3)};
eig.fun &lt;- function(t, k) {
  if (k==1) ef &lt;- sqrt(2)*sin(2*pi*t)
  else if (k==2) ef &lt;- sqrt(2)*cos(2*pi*t)
  return(ef)}
eig.fun.vec  &lt;- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))}
eigen.comp   &lt;- list("eig.val" = c(1, 0.5), "eig.obj" = eig.fun.vec)
obs.design   &lt;- list(design = "functional", fun.domain = c(0,1))
cov.par      &lt;- list("cov.obj" = NULL, "eigen.comp" = eigen.comp)
sigma2.e     &lt;- 0.001; nobs_per_subj &lt;- 4:7;
missing_type &lt;- "nomiss"; missing_percent &lt;- 0;
fpca_method  &lt;- "fpca.sc"
# Please increase `eval_SS` argument from 1000 to 5000 to get
# accurate precision on the estimated eigenfunctions.
pow  &lt;- PASS_Proj_Test_ufDA(sample_size = NULL, target.power = 0.8,
                            sig.level = 0.05, obs.design = obs.design,
                            mean_diff_fnm = "mean.diff", cov.type = "NS",
                            cov.par = cov.par, sigma2.e = sigma2.e,
                            nobs_per_subj = nobs_per_subj, missing_type = missing_type,
                            missing_percent = missing_percent, eval_SS = 1000,
                            alloc.ratio = alloc.ratio, fpca_method = "fpca.sc",
                            mean_diff_add_args = list(), fpca_optns = list(pve = 0.95),
                            nsim = 1e3, nWgrid = 201)

print(pow$required_SS)

</code></pre>

<hr>
<h2 id='pHotellingT'>CDF of Hotelling-<code class="reqn">T^2</code> statistic.</h2><span id='topic+pHotellingT'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The function <code>pHotellingT()</code> computes the cumulative distribution function (CDF)
of the two-sample Hotelling-<code class="reqn">T^2</code> statistic (<code class="reqn">P(T &gt; q)</code>) in the multivariate response
setting. This function is used to compute the power function
of Two-Sample (TS) Projection-based test (Wang 2021, EJS.)
for sparsely observed univariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pHotellingT(
  q,
  total_sample_size,
  mean_diff,
  sig1,
  sig2,
  alloc.ratio = c(1, 1),
  lower.tail = TRUE,
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pHotellingT_+3A_q">q</code></td>
<td>
<p>The point at which the CDF needs to be evaluated</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_total_sample_size">total_sample_size</code></td>
<td>
<p>Target sample size, must be a positive integer.</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_mean_diff">mean_diff</code></td>
<td>
<p>The difference in the mean vector between the two groups, must be a vector.</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_sig1">sig1</code></td>
<td>
<p>The true (or estimate) of covariance matrix for the first group. Must be symmetric
(<code>is.symmetric(sig1) == TRUE</code>) and positive definite (<code>chol(sig1)</code> without an error!).</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_sig2">sig2</code></td>
<td>
<p>The true (or estimate) of covariance matrix for the second group. Must be symmetric
(<code>is.symmetric(sig2) == TRUE</code>) and positive definite (<code>chol(sig2)</code> without an error!).</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_alloc.ratio">alloc.ratio</code></td>
<td>
<p>Allocation of total sample size into the two groups. Must set as a vector of two
positive numbers. For equal allocation it should be put as c(1,1), for non-equal
allocation one can put c(2,1) or c(3,1) etc.</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_lower.tail">lower.tail</code></td>
<td>
<p>if TRUE, the CDF is returned, otherwise right tail probability is returned.</p>
</td></tr>
<tr><td><code id="pHotellingT_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to be generated from the alternate distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the assumption of the equal variance, we know that the alternative
distribution of the Hotelling-<code class="reqn">T^2</code> statistic (<code class="reqn">(n-k-1)T/(n-2)*K</code>) has an
F distribution with the
non-centrality depending on the difference between the true mean vectors and the
(common) covariance of the response. However, when the true covariance of the true groups
of responses differ, the alternate distribution becomes non-trivial. Koner and Luo (2023)
proved that the alternate distribution of the test-statistic approximately follows
a ratio of the linear combination of the K (dimension of the response) non-central
chi-squared random variables (where the non-centrality parameter depends on the mean difference)
and a chi-squared distribution whose degrees of freedom depends on a complicated functions of
sample size in the two groups. This function initially calls the
<a href="#topic+Sim_HotellingT_unequal_var">Sim_HotellingT_unequal_var</a> function to obtain the samples from the non-null distribution
and computes the CDF numerically with high precision based on a large number of samples.
See Koner and Luo (2023) for more details on the formula of the non-null distribution.
</p>


<h3>Value</h3>

<p>The CDF of the Hotelling T statistic, if <code>lower.tail == TRUE</code>,
otherwise the right tail probability is returned.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br /> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="Hotelling.html#topic+hotelling.test">Hotelling::hotelling.test()</a></code>, <code><a href="Hotelling.html#topic+hotelling.stat">Hotelling::hotelling.stat()</a></code> to generate empirical samples
from the Hotelling T-statistic from empirical data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
B           &lt;- 10000
k           &lt;- 4
n2          &lt;- 60
n1_by_n2    &lt;- 2
n1          &lt;- n1_by_n2 * n2
mu1         &lt;- rep(0,k)
del         &lt;- 0.4
mu2         &lt;- mu1 + rep(del, k) # rep(0.19,k)  # 0.23 (0.9), 0.18 (0.7) 0.20 (0.8)
sig1        &lt;- diag(k)
sig2        &lt;- sig1
cutoff      &lt;- seq(0,30, length.out=20)
the_cdf     &lt;- round(pHotellingT(cutoff, n1+n2, mu1 - mu2,
                                 sig1, sig2, alloc.ratio=c(2,1),
                                 lower.tail=FALSE, nsim = 1e4),3)

</code></pre>

<hr>
<h2 id='Power_Proj_Test_ufDA'>Power of the Two-sample Projection-based test for functional data with known (or estimated)
eigencomponents.</h2><span id='topic+Power_Proj_Test_ufDA'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The function <code>Power_Proj_Test_ufDA()</code> computes the power of
of the two-sample projection-based test for functional response data
setting, when the group difference, the eigenfunctions of the covariance
of the data are specified at dense grid of time points, along with the
(estimated) covariance of the <code>shrinkage</code> scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Power_Proj_Test_ufDA(
  total_sample_size,
  argvals,
  mean_vector,
  eigen_matrix,
  scores_var1,
  scores_var2,
  weights,
  sig.level = 0.05,
  alloc.ratio = c(1, 1),
  npc_to_pick = ncol(eigen_matrix),
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_total_sample_size">total_sample_size</code></td>
<td>
<p>Total sample size combing the two groups, must be a positive integer.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_argvals">argvals</code></td>
<td>
<p>The working grid of timepoints to evaluate the eigenfunctions and the mean functions.
It is preferred to take the working grid as dense grid so that
<code class="reqn">\int [\mu_1(t) - \mu_2(t)]\phi_k(t) \,dt</code> can be calculated with a required precision.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_mean_vector">mean_vector</code></td>
<td>
<p>The difference in the mean function evaluated at argvals, must be a numeric vector of length same
as that that of argavls.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_eigen_matrix">eigen_matrix</code></td>
<td>
<p>The matrix of eigenfunctions evaluated at argvals,
must be a length(argvals) by K matrix, where K is the number of eigenfunctions.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_scores_var1">scores_var1</code></td>
<td>
<p>The true (or estimate) of covariance matrix of the shrinkage scores for the first group.
Must be symmetric (<code>is.symmetric(scores_var1) == TRUE</code>) and positive definite
(<code>chol(scores_var1)</code> without an error!).</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_scores_var2">scores_var2</code></td>
<td>
<p>The true (or estimate) of covariance matrix of the shrinkage scores for the second group.
Must be symmetric (<code>is.symmetric(scores_var2) == TRUE</code>) and positive definite
(<code>chol(scores_var2)</code> without an error!).</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_weights">weights</code></td>
<td>
<p>The weights to put to compute the projection <code class="reqn">\int [\mu_1(t) - \mu_2(t)]\phi_k(t) \,dt</code>,
for each <code class="reqn">k=1,\dots, K</code>. The integral is numerically approximated as
<code>sum(mean_diff(argvals)*eigen_matrix[,k]*weights)</code>.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level of the test, default set at 0.05, must be less than 0.2.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_alloc.ratio">alloc.ratio</code></td>
<td>
<p>The allocation ratio of samples in the each group. Note that the eigenfunctions
will still be estimated based on the total sample_size, however, the variance
of the <code>shrinkage</code> scores (which is required to compute the power function) will be
estimated based on the allocation of the samples in each group. Must be given as vector of
length 2. Default value is set at <code>c(1, 1)</code>, indicating equal sample size.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_npc_to_pick">npc_to_pick</code></td>
<td>
<p>Number of eigenfunction to be used to compute the power. Typically this is
becomes handy when the user want to discard few of the last eigenfunctions,
typically with a very small eigenvalues.</p>
</td></tr>
<tr><td><code id="Power_Proj_Test_ufDA_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to be generated from the alternate distribution of
Hotelling T statistic. Default value is 10000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The projection-based test first extracts K eigenfunctions from the data, and then
project the mean difference function onto each of the eigenfunctions to obtain a K-dimensional
projection vector that reflects the group difference. Wang (2021) pointed that under the null
hypothesis the covariance of K-dimensional functional principal component analysis (fPCA) scores
are the same, and thus a Hotelling <code class="reqn">T^2</code> test with assuming equal variance of the shrinkage scores
is a valid test. However, Koner and Luo (2023) pointed out that under the alternate hypothesis,
when the difference is mean is significant, the covariance of the shrinkage scores also differ
between the groups. Therefore, while computing the power of test, we must have to derive the
distribution of the Hotelling <code class="reqn">T^2</code> statistic under the assumption of unequal variance. The
alogrithm for the power of multivariate Hotelling <code class="reqn">T^2</code> under unequal variance
is coded in <code><a href="#topic+pHotellingT">pHotellingT()</a></code> function. This particular function is a wrapper around that
function, which inputs the mean difference as a function, and the eigenfunctions and
the scores, and subsequently call the <code><a href="#topic+pHotellingT">pHotellingT()</a></code> function to compute the power
under unequal variance. See Koner and Luo (2023) for more details on the
formula of the non-null distribution.
</p>


<h3>Value</h3>

<p>Power of the projection-based test for specified difference in the mean function
and the eigencomponents of the covariance of the functional data.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br /> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Wang, Qiyao (2021)
<em>Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423</em> <br />
<a href="https://doi.org/10.1214/21-EJS1802">doi:10.1214/21-EJS1802</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+pHotellingT">pHotellingT()</a></code> and <code><a href="#topic+Sim_HotellingT_unequal_var">Sim_HotellingT_unequal_var()</a></code> for samples
from Hotelling T distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ngrid          &lt;- 101
interval       &lt;- c(-1,1)
gauss.quad.pts &lt;- gss::gauss.quad(ngrid,interval) # evaluation points
working.grid   &lt;- gauss.quad.pts$pt
mean_fn        &lt;- function(t) {0.4*sin(2*pi*t)}
mean_vector    &lt;- mean_fn(working.grid)
eigen_fn       &lt;- function(t, k){ sqrt(2)*{(k==2)*sin(2*pi*t) + (k==1)*cos(2*pi*t)} }
eigen_matrix   &lt;- cbind(eigen_fn(working.grid,1), eigen_fn(working.grid,2))
mean_proj      &lt;- sapply(1:2, function(r) integrate(function(x)
eigen_fn(x,r)*mean_fn(x), interval[1], interval[2])$value)
sig1           &lt;- diag(2)
sig2           &lt;- 2*diag(2)
alp            &lt;- 0.05
n              &lt;- 100
k              &lt;- ncol(eigen_matrix)
cutoff         &lt;- {(n - 2)*k/(n - k -1)}*qf(1-alp, k, n-k-1)
func_power     &lt;- Power_Proj_Test_ufDA(total_sample_size=n,
argvals=working.grid,
mean_vector = mean_vector, eigen_matrix = eigen_matrix,
scores_var1 = sig1, scores_var2= sig2, weights = gauss.quad.pts$wt,
sig.level=alp, alloc.ratio = c(1,1), npc_to_pick=ncol(eigen_matrix),
nsim = 5e3)

</code></pre>

<hr>
<h2 id='Sim_HotellingT_unequal_var'>Samples from the non-null distribution of the Hotelling-<code class="reqn">T^2</code> statistic under unequal covariance.</h2><span id='topic+Sim_HotellingT_unequal_var'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The function <code>Sim_HotellingT_unequal_var()</code> generates samples from the
(non-null) distribution of the two-sample Hotelling-<code class="reqn">T^2</code> statistic
under the assuming of unequal covariance of the multivariate response
between the two groups. This function is used to compute the power function
of Two-Sample (TS) Projection-based test (Wang 2021, EJS.)
for sparsely observed univariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sim_HotellingT_unequal_var(
  total_sample_size,
  mean_diff,
  sig1,
  sig2,
  alloc.ratio = c(1, 1),
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sim_HotellingT_unequal_var_+3A_total_sample_size">total_sample_size</code></td>
<td>
<p>Target sample size, must be a positive integer.</p>
</td></tr>
<tr><td><code id="Sim_HotellingT_unequal_var_+3A_mean_diff">mean_diff</code></td>
<td>
<p>The difference in the mean vector between the two groups, must be a vector.</p>
</td></tr>
<tr><td><code id="Sim_HotellingT_unequal_var_+3A_sig1">sig1</code></td>
<td>
<p>The true (or estimate) of covariance matrix for the first group. Must be symmetric
(<code>is.symmetric(sig1) == TRUE</code>) and positive definite (<code>chol(sig1)</code> without an error!).</p>
</td></tr>
<tr><td><code id="Sim_HotellingT_unequal_var_+3A_sig2">sig2</code></td>
<td>
<p>The true (or estimate) of covariance matrix for the second group. Must be symmetric
(<code>is.symmetric(sig2) == TRUE</code>) and positive definite (<code>chol(sig2)</code> without an error!).</p>
</td></tr>
<tr><td><code id="Sim_HotellingT_unequal_var_+3A_alloc.ratio">alloc.ratio</code></td>
<td>
<p>Allocation of total sample size into the two groups. Must set as a vector of two
positive numbers. For equal allocation it should be put as c(1,1), for non-equal
allocation one can put c(2,1) or c(3,1) etc.</p>
</td></tr>
<tr><td><code id="Sim_HotellingT_unequal_var_+3A_nsim">nsim</code></td>
<td>
<p>The number of samples to be generated from the alternate distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the assumption of the equal variance, we know that the alternative
distribution of the Hotelling-<code class="reqn">T^2</code> statistic has an F distribution with the
non-centrality depending on the difference between the true mean vectors and the
(common) covariance of the response. However, when the true covariance of the true groups
of responses differ, the alternate distribution becomes non-trivial. Koner and Luo (2023)
proved that the alternate distribution of the test-statistic approximately follows
a ratio of the linear combination of the K (dimension of the response) non-central
chi-squared random variables (where the non-centrality parameter depends on the mean difference)
and a chi-squared distribution whose degrees of freedom depends on a complicated functions of
sample size in the two groups.
See Koner and Luo (2023) for more details on the formula of the non-null distribution.
</p>


<h3>Value</h3>

<p>A named list with two elements.
</p>

<ol>
<li> <p><code>samples</code> - a vector of length <code>nsim</code>, containing
The samples from the distribution of the Hotelling T statistic
under unequal variance.
</p>
</li>
<li> <p><code>denom.df</code> - The denominator degrees of freedom of the chi-square statistic
obtained by approximation of the sum of two Wishart distribution under unequal variance.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Salil Koner <br /> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Wang, Qiyao (2021)
<em>Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423</em> <br />
<a href="https://doi.org/10.1214/21-EJS1802">doi:10.1214/21-EJS1802</a>.
</p>


<h3>See Also</h3>

<p><code><a href="Hotelling.html#topic+hotelling.test">Hotelling::hotelling.test()</a></code>, <code><a href="Hotelling.html#topic+hotelling.stat">Hotelling::hotelling.stat()</a></code> to generate empirical samples
from the Hotelling T-statistic from empirical data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Case 1: Null hypothesis is true. True mean difference is zero, and the true
# covariance of the two groups are same.
k &lt;- 5
mu1  &lt;- rep(0,k); del  &lt;- 0; mu2 &lt;- mu1 + rep(del, k);
sig1 &lt;- diag(k); sig2 &lt;- sig1 + del*toeplitz(c(1,rep(0.5, k-1))); n &lt;- 200;
null.dist.samples &lt;- Sim_HotellingT_unequal_var(total_sample_size=n, mean_diff=mu1-mu2,
                     sig1=sig1, sig2=sig2, alloc.ratio=c(1,1), nsim=1e3)
# The following Kolmogorov Smirnov test confirms that under null hypothesis
# and when the covariances are same, the distribution is exactly a
# central F distribution with \eqn{k} and \eqn{n-k}  degrees of freedom.
ks.test(null.dist.samples$samples, {{(n - 2) * k}/(n - k -1)} * {rf(n=1e3, k, n-k-1)} )


# Case 2: Alternate hypothesis is true. The mean difference is non-zero,
# and the covariances of the two groups are same:
k &lt;- 6
mu1  &lt;- rep(0,k); del  &lt;- 0.15; mu2 &lt;- mu1 + rep(del, k);
sig1 &lt;- diag(k); sig2 &lt;- sig1;
n1 &lt;- 100; n2 &lt;- 100;
alt.dist.samples &lt;- Sim_HotellingT_unequal_var(total_sample_size=n1+n2, mean_diff=mu1-mu2,
                                               sig1=sig1, sig2=sig2, alloc.ratio=c(1,1), nsim=1e3)
ks.test(alt.dist.samples$samples,
        {(n1+n2 - 2) * k /(n1+n2 - k -1)}*rf(n=1e3, k, n1+n2-k-1,
          ncp = {(n1*n2)/(n1+n2)}*as.vector(crossprod(mu1-mu2, solve(sig1, mu1-mu2))) ) )


# Case 3: Alternate hypothesis is true. The mean difference is non-zero,
# and the covariances of the two groups are different
k &lt;- 5
mu1  &lt;- rep(0,k); del  &lt;- 0.25; mu2 &lt;- mu1 + rep(del, k);
sig1 &lt;- diag(k); sig2 &lt;- sig1 + del*toeplitz(c(1,rep(0.5, k-1)))
alt.dist.samples &lt;- Sim_HotellingT_unequal_var(total_sample_size=200, mean_diff=mu1-mu2,
sig1=sig1, sig2=sig2, alloc.ratio=c(1,1), nsim=1e3)

# Generate samples with unequal allocation ratio:
k &lt;- 8
mu1  &lt;- rep(0,k); del  &lt;- 0.4; mu2 &lt;- mu1 + rep(del, k);
sig1 &lt;- diag(k); sig2 &lt;- sig1 + del*toeplitz(c(1,rep(0.5, k-1)))
alt.dist.samples &lt;- Sim_HotellingT_unequal_var(total_sample_size=150, mean_diff=mu1-mu2,
sig1=sig1, sig2=sig2, alloc.ratio=c(2,1), nsim=1e3)

</code></pre>

<hr>
<h2 id='Sum_of_Wishart_df'>The approximate degrees of freedom formula for sum of Wishart.</h2><span id='topic+Sum_of_Wishart_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The approximate degrees of freedom formula for sum of two
independent Wishart random variable
with parameter sig1 and sig2, and degrees of freedom n1-1 and n2-1
where n1 + n2 is equal to the <code>total_sample_size</code>.
</p>
<p>See Koner and Luo (2023) for more details on the formula for degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sum_of_Wishart_df(total_sample_size, alloc.ratio, sig1, sig2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sum_of_Wishart_df_+3A_total_sample_size">total_sample_size</code></td>
<td>
<p>Target sample size, must be a positive integer.</p>
</td></tr>
<tr><td><code id="Sum_of_Wishart_df_+3A_alloc.ratio">alloc.ratio</code></td>
<td>
<p>Allocation of total sample size into the two groups. Must set as a vector of two
positive numbers. For equal allocation it should be put as c(1,1), for non-equal
allocation one can put c(2,1) or c(3,1) etc.</p>
</td></tr>
<tr><td><code id="Sum_of_Wishart_df_+3A_sig1">sig1</code></td>
<td>
<p>The true (or estimate) of covariance matrix for the first group. Must be symmetric
(<code>is.symmetric(sig1) == TRUE</code>) and positive definite (<code>chol(sig1)</code> without an error!).</p>
</td></tr>
<tr><td><code id="Sum_of_Wishart_df_+3A_sig2">sig2</code></td>
<td>
<p>The true (or estimate) of covariance matrix for the second group. Must be symmetric
(<code>is.symmetric(sig2) == TRUE</code>) and positive definite (<code>chol(sig2)</code> without an error!).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximate degrees of freedom.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br /> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sim_HotellingT_unequal_var">Sim_HotellingT_unequal_var()</a></code> and <code><a href="#topic+pHotellingT">pHotellingT()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k &lt;- 8
mu1  &lt;- rep(0,k); del  &lt;- 0.4; mu2 &lt;- mu1 + rep(del, k);
sig1 &lt;- diag(k); sig2 &lt;- sig1 + del*toeplitz(c(1,rep(0.5, k-1)))
alt.dist.samples &lt;- Sum_of_Wishart_df(total_sample_size=150,
sig1=sig1, sig2=sig2, alloc.ratio=c(2,1))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
