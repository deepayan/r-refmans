<!DOCTYPE html><html lang="en"><head><title>Help for package Biodem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Biodem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#col.sto'><p>Turns a Migration Matrix into a Column Stochastic Matrix</p></a></li>
<li><a href='#Fst'><p> Calculates the Fst from the conditional kinship matrix</p></a></li>
<li><a href='#hedrick'><p> Calculates the Hedrick standardized kinship coefficient</p></a></li>
<li><a href='#lasker'><p> Calculates the lasker kinship coeffcient</p></a></li>
<li><a href='#mal.cond'><p> Calculates a Conditional Kinship matrix</p></a></li>
<li><a href='#mal.eq'><p> Calculates the asymptotic generation for the Malecot model</p></a></li>
<li><a href='#mal.phi'><p> Calculates a kinship matrix using the Malecot Migration Model</p></a></li>
<li><a href='#mar.iso'><p> Observed and Random Marital Isonymy</p></a></li>
<li><a href='#mtx.exp'><p> Calculates the n-th power of a matrix</p></a></li>
<li><a href='#N'><p> Effective population vector</p></a></li>
<li><a href='#P'><p> Column stochastic migration matrix</p></a></li>
<li><a href='#r.pairs'><p> Observed and Random Repeated Pairs Coefficients</p></a></li>
<li><a href='#raw.mig'><p> A raw migration data</p></a></li>
<li><a href='#rel.cond'><p> Calculates a conditional kinship matrix from isonymy data</p></a></li>
<li><a href='#rel.phi'><p> Calculates an 'a priori' kinship matrix from isonymy data</p></a></li>
<li><a href='#rri'><p> Calculates an unbiased estimate of Regional Random Isonymy</p></a></li>
<li><a href='#S'><p> Systematic pressure matrix</p></a></li>
<li><a href='#sur.freq'><p> Calculates surnames frequency tables</p></a></li>
<li><a href='#sur.inbr'><p> Total, Random and Non-random Inbreeding Coefficients</p></a></li>
<li><a href='#surnames'><p> Surname frequency table</p></a></li>
<li><a href='#sym.P'><p> Calculate the symmetric column stochastic matrix</p></a></li>
<li><a href='#uri'><p> Calculates the Unbiased Random Isonymy matrix</p></a></li>
<li><a href='#valley'><p> Raw marriage data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Biodemography Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessio Boattini and Federico C. F. Calboli; Vincente Canto Cassola together with Martin Maechler authored the function mtx.exp.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Federico Calboli &lt;f.calboli@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Biodem package provides a number of functions for Biodemographic analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-05 08:03:14 UTC; greatsage</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-05 15:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='col.sto'>Turns a Migration Matrix into a Column Stochastic Matrix</h2><span id='topic+col.sto'></span>

<h3>Description</h3>

<p>Calculates the column stochastic matrix starting from the raw migration matrix <code>x</code>. For each column, it divides each term by the column sum. Then it returns the thus &quot;normalized by column&quot; matrix, ready to be used in the Malecot migration model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.sto(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col.sto_+3A_x">x</code></td>
<td>
<p>the raw data migration matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Malecot model uses a transformation of the raw migration data; in the &quot;Malecot&quot; library the use of a column stochastic matrix follows Imaizumi 1970 and Swedlund 1984.
</p>


<h3>Value</h3>

<p>col.sto is used on a an object of class &quot;matrix&quot; and returns an object of class &quot;matrix&quot;.
</p>


<h3>Author(s)</h3>

<p>Federico C. F. Calboli <a href="mailto:f.calboli@gmail.com">f.calboli@gmail.com</a>
</p>


<h3>References</h3>

<p>Imaizumi, Y., N. E. Morton and D. E. Harris. 1970. Isolation by distance in artificial populations. Genetics 66: 569-582.
</p>
<p>Jorde, L. B. 1982. The genetic structure of the Utah mormons: migration analysis. Human Biology 54(3): 583-597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raw.mig)
new.mig.mat&lt;-col.sto(raw.mig)
new.mig.mat

</code></pre>

<hr>
<h2 id='Fst'> Calculates the Fst from the conditional kinship matrix </h2><span id='topic+Fst'></span>

<h3>Description</h3>

<p>Calculates the Fst from a conditional kinship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fst(rval, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fst_+3A_rval">rval</code></td>
<td>
<p> is a conditional kinship matrix, normally obtained by the functions 'R' and 'rel.cond' in the Biodem library. </p>
</td></tr>
<tr><td><code id="Fst_+3A_n">N</code></td>
<td>
<p> the vector of effective populations size, nominally obtained by dividing the total population size by three. Starting form surname data, effective population size coincides with the number of marriages </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of the Fst function follows Harpending and Jenkins 1974, and Jorde 1982. It gives an estimate of Wright's Fst, which is a measure of between-subdivision genetic heterogeneity.
</p>


<h3>Value</h3>

<p>Fst returns one numeric value.
</p>


<h3>Note</h3>

<p> ... </p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli <a href="mailto:f.calboli@gmail.com">f.calboli@gmail.com</a> </p>


<h3>References</h3>

<p> Harpending, H. C. and T. jenkins. 1974. !Kung population structure. In: J. F. Crow and C. F. Denniston (eds.), Genetic distance, pp 137-161. Plenum Press, NY.
</p>
<p>Jorde, L. B. 1982. The genetic structure of the Utah mormons: migration analysis. Human Biology 54(3): 583-597. </p>


<h3>Examples</h3>

<pre><code class='language-R'># Swedlund data again...
data(P); data(S); data(N)
# starting with how many cycles to equilibrium
x&lt;-mal.eq(S,P,N)
# calculation of phi
phi&lt;-mal.phi(S,P,N,x)
# calculation of the conditional kinship matrix
cond&lt;-mal.cond(phi,N)
# finally! we get the Fst value
fst&lt;-Fst(cond,N)
fst

# starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
iso.matrix &lt;- uri(tot)
iso.matrix # an unbiased random isonymy matrix
reg &lt;- rri(tot)
reg # a coefficient of unbiased Regional Random Isonymy
kin.cond &lt;- rel.cond(iso.matrix,reg)
kin.cond # a conditional kinship matrix
N &lt;- colSums(tot) # effective population size
fst&lt;-Fst(kin.cond,N)
fst
</code></pre>

<hr>
<h2 id='hedrick'> Calculates the Hedrick standardized kinship coefficient </h2><span id='topic+hedrick'></span>

<h3>Description</h3>

<p>&ldquo;hedrick&rdquo;calculates the Hedrick standardized kinship coefficient starting from surname frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hedrick(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hedrick_+3A_x">x</code></td>
<td>
<p> is a surname frequency table where the N rows correspond to the surnames present in the whole population and the M columns are the subpopulations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of &ldquo;hedrick&rdquo; could be problematic, because different people are likely to arrange isonymy data in different ways on their computers. We decided for a matrix format for the isonymy data; the function would originally accept data in a different format and then convert it internally, but this would be a problem for people with data arranged in a different format. In the end we decided to write a specific function, &quot;sur.freq&quot;, to generate surname frequency tables directly from raw marriage data or marriage-like data (the most commonly used sources in bio-demographic studies). For other types of surname data, see the verbose explanation in the info for the dataset &quot;surnames&quot; so it would be clear for the user how &ldquo;hedrick&rdquo; works.
</p>


<h3>Value</h3>

<p>Returns a square symmetric standardized kinship matrix. 
</p>


<h3>Note</h3>

<p>The Hedrick index was originally conceived as a measure of the probability of genotypic identity between (sub)populations and uses a standardization analogous to that employed when calculating a correlation coefficient. As a consequence, it is equal to 1 if measured on populations with identical surname distribution.
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Hedrick, P. W. 1971. A new approach to measuring genetic similarity. Evolution 25: 276-280. Weiss, V. 1980. Inbreeding and genetic distance between hierarchically structured populations measured by surname frequencies. Mankind Quarterly 21: 135-149 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to generate the input surname frequency table from marriage data, <code><a href="#topic+surnames">surnames</a></code> for an explanation on how to generate the correct input table from other surname sources, <code><a href="#topic+lasker">lasker</a></code>and <code><a href="#topic+uri">uri</a></code> for other types of inter-population kinship matrices </p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
hed.kin &lt;- hedrick(tot)
hed.kin # a standardized kinship matrix

#starting from a generic surname frequency table
data(surnames)
surnames #a made-up dataset
# you can see that the surnames are arranged as the _rows_ and
# the populations are the _columns_
# the use of the function "hedrick" just turns this data into a kinship matrix
hed.kin &lt;- hedrick(surnames)
hed.kin
</code></pre>

<hr>
<h2 id='lasker'> Calculates the lasker kinship coeffcient </h2><span id='topic+lasker'></span>

<h3>Description</h3>

<p>&ldquo;Lasker&rdquo;calculates the lasker kinship coefficient starting from a surname frequency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasker(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasker_+3A_x">x</code></td>
<td>
<p> is a surname frequency table where the N rows correspond to the surnames present in the whole population and the M columns are the subpopulations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of &ldquo;lasker&rdquo; could be problematic, because different people are likely to arrange isonymy data in different ways on their computers. We decided for a matrix format for the isonymy data; the function would originally accept data in a different format and then convert it internally, but this would be a problem for people with data arranged in a different format. In the end we decided to write a specific function, &quot;sur.freq&quot;, to generate surname frequency tables directly from raw marriage data or marriage-like data (the most commonly used sources in bio-demographic studies). For other types of surname data, see the verbose explanation in the info for the dataset &quot;surnames&quot; so it would be clear for the user how &ldquo;lasker&rdquo; works.
</p>


<h3>Value</h3>

<p>Returns a square symmetric kinship matrix.
</p>


<h3>Note</h3>

<p>...
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Lasker, G.W. 1977. A coefficient of relationship by isonymy: A method for estimating the genetic relationship between populations. Hum. Biol. 49:489-493. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to generate the input surname frequency table from marriage data, <code><a href="#topic+surnames">surnames</a></code> for an explanation on how to generate the correct input table from other surname sources, <code><a href="#topic+hedrick">hedrick</a></code>and <code><a href="#topic+uri">uri</a></code> for other types of inter-population kinship matrices </p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
lask.kin &lt;- lasker(tot)
lask.kin # a kinship matrix

#starting from a generic surname frequency table
data(surnames)
surnames #a made-up dataset
# the surnames are arranged as the _rows_ and the populations are the _columns_
# the use of the function ``Lasker'' just turns this data into a kinship matrix
lask.kin &lt;- lasker(surnames)
lask.kin
</code></pre>

<hr>
<h2 id='mal.cond'> Calculates a Conditional Kinship matrix </h2><span id='topic+mal.cond'></span>

<h3>Description</h3>

<p>The function &ldquo;mal.cond&rdquo; calculates a R conditional kinship matrix starting from a kinship matrix obtained by the applicatio of the Malecot migration model on a colum stochastic migration matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mal.cond(PHI, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mal.cond_+3A_phi">PHI</code></td>
<td>
 <p><code>PHI</code> is a square and symmetrical kinship matrix, possibly the output of the function Phi </p>
</td></tr>
<tr><td><code id="mal.cond_+3A_n">N</code></td>
<td>
 <p><code>N</code> is the effectiove population vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Much more useful than the Phi matrix, the conditional kinship R matrix is the basis for further analysis by means of Mantel tests, Procrustes rotations and cluster analysis.
</p>


<h3>Value</h3>

<p>Returns a square symmetrical matrix.
</p>


<h3>Note</h3>

<p> ... </p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli <a href="mailto:f.calboli@gmail.com">f.calboli@gmail.com</a> </p>


<h3>References</h3>

<p> Jorde, L. B. 1982. The genetic structure of the Utah mormons: migration analysis. Human Biology 54(3): 583-597. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mal.phi">mal.phi</a></code> for the calculation of &quot;absolute&quot; kinship values </p>


<h3>Examples</h3>

<pre><code class='language-R'># using Swedlund data again...
data(S); data(P); data(N)
x&lt;-mal.eq(S,P,N)
phi&lt;-mal.phi(S,P,N,x)
cond.mat&lt;-mal.cond(phi,N)
cond.mat
</code></pre>

<hr>
<h2 id='mal.eq'> Calculates the asymptotic generation for the Malecot model </h2><span id='topic+mal.eq'></span>

<h3>Description</h3>

<p>Mal.eq calculates the Malecot model iteratively, stopping when one more cycle adds 0 to every value of the matrix obtained by the model. Once equilibrium is reached, Mal.eq returns the number of cycles (&quot;generations&quot;) needed to reach it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mal.eq(S, P, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mal.eq_+3A_s">S</code></td>
<td>
<p> is the Sistematic pressure matrix. </p>
</td></tr>
<tr><td><code id="mal.eq_+3A_p">P</code></td>
<td>
<p> is the colum-stochastic migration matrix. </p>
</td></tr>
<tr><td><code id="mal.eq_+3A_n">N</code></td>
<td>
<p> is the vector of effective population size. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of mal.eq is necessary before the calculation of the Malecot model proper because the value returned by Mal.eq is one of the arguments of the Malecot model function Phi.
</p>


<h3>Value</h3>

<p>Returns one numeric value.
</p>


<h3>Note</h3>

<p>This function has been coerced to use &quot;only&quot; six significant digits.
...
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli <a href="mailto:f.calboli@gmail.com">f.calboli@gmail.com</a> </p>


<h3>References</h3>

<p> Imaizumi, Y., N. E. Morton and D. E. Harris. 1970. Isolation by distance in artificial populations. Genetics 66: 569-582.
</p>
<p>Jorde, L. B. 1982. The genetic structure of the Utah mormons: migration analysis. Human Biology 54(3): 583-597.
</p>
<p>Swedlund, A. C., L. B. Jorde and J. H. Mielke. 1984. Population structure in the Connecticut valley. I. Marital migration. American Journal of Physical Anthropology 65: 61-70 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mal.phi">mal.phi</a></code> for the function using the output of 'mal.eq' </p>


<h3>Examples</h3>

<pre><code class='language-R'># the data is originally from a paper by Swedlund et al. 1984.
data(S); data(P); data(N)
mal.eq(S,P,N)
</code></pre>

<hr>
<h2 id='mal.phi'> Calculates a kinship matrix using the Malecot Migration Model </h2><span id='topic+mal.phi'></span>

<h3>Description</h3>

<p>Calculates a kinship matrix using the Malecot Migration Model, in the form described by L. B. Jorde 1982.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mal.phi(S, P, N, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mal.phi_+3A_s">S</code></td>
<td>
<p> the sistematic pressure matrix, where the diagonal elements are 1-sk, with sk the sistematic pressure for the k-th population, and the non diagonal elements are 0 </p>
</td></tr>
<tr><td><code id="mal.phi_+3A_p">P</code></td>
<td>
<p> the column stochastic migration matrix, possibly obtained using col.sto on the &quot;raw&quot; migration matrix </p>
</td></tr>
<tr><td><code id="mal.phi_+3A_n">N</code></td>
<td>
<p> the vector of effective populations, where each element is the population size for all the n populations divided by 3 </p>
</td></tr>
<tr><td><code id="mal.phi_+3A_n">n</code></td>
<td>
<p> the number of iterations needed to reach the equilibrium, calculated by the function Mal.eq </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Malecot model is simply an iterative markow-chain-like process that gives rise to an asymptotic growth curve, so that an equilibrium is reached after a number of iterations.
</p>


<h3>Value</h3>

<p>Returns a square and symmetrical matrix.
</p>


<h3>Note</h3>

<p> ... </p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli <a href="mailto:f.calboli@gmail.com">f.calboli@gmail.com</a> </p>


<h3>References</h3>

<p> Imaizumi, Y., N. E. Morton and D. E. Harris. 1970. Isolation by distance in artificial populations. Genetics 66: 569-582.
</p>
<p>Jorde, L. B. 1982. The genetic structure of the Utah mormons: migration analysis. Human Biology 54(3): 583-597. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mal.eq">mal.eq</a></code> for the function generating the number of cycles needed to reach the asymptotic value </p>


<h3>Examples</h3>

<pre><code class='language-R'># using Swedlund data again...
data(S); data(P); data(N)
x&lt;-mal.eq(S,P,N)
phi&lt;-mal.phi(S,P,N,x)
phi
</code></pre>

<hr>
<h2 id='mar.iso'> Observed and Random Marital Isonymy </h2><span id='topic+mar.iso'></span>

<h3>Description</h3>

<p>Function &ldquo;mar.iso&rdquo; calculates Observed and Random Marital Isonymy starting from tables of observed couples of surnames frequencies in each (sub)population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mar.iso(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mar.iso_+3A_x">x</code></td>
<td>
<p> is a table object containing N matrices, where N is the number of analysed (sub)populations. Each matrix is a square matrix whose dimensions are equal to the total number of different surnames observed in the analysed subpopulations. Rows correspond to male surnames entries and columns to female surnames entries </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marital Isonymy coefficients are obtainable starting from marriage data or equivalent data. The tables of observed couples of surnames needed as argument in &ldquo;mar.iso&rdquo; are easily obtainable from raw data using the &quot;sur.freq&quot; function selecting the &quot;marriage&quot; option. Observed Isonymy (Pt) is the number of isonymic marriages (i. e. marriages in which both the mates have the same surname) on the total number of marriages. Random Isonymy (Pr) is the probability that two mates have randomly the same surname and is given by: Pr = sum (pi * qi), where pi is the frequence of the i-th surname among males and qi is the frequency of the i-th surname among females. 
</p>


<h3>Value</h3>

<p>Returns a data frame reporting Observed Isonymy (Pt) and Random Isonymy (Pr) for each (sub)population (pop)
</p>


<h3>Note</h3>

<p>The Observed Isonymy coefficient (Pt) is a measure of within (sub)population kinship. The Random Isonymy coefficient (Pr) is an unbiased measure of the expected within (sub)population kinship value in case of random marriage unions. The output of the &ldquo;mar.iso&rdquo; function can be used as the argument for the &quot;sur.inbr&quot; function to calculate Inbreeding indexes. Pr values can also be substituted to the diagonal values of the kinship between populations matrix given by the function &quot;uri&quot; to obtain another unbiased random kinship matrix. 
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Crow, J. F., Mange, A. P. 1965. Measurement of inbreeding from the frequency of marriages between persons of the same surnames. Eugen. Q. 12:199-203. Crow, J. F. 1980. The estimation of inbreeding from isonymy. Hum. Biol. 52:1-14. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to calculate surnames frequencies tables from raw marriages data bases, <code><a href="#topic+sur.inbr">sur.inbr</a></code> to calculate inbreeding coefficients starting from Pt and Pr, <code><a href="#topic+r.pairs">r.pairs</a></code> to calculate Repeated Pairs indexes, <code><a href="#topic+uri">uri</a></code> to calculate a matrix of Unbiased Random Isonymy coefficients between (sub)populations </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(valley)
valley #a subset of a real marriage data base

mar &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF,freq.table="marriages")
mar # frequency tables of the observed pairs of surnames in each population

iso &lt;- mar.iso(mar)
iso # a data frame containing Pt and Pr values for each (sub)population
</code></pre>

<hr>
<h2 id='mtx.exp'> Calculates the n-th power of a matrix </h2><span id='topic+mtx.exp'></span>

<h3>Description</h3>

<p>Calculates the n-th power of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtx.exp(X, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mtx.exp_+3A_x">X</code></td>
<td>
<p> a square matrix </p>
</td></tr>
<tr><td><code id="mtx.exp_+3A_n">n</code></td>
<td>
<p> the exponential value </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates (efficiently!) the n-th power of a matrix.
</p>


<h3>Value</h3>

<p>Takes a matrix and returns a matrix.
</p>


<h3>Note</h3>

<p> Original code by VCC &quot;beautyfied&quot; by MM </p>


<h3>Author(s)</h3>

<p> Vincente Canto Cassola and Martin Maechler </p>


<h3>References</h3>

<p> ... </p>


<h3>Examples</h3>

<pre><code class='language-R'>test&lt;-matrix(c(1:16), 4,4)
pow.test&lt;-mtx.exp(test,10)
pow.test
</code></pre>

<hr>
<h2 id='N'> Effective population vector </h2><span id='topic+N'></span>

<h3>Description</h3>

<p>A vector giving the effective population size for n populations. The effective population size is calculated as the total population divided by three.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(N)</code></pre>


<h3>Format</h3>

<p>A 12 elements vector.
</p>


<h3>Details</h3>

<p>This data comes for Swedlund et al. 1984.
</p>


<h3>Source</h3>

<p>Swedlund, A. C., L. B. Jorde and J. H. Mielke. 1984. Population structure in the Connecticut valley. I. Marital migration. American Journal of Physical Anthropology 65: 61-70
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(N)
</code></pre>

<hr>
<h2 id='P'> Column stochastic migration matrix </h2><span id='topic+P'></span>

<h3>Description</h3>

<p>A column stochastic migration matrix for 12 populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(P)</code></pre>


<h3>Format</h3>

<p>A 12 by 12 square matrix
</p>


<h3>Details</h3>

<p>This data comes for Swedlund et al. 1984.
</p>


<h3>Source</h3>

<p>Swedlund, A. C., L. B. Jorde and J. H. Mielke. 1984. Population structure in the Connecticut valley. I. Marital migration. American Journal of Physical Anthropology 65: 61-70
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(P)
</code></pre>

<hr>
<h2 id='r.pairs'> Observed and Random Repeated Pairs Coefficients </h2><span id='topic+r.pairs'></span>

<h3>Description</h3>

<p>Function &ldquo;r.pairs&rdquo; calculates Observed and Random Repeated Pairs Coefficients starting from tables of observed couples of surnames frequencies in each (sub)population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r.pairs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r.pairs_+3A_x">x</code></td>
<td>
<p> is a table object containing N matrices, where N is the number of analysed (sub)populations. Each matrix is a square matrix whose dimensions are equal to the total number of different surnames observed in the analysed subpopulations. Rows correspond to male surnames entries and columns to female surnames entries. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Repeated Pairs coefficients are obtainable starting from marriage data or equivalent data. The tables of observed couples of surnames needed as argument in &ldquo;rep.pairs&rdquo; are easily obtainable from raw data using the &quot;sur.freq&quot; function selecting the &quot;marriage&quot; option. Observed Repeated Pairs coefficient (RP) estimate the level of homozigosity in a (sub)population on the basis of repeated appearences of couples of identical surnames. Random Repeated Pairs coefficient (RPr) is the expected RP value in case of completely random marriage unions. Comparisons between RP and RPr are expressed with their percentage difference (perc.diff) given by (RP-RPr)/RPr. 
</p>


<h3>Value</h3>

<p>Returns a data frame reporting Observed Repeated Pairs (RP), Random Repeated Pairs (RPr) and the Percentual difference between RP and RPr (perc. diff) for each (sub)population (pop).
</p>


<h3>Note</h3>

<p>RP and RPr are standardized indexes and their values vary between 0 and 1. RP, being calculated using the whole surname matrix, is considered a more reliable source of information on the level of homozigosity in a population than Isonymy data. An excess of RP on RPr, as calculated by their percentage difference, suggests the existence of a degree of subdvision internal to the analysed (sub)population.  
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Lasker G. W., Kaplan B. A. 1985. Surnames and genetic structure: repetition of the same pairs of names of married couples, a measure of subdivision of the population. Hum. Biol. 57:431-440. Chakraborty R. 1985. A note on the calculation of random RP and its sampling variance. Hum. Biol. 57:713-717. Chakraborty R. 1986. Erratum. Hum. Biol. 58:991. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to calculate surnames frequencies tables from raw marriages data bases, <code><a href="#topic+mar.iso">mar.iso</a></code> to calculate Observed and Random Isonymy coefficients starting from tables of couples of surnames frequencies, <code><a href="#topic+sur.inbr">sur.inbr</a></code> to calculate Inbreeding indexes from Isonymy coefficients</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(valley)
valley # a subset of a real marriage data base

mar &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF,freq.table="marriages")
mar # frequency tables of the observed pairs of surnames in each population

RP &lt;- r.pairs(mar)
RP # a data frame containing RP, RPr perc.diff values for each (sub)population

</code></pre>

<hr>
<h2 id='raw.mig'> A raw migration data </h2><span id='topic+raw.mig'></span>

<h3>Description</h3>

<p>Made up raw dataset, created as if count data for marital migration were put into matrix form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(raw.mig)</code></pre>


<h3>Format</h3>

<p>A 4 by 4 square matrix.
</p>


<h3>Details</h3>

<p>Completely made up for pedagogical purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raw.mig)
col.sto(raw.mig)
</code></pre>

<hr>
<h2 id='rel.cond'> Calculates a conditional kinship matrix from isonymy data </h2><span id='topic+rel.cond'></span>

<h3>Description</h3>

<p>&quot;rel.cond&quot; calculates a conditional kinship matrix starting from isonymy data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.cond(x,R, method="A")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rel.cond_+3A_x">x</code></td>
<td>
<p> is a square Unbiased Random Isonymy matrix, possibly obtained using the &quot;uri&quot; function on the raw surname data </p>
</td></tr>
<tr><td><code id="rel.cond_+3A_r">R</code></td>
<td>
<p> is an unbiased estimate of Regional Random Isonymy, calculated by the function &quot;rri&quot; </p>
</td></tr>
<tr><td><code id="rel.cond_+3A_method">method</code></td>
<td>
<p> a character string specifying the method to be used in the calculation of the coefficients. The available options are &quot;A&quot; and &quot;B&quot;. Both the methods give similar results. The &quot;A&quot; method is given as the default option 
</p>
</td></tr></table>


<h3>Details</h3>

<p>The function implements Relethford's method to calculate kinship coefficients starting from surname data. 
</p>


<h3>Value</h3>

<p>Returns a square symmetric conditional kinship matrix. 
</p>


<h3>Note</h3>

<p>The term 'conditional kinship' refers to kinship relative to the contemporary region
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Relethford, J. H. 1988. Estimation of kinship and genetic distance from
surnames. Human Biology, 60(3): 475-492.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+uri">uri</a></code> to calculate Unbiased Random Isonymy starting from tables of surname frequencies, <code><a href="#topic+rri">rri</a></code> to calculate an an unbiased estimate of Regional Random Isonymy, <code><a href="#topic+rel.phi">rel.phi</a></code> to calculate an 'a priori' kinship matrix from isonymy data</p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
iso.matrix &lt;- uri(tot)
iso.matrix # an unbiased random isonymy matrix
reg &lt;- rri(tot)
reg # a coefficient of unbiased Regional Random Isonymy
kin.cond &lt;- rel.cond(iso.matrix,reg)
kin.cond # a conditional kinship matrix

#starting from a generic surname frequency table
data(surnames)
surnames # a made-up dataset
iso.matrix &lt;- uri(surnames)
iso.matrix # an unbiased random isonymy matrix
reg &lt;- rri(surnames)
reg # a coefficient of unbiased Regional Random Isonymy
kin.cond &lt;- rel.cond(iso.matrix,reg)
kin.cond # a conditional kinship matrix
</code></pre>

<hr>
<h2 id='rel.phi'> Calculates an 'a priori' kinship matrix from isonymy data </h2><span id='topic+rel.phi'></span>

<h3>Description</h3>

<p>&quot;rel.phi&quot; calculates an 'a priori' kinship matrix starting from isonymy data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.phi(x,R, method="A")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rel.phi_+3A_x">x</code></td>
<td>
<p> is a square Unbiased Random Isonymy matrix, possibly obtained using the &quot;uri&quot; function on the raw surname data </p>
</td></tr>
<tr><td><code id="rel.phi_+3A_r">R</code></td>
<td>
<p> is an unbiased estimate of Regional Random Isonymy, calculated by the function &quot;rri&quot; </p>
</td></tr>
<tr><td><code id="rel.phi_+3A_method">method</code></td>
<td>
<p> a character string specifying the method to be used in the calculation of the coefficients. The available options are &quot;A&quot; and &quot;B&quot;. Both the methods give similar results. The &quot;A&quot; method is given as the default option 
</p>
</td></tr></table>


<h3>Details</h3>

<p>The function implements Relethford's method to calculate kinship coefficients starting from surname data. 
</p>


<h3>Value</h3>

<p>Returns a square symmetric 'a priori' kinship matrix. 
</p>


<h3>Note</h3>

<p>The term 'a priori kinship' refers to kinship relative to a founding population
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Relethford, J. H. 1988. Estimation of kinship and genetic distance from
surnames. Human Biology, 60(3): 475-492.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+uri">uri</a></code> to calculate Unbiased Random Isonymy starting from tables of surname frequencies, <code><a href="#topic+rri">rri</a></code> to calculate an an unbiased estimate of Regional Random Isonymy, <code><a href="#topic+rel.cond">rel.cond</a></code> to calculate a conditional kinship matrix from isonymy data</p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
iso.matrix &lt;- uri(tot)
iso.matrix # an unbiased random isonymy matrix
reg &lt;- rri(tot)
reg # a coefficient of unbiased Regional Random Isonymy
kin &lt;- rel.phi(iso.matrix,reg)
kin # an 'a priori' kinship matrix

#starting from a generic surname frequency table
data(surnames)
surnames # a made-up dataset
iso.matrix &lt;- uri(surnames)
iso.matrix # an unbiased random isonymy matrix
reg &lt;- rri(surnames)
reg # a coefficient of unbiased Regional Random Isonymy
kin &lt;- rel.phi(iso.matrix,reg)
kin # an 'a priori' kinship matrix
</code></pre>

<hr>
<h2 id='rri'> Calculates an unbiased estimate of Regional Random Isonymy </h2><span id='topic+rri'></span>

<h3>Description</h3>

<p>&quot;rri&quot; calculates an unbiased estimate of Regional Random Isonymy starting from surname frequencies. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rri(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rri_+3A_x">x</code></td>
<td>
<p> is a surname frequency table where the N rows correspond to the surnames present in the whole population and the M columns are the (sub)populations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements Morton's isonymy method as outlined by Relethford. 
Unbiased estimate of Regional Random Isonymy refers to random isonymy of the contemporary region relative to the founding population. This value is an argument needed to calculate 'a priori' and conditional kinship matrices using the &quot;rel.phi&quot; and &quot;rel.cond&quot; functions.
</p>


<h3>Value</h3>

<p>Returns one numeric value. 
</p>


<h3>Note</h3>

<p>The use of &ldquo;rri&rdquo; could be problematic, because different people are likely to arrange isonymy data in different ways on their computers. We decided for a matrix format for the isonymy data; the function would originally accept data in a different format and then convert it internally, but this would be a problem for people with data arranged in a different format. In the end we decided to write a specific function, &quot;sur.freq&quot;, to generate surname frequency tables directly from raw marriage data or marriage-like data (the most commonly used sources in bio-demographic studies). For other types of surname data, see the verbose explanation in the info for the dataset &quot;surnames&quot; so it would be clear for the user how &ldquo;rri&rdquo; works.
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Morton, N. E. 1973. Kinship bioassy. In: Genetic distance,
J. F Crow and C Denniston (eds.). New York, Plenum Press, 97-104.
Relethford, J. H. 1988. Estimation of kinship and genetic distance from
surnames. Human Biology, 60(3): 475-492.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to generate the input surname frequency table from marriage data, <code><a href="#topic+surnames">surnames</a></code> for an explanation on how to generate the correct input table from other surname sources, <code><a href="#topic+uri">uri</a></code> to calculate an Unbiased Random Isonymy matrix, <code><a href="#topic+rel.phi">rel.phi</a></code> to calculate an 'a priori' kinship matrix from isonymy data, <code><a href="#topic+rel.cond">rel.cond</a></code> to calculate a conditional kinship matrix from isonymy data</p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
reg &lt;- rri(tot)
reg # an unbiased estimate or Regional Random Isonymy

#starting from a generic surname frequency table
data(surnames)
surnames # a made-up dataset
# you can see that the surnames are arranged as the _rows_
# and the populations are the _columns_
reg &lt;- rri(surnames)
reg # an unbiased estimate or Regional Random Isonymy
</code></pre>

<hr>
<h2 id='S'> Systematic pressure matrix </h2><span id='topic+S'></span>

<h3>Description</h3>

<p>Systematic pressure matrix obtained by creating a square matix, where the non diagonal elements are all 0 and the diagonal elements are calculated as 1-Sk, where Sk is the systematic pressure for the k-th population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(S)</code></pre>


<h3>Format</h3>

<p>A 12 by 12 square matrix.
</p>


<h3>Details</h3>

<p>This data comes for Swedlund et al. 1984.
</p>


<h3>Source</h3>

<p>Swedlund, A. C., L. B. Jorde and J. H. Mielke. 1984. Population structure in the Connecticut valley. I. Marital migration. American Journal of Physical Anthropology 65: 61-70
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(S)
</code></pre>

<hr>
<h2 id='sur.freq'> Calculates surnames frequency tables </h2><span id='topic+sur.freq'></span>

<h3>Description</h3>

<p>&ldquo;sur.freq&rdquo;calculates surnames frequency tables starting from raw marriage data or equivalent sources (i.e. birth registrations)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sur.freq(x,pop,mal.sur,fem.sur,freq.table="total")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sur.freq_+3A_x">x</code></td>
<td>
<p> is a data frame in which every row corresponds to a different marriage record. The data frame must contain: <b>a</b> a column reporting the population in which the marriage was recorded; <b>b</b> a column containing male surnames; <b>c</b> a column containing female surnames </p>
</td></tr>
<tr><td><code id="sur.freq_+3A_pop">pop</code></td>
<td>
<p> is the name of the column in the data frame that reports the population in which the marriage was recorded </p>
</td></tr>
<tr><td><code id="sur.freq_+3A_mal.sur">mal.sur</code></td>
<td>
<p> is the name of the column in the data frame that contains male surnames </p>
</td></tr>
<tr><td><code id="sur.freq_+3A_fem.sur">fem.sur</code></td>
<td>
<p> is the name of the column in the data frame that comtains female surnames </p>
</td></tr>
<tr><td><code id="sur.freq_+3A_freq.table">freq.table</code></td>
<td>
<p> character string specifying the type of surname frequency table to be calculated. The available options are: &quot;males&quot; (table calculated using only male surnames); &quot;females&quot; (table calculated using only female surnames); &quot;total&quot; (table calculated using all the surnames); &quot;marriages&quot; (tables calculated using observed pairs of surnames in each population). The default option is &quot;total&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;sur.freq&rdquo; is specifically written to derive surname frequency tables from marriage data, or, more generally, data in which appear couples of related surnames, as birth records etc. 
</p>


<h3>Value</h3>

<p>A single table of surname frequencies (&quot;male&quot;, &quot;female&quot;, &quot;total&quot; options) or tables of observed pairs of surnames frequencies for each population (&quot;marriages&quot; option)
</p>


<h3>Note</h3>

<p>Surname frequency tables produced with &ldquo;sur.freq&rdquo; are intended to be used as an argument for other functions to investigate the bio-demographic structure of populations. In particular, the &quot;male&quot;, &quot;female&quot; and &quot;total&quot; options produce tables to be used in inter-population analyses (maesures of kinship/distance between populations, etc.); the &quot;marriage&quot; option produces tables to be used in intra-population analyses (inbreeding levels etc.). 
Tables of surname frequencies can also be obtained from simple lists of surnames (i.e. telephone directories, etc.) using the function &ldquo;table&rdquo;; for further explanations see the info for the &quot;surnames&quot; data set.
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Lasker, G. W. 1985. Surnames and genetic structure. Cambridge University Press. Cambridge, England </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mar.iso">mar.iso</a></code> for the calculation of Marital Isonymy coefficients from tables of observed pairs of surnames frequencies, <code><a href="#topic+r.pairs">r.pairs</a></code> fot the calculation of Repeated Pairs coefficients from tables of observed pairs of surnames frequencies, <code><a href="#topic+lasker">lasker</a></code> and <code><a href="#topic+hedrick">hedrick</a></code> for the calculation of similarity indexes between populations from surnames frequency tables, <code><a href="#topic+surnames">surnames</a></code> for an explanation on how to generate a surname frequency table starting from non-marriage like data </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(valley)
valley #a subset of a real marriage data base

# you can see that marriages correspond to rows in the data frame.
# Note that the data frame contains other columns 

tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
mal &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF,freq.table="males")
mal # a frequency table calculated above the male surnames
fem &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF,freq.table="females")
fem # a frequency table calculated above the female surnames
mar &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF,freq.table="marriages")
mar # frequency tables for the observed pairs of surnames in each population
</code></pre>

<hr>
<h2 id='sur.inbr'> Total, Random and Non-random Inbreeding Coefficients </h2><span id='topic+sur.inbr'></span>

<h3>Description</h3>

<p>Function &ldquo;sur.inbr&rdquo; calculates Total, Random and Non-random Inbreeding Coefficients starting from Observed and Random Isonymy indexes in each (sub)population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sur.inbr(x,method="B")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sur.inbr_+3A_x">x</code></td>
<td>
<p> is a data frame composed by 3 columns which, in order, contain: a code (or  a name) identifying the analysed (sub)populations; Observed Isonymy (Pt) values; Random Isonymy (Pr) values. The number of rows is equal to the total number of analysed (sub)populations. </p>
</td></tr>
<tr><td><code id="sur.inbr_+3A_method">method</code></td>
<td>
<p> character string specifying the method to be used in the calculation of the indexes. The available options are &quot;A&quot; and &quot;B&quot;. Both the methods give similar results. The &quot;B&quot; method, being the most frequently used in the studies, is given as the default option </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inbreeding coefficients are obtainable starting from Isonymy data. The data frame containing Observed and Random Isomymy for each (sub)population needed as argument in &ldquo;sur.inbr&rdquo; is easily obtainable using the &quot;mar.iso&quot; function. Inbreeding coefficients allow an estimate of the inbreeding level in a (sub)population on the basis of couples of surnames. 
</p>


<h3>Value</h3>

<p>Returns a data frame reporting Total Inbreeding (Ft), Random Inbreeding (Fr) and Non-random Inbreeding (Fn) for each (sub)population (pop)
</p>


<h3>Note</h3>

<p>Total Inbreeding (Ft) is an estimate of the inbreeding level in a (sub)population. Random Inbreeding (Fr) is the expected inbreeding level in a (sub)population in case of completely random marriage unions. Non-random Inbreeding (Fn) expresses the deviance between Ft and Fr: positive Fn values show preference towards unions between consanguineous mates, negative Fn values show aversion towards unions between consanguineous mates.
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Crow, J. F., Mange, A. P. 1965. Measurement of inbreeding from the frequency of marriages between persons of the same surnames. Eugen. Q. 12:199-203. Crow, J. F. 1980. The estimation of inbreeding from isonymy. Hum. Biol. 52:1-14. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to calculate surnames frequencies tables from raw marriages data bases, <code><a href="#topic+mar.iso">mar.iso</a></code> to calculate Observed and Random Isonymy coefficients starting from tables of couples of surnames frequencies, <code><a href="#topic+r.pairs">r.pairs</a></code> to calculate Repeated Pairs indexes </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(valley)
valley # a subset of a real marriage data base

mar &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF,freq.table="marriages")
mar # frequency tables calculated above the observed pairs of surnames in each population

iso &lt;- mar.iso(mar)
iso # a data frame containing Pt and Pr values for each (sub)population

inbreeding &lt;- sur.inbr(iso)
inbreeding # inbreeding indexes calculated using the method "B"

inbreeding2 &lt;- sur.inbr(iso,method="A")
inbreeding2 # inbreeding indexes calculated using the method "A"
</code></pre>

<hr>
<h2 id='surnames'> Surname frequency table </h2><span id='topic+surnames'></span>

<h3>Description</h3>

<p>A surname frequency table, with 3 populations and 5 surnames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(surnames)</code></pre>


<h3>Format</h3>

<p>A 5 rows by 3 columns dataset 
</p>


<h3>Details</h3>

<p>Surname frequency tables are the argument needed in all the surname-based inter-population analysis functions (e.g. &quot;lasker&quot;, &quot;hedrick&quot;, &quot;uri&quot;, etc.).
Surname frequency tables can be generated from marriage and marriage-like data (e.g. data that contain couples of related surnames) using the &quot;sur.freq&quot; function. 
In order to generate surname frequency tables from other surname sources (e.g. telephone directories, registers of voters, etc.) see the example in this help page.
To import correctly surnames data bases in R see the &quot;valley&quot; dataset help page.
</p>


<h3>Source</h3>

<p>Alessio Boattini. Dummy dataset generated for testing and example purposes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surnames)

# NB. How did we produce the "surnames" dataset?
# the original data (an hypothetic list of surnames)
# were arranged as:

#  YEAR POP SURNAME
#  1901   3  FABBRI
#  1901   3  VITALI
#  1901   2   LIPPI
#  1901   2  FABBRI
#  1901   2   NARDI
#  1901   2   NARDI
#  1901   1  ANGELI
#  1902   1  ANGELI
#  1902   2  VITALI
#  1902   2   LIPPI
#  1902   1   LIPPI
#  1902   1   LIPPI
#  1902   3  VITALI
#  1902   3  FABBRI
#  1902   2  FABBRI
#  1904   2   NARDI
#  1904   2   NARDI
#  1904   2   LIPPI
#  1905   1  VITALI
#  1905   1  FABBRI
#  1905   3  FABBRI
#  1905   3  ANGELI
#  1905   2   LIPPI
#  1905   2   NARDI
#  1905   3   NARDI
#  1905   3   NARDI

#       ..........

# This arrangement does not necessarily reflect
# the way other people would arrange their data. 
# The "surnames" dataset was generated using
# the "table" function as follows:

# table(data$SURNAME,data$POP)
</code></pre>

<hr>
<h2 id='sym.P'> Calculate the symmetric column stochastic matrix </h2><span id='topic+sym.P'></span>

<h3>Description</h3>

<p>Used to turn the asymmetric column stochastic matrix into a symmetric column stochastic matric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sym.P(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sym.P_+3A_x">x</code></td>
<td>
 <p><code>x</code> is a column stochastic matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the symmetric matrix from the asymmetric column stochastic matrix, leaving the diagonal unchanged and averaging m[i,j] and m[j,i] as (m[i,j]+m[j,i])/2. The computed average substitutes each pair of values in the new symmetric column stochastic matrix.
</p>


<h3>Value</h3>

<p>Returns a matrix.
</p>


<h3>Note</h3>

<p> ... </p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli <a href="mailto:f.calboli@gmail.com">f.calboli@gmail.com</a> </p>


<h3>References</h3>

<p> Jorde, L. B. 1982. The genetic structure of the Utah mormons: migration analysis. Human Biology 54(3): 583-597. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(P)
symmetric&lt;-sym.P(P)
</code></pre>

<hr>
<h2 id='uri'> Calculates the Unbiased Random Isonymy matrix </h2><span id='topic+uri'></span>

<h3>Description</h3>

<p>&quot;uri&quot; calculates the unbiased random isonymy coefficient starting from surname frequencies. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uri(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uri_+3A_x">x</code></td>
<td>
<p> is a surname frequency table where the N rows correspond to the surnames present in the whole population and the M columns are the (sub)populations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements Morton's isonymy method as outlined by Relethford. Unbiased estimations of intra-(sub)population isonymy were included.
Unbiased Random Isonymy is an argument needed to calculate 'a priori' and conditional kinship matrices using the &quot;rel.phi&quot; and &quot;rel.cond&quot; functions.
</p>


<h3>Value</h3>

<p>Returns a square symmetric unbiased isonymy matrix. 
</p>


<h3>Note</h3>

<p>The use of &ldquo;uri&rdquo; could be problematic, because different people are likely to arrange isonymy data in different ways on their computers. We decided for a matrix format for the isonymy data; the function would originally accept data in a different format and then convert it internally, but this would be a problem for people with data arranged in a different format. In the end we decided to write a specific function, &quot;sur.freq&quot;, to generate surname frequency tables directly from raw marriage data or marriage-like data (the most commonly used sources in bio-demographic studies). For other types of surname data, see the verbose explanation in the info for the dataset &quot;surnames&quot; so it would be clear for the user how &ldquo;uri&rdquo; works.
</p>


<h3>Author(s)</h3>

<p> Federico C. F. Calboli and Alessio Boattini <a href="mailto:alessio.boattini2@unibo.it">alessio.boattini2@unibo.it</a> </p>


<h3>References</h3>

<p> Morton, N. E. 1973. Kinship bioassy. In: Genetic distance,
J. F Crow and C Denniston (eds.). New York, Plenum Press, 97-104.
Relethford, J. H. 1988. Estimation of kinship and genetic distance from
surnames. Human Biology, 60(3): 475-492.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sur.freq">sur.freq</a></code> to generate the input surname frequency table from marriage data, <code><a href="#topic+surnames">surnames</a></code> for an explanation on how to generate the correct input table from other surname sources, <code><a href="#topic+lasker">lasker</a></code> for a similar kinship coefficient derived from surnames, <code><a href="#topic+hedrick">hedrick</a></code> for a standardized kinship coefficient derived from surnames, <code><a href="#topic+rri">rri</a></code> to calculate an unbiased estimate of Regional Random Isonymy from surnmaes <code><a href="#topic+rel.phi">rel.phi</a></code> to calculate an 'a priori' kinship matrix from isonymy data, <code><a href="#topic+rel.cond">rel.cond</a></code> to calculate a conditional kinship matrix from isonymy data</p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a raw marriage records dataset:
data(valley)
tot &lt;- sur.freq(valley,valley$PAR,valley$SURM,valley$SURF)
tot # a frequency table calculated above all the surnames
iso.matrix &lt;- uri(tot)
iso.matrix # a unbiased random isonymy matrix

#starting from a generic surname frequency table
data(surnames)
surnames # a made-up dataset
# you can see that the surnames are arranged as the _rows_
# and the populations are the _columns_
# the function "uri" turns this data into a unbiased random isonymy matrix
iso.matrix &lt;- uri(surnames)
iso.matrix
</code></pre>

<hr>
<h2 id='valley'> Raw marriage data </h2><span id='topic+valley'></span>

<h3>Description</h3>

<p>A raw marriage data set, in which every row corresponds to a different marriage record. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(valley)</code></pre>


<h3>Format</h3>

<p>A 702 rows by 8 columns dataset. The columns of &quot;valley&quot; contain the following information:
</p>

<table>
<tr>
 <td style="text-align: left;">
    
PAR: </td><td style="text-align: left;"> (sub)population to which the marriage is referred.</td>
</tr>
<tr>
 <td style="text-align: left;">
YEAR: </td><td style="text-align: left;"> year in which the marriage was performed.</td>
</tr>
<tr>
 <td style="text-align: left;">
SURM: </td><td style="text-align: left;"> male surname.</td>
</tr>
<tr>
 <td style="text-align: left;">
NM: </td><td style="text-align: left;"> male birth (sub)population.</td>
</tr>
<tr>
 <td style="text-align: left;">
RM:  </td><td style="text-align: left;"> male residence (sub)population.</td>
</tr>
<tr>
 <td style="text-align: left;">
SURF: </td><td style="text-align: left;"> female surname.</td>
</tr>
<tr>
 <td style="text-align: left;">
NF: </td><td style="text-align: left;"> female birth (sub)population. </td>
</tr>
<tr>
 <td style="text-align: left;">
RF: </td><td style="text-align: left;"> female residence (sub)population.
</td>
</tr>

</table>

<p>For all columns the letter &quot;X&quot; indicates that the mate was born or resident outside of the study area.
</p>


<h3>Details</h3>

<p>Marriage data, depending from the used sources, may contain more or less information than the &quot;valley&quot; example data set. Columns order in the dataset is not relevant. Information on (sub)population, male and female surnames are needed to perform surname-based analyses on marriage data.
NB. Information on mates birthplace (or equivalent data) can be used to produce a migration matrix (see the &quot;raw.mig&quot; dataset).
NB2. Given that surnames may contain spaces (e.g. &quot;DE IORIO&quot;), the best way to import surname data is to save the original data base as a .csv file, and then use the read.csv() or read.csv2() functions. Another option is to use GNUMERIC, because it has a text export feature that allows to put  brakets (&quot;&quot;) to the left and right of every cell content, so that composite surnames are read as a string. The resulting text file is easily imported by read.table().
</p>


<h3>Source</h3>

<p>Paola Gueresi. Subset of a real marriage dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(valley)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
