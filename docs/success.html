<!DOCTYPE html><html><head><title>Help for package success</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {success}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrival_rate'><p>Estimate arrival rate of a Poisson points process</p></a></li>
<li><a href='#bernoulli_ARL'><p>Average Run Length for Bernoulli CUSUM</p></a></li>
<li><a href='#bernoulli_ARL_MC'><p>Average run length for Bernoulli CUSUM using Markov Chain methodology</p></a></li>
<li><a href='#bernoulli_ARL_SPRT'><p>Average run length for Bernoulli CUSUM using Integral Equation methodology</p></a></li>
<li><a href='#bernoulli_cdf_MC'><p>Average run length for Bernoulli CUSUM using Markov Chain methodology</p></a></li>
<li><a href='#bernoulli_control_limit'><p>Determine control limits for the Bernoulli CUSUM by simulation</p></a></li>
<li><a href='#bernoulli_cusum'><p>Risk-adjusted Bernoulli CUSUM</p></a></li>
<li><a href='#bernoulli_RL_cdf'><p>Cumulative distribution function (cdf) of Run Length for Bernoulli CUSUM</p></a></li>
<li><a href='#bk_control_limit'><p>Determine control limits for BK-CUSUM by simulation</p></a></li>
<li><a href='#bk_cusum'><p>Continuous time BK-CUSUM</p></a></li>
<li><a href='#breast'><p>Survival after breast cancer surgery</p></a></li>
<li><a href='#calc_MC_trans_matrix'><p>Transition probability matrix for Bernoulli CUSUM</p></a></li>
<li><a href='#calc_risk'><p>Calculate the Cox Proportional hazards relative risk associated</p>
with the covariates of subjects</a></li>
<li><a href='#calc_Wncdf'><p>Calculate cdf of singletons W_n for CUSUM</p></a></li>
<li><a href='#cgr_control_limit'><p>Determine control limits for CGR-CUSUM by simulation</p></a></li>
<li><a href='#cgr_cusum'><p>Continuous time Generalized Rapid response CUSUM (CGR-CUSUM)</p></a></li>
<li><a href='#exp_hazards'><p>Exponential hazard, cumulative hazard and inverse cumulative hazard</p></a></li>
<li><a href='#extract_hazard'><p>Extract (inverse) cumulative baseline hazard from Cox PH model</p></a></li>
<li><a href='#funnel_plot'><p>Risk-adjusted funnel plot</p></a></li>
<li><a href='#gen_arriv_times'><p>Generate arrival times according to a Poisson point process</p></a></li>
<li><a href='#gen_surv_times'><p>Generate survival times</p></a></li>
<li><a href='#generate_units'><p>Generate units with specified failure rate</p></a></li>
<li><a href='#interactive_plot'><p>Plot a list of CUSUM charts (interactive)</p></a></li>
<li><a href='#parameter_assist'><p>Assist users in parameter selection</p></a></li>
<li><a href='#plot.cgrcusum'><p>Plot a quality control chart</p></a></li>
<li><a href='#runlength'><p>Determine run length of a CUSUM chart</p></a></li>
<li><a href='#summary.funnelplot'><p>Summarizes S3 objects in this package.</p></a></li>
<li><a href='#surgerydat'><p>Simulated data set with data of surgery procedures</p>
performed at multiple hospitals.</a></li>
<li><a href='#weib_hazards'><p>Weibull hazard, cumulative hazard and inverse cumulative hazard</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Survival Control Charts Estimation Software</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Gomon &lt;d.gomon@math.leidenuniv.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quality control charts for survival outcomes.
    Allows users to construct the Continuous Time Generalized
    Rapid Response CUSUM (CGR-CUSUM) &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxac041">doi:10.1093/biostatistics/kxac041</a>&gt;, 
    the Biswas &amp; Kalbfleisch (2008)  &lt;<a href="https://doi.org/10.1002%2Fsim.3216">doi:10.1002/sim.3216</a>&gt; CUSUM, 
    the Bernoulli CUSUM and the risk-adjusted funnel plot for survival data 
    &lt;<a href="https://doi.org/10.1002%2Fsim.1970">doi:10.1002/sim.1970</a>&gt;. 
    These procedures can be used to monitor survival processes for a change 
    in the failure rate.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/d-gomon/success">https://github.com/d-gomon/success</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2, pbapply, plotly, Rfast, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, ggrepel, Matrix, matrixcalc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gridExtra, knitr, rmarkdown, vlad, testthat (&ge; 3.1.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 14:37:14 UTC; danie</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Gomon <a href="https://orcid.org/0000-0001-9011-3743"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mirko Signorelli <a href="https://orcid.org/0000-0002-8102-3356"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arrival_rate'>Estimate arrival rate of a Poisson points process</h2><span id='topic+arrival_rate'></span>

<h3>Description</h3>

<p>In a Poisson point process, subjects arrive with exponentially
distributed inter-arrival times with rate <code class="reqn">\psi</code>. This function
can be used to estimate the parameter <code class="reqn">\psi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrival_rate(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrival_rate_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the following named column for each subject:
</p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
</dl>
<p> If the <code>data.frame</code> also contains a column named <code>unit</code>, the arrival
rate will be determined for each unit separately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (named) vector containing the estimated arrival rate in the data,
or for each unit in the data.
</p>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arrival_rate(surgerydat)


</code></pre>

<hr>
<h2 id='bernoulli_ARL'>Average Run Length for Bernoulli CUSUM</h2><span id='topic+bernoulli_ARL'></span>

<h3>Description</h3>

<p>This function allows to estimate the Average Run Length (ARL)
of the risk-adjusted Bernoulli CUSUM (see <code><a href="#topic+bernoulli_cusum">bernoulli_cusum()</a></code>)
through a Markov Chain Approach (Brook &amp; Evans(1972) &amp; Steiner et al. (2000)) or
exploiting the relationship with the Sequential Probability Ratio Test (Kemp (1971)).
The function requires the specification of one of the following combinations of parameters
as arguments to the function:
</p>

<ul>
<li> <p><code>glmmod</code> &amp; <code>theta</code>
</p>
</li>
<li> <p><code>p0</code> &amp; <code>theta</code>
</p>
</li>
<li> <p><code>p0</code> &amp; <code>p1</code>
</p>
</li></ul>
<p> Average run length of lower-sided Bernoulli CUSUM charts can be determined
by specifying <code>theta</code> &lt; 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_ARL(h, n_grid, glmmod, theta, theta_true, p0, p1, method = c("MC",
  "SPRT"), smooth_prob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_ARL_+3A_h">h</code></td>
<td>
<p>Control limit for the Bernoulli CUSUM</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_n_grid">n_grid</code></td>
<td>
<p>Number of state spaces used to discretize the outcome space (when <code>method = "MC"</code>)
or number of grid points used for trapezoidal integration (when <code>method = "SPRT"</code>).
Increasing this number improves accuracy, but can also significantly increase computation time.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the average run length for the upper one-sided
Bernoulli CUSUM will be determined. If <code class="reqn">\theta &lt; 0</code>,
the average run length for the lower one-sided CUSUM will be determined.
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_theta_true">theta_true</code></td>
<td>
<p>The true log odds ratio <code class="reqn">\theta</code>, describing the
true increase in failure rate from the null-hypothesis. Default = log(1), indicating
no increase in failure rate.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_p1">p1</code></td>
<td>
<p>The alternative hypothesis failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_method">method</code></td>
<td>
<p>The method used to obtain the average run length. Either &quot;MC&quot; for Markov Chain
or &quot;SPRT&quot; for SPRT methodology. Default = &quot;MC&quot;.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_+3A_smooth_prob">smooth_prob</code></td>
<td>
<p>Should the probability distribution of failure under the null distribution be smoothed?
Useful for small samples. Can only be TRUE when <code>glmmod</code> is supplied. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average run length of a CUSUM chart <code class="reqn">S_n</code> is given by
<code class="reqn">E[\tau_n],</code> where <code class="reqn">\tau_n</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\tau_n = \inf\{n \geq 0: S_n \geq h\}.</code>
</p>

<p>When <code>method = "MC"</code>, the average run length will be determined by
the Markov Chain approach described
in Brook &amp; Evans (1972), using the risk-adjustment correction proposed in
Steiner et al. (2000). The idea is to discretize the domain (0, h) into <code class="reqn">n_{grid} -1</code>
state spaces, with <code class="reqn">E_0</code> of width <code class="reqn">w/2</code>
and <code class="reqn">E_1, \ldots, E_{n_{grid}-1}</code> of width <code class="reqn">w</code>, such that
<code class="reqn">E_{n_{grid}}</code> is an absorbing state.  This is done using the following steps:
</p>

<ul>
<li> <p><code class="reqn">w</code> is determined using the relationship <code class="reqn">\frac{2h}{2t-1}</code>.
</p>
</li>
<li><p> Transition probabilities between the states are determined and
'transition matrix' <code class="reqn">R</code> is constructed.
</p>
</li>
<li><p> The equation <code class="reqn">(\bm{I}-\bm{R}) \bm{ARL} = \bm{1}</code> is
solved to find the ARL starting from each of the states.
</p>
</li></ul>

<p>When <code>method = "SPRT"</code>, the average run length will be determined by
the relationship between the SPRT and CUSUM described in Kemp (1971), using the risk-adjustment
correction proposed in Steiner et al. (2000).
If N is the run length of a SPRT, P(0) the probability of
a SPRT terminating on the lower boundary of zero and R the run length of
a CUSUM, then: </p>
<p style="text-align: center;"><code class="reqn">E[R] = \frac{E[N]}{1 - P(0)}.</code>
</p>

<p><code class="reqn">E[N]</code> and <code class="reqn">P(0)</code> are completely determined by
</p>
<p style="text-align: center;"><code class="reqn">G_n(z) = \int_0^h F(z-w) dG_{n-1}(w)</code>
</p>

<p>with <code class="reqn">F(x)</code> the cdf of the singletons <code class="reqn">W_n</code>. The integral can be
approximated using the generalized trapezoidal quadrature rule:
</p>
<p style="text-align: center;"><code class="reqn">G_n(z) = \sum_{i=0}^{n_{grid}-1} \frac{F(z-x_{i+1}) + F(z-x_{i})}{2} \left(G_{n-1}(x_{i+1}) - G_{n-1}(x_{i})  \right)</code>
</p>



<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>ARL_0</code>: A numeric value indicating the average run length in
number of outcomes when starting from state E_0.
</p>
</li>
<li> <p><code>ARL</code>: A <code>data.frame</code> containing the average run length (#outcomes)
depending on the state in which the process starts (E_0, E_1, ..., E_n_grid-1)
</p>

<dl>
<dt><code>start_val</code>:</dt><dd><p>Starting value of the CUSUM, corresponding to the
discretized state spaces E_i;</p>
</dd>
<dt><code>#outcomes</code>:</dt><dd><p>ARL for the CUSUM with
initial value <code>start_val</code>;</p>
</dd>
</dl>

</li>
<li> <p><code>R</code>: A transition probability <code>matrix</code> containing the transition
probabilities between states <code class="reqn">E_0, \ldots, E_{t-1}</code>.
<code class="reqn">R_{i,j}</code> is the transition probability from state i to state j.
</p>
</li>
<li> <p><code>h</code>: Value of the control limit.
</p>
</li></ul>
<p> The value of <code>ARL_0</code> will be printed to the console.
</p>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>References</h3>

<p>Brook, D., &amp; Evans, D. A. (1972). An Approach to the Probability
Distribution of Cusum Run Length. Biometrika, 59(3), 539–549.
<a href="https://doi.org/10.2307/2334805">doi:10.2307/2334805</a>
</p>
<p>Steiner, S. H., Cook, R. J., Farewell, V. T., &amp; Treasure, T. (2000).
Monitoring surgical performance using risk-adjusted cumulative sum charts.
Biostatistics, 1(4), 441–452. <a href="https://doi.org/10.1093/biostatistics/1.4.441">doi:10.1093/biostatistics/1.4.441</a>
</p>
<p>Kemp, K. W. (1971). Formal Expressions which Can Be Applied to Cusum Charts.
Journal of the Royal Statistical Society. Series B (Methodological), 33(3),
331–360. <a href="https://doi.org/10.1111/j.2517-6161.1971.tb01521.x">doi:10.1111/j.2517-6161.1971.tb01521.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bernoulli_cusum">bernoulli_cusum</a></code>, <code><a href="#topic+bernoulli_control_limit">bernoulli_control_limit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Determine a risk-adjustment model using a generalized linear model.
#Outcome (failure within 100 days) is regressed on the available covariates:
glmmodber &lt;- glm((survtime &lt;= 100) &amp; (censorid == 1)~ age + sex + BMI,
                  data = surgerydat, family = binomial(link = "logit"))
#Determine the Average Run Length in number of outcomes for
#control limit h = 2.5 with (0, h) divided into n_grid = 200 segments
ARL &lt;- bernoulli_ARL(h = 2.5, n_grid = 200, glmmod = glmmodber, theta = log(2))
#Calculate ARL, but now exploiting connection between SPRT and CUSUM:
#n_grid now decides the accuracy of the Trapezoidal rule for integral approximation
ARLSPRT &lt;- bernoulli_ARL(h = 2.5, n_grid = 200, glmmod = glmmodber,
theta = log(2), method = "SPRT")


#We can compare our ARL with that determined using the VLAD package
#See \url{https://cran.r-project.org/package=vlad}
if(require("vlad")){
   fi &lt;- as.numeric(table(glmmodber$fitted.values)/length(glmmodber$fitted.values))
   pi1 &lt;- sort(unique(glmmodber$fitted.values))
   pmix1 &lt;- data.frame(fi, pi1, pi1)
   vlad_ARL &lt;- round(vlad::racusum_arl_mc(pmix = pmix1, RA = 2, RQ = 1, h = 2.5, scaling = 200))
   print(vlad_ARL)
}

</code></pre>

<hr>
<h2 id='bernoulli_ARL_MC'>Average run length for Bernoulli CUSUM using Markov Chain methodology</h2><span id='topic+bernoulli_ARL_MC'></span>

<h3>Description</h3>

<p>Internal function that discretizes grid and solves
matrix equation involving transition matrix for Markov Chain methodology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_ARL_MC(n_grid, R, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_ARL_MC_+3A_n_grid">n_grid</code></td>
<td>
<p>Number of state spaces used to discretize the outcome space (when <code>method = "MC"</code>)
or number of grid points used for trapezoidal integration (when <code>method = "SPRT"</code>).
Increasing this number improves accuracy, but can also significantly increase computation time.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_MC_+3A_r">R</code></td>
<td>
<p>Transition probability matrix obtained from <code>calc_MC_trans_matrix</code></p>
</td></tr>
<tr><td><code id="bernoulli_ARL_MC_+3A_h">h</code></td>
<td>
<p>Control limit for the Bernoulli CUSUM</p>
</td></tr>
</table>

<hr>
<h2 id='bernoulli_ARL_SPRT'>Average run length for Bernoulli CUSUM using Integral Equation methodology</h2><span id='topic+bernoulli_ARL_SPRT'></span>

<h3>Description</h3>

<p>Internal function that calculates the ARL using the connection
between the ARL of a Wald SPRT and a CUSUM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_ARL_SPRT(h, n_grid, Wncdf, glmmod, theta, theta_true, p0,
  tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_h">h</code></td>
<td>
<p>Control limit for the Bernoulli CUSUM</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_n_grid">n_grid</code></td>
<td>
<p>Number of state spaces used to discretize the outcome space (when <code>method = "MC"</code>)
or number of grid points used for trapezoidal integration (when <code>method = "SPRT"</code>).
Increasing this number improves accuracy, but can also significantly increase computation time.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_wncdf">Wncdf</code></td>
<td>
<p>A function returning the values of the (risk-adjusted) cumulative
distribution function (cdf) for the singletons Wn.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the average run length for the upper one-sided
Bernoulli CUSUM will be determined. If <code class="reqn">\theta &lt; 0</code>,
the average run length for the lower one-sided CUSUM will be determined.
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_theta_true">theta_true</code></td>
<td>
<p>The true log odds ratio <code class="reqn">\theta</code>, describing the
true increase in failure rate from the null-hypothesis. Default = log(1), indicating
no increase in failure rate.</p>
</td></tr>
<tr><td><code id="bernoulli_ARL_SPRT_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
</table>

<hr>
<h2 id='bernoulli_cdf_MC'>Average run length for Bernoulli CUSUM using Markov Chain methodology</h2><span id='topic+bernoulli_cdf_MC'></span>

<h3>Description</h3>

<p>Internal function that discretizes grid and solves
matrix equation involving transition matrix for Markov Chain methodology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_cdf_MC(n_grid, R, r, h, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_cdf_MC_+3A_n_grid">n_grid</code></td>
<td>
<p>Number of state spaces used to discretize the outcome space (when <code>method = "MC"</code>)
or number of grid points used for trapezoidal integration (when <code>method = "SPRT"</code>).
Increasing this number improves accuracy, but can also significantly increase computation time.</p>
</td></tr>
<tr><td><code id="bernoulli_cdf_MC_+3A_r">R</code></td>
<td>
<p>Transition probability matrix obtained from <code>calc_MC_trans_matrix</code></p>
</td></tr>
<tr><td><code id="bernoulli_cdf_MC_+3A_h">h</code></td>
<td>
<p>Control limit for the Bernoulli CUSUM</p>
</td></tr>
</table>

<hr>
<h2 id='bernoulli_control_limit'>Determine control limits for the Bernoulli CUSUM by simulation</h2><span id='topic+bernoulli_control_limit'></span>

<h3>Description</h3>

<p>This function can be used to determine control limits for the
Bernoulli CUSUM (<code><a href="#topic+bernoulli_cusum">bernoulli_cusum</a></code>) procedure by
restricting the type I error <code>alpha</code> of the
procedure over <code>time</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_control_limit(time, alpha = 0.05, followup, psi, n_sim = 200,
  glmmod, baseline_data, theta, p0, p1, h_precision = 0.01, seed = 1041996,
  pb = FALSE, assist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_control_limit_+3A_time">time</code></td>
<td>
<p>A numeric value over which the type I error <code>alpha</code> must be restricted.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_alpha">alpha</code></td>
<td>
<p>A proportion between 0 and 1 indicating the required maximal type I error.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_followup">followup</code></td>
<td>
<p>The value of the follow-up time to be used to determine event time.
Event time will be equal to <code>entrytime + followup</code> for each subject.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_psi">psi</code></td>
<td>
<p>A numeric value indicating the estimated Poisson arrival rate of subjects
at their respective units. Can be determined using
<code><a href="#topic+parameter_assist">parameter_assist()</a></code>.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_n_sim">n_sim</code></td>
<td>
<p>An integer value indicating the amount of units to generate for the
determination of the control limit. Larger values yield more precise control limits,
but increase computation times. Default is 200.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_baseline_data">baseline_data</code></td>
<td>
<p>(optional): A <code>data.frame</code> used for covariate resampling
with rows representing subjects and at least the
following named columns: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment. Can only be specified
in combination with <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the chart will try to detect an increase
in hazard ratio (upper one-sided). If <code class="reqn">\theta &lt; 0</code>,
the chart will look for a decrease in hazard ratio (lower one-sided).
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_p1">p1</code></td>
<td>
<p>The alternative hypothesis failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_h_precision">h_precision</code></td>
<td>
<p>(optional): A numerical value indicating how precisely the control limit
should be determined. By default, control limits will be determined up to 2 significant digits.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_seed">seed</code></td>
<td>
<p>(optional): A numeric seed for survival time generation.
Default is 01041996 (my birthday).</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_pb">pb</code></td>
<td>
<p>(optional): A boolean indicating whether a progress bar should
be shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bernoulli_control_limit_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs 3 steps to determine a suitable control limit.
</p>

<ul>
<li><p> Step 1: Generates <code>n_sim</code> in-control units (failure rate as baseline).
If <code>data</code> is provided, subject covariates are resampled from the data set.
</p>
</li>
<li><p> Step 2: Determines chart values for all simulated units.
</p>
</li>
<li><p> Step 3: Determines control limits such that at most a proportion <code>alpha</code>
of all units cross the control limit.
</p>
</li></ul>
<p> The generated data as well as the charts are also returned in the output.
</p>


<h3>Value</h3>

<p>A list containing three components:
</p>

<ul>
<li> <p><code>call</code>: the call used to obtain output;
</p>
</li>
<li> <p><code>charts</code>: A list of length <code>n_sim</code> containing the constructed charts;
</p>
</li>
<li> <p><code>data</code>: A <code>data.frame</code> containing the in-control generated data.
</p>
</li>
<li> <p><code>h</code>: Determined value of the control limit.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bernoulli_cusum">bernoulli_cusum</a></code>
</p>
<p>Other control limit simulation: 
<code><a href="#topic+bk_control_limit">bk_control_limit</a>()</code>,
<code><a href="#topic+cgr_control_limit">cgr_control_limit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We consider patient outcomes 100 days after their entry into the study.
followup &lt;- 100

#Determine a risk-adjustment model using a generalized linear model.
#Outcome (failure within 100 days) is regressed on the available covariates:
exprfitber &lt;- as.formula("(survtime &lt;= followup) &amp; (censorid == 1)~ age + sex + BMI")
glmmodber &lt;- glm(exprfitber, data = surgerydat, family = binomial(link = "logit"))

#Determine control limit restricting type I error to 0.1 over 500 days
#using the risk-adjusted glm constructed on the baseline data.
a &lt;- bernoulli_control_limit(time = 500, alpha = 0.1, followup = followup,
 psi = 0.5, n_sim = 10, theta = log(2), glmmod = glmmodber, baseline_data = surgerydat)

print(a$h)
</code></pre>

<hr>
<h2 id='bernoulli_cusum'>Risk-adjusted Bernoulli CUSUM</h2><span id='topic+bernoulli_cusum'></span>

<h3>Description</h3>

<p>This function can be used to construct a risk-adjusted Bernoulli
CUSUM chart for survival data.
It requires the specification of one of the following combinations of parameters
as arguments to the function:
</p>

<ul>
<li> <p><code>glmmod</code> &amp; <code>theta</code>
</p>
</li>
<li> <p><code>p0</code> &amp; <code>theta</code>
</p>
</li>
<li> <p><code>p0</code> &amp; <code>p1</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_cusum(data, followup, glmmod, theta, p0, p1, h, stoptime, assist,
  twosided = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_cusum_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the following named columns for each subject:
</p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed)
(integer);</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment.</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_followup">followup</code></td>
<td>
<p>The value of the follow-up time to be used to determine event time.
Event time will be equal to <code>entrytime + followup</code> for each subject.</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the chart will try to detect an increase
in hazard ratio (upper one-sided). If <code class="reqn">\theta &lt; 0</code>,
the chart will look for a decrease in hazard ratio (lower one-sided).
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_p1">p1</code></td>
<td>
<p>The alternative hypothesis failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_h">h</code></td>
<td>
<p>(optional): Control limit to be used for the procedure.</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_stoptime">stoptime</code></td>
<td>
<p>(optional): Time after which the value of the chart should no longer be determined.</p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
<tr><td><code id="bernoulli_cusum_+3A_twosided">twosided</code></td>
<td>
<p>(optional): Should a two-sided Bernoulli CUSUM be constructed?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bernoulli CUSUM chart is given by
</p>
<p style="text-align: center;"><code class="reqn">S_n = \max(0, S_{n-1} + W_n),</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">W_n = X_n \ln \left( \frac{p_1 (1-p_0)}{p_0(1-p_1)}  \right) + \ln \left( \frac{1-p_1}{1-p_0} \right)</code>
</p>

<p>and <code class="reqn">X_n</code> is the outcome of the <code class="reqn">n</code>-th (chronological) subject in the data. In terms of the Odds Ratio:
</p>
<p style="text-align: center;"><code class="reqn">W_n = X_n \ln \left( e^\theta  \right) + \ln \left( \frac{1}{1-p_0 + e^\theta p_0} \right)</code>
</p>

<p>For a risk-adjusted procedure (when <code>glmmod</code> is specified), a patient specific baseline failure probability <code class="reqn">p_{0i}</code> is modelled using logistic regression first.
Instead of the standard practice of displaying patient numbering on the
x-axis, the time of outcome is displayed.
</p>


<h3>Value</h3>

<p>An object of class <code>bercusum</code> containing:
</p>

<ul>
<li> <p><code>CUSUM</code>: A <code>data.frame</code> containing the following named columns:
</p>

<dl>
<dt><code>time</code>:</dt><dd><p>times at which chart is constructed;</p>
</dd>
<dt><code>value</code>:</dt><dd><p>value of the chart at corresponding times;</p>
</dd>
<dt><code>numobs</code>:</dt><dd><p>number of observations at corresponding times.</p>
</dd>
</dl>

</li>
<li> <p><code>call</code>: the call used to obtain output;
</p>
</li>
<li> <p><code>glmmod</code>: coefficients of the <code><a href="stats.html#topic+glm">glm()</a></code> used
for risk-adjustment, if specified;
</p>
</li>
<li> <p><code>stopind</code>: indicator for whether the chart was stopped by the
control limit.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bercusum">plot.bercusum</a></code>, <code><a href="#topic+runlength.bercusum">runlength.bercusum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We consider patient outcomes 100 days after their entry into the study.
followup &lt;- 100
#Determine a risk-adjustment model using a generalized linear model.
#Outcome (failure within 100 days) is regressed on the available covariates:
exprfitber &lt;- as.formula("(survtime &lt;= followup) &amp; (censorid == 1)~ age + sex + BMI")
glmmodber &lt;- glm(exprfitber, data = surgerydat, family = binomial(link = "logit"))
#Construct the Bernoulli CUSUM on the 1st hospital in the data set.
bercus &lt;- bernoulli_cusum(data = subset(surgerydat, unit == 1), glmmod = glmmodber,
 followup = followup, theta = log(2))
#Plot the Bernoulli CUSUM
plot(bercus)
</code></pre>

<hr>
<h2 id='bernoulli_RL_cdf'>Cumulative distribution function (cdf) of Run Length for Bernoulli CUSUM</h2><span id='topic+bernoulli_RL_cdf'></span>

<h3>Description</h3>

<p>Calculate the cdf of the Run Length of the Bernoulli CUSUM,
starting from initial value between 0 and <code>h</code>, using Markov Chain methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli_RL_cdf(h, x, n_grid, glmmod, theta, theta_true, p0, p1,
  smooth_prob = FALSE, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_RL_cdf_+3A_h">h</code></td>
<td>
<p>Control limit for the Bernoulli CUSUM</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_x">x</code></td>
<td>
<p>Quantile at which to evaluate the cdf.</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_n_grid">n_grid</code></td>
<td>
<p>Number of state spaces used to discretize the outcome space (when <code>method = "MC"</code>)
or number of grid points used for trapezoidal integration (when <code>method = "SPRT"</code>).
Increasing this number improves accuracy, but can also significantly increase computation time.</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the average run length for the upper one-sided
Bernoulli CUSUM will be determined. If <code class="reqn">\theta &lt; 0</code>,
the average run length for the lower one-sided CUSUM will be determined.
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_theta_true">theta_true</code></td>
<td>
<p>The true log odds ratio <code class="reqn">\theta</code>, describing the
true increase in failure rate from the null-hypothesis. Default = log(1), indicating
no increase in failure rate.</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_p1">p1</code></td>
<td>
<p>The alternative hypothesis failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_smooth_prob">smooth_prob</code></td>
<td>
<p>Should the probability distribution of failure under the null distribution be smoothed?
Useful for small samples. Can only be TRUE when <code>glmmod</code> is supplied. Default = FALSE.</p>
</td></tr>
<tr><td><code id="bernoulli_RL_cdf_+3A_exact">exact</code></td>
<td>
<p>Should the cdf be determined exactly (TRUE), or approximately
(FALSE)? The approximation works well for large <code>x</code>, and can cut computation
time significantly. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">K</code> denote the run length of the Bernoulli CUSUM with control limit <code>h</code>, then
this function can be used to evaluate <code class="reqn">P(K \leq x)</code>.
</p>
<p>The formula on page 543 of Brook &amp; Evans (1972)
is used if <code>exact = TRUE</code>. When <code>exact = FALSE</code>, formula (3.9) on
page 545 is used instead, approximating the transition matrix using its
Jordan canonical form. This can save computation time considerably, but is
not appropriate for small values of <code>x</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>Fr_0</code>: A numeric value indicating the probability of the run
length being smaller than <code>x</code>.
</p>
</li>
<li> <p><code>Fr</code>: A <code>data.frame</code> containing the cumulative distribution function of the run length
depending on the state in which the process starts (E_0, E_1, ..., E_n_grid-1)
</p>

<dl>
<dt><code>start_val</code>:</dt><dd><p>Starting value of the CUSUM, corresponding to the
discretized state spaces E_i;</p>
</dd>
<dt><code>P(K &lt;= x)</code>:</dt><dd><p>Value of the cdf at <code>x</code> for the CUSUM with
initial value <code>start_val</code>;</p>
</dd>
</dl>

</li>
<li> <p><code>R</code>: A transition probability <code>matrix</code> containing the transition
probabilities between states <code class="reqn">E_0, \ldots, E_{t-1}</code>.
<code class="reqn">R_{i,j}</code> is the transition probability from state i to state j.
</p>
</li></ul>
<p> The value of <code>ARL_0</code> will be printed to the console.
</p>


<h3>References</h3>

<p>Brook, D., &amp; Evans, D. A. (1972). An Approach to the Probability
Distribution of Cusum Run Length. Biometrika, 59(3), 539–549.
<a href="https://doi.org/10.2307/2334805">doi:10.2307/2334805</a>
</p>
<p>Steiner, S. H., Cook, R. J., Farewell, V. T., &amp; Treasure, T. (2000).
Monitoring surgical performance using risk-adjusted cumulative sum charts.
Biostatistics, 1(4), 441–452. <a href="https://doi.org/10.1093/biostatistics/1.4.441">doi:10.1093/biostatistics/1.4.441</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Determine a risk-adjustment model using a generalized linear model.
#Outcome (failure within 100 days) is regressed on the available covariates:
glmmodber &lt;- glm((survtime &lt;= 100) &amp; (censorid == 1)~ age + sex + BMI,
                  data = surgerydat, family = binomial(link = "logit"))
#Determine probability of run length being less than 600
prob600 &lt;- bernoulli_RL_cdf(h = 2.5, x = 600, n_grid = 200, glmmod = glmmodber, theta = log(2))
</code></pre>

<hr>
<h2 id='bk_control_limit'>Determine control limits for BK-CUSUM by simulation</h2><span id='topic+bk_control_limit'></span>

<h3>Description</h3>

<p>This function can be used to determine control limits for the
BK-CUSUM (<code><a href="#topic+bk_cusum">bk_cusum</a></code>) procedure by restricting the type I error <code>alpha</code> of the
procedure over <code>time</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bk_control_limit(time, alpha = 0.05, psi, n_sim = 200, theta, coxphmod,
  baseline_data, cbaseh, inv_cbaseh, interval = c(0, 9e+12),
  h_precision = 0.01, seed = 1041996, pb = FALSE, chartpb = FALSE,
  assist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bk_control_limit_+3A_time">time</code></td>
<td>
<p>A numeric value over which the type I error <code>alpha</code> must be restricted.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_alpha">alpha</code></td>
<td>
<p>A proportion between 0 and 1 indicating the required maximal type I error.
Default is 0.05.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_psi">psi</code></td>
<td>
<p>A numeric value indicating the estimated Poisson arrival rate of subjects
at their respective units. Can be determined using
<code><a href="#topic+parameter_assist">parameter_assist()</a></code>.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_n_sim">n_sim</code></td>
<td>
<p>An integer value indicating the amount of units to generate for the
determination of the control limit. Larger values yield more precise control limits,
but increase computation times. Default is 200.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_theta">theta</code></td>
<td>
<p>The expected log-hazard ratio <code class="reqn">\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the chart will try to detect an increase
in hazard ratio (upper one-sided). If <code class="reqn">\theta &lt; 0</code>,
the chart will look for a decrease in hazard ratio (lower one-sided).</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_coxphmod">coxphmod</code></td>
<td>
<p>A Cox proportional hazards regression model as
produced by
the function <code><a href="survival.html#topic+coxph">coxph()</a></code>. Suggested: <br />
<code>coxph(Surv(survtime, censorid) ~ covariates, data = data)</code>. <br />
Alternatively, a list with the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_baseline_data">baseline_data</code></td>
<td>
<p>(optional): A <code>data.frame</code> used for covariate resampling
with rows representing subjects and at least the
following named columns: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment. Can only be specified
in combination with <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_cbaseh">cbaseh</code></td>
<td>
<p>A function that returns the unadjusted cumulative
baseline hazard <code class="reqn">H_0(t)</code>. If <code>cbaseh</code> is missing but
<code>coxphmod</code> has been
specified as a survival object, this baseline hazard rate will be determined
using the provided <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_inv_cbaseh">inv_cbaseh</code></td>
<td>
<p>(optional): A function that returns the unadjusted inverse cumulative
baseline
hazard <code class="reqn">H^{-1}_0(t)</code>. If <code>inv_cbaseh</code> is missing, it will be
determined from <code>cbaseh</code> numerically.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_interval">interval</code></td>
<td>
<p>(optional): Interval in which survival times should be solved for numerically.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_h_precision">h_precision</code></td>
<td>
<p>(optional): A numerical value indicating how precisely the control limit
should be determined. By default, control limits will be determined up to 2 significant digits.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_seed">seed</code></td>
<td>
<p>(optional): A numeric seed for survival time generation. Default
is 01041996 (my birthday).</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_pb">pb</code></td>
<td>
<p>(optional): A boolean indicating whether a progress bar should
be shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_chartpb">chartpb</code></td>
<td>
<p>(optional): A boolean indicating whether progress bars should
be displayed for the constructions of the charts. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bk_control_limit_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs 3 steps to determine a suitable control limit.
</p>

<ul>
<li><p> Step 1: Generates <code>n_sim</code> in-control units (failure rate as baseline).
If <code>data</code> is provided, subject covariates are resampled from the data set.
</p>
</li>
<li><p> Step 2: Determines chart values for all simulated units.
</p>
</li>
<li><p> Step 3: Determines control limits such that at most a proportion <code>alpha</code>
of all units cross the control limit.
</p>
</li></ul>
<p> The generated data as well as the charts are also returned in the output.
</p>


<h3>Value</h3>

<p>A list containing three components:
</p>

<ul>
<li> <p><code>call</code>: the call used to obtain output;
</p>
</li>
<li> <p><code>charts</code>: A list of length <code>n_sim</code> containing the constructed charts;
</p>
</li>
<li> <p><code>data</code>: A <code>data.frame</code> containing the in-control generated data.
</p>
</li>
<li> <p><code>h</code>: Determined value of the control limit.
</p>
</li>
<li> <p><code>achieved_alpha</code>: Achieved type I error on the sample of
<code>n_sim</code> simulated units.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bk_cusum">bk_cusum</a></code>
</p>
<p>Other control limit simulation: 
<code><a href="#topic+bernoulli_control_limit">bernoulli_control_limit</a>()</code>,
<code><a href="#topic+cgr_control_limit">cgr_control_limit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)

#Determine a cox proportional hazards model for risk-adjustment
exprfit &lt;- as.formula("Surv(survtime, censorid) ~ age + sex + BMI")
tcoxmod &lt;- coxph(exprfit, data= surgerydat)

#Determine a control limit restricting type I error to 0.1 over 500 days
#with specified cumulative hazard function without risk-adjustment
a &lt;- bk_control_limit(time = 500, alpha = 0.1, theta = log(2),
cbaseh = function(t) chaz_exp(t, lambda = 0.02),
inv_cbaseh = function(t) inv_chaz_exp(t, lambda = 0.02), psi = 0.5,
n_sim = 10)

#Determine a control limit restricting type I error to 0.1 over 500 days
#using the risk-adjusted cumulative hazard determined using coxph()
b &lt;- bk_control_limit(time = 500, alpha = 0.1, theta = log(2),
coxphmod = tcoxmod, psi = 0.5, n_sim = 10)

print(a$h)
print(b$h)
</code></pre>

<hr>
<h2 id='bk_cusum'>Continuous time BK-CUSUM</h2><span id='topic+bk_cusum'></span>

<h3>Description</h3>

<p>This function implements the BK-CUSUM procedure based on the
Biswas &amp; Kalbfleisch (2008) CUSUM. To construct the Biswas &amp; Kalbfleisch
(2008) CUSUM, set <code>C = 1</code> (years) or <code>C = 365</code> (days).
For detection purposes, it is sufficient
to determine the value of the chart at the times of failure. This can be
achieved by leaving <code>ctimes</code> unspecified.
The function requires the specification of <code>theta</code> and
has two vital parameters, at least one of which must be specified:
</p>

<ul>
<li><p><code>coxphmod</code>: Cox proportional hazards model to be used for
risk-adjustment. If <code>cbaseh</code> is not specified, it will be determined
from <code>coxphmod</code> numerically.
</p>
</li>
<li><p><code>cbaseh</code>: The cumulative baseline hazard rate to use for chart
construction. If specified with <code>coxphmod</code> missing, no risk-adjustment
will be performed
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bk_cusum(data, theta, coxphmod, cbaseh, ctimes, h, stoptime, C,
  twosided = FALSE, pb = FALSE, assist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bk_cusum_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with rows representing subjects and the
following named columns: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_theta">theta</code></td>
<td>
<p>The expected log-hazard ratio <code class="reqn">\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the chart will try to detect an increase
in hazard ratio (upper one-sided). If <code class="reqn">\theta &lt; 0</code>,
the chart will look for a decrease in hazard ratio (lower one-sided).</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_coxphmod">coxphmod</code></td>
<td>
<p>A Cox proportional hazards regression model as
produced by
the function <code><a href="survival.html#topic+coxph">coxph()</a></code>. Suggested: <br />
<code>coxph(Surv(survtime, censorid) ~ covariates, data = data)</code>. <br />
Alternatively, a list with the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bk_cusum_+3A_cbaseh">cbaseh</code></td>
<td>
<p>A function that returns the unadjusted cumulative
baseline hazard <code class="reqn">H_0(t)</code>. If <code>cbaseh</code> is missing but
<code>coxphmod</code> has been
specified as a survival object, this baseline hazard rate will be determined
using the provided <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_ctimes">ctimes</code></td>
<td>
<p>(optional): Vector of construction times at which the value of the chart should be
determined. When not specified, the chart is constructed at all failure times.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_h">h</code></td>
<td>
<p>(optional): Value of the control limit. The chart will only be
constructed until the value of the control limit has been reached or
surpassed.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_stoptime">stoptime</code></td>
<td>
<p>(optional): Time after which the value of the chart should no
longer be determined. Default = max(failure time). Useful when ctimes
has not been specified.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_c">C</code></td>
<td>
<p>(optional): A numeric value indicating how long after entering the study
patients should no longer influence the value of the chart. This is
equivalent to right-censoring every observation at time <code>entrytime</code> + C.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_twosided">twosided</code></td>
<td>
<p>(optional): A boolean indicating whether a two-sided CUSUM
should be constructed.
If <code>TRUE</code>, 2 CUSUM charts are determined. One to check for an increase
of <code class="reqn">e^\theta</code> and one for
a decrease of <code class="reqn">e^{-\theta}</code> in the hazard rate w.r.t.
the baseline hazard. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_pb">pb</code></td>
<td>
<p>(optional): A boolean indicating whether a progress bar should
be shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bk_cusum_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BK-CUSUM can be used to test the alternative hypothesis of an
instant change of fixed size <code class="reqn">e^\theta</code>
in the subject specific hazard rate from <code class="reqn">h_i(t)</code> to
<code class="reqn">h_i(t) e^\theta</code>. The parameter <code>C</code> can be used
to ignore the contributions of subjects, C time units after their entry
into the study.
The BK-CUSUM is constructed as
</p>
<p style="text-align: center;"><code class="reqn">G(t) = \max_{0 \leq k \leq t} \left( \theta N(k,t) - \left( e^\theta -1  \right) \Lambda(k,t)  \right),</code>
</p>

<p>where <code class="reqn">\theta</code> is the log expected hazard ratio,
</p>
<p style="text-align: center;"><code class="reqn">N(k,t) = N(t) - N(k)</code>
</p>

<p>with <code class="reqn">N(t)</code> the counting process of all failures at time t, and </p>
<p style="text-align: center;"><code class="reqn">\Lambda(k,t) = \Lambda(t) - \Lambda(k)</code>
</p>

<p>with <code class="reqn">\Lambda(t)</code> the summed cumulative intensity of all
subjects at time <code class="reqn">t</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bkcusum</code> containing:
</p>

<ul>
<li> <p><code>BK</code>: a <code>data.frame</code> containing the following named columns:
</p>

<dl>
<dt><code>time</code>:</dt><dd><p>times at which chart is constructed;</p>
</dd>
<dt><code>value</code>:</dt><dd><p>value of the chart at corresponding times.</p>
</dd>
</dl>

</li>
<li> <p><code>stopind</code>: indicator for whether the chart was stopped by
the control limit;
</p>
</li>
<li> <p><code>call</code>: the call used to obtain output;
</p>
</li>
<li> <p><code>h</code>: Specified value for the control limit.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>References</h3>

<p>Biswas P. and Kalbfleisch J.D. (2008), A risk-adjusted CUSUM in
continuous time based on the Cox Model, Statistics in medicine 27, 3452-3452.
<a href="https://doi.org/10.1002/sim.3216">doi:10.1002/sim.3216</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bkcusum">plot.bkcusum</a></code>, <code><a href="#topic+runlength.bkcusum">runlength.bkcusum</a></code>
</p>
<p>Other quality control charts: 
<code><a href="#topic+cgr_cusum">cgr_cusum</a>()</code>,
<code><a href="#topic+funnel_plot">funnel_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)
#Select only the data of the first hospital in the surgerydat data set
tdat &lt;- subset(surgerydat, unit == 1)

#We know that the cumulative baseline hazard in the data set is
#Exponential(0.01). If you don't know the cumulative baseline, we suggest
#leaving the cbaseh argument empty and determining a coxphmod (see help)
tcbaseh &lt;- function(t) chaz_exp(t, lambda = 0.01)

#Determine a risk-adjustment model using a Cox proportional hazards model.
#Outcome (survival) is regressed on the available covariates:
exprfit &lt;- Surv(survtime, censorid) ~ age + sex + BMI
tcoxmod &lt;- coxph(exprfit, data= surgerydat)

#Determine the values of the chart
bk &lt;- bk_cusum(data = tdat, theta = log(2), coxphmod = tcoxmod, cbaseh = tcbaseh, pb = TRUE)
#plot the BK-CUSUM (exact hazard)
plot(bk)

#Alternatively, cbaseh can be left empty when specifying coxphmod through coxph()
bk_cox &lt;- bk_cusum(data = tdat, theta = log(2), coxphmod = tcoxmod, pb = TRUE)
#plot the BK-CUSUM (estimated hazard from coxph)
plot(bk_cox)
</code></pre>

<hr>
<h2 id='breast'>Survival after breast cancer surgery</h2><span id='topic+breast'></span>

<h3>Description</h3>

<p>Data about patient survival after their breast cancer surgery procedure
performed at one of the 15 units participating in a cancer treatment study.
The data is based on a trial performed at the European Organisation for
Research and Treatment of Cancer (EORTC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breast
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2663 rows and 11 variables:
</p>

<dl>
<dt>entrytime</dt><dd><p>Chronological time of entry of patient into study/time of surgery (numeric)</p>
</dd>
<dt>survtime</dt><dd><p>Time from entry until failure of patient (numeric)</p>
</dd>
<dt>censorid</dt><dd><p>Censoring indicator (0 - right censored, 1 - observed) (integer)</p>
</dd>
<dt>unit</dt><dd><p>Unit number at which patient received treatment (integer)</p>
</dd>
<dt>var1-7</dt><dd><p>Covariates associated with patient (factor)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Based on trial data from the European Organisation for Research and
Treatment of Cancer, <a href="https://www.eortc.org/">https://www.eortc.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Determine the estimated arrival rate for all units in the data
arrival_rate(breast)

#Plot Quality Control charts for unit 11 in the study
library(survival)
phmodbreast &lt;- coxph(Surv(survtime, censorid) ~ . - entrytime - unit ,
data = breast)
glmmodbreast &lt;- glm((survtime &lt;= 36) &amp; (censorid == 1) ~ . - entrytime - unit,
 data = breast, family = binomial(link = "logit"))

par(mfrow = c(1, 3))
p1 &lt;- plot(cgr_cusum(data = subset(breast, unit == 11),  coxphmod = phmodbreast)) +
ggtitle("CGR-CUSUM")
p2 &lt;- plot(bk_cusum(data = subset(breast, unit == 11),  coxphmod = phmodbreast,
 theta = log(2))) + ggtitle("BK-CUSUM")
p3 &lt;- plot(bernoulli_cusum(data = subset(breast, unit == 11), followup = 36,
 glmmod = glmmodbreast, theta = log(2))) + ggtitle("Bernoulli CUSUM")
p4 &lt;- plot(funnel_plot(data = breast, glmmod = glmmodbreast, followup = 36 )) +
ggtitle("Funnel plot")

if(require("gridExtra")){
 grid.arrange(p1, p2, p3, p4, nrow = 2)
}

</code></pre>

<hr>
<h2 id='calc_MC_trans_matrix'>Transition probability matrix for Bernoulli CUSUM</h2><span id='topic+calc_MC_trans_matrix'></span>

<h3>Description</h3>

<p>Calculates the transition probability matrix for the Bernoulli
CUSUM described in Brook &amp; Evans (1972).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_MC_trans_matrix(h, n_grid, Wncdf, glmmod, p0, theta, theta_true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_MC_trans_matrix_+3A_h">h</code></td>
<td>
<p>Control limit for the Bernoulli CUSUM</p>
</td></tr>
<tr><td><code id="calc_MC_trans_matrix_+3A_n_grid">n_grid</code></td>
<td>
<p>Number of state spaces used to discretize the outcome space (when <code>method = "MC"</code>)
or number of grid points used for trapezoidal integration (when <code>method = "SPRT"</code>).
Increasing this number improves accuracy, but can also significantly increase computation time.</p>
</td></tr>
<tr><td><code id="calc_MC_trans_matrix_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="calc_MC_trans_matrix_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="calc_MC_trans_matrix_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the average run length for the upper one-sided
Bernoulli CUSUM will be determined. If <code class="reqn">\theta &lt; 0</code>,
the average run length for the lower one-sided CUSUM will be determined.
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="calc_MC_trans_matrix_+3A_theta_true">theta_true</code></td>
<td>
<p>The true log odds ratio <code class="reqn">\theta</code>, describing the
true increase in failure rate from the null-hypothesis. Default = log(1), indicating
no increase in failure rate.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_risk'>Calculate the Cox Proportional hazards relative risk associated
with the covariates of subjects</h2><span id='topic+calc_risk'></span>

<h3>Description</h3>

<p>This function can be used to calculate the change in the
relative risk of a subject pertaining to their covariates
under a specified Cox proportional hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_risk(data, coxphmod = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_risk_+3A_data">data</code></td>
<td>
<p>A data frame containing the covariates to be used
for risk-adjustment as named columns.</p>
</td></tr>
<tr><td><code id="calc_risk_+3A_coxphmod">coxphmod</code></td>
<td>
<p>(optional): A cox proportional hazards model generated using
<code><a href="survival.html#topic+coxph">coxph()</a></code> or a list containing:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The subject-specific relative risk is
<code class="reqn">e^{\beta  Z_i}</code>,
where <code class="reqn">\beta</code> is a vector of regression coefficients
and <code class="reqn">Z_i</code> a vector of covariates for subject i.
</p>


<h3>Value</h3>

<p>A vector of <code>nrow(data)</code> specifying the increased/decreased
risk of failure for each subject.
</p>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Small example data
crdat &lt;- data.frame(age = rnorm(10, 40, 5), BMI = rnorm(10, 24, 3))
#Example risk-adjustment list (can also specify coxphmod)
crlist &lt;- list(formula = as.formula("~age + BMI"), coefficients = c("age"= 0.02, "BMI"= 0.009))
#Calculate the increase or decrease of the relative risk for the subjects
#in crdat.
calc_risk(crdat, crlist)
</code></pre>

<hr>
<h2 id='calc_Wncdf'>Calculate cdf of singletons W_n for CUSUM</h2><span id='topic+calc_Wncdf'></span>

<h3>Description</h3>

<p>Internal function to calculate cdf of singletons <code class="reqn">W_n</code>
of the Bernoulli CUSUM chart. The cdf is used to create the transition matrix
when Markov Chain methodology is used or to determine the integral equation/probabilities
of a Wald test when integral equation or Kemp's methodology is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Wncdf(glmmod, theta, theta_true, p0, smooth_prob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_Wncdf_+3A_glmmod">glmmod</code></td>
<td>
<p>Generalized linear regression model used for risk-adjustment as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Suggested: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list containing the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="calc_Wncdf_+3A_theta">theta</code></td>
<td>
<p>The <code class="reqn">\theta</code> value used to specify the odds ratio
<code class="reqn">e^\theta</code> under the alternative hypothesis.
If <code class="reqn">\theta &gt;= 0</code>, the average run length for the upper one-sided
Bernoulli CUSUM will be determined. If <code class="reqn">\theta &lt; 0</code>,
the average run length for the lower one-sided CUSUM will be determined.
Note that </p>
<p style="text-align: center;"><code class="reqn">p_1 = \frac{p_0 e^\theta}{1-p_0 +p_0 e^\theta}.</code>
</p>
</td></tr>
<tr><td><code id="calc_Wncdf_+3A_theta_true">theta_true</code></td>
<td>
<p>The true log odds ratio <code class="reqn">\theta</code>, describing the
true increase in failure rate from the null-hypothesis. Default = log(1), indicating
no increase in failure rate.</p>
</td></tr>
<tr><td><code id="calc_Wncdf_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.</p>
</td></tr>
<tr><td><code id="calc_Wncdf_+3A_smooth_prob">smooth_prob</code></td>
<td>
<p>Should the probability distribution of failure under the null distribution be smoothed?
Useful for small samples. Can only be TRUE when <code>glmmod</code> is supplied. Default = FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='cgr_control_limit'>Determine control limits for CGR-CUSUM by simulation</h2><span id='topic+cgr_control_limit'></span>

<h3>Description</h3>

<p>This function can be used to determine control limits for the
CGR-CUSUM (<code><a href="#topic+cgr_cusum">cgr_cusum</a></code>) procedure by restricting the type I error <code>alpha</code> of the
procedure over <code>time</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgr_control_limit(time, alpha = 0.05, psi, n_sim = 20, coxphmod,
  baseline_data, cbaseh, inv_cbaseh, interval = c(0, 9e+12),
  h_precision = 0.01, ncores = 1, seed = 1041996, pb = FALSE,
  chartpb = FALSE, detection = "upper", maxtheta = log(6), assist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cgr_control_limit_+3A_time">time</code></td>
<td>
<p>A numeric value over which the type I error <code>alpha</code> must be restricted.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_alpha">alpha</code></td>
<td>
<p>A proportion between 0 and 1 indicating the required maximal type I error.
Default is 0.05.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_psi">psi</code></td>
<td>
<p>A numeric value indicating the estimated Poisson arrival rate of subjects
at their respective units. Can be determined using
<code><a href="#topic+parameter_assist">parameter_assist()</a></code>.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_n_sim">n_sim</code></td>
<td>
<p>An integer value indicating the amount of units to generate for the
determination of the control limit. Larger values yield more precise control limits,
but greatly increase computation times. Default is 20.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_coxphmod">coxphmod</code></td>
<td>
<p>(optional): A cox proportional hazards regression model as
produced by
the function <code><a href="survival.html#topic+coxph">coxph()</a></code>. Suggested: <br />
<code>coxph(Surv(survtime, censorid) ~ covariates, data = baseline_data)</code>. <br />
Alternatively, a list with the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_baseline_data">baseline_data</code></td>
<td>
<p>(optional): A <code>data.frame</code> used for covariate resampling
with rows representing subjects and at least the
following named columns: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment. Can only be specified
in combination with <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_cbaseh">cbaseh</code></td>
<td>
<p>(optional): A function that returns the unadjusted cumulative
baseline hazard <code class="reqn">H_0(t)</code>. If <code>cbaseh</code> is missing but
<code>coxphmod</code> has been
specified as a survival object, this baseline hazard rate will be determined
using the provided <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_inv_cbaseh">inv_cbaseh</code></td>
<td>
<p>(optional): A function that returns the unadjusted inverse cumulative
baseline
hazard <code class="reqn">H^{-1}_0(t)</code>. If <code>inv_cbaseh</code> is missing, it will be
determined from <code>cbaseh</code> numerically.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_interval">interval</code></td>
<td>
<p>(optional): Interval in which survival times should be solved for numerically.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_h_precision">h_precision</code></td>
<td>
<p>(optional): A numerical value indicating how precisely the control limit
should be determined. By default, control limits will be determined up to 2 significant digits.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_ncores">ncores</code></td>
<td>
<p>(optional): Number of cores to use to parallelize the computation of the
CGR-CUSUM charts. If ncores = 1 (default), no parallelization is done. You
can use <code><a href="parallel.html#topic+detectCores">detectCores()</a></code> to check how many
cores are available on your computer.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_seed">seed</code></td>
<td>
<p>(optional): A numeric seed for survival time generation. Default = my birthday.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_pb">pb</code></td>
<td>
<p>(optional): A boolean indicating whether a progress bar should
be shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_chartpb">chartpb</code></td>
<td>
<p>(optional): A boolean indicating whether progress bars should
be displayed for the constructions of the charts. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_detection">detection</code></td>
<td>
<p>Should the control limit be determined for an
<code>"upper"</code> or <code>"lower"</code> CGR-CUSUM? Default is <code>"upper"</code>.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_maxtheta">maxtheta</code></td>
<td>
<p>(optional): Maximum value of maximum likelihood estimate for
parameter <code class="reqn">\theta</code>. Default is <code>log(6)</code>, meaning that
at most a 6 times increase/decrease in the odds/hazard ratio is expected.</p>
</td></tr>
<tr><td><code id="cgr_control_limit_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs 3 steps to determine a suitable control limit.
</p>

<ul>
<li><p> Step 1: Generates <code>n_sim</code> in-control units (failure rate as baseline).
If <code>data</code> is provided, subject covariates are resampled from the data set.
</p>
</li>
<li><p> Step 2: Determines chart values for all simulated units.
</p>
</li>
<li><p> Step 3: Determines control limits such that at most a proportion <code>alpha</code>
of all units cross the control limit.
</p>
</li></ul>
<p> The generated data as well as the charts are also returned in the output.
</p>


<h3>Value</h3>

<p>A list containing three components:
</p>

<ul>
<li> <p><code>call</code>: the call used to obtain output;
</p>
</li>
<li> <p><code>charts</code>: A list of length <code>n_sim</code> containing the constructed charts;
</p>
</li>
<li> <p><code>data</code>: A <code>data.frame</code> containing the in-control generated data.
</p>
</li>
<li> <p><code>h</code>: Determined value of the control limit.
</p>
</li>
<li> <p><code>achieved_alpha</code>: Achieved type I error on the sample of
<code>n_sim</code> simulated units.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgr_cusum">cgr_cusum</a></code>
</p>
<p>Other control limit simulation: 
<code><a href="#topic+bernoulli_control_limit">bernoulli_control_limit</a>()</code>,
<code><a href="#topic+bk_control_limit">bk_control_limit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(survival)

#Determine a cox proportional hazards model for risk-adjustment
exprfit &lt;- as.formula("Surv(survtime, censorid) ~ age + sex + BMI")
tcoxmod &lt;- coxph(exprfit, data= surgerydat)

#Determine a control limit restricting type I error to 0.1 over 500 days
#with specified cumulative hazard function without risk-adjustment
a &lt;- cgr_control_limit(time = 500, alpha = 0.1, cbaseh = function(t) chaz_exp(t, lambda = 0.02),
inv_cbaseh = function(t) inv_chaz_exp(t, lambda = 0.02), psi = 0.5, n_sim = 10)


#Determine a control limit restricting type I error to 0.1 over 500 days
#using the risk-adjusted cumulative hazard found using coxph()
b &lt;- cgr_control_limit(time = 500, alpha = 0.1, coxphmod = tcoxmod, psi = 0.5, n_sim = 10,
baseline_data = subset(surgerydat, unit == 1))

print(a$h)
print(b$h)

</code></pre>

<hr>
<h2 id='cgr_cusum'>Continuous time Generalized Rapid response CUSUM (CGR-CUSUM)</h2><span id='topic+cgr_cusum'></span>

<h3>Description</h3>

<p>This function performs the CGR-CUSUM procedure
described in Gomon et al. (2022). For detection purposes, it suffices
to determine the value of the chart at the times of failure. This can be
achieved by leaving <code>ctimes</code> unspecified.
The function has two vital parameters, at least one of which must be specified:
</p>

<ul>
<li><p><code>coxphmod</code>: Cox proportional hazards model to be used for
risk-adjustment. If <code>cbaseh</code> is not specified, it will be determined
from <code>coxphmod</code> numerically.
</p>
</li>
<li><p><code>cbaseh</code>: The cumulative baseline hazard rate to use for chart
construction. If specified with <code>coxphmod</code> missing, no risk-adjustment
will be performed
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cgr_cusum(data, coxphmod, cbaseh, ctimes, h, stoptime, C, pb = FALSE,
  ncores = 1, cmethod = "memory", dependencies, detection = "upper",
  assist, maxtheta = log(6))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cgr_cusum_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with rows representing subjects and the
following named columns: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_coxphmod">coxphmod</code></td>
<td>
<p>A Cox proportional hazards regression model as
produced by
the function <code><a href="survival.html#topic+coxph">coxph()</a></code>. Suggested: <br />
<code>coxph(Surv(survtime, censorid) ~ covariates, data = data)</code>. <br />
Alternatively, a list with the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_cbaseh">cbaseh</code></td>
<td>
<p>A function that returns the unadjusted cumulative
baseline hazard <code class="reqn">H_0(t)</code>. If <code>cbaseh</code> is missing but
<code>coxphmod</code> has been
specified as a survival object, this baseline hazard rate will be determined
using the provided <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_ctimes">ctimes</code></td>
<td>
<p>(optional): Vector of construction times at which the value of the chart should be
determined. When not specified, the chart is constructed at all failure times.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_h">h</code></td>
<td>
<p>(optional): Value of the control limit. The chart will only be
constructed until the value of the control limit has been reached or
surpassed.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_stoptime">stoptime</code></td>
<td>
<p>(optional): Time after which the value of the chart should no
longer be determined. Default = max(failure time). Useful when ctimes
has not been specified.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_c">C</code></td>
<td>
<p>(optional): A numeric value indicating how long after entering the study
patients should no longer influence the value of the chart. This is
equivalent to right-censoring every observation at time <code>entrytime</code> + C.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_pb">pb</code></td>
<td>
<p>(optional): A boolean indicating whether a progress bar should
be shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use to parallelize the computation of the
CGR-CUSUM chart. If ncores = 1 (default), no parallelization is done. You
can use <code><a href="parallel.html#topic+detectCores">detectCores()</a></code> to check how many
cores are available on your computer.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_cmethod">cmethod</code></td>
<td>
<p>Method to calculate chart values. One of the following:
</p>

<ul>
<li> <p><code>"memory"</code> (default): matrix formulation of the problem
(faster for high volume/long time construction)
</p>
</li>
<li> <p><code>"CPU"</code> calculates the value of the CGR-CUSUM for every
time point from scratch. Recommended for small data volume
(lower initialization time).
</p>
</li></ul>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_dependencies">dependencies</code></td>
<td>
<p>(optional): When <code>ncores &gt; 1</code>, specify a list of
variables/functions/other dependencies to be exported to the core clusters
for parallel computation.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_detection">detection</code></td>
<td>
<p>Should an <code>"upper"</code> or <code>"lower"</code> CGR-CUSUM be
constructed. Upper CUSUMs can be used to monitor for an increase in the
failure rate, while lower CUSUMs can be used to monitor for a decrease in the
failure rate.</p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
<tr><td><code id="cgr_cusum_+3A_maxtheta">maxtheta</code></td>
<td>
<p>(optional): Maximum value the maximum likelihood estimate for
parameter <code class="reqn">\theta</code> can take. If <code>detection = "lower"</code>, <code>-abs(theta)</code>
will be the minimum value the maximum likelihood estimate for
parameter <code class="reqn">\theta</code> can take.  Default is <code>log(6)</code>, meaning that
at most a 6 times increase/decrease in the odds/hazard ratio is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CGR-CUSUM can be used to test for a change of unknown positive fixed size <code class="reqn">\theta</code>
in the subject-specific hazard rate from <code class="reqn">h_i(t)</code> to <code class="reqn">h_i(t) e^\theta</code>
starting from some unknown subject <code class="reqn">\nu</code>. The starting time of the first subject
who had an increase in failure rate as well as the estimated increase in the
hazard rate are shown in the output.
The CGR-CUSUM is determined as
</p>
<p style="text-align: center;"><code class="reqn">\max_{1 \leq \nu \leq n} \left( \hat{\theta}_{\geq \nu}(t) N_{\geq \nu}(t) - \left( \exp\left( \hat{\theta}_{\geq \nu}(t) \right) - 1 \right) \Lambda_{\geq \nu}(t)\right),</code>
</p>

<p>where  </p>
<p style="text-align: center;"><code class="reqn">N(\geq \nu)(t) = \sum_{i \geq \nu} N_i(t),</code>
</p>

<p>with <code class="reqn">N_i(t)</code> the counting process for the failure at time <code class="reqn">t</code> of subject <code class="reqn">i</code>
and </p>
<p style="text-align: center;"><code class="reqn">\Lambda_{\geq \nu}(t) = \sum_{i \geq \nu} \Lambda_i(t),</code>
</p>

<p>where <code class="reqn">\Lambda_i(t)</code> is the cumulative intensity of subject <code class="reqn">i</code> at time <code class="reqn">t</code>.
</p>
<p>When <code>maxtheta</code> is specified, the maximum likelihood estimate of <code class="reqn">\theta</code>
is restricted to either <code>abs(maxtheta)</code> (upper sided CGR-CUSUM) or
<code>-abs(maxtheta)</code> (lower sided CGR-CUSUM). Choosing this value smaller leads to smaller
control limits and therefore quicker detection times, but can cause delays in
detection if the true increase in failure rate is larger than the cut-off. The
default of expecting at most a 6 times increase in hazard/odds ratio can therefore
be the wrong choice for your intended application area. If unsure, the most conservative
choice is to take <code>maxtheta = Inf</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;cgrcusum&quot; containing:
</p>

<ul>
<li> <p><code>CGR</code>: a <code>data.frame</code> with named columns:
</p>

<dl>
<dt><code>time</code>:</dt><dd><p>times at which chart is constructed;</p>
</dd>
<dt><code>value</code>:</dt><dd><p>value of the chart at corresponding times;</p>
</dd>
<dt><code>exp_theta_t</code>:</dt><dd><p>value of MLE <code class="reqn">e^{\theta_t}</code>;</p>
</dd>
<dt><code>S_nu</code></dt><dd><p>time from which patients are considered for constructing the chart.</p>
</dd>
</dl>

</li>
<li> <p><code>call</code>: the call used to obtain output;
</p>
</li>
<li> <p><code>stopind</code>: indicator for whether the chart was stopped by
the control limit;
</p>
</li>
<li> <p><code>h</code>: Specified value for the control limit.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>References</h3>

<p>Gomon, D. and Putter, H. and Nelissen, R. G. H. H. and van der Pas, S. (2022),
CGR-CUSUM: A Continuous time Generalized Rapid Response Cumulative Sum chart, Biostatistics
<a href="https://doi.org/10.1093/biostatistics/kxac041">doi:10.1093/biostatistics/kxac041</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cgrcusum">plot.cgrcusum</a></code>, <code><a href="#topic+runlength.cgrcusum">runlength.cgrcusum</a></code>
</p>
<p>Other quality control charts: 
<code><a href="#topic+bk_cusum">bk_cusum</a>()</code>,
<code><a href="#topic+funnel_plot">funnel_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)
#Select only the data of the first year of the first hospital in the surgerydat data set
tdat &lt;- subset(surgerydat, unit == 1 &amp; entrytime &lt; 365)

#We know that the cumulative baseline hazard in the data set is
#Exponential(0.01). If you don't know the cumulative baseline, we suggest
#leaving the cbaseh argument empty and determining a coxphmod (see help)
tcbaseh &lt;- function(t) chaz_exp(t, lambda = 0.01)

#Determine a risk-adjustment model using a Cox proportional hazards model.
#Outcome (survival) is regressed on the available covariates:
exprfit &lt;- as.formula("Surv(survtime, censorid) ~ age + sex + BMI")
tcoxmod &lt;- coxph(exprfit, data= surgerydat)

#Determine the values of the chart
cgr &lt;- cgr_cusum(data = tdat, coxphmod = tcoxmod, cbaseh = tcbaseh, pb = TRUE)
#plot the CGR-CUSUM (exact hazard)
plot(cgr)

#Alternatively, cbaseh can be left empty when specifying coxphmod through coxph()
cgr_cox &lt;- cgr_cusum(data = tdat, coxphmod = tcoxmod, pb = TRUE)
#plot the CGR-CUSUM (estimated hazard from coxph)
plot(cgr_cox)

</code></pre>

<hr>
<h2 id='exp_hazards'>Exponential hazard, cumulative hazard and inverse cumulative hazard</h2><span id='topic+exp_hazards'></span><span id='topic+haz_exp'></span><span id='topic+chaz_exp'></span><span id='topic+inv_chaz_exp'></span>

<h3>Description</h3>

<p>Functions which return the hazard, cumulative
hazard and inverse cumulative hazard at time t for an exponential distribution
with parameter <code class="reqn">\lambda</code> and true hazard ratio <code class="reqn">\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haz_exp(t, lambda, mu = log(1))

chaz_exp(t, lambda, mu = log(1))

inv_chaz_exp(t, lambda, mu = log(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_hazards_+3A_t">t</code></td>
<td>
<p>time of evaluation.</p>
</td></tr>
<tr><td><code id="exp_hazards_+3A_lambda">lambda</code></td>
<td>
<p>parameter of the exponential distribution.</p>
</td></tr>
<tr><td><code id="exp_hazards_+3A_mu">mu</code></td>
<td>
<p>(optional) true excess hazard rate <code class="reqn">\mu</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hazard function of an exponential distribution is given by:
</p>
<p style="text-align: center;"><code class="reqn">h(t| \lambda, \mu) = \lambda e^\mu</code>
</p>

<p>The cumulative hazard (with true hazard ratio <code class="reqn">\mu</code>) is given by:
</p>
<p style="text-align: center;"><code class="reqn">H(t| \lambda, \mu) = \lambda t e^\mu</code>
</p>

<p>The inverse cumulative hazard (with true hazard ratio <code class="reqn">\mu</code>) by:
</p>
<p style="text-align: center;"><code class="reqn">H^{-1}(t| \lambda, \mu) = \frac{t}{\lambda e^\mu}</code>
</p>



<h3>Value</h3>

<p>Value of specified function at time <code class="reqn">t</code>.
</p>

<hr>
<h2 id='extract_hazard'>Extract (inverse) cumulative baseline hazard from Cox PH model</h2><span id='topic+extract_hazard'></span>

<h3>Description</h3>

<p>Extracts a function which returns the (inverse) cumulative
baseline hazard from a <code><a href="survival.html#topic+coxph">coxph()</a></code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_hazard(coxphmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_hazard_+3A_coxphmod">coxphmod</code></td>
<td>
<p>A call to <code><a href="survival.html#topic+coxph">coxph()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The baseline hazard is extracted from the <code><a href="survival.html#topic+coxph">coxph()</a></code>
call using the <code><a href="survival.html#topic+basehaz">basehaz()</a></code> function. The
baseline hazard function is then smoothed using
<code><a href="stats.html#topic+approxfun">approxfun()</a></code> to obtain the linear interpolant.
If required, the inverse baseline hazard is determined using root linear
interpolation. For this, a function written by Zheyuan Li (see references) is used.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>cbaseh</code>: A function which returns the cumulative baseline hazard
at specified time;
</p>
</li>
<li> <p><code>inv_cbaseh</code>: A function which returns the inverse cumulative
baseline hazard at specified time.
</p>
</li>
<li> <p><code>max_time</code>: maximal time at which <code>cbaseh</code> is known;
</p>
</li>
<li> <p><code>max_haz</code>: value of maximal hazard (at maximum time).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/users/4891738/zheyuan-li">Zheyuan Li:</a>
<a href="https://stackoverflow.com/questions/52650467/how-to-estimate-x-value-from-y-value-input-after-approxfun-in-r">How to estimate x value from y value input after approxfun in R?</a> (accessed: 09/10/2023)
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)
exprfit &lt;- as.formula("Surv(survtime, censorid) ~ age + sex + BMI")
tcoxmod &lt;- coxph(exprfit, data= surgerydat)
tcox_hazard_fcts &lt;- extract_hazard(tcoxmod)


</code></pre>

<hr>
<h2 id='funnel_plot'>Risk-adjusted funnel plot</h2><span id='topic+funnel_plot'></span>

<h3>Description</h3>

<p>This function allows to construct a risk-adjusted funnel plot
for comparing survival proportion between units, see Spiegelhalter (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funnel_plot(data, ctime, p0, glmmod, followup, predlim = c(0.95, 0.99),
  assist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funnel_plot_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with rows representing subjects and the
following named columns: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer);</p>
</dd>
<dt><code>unit</code>:</dt><dd><p>integer or character indicating which unit
(f.e. hospital) the observation belongs to.</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment.</p>
</td></tr>
<tr><td><code id="funnel_plot_+3A_ctime">ctime</code></td>
<td>
<p>Construction time at which the funnel plot
should be determined. Maximum possible time used when not specified.</p>
</td></tr>
<tr><td><code id="funnel_plot_+3A_p0">p0</code></td>
<td>
<p>The baseline failure probability at <code>entrytime + followup</code> for individuals.
If not specified, average failure proportion over whole data is used instead.</p>
</td></tr>
<tr><td><code id="funnel_plot_+3A_glmmod">glmmod</code></td>
<td>
<p>A generalized linear regression model as produced by
the function <code><a href="stats.html#topic+glm">glm()</a></code>. Recommended: <br />
<code>glm(as.formula("(survtime &lt;= followup) &amp; (censorid == 1) ~ covariates"), data = data)</code>. <br />
Alternatively, a list with the following elements:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="funnel_plot_+3A_followup">followup</code></td>
<td>
<p>The followup time for every individual. At what time
after subject entry do we consider the outcome?</p>
</td></tr>
<tr><td><code id="funnel_plot_+3A_predlim">predlim</code></td>
<td>
<p>A vector of confidence levels for the prediction limits of interest. Default is c(0.95, 0.99).</p>
</td></tr>
<tr><td><code id="funnel_plot_+3A_assist">assist</code></td>
<td>
<p>(optional): Output of the function <code><a href="#topic+parameter_assist">parameter_assist()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;funnelplot&quot; containing:
</p>

<ul>
<li> <p><code>data</code>: A <code>data.frame</code> containing:
</p>

<dl>
<dt><code>unit</code>:</dt><dd><p>unit number/name;</p>
</dd>
<dt><code>observed</code>:</dt><dd><p>observed number of failures at unit;</p>
</dd>
<dt><code>expected</code>:</dt><dd><p>expected (risk-adjusted) number of failures at unit;</p>
</dd>
<dt><code>numtotal</code></dt><dd><p>total number of individuals considered at this unit;</p>
</dd>
<dt><code>p</code>:</dt><dd><p>(risk-adjusted) proportion of failure at unit;</p>
</dd>
<dt><code>predlimels</code>:</dt><dd><p>worse/in-control/better performance than expected at
specified confidence levels.</p>
</dd>
</dl>

</li>
<li> <p><code>call</code>: the call used to obtain output
</p>
</li>
<li> <p><code>plotdata</code>: data used for plotting confidence intervals
</p>
</li>
<li> <p><code>predlim</code>: specified confidence level(s)
</p>
</li>
<li> <p><code>p0</code>: (Estimated) baseline failure probability
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>References</h3>

<p>Spiegelhalter D. J. (2005). Funnel plots for comparing
institutional performance. Statistics in medicine, 24(8), 1185-1202.
<a href="https://doi.org/10.1002/sim.1970">doi:10.1002/sim.1970</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.funnelplot">plot.funnelplot</a></code>, <code><a href="#topic+summary.funnelplot">summary.funnelplot</a></code>
</p>
<p>Other quality control charts: 
<code><a href="#topic+bk_cusum">bk_cusum</a>()</code>,
<code><a href="#topic+cgr_cusum">cgr_cusum</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Determine a risk-adjustment model using a generalized linear model.
#Outcome (survival in first 100 days) is regressed on the available covariates:
exprfitfunnel &lt;- as.formula("(survtime &lt;= 100) &amp; (censorid == 1)~ age + sex + BMI")
glmmodfun &lt;- glm(exprfitfunnel, data = surgerydat, family = binomial(link = "logit"))
#Determine the necessary values to produce a funnel plot
funnel &lt;- funnel_plot(data = surgerydat, ctime = 3*365, glmmod = glmmodfun, followup = 100)
#Produce a funnel plot!
plot(funnel)
## Not run: 
require(plotly)
#Create an interactive plot!
ggplotly(plot(funnel))

## End(Not run)
</code></pre>

<hr>
<h2 id='gen_arriv_times'>Generate arrival times according to a Poisson point process</h2><span id='topic+gen_arriv_times'></span>

<h3>Description</h3>

<p>This function can be used to generate arrival times for a Poisson point
process with rate psi up until time t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_arriv_times(psi, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_arriv_times_+3A_psi">psi</code></td>
<td>
<p>rate of the arrival process.</p>
</td></tr>
<tr><td><code id="gen_arriv_times_+3A_t">t</code></td>
<td>
<p>time until which arrivals should be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exponential(<code class="reqn">\psi</code>) interarrival times.
</p>


<h3>Value</h3>

<p>A vector of arrival times up until time t.
</p>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gen_arriv_times(psi = 0.3, t = 5)
gen_arriv_times(psi = 0.3, t = 20)
</code></pre>

<hr>
<h2 id='gen_surv_times'>Generate survival times</h2><span id='topic+gen_surv_times'></span>

<h3>Description</h3>

<p>Generate survival times according to hazard rate
<code class="reqn">h(t) \exp(\mu)</code> with <code class="reqn">h(t)</code> the hazard rate associated with the
specified inverse cumulative hazard rate <code>invchaz</code> and <code class="reqn">\mu</code> the
specified true hazard ratio <code>mu</code>. See Bender et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_surv_times(invchaz, mu = log(1), data, coxphmod = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_surv_times_+3A_invchaz">invchaz</code></td>
<td>
<p>the inverse cumulative (baseline) hazard rate to be used
for generating survival times. Must take vector inputs!</p>
</td></tr>
<tr><td><code id="gen_surv_times_+3A_mu">mu</code></td>
<td>
<p>the true hazard ratio used to generate survival times.</p>
</td></tr>
<tr><td><code id="gen_surv_times_+3A_data">data</code></td>
<td>
<p>an integer number of survival times to generate or
(in combination with coxphmod): a <code>data.frame</code> containing
subject covariates in named columns.</p>
</td></tr>
<tr><td><code id="gen_surv_times_+3A_coxphmod">coxphmod</code></td>
<td>
<p>(optional) a cox proportional hazards regression model as produced by
the function <code><a href="survival.html#topic+coxph">coxph()</a></code>. Standard practice: <br />
<code>coxph(Surv(survtime, censorid) ~ covariates, data = data)</code>. <br />
Alternatively, a list with:
</p>

<ul>
<li><p> $formula (~ covariates)
</p>
</li>
<li><p> $coefficients (named vector specifying risk adjustment coefficients
for covariates - names must be the same as in $formula and colnames of <code>data</code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes it is desirable to generate survival times from an
increased hazard rate </p>
<p style="text-align: center;"><code class="reqn">h(t, \mu) = h_0(t) e^\mu</code>
</p>

<p>with <code class="reqn">h_0</code> the baseline hazard rate. We call <code class="reqn">e^\mu</code> the true hazard ratio.
</p>


<h3>Value</h3>

<p>A vector of survival times from subject entry time.
</p>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>References</h3>

<p>Bender, R., Augustin, T., &amp; Blettner, M. (2005).
Generating survival times to simulate Cox proportional hazards models.
Statistics in Medicine, 24(11), 1713-1723. <a href="https://doi.org/10.1002/sim.2059">doi:10.1002/sim.2059</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gen_surv_times(invchaz = function(t) inv_chaz_exp(t, lambda = 0.01), data = 5)
</code></pre>

<hr>
<h2 id='generate_units'>Generate units with specified failure rate</h2><span id='topic+generate_units'></span>

<h3>Description</h3>

<p>Generate <code>n_sim</code> units with subjects arriving according to
a Poisson
process with rate <code>psi</code> until <code>time</code>. Failure rate is determined
either from <code>cbaseh</code> or <code>inv_cbaseh</code>, or from specified
<code>coxphmod</code>. Covariates will be resampled from <code>baseline_data</code> if
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_units(time, psi, n_sim = 20, cbaseh, inv_cbaseh, coxphmod = NULL,
  baseline_data, interval = c(0, 9e+12), mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_units_+3A_time">time</code></td>
<td>
<p>A numeric value indicating until what time from the start of the
study subjects can arrive.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_psi">psi</code></td>
<td>
<p>Poisson arrival rate for subjects.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_n_sim">n_sim</code></td>
<td>
<p>An integer indicating how many units should be generated.
Default is 20.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_cbaseh">cbaseh</code></td>
<td>
<p>A function returning the cumulative baseline hazard
at each relevant time point. Will be numerically inverted to generate
failure times. If
the inverse cumulative baseline hazard function is available, please specify
<code>inv_cbaseh</code> instead.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_inv_cbaseh">inv_cbaseh</code></td>
<td>
<p>A function returning the inverse cumulative baseline
hazard at each relevant time point.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_coxphmod">coxphmod</code></td>
<td>
<p>(optional): A cox proportional hazards model generated using
<code><a href="survival.html#topic+coxph">coxph()</a></code> or a list containing:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>a <code><a href="stats.html#topic+formula">formula()</a></code> in the form <code>~ covariates</code>;</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>a named vector specifying risk adjustment coefficients
for covariates. Names must be the same as in <code>formula</code> and colnames of <code>data</code>.</p>
</dd>
</dl>
<p> If both <code>cbaseh</code> and <code>inv_cbaseh</code> are missing, the hazard rate
will be determined from <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_baseline_data">baseline_data</code></td>
<td>
<p>(optional): A <code>data.frame</code> used for covariate resampling
with rows representing subjects and columns containing covariates to use for risk-adjustment.
Should only be specified in combination with <code>coxphmod</code>.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_interval">interval</code></td>
<td>
<p>(optional) A numeric vector of length 2 indicating in which
range of values the failure times of subjects should be determined. By default,
failure times will be restricted between 0 and 9e12.</p>
</td></tr>
<tr><td><code id="generate_units_+3A_mu">mu</code></td>
<td>
<p>(optional) The increased log hazard ratio at the generated units with
respect to the specified baseline hazard rate. Default is log(1) = 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a Poisson arrival process, inter-arrival times are exponentially
distributed with parameter <code>psi</code>. If <code>cbaseh</code> is specified,
the inverse baseline hazard will be determined using <code><a href="stats.html#topic+uniroot">uniroot()</a></code>.
The times of failure are then determined using <code><a href="#topic+gen_surv_times">gen_surv_times()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with rows representing subjects and the
following named columns:
</p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of subject entry into the study;</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>survival time of subject;</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator, 0 = censored, 1 = observed;</p>
</dd>
<dt><code>unit</code>:</dt><dd><p>unit number;</p>
</dd>
<dt><code>expmu</code>:</dt><dd><p>exponent of the log hazard ratio used to generate
survival times;</p>
</dd>
<dt><code>psival</code>:</dt><dd><p>arrival rate at unit;</p>
</dd>
<dt><code>covariates</code>:</dt><dd><p>covariates resampled from <code>baseline_data</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)
#Fit a Cox model
exprfit &lt;- as.formula("Surv(survtime, censorid) ~ age + sex + BMI")
tcoxmod &lt;- coxph(exprfit, data= surgerydat)

#Generate 30 hospitals with on average 2 patients per day arriving
#according to the Cox model determined above, with resampling from the
#original data set. The hazard rate at the hospitals is twice the baseline
#hazard.
generate_units(time = 50, psi = 2, n_sim = 30, coxphmod = tcoxmod,
baseline_data = surgerydat, mu = log(2))



</code></pre>

<hr>
<h2 id='interactive_plot'>Plot a list of CUSUM charts (interactive)</h2><span id='topic+interactive_plot'></span>

<h3>Description</h3>

<p>Create an interactive plot visualizing a combination of control charts
which can be created using this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactive_plot(x, unit_names, scale = FALSE, group_by = c("none", "unit",
  "type"), highlight = FALSE, manual_colors = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactive_plot_+3A_x">x</code></td>
<td>
<p>A list with each item containing one cumulative sum chart.</p>
</td></tr>
<tr><td><code id="interactive_plot_+3A_unit_names">unit_names</code></td>
<td>
<p>The unit names to be displayed in the interactive plot.
Must be of equal length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="interactive_plot_+3A_scale">scale</code></td>
<td>
<p>Should charts be scaled with respect to their control limit/
maximum value? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="interactive_plot_+3A_group_by">group_by</code></td>
<td>
<p>Character indicating how to group the CUSUM charts in the plot.
Possible values are <code>c("none", "unit", "type")</code>. Default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="interactive_plot_+3A_highlight">highlight</code></td>
<td>
<p>Should charts be highlighted on hover? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="interactive_plot_+3A_manual_colors">manual_colors</code></td>
<td>
<p>A character vector specifying which colors to use
for the units in the data. By default, the &quot;Set2&quot; color set from
<code><a href="grDevices.html#topic+palette">palette()</a></code> will be used.</p>
</td></tr>
<tr><td><code id="interactive_plot_+3A_...">...</code></td>
<td>
<p>Further plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interactive plot will be produced in the current graphics device.
For more information on the possibilities for interaction, see <a href="https://plotly.com/r/">https://plotly.com/r/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgr_cusum">cgr_cusum</a></code>, <code><a href="#topic+bk_cusum">bk_cusum</a></code>, <code><a href="#topic+bernoulli_cusum">bernoulli_cusum</a></code>, <code><a href="#topic+funnel_plot">funnel_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(survival)
#Extract data to construct CUSUM charts on
tdat &lt;- subset(surgerydat, unit == 1 &amp; entrytime &lt; 365)
tdat2 &lt;- subset(surgerydat, unit == 2 &amp; entrytime &lt; 365)

#Determine model parameters
followup &lt;- 100
tcbaseh &lt;- function(t) chaz_exp(t, lambda = 0.01)
exprfit &lt;- as.formula("Surv(survtime, censorid) ~ age + sex + BMI")
tcoxmod &lt;- coxph(exprfit, data= surgerydat)
exprfitber &lt;- as.formula("(survtime &lt;= followup) &amp; (censorid == 1)~ age + sex + BMI")
glmmodber &lt;- glm(exprfitber, data = surgerydat, family = binomial(link = "logit"))


#Construct the charts
cgr &lt;- cgr_cusum(data = tdat, coxphmod = tcoxmod, cbaseh = tcbaseh, pb = TRUE)
cgr$h &lt;- 8.29
bk &lt;- bk_cusum(data = tdat, theta = log(2), coxphmod = tcoxmod, cbaseh = tcbaseh, pb = TRUE)
bk$h &lt;- 6.23
bercus &lt;- bernoulli_cusum(data = subset(surgerydat, unit == 1), glmmod = glmmodber,
followup = followup, theta = log(2))
bercus$h &lt;- 3.36
bk2 &lt;- bk_cusum(data = tdat2, theta = log(2), coxphmod = tcoxmod, cbaseh = tcbaseh, pb = TRUE)
bk2$h &lt;- 6.23

#Create the plot
interactive_plot(list(cgr, bk, bercus, bk2), unit_names =
c("hosp1", "hosp1", "hosp1", "hosp2"))

</code></pre>

<hr>
<h2 id='parameter_assist'>Assist users in parameter selection</h2><span id='topic+parameter_assist'></span>

<h3>Description</h3>

<p>This function can be used to determine some of the vital
parameters used to construct control charts in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_assist(baseline_data, data, formula, followup, theta = log(2),
  time, alpha = 0.05, maxtheta = log(6))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameter_assist_+3A_baseline_data">baseline_data</code></td>
<td>
<p>A <code>data.frame</code> for determining a baseline performance
metric. Rows should represent subjects and the
following named columns should be present: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment.</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with data on which the user wants to construct
quality control charts.
Rows should represent subjects and the
following named columns should be present: </p>

<dl>
<dt><code>entrytime</code>:</dt><dd><p>time of entry into study (numeric);</p>
</dd>
<dt><code>survtime</code>:</dt><dd><p>time from entry until event (numeric);</p>
</dd>
<dt><code>censorid</code>:</dt><dd><p>censoring indicator (0 = right censored, 1 = observed),
(integer).</p>
</dd>
</dl>
<p> and optionally additional covariates used for risk-adjustment.</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_formula">formula</code></td>
<td>
<p>A formula with right-hand side (RHS) indicating the form in which
the covariates should be used for the Cox and GLM
regression models. LHS of the formula will be ignored, and can be left empty.</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_followup">followup</code></td>
<td>
<p>(optional): The value of the follow-up time to be used to determine event time.
Event time will be equal to <code>entrytime + followup</code> for each subject.</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_theta">theta</code></td>
<td>
<p>The value of the expected log-hazard/odds ratio. In other words: the logarithm of the
expected increase in the odds/hazard ratio. Default is log(2) (detecting a
doubling of the odds/failure rate).</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_time">time</code></td>
<td>
<p>Timeframe over which the type I error of the control chart should be
limited. Should be in the same unit as <code>survtime</code> in <code>data</code>. If left
unspecified, the maximum entrytime in <code>baseline_data</code> is taken. (numeric)</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_alpha">alpha</code></td>
<td>
<p>Required maximal type I error (between 0 and 1) of the procedure
over the timeframe specified in <code>time</code>. Default is 0.05. (numeric)</p>
</td></tr>
<tr><td><code id="parameter_assist_+3A_maxtheta">maxtheta</code></td>
<td>
<p>Maximum value the maximum likelihood estimate for
parameter <code class="reqn">\theta</code> can take. If <code>detection = "lower"</code>, <code>-abs(theta)</code>
will be the minimum value the maximum likelihood estimate for
parameter <code class="reqn">\theta</code> can take.  Default is <code>log(6)</code>, meaning that
at most a 6 times increase/decrease in the odds/hazard ratio is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the specified arguments, the function will return
parameters. If <code>covariate_names</code> is not specified, the returned
risk-adjustment models will be trivial. If <code>formula</code> is not specified
but <code>covariate_names</code> are,
the function assumes the simplest form for the regression model
(cov1 + cov2 + ...). If <code>followup</code> is not specified, no <code>glmmod</code>
will be determined
</p>


<h3>Value</h3>

<p>A list of parameters to feed to quality control charts in this
package:
</p>

<ul>
<li><p>call: The call used to obtain output.
</p>
</li>
<li><p>data: The data used in the call to the function.
</p>
</li>
<li><p>baseline_data: The baseline_data used in the call to the function
</p>
</li>
<li><p>glmmod: A <code><a href="stats.html#topic+glm">glm()</a></code> model which can be fed to
the <code><a href="#topic+funnel_plot">funnel_plot()</a></code>
and <code><a href="#topic+bernoulli_cusum">bernoulli_cusum()</a></code> functions.
</p>
</li>
<li><p>coxphmod: A <code><a href="survival.html#topic+coxph">coxph()</a></code> model which can be
fed to the <code><a href="#topic+cgr_cusum">cgr_cusum()</a></code> and
<code><a href="#topic+cgr_cusum">cgr_cusum()</a></code> functions.
</p>
</li>
<li><p>theta: Expected increase in the odds/hazard ratio.
</p>
</li>
<li><p>psi: Estimated Poisson arrival rate in <code>data</code>.
</p>
</li>
<li><p>time: Time frame over which to restrict type I error.
</p>
</li>
<li><p>alpha: Desired level of type I error for control limit determination.
</p>
</li>
<li><p>maxtheta: Maximum expected increase/decrease in the odds/hazard ratio.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)

#Minimal example - no risk-adjustment
pars_min &lt;- parameter_assist(baseline_data = surgerydat,
data = subset(surgerydat, unit == 1))

#Specifying all parameters
pars &lt;- parameter_assist(baseline_data = surgerydat,
data = subset(surgerydat, unit == 1),
formula = formula("survtime ~ age + sex + BMI"), followup = 100)
</code></pre>

<hr>
<h2 id='plot.cgrcusum'>Plot a quality control chart</h2><span id='topic+plot.cgrcusum'></span><span id='topic+plot.bkcusum'></span><span id='topic+plot.funnelplot'></span><span id='topic+plot.bercusum'></span>

<h3>Description</h3>

<p>Plot a <code>cgrcusum</code>, <code>bkcusum</code>,
<code>bercusum</code> or <code>funnelplot</code> chart, or a list containing a combination of
<code>'bercusum'</code>, <code>'bkcusum'</code> and <code>'cgrcusum'</code> charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgrcusum'
plot(x, h, ...)

## S3 method for class 'bkcusum'
plot(x, h, ...)

## S3 method for class 'funnelplot'
plot(x, percentage = TRUE, unit_label = TRUE,
  label_size = 3, col_fill = "blue", ...)

## S3 method for class 'bercusum'
plot(x, h = x$h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cgrcusum_+3A_x">x</code></td>
<td>
<p>Chart to plot</p>
</td></tr>
<tr><td><code id="plot.cgrcusum_+3A_h">h</code></td>
<td>
<p>Control limit to display for <code>cgrcusum</code>, <code>bkcusum</code> or <code>bercusum</code></p>
</td></tr>
<tr><td><code id="plot.cgrcusum_+3A_...">...</code></td>
<td>
<p>Further plotting parameters</p>
</td></tr>
<tr><td><code id="plot.cgrcusum_+3A_percentage">percentage</code></td>
<td>
<p>Should output be shown in percentages? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.cgrcusum_+3A_unit_label">unit_label</code></td>
<td>
<p>Should unit labels be displayed next to detected units in the funnel plot?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.cgrcusum_+3A_label_size">label_size</code></td>
<td>
<p>Size of the labels when <code>unit_label</code> is <code>TRUE</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="plot.cgrcusum_+3A_col_fill">col_fill</code></td>
<td>
<p>Single fill colour for the prediction intervals in the funnel plot.
In any format that <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code> accepts. Default is <code>"blue"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the associated chart is displayed in the current graphics device.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>plot(cgrcusum)</code>: Plot a CGR-CUSUM
</p>
</li>
<li> <p><code>plot(bkcusum)</code>: Plot a BK-CUSUM
</p>
</li>
<li> <p><code>plot(funnelplot)</code>: Display a funnel plot
</p>
</li>
<li> <p><code>plot(bercusum)</code>: Plot a Bernoulli CUSUM
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cgr_cusum">cgr_cusum</a></code>, <code><a href="#topic+bk_cusum">bk_cusum</a></code>, <code><a href="#topic+bernoulli_cusum">bernoulli_cusum</a></code>, <code><a href="#topic+funnel_plot">funnel_plot</a></code>
</p>

<hr>
<h2 id='runlength'>Determine run length of a CUSUM chart</h2><span id='topic+runlength'></span><span id='topic+runlength.cgrcusum'></span><span id='topic+runlength.bkcusum'></span><span id='topic+runlength.bercusum'></span>

<h3>Description</h3>

<p>This function can be used to calculate the run length of a 'cgrcusum', 'bkcusum'
or 'bercusum'
chart when using control limit h
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runlength(chart, h)

## S3 method for class 'cgrcusum'
runlength(chart, h, ...)

## S3 method for class 'bkcusum'
runlength(chart, h, ...)

## S3 method for class 'bercusum'
runlength(chart, h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runlength_+3A_chart">chart</code></td>
<td>
<p>A <code>cgrcusum</code>, <code>bkcusum</code> or <code>bercusum</code> chart.</p>
</td></tr>
<tr><td><code id="runlength_+3A_h">h</code></td>
<td>
<p>Control limit h to be used when determining the run length</p>
</td></tr>
<tr><td><code id="runlength_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The run length of the chart with the given control limit.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>runlength(cgrcusum)</code>: determines runlength of <code>cgrcusum</code> object
</p>
</li>
<li> <p><code>runlength(bkcusum)</code>: determines runlength of <code>bkcusum</code> object
</p>
</li>
<li> <p><code>runlength(bercusum)</code>: determines runlength of <code>bercusum</code> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Daniel Gomon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exprfitber &lt;- as.formula("(survtime &lt;= 100) &amp; (censorid == 1) ~ age + sex + BMI")
glmmodber &lt;- glm(exprfitber, data = surgerydat, family = binomial(link = "logit"))
bercus &lt;- bernoulli_cusum(data = subset(surgerydat, unit == 14), glmmod = glmmodber,
                   followup = 100, theta = log(2))
#Determine the run length of the above Bernoulli CUSUM when using a control limit
#of h = 1.
runlength(bercus, h = 1)
</code></pre>

<hr>
<h2 id='summary.funnelplot'>Summarizes S3 objects in this package.</h2><span id='topic+summary.funnelplot'></span>

<h3>Description</h3>

<p>Prints a summary of the
<code>funnelplot</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funnelplot'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.funnelplot_+3A_object">object</code></td>
<td>
<p>S3 object to summarize</p>
</td></tr>
<tr><td><code id="summary.funnelplot_+3A_...">...</code></td>
<td>
<p>extra parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with:
</p>

<ul>
<li> <p><code>unit</code>: unit number/identifier;
</p>
</li>
<li> <p><code>observed</code>: the observed amount of failures at respective unit;
</p>
</li>
<li> <p><code>expected</code>: the expected amount of failures at respective unit,
given that the unit is performing at target;
</p>
</li>
<li> <p><code>numtotal</code>: total number of subjects at respective unit;
</p>
</li>
<li> <p><code>p</code>: estimated probability of failure at unit;
</p>
</li>
<li> <p><code>'0.xx'</code>: better/normal/worse proportion of failure at specified
confidence levels.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>summary(funnelplot)</code>: summarize instances detected by the
<code>funnelplot</code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+funnel_plot">funnel_plot</a></code>
</p>

<hr>
<h2 id='surgerydat'>Simulated data set with data of surgery procedures
performed at multiple hospitals.</h2><span id='topic+surgerydat'></span>

<h3>Description</h3>

<p>Data about patients and their surgery procedure from 45 simulated hospitals
with patient arrivals in the first 400 days after the start of the study. <br />
Patient survival times were determined using a risk-adjusted Cox proportional hazards model
with coefficients age = 0.003, BMI = 0.02 and sexmale = 0.2 and exponential baseline hazard rate
<code class="reqn">h_0(t, \lambda = 0.01) e^\mu</code>.
The increase in hazard rate is sampled from a normal distribution for all hospitals:
</p>

<ul>
<li> <p><code class="reqn">\theta \sim N(log(1), sd = 0.4)</code>
</p>
</li></ul>
<p> This means that the average failure rate of hospitals in the data set
should be baseline (<code class="reqn">\theta = 0</code>), with some hospitals
experiencing higher and lower failure rates. True failure rate can be found
in the column <code>exptheta</code>. <br />
The arrival rate <code class="reqn">\psi</code> of patients at a hospital differs. The arrival rates are:
</p>

<ul>
<li><p> Hospitals 1-5 &amp; 16-20: 0.5 patients per day (small hospitals)
</p>
</li>
<li><p> Hospitals 6-10 &amp; 21-25: 1 patient per day (medium sized hospitals)
</p>
</li>
<li><p> Hospitals 11-15 &amp; 26-30: 1.5 patients per day (large hospitals)
</p>
</li></ul>
<p> These are then respectively small, medium and large hospitals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surgerydat
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 12010 rows and 9 variables:
</p>

<dl>
<dt>entrytime</dt><dd><p>Time of entry of patient into study (numeric)</p>
</dd>
<dt>survtime</dt><dd><p>Time from entry until failure of patient (numeric)</p>
</dd>
<dt>censorid</dt><dd><p>Censoring indicator (0 - right censored, 1 - observed) (integer)</p>
</dd>
<dt>unit</dt><dd><p>Hospital number at which patient received treatment (integer)</p>
</dd>
<dt>exptheta</dt><dd><p>True excess hazard used for generating patient survival (numeric)</p>
</dd>
<dt>psival</dt><dd><p>Poisson arrival rate at hospital which the patient was at (numeric)</p>
</dd>
<dt>age</dt><dd><p>Age of the patient (numeric)</p>
</dd>
<dt>sex</dt><dd><p>Sex of the patient (factor)</p>
</dd>
<dt>BMI</dt><dd><p>Body mass index of the patient (numeric)</p>
</dd>
</dl>


<hr>
<h2 id='weib_hazards'>Weibull hazard, cumulative hazard and inverse cumulative hazard</h2><span id='topic+weib_hazards'></span><span id='topic+haz_weib'></span><span id='topic+chaz_weib'></span><span id='topic+inv_chaz_weib'></span>

<h3>Description</h3>

<p>Functions which return the hazard, cumulative
hazard and inverse cumulative hazard at time t for a Weibull distribution
with shape parameter <code class="reqn">\lambda</code>, scale parameter <code class="reqn">\theta</code>
and true hazard ratio <code class="reqn">\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haz_weib(t, lambda, theta, mu = log(1))

chaz_weib(t, lambda, theta, mu = log(1))

inv_chaz_weib(t, lambda, theta, mu = log(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weib_hazards_+3A_t">t</code></td>
<td>
<p>time of evaluation.</p>
</td></tr>
<tr><td><code id="weib_hazards_+3A_lambda">lambda</code></td>
<td>
<p>shape parameter <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="weib_hazards_+3A_theta">theta</code></td>
<td>
<p>scale parameter <code class="reqn">\theta</code></p>
</td></tr>
<tr><td><code id="weib_hazards_+3A_mu">mu</code></td>
<td>
<p>(optional) true excess hazard rate <code class="reqn">\mu</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hazard function of a Weibull distribution is given by:
</p>
<p style="text-align: center;"><code class="reqn">h(t| \lambda, \theta, \mu) = \frac{\lambda}{\theta} \left(\frac{t}{\theta}  \right)^{\lambda -1} e^\mu</code>
</p>

<p>The cumulative hazard (with true hazard ratio <code class="reqn">\mu</code>) is given by:
</p>
<p style="text-align: center;"><code class="reqn">H(t| \lambda, \theta, \mu) = \left( \frac{t}{\theta} \right)^{\lambda} e^\mu</code>
</p>

<p>The inverse cumulative hazard (with true hazard ratio <code class="reqn">\mu</code>) by:
</p>
<p style="text-align: center;"><code class="reqn">H^{-1}(t| \lambda, \theta, \mu) = \theta \left( \frac{t}{e^\mu}  \right)^{1/\lambda}</code>
</p>



<h3>Value</h3>

<p>Value of specified function at time <code class="reqn">t</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
