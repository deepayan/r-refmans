<!DOCTYPE html><html lang="en"><head><title>Help for package ridigbio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ridigbio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ridigbio-package'><p>ridigbio: Interface to the iDigBio Data API</p></a></li>
<li><a href='#.onAttach'><p>onAttach</p></a></li>
<li><a href='#build_field_lists'><p>Build fields and fields_exclude for queries.</p></a></li>
<li><a href='#idig_build_attrib'><p>Attribution dataframe of iDigBio records query</p></a></li>
<li><a href='#idig_check'><p>check HTTP code</p></a></li>
<li><a href='#idig_check_error'><p>Check is the request returned an error.</p></a></li>
<li><a href='#idig_count_media'><p>Count media endpoint</p></a></li>
<li><a href='#idig_count_records'><p>Count record endpoint</p></a></li>
<li><a href='#idig_GET'><p>internal GET request</p></a></li>
<li><a href='#idig_meta_fields'><p>meta fields endpoint</p></a></li>
<li><a href='#idig_parse'><p>parse successfully returned request</p></a></li>
<li><a href='#idig_POST'><p>internal POST request</p></a></li>
<li><a href='#idig_search'><p>Basic searching of iDigBio records</p></a></li>
<li><a href='#idig_search_media'><p>Searching of iDigBio media records</p></a></li>
<li><a href='#idig_search_records'><p>Searching of iDigBio records</p></a></li>
<li><a href='#idig_top_media'><p>Top media endpoint</p></a></li>
<li><a href='#idig_top_records'><p>Top records endpoint</p></a></li>
<li><a href='#idig_url'><p>base URL</p></a></li>
<li><a href='#idig_validate'><p>validate fields</p></a></li>
<li><a href='#idig_version'><p>API version</p></a></li>
<li><a href='#idig_view_media'><p>view media endpoint</p></a></li>
<li><a href='#idig_view_records'><p>view specimen endpoint</p></a></li>
<li><a href='#ignore_unused_imports'><p>Stub function for passing import checks</p></a></li>
<li><a href='#ridigbio'><p>Retrieve data from the iDigBio specimen data repository.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interface to the iDigBio Data API</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-9-27</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to iDigBio's search API that allows downloading
  specimen records. Searches are returned as a data.frame. Other functions
  such as the metadata end points return lists of information. iDigBio is a US
  project focused on digitizing and serving museum specimen collections on the
  web. See <a href="https://www.idigbio.org">https://www.idigbio.org</a> for information on iDigBio.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/iDigBio/ridigbio">https://github.com/iDigBio/ridigbio</a>,
<a href="https://idigbio.github.io/ridigbio/">https://idigbio.github.io/ridigbio/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/iDigBio/ridigbio/issues">https://github.com/iDigBio/ridigbio/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, plyr, httr, jsonlite, leaflet, kableExtra, tidyverse,
cowplot</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, markdown, knitr, utils, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-30 17:28:06 UTC; jessebennett</td>
</tr>
<tr>
<td>Author:</td>
<td>Francois Michonneau [aut, cph] (Original Author),
  Matthew Collins [aut] (Original Author),
  Scott Chamberlain [ctb],
  Kevin Love [ctb],
  Hem Nalini Morzaria-Luna [ctb],
  Michelle L. Gaynor [ctb, aut],
  Jesse Bennett [cre] (Maintainer)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jesse Bennett &lt;j3553@ufl.edu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-01 02:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ridigbio-package'>ridigbio: Interface to the iDigBio Data API</h2><span id='topic+ridigbio-package'></span>

<h3>Description</h3>

<p>An interface to iDigBio's search API that allows downloading specimen records. Searches are returned as a data.frame. Other functions such as the metadata end points return lists of information. iDigBio is a US project focused on digitizing and serving museum specimen collections on the web. See <a href="https://www.idigbio.org">https://www.idigbio.org</a> for information on iDigBio.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jesse Bennett <a href="mailto:j3553@ufl.edu">j3553@ufl.edu</a> (Maintainer)
</p>
<p>Authors:
</p>

<ul>
<li><p> Francois Michonneau <a href="mailto:francois.michonneau@gmail.com">francois.michonneau@gmail.com</a> (Original Author) [copyright holder]
</p>
</li>
<li><p> Matthew Collins <a href="mailto:mcollins@acis.ufl.edu">mcollins@acis.ufl.edu</a> (Original Author)
</p>
</li>
<li><p> Michelle L. Gaynor <a href="mailto:michellegaynor@ufl.edu">michellegaynor@ufl.edu</a> [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Scott Chamberlain <a href="mailto:myrmecocystus@gmail.com">myrmecocystus@gmail.com</a> [contributor]
</p>
</li>
<li><p> Kevin Love <a href="mailto:klove@flmnh.ufl.edu">klove@flmnh.ufl.edu</a> [contributor]
</p>
</li>
<li><p> Hem Nalini Morzaria-Luna <a href="mailto:hemnalin.morzarialuna@noaa.gov">hemnalin.morzarialuna@noaa.gov</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/iDigBio/ridigbio">https://github.com/iDigBio/ridigbio</a>
</p>
</li>
<li> <p><a href="https://idigbio.github.io/ridigbio/">https://idigbio.github.io/ridigbio/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/iDigBio/ridigbio/issues">https://github.com/iDigBio/ridigbio/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.onAttach'>onAttach</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Display startup message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".onAttach_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='build_field_lists'>Build fields and fields_exclude for queries.</h2><span id='topic+build_field_lists'></span>

<h3>Description</h3>

<p>Given the desired fields to be returned, intelligently add an exclusion for
the data array if warranted and handle the &quot;all&quot; keyword. And do so without
setting both fields and fields_exclude due to fact that the API will return
wrong results if are passed. This is still posssible if the user
deliberately sets both. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_field_lists(fields, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_field_lists_+3A_fields">fields</code></td>
<td>
<p>character vector of fields user wants returned</p>
</td></tr>
<tr><td><code id="build_field_lists_+3A_type">type</code></td>
<td>
<p>type of records to get fields for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list list with fields key for df fields and query key for parameters
to be merged with the query sent
</p>

<hr>
<h2 id='idig_build_attrib'>Attribution dataframe of iDigBio records query</h2><span id='topic+idig_build_attrib'></span>

<h3>Description</h3>

<p>Function to build attribution dataframe from a query to the iDigBio API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_build_attrib(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_build_attrib_+3A_dat">dat</code></td>
<td>
<p>dataframe generated by idig_search method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from the attribution metadata that is attached to the
dataframe returned by the idig_search_* methods. It summarizes the record
sets used by records in the dataframe, not the record sets that have records
that match the query sent to iDigBio. This is useful if only part of the
records for a query are downloaded, for example with the limit and offset
parameters.
</p>
<p>Exported.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>Kevin Love
</p>

<hr>
<h2 id='idig_check'>check HTTP code</h2><span id='topic+idig_check'></span>

<h3>Description</h3>

<p>Checks for HTTP error codes and JSON errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_check(req)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_check_+3A_req">req</code></td>
<td>
<p>the returned request</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part 1 of the error checking process. This part handles HTTP error codes and
then calls part 2 which handles JSON errors in the responses. Not exported.
</p>


<h3>Value</h3>

<p>nothing. Stops if HTTP code is &gt;= 400
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_check_error'>Check is the request returned an error.</h2><span id='topic+idig_check_error'></span>

<h3>Description</h3>

<p>Checks for error messages that can be returned by the API in JSON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_check_error(req)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_check_error_+3A_req">req</code></td>
<td>
<p>the returned request</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part 2 of the error checking process. Checks the JSON response for error
messages and stops if any are found. Not exported.
</p>


<h3>Value</h3>

<p>nothing. Stops if request contains an error.
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_count_media'>Count media endpoint</h2><span id='topic+idig_count_media'></span>

<h3>Description</h3>

<p>Count media records matching a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_count_media(rq = FALSE, mq = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_count_media_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_count_media_+3A_mq">mq</code></td>
<td>
<p>iDigBio media query in nested list format</p>
</td></tr>
<tr><td><code id="idig_count_media_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quickly return a count of the media records matching the query(s) provided.
</p>


<h3>Value</h3>

<p>count of media records matching the query(s)
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_count_records'>Count record endpoint</h2><span id='topic+idig_count_records'></span>

<h3>Description</h3>

<p>Count specimen records matching a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_count_records(rq = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_count_records_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_count_records_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quickly return a count of the specimen records matching the query(s)
provided.
</p>


<h3>Value</h3>

<p>count of specimen records matching the query(s)
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_GET'>internal GET request</h2><span id='topic+idig_GET'></span>

<h3>Description</h3>

<p>Internal function for GET requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_GET(path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_GET_+3A_path">path</code></td>
<td>
<p>endpoint</p>
</td></tr>
<tr><td><code id="idig_GET_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to httr::GET</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a GET request and performs the checks on what is returned. Not
exported.
</p>


<h3>Value</h3>

<p>the request (as a list)
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_meta_fields'>meta fields endpoint</h2><span id='topic+idig_meta_fields'></span>

<h3>Description</h3>

<p>List of fields in iDigBio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_meta_fields(type = "records", subset = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_meta_fields_+3A_type">type</code></td>
<td>
<p>string type of fields to return, defaults to &quot;records&quot;</p>
</td></tr>
<tr><td><code id="idig_meta_fields_+3A_subset">subset</code></td>
<td>
<p>set of fields to return, &quot;indexed&quot;, &quot;raw&quot;, or unset for all</p>
</td></tr>
<tr><td><code id="idig_meta_fields_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return a list of media or specimen fields that are contained in iDigBio.
</p>


<h3>Value</h3>

<p>list of fields of the requested type
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_parse'>parse successfully returned request</h2><span id='topic+idig_parse'></span>

<h3>Description</h3>

<p>Parses output of successful query to return a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_parse(req)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_parse_+3A_req">req</code></td>
<td>
<p>the returned request</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not exported.
</p>


<h3>Value</h3>

<p>a list
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_POST'>internal POST request</h2><span id='topic+idig_POST'></span>

<h3>Description</h3>

<p>Internal function for POST requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_POST(path, body, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_POST_+3A_path">path</code></td>
<td>
<p>endpoint</p>
</td></tr>
<tr><td><code id="idig_POST_+3A_body">body</code></td>
<td>
<p>a list of parameters for the endpoint</p>
</td></tr>
<tr><td><code id="idig_POST_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to httr::POST</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a POST request and performs the checks on what is returned. Not
exported.
</p>


<h3>Value</h3>

<p>the request (as a list)
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_search'>Basic searching of iDigBio records</h2><span id='topic+idig_search'></span>

<h3>Description</h3>

<p>Base function to query the iDigBio API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_search(
  type = "records",
  mq = FALSE,
  rq = FALSE,
  fields = FALSE,
  max_items = 1e+05,
  limit = 0,
  offset = 0,
  sort = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_search_+3A_type">type</code></td>
<td>
<p>string type of records to query, defaults to &quot;records&quot;</p>
</td></tr>
<tr><td><code id="idig_search_+3A_mq">mq</code></td>
<td>
<p>iDigBio media query in nested list format</p>
</td></tr>
<tr><td><code id="idig_search_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_search_+3A_fields">fields</code></td>
<td>
<p>vector of fields that will be contained in the data.frame</p>
</td></tr>
<tr><td><code id="idig_search_+3A_max_items">max_items</code></td>
<td>
<p>CURRENTLY IGNORED, SEE ISSUE #33 maximum number of results
allowed to be retrieved (fail-safe)</p>
</td></tr>
<tr><td><code id="idig_search_+3A_limit">limit</code></td>
<td>
<p>maximum number of results returned</p>
</td></tr>
<tr><td><code id="idig_search_+3A_offset">offset</code></td>
<td>
<p>number of results to skip before returning results</p>
</td></tr>
<tr><td><code id="idig_search_+3A_sort">sort</code></td>
<td>
<p>vector of fields to use for sorting, UUID is always appended to
make paging safe</p>
</td></tr>
<tr><td><code id="idig_search_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is wrapped for media and specimen record searches. Please
consider using <code><a href="#topic+idig_search_media">idig_search_media</a></code> or
<code><a href="#topic+idig_search_records">idig_search_records</a></code> instead as they supply nice defaults to
this function depending on the type of records desired.
</p>
<p>Fuller documentation of parameters is in the
<code><a href="#topic+idig_search_records">idig_search_records</a></code> function's help.
</p>
<p>Exported to facilitate wrapping this package in other packages.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Ten media records related to genus Acer specimens
idig_search(type="media", rq=list(genus="acer"), limit=10)

## End(Not run)

</code></pre>

<hr>
<h2 id='idig_search_media'>Searching of iDigBio media records</h2><span id='topic+idig_search_media'></span>

<h3>Description</h3>

<p>Function to query the iDigBio API for media records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_search_media(
  mq = FALSE,
  rq = FALSE,
  fields = FALSE,
  max_items = 1e+05,
  limit = 0,
  offset = 0,
  sort = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_search_media_+3A_mq">mq</code></td>
<td>
<p>iDigBio media query in nested list format</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_fields">fields</code></td>
<td>
<p>vector of fields that will be contained in the data.frame,
defaults to &quot;all&quot; which is all indexed fields</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_max_items">max_items</code></td>
<td>
<p>maximum number of results allowed to be retrieved (fail
-safe)</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_limit">limit</code></td>
<td>
<p>maximum number of results returned</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_offset">offset</code></td>
<td>
<p>number of results to skip before returning results</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_sort">sort</code></td>
<td>
<p>vector of fields to use for sorting, UUID is always appended to
make paging safe</p>
</td></tr>
<tr><td><code id="idig_search_media_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Also see <code><a href="#topic+idig_search_records">idig_search_records</a></code> for the full examples of all the
parameters related to searching iDigBio.
</p>
<p>Wraps <code><a href="#topic+idig_search">idig_search</a></code> to provide defaults specific to searching
media records. Using this function instead of <code><a href="#topic+idig_search">idig_search</a></code>
directly is recommened. Record queries and media queries objects are allowed
(rq and mq parameters) and media records returned will match the
requirements of both.
</p>
<p>This function defaults to returning all indexed media record fields.
</p>


<h3>Value</h3>

<p>A data frame with fields requested or the following default fields:
</p>

<ul>
<li><p><a href="https://ac.tdwg.org/termlist/#ac_accessURI">accessuri</a> 
</p>
</li>
<li><p>datemodified: Date last modified, which is assigned by iDigBio.
</p>
</li>
<li><p>dqs: Data quality score assigned by iDigBio.
</p>
</li>
<li><p>etag: Tag assigned by iDigBio.
</p>
</li>
<li><p>flags: Data quality flag assigned by iDigBio.
</p>
</li>
<li><p><a href="https://purl.org/dc/terms/format">format</a> 
</p>
</li>
<li><p>hasSpecimen: TRUE or FALSE, indicates if there is an associated record for this media.
</p>
</li>
<li><p><a href="https://ac.tdwg.org/termlist/#ac_licenseLogoURL">licenselogourl</a>
</p>
</li>
<li><p>mediatype: Media object type.
</p>
</li>
<li><p><a href="https://purl.org/dc/terms/modified">modified</a>
</p>
</li>
<li><p>recordids: List of UUID for associated records.
</p>
</li>
<li><p>records: UUID for the associated record.
</p>
</li>
<li><p>recordset: Record set ID assigned by iDigBio.
</p>
</li>
<li><p><a href="https://purl.org/dc/terms/rights">rights</a>
</p>
</li>
<li><p><a href="https://rs.tdwg.org/ac/terms/tag">tag</a>
</p>
</li>
<li><p><a href="https://purl.org/dc/terms/type">type</a>
</p>
</li>
<li><p>uuid: Unique identifier assigned by iDigBio.
</p>
</li>
<li><p>version: Media record version assigned by iDigBio.
</p>
</li>
<li><p><a href="https://developer.adobe.com/xmp/docs/XMPNamespaces/xmpRights/">webstatement</a>
</p>
</li>
<li><p>xpixels: As defined by EXIF, x dimension in pixel.
</p>
</li>
<li><p>ypixels: As defined by EXIF,y dimension in pixels.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Collins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Searching for media using a query on related specimen information - first
# 10 media records with image URIs related to a specimen in the genus Acer:
df &lt;- idig_search_media(rq=list(genus="acer"),
                        mq=list("data.ac:accessURI"=list("type"="exists")),
                        fields=c("uuid","data.ac:accessURI"), limit=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='idig_search_records'>Searching of iDigBio records</h2><span id='topic+idig_search_records'></span>

<h3>Description</h3>

<p>Function to query the iDigBio API for specimen records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_search_records(
  rq,
  fields = FALSE,
  max_items = 1e+05,
  limit = 0,
  offset = 0,
  sort = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_search_records_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_search_records_+3A_fields">fields</code></td>
<td>
<p>vector of fields that will be contained in the data.frame,
limited set returned by default, use &quot;all&quot; to get all indexed fields</p>
</td></tr>
<tr><td><code id="idig_search_records_+3A_max_items">max_items</code></td>
<td>
<p>maximum number of results allowed to be retrieved (fail
-safe)</p>
</td></tr>
<tr><td><code id="idig_search_records_+3A_limit">limit</code></td>
<td>
<p>maximum number of results returned</p>
</td></tr>
<tr><td><code id="idig_search_records_+3A_offset">offset</code></td>
<td>
<p>number of results to skip before returning results</p>
</td></tr>
<tr><td><code id="idig_search_records_+3A_sort">sort</code></td>
<td>
<p>vector of fields to use for sorting, UUID is always appended to
make paging safe</p>
</td></tr>
<tr><td><code id="idig_search_records_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wraps <code><a href="#topic+idig_search">idig_search</a></code> to provide defaults specific to searching
specimen records. Using this function instead of <code><a href="#topic+idig_search">idig_search</a></code>
directly is recommened.
</p>
<p>Queries need to be specified as a nested list structure that will serialize
to an iDigBio query object's JSON as expected by the iDigBio API:
<a href="https://github.com/iDigBio/idigbio-search-api/wiki/Query-Format">https://github.com/iDigBio/idigbio-search-api/wiki/Query-Format</a>
</p>
<p>As an example, the first sample query looks like this in JSON in the API
documentation:
</p>
<pre>
{
  "scientificname": {
    "type": "exists"
  },
  "family": "asteraceae"
}
</pre>
<p>To rewrite this in R for use as the rq parameter to
<code>idig_search_records</code> or <code>idig_search_media</code>, it would look like
this:
</p>
<pre>
rq &lt;- list("scientificname"=list("type"="exists"),
           "family"="asteraceae"
           )
</pre>
<p>An example of a more complex JSON query with nested structures:
</p>
<pre>
{
  "geopoint": {
   "type": "geo_bounding_box",
   "top_left": {
     "lat": 19.23,
     "lon": -130
    },
    "bottom_right": {
      "lat": -45.1119,
      "lon": 179.99999
    }
   }
 }
</pre>
<p>To rewrite this in R for use as the rq parameter, use nested calls to the
list() function:
</p>
<pre>
rq &lt;- list(geopoint=list(
                         type="geo_bounding_box",
                         top_left=list(lat=19.23, lon=-130),
                         bottom_right=list(lat=-45.1119, lon= 179.99999)
                        )
           )
</pre>
<p>See the Examples section below for more samples of simpler and more complex
queries. Please refer to the API documentation for the full functionality
availible in queries.
</p>
<p>All matching results are returned up to the max_items cap (default 100,000).
If more results are wanted, a higher max_items can be passed as an option.
This API loads records 5,000 at a time using HTTP so performance with large
sets of data is not very good. Expect result sets over 50,000 records to
take tens of minutes. You can use the <code><a href="#topic+idig_count_records">idig_count_records</a></code> or
<code><a href="#topic+idig_count_media">idig_count_media</a></code> functions to find out how many records a
query will return; these are fast.
</p>
<p>The iDigBio API will only return 5,000 records at a time but this function
will automatically page through the results and return them all. Limit
and offset are availible if manual paging of results is needed though the
max_items cap still applies. The item count comes from the results header
not the count of actual records in the limit/offset window.
</p>
<p>Return is a data.frame containing the requested fields (or the default
fields). The columns in the data frame are untyped and no factors are pre-
built. Attribution and other metadata is attached to the dataframe in the
data.frame's attributes. (I.e. <code>attributes(df)</code>)
</p>


<h3>Value</h3>

<p>A data frame with fields requested or the following default fields:
</p>

<ul>
<li><p>UUID: Unique identifier assigned by iDigBio.
</p>
</li>
<li><p><a href="https://dwc.tdwg.org/list/#dwc_occurrenceID">occurrenceID</a>
</p>
</li>
<li><p><a href="https://rs.tdwg.org/dwc/terms/catalogNumber">catalognumber</a>
</p>
</li>
<li><p><a href="https://rs.tdwg.org/dwc/terms/family">family</a> - may be reassigned by iDigBio
</p>
</li>
<li><p><a href="https://dwc.tdwg.org/list/#dwc_genus">genus</a> - may be reassigned by iDigBio
</p>
</li>
<li><p><a href="https://rs.tdwg.org/dwc/terms/scientificName">scientificname</a> - may be reassigned by iDigBio
</p>
</li>
<li><p><a href="https://rs.tdwg.org/dwc/terms/country">country</a> - may be modified by iDigBio
</p>
</li>
<li><p><a href="https://rs.tdwg.org/dwc/terms/stateProvince">stateprovince</a> 
</p>
</li>
<li><p>geopoint: Assigned by iDigBio.
</p>
</li>
<li><p><a href="https://dwc.tdwg.org/list/#dwc_eventDate">data.dwc:eventDate</a>
</p>
</li>
<li><p><a href="https://dwc.tdwg.org/list/#dwc_year">data.dwc:year</a>
</p>
</li>
<li><p><a href="https://dwc.tdwg.org/list/#dwc_month">data.dwc:month</a>
</p>
</li>
<li><p><a href="https://dwc.tdwg.org/list/#dwc_day">data.dwc:day</a>
</p>
</li>
<li><p>datecollected: May be reassigned by iDigBio, <a href="https://github.com/iDigBio/idb-backend/issues/229">see more here</a>
</p>
</li>
<li><p>collector: Assigned by iDigBio.
</p>
</li>
<li><p>recordset: Assigned by iDigBio.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Collins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simple example of retriving records in a genus:
idig_search_records(rq=list(genus="acer"), limit=10)

# This complex query shows that booleans passed to the API are represented
# as strings in R, fields used in the query don't have to be returned, and
# the syntax for accessing raw data fields:
idig_search_records(rq=list("hasImage"="true", genus="acer"),
            fields=c("uuid", "data.dwc:verbatimLatitude"), limit=100)

# Searching inside a raw data field for a string, note that raw data fields
# are searched as full text, indexed fields are search with exact matches:

idig_search_records(rq=list("data.dwc:dynamicProperties"="parasite"),
            fields=c("uuid", "data.dwc:dynamicProperties"), limit=100)

# Retriving a data.frame for use with MaxEnt. Notice geopoint is expanded
# to two columns in the data.frame: gepoint.lat and geopoint.lon:
df &lt;- idig_search_records(rq=list(genus="acer", geopoint=list(type="exists")),
          fields=c("uuid", "geopoint"), limit=10)
write.csv(df[c("uuid", "geopoint.lon", "geopoint.lat")],
          file="acer_occurrences.csv", row.names=FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='idig_top_media'>Top media endpoint</h2><span id='topic+idig_top_media'></span>

<h3>Description</h3>

<p>Top media records summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_top_media(rq = FALSE, mq = FALSE, top_fields = FALSE, count = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_top_media_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_top_media_+3A_mq">mq</code></td>
<td>
<p>iDigBio media query in nested list format</p>
</td></tr>
<tr><td><code id="idig_top_media_+3A_top_fields">top_fields</code></td>
<td>
<p>vector of field names to summarize by</p>
</td></tr>
<tr><td><code id="idig_top_media_+3A_count">count</code></td>
<td>
<p>maximum number of results to return, capped at 1000</p>
</td></tr>
<tr><td><code id="idig_top_media_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize the count of media records in iDigBio according to unique values
in the fields passed. This operates similarly to a SELECT DISTINCT count(
field_name) query in SQL. When multiple fields are passed, the summaries are
nested eg fields=c(&quot;country&quot;, &quot;genus&quot;) would result in counting the top 10
genera in each of the top 10 countries for a total of 100 counts.
</p>


<h3>Value</h3>

<p>nested list of field values with counts of media records
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_top_records'>Top records endpoint</h2><span id='topic+idig_top_records'></span>

<h3>Description</h3>

<p>Top specimen records summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_top_records(rq = FALSE, top_fields = FALSE, count = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_top_records_+3A_rq">rq</code></td>
<td>
<p>iDigBio record query in nested list format</p>
</td></tr>
<tr><td><code id="idig_top_records_+3A_top_fields">top_fields</code></td>
<td>
<p>vector of field names to summarize by</p>
</td></tr>
<tr><td><code id="idig_top_records_+3A_count">count</code></td>
<td>
<p>maximum number of results to return, capped at 1000</p>
</td></tr>
<tr><td><code id="idig_top_records_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize the count of specimen records in iDigBio according to unique
values in the fields passed. This operates similarly to a SELECT DISTINCT
count(field_name) query in SQL. When multiple fields are passed, the
summaries are nested eg fields=c(&quot;country&quot;, &quot;genus&quot;) would result in
counting the top 10 genera in each of the top 10 countries for a total of
100 counts.
</p>


<h3>Value</h3>

<p>nested list of field values with counts of specimen records
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_url'>base URL</h2><span id='topic+idig_url'></span>

<h3>Description</h3>

<p>Return base URL for the API calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_url(dev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_url_+3A_dev">dev</code></td>
<td>
<p>Should be the beta version of the API be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Defaults to use beta URL. Not exported.
</p>


<h3>Value</h3>

<p>string for the URL
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_validate'>validate fields</h2><span id='topic+idig_validate'></span>

<h3>Description</h3>

<p>Stub function for validating parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_validate(inputs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_validate_+3A_inputs">inputs</code></td>
<td>
<p>list of inputs to validate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes list of inputs named by validation rule eg:
<code style="white-space: pre;">&#8288;number:[2, 3]&#8288;</code> and returns
a vector of strings with any validation errors. If the vector is 0 length,
everything is valid. Not exported.
</p>


<h3>Value</h3>

<p>boolean
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_version'>API version</h2><span id='topic+idig_version'></span>

<h3>Description</h3>

<p>Return the version number to use for the API calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_version(version = "v2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_version_+3A_version">version</code></td>
<td>
<p>optional argument giving the version of the API to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current default is &quot;v2&quot;. Not exported.
</p>


<h3>Value</h3>

<p>string for the version to use
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>

<hr>
<h2 id='idig_view_media'>view media endpoint</h2><span id='topic+idig_view_media'></span>

<h3>Description</h3>

<p>View individual media records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_view_media(uuid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_view_media_+3A_uuid">uuid</code></td>
<td>
<p>uuid of media record</p>
</td></tr>
<tr><td><code id="idig_view_media_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>View all information about a specific media record.
</p>


<h3>Value</h3>

<p>nested list of data
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='idig_view_records'>view specimen endpoint</h2><span id='topic+idig_view_records'></span>

<h3>Description</h3>

<p>View individual specimen records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idig_view_records(uuid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idig_view_records_+3A_uuid">uuid</code></td>
<td>
<p>uuid of specimen record</p>
</td></tr>
<tr><td><code id="idig_view_records_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>View all information about a specific specimen record.
</p>


<h3>Value</h3>

<p>nested list of data
</p>


<h3>Author(s)</h3>

<p>Matthew Collins
</p>

<hr>
<h2 id='ignore_unused_imports'>Stub function for passing import checks</h2><span id='topic+ignore_unused_imports'></span>

<h3>Description</h3>

<p>Stub function for passing import checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ignore_unused_imports()
</code></pre>

<hr>
<h2 id='ridigbio'>Retrieve data from the iDigBio specimen data repository.</h2><span id='topic+ridigbio'></span>

<h3>Description</h3>

<p>Retrieve data from the iDigBio specimen data repository.
</p>


<h3>About</h3>

<p>ridigbio provides an interface to the iDigBio data API described here:
<a href="https://www.idigbio.org/wiki/index.php/IDigBio_API">https://www.idigbio.org/wiki/index.php/IDigBio_API</a>. With this package
you can retrieve specimen and media records from the iDigBio data
repository. The iDigBio portal <a href="https://portal.idigbio.org/">https://portal.idigbio.org/</a> uses the
same API so you should be able to retrieve the same information as shown in
the portal.
</p>
<p>iDigBio contains nearly 30 million data records on museum specimens held at
United States institutions. It also holds nearly 5 million images of these
specimens.
</p>


<h3>Getting Started</h3>

<p>The main function is <code><a href="#topic+idig_search_records">idig_search_records</a></code> and reviewing its
documenation first with <code>?idig_search_records</code> is recommended.
</p>


<h3>Limitations</h3>

<p>This package does not yet provide an interface to the mapping or the
download APIs.
</p>


<h3>Citing</h3>

<p>To cite the ridigbio package in your work, please use the following format:
</p>
<p>Michonneau F, Collins M, Chamberlain SA (2016). ridigbio: An interface to iDigBio's search API that allows downloading specimen records. R package version 0.3.8. https://github.com/iDigBio/ridigbio
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau <a href="mailto:francois.michonneau@gmail.com">francois.michonneau@gmail.com</a>
</p>
<p>Matthew Collins <a href="mailto:mcollins@acis.ufl.edu">mcollins@acis.ufl.edu</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
