<!DOCTYPE html><html><head><title>Help for package wavelets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wavelets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align'>
<p>Align Wavelet Transform Coefficients</p></a></li>
<li><a href='#dwt'>
<p>Discrete Wavelet Transform</p></a></li>
<li><a href='#dwt-class'>
<p>Discrete Wavelet Transform Object</p></a></li>
<li><a href='#dwt.forward'>
<p>Discrete Wavelet Transform and Maximal Overlap Discrete Wavelet</p>
Tranform Forward and Backward Pyramid Algorithm</a></li>
<li><a href='#ecg'><p>Electrocardiogram Data</p></a></li>
<li><a href='#extend.series'>
<p>Extend a Time Series</p></a></li>
<li><a href='#figure108.wt.filter'>
<p>Plot Multiple DWT Wavelet or Scaling Filters</p></a></li>
<li><a href='#figure98.wt.filter'>
<p>Plot a DWT Wavelet or Scaling Filter for Specific Levels.</p></a></li>
<li><a href='#idwt'>
<p>Inverse Discrete Wavelet Transform</p></a></li>
<li><a href='#imodwt'>
<p>Inverse Maximal Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt'>
<p>Maximal Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt-class'>
<p>Maximal Overlap Discrete Wavelet Transform Object</p></a></li>
<li><a href='#mra'>
<p>Multiresolution Analysis</p></a></li>
<li><a href='#mra-class'>
<p>Multiresolution Analysis Object</p></a></li>
<li><a href='#nile'><p>Yearly Nile River Minima</p></a></li>
<li><a href='#ocean'><p>Vertical Ocean Sheer Measurements</p></a></li>
<li><a href='#plot.dwt'>
<p>Plot DWT Coefficients</p></a></li>
<li><a href='#plot.dwt.multiple'>
<p>Plot Multiple DWT Objects</p></a></li>
<li><a href='#plot.modwt'>
<p>Plot MODWT Coefficients</p></a></li>
<li><a href='#scalingshift.dwt'>
<p>Find Circular Shift of DWT Scaling Coefficients</p></a></li>
<li><a href='#squaredgain.wt.filter'>
<p>Plot Squared Gain Function for Wavelet Filter</p></a></li>
<li><a href='#stackplot'>
<p>Stacked Plotting</p></a></li>
<li><a href='#subtidal'><p>Subtidal Sea Level Measurements</p></a></li>
<li><a href='#waveletshift.dwt'>
<p>Find Circular Shift of DWT Wavelet Coefficients</p></a></li>
<li><a href='#wt.filter'>
<p>Wavelet Transform Filter</p></a></li>
<li><a href='#wt.filter-class'>
<p>Wavelet Transform Filter Object</p></a></li>
<li><a href='#wt.filter.equivalent'>
<p>Equivalent Wavelet Transform Filter</p></a></li>
<li><a href='#wt.filter.qmf'>
<p>Quadrature Mirror Filter</p></a></li>
<li><a href='#wt.filter.shift'>
<p>Wavelet Transform Filter Phase Shift</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3-0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Computing Wavelet Filters, Wavelet Transforms and
Multiresolution Analyses</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Aldrich &lt;ealdrich@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Aldrich &lt;ealdrich@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for computing and plotting
        discrete wavelet transforms (DWT) and maximal overlap discrete
        wavelet transforms (MODWT), as well as their inverses.
        Additionally, it contains functionality for computing and
        plotting wavelet transform filters that are used in the above
        decompositions as well as multiresolution analyses.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-16 16:39:09 UTC; ericaldrich</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-17 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='align'>
Align Wavelet Transform Coefficients
</h2><span id='topic+align'></span>

<h3>Description</h3>

<p>Aligns both wavelet (high pass) and scaling (low pass) coefficients of
objects of class <code>dwt</code>, <code>modwt</code>, <code>dwpt</code>, and
<code>modwpt</code> using phase shift values computed by
<code>wt.filter.shift</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(wt, coe=FALSE, inverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_wt">wt</code></td>
<td>
<p>An object of class <code>dwt</code>, <code>modwt</code>, <code>dwpt</code>, or
<code>modwpt</code>.</p>
</td></tr>
<tr><td><code id="align_+3A_coe">coe</code></td>
<td>
<p>Logical value indicating whether to use center of energy
method in computing phase shifts.</p>
</td></tr>
<tr><td><code id="align_+3A_inverse">inverse</code></td>
<td>
<p>Logical value indicating whether to shift wavelet and
scaling coefficients of an aligned object back to their original
positions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>dwt</code>, <code>modwt</code>, is characterized as
'unaligned' if the value in the <code>aligned</code> slot is <code>FALSE</code>.
Similarly, these objects are classified as 'aligned' if the value in
the <code>aligned</code> slot is <code>TRUE</code>. Thus, <code>align</code> will only
operate on an 'unaligned' wavelet transform object if <code>inverse =
    FALSE</code> and on an 'aligned' wavelet transform object if <code>inverse
    = TRUE</code>.
</p>
<p>The argument <code>coe</code> is passed to the <code>wt.filter.shift</code>
function to determine what method to use for computing phase shifts
(see documentation for <code>wt.filter.shift</code>).
</p>


<h3>Value</h3>

<p>Either an aligned or unaligned object of the same class as <code>wt</code>
(see Details above). 
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter.shift">wt.filter.shift</a></code>,
<code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and compute DWT
newX &lt;- cbind(X1,X2)
wt &lt;- dwt(newX, n.levels=3, boundary="reflection", fast=FALSE)

# align
wt.aligned &lt;- align(wt)
</code></pre>

<hr>
<h2 id='dwt'>
Discrete Wavelet Transform
</h2><span id='topic+dwt'></span><span id='topic+print.dwt'></span><span id='topic+summary.dwt'></span>

<h3>Description</h3>

<p>Computes the discrete wavelet transform coefficients for a univariate
or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt(X, filter="la8", n.levels, boundary="periodic", fast=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt_+3A_x">X</code></td>
<td>
<p>A univariate or multivariate time series. Numeric vectors,
matrices and data frames are also accepted.</p>
</td></tr>
<tr><td><code id="dwt_+3A_filter">filter</code></td>
<td>
<p>Either a <code>wt.filter</code> object, a character string
indicating which wavelet filter to use in the decomposition, or a
numeric vector of wavelet coefficients (not scaling coefficients). See
<code>help(wt.filter)</code> for acceptable filter names.</p>
</td></tr>
<tr><td><code id="dwt_+3A_n.levels">n.levels</code></td>
<td>
<p>An integer specifying the level of the decomposition.
By default this is the value J such that the length of <code class="reqn">X</code> is at
least as great as the length of the level <code class="reqn">J</code> wavelet filter,
but less than the length of the level <code class="reqn">J+1</code> wavelet
filter. Thus, <code class="reqn">J \le \log{(\frac{N-1}{L-1}+1)}</code>, where <code class="reqn">N</code> is the length of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="dwt_+3A_boundary">boundary</code></td>
<td>
<p>A character string indicating which boundary method to
use. <code>boundary = "periodic"</code> and <code>boundary = "reflection"</code>
are the only supported methods at this time.</p>
</td></tr>
<tr><td><code id="dwt_+3A_fast">fast</code></td>
<td>
<p>A logical flag which, if true, indicates that the pyramid
algorithm is computed with an internal C function.  Otherwise, only
R code is used in all computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete wavelet transform is computed via the pyramid
algorithm, using pseudocode written by Percival and Walden (2000),
pp. 100-101. When <code>boundary="periodic"</code> the resulting wavelet and
scaling coefficients are computed without making changes to the
original series - the pyramid algorithm treats <code>X</code> as if it is
circular. However, when <code>boundary="reflection"</code> a call is made to
<code>extend.series</code>, resulting in a new series which is reflected to
twice the length of the original series.  The wavelet and scaling
coefficients are then computed by using a periodic boundary condition
on the reflected sereis, resulting in twice as many wavelet and
scaling coefficients at each level.</p>


<h3>Value</h3>

<p>Returns an object of class <code>dwt</code>, which is an S4 object with
slots 
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet coefficients.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level scaling coefficients.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A <code>wt.filter</code> object containing information for
the filter used in the decomposition. See <code>help(wt.filter)</code> for
details.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>An integer value representing the level of wavelet
decomposition.</p>
</td></tr>
<tr><td><code>n.boundary</code></td>
<td>
<p>A numeric vector indicating the number of boundary
coefficients at each level of the decomposition.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>A character string indicating the boundary method used
in the decomposition. Valid values are &quot;periodic&quot; or &quot;reflection&quot;.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The original time series, <code>X</code>, in matrix format.</p>
</td></tr>
<tr><td><code>class.X</code></td>
<td>
<p>A character string indicating the class of the input
series.  Possible values are <code>"ts"</code>, <code>"mts"</code>,
<code>"numeric"</code>, <code>"matrix"</code>, or <code>"data.frame"</code>.</p>
</td></tr>
<tr><td><code>attr.X</code></td>
<td>
<p>A list containing the attributes information of the
original time series, <code>X</code>.  This is useful if <code>X</code> is an
object of class <code>ts</code> or <code>mts</code> and it is desired to retain
relevant time information. If the original time series, <code>X</code>, is
a matrix or has no attributes, then <code>attr.X</code> is an empty list.</p>
</td></tr>
<tr><td><code>aligned</code></td>
<td>
<p>A logical value indicating whether the wavelet and
scaling coefficients have been phase shifted so as to be aligned
with relevant time information from the original series. The value
of this slot is initially FALSE and can only be changed to TRUE via
the <code>align</code> function, with the <code>dwt</code> object as input.</p>
</td></tr>
<tr><td><code>coe</code></td>
<td>
<p>A logical value indicating whether the center of energy
method was used in phase alignement of the wavelet and scaling
coefficients. By default, this value is FALSE (and will always be
FALSE when <code>aligned</code> is FALSE) and will be set to true if the
<code>dwt</code> object is phase shifted via the <code>align</code> function and
center of energy method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and compute DWT
newX &lt;- cbind(X1,X2)
wt &lt;- dwt(newX, n.levels=3, boundary="reflection", fast=FALSE)
</code></pre>

<hr>
<h2 id='dwt-class'>
Discrete Wavelet Transform Object
</h2><span id='topic+dwt-class'></span>

<h3>Description</h3>

<p>An S4 object containing discrete wavelet transform information.
</p>


<h3>Slots</h3>


<dl>
<dt>W</dt><dd><p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet coefficients.</p>
</dd>
<dt>V</dt><dd><p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level scaling coefficients.</p>
</dd>
<dt>filter</dt><dd><p>A <code>wt.filter</code> object containing information for
the filter used in the decomposition. See <code>help(wt.filter)</code> for
details.</p>
</dd>
<dt>level</dt><dd><p>An integer value representing the level of wavelet
decomposition.</p>
</dd>
<dt>n.boundary</dt><dd><p>A numeric vector indicating the number of boundary
coefficients at each level of the decomposition.</p>
</dd>
<dt>boundary</dt><dd><p>A character string indicating the boundary method used
in the decomposition. Valid values are &quot;periodic&quot; or &quot;reflection&quot;.</p>
</dd>
<dt>series</dt><dd><p>The original time series, <code>X</code>, in matrix format.</p>
</dd>
<dt>class.X</dt><dd><p>A character string indicating the class of the input
series.  Possible values are <code>"ts"</code>, <code>"mts"</code>,
<code>"numeric"</code>, <code>"matrix"</code>, or <code>"data.frame"</code>.</p>
</dd>
<dt>attr.X</dt><dd><p>A list containing the attributes information of the
original time series, <code>X</code>.  This is useful if <code>X</code> is an
object of class <code>ts</code> or <code>mts</code> and it is desired to retain
relevant time information. If the original time series, <code>X</code>, is
a matrix or has no attributes, then <code>attr.X</code> is an empty list.</p>
</dd>
<dt>aligned</dt><dd><p>A logical value indicating whether the wavelet and
scaling coefficients have been phase shifted so as to be aligned
with relevant time information from the original series. The value
of this slot is initially FALSE and can only be changed to TRUE via
the <code>align</code> function, with the <code>dwt</code> object as input.</p>
</dd>
<dt>coe</dt><dd><p>A logical value indicating whether the center of energy
method was used in phase alignement of the wavelet and scaling
coefficients. By default, this value is FALSE (and will always be
FALSE when <code>aligned</code> is FALSE) and will be set to true if the
<code>dwt</code> object is phase shifted via the <code>align</code> function and
center of energy method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods
for Time Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+modwt-class">modwt-class</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>

<hr>
<h2 id='dwt.forward'>
Discrete Wavelet Transform and Maximal Overlap Discrete Wavelet
Tranform Forward and Backward Pyramid Algorithm
</h2><span id='topic+dwt.forward'></span><span id='topic+dwt.backward'></span><span id='topic+modwt.forward'></span><span id='topic+modwt.backward'></span>

<h3>Description</h3>

<p>Implementation of DWT and MODWT forward and backward pyramid
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.forward(V, filter)
dwt.backward(W, V, filter)
modwt.forward(V, filter, j)
modwt.backward(W, V, filter, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.forward_+3A_w">W</code></td>
<td>
<p>A vector of wavelet coefficients.</p>
</td></tr>
<tr><td><code id="dwt.forward_+3A_v">V</code></td>
<td>
<p>A vector of scaling coefficients.</p>
</td></tr>
<tr><td><code id="dwt.forward_+3A_filter">filter</code></td>
<td>
<p>A <code>wt.filter</code> object.</p>
</td></tr>
<tr><td><code id="dwt.forward_+3A_j">j</code></td>
<td>
<p>The level of wavelet and scaling coefficients to compute (for
forward algorithm) or the level of wavelet and scaling coefficient
inputs (for inverse algorithm).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of the DWT and MODWT forward and backward
pyramid algorithms using pseudocode written by Percival and Walden 
(2000), pp. 100-101, 177-178. These functions are intended primarily
as helper functions for the <code>dwt</code>, <code>modwt</code>, <code>idwt</code> and
<code>imodwt</code> functions.</p>


<h3>Value</h3>

<p><code>dwt.forward</code> and <code>modwt.forward</code> return a list of two
elements containing vectors of wavelet and scaling coefficients for
the subsequent level of analysis. <code>dwt.backward</code> and
<code>modwt.backward</code> return a vector of scaling coefficients for the
previous level of analysis.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# compute the LA8 wavelet filter for both DWT and MODWT
la8.dwt &lt;- wt.filter()
la8.modwt &lt;- wt.filter(modwt=TRUE)

# compute the DWT and MODWT level one wavelet and scaling coefficients
wt.dwt &lt;- dwt.forward(X1, la8.dwt)
wt.modwt &lt;- modwt.forward(X2, la8.modwt, 1)

# compute the original series with the level one coefficients
newX.dwt &lt;- dwt.backward(wt.dwt$W, wt.dwt$V, la8.dwt)
newX.modwt &lt;- modwt.backward(wt.modwt$W, wt.modwt$V, la8.modwt, 1)
</code></pre>

<hr>
<h2 id='ecg'>Electrocardiogram Data</h2><span id='topic+ecg'></span>

<h3>Description</h3>

<p>Electrocardiogram measurements for an individual with arhythmia.
Observations were made over an 11.37 second interval at a rate of 180
samples per second. For more detailed information regarding the
collection of this data, see Percival and Walden (2000), p. 125.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecg)</code></pre>


<h3>Format</h3>

<p>A time series object containing 2048 observations.</p>


<h3>Source</h3>

<p>http://www.ms.washington.edu/~s530/data.html</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press, sec. 4.10.
</p>

<hr>
<h2 id='extend.series'>
Extend a Time Series
</h2><span id='topic+extend.series'></span>

<h3>Description</h3>

<p>Extends a univariate or multivariate time series beyond its original
length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend.series(X, method="reflection", length="double", n, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend.series_+3A_x">X</code></td>
<td>
<p>A univariate or multivariate time series. Numeric vectors,
matrices and data frames are accepted.</p>
</td></tr>
<tr><td><code id="extend.series_+3A_method">method</code></td>
<td>
<p>A character string indicating which extension method to
use. Possible values are <code>"periodic"</code>, <code>"reflection"</code>,
<code>"zero"</code>, <code>"mean"</code>, and <code>"reflection.inverse"</code>.</p>
</td></tr>
<tr><td><code id="extend.series_+3A_length">length</code></td>
<td>
<p>A character string indicating how to determine the
length of the extended series. Possible values are
<code>"aribitrary"</code>, <code>"powerof2"</code>, and <code>"double"</code>.</p>
</td></tr>
<tr><td><code id="extend.series_+3A_n">n</code></td>
<td>
<p>An integer value specifying the length of the extended
series. This argument is only relevant when <code>length =
      "arbitrary"</code>.</p>
</td></tr>
<tr><td><code id="extend.series_+3A_j">j</code></td>
<td>
<p>An integer value specifying the power of two of which the
length of the extended series should be a multiple. This argument is
only relevant for <code>length = "powerof2"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original time series, <code>X</code>, is extended to a new length
as determined by <code>length</code>: if <code>length = "arbitrary"</code>, a value
for the argument <code>n</code> must be specified in order to extend the
series to length <code>n</code>; if <code>length = "powerof2"</code> the series
will be extended to the nearst multiple of <code class="reqn">2^j</code>, where <code>j</code>
must be specified as an argument to the function;  if <code>length =
  "double"</code> the series will be extended to twice its original length.
</p>
<p>Once the length of the extended series is determined, the actual
extension is performed using one of five methods: if <code>method =
  "periodic"</code> a periodic extension is made by concatenating the series
with itself (without changing the order of the values); if
<code>method = "reflection"</code> an extension is made by concatenating
the series with a reflection (reverse ordering) of itself; if
<code>method = "zero"</code> the series is padded with zeros; if
<code>method = "mean"</code> the series is padded with its mean; if
<code>method = "reflection.inverse"</code> an extension is made by
concatenating the series with a reflection (reverse ordering) of
itself that is further reflected of the horizontal axis <code class="reqn">y = x_N</code>
where <code class="reqn">x_N</code> is the last value of the observed series.
</p>
<p>In the case that the series is extended beyond twice it's original
length, the <code>"periodic"</code> and <code>"reflection"</code> methods are
repetetively applied so that every subseries of length <code class="reqn">N</code> (the
length of the original series) is either a periodic or reflected
extension of any other <code class="reqn">N</code> adjacent values. Similarly, the
<code>"reflection.inverse"</code> method is repetetively applied so that
every <code class="reqn">2N</code> values are a periodic extension of any adjacent
<code class="reqn">2N</code> values.
</p>


<h3>Value</h3>

<p>The extended time series, in its original class.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and extend using reflection method
newX &lt;- cbind(X1,X2)
newX.ext1 &lt;- extend.series(newX, length="arbitrary", n=64)
plot.ts(newX.ext1)

# apply another extension method
newX.ext2 &lt;- extend.series(newX, method="reflection.inverse",
                           length="powerof2", j=6)
plot.ts(newX.ext2) 
</code></pre>

<hr>
<h2 id='figure108.wt.filter'>
Plot Multiple DWT Wavelet or Scaling Filters
</h2><span id='topic+figure108.wt.filter'></span>

<h3>Description</h3>

<p>Plots multiple DWT Wavelet or Scaling Filters similar to
Figure 108 in <em>Wavelet Methods for Time Series Analysis</em> by
Percival and Walden (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>figure108.wt.filter(filter.objects, level = 1, l = NULL, wavelet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="figure108.wt.filter_+3A_filter.objects">filter.objects</code></td>
<td>
<p>List containing 'wt.filter' objects, character
strings specifying a wavelet filter, or numeric vectors of wavelet
coefficients. The list can contain a combination of 'wt.filter'
objects, character strings, and numeric vectors. If only one filter
is to be plotted, a single 'wt.filter' object, character string, or
numeric vector may be supplied. See 'help(wt.filter)' for acceptable
filter names.</p>
</td></tr>
<tr><td><code id="figure108.wt.filter_+3A_level">level</code></td>
<td>
<p>If <code>filter.object</code> is only a single 'wt.filter'
object, character string, or numeric vector, then the level of the
filter can be specified in <code>level</code>.  Defaulted to 1.</p>
</td></tr>
<tr><td><code id="figure108.wt.filter_+3A_l">l</code></td>
<td>
<p>Single integer representing the right hand limit of the
horizontal axis. If unspecified, it will default to the length
of the filter of greatest length given in
<code>filter.object</code>. Cannot be less than the length of the filter
of greatest length.</p>
</td></tr>
<tr><td><code id="figure108.wt.filter_+3A_wavelet">wavelet</code></td>
<td>
<p>A logical flag indicating whether to plot the wavelet
(high pass) or scaling (low pass) filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotting space available for each filter is dictated by the
value of greatest magnitude of all the filters plotted. The vertical
plotting space for each level will then be 2 times the absolute
value of this magnitude.
</p>
<p>The filters are successively plotted in the order given in
<code>filter.object</code>, where the first filter in <code>filter.object</code>
is drawn at the top of the plot region, and the successive filters
are plotted below.  
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter">wt.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting the LA8 Wavelet Filter
filter &lt;- wt.filter()
figure108.wt.filter(filter)

# Alternatively
figure108.wt.filter("la8")

# Plotting the Haar, D4, D6 Wavelet Filters
figure108.wt.filter(list("haar", "d4", "d6"))

# Plotting the Haar, D4, D6 Scaling Filters
figure108.wt.filter(list("haar", "d4", "d6"), wavelet = FALSE)

# Alternatively
haar &lt;- wt.filter("haar")
d6 &lt;- wt.filter("d6")
figure108.wt.filter(list(haar, "d4", d6), wavelet = FALSE)

# Adding an "made up" filter (represented by c(1,-1,1,-1)
figure108.wt.filter(list(haar, "d4", d6, c(1,-1,1,-1)), wavelet = FALSE)
</code></pre>

<hr>
<h2 id='figure98.wt.filter'>
Plot a DWT Wavelet or Scaling Filter for Specific Levels.
</h2><span id='topic+figure98.wt.filter'></span>

<h3>Description</h3>

<p>Plots a DWT Wavelet or Scaling Filter for specific levels similar to
Figure 98 in <em>Wavelet Methods for Time Series Analysis</em> by
Percival and Walden (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>figure98.wt.filter(filter, levels = NULL, wavelet = TRUE, y.normalize =
TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="figure98.wt.filter_+3A_filter">filter</code></td>
<td>
<p>Either a 'wt.filter' object, a character string
specifying a wavelet filter, or a numeric vector of wavelet
coefficients. See 'help(wt.filter)' for acceptable filter 
names.</p>
</td></tr>
<tr><td><code id="figure98.wt.filter_+3A_levels">levels</code></td>
<td>
<p>Number or vector indicating levels of filter to
plot. See Details.</p>
</td></tr>
<tr><td><code id="figure98.wt.filter_+3A_wavelet">wavelet</code></td>
<td>
<p>A logical flag indicating whether to plot the wavelet
(high pass) or scaling (low pass) filter.</p>
</td></tr>
<tr><td><code id="figure98.wt.filter_+3A_y.normalize">y.normalize</code></td>
<td>
<p>A logical flag indicating whether to vertically
normalize each level of the filter to the plotting space available
for each level of the filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a single number is specified for <code>levels</code>, then the filter
of levels 1 through <code>levels</code> will be plotted.
Otherwise, a vector will specify which levels of the wavelet
coefficients will be plotted. If <code>levels</code> is not defined, it
will default to the vector 1:7.
</p>
<p>The plotting space available for each level of the filter is
dictated by the value of greatest magnitude of all the levels of
the filter plotted. The vertical plotting space for each level will
then be 2 times the absolute value of this magnitude.
</p>
<p>The label 'L sub j' on the horizontal axis varies from level to
level, but 'L sub j' indicates the length of a filter at level
j. The filter vector at a given level j is indexed from 0 to 'L sub
j' - 1. 'L sub j' is defined by formula 96a in <em>Wavelet Methods
for Time Series Analysis</em> by Percival and Walden (2000).
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter">wt.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting LA8 Wavelet Filter Coefficients Levels 1 through 7.
filter &lt;- wt.filter()
figure98.wt.filter(filter)

# Alternatively
figure98.wt.filter("la8")

# Plotting D4 Scaling Filter Coefficients Levels 1, 3, and 5 and not
# vertically normalizing each level to its plotting region.
figure98.wt.filter("d4", levels = c(1,3,5), wavelet = FALSE, y.normalize
= FALSE)
</code></pre>

<hr>
<h2 id='idwt'>
Inverse Discrete Wavelet Transform
</h2><span id='topic+idwt'></span>

<h3>Description</h3>

<p>Computes the inverse discrete wavelet transform for a discrete wavelet
transform that was obtained from a univariate or multivariate time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idwt(wt, fast=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idwt_+3A_wt">wt</code></td>
<td>
<p>A <code>dwt</code> object.</p>
</td></tr>
<tr><td><code id="idwt_+3A_fast">fast</code></td>
<td>
<p>A logical flag which, if true, indicates that the inverse
pyramid algorithm is computed with an internal C function.
Otherwise, only R code is used in all computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse discrete wavelet transform is computed via the
inverse pyramid algorithm, using pseudocode written by Percival and
Walden (2000), p. 101.</p>


<h3>Value</h3>

<p>An object with class and attributes equivalent to the original
series that was used to compute the DWT.  In general, the output will
be equivalent to the original series (i.e. X = idwt(dwt(X))), however
when thresholding or shrinkage methods are used on the <code>dwt</code>
object, the output of <code>idwt</code> may differ from the original series.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+imodwt">imodwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and compute DWT
newX &lt;- cbind(X1,X2)
wt &lt;- dwt(newX, n.levels=3, boundary="reflection")

# compute the inverse DWT
invX &lt;- idwt(wt)

# compare
newX
invX
</code></pre>

<hr>
<h2 id='imodwt'>
Inverse Maximal Overlap Discrete Wavelet Transform
</h2><span id='topic+imodwt'></span>

<h3>Description</h3>

<p>Computes the inverse maximal overlap discrete wavelet transform for a
maximal overlap discrete wavelet transform that was obtained from a
univariate or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imodwt(wt, fast=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imodwt_+3A_wt">wt</code></td>
<td>
<p>A <code>modwt</code> object.</p>
</td></tr>
<tr><td><code id="imodwt_+3A_fast">fast</code></td>
<td>
<p>A logical flag which, if true, indicates that the inverse
pyramid algorithm is computed with an internal C function.
Otherwise, only R code is used in all computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse discrete wavelet transform is computed via the
inverse pyramid algorithm, using pseudocode written by Percival and
Walden (2000), p. 101.</p>


<h3>Value</h3>

<p>An object with class and attributes equivalent to the original
series that was used to compute the MODWT.  In general, the output will
be equivalent to the original series (i.e. X = imodwt(modwt(X))), however
when thresholding or shrinkage methods are used on the <code>modwt</code>
object, the output of <code>imodwt</code> may differ from the original series.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+idwt">idwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and compute MODWT
newX &lt;- cbind(X1,X2)
wt &lt;- modwt(newX, n.levels=3, boundary="reflection")

# compute the inverse MODWT
invX &lt;- imodwt(wt)

# compare
newX
invX
</code></pre>

<hr>
<h2 id='modwt'>
Maximal Overlap Discrete Wavelet Transform
</h2><span id='topic+modwt'></span><span id='topic+print.modwt'></span><span id='topic+summary.modwt'></span>

<h3>Description</h3>

<p>Computes the maximal overlap discrete wavelet transform coefficients
for a univariate or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt(X, filter="la8", n.levels, boundary="periodic", fast=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt_+3A_x">X</code></td>
<td>
<p>A univariate or multivariate time series. Numeric vectors,
matrices and data frames are also accepted.</p>
</td></tr>
<tr><td><code id="modwt_+3A_filter">filter</code></td>
<td>
<p>Either a <code>wt.filter</code> object, a character string
indicating which wavelet filter to use in the decomposition, or a
numeric vector of wavelet coefficients (not scaling coefficients). See
<code>help(wt.filter)</code> for acceptable filter names.</p>
</td></tr>
<tr><td><code id="modwt_+3A_n.levels">n.levels</code></td>
<td>
<p>An integer specifying the level of the decomposition.
By default this is the value J such that the length of <code class="reqn">X</code> is at
least as great as the length of the level <code class="reqn">J</code> wavelet filter,
but less than the length of the level <code class="reqn">J+1</code> wavelet
filter. Thus, <code class="reqn">J \le \log{(\frac{N-1}{L-1}+1)}</code>, where <code class="reqn">N</code> is the length of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="modwt_+3A_boundary">boundary</code></td>
<td>
<p>A character string indicating which boundary method to
use. <code>boundary = "periodic"</code> and <code>boundary = "reflection"</code>
are the only supported methods at this time.</p>
</td></tr>
<tr><td><code id="modwt_+3A_fast">fast</code></td>
<td>
<p>A logical flag which, if true, indicates that the pyramid
algorithm is computed with an internal C function.  Otherwise, only
R code is used in all computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximal overlap discrete wavelet transform is computed via
the pyramid algorithm, using pseudocode written by Percival and Walden
(2000), p. 178. When <code>boundary="periodic"</code> the resulting wavelet
and scaling coefficients are computed without making changes to the
original series - the pyramid algorithm treats <code>X</code> as if it is
circular. However, when <code>boundary="reflection"</code> a call is made to
<code>extend.series</code>, resulting in a new series which is reflected to
twice the length of the original series.  The wavelet and scaling
coefficients are then computed by using a periodic boundary condition
on the reflected sereis, resulting in twice as many wavelet and
scaling coefficients at each level.</p>


<h3>Value</h3>

<p>Returns an object of class <code>modwt</code>, which is an S4 object with
slots 
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet coefficients.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level scaling coefficients.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A <code>wt.filter</code> object containing information for
the filter used in the decomposition. See <code>help(wt.filter)</code> for
details.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>An integer value representing the level of wavelet
decomposition.</p>
</td></tr>
<tr><td><code>n.boundary</code></td>
<td>
<p>A numeric vector indicating the number of boundary
coefficients at each level of the decomposition.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>A character string indicating the boundary method used
in the decomposition. Valid values are &quot;periodic&quot; or &quot;reflection&quot;.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The original time series, <code>X</code>, in matrix format.</p>
</td></tr>
<tr><td><code>class.X</code></td>
<td>
<p>A character string indicating the class of the input
series.  Possible values are <code>"ts"</code>, <code>"mts"</code>,
<code>"numeric"</code>, <code>"matrix"</code>, or <code>"data.frame"</code>.</p>
</td></tr>
<tr><td><code>attr.X</code></td>
<td>
<p>A list containing the attributes information of the
original time series, <code>X</code>.  This is useful if <code>X</code> is an
object of class <code>ts</code> or <code>mts</code> and it is desired to retain
relevant time information. If the original time series, <code>X</code>, is
a matrix or has no attributes, then <code>attr.X</code> is an empty list.</p>
</td></tr>
<tr><td><code>aligned</code></td>
<td>
<p>A logical value indicating whether the wavelet and
scaling coefficients have been phase shifted so as to be aligned
with relevant time information from the original series. The value
of this slot is initially FALSE and can only be changed to TRUE via
the <code>align</code> function, with the <code>modwt</code> object as input.</p>
</td></tr>
<tr><td><code>coe</code></td>
<td>
<p>A logical value indicating whether the center of energy
method was used in phase alignement of the wavelet and scaling
coefficients. By default, this value is FALSE (and will always be
FALSE when <code>aligned</code> is FALSE) and will be set to true if the
<code>modwt</code> object is phase shifted via the <code>align</code> function
and center of energy method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and compute DWT
newX &lt;- cbind(X1,X2)
wt &lt;- dwt(newX, n.level=3, boundary="reflection", fast=FALSE)
</code></pre>

<hr>
<h2 id='modwt-class'>
Maximal Overlap Discrete Wavelet Transform Object
</h2><span id='topic+modwt-class'></span>

<h3>Description</h3>

<p>An S4 object containing maximal overlap discrete wavelet transform
information.
</p>


<h3>Slots</h3>


<dl>
<dt>W</dt><dd><p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet coefficients.</p>
</dd>
<dt>V</dt><dd><p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level scaling coefficients.</p>
</dd>
<dt>filter</dt><dd><p>A <code>wt.filter</code> object containing information for
the filter used in the decomposition. See <code>help(wt.filter)</code> for
details.</p>
</dd>
<dt>level</dt><dd><p>An integer value representing the level of wavelet
decomposition.</p>
</dd>
<dt>n.boundary</dt><dd><p>A numeric vector indicating the number of boundary
coefficients at each level of the decomposition.</p>
</dd>
<dt>boundary</dt><dd><p>A character string indicating the boundary method used
in the decomposition. Valid values are &quot;periodic&quot; or &quot;reflection&quot;.</p>
</dd>
<dt>series</dt><dd><p>The original time series, <code>X</code>, in matrix format.</p>
</dd>
<dt>class.X</dt><dd><p>A character string indicating the class of the input
series.  Possible values are <code>"ts"</code>, <code>"mts"</code>,
<code>"numeric"</code>, <code>"matrix"</code>, or <code>"data.frame"</code>.</p>
</dd>
<dt>attr.X</dt><dd><p>A list containing the attributes information of the
original time series, <code>X</code>.  This is useful if <code>X</code> is an
object of class <code>ts</code> or <code>mts</code> and it is desired to retain
relevant time information. If the original time series, <code>X</code>, is
a matrix or has no attributes, then <code>attr.X</code> is an empty list.</p>
</dd>
<dt>aligned</dt><dd><p>A logical value indicating whether the wavelet and
scaling coefficients have been phase shifted so as to be aligned
with relevant time information from the original series. The value
of this slot is initially FALSE and can only be changed to TRUE via
the <code>align</code> function, with the <code>modwt</code> object as input.</p>
</dd>
<dt>coe</dt><dd><p>A logical value indicating whether the center of energy
method was used in phase alignement of the wavelet and scaling
coefficients. By default, this value is FALSE (and will always be
FALSE when <code>aligned</code> is FALSE) and will be set to true if the
<code>modwt</code> object is phase shifted via the <code>align</code> function
and center of energy method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods
for Time Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+dwt-class">dwt-class</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>

<hr>
<h2 id='mra'>
Multiresolution Analysis
</h2><span id='topic+mra'></span>

<h3>Description</h3>

<p>Computes the multiresolution analysis for a univariate or multivariate
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra(X, filter="la8", n.levels, boundary="periodic", fast=TRUE, method="dwt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra_+3A_x">X</code></td>
<td>
<p>A univariate or multivariate time series. Numeric vectors,
matrices and data frames are also accepted.</p>
</td></tr>
<tr><td><code id="mra_+3A_filter">filter</code></td>
<td>
<p>Either a <code>wt.filter</code> object, a character string
indicating which wavelet filter to use in the decomposition, or a
numeric vector of wavelet coefficients (not scaling coefficients). See
<code>help(wt.filter)</code> for acceptable filter names.</p>
</td></tr>
<tr><td><code id="mra_+3A_n.levels">n.levels</code></td>
<td>
<p>An integer specifying the level of the decomposition.
By default this is the value J such that the length of <code class="reqn">X</code> is at
least as great as the length of the level <code class="reqn">J</code> wavelet filter,
but less than the length of the level <code class="reqn">J+1</code> wavelet
filter. Thus, <code class="reqn">J \le \log{(\frac{N-1}{L-1}+1)}</code>, where <code class="reqn">N</code> is the length of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="mra_+3A_boundary">boundary</code></td>
<td>
<p>A character string indicating which boundary method to
use. <code>boundary = "periodic"</code> and <code>boundary = "reflection"</code>
are the only supported methods at this time.</p>
</td></tr>
<tr><td><code id="mra_+3A_fast">fast</code></td>
<td>
<p>A logical flag which, if true, indicates that the pyramid
algorithm is computed with an internal C function.  Otherwise, only
R code is used in all computations.</p>
</td></tr>
<tr><td><code id="mra_+3A_method">method</code></td>
<td>
<p>A character string, taking values &quot;dwt&quot; or &quot;modwt&quot;,
that indicates which type of transform to use when computing the
MRA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>mra</code>, which is an S4 object with
slots 
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet detail.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet smooths.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>A <code>wt.filter</code> object containing information for
the filter used in the decomposition. See <code>help(wt.filter)</code> for
details.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>An integer value representing the level of wavelet
decomposition.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>A character string indicating the boundary method used
in the wavelet decomposition. Valid values are &quot;periodic&quot; or
&quot;reflection&quot;.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The original time series, <code>X</code>, in matrix format.</p>
</td></tr>
<tr><td><code>class.X</code></td>
<td>
<p>A character string indicating the class of the input
series.  Possible values are <code>"ts"</code>, <code>"mts"</code>,
<code>"numeric"</code>, <code>"matrix"</code>, or <code>"data.frame"</code>.</p>
</td></tr>
<tr><td><code>attr.X</code></td>
<td>
<p>A list containing the attributes information of the
original time series, <code>X</code>.  This is useful if <code>X</code> is an
object of class <code>ts</code> or <code>mts</code> and it is desired to retain
relevant time information. If the original time series, <code>X</code>, is
a matrix or has no attributes, then <code>attr.X</code> is an empty list.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating which type of wavelet
decomposition was performed (either &quot;dwt&quot; or &quot;modwt&quot;).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain the two series listed in Percival and Walden (2000), page 42
X1 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,.7,.9,0,.3)
X2 &lt;- c(.2,-.4,-.6,-.5,-.8,-.4,-.9,0,-.2,.1,-.1,.1,-.7,.9,0,.3)

# combine them and compute MRA
newX &lt;- cbind(X1,X2)
mra.out &lt;- mra(newX, n.levels=3, boundary="reflection")
</code></pre>

<hr>
<h2 id='mra-class'>
Multiresolution Analysis Object
</h2><span id='topic+mra-class'></span>

<h3>Description</h3>

<p>An S4 object containing multiresolution analysis information.
</p>


<h3>Slots</h3>


<dl>
<dt>D</dt><dd><p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet detail.</p>
</dd>
<dt>S</dt><dd><p>A list with element <code class="reqn">i</code> comprised of a matrix containing
the <code class="reqn">i</code>th level wavelet smooths.</p>
</dd>
<dt>filter</dt><dd><p>A <code>wt.filter</code> object containing information for
the filter used in the decomposition. See <code>help(wt.filter)</code> for
details.</p>
</dd>
<dt>level</dt><dd><p>An integer value representing the level of wavelet
decomposition.</p>
</dd>
<dt>boundary</dt><dd><p>A character string indicating the boundary method used
in the wavelet decomposition. Valid values are &quot;periodic&quot; or
&quot;reflection&quot;.</p>
</dd>
<dt>series</dt><dd><p>The original time series, <code>X</code>, in matrix format.</p>
</dd>
<dt>class.X</dt><dd><p>A character string indicating the class of the input
series.  Possible values are <code>"ts"</code>, <code>"mts"</code>,
<code>"numeric"</code>, <code>"matrix"</code>, or <code>"data.frame"</code>.</p>
</dd>
<dt>attr.X</dt><dd><p>A list containing the attributes information of the
original time series, <code>X</code>.  This is useful if <code>X</code> is an
object of class <code>ts</code> or <code>mts</code> and it is desired to retain
relevant time information. If the original time series, <code>X</code>, is
a matrix or has no attributes, then <code>attr.X</code> is an empty list.</p>
</dd>
<dt>method</dt><dd><p>A character string indicating which type of wavelet
decomposition was performed (either &quot;dwt&quot; or &quot;modwt&quot;).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods
for Time Series Analysis</em>, Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>,
<code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>

<hr>
<h2 id='nile'>Yearly Nile River Minima</h2><span id='topic+nile'></span>

<h3>Description</h3>

<p>Yearly minimum water level of the Nile River starting in 622 A.D. and
ending in 1284 A.D. For more information see Percival and Walden
(2000), p. 190.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nile)</code></pre>


<h3>Format</h3>

<p>A time series object containing 683 observations.</p>


<h3>Source</h3>

<p>http://www.ms.washington.edu/~s530/data.html</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press, sec. 5.9.
</p>

<hr>
<h2 id='ocean'>Vertical Ocean Sheer Measurements</h2><span id='topic+ocean'></span>

<h3>Description</h3>

<p>Measurements of vertical ocean sheer, obtained by dropping an
instrument veritcally into the ocean and recording observations at 0.1
meter intervals.  Starting depth for the series is 350.0 meters and
ending depth is 1037.4 meters. For more detailed information regarding
the collection of this data, see Percival and Walden (2000), p. 193.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ocean)</code></pre>


<h3>Format</h3>

<p>A time series object containing 6875 observations.</p>


<h3>Source</h3>

<p>http://www.ms.washington.edu/~s530/data.html</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press, sec. 5.10.
</p>

<hr>
<h2 id='plot.dwt'>
Plot DWT Coefficients
</h2><span id='topic+plot.dwt'></span>

<h3>Description</h3>

<p>Plot DWT wavelet and scaling coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dwt'
plot(x, levels = NULL, draw.boundary = FALSE, type = "stack",
col.plot = "black", col.boundary = "red", X.xtick.at = NULL, X.ytick.at
= NULL, Stack.xtick.at = NULL, Stack.ytick.at = NULL, X.xlab = "t",
y.rlabs = TRUE, plot.X = TRUE, plot.W = TRUE, plot.V = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dwt_+3A_x">x</code></td>
<td>
<p>An object of class <code>dwt</code>.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_levels">levels</code></td>
<td>
<p>Number, vector, or list of two vectors indicating range
of levels to plot. See details.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_draw.boundary">draw.boundary</code></td>
<td>
<p>Logical value indicating whether to draw boundary
coefficients.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_type">type</code></td>
<td>
<p>Type of plot to draw. Currently only &quot;stack&quot; is
implemented.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_col.plot">col.plot</code></td>
<td>
<p>Color of wavelet and scaling coefficients.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_col.boundary">col.boundary</code></td>
<td>
<p>Color of boundary coefficient lines.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_x.xtick.at">X.xtick.at</code></td>
<td>
<p>Vector specifying the extreme tick mark locations
and the number of intervals between those extreme tick marks on the
horizontal axis of the plot of the original times series. This
vector takes the form similar to par(&quot;xaxp&quot;), and is defaulted to
par(&quot;xaxp&quot;) when <code>X.xtick.at</code> is not specified.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_x.ytick.at">X.ytick.at</code></td>
<td>
<p>Vector specifying the extreme tick mark locations
and the number of intervals between those extreme tick marks on the
vertical axis of the plot of the original times series. This vector
takes the form similar to par(&quot;yaxp&quot;), and is defaulted to
par(&quot;yaxp&quot;) when <code>X.ytick.at</code> is not specified.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_stack.xtick.at">Stack.xtick.at</code></td>
<td>
<p>Vector of form similar to <code>X.xtick.at</code>
specifying the tick mark locations on the horizontal
axis of the stacked plot. This is applicable only if <code>plot.X</code>
is FALSE.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_stack.ytick.at">Stack.ytick.at</code></td>
<td>
<p>Vector of form similar to <code>X.ytick.at</code>
specifying the tick mark locations on the vertical
axis of the stacked plot. This is applicable only if <code>plot.X</code>
is FALSE.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_x.xlab">X.xlab</code></td>
<td>
<p>String specifying the label of the horizontal axis of
the plot of the original time series.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_y.rlabs">y.rlabs</code></td>
<td>
<p>Logical flag indicating whether to draw the vertical
labels on the right vertical axis of the stacked plot.  These labels
indicate the number of boundary coefficients to the right of the
right boundary line, and the level of decomposition of the wavelet
(or scaling) coefficients.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_plot.x">plot.X</code></td>
<td>
<p>Logical flag indicating whether to draw original time
series.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_plot.w">plot.W</code></td>
<td>
<p>Logical flag indicating whether to draw the wavelet
coefficients in the stacked plot.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_plot.v">plot.V</code></td>
<td>
<p>Logical flag indicating whether to draw the scaling
coefficients in the stacked plot.</p>
</td></tr>  
<tr><td><code id="plot.dwt_+3A_...">...</code></td>
<td>
<p>Additional paramters that are acceptable arguments to the
generic <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.dwt</code> plots the DWT wavelet and scaling coefficients. The
<code>type</code> parameter species the type of plot, which is currently
only stack. If the DWT object is defined for multiple time series,
only the data pertaining to the first time series of the DWT object
is plotted. Thus, only the wavelet coefficients and scaling
coefficients of the first time series of the DWT object will be
plotted.
</p>
<p>If a single number is specified for <code>levels</code>, then the wavelet
coefficients of levels 1 through <code>levels</code> will be plotted.
Otherwise, a vector or the first element of a list will specify
which levels of the wavelet coefficients will be plotted.
Unless specified in the second element of a list, only one level
of scaling coefficients will be plotted and this level is equal
to the highest level of the wavelet coefficients plotted.
</p>
<p>For each respective axis, the distance between a tick mark on the
plot of the original time series is equivalent to the distance
between a tick mark on the stacked plot. Thus, when altering the
relative spacing of the tick marks on the plot of the original time
series using <code>X.xtick.at</code> or <code>X.ytick.at</code>, the tick marks
of the stacked plot are automatically adjusted. If the plot of the
original time series is not drawn, then the user can alter the
spacing of the tick marks using <code>Stack.xtick.at</code> and
<code>Stack.ytick.at</code> for the horizontal and vertical axes,
respectively.
</p>
<p>One of <code>plot.W</code> or <code>plot.V</code> must be TRUE.
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stackplot">stackplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rnorm(2048)
dwtobj &lt;- dwt(X)

# Plotting wavelet coefficients of levels 1 through 6 and scaling
# coefficients of level 6.
plot.dwt(dwtobj, levels = 6)

# Plotting wavelet coefficients of levels 1, 3, 5, and scaling
# coefficients of levels 4 and 5, and green boundary coefficient lines.
plot.dwt(dwtobj, levels = list(c(1,3,5),c(4,5)), draw.boundary = TRUE,
col.boundary = "green")

# Plotting wavelet coefficients of level 1 through 6 and not plotting
# any scaling coefficients.
plot.dwt(dwtobj, levels = 6, plot.V = FALSE)
</code></pre>

<hr>
<h2 id='plot.dwt.multiple'>
Plot Multiple DWT Objects
</h2><span id='topic+plot.dwt.multiple'></span>

<h3>Description</h3>

<p>Plot wavelet and scaling coefficients of multiple DWT objects.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiple'
plot.dwt(x, levels = NULL, ylim = NULL, draw.dashed.lines =
TRUE, draw.level.labels = TRUE, col = c("red","blue"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dwt.multiple_+3A_x">x</code></td>
<td>
<p>A list of <code>dwt</code> objects.</p>
</td></tr>
<tr><td><code id="plot.dwt.multiple_+3A_levels">levels</code></td>
<td>
<p>Number, vector, or list of two vectors indicating range
of levels to plot.  See details.</p>
</td></tr>
<tr><td><code id="plot.dwt.multiple_+3A_ylim">ylim</code></td>
<td>
<p>Vector specifying the lower and upper limits of the
vertical y-axis of each plot.</p>
</td></tr>
<tr><td><code id="plot.dwt.multiple_+3A_draw.dashed.lines">draw.dashed.lines</code></td>
<td>
<p>Boolean indicating whether dashed lines
should be drawn between levels of wavelet and scaling coefficients.</p>
</td></tr>
<tr><td><code id="plot.dwt.multiple_+3A_draw.level.labels">draw.level.labels</code></td>
<td>
<p>Boolean indicating whether the labels for the
levels of wavelet and scaling coefficients should be drawn.</p>
</td></tr>  
<tr><td><code id="plot.dwt.multiple_+3A_col">col</code></td>
<td>
<p>Vector of length 2 for the alternating colors of the
coefficients to be drawn.  The colors alternate by level of the
wavelet or scaling coefficients drawn.  The first element of the
vector is the color of the coefficients of the first level drawn.</p>
</td></tr>
<tr><td><code id="plot.dwt.multiple_+3A_...">...</code></td>
<td>
<p>Additional paramters that are acceptable arguments to the
generic <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a single number is specified for <code>levels</code>, then the wavelet
coefficients of levels 1 through <code>levels</code> will be plotted.
Otherwise, a vector or the first element of a list will specify
which levels of the wavelet coefficients will be plotted.
Unless specified in the second element of a list, only one level
of scaling coefficients will be plotted and this level is equal
to the highest level of the wavelet coefficients plotted. If a DWT
object is defined for multiple time series, only the data pertaining
to the first time series of the DWT object is plotted. Thus, only
the wavelet coefficients and scaling coefficients of the first time
series of the DWT objects will be plotted.
</p>
<p>For each <code>dwt</code>object in the list of <code>x</code>,
<code>plot.dwt.multiple</code> takes the coefficients of the <code>dwt</code>
object and concatenates wavelet coefficients and scaling
coefficients by levels specified in <code>levels</code>.  The wavelet
coefficients will always be plotted preceding the scaling
coefficients.
</p>
<p>This function allows users to visually examine differences in the
DWT transform of a time series using different filters (different
<code>dwt</code> objects).    
</p>
<p>For an example, see Figure 126 of <em>Wavelet Methods for Time
Series Analysis</em> by Percival and Walden (2000).
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for
Time Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dwt">plot.dwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rnorm(2048)
# Create DWT Object of X with the "la8" filter.
dwtobj1 &lt;- dwt(X, filter = "la8")
# Create DWT Object of X with the "d4" filter.
dwtobj2 &lt;- dwt(X, filter = "d4")
# Create DWT Object of X with the "haar" filter
dwtobj3 &lt;- dwt(X, filter = "haar")
# Create DWT Object of X with the "c6" filter
dwtobj4 &lt;- dwt(X, filter = "c6")

#Create list of dwt objects
dwtlist &lt;- list(dwtobj1, dwtobj2, dwtobj3, dwtobj4)

# Plot the dwt objects and the wavelet coefficients of level 1 through 6
# and the scaling coefficients of level 6.  The first level drawn will
# be purple and the next level drawn will be gold.
plot.dwt.multiple(dwtlist, levels = 6, col = c("purple", "gold"))

# Plot the dwt objects and the wavelet coefficients of level 1, 3, and 5
# and scaling coefficients of level 2, and 4.
plot.dwt.multiple(dwtlist, levels = list(c(1,3,5), c(2,4)))

</code></pre>

<hr>
<h2 id='plot.modwt'>
Plot MODWT Coefficients
</h2><span id='topic+plot.modwt'></span>

<h3>Description</h3>

<p>Plot MODWT wavelet and scaling coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modwt'
plot(x, levels = NULL, draw.boundary = FALSE, type = "stack",
col.plot = "black", col.boundary = "red", X.xtick.at = NULL, X.ytick.at
= NULL, Stack.xtick.at = NULL, Stack.ytick.at = NULL, X.xlab = "t",
y.rlabs = TRUE, plot.X = TRUE, plot.W = TRUE, plot.V = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.modwt_+3A_x">x</code></td>
<td>
<p>An object of class <code>dwt</code>.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_levels">levels</code></td>
<td>
<p>Number, vector, or list of two vectors indicating range
of levels to plot.  See details.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_draw.boundary">draw.boundary</code></td>
<td>
<p>Logical value indicating whether to draw boundary
coefficients.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_type">type</code></td>
<td>
<p>Type of plot to draw.  Currently only &quot;stack&quot; is
implemented.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_col.plot">col.plot</code></td>
<td>
<p>Color of wavelet and scaling coefficients.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_col.boundary">col.boundary</code></td>
<td>
<p>Color of boundary coefficient lines.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_x.xtick.at">X.xtick.at</code></td>
<td>
<p>Vector specifying the extreme tick mark locations
and the number of intervals between those extreme tick marks on the
horizontal axis of the plot of the original times series. This
vector takes the form similar to par(&quot;xaxp&quot;), and is defaulted to
par(&quot;xaxp&quot;) when <code>X.xtick.at</code> is not specified.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_x.ytick.at">X.ytick.at</code></td>
<td>
<p>Vector specifying the extreme tick mark locations
and the number of intervals between those extreme tick marks on the
vertical axis of the plot of the original times series. This vector
takes the form similar to par(&quot;yaxp&quot;), and is defaulted to
par(&quot;yaxp&quot;) when <code>X.ytick.at</code> is not specified.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_stack.xtick.at">Stack.xtick.at</code></td>
<td>
<p>Vector of form similar to <code>X.xtick.at</code>
specifying the tick mark locations on the horizontal
axis of the stacked plot. This is applicable only if <code>plot.X</code>
is FALSE.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_stack.ytick.at">Stack.ytick.at</code></td>
<td>
<p>Vector of form similar to <code>X.ytick.at</code>
specifying the tick mark locations on the vertical
axis of the stacked plot. This is applicable only if <code>plot.X</code>
is FALSE.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_x.xlab">X.xlab</code></td>
<td>
<p>String specifying the label of the horizontal axis of
the plot of the original time series.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_y.rlabs">y.rlabs</code></td>
<td>
<p>Logical flag indicating whether to draw the vertical
labels on the right vertical axis of the stacked plot.  These labels
indicate the number of boundary coefficients to the right of the
right boundary line, and the level of decomposition of the wavelet
(or scaling) coefficients.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_plot.x">plot.X</code></td>
<td>
<p>Logical flag indicating whether to draw original time
series.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_plot.w">plot.W</code></td>
<td>
<p>Logical flag indicating whether to draw the wavelet
coefficients in the stacked plot.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_plot.v">plot.V</code></td>
<td>
<p>Logical flag indicating whether to draw the scaling
coefficients in the stacked plot.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_...">...</code></td>
<td>
<p>Additional paramters that are acceptable arguments to the
generic <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.modwt</code> plots the MODWT wavelet and scaling coefficients.
The <code>type</code> parameter species the type of plot, which is currently
only stack. If the MODWT object is defined for multiple time series,
only the data pertaining to the first time series of the MODWT object
is plotted. Thus, only the wavelet coefficients and scaling
coefficients of the first time series of the MODWT object will be
plotted. If a single number is specified for <code>levels</code>, then the
wavelet coefficients of levels 1 through <code>levels</code> will be
plotted. Otherwise, a vector or the first element of a list will
specify which levels of the wavelet coefficients will be
plotted. Unless specified in the second element of a list, only one
level of scaling coefficients will be plotted and this level is equal
to the highest level of the wavelet coefficients plotted.
</p>
<p>For each respective axis, the distance between a tick mark on the plot
of the original time series is equivalent to the distance between a
tick mark on the stacked plot. Thus, when altering the relative
spacing of the tick marks on the plot of the original time series
using <code>X.xtick.at</code> or <code>X.ytick.at</code>, the tick marks of the
stacked plot are automatically adjusted. If the plot of the original
time series is not drawn, then the user can alter the spacing of the
tick marks using <code>Stack.xtick.at</code> and <code>Stack.ytick.at</code> for
the horizontal and vertical axes, respectively.
</p>
<p>One of <code>plot.W</code> or <code>plot.V</code> must be TRUE.
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stackplot">stackplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rnorm(2048)
modwtobj &lt;- modwt(X)

# Plotting wavelet coefficients at levels 1 through 6 and scaling
# coefficients at level 6.
plot.modwt(modwtobj, levels = 6)

# Plotting wavelet coefficients of levels 1, 3, 5, and scaling
# coefficients of levels 4 and 5, and green boundary coefficients
# lines.
plot.modwt(modwtobj, levels = list(c(1,3,5),c(4,5)), draw.boundary =
TRUE, col.boundary = "green")

# Plotting wavelet coefficients at level 1 through 6 and not plotting
# any scaling coefficients.
plot.modwt(modwtobj, levels = 6, plot.V = FALSE)
</code></pre>

<hr>
<h2 id='scalingshift.dwt'>
Find Circular Shift of DWT Scaling Coefficients
</h2><span id='topic+scalingshift.dwt'></span>

<h3>Description</h3>

<p>Finds circular shift of DWT scaling coefficients at a specified level,
for a specified filter length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalingshift.dwt(L, j, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalingshift.dwt_+3A_l">L</code></td>
<td>
<p>Length of wavelet transform filter used.</p>
</td></tr>
<tr><td><code id="scalingshift.dwt_+3A_j">j</code></td>
<td>
<p>Level of DWT scaling coefficients to be shifted.</p>
</td></tr>
<tr><td><code id="scalingshift.dwt_+3A_n">N</code></td>
<td>
<p>Length of original time series sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the circular shift associated with a wavelet
transform filter of length <code>L</code> and level <code>j</code>. <code>L</code> must
be of even length.
</p>
<p>Each coefficient's index will be circularly shifted forward by the
value outputted. For example, if we have a vector of DWT scaling
coefficients (with NAs inserted) with indices 1,2,3,4,5,6,7,8 and the
value outputted from the function <code>scalingshift.dwt</code> is 2, the
new order of the vector of aligned DWT wavelet coefficients would be
7,8,1,2,3,4,5,6.
</p>
<p>If <code>N</code> is specified, the function will output the &quot;shift&quot; Modulo
N. Because the shift is circular, the value outputted when N is
specified is equivalent to the case when N is not specified.
</p>
<p>This function calculates the absolute value of vjH in formulas (114c)
in <em>Wavelet Methods for Time Series Analysis</em> by Percival and
Walden (2000). (And optionally vjH Modulo N)
</p>


<h3>Value</h3>

<table>
<tr><td><code>shift</code></td>
<td>
<p>Circular shift for specified level of DWT scaling
coefficients for a specified filter length.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+waveletshift.dwt">waveletshift.dwt</a></code> and <code><a href="#topic+plot.dwt">plot.dwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding the circular shift for a wavelet transform filter of length 8,
# pertaining to DWT Scaling Coefficients of level 5.
scalingshift.dwt(8, 5)

# If the sample size of the original time series is of length 1024.
scalingshift.dwt(8, 5, N = 1024)
</code></pre>

<hr>
<h2 id='squaredgain.wt.filter'>
Plot Squared Gain Function for Wavelet Filter
</h2><span id='topic+squaredgain.wt.filter'></span>

<h3>Description</h3>

<p>Plots squared gain function for a wavelet filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squaredgain.wt.filter(filter, level = 1, N = NULL, draw.bands = TRUE,
wavelet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squaredgain.wt.filter_+3A_filter">filter</code></td>
<td>
<p>Either a 'wt.filter' object, a character string
specifying a wavelet filter, or a numeric vector of wavelet
coefficients. See 'help(wt.filter)' for acceptable filter names.</p>
</td></tr>
<tr><td><code id="squaredgain.wt.filter_+3A_level">level</code></td>
<td>
<p>Level of wavelet filter. Applicable only if a character
string is supplied in <code>filter</code></p>
</td></tr>
<tr><td><code id="squaredgain.wt.filter_+3A_n">N</code></td>
<td>
<p>Length of filter vector after padding the wavelet filter with
zeroes. The zeroes are inserted after the filter values.</p>
</td></tr>
<tr><td><code id="squaredgain.wt.filter_+3A_draw.bands">draw.bands</code></td>
<td>
<p>Draws dashed lines marking the lower and upper ends
of the nominal pass-band for the wavelet filter.</p>
</td></tr>
<tr><td><code id="squaredgain.wt.filter_+3A_wavelet">wavelet</code></td>
<td>
<p>A logical flag indicating whether to plot the squared
gain function for the wavelet (high pass) or scaling (low pass)
filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>N</code> is not specified, and the filter supplied is of length
less than 1024, then the filter vector will be padded to a length of
1024.  Otherwise, if the filter supplied is of length greater than
1024, then the filter vector will be padded to the first 'power of 2'
that is greater than the length of the filter supplied.
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter">wt.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting the squared gain function of LA8 Wavelet Filter Coefficients.
filter &lt;- wt.filter("la8")
squaredgain.wt.filter(filter)

# Plotting the squared gain function of LA8 Scaling Filter Coefficients.
squaredgain.wt.filter(filter, wavelet = FALSE)

# Plotting the squared gain function of Haar Wavelet Filter Coefficients
# without supplying a filter object.
squaredgain.wt.filter("haar")
</code></pre>

<hr>
<h2 id='stackplot'>
Stacked Plotting
</h2><span id='topic+stackplot'></span>

<h3>Description</h3>

<p>Plot an object as a stacked set of plots, plotting each column using
the same x-axis and plotting the y-values at the same scale with an
offset equal to the magnitude of each column vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackplot(x, y = NULL, type = "h", axes.labels = FALSE,
xlab = "", ylab = "", y.llabs = NULL, y.rlabs = NULL, draw.divides =
TRUE, xtick.at = NULL, ytick.at = NULL, col = "black", main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackplot_+3A_x">x</code></td>
<td>
<p>Specifies the coordinates of the points to be
plotted. Alternatively, <code>x</code> can be a list containing matrices
representing the values to be plotted, or a time series object. The
x-values will be specified by the rownames of each matrix. The
y-values, or offsets of each level, will be represented by the
values of the elements in the columns of each matrix.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_y">y</code></td>
<td>
<p>If <code>x</code> specifies the coordinates of the points to be
plotted, then <code>y</code> can be a list containing matrices that 
represent the values to be plotted.  The y-values, or offsets of
each level will be represented by the values of the elements in the
columns of each matrix.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_type">type</code></td>
<td>
<p>Type of plots to be drawn.  Currently only <code>h</code>, or
histogram, and <code>l</code>, or lines, are implemented.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_axes.labels">axes.labels</code></td>
<td>
<p>Boolean representing whether or not to display the
numeric labels of the horizontal and vertical axes.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_xlab">xlab</code></td>
<td>
<p>String indicating the label for the horizontal x-axis.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_ylab">ylab</code></td>
<td>
<p>String indicating the label for the vertical y-axis.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_y.llabs">y.llabs</code></td>
<td>
<p>Vector or list of labels to be placed on left side of
plot.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_y.rlabs">y.rlabs</code></td>
<td>
<p>Vector or list of labels to be placed on right side of
plot.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_draw.divides">draw.divides</code></td>
<td>
<p>Logical value indicating whether to draw lines to
separate each subplot in the stackplot.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_xtick.at">xtick.at</code></td>
<td>
<p>Vector specifying the tick mark locations on the
horizontal axis of the plot. Defaulted to par(&quot;xaxp&quot;).</p>
</td></tr>
<tr><td><code id="stackplot_+3A_ytick.at">ytick.at</code></td>
<td>
<p>Vector specifying the tick mark locations on the
vertical axis of the plot. Defaulted to par(&quot;yaxp&quot;).</p>
</td></tr>
<tr><td><code id="stackplot_+3A_col">col</code></td>
<td>
<p>String representing color of plot.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_main">main</code></td>
<td>
<p>String representing the title of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each object specified by <code>x</code> or <code>y</code> will be
coerced into a list, and each object of the list will be coerced into
a matrix using the function <code>as.matrix</code>. Each column of a matrix
will represent the vertical y-values for each individual plot in the
stacked plot. Horizontal x-values are discussed below.
</p>
<p><code>stackplot</code> will plot a matrix of values as a series of
<code>stacked</code> plots, where the individual columns are plotted using
the same x and y scales, but offset by the magnitude (= abs(max-min))
of the column.  
</p>
<p>If the object to be plotted is a Time Series object, the <code>start</code>
and <code>end</code> values of the object will represent the first and last
horizontal x-values of the points to be plotted. The Time Series
will be coerced into matrix.  
</p>
<p>The limits of the horizontal x-axis and vertical y-axis will be
dictated by the data in the first object of the list.
</p>
<p>If the object to be plotted is a list of matrices, and <code>x</code> is not
specified, the horizontal x-values of the points to be plotted for a
given matrix will default to the rownames of that matrix. The rownames
can be either <code>numeric</code> or <code>character</code>. If the first matrix
of the list does not have rownames, then the horizontal x-values for
each matrix (and its corresponding plot) will default to range from 1
to the length of the columns of the respective matrix.
</p>
<p>If the first matrix of the list does have specified rownames, then the
horizontal x-values assume the values of the rownames of the
respective matrix. However, if another matrix of the list does not
have specified rownames, then its horizontal x-values will default to
range from 1 to the length of the columns of that respective matrix.
</p>
<p>The user can specify the type of plot (currently only &quot;h&quot; and &quot;l&quot;) to
be drawn for every element of the list in <code>x</code> or <code>y</code> using
the vector <code>type</code>. If the Nth element (N&gt;1) in <code>type</code> is NA
and the Nth element of the list in <code>x</code> or <code>y</code> exists, then
the type of plot for the Nth element of the list will be equal to the
type of plot for the N-1th element of the list. Similarly for
<code>col</code>, which specifies the colors for each element of the list in
<code>x</code> or <code>y</code>.
</p>
<p>The labels <code>y.llabs</code> and <code>y.rlabs</code> will be placed at the
&quot;zero&quot; lines of each individual plot starting from the bottom working
up to the top.
</p>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dwt">plot.dwt</a></code> and <code><a href="#topic+plot.modwt">plot.modwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- array(c(1,2,3,4), c(3,4))

# Plotting the vectors c(1,2,3), c(4,1,2), c(3,4,1), and c(2,3,4) in a
# stacked plot with 4 separate plots).  The x-values will be 1:3.
stackplot(A)

#Plotting A with numeric labels on the axis and making the plot "red".
#Also labeling the x-axis with "X-Label", and the y-axis with "Y-Label".
stackplot(A, axes.labels = TRUE, xlab = "X-Label", ylab = "Y-Label")

timeSeries &lt;- ts(A)
# Plotting the Time Series created by coercing the array A into a Time
# Series.  Observe that this plot similar to the plot in the first example.
stackplot(timeSeries)

lfig &lt;- 2:11
hfig &lt;- 1:10
# Plotting a stacked plot of two types: histogram and lines.  Where the
# line joins the points (1,2) and (10,11), and the histogram is similar to
# the histogram formed by entering plot(1:10, type = "h").  The line will
# be red and the histogram will be yellow.
stackplot(list(lfig, hfig), type = c("l", "h"), col = c("red", "yellow"))

</code></pre>

<hr>
<h2 id='subtidal'>Subtidal Sea Level Measurements</h2><span id='topic+subtidal'></span>

<h3>Description</h3>

<p>Wwater level measurements from a stilling well on the open coast in
Crescent Bay, CA. Observations were recorded every six minutes,
from the beginning of 1980 to the end of 1991. For more detailed
information regarding the collection of this data, see Percival and
Walden (2000), p. 185.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(subtidal)</code></pre>


<h3>Format</h3>

<p>A time series object containing 8746 observations.</p>


<h3>Source</h3>

<p>http://www.ms.washington.edu/~s530/data.html</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press, sec. 5.8.
</p>

<hr>
<h2 id='waveletshift.dwt'>
Find Circular Shift of DWT Wavelet Coefficients
</h2><span id='topic+waveletshift.dwt'></span>

<h3>Description</h3>

<p>Finds circular shift of DWT wavelet coefficients at a specified level,
for a specified filter length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waveletshift.dwt(L, j, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waveletshift.dwt_+3A_l">L</code></td>
<td>
<p>Length of wavelet transform filter used.</p>
</td></tr>
<tr><td><code id="waveletshift.dwt_+3A_j">j</code></td>
<td>
<p>Level of DWT wavelet coefficients to be shifted.</p>
</td></tr>
<tr><td><code id="waveletshift.dwt_+3A_n">N</code></td>
<td>
<p>Length of original time series sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the circular shift associated with a wavelet
transform filter of length <code>L</code> and level <code>j</code>. <code>L</code> must
be of even length.
</p>
<p>Each coefficient's index will be circularly shifted forward by the
value outputted. For example, if we have a vector of DWT wavelet
coefficients (with NAs inserted) with indices 1,2,3,4,5,6,7,8 and the
value outputted from the function <code>waveletshift.dwt</code> is 2, the
new order of the vector of aligned DWT wavelet coefficients would be
7,8,1,2,3,4,5,6.
</p>
<p>If <code>N</code> is specified, the function will output the &quot;shift&quot; Modulo
N. Because the shift is circular, the value outputted when N is
specified is equivalent to the case when N is not specified.
</p>
<p>This function calculates the absolute value of vjG in formulas (114c)
in <em>Wavelet Methods for Time Series Analysis</em> by Percival and
Walden (2000). (And optionally vjG Modulo N)
</p>


<h3>Value</h3>

<table>
<tr><td><code>shift</code></td>
<td>
<p>Circular shift for specified level of DWT wavelet
coefficients for a specified filter length.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kelvin Ma, kkym@u.washington.edu
</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalingshift.dwt">scalingshift.dwt</a></code> and <code><a href="#topic+plot.dwt">plot.dwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding the circular shift for a wavelet transform filter of length 8,
# pertaining to DWT Wavelet Coefficients of level 5.
waveletshift.dwt(8, 5)

# If the sample size of the original time series is of length 1024.
waveletshift.dwt(8, 5, N = 1024)
</code></pre>

<hr>
<h2 id='wt.filter'>
Wavelet Transform Filter
</h2><span id='topic+wt.filter'></span><span id='topic+print.wt.filter'></span><span id='topic+summary.wt.filter'></span>

<h3>Description</h3>

<p>Generates a wavelet transform filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.filter(filter="la8", modwt=FALSE, level=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.filter_+3A_filter">filter</code></td>
<td>
<p>A character string indicating which wavelet transform
filter to compute or a numeric vector of wavelet (high pass) filter
coefficients (not scaling (low pass) coefficients). If a numeric
vector is supplied, the length must be even.</p>
</td></tr>
<tr><td><code id="wt.filter_+3A_modwt">modwt</code></td>
<td>
<p>A logical value indicating whether to compute the
maximal overlap discrete wavelet transform filter.</p>
</td></tr>
<tr><td><code id="wt.filter_+3A_level">level</code></td>
<td>
<p>An integer value indicating the level of the wavelet
filter to compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The character strings currently supported are derived from one of four
classes of wavelet transform filters: Daubechies, Least Asymetric,
Best Localized and Coiflet. The prefixes for filters of these classes
are <code>d</code>, <code>la</code>, <code>bl</code> and <code>c</code>,
respectively. Following the prefix, the filter name consists of an
integer indicating length.  Supported lengths are as follows:
</p>

<dl>
<dt>Daubechies</dt><dd><p>2,4,6,8,10,12,14,16,18,20.</p>
</dd>
<dt>Least Asymetric</dt><dd><p>8,10,12,14,16,18,20.</p>
</dd>
<dt>Best Localized</dt><dd><p>14,18,20.</p>
</dd>
<dt>Coiflet</dt><dd><p>6,12,18,24,30.</p>
</dd>
</dl>

<p>Thus, to obtain the Daubechies wavelet transform filter of length 4,
the character string <code>"d4"</code> can be passed to
<code>wt.filter</code>.
<br />
<br />
This naming convention has one exception: the Daubechies wavelet
transform filter of length 2 is denoted by <code>haar</code> instead of
<code>d2</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>wt.filter</code>, which is an S4 object
with slots 
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>An integer representing the length of the wavelet and scaling
filters.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A numeric vector of wavelet filter coefficients.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>A numeric vector of scaling filter coefficients.</p>
</td></tr>
<tr><td><code>wt.class</code></td>
<td>
<p>A character string indicating the class of the wavelet
transform filter. Possible values are <code>"Daubechies"</code>,
<code>"Least Asymetric"</code>, <code>"Best Localized"</code>, and
<code>"Coiflet"</code>. If the <code>wt.filter</code> object is generated from a
numeric vector of wavelet coefficients, <code>wt.class</code> is
<code>"none"</code>.</p>
</td></tr>
<tr><td><code>wt.name</code></td>
<td>
<p>A character string indicating the name of the wavlet
filter as listed in the Details section, above. If the
<code>wt.filter</code> object is generated from a numeric vector of
wavelet coefficients, <code>wt.name</code> is <code>"none"</code>.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p>A character string indicating whether the resulting
wavelet transform object contains DWT or MODWT coefficients. Possible
values are <code>"dwt"</code> and <code>"modwt"</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The notation <code>h</code> and <code>g</code> for wavelet and scaling
coefficients, respectively, follows Percival and Walden (2000).  In
other texts and articles the reverse notation is often adopted.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter.qmf">wt.filter.qmf</a></code>,
<code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wt.filter("la14")

wt.filter(1:10, modwt=TRUE)
</code></pre>

<hr>
<h2 id='wt.filter-class'>
Wavelet Transform Filter Object
</h2><span id='topic+wt.filter-class'></span>

<h3>Description</h3>

<p>An S4 object containing wavelet transform filter information.
</p>


<h3>Slots</h3>


<dl>
<dt>L</dt><dd><p>An integer representing the length of the wavelet and scaling
filters.</p>
</dd>
<dt>level</dt><dd><p>An integer representing the level of the wavelet filter.</p>
</dd>
<dt>h</dt><dd><p>A numeric vector of wavelet filter coefficients.</p>
</dd>
<dt>g</dt><dd><p>A numeric vector of scaling filter coefficients.</p>
</dd>
<dt>wt.class</dt><dd><p>A character string indicating the class of the wavelet
transform filter. Possible values are <code>"Daubechies"</code>,
<code>"Least Asymetric"</code>, <code>"Best Localized"</code>, and
<code>"Coiflet"</code>. If the <code>wt.filter</code> object is generated from a
numeric vector of wavelet coefficients, <code>wt.class</code> is
<code>"none"</code>.</p>
</dd>
<dt>wt.name</dt><dd><p>A character string indicating the name of the wavlet
filter as listed in the Details section, above. If the
<code>wt.filter</code> object is generated from a numeric vector of
wavelet coefficients, <code>wt.name</code> is <code>"none"</code>.</p>
</dd>
<dt>transform</dt><dd><p>A character string indicating whether the resulting
wavelet transform object contains DWT or MODWT coefficients. Possible
values are <code>"dwt"</code> and <code>"modwt"</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The notation <code>h</code> and <code>g</code> for wavelet and scaling
coefficients, respectively, follows Percival and Walden (2000).  In
other texts and articles the reverse notation is often adopted.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods
for Time Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter.qmf">wt.filter.qmf</a></code>,
<code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>.
</p>

<hr>
<h2 id='wt.filter.equivalent'>
Equivalent Wavelet Transform Filter
</h2><span id='topic+wt.filter.equivalent'></span>

<h3>Description</h3>

<p>Generates an equivalent filter for a specified wavelet transform
filter and level..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.filter.equivalent(wt.filter, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.filter.equivalent_+3A_wt.filter">wt.filter</code></td>
<td>
<p>A <code>wt.filter</code> object.</p>
</td></tr>
<tr><td><code id="wt.filter.equivalent_+3A_j">J</code></td>
<td>
<p>Level of equivalent filter to compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wavelet transform of level <code class="reqn">j</code> can be computed by iterating the
pyramid algorithm <code class="reqn">j</code> times with a level 1 wavelet filter, or by
simply implementing the pyramid once with the level <code class="reqn">j</code> equivalent
filter.  The equivalent filter is obtained by iteratively filtering
the level 1 wavelet filter and scaling filters with upsampled versions
of themselves.  For details regarding the computation, see Percival
and Walden (2000), eqs. 95e and 96e.
</p>


<h3>Value</h3>

<p>Returns the original <code>wt.filter</code> object with modifications made
to the wavelet and scaling filter coefficients, filter length and
filter level.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter">wt.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wf &lt;- wt.filter("la14")
wt.filter.equivalent(wf, 3)
</code></pre>

<hr>
<h2 id='wt.filter.qmf'>
Quadrature Mirror Filter
</h2><span id='topic+wt.filter.qmf'></span>

<h3>Description</h3>

<p>Computes the quadrature mirror filter of a series of even length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.filter.qmf(x, inverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.filter.qmf_+3A_x">x</code></td>
<td>
<p>A numeric vector of even length</p>
</td></tr>
<tr><td><code id="wt.filter.qmf_+3A_inverse">inverse</code></td>
<td>
<p>A logical flag indicating whether to compute the
inverse quadrature mirror filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quadrature mirror filter is computed as outlined in
Percival and Walden, page 75.  Specifically, the forward QMF makes use
of a wavelet filter to obtain a scaling filter and the inverse QMF
does the opposite.</p>


<h3>Value</h3>

<p>A numeric vector which contains the values of <code>x</code> in reverse
order, with the values of the resulting vector at even indices being
negated in the case that <code>inverse=FALSE</code> and the values at odd
indices being negated in the case that <code>inverse=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods
for Time Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter.qmf">wt.filter.qmf</a></code>,
<code><a href="#topic+dwt">dwt</a></code>,
<code><a href="#topic+modwt">modwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain both the la8 wavelet and scaling filters
la8 &lt;- wt.filter("la8")

# now compare output of qmf with values in wt.filter object
wt.filter.qmf(la8@h)
la8@g
</code></pre>

<hr>
<h2 id='wt.filter.shift'>
Wavelet Transform Filter Phase Shift
</h2><span id='topic+wt.filter.shift'></span>

<h3>Description</h3>

<p>Computes phase shifts for wavelet transform coefficients corresponding
to a particular filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt.filter.shift(filter, J, wavelet=TRUE, coe=FALSE, modwt=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt.filter.shift_+3A_filter">filter</code></td>
<td>
<p>A <code>wt.filter</code> object, a character string indicating
which wavelet transform filter to compute, or a numeric vector of
wavelet (high pass) filter coefficients (not scaling (low pass)
coefficients). If a numeric vector is supplied, the length must be
even.</p>
</td></tr>
<tr><td><code id="wt.filter.shift_+3A_j">J</code></td>
<td>
<p>A vector of positive integers indicating levels for which
to compute phase shifts.</p>
</td></tr>
<tr><td><code id="wt.filter.shift_+3A_wavelet">wavelet</code></td>
<td>
<p>A logical flag indicating whether to compute the
wavelet (high pass) or scaling (low pass) phase shift(s).</p>
</td></tr>
<tr><td><code id="wt.filter.shift_+3A_coe">coe</code></td>
<td>
<p>A logical value indicating whether to use the center of
energy method (see Percival and Walden 2000, page 118) to compute
the phase shift(s).</p>
</td></tr>
<tr><td><code id="wt.filter.shift_+3A_modwt">modwt</code></td>
<td>
<p>A logical value indicating whether to compute MODWT phase
shift(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For wavelet filters of class 'Least Assymetric' or 'Coiflet', the
default method for calculating phase shifts is outlined on pages
112-114 and page 124 of Percival and Walden 2000.  For wavelet filters of
class 'Best Localized', the default shifts are given on page 119 of
Percival and Walden 2000. For the Haar filter, both the level <code class="reqn">j</code>
wavelet and scaling phase shifts are half the length of the level
<code class="reqn">j</code> wavelet and scaling filters and the phase shifts for the D(4)
filter are determined by specifying <code class="reqn">\nu = -1</code> in equations (114a)
and (114b) of Percival and Walden 2000.
</p>
<p>For all other filters, the center of energy method is the default
method for computing phase shifts (thus rendering the <code>coe</code>
argument irrelevant). If <code>coe = TRUE</code>, then the center of energy
method is used regardless of filter class.
</p>
<p>By default the DWT phase shifts are computed, using the MODWT phase
shifts and the methods outlined on pages 115-116 of Percival and
Walden 2000. If <code>modwt = TRUE</code>, then only the MODWT phase shifts
are computed.
</p>


<h3>Value</h3>

<p>A vector of phase shifts, expressed in absolute value.  Each element
corresponds to the equivalent element in <code>J</code>.
</p>


<h3>Author(s)</h3>

<p>Eric Aldrich. ealdrich@gmail.com.</p>


<h3>References</h3>

<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt.filter">wt.filter</a></code>,
<code><a href="#topic+align">align</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wt.filter.shift("la14", J=1:6)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
