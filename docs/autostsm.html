<!DOCTYPE html><html lang="en"><head><title>Help for package autostsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {autostsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autostsm-package'><p>autostsm: Automatic Structural Time Series Models</p></a></li>
<li><a href='#DGS5'><p>5 Year Treasury Yield</p></a></li>
<li><a href='#GDP'><p>US GDP Seasonally Adjusted</p></a></li>
<li><a href='#NA000334Q'><p>US GDP Not Seasonally Adjusted</p></a></li>
<li><a href='#SP500'><p>S&amp;P 500</p></a></li>
<li><a href='#stsm_bdiag'><p>Build a block diagonal matrix from two matrices</p></a></li>
<li><a href='#stsm_build_dates'><p>Build the date sequence as a Date type</p></a></li>
<li><a href='#stsm_check_exo'><p>Data check for input exo</p></a></li>
<li><a href='#stsm_check_exo_fc'><p>Data check for input exo.fc</p></a></li>
<li><a href='#stsm_check_y'><p>Data check for input y</p></a></li>
<li><a href='#stsm_constraints'><p>Set the inequality constraints for estimation</p></a></li>
<li><a href='#stsm_coxstuart'><p>Cox-Stuart Test</p></a></li>
<li><a href='#stsm_dates_to_interpolate'><p>Create dates to interpolate</p></a></li>
<li><a href='#stsm_detect_anomalies'><p>Detect Anomalies</p></a></li>
<li><a href='#stsm_detect_breaks'><p>Detect Structural Breaks</p></a></li>
<li><a href='#stsm_detect_cycle'><p>Detect cycle from the data</p></a></li>
<li><a href='#stsm_detect_frequency'><p>Detect frequency and dates from the data</p></a></li>
<li><a href='#stsm_detect_multiplicative'><p>Detect if log transformation is best</p></a></li>
<li><a href='#stsm_detect_seasonality'><p>Detect seasonality from the data</p></a></li>
<li><a href='#stsm_detect_trend'><p>Detect trend type</p></a></li>
<li><a href='#stsm_estimate'><p>Trend cycle seasonal decomposition using the Kalman filter.</p></a></li>
<li><a href='#stsm_filter'><p>Kalman Filter</p></a></li>
<li><a href='#stsm_fixed_pars'><p>Fixed parameter setting</p></a></li>
<li><a href='#stsm_forecast'><p>Kalman Filter and Forecast</p></a></li>
<li><a href='#stsm_format_exo'><p>Format exo</p></a></li>
<li><a href='#stsm_init_pars'><p>Get initial parameter estimates for estimation</p></a></li>
<li><a href='#stsm_na_kalman'><p>Missing Value Imputation by Kalman Smoothing and State Space Models</p></a></li>
<li><a href='#stsm_prior'><p>Return a naive model prior decomposition</p></a></li>
<li><a href='#stsm_ssm'><p>State space model</p></a></li>
<li><a href='#UNRATE'><p>Unemployment Rate Seasonally Adjusted</p></a></li>
<li><a href='#UNRATENSA'><p>Unemployment Rate Not Seasonally Adjusted</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automatic Structural Time Series Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic model selection for structural time series decomposition into trend, cycle, and seasonal components, plus optionality for structural interpolation, using the Kalman filter. 
  Koopman, Siem Jan and Marius Ooms (2012) "Forecasting Economic Time Series Using Unobserved Components Time Series Models" &lt;<a href="https://doi.org/10.1093%2Foxfordhb%2F9780195398649.013.0006">doi:10.1093/oxfordhb/9780195398649.013.0006</a>&gt;.
  Kim, Chang-Jin and Charles R. Nelson (1999) "State-Space Models with Regime Switching: Classical and Gibbs-Sampling Approaches with Applications" &lt;<a href="https://doi.org/10.7551%2Fmitpress%2F6444.001.0001">doi:10.7551/mitpress/6444.001.0001</a>&gt;<a href="http://econ.korea.ac.kr/~cjkim/">http://econ.korea.ac.kr/~cjkim/</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>maxLik (&ge; 1.5-2), forecast (&ge; 8.15), lubridate (&ge; 1.7),
ggplot2 (&ge; 3.3), gridExtra (&ge; 2.3), strucchange (&ge; 1.5),
foreach (&ge; 1.5), doSNOW (&ge; 1.0.19), parallel (&ge; 4.1.1),
lmtest (&ge; 0.9-38), ggrepel(&ge; 0.9), progress (&ge; 1.2),
sandwich (&ge; 3.0), data.table (&ge; 1.15), kalmanfilter (&ge;
2.0.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-05 17:07:52 UTC; alex.hubbard</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Hubbard [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Hubbard &lt;hubbard.alex@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-05 21:40:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='autostsm-package'>autostsm: Automatic Structural Time Series Models</h2><span id='topic+autostsm'></span><span id='topic+autostsm-package'></span>

<h3>Description</h3>

<p>Automatic model selection for structural time series decomposition into trend, cycle, and seasonal components, plus optionality for structural interpolation, using the Kalman filter. Koopman, Siem Jan and Marius Ooms (2012) &quot;Forecasting Economic Time Series Using Unobserved Components Time Series Models&quot; <a href="https://doi.org/10.1093/oxfordhb/9780195398649.013.0006">doi:10.1093/oxfordhb/9780195398649.013.0006</a>. Kim, Chang-Jin and Charles R. Nelson (1999) &quot;State-Space Models with Regime Switching: Classical and Gibbs-Sampling Approaches with Applications&quot; <a href="https://doi.org/10.7551/mitpress/6444.001.0001">doi:10.7551/mitpress/6444.001.0001</a><a href="http://econ.korea.ac.kr/~cjkim/">http://econ.korea.ac.kr/~cjkim/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex Hubbard <a href="mailto:hubbard.alex@gmail.com">hubbard.alex@gmail.com</a>
</p>

<hr>
<h2 id='DGS5'>5 Year Treasury Yield</h2><span id='topic+DGS5'></span>

<h3>Description</h3>

<p>5 Year Treasury Yield
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DGS5)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE and DGS5, monthly frequency
</p>


<h3>Source</h3>

<p>FRED
</p>

<hr>
<h2 id='GDP'>US GDP Seasonally Adjusted</h2><span id='topic+GDP'></span>

<h3>Description</h3>

<p>US GDP Seasonally Adjusted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GDP)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE and GDP, quarterly frequency
</p>


<h3>Source</h3>

<p>FRED
</p>

<hr>
<h2 id='NA000334Q'>US GDP Not Seasonally Adjusted</h2><span id='topic+NA000334Q'></span>

<h3>Description</h3>

<p>US GDP Not Seasonally Adjusted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NA000334Q)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE and NA000334Q, quarterly frequency
</p>


<h3>Source</h3>

<p>FRED
</p>

<hr>
<h2 id='SP500'>S&amp;P 500</h2><span id='topic+SP500'></span>

<h3>Description</h3>

<p>S&amp;P 500
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SP500)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE and SP500, daily frequency
</p>


<h3>Source</h3>

<p>FRED
</p>

<hr>
<h2 id='stsm_bdiag'>Build a block diagonal matrix from two matrices</h2><span id='topic+stsm_bdiag'></span>

<h3>Description</h3>

<p>Build a block diagonal matrix from two matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_bdiag(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_bdiag_+3A_a">A</code></td>
<td>
<p>The top left matrix</p>
</td></tr>
<tr><td><code id="stsm_bdiag_+3A_b">B</code></td>
<td>
<p>The bottom right matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A block diagonal matrix
</p>

<hr>
<h2 id='stsm_build_dates'>Build the date sequence as a Date type</h2><span id='topic+stsm_build_dates'></span>

<h3>Description</h3>

<p>Build the date sequence as a Date type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_build_dates(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_build_dates_+3A_y">y</code></td>
<td>
<p>a list object created from stsm_detect_frequency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the univariate time series and corrected dates
</p>

<hr>
<h2 id='stsm_check_exo'>Data check for input exo</h2><span id='topic+stsm_check_exo'></span>

<h3>Description</h3>

<p>Checks for proper input of the table exo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_check_exo(exo, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_check_exo_+3A_exo">exo</code></td>
<td>
<p>matrix of exogenous data</p>
</td></tr>
<tr><td><code id="stsm_check_exo_+3A_y">y</code></td>
<td>
<p>input data y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>

<hr>
<h2 id='stsm_check_exo_fc'>Data check for input exo.fc</h2><span id='topic+stsm_check_exo_fc'></span>

<h3>Description</h3>

<p>Checks for proper input of the table exo.fc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_check_exo_fc(exo.fc, n.ahead)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_check_exo_fc_+3A_exo.fc">exo.fc</code></td>
<td>
<p>exogenous forecast data</p>
</td></tr>
<tr><td><code id="stsm_check_exo_fc_+3A_n.ahead">n.ahead</code></td>
<td>
<p>forecast periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>

<hr>
<h2 id='stsm_check_y'>Data check for input y</h2><span id='topic+stsm_check_y'></span>

<h3>Description</h3>

<p>Checks for proper input of the table y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_check_y(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_check_y_+3A_y">y</code></td>
<td>
<p>input data y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>

<hr>
<h2 id='stsm_constraints'>Set the inequality constraints for estimation</h2><span id='topic+stsm_constraints'></span>

<h3>Description</h3>

<p>Inequality constraints: ineqA 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_constraints(
  prior,
  par,
  freq,
  unconstrained,
  det_trend,
  det_drift,
  det_cycle,
  det_seas,
  det_obs,
  saturating_growth
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_constraints_+3A_prior">prior</code></td>
<td>
<p>A data table created by stsm_prior</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_par">par</code></td>
<td>
<p>parameter values for the state space model</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_unconstrained">unconstrained</code></td>
<td>
<p>Whether to remove inequality constraints on the trend during estimation</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_det_trend">det_trend</code></td>
<td>
<p>Set the trend error variance to 0 (deterministic trend)</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_det_drift">det_drift</code></td>
<td>
<p>Set the drift error variance to 0 (deterministic drift)</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_det_cycle">det_cycle</code></td>
<td>
<p>Set the cycle error variance to 0 (deterministic cycle)</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_det_seas">det_seas</code></td>
<td>
<p>Set the seasonality error variances to 0 (deterministic seasonality)</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_det_obs">det_obs</code></td>
<td>
<p>Set the observation equation error variance to 0 (deterministic observation equation)</p>
</td></tr>
<tr><td><code id="stsm_constraints_+3A_saturating_growth">saturating_growth</code></td>
<td>
<p>Force the growth rate to converge to 0 in the long term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the initial values for the Kalman filter
</p>

<hr>
<h2 id='stsm_coxstuart'>Cox-Stuart Test</h2><span id='topic+stsm_coxstuart'></span>

<h3>Description</h3>

<p>Taken from the 'tsutils' package. Performs the Cox-Stuart test for trend, deviation, or dispersion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_coxstuart(
  y,
  type = c("trend", "deviation", "dispersion"),
  sig_level = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_coxstuart_+3A_y">y</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="stsm_coxstuart_+3A_type">type</code></td>
<td>
<p>Type of test: &quot;trend&quot;, &quot;deviation&quot;, or &quot;dispersion&quot;
If type = &quot;trend&quot;, test for changes in trend
If type = &quot;deviation&quot;, test for changes in deviation
If type = &quot;dispersion&quot;, test for changes in dispersion (range)</p>
</td></tr>
<tr><td><code id="stsm_coxstuart_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant seasonal frequencies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list describing the results
</p>

<hr>
<h2 id='stsm_dates_to_interpolate'>Create dates to interpolate</h2><span id='topic+stsm_dates_to_interpolate'></span>

<h3>Description</h3>

<p>Create dates to interpolate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_dates_to_interpolate(y, dates, exo = NULL, interpolate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_dates_to_interpolate_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values.</p>
</td></tr>
<tr><td><code id="stsm_dates_to_interpolate_+3A_dates">dates</code></td>
<td>
<p>Vector of date values for y</p>
</td></tr>
<tr><td><code id="stsm_dates_to_interpolate_+3A_exo">exo</code></td>
<td>
<p>Matrix of exogenous variables. Can be used to specify regression effects or other seasonal effects like holidays, etc.</p>
</td></tr>
<tr><td><code id="stsm_dates_to_interpolate_+3A_interpolate">interpolate</code></td>
<td>
<p>Character string of how to interpolate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the data, dates, and exo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
dates_interp = stsm_dates_to_interpolate(y = NA000334Q$y, dates = NA000334Q$date, 
interpolate = "monthly")

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_anomalies'>Detect Anomalies</h2><span id='topic+stsm_detect_anomalies'></span>

<h3>Description</h3>

<p>Detect anomalies using the estimated structural time series model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_anomalies(
  model,
  y = NULL,
  freq = NULL,
  exo_obs = NULL,
  exo_state = NULL,
  sig_level = 0.01,
  smooth = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_anomalies_+3A_model">model</code></td>
<td>
<p>Structural time series model estimated using stsm_estimate.</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily)), default is NULL and will be automatically detected</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_exo_obs">exo_obs</code></td>
<td>
<p>Matrix of exogenous variables to be used in the observation equation.</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_exo_state">exo_state</code></td>
<td>
<p>Matrix of exogenous variables to be used in the state matrix.</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant anomalies</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_smooth">smooth</code></td>
<td>
<p>Whether or not to use the Kalman smoother</p>
</td></tr>
<tr><td><code id="stsm_detect_anomalies_+3A_plot">plot</code></td>
<td>
<p>Whether to plot everything</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table (or list of data tables) containing the dates of detected anomalies from the filtered and/or smoothed series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
stsm = stsm_estimate(NA000334Q)
anomalies = stsm_detect_anomalies(model = stsm, y = NA000334Q, plot = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_breaks'>Detect Structural Breaks</h2><span id='topic+stsm_detect_breaks'></span>

<h3>Description</h3>

<p>Detect structural breaks using the estimated structural time series model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_breaks(
  model,
  y,
  components = c("trend", "cycle", "seasonal"),
  freq = NULL,
  exo_obs = NULL,
  exo_state = NULL,
  sig_level = 0.01,
  ci = 0.8,
  smooth = TRUE,
  plot = FALSE,
  cores = NULL,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_breaks_+3A_model">model</code></td>
<td>
<p>Structural time series model estimated using stsm_estimate.</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_components">components</code></td>
<td>
<p>Vector of components to test for structural breaks</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily)), default is NULL and will be automatically detected</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_exo_obs">exo_obs</code></td>
<td>
<p>Matrix of exogenous variables to be used in the observation equation.</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_exo_state">exo_state</code></td>
<td>
<p>Matrix of exogenous variables to be used in the state matrix.</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant anomalies</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_ci">ci</code></td>
<td>
<p>Confidence interval, value between 0 and 1 exclusive.</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_smooth">smooth</code></td>
<td>
<p>Whether or not to use the Kalman smoother</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_plot">plot</code></td>
<td>
<p>Whether to plot everything</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for break detection</p>
</td></tr>
<tr><td><code id="stsm_detect_breaks_+3A_show_progress">show_progress</code></td>
<td>
<p>Whether to show progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table (or list of data tables) containing the dates of detected anomalies from the filtered and/or smoothed series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
stsm = stsm_estimate(NA000334Q)
breaks = stsm_detect_breaks(model = stsm, y = NA000334Q, plot = TRUE, cores = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_cycle'>Detect cycle from the data</h2><span id='topic+stsm_detect_cycle'></span>

<h3>Description</h3>

<p>Detect cycle from the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_cycle(
  y,
  freq,
  sig_level = 0.01,
  prior = NULL,
  interpolate = NA,
  cl = NULL,
  cores = NULL,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_cycle_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values.</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily))</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant seasonal frequencies</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_prior">prior</code></td>
<td>
<p>A data table created by stsm_prior</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_interpolate">interpolate</code></td>
<td>
<p>Character string giving frequency to interpolate to: i.e. &quot;quarterly&quot;, &quot;monthly&quot;, &quot;weekly&quot;, &quot;daily&quot;</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_cl">cl</code></td>
<td>
<p>a parallel cluster object</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="stsm_detect_cycle_+3A_show_progress">show_progress</code></td>
<td>
<p>Whether to show progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of cycle periodicity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
cycle = stsm_detect_cycle(y = NA000334Q$y, freq = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_frequency'>Detect frequency and dates from the data</h2><span id='topic+stsm_detect_frequency'></span>

<h3>Description</h3>

<p>Detect frequency and dates from the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_frequency(y, freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_frequency_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_detect_frequency_+3A_freq">freq</code></td>
<td>
<p>Initial setting for the frequency detection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List giving the dates and frequency of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
freq = stsm_detect_frequency(y = NA000334Q)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_multiplicative'>Detect if log transformation is best</h2><span id='topic+stsm_detect_multiplicative'></span>

<h3>Description</h3>

<p>Detect if log transformation is best
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_multiplicative(y, freq, sig_level = 0.01, prior = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_multiplicative_+3A_y">y</code></td>
<td>
<p>an object created from stsm_detect_frequency</p>
</td></tr>
<tr><td><code id="stsm_detect_multiplicative_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data</p>
</td></tr>
<tr><td><code id="stsm_detect_multiplicative_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant seasonal frequencies</p>
</td></tr>
<tr><td><code id="stsm_detect_multiplicative_+3A_prior">prior</code></td>
<td>
<p>A data table created by stsm_prior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical indicating if the model should be multiplicative or not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
multiplicative = stsm_detect_multiplicative(y = NA000334Q$y, freq = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_seasonality'>Detect seasonality from the data</h2><span id='topic+stsm_detect_seasonality'></span>

<h3>Description</h3>

<p>Detect seasonality from the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_seasonality(
  y,
  freq,
  sig_level = 0.01,
  prior = NULL,
  interpolate = NA,
  cl = NULL,
  cores = NULL,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_seasonality_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values.</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily))</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant seasonal frequencies</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_prior">prior</code></td>
<td>
<p>A data table created from stsm_prior</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_interpolate">interpolate</code></td>
<td>
<p>Character string giving frequency to interpolate to: i.e. &quot;quarterly&quot;, &quot;monthly&quot;, &quot;weekly&quot;, &quot;daily&quot;</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_cl">cl</code></td>
<td>
<p>a parallel cluster object</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="stsm_detect_seasonality_+3A_show_progress">show_progress</code></td>
<td>
<p>Whether to show progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of seasonal periodicities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
seasonality = stsm_detect_seasonality(y = NA000334Q$y, freq = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_detect_trend'>Detect trend type</h2><span id='topic+stsm_detect_trend'></span>

<h3>Description</h3>

<p>Detect trend type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_detect_trend(
  y,
  freq,
  decomp = "",
  sig_level = 0.01,
  prior = NULL,
  seasons = NULL,
  cycle = NULL,
  cl = NULL,
  cores = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_detect_trend_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily))</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_decomp">decomp</code></td>
<td>
<p>Decomposition model (&quot;tend-cycle-seasonal&quot;, &quot;trend-seasonal&quot;, &quot;trend-cycle&quot;, &quot;trend-noise&quot;)</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significant seasonal frequencies</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_prior">prior</code></td>
<td>
<p>A data table created by stsm_prior</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_seasons">seasons</code></td>
<td>
<p>The seasonal periods</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_cycle">cycle</code></td>
<td>
<p>The cycle period</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_cl">cl</code></td>
<td>
<p>a parallel cluster object</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="stsm_detect_trend_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether to print messages or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with trend type and logical flag for deterministic trend if the trend is determined to have 0 differencing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
trend = stsm_detect_trend(y = NA000334Q$y, freq = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_estimate'>Trend cycle seasonal decomposition using the Kalman filter.</h2><span id='topic+stsm_estimate'></span>

<h3>Description</h3>

<p>Estimates a structural time series model using the Kalman filter and maximum likelihood.
The seasonal and cycle components are assumed to be of a trigonometric form.
The function checks three trend specifications to decompose a univariate time series
into trend, cycle, and/or seasonal components plus noise. The function automatically
detects the frequency and checks for a seasonal and cycle component if the user does not specify
the frequency or decomposition model. This can be turned off by setting freq or specifying decomp.
State space model for decomposition follows
Yt = T_t + C_t + S_t + B*X_t + e_t, e_t ~ N(0, sig_e^2)
Y is the data
T is the trend component
C is the cycle component
S is the seasonal component
X is the exogenous data with parameter vector B
e is the observation error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_estimate(
  y,
  exo_obs = NULL,
  exo_state = NULL,
  state_eqns = NULL,
  freq = NULL,
  decomp = NULL,
  trend = NULL,
  unconstrained = FALSE,
  saturating_growth = FALSE,
  multiplicative = NULL,
  par = NULL,
  seasons = NULL,
  cycle = NULL,
  arma = c(p = NA, q = NA),
  interpolate = NA,
  interpolate_method = NA,
  det_obs = FALSE,
  det_trend = NULL,
  det_seas = FALSE,
  det_drift = FALSE,
  det_cycle = FALSE,
  sig_level = NULL,
  sig_level_seas = NULL,
  sig_level_cycle = NULL,
  sig_level_trend = NULL,
  optim_methods = c("BFGS", "NM", "CG", "SANN"),
  maxit = 10000,
  verbose = FALSE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_estimate_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_exo_obs">exo_obs</code></td>
<td>
<p>Matrix of exogenous variables to be used in the observation equation.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_exo_state">exo_state</code></td>
<td>
<p>Matrix of exogenous variables to be used in the state matrix.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_state_eqns">state_eqns</code></td>
<td>
<p>Character vector of equations to apply exo_state to the unobserved components. If left as the default, then all variables in
exo_state will be applied to all the unobserved components. The equations should look like:
&quot;trend ~ var - 1&quot;, &quot;drift ~ var - 1&quot;, &quot;cycle ~ var - 1&quot;, &quot;seasonal ~ var - 1&quot;.
If only some equations are specified, it will be assumed that the exogenous data will be applied to only those specified equations.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily)), default is NULL and will be automatically detected</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_decomp">decomp</code></td>
<td>
<p>Decomposition model (&quot;tend-cycle-seasonal&quot;, &quot;trend-seasonal&quot;, &quot;trend-cycle&quot;, &quot;trend-noise&quot;)</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_trend">trend</code></td>
<td>
<p>Trend specification (&quot;random-walk&quot;, &quot;random-walk-drift&quot;, &quot;double-random-walk&quot;, &quot;random-walk2&quot;). The default is NULL which will choose the best of all specifications based on the maximum likelihood.
&quot;random-walk&quot; is the random walk trend.
&quot;random-walk-drift&quot; is the random walk with constant drift trend.
&quot;double-random-walk&quot; is the random walk with random walk drift trend.
&quot;random-walk2&quot; is a 2nd order random walk trend as in the Hodrick-Prescott filter.
If trend is &quot;random-walk&quot;, the trend model is T_t = T_{t-1} + e_t, 
e_t ~ N(0, sig_t^2)
If trend is &quot;random-walk-drift&quot;, the trend model is T_t = T_{t-1} + D_{t-1} + e_t, 
e_t ~ N(0, sig_t^2) with
D_t = d + phi_d*D_{t-1} + n_t, n_t ~ N(0, sig_d^2)
If trend is &quot;double-random-walk&quot;, the trend model is T_t = M_{t-1} + T_{t-1} + e_t, 
e_t ~ N(0, sig_t^2) with
M_t = M_{t-1} + n_t, n_t ~ N(0, sig_d^2)
If trend is &quot;random-walk2&quot;, the trend model is T_t = 2T_{t-1} - T_{t-2} + e_t, 
e_t ~ N(0, sig_t^2)</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_unconstrained">unconstrained</code></td>
<td>
<p>Logical whether to remove inequality constraints on the trend during estimation</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_saturating_growth">saturating_growth</code></td>
<td>
<p>Force the growth rate to converge to 0 in the long term</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_multiplicative">multiplicative</code></td>
<td>
<p>If data should be logged to create a multiplicative model.
If multiplicative = TRUE, then the data is logged and the original model becomes multiplicative 
(Y_t = T_t * C_t * S_t * BX_t * e_t)</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_par">par</code></td>
<td>
<p>Initial parameters, default is NULL and will auto-select them</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_seasons">seasons</code></td>
<td>
<p>The seasonal periods: i.e. c(365.25, 7 if yearly and weekly seasonality). Default is NULL and will be estimated via wavelet analysis. 
Can set to FALSE if want no seasonality</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_cycle">cycle</code></td>
<td>
<p>The period for the longer-term cycle. Default is NULL and will be estimated via wavelet analysis.
Can set to FALSE if want no cycle, &quot;trig&quot; for trigonometric specification only, or &quot;arma&quot; for ARMA(p,q) specification only.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_arma">arma</code></td>
<td>
<p>Named vector with values for p and q corresponding to the ARMA(p,q) specification if
cycle is set to 'arma'. If NA, then will auto-select the order.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_interpolate">interpolate</code></td>
<td>
<p>Character string giving frequency to interpolate to: i.e. &quot;quarterly&quot;, &quot;monthly&quot;, &quot;weekly&quot;, &quot;daily&quot;</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_interpolate_method">interpolate_method</code></td>
<td>
<p>Character string giving the interpolation method: 
i.e. &quot;eop&quot; for end of period, &quot;avg&quot; for period average, or &quot;sum&quot; for period sum.</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_det_obs">det_obs</code></td>
<td>
<p>Set the observation equation error variance to 0 (deterministic observation equation)
If det_obs = TRUE then the error variance of the observation equation (sig_e) is set to 0</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_det_trend">det_trend</code></td>
<td>
<p>Set the trend error variance to 0 (deterministic trend)
If det_trend = TRUE then the error variance of the trend equation (sig_t) is set to 0 and 
is referred to as a smooth trend</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_det_seas">det_seas</code></td>
<td>
<p>Set the seasonality error variances to 0 (deterministic seasonality)
If det_seas = TRUE then the error variance all seasonality frequency j equations (sig_s) 
are set to 0 and is referred to as deterministic seasonality</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_det_drift">det_drift</code></td>
<td>
<p>Set the drift error variance to 0 (deterministic drift)
If det_drift = TRUE then the error variance of the drift equation (sig_d) is set to 0 and 
is refereed to as a deterministic drift</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_det_cycle">det_cycle</code></td>
<td>
<p>Set the cycle error variance to 0 (deterministic cycle)
If det_cycle = TRUE then the error variance of the cycle equation (sig_c) is set to 0 and 
is referred to as a deterministic cycle</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level to determine statistically significance for all tests. Default is 0.01</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_sig_level_seas">sig_level_seas</code></td>
<td>
<p>Significance level to determine statistically significant seasonal frequencies. Default is 0.01</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_sig_level_cycle">sig_level_cycle</code></td>
<td>
<p>Significance level to determine a statistically significant cycle frequency. Default is 0.01</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_sig_level_trend">sig_level_trend</code></td>
<td>
<p>Significance level to determine statistically significant order of integration. Default is 0.01</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_optim_methods">optim_methods</code></td>
<td>
<p>Vector of 1 to 3 optimization methods in order of preference (&quot;NR&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;BHHH&quot;, or &quot;SANN&quot;)</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the optimization</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether to print messages or not</p>
</td></tr>
<tr><td><code id="stsm_estimate_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for seasonality and cycle detection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of estimation values including a data table with coefficients, convergence code, frequency, decomposition, seasonality, cyclicality, and trend specification
as well as the a data table with the original data with dates. Any exogenous data given is also returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
stsm = stsm_estimate(NA000334Q)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_filter'>Kalman Filter</h2><span id='topic+stsm_filter'></span>

<h3>Description</h3>

<p>Kalman filter an estimated model from stsm_estimate output. This is a wrapper to stsm_forecast with n.ahead = 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_filter(
  model,
  y,
  freq = NULL,
  exo_obs = NULL,
  exo_state = NULL,
  ci = 0.8,
  plot = FALSE,
  plot.decomp = FALSE,
  n.hist = NULL,
  smooth = TRUE,
  dampen_cycle = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_filter_+3A_model">model</code></td>
<td>
<p>Structural time series model estimated using stsm_estimate.</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily)), default is NULL and will be automatically detected</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_exo_obs">exo_obs</code></td>
<td>
<p>Matrix of exogenous variables to be used in the observation equation.</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_exo_state">exo_state</code></td>
<td>
<p>Matrix of exogenous variables to be used in the state matrix.</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_ci">ci</code></td>
<td>
<p>Confidence interval, value between 0 and 1 exclusive.</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_plot">plot</code></td>
<td>
<p>Logical, whether to plot everything</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_plot.decomp">plot.decomp</code></td>
<td>
<p>Logical, whether to plot the filtered historical data</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_n.hist">n.hist</code></td>
<td>
<p>Number of historical periods to include in the forecast plot. If plot = TRUE and n.hist = NULL, defaults to 3 years.</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_smooth">smooth</code></td>
<td>
<p>Whether or not to use the Kalman smoother</p>
</td></tr>
<tr><td><code id="stsm_filter_+3A_dampen_cycle">dampen_cycle</code></td>
<td>
<p>Whether to remove oscillating cycle dynamics and smooth the cycle forecast into the trend using a sigmoid function that maintains the rate of convergence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table (or list of data tables) containing the filtered and/or smoothed series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
stsm = stsm_estimate(NA000334Q)
fc = stsm_filter(stsm, y = NA000334Q, plot = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_fixed_pars'>Fixed parameter setting</h2><span id='topic+stsm_fixed_pars'></span>

<h3>Description</h3>

<p>Fixed parameter setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_fixed_pars(
  par,
  y,
  det_obs = FALSE,
  det_trend = FALSE,
  det_drift = FALSE,
  det_cycle = FALSE,
  det_seas = FALSE,
  saturating_growth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_fixed_pars_+3A_par">par</code></td>
<td>
<p>Initial parameters</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_y">y</code></td>
<td>
<p>Vector of univariate time series</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_det_obs">det_obs</code></td>
<td>
<p>Set the observation equation error variance to 0 (deterministic observation equation)
If det_obs = TRUE then the error variance of the observation equation (sig_e) is set to 0</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_det_trend">det_trend</code></td>
<td>
<p>Set the trend error variance to 0 (deterministic trend)
If det_trend = TRUE then the error variance of the trend equation (sig_t) is set to 0 and 
is referred to as a smooth trend</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_det_drift">det_drift</code></td>
<td>
<p>Set the drift error variance to 0 (deterministic drift)
If det_drift = TRUE then the error variance of the drift equation (sig_d) is set to 0 and 
is refereed to as a deterministic drift</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_det_cycle">det_cycle</code></td>
<td>
<p>Set the cycle error variance to 0 (deterministic cycle)
If det_cycle = TRUE then the error variance of the cycle equation (sig_c) is set to 0 and 
is referred to as a deterministic cycle</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_det_seas">det_seas</code></td>
<td>
<p>Set the seasonality error variances to 0 (deterministic seasonality)
If det_seas = TRUE then the error variance all seasonality frequency j equations (sig_s) 
are set to 0 and is referred to as deterministic seasonality</p>
</td></tr>
<tr><td><code id="stsm_fixed_pars_+3A_saturating_growth">saturating_growth</code></td>
<td>
<p>Force the growth rate to converge to 0 in the long term</p>
</td></tr>
</table>

<hr>
<h2 id='stsm_forecast'>Kalman Filter and Forecast</h2><span id='topic+stsm_forecast'></span>

<h3>Description</h3>

<p>Kalman filter and forecast an estimated model from stsm_estimate output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_forecast(
  model,
  y,
  n.ahead = 0,
  freq = NULL,
  exo_obs = NULL,
  exo_state = NULL,
  exo_obs.fc = NULL,
  exo_state.fc = NULL,
  ci = 0.8,
  plot = FALSE,
  plot.decomp = FALSE,
  plot.fc = FALSE,
  n.hist = NULL,
  smooth = TRUE,
  dampen_cycle = FALSE,
  envelope_ci = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_forecast_+3A_model">model</code></td>
<td>
<p>Structural time series model estimated using stsm_estimate.</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_y">y</code></td>
<td>
<p>Univariate time series of data values. May also be a 2 column data frame containing a date column.</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of periods to forecast</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data (1 (yearly), 4 (quarterly), 12 (monthly), 365.25/7 (weekly), 365.25 (daily)), default is NULL and will be automatically detected</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_exo_obs">exo_obs</code></td>
<td>
<p>Matrix of exogenous variables to be used in the observation equation.</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_exo_state">exo_state</code></td>
<td>
<p>Matrix of exogenous variables to be used in the state matrix.</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_exo_obs.fc">exo_obs.fc</code></td>
<td>
<p>Matrix of exogenous variables in the observation matrix used for the forecast</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_exo_state.fc">exo_state.fc</code></td>
<td>
<p>Matrix of exogenous variables in the state matrix used for the forecast</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_ci">ci</code></td>
<td>
<p>Confidence interval, value between 0 and 1 exclusive.</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_plot">plot</code></td>
<td>
<p>Logical, whether to plot everything</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_plot.decomp">plot.decomp</code></td>
<td>
<p>Logical, whether to plot the filtered historical data</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_plot.fc">plot.fc</code></td>
<td>
<p>Logical, whether to plot the forecast</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_n.hist">n.hist</code></td>
<td>
<p>Number of historical periods to include in the forecast plot. If plot = TRUE and n.hist = NULL, defaults to 3 years.</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_smooth">smooth</code></td>
<td>
<p>Whether or not to use the Kalman smoother</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_dampen_cycle">dampen_cycle</code></td>
<td>
<p>Whether to remove oscillating cycle dynamics and smooth the cycle forecast into the trend using a sigmoid function that maintains the rate of convergence</p>
</td></tr>
<tr><td><code id="stsm_forecast_+3A_envelope_ci">envelope_ci</code></td>
<td>
<p>Whether to create a envelope for the confidence interval to smooth out seasonal fluctuations
to the longest seasonal period</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table (or list of data tables) containing the filtered and/or smoothed series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
stsm = stsm_estimate(NA000334Q)
fc = stsm_forecast(stsm, y = NA000334Q, n.ahead = floor(stsm$freq)*3, plot = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_format_exo'>Format exo</h2><span id='topic+stsm_format_exo'></span>

<h3>Description</h3>

<p>Format the exo table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_format_exo(exo_obs, exo_state, dates, range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_format_exo_+3A_exo_obs">exo_obs</code></td>
<td>
<p>exogenous observation data</p>
</td></tr>
<tr><td><code id="stsm_format_exo_+3A_exo_state">exo_state</code></td>
<td>
<p>exogenous state data</p>
</td></tr>
<tr><td><code id="stsm_format_exo_+3A_dates">dates</code></td>
<td>
<p>dates vector</p>
</td></tr>
<tr><td><code id="stsm_format_exo_+3A_range">range</code></td>
<td>
<p>range of data to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data table
</p>

<hr>
<h2 id='stsm_init_pars'>Get initial parameter estimates for estimation</h2><span id='topic+stsm_init_pars'></span>

<h3>Description</h3>

<p>Get initial parameter estimates for estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_init_pars(
  y,
  freq,
  trend,
  cycle,
  decomp = "",
  seasons = NULL,
  prior = NULL,
  sig_level = 0.01,
  arma = c(p = NA, q = NA),
  exo = NULL,
  state_eqns = NULL,
  interpolate = NA,
  interpolate_method = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_init_pars_+3A_y">y</code></td>
<td>
<p>an object created from stsm_detect_frequency</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_trend">trend</code></td>
<td>
<p>Trend specification (&quot;random-walk&quot;, &quot;random-walk-drift&quot;, &quot;double-random-walk&quot;, &quot;random-walk2&quot;).</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_cycle">cycle</code></td>
<td>
<p>The period for the longer-term cycle</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_decomp">decomp</code></td>
<td>
<p>Decomposition model (&quot;tend-cycle-seasonal&quot;, &quot;trend-seasonal&quot;, &quot;trend-cycle&quot;, &quot;trend-noise&quot;)</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_seasons">seasons</code></td>
<td>
<p>The seasonal lengths to split the seasonality into</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_prior">prior</code></td>
<td>
<p>A data table created by stsm_prior</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_sig_level">sig_level</code></td>
<td>
<p>Significance level for statistical tests</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_arma">arma</code></td>
<td>
<p>Named vector with values for p and q corresponding to the ARMA(p,q) specification if</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_exo">exo</code></td>
<td>
<p>Matrix of exogenous variables. Can be used to specify regression effects or other seasonal effects like holidays, etc.</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_state_eqns">state_eqns</code></td>
<td>
<p>Character vector of equations to apply exo_state to the unobserved components. If left as the default, then all variables in
exo_state will be applied to all the unobserved components. The equations should look like:
&quot;trend ~ var - 1&quot;, &quot;drift ~ var - 1&quot;, &quot;cycle ~ var - 1&quot;, &quot;seasonal ~ var - 1&quot;.
If only some equations are specified, it will be assumed that the exogenous data will be applied to only those specified equations.</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_interpolate">interpolate</code></td>
<td>
<p>Character string giving frequency to interpolate to: i.e. &quot;quarterly&quot;, &quot;monthly&quot;, &quot;weekly&quot;, &quot;daily&quot;
cycle is set to 'arma'. If NA, then will auto-select the order.</p>
</td></tr>
<tr><td><code id="stsm_init_pars_+3A_interpolate_method">interpolate_method</code></td>
<td>
<p>Character string giving the interpolation method:</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector containing the initial parameter estimates for estimation
</p>

<hr>
<h2 id='stsm_na_kalman'>Missing Value Imputation by Kalman Smoothing and State Space Models</h2><span id='topic+stsm_na_kalman'></span>

<h3>Description</h3>

<p>Simplified version taken from the 'imputeTS' package.
Uses Kalman Smoothing on structural time series models for imputation. It uses &quot;StructTS&quot; to build a
&quot;basic structural model&quot; if the frequency of y is greater than 1. Otherwise, it uses a local trend model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_na_kalman(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_na_kalman_+3A_y">y</code></td>
<td>
<p>Univariate time series</p>
</td></tr>
</table>

<hr>
<h2 id='stsm_prior'>Return a naive model prior decomposition</h2><span id='topic+stsm_prior'></span>

<h3>Description</h3>

<p>Return a naive model prior decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_prior(y, freq, decomp = "", seasons = NULL, cycle = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_prior_+3A_y">y</code></td>
<td>
<p>an object created from stsm_detect_frequency</p>
</td></tr>
<tr><td><code id="stsm_prior_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data</p>
</td></tr>
<tr><td><code id="stsm_prior_+3A_decomp">decomp</code></td>
<td>
<p>decomposition string</p>
</td></tr>
<tr><td><code id="stsm_prior_+3A_seasons">seasons</code></td>
<td>
<p>The seasonal periods to split the seasonality into</p>
</td></tr>
<tr><td><code id="stsm_prior_+3A_cycle">cycle</code></td>
<td>
<p>The cycle periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table containing a naive decomposition using STL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
prior = stsm_prior(y = NA000334Q$y, freq = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='stsm_ssm'>State space model</h2><span id='topic+stsm_ssm'></span>

<h3>Description</h3>

<p>Creates a state space model in list form
yt = H*B + B^O X^O_t + e_t
B = F*B_{t-1} + B^S X^S_t + u_t
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsm_ssm(
  par = NULL,
  yt = NULL,
  decomp = NULL,
  trend = NULL,
  init = NULL,
  model = NULL,
  prior = NULL,
  freq = NULL,
  seasons = NULL,
  cycle = NULL,
  interpolate = NULL,
  interpolate_method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsm_ssm_+3A_par">par</code></td>
<td>
<p>Vector of named parameter values, includes the harmonics</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_yt">yt</code></td>
<td>
<p>Univariate time series of data values</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_decomp">decomp</code></td>
<td>
<p>Decomposition model (&quot;tend-cycle-seasonal&quot;, &quot;trend-seasonal&quot;, &quot;trend-cycle&quot;, &quot;trend-noise&quot;)</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_trend">trend</code></td>
<td>
<p>Trend specification (&quot;random-walk&quot;, &quot;random-walk-drift&quot;, &quot;double-random-walk&quot;, &quot;random-walk2&quot;). The default is NULL which will choose the best of all specifications based on the maximum likelihood.
&quot;random-walk&quot; is the random walk trend.
&quot;random-walk-drift&quot; is the random walk with constant drift trend.
&quot;double-random-walk&quot; is the random walk with random walk drift trend.
&quot;random-walk2&quot; is a 2nd order random walk trend as in the Hodrick-Prescott filter.</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_init">init</code></td>
<td>
<p>Initial state values for the Kalman filter</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_model">model</code></td>
<td>
<p>a stsm_estimate model object</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_prior">prior</code></td>
<td>
<p>Model prior built from stsm_prior. Only needed if prior needs to be built for initial values</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_freq">freq</code></td>
<td>
<p>Frequency of the data. Only needed if prior needs to be built for initial values and prior = NULL</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_seasons">seasons</code></td>
<td>
<p>Numeric vector of seasonal frequencies. Only needed if prior needs to be built for initial values and prior = NULL</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_cycle">cycle</code></td>
<td>
<p>Numeric value for the cycle frequency. Only needed if prior needs to be built for initial values and prior = NULL</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_interpolate">interpolate</code></td>
<td>
<p>Character string of how to interpolate</p>
</td></tr>
<tr><td><code id="stsm_ssm_+3A_interpolate_method">interpolate_method</code></td>
<td>
<p>Character string for the method of interpolation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of space space matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#GDP Not seasonally adjusted
library(autostsm)
data("NA000334Q", package = "autostsm") #From FRED
NA000334Q = data.table(NA000334Q, keep.rownames = TRUE)
colnames(NA000334Q) = c("date", "y")
NA000334Q[, "date" := as.Date(date)]
NA000334Q[, "y" := as.numeric(y)]
NA000334Q = NA000334Q[date &gt;= "1990-01-01", ]
stsm = stsm_estimate(NA000334Q)
ssm = stsm_ssm(model = stsm)

## End(Not run)
</code></pre>

<hr>
<h2 id='UNRATE'>Unemployment Rate Seasonally Adjusted</h2><span id='topic+UNRATE'></span>

<h3>Description</h3>

<p>Unemployment Rate Seasonally Adjusted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UNRATE)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE and UNRATE, monthly frequency
</p>


<h3>Source</h3>

<p>FRED
</p>

<hr>
<h2 id='UNRATENSA'>Unemployment Rate Not Seasonally Adjusted</h2><span id='topic+UNRATENSA'></span>

<h3>Description</h3>

<p>Unemployment Rate Not Seasonally Adjusted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UNRATENSA)
</code></pre>


<h3>Format</h3>

<p>data.table with columns DATE and UNRATENSA, monthly frequency
</p>


<h3>Source</h3>

<p>FRED
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
