<!DOCTYPE html><html><head><title>Help for package LindenmayeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LindenmayeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LindenmayeR-package'><p>Lindenmayer System Functions</p></a></li>
<li><a href='#drawLsys'><p>Draw a 2D L-System Using Turtle Graphics</p></a></li>
<li><a href='#Lsys'><p>Rewrite an Axiom Using Production Rules to Give a String Ready for Turtle Graphics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions to Explore L-Systems (Lindenmayer Systems)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-31</td>
</tr>
<tr>
<td>Description:</td>
<td>L-systems or Lindenmayer systems are parallel rewriting systems which can
    be used to simulate biological forms and certain kinds of fractals.
    Briefly, in an L-system a series of symbols in a string are replaced
    iteratively according to rules to give a more complex string. Eventually,
    the symbols are translated into turtle graphics for plotting. Wikipedia has
    a very good introduction: en.wikipedia.org/wiki/L-system This package
    provides basic functions for exploring L-systems.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>stringr, grid</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bryanhanson/LindenmayeR/issues">https://github.com/bryanhanson/LindenmayeR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-31 19:02:05 UTC; bryanhanson</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan Hanson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryan Hanson &lt;hanson@depauw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-31 21:52:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='LindenmayeR-package'>Lindenmayer System Functions</h2><span id='topic+LindenmayeR-package'></span><span id='topic+LindenmayeR'></span>

<h3>Description</h3>

<p>Functions to Explore L-Systems (Lindenmayer Systems)
</p>


<h3>Details</h3>

<p>Lindenmayer or L-systems are parallel rewriting systems
which can be used to simulate biological forms and certain
kinds of fractals.  Briefly, in an L-system a series of
symbols in a string are replaced iteratively according to
rules to give a more complex string. Eventually, the
symbols are translated into turtle
graphics for plotting.  Wikipedia has a very good
introduction: <a href="https://en.wikipedia.org/wiki/L-system">https://en.wikipedia.org/wiki/L-system</a>
This package provides basic functions for exploring L-systems.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson
</p>

<hr>
<h2 id='drawLsys'>Draw a 2D L-System Using Turtle Graphics</h2><span id='topic+drawLsys'></span>

<h3>Description</h3>

<p>This function takes input strings, previously created with <code><a href="#topic+Lsys">Lsys</a></code>,
translates them into 2D turtle graphics instructions, and then plots the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawLsys(string = NULL, drules = NULL, st = c(5, 50, 0), stepSize = 1,
  ang = 90, which = length(string), shrinkFactor = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawLsys_+3A_string">string</code></td>
<td>
<p>A character vector giving the strings containing the turtle graphics
instructions.  Created by <code><a href="#topic+Lsys">Lsys</a></code>.  The &quot;language&quot; and character set
of this string is arbitary.  Compare the examples below for the modified Koch
curve and the Sierpinski triangle.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_drules">drules</code></td>
<td>
<p>A data frame containing columns &quot;symbols&quot; and &quot;action&quot;.  These contain the input
symbols and the corresponding drawing action.  The symbol column is in the
character set used by <code><a href="#topic+Lsys">Lsys</a></code> and is arbitary.  The action column
entries must be from the set <code>c("F", "f", "+", "-", "[", "]")</code>.  These are 
the final drawing instructions and are interpreted as follows:
</p>

<dl>
<dt>&quot;F&quot;</dt><dd><p>Move forward drawing as you go.</p>
</dd>
<dt>&quot;f&quot;</dt><dd><p>Move forward w/o drawing.</p>
</dd>
<dt>&quot;+&quot;</dt><dd><p>Turn by positive <code>ang</code>.</p>
</dd>
<dt>&quot;-&quot;</dt><dd><p>Turn by negative <code>ang</code>.</p>
</dd>
<dt>&quot;[&quot;</dt><dd><p>Save current position and heading.</p>
</dd>
<dt>&quot;]&quot;</dt><dd><p>Restore saved position and heading (allows one to go back).</p>
</dd>
</dl>

<p>See the examples.  Note that the &quot;action&quot; entry always uses these symbols,
though not all of them need be used.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_st">st</code></td>
<td>
<p>A numeric vector of length 3 giving the screen coordinates where
the start of the curve should be placed.  The screen is 100 x 100 with the
lower left corner as 0,0.  The third element is the initial drawing angle
in degrees.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_stepsize">stepSize</code></td>
<td>
<p>Numeric.  The length of the drawing step.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_ang">ang</code></td>
<td>
<p>Numeric.  The angle in degrees when a change in direction is requested.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_which">which</code></td>
<td>
<p>Integer.  The entries in <code>string</code> which should be drawn.  Defaults
to the last (most complex) entry.  If <code>length(which) &gt; 1</code> each plot is drawn in
its own window.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_shrinkfactor">shrinkFactor</code></td>
<td>
<p>A numeric vector of the same length as <code>string</code>.  As each
plot is made, <code>stepSize</code> will be divided by the corresponding value in <code>shrinkFactor</code>.
This allows one to scale down the increasingly large/complex plots to make them
occupy a space similar to the less complex plots.</p>
</td></tr>
<tr><td><code id="drawLsys_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the <code>grid</code> drawing routines.
Most likely, something of the form <code>gp = gpar(...)</code>.  See <code><a href="grid.html#topic+gpar">gpar</a></code>
and the last example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None; side effect is a plot.
</p>


<h3>Warning</h3>

<p>Remember that if <code>retAll = TRUE</code>, <code><a href="#topic+Lsys">Lsys</a></code> returns
the initial string plus the results of all iterations.  In this case, if you want
the 5th iteration, you should specify <code>which = 6</code> since
the initial string is in <code>string[1]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require('grid')

# Modified Koch curve
rkoch1 &lt;- data.frame(inp = c("F"), out = c("F+F-F-F+F"), stringsAsFactors = FALSE)
k1 &lt;- Lsys(init = "F", rules = rkoch1, n = 3)
dkoch &lt;- data.frame(symbol = c("F", "f", "+", "-", "[", "]"),
action = c("F", "f", "+", "-", "[", "]"), stringsAsFactors = FALSE)
drawLsys(string = k1, stepSize = 3, st = c(10, 50, 0), drules = dkoch)
grid.text("Modified Koch Curve (n = 3)", 0.5, 0.25)

# Classic Koch snowflake
rkoch2 &lt;- data.frame(inp = c("F"), out = c("F-F++F-F"), stringsAsFactors = FALSE)
k2 &lt;- Lsys(init = "F++F++F", rules = rkoch2, n = 4)
drawLsys(string = k2, stepSize = 1, ang = 60, st = c(10, 25, 0), drules = dkoch)
grid.text("Classic Koch Snowflake (n = 4)", 0.5, 0.5)

# Sierpinski Triangle
rSierp &lt;- data.frame(inp = c("A", "B"), out = c("B-A-B", "A+B+A"), stringsAsFactors = FALSE)
s &lt;- Lsys(init = "A", rules = rSierp, n = 6)
dSierp &lt;- data.frame(symbol = c("A", "B", "+", "-", "[", "]"),
action = c("F", "F", "+", "-", "[", "]"), stringsAsFactors = FALSE)
drawLsys(string = s, stepSize = 1, ang = 60, st = c(20, 25, 0), drules = dSierp)
grid.text("Sierpinski Triangle (n = 6)", 0.5, 0.1)

# Islands &amp; Lakes
islands_rules &lt;- data.frame(inp = c("F", "f"), out = c("F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF",
"ffffff"), stringsAsFactors = FALSE)
islands &lt;- Lsys(init = "F+F+F+F", rules = islands_rules, n = 2)
draw_islands &lt;- data.frame(symbol = c("F", "f", "+", "-", "[", "]"),
action = c("F", "f", "+", "-", "[", "]"), stringsAsFactors = FALSE)
drawLsys(string = islands, step = 1, ang = 90, st = c(70, 35, 90),
drules = draw_islands,  gp = gpar(col = "red", fill = "gray"))

# A primitive tree (aka Pythagoras Tree)
prim_rules &lt;- data.frame(inp = c("0", "1"),
out = c("1[+0]-0", "11"), stringsAsFactors = FALSE)
primitive_plant &lt;- Lsys(init = "0", rules = prim_rules, n = 7)
draw_prim &lt;- data.frame(symbol = c("0", "1", "+", "-", "[", "]"),
action = c("F", "F", "+", "-", "[", "]"), stringsAsFactors = FALSE)
drawLsys(string = primitive_plant, stepSize = 1, ang = 45, st = c(50, 5, 90),
drules = draw_prim, which = 7)
grid.text("Primitive Tree (n = 6)", 0.5, 0.75)

# A more realistic botanical structure
# Some call this a fractal tree, I think it is more like seaweed
# Try drawing the last iteration (too slow for here, but looks great)
fractal_tree_rules &lt;- data.frame(inp = c("X", "F"),
out = c("F-[[X]+X]+F[+FX]-X", "FF"), stringsAsFactors = FALSE)
fractal_tree &lt;- Lsys(init = "X", rules = fractal_tree_rules, n = 7)
draw_ft &lt;- data.frame(symbol = c("X", "F", "+", "-", "[", "]"),
action = c("f", "F", "+", "-", "[", "]"), stringsAsFactors = FALSE)
drawLsys(string = fractal_tree, stepSize = 2, ang = 25, st = c(50, 5, 90),
drules = draw_ft, which = 5, gp = gpar(col = "chocolate4", fill = "honeydew"))
grid.text("Fractal Seaweed (n = 4)", 0.25, 0.25)
</code></pre>

<hr>
<h2 id='Lsys'>Rewrite an Axiom Using Production Rules to Give a String Ready for Turtle Graphics</h2><span id='topic+Lsys'></span>

<h3>Description</h3>

<p>This is the central function for rewriting an initial string of symbols (the axiom)
into a new string using production rules.  Production rules are very simple: if
the symbol is A, turn it into something.  If it is B, turn it into something else.
Production rules typically contain instructions about moving while drawing,
moving w/o drawing, changing direction, or storing the current state for re-use later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lsys(init = NULL, rules = NULL, n = 5, retAll = TRUE, verbose = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lsys_+3A_init">init</code></td>
<td>
<p>A character string giving variables (symbols) to use as the initial string
Also known as the axiom.</p>
</td></tr>
<tr><td><code id="Lsys_+3A_rules">rules</code></td>
<td>
<p>A data frame containing columns &quot;inp&quot; and &quot;out&quot;.  These contain the input
variables and the corresponding replacement string.  See the examples in
<code><a href="#topic+drawLsys">drawLsys</a></code>.</p>
</td></tr>
<tr><td><code id="Lsys_+3A_n">n</code></td>
<td>
<p>An integer giving the number of cycles or iterations desired.</p>
</td></tr>
<tr><td><code id="Lsys_+3A_retall">retAll</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the result at each cycle will be returned,
otherwise only the last result is returned.</p>
</td></tr>
<tr><td><code id="Lsys_+3A_verbose">verbose</code></td>
<td>
<p>An integer giving the level of information desired as the calculation
proceeds.  <code>verbose = 1L</code> gives basic information at each cycle.
Any value greater than 1 gives much more detail.  Supress messages by using a value
less than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The job of this function is to take an input &quot;axiom&quot; and apply the &quot;production
rules&quot; and other paramters to create a new string of drawing instructions.  The
&quot;language&quot; or character set of the axiom and production rules are arbitary, and
the internet and literature contains many different examples.  The same fractal
could be drawn using completely different sets of symbols.  The string produced
by this function is processed by <code><a href="#topic+drawLsys">drawLsys</a></code>.  See there for further
explanation and examples.
</p>


<h3>Value</h3>

<p>If <code>retAll = FALSE</code>, a character vector of length 1 giving the string
at the end processing.  Otherwise, a character vector of length <code>n + 1</code>
containing <code>init</code> plus the results at the end of each iteration.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawLsys">drawLsys</a></code> for examples, including plotting.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
