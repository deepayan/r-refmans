<!DOCTYPE html><html><head><title>Help for package COINr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {COINr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a_amean'><p>Weighted arithmetic mean</p></a></li>
<li><a href='#a_copeland'><p>Copeland scores</p></a></li>
<li><a href='#a_genmean'><p>Weighted generalised mean</p></a></li>
<li><a href='#a_gmean'><p>Weighted geometric mean</p></a></li>
<li><a href='#a_hmean'><p>Weighted harmonic mean</p></a></li>
<li><a href='#Aggregate'><p>Aggregate data</p></a></li>
<li><a href='#Aggregate.coin'><p>Aggregate indicators in a coin</p></a></li>
<li><a href='#Aggregate.data.frame'><p>Aggregate data frame</p></a></li>
<li><a href='#Aggregate.purse'><p>Aggregate indicators</p></a></li>
<li><a href='#approx_df'><p>Interpolate time-indexed data frame</p></a></li>
<li><a href='#ASEM_COIN'><p>ASEM COIN (COINr &lt; v1.0)</p></a></li>
<li><a href='#ASEM_iData'><p>ASEM raw indicator data</p></a></li>
<li><a href='#ASEM_iData_p'><p>ASEM raw panel data</p></a></li>
<li><a href='#ASEM_iMeta'><p>ASEM indicator metadata</p></a></li>
<li><a href='#boxcox'><p>Box Cox transformation</p></a></li>
<li><a href='#build_example_coin'><p>Build ASEM example coin</p></a></li>
<li><a href='#build_example_purse'><p>Build example purse</p></a></li>
<li><a href='#CAGR'><p>Compound annual growth rate</p></a></li>
<li><a href='#change_ind'><p>Add and remove indicators</p></a></li>
<li><a href='#check_iData'><p>Check iData</p></a></li>
<li><a href='#check_iMeta'><p>Check iMeta</p></a></li>
<li><a href='#check_SkewKurt'><p>Check skew and kurtosis of a vector</p></a></li>
<li><a href='#COIN_to_coin'><p>Convert a COIN to a coin</p></a></li>
<li><a href='#compare_coins'><p>Compare two coins</p></a></li>
<li><a href='#compare_coins_corr'><p>Compare two coins by correlation</p></a></li>
<li><a href='#compare_coins_multi'><p>Compare multiple coins</p></a></li>
<li><a href='#compare_df'><p>Compare two data frames</p></a></li>
<li><a href='#Custom'><p>Custom operation</p></a></li>
<li><a href='#Custom.coin'><p>Custom operation</p></a></li>
<li><a href='#Custom.purse'><p>Custom operation</p></a></li>
<li><a href='#Denominate'><p>Denominate data</p></a></li>
<li><a href='#Denominate.coin'><p>Denominate data set in a coin</p></a></li>
<li><a href='#Denominate.data.frame'><p>Denominate data sets by other variables</p></a></li>
<li><a href='#Denominate.purse'><p>Denominate a data set within a purse.</p></a></li>
<li><a href='#export_to_excel'><p>Export a coin or purse to Excel</p></a></li>
<li><a href='#export_to_excel.coin'><p>Export a coin to Excel</p></a></li>
<li><a href='#export_to_excel.purse'><p>Export a purse to Excel</p></a></li>
<li><a href='#get_corr'><p>Get correlations</p></a></li>
<li><a href='#get_corr_flags'><p>Find highly-correlated indicators within groups</p></a></li>
<li><a href='#get_cronbach'><p>Cronbach's alpha</p></a></li>
<li><a href='#get_data'><p>Get subsets of indicator data</p></a></li>
<li><a href='#get_data_avail'><p>Get data availability of units</p></a></li>
<li><a href='#get_data_avail.coin'><p>Get data availability of units</p></a></li>
<li><a href='#get_data_avail.data.frame'><p>Get data availability of units</p></a></li>
<li><a href='#get_data.coin'><p>Get subsets of indicator data</p></a></li>
<li><a href='#get_data.purse'><p>Get subsets of indicator data</p></a></li>
<li><a href='#get_denom_corr'><p>Correlations between indicators and denominators</p></a></li>
<li><a href='#get_dset'><p>Gets a named data set and performs checks</p></a></li>
<li><a href='#get_dset.coin'><p>Gets a named data set and performs checks</p></a></li>
<li><a href='#get_dset.purse'><p>Gets a named data set and performs checks</p></a></li>
<li><a href='#get_eff_weights'><p>Get effective weights</p></a></li>
<li><a href='#get_noisy_weights'><p>Noisy replications of weights</p></a></li>
<li><a href='#get_opt_weights'><p>Weight optimisation</p></a></li>
<li><a href='#get_PCA'><p>Perform PCA on a coin</p></a></li>
<li><a href='#get_pvals'><p>P-values for correlations in a data frame or matrix</p></a></li>
<li><a href='#get_results'><p>Results summary tables</p></a></li>
<li><a href='#get_sensitivity'><p>Sensitivity and uncertainty analysis of a coin</p></a></li>
<li><a href='#get_stats'><p>Statistics of columns/indicators</p></a></li>
<li><a href='#get_stats.coin'><p>Statistics of indicators</p></a></li>
<li><a href='#get_stats.data.frame'><p>Statistics of columns</p></a></li>
<li><a href='#get_str_weak'><p>Generate strengths and weaknesses for a specified unit</p></a></li>
<li><a href='#get_trends'><p>Get time trends</p></a></li>
<li><a href='#get_unit_summary'><p>Generate unit summary table</p></a></li>
<li><a href='#i_mean'><p>Impute by mean</p></a></li>
<li><a href='#i_mean_grp'><p>Impute by group mean</p></a></li>
<li><a href='#i_median'><p>Impute by median</p></a></li>
<li><a href='#i_median_grp'><p>Impute by group median</p></a></li>
<li><a href='#icodes_to_inames'><p>Convert iCodes to iNames</p></a></li>
<li><a href='#import_coin_tool'><p>Import data directly from COIN Tool</p></a></li>
<li><a href='#Impute'><p>Imputation of missing data</p></a></li>
<li><a href='#impute_panel'><p>Impute panel data</p></a></li>
<li><a href='#Impute.coin'><p>Impute a data set in a coin</p></a></li>
<li><a href='#Impute.data.frame'><p>Impute a data frame</p></a></li>
<li><a href='#Impute.numeric'><p>Impute a numeric vector</p></a></li>
<li><a href='#Impute.purse'><p>Impute data sets in a purse</p></a></li>
<li><a href='#is.coin'><p>Check if object is coin class</p></a></li>
<li><a href='#is.purse'><p>Check if object is purse class</p></a></li>
<li><a href='#kurt'><p>Calculate kurtosis</p></a></li>
<li><a href='#log_CT'><p>Log-transform a vector</p></a></li>
<li><a href='#log_CT_orig'><p>Log-transform a vector</p></a></li>
<li><a href='#log_CT_plus'><p>Log transform a vector (skew corrected)</p></a></li>
<li><a href='#log_GII'><p>Log-transform a vector</p></a></li>
<li><a href='#n_borda'><p>Normalise using Borda scores</p></a></li>
<li><a href='#n_dist2max'><p>Normalise as distance to maximum value</p></a></li>
<li><a href='#n_dist2ref'><p>Normalise as distance to reference value</p></a></li>
<li><a href='#n_dist2targ'><p>Normalise as distance to target</p></a></li>
<li><a href='#n_fracmax'><p>Normalise as fraction of max value</p></a></li>
<li><a href='#n_goalposts'><p>Normalise using goalpost method</p></a></li>
<li><a href='#n_minmax'><p>Minmax a vector</p></a></li>
<li><a href='#n_prank'><p>Normalise using percentile ranks</p></a></li>
<li><a href='#n_rank'><p>Normalise using ranks</p></a></li>
<li><a href='#n_scaled'><p>Scale a vector</p></a></li>
<li><a href='#n_zscore'><p>Z-score a vector</p></a></li>
<li><a href='#names_to_codes'><p>Generate short codes from long names</p></a></li>
<li><a href='#new_coin'><p>Create a new coin</p></a></li>
<li><a href='#Normalise'><p>Normalise data</p></a></li>
<li><a href='#Normalise.coin'><p>Create a normalised data set</p></a></li>
<li><a href='#Normalise.data.frame'><p>Normalise a data frame</p></a></li>
<li><a href='#Normalise.numeric'><p>Normalise a numeric vector</p></a></li>
<li><a href='#Normalise.purse'><p>Create normalised data sets in a purse of coins</p></a></li>
<li><a href='#outrankMatrix'><p>Outranking matrix</p></a></li>
<li><a href='#plot_bar'><p>Bar chart</p></a></li>
<li><a href='#plot_corr'><p>Static heatmaps of correlation matrices</p></a></li>
<li><a href='#plot_dist'><p>Static indicator distribution plots</p></a></li>
<li><a href='#plot_dot'><p>Dot plots of single indicator with highlighting</p></a></li>
<li><a href='#plot_framework'><p>Framework plots</p></a></li>
<li><a href='#plot_scatter'><p>Scatter plot of two variables</p></a></li>
<li><a href='#plot_sensitivity'><p>Plot sensitivity indices</p></a></li>
<li><a href='#plot_uncertainty'><p>Plot ranks from an uncertainty/sensitivity analysis</p></a></li>
<li><a href='#prc_change'><p>Percentage change of time series</p></a></li>
<li><a href='#print.coin'><p>Print coin</p></a></li>
<li><a href='#print.purse'><p>Print purse</p></a></li>
<li><a href='#qNormalise'><p>Quick normalisation</p></a></li>
<li><a href='#qNormalise.coin'><p>Quick normalisation of a coin</p></a></li>
<li><a href='#qNormalise.data.frame'><p>Quick normalisation of a data frame</p></a></li>
<li><a href='#qNormalise.purse'><p>Quick normalisation of a purse</p></a></li>
<li><a href='#qTreat'><p>Quick outlier treatment</p></a></li>
<li><a href='#qTreat.coin'><p>Quick outlier treatment of a coin</p></a></li>
<li><a href='#qTreat.data.frame'><p>Quick outlier treatment of a data frame</p></a></li>
<li><a href='#qTreat.purse'><p>Quick outlier treatment of a purse</p></a></li>
<li><a href='#rank_df'><p>Convert a data frame to ranks</p></a></li>
<li><a href='#Regen'><p>Regenerate a coin or purse</p></a></li>
<li><a href='#Regen.coin'><p>Regenerate a coin</p></a></li>
<li><a href='#Regen.purse'><p>Regenerate a purse</p></a></li>
<li><a href='#remove_elements'><p>Check the effect of removing indicators or aggregates</p></a></li>
<li><a href='#replace_df'><p>Replace multiple values in a data frame</p></a></li>
<li><a href='#round_df'><p>Round down a data frame</p></a></li>
<li><a href='#SA_estimate'><p>Estimate sensitivity indices</p></a></li>
<li><a href='#SA_sample'><p>Generate sample for sensitivity analysis</p></a></li>
<li><a href='#Screen'><p>Screen units based on data availability</p></a></li>
<li><a href='#Screen.coin'><p>Screen units based on data availability</p></a></li>
<li><a href='#Screen.data.frame'><p>Screen units based on data availability</p></a></li>
<li><a href='#Screen.purse'><p>Screen units based on data availability</p></a></li>
<li><a href='#signif_df'><p>Round a data frame to specified significant figures</p></a></li>
<li><a href='#skew'><p>Calculate skewness</p></a></li>
<li><a href='#Treat'><p>Treat outliers</p></a></li>
<li><a href='#Treat.coin'><p>Treat a data set in a coin for outliers</p></a></li>
<li><a href='#Treat.data.frame'><p>Treat a data frame for outliers</p></a></li>
<li><a href='#Treat.numeric'><p>Treat a numeric vector for outliers</p></a></li>
<li><a href='#Treat.purse'><p>Treat a purse of coins for outliers</p></a></li>
<li><a href='#ucodes_to_unames'><p>Convert uCodes to uNames</p></a></li>
<li><a href='#winsorise'><p>Winsorise a vector</p></a></li>
<li><a href='#WorldDenoms'><p>World denomination data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Composite Indicator Construction and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Becker &lt;william.becker@bluefoxdata.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive high-level package, for composite indicator construction and analysis. It is a "development environment"
    for composite indicators and scoreboards, which includes utilities for construction (indicator selection, denomination, imputation,
    data treatment, normalisation, weighting and aggregation) and analysis (multivariate analysis, correlation plotting, short cuts for
    principal component analysis, global sensitivity analysis, and more). A composite indicator is completely encapsulated inside a single
    hierarchical list called a "coin". This allows a fast and efficient work flow, as well as making quick copies, testing methodological variations and making comparisons.
    It also includes many plotting options, both statistical (scatter plots, distribution plots) as well as for presenting results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bluefoxr.github.io/COINr/">https://bluefoxr.github.io/COINr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bluefoxr/COINr/issues">https://github.com/bluefoxr/COINr/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>openxlsx (&ge; 4.2.3), stats, rlang (&ge; 0.4.10), ggplot2 (&ge;
3.3.3), readxl (&ge; 1.3.1), utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, spelling, knitr, testthat (&ge; 3.0.0), matrixStats,
performance, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-21 15:22:07 UTC; becke</td>
</tr>
<tr>
<td>Author:</td>
<td>William Becker <a href="https://orcid.org/0000-0002-6467-4472"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-21 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='a_amean'>Weighted arithmetic mean</h2><span id='topic+a_amean'></span>

<h3>Description</h3>

<p>The vector of weights <code>w</code> is relative since the formula is:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_amean(x, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_amean_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="a_amean_+3A_w">w</code></td>
<td>
<p>A vector of numeric weights of the same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> y = \frac{1}{\sum w_i} \sum w_i x_i </code>
</p>

<p>If <code>x</code> contains <code>NA</code>s, these <code>x</code> values and the corresponding <code>w</code> values are removed before applying the
formula above.
</p>


<h3>Value</h3>

<p>The weighted mean as a scalar value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10)
w &lt;- c(10:1)
a_amean(x,w)

</code></pre>

<hr>
<h2 id='a_copeland'>Copeland scores</h2><span id='topic+a_copeland'></span>

<h3>Description</h3>

<p>Aggregates a data frame of indicator values into a single column using the Copeland method.
This function calls <code>outrankMatrix()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_copeland(X, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_copeland_+3A_x">X</code></td>
<td>
<p>A numeric data frame or matrix of indicator data, with observations as rows and indicators
as columns. No other columns should be present (e.g. label columns).</p>
</td></tr>
<tr><td><code id="a_copeland_+3A_w">w</code></td>
<td>
<p>A numeric vector of weights, which should have length equal to <code>ncol(X)</code>. Weights are relative
and will be re-scaled to sum to 1. If <code>w</code> is not specified, defaults to equal weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outranking matrix is transformed as follows:
</p>

<ul>
<li><p> values &gt; 0.5 are replaced by 1
</p>
</li>
<li><p> values &lt; 0.5 are replaced by -1
</p>
</li>
<li><p> values == 0.5 are replaced by 0
</p>
</li>
<li><p> the diagonal of the matrix is all zeros
</p>
</li></ul>

<p>The Copeland scores are calculated as the row sums of this transformed matrix.
</p>
<p>This function replaces the now-defunct <code>copeland()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Numeric vector of Copeland scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some example data
ind_data &lt;- COINr::ASEM_iData[12:16]

# aggregate with vector of weights
outlist &lt;- outrankMatrix(ind_data)

</code></pre>

<hr>
<h2 id='a_genmean'>Weighted generalised mean</h2><span id='topic+a_genmean'></span>

<h3>Description</h3>

<p>Weighted generalised mean of a vector. <code>NA</code> are skipped by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_genmean(x, w = NULL, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_genmean_+3A_x">x</code></td>
<td>
<p>A numeric vector of positive values.</p>
</td></tr>
<tr><td><code id="a_genmean_+3A_w">w</code></td>
<td>
<p>A vector of weights, which should have length equal to <code>length(x)</code>. Weights are relative
and will be re-scaled to sum to 1. If <code>w</code> is not specified, defaults to equal weights.</p>
</td></tr>
<tr><td><code id="a_genmean_+3A_p">p</code></td>
<td>
<p>Coefficient - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalised mean is as follows:
</p>
<p style="text-align: center;"><code class="reqn"> y = \left( \frac{1}{\sum w_i} \sum w_i x_i^p  \right)^{1/p} </code>
</p>

<p>where <code>p</code> is a coefficient specified in the function argument here. Note that:
</p>

<ul>
<li><p> For negative <code>p</code>, all <code>x</code> values must be positive
</p>
</li>
<li><p> Setting <code>p = 0</code> will result in an error due to the negative exponent. This case
is equivalent to the geometric mean in the limit, so use <code><a href="#topic+a_gmean">a_gmean()</a></code> instead.
</p>
</li></ul>



<h3>Value</h3>

<p>Weighted harmonic mean, as a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector of values
x &lt;- 1:10
# a vector of weights
w &lt;- runif(10)
# cubic mean
a_genmean(x,w, p = 2)

</code></pre>

<hr>
<h2 id='a_gmean'>Weighted geometric mean</h2><span id='topic+a_gmean'></span>

<h3>Description</h3>

<p>Weighted geometric mean of a vector. <code>NA</code> are skipped by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_gmean(x, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_gmean_+3A_x">x</code></td>
<td>
<p>A numeric vector of positive values.</p>
</td></tr>
<tr><td><code id="a_gmean_+3A_w">w</code></td>
<td>
<p>A vector of weights, which should have length equal to <code>length(x)</code>. Weights are relative
and will be re-scaled to sum to 1. If <code>w</code> is not specified, defaults to equal weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>geoMean()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>The geometric mean, as a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector of values
x &lt;- 1:10
# a vector of weights
w &lt;- runif(10)
# weighted geometric mean
a_gmean(x,w)

</code></pre>

<hr>
<h2 id='a_hmean'>Weighted harmonic mean</h2><span id='topic+a_hmean'></span>

<h3>Description</h3>

<p>Weighted harmonic mean of a vector. <code>NA</code> are skipped by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_hmean(x, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_hmean_+3A_x">x</code></td>
<td>
<p>A numeric vector of positive values.</p>
</td></tr>
<tr><td><code id="a_hmean_+3A_w">w</code></td>
<td>
<p>A vector of weights, which should have length equal to <code>length(x)</code>. Weights are relative
and will be re-scaled to sum to 1. If <code>w</code> is not specified, defaults to equal weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>harMean()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Weighted harmonic mean, as a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector of values
x &lt;- 1:10
# a vector of weights
w &lt;- runif(10)
# weighted harmonic mean
a_hmean(x,w)

</code></pre>

<hr>
<h2 id='Aggregate'>Aggregate data</h2><span id='topic+Aggregate'></span>

<h3>Description</h3>

<p>Methods for aggregating numeric vectors, data frames, coins and purses. See individual method documentation
for more details:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aggregate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aggregate_+3A_x">x</code></td>
<td>
<p>Object to be aggregated</p>
</td></tr>
<tr><td><code id="Aggregate_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+Aggregate.data.frame">Aggregate.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Aggregate.coin">Aggregate.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Aggregate.purse">Aggregate.purse()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object similar to the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see individual method documentation

</code></pre>

<hr>
<h2 id='Aggregate.coin'>Aggregate indicators in a coin</h2><span id='topic+Aggregate.coin'></span>

<h3>Description</h3>

<p>Aggregates a named data set specified by <code>dset</code> using aggregation function(s) <code>f_ag</code>, weights <code>w</code>, and optional
function parameters <code>f_ag_para</code>. Note that COINr has a number of aggregation functions built in,
all of which are of the form <code style="white-space: pre;">&#8288;a_*()&#8288;</code>, e.g. <code><a href="#topic+a_amean">a_amean()</a></code>, <code><a href="#topic+a_gmean">a_gmean()</a></code> and friends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Aggregate(
  x,
  dset,
  f_ag = NULL,
  w = NULL,
  f_ag_para = NULL,
  dat_thresh = NULL,
  by_df = FALSE,
  out2 = "coin",
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aggregate.coin_+3A_x">x</code></td>
<td>
<p>A coin class object.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_f_ag">f_ag</code></td>
<td>
<p>The name of an aggregation function, a string. This can either be a single string naming
a function to use for all aggregation levels, or else a character vector of function names of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure. In this latter case, a different aggregation function may be used for each level
in the index: the first in the vector will be used to aggregate from Level 1 to Level 2, the second from Level 2 to Level 3, and
so on.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_w">w</code></td>
<td>
<p>An optional data frame of weights. If <code>f_ag</code> does not require accept weights, set to <code>"none"</code>. Alternatively, can be the
name of a weight set found in <code>.$Meta$Weights</code>. This can also be specified as a list specifying the aggregation weights for each
level, in the same way as the previous parameters.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_f_ag_para">f_ag_para</code></td>
<td>
<p>Optional parameters to pass to <code>f_ag</code>, other than <code>x</code> and <code>w</code>. As with <code>f_ag</code>, this can specified to have different
parameters for each aggregation level by specifying as a nested list of length <code>n-1</code>. See details.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_dat_thresh">dat_thresh</code></td>
<td>
<p>An optional data availability threshold, specified as a number between 0 and 1. If a row
within an aggregation group has data availability lower than this threshold, the aggregated value for that row will be
<code>NA</code>. Data availability, for a row <code>x_row</code> is defined as <code>sum(!is.na(x_row))/length(x_row)</code>, i.e. the
fraction of non-<code>NA</code> values. Can also be specified as a vector of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure, to specify different data availability thresholds by level.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_by_df">by_df</code></td>
<td>
<p>Controls whether to send a numeric vector to <code>f_ag</code> (if <code>FALSE</code>, default) or a data frame (if <code>TRUE</code>) - see
details. Can also be specified as a logical vector of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_out2">out2</code></td>
<td>
<p>Either <code>"coin"</code> (default) to return updated coin or <code>"df"</code> to output the aggregated data set.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Aggregated"</code>.</p>
</td></tr>
<tr><td><code id="Aggregate.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>by_df = FALSE</code>, aggregation is performed row-wise using the function <code>f_ag</code>, such that for each row <code>x_row</code>, the output is
<code>f_ag(x_row, f_ag_para)</code>, and for the whole data frame, it outputs a numeric vector. Otherwise if <code>by_df = TRUE</code>,
the entire data frame of each indicator group is passed to <code>f_ag</code>.
</p>
<p>The function <code>f_ag</code> must be supplied as a string, e.g. <code>"a_amean"</code>, and it must take as a minimum an input
<code>x</code> which is either a numeric vector (if <code>by_df = FALSE</code>), or a data frame (if <code>by_df = TRUE</code>). In the former
case <code>f_ag</code> should return a single numeric value (i.e. the result of aggregating <code>x</code>), or in the latter case
a numeric vector (the result of aggregating the whole data frame in one go).
</p>
<p>Weights are passed to the function <code>f_ag</code> as an argument named <code>w</code>. This means that the function should have
arguments that look like <code>f_ag(x, w, ...)</code>, where <code>...</code> are possibly other input arguments to the function. If the
aggregation function doesn't use weights, you can set <code>w = "none"</code>, and no weights will be passed to it.
</p>
<p><code>f_ag</code> can optionally have other parameters, apart from <code>x</code> and <code>w</code>, specified as a list in <code>f_ag_para</code>.
</p>
<p>The aggregation specifications can be set to be different for each level of aggregation: the arguments <code>f_ag</code>,
<code>f_ag_para</code>, <code>dat_thresh</code>, <code>w</code> and <code>by_df</code> can all be optionally specified as vectors or lists of length n-1, where
n is the number of levels in the index. In this case, the first value in each vector/list will be used for the first
round of aggregation, i.e. from indicators to the aggregates at level 2. The next will be used to aggregate from
level 2 to level 3, and so on.
</p>
<p>When different functions are used for different levels, it is important to get the list syntax correct. For example, in a case with
three aggregations using different functions, say we want to use <code>a_amean()</code> for the first two levels, then a custom
function <code>f_cust()</code> for the last. <code>f_cust()</code> has some additional parameters <code>a</code> and <code>b</code>. In this case, we would specify e.g.
<code>f_ag_para = list(NULL, NULL, list(a = 2, b = 3))</code> - this is becauase <code>a_amean()</code> requires no additional parameters, so
we pass <code>NULL</code>.
</p>
<p>Note that COINr has a number of aggregation functions built in,
all of which are of the form <code style="white-space: pre;">&#8288;a_*()&#8288;</code>, e.g. <code><a href="#topic+a_amean">a_amean()</a></code>, <code><a href="#topic+a_gmean">a_gmean()</a></code> and friends. To see a list browse COINr functions alphabetically or
type <code>a_</code> in the R Studio console and press the tab key (after loading COINr), or see the <a href="https://bluefoxr.github.io/COINr/articles/aggregate.html#coinr-aggregation-functions">online documentation</a>.
</p>
<p>Optionally, a data availability threshold can be assigned below which the aggregated value will return
<code>NA</code> (see <code>dat_thresh</code> argument). If <code>by_df = TRUE</code>, this will however be ignored because aggregation is not
done on individual rows. Note that more complex constraints could be built into <code>f_ag</code> if needed.
</p>


<h3>Value</h3>

<p>An updated coin with aggregated data set added at <code>.$Data[[write_to]]</code> if <code>out2 = "coin"</code>,
else if <code>out2 = "df"</code> outputs the aggregated data set as a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example up to normalised data set
coin &lt;- build_example_coin(up_to = "Normalise")

# aggregate normalised data set
coin &lt;- Aggregate(coin, dset = "Normalised")

</code></pre>

<hr>
<h2 id='Aggregate.data.frame'>Aggregate data frame</h2><span id='topic+Aggregate.data.frame'></span>

<h3>Description</h3>

<p>Aggregates a data frame into a single column using a specified function. Note that COINr has a number of aggregation functions built in,
all of which are of the form <code style="white-space: pre;">&#8288;a_*()&#8288;</code>, e.g. <code><a href="#topic+a_amean">a_amean()</a></code>, <code><a href="#topic+a_gmean">a_gmean()</a></code> and friends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
Aggregate(
  x,
  f_ag = NULL,
  f_ag_para = NULL,
  dat_thresh = NULL,
  by_df = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aggregate.data.frame_+3A_x">x</code></td>
<td>
<p>Data frame to be aggregated</p>
</td></tr>
<tr><td><code id="Aggregate.data.frame_+3A_f_ag">f_ag</code></td>
<td>
<p>The name of an aggregation function, as a string.</p>
</td></tr>
<tr><td><code id="Aggregate.data.frame_+3A_f_ag_para">f_ag_para</code></td>
<td>
<p>Any additional parameters to pass to <code>f_ag</code>, as a named list.</p>
</td></tr>
<tr><td><code id="Aggregate.data.frame_+3A_dat_thresh">dat_thresh</code></td>
<td>
<p>An optional data availability threshold, specified as a number between 0 and 1. If a row
of <code>x</code> has data availability lower than this threshold, the aggregated value for that row will be
<code>NA</code>. Data availability, for a row <code>x_row</code> is defined as <code>sum(!is.na(x_row))/length(x_row)</code>, i.e. the
fraction of non-<code>NA</code> values.</p>
</td></tr>
<tr><td><code id="Aggregate.data.frame_+3A_by_df">by_df</code></td>
<td>
<p>Controls whether to send a numeric vector to <code>f_ag</code> (if <code>FALSE</code>, default) or a data frame (if <code>TRUE</code>) - see
details.</p>
</td></tr>
<tr><td><code id="Aggregate.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aggregation is performed row-wise using the function <code>f_ag</code>, such that for each row <code>x_row</code>, the output is
<code>f_ag(x_row, f_ag_para)</code>, and for the whole data frame, it outputs a numeric vector. The data frame <code>x</code> must
only contain numeric columns.
</p>
<p>The function <code>f_ag</code> must be supplied as a string, e.g. <code>"a_amean"</code>, and it must take as a minimum an input
<code>x</code> which is either a numeric vector (if <code>by_df = FALSE</code>), or a data frame (if <code>by_df = TRUE</code>). In the former
case <code>f_ag</code> should return a single numeric value (i.e. the result of aggregating <code>x</code>), or in the latter case
a numeric vector (the result of aggregating the whole data frame in one go).
</p>
<p><code>f_ag</code> can optionally have other parameters, e.g. weights, specified as a list in <code>f_ag_para</code>.
</p>
<p>Note that COINr has a number of aggregation functions built in,
all of which are of the form <code style="white-space: pre;">&#8288;a_*()&#8288;</code>, e.g. <code><a href="#topic+a_amean">a_amean()</a></code>, <code><a href="#topic+a_gmean">a_gmean()</a></code> and friends. To see a list browse COINr functions alphabetically or
type <code>a_</code> in the R Studio console and press the tab key (after loading COINr), or see the <a href="https://bluefoxr.github.io/COINr/articles/aggregate.html#coinr-aggregation-functions">online documentation</a>.
</p>
<p>Optionally, a data availability threshold can be assigned below which the aggregated value will return
<code>NA</code> (see <code>dat_thresh</code> argument). If <code>by_df = TRUE</code>, this will however be ignored because aggregation is not
done on individual rows. Note that more complex constraints could be built into <code>f_ag</code> if needed.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get some indicator data - take a few columns from built in data set
X &lt;- ASEM_iData[12:15]

# normalise to avoid zeros - min max between 1 and 100
X &lt;- Normalise(X,
               global_specs = list(f_n = "n_minmax",
                                    f_n_para = list(l_u = c(1,100))))

# aggregate using harmonic mean, with some weights
y &lt;- Aggregate(X, f_ag = "a_hmean", f_ag_para = list(w = c(1, 1, 2, 1)))

</code></pre>

<hr>
<h2 id='Aggregate.purse'>Aggregate indicators</h2><span id='topic+Aggregate.purse'></span>

<h3>Description</h3>

<p>Aggregates indicators following the structure specified in <code>iMeta</code>, for each coin inside the purse.
See <code><a href="#topic+Aggregate.coin">Aggregate.coin()</a></code>, which is applied to each coin, for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Aggregate(
  x,
  dset,
  f_ag = NULL,
  w = NULL,
  f_ag_para = NULL,
  dat_thresh = NULL,
  write_to = NULL,
  by_df = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aggregate.purse_+3A_x">x</code></td>
<td>
<p>A purse-class object</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_f_ag">f_ag</code></td>
<td>
<p>The name of an aggregation function, a string. This can either be a single string naming
a function to use for all aggregation levels, or else a character vector of function names of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure. In this latter case, a different aggregation function may be used for each level
in the index: the first in the vector will be used to aggregate from Level 1 to Level 2, the second from Level 2 to Level 3, and
so on.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_w">w</code></td>
<td>
<p>An optional data frame of weights. If <code>f_ag</code> does not require accept weights, set to <code>"none"</code>. Alternatively, can be the
name of a weight set found in <code>.$Meta$Weights</code>. This can also be specified as a list specifying the aggregation weights for each
level, in the same way as the previous parameters.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_f_ag_para">f_ag_para</code></td>
<td>
<p>Optional parameters to pass to <code>f_ag</code>, other than <code>x</code> and <code>w</code>. As with <code>f_ag</code>, this can specified to have different
parameters for each aggregation level by specifying as a nested list of length <code>n-1</code>. See details.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_dat_thresh">dat_thresh</code></td>
<td>
<p>An optional data availability threshold, specified as a number between 0 and 1. If a row
within an aggregation group has data availability lower than this threshold, the aggregated value for that row will be
<code>NA</code>. Data availability, for a row <code>x_row</code> is defined as <code>sum(!is.na(x_row))/length(x_row)</code>, i.e. the
fraction of non-<code>NA</code> values. Can also be specified as a vector of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure, to specify different data availability thresholds by level.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Aggregated"</code>.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_by_df">by_df</code></td>
<td>
<p>Controls whether to send a numeric vector to <code>f_ag</code> (if <code>FALSE</code>, default) or a data frame (if <code>TRUE</code>) - see
details. Can also be specified as a logical vector of length <code>n-1</code>, where <code>n</code> is
the number of levels in the index structure.</p>
</td></tr>
<tr><td><code id="Aggregate.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated purse with new treated data sets added at <code>.$Data[[write_to]]</code> in each coin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse up to normalised data set
purse &lt;- build_example_purse(up_to = "Normalise", quietly = TRUE)

# aggregate using defaults
purse &lt;- Aggregate(purse, dset = "Normalised")

</code></pre>

<hr>
<h2 id='approx_df'>Interpolate time-indexed data frame</h2><span id='topic+approx_df'></span>

<h3>Description</h3>

<p>Given a numeric data frame <code>Y</code> with rows indexed by a time vector <code>tt</code>, interpolates at time values
specified by the vector <code>tt_est</code>. If <code>tt_est</code> is not in <code>tt</code>, will create new rows in the data frame
corresponding to these interpolated points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_df(Y, tt, tt_est = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_df_+3A_y">Y</code></td>
<td>
<p>A data frame with all numeric columns</p>
</td></tr>
<tr><td><code id="approx_df_+3A_tt">tt</code></td>
<td>
<p>A time vector with length equal to <code>nrow(Y)</code>, indexing the rows in <code>Y</code>.</p>
</td></tr>
<tr><td><code id="approx_df_+3A_tt_est">tt_est</code></td>
<td>
<p>A time vector of points to interpolate in <code>Y</code>. If <code>NULL</code>, will attempt to interpolate all
points in <code>Y</code> (you may need to adjust the <code>rule</code> argument of <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> here). Note that points not
specified in <code>tt_est</code> will not be interpolated. <code>tt_est</code> does not need to be a subset of <code>tt</code>.</p>
</td></tr>
<tr><td><code id="approx_df_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> other than <code>x</code>, <code>y</code> and <code>xout</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for <code><a href="stats.html#topic+approxfun">stats::approx()</a></code>, with some differences. In the first place, <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> is
applied to each column of <code>Y</code>, using <code>tt</code> each time as the corresponding time vector indexing <code>Y</code>. Interpolated
values are generated at points specified in <code>tt_est</code> but these are appended to the existing data (whereas
<code><a href="stats.html#topic+approxfun">stats::approx()</a></code> will only return the interpolated points and nothing else). Further arguments to
<code><a href="stats.html#topic+approxfun">stats::approx()</a></code> can be passed using the <code>...</code> argument.
</p>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>.$tt</code> the vector of time points, including time values of interpolated points
</p>
</li>
<li> <p><code>.$Y</code>  the corresponding interpolated data frame
</p>
</li></ul>

<p>Both outputs are sorted by <code>tt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a time vector
tt &lt;- 2011:2020

# two random vectors with some missing values
y1 &lt;- runif(10)
y2 &lt;- runif(10)
y1[2] &lt;- y1[5] &lt;- NA
y2[3] &lt;- y2[5] &lt;- NA
# make into df
Y &lt;- data.frame(y1, y2)

# interpolate for time = 2012
Y_int &lt;- approx_df(Y, tt, 2012)
Y_int$Y

# notice Y_int$y2 is unchanged since at 2012 it did not have NA value
stopifnot(identical(Y_int$Y$y2, y2))

# interpolate at value not in tt
approx_df(Y, tt, 2015.5)

</code></pre>

<hr>
<h2 id='ASEM_COIN'>ASEM COIN (COINr &lt; v1.0)</h2><span id='topic+ASEM_COIN'></span>

<h3>Description</h3>

<p>This is an &quot;old format&quot; &quot;COIN&quot; object which is stored for testing purposes.
It is generated using the COINr6 package (only available on GitHub) using
<code>COINr6::build_ASEM()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASEM_COIN
</code></pre>


<h3>Format</h3>

<p>A &quot;COIN&quot; class object
</p>


<h3>Source</h3>

<p><a href="https://github.com/bluefoxr/COINr6">https://github.com/bluefoxr/COINr6</a>
</p>

<hr>
<h2 id='ASEM_iData'>ASEM raw indicator data</h2><span id='topic+ASEM_iData'></span>

<h3>Description</h3>

<p>A data set containing raw values of indicators for 51 countries, groups and denominators. See the ASEM Portal
for further information and detailed description of each indicator. See also <code>vignette("coins")</code> for the format
of this data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASEM_iData
</code></pre>


<h3>Format</h3>

<p>A data frame with 51 rows and 60 variables.
</p>


<h3>Details</h3>

<p>This data set is in the new v1.0 format.
</p>


<h3>Source</h3>

<p><a href="https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/repository">https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/repository</a>
</p>

<hr>
<h2 id='ASEM_iData_p'>ASEM raw panel data</h2><span id='topic+ASEM_iData_p'></span>

<h3>Description</h3>

<p>This is an artificially-generated set of panel data (multiple observations of indicators over time) that
is included to build the example &quot;purse&quot; class, i.e. to build composite indicators over time. This will
eventually be replaced with a better example, i.e. a real data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASEM_iData_p
</code></pre>


<h3>Format</h3>

<p>A data frame with 255 rows and 60 variables.
</p>


<h3>Details</h3>

<p>This data set is in the new v1.0 format.
</p>


<h3>Source</h3>

<p><a href="https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/repository">https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/repository</a>
</p>

<hr>
<h2 id='ASEM_iMeta'>ASEM indicator metadata</h2><span id='topic+ASEM_iMeta'></span>

<h3>Description</h3>

<p>This contains all metadata for ASEM indicators, including names, weights, directions, etc. See the ASEM Portal
for further information and detailed description of each indicator.
See also <code>vignette("coins")</code> for the format
of this data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASEM_iMeta
</code></pre>


<h3>Format</h3>

<p>A data frame with 68 rows and 9 variables
</p>


<h3>Details</h3>

<p>This data set is in the new v1.0 format.
</p>


<h3>Source</h3>

<p><a href="https://bluefoxr.github.io/COINrDoc/coins-the-currency-of-coinr.html#aggregation-metadata">https://bluefoxr.github.io/COINrDoc/coins-the-currency-of-coinr.html#aggregation-metadata</a>
</p>

<hr>
<h2 id='boxcox'>Box Cox transformation</h2><span id='topic+boxcox'></span>

<h3>Description</h3>

<p>Simple Box Cox, with no optimisation of lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox(x, lambda, makepos = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_+3A_x">x</code></td>
<td>
<p>A vector or column of data to transform</p>
</td></tr>
<tr><td><code id="boxcox_+3A_lambda">lambda</code></td>
<td>
<p>The lambda parameter of the Box Cox transform</p>
</td></tr>
<tr><td><code id="boxcox_+3A_makepos">makepos</code></td>
<td>
<p>If <code>TRUE</code> (default) makes all values positive by subtracting the minimum and adding 1.</p>
</td></tr>
<tr><td><code id="boxcox_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, <code>NA</code>s will be removed: only relevant if <code>makepos = TRUE</code> which invokes <code>min()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>BoxCox()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A vector of length <code>length(x)</code> with transformed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
x &lt;- runif(30)
# Apply Box Cox
xBox &lt;- boxcox(x, lambda = 2)
# plot one against the other
plot(x, xBox)

</code></pre>

<hr>
<h2 id='build_example_coin'>Build ASEM example coin</h2><span id='topic+build_example_coin'></span>

<h3>Description</h3>

<p>Shortcut function to build the ASEM example coin, using inbuilt example data. This can be useful for testing and also
for building reproducible examples. To see the underlying commands run <code>edit(build_example_coin)</code>. See also
<code>vignette("coins")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_example_coin(up_to = NULL, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_example_coin_+3A_up_to">up_to</code></td>
<td>
<p>The point up to which to build the index. If <code>NULL</code>, builds full index. Else specify a building function
(as a string) - the index will be built up to and including this function. This option is mainly for helping with
function examples. Example: <code>up_to = "Normalise"</code>.</p>
</td></tr>
<tr><td><code id="build_example_coin_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code>, suppresses all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>build_ASEM()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>coin class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin up to data treatment step
coin &lt;- build_example_coin(up_to = "Treat")
coin

</code></pre>

<hr>
<h2 id='build_example_purse'>Build example purse</h2><span id='topic+build_example_purse'></span>

<h3>Description</h3>

<p>Shortcut function to build an example purse. This is currently an &quot;artificial&quot; example, in that it takes the ASEM data set
used in <code><a href="#topic+build_example_coin">build_example_coin()</a></code> and replicates it for five years, adding artificial noise to simulate year-on-year variation.
This was done simply to demonstrate the functionality of purses, and will at some point be replaced with a real example.
See also <code>vignette("coins")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_example_purse(up_to = NULL, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_example_purse_+3A_up_to">up_to</code></td>
<td>
<p>The point up to which to build the index. If <code>NULL</code>, builds full index. Else specify a <code style="white-space: pre;">&#8288;build_*&#8288;</code> function
(as a string) - the index will be built up to and including this function. This option is mainly for helping with
function examples. Example: <code>up_to = "build_normalise"</code>.</p>
</td></tr>
<tr><td><code id="build_example_purse_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code>, suppresses all messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>purse class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse up to unit screening step
purse &lt;- build_example_purse(up_to = "Screen")
purse

</code></pre>

<hr>
<h2 id='CAGR'>Compound annual growth rate</h2><span id='topic+CAGR'></span>

<h3>Description</h3>

<p>Given a variable <code>y</code> indexed by a time vector <code>x</code>, calculates the compound annual growth rate. Note that CAGR assumes
that the <code>x</code> refer to years. Also it is only calculated using the first and latest observed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAGR(y, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAGR_+3A_y">y</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="CAGR_+3A_x">x</code></td>
<td>
<p>A numeric vector of the same length as <code>y</code>, indexing <code>y</code> in time. No <code>NA</code> values are allowed
in <code>x</code>. This vector is assumed to be years, otherwise the result must be interpreted differently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value (CAGR)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># random points over 10 years
x &lt;- 2011:2020
y &lt;- runif(10)

CAGR(y, x)

</code></pre>

<hr>
<h2 id='change_ind'>Add and remove indicators</h2><span id='topic+change_ind'></span>

<h3>Description</h3>

<p>A shortcut function to add and remove indicators. This will make the relevant changes
and recalculate the index if asked. Adding and removing is done relative to the current set of
indicators used in calculating the index results. Any indicators that are added must of course be
present in the original <code>iData</code> and <code>iMeta</code> that were input to <code>new_coin()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_ind(coin, add = NULL, drop = NULL, regen = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_ind_+3A_coin">coin</code></td>
<td>
<p>coin object</p>
</td></tr>
<tr><td><code id="change_ind_+3A_add">add</code></td>
<td>
<p>A character vector of indicator codes to add (must be present in the original input data)</p>
</td></tr>
<tr><td><code id="change_ind_+3A_drop">drop</code></td>
<td>
<p>A character vector of indicator codes to remove (must be present in the original input data)</p>
</td></tr>
<tr><td><code id="change_ind_+3A_regen">regen</code></td>
<td>
<p>Logical (default): if <code>TRUE</code>, automatically regenerates the results based on the new specs
Otherwise, just updates the <code>.$Log</code> parameters. This latter might be useful if you want to
Make other changes before re-running using the <code><a href="#topic+Regen">Regen()</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also <code>vignette("adjustments")</code>.
</p>
<p>This function replaces the now-defunct <code>indChange()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>An updated coin, with regenerated results if <code>regen = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example coin
coin &lt;- build_example_coin(quietly = TRUE)

# exclude two indicators and regenerate
# remove two indicators and regenerate the coin
coin_remove &lt;- change_ind(coin, drop = c("LPI", "Forest"), regen = TRUE)

coin_remove

</code></pre>

<hr>
<h2 id='check_iData'>Check iData</h2><span id='topic+check_iData'></span>

<h3>Description</h3>

<p>Checks the format of <code>iData</code> input to <code><a href="#topic+new_coin">new_coin()</a></code>. This check must be passed to successfully build a new
coin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_iData(iData, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_iData_+3A_idata">iData</code></td>
<td>
<p>A data frame of indicator data.</p>
</td></tr>
<tr><td><code id="check_iData_+3A_quietly">quietly</code></td>
<td>
<p>Set <code>TRUE</code> to suppress message if input is valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The restrictions on <code>iData</code> are not extensive. It should be a data frame with only one required column
<code>uCode</code> which gives the code assigned to each unit (alphanumeric, not starting with a number). All other
columns are defined by corresponding entries in <code>iMeta</code>, with the following special exceptions:
</p>

<ul>
<li> <p><code>Time</code> is an optional column which allows panel data to be input, consisting of e.g. multiple rows for
each <code>uCode</code>: one for each <code>Time</code> value. This can be used to split a set of panel data into multiple coins
(a so-called &quot;purse&quot;) which can be input to COINr functions. See <code><a href="#topic+new_coin">new_coin()</a></code> for more details.
</p>
</li>
<li> <p><code>uName</code> is an optional column which specifies a longer name for each unit. If this column is not included,
unit codes (<code>uCode</code>) will be used as unit names where required.
</p>
</li></ul>

<p>No column names should contain blank spaces.
</p>


<h3>Value</h3>

<p>Message if everything ok, else error messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_iData(ASEM_iData)

</code></pre>

<hr>
<h2 id='check_iMeta'>Check iMeta</h2><span id='topic+check_iMeta'></span>

<h3>Description</h3>

<p>Checks the format of <code>iMeta</code> input to <code><a href="#topic+new_coin">new_coin()</a></code>. This performs a series of thorough checks to make sure
that <code>iMeta</code> agrees with the specifications. This also includes checks to make sure the structure makes
sense, there are no duplicates, and other things. <code>iMeta</code> must pass this check to build a new coin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_iMeta(iMeta, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_iMeta_+3A_imeta">iMeta</code></td>
<td>
<p>A data frame of indicator metadata. See details.</p>
</td></tr>
<tr><td><code id="check_iMeta_+3A_quietly">quietly</code></td>
<td>
<p>Set <code>TRUE</code> to suppress message if input is valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Required columns for <code>iMeta</code> are:
</p>

<ul>
<li> <p><code>Level</code>: Level in aggregation, where 1 is indicator level, 2 is the level resulting from aggregating
indicators, 3 is the result of aggregating level 2, and so on. Set to <code>NA</code> for entries that are not included
in the index (groups, denominators, etc).
</p>
</li>
<li> <p><code>iCode</code>: Indicator code, alphanumeric. Must not start with a number or contain blank spaces.
</p>
</li>
<li> <p><code>Parent</code>: Group (<code>iCode</code>) to which indicator/aggregate belongs in level immediately above.
Each entry here should also be found in <code>iCode</code>. Set to <code>NA</code> only
for the highest (Index) level (no parent), or for entries that are not included
in the index (groups, denominators, etc).
</p>
</li>
<li> <p><code>Direction</code>: Numeric, either -1 or 1
</p>
</li>
<li> <p><code>Weight</code>: Numeric weight, will be rescaled to sum to 1 within aggregation group. Set to <code>NA</code> for entries that are not included
in the index (groups, denominators, etc).
</p>
</li>
<li> <p><code>Type</code>: The type, corresponding to <code>iCode</code>. Can be either <code>Indicator</code>, <code>Aggregate</code>, <code>Group</code>, <code>Denominator</code>,
or <code>Other</code>.
</p>
</li></ul>

<p>Optional columns that are recognised in certain functions are:
</p>

<ul>
<li> <p><code>iName</code>: Name of the indicator: a longer name which is used in some plotting functions.
</p>
</li>
<li> <p><code>Unit</code>: the unit of the indicator, e.g. USD, thousands, score, etc. Used in some plots if available.
</p>
</li>
<li> <p><code>Target</code>: a target for the indicator. Used if normalisation type is distance-to-target.
</p>
</li></ul>

<p>The <code>iMeta</code> data frame essentially gives details about each of the columns found in <code>iData</code>, as well as
details about additional data columns eventually created by aggregating indicators. This means that the
entries in <code>iMeta</code> must include <em>all</em> columns in <code>iData</code>, <em>except</em> the three special column names: <code>uCode</code>,
<code>uName</code>, and <code>Time</code>. In other words, all column names of <code>iData</code> should appear in <code>iMeta$iCode</code>, except
the three special cases mentioned. The <code>iName</code> column optionally can be used to give longer names to each indicator
which can be used for display in plots.
</p>
<p><code>iMeta</code> also specifies the structure of the index, by specifying the parent of each indicator and aggregate.
The <code>Parent</code> column must refer to entries that can be found in <code>iCode</code>. Try <code>View(ASEM_iMeta)</code> for an example
of how this works.
</p>
<p><code>Level</code> is the &quot;vertical&quot; level in the hierarchy, where 1 is the bottom level (indicators), and each successive
level is created by aggregating the level below according to its specified groups.
</p>
<p><code>Direction</code> is set to 1 if higher values of the indicator should result in higher values of the index, and
-1 in the opposite case.
</p>
<p>The <code>Type</code> column specifies the type of the entry: <code>Indicator</code> should be used for indicators at level 1.
<code>Aggregate</code> for aggregates created by aggregating indicators or other aggregates. Otherwise set to <code>Group</code>
if the variable is not used for building the index but instead is for defining groups of units. Set to
<code>Denominator</code> if the variable is to be used for scaling (denominating) other indicators. Finally, set to
<code>Other</code> if the variable should be ignored but passed through. Any other entries here will cause an error.
</p>
<p>Note: this function requires the columns above as specified, but extra columns can also be added without
causing errors.
</p>


<h3>Value</h3>

<p>Message if everything ok, else error messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_iMeta(ASEM_iMeta)

</code></pre>

<hr>
<h2 id='check_SkewKurt'>Check skew and kurtosis of a vector</h2><span id='topic+check_SkewKurt'></span>

<h3>Description</h3>

<p>Logical test: if <code>abs(skewness) &lt; skew_thresh</code> OR <code>kurtosis &lt; kurt_thresh</code>, returns <code>TRUE</code>, else <code>FALSE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_SkewKurt(x, na.rm = FALSE, skew_thresh = 2, kurt_thresh = 3.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_SkewKurt_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="check_SkewKurt_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
<tr><td><code id="check_SkewKurt_+3A_skew_thresh">skew_thresh</code></td>
<td>
<p>A threshold for absolute skewness (positive). Default 2.25.</p>
</td></tr>
<tr><td><code id="check_SkewKurt_+3A_kurt_thresh">kurt_thresh</code></td>
<td>
<p>A threshold for kurtosis. Default 3.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>.$Pass</code> is a Logical, where <code>TRUE</code> is pass, <code>FALSE</code> is fail, and <code>.$Details</code> is a
sub-list with skew and kurtosis values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
x &lt;- runif(20)
# this passes
check_SkewKurt(x)
# if we add an outlier, doesn't pass
check_SkewKurt(c(x, 1000))

</code></pre>

<hr>
<h2 id='COIN_to_coin'>Convert a COIN to a coin</h2><span id='topic+COIN_to_coin'></span>

<h3>Description</h3>

<p>Converts an older COIN class to the newer coin class. Note that there are some limitations to this. First,
the function arguments used to create the COIN will not be passed to the coin, since the function arguments
are different. This means that any data sets beyond &quot;Raw&quot; cannot be regenerated. The second limitation is
that anything from the <code>.$Analysis</code> folder will not be passed on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COIN_to_coin(COIN, recover_dsets = FALSE, out2 = "coin")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COIN_to_coin_+3A_coin">COIN</code></td>
<td>
<p>A COIN class object, generated by COINr version &lt;= 0.6.1, OR a list containing IndData, IndMeta and
AggMeta entries.</p>
</td></tr>
<tr><td><code id="COIN_to_coin_+3A_recover_dsets">recover_dsets</code></td>
<td>
<p>Logical: if <code>TRUE</code>, will recover data sets other than &quot;Raw&quot; which are found in the
<code>.$Data</code> list.</p>
</td></tr>
<tr><td><code id="COIN_to_coin_+3A_out2">out2</code></td>
<td>
<p>If <code>"coin"</code> (default) outputs a coin, else if <code>"list"</code>, outputs a list with
<code>iData</code> and <code>iMeta</code> entries. This may be useful if you want to make further edits before building the coin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works by building the <code>iData</code> and <code>iMeta</code> arguments to <code>new_coin()</code>, using information from
the COIN. It then uses these to build a coin if <code>out2 = "coin"</code> or else outputs both data frames in a list.
</p>
<p>If <code>recover_dsets = TRUE</code>, any data sets found in <code>COIN$Data</code> (except &quot;Raw&quot;) will also be put in <code>coin$Data</code>,
in the correct format. These can be used to inspect the data but not to regenerate.
</p>
<p>Note that if you want to exclude any indicators, you will have to set <code>out2 = "list"</code> and build the coin
in a separate step with <code>exclude</code> specified. Any exclusions/inclusions from the COIN are not passed on
automatically.
</p>


<h3>Value</h3>

<p>A coin class object if <code>out2 = "coin"</code>, else a list of data frames if <code>out2 = "list"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see vignette("other_functions")

</code></pre>

<hr>
<h2 id='compare_coins'>Compare two coins</h2><span id='topic+compare_coins'></span>

<h3>Description</h3>

<p>Compares two coin class objects using a specified <code>iCode</code> (column of data) from specified data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_coins(
  coin1,
  coin2,
  dset,
  iCode,
  also_get = NULL,
  compare_by = "ranks",
  sort_by = NULL,
  decreasing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_coins_+3A_coin1">coin1</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_coin2">coin2</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_dset">dset</code></td>
<td>
<p>A data set that is found in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_icode">iCode</code></td>
<td>
<p>The name of a column that is found in <code>.$Data[[dset]]</code>.</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_also_get">also_get</code></td>
<td>
<p>Optional metadata columns to attach to the table: see <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_compare_by">compare_by</code></td>
<td>
<p>Either <code>"ranks"</code> which produces a comparison using ranks, or else <code>"scores"</code>, which instead
uses scores. Note that scores may be very different if the methodology is different from one coin to another,
e.g. for different normalisation methods.</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_sort_by">sort_by</code></td>
<td>
<p>Optionally, a column name of the output data frame to sort rows by. Can be either
<code>"coin.1"</code>, <code>"coin.2"</code>, <code>"Diff"</code>, <code>"Abs.diff"</code> or possibly a column name imported using <code>also_get</code>.</p>
</td></tr>
<tr><td><code id="compare_coins_+3A_decreasing">decreasing</code></td>
<td>
<p>Argument to pass to <code><a href="base.html#topic+order">order()</a></code>: how to sort.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>compTable()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame of comparison information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example coin
coin &lt;- build_example_coin(quietly = TRUE)

# copy coin
coin2 &lt;- coin

# change to prank function (percentile ranks)
# we don't need to specify any additional parameters (f_n_para) here
coin2$Log$Normalise$global_specs &lt;- list(f_n = "n_prank")

# regenerate
coin2 &lt;- Regen(coin2)

# compare index, sort by absolute rank difference
compare_coins(coin, coin2, dset = "Aggregated", iCode = "Index",
              sort_by = "Abs.diff", decreasing = TRUE)

</code></pre>

<hr>
<h2 id='compare_coins_corr'>Compare two coins by correlation</h2><span id='topic+compare_coins_corr'></span>

<h3>Description</h3>

<p>Given two coins, this function returns the correlation between the two coins,
for target datset <code>dset</code> and target indicator code(s) <code>iCodes</code>. Correlation
is calculated as the Pearson correlation coefficient, but if <code>compare_by = "Ranks"</code>
then this is the correlation coefficient of the ranks, which amounts to the
Spearman rank correlation. Set <code>compare_by = "Scores"</code> to return the Pearson
correlation between scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_coins_corr(coin1, coin2, dset, iCodes, compare_by = "ranks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_coins_corr_+3A_coin1">coin1</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="compare_coins_corr_+3A_coin2">coin2</code></td>
<td>
<p>A coin, with possibly alternative methodology. This should share at
least two units in common with <code>coin1</code>.</p>
</td></tr>
<tr><td><code id="compare_coins_corr_+3A_dset">dset</code></td>
<td>
<p>Target data set, must be present in both <code>coin1</code> and <code>coin2</code></p>
</td></tr>
<tr><td><code id="compare_coins_corr_+3A_icodes">iCodes</code></td>
<td>
<p>Character vector of indicator codes to correlate between the two
coins.</p>
</td></tr>
<tr><td><code id="compare_coins_corr_+3A_compare_by">compare_by</code></td>
<td>
<p>Either <code>"Ranks"</code> or <code>"Scores"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a correlation table and a list of comparison data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example
coin &lt;- build_example_coin()

# copy coin
coin2 &lt;- coin

# change to prank function (percentile ranks)
# we don't need to specify any additional parameters (f_n_para) here
coin2$Log$Normalise$global_specs &lt;- list(f_n = "n_prank")

# regenerate
coin2 &lt;- Regen(coin2)

# iCodes to compare: all at level 3 and 4
iCodes &lt;- coin$Meta$Ind$iCode[which(coin$Meta$Ind$Level &gt; 2)]

# compare index, sort by absolute rank difference
l_comp &lt;- compare_coins_corr(coin, coin2, dset = "Aggregated", iCodes = iCodes)

# see df
l_comp$df_corr

</code></pre>

<hr>
<h2 id='compare_coins_multi'>Compare multiple coins</h2><span id='topic+compare_coins_multi'></span>

<h3>Description</h3>

<p>Given multiple coins as a list, generates a rank comparison of a single indicator or aggregate which is specified
by the <code>dset</code> and <code>iCode</code> arguments (passed to <code><a href="#topic+get_data">get_data()</a></code>). The indicator or aggregate targeted must be available
in all the coins in <code>coins</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_coins_multi(
  coins,
  dset,
  iCode,
  also_get = NULL,
  tabtype = "Values",
  ibase = 1,
  sort_table = TRUE,
  compare_by = "ranks"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_coins_multi_+3A_coins">coins</code></td>
<td>
<p>A list of coins. If names are provided, these will be used in the tables returned by this function.</p>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_dset">dset</code></td>
<td>
<p>The name of a data set found in <code>.$Data</code>. See <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_icode">iCode</code></td>
<td>
<p>A column name of the data set targeted by <code>dset</code>. See <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_also_get">also_get</code></td>
<td>
<p>Optional metadata columns to attach to the table: see <code><a href="#topic+get_data">get_data()</a></code>. If this is not specified, the
results of each coin will be merged using the <code>uCode</code>s within each coin. If this is specified, results will be
merged additionally using the metadata columns. This means that coins must share the same metadata columns that
are returned as a result of <code>also_get</code>.</p>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_tabtype">tabtype</code></td>
<td>
<p>The type of table to generate. One of:
</p>

<ul>
<li> <p><code>"Values"</code>: returns a data frame of rank values for each coin provided, plus ISO3 column
</p>
</li>
<li> <p><code>"Diffs"</code>: returns a data frame of rank differences between the base coin and each other coin (see <code>ibase</code>)
</p>
</li>
<li> <p><code>"AbsDiffs"</code>: as <code>"Diffs"</code> but absolute rank differences are returned
</p>
</li>
<li> <p><code>"All"</code>: returns all of the three previous rank tables, as a list of data frames
</p>
</li></ul>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_ibase">ibase</code></td>
<td>
<p>The index of the coin to use as a base comparison (default first coin in list)</p>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_sort_table">sort_table</code></td>
<td>
<p>If TRUE, sorts by the base COIN (<code>ibase</code>) (default).</p>
</td></tr>
<tr><td><code id="compare_coins_multi_+3A_compare_by">compare_by</code></td>
<td>
<p>Either <code>"ranks"</code> which produces a comparison using ranks, or else <code>"scores"</code>, which instead
uses scores. Note that scores may be very different if the methodology is different from one coin to another,
e.g. for different normalisation methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the ranks of the target indicator/aggregate of each coin will be merged using the <code>uCode</code>s within each coin.
Optionally, specifying <code>also_get</code> (passed to <code><a href="#topic+get_data">get_data()</a></code>) will additionally merge using the metadata columns.
This means that coins must share the same metadata columns that are returned as a result of <code>also_get</code>.
</p>
<p>This function replaces the now-defunct <code>compTableMulti()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Data frame unless <code>tabtype = "All"</code>, in which case a list of three data frames is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see vignette("adjustments")

</code></pre>

<hr>
<h2 id='compare_df'>Compare two data frames</h2><span id='topic+compare_df'></span>

<h3>Description</h3>

<p>A custom function for comparing two data frames of indicator data, to see whether they match up, at a specified number of
significant figures. Specifically, this is intended to compare two data frames, without regard to row or column ordering.
Rows are matched by the required <code>matchcol</code> argument. Hence, it is different from e.g. <code><a href="base.html#topic+all.equal">all.equal()</a></code> which requires rows
to be ordered. In COINr, typically <code>matchcol</code> is the <code>uCode</code> column, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_df(df1, df2, matchcol, sigfigs = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_df_+3A_df1">df1</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="compare_df_+3A_df2">df2</code></td>
<td>
<p>Another data frame</p>
</td></tr>
<tr><td><code id="compare_df_+3A_matchcol">matchcol</code></td>
<td>
<p>A common column name that is used to match row order. E.g. this might be <code>uCode</code>.</p>
</td></tr>
<tr><td><code id="compare_df_+3A_sigfigs">sigfigs</code></td>
<td>
<p>The number of significant figures to use for matching numerical columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares numerical and non-numerical columns to see if they match. Rows and columns can be in any order. The function
performs the following checks:
</p>

<ul>
<li><p> Checks that the two data frames are the same size
</p>
</li>
<li><p> Checks that column names are the same, and that the matching column has the same entries
</p>
</li>
<li><p> Checks column by column that the elements are the same, after sorting according to the matching column
</p>
</li></ul>

<p>It then summarises for each column whether there are any differences, and also what the differences are, if any.
</p>
<p>This is intended to cross-check results. For example, if you run something in COINr and want to check indicator results against
external calculations.
</p>
<p>This function replaces the now-defunct <code>compareDF()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A list with comparison results. List contains:
</p>

<ul>
<li> <p><code>.$Same</code>: overall summary: if <code>TRUE</code> the data frames are the same according to the rules specified, otherwise <code>FALSE</code>.
</p>
</li>
<li> <p><code>.$Details</code>: details of each column as a data frame. Each row summarises a column of the data frame, saying whether
the column is the same as its equivalent, and the number of differences, if any. In case the two data frames have differing
numbers of columns and rows, or have differing column names or entries in <code>matchcol</code>, <code>.$Details</code> will simply contain a
message to this effect.
</p>
</li>
<li> <p><code>.$Differences</code>: a list with one entry for every column which contains different entries. Differences are summarised as
a data frame with one row for each difference, reporting the value from <code>df1</code> and its equivalent from <code>df2</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># take a sample of indicator data (including the uCode column)
data1 &lt;- ASEM_iData[c(2,12:15)]
# copy the data
data2 &lt;- data1
# make a change: replace one value in data2 by NA
data2[1,2] &lt;- NA
# compare data frames
compare_df(data1, data2, matchcol = "uCode")

</code></pre>

<hr>
<h2 id='Custom'>Custom operation</h2><span id='topic+Custom'></span>

<h3>Description</h3>

<p>Allows a custom data operation on coins or purses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Custom(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Custom_+3A_x">x</code></td>
<td>
<p>Object to be operated on (coin or purse)</p>
</td></tr>
<tr><td><code id="Custom_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified object.
</p>

<hr>
<h2 id='Custom.coin'>Custom operation</h2><span id='topic+Custom.coin'></span>

<h3>Description</h3>

<p>Custom operation on a coin. This is an experimental new feature so please check
the results carefully.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Custom(
  x,
  dset,
  f_cust,
  f_cust_para = NULL,
  write_to = NULL,
  write2log = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Custom.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="Custom.coin_+3A_dset">dset</code></td>
<td>
<p>Target data set</p>
</td></tr>
<tr><td><code id="Custom.coin_+3A_f_cust">f_cust</code></td>
<td>
<p>Function to apply to the data set. See details.</p>
</td></tr>
<tr><td><code id="Custom.coin_+3A_f_cust_para">f_cust_para</code></td>
<td>
<p>Optional additional parameters to pass to the function defined
by <code>f_cust</code>.</p>
</td></tr>
<tr><td><code id="Custom.coin_+3A_write_to">write_to</code></td>
<td>
<p>Name of data set to write to</p>
</td></tr>
<tr><td><code id="Custom.coin_+3A_write2log">write2log</code></td>
<td>
<p>Logical: whether or not to write to the log.</p>
</td></tr>
<tr><td><code id="Custom.coin_+3A_...">...</code></td>
<td>
<p>Arguments to pass to/from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the data set named <code>dset</code> is extracted from the coin using
<code>get_dset(coin, dset)</code>. It is passed to the function <code>f_cust</code>, which is required
to return an equivalent but modified data frame, which is then written as a new
data set with name <code>write_to</code>. This is intended to allow arbitrary operations
on coin data sets while staying within the COINr framework, which means that if
<code>Regen()</code> is used, these operations will be re-run, allowing them to be included
in things like sensitivity analysis.
</p>
<p>The format of <code>f_cust</code> is important. It must be a function whose first argument
is called <code>x</code>: this will be the argument that the data is passed to. The data will
be in the same format as extracted via <code>get_dset(coin, dset)</code>, which means it will
have a <code>uCode</code> column. <code>f_cust</code> can have other arguments which are passed
to it via <code>f_cust_para</code>. The function should return a data frame similar to the data
that was passed to it, it must contain have the same column names (meaning you can't
remove indicators), but otherwise is flexible - this means some caution is necessary
to ensure that subsequent operations don't fail. Be careful, for example, to ensure
that there are no duplicates in <code>uCode</code>, and that indicator columns are numeric.
</p>
<p>The function assigned to <code>f_cust</code> is passed to <code><a href="base.html#topic+do.call">base::do.call()</a></code>, therefore it can
be passed either as a string naming the function, or as the function itself. Depending
on the context, the latter option may be preferable because this stores the function
within the coin, which makes it portable. Otherwise, if the function is simply
named as a string, you must make sure it is available to access in the environment.
</p>


<h3>Value</h3>

<p>A coin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# create function - replaces suspected unreliable point with NA
f_NA &lt;- function(x){ x[3, 10] &lt;- NA; return(x)}

# call function from Custom()
coin &lt;- Custom(coin, dset = "Raw", f_cust = f_NA)
stopifnot(is.na(coin$Data$Custom[3,10]))

</code></pre>

<hr>
<h2 id='Custom.purse'>Custom operation</h2><span id='topic+Custom.purse'></span>

<h3>Description</h3>

<p>Custom operation on a purse. This is an experimental new feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Custom(
  x,
  dset,
  f_cust,
  f_cust_para = NULL,
  global = FALSE,
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Custom.purse_+3A_x">x</code></td>
<td>
<p>A purse object</p>
</td></tr>
<tr><td><code id="Custom.purse_+3A_dset">dset</code></td>
<td>
<p>The data set to apply the operation to.</p>
</td></tr>
<tr><td><code id="Custom.purse_+3A_f_cust">f_cust</code></td>
<td>
<p>Function to apply to the data set. See details.</p>
</td></tr>
<tr><td><code id="Custom.purse_+3A_f_cust_para">f_cust_para</code></td>
<td>
<p>Optional additional parameters to pass to the function defined
by <code>f_cust</code>.</p>
</td></tr>
<tr><td><code id="Custom.purse_+3A_global">global</code></td>
<td>
<p>Logical: if <code>TRUE</code>, the entire data set, over all time points, is passed
to the function <code>f_cust</code>. This is useful if the custom operation should be different for
different time points, for example. Otherwise if <code>FALSE</code>, passes the data set within each
coin one at a time to <code>f_cust</code>.</p>
</td></tr>
<tr><td><code id="Custom.purse_+3A_write_to">write_to</code></td>
<td>
<p>Name of data set to write to</p>
</td></tr>
<tr><td><code id="Custom.purse_+3A_...">...</code></td>
<td>
<p>Arguments to pass to/from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the data set named <code>dset</code> is extracted from the coin using
<code>get_dset(purse, dset)</code>. It is passed to the function <code>f_cust</code>, which is required
to return an equivalent but modified data frame, which is then written as a new
data set with name <code>write_to</code>. This is intended to allow arbitrary operations
on coin data sets while staying within the COINr framework, which means that if
<code>Regen()</code> is used, these operations will be re-run, allowing them to be included
in things like sensitivity analysis.
</p>
<p>The format of <code>f_cust</code> is important. It must be a function whose first argument
is called <code>x</code>: this will be the argument that the data is passed to. The data will
be in the same format as extracted via <code>get_dset(purse, dset)</code>, which means it will
have <code>uCode</code> and <code>Time</code> columns. <code>f_cust</code> can have other arguments which are passed
to it via <code>f_cust_para</code>. The function should return a data frame similar to the data
that was passed to it, it must contain have the same column names (meaning you can't
remove indicators), but otherwise is flexible - this means some caution is necessary
to ensure that subsequent operations don't fail. Be careful, for example, to ensure
that there are no duplicates in <code>uCode</code>, and that indicator columns are numeric.
</p>
<p>The function assigned to <code>f_cust</code> is passed to <code><a href="base.html#topic+do.call">base::do.call()</a></code>, therefore it can
be passed either as a string naming the function, or as the function itself. Depending
on the context, the latter option may be preferable because this stores the function
within the coin, which makes it portable. Otherwise, if the function is simply
named as a string, you must make sure it is available to access in the environment.
</p>


<h3>Value</h3>

<p>An updated purse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse
purse &lt;- build_example_purse(up_to = "new_coin")

# custom function - set points before 2020 to NA for BEL in FDI due to a
# break in the series
f_cust &lt;- function(x){x[(x$uCode == "BEL") &amp; (x$Time &lt; 2020), "FDI"] &lt;- NA;
                      return(x)}



</code></pre>

<hr>
<h2 id='Denominate'>Denominate data</h2><span id='topic+Denominate'></span>

<h3>Description</h3>

<p>&quot;Denominates&quot; or &quot;scales&quot; variables by other variables. Typically this is done by dividing extensive variables such as
GDP by a scaling variable such as population, to give an intensive variable (GDP per capita).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Denominate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Denominate_+3A_x">x</code></td>
<td>
<p>Object to be denominated</p>
</td></tr>
<tr><td><code id="Denominate_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for individual methods:
</p>

<ul>
<li> <p><code><a href="#topic+Denominate.data.frame">Denominate.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Denominate.coin">Denominate.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Denominate.purse">Denominate.purse()</a></code>.
</p>
</li></ul>

<p>This function replaces the now-defunct <code>denominate()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>See individual method documentation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See individual method documentation

</code></pre>

<hr>
<h2 id='Denominate.coin'>Denominate data set in a coin</h2><span id='topic+Denominate.coin'></span>

<h3>Description</h3>

<p>&quot;Denominates&quot; or &quot;scales&quot; indicators by other variables. Typically this is done by dividing extensive variables such as
GDP by a scaling variable such as population, to give an intensive variable (GDP per capita).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Denominate(
  x,
  dset,
  denoms = NULL,
  denomby = NULL,
  denoms_ID = NULL,
  f_denom = NULL,
  write_to = NULL,
  out2 = "coin",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Denominate.coin_+3A_x">x</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_denoms">denoms</code></td>
<td>
<p>An optional data frame of denominator data. Columns should be denominator data, with column names corresponding
to entries in <code>denomby</code>. This must also include an ID column identified by <code>denoms_ID</code> to match rows. If <code>denoms</code>
is not specified, will extract any potential denominator columns that were attached to <code>iData</code> when calling <code><a href="#topic+new_coin">new_coin()</a></code>.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_denomby">denomby</code></td>
<td>
<p>Optional data frame which specifies which denominators to use for each indicator, and any scaling factors
to apply. Should have columns <code>iCode</code>, <code>Denominator</code>, <code>ScaleFactor</code>. <code>iCode</code> specifies an indicator code found in <code>dset</code>,
<code>Denominator</code> specifies a column name from <code>denoms</code> to use to denominate the corresponding column from <code>x</code>.
<code>ScaleFactor</code> allows the possibility to scale
denominators if needed, and specifies a factor to multiply the resulting values by. For example, if GDP is a denominator and is measured in
dollars, dividing will create very small numbers (order 1e-10 and smaller) which could cause problems with numerical precision. If <code>denomby</code>
is not specified, specifications will be taken from the &quot;Denominator&quot; column in <code>iMeta</code>, if it exists.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_denoms_id">denoms_ID</code></td>
<td>
<p>An ID column for matching <code>denoms</code> with the data to be denominated. This column should contain
<code>uMeta</code> codes to match with the data set extracted from the coin.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_f_denom">f_denom</code></td>
<td>
<p>A function which takes two numeric vector arguments and is used to perform the denomination for each
column. By default, this is division, i.e. <code>x[[col]]/denoms[[col]]</code> for given columns, but any function can be passed
that takes two numeric vectors as inputs and returns a single numeric vector. See details.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Denominated"</code>.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_out2">out2</code></td>
<td>
<p>Either <code>"coin"</code> (default) to return updated coin or <code>"df"</code> to output the aggregated data set.</p>
</td></tr>
<tr><td><code id="Denominate.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function denominates a data set <code>dset</code> inside the coin. By default, denominating variables are taken from
the coin, specifically as variables in <code>iData</code> with <code>Type = "Denominator"</code> in <code>iMeta</code> (input to <code><a href="#topic+new_coin">new_coin()</a></code>).
Specifications to map denominators to indicators are also taken by default from <code>iMeta$Denominator</code>, if it exists.
</p>
<p>These specifications can be overridden using the <code>denoms</code> and <code>denomby</code> arguments. The operator for denomination
can also be changed using the <code>f_denom</code> argument.
</p>
<p>See also documentation for <code><a href="#topic+Denominate.data.frame">Denominate.data.frame()</a></code> which is called by this method.
</p>


<h3>Value</h3>

<p>An updated coin if <code>out2 = "coin"</code>, else a data frame of denominated data if <code>out2 = "df"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# denominate (here, we only need to say which dset to use, takes
# specs and denominators from within the coin)
coin &lt;- Denominate(coin, dset = "Raw")

</code></pre>

<hr>
<h2 id='Denominate.data.frame'>Denominate data sets by other variables</h2><span id='topic+Denominate.data.frame'></span>

<h3>Description</h3>

<p>&quot;Denominates&quot; or &quot;scales&quot; variables by other variables. Typically this is done by dividing extensive variables such as
GDP by a scaling variable such as population, to give an intensive variable (GDP per capita).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
Denominate(
  x,
  denoms,
  denomby,
  x_ID = NULL,
  denoms_ID = NULL,
  f_denom = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Denominate.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame of data to be denominated. Columns to be denominated must be numeric, but any columns not
specified in <code>denomby</code> will be ignored. <code>x</code> must also contain an ID column specified by <code>x_ID</code> to match rows with
<code>denoms</code>.</p>
</td></tr>
<tr><td><code id="Denominate.data.frame_+3A_denoms">denoms</code></td>
<td>
<p>A data frame of denominator data. Columns should be denominator data, with column names corresponding
to entries in <code>denomby</code>. This must also include an ID column identified by <code>denoms_ID</code> to match rows.</p>
</td></tr>
<tr><td><code id="Denominate.data.frame_+3A_denomby">denomby</code></td>
<td>
<p>A data frame which specifies which denominators to use for each indicator, and any scaling factors
to apply. Should have columns <code>iCode</code>, <code>Denominator</code>, <code>ScaleFactor</code>. <code>iCode</code> specifies a column name from <code>x</code>,
<code>Denominator</code> specifies a column name from <code>denoms</code> to use to denominate the corresponding column from <code>x</code>.
<code>ScaleFactor</code> allows the possibility to scale
denominators if needed, and specifies a factor to multiply the resulting values by. For example, if GDP is a denominator and is measured in
dollars, dividing will create very small numbers (order 1e-10 and smaller) which could cause problems with numerical precision.</p>
</td></tr>
<tr><td><code id="Denominate.data.frame_+3A_x_id">x_ID</code></td>
<td>
<p>A column name of <code>x</code> to use to match rows with <code>denoms</code>. Default is <code>"uCode"</code>.</p>
</td></tr>
<tr><td><code id="Denominate.data.frame_+3A_denoms_id">denoms_ID</code></td>
<td>
<p>A column name of <code>denoms</code> to use to match rows with <code>x</code>. Default is <code>"uCode"</code>.</p>
</td></tr>
<tr><td><code id="Denominate.data.frame_+3A_f_denom">f_denom</code></td>
<td>
<p>A function which takes two numeric vector arguments and is used to perform the denomination for each
column. By default, this is division, i.e. <code>x[[col]]/denoms[[col]]</code> for given columns, but any function can be passed
that takes two numeric vectors as inputs and returns a single numeric vector. See details.</p>
</td></tr>
<tr><td><code id="Denominate.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data frame <code>x</code> is denominated by variables found in another data frame <code>denoms</code>, according to specifications in
<code>denomby</code>. <code>denomby</code> specifies which columns in <code>x</code> are to be denominated, and by which columns in <code>denoms</code>, and
any scaling factors to apply to each denomination.
</p>
<p>Both <code>x</code> and <code>denomby</code> must contain an ID column which matches the rows of <code>x</code> to <code>denomby</code>. If not specified, this
is assumed to be <code>uCode</code>,  but can also be specified using the <code>x_ID</code> and <code>denoms_ID</code> arguments. All entries in
<code>x[[x_ID]]</code> must be present in <code>denoms[[denoms_ID]]</code>, although extra rows are allowed in <code>denoms</code>. This is because
the rows of <code>x</code> are matched to the rows of <code>denoms</code> using these ID columns, to ensure that units (rows) are correctly
denominated.
</p>
<p>By default, columns of <code>x</code> are divided by columns of <code>denoms</code>. This can be generalised by setting <code>f_denom</code> to another
function which takes two numeric vector arguments. I.e. setting <code style="white-space: pre;">&#8288;denoms = ``*`` &#8288;</code> will multiply columns of <code>x</code> and
denoms together.
</p>


<h3>Value</h3>

<p>A data frame of the same size as <code>x</code>, with any specified columns denominated according to specifications.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+WorldDenoms">WorldDenoms</a> A data set of some common national-level denominators.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get a sample of indicator data (note must be indicators plus a "UnitCode" column)
iData &lt;- ASEM_iData[c("uCode", "Goods", "Flights", "LPI")]
# Also get some denominator data
denoms &lt;- ASEM_iData[c("uCode", "GDP", "Population")]
# specify how to denominate
denomby &lt;- data.frame(iCode = c("Goods", "Flights"),
Denominator = c("GDP", "Population"),
ScaleFactor = c(1, 1000))
# Denominate one by the other
iData_den &lt;- Denominate(iData, denoms, denomby)

</code></pre>

<hr>
<h2 id='Denominate.purse'>Denominate a data set within a purse.</h2><span id='topic+Denominate.purse'></span>

<h3>Description</h3>

<p>This works in almost exactly the same way as <code><a href="#topic+Denominate.coin">Denominate.coin()</a></code>. The only point of care is that the
<code>denoms</code> argument here cannot take time-indexed data, but only a single value for each unit. It is
therefore recommended to pass the time-dependent denominator data as part of <code>iData</code> when calling
<code><a href="#topic+new_coin">new_coin()</a></code>. In this way, denominators can vary with time. See <code>vignette("denomination")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Denominate(
  x,
  dset,
  denoms = NULL,
  denomby = NULL,
  denoms_ID = NULL,
  f_denom = NULL,
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Denominate.purse_+3A_x">x</code></td>
<td>
<p>A purse class object</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_denoms">denoms</code></td>
<td>
<p>An optional data frame of denominator data. Columns should be denominator data, with column names corresponding
to entries in <code>denomby</code>. This must also include an ID column identified by <code>denoms_ID</code> to match rows. If <code>denoms</code>
is not specified, will extract any potential denominator columns that were attached to <code>iData</code> when calling <code><a href="#topic+new_coin">new_coin()</a></code>.</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_denomby">denomby</code></td>
<td>
<p>Optional data frame which specifies which denominators to use for each indicator, and any scaling factors
to apply. Should have columns <code>iCode</code>, <code>Denominator</code>, <code>ScaleFactor</code>. <code>iCode</code> specifies an indicator code found in <code>dset</code>,
<code>Denominator</code> specifies a column name from <code>denoms</code> to use to denominate the corresponding column from <code>x</code>.
<code>ScaleFactor</code> allows the possibility to scale
denominators if needed, and specifies a factor to multiply the resulting values by. For example, if GDP is a denominator and is measured in
dollars, dividing will create very small numbers (order 1e-10 and smaller) which could cause problems with numerical precision. If <code>denomby</code>
is not specified, specifications will be taken from the &quot;Denominator&quot; column in <code>iMeta</code>, if it exists.</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_denoms_id">denoms_ID</code></td>
<td>
<p>An ID column for matching <code>denoms</code> with the data to be denominated. This column should contain
uMeta codes to match with the data set extracted from the coin.</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_f_denom">f_denom</code></td>
<td>
<p>A function which takes two numeric vector arguments and is used to perform the denomination for each
column. By default, this is division, i.e. <code>x[[col]]/denoms[[col]]</code> for given columns, but any function can be passed
that takes two numeric vectors as inputs and returns a single numeric vector. See details.</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Denominated"</code>.</p>
</td></tr>
<tr><td><code id="Denominate.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated purse
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse
purse &lt;- build_example_purse(up_to = "new_coin", quietly = TRUE)

# denominate using data/specs already included in coin
purse &lt;- Denominate(purse, dset = "Raw")


</code></pre>

<hr>
<h2 id='export_to_excel'>Export a coin or purse to Excel</h2><span id='topic+export_to_excel'></span>

<h3>Description</h3>

<p>Writes coins and purses to Excel. See individual method
documentation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_to_excel(x, fname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_to_excel_+3A_x">x</code></td>
<td>
<p>A coin or purse</p>
</td></tr>
<tr><td><code id="export_to_excel_+3A_fname">fname</code></td>
<td>
<p>The file name to write to</p>
</td></tr>
<tr><td><code id="export_to_excel_+3A_...">...</code></td>
<td>
<p>Arguments passed to/from methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>coin2Excel()</code> from COINr &lt; v1.0.
</p>

<ul>
<li> <p><code><a href="#topic+export_to_excel.coin">export_to_excel.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+export_to_excel.purse">export_to_excel.purse()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>An Excel spreadsheet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see individual method documentation

</code></pre>

<hr>
<h2 id='export_to_excel.coin'>Export a coin to Excel</h2><span id='topic+export_to_excel.coin'></span>

<h3>Description</h3>

<p>Exports the contents of the coin to Excel. This writes all data frames inside the coin to Excel, with each data
frame on a separate tab. Tabs are named according to the position in the coin object. You can write other
data frames by simply attaching them to the coin object somewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
export_to_excel(x, fname = "coin_export.xlsx", include_log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_to_excel.coin_+3A_x">x</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="export_to_excel.coin_+3A_fname">fname</code></td>
<td>
<p>The file name/path to write to, as a character string</p>
</td></tr>
<tr><td><code id="export_to_excel.coin_+3A_include_log">include_log</code></td>
<td>
<p>Logical: if <code>TRUE</code>, also writes data frames from the <code>.$Log</code> list inside the coin.</p>
</td></tr>
<tr><td><code id="export_to_excel.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.xlsx file at specified path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Here we write a COIN to Excel, but this is done to a temporary directory
## to avoid "polluting" the working directory when running automatic tests.
## In a real case, set fname to a directory of your choice.

# build example coin up to data treatment step
coin &lt;- build_example_coin(up_to = "Treat")

# write to Excel in temporary directory
export_to_excel(coin, fname = paste0(tempdir(), "\\ASEM_results.xlsx"))

# spreadsheet is at:
print(paste0(tempdir(), "\\ASEM_results.xlsx"))

# now delete temporary file to keep things tidy in testing
unlink(paste0(tempdir(),"\\ASEM_results.xlsx"))

</code></pre>

<hr>
<h2 id='export_to_excel.purse'>Export a purse to Excel</h2><span id='topic+export_to_excel.purse'></span>

<h3>Description</h3>

<p>Exports the contents of the purse to Excel. This is similar to the coin method <code><a href="#topic+export_to_excel.coin">export_to_excel.coin()</a></code>,
but combines data sets from various time points. It also selectively writes metadata since this may be
spread across multiple coins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
export_to_excel(x, fname = "coin_export.xlsx", include_log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_to_excel.purse_+3A_x">x</code></td>
<td>
<p>A purse class object</p>
</td></tr>
<tr><td><code id="export_to_excel.purse_+3A_fname">fname</code></td>
<td>
<p>The file name/path to write to, as a character string</p>
</td></tr>
<tr><td><code id="export_to_excel.purse_+3A_include_log">include_log</code></td>
<td>
<p>Logical: if <code>TRUE</code>, also writes data frames from the <code>.$Log</code> list inside the coin.</p>
</td></tr>
<tr><td><code id="export_to_excel.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.xlsx file at specified path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#

</code></pre>

<hr>
<h2 id='get_corr'>Get correlations</h2><span id='topic+get_corr'></span>

<h3>Description</h3>

<p>Helper function for getting correlations between indicators and aggregates. This retrieves subsets of correlation
matrices between different aggregation levels, in different formats. By default, it will return a
long-form data frame, unless <code>make_long = FALSE</code>. By default, any correlations with a p-value less than 0.05 are
replaced with <code>NA</code>. See <code>pval</code> argument to adjust this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_corr(
  coin,
  dset,
  iCodes = NULL,
  Levels = NULL,
  ...,
  cortype = "pearson",
  pval = 0.05,
  withparent = FALSE,
  grouplev = NULL,
  make_long = TRUE,
  use_directions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_corr_+3A_coin">coin</code></td>
<td>
<p>A coin class coin object</p>
</td></tr>
<tr><td><code id="get_corr_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_icodes">iCodes</code></td>
<td>
<p>An optional list of character vectors where the first entry specifies the indicator/aggregate
codes to correlate against the second entry (also a specification of indicator/aggregate codes). If this is specified as a character vector
it will coerced to the first entry of a list, i.e. <code>list(iCodes)</code>.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_levels">Levels</code></td>
<td>
<p>The aggregation levels to take the two groups of indicators from. See <code><a href="#topic+get_data">get_data()</a></code> for details.
Defaults to indicator level.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+get_data">get_data()</a></code> (<code>uCodes</code> and <code>use_group</code>).</p>
</td></tr>
<tr><td><code id="get_corr_+3A_cortype">cortype</code></td>
<td>
<p>The type of correlation to calculate, either <code>"pearson"</code>, <code>"spearman"</code>, or <code>"kendall"</code>.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_pval">pval</code></td>
<td>
<p>The significance level for including correlations. Correlations with <code class="reqn">p &gt; pval</code> will be returned as <code>NA</code>.
Default 0.05. Set to 0 to disable this.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_withparent">withparent</code></td>
<td>
<p>If <code>TRUE</code>, and <code>aglev[1] != aglev[2]</code>, will only return correlations of each row with its parent. Alternatively, if
<code>withparent = "family"</code>, will return correlations with parents, grandparents etc, up to the highest level. In both cases the data set
must be aggregated for this to work.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_grouplev">grouplev</code></td>
<td>
<p>The aggregation level to group correlations by if <code>aglev[1] == aglev[2]</code>. Requires that
<code>make_long = TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_make_long">make_long</code></td>
<td>
<p>Logical: if <code>TRUE</code>, returns correlations in long format (default), else if <code>FALSE</code>
returns in wide format. Note that if wide format is requested, features specified by <code>grouplev</code>
and <code>withparent</code> are not supported.</p>
</td></tr>
<tr><td><code id="get_corr_+3A_use_directions">use_directions</code></td>
<td>
<p>Logical: if <code>TRUE</code> the extracted data is adjusted using directions found inside the coin (i.e. the &quot;Direction&quot;
column input in <code>iMeta</code>: any indicators with negative direction will have their values multiplied by -1 which will reverse the
direction of correlation). This should only be set to <code>TRUE</code> if the data set has not yet been normalised. For example, this can be
useful to set to <code>TRUE</code> to analyse correlations in the raw data, but would make no sense to analyse correlations in the normalised
data because that already has the direction adjusted! So you would reverse direction twice. In other words, use this at your
discretion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to obtain correlations between any subset of indicators or aggregates, from
any data set present in a coin. Indicator selection is performed using <code><a href="#topic+get_data">get_data()</a></code>. Two different
indicator sets can be correlated against each other by specifying <code>iCodes</code> and <code>Levels</code> as vectors.
</p>
<p>The correlation type can be specified by the <code>cortype</code> argument, which is passed to <code><a href="stats.html#topic+cor">stats::cor()</a></code>.
</p>
<p>The <code>withparent</code> argument will optionally only return correlations which correspond to the structure
of the index. For example, if <code>Levels = c(1,2)</code> (i.e. we wish to correlate indicators from Level 1 with
aggregates from Level 2), and we set <code>withparent = TRUE</code>, only the correlations between each indicator
and its parent group will be returned (not correlations between indicators and other aggregates to which
it does not belong). This can be useful to check whether correlations of an indicator/aggregate with
any of its parent groups exceeds or falls below thresholds.
</p>
<p>Similarly, the <code>grouplev</code> argument can be used to restrict correlations to within groups corresponding
to the index structure. Setting e.g. <code>grouplev = 2</code> will only return correlations within the groups
defined at Level 2.
</p>
<p>The <code>grouplev</code> and <code>withparent</code> options are disabled if <code>make_long = FALSE</code>.
</p>
<p>Note that this function can only call correlations within the same data set (i.e. only one data set in <code>.$Data</code>).
</p>
<p>This function replaces the now-defunct <code>getCorr()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame of pairwise correlation values in wide or long format (see <code>make_long</code>).
Correlations with <code class="reqn">p &gt; pval</code> will be returned as <code>NA</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+plot_corr">plot_corr()</a></code> Plot correlation matrices of indicator subsets
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# get correlations
cmat &lt;- get_corr(coin, dset = "Raw", iCodes = list("Environ"),
                 Levels = 1, make_long = FALSE)

</code></pre>

<hr>
<h2 id='get_corr_flags'>Find highly-correlated indicators within groups</h2><span id='topic+get_corr_flags'></span>

<h3>Description</h3>

<p>This returns a data frame of any highly correlated indicators within the same aggregation group. The level of the aggregation
grouping can be controlled by the <code>grouplev</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_corr_flags(
  coin,
  dset,
  cor_thresh = 0.9,
  thresh_type = "high",
  cortype = "pearson",
  grouplev = NULL,
  roundto = 3,
  use_directions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_corr_flags_+3A_coin">coin</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_cor_thresh">cor_thresh</code></td>
<td>
<p>A threshold to flag high correlation. Default 0.9.</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_thresh_type">thresh_type</code></td>
<td>
<p>Either <code>"high"</code>, which will only flag correlations <em>above</em> <code>cor_thresh</code>, or <code>"low"</code>,
which will only flag correlations <em>below</em> <code>cor_thresh</code>.</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_cortype">cortype</code></td>
<td>
<p>The type of correlation, either <code>"pearson"</code> (default), <code>"spearman"</code> or <code>"kendall"</code>. See <a href="stats.html#topic+cor">stats::cor</a>.</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_grouplev">grouplev</code></td>
<td>
<p>The level to group indicators in. E.g. if <code>grouplev = 2</code> it will look for high correlations between indicators that
belong to the same group in Level 2.</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_roundto">roundto</code></td>
<td>
<p>Number of decimal places to round correlations to. Default 3. Set <code>NULL</code> to disable rounding.</p>
</td></tr>
<tr><td><code id="get_corr_flags_+3A_use_directions">use_directions</code></td>
<td>
<p>Logical: if <code>TRUE</code> the extracted data is adjusted using directions found inside the coin (i.e. the &quot;Direction&quot;
column input in <code>iMeta</code>. See comments on this argument in <code><a href="#topic+get_corr">get_corr()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is motivated by the idea that having very highly-correlated indicators within the same group may
amount to double counting, or possibly redundancy in the framework.
</p>
<p>This function replaces the now-defunct <code>hicorrSP()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame with one entry for every indicator pair that is highly correlated within the same group, at the specified level.
Pairs are only reported once, i.e. only uses the upper triangle of the correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "Normalise", quietly = TRUE)

# get correlations between indicator over 0.75 within level 2 groups
get_corr_flags(coin, dset = "Normalised", cor_thresh = 0.75,
               thresh_type = "high", grouplev = 2)

</code></pre>

<hr>
<h2 id='get_cronbach'>Cronbach's alpha</h2><span id='topic+get_cronbach'></span>

<h3>Description</h3>

<p>Calculates Cronbach's alpha, a measure of statistical reliability. Cronbach's alpha is a simple measure
of &quot;consistency&quot; of a data set, where a high value implies higher reliability/consistency. The
selection of indicators via <code><a href="#topic+get_data">get_data()</a></code> allows to calculate the measure on any group of
indicators or aggregates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cronbach(coin, dset, iCodes, Level, ..., use = "pairwise.complete.obs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cronbach_+3A_coin">coin</code></td>
<td>
<p>A coin or a data frame containing only numerical columns of data.</p>
</td></tr>
<tr><td><code id="get_cronbach_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_cronbach_+3A_icodes">iCodes</code></td>
<td>
<p>Indicator codes to retrieve. If <code>NULL</code> (default), returns all iCodes found in
the selected data set. See <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="get_cronbach_+3A_level">Level</code></td>
<td>
<p>The level in the hierarchy to extract data from. See <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="get_cronbach_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+get_data">get_data()</a></code>, other than those explicitly specified here.</p>
</td></tr>
<tr><td><code id="get_cronbach_+3A_use">use</code></td>
<td>
<p>Argument to pass to <a href="stats.html#topic+cor">stats::cor</a> to calculate the covariance matrix. Default <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply returns Cronbach's alpha. If you want a lot more details on reliability, the 'psych' package has
a much more detailed analysis.
</p>
<p>This function replaces the now-defunct <code>getCronbach()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Cronbach alpha as a numerical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# Cronbach's alpha for the "P2P" group
get_cronbach(coin, dset = "Raw", iCodes = "P2P", Level = 1)

</code></pre>

<hr>
<h2 id='get_data'>Get subsets of indicator data</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>A helper function to retrieve a named data set from coin or purse objects. See individual method
documentation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_x">x</code></td>
<td>
<p>A coin or purse</p>
</td></tr>
<tr><td><code id="get_data_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+get_data.coin">get_data.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_data.purse">get_data.purse()</a></code>
</p>
</li></ul>

<p>This function replaces the now-defunct <code>getIn()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Data frame of indicator data, indexed also by time if input is a purse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see individual method documentation

</code></pre>

<hr>
<h2 id='get_data_avail'>Get data availability of units</h2><span id='topic+get_data_avail'></span>

<h3>Description</h3>

<p>Generic function for getting the data availability of each unit (row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_avail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_avail_+3A_x">x</code></td>
<td>
<p>Either a coin or a data frame</p>
</td></tr>
<tr><td><code id="get_data_avail_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See method documentation:
</p>

<ul>
<li> <p><code><a href="#topic+get_data_avail.data.frame">get_data_avail.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_data_avail.coin">get_data_avail.coin()</a></code>
</p>
</li></ul>

<p>See also vignettes: <code>vignette("analysis")</code> and <code>vignette("imputation")</code>.
</p>

<hr>
<h2 id='get_data_avail.coin'>Get data availability of units</h2><span id='topic+get_data_avail.coin'></span>

<h3>Description</h3>

<p>Returns a list of data frames: the data availability of each unit (row) in a given data set, as well as percentage of zeros.
A second data frame gives data availability by aggregation (indicator) groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
get_data_avail(x, dset, out2 = "coin", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_avail.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="get_data_avail.coin_+3A_dset">dset</code></td>
<td>
<p>String indicating name of data set in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_data_avail.coin_+3A_out2">out2</code></td>
<td>
<p>Either <code>"coin"</code> to output an updated coin or <code>"list"</code> to output a list.</p>
</td></tr>
<tr><td><code id="get_data_avail.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function ignores any non-numeric columns, and returns a data availability table of numeric columns with non-numeric columns
appended at the beginning.
</p>
<p>See also vignettes: <code>vignette("analysis")</code> and <code>vignette("imputation")</code>.
</p>


<h3>Value</h3>

<p>An updated coin with data availability tables written in <code>.$Analysis[[dset]]</code>, or a
list of data availability tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;-  build_example_coin(up_to = "new_coin", quietly = TRUE)

# get data availability of Raw dset
l_dat &lt;- get_data_avail(coin, dset = "Raw", out2 = "list")
head(l_dat$Summary, 5)

</code></pre>

<hr>
<h2 id='get_data_avail.data.frame'>Get data availability of units</h2><span id='topic+get_data_avail.data.frame'></span>

<h3>Description</h3>

<p>Returns a data frame of the data availability of each unit (row), as well as percentage of zeros. This
function ignores any non-numeric columns, and returns a data availability table with non-numeric columns
appended at the beginning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
get_data_avail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_avail.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="get_data_avail.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also vignettes: <code>vignette("analysis")</code> and <code>vignette("imputation")</code>.
</p>


<h3>Value</h3>

<p>A data frame of data availability statistics for each column of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data availability of "airquality" data set
get_data_avail(airquality)

</code></pre>

<hr>
<h2 id='get_data.coin'>Get subsets of indicator data</h2><span id='topic+get_data.coin'></span>

<h3>Description</h3>

<p>A flexible function for retrieving data from a coin, from a specified data set. Subsets of data can
be returned based on selection of columns, using the <code>iCodes</code> and <code>Level</code> arguments, and by filtering
rowwise using the <code>uCodes</code> and <code>use_group</code> arguments. The <code>also_get</code> argument also allows unit metadata
columns to be attached, such as names, groups, and denominators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
get_data(
  x,
  dset,
  iCodes = NULL,
  Level = NULL,
  uCodes = NULL,
  use_group = NULL,
  also_get = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data.coin_+3A_x">x</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_icodes">iCodes</code></td>
<td>
<p>Optional indicator codes to retrieve. If <code>NULL</code> (default), returns all iCodes found in
the selected data set. Can also refer to indicator groups. See details.</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_level">Level</code></td>
<td>
<p>Optionally, the level in the hierarchy to extract data from. See details.</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_ucodes">uCodes</code></td>
<td>
<p>Optional unit codes to filter rows of the resulting data set. Can also be used in conjunction
with groups. See details.</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_use_group">use_group</code></td>
<td>
<p>Optional group to filter rows of the data set. Specified as <code>list(Group_Var = Group)</code>,
where <code>Group_Var</code> is a Group_ column that must be present in the selected data set, and <code>Group</code> is a specified group
inside that grouping variable. This filters the selected data to only include rows from the specified group. Can
also be used in conjunction with <code>uCodes</code> &ndash; see details.</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_also_get">also_get</code></td>
<td>
<p>A character vector specifying any columns to attach to the data set that are <em>not</em>
indicators or aggregates. These will be e.g. <code>uName</code>, groups, denominators or columns labelled as &quot;Other&quot;
in <code>iMeta</code>. These columns are stored in <code>.$Meta$Unit</code> to avoid repetition. Set <code>also_get = "all"</code> to
attach all columns, or set <code>also_get = "none"</code> to return only numeric columns, i.e. no <code>uCode</code> column.</p>
</td></tr>
<tr><td><code id="get_data.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>iCodes</code> argument can be used to directly select named indicators, i.e. setting <code>iCodes = c("a", "b")</code>
will select indicators &quot;a&quot; and &quot;b&quot;, attaching any extra columns specified by <code>also_get</code>. However,
using this in conjunction with the <code>Level</code> argument returns named groups of indicators. For example,
setting <code>iCodes = "Group1"</code> (for e.g. an aggregation group in Level 2) and <code>Level = 1</code> will return
all indicators in Level 1, belonging to &quot;Group1&quot;.
</p>
<p>Rows can also be subsetted. The <code>uCodes</code> argument can be used to select specified units in the same
way as <code>iCodes</code>. Additionally, the <code>use_group</code> argument filters to specified groups. If <code>uCodes</code> is
specified, and <code>use_group</code> refers to a named group column, then it will return all units in the
groups that the <code>uCodes</code> belong to. This is useful for putting a unit into context with its peers
based on some grouping variable.
</p>
<p>Note that if you want to retrieve a whole data set (with no column/row subsetting), use the
<code><a href="#topic+get_dset">get_dset()</a></code> function which should be slightly faster.
</p>


<h3>Value</h3>

<p>A data frame of indicator data according to specifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# get all indicators in "Political group
x &lt;- get_data(coin, dset = "Raw", iCodes = "Political", Level = 1)
head(x, 5)

# see vignette("data_selection") for more examples

</code></pre>

<hr>
<h2 id='get_data.purse'>Get subsets of indicator data</h2><span id='topic+get_data.purse'></span>

<h3>Description</h3>

<p>This retrieves data from a purse. It functions in a similar way to <code><a href="#topic+get_data.coin">get_data.coin()</a></code> but has the
additional <code>Time</code> argument to allow selection based on the point(s) in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
get_data(
  x,
  dset,
  iCodes = NULL,
  Level = NULL,
  uCodes = NULL,
  use_group = NULL,
  Time = NULL,
  also_get = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data.purse_+3A_x">x</code></td>
<td>
<p>A purse class object</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_icodes">iCodes</code></td>
<td>
<p>Optional indicator codes to retrieve. If <code>NULL</code> (default), returns all iCodes found in
the selected data set. Can also refer to indicator groups. See details.</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_level">Level</code></td>
<td>
<p>Optionally, the level in the hierarchy to extract data from. See details.</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_ucodes">uCodes</code></td>
<td>
<p>Optional unit codes to filter rows of the resulting data set. Can also be used in conjunction
with groups. See details.</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_use_group">use_group</code></td>
<td>
<p>Optional group to filter rows of the data set. Specified as <code>list(Group_Var = Group)</code>,
where <code>Group_Var</code> is a Group_ column that must be present in the selected data set, and <code>Group</code> is a specified group
inside that grouping variable. This filters the selected data to only include rows from the specified group. Can
also be used in conjunction with <code>uCodes</code> &ndash; see details.</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_time">Time</code></td>
<td>
<p>Optional time index to extract from a subset of the coins present in the purse. Should be a
vector containing one or more entries in <code>x$Time</code> or <code>NULL</code> to return all (default).</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_also_get">also_get</code></td>
<td>
<p>A character vector specifying any columns to attach to the data set that are <em>not</em>
indicators or aggregates. These will be e.g. <code>uName</code>, groups, denominators or columns labelled as &quot;Other&quot;
in <code>iMeta</code>. These columns are stored in <code>.$Meta$Unit</code> to avoid repetition. Set <code>also_get = "all"</code> to
attach all columns, or set <code>also_get = "none"</code> to return only numeric columns, i.e. no <code>uCode</code> column.</p>
</td></tr>
<tr><td><code id="get_data.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that
</p>


<h3>Value</h3>

<p>A data frame of indicator data indexed by a &quot;Time&quot; column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example purse
purse &lt;- build_example_purse(up_to = "new_coin", quietly = TRUE)

# get specified indicators for specific years, for specified units
get_data(purse, dset = "Raw",
         iCodes = c("Lang", "Forest"),
         uCodes = c("AUT", "CHN", "DNK"),
         Time = c(2019, 2020))

</code></pre>

<hr>
<h2 id='get_denom_corr'>Correlations between indicators and denominators</h2><span id='topic+get_denom_corr'></span>

<h3>Description</h3>

<p>Get a data frame containing any correlations between indicators and denominators that exceed a given
threshold. This can be useful when <em>whether</em> to denominate an indicator and <em>by what</em> may not be obvious.
If an indicator is strongly correlated with a denominator, this may suggest to denominate it by that
denominator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_denom_corr(
  coin,
  dset,
  cor_thresh = 0.6,
  cortype = "pearson",
  nround = 2,
  use_directions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_denom_corr_+3A_coin">coin</code></td>
<td>
<p>A coin class object.</p>
</td></tr>
<tr><td><code id="get_denom_corr_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="get_denom_corr_+3A_cor_thresh">cor_thresh</code></td>
<td>
<p>A correlation threshold: the absolute value of any correlations between indicator-denominator pairs above this
threshold will be flagged.</p>
</td></tr>
<tr><td><code id="get_denom_corr_+3A_cortype">cortype</code></td>
<td>
<p>The type of correlation: to be passed to the <code>method</code> argument of <code>stats::cor</code>.</p>
</td></tr>
<tr><td><code id="get_denom_corr_+3A_nround">nround</code></td>
<td>
<p>Optional number of decimal places to round correlation values to. Default 2, set <code>NULL</code> to
disable.</p>
</td></tr>
<tr><td><code id="get_denom_corr_+3A_use_directions">use_directions</code></td>
<td>
<p>Logical: if <code>TRUE</code> the extracted data is adjusted using directions found inside the coin (i.e. the &quot;Direction&quot;
column input in <code>iMeta</code>. See comments on this argument in <code><a href="#topic+get_corr">get_corr()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of pairwise correlations that exceed the threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# get correlations &gt;0.7 of any indicator with denominators
get_denom_corr(coin, dset = "Raw", cor_thresh = 0.7)

</code></pre>

<hr>
<h2 id='get_dset'>Gets a named data set and performs checks</h2><span id='topic+get_dset'></span>

<h3>Description</h3>

<p>A helper function to retrieve a named data set from coin or purse objects. See individual
documentation on:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dset(x, dset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dset_+3A_x">x</code></td>
<td>
<p>A coin or purse</p>
</td></tr>
<tr><td><code id="get_dset_+3A_dset">dset</code></td>
<td>
<p>A character string corresponding to a named data set within <code>.$Data</code>. E.g. <code>"Raw"</code>.</p>
</td></tr>
<tr><td><code id="get_dset_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+get_dset.coin">get_dset.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_dset.purse">get_dset.purse()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>Data frame of indicator data, indexed also by time if input is a purse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples for methods

</code></pre>

<hr>
<h2 id='get_dset.coin'>Gets a named data set and performs checks</h2><span id='topic+get_dset.coin'></span>

<h3>Description</h3>

<p>A helper function to retrieve a named data set from the coin object. Also performs input checks at the
same time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
get_dset(x, dset, also_get = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dset.coin_+3A_x">x</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="get_dset.coin_+3A_dset">dset</code></td>
<td>
<p>A character string corresponding to a named data set within <code>.$Data</code>. E.g. <code>"Raw"</code>.</p>
</td></tr>
<tr><td><code id="get_dset.coin_+3A_also_get">also_get</code></td>
<td>
<p>A character vector specifying any columns to attach to the data set that are <em>not</em>
indicators or aggregates. These will be e.g. <code>uName</code>, groups, denominators or columns labelled as &quot;Other&quot;
in <code>iMeta</code>. These columns are stored in <code>.$Meta$Unit</code> to avoid repetition. Set <code>also_get = "all"</code> to
attach all columns, or set <code>also_get = "none"</code> to return only numeric columns, i.e. no <code>uCode</code> column.</p>
</td></tr>
<tr><td><code id="get_dset.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>also_get</code> is not specified, this will return the indicator columns with the <code>uCode</code> identifiers
in the first column. Optionally, <code>also_get</code> can be specified to attach other metadata columns, or
to only return the numeric (indicator) columns with no identifiers. This latter option might be useful
for e.g. examining correlations.
</p>


<h3>Value</h3>

<p>Data frame of indicator data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin, just up to raw dset for speed
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# retrieve raw data set with added cols
get_dset(coin, dset = "Raw", also_get = c("uName", "GDP_group"))

</code></pre>

<hr>
<h2 id='get_dset.purse'>Gets a named data set and performs checks</h2><span id='topic+get_dset.purse'></span>

<h3>Description</h3>

<p>A helper function to retrieve a named data set from a purse object. Retrieves the specified data set
from each coin in the purse and joins them together in a single data frame using <code><a href="base.html#topic+rbind">rbind()</a></code>, indexed
with a <code>Time</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
get_dset(x, dset, Time = NULL, also_get = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dset.purse_+3A_x">x</code></td>
<td>
<p>A purse class object</p>
</td></tr>
<tr><td><code id="get_dset.purse_+3A_dset">dset</code></td>
<td>
<p>A character string corresponding to a named data set within each coin <code>.$Data</code>. E.g. <code>"Raw"</code>.</p>
</td></tr>
<tr><td><code id="get_dset.purse_+3A_time">Time</code></td>
<td>
<p>Optional time index to extract from a subset of the coins present in the purse. Should be a
vector containing one or more entries in <code>x$Time</code> or <code>NULL</code> to return all (default).</p>
</td></tr>
<tr><td><code id="get_dset.purse_+3A_also_get">also_get</code></td>
<td>
<p>A character vector specifying any columns to attach to the data set that are <em>not</em>
indicators or aggregates. These will be e.g. <code>uName</code>, groups, denominators or columns labelled as &quot;Other&quot;
in <code>iMeta</code>. These columns are stored in <code>.$Meta$Unit</code> to avoid repetition. Set <code>also_get = "all"</code> to
attach all columns, or set <code>also_get = "none"</code> to return only numeric columns, i.e. no <code>uCode</code> column.</p>
</td></tr>
<tr><td><code id="get_dset.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of indicator data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse
purse &lt;- build_example_purse(up_to = "new_coin", quietly = TRUE)

# get raw data set
df1 &lt;- get_dset(purse, dset = "Raw")

</code></pre>

<hr>
<h2 id='get_eff_weights'>Get effective weights</h2><span id='topic+get_eff_weights'></span>

<h3>Description</h3>

<p>Calculates the &quot;effective weight&quot; of each indicator and aggregate at the index level. The effective weight is calculated
as the final weight of each component in the index, and this is due to not just to its own weight, but also to the weights of
each aggregation that it is involved in, plus the number of indicators/aggregates in each group. The effective weight
is one way of understanding the final contribution of each indicator to the index. See also <code>vignette("weights")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eff_weights(coin, out2 = "df")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eff_weights_+3A_coin">coin</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="get_eff_weights_+3A_out2">out2</code></td>
<td>
<p>Either <code>"coin"</code> or <code>"df"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>effectiveWeight()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Either an iMeta data frame with effective weights as an added column, or an updated coin with effective
weights added to <code>.$Meta$Ind</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# get effective weights as data frame
w_eff &lt;- get_eff_weights(coin, out2 = "df")

head(w_eff)

</code></pre>

<hr>
<h2 id='get_noisy_weights'>Noisy replications of weights</h2><span id='topic+get_noisy_weights'></span>

<h3>Description</h3>

<p>Given a data frame of weights, this function returns multiple replicates of the weights, with added
noise. This is intended for use in uncertainty and sensitivity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_noisy_weights(w, noise_specs, Nrep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_noisy_weights_+3A_w">w</code></td>
<td>
<p>A data frame of weights, in the format found in <code>.$Meta$Weights</code>.</p>
</td></tr>
<tr><td><code id="get_noisy_weights_+3A_noise_specs">noise_specs</code></td>
<td>
<p>a data frame with columns:
</p>

<ul>
<li> <p><code>Level</code>: The aggregation level to apply noise to
</p>
</li>
<li> <p><code>NoiseFactor</code>: The size of the perturbation: setting e.g. 0.2 perturbs by +/- 20% of nominal values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_noisy_weights_+3A_nrep">Nrep</code></td>
<td>
<p>The number of weight replications to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights are expected to be in a data frame format with columns <code>Level</code>, <code>iCode</code> and <code>Weight</code>, as
used in <code>iMeta</code>. Note that no <code>NA</code>s are allowed anywhere in the data frame.
</p>
<p>Noise is added using the <code>noise_specs</code> argument, which is specified by a data frame with columns
<code>Level</code> and <code>NoiseFactor</code>. The aggregation level refers to number of the aggregation level to target
while the <code>NoiseFactor</code> refers to the size of the perturbation. If e.g. a row is <code>Level = 1</code> and
<code>NoiseFactor = 0.2</code>, this will allow the weights in aggregation level 1 to deviate by +/- 20% of their
nominal values (the values in <code>w</code>).
</p>
<p>This function replaces the now-defunct <code>noisyWeights()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A list of <code>Nrep</code> sets of weights (data frames).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_sensitivity">get_sensitivity()</a></code> Perform global sensitivity or uncertainty analysis on a COIN
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# get nominal weights
w_nom &lt;- coin$Meta$Weights$Original

# build data frame specifying the levels to apply the noise at
# here we vary at levels 2 and 3
noise_specs = data.frame(Level = c(2,3),
                         NoiseFactor = c(0.25, 0.25))

# get 100 replications
noisy_wts &lt;- get_noisy_weights(w = w_nom, noise_specs = noise_specs, Nrep = 100)

# examine one of the noisy weight sets, last few rows
tail(noisy_wts[[1]])

</code></pre>

<hr>
<h2 id='get_opt_weights'>Weight optimisation</h2><span id='topic+get_opt_weights'></span>

<h3>Description</h3>

<p>This function provides optimised weights to agree with a pre-specified vector of &quot;target importances&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_opt_weights(
  coin,
  itarg = NULL,
  dset,
  Level,
  cortype = "pearson",
  optype = "balance",
  toler = NULL,
  maxiter = NULL,
  weights_to = NULL,
  out2 = "list"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_opt_weights_+3A_coin">coin</code></td>
<td>
<p>coin object</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_itarg">itarg</code></td>
<td>
<p>a vector of (relative) target importances. For example, <code>c(1,2,1)</code> would specify that the second
indicator should be twice as &quot;important&quot; as the other two.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_dset">dset</code></td>
<td>
<p>Name of the aggregated data set found in <code>coin$Data</code> which results from calling <code><a href="#topic+Aggregate">Aggregate()</a></code>.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_level">Level</code></td>
<td>
<p>The aggregation level to apply the weight adjustment to. This can only be one level.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_cortype">cortype</code></td>
<td>
<p>The type of correlation to use - can be either <code>"pearson"</code>, <code>"spearman"</code> or <code>"kendall"</code>. See <a href="stats.html#topic+cor">stats::cor</a>.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_optype">optype</code></td>
<td>
<p>The optimisation type. Either <code>"balance"</code>, which aims to balance correlations
according to a vector of &quot;importances&quot; specified by <code>itarg</code> (default), or <code>"infomax"</code> which aims to maximise
overall correlations.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_toler">toler</code></td>
<td>
<p>Tolerance for convergence. Defaults to 0.1 (decrease for more accuracy, increase if convergence problems).</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Default 500.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_weights_to">weights_to</code></td>
<td>
<p>Name to write the optimised weight set to, if <code>out2 = "coin"</code>.</p>
</td></tr>
<tr><td><code id="get_opt_weights_+3A_out2">out2</code></td>
<td>
<p>Where to output the results. If <code>"coin"</code> (default for coin input), appends to updated coin,
creating a new list of weights in <code>.$Parameters$Weights</code>. Otherwise if <code>"list"</code> outputs to a list (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a linear version of the weight optimisation proposed in this paper: <a href="https://doi.org/10.1016/j.ecolind.2017.03.056">doi:10.1016/j.ecolind.2017.03.056</a>.
Weights are optimised to agree with a pre-specified vector of &quot;importances&quot;. The optimised weights are returned back to the coin.
</p>
<p>See <code>vignette("weights")</code> for more details on the usage of this function and an explanation of the underlying
method. Note that this function calculates correlations without considering statistical significance.
</p>
<p>This function replaces the now-defunct <code>weightOpt()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>If <code>out2 = "coin"</code> returns an updated coin object with a new set of weights in <code>.$Meta$Weights</code>, plus
details of the optimisation in <code>.$Analysis</code>.
Else if <code>out2 = "list"</code> the same outputs (new weights plus details of optimisation) are wrapped in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(quietly = TRUE)

# check correlations between level 3 and index
get_corr(coin, dset = "Aggregated", Levels = c(3, 4))

# optimise weights at level 3
l_opt &lt;- get_opt_weights(coin, itarg = "equal", dset = "Aggregated",
                        Level = 3, weights_to = "OptLev3", out2 = "list")

# view results
tail(l_opt$WeightsOpt)

l_opt$CorrResultsNorm

</code></pre>

<hr>
<h2 id='get_PCA'>Perform PCA on a coin</h2><span id='topic+get_PCA'></span>

<h3>Description</h3>

<p>Performs Principle Component Analysis (PCA) on a specified data set and subset of indicators or aggregation groups.
This function has two main outputs: the output(s) of <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, and optionally the weights resulting from
the PCA. Therefore it can be used as an analysis tool and/or a weighting tool. For the weighting aspect, please
see the details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_PCA(
  coin,
  dset = "Raw",
  iCodes = NULL,
  Level = NULL,
  by_groups = TRUE,
  nowarnings = FALSE,
  weights_to = NULL,
  out2 = "list"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_PCA_+3A_coin">coin</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="get_PCA_+3A_dset">dset</code></td>
<td>
<p>The name of the data set in <code>.$Data</code> to use.</p>
</td></tr>
<tr><td><code id="get_PCA_+3A_icodes">iCodes</code></td>
<td>
<p>An optional character vector of indicator codes to subset the indicator data, passed to <code><a href="#topic+get_data">get_data()</a></code></p>
</td></tr>
<tr><td><code id="get_PCA_+3A_level">Level</code></td>
<td>
<p>The aggregation level to take indicator data from. Integer from 1 (indicator level)
to N (top aggregation level, typically the index).</p>
</td></tr>
<tr><td><code id="get_PCA_+3A_by_groups">by_groups</code></td>
<td>
<p>If <code>TRUE</code> (default), performs PCA inside each aggregation group inside the specified level. If <code>FALSE</code>,
performs a single PCA over all indicators/aggregates in the specified level.</p>
</td></tr>
<tr><td><code id="get_PCA_+3A_nowarnings">nowarnings</code></td>
<td>
<p>If <code>FALSE</code> (default), will give warnings where missing data are found. Set to <code>TRUE</code> to suppress these warnings.</p>
</td></tr>
<tr><td><code id="get_PCA_+3A_weights_to">weights_to</code></td>
<td>
<p>A string to name the resulting set of weights. If this is specified, and <code>out2 = "coin"</code>,
will write a new set of &quot;PCA weights&quot; to the <code>.$Meta$Weights</code> list. This is experimental - see details. If
<code>NULL</code>, does not write any weights (default).</p>
</td></tr>
<tr><td><code id="get_PCA_+3A_out2">out2</code></td>
<td>
<p>If the input is a coin object, this controls where to send the output. If <code>"coin"</code>, it
sends the results to the coin object, otherwise if <code>"list"</code>, outputs to a separate list (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PCA must be approached with care and an understanding of what is going on. First, let's consider the PCA excluding
the weighting component. PCA takes a set of data consisting of variables (indicators) and observations. It then
rotates the coordinate system such that in the new coordinate system, the first axis (called the first principal
component (PC)) aligns with the direction of maximum variance of the data set. The amount of variance explained by the
first PC, and by the next several PCs, can help to understand whether the data can be explained by simpler set of
variables. PCA is often used for dimensionality reduction in modelling, for example.
</p>
<p>In the context of composite indicators, PCA can be used first as an analysis tool. We can check for example, within
an aggregation group, can the indicators mostly be explained by one PC? If so, this gives a little extra justification
to aggregating the indicators because the information lost in aggregation will be less. We can also check this over
the entire set of indicators.
</p>
<p>The complications are in a composite indicator, the indicators are grouped and arranged into a hierarchy. This means
that when performing a PCA, we have to decide which level to perform it at, and which groupings to use, if any. The <code><a href="#topic+get_PCA">get_PCA()</a></code>
function, using the <code>by_groups</code> argument, allows to automatically apply PCA by group if this is required.
</p>
<p>The output of <code><a href="#topic+get_PCA">get_PCA()</a></code> is a PCA object for each of the groups specified, which can then be examined using existing
tools in R, see <code>vignette("analysis")</code>.
</p>
<p>The other output of <code><a href="#topic+get_PCA">get_PCA()</a></code> is a set of &quot;PCA weights&quot; if the <code>weights_to</code> argument is specified. Here we also need
to say some words of caution. First, what constitutes &quot;PCA weights&quot; in composite indicators is not very well-defined.
In COINr, a simple option is adopted. That is, the loadings of the first principal component are taken as the weights.
The logic here is that these loadings should maximise the explained variance - the implication being that if we use
these as weights in an aggregation, we should maximise the explained variance and hence the information passed from
the indicators to the aggregate value. This is a nice property in a composite indicator, where one of the aims is to
represent many indicators by single composite. See <a href="https://doi.org/10.1016/j.envsoft.2021.105208">doi:10.1016/j.envsoft.2021.105208</a> for a
discussion on this.
</p>
<p>But. The weights that result from PCA have a number of downsides. First, they can often include negative weights
which can be hard to justify. Also PCA may arbitrarily flip the axes (since from a variance point of view the
direction is not important). In the quest for maximum variance, PCA will also weight the strongest-correlating
indicators the highest, which means that other indicators may be neglected. In short, it often results in a very
unbalanced set of weights. Moreover, PCA can only be performed on one level at a time.
</p>
<p>All these considerations point to the fact: while PCA as an analysis tool is well-established, please use PCA weights
with care and understanding of what is going on.
</p>
<p>This function replaces the now-defunct <code>getPCA()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>If <code>out2 = "coin"</code>, results are appended to the coin object. Specifically:
</p>

<ul>
<li><p> A list is added to <code>.$Analysis</code> containing PCA weights (loadings) of the first principle component, and the output of <a href="stats.html#topic+prcomp">stats::prcomp</a>, for each
aggregation group found in the targeted level.
</p>
</li>
<li><p> If <code>weights_to</code> is specified, a new set of PCA weights is added to <code>.$Meta$Weights</code>
If <code>out2 = "list"</code> the same outputs are contained in a list.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="stats.html#topic+prcomp">stats::prcomp</a> Principle component analysis
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# PCA on "Sust" group of indicators
l_pca &lt;- get_PCA(coin, dset = "Raw", iCodes = "Sust",
                 out2 = "list", nowarnings = TRUE)

# Summary of results for one of the sub-groups
summary(l_pca$PCAresults$Social$PCAres)

</code></pre>

<hr>
<h2 id='get_pvals'>P-values for correlations in a data frame or matrix</h2><span id='topic+get_pvals'></span>

<h3>Description</h3>

<p>This is a stripped down version of the &quot;cor.mtest()&quot; function from the &quot;corrplot&quot; package. It uses
the <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code> function to calculate pairwise p-values. Unlike the corrplot version, this
only calculates p-values, and not confidence intervals. Credit to corrplot for this code, I only
replicate it here to avoid depending on their package for a single function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pvals(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pvals_+3A_x">X</code></td>
<td>
<p>A numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="get_pvals_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to function <code><a href="stats.html#topic+cor.test">cor.test()</a></code>, e.g. <code>conf.level = 0.95</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of p-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a matrix of random numbers, 3 cols
x &lt;- matrix(runif(30), 10, 3)

# get correlations between cols
cor(x)

# get p values of correlations between cols
get_pvals(x)

</code></pre>

<hr>
<h2 id='get_results'>Results summary tables</h2><span id='topic+get_results'></span>

<h3>Description</h3>

<p>Generates fast results tables, either attached to the coin or as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_results(
  coin,
  dset,
  tab_type = "Summ",
  also_get = NULL,
  use = "scores",
  order_by = NULL,
  nround = 2,
  use_group = NULL,
  dset_indicators = NULL,
  out2 = "df"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_results_+3A_coin">coin</code></td>
<td>
<p>The coin object, or a data frame of indicator data</p>
</td></tr>
<tr><td><code id="get_results_+3A_dset">dset</code></td>
<td>
<p>Name of data set in <code>.$Data</code></p>
</td></tr>
<tr><td><code id="get_results_+3A_tab_type">tab_type</code></td>
<td>
<p>The type of table to generate. Either <code>"Summ"</code> (a single indicator plus rank), <code>"Aggs"</code> (all aggregated
scores/ranks above indicator level), or <code>"Full"</code> (all scores/ranks plus all group, denominator columns).</p>
</td></tr>
<tr><td><code id="get_results_+3A_also_get">also_get</code></td>
<td>
<p>Names of further columns to attach to table.</p>
</td></tr>
<tr><td><code id="get_results_+3A_use">use</code></td>
<td>
<p>Either <code>"scores"</code> (default), <code>"ranks"</code>, or <code>"groupranks"</code>. For the latter, <code>use_group</code> must be specified.</p>
</td></tr>
<tr><td><code id="get_results_+3A_order_by">order_by</code></td>
<td>
<p>A code of the indicator or aggregate to sort the table by. If not specified, defaults to the highest
aggregate level, i.e. the index in most cases. If <code>use_group</code> is specified, rows will also be sorted by the specified group.</p>
</td></tr>
<tr><td><code id="get_results_+3A_nround">nround</code></td>
<td>
<p>The number of decimal places to round numerical values to. Defaults to 2.</p>
</td></tr>
<tr><td><code id="get_results_+3A_use_group">use_group</code></td>
<td>
<p>An optional grouping variable. If specified, the results table includes this group column,
and if <code>use = "groupranks"</code>, ranks will be returned with respect to the groups in this column.</p>
</td></tr>
<tr><td><code id="get_results_+3A_dset_indicators">dset_indicators</code></td>
<td>
<p>Optional data set from which to take only indicator (level 1) data from. This can be set to <code>"Raw"</code>
for example, so that all aggregates come from the aggregated data set, and the indicators come from the raw data set. This
can make more sense in presenting results in many cases, so that the &quot;real&quot; indicator data is visible.</p>
</td></tr>
<tr><td><code id="get_results_+3A_out2">out2</code></td>
<td>
<p>If <code>"df"</code>, outputs a data frame (tibble). Else if <code>"coin"</code> attaches to <code>.$Results</code> in an updated coin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although results are available in a coin in <code>.$Data</code>, the format makes it difficult to quickly present results. This function
generates results tables that are suitable for immediate presentation, i.e. sorted by index or other indicators, and only including
relevant columns. Scores are also rounded by default, and there is the option to present scores or ranks.
</p>
<p>See also <code>vignette("results")</code> for more info.
</p>
<p>This function replaces the now-defunct <code>getResults()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>If <code>out2 = "df"</code>, the results table is returned as a data frame. If <code>out2 = "coin"</code>, this function returns an updated
coin with the results table attached to <code>.$Results</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example coin
coin &lt;- build_example_coin(quietly = TRUE)

# get results table
df_results &lt;- get_results(coin, dset = "Aggregated", tab_type = "Aggs")

head(df_results)

</code></pre>

<hr>
<h2 id='get_sensitivity'>Sensitivity and uncertainty analysis of a coin</h2><span id='topic+get_sensitivity'></span>

<h3>Description</h3>

<p>This function performs global sensitivity and uncertainty analysis of a coin. You must specify which
parameters of the coin to vary, and the alternatives/distributions for those parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sensitivity(
  coin,
  SA_specs,
  N,
  SA_type = "UA",
  dset,
  iCode,
  Nboot = NULL,
  quietly = FALSE,
  check_addresses = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sensitivity_+3A_coin">coin</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_sa_specs">SA_specs</code></td>
<td>
<p>Specifications of the input uncertainties</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_n">N</code></td>
<td>
<p>The number of regenerations</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_sa_type">SA_type</code></td>
<td>
<p>The type of analysis to run. <code>"UA"</code> runs an uncertainty analysis. <code>"SA"</code> runs a sensitivity
analysis (which anyway includes an uncertainty analysis).</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_dset">dset</code></td>
<td>
<p>The data set to extract the target variable from (passed to <code><a href="#topic+get_data">get_data()</a></code>).</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_icode">iCode</code></td>
<td>
<p>The variable within <code>dset</code> to use as the target variable (passed to <code><a href="#topic+get_data">get_data()</a></code>).</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_nboot">Nboot</code></td>
<td>
<p>Number of bootstrap samples to take when estimating confidence intervals on sensitivity
indices.</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_quietly">quietly</code></td>
<td>
<p>Set to <code>TRUE</code> to suppress progress messages.</p>
</td></tr>
<tr><td><code id="get_sensitivity_+3A_check_addresses">check_addresses</code></td>
<td>
<p>Logical: if <code>FALSE</code> skips the check of the validity of the parameter addresses. Default <code>TRUE</code>,
but useful to set to <code>FALSE</code> if running this e.g. in a Rmd document (because may require user input).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>COINr implements a flexible variance-based global sensitivity analysis approach, which allows almost any assumption
to be varied, as long as the distribution of alternative values can be described. Variance-based &quot;sensitivity indices&quot;
are estimated using a Monte Carlo design (running the composite indicator many times with a particular combination of
input values). This follows the methodology described in <a href="https://doi.org/10.1111/j.1467-985X.2005.00350.x">doi:10.1111/j.1467-985X.2005.00350.x</a>.
</p>
<p>To understand how this function works, please see <code>vignette("sensitivity")</code>. Here, we briefly recap the main input
arguments.
</p>
<p>First, you can select whether to run an uncertainty analysis <code>SA_type = "UA"</code> or sensitivity analysis <code>SA_type = "SA"</code>.
The number of replications (regenerations of the coin) is specified by <code>N</code>. Keep in mind that the <em>total</em> number of
replications is <code>N</code> for an uncertainty analysis but is <code>N*(d + 2)</code> for a sensitivity analysis due to the experimental
design used.
</p>
<p>To run either types of analysis, you must specify <em>which</em> parts of the coin to vary and <em>what the distributions/alternatives are</em>
This is done using <code>SA_specs</code>, a structured list. See <code>vignette("sensitivity")</code> for details and examples.
</p>
<p>You also need to specify the target of the sensitivity analysis. This should be an indicator or aggregate that can be
found in one of the data sets of the coin, and is specified using the <code>dset</code> and <code>iCode</code> arguments.
</p>
<p>Finally, if <code>SA_type = "SA"</code>, it is advisable to set <code>Nboot</code> to e.g. 100 or more, which is the number of bootstrap samples
to take when estimating confidence intervals on sensitivity indices. This does <em>not</em> perform extra regenerations of the
coin, so setting this to a higher number shouldn't have much impact on computational time.
</p>
<p>This function replaces the now-defunct <code>sensitivity()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Sensitivity analysis results as a list, containing:
</p>

<ul>
<li> <p><code>.$Scores</code> a data frame with a row for each unit, and columns are the scores for each replication.
</p>
</li>
<li> <p><code>.$Ranks</code> as <code>.$Scores</code> but for unit ranks
</p>
</li>
<li> <p><code>.$RankStats</code> summary statistics for ranks of each unit
</p>
</li>
<li> <p><code>.$Para</code> a list containing parameter values for each run
</p>
</li>
<li> <p><code>.$Nominal</code> the nominal scores and ranks of each unit (i.e. from the original COIN)
</p>
</li>
<li> <p><code>.$Sensitivity</code> (only if <code>SA_type = "SA"</code>) sensitivity indices for each parameter. Also confidence intervals if <code>Nboot</code>
was specified.
</p>
</li>
<li><p> Some information on the time elapsed, average time, and the parameters perturbed.
</p>
</li>
<li><p> Depending on the setting of <code>store_results</code>, may also contain a list of Methods or a list of COINs for each replication.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># for examples, see `vignette("sensitivity")`
# (this is because package examples are run automatically and this function can
# take a few minutes to run at realistic settings)

</code></pre>

<hr>
<h2 id='get_stats'>Statistics of columns/indicators</h2><span id='topic+get_stats'></span>

<h3>Description</h3>

<p>Generic function for reports various statistics from a data frame or coin. See method documentation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stats(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stats_+3A_x">x</code></td>
<td>
<p>Object (data frame or coin)</p>
</td></tr>
<tr><td><code id="get_stats_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+get_stats.data.frame">get_stats.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_stats.coin">get_stats.coin()</a></code>
</p>
</li></ul>

<p>See also <code>vignette("analysis")</code>.
</p>
<p>This function replaces the now-defunct <code>getStats()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame of statistics for each column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see individual method documentation

</code></pre>

<hr>
<h2 id='get_stats.coin'>Statistics of indicators</h2><span id='topic+get_stats.coin'></span>

<h3>Description</h3>

<p>Given a coin and a specified data set (<code>dset</code>), returns a table of statistics with entries for each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
get_stats(
  x,
  dset,
  t_skew = 2,
  t_kurt = 3.5,
  t_avail = 0.65,
  t_zero = 0.5,
  t_unq = 0.5,
  nsignif = 3,
  out2 = "df",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stats.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_dset">dset</code></td>
<td>
<p>A data set present in <code>.$Data</code></p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_t_skew">t_skew</code></td>
<td>
<p>Absolute skewness threshold. See details.</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_t_kurt">t_kurt</code></td>
<td>
<p>Kurtosis threshold. See details.</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_t_avail">t_avail</code></td>
<td>
<p>Data availability threshold. See details.</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_t_zero">t_zero</code></td>
<td>
<p>A threshold between 0 and 1 for flagging indicators with high proportion of zeroes. See details.</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_t_unq">t_unq</code></td>
<td>
<p>A threshold between 0 and 1 for flagging indicators with low proportion of unique values. See details.plot</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_nsignif">nsignif</code></td>
<td>
<p>Number of significant figures to round the output table to.</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_out2">out2</code></td>
<td>
<p>Either <code>"df"</code> (default) to output a data frame of indicator statistics, or &quot;<code>coin</code>&quot; to output an
updated coin with the data frame attached under <code>.$Analysis</code>.</p>
</td></tr>
<tr><td><code id="get_stats.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistics (columns in the output table) are as follows (entries correspond to each column):
</p>

<ul>
<li> <p><code>Min</code>: the minimum
</p>
</li>
<li> <p><code>Max</code>: the maximum
</p>
</li>
<li> <p><code>Mean</code>: the (arirthmetic) mean
</p>
</li>
<li> <p><code>Median</code>: the median
</p>
</li>
<li> <p><code>Std</code>: the standard deviation
</p>
</li>
<li> <p><code>Skew</code>: the skew
</p>
</li>
<li> <p><code>Kurt</code>: the kurtosis
</p>
</li>
<li> <p><code>N.Avail</code>: the number of non-<code>NA</code> values
</p>
</li>
<li> <p><code>N.NonZero</code>: the number of non-zero values
</p>
</li>
<li> <p><code>N.Unique</code>: the number of unique values
</p>
</li>
<li> <p><code>Frc.Avail</code>: the fraction of non-<code>NA</code> values
</p>
</li>
<li> <p><code>Frc.NonZero</code>: the fraction of non-zero values
</p>
</li>
<li> <p><code>Frc.Unique</code>: the fraction of unique values
</p>
</li>
<li> <p><code>Flag.Avail</code>: a data availability flag - columns with <code>Frc.Avail &lt; t_avail</code> will be flagged as <code>"LOW"</code>, else <code>"ok"</code>.
</p>
</li>
<li> <p><code>Flag.NonZero</code>: a flag for columns with a high proportion of zeros. Any columns with <code>Frc.NonZero &lt; t_zero</code> are
flagged as <code>"LOW"</code>, otherwise <code>"ok"</code>.
</p>
</li>
<li> <p><code>Flag.Unique</code>: a unique value flag - any columns with <code>Frc.Unique &lt; t_unq</code> are flagged as <code>"LOW"</code>, otherwise <code>"ok"</code>.
</p>
</li>
<li> <p><code>Flag.SkewKurt</code>: a skew and kurtosis flag which is an indication of possible outliers. Any columns with
<code>abs(Skew) &gt; t_skew</code> AND <code>Kurt &gt; t_kurt</code> are flagged as <code>"OUT"</code>, otherwise <code>"ok"</code>.
</p>
</li></ul>

<p>The aim of this table, among other things, is to check the basic statistics of each column/indicator, and identify
any possible issues for each indicator. For example, low data availability, having a high proportion of zeros and/or
a low proportion of unique values. Further, the combination of skew and kurtosis (i.e. the <code>Flag.SkewKurt</code> column)
is a simple test for possible outliers, which may require treatment using <code><a href="#topic+Treat">Treat()</a></code>.
</p>
<p>The table can be returned either to the coin or as a standalone data frame - see <code>out2</code>.
</p>
<p>See also <code>vignette("analysis")</code>.
</p>


<h3>Value</h3>

<p>Either a data frame or updated coin - see <code>out2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;-  build_example_coin(up_to = "new_coin", quietly = TRUE)

# get table of indicator statistics for raw data set
get_stats(coin, dset = "Raw", out2 = "df")

</code></pre>

<hr>
<h2 id='get_stats.data.frame'>Statistics of columns</h2><span id='topic+get_stats.data.frame'></span>

<h3>Description</h3>

<p>Takes a data frame and returns a table of statistics with entries for each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
get_stats(
  x,
  t_skew = 2,
  t_kurt = 3.5,
  t_avail = 0.65,
  t_zero = 0.5,
  t_unq = 0.5,
  nsignif = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stats.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame with only numeric columns.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_t_skew">t_skew</code></td>
<td>
<p>Absolute skewness threshold. See details.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_t_kurt">t_kurt</code></td>
<td>
<p>Kurtosis threshold. See details.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_t_avail">t_avail</code></td>
<td>
<p>Data availability threshold. See details.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_t_zero">t_zero</code></td>
<td>
<p>A threshold between 0 and 1 for flagging indicators with high proportion of zeroes. See details.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_t_unq">t_unq</code></td>
<td>
<p>A threshold between 0 and 1 for flagging indicators with low proportion of unique values. See details.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_nsignif">nsignif</code></td>
<td>
<p>Number of significant figures to round the output table to.</p>
</td></tr>
<tr><td><code id="get_stats.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistics (columns in the
output table) are as follows (entries correspond to each column):
</p>

<ul>
<li> <p><code>Min</code>: the minimum
</p>
</li>
<li> <p><code>Max</code>: the maximum
</p>
</li>
<li> <p><code>Mean</code>: the (arirthmetic) mean
</p>
</li>
<li> <p><code>Median</code>: the median
</p>
</li>
<li> <p><code>Std</code>: the standard deviation
</p>
</li>
<li> <p><code>Skew</code>: the skew
</p>
</li>
<li> <p><code>Kurt</code>: the kurtosis
</p>
</li>
<li> <p><code>N.Avail</code>: the number of non-<code>NA</code> values
</p>
</li>
<li> <p><code>N.NonZero</code>: the number of non-zero values
</p>
</li>
<li> <p><code>N.Unique</code>: the number of unique values
</p>
</li>
<li> <p><code>Frc.Avail</code>: the fraction of non-<code>NA</code> values
</p>
</li>
<li> <p><code>Frc.NonZero</code>: the fraction of non-zero values
</p>
</li>
<li> <p><code>Frc.Unique</code>: the fraction of unique values
</p>
</li>
<li> <p><code>Flag.Avail</code>: a data availability flag - columns with <code>Frc.Avail &lt; t_avail</code> will be flagged as <code>"LOW"</code>, else <code>"ok"</code>.
</p>
</li>
<li> <p><code>Flag.NonZero</code>: a flag for columns with a high proportion of zeros. Any columns with <code>Frc.NonZero &lt; t_zero</code> are
flagged as <code>"LOW"</code>, otherwise <code>"ok"</code>.
</p>
</li>
<li> <p><code>Flag.Unique</code>: a unique value flag - any columns with <code>Frc.Unique &lt; t_unq</code> are flagged as <code>"LOW"</code>, otherwise <code>"ok"</code>.
</p>
</li>
<li> <p><code>Flag.SkewKurt</code>: a skew and kurtosis flag which is an indication of possible outliers. Any columns with
<code>abs(Skew) &gt; t_skew</code> AND <code>Kurt &gt; t_kurt</code> are flagged as <code>"OUT"</code>, otherwise <code>"ok"</code>.
</p>
</li></ul>

<p>The aim of this table, among other things, is to check the basic statistics of each column/indicator, and identify
any possible issues for each indicator. For example, low data availability, having a high proportion of zeros and/or
a low proportion of unique values. Further, the combination of skew and kurtosis (i.e. the <code>Flag.SkewKurt</code> column)
is a simple test for possible outliers, which may require treatment using <code><a href="#topic+Treat">Treat()</a></code>.
</p>
<p>See also <code>vignette("analysis")</code>.
</p>


<h3>Value</h3>

<p>A data frame of statistics for each column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># stats of mtcars
get_stats(mtcars)

</code></pre>

<hr>
<h2 id='get_str_weak'>Generate strengths and weaknesses for a specified unit</h2><span id='topic+get_str_weak'></span>

<h3>Description</h3>

<p>Generates a table of strengths and weaknesses for a selected unit, based on ranks, or ranks within
a specified grouping variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_str_weak(
  coin,
  dset,
  usel = NULL,
  topN = 5,
  bottomN = 5,
  withcodes = TRUE,
  use_group = NULL,
  unq_discard = NULL,
  min_discard = TRUE,
  report_level = NULL,
  with_units = TRUE,
  adjust_direction = NULL,
  sig_figs = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_str_weak_+3A_coin">coin</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_dset">dset</code></td>
<td>
<p>The data set to extract indicator data from, to use as strengths and weaknesses.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_usel">usel</code></td>
<td>
<p>A selected unit code</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_topn">topN</code></td>
<td>
<p>The top N indicators to report</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_bottomn">bottomN</code></td>
<td>
<p>The bottom N indicators to report</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_withcodes">withcodes</code></td>
<td>
<p>If <code>TRUE</code> (default), also includes a column of indicator codes. Setting to <code>FALSE</code> may be more useful
in generating reports, where codes are not helpful.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_use_group">use_group</code></td>
<td>
<p>An optional grouping variable to use for reporting
in-group ranks. Specifying this will report the ranks of the selected unit within the group of <code>use_group</code>
to which it belongs.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_unq_discard">unq_discard</code></td>
<td>
<p>Optional parameter for handling discrete indicators. Some indicators may be binary
variables of the type &quot;yes = 1&quot;, &quot;no = 0&quot;. These may be picked up as strengths or weaknesses, when they
may not be wanted to be highlighted, since e.g. maybe half of units will have a zero or a one. This argument
takes a number between 0 and 1 specifying a unique value threshold for ignoring indicators as strengths. E.g.
setting <code>prc_unq_discard = 0.2</code> will ensure that only indicators with at least 20% unique values will be
highlighted as strengths or weaknesses. Set to <code>NULL</code> to disable (default).</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_min_discard">min_discard</code></td>
<td>
<p>If <code>TRUE</code> (default), discards any strengths which correspond to the minimum rank for the given
indicator. See details.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_report_level">report_level</code></td>
<td>
<p>Aggregation level to report parent codes from. For example, setting
<code>report_level = 2</code> (default) will add a column to the strengths and weaknesses tables which reports the aggregation
group from level 2, to which each reported indicator belongs.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_with_units">with_units</code></td>
<td>
<p>If <code>TRUE</code> (default), includes indicator units in output tables.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_adjust_direction">adjust_direction</code></td>
<td>
<p>If <code>TRUE</code>, will adjust directions of indicators according to the &quot;Direction&quot; column
of <code>IndMeta</code>. By default, this is <code>TRUE</code> <em>if</em> <code>dset = "Raw"</code>, and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="get_str_weak_+3A_sig_figs">sig_figs</code></td>
<td>
<p>Number of significant figures to round values to. If <code>NULL</code> returns values as they are.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This currently only works at the indicator level. Indicators with <code>NA</code> values for the selected unit are ignored.
Strengths and weaknesses mean the <code>topN</code>-ranked indicators for the selected unit. Effectively, this takes the rank that the
selected unit has in each indicator, sorts the ranks, and takes the top N highest and lowest.
</p>
<p>This function must be used with a little care: indicators should be adjusted for their directions before use,
otherwise a weakness might be counted as a strength, and vice versa. Use the <code>adjust_direction</code> parameter
to help here.
</p>
<p>A further useful parameter is <code>unq_discard</code>, which also filters out any indicators with a low number of
unique values, based on a specified threshold. Also <code>min_discard</code> which filters out any indicators which
have the minimum rank.
</p>
<p>The best way to use this function is to play around with the settings a little bit. The reason being that
in practice, indicators have very different distributions and these can sometimes lead to unexpected
outcomes. An example is if you have an indicator with 50% zero values, and the rest non-zero (but unique).
Using the sport ranking system, all units with zero values will receive a rank which is equal to the number
of units divided by two. This then might be counted as a &quot;strength&quot; for some units with overall low scores.
But a zero value can hardly be called a strength. This is where the <code>min_discard</code> function can help out.
</p>
<p>Problems such as these mainly arise when e.g. generating a large number of country profiles.
</p>
<p>This function replaces the now-defunct <code>getStrengthNWeak()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A list containing a data frame <code>.$Strengths</code>, and a data frame <code>.$Weaknesses</code>.
Each data frame has columns with indicator code, name, rank and value (for the selected unit).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# get strengths and weaknesses for ESP
get_str_weak(coin, dset = "Raw", usel = "ESP")

</code></pre>

<hr>
<h2 id='get_trends'>Get time trends</h2><span id='topic+get_trends'></span>

<h3>Description</h3>

<p>Get time trends from a purse object. This function extracts a panel data set from a purse, and calculates trends
for each indicator/unit pair using a specified function <code>f_trend</code>. For example, if <code>f_trend = "CAGR"</code>, this extracts
the time series for each indicator/unit pair and passes it to <code><a href="#topic+CAGR">CAGR()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trends(
  purse,
  dset,
  uCodes = NULL,
  iCodes = NULL,
  Time = NULL,
  use_latest = NULL,
  f_trend = "CAGR",
  interp_at = NULL,
  adjust_directions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trends_+3A_purse">purse</code></td>
<td>
<p>A purse object</p>
</td></tr>
<tr><td><code id="get_trends_+3A_dset">dset</code></td>
<td>
<p>Name of the data set to extract, passed to <code><a href="#topic+get_data.purse">get_data.purse()</a></code></p>
</td></tr>
<tr><td><code id="get_trends_+3A_ucodes">uCodes</code></td>
<td>
<p>Optional subset of unit codes to extract, passed to <code><a href="#topic+get_data.purse">get_data.purse()</a></code></p>
</td></tr>
<tr><td><code id="get_trends_+3A_icodes">iCodes</code></td>
<td>
<p>Optional subset of indicator/aggregate codes to extract, passed to <code><a href="#topic+get_data.purse">get_data.purse()</a></code></p>
</td></tr>
<tr><td><code id="get_trends_+3A_time">Time</code></td>
<td>
<p>Optional vector of time points to extract, passed to <code><a href="#topic+get_data.purse">get_data.purse()</a></code></p>
</td></tr>
<tr><td><code id="get_trends_+3A_use_latest">use_latest</code></td>
<td>
<p>A positive integer which specifies to use only the latest &quot;n&quot; data points. If this is specified, it
overrides <code>Time</code>. If e.g. <code>use_latest = 5</code>, will use the latest five observations, working backwards from the latest
non-<code>NA</code> point.</p>
</td></tr>
<tr><td><code id="get_trends_+3A_f_trend">f_trend</code></td>
<td>
<p>Function that returns a metric describing the trend of the time series. See details.</p>
</td></tr>
<tr><td><code id="get_trends_+3A_interp_at">interp_at</code></td>
<td>
<p>Option to linearly interpolate missing data points in each time series. Must be specified as a vector
of time values where to apply interpolation. If <code>interp_at = "all"</code>, will attempt to interpolate at every
time point. Uses linear interpolation - note that any <code>NA</code>s outside of the range of observed values will not
be estimated, i.e. this does not <em>extrapolate</em> beyond the range of data. See <code><a href="#topic+approx_df">approx_df()</a></code>.</p>
</td></tr>
<tr><td><code id="get_trends_+3A_adjust_directions">adjust_directions</code></td>
<td>
<p>Logical: if <code>TRUE</code>, trend metrics are adjusted according to indicator/aggregate
directions input in <code>iMeta</code> (i.e. if the corresponding direction is -1, the metric will be multiplied by -1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a purse object as an input. The data set is selected using <code><a href="#topic+get_data">get_data()</a></code>, such that a subset
of the data set can be analysed using the <code>uCodes</code>, <code>iCodes</code> and <code>Time</code> arguments. The latter is useful especially
if only a subset of the time series should be analysed.
</p>
<p>The function <code>f_trend</code> is a function that, given a time series, returns a trend metric. This must follow a
specific format. It must of course be available to call, and <em>must</em> have arguments <code>y</code> and <code>x</code>, which are
respectively a vector of values and a vector indexing the values in time. See <code><a href="#topic+prc_change">prc_change()</a></code> and <code><a href="#topic+CAGR">CAGR()</a></code>
for examples. The function <em>must</em> return a single value (not a vector with multiple entries, or a list).
The function can return either numeric or character values.
</p>


<h3>Value</h3>

<p>A data frame in long format, with trend metrics for each indicator/unit pair, plus
data availability statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#

</code></pre>

<hr>
<h2 id='get_unit_summary'>Generate unit summary table</h2><span id='topic+get_unit_summary'></span>

<h3>Description</h3>

<p>Generates a summary table for a single unit. This is mostly useful in unit reports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unit_summary(coin, usel, Levels, dset = "Aggregated", nround = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_unit_summary_+3A_coin">coin</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="get_unit_summary_+3A_usel">usel</code></td>
<td>
<p>A selected unit code</p>
</td></tr>
<tr><td><code id="get_unit_summary_+3A_levels">Levels</code></td>
<td>
<p>The aggregation levels to display results from.</p>
</td></tr>
<tr><td><code id="get_unit_summary_+3A_dset">dset</code></td>
<td>
<p>The data set within the coin to extract scores and ranks from</p>
</td></tr>
<tr><td><code id="get_unit_summary_+3A_nround">nround</code></td>
<td>
<p>Number of decimals to round scores to, default 2. Set to <code>NULL</code> to disable rounding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns the scores and ranks for each indicator/aggregate as specified in <code>aglevs</code>. It orders the table so that
the highest aggregation levels are first. This means that if the index level is included, it will be first.
</p>
<p>This function replaces the now-defunct <code>getUnitSummary()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A summary table as a data frame, containing scores and ranks for specified indicators/aggregates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example coin
coin &lt;- build_example_coin(quietly = TRUE)

# summary of scores for IND at levels 4, 3 and 2
get_unit_summary(coin, usel = "IND", Levels = c(4,3,2), dset = "Aggregated")

</code></pre>

<hr>
<h2 id='i_mean'>Impute by mean</h2><span id='topic+i_mean'></span>

<h3>Description</h3>

<p>Replaces <code>NA</code>s in a numeric vector with the mean of the non-<code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_mean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i_mean_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,2,3,4, NA)
i_mean(x)

</code></pre>

<hr>
<h2 id='i_mean_grp'>Impute by group mean</h2><span id='topic+i_mean_grp'></span>

<h3>Description</h3>

<p>Replaces <code>NA</code>s in a numeric vector with the grouped arithmetic means of the non-<code>NA</code> values.
Groups are defined by the <code>f</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_mean_grp(x, f, skip_f_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i_mean_grp_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="i_mean_grp_+3A_f">f</code></td>
<td>
<p>A grouping variable, of the same length of <code>x</code>, that specifies the group that each value
of <code>x</code> belongs to. This will be coerced to a factor.</p>
</td></tr>
<tr><td><code id="i_mean_grp_+3A_skip_f_na">skip_f_na</code></td>
<td>
<p>If <code>TRUE</code>, will work around any <code>NA</code>s in <code>f</code> (the corresponding values of <code>x</code> will be excluded from the imputation
and returned unaltered). Else if <code>FALSE</code>, will cause an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, runif(10), NA)
f &lt;- c(rep("a", 6), rep("b", 6))
i_mean_grp(x, f)

</code></pre>

<hr>
<h2 id='i_median'>Impute by median</h2><span id='topic+i_median'></span>

<h3>Description</h3>

<p>Replaces <code>NA</code>s in a numeric vector with the median of the non-<code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_median(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i_median_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,2,3,4, NA)
i_median(x)

</code></pre>

<hr>
<h2 id='i_median_grp'>Impute by group median</h2><span id='topic+i_median_grp'></span>

<h3>Description</h3>

<p>Replaces <code>NA</code>s in a numeric vector with the grouped medians of the non-<code>NA</code> values.
Groups are defined by the <code>f</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_median_grp(x, f, skip_f_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i_median_grp_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="i_median_grp_+3A_f">f</code></td>
<td>
<p>A grouping variable, of the same length of <code>x</code>, that specifies the group that each value
of <code>x</code> belongs to. This will be coerced to a factor.</p>
</td></tr>
<tr><td><code id="i_median_grp_+3A_skip_f_na">skip_f_na</code></td>
<td>
<p>If <code>TRUE</code>, will work around any <code>NA</code>s in <code>f</code> (the corresponding values of <code>x</code> will be excluded from the imputation
and returned unaltered). Else if <code>FALSE</code>, will cause an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, runif(10), NA)
f &lt;- c(rep("a", 6), rep("b", 6))
i_median_grp(x, f)

</code></pre>

<hr>
<h2 id='icodes_to_inames'>Convert iCodes to iNames</h2><span id='topic+icodes_to_inames'></span>

<h3>Description</h3>

<p>Convert iCodes to iNames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icodes_to_inames(coin, iCodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icodes_to_inames_+3A_coin">coin</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="icodes_to_inames_+3A_icodes">iCodes</code></td>
<td>
<p>A vector of iCodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of iNames
</p>

<hr>
<h2 id='import_coin_tool'>Import data directly from COIN Tool</h2><span id='topic+import_coin_tool'></span>

<h3>Description</h3>

<p>The <a href="https://knowledge4policy.ec.europa.eu/composite-indicators/coin-tool_en">COIN Tool</a> is an Excel-based tool
for building composite indicators. This function provides a direct interface for reading a COIN Tool input deck and
converting it to COINr. You need to provide a COIN Tool file, with the &quot;Database&quot; sheet properly compiled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_coin_tool(fname, makecodes = FALSE, oldtool = FALSE, out2 = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_coin_tool_+3A_fname">fname</code></td>
<td>
<p>The file name and path to read, e.g. <code>"C:/Documents/COINToolFile.xlsx"</code>.</p>
</td></tr>
<tr><td><code id="import_coin_tool_+3A_makecodes">makecodes</code></td>
<td>
<p>Logical: if <code>TRUE</code>, will generate short indicator codes based on indicator names,
otherwise if <code>FALSE</code>, will use COIN Tool indicator codes <code>"Ind.01"</code>, etc. Currently only does this
for indicators, not aggregation groups.</p>
</td></tr>
<tr><td><code id="import_coin_tool_+3A_oldtool">oldtool</code></td>
<td>
<p>Logical: if <code>TRUE</code>, compatible with old COIN Tool (pre-release, early 2019 or earlier).
There are some minor differences on where the elements are found.</p>
</td></tr>
<tr><td><code id="import_coin_tool_+3A_out2">out2</code></td>
<td>
<p>Either <code>"list"</code> (default) to output a list with <code>iData</code> and <code>iMeta</code> entries (for input into <code><a href="#topic+new_coin">new_coin()</a></code>),
else <code>"coin"</code> to output a coin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>COINToolIn()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Either a list or a coin, depending on <code>out2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example downloads a COIN Tool spreadsheet containing example data,
## saves it to a temporary directory, unzips, and reads into R. Finally it
## assembles it into a COIN.

# Make temp zip filename in temporary directory
tmpz &lt;- tempfile(fileext = ".zip")
# Download an example COIN Tool file to temporary directory
# NOTE: the download.file() command may need its "method" option set to a
# specific value depending on the platform you run this on. You can also
# choose to download/unzip this file manually.
download.file("https://knowledge4policy.ec.europa.eu/sites/default/
files/coin_tool_v1_lite_exampledata.zip", tmpz)
# Unzip
CTpath &lt;- unzip(tmpz, exdir = tempdir())
# Read COIN Tool into R
l &lt;- import_coin_tool(CTpath, makecodes = TRUE) 
## End(Not run)

</code></pre>

<hr>
<h2 id='Impute'>Imputation of missing data</h2><span id='topic+Impute'></span>

<h3>Description</h3>

<p>This is a generic function with the following methods:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Impute(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Impute_+3A_x">x</code></td>
<td>
<p>Object to be imputed</p>
</td></tr>
<tr><td><code id="Impute_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+Impute.numeric">Impute.numeric()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Impute.data.frame">Impute.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Impute.coin">Impute.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Impute.purse">Impute.purse()</a></code>
</p>
</li></ul>

<p>See those methods for individual documentation.
</p>
<p>This function replaces the now-defunct <code>impute()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, but imputed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See individual method documentation

</code></pre>

<hr>
<h2 id='impute_panel'>Impute panel data</h2><span id='topic+impute_panel'></span>

<h3>Description</h3>

<p>Given a data frame of panel data, with a time-index column <code>time_col</code> and a unit ID column <code>unit_col</code>, imputes other
columns using the entry from the latest available time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_panel(
  iData,
  time_col = NULL,
  unit_col = NULL,
  cols = NULL,
  imp_type = NULL,
  max_time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_panel_+3A_idata">iData</code></td>
<td>
<p>A data frame of indicator data, containing a time index column <code>time_col</code>, a unit code column <code>unit_col</code>,
and other numerical columns to be imputed.</p>
</td></tr>
<tr><td><code id="impute_panel_+3A_time_col">time_col</code></td>
<td>
<p>The name of a column found in <code>iData</code> to be used as the time index column. Must point to a numeric column.</p>
</td></tr>
<tr><td><code id="impute_panel_+3A_unit_col">unit_col</code></td>
<td>
<p>The name of a column found in <code>iData</code> to be used as the unit code/ID column. Must point to a character column.</p>
</td></tr>
<tr><td><code id="impute_panel_+3A_cols">cols</code></td>
<td>
<p>Optionally, a character vector of names of columns to impute. If <code>NULL</code> (default), all columns apart from <code>time_col</code> and
<code>unit_col</code> will be imputed where possible.</p>
</td></tr>
<tr><td><code id="impute_panel_+3A_imp_type">imp_type</code></td>
<td>
<p>One of <code>"latest"</code> <code>"constant"</code> or <code>"linear"</code>. In the first case, missing points are imputed with the last non-<code>NA</code> observation for each
time series, up to <code>max_time</code>. For <code>"constant"</code> or <code>"linear"</code>, missing points are imputed using <code><a href="stats.html#topic+approxfun">stats::approx()</a></code>, passing  <code>"constant"</code> or <code>"linear"</code> to the
<code>method</code> argument, and points outside of the range of observed values are replaced with the nearest non-<code>NA</code> point.
This is equivalent to <code>rule = 2</code> in <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> for each time series. The difference between <code>"latest"</code> and <code>"constant"</code> is that
the latter allows control over the maximum number of time points to impute backwards (using <code>max_time</code>) whereas the former
doesn't. Additionally, <code>"constant"</code> will impute outside of the observed range of values at the beginning of the time series, whereas <code>"latest"</code> won't.</p>
</td></tr>
<tr><td><code id="impute_panel_+3A_max_time">max_time</code></td>
<td>
<p>The maximum number of time points to look backwards to impute from. E.g. if <code>max_time = 1</code>, if an
<code>NA</code> is found at time <code class="reqn">t</code>, it will only look for a replacement value at <code class="reqn">t-1</code> but not in any time points before that.
By default, searches all time points available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This presumes that there are multiple observations for each unit code, i.e. one per time point. It then searches for any missing values in the target year, and replaces them with the equivalent points
from previous time points. It will replace using the most recently available point or using linear interpolation: see <code>imp_type</code> argument.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>.$iData_imp</code>: An <code>iData</code> format data frame with missing data imputed using previous time points (where possible).
</p>
</li>
<li> <p><code>.$DataT</code>: A data frame in the same format as <code>iData</code>, where each entry shows which time point each data point
came from.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Copy example panel data
iData_p &lt;- ASEM_iData_p

# we introduce two NAs: one for NZ in 2022 in LPI indicator
iData_p$LPI[iData_p$uCode == "NZ" &amp; iData_p$Time == 2022] &lt;-  NA
# one for AT, also in 2022, but for Flights indicator
iData_p$Flights[iData_p$uCode == "AT" &amp; iData_p$Time == 2022] &lt;- NA

# impute: target only the two columns where NAs introduced
l_imp &lt;- impute_panel(iData_p, cols = c("LPI", "Flights"))
# get imputed df
iData_imp &lt;- l_imp$iData_imp

# check the output is what we expect: both NAs introduced should now have 2021 values
iData_imp$LPI[iData_imp$uCode == "NZ" &amp; iData_imp$Time == 2022] ==
  ASEM_iData_p$LPI[ASEM_iData_p$uCode == "NZ" &amp; ASEM_iData_p$Time == 2021]

iData_imp$Flights[iData_imp$uCode == "AT" &amp; iData_imp$Time == 2022] ==
  ASEM_iData_p$Flights[ASEM_iData_p$uCode == "AT" &amp; ASEM_iData_p$Time == 2021]

</code></pre>

<hr>
<h2 id='Impute.coin'>Impute a data set in a coin</h2><span id='topic+Impute.coin'></span>

<h3>Description</h3>

<p>This imputes any <code>NA</code>s in the data set specified by <code>dset</code>
by invoking the function <code>f_i</code> and any optional arguments <code>f_i_para</code> on each column at a time (if
<code>impute_by = "column"</code>), or on each row at a time (if <code>impute_by = "row"</code>), or by passing the entire
data frame to <code>f_i</code> if <code>impute_by = "df"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Impute(
  x,
  dset,
  f_i = NULL,
  f_i_para = NULL,
  impute_by = "column",
  use_group = NULL,
  group_level = NULL,
  normalise_first = NULL,
  out2 = "coin",
  write_to = NULL,
  disable = FALSE,
  warn_on_NAs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Impute.coin_+3A_x">x</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_f_i">f_i</code></td>
<td>
<p>An imputation function. See details.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_f_i_para">f_i_para</code></td>
<td>
<p>Further arguments to pass to <code>f_i</code>, other than <code>x</code>. See details.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_impute_by">impute_by</code></td>
<td>
<p>Specifies how to impute: if <code>"column"</code>, passes each column (indicator) separately as a numerical
vector to <code>f_i</code>; if <code>"row"</code>, passes each <em>row</em> separately; and if <code>"df"</code> passes the entire data set (data frame) to
<code>f_i</code>. The function called by <code>f_i</code> should be compatible with the type of data passed to it.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_use_group">use_group</code></td>
<td>
<p>Optional grouping variable name to pass to imputation function if this supports group
imputation.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_group_level">group_level</code></td>
<td>
<p>A level of the framework to use for grouping indicators. This is only
relevant if <code>impute_by = "row"</code> or <code>"df"</code>. In that case, indicators will be split into their groups at the
level specified by <code>group_level</code>, and imputation will be performed across rows of the group, rather
than the whole data set. This can make more sense because indicators within a group are likely to be
more similar.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_normalise_first">normalise_first</code></td>
<td>
<p>Logical: if <code>TRUE</code>, each column is normalised using a min-max operation before
imputation. By default this is <code>FALSE</code> unless <code>impute_by = "row"</code>. See details.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_out2">out2</code></td>
<td>
<p>Either <code>"coin"</code> to return normalised data set back to the coin, or <code>df</code> to simply return a data
frame.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_write_to">write_to</code></td>
<td>
<p>Optional character string for naming the data set in the coin. Data will be written to
<code>.$Data[[write_to]]</code>. Default is <code>write_to == "Imputed"</code>.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_disable">disable</code></td>
<td>
<p>Logical: if <code>TRUE</code> will disable imputation completely and write the unaltered data set. This option is mainly useful
in sensitivity and uncertainty analysis (to test the effect of turning imputation on/off).</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_warn_on_nas">warn_on_NAs</code></td>
<td>
<p>Logical: if <code>TRUE</code> will issue a warning if there are any <code>NA</code>s detected in the data frame
after imputation has been applied. Set <code>FALSE</code> to suppress these warnings.</p>
</td></tr>
<tr><td><code id="Impute.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clearly, the function <code>f_i</code> needs to be able to accept with the data class passed to it - if
<code>impute_by</code> is <code>"row"</code> or <code>"column"</code> this will be a numeric vector, or if <code>"df"</code> it will be a data
frame. Moreover, this function should return a vector or data frame identical to the vector/data frame passed to
it except for <code>NA</code> values, which can be replaced. The function <code>f_i</code> is not required to replace <em>all</em> <code>NA</code>
values.
</p>
<p>COINr has several built-in imputation functions of the form <code style="white-space: pre;">&#8288;i_*()&#8288;</code> for vectors which can be called by <code><a href="#topic+Impute">Impute()</a></code>. See the
<a href="https://bluefoxr.github.io/COINr/articles/imputation.html#data-frames">online documentation</a> for more details.
</p>
<p>When imputing row-wise, prior normalisation of the data is recommended. This is because imputation
will use e.g. the mean of the unit values over all indicators (columns). If the indicators are on
very different scales, the result will likely make no sense. If the indicators are normalised first,
more sensible results can be obtained. There are two options to pre-normalise: first is by setting
<code>normalise_first = TRUE</code> - this is anyway the default if <code>impute_by = "row"</code>. In this case, you also
need to supply a vector of directions. The data will then be normalised using a min-max approach
before imputation, followed by the inverse operation to return the data to the original scales.
</p>
<p>Another approach which gives more control is to simply run <code><a href="#topic+Normalise">Normalise()</a></code> first, and work with the
normalised data from that point onwards. In that case it is better to set <code>normalise_first = FALSE</code>,
since by default if <code>impute_by = "row"</code> it will be set to <code>TRUE</code>.
</p>
<p>Checks are made on the format of the data returned by imputation functions, to ensure the
type and that non-<code>NA</code> values have not been inadvertently altered. This latter check is allowed
a degree of tolerance for numerical precision, controlled by the <code>sfigs</code> argument. This is because
if the data frame is normalised, and/or depending on the imputation function, there may be a very
small differences. By default <code>sfigs = 9</code>, meaning that the non-<code>NA</code> values pre and post-imputation
are compared to 9 significant figures.
</p>
<p>See also documentation for <code><a href="#topic+Impute.data.frame">Impute.data.frame()</a></code> and <code><a href="#topic+Impute.numeric">Impute.numeric()</a></code> which are called by this function.
</p>


<h3>Value</h3>

<p>An updated coin with imputed data set at <code>.$Data[[write_to]]</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # build coin
coin &lt;- build_example_coin(up_to = "new_coin")

# impute raw data set using population groups
# output to data frame directly
Impute(coin, dset = "Raw", f_i = "i_mean_grp",
               use_group = "Pop_group", out2 = "df")

</code></pre>

<hr>
<h2 id='Impute.data.frame'>Impute a data frame</h2><span id='topic+Impute.data.frame'></span>

<h3>Description</h3>

<p>Impute a data frame using any function, either column-wise, row-wise or by the whole data frame in one
shot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
Impute(
  x,
  f_i = NULL,
  f_i_para = NULL,
  impute_by = "column",
  normalise_first = NULL,
  directions = NULL,
  warn_on_NAs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Impute.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame with only numeric columns.</p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_f_i">f_i</code></td>
<td>
<p>A function to use for imputation. By default, imputation is performed by simply substituting
the mean of non-<code>NA</code> values for each column at a time.</p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_f_i_para">f_i_para</code></td>
<td>
<p>Any additional parameters to pass to <code>f_i</code>, apart from <code>x</code></p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_impute_by">impute_by</code></td>
<td>
<p>Specifies how to impute: if <code>"column"</code>, passes each column separately as a numerical
vector to <code>f_i</code>; if <code>"row"</code>, passes each <em>row</em> separately; and if <code>"df"</code> passes the entire data frame to
<code>f_i</code>. The function called by <code>f_i</code> should be compatible with the type of data passed to it.</p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_normalise_first">normalise_first</code></td>
<td>
<p>Logical: if <code>TRUE</code>, each column is normalised using a min-max operation before
imputation. By default this is <code>FALSE</code> unless <code>impute_by = "row"</code>. See details.</p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_directions">directions</code></td>
<td>
<p>A vector of directions: either -1 or 1 to indicate the direction of each column
of <code>x</code> - this is only used if <code>normalise_first = TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_warn_on_nas">warn_on_NAs</code></td>
<td>
<p>Logical: if <code>TRUE</code> will issue a warning if there are any <code>NA</code>s detected in the data frame
after imputation has been applied. Set <code>FALSE</code> to suppress these warnings.</p>
</td></tr>
<tr><td><code id="Impute.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only accepts data frames with all numeric columns. It imputes any <code>NA</code>s in the data frame
by invoking the function <code>f_i</code> and any optional arguments <code>f_i_para</code> on each column at a time (if
<code>impute_by = "column"</code>), or on each row at a time (if <code>impute_by = "row"</code>), or by passing the entire
data frame to <code>f_i</code> if <code>impute_by = "df"</code>.
</p>
<p>Clearly, the function <code>f_i</code> needs to be able to accept with the data class passed to it - if
<code>impute_by</code> is <code>"row"</code> or <code>"column"</code> this will be a numeric vector, or if <code>"df"</code> it will be a data
frame. Moreover, this function should return a vector or data frame identical to the vector/data frame passed to
it except for <code>NA</code> values, which can be replaced. The function <code>f_i</code> is not required to replace <em>all</em> <code>NA</code>
values.
</p>
<p>COINr has several built-in imputation functions of the form <code style="white-space: pre;">&#8288;i_*()&#8288;</code> for vectors which can be called by <code><a href="#topic+Impute">Impute()</a></code>. See the
<a href="https://bluefoxr.github.io/COINr/articles/imputation.html#data-frames">online documentation</a> for more details.
</p>
<p>When imputing row-wise, prior normalisation of the data is recommended. This is because imputation
will use e.g. the mean of the unit values over all indicators (columns). If the indicators are on
very different scales, the result will likely make no sense. If the indicators are normalised first,
more sensible results can be obtained. There are two options to pre-normalise: first is by setting
<code>normalise_first = TRUE</code> - this is anyway the default if <code>impute_by = "row"</code>. In this case, you also
need to supply a vector of directions. The data will then be normalised using a min-max approach
before imputation, followed by the inverse operation to return the data to the original scales.
</p>
<p>Another approach which gives more control is to simply run <code><a href="#topic+Normalise">Normalise()</a></code> first, and work with the
normalised data from that point onwards. In that case it is better to set <code>normalise_first = FALSE</code>,
since by default if <code>impute_by = "row"</code> it will be set to <code>TRUE</code>.
</p>
<p>Checks are made on the format of the data returned by imputation functions, to ensure the
type and that non-<code>NA</code> values have not been inadvertently altered. This latter check is allowed
a degree of tolerance for numerical precision, controlled by the <code>sfigs</code> argument. This is because
if the data frame is normalised, and/or depending on the imputation function, there may be a very
small differences. By default <code>sfigs = 9</code>, meaning that the non-<code>NA</code> values pre and post-imputation
are compared to 9 significant figures.
</p>


<h3>Value</h3>

<p>An imputed data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a df of random numbers
X &lt;- as.data.frame(matrix(runif(50), 10, 5))

# introduce NAs (2 in 3 of 5 cols)
X[sample(1:10, 2), 1] &lt;- NA
X[sample(1:10, 2), 3] &lt;- NA
X[sample(1:10, 2), 5] &lt;- NA

# impute using column mean
Impute(X, f_i = "i_mean")

# impute using row median (no normalisation)
Impute(X, f_i = "i_median", impute_by = "row",
       normalise_first = FALSE)


</code></pre>

<hr>
<h2 id='Impute.numeric'>Impute a numeric vector</h2><span id='topic+Impute.numeric'></span>

<h3>Description</h3>

<p>Imputes missing values in a numeric vector using a function <code>f_i</code>. This function should return a vector identical
to <code>x</code> except for <code>NA</code> values, which can be replaced. The function <code>f_i</code> is not required to replace <em>all</em> <code>NA</code>
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
Impute(x, f_i = NULL, f_i_para = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Impute.numeric_+3A_x">x</code></td>
<td>
<p>A numeric vector, possibly with <code>NA</code> values to be imputed.</p>
</td></tr>
<tr><td><code id="Impute.numeric_+3A_f_i">f_i</code></td>
<td>
<p>A function that imputes missing values in a numeric vector. See description and details.</p>
</td></tr>
<tr><td><code id="Impute.numeric_+3A_f_i_para">f_i_para</code></td>
<td>
<p>Optional further arguments to be passed to <code>f_i()</code></p>
</td></tr>
<tr><td><code id="Impute.numeric_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calls the function <code>f_i()</code>, with optionally further arguments <code>f_i_para</code>, to impute any missing
values found in <code>x</code>. By default, <code>f_i = "i_mean()"</code>, which simply imputes <code>NA</code>s with the mean of the
non-<code>NA</code> values in <code>x</code>.
</p>
<p>COINr has several built-in imputation functions of the form <code style="white-space: pre;">&#8288;i_*()&#8288;</code> for vectors which can be called by <code><a href="#topic+Impute">Impute()</a></code>. See the
<a href="https://bluefoxr.github.io/COINr/articles/imputation.html#data-frames">online documentation</a> for more details.
</p>
<p>You could also use one of the imputation functions directly (such as <code><a href="#topic+i_mean">i_mean()</a></code>). However, this
function offers a few extra advantages, such as checking the input and output formats, and making
sure the resulting imputed vector agrees with the input. It will also skip imputation entirely if
there are no <code>NA</code>s at all.
</p>


<h3>Value</h3>

<p>An imputed numeric vector of the same length of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector with a missing value
x &lt;- 1:10
x[3] &lt;- NA
x

# impute using median
# this calls COINr's i_median() function
Impute(x, f_i = "i_median")

</code></pre>

<hr>
<h2 id='Impute.purse'>Impute data sets in a purse</h2><span id='topic+Impute.purse'></span>

<h3>Description</h3>

<p>This function imputes the target data set <code>dset</code> in each coin using the imputation function <code>f_i</code>. This is performed
in the same way as the coin method <code><a href="#topic+Impute.coin">Impute.coin()</a></code>, but with one &quot;special case&quot; for panel data. If <code style="white-space: pre;">&#8288;f_i = "impute_panel&#8288;</code>,
the data sets inside the purse are imputed using the <code><a href="#topic+impute_panel">impute_panel()</a></code>
function. In this case, coins are not imputed individually, but treated as a single data set. In this
case, optionally set the imputation method as <code>f_i_para = list(imp_type = .)</code>
and <code>f_i_para = list(max_time = .)</code> where <code>.</code> should be substituted with the maximum
number of time points to search backwards for a non-<code>NA</code> value. See <code><a href="#topic+impute_panel">impute_panel()</a></code> for more details.
No further arguments need to be passed to <code><a href="#topic+impute_panel">impute_panel()</a></code>. See <code>vignette("imputation")</code> for more
details. See also <code><a href="#topic+Impute.coin">Impute.coin()</a></code> documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Impute(
  x,
  dset,
  f_i = NULL,
  f_i_para = NULL,
  impute_by = "column",
  group_level = NULL,
  use_group = NULL,
  normalise_first = NULL,
  write_to = NULL,
  warn_on_NAs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Impute.purse_+3A_x">x</code></td>
<td>
<p>A purse object</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_f_i">f_i</code></td>
<td>
<p>An imputation function. For the &quot;purse&quot; class, if <code style="white-space: pre;">&#8288;f_i = "impute_panel&#8288;</code> this is a special
case: see details.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_f_i_para">f_i_para</code></td>
<td>
<p>Further arguments to pass to <code>f_i</code>, other than <code>x</code>. See details.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_impute_by">impute_by</code></td>
<td>
<p>Specifies how to impute: if <code>"column"</code>, passes each column (indicator) separately as a numerical
vector to <code>f_i</code>; if <code>"row"</code>, passes each <em>row</em> separately; and if <code>"df"</code> passes the entire data set (data frame) to
<code>f_i</code>. The function called by <code>f_i</code> should be compatible with the type of data passed to it.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_group_level">group_level</code></td>
<td>
<p>A level of the framework to use for grouping indicators. This is only
relevant if <code>impute_by = "row"</code> or <code>"df"</code>. In that case, indicators will be split into their groups at the
level specified by <code>group_level</code>, and imputation will be performed across rows of the group, rather
than the whole data set. This can make more sense because indicators within a group are likely to be
more similar.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_use_group">use_group</code></td>
<td>
<p>Optional grouping variable name to pass to imputation function if this supports group
imputation.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_normalise_first">normalise_first</code></td>
<td>
<p>Logical: if <code>TRUE</code>, each column is normalised using a min-max operation before
imputation. By default this is <code>FALSE</code> unless <code>impute_by = "row"</code>. See details.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_write_to">write_to</code></td>
<td>
<p>Optional character string for naming the resulting data set in each coin. Data will be written to
<code>.$Data[[write_to]]</code>. Default is <code>write_to == "Imputed"</code>.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_warn_on_nas">warn_on_NAs</code></td>
<td>
<p>Logical: if <code>TRUE</code> will issue a warning if there are any <code>NA</code>s detected in the data frame
after imputation has been applied. Set <code>FALSE</code> to suppress these warnings.</p>
</td></tr>
<tr><td><code id="Impute.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated purse with imputed data sets added to each coin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see vignette("imputation")
</code></pre>

<hr>
<h2 id='is.coin'>Check if object is coin class</h2><span id='topic+is.coin'></span>

<h3>Description</h3>

<p>Check if object is coin class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.coin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.coin_+3A_x">x</code></td>
<td>
<p>An object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>

<hr>
<h2 id='is.purse'>Check if object is purse class</h2><span id='topic+is.purse'></span>

<h3>Description</h3>

<p>Check if object is purse class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.purse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.purse_+3A_x">x</code></td>
<td>
<p>An object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>

<hr>
<h2 id='kurt'>Calculate kurtosis</h2><span id='topic+kurt'></span>

<h3>Description</h3>

<p>Calculates kurtosis of the values of a numeric vector. This uses the same definition of kurtosis as
as the &quot;kurtosis()&quot; function in the e1071 package, where <code>type == 2</code>, which is equivalent to the definition of kurtosis used in Excel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurt(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurt_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="kurt_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kurtosis value (scalar).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
kurt(x)

</code></pre>

<hr>
<h2 id='log_CT'>Log-transform a vector</h2><span id='topic+log_CT'></span>

<h3>Description</h3>

<p>Performs a log transform on a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_CT(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_CT_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="log_CT_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically, this performs a modified &quot;COIN Tool log&quot; transform: <code>log(x-min(x) + a)</code>, where
<code>a &lt;- 0.01*(max(x)-min(x))</code>.
</p>


<h3>Value</h3>

<p>A log-transformed vector of data, and treatment details wrapped in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
log_CT(x)

</code></pre>

<hr>
<h2 id='log_CT_orig'>Log-transform a vector</h2><span id='topic+log_CT_orig'></span>

<h3>Description</h3>

<p>Performs a log transform on a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_CT_orig(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_CT_orig_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="log_CT_orig_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically, this performs a &quot;COIN Tool log&quot; transform: <code>log(x-min(x) + 1)</code>.
</p>


<h3>Value</h3>

<p>A log-transformed vector of data, and treatment details wrapped in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
log_CT_orig(x)

</code></pre>

<hr>
<h2 id='log_CT_plus'>Log transform a vector (skew corrected)</h2><span id='topic+log_CT_plus'></span>

<h3>Description</h3>

<p>Performs a log transform on a numeric vector, but with consideration for the direction of the skew. The aim
here is to reduce the absolute value of skew, regardless of its direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_CT_plus(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_CT_plus_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="log_CT_plus_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically:
</p>
<p>If the skew of <code>x</code> is positive, this performs a modified &quot;COIN Tool log&quot; transform: <code>log(x-min(x) + a)</code>, where
<code>a &lt;- 0.01*(max(x)-min(x))</code>.
</p>
<p>If the skew of <code>x</code> is negative, it performs an equivalent transformation <code>-log(xmax + a - x)</code>.
</p>


<h3>Value</h3>

<p>A log-transformed vector of data, and treatment details wrapped in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
log_CT(x)

</code></pre>

<hr>
<h2 id='log_GII'>Log-transform a vector</h2><span id='topic+log_GII'></span>

<h3>Description</h3>

<p>Performs a log transform on a numeric vector. This function is currently not recommended - see comments
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_GII(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_GII_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="log_GII_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically, this performs a &quot;GII log&quot; transform, which is what was encoded in the GII2020 spreadsheet.
</p>
<p>Note that this transformation is currently NOT recommended because it seems quite volatile and can flip
the direction of the indicator. If the maximum value of the indicator is less than one, this reverses the
direction.
</p>


<h3>Value</h3>

<p>A log-transformed vector of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
log_GII(x)

</code></pre>

<hr>
<h2 id='n_borda'>Normalise using Borda scores</h2><span id='topic+n_borda'></span>

<h3>Description</h3>

<p>Calculates Borda scores as <code>rank(x) - 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_borda(x, ties.method = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_borda_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_borda_+3A_ties.method">ties.method</code></td>
<td>
<p>This argument is passed to <code><a href="base.html#topic+rank">base::rank()</a></code> - see there for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_borda(x)

</code></pre>

<hr>
<h2 id='n_dist2max'>Normalise as distance to maximum value</h2><span id='topic+n_dist2max'></span>

<h3>Description</h3>

<p>A measure of the distance to the maximum value, where the maximum value is the highest-scoring value. The
formula used is:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_dist2max(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_dist2max_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> 1 - (x_{max} - x)/(x_{max} - x_{min}) </code>
</p>

<p>This means that the closer a value is to the maximum, the higher its score will be. Scores will be in the
range of 0 to 1.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_dist2max(x)

</code></pre>

<hr>
<h2 id='n_dist2ref'>Normalise as distance to reference value</h2><span id='topic+n_dist2ref'></span>

<h3>Description</h3>

<p>A measure of the distance to a specific value found in <code>x</code>, specified by <code>iref</code>. The formula is:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_dist2ref(x, iref, cap_max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_dist2ref_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_dist2ref_+3A_iref">iref</code></td>
<td>
<p>An integer which indexes <code>x</code> to specify the reference value. The reference value will be
<code>x[iref]</code>.</p>
</td></tr>
<tr><td><code id="n_dist2ref_+3A_cap_max">cap_max</code></td>
<td>
<p>If <code>TRUE</code>, any value of <code>x</code> that exceeds <code>x[iref]</code> will be assigned a score of 1, otherwise
will have a score greater than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> 1 - (x_{ref} - x)/(x_{ref} - x_{min}) </code>
</p>

<p>Values exceeding <code>x_ref</code> can be optionally capped at 1 if <code>cap_max = TRUE</code>.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_dist2ref(x, 5)

</code></pre>

<hr>
<h2 id='n_dist2targ'>Normalise as distance to target</h2><span id='topic+n_dist2targ'></span>

<h3>Description</h3>

<p>A measure of the distance of each value of <code>x</code> to a specified target which can be a high or low target depending on <code>direction</code>. See details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_dist2targ(x, targ, direction = 1, cap_max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_dist2targ_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_dist2targ_+3A_targ">targ</code></td>
<td>
<p>An target value</p>
</td></tr>
<tr><td><code id="n_dist2targ_+3A_direction">direction</code></td>
<td>
<p>Either 1 (default) or -1. In the former case, the indicator is assumed to be &quot;positive&quot; so that the target is at the higher
end of the range. In the latter, the indicator is &quot;negative&quot; so that the target is typically at the low end of the range.</p>
</td></tr>
<tr><td><code id="n_dist2targ_+3A_cap_max">cap_max</code></td>
<td>
<p>If <code>TRUE</code>, any value of <code>x</code> that exceeds <code>targ</code> will be assigned a score of 1, otherwise
will have a score greater than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>direction = 1</code>, the formula is:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{x - x_{min}}{x_{targ} - x_{min}} </code>
</p>

<p>else if <code>direction = -1</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{x_{max} - x}{x_{max} - x_{targ}} </code>
</p>

<p>Values surpassing <code>x_targ</code> in either case can be optionally capped at 1 if <code>cap_max = TRUE</code>.
</p>
<p>This function also supports parameter specification in <code>iMeta</code> for the <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code> method.
To do this, add columns <code>Target</code>, and <code>dist2targ_cap_max</code> to the <code>iMeta</code> table, which correspond
to the <code>targ</code> and <code>cap_max</code> parameters respectively. Then set <code>f_n_para = "use_iMeta"</code> within the
<code>global_specs</code> list. See also examples in the <a href="https://bluefoxr.github.io/COINr/articles/normalise.html">normalisation vignette</a>.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_dist2targ(x, 0.8, cap_max = TRUE)

</code></pre>

<hr>
<h2 id='n_fracmax'>Normalise as fraction of max value</h2><span id='topic+n_fracmax'></span>

<h3>Description</h3>

<p>The ratio of each value of <code>x</code> to <code>max(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_fracmax(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_fracmax_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> x / x_{max} </code>
</p>



<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_fracmax(x)

</code></pre>

<hr>
<h2 id='n_goalposts'>Normalise using goalpost method</h2><span id='topic+n_goalposts'></span>

<h3>Description</h3>

<p>The fraction of the distance of each value of <code>x</code> from the lower &quot;goalpost&quot; to the upper one. Goalposts are specified by
<code>gposts = c(l, u, a)</code>, where <code>l</code> is the lower bound, <code>u</code> is the upper bound, and <code>a</code> is a scaling parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_goalposts(x, gposts, direction = 1, trunc2posts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_goalposts_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_goalposts_+3A_gposts">gposts</code></td>
<td>
<p>A numeric vector <code>c(l, u, a)</code>, where <code>l</code> is the lower bound, <code>u</code> is the upper bound,
and <code>a</code> is a scaling parameter.</p>
</td></tr>
<tr><td><code id="n_goalposts_+3A_direction">direction</code></td>
<td>
<p>Either 1 or -1. Set to -1 to flip goalposts.</p>
</td></tr>
<tr><td><code id="n_goalposts_+3A_trunc2posts">trunc2posts</code></td>
<td>
<p>If <code>TRUE</code> (default) will truncate any values that fall outside of the goalposts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specify <code>direction = -1</code> to &quot;flip&quot; the goalposts. In this case, the fraction from the upper to the lower goalpost is
measured.
</p>
<p>The goalposts equations are:
</p>
<p style="text-align: center;"><code class="reqn"> (x - GP_{low})/(GP_{high} - GP_{low}) </code>
</p>

<p>and for a negative directionality indicator:
</p>
<p style="text-align: center;"><code class="reqn"> (x - GP_{high})/(GP_{low} - GP_{high}) </code>
</p>

<p>This function also supports parameter specification in <code>iMeta</code> for the <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code> method.
To do this, add columns:
</p>

<ul>
<li> <p><code>goalpost_lower</code>: the lower goalpost
</p>
</li>
<li> <p><code>goalpost_upper</code>: the upper goalpost
</p>
</li>
<li> <p><code>goalpost_scale</code>: the scaling parameter
</p>
</li>
<li> <p><code>goalpost_trunc2posts</code>: corresponds to the <code>trunc2posts</code> argument
</p>
</li></ul>

<p>to the <code>iMeta</code> table. Then set <code>f_n_para = "use_iMeta"</code> within the
<code>global_specs</code> list. See also examples in the <a href="https://bluefoxr.github.io/COINr/articles/normalise.html">normalisation vignette</a>.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># positive direction
n_goalposts(1, gposts = c(0, 10, 1))
# negative direction
n_goalposts(1, gposts = c(0, 10, 1), direction = -1)

</code></pre>

<hr>
<h2 id='n_minmax'>Minmax a vector</h2><span id='topic+n_minmax'></span>

<h3>Description</h3>

<p>Scales a vector using min-max method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_minmax(x, l_u = c(0, 100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_minmax_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_minmax_+3A_l_u">l_u</code></td>
<td>
<p>A vector <code>c(l, u)</code>, where <code>l</code> is the lower bound and <code>u</code> is the upper bound. <code>x</code> will
be scaled exactly onto this interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also supports parameter specification in <code>iMeta</code> for the <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code> method.
To do this, add columns <code>minmax_lower</code>, and <code>minmax_upper</code> to the <code>iMeta</code> table, which specify the
lower and upper bounds to scale each indicator to. Then set <code>f_n_para = "use_iMeta"</code> within the
<code>global_specs</code> list. See also examples in the <a href="https://bluefoxr.github.io/COINr/articles/normalise.html">normalisation vignette</a>.
</p>


<h3>Value</h3>

<p>Normalised vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_minmax(x)

</code></pre>

<hr>
<h2 id='n_prank'>Normalise using percentile ranks</h2><span id='topic+n_prank'></span>

<h3>Description</h3>

<p>Calculates percentile ranks of a numeric vector using &quot;sport&quot; ranking. Ranks are calculated by <code><a href="base.html#topic+rank">base::rank()</a></code>
and converted to percentile ranks. The <code>ties.method</code> can be changed - this is directly passed to
<code><a href="base.html#topic+rank">base::rank()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_prank(x, ties.method = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_prank_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_prank_+3A_ties.method">ties.method</code></td>
<td>
<p>This argument is passed to <code><a href="base.html#topic+rank">base::rank()</a></code> - see there for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_prank(x)

</code></pre>

<hr>
<h2 id='n_rank'>Normalise using ranks</h2><span id='topic+n_rank'></span>

<h3>Description</h3>

<p>This is simply a wrapper for <code><a href="base.html#topic+rank">base::rank()</a></code>. Higher scores will give higher ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_rank(x, ties.method = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_rank_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_rank_+3A_ties.method">ties.method</code></td>
<td>
<p>This argument is passed to <code><a href="base.html#topic+rank">base::rank()</a></code> - see there for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_rank(x)

</code></pre>

<hr>
<h2 id='n_scaled'>Scale a vector</h2><span id='topic+n_scaled'></span>

<h3>Description</h3>

<p>Scales a vector for normalisation using the method applied in the GII2020 for some indicators. This
does <code>x_scaled &lt;- (x-l)/(u-l) * scale_factor</code>. Note this is <em>not</em> the minmax transformation (see <code><a href="#topic+n_minmax">n_minmax()</a></code>).
This is a linear transformation with shift <code>u</code> and scaling factor <code>u-l</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_scaled(x, npara = c(0, 100), scale_factor = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_scaled_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_scaled_+3A_npara">npara</code></td>
<td>
<p>Parameters as a vector <code>c(l, u)</code>. See description.</p>
</td></tr>
<tr><td><code id="n_scaled_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Optional scaling factor to apply to the result. Default 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also supports parameter specification in <code>iMeta</code> for the <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code> method.
To do this, add columns <code>scaled_lower</code>, <code>scaled_upper</code> and <code>scale_factor</code> to the <code>iMeta</code> table, which specify the
first and second elements of <code>npara</code>, respectively. Then set <code>f_n_para = "use_iMeta"</code> within the
<code>global_specs</code> list. See also examples in the <a href="https://bluefoxr.github.io/COINr/articles/normalise.html">normalisation vignette</a>.
</p>


<h3>Value</h3>

<p>Scaled vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_scaled(x, npara = c(1,10))

</code></pre>

<hr>
<h2 id='n_zscore'>Z-score a vector</h2><span id='topic+n_zscore'></span>

<h3>Description</h3>

<p>Standardises a vector <code>x</code> by scaling it to have a mean and standard deviation specified by <code>m_sd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_zscore(x, m_sd = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_zscore_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="n_zscore_+3A_m_sd">m_sd</code></td>
<td>
<p>A vector <code>c(m, sd)</code>, where <code>m</code> is desired mean and <code>sd</code> is the target standard deviation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also supports parameter specification in <code>iMeta</code> for the <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code> method.
To do this, add columns <code>zscore_mean</code>, and <code>zscore_sd</code> to the <code>iMeta</code> table, which specify the
mean and standard deviation to scale each indicator to, respectively. Then set <code>f_n_para = "use_iMeta"</code> within the
<code>global_specs</code> list. See also examples in the <a href="https://bluefoxr.github.io/COINr/articles/normalise.html">normalisation vignette</a>.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
n_zscore(x)

</code></pre>

<hr>
<h2 id='names_to_codes'>Generate short codes from long names</h2><span id='topic+names_to_codes'></span>

<h3>Description</h3>

<p>Given a character vector of long names (probably with spaces), generates short codes.
Intended for use when importing from the COIN Tool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names_to_codes(cvec, maxword = 2, maxlet = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_to_codes_+3A_cvec">cvec</code></td>
<td>
<p>A character vector of names</p>
</td></tr>
<tr><td><code id="names_to_codes_+3A_maxword">maxword</code></td>
<td>
<p>The maximum number of words to use in building a short name (default 2)</p>
</td></tr>
<tr><td><code id="names_to_codes_+3A_maxlet">maxlet</code></td>
<td>
<p>The number of letters to take from each word (default 4)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>names2Codes()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A corresponding character vector, but with short codes, and no duplicates.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+import_coin_tool">import_coin_tool()</a></code> Import data from the COIN Tool (Excel).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get names from example data
iNames &lt;- ASEM_iMeta$iName

# convert to codes
names_to_codes(iNames)

</code></pre>

<hr>
<h2 id='new_coin'>Create a new coin</h2><span id='topic+new_coin'></span>

<h3>Description</h3>

<p>Creates a new &quot;coin&quot; class object, or a &quot;purse&quot; class object (time-indexed collection of coins).
A purse class object is created if panel data is supplied. Coins and purses are the main object classes
used in COINr, although a number of functions also support other classes such as data frames and vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_coin(
  iData,
  iMeta,
  exclude = NULL,
  split_to = NULL,
  level_names = NULL,
  retain_all_uCodes_on_split = FALSE,
  quietly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_coin_+3A_idata">iData</code></td>
<td>
<p>The indicator data and metadata of each unit</p>
</td></tr>
<tr><td><code id="new_coin_+3A_imeta">iMeta</code></td>
<td>
<p>Indicator metadata</p>
</td></tr>
<tr><td><code id="new_coin_+3A_exclude">exclude</code></td>
<td>
<p>Optional character vector of any indicator codes (<code>iCode</code>s) to exclude from the coin(s).</p>
</td></tr>
<tr><td><code id="new_coin_+3A_split_to">split_to</code></td>
<td>
<p>This is used to split panel data into multiple coins, a so-called &quot;purse&quot;. Should be either
<code>"all"</code>, or a subset of entries in <code>iData$Time</code>. See Details.</p>
</td></tr>
<tr><td><code id="new_coin_+3A_level_names">level_names</code></td>
<td>
<p>Optional character vector of names of levels. Must have length equal to the number of
levels in the hierarchy (<code>max(iMeta$Level, na.rm = TRUE)</code>).</p>
</td></tr>
<tr><td><code id="new_coin_+3A_retain_all_ucodes_on_split">retain_all_uCodes_on_split</code></td>
<td>
<p>Logical: if panel data is input and split to a purse using <code>split_to</code>, this controls how
units with no data at certain time points are handled. If set <code>FALSE</code>, then unit at time t with no data in any indicators
will be removed completely from the coin for that time point. If <code>TRUE</code>, all units will be included in every time point. The latter option
may be useful if you impute over time.</p>
</td></tr>
<tr><td><code id="new_coin_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code>, suppresses all messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coin object is fundamentally created by passing two data frames to <code><a href="#topic+new_coin">new_coin()</a></code>:
<code>iData</code> which specifies the data points for each unit and indicator, as well as other optional
variables; and <code>iMeta</code> which specifies details about each indicator/variable found in <code>iData</code>,
including its type, name, position in the index, units, and other properties.
</p>
<p>These data frames need to follow fairly strict requirements regarding their format and consistency.
Run <code><a href="#topic+check_iData">check_iData()</a></code> and <code><a href="#topic+check_iMeta">check_iMeta()</a></code> to validate your data frames, and these should generate helpful
error messages when things go wrong.
</p>
<p>It is worth reading a little about coins and purses to use COINr. See <code>vignette("coins")</code> for more details.
</p>


<h4><code>iData</code></h4>

<p><code>iData</code> should be a data frame with required column
<code>uCode</code> which gives the code assigned to each unit (alphanumeric, not starting with a number). All other
columns are defined by corresponding entries in <code>iMeta</code>, with the following special exceptions:
</p>

<ul>
<li> <p><code>Time</code> is an optional column which allows panel data to be input, consisting of e.g. multiple rows for
each <code>uCode</code>: one for each <code>Time</code> value. This can be used to split a set of panel data into multiple coins
(a so-called &quot;purse&quot;) which can be input to COINr functions.
</p>
</li>
<li> <p><code>uName</code> is an optional column which specifies a longer name for each unit. If this column is not included,
unit codes (<code>uCode</code>) will be used as unit names where required.
</p>
</li></ul>




<h4><code>iMeta</code></h4>

<p>Required columns for <code>iMeta</code> are:
</p>

<ul>
<li> <p><code>Level</code>: Level in aggregation, where 1 is indicator level, 2 is the level resulting from aggregating
indicators, 3 is the result of aggregating level 2, and so on. Set to <code>NA</code> for entries that are not included
in the index (groups, denominators, etc).
</p>
</li>
<li> <p><code>iCode</code>: Indicator code, alphanumeric. Must not start with a number.
</p>
</li>
<li> <p><code>Parent</code>: Group (<code>iCode</code>) to which indicator/aggregate belongs in level immediately above.
Each entry here should also be found in <code>iCode</code>. Set to <code>NA</code> only
for the highest (Index) level (no parent), or for entries that are not included
in the index (groups, denominators, etc).
</p>
</li>
<li> <p><code>Direction</code>: Numeric, either -1 or 1
</p>
</li>
<li> <p><code>Weight</code>: Numeric weight, will be rescaled to sum to 1 within aggregation group. Set to <code>NA</code> for entries that are not included
in the index (groups, denominators, etc).
</p>
</li>
<li> <p><code>Type</code>: The type, corresponding to <code>iCode</code>. Can be either <code>Indicator</code>, <code>Aggregate</code>, <code>Group</code>, <code>Denominator</code>,
or <code>Other</code>.
</p>
</li></ul>

<p>Optional columns that are recognised in certain functions are:
</p>

<ul>
<li> <p><code>iName</code>: Name of the indicator: a longer name which is used in some plotting functions.
</p>
</li>
<li> <p><code>Unit</code>: the unit of the indicator, e.g. USD, thousands, score, etc. Used in some plots if available.
</p>
</li>
<li> <p><code>Target</code>: a target for the indicator. Used if normalisation type is distance-to-target.
</p>
</li></ul>

<p>The <code>iMeta</code> data frame essentially gives details about each of the columns found in <code>iData</code>, as well as
details about additional data columns eventually created by aggregating indicators. This means that the
entries in <code>iMeta</code> must include <em>all</em> columns in <code>iData</code>, <em>except</em> the three special column names: <code>uCode</code>,
<code>uName</code>, and <code>Time</code>. In other words, all column names of <code>iData</code> should appear in <code>iMeta$iCode</code>, except
the three special cases mentioned. The <code>iName</code> column optionally can be used to give longer names to each indicator
which can be used for display in plots.
</p>
<p><code>iMeta</code> also specifies the structure of the index, by specifying the parent of each indicator and aggregate.
The <code>Parent</code> column must refer to entries that can be found in <code>iCode</code>. Try <code>View(ASEM_iMeta)</code> for an example
of how this works.
</p>
<p><code>Level</code> is the &quot;vertical&quot; level in the hierarchy, where 1 is the bottom level (indicators), and each successive
level is created by aggregating the level below according to its specified groups.
</p>
<p><code>Direction</code> is set to 1 if higher values of the indicator should result in higher values of the index, and
-1 in the opposite case.
</p>
<p>The <code>Type</code> column specifies the type of the entry: <code>Indicator</code> should be used for indicators at level 1.
<code>Aggregate</code> for aggregates created by aggregating indicators or other aggregates. Otherwise set to <code>Group</code>
if the variable is not used for building the index but instead is for defining groups of units. Set to
<code>Denominator</code> if the variable is to be used for scaling (denominating) other indicators. Finally, set to
<code>Other</code> if the variable should be ignored but passed through. Any other entries here will cause an error.
</p>
<p>Note: this function requires the columns above as specified, but extra columns can also be added without
causing errors.
</p>



<h4>Other arguments</h4>

<p>The <code>exclude</code> argument can be used to exclude specified indicators. If this is specified, <code>.$Data$Raw</code>
will be built excluding these indicators, as will all subsequent build operations. However the full data set
will still be stored in <code>.$Log$new_coin</code>. The codes here should correspond to entries in the <code>iMeta$iCode</code>.
This option is useful e.g. in generating alternative coins with different indicator sets, and can be included
as a variable in a sensitivity analysis.
</p>
<p>The <code>split_to</code> argument allows panel data to be used. Panel data must have a <code>Time</code> column in <code>iData</code>, which
consists of some numerical time variable, such as a year. Panel data has multiple observations for each <code>uCode</code>,
one for each unique entry in <code>Time</code>. The <code>Time</code> column is required to be numerical, because it needs to be
possible to order it. To split panel data, specify <code>split_to = "all"</code> to split to a single coin for each
of the unique entries in <code>Time</code>. Alternatively, you can pass a vector of entries in <code>Time</code> which allows
to split to a subset of the entries to <code>Time</code>.
</p>
<p>Splitting panel data results in a so-called &quot;purse&quot; class, which is a data frame of COINs, indexed by <code>Time</code>.
See <code>vignette("coins")</code> for more details.
</p>
<p>This function replaces the now-defunct <code>assemble()</code> from COINr &lt; v1.0.
</p>



<h3>Value</h3>

<p>A &quot;coin&quot; object or a &quot;purse&quot; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build a coin using example data frames
ASEM_coin &lt;- new_coin(iData = ASEM_iData,
                      iMeta = ASEM_iMeta,
                      level_names = c("Indicator", "Pillar", "Sub-index", "Index"))
# view coin contents
ASEM_coin

# build example purse class
ASEM_purse &lt;- new_coin(iData = ASEM_iData_p,
                       iMeta = ASEM_iMeta,
                       split_to = "all",
                       quietly = TRUE)
# view purse contents
ASEM_purse

# see vignette("coins") for further info

</code></pre>

<hr>
<h2 id='Normalise'>Normalise data</h2><span id='topic+Normalise'></span>

<h3>Description</h3>

<p>This is a generic function for normalising variables and indicators, i.e. bringing them onto
a common scale. Please see individual method documentation depending on your data class:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalise(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalise_+3A_x">x</code></td>
<td>
<p>Object to be normalised</p>
</td></tr>
<tr><td><code id="Normalise_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+Normalise.numeric">Normalise.numeric()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Normalise.data.frame">Normalise.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Normalise.coin">Normalise.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Normalise.purse">Normalise.purse()</a></code>
</p>
</li></ul>

<p>See also <code>vignette("normalise")</code> for more details.
</p>
<p>This function replaces the now-defunct <code>normalise()</code> from COINr &lt; v1.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See individual method documentation.

</code></pre>

<hr>
<h2 id='Normalise.coin'>Create a normalised data set</h2><span id='topic+Normalise.coin'></span>

<h3>Description</h3>

<p>Creates a normalised data set using specifications specified in <code>global_specs</code>. Columns of <code>dset</code> can also optionally be
normalised with individual specifications using the <code>indiv_specs</code> argument. If indicators should have their
directions reversed, this can be specified using the <code>directions</code> argument. Non-numeric columns are ignored
automatically by this function. By default, this function normalises each indicator using the &quot;min-max&quot; method, scaling indicators to lie between
0 and 100. This calls the <code><a href="#topic+n_minmax">n_minmax()</a></code> function. COINr has a number of built-in normalisation functions of the form <code style="white-space: pre;">&#8288;n_*()&#8288;</code>. See <a href="https://bluefoxr.github.io/COINr/articles/normalise.html#built-in-normalisation-functions">online documentation</a>
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Normalise(
  x,
  dset,
  global_specs = NULL,
  indiv_specs = NULL,
  directions = NULL,
  out2 = "coin",
  write_to = NULL,
  write2log = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalise.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_dset">dset</code></td>
<td>
<p>A named data set found in <code>.$Data</code></p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_global_specs">global_specs</code></td>
<td>
<p>Specifications to apply to all columns, apart from those specified by <code>indiv_specs</code>. See details.</p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_indiv_specs">indiv_specs</code></td>
<td>
<p>Specifications applied to specific columns, overriding those specified in <code>global_specs</code>.
See details.</p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_directions">directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data set
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will be taken from the <code>iMeta</code> table in the coin, if available.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_out2">out2</code></td>
<td>
<p>Either <code>"coin"</code> to return normalised data set back to the coin, or <code>df</code> to simply return a data
frame.</p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_write_to">write_to</code></td>
<td>
<p>Optional character string for naming the data set in the coin. Data will be written to
<code>.$Data[[write_to]]</code>. Default is <code>write_to == "Normalised"</code>.</p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_write2log">write2log</code></td>
<td>
<p>Logical: if <code>FALSE</code>, the arguments of this function are not written to the coin log, so this
function will not be invoked when regenerating. Recommend to keep <code>TRUE</code> unless you have a good reason to do otherwise.</p>
</td></tr>
<tr><td><code id="Normalise.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Global specification</h4>

<p>The <code>global_specs</code> argument is a list which specifies the normalisation function and any function parameters
that should be used to normalise the indicators found in the data set. Unless <code>indiv_specs</code> is specified, this will be applied
to all indicators. The list should have two entries:
</p>

<ul>
<li> <p><code>.$f_n</code>: the name of the function to use to normalise each indicator
</p>
</li>
<li> <p><code>.$f_n_para</code>: any further parameters to pass to <code>f_n</code>, apart from the numeric vector (each column of the data set)
</p>
</li></ul>

<p>In this list, <code>f_n</code> should be a character string which is the name of a normalisation
function. For example, <code>f_n = "n_minmax"</code> calls the <code><a href="#topic+n_minmax">n_minmax()</a></code> function. <code>f_n_para</code> is a list of any
further arguments to <code>f_n</code>. This means that any function can be passed to <code><a href="#topic+Normalise">Normalise()</a></code>, as long as its
first argument is <code>x</code>, a numeric vector, and it returns a numeric vector of the same length. See <code><a href="#topic+n_minmax">n_minmax()</a></code>
for an example.
</p>
<p><code>f_n_para</code> is <em>required</em> to be a named list. So e.g. if we define a function <code>f1(x, arg1, arg2)</code> then we should
specify <code>f_n = "f1"</code>, and <code>f_n_para = list(arg1 = val1, arg2 = val2)</code>, where <code>val1</code> and <code>val2</code> are the
values assigned to the arguments <code>arg1</code> and <code>arg2</code> respectively.
</p>
<p>The default list for <code>global_specs</code> is: <code>list(f_n = "n_minmax", f_n_para = list(l_u = c(0,100)))</code>, i.e.
min-max normalisation between 0 and 100.
</p>
<p>Note, all COINr normalisation functions (passed to <code>f_n</code>) are of the form <code style="white-space: pre;">&#8288;n_*()&#8288;</code>. Type <code>n_</code> in the R Studio console and press the Tab key to see a list.
</p>



<h4>Individual parameter specification with iMeta</h4>

<p>For some normalisation methods we may use the same function for all indicators but use different parameters - for example, using
distance to target normalisation or goalpost normalisation. COINr now supports specifying these parameters in the <code>iMeta</code> table.
To enable this, set <code>f_n_para = "use_iMeta"</code> within the <code>global_specs</code> list.
</p>
<p>For this to work you will also need to add the correct-named columns in the <code>iMeta</code> table. To see which column names to add, check the
function documentation of the normalisation function you wish to use (e.g. <code><a href="#topic+n_goalposts">n_goalposts()</a></code>). See also examples in the
<a href="https://bluefoxr.github.io/COINr/articles/normalise.html">normalisation vignette</a>. These columns should be added before construction of
the coin.
</p>



<h4>Individual column specification</h4>

<p>To give full individual control, indicators can be normalised with different normalisation functions and parameters using the
<code>indiv_specs</code> argument. This must be specified as a named list e.g. <code>list(i1 = specs1, i2 = specs2)</code> where
<code>i1</code> and <code>i2</code> are <code>iCode</code>s to apply individual normalisation to, and <code>specs1</code> and <code>specs2</code> are
respectively lists of the same format as <code>global_specs</code> (see above). In other words, <code>indiv_specs</code> is a big
list wrapping together <code>global_specs</code>-style lists. Any <code>iCode</code>s not named in <code>indiv_specs</code> (
i.e. those not in <code>names(indiv_specs)</code>) are normalised using the specifications from <code>global_specs</code>. So
<code>indiv_specs</code> lists the exceptions to <code>global_specs</code>.
</p>
<p>See also <code>vignette("normalise")</code> for more details.
</p>



<h3>Value</h3>

<p>An updated coin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# normalise the raw data set
coin &lt;- Normalise(coin, dset = "Raw")

</code></pre>

<hr>
<h2 id='Normalise.data.frame'>Normalise a data frame</h2><span id='topic+Normalise.data.frame'></span>

<h3>Description</h3>

<p>Normalises a data frame using specifications specified in <code>global_specs</code>. Columns can also optionally be
normalised with individual specifications using the <code>indiv_specs</code> argument. If variables should have their
directions reversed, this can be specified using the <code>directions</code> argument. Non-numeric columns are ignored
automatically by this function. By default, this function normalises each indicator using the &quot;min-max&quot; method, scaling indicators to lie between
0 and 100. This calls the <code><a href="#topic+n_minmax">n_minmax()</a></code> function. COINr has a number of built-in normalisation functions of the form <code style="white-space: pre;">&#8288;n_*()&#8288;</code>. See <a href="https://bluefoxr.github.io/COINr/articles/normalise.html#built-in-normalisation-functions">online documentation</a>
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
Normalise(x, global_specs = NULL, indiv_specs = NULL, directions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalise.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Normalise.data.frame_+3A_global_specs">global_specs</code></td>
<td>
<p>Specifications to apply to all columns, apart from those specified by <code>indiv_specs</code>. See details.</p>
</td></tr>
<tr><td><code id="Normalise.data.frame_+3A_indiv_specs">indiv_specs</code></td>
<td>
<p>Specifications applied to specific columns, overriding those specified in <code>global_specs</code>. See details.</p>
</td></tr>
<tr><td><code id="Normalise.data.frame_+3A_directions">directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data frame
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will all be assigned as <code>1</code>. Non-numeric columns do not need
to have directions assigned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Normalise.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Global specification</h4>

<p>The <code>global_specs</code> argument is a list which specifies the normalisation function and any function parameters
that should be used to normalise the columns of <code>x</code>. Unless <code>indiv_specs</code> is specified, this will be applied
to all numeric columns of <code>x</code>. The list should have two entries:
</p>

<ul>
<li> <p><code>.$f_n</code>: the name of the function to use to normalise each column
</p>
</li>
<li> <p><code>.$f_n_para</code>: any further parameters to pass to <code>f_n</code>, apart from the numeric vector (each column of <code>x</code>)
</p>
</li></ul>

<p>In this list, <code>f_n</code> should be a character string which is the name of a normalisation
function. For example, <code>f_n = "n_minmax"</code> calls the <code><a href="#topic+n_minmax">n_minmax()</a></code> function. <code>f_n_para</code> is a list of any
further arguments to <code>f_n</code>. This means that any function can be passed to <code><a href="#topic+Normalise">Normalise()</a></code>, as long as its
first argument is <code>x</code>, a numeric vector, and it returns a numeric vector of the same length. See <code><a href="#topic+n_minmax">n_minmax()</a></code>
for an example.
</p>
<p><code>f_n_para</code> is <em>required</em> to be a named list. So e.g. if we define a function <code>f1(x, arg1, arg2)</code> then we should
specify <code>f_n = "f1"</code>, and <code>f_n_para = list(arg1 = val1, arg2 = val2)</code>, where <code>val1</code> and <code>val2</code> are the
values assigned to the arguments <code>arg1</code> and <code>arg2</code> respectively.
</p>
<p>The default list for <code>global_specs</code> is: <code>list(f_n = "n_minmax", f_n_para = list(l_u = c(0,100)))</code>.
</p>
<p>Note, all COINr normalisation functions (passed to <code>f_n</code>) are of the form <code style="white-space: pre;">&#8288;n_*()&#8288;</code>. Type <code>n_</code> in the R Studio console and press the Tab key to see a list.
</p>



<h4>Individual column specification</h4>

<p>Optionally, columns of <code>x</code> can be normalised with different normalisation functions and parameters using the
<code>indiv_specs</code> argument. This must be specified as a named list e.g. <code>list(i1 = specs1, i2 = specs2)</code> where
<code>i1</code> and <code>i2</code> are column names of <code>x</code> to apply individual normalisation to, and <code>specs1</code> and <code>specs2</code> are
respectively lists of the same format as <code>global_specs</code> (see above). In other words, <code>indiv_specs</code> is a big
list wrapping together <code>global_specs</code>-style lists. Any numeric columns of <code>x</code> not named in <code>indiv_specs</code> (
i.e. those not in <code>names(indiv_specs)</code>) are normalised using the specifications from <code>global_specs</code>. So
<code>indiv_specs</code> lists the exceptions to <code>global_specs</code>.
</p>
<p>See also <code>vignette("normalise")</code> for more details.
</p>



<h3>Value</h3>

<p>A normalised data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_norm &lt;- Normalise(iris)
head(iris_norm)

</code></pre>

<hr>
<h2 id='Normalise.numeric'>Normalise a numeric vector</h2><span id='topic+Normalise.numeric'></span>

<h3>Description</h3>

<p>Normalise a numeric vector using a specified function <code>f_n</code>, with possible reversal of direction
using <code>direction</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
Normalise(x, f_n = NULL, f_n_para = NULL, direction = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalise.numeric_+3A_x">x</code></td>
<td>
<p>Object to be normalised</p>
</td></tr>
<tr><td><code id="Normalise.numeric_+3A_f_n">f_n</code></td>
<td>
<p>The normalisation method, specified as string which refers to a function of the form <code>f_n(x, npara)</code>.
See details. Defaults to <code>"n_minmax"</code> which is the min-max function.</p>
</td></tr>
<tr><td><code id="Normalise.numeric_+3A_f_n_para">f_n_para</code></td>
<td>
<p>Supporting list of arguments for <code>f_n</code>. This is required to be a list.</p>
</td></tr>
<tr><td><code id="Normalise.numeric_+3A_direction">direction</code></td>
<td>
<p>If <code>direction = -1</code> the highest values of <code>x</code> will correspond to the lowest
values of the normalised <code>x</code>. Else if <code>direction = 1</code> the direction of <code>x</code> in unaltered.</p>
</td></tr>
<tr><td><code id="Normalise.numeric_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalisation is specified using the <code>f_n</code> and <code>f_n_para</code> arguments. In these, <code>f_n</code> should be a character
string which is the name of a normalisation
function. For example, <code>f_n = "n_minmax"</code> calls the <code><a href="#topic+n_minmax">n_minmax()</a></code> function. <code>f_n_para</code> is a list of any
further arguments to <code>f_n</code>. This means that any function can be passed to <code><a href="#topic+Normalise">Normalise()</a></code>, as long as its
first argument is <code>x</code>, a numeric vector, and it returns a numeric vector of the same length. See <code><a href="#topic+n_minmax">n_minmax()</a></code>
for an example.
</p>
<p>COINr has a number of built-in normalisation functions of the form <code style="white-space: pre;">&#8288;n_*()&#8288;</code>. See <a href="https://bluefoxr.github.io/COINr/articles/normalise.html#built-in-normalisation-functions">online documentation</a>
for details.
</p>
<p><code>f_n_para</code> is <em>required</em> to be a named list. So e.g. if we define a function <code>f1(x, arg1, arg2)</code> then we should
specify <code>f_n = "f1"</code>, and <code>f_n_para = list(arg1 = val1, arg2 = val2)</code>, where <code>val1</code> and <code>val2</code> are the
values assigned to the arguments <code>arg1</code> and <code>arg2</code> respectively.
</p>
<p>See also <code>vignette("normalise")</code> for more details.
</p>


<h3>Value</h3>

<p>A normalised numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example vector
x &lt;- runif(10)

# normalise using distance to reference (5th data point)
x_norm &lt;- Normalise(x, f_n = "n_dist2ref", f_n_para = list(iref = 5))

# view side by side
data.frame(x, x_norm)

</code></pre>

<hr>
<h2 id='Normalise.purse'>Create normalised data sets in a purse of coins</h2><span id='topic+Normalise.purse'></span>

<h3>Description</h3>

<p>This creates normalised data sets for each coin in the purse. In most respects, this works in a similar way
to normalising on a coin, for which reason please see <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code> for most documentation. There is however
a special case in terms of operating on a purse of coins. This is because, when
dealing with time series data, it is often desirable to normalise over the whole panel data set at once
rather than independently for each time point. This makes the resulting index and aggregates comparable
over time. Here, the <code>global</code> argument controls whether to normalise each coin independently or to normalise
across all data at once. In other respects, this function behaves the same as <code><a href="#topic+Normalise.coin">Normalise.coin()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Normalise(
  x,
  dset,
  global_specs = NULL,
  indiv_specs = NULL,
  directions = NULL,
  global = TRUE,
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalise.purse_+3A_x">x</code></td>
<td>
<p>A purse object</p>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_dset">dset</code></td>
<td>
<p>The data set to normalise in each coin</p>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_global_specs">global_specs</code></td>
<td>
<p>Default specifications</p>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_indiv_specs">indiv_specs</code></td>
<td>
<p>Individual specifications</p>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_directions">directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data set
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will be taken from the <code>iMeta</code> table in the coin, if available.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_global">global</code></td>
<td>
<p>Logical: if <code>TRUE</code>, normalisation is performed &quot;globally&quot; across all coins, by using e.g. the
max and min of each indicator in any coin. This effectively makes normalised scores comparable between coins
because they are all scaled using the same parameters. Otherwise if <code>FALSE</code>, coins are normalised individually.</p>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_write_to">write_to</code></td>
<td>
<p>Optional character string for naming the data set in each coin. Data will be written to
<code>.$Data[[write_to]]</code>. Default is <code>write_to == "Normalised"</code>.</p>
</td></tr>
<tr><td><code id="Normalise.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same specifications are passed to each coin in the purse. This means that each coin is normalised
using the same set of specifications and directions. If you need control over individual coins, you
will have to normalise coins individually.
</p>


<h3>Value</h3>

<p>An updated purse with new normalised data sets added at <code>.$Data$Normalised</code> in each coin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse
purse &lt;- build_example_purse(up_to = "new_coin", quietly = TRUE)

# normalise raw data set
purse &lt;- Normalise(purse, dset = "Raw", global = TRUE)

</code></pre>

<hr>
<h2 id='outrankMatrix'>Outranking matrix</h2><span id='topic+outrankMatrix'></span>

<h3>Description</h3>

<p>Constructs an outranking matrix based on a data frame of indicator data and corresponding weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outrankMatrix(X, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outrankMatrix_+3A_x">X</code></td>
<td>
<p>A data frame or matrix of indicator data, with observations as rows and indicators
as columns. No other columns should be present (e.g. label columns).</p>
</td></tr>
<tr><td><code id="outrankMatrix_+3A_w">w</code></td>
<td>
<p>A vector of weights, which should have length equal to <code>ncol(X)</code>. Weights are relative
and will be re-scaled to sum to 1. If <code>w</code> is not specified, defaults to equal weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>.$OutRankMatrix</code> the outranking matrix with <code>nrow(X)</code> rows and columns (matrix class).
</p>
</li>
<li> <p><code>.$nDominant</code> the number of dominance/robust pairs
</p>
</li>
<li> <p><code>.$fracDominant</code> the percentage of dominance/robust pairs
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get a sample of a few indicators
ind_data &lt;- COINr::ASEM_iData[12:16]
# calculate outranking matrix
outlist &lt;- outrankMatrix(ind_data)
# see fraction of dominant pairs (robustness)
outlist$fracDominant

</code></pre>

<hr>
<h2 id='plot_bar'>Bar chart</h2><span id='topic+plot_bar'></span>

<h3>Description</h3>

<p>Plot bar charts of single indicators. Bar charts can be coloured by an optional grouping variable <code>by_group</code>, or if
<code>iCode</code> points to an aggregate, setting <code>stack_children = TRUE</code> will plot <code>iCode</code> coloured by its underlying scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bar(
  coin,
  dset,
  iCode,
  ...,
  uLabel = "uCode",
  axes_label = "iCode",
  by_group = NULL,
  filter_to_ends = NULL,
  dset_label = FALSE,
  log_scale = FALSE,
  stack_children = FALSE,
  bar_colours = NULL,
  flip_coords = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bar_+3A_coin">coin</code></td>
<td>
<p>A coin object.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_dset">dset</code></td>
<td>
<p>Data set from which to extract the variable to plot. Passed to <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_icode">iCode</code></td>
<td>
<p>Code of variable or indicator to plot. Passed to <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="#topic+get_data">get_data()</a></code>, e.g. for filtering units.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_ulabel">uLabel</code></td>
<td>
<p>How to label units: either <code>"uCode"</code>, or <code>"uName"</code>.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_axes_label">axes_label</code></td>
<td>
<p>How to label the y axis and group legend: either <code>"iCode"</code> or <code>"iName"</code>.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_by_group">by_group</code></td>
<td>
<p>Optional group variable to use to colour bars. Cannot be used if <code>stack_children = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_filter_to_ends">filter_to_ends</code></td>
<td>
<p>Optional way to filter the bar chart to only display the top/bottom N units. This is useful in cases
where the number of units is large. Specify as e.g. <code>list(top = 10)</code> or <code>list(bottom = 10)</code> to return only the top or bottom
ten units respectively (the value 10 can be changed of course).</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_dset_label">dset_label</code></td>
<td>
<p>Logical: whether to include the data set in the y axis label.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_log_scale">log_scale</code></td>
<td>
<p>Logical: if <code>TRUE</code> uses a log scale for the y axis.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_stack_children">stack_children</code></td>
<td>
<p>Logical: if <code>TRUE</code> and <code>iCode</code> refers to an aggregate, will plot <code>iCode</code> with each bar split into
its underlying component values (the underlying indicators/aggregates used to create <code>iCode</code>). To use this, you must
have aggregated your data and <code>dset</code> must point to a data set where the underlying (child) scores of <code>iCode</code> are available.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_bar_colours">bar_colours</code></td>
<td>
<p>Optional vector of colour codes for colouring bars.</p>
</td></tr>
<tr><td><code id="plot_bar_+3A_flip_coords">flip_coords</code></td>
<td>
<p>Logical; if <code>TRUE</code> flips to horizontal bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses ggplot2 to generate plots, so the plot can be further manipulated using ggplot2 commands.
See <code style="white-space: pre;">&#8288;vignette("visualisation&#8288;</code>) for more details on plotting.
</p>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# bar plot of CO2 by GDP per capita group
plot_bar(coin, dset = "Raw", iCode = "CO2",
         by_group = "GDPpc_group", axes_label = "iName")
</code></pre>

<hr>
<h2 id='plot_corr'>Static heatmaps of correlation matrices</h2><span id='topic+plot_corr'></span>

<h3>Description</h3>

<p>Generates heatmaps of correlation matrices using ggplot2, which can be tailored according to the grouping and structure
of the index. This enables correlating any set of indicators against any other,
and supports calling named aggregation groups of indicators. The <code>withparent</code> argument generates tables of correlations only with
parents of each indicator. Also supports discrete colour maps using <code>flagcolours</code>, different types of correlation, and groups
plots by higher aggregation levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_corr(
  coin,
  dset,
  iCodes = NULL,
  Levels = 1,
  ...,
  cortype = "pearson",
  withparent = FALSE,
  grouplev = NULL,
  box_level = NULL,
  showvals = TRUE,
  flagcolours = FALSE,
  flagthresh = NULL,
  pval = 0.05,
  insig_colour = "#F0F0F0",
  text_colour = NULL,
  discrete_colours = NULL,
  box_colour = NULL,
  order_as = NULL,
  use_directions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_corr_+3A_coin">coin</code></td>
<td>
<p>The coin object</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_dset">dset</code></td>
<td>
<p>The target data set.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_icodes">iCodes</code></td>
<td>
<p>An optional list of character vectors where the first entry specifies the indicator/aggregate
codes to correlate against the second entry (also a specification of indicator/aggregate codes)</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_levels">Levels</code></td>
<td>
<p>The aggregation levels to take the two groups of indicators from. See <code><a href="#topic+get_data">get_data()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_...">...</code></td>
<td>
<p>Optional further arguments to pass to <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_cortype">cortype</code></td>
<td>
<p>The type of correlation to calculate, either <code>"pearson"</code>, <code>"spearman"</code>, or <code>"kendall"</code> (see <code><a href="stats.html#topic+cor">stats::cor()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_withparent">withparent</code></td>
<td>
<p>If <code>aglev[1] != aglev[2]</code>, and equal <code>TRUE</code> will only plot correlations of each row with its parent.
If <code>"family"</code>, plots the lowest aggregation level in <code>Levels</code> against all its parent levels.
If <code>FALSE</code> plots the full correlation matrix (default).</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_grouplev">grouplev</code></td>
<td>
<p>The aggregation level to group correlations by if <code>aglev[1] == aglev[2]</code>. By default, groups correlations into the
aggregation level above. Set to 0 to disable grouping and plot the full matrix.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_box_level">box_level</code></td>
<td>
<p>The aggregation level to draw boxes around if <code>aglev[1] == aglev[2]</code>.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_showvals">showvals</code></td>
<td>
<p>If <code>TRUE</code>, shows correlation values. If <code>FALSE</code>, no values shown.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_flagcolours">flagcolours</code></td>
<td>
<p>If <code>TRUE</code>, uses discrete colour map with thresholds defined by <code>flagthresh</code>. If <code>FALSE</code> uses continuous colour map.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_flagthresh">flagthresh</code></td>
<td>
<p>A 3-length vector of thresholds for highlighting correlations, if <code>flagcolours = TRUE</code>.
<code>flagthresh[1]</code> is the negative threshold (default -0.4). Below this value, values will be flagged red.
<code>flagthresh[2]</code> is the &quot;weak&quot; threshold (default 0.3). Values between <code>flagthresh[1]</code> and <code>flagthresh[2]</code> are coloured grey.
<code>flagthresh[3]</code> is the &quot;high&quot; threshold (default 0.9). Anything between <code>flagthresh[2]</code> and <code>flagthresh[3]</code> is flagged &quot;OK&quot;,
and anything above <code>flagthresh[3]</code> is flagged &quot;high&quot;.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_pval">pval</code></td>
<td>
<p>The significance level for plotting correlations. Correlations with <code class="reqn">p &lt; pval</code> will be shown,
otherwise they will be plotted as the colour specified by <code>insig_colour</code>. Set to 0 to disable this.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_insig_colour">insig_colour</code></td>
<td>
<p>The colour to plot insignificant correlations. Defaults to a light grey.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_text_colour">text_colour</code></td>
<td>
<p>The colour of the correlation value text (default white).</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_discrete_colours">discrete_colours</code></td>
<td>
<p>An optional 4-length character vector of colour codes or names to define the discrete
colour map if <code>flagcolours = TRUE</code> (from high to low correlation categories). Defaults to a green/blue/grey/purple.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_box_colour">box_colour</code></td>
<td>
<p>The line colour of grouping boxes, default black.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_order_as">order_as</code></td>
<td>
<p>Optional list for ordering the plotting of variables. If specified, this must be a list of length 2, where each entry of the list is
a character vector of the iCodes plotted on the x and y axes of the plot. The plot will then follow the order of these character vectors. Note this must
be used with care because the <code>grouplev</code> and <code>boxlev</code> arguments will not follow the reordering. Hence this argument is probably best used for plots
with no grouping, or for simply re-ordering within groups.</p>
</td></tr>
<tr><td><code id="plot_corr_+3A_use_directions">use_directions</code></td>
<td>
<p>Logical: if <code>TRUE</code> the extracted data is adjusted using directions found inside the coin (i.e. the &quot;Direction&quot;
column input in <code>iMeta</code>: any indicators with negative direction will have their values multiplied by -1 which will reverse the
direction of correlation). This should only be set to <code>TRUE</code> if the data set has <em>not</em> yet been normalised. For example, this can be
useful to set to <code>TRUE</code> to analyse correlations in the raw data, but would make no sense to analyse correlations in the normalised
data because that already has the direction adjusted! So you would reverse direction twice. In other words, use this at your
discretion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+get_corr">get_corr()</a></code>.
</p>
<p>Note that this function can only call correlations within the same data set (i.e. only one data set in <code>.$Data</code>).
</p>
<p>This function uses ggplot2 to generate plots, so the plot can be further manipulated using ggplot2 commands.
See <code>vignette("visualisation")</code> for more details on plotting.
</p>
<p>This function replaces the now-defunct <code>plotCorr()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A plot object generated with ggplot2, which can be edited further with ggplot2 commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "Normalise", quietly = TRUE)

# plot correlations between indicators in Sust group, using Normalised dset
plot_corr(coin, dset = "Normalised", iCodes = list("Sust"),
          grouplev = 2, flagcolours = TRUE)

</code></pre>

<hr>
<h2 id='plot_dist'>Static indicator distribution plots</h2><span id='topic+plot_dist'></span>

<h3>Description</h3>

<p>Plots indicator distributions using box plots, dot plots, violin plots, violin-dot plots, and histograms.
Supports plotting multiple indicators by calling aggregation groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dist(
  coin,
  dset,
  iCodes,
  ...,
  type = "Box",
  normalise = FALSE,
  global_specs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dist_+3A_coin">coin</code></td>
<td>
<p>The coin object, or a data frame of indicator data</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_icodes">iCodes</code></td>
<td>
<p>Indicator code(s) to plot. See details.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+get_data">get_data()</a></code> (other than <code>coin</code>, <code>dset</code> and <code>iCodes</code>).</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_type">type</code></td>
<td>
<p>The type of plot. Currently supported <code>"Box"</code>, <code>"Dot"</code>, <code>"Violin"</code>, <code>"Violindot"</code>, <code>"Histogram"</code>.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_normalise">normalise</code></td>
<td>
<p>Logical: if <code>TRUE</code>, normalises the data first, using <code>global_specs</code>. If <code>FALSE</code> (default),
data is not normalised.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_global_specs">global_specs</code></td>
<td>
<p>Specifications for normalising data if <code>normalise = TRUE</code>. This is passed to the
<code>global_specs</code> argument of <code><a href="#topic+Normalise">Normalise()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses ggplot2 to generate plots, so the plot can be further manipulated using ggplot2 commands.
See <code style="white-space: pre;">&#8288;vignette("visualisation&#8288;</code>) for more details on plotting.
</p>
<p>This function replaces the now-defunct <code>plotIndDist()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# plot all indicators in P2P group
plot_dist(coin, dset = "Raw", iCodes = "P2P", Level = 1, type = "Violindot")

</code></pre>

<hr>
<h2 id='plot_dot'>Dot plots of single indicator with highlighting</h2><span id='topic+plot_dot'></span>

<h3>Description</h3>

<p>Plots a single indicator as a line of dots, and optionally highlights selected units and statistics.
This is intended for showing the relative position of units to other units, rather than as a statistical
plot. For the latter, use <code><a href="#topic+plot_dist">plot_dist()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dot(
  coin,
  dset,
  iCode,
  Level = NULL,
  ...,
  usel = NULL,
  marker_type = "circle",
  add_stat = NULL,
  stat_label = NULL,
  show_ticks = TRUE,
  plabel = NULL,
  usel_label = TRUE,
  vert_adjust = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dot_+3A_coin">coin</code></td>
<td>
<p>The coin</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to apply the function to, which should be accessible in <code>.$Data</code>.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_icode">iCode</code></td>
<td>
<p>Code of indicator or aggregate found in <code>dset</code>. Required to be of length 1.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_level">Level</code></td>
<td>
<p>The level in the hierarchy to extract data from. See <code><a href="#topic+get_data">get_data()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="#topic+get_data">get_data()</a></code>, other than those explicitly specified here.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_usel">usel</code></td>
<td>
<p>A subset of units to highlight.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_marker_type">marker_type</code></td>
<td>
<p>The type of marker, either <code>"circle"</code> (default) or <code>"cross"</code>, or a marker number to pass to ggplot2 (0-25).</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_add_stat">add_stat</code></td>
<td>
<p>A statistic to overlay, either <code>"mean"</code>, <code>"median"</code> or else a specified value.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_stat_label">stat_label</code></td>
<td>
<p>An optional string to use as label at the point specified by <code>add_stat</code>.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_show_ticks">show_ticks</code></td>
<td>
<p>Set <code>FALSE</code> to remove axis ticks.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_plabel">plabel</code></td>
<td>
<p>Controls the labelling of the indicator. If <code>NULL</code> (default), returns the indicator code.
Otherwise if <code>"iName"</code>, returns only indicator name, if <code>"iName+unit"</code>, returns
indicator name plus unit (if found), if <code>"unit"</code> returns only unit (if found), otherwise if <code>"none"</code>,
displays no text. Finally, any other string can be passed, so e.g. <code>"My indicator"</code> will display this on the
axis.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_usel_label">usel_label</code></td>
<td>
<p>If <code>TRUE</code> (default) also labels selected units with their unit codes. <code>FALSE</code> to disable.</p>
</td></tr>
<tr><td><code id="plot_dot_+3A_vert_adjust">vert_adjust</code></td>
<td>
<p>Adjusts the vertical height of text labels and stat lines, which matters depending on plot size.
Takes a value between 0 to 2 (higher will probably remove the label from the axis space).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses ggplot2 to generate plots, so the plot can be further manipulated using ggplot2 commands.
See <code style="white-space: pre;">&#8288;vignette("visualisation&#8288;</code>) for more details on plotting.
</p>
<p>This function replaces the now-defunct <code>plotIndDot()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# dot plot of LPI, highlighting two countries and with median shown
plot_dot(coin, dset = "Raw", iCode = "LPI", usel = c("JPN", "ESP"),
         add_stat = "median", stat_label = "Median", plabel = "iName+unit")

</code></pre>

<hr>
<h2 id='plot_framework'>Framework plots</h2><span id='topic+plot_framework'></span>

<h3>Description</h3>

<p>Plots the hierarchical indicator framework. If <code>type = "sunburst"</code> (default), the framework is plotted as a
sunburst plot. If <code>type = "stack"</code> it is plotted as a linear stack. In both cases, the size of each component
is reflected by its weight and the weight of its parent, i.e. its &quot;effective weight&quot; in the framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_framework(
  coin,
  type = "sunburst",
  colour_level = NULL,
  text_colour = NULL,
  text_size = NULL,
  transparency = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_framework_+3A_coin">coin</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="plot_framework_+3A_type">type</code></td>
<td>
<p>Either <code>"sunburst"</code> or <code>"stack"</code>.</p>
</td></tr>
<tr><td><code id="plot_framework_+3A_colour_level">colour_level</code></td>
<td>
<p>The framework level, as an integer, to colour from. See details.</p>
</td></tr>
<tr><td><code id="plot_framework_+3A_text_colour">text_colour</code></td>
<td>
<p>Colour of label text - default <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="plot_framework_+3A_text_size">text_size</code></td>
<td>
<p>Text size of labels, default 2.5</p>
</td></tr>
<tr><td><code id="plot_framework_+3A_transparency">transparency</code></td>
<td>
<p>If <code>TRUE</code>, levels below <code>colour_level</code> are differentiated with some transparency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The colouring of the plot is defined to some extent by the <code>colour_level</code> argument. This should be specified
as an integer between 1 and the highest level in the framework (i.e. the maximum of the <code>iMeta$Level</code> column).
Levels higher than and including <code>colour_level</code> are coloured with individual colours from the standard colour
palette. Any levels <em>below</em> <code>colour_level</code> are coloured with the same colours as their parents, to emphasise
that they belong to the same group, and also to avoid repeating the colour palette. Levels below <code>colour_level</code>
can be additionally differentiated by setting <code>transparency = TRUE</code> which will apply increasing transparency
to lower levels.
</p>
<p>This function returns a ggplot2 class object. If you want more control over the appearance of the plot, pass
return the output of this function to a variable, and manipulate this further with ggplot2 commands to e.g.
change colour palette, individual colours, add titles, etc.
See <code style="white-space: pre;">&#8288;vignette("visualisation&#8288;</code>) for more details on plotting.
</p>
<p>This function replaces the now-defunct <code>plotframework()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A ggplot2 plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# plot framework as sunburst, colouring at level 2 upwards
plot_framework(coin, colour_level = 2, transparency = TRUE)

</code></pre>

<hr>
<h2 id='plot_scatter'>Scatter plot of two variables</h2><span id='topic+plot_scatter'></span>

<h3>Description</h3>

<p>This is a convenient quick scatter plot function for plotting any two variables x and y in a coin against each other.
At a minimum, you must specify the data set and iCode of both x and y using the <code>dsets</code> and <code>iCodes</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scatter(
  coin,
  dsets,
  iCodes,
  ...,
  by_group = NULL,
  alpha = 0.5,
  axes_label = "iCode",
  dset_label = TRUE,
  point_label = NULL,
  check_overlap = TRUE,
  nudge_y = 5,
  log_scale = c(FALSE, FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scatter_+3A_coin">coin</code></td>
<td>
<p>A coin object</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_dsets">dsets</code></td>
<td>
<p>A 2-length character vector specifying the data sets to extract v1 and v2 from,
respectively (passed as <code>dset</code> argument to <code><a href="#topic+get_data">get_data()</a></code>. Alternatively specify as a single string
which will be used for both x and y.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_icodes">iCodes</code></td>
<td>
<p>A 2-length character vector specifying the <code>iCodes</code> to use as v1 and v2,
respectively (passed as <code>iCodes</code> argument to <code><a href="#topic+get_data">get_data()</a></code>. Alternatively specify as a single string
which will be used for both x and y.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_...">...</code></td>
<td>
<p>Optional further arguments to be passed to <code><a href="#topic+get_data">get_data()</a></code>, e.g. to specify which <code>uCode</code>s to plot.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_by_group">by_group</code></td>
<td>
<p>A string specifying an optional group variable. If specified, the plot will be
coloured by this grouping variable.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_alpha">alpha</code></td>
<td>
<p>Transparency value for points between 0 and 1, passed to ggplot2.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_axes_label">axes_label</code></td>
<td>
<p>A string specifying how to label axes and legend. Either <code>"iCode"</code> to use the respective codes
of each variable, or else <code>"iName"</code> to use the names (as specified in <code>iMeta</code>).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_dset_label">dset_label</code></td>
<td>
<p>Logical: if <code>TRUE</code> (default), also adds to the axis labels which data set each variable is from.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_point_label">point_label</code></td>
<td>
<p>Specifies whether and how to label points. If <code>"uCode"</code>, points are labelled with their unit codes,
else if <code>"uName"</code>, points are labelled with their unit names. Set <code>NULL</code> to remove labels (default).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_check_overlap">check_overlap</code></td>
<td>
<p>Logical: if <code>TRUE</code> (default), point labels that overlap are removed - this results in a legible
plot but some labels may be missing. Else if <code>FALSE</code>, all labels are plotted.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Parameter passed to ggplot which controls the vertical adjustment of the text labels if present.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_log_scale">log_scale</code></td>
<td>
<p>A 2-length logical vector specifying whether to use log axes for x and y respectively: if <code>TRUE</code>,
a log axis will be used. Defaults to not-log.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally, the scatter plot can be coloured by grouping variables specified in the coin (see <code>by_group</code>). Points
and axes can be labelled using other arguments.
</p>
<p>This function is powered by ggplot2 and outputs a ggplot2 object. To further customise the plot, assign the output
of this function to a variable and use ggplot2 commands to further edit. See <code style="white-space: pre;">&#8288;vignette("visualisation&#8288;</code>) for more details on plotting.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# scatter plot of Flights against Population
# coloured by GDP per capita
# log scale applied to population
plot_scatter(coin, dsets = c("uMeta", "Raw"),
             iCodes = c("Population", "Flights"),
             by_group = "GDPpc_group", log_scale = c(TRUE, FALSE))


</code></pre>

<hr>
<h2 id='plot_sensitivity'>Plot sensitivity indices</h2><span id='topic+plot_sensitivity'></span>

<h3>Description</h3>

<p>Plots sensitivity indices as bar or pie charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sensitivity(SAresults, ptype = "bar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sensitivity_+3A_saresults">SAresults</code></td>
<td>
<p>A list of sensitivity/uncertainty analysis results from <code><a href="#topic+plot_sensitivity">plot_sensitivity()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_sensitivity_+3A_ptype">ptype</code></td>
<td>
<p>Type of plot to generate - either <code>"bar"</code>, <code>"pie"</code> or <code>"box"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use this function you first need to run <code><a href="#topic+get_sensitivity">get_sensitivity()</a></code>. Then enter the resulting list as the
<code>SAresults</code> argument here.
</p>
<p>See <code>vignette("sensitivity")</code>.
</p>
<p>This function replaces the now-defunct <code>plotSA()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A plot of sensitivity indices generated by ggplot2.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_sensitivity">get_sensitivity()</a></code> Perform global sensitivity or uncertainty analysis on a COIN
</p>
</li>
<li> <p><code><a href="#topic+plot_uncertainty">plot_uncertainty()</a></code> Plot confidence intervals on ranks following a sensitivity analysis
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># for examples, see `vignette("sensitivity")`
# (this is because package examples are run automatically and sensitivity analysis
# can take a few minutes to run at realistic settings)

</code></pre>

<hr>
<h2 id='plot_uncertainty'>Plot ranks from an uncertainty/sensitivity analysis</h2><span id='topic+plot_uncertainty'></span>

<h3>Description</h3>

<p>Plots the ranks resulting from an uncertainty and sensitivity analysis, in particular plots
the median, and 5th/95th percentiles of ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_uncertainty(
  SAresults,
  plot_units = NULL,
  order_by = "nominal",
  dot_colour = NULL,
  line_colour = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_uncertainty_+3A_saresults">SAresults</code></td>
<td>
<p>A list of sensitivity/uncertainty analysis results from <code><a href="#topic+get_sensitivity">get_sensitivity()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_plot_units">plot_units</code></td>
<td>
<p>A character vector of units to plot. Defaults to all units. You can also set
to <code>"top10"</code> to only plot top 10 units, and <code>"bottom10"</code> for bottom ten.</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_order_by">order_by</code></td>
<td>
<p>If set to <code>"nominal"</code>, orders the rank plot by nominal ranks
(i.e. the original ranks prior to the sensitivity analysis). Otherwise if <code>"median"</code>, orders by
median ranks.</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_dot_colour">dot_colour</code></td>
<td>
<p>Colour of dots representing median ranks.</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_line_colour">line_colour</code></td>
<td>
<p>Colour of lines connecting 5th and 95th percentiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use this function you first need to run <code><a href="#topic+get_sensitivity">get_sensitivity()</a></code>. Then enter the resulting list as the
<code>SAresults</code> argument here.
</p>
<p>See <code>vignette("sensitivity")</code>.
</p>
<p>This function replaces the now-defunct <code>plotSARanks()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A plot of rank confidence intervals, generated by 'ggplot2'.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_sensitivity">get_sensitivity()</a></code> Perform global sensitivity or uncertainty analysis on a coin
</p>
</li>
<li> <p><code><a href="#topic+plot_sensitivity">plot_sensitivity()</a></code> Plot sensitivity indices following a sensitivity analysis.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># for examples, see `vignette("sensitivity")`
# (this is because package examples are run automatically and sensitivity analysis
# can take a few minutes to run at realistic settings)

</code></pre>

<hr>
<h2 id='prc_change'>Percentage change of time series</h2><span id='topic+prc_change'></span>

<h3>Description</h3>

<p>Calculates the percentage change in a time series from the initial value. The time series is defined by
<code>y</code> the response variable, indexed by <code>x</code>, the time variable. The <code>per</code> argument can optionally be used
to scale the result according to a period of time. E.g. if the units of <code>x</code> are years, setting <code>x = 10</code>
will measure the percentage change per decade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prc_change(y, x, per = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prc_change_+3A_y">y</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="prc_change_+3A_x">x</code></td>
<td>
<p>A numeric vector of the same length as <code>y</code>, indexing <code>y</code> in time. No <code>NA</code> values are allowed
in <code>x</code>.</p>
</td></tr>
<tr><td><code id="prc_change_+3A_per">per</code></td>
<td>
<p>Numeric value to scale the change according to a period of time. See description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function operates in two ways, depending on the number of data points. If <code>x</code> and <code>y</code> have two non-<code>NA</code>
observations, percentage change is calculated using the first and last values. If three or more points are
available, a linear regression is used to estimate the average percentage change. If fewer than two points
are available, the percentage change cannot be estimated and <code>NA</code> is returned.
</p>
<p>If all <code>y</code> values are equal, it will return a change of zero.
</p>


<h3>Value</h3>

<p>Percentage change as a scalar value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a time vector
x &lt;- 2011:2020

# some random points
y &lt;- runif(10)

# find percentage change per decade
prc_change(y, x, 10)
</code></pre>

<hr>
<h2 id='print.coin'>Print coin</h2><span id='topic+print.coin'></span>

<h3>Description</h3>

<p>Some details about the coin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="print.coin_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output
</p>

<hr>
<h2 id='print.purse'>Print purse</h2><span id='topic+print.purse'></span>

<h3>Description</h3>

<p>Some details about the purse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.purse_+3A_x">x</code></td>
<td>
<p>A purse</p>
</td></tr>
<tr><td><code id="print.purse_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output
</p>

<hr>
<h2 id='qNormalise'>Quick normalisation</h2><span id='topic+qNormalise'></span>

<h3>Description</h3>

<p>This is a generic wrapper function for <code><a href="#topic+Normalise">Normalise()</a></code>, which offers a simpler syntax but less flexibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qNormalise(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qNormalise_+3A_x">x</code></td>
<td>
<p>Object to be normalised</p>
</td></tr>
<tr><td><code id="qNormalise_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method documentation:
</p>

<ul>
<li> <p><code><a href="#topic+qNormalise.data.frame">qNormalise.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+qNormalise.coin">qNormalise.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+qNormalise.purse">qNormalise.purse()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>A normalised object
</p>

<hr>
<h2 id='qNormalise.coin'>Quick normalisation of a coin</h2><span id='topic+qNormalise.coin'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code><a href="#topic+Normalise">Normalise()</a></code>, which offers a simpler syntax but less flexibility. It
normalises a data set within a coin using a specified function <code>f_n</code> which is used to normalise each indicator, with
additional function arguments passed by <code>f_n_para</code>. By default, <code>f_n = "n_minmax"</code> and <code>f_n_para</code> is
set so that the indicators are normalised using the min-max method, between 0 and 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
qNormalise(
  x,
  dset,
  f_n = "n_minmax",
  f_n_para = list(l_u = c(0, 100)),
  directions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qNormalise.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="qNormalise.coin_+3A_dset">dset</code></td>
<td>
<p>Name of data set to normalise</p>
</td></tr>
<tr><td><code id="qNormalise.coin_+3A_f_n">f_n</code></td>
<td>
<p>Name of a normalisation function (as a string) to apply to each indicator. Default <code>"n_minmax"</code>.</p>
</td></tr>
<tr><td><code id="qNormalise.coin_+3A_f_n_para">f_n_para</code></td>
<td>
<p>Any further arguments to pass to <code>f_n</code>, as a named list.</p>
</td></tr>
<tr><td><code id="qNormalise.coin_+3A_directions">directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data frame
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will be taken from the <code>iMeta</code> table in the coin, if available.
</p>
</li></ul>
</td></tr>
<tr><td><code id="qNormalise.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function is similar to <code><a href="#topic+Normalise">Normalise()</a></code> but brings parameters into the function arguments
rather than being wrapped in a list. It also does not allow individual normalisation.
</p>
<p>See <code><a href="#topic+Normalise">Normalise()</a></code> documentation for more details, and <code>vignette("normalise")</code>.
</p>


<h3>Value</h3>

<p>An updated coin with normalised data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# normalise raw data set using min max, but change to scale 1-10
coin &lt;- qNormalise(coin, dset = "Raw", f_n = "n_minmax",
                   f_n_para = list(l_u = c(1,10)))

</code></pre>

<hr>
<h2 id='qNormalise.data.frame'>Quick normalisation of a data frame</h2><span id='topic+qNormalise.data.frame'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code><a href="#topic+Normalise">Normalise()</a></code>, which offers a simpler syntax but less flexibility. It
normalises a data frame using a specified function <code>f_n</code> which is used to normalise each column, with
additional function arguments passed by <code>f_n_para</code>. By default, <code>f_n = "n_minmax"</code> and <code>f_n_para</code> is
set so that the columns of <code>x</code> are normalised using the min-max method, between 0 and 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
qNormalise(x, f_n = "n_minmax", f_n_para = NULL, directions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qNormalise.data.frame_+3A_x">x</code></td>
<td>
<p>A numeric data frame</p>
</td></tr>
<tr><td><code id="qNormalise.data.frame_+3A_f_n">f_n</code></td>
<td>
<p>Name of a normalisation function (as a string) to apply to each column of <code>x</code>. Default <code>"n_minmax"</code>.</p>
</td></tr>
<tr><td><code id="qNormalise.data.frame_+3A_f_n_para">f_n_para</code></td>
<td>
<p>Any further arguments to pass to <code>f_n</code>, as a named list. If <code>f_n = "n_minmax"</code>, this defaults
to <code>list(l_u = c(0,100))</code> (scale between 0 and 100).</p>
</td></tr>
<tr><td><code id="qNormalise.data.frame_+3A_directions">directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data frame
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will all be assigned as <code>1</code>. Non-numeric columns do not need
to have directions assigned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="qNormalise.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function is similar to <code><a href="#topic+Normalise">Normalise()</a></code> but brings parameters into the function arguments
rather than being wrapped in a list. It also does not allow individual normalisation.
</p>
<p>See <code><a href="#topic+Normalise">Normalise()</a></code> documentation for more details, and <code>vignette("normalise")</code>.
</p>


<h3>Value</h3>

<p>A normalised data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some made up data
X &lt;- data.frame(uCode = letters[1:10],
                a = runif(10),
                b = runif(10)*100)
# normalise (defaults to min-max)
qNormalise(X)

</code></pre>

<hr>
<h2 id='qNormalise.purse'>Quick normalisation of a purse</h2><span id='topic+qNormalise.purse'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code><a href="#topic+Normalise">Normalise()</a></code>, which offers a simpler syntax but less flexibility. It
normalises data sets within a purse using a specified function <code>f_n</code> which is used to normalise each indicator, with
additional function arguments passed by <code>f_n_para</code>. By default, <code>f_n = "n_minmax"</code> and <code>f_n_para</code> is
set so that the indicators are normalised using the min-max method, between 0 and 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
qNormalise(
  x,
  dset,
  f_n = "n_minmax",
  f_n_para = list(l_u = c(0, 100)),
  directions = NULL,
  global = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qNormalise.purse_+3A_x">x</code></td>
<td>
<p>A purse</p>
</td></tr>
<tr><td><code id="qNormalise.purse_+3A_dset">dset</code></td>
<td>
<p>Name of data set to normalise</p>
</td></tr>
<tr><td><code id="qNormalise.purse_+3A_f_n">f_n</code></td>
<td>
<p>Name of a normalisation function (as a string) to apply to each indicator. Default <code>"n_minmax"</code>.</p>
</td></tr>
<tr><td><code id="qNormalise.purse_+3A_f_n_para">f_n_para</code></td>
<td>
<p>Any further arguments to pass to <code>f_n</code>, as a named list.</p>
</td></tr>
<tr><td><code id="qNormalise.purse_+3A_directions">directions</code></td>
<td>
<p>An optional data frame containing the following columns:
</p>

<ul>
<li> <p><code>iCode</code> The indicator code, corresponding to the column names of the data frame
</p>
</li>
<li> <p><code>Direction</code> numeric vector with entries either <code>-1</code> or <code>1</code>
If <code>directions</code> is not specified, the directions will be taken from the <code>iMeta</code> table in the coin, if available.
</p>
</li></ul>
</td></tr>
<tr><td><code id="qNormalise.purse_+3A_global">global</code></td>
<td>
<p>Logical: if <code>TRUE</code>, normalisation is performed &quot;globally&quot; across all coins, by using e.g. the
max and min of each indicator in any coin. This effectively makes normalised scores comparable between coins
because they are all scaled using the same parameters. Otherwise if <code>FALSE</code>, coins are normalised individually.</p>
</td></tr>
<tr><td><code id="qNormalise.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function is similar to <code><a href="#topic+Normalise">Normalise()</a></code> but brings parameters into the function arguments
rather than being wrapped in a list. It also does not allow individual normalisation.
</p>
<p>Normalisation can either be performed independently on each coin, or over the entire panel data set
simultaneously. See the discussion in <code><a href="#topic+Normalise.purse">Normalise.purse()</a></code> and <code>vignette("normalise")</code>.
</p>


<h3>Value</h3>

<p>An updated purse with normalised data sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example purse
purse &lt;- build_example_purse(up_to = "new_coin", quietly = TRUE)

# normalise using min-max, globally
purse &lt;- qNormalise(purse, dset = "Raw", global = TRUE)

</code></pre>

<hr>
<h2 id='qTreat'>Quick outlier treatment</h2><span id='topic+qTreat'></span>

<h3>Description</h3>

<p>This is a generic wrapper function for <code><a href="#topic+Treat">Treat()</a></code>. It offers a simpler syntax but less flexibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qTreat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qTreat_+3A_x">x</code></td>
<td>
<p>Object to be normalised.</p>
</td></tr>
<tr><td><code id="qTreat_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See individual method documentation:
</p>

<ul>
<li> <p><code><a href="#topic+qTreat.data.frame">qTreat.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+qTreat.coin">qTreat.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+qTreat.purse">qTreat.purse()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>A treated object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See individual method examples

</code></pre>

<hr>
<h2 id='qTreat.coin'>Quick outlier treatment of a coin</h2><span id='topic+qTreat.coin'></span>

<h3>Description</h3>

<p>A simplified version of <code><a href="#topic+Treat">Treat()</a></code> which allows direct access to the default parameters. This has less flexibility,
but is an easier interface and probably more convenient if the objective is to use the default treatment process
but with some minor adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
qTreat(
  x,
  dset,
  winmax = 5,
  skew_thresh = 2,
  kurt_thresh = 3.5,
  f2 = "log_CT",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qTreat.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="qTreat.coin_+3A_dset">dset</code></td>
<td>
<p>Name of data set to treat for outliers</p>
</td></tr>
<tr><td><code id="qTreat.coin_+3A_winmax">winmax</code></td>
<td>
<p>Maximum number of points to Winsorise for each indicator. Default 5.</p>
</td></tr>
<tr><td><code id="qTreat.coin_+3A_skew_thresh">skew_thresh</code></td>
<td>
<p>Absolute skew threshold - default 2.</p>
</td></tr>
<tr><td><code id="qTreat.coin_+3A_kurt_thresh">kurt_thresh</code></td>
<td>
<p>Kurtosis threshold - default 3.5.</p>
</td></tr>
<tr><td><code id="qTreat.coin_+3A_f2">f2</code></td>
<td>
<p>Function to call if Winsorisation does not bring skew and kurtosis within limits. Default <code>"log_CT"</code>.</p>
</td></tr>
<tr><td><code id="qTreat.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function treats each indicator in the data set targeted by <code>dset</code> using the following process:
</p>

<ul>
<li><p> First, it checks whether skew and kurtosis are within the specified limits of <code>skew_thresh</code> and <code>kurt_thresh</code>
</p>
</li>
<li><p> If the indicator is not within the limits, it applies the <code><a href="#topic+winsorise">winsorise()</a></code> function, with maximum number of winsorised
points specified by <code>winmax</code>.
</p>
</li>
<li><p> If winsorisation does not bring the indicator within the skew/kurtosis limits, it is instead passed to <code>f2</code>, which is
a second outlier treatment function, default <code><a href="#topic+log_CT">log_CT()</a></code>.
</p>
</li></ul>

<p>The arguments of <code><a href="#topic+qTreat">qTreat()</a></code> are passed to <code><a href="#topic+Treat">Treat()</a></code>.
</p>
<p>See <code><a href="#topic+Treat">Treat()</a></code> documentation for more details, and <code>vignette("treat")</code>.
</p>


<h3>Value</h3>

<p>An updated coin with treated data set at <code>.$Data$Treated</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# treat with winmax = 3
coin &lt;- qTreat(coin, dset = "Raw", winmax = 3)

</code></pre>

<hr>
<h2 id='qTreat.data.frame'>Quick outlier treatment of a data frame</h2><span id='topic+qTreat.data.frame'></span>

<h3>Description</h3>

<p>A simplified version of <code><a href="#topic+Treat">Treat()</a></code> which allows direct access to the default parameters. This has less flexibility,
but is an easier interface and probably more convenient if the objective is to use the default treatment process
but with some minor adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
qTreat(x, winmax = 5, skew_thresh = 2, kurt_thresh = 3.5, f2 = "log_CT", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qTreat.data.frame_+3A_x">x</code></td>
<td>
<p>A numeric data frame</p>
</td></tr>
<tr><td><code id="qTreat.data.frame_+3A_winmax">winmax</code></td>
<td>
<p>Maximum number of points to Winsorise for each column. Default 5.</p>
</td></tr>
<tr><td><code id="qTreat.data.frame_+3A_skew_thresh">skew_thresh</code></td>
<td>
<p>Absolute skew threshold - default 2.</p>
</td></tr>
<tr><td><code id="qTreat.data.frame_+3A_kurt_thresh">kurt_thresh</code></td>
<td>
<p>Kurtosis threshold - default 3.5.</p>
</td></tr>
<tr><td><code id="qTreat.data.frame_+3A_f2">f2</code></td>
<td>
<p>Function to call if Winsorisation does not bring skew and kurtosis within limits. Default <code>"log_CT"</code>.</p>
</td></tr>
<tr><td><code id="qTreat.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function treats each column in <code>x</code> using the following process:
</p>

<ul>
<li><p> First, it checks whether skew and kurtosis are within the specified limits of <code>skew_thresh</code> and <code>kurt_thresh</code>
</p>
</li>
<li><p> If the column is not within the limits, it applies the <code><a href="#topic+winsorise">winsorise()</a></code> function, with maximum number of winsorised
points specified by <code>winmax</code>.
</p>
</li>
<li><p> If winsorisation does not bring the column within the skew/kurtosis limits, it is instead passed to <code>f2</code>, which is
a second outlier treatment function, default <code><a href="#topic+log_CT">log_CT()</a></code>.
</p>
</li></ul>

<p>The arguments of <code><a href="#topic+qTreat">qTreat()</a></code> are passed to <code><a href="#topic+Treat">Treat()</a></code>.
</p>
<p>See <code><a href="#topic+Treat">Treat()</a></code> documentation for more details, and <code>vignette("treat")</code>.
</p>


<h3>Value</h3>

<p>A list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># select three indicators
df1 &lt;- ASEM_iData[c("Flights", "Goods", "Services")]

# treat data frame, changing winmax and skew/kurtosis limits
l_treat &lt;- qTreat(df1, winmax = 1, skew_thresh = 1.5, kurt_thresh = 3)

# Now we check what the results are:
l_treat$Dets_Table

</code></pre>

<hr>
<h2 id='qTreat.purse'>Quick outlier treatment of a purse</h2><span id='topic+qTreat.purse'></span>

<h3>Description</h3>

<p>A simplified version of <code><a href="#topic+Treat">Treat()</a></code> which allows direct access to the default parameters. This has less flexibility,
but is an easier interface and probably more convenient if the objective is to use the default treatment process
but with some minor adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
qTreat(
  x,
  dset,
  winmax = 5,
  skew_thresh = 2,
  kurt_thresh = 3.5,
  f2 = "log_CT",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qTreat.purse_+3A_x">x</code></td>
<td>
<p>A purse</p>
</td></tr>
<tr><td><code id="qTreat.purse_+3A_dset">dset</code></td>
<td>
<p>Name of data set to treat for outliers in each coin</p>
</td></tr>
<tr><td><code id="qTreat.purse_+3A_winmax">winmax</code></td>
<td>
<p>Maximum number of points to Winsorise for each indicator. Default 5.</p>
</td></tr>
<tr><td><code id="qTreat.purse_+3A_skew_thresh">skew_thresh</code></td>
<td>
<p>Absolute skew threshold - default 2.</p>
</td></tr>
<tr><td><code id="qTreat.purse_+3A_kurt_thresh">kurt_thresh</code></td>
<td>
<p>Kurtosis threshold - default 3.5.</p>
</td></tr>
<tr><td><code id="qTreat.purse_+3A_f2">f2</code></td>
<td>
<p>Function to call if Winsorisation does not bring skew and kurtosis within limits. Default <code>"log_CT"</code>.</p>
</td></tr>
<tr><td><code id="qTreat.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply applies the same data treatment to each coin. See documentation for <code><a href="#topic+Treat.coin">Treat.coin()</a></code>,
<code><a href="#topic+qTreat.coin">qTreat.coin()</a></code> and <code>vignette("treat")</code>.
</p>


<h3>Value</h3>

<p>An updated purse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='rank_df'>Convert a data frame to ranks</h2><span id='topic+rank_df'></span>

<h3>Description</h3>

<p>Replaces all numerical columns of a data frame with their ranks. Uses sport ranking, i.e. ties
share the highest rank place. Ignores non-numerical columns. See <code><a href="base.html#topic+rank">rank()</a></code>. Optionally, returns in-group ranks
using a specified grouping column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_df(df, use_group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_df_+3A_df">df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="rank_df_+3A_use_group">use_group</code></td>
<td>
<p>An optional column of df (specified as a string) to use as a grouping variable. If specified, returns ranks
inside each group present in this column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>rankDF()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame equal to the data frame that was input, but with any numerical columns replaced with ranks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some random data, with a column of characters
df &lt;- data.frame(RName = c("A", "B", "C"),
Score1 = runif(3), Score2 = runif(3))
# convert to ranks
rank_df(df)
# grouped ranking - use some example data
df1 &lt;- ASEM_iData[c("uCode", "GDP_group", "Goods", "LPI")]
rank_df(df1, use_group = "GDP_group")

</code></pre>

<hr>
<h2 id='Regen'>Regenerate a coin or purse</h2><span id='topic+Regen'></span>

<h3>Description</h3>

<p>Methods for regenerating coins and purses. Regeneration is re-running all the functions used to build
the coin/purse, using the order and parameters found in the <code>.$Log</code> list of the coin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Regen(x, from = NULL, quietly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Regen_+3A_x">x</code></td>
<td>
<p>A coin or purse object to be regenerated</p>
</td></tr>
<tr><td><code id="Regen_+3A_from">from</code></td>
<td>
<p>Optional: a construction function name. If specified, regeneration begins from this function, rather
than re-running all functions.</p>
</td></tr>
<tr><td><code id="Regen_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code> (default), messages are suppressed during building.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see individual method documentation:
</p>

<ul>
<li> <p><code><a href="#topic+Regen.coin">Regen.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Regen.purse">Regen.purse()</a></code>
</p>
</li></ul>

<p>See also <code>vignette("adjustments")</code>.
</p>
<p>This function replaces the now-defunct <code>regen()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A regenerated object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see individual method examples

</code></pre>

<hr>
<h2 id='Regen.coin'>Regenerate a coin</h2><span id='topic+Regen.coin'></span>

<h3>Description</h3>

<p>Regenerates the <code>.$Data</code> entries in a coin by rerunning the construction functions according to the specifications in <code>.$Log</code>.
This effectively regenerates the results. Different variations of coins can be quickly achieved by editing the
saved arguments in <code>.$Log</code> and regenerating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Regen(x, from = NULL, quietly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Regen.coin_+3A_x">x</code></td>
<td>
<p>A coin class object</p>
</td></tr>
<tr><td><code id="Regen.coin_+3A_from">from</code></td>
<td>
<p>Optional: a construction function name. If specified, regeneration begins from this function, rather
than re-running all functions.</p>
</td></tr>
<tr><td><code id="Regen.coin_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code> (default), messages are suppressed during building.</p>
</td></tr>
<tr><td><code id="Regen.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>from</code> argument allows partial regeneration, starting from a
specified function. This can be helpful to speed up regeneration in some cases. However, keep in mind that
if you change a <code>.$Log</code> argument from a function that is run before the point that you choose to start running
from, it will not affect the results.
</p>
<p>Note that while sets of weights will be passed to the regenerated COIN, anything in <code>.$Analysis</code> will be removed
and will have to be recalculated.
</p>
<p>See also <code>vignette("adjustments")</code> for more info on regeneration.
</p>


<h3>Value</h3>

<p>Updated coin object with regenerated results (data sets).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build full example coin
coin &lt;- build_example_coin(quietly = TRUE)

# copy coin
coin2 &lt;- coin

# change to prank function (percentile ranks)
# we don't need to specify any additional parameters (f_n_para) here
coin2$Log$Normalise$global_specs &lt;- list(f_n = "n_prank")

# regenerate
coin2 &lt;- Regen(coin2)

# compare index, sort by absolute rank difference
compare_coins(coin, coin2, dset = "Aggregated", iCode = "Index",
              sort_by = "Abs.diff", decreasing = TRUE)

</code></pre>

<hr>
<h2 id='Regen.purse'>Regenerate a purse</h2><span id='topic+Regen.purse'></span>

<h3>Description</h3>

<p>Regenerates the <code>.$Data</code> entries in all coins by rerunning the construction functions according to the specifications in
<code>.$Log</code>, for each coin in the purse. This effectively regenerates the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Regen(x, from = NULL, quietly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Regen.purse_+3A_x">x</code></td>
<td>
<p>A purse class object</p>
</td></tr>
<tr><td><code id="Regen.purse_+3A_from">from</code></td>
<td>
<p>Optional: a construction function name. If specified, regeneration begins from this function, rather
than re-running all functions.</p>
</td></tr>
<tr><td><code id="Regen.purse_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code> (default), messages are suppressed during building.</p>
</td></tr>
<tr><td><code id="Regen.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>from</code> argument allows partial regeneration, starting from a
specified function. This can be helpful to speed up regeneration in some cases. However, keep in mind that
if you change a <code>.$Log</code> argument from a function that is run before the point that you choose to start running
from, it will not affect the results.
</p>
<p>Note that for the moment, regeneration of purses is only partially supported. This is because usually, in the
normalisation step, it is necessary to normalise across the full panel data set (see the <code>global</code> argument in
<code><a href="#topic+Normalise">Normalise()</a></code>). At the moment, purse regeneration is performed by regenerating each coin individually, but this
does not allow for global normalisation which has to be done at the purse level. This may be fixed in future
releases.
</p>
<p>See also documentation for <code><a href="#topic+Regen.coin">Regen.coin()</a></code> and <code>vignette("adjustments")</code>.
</p>


<h3>Value</h3>

<p>Updated purse object with regenerated results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples from Regen.coin() and vignette("adjustments")

</code></pre>

<hr>
<h2 id='remove_elements'>Check the effect of removing indicators or aggregates</h2><span id='topic+remove_elements'></span>

<h3>Description</h3>

<p>This is an analysis function for seeing what happens when elements of the composite indicator are removed. This can help with &quot;what if&quot;
experiments and acts as different measure of the influence of each indicator or aggregate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_elements(coin, Level, dset, iCode, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_elements_+3A_coin">coin</code></td>
<td>
<p>A coin class object, which must be constructed up to and including the aggregation step, i.e. using <code><a href="#topic+Aggregate">Aggregate()</a></code>.</p>
</td></tr>
<tr><td><code id="remove_elements_+3A_level">Level</code></td>
<td>
<p>The level at which to remove elements. For example, <code>Level = 1</code> would check the effect of removing each indicator, one at
a time. <code>Level = 2</code> would check the effect of removing each of the aggregation groups above the indicator level, one at a time.</p>
</td></tr>
<tr><td><code id="remove_elements_+3A_dset">dset</code></td>
<td>
<p>The name of the data set to take <code>iCode</code> from. Most likely this should be name of the aggregated data set, typically <code>"Aggregated"</code>.</p>
</td></tr>
<tr><td><code id="remove_elements_+3A_icode">iCode</code></td>
<td>
<p>A character string indicating the indicator or aggregate code to extract from each iteration. I.e. normally this would be set to
the index code to compare the ranks of the index upon removing each indicator or aggregate. But it can be any code that is present in
<code>.$Data[[dset]]</code>.</p>
</td></tr>
<tr><td><code id="remove_elements_+3A_quietly">quietly</code></td>
<td>
<p>Logical: if <code>FALSE</code> (default) will output to the console an indication of progress. Might be useful when iterating over many
indicators. Otherwise set to <code>TRUE</code> to shut this up.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One way of looking at indicator &quot;importance&quot; in a composite indicator is via correlations. A different way is to see what happens if we
remove the indicator completely from the framework. If removing an indicator or a whole aggregation of indicators results in very little
rank change, it is one indication that perhaps it is not necessary to include it. Emphasis on <em>one</em>: there may be many other things to take
into account.
</p>
<p>This function works by successively setting the weight of each indicator or aggregate to zero. If the analysis is performed at the indicator
level, it creates a copy of the coin, sets the weight of the first indicator to zero, regenerates the results, and compares to the nominal
results (results when no weights are set to zero). It repeats this for each indicator in turn, such that each time one indicator is set to
zero weights, and the others retain their original weights. The output is a series of tables comparing scores and ranks (see Value).
</p>
<p>Note that &quot;removing the indicator&quot; here means more precisely &quot;setting its weight to zero&quot;. In most cases the first implies the second,
but check that the aggregation method that you are using satisfies this relationship. For example, if the aggregation method does not
use any weights, then setting the weight to zero will have no effect.
</p>
<p>This function replaces the now-defunct <code>removeElements()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A list with elements as follows:
</p>

<ul>
<li> <p><code>.$Scores</code>: a data frame where each column is the scores for each unit, with indicator/aggregate corresponding to the column name removed.
E.g. <code>.$Scores$Ind1</code> gives the scores resulting from removing &quot;Ind1&quot;.
</p>
</li>
<li> <p><code>.$Ranks</code>: as above but ranks
</p>
</li>
<li> <p><code>.$RankDiffs</code>: as above but difference between nominal rank and rank on removing each indicator/aggregate
</p>
</li>
<li> <p><code>.$RankAbsDiffs</code>: as above but absolute rank differences
</p>
</li>
<li> <p><code>.$MeanAbsDiffs</code>: as above, but the mean of each column. So it is the mean (over units) absolute rank change resulting from removing each
indicator or aggregate.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(quietly = TRUE)

# run function removing elements in level 2
l_res &lt;- remove_elements(coin, Level = 3, dset = "Aggregated", iCode = "Index")

# get summary of rank changes
l_res$MeanAbsDiff

</code></pre>

<hr>
<h2 id='replace_df'>Replace multiple values in a data frame</h2><span id='topic+replace_df'></span>

<h3>Description</h3>

<p>Given a data frame (or vector), this function replaces values according to a look up table or dictionary. In COINr this may
be useful for exchanging categorical data with numeric scores, prior to assembly. Or for changing codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_df(df, lookup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_df_+3A_df">df</code></td>
<td>
<p>A data frame or a vector</p>
</td></tr>
<tr><td><code id="replace_df_+3A_lookup">lookup</code></td>
<td>
<p>A data frame with columns <code>old</code> (the values to be replaced) and <code>new</code> the values to replace with. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lookup data frame must not have any duplicated values in the <code>old</code> column. This function looks for exact matches of
elements of the <code>old</code> column and replaces them with the corresponding value in the <code>new</code> column. For each row of <code>lookup</code>,
the class of the old value must match the class of the new value. This is to keep classes of data frames columns consistent.
If you wish to replace with a different class, you should convert classes in your data frame before using this function.
</p>
<p>This function replaces the now-defunct <code>replaceDF()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame with replaced values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># replace sub-pillar codes in ASEM indicator metadata
codeswap &lt;- data.frame(old = c("Conn", "Sust"), new = c("SI1", "SI2"))
# swap codes in both iMeta
replace_df(ASEM_iMeta, codeswap)

</code></pre>

<hr>
<h2 id='round_df'>Round down a data frame</h2><span id='topic+round_df'></span>

<h3>Description</h3>

<p>Tiny function just to round down a data frame for display in a table, ignoring non-numeric columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_df(df, decimals = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_df_+3A_df">df</code></td>
<td>
<p>A data frame to input</p>
</td></tr>
<tr><td><code id="round_df_+3A_decimals">decimals</code></td>
<td>
<p>The number of decimal places to round to (default 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>roundDF()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A data frame, with any numeric columns rounded to the specified amount.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_df( as.data.frame(matrix(runif(20),10,2)), decimals = 3)

</code></pre>

<hr>
<h2 id='SA_estimate'>Estimate sensitivity indices</h2><span id='topic+SA_estimate'></span>

<h3>Description</h3>

<p>Post process a sample to obtain sensitivity indices. This function takes a univariate output
which is generated as a result of running a Monte Carlo sample from <code><a href="#topic+SA_sample">SA_sample()</a></code> through a system.
Then it estimates sensitivity indices using this sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SA_estimate(yy, N, d, Nboot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SA_estimate_+3A_yy">yy</code></td>
<td>
<p>A vector of model output values, as a result of a <code class="reqn">N(d+2)</code> Monte Carlo design.</p>
</td></tr>
<tr><td><code id="SA_estimate_+3A_n">N</code></td>
<td>
<p>The number of sample points per dimension.</p>
</td></tr>
<tr><td><code id="SA_estimate_+3A_d">d</code></td>
<td>
<p>The dimensionality of the sample</p>
</td></tr>
<tr><td><code id="SA_estimate_+3A_nboot">Nboot</code></td>
<td>
<p>Number of bootstrap draws for estimates of confidence intervals on sensitivity indices.
If this is not specified, bootstrapping is not applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is built to be used inside <code><a href="#topic+get_sensitivity">get_sensitivity()</a></code>.
</p>


<h3>Value</h3>

<p>A list with the output variance, plus a data frame of first order and total order sensitivity indices for
each variable, as well as bootstrapped confidence intervals if <code>!is.null(Nboot)</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_sensitivity">get_sensitivity()</a></code> Perform global sensitivity or uncertainty analysis on a COIN
</p>
</li>
<li> <p><code><a href="#topic+SA_sample">SA_sample()</a></code> Input design for estimating sensitivity indices
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># This is a generic example rather than applied to a COIN (for reasons of speed)

# A simple test function
testfunc &lt;- function(x){
x[1] + 2*x[2] + 3*x[3]
}

# First, generate a sample
X &lt;- SA_sample(500, 3)

# Run sample through test function to get corresponding output for each row
y &lt;- apply(X, 1, testfunc)

# Estimate sensitivity indices using sample
SAinds &lt;- SA_estimate(y, N = 500, d = 3, Nboot = 1000)
SAinds$SensInd
# Notice that total order indices have narrower confidence intervals than first order.

</code></pre>

<hr>
<h2 id='SA_sample'>Generate sample for sensitivity analysis</h2><span id='topic+SA_sample'></span>

<h3>Description</h3>

<p>Generates an input sample for a Monte Carlo estimation of global sensitivity indices. Used in
the <code><a href="#topic+get_sensitivity">get_sensitivity()</a></code> function. The total sample size will be <code class="reqn">N(d+2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SA_sample(N, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SA_sample_+3A_n">N</code></td>
<td>
<p>The number of sample points per dimension.</p>
</td></tr>
<tr><td><code id="SA_sample_+3A_d">d</code></td>
<td>
<p>The dimensionality of the sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a Monte Carlo sample as described e.g. in the <a href="https://onlinelibrary.wiley.com/doi/book/10.1002/9780470725184">Global Sensitivity Analysis: The Primer book</a>.
</p>


<h3>Value</h3>

<p>A matrix with <code class="reqn">N(d+2)</code> rows and <code>d</code> columns.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_sensitivity">get_sensitivity()</a></code> Perform global sensitivity or uncertainty analysis on a COIN.
</p>
</li>
<li> <p><code><a href="#topic+SA_estimate">SA_estimate()</a></code> Estimate sensitivity indices from system output, as a result of input design from SA_sample().
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># sensitivity analysis sample for 3 dimensions with 100 points per dimension
X &lt;- SA_sample(100, 3)

</code></pre>

<hr>
<h2 id='Screen'>Screen units based on data availability</h2><span id='topic+Screen'></span>

<h3>Description</h3>

<p>This is a generic function for screening units/rows based on data availability. See method documentation
for more details:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Screen(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Screen_+3A_x">x</code></td>
<td>
<p>Object to be screened</p>
</td></tr>
<tr><td><code id="Screen_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the now-defunct <code>checkData()</code> from COINr &lt; v1.0.
</p>

<ul>
<li> <p><code><a href="#topic+Screen.data.frame">Screen.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Screen.coin">Screen.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Screen.purse">Screen.purse()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of the same class as <code>x</code>
</p>

<hr>
<h2 id='Screen.coin'>Screen units based on data availability</h2><span id='topic+Screen.coin'></span>

<h3>Description</h3>

<p>Screens units based on a data availability threshold and presence of zeros. Units can be optionally
&quot;forced&quot; to be included or excluded, making exceptions for the data availability threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Screen(
  x,
  dset,
  unit_screen,
  dat_thresh = NULL,
  nonzero_thresh = NULL,
  Force = NULL,
  out2 = "coin",
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Screen.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_dset">dset</code></td>
<td>
<p>The data set to be checked/screened</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_unit_screen">unit_screen</code></td>
<td>
<p>Specifies whether and how to screen units based on data availability or zero values.
</p>

<ul>
<li><p> If set to <code>"byNA"</code>, screens units with data availability below <code>dat_thresh</code>
</p>
</li>
<li><p> If set to <code>"byzeros"</code>, screens units with non-zero values below <code>nonzero_thresh</code>
</p>
</li>
<li><p> If set to <code>"byNAandzeros"</code>, screens units based on either of the previous two criteria being true.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Screen.coin_+3A_dat_thresh">dat_thresh</code></td>
<td>
<p>A data availability threshold (<code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 0&#8288;</code>) used for flagging low data and screening units if <code>unit_screen != "none"</code>. Default 0.66.</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_nonzero_thresh">nonzero_thresh</code></td>
<td>
<p>As <code>dat_thresh</code> but for non-zero values. Defaults to 0.05, i.e. it will flag any units with less than 5% non-zero values (equivalently more than 95% zero values).</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_force">Force</code></td>
<td>
<p>A data frame with any additional countries to force inclusion or exclusion. Required columns <code>uCode</code>
(unit code(s)) and <code>Include</code> (logical: <code>TRUE</code> to include and <code>FALSE</code> to exclude). Specifications here override
exclusion/inclusion based on data rules.</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_out2">out2</code></td>
<td>
<p>Where to output the results. If <code>"COIN"</code> (default for COIN input), appends to updated COIN,
otherwise if <code>"list"</code> outputs to data frame.</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Screened"</code>.</p>
</td></tr>
<tr><td><code id="Screen.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two main criteria of interest are <code>NA</code> values, and zeros. The summary table gives percentages of
<code>NA</code> values for each unit, across indicators, and percentage zero values (<em>as a percentage of non-<code>NA</code> values</em>).
Each unit is flagged as having low data or too many zeros based on thresholds.
</p>
<p>See also <code>vignette("screening")</code>.
</p>


<h3>Value</h3>

<p>An updated coin with data frames showing missing data in <code>.$Analysis</code>, and a new data set <code>.$Data$Screened</code>.
If <code>out2 = "list"</code> wraps missing data stats and screened data set into a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin", quietly = TRUE)

# screen units from raw dset
coin &lt;- Screen(coin, dset = "Raw", unit_screen = "byNA",
               dat_thresh = 0.85, write_to = "Filtered_85pc")

# some details about the coin by calling its print method
coin

</code></pre>

<hr>
<h2 id='Screen.data.frame'>Screen units based on data availability</h2><span id='topic+Screen.data.frame'></span>

<h3>Description</h3>

<p>Screens units (rows) based on a data availability threshold and presence of zeros. Units can be optionally
&quot;forced&quot; to be included or excluded, making exceptions for the data availability threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
Screen(
  x,
  id_col = NULL,
  unit_screen,
  dat_thresh = NULL,
  nonzero_thresh = NULL,
  Force = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Screen.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Screen.data.frame_+3A_id_col">id_col</code></td>
<td>
<p>Name of column of the data frame to be used as the identifier, e.g. normally this would be <code>uCode</code>
for indicator data sets used in coins. This must be specified if <code>Force</code> is specified.</p>
</td></tr>
<tr><td><code id="Screen.data.frame_+3A_unit_screen">unit_screen</code></td>
<td>
<p>Specifies whether and how to screen units based on data availability or zero values.
</p>

<ul>
<li><p> If set to <code>"byNA"</code>, screens units with data availability below <code>dat_thresh</code>
</p>
</li>
<li><p> If set to <code>"byzeros"</code>, screens units with non-zero values below <code>nonzero_thresh</code>
</p>
</li>
<li><p> If set to <code>"byNAandzeros"</code>, screens units based on either of the previous two criteria being true.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Screen.data.frame_+3A_dat_thresh">dat_thresh</code></td>
<td>
<p>A data availability threshold (<code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 0&#8288;</code>) used for flagging low data and screening units if <code>unit_screen != "none"</code>. Default 0.66.</p>
</td></tr>
<tr><td><code id="Screen.data.frame_+3A_nonzero_thresh">nonzero_thresh</code></td>
<td>
<p>As <code>dat_thresh</code> but for non-zero values. Defaults to 0.05, i.e. it will flag any units with less than 5% non-zero values (equivalently more than 95% zero values).</p>
</td></tr>
<tr><td><code id="Screen.data.frame_+3A_force">Force</code></td>
<td>
<p>A data frame with any additional units to force inclusion or exclusion. Required columns <code>uCode</code>
(unit code(s)) and <code>Include</code> (logical: <code>TRUE</code> to include and <code>FALSE</code> to exclude). Specifications here override
exclusion/inclusion based on data rules.</p>
</td></tr>
<tr><td><code id="Screen.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two main criteria of interest are <code>NA</code> values, and zeros. The summary table gives percentages of
<code>NA</code> values for each unit, across indicators, and percentage zero values (<em>as a percentage of non-<code>NA</code> values</em>).
Each unit is flagged as having low data or too many zeros based on thresholds.
</p>
<p>See also <code>vignette("screening")</code>.
</p>


<h3>Value</h3>

<p>Missing data stats and screened data as a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
iData &lt;- ASEM_iData[40:51, c("uCode", "Research", "Pat", "CultServ", "CultGood")]

# screen to 75% data availability (by row)
l_scr &lt;- Screen(iData, unit_screen = "byNA", dat_thresh = 0.75)

# summary of screening
head(l_scr$DataSummary)

</code></pre>

<hr>
<h2 id='Screen.purse'>Screen units based on data availability</h2><span id='topic+Screen.purse'></span>

<h3>Description</h3>

<p>Screens units based on a data availability threshold and presence of zeros. Units can be optionally
&quot;forced&quot; to be included or excluded, making exceptions for the data availability threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Screen(
  x,
  dset,
  unit_screen,
  dat_thresh = NULL,
  nonzero_thresh = NULL,
  Force = NULL,
  write_to = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Screen.purse_+3A_x">x</code></td>
<td>
<p>A purse object</p>
</td></tr>
<tr><td><code id="Screen.purse_+3A_dset">dset</code></td>
<td>
<p>The data set to be checked/screened</p>
</td></tr>
<tr><td><code id="Screen.purse_+3A_unit_screen">unit_screen</code></td>
<td>
<p>Specifies whether and how to screen units based on data availability or zero values.
</p>

<ul>
<li><p> If set to <code>"byNA"</code>, screens units with data availability below <code>dat_thresh</code>
</p>
</li>
<li><p> If set to <code>"byzeros"</code>, screens units with non-zero values below <code>nonzero_thresh</code>
</p>
</li>
<li><p> If set to <code>"byNAandzeros"</code>, screens units based on either of the previous two criteria being true.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Screen.purse_+3A_dat_thresh">dat_thresh</code></td>
<td>
<p>A data availability threshold (<code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;= 0&#8288;</code>) used for flagging low data and screening units if <code>unit_screen != "none"</code>. Default 0.66.</p>
</td></tr>
<tr><td><code id="Screen.purse_+3A_nonzero_thresh">nonzero_thresh</code></td>
<td>
<p>As <code>dat_thresh</code> but for non-zero values. Defaults to 0.05, i.e. it will flag any units with less than 5% non-zero values (equivalently more than 95% zero values).</p>
</td></tr>
<tr><td><code id="Screen.purse_+3A_force">Force</code></td>
<td>
<p>A data frame with any additional countries to force inclusion or exclusion. Required columns <code>uCode</code>
(unit code(s)) and <code>Include</code> (logical: <code>TRUE</code> to include and <code>FALSE</code> to exclude). Specifications here override
exclusion/inclusion based on data rules.</p>
</td></tr>
<tr><td><code id="Screen.purse_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Screened"</code>.</p>
</td></tr>
<tr><td><code id="Screen.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two main criteria of interest are <code>NA</code> values, and zeros. The summary table gives percentages of
<code>NA</code> values for each unit, across indicators, and percentage zero values (<em>as a percentage of non-<code>NA</code> values</em>).
Each unit is flagged as having low data or too many zeros based on thresholds.
</p>
<p>See also <code>vignette("screening")</code>.
</p>


<h3>Value</h3>

<p>An updated purse with coins screened and updated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see vignette("screening") for an example.

</code></pre>

<hr>
<h2 id='signif_df'>Round a data frame to specified significant figures</h2><span id='topic+signif_df'></span>

<h3>Description</h3>

<p>Tiny function just to round down a data frame by significant figures for display in a table, ignoring non-numeric columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_df(df, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_df_+3A_df">df</code></td>
<td>
<p>A data frame to input</p>
</td></tr>
<tr><td><code id="signif_df_+3A_digits">digits</code></td>
<td>
<p>The number of decimal places to round to (default 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, with any numeric columns rounded to the specified amount.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signif_df( as.data.frame(matrix(runif(20),10,2)), digits = 3)


</code></pre>

<hr>
<h2 id='skew'>Calculate skewness</h2><span id='topic+skew'></span>

<h3>Description</h3>

<p>Calculates skewness of the values of a numeric vector. This uses the same definition of skewness as
the &quot;skewness()&quot; function in the &quot;e1071&quot; package where <code>type == 2</code>, which is equivalent to the definition of skewness used in Excel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skew(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skew_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="skew_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A skewness value (scalar).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
skew(x)

</code></pre>

<hr>
<h2 id='Treat'>Treat outliers</h2><span id='topic+Treat'></span>

<h3>Description</h3>

<p>Generic function for treating outliers using a two-step process. See individual method documentation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Treat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Treat_+3A_x">x</code></td>
<td>
<p>Object to be treated</p>
</td></tr>
<tr><td><code id="Treat_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+Treat.numeric">Treat.numeric()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Treat.data.frame">Treat.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Treat.coin">Treat.coin()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Treat.purse">Treat.purse()</a></code>
</p>
</li></ul>

<p>See also <code>vignette("treat")</code>.
</p>
<p>This function replaces the now-defunct <code>treat()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>Treated object plus details.
</p>

<hr>
<h2 id='Treat.coin'>Treat a data set in a coin for outliers</h2><span id='topic+Treat.coin'></span>

<h3>Description</h3>

<p>Operates a two-stage data treatment process on the data set specified by <code>dset</code>, based on two data treatment functions, and a pass/fail
function which detects outliers. The method of data treatment can be either specified by the <code>global_specs</code> argument (which applies
the same specifications to all indicators in the specified data set), or else (additionally) by the <code>indiv_specs</code> argument which allows different
methods to be applied for each indicator. See details. For a simpler function for data treatment, see the wrapper function <code><a href="#topic+qTreat">qTreat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coin'
Treat(
  x,
  dset,
  global_specs = NULL,
  indiv_specs = NULL,
  combine_treat = FALSE,
  out2 = "coin",
  write_to = NULL,
  write2log = TRUE,
  disable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Treat.coin_+3A_x">x</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_dset">dset</code></td>
<td>
<p>A named data set available in <code>.$Data</code></p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_global_specs">global_specs</code></td>
<td>
<p>A list specifying the treatment to apply to all columns. This will be applied to all columns, except any
that are specified in the <code>indiv_specs</code> argument. Alternatively, set to <code>"none"</code> to apply no treatment. See details.</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_indiv_specs">indiv_specs</code></td>
<td>
<p>A list specifying any individual treatment to apply to specific columns, overriding <code>global_specs</code>
for those columns. See details.</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_combine_treat">combine_treat</code></td>
<td>
<p>By default, if <code>f1</code> fails to pass <code>f_pass</code>, then <code>f2</code> is applied to the original <code>x</code>,
rather than the treated output of <code>f1</code>. If <code>combine_treat = TRUE</code>, <code>f2</code> will instead be applied to the output
of <code>f1</code>, so the two treatments will be combined.</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_out2">out2</code></td>
<td>
<p>The type of function output: either <code>"coin"</code> to return an updated coin, or <code>"list"</code> to return a
list with treated data and treatment details.</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Treated"</code>.</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_write2log">write2log</code></td>
<td>
<p>Logical: if <code>FALSE</code>, the arguments of this function are not written to the coin log, so this
function will not be invoked when regenerating. Recommend to keep <code>TRUE</code> unless you have a good reason to do otherwise.</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_disable">disable</code></td>
<td>
<p>Logical: if <code>TRUE</code> will disable data treatment completely and write the unaltered data set. This option is mainly useful
in sensitivity and uncertainty analysis (to test the effect of turning imputation on/off).</p>
</td></tr>
<tr><td><code id="Treat.coin_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated coin with a new data set <code>.Data$Treated</code> added, plus analysis information in
<code>.$Analysis$Treated</code>.
</p>


<h3>Global specifications</h3>

<p>If the same method of data treatment should be applied to all indicators, use the <code>global_specs</code> argument. This argument takes a structured
list which looks like this:
</p>
<div class="sourceCode"><pre>global_specs = list(f1 = .,
                    f1_para = list(.),
                    f2 = .,
                    f2_para = list(.),
                    f_pass = .,
                    f_pass_para = list()
                    )
</pre></div>
<p>The entries in this list correspond to arguments in <code><a href="#topic+Treat.numeric">Treat.numeric()</a></code>, and the meanings of each are also described in more detail here
below. In brief, <code>f1</code> is the name of a function to apply at the first round of data treatment, <code>f1_para</code> is a list of any additional
parameters to pass to <code>f1</code>, <code>f2</code> and <code>f2_para</code> are equivalently the function name and parameters of the second round of data treatment, and
<code>f_pass</code> and <code>f_pass_para</code> are the function and additional arguments to check for the existence of outliers.
</p>
<p>The default values for <code>global_specs</code> are as follows:
</p>
<div class="sourceCode"><pre>global_specs = list(f1 = "winsorise",
                     f1_para = list(na.rm = TRUE,
                                    winmax = 5,
                                    skew_thresh = 2,
                                    kurt_thresh = 3.5,
                                    force_win = FALSE),
                     f2 = "log_CT",
                     f2_para = list(na.rm = TRUE),
                     f_pass = "check_SkewKurt",
                     f_pass_para = list(na.rm = TRUE,
                                        skew_thresh = 2,
                                        kurt_thresh = 3.5))
</pre></div>
<p>This shows that by default (i.e. if <code>global_specs</code> is not specified), each indicator is checked for outliers by the <code><a href="#topic+check_SkewKurt">check_SkewKurt()</a></code> function, which
uses skew and kurtosis thresholds as its parameters. Then, if outliers exist, the first function <code><a href="#topic+winsorise">winsorise()</a></code> is applied, which also
uses skew and kurtosis parameters, as well as a maximum number of winsorised points. If the Winsorisation function does not satisfy
<code>f_pass</code>, the <code><a href="#topic+log_CT">log_CT()</a></code> function is invoked.
</p>
<p>To change the global specifications, you don't have to supply the whole list. If, for example, you are happy with all the defaults but
want to simply change the maximum number of Winsorised points, you could specify e.g. <code>global_specs = list(f1_para = list(winmax = 3))</code>.
In other words, a subset of the list can be specified, as long as the structure of the list is correct.
</p>


<h3>Individual specifications</h3>

<p>The <code>indiv_specs</code> argument allows different specifications for each indicator. This is done by wrapping multiple lists of the format of the
list described in <code>global_specs</code> into one single list, named according to the column names of <code>x</code>. For example, if the date set has indicators with codes
&quot;x1&quot;, &quot;x2&quot; and &quot;x3&quot;, we could specify individual treatment as follows:
</p>
<div class="sourceCode"><pre>indiv_specs = list(x1 = list(.),
                   x2 = list(.)
                   x3 = list(.))
</pre></div>
<p>where each <code>list(.)</code> is a specifications list of the same format as <code>global_specs</code>. Any indicators that are <em>not</em> named in <code>indiv_specs</code> are
treated using the specifications from <code>global_specs</code> (which will be the defaults if it is not specified). As with <code>global_specs</code>,
a subset of the <code>global_specs</code> list may be specified for
each entry. Additionally, as a special case, specifying a list entry as e.g. <code>x1 = "none"</code> will apply no data treatment to the indicator &quot;x1&quot;. See
<code>vignette("treat")</code> for examples of individual treatment.
</p>


<h3>Function methodology</h3>

<p>This function is set up to allow any functions to be passed as the
data treatment functions (<code>f1</code> and <code>f2</code>), as well as any function to be passed as the outlier detection
function <code>f_pass</code>, as specified in the <code>global_specs</code> and <code>indiv_specs</code> arguments.
</p>
<p>The arrangement of this function is inspired by a fairly standard data treatment process applied to
indicators, which consists of checking skew and kurtosis, then if the criteria are not met, applying
Winsorisation up to a specified limit. Then if Winsorisation still does not bring skew and kurtosis
within limits, applying a nonlinear transformation such as log or Box-Cox.
</p>
<p>This function generalises this process by using the following general steps:
</p>

<ol>
<li><p> Check if variable passes or fails using <code>f_pass</code>
</p>
</li>
<li><p> If <code>f_pass</code> returns <code>FALSE</code>, apply <code>f1</code>, else return <code>x</code> unmodified
</p>
</li>
<li><p> Check again using *<code>f_pass</code>
</p>
</li>
<li><p> If <code>f_pass</code> still returns <code>FALSE</code>, apply <code>f2</code>
</p>
</li>
<li><p> Return the modified <code>x</code> as well as other information.
</p>
</li></ol>

<p>For the &quot;typical&quot; case described above <code>f1</code> is a Winsorisation function, <code>f2</code> is a nonlinear transformation
and <code>f_pass</code> is a skew and kurtosis check. Parameters can be passed to each of these three functions in
a named list, for example to specify a maximum number of points to Winsorise, or Box-Cox parameters, or anything
else. The constraints are that:
</p>

<ul>
<li><p> All of <code>f1</code>, <code>f2</code> and <code>f_pass</code> must follow the format <code style="white-space: pre;">&#8288;function(x, f_para)&#8288;</code>, where <code>x</code> is a
numerical vector, and <code>f_para</code> is a list of other function parameters to be passed to the function, which
is specified by <code>f1_para</code> for <code>f1</code> and similarly for the other functions. If the function has no parameters
other than <code>x</code>, then <code>f_para</code> can be omitted.
</p>
</li>
<li> <p><code>f1</code> and <code>f2</code> should return either a list with <code>.$x</code> as the modified numerical vector, and any other information
to be attached to the list, OR, simply <code>x</code> as the only output.
</p>
</li>
<li> <p><code>f_pass</code> must return a logical value, where <code>TRUE</code> indicates that the <code>x</code> passes the criteria (and
therefore doesn't need any (more) treatment), and <code>FALSE</code> means that it fails to meet the criteria.
</p>
</li></ul>

<p>See also <code>vignette("treat")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build example coin
coin &lt;- build_example_coin(up_to = "new_coin")

# treat raw data set
coin &lt;- Treat(coin, dset = "Raw")

# summary of treatment for each indicator
head(coin$Analysis$Treated$Dets_Table)

</code></pre>

<hr>
<h2 id='Treat.data.frame'>Treat a data frame for outliers</h2><span id='topic+Treat.data.frame'></span>

<h3>Description</h3>

<p>Operates a two-stage data treatment process, based on two data treatment functions, and a pass/fail
function which detects outliers. The method of data treatment can be either specified by the <code>global_specs</code> argument (which applies
the same specifications to all columns in <code>x</code>), or else (additionally) by the <code>indiv_specs</code> argument which allows different
methods to be applied for each column. See details. For a simpler function for data treatment, see the wrapper function <code><a href="#topic+qTreat">qTreat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
Treat(x, global_specs = NULL, indiv_specs = NULL, combine_treat = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Treat.data.frame_+3A_x">x</code></td>
<td>
<p>A data frame. Can have both numeric and non-numeric columns.</p>
</td></tr>
<tr><td><code id="Treat.data.frame_+3A_global_specs">global_specs</code></td>
<td>
<p>A list specifying the treatment to apply to all columns. This will be applied to all columns, except any
that are specified in the <code>indiv_specs</code> argument. Alternatively, set to <code>"none"</code> to apply no treatment. See details.</p>
</td></tr>
<tr><td><code id="Treat.data.frame_+3A_indiv_specs">indiv_specs</code></td>
<td>
<p>A list specifying any individual treatment to apply to specific columns, overriding <code>global_specs</code>
for those columns. See details.</p>
</td></tr>
<tr><td><code id="Treat.data.frame_+3A_combine_treat">combine_treat</code></td>
<td>
<p>By default, if <code>f1</code> fails to pass <code>f_pass</code>, then <code>f2</code> is applied to the original <code>x</code>,
rather than the treated output of <code>f1</code>. If <code>combine_treat = TRUE</code>, <code>f2</code> will instead be applied to the output
of <code>f1</code>, so the two treatments will be combined.</p>
</td></tr>
<tr><td><code id="Treat.data.frame_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A treated data frame of data
</p>


<h3>Global specifications</h3>

<p>If the same method of data treatment should be applied to all the columns, use the <code>global_specs</code> argument. This argument takes a structured
list which looks like this:
</p>
<div class="sourceCode"><pre>global_specs = list(f1 = .,
                    f1_para = list(.),
                    f2 = .,
                    f2_para = list(.),
                    f_pass = .,
                    f_pass_para = list()
                    )
</pre></div>
<p>The entries in this list correspond to arguments in <code><a href="#topic+Treat.numeric">Treat.numeric()</a></code>, and the meanings of each are also described in more detail here
below. In brief, <code>f1</code> is the name of a function to apply at the first round of data treatment, <code>f1_para</code> is a list of any additional
parameters to pass to <code>f1</code>, <code>f2</code> and <code>f2_para</code> are equivalently the function name and parameters of the second round of data treatment, and
<code>f_pass</code> and <code>f_pass_para</code> are the function and additional arguments to check for the existence of outliers.
</p>
<p>The default values for <code>global_specs</code> are as follows:
</p>
<div class="sourceCode"><pre>global_specs = list(f1 = "winsorise",
                     f1_para = list(na.rm = TRUE,
                                    winmax = 5,
                                    skew_thresh = 2,
                                    kurt_thresh = 3.5,
                                    force_win = FALSE),
                     f2 = "log_CT",
                     f2_para = list(na.rm = TRUE),
                     f_pass = "check_SkewKurt",
                     f_pass_para = list(na.rm = TRUE,
                                        skew_thresh = 2,
                                        kurt_thresh = 3.5))
</pre></div>
<p>This shows that by default (i.e. if <code>global_specs</code> is not specified), each column is checked for outliers by the <code><a href="#topic+check_SkewKurt">check_SkewKurt()</a></code> function, which
uses skew and kurtosis thresholds as its parameters. Then, if outliers exist, the first function <code><a href="#topic+winsorise">winsorise()</a></code> is applied, which also
uses skew and kurtosis parameters, as well as a maximum number of winsorised points. If the Winsorisation function does not satisfy
<code>f_pass</code>, the <code><a href="#topic+log_CT">log_CT()</a></code> function is invoked.
</p>
<p>To change the global specifications, you don't have to supply the whole list. If, for example, you are happy with all the defaults but
want to simply change the maximum number of Winsorised points, you could specify e.g. <code>global_specs = list(f1_para = list(winmax = 3))</code>.
In other words, a subset of the list can be specified, as long as the structure of the list is correct.
</p>


<h3>Individual specifications</h3>

<p>The <code>indiv_specs</code> argument allows different specifications for each column in <code>x</code>. This is done by wrapping multiple lists of the format of the
list described in <code>global_specs</code> into one single list, named according to the column names of <code>x</code>. For example, if <code>x</code> has column names
&quot;x1&quot;, &quot;x2&quot; and &quot;x3&quot;, we could specify individual treatment as follows:
</p>
<div class="sourceCode"><pre>indiv_specs = list(x1 = list(.),
                   x2 = list(.)
                   x3 = list(.))
</pre></div>
<p>where each <code>list(.)</code> is a specifications list of the same format as <code>global_specs</code>. Any columns that are not named in <code>indiv_specs</code> are
treated using the specifications from <code>global_specs</code> (which will be the defaults if it is not specified). As with <code>global_specs</code>,
a subset of the <code>global_specs</code> list may be specified for
each entry. Additionally, as a special case, specifying a list entry as e.g. <code>x1 = "none"</code> will apply no data treatment to the column &quot;x1&quot;. See
<code>vignette("treat")</code> for examples of individual treatment.
</p>


<h3>Function methodology</h3>

<p>This function is set up to allow any functions to be passed as the
data treatment functions (<code>f1</code> and <code>f2</code>), as well as any function to be passed as the outlier detection
function <code>f_pass</code>, as specified in the <code>global_specs</code> and <code>indiv_specs</code> arguments.
</p>
<p>The arrangement of this function is inspired by a fairly standard data treatment process applied to
indicators, which consists of checking skew and kurtosis, then if the criteria are not met, applying
Winsorisation up to a specified limit. Then if Winsorisation still does not bring skew and kurtosis
within limits, applying a nonlinear transformation such as log or Box-Cox.
</p>
<p>This function generalises this process by using the following general steps:
</p>

<ol>
<li><p> Check if variable passes or fails using <code>f_pass</code>
</p>
</li>
<li><p> If <code>f_pass</code> returns <code>FALSE</code>, apply <code>f1</code>, else return <code>x</code> unmodified
</p>
</li>
<li><p> Check again using *<code>f_pass</code>
</p>
</li>
<li><p> If <code>f_pass</code> still returns <code>FALSE</code>, apply <code>f2</code>
</p>
</li>
<li><p> Return the modified <code>x</code> as well as other information.
</p>
</li></ol>

<p>For the &quot;typical&quot; case described above <code>f1</code> is a Winsorisation function, <code>f2</code> is a nonlinear transformation
and <code>f_pass</code> is a skew and kurtosis check. Parameters can be passed to each of these three functions in
a named list, for example to specify a maximum number of points to Winsorise, or Box-Cox parameters, or anything
else. The constraints are that:
</p>

<ul>
<li><p> All of <code>f1</code>, <code>f2</code> and <code>f_pass</code> must follow the format <code style="white-space: pre;">&#8288;function(x, f_para)&#8288;</code>, where <code>x</code> is a
numerical vector, and <code>f_para</code> is a list of other function parameters to be passed to the function, which
is specified by <code>f1_para</code> for <code>f1</code> and similarly for the other functions. If the function has no parameters
other than <code>x</code>, then <code>f_para</code> can be omitted.
</p>
</li>
<li> <p><code>f1</code> and <code>f2</code> should return either a list with <code>.$x</code> as the modified numerical vector, and any other information
to be attached to the list, OR, simply <code>x</code> as the only output.
</p>
</li>
<li> <p><code>f_pass</code> must return a logical value, where <code>TRUE</code> indicates that the <code>x</code> passes the criteria (and
therefore doesn't need any (more) treatment), and <code>FALSE</code> means that it fails to meet the criteria.
</p>
</li></ul>

<p>See also <code>vignette("treat")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># select three indicators
df1 &lt;- ASEM_iData[c("Flights", "Goods", "Services")]

# treat the data frame using defaults
l_treat &lt;- Treat(df1)

# details of data treatment for each column
l_treat$Dets_Table

</code></pre>

<hr>
<h2 id='Treat.numeric'>Treat a numeric vector for outliers</h2><span id='topic+Treat.numeric'></span>

<h3>Description</h3>

<p>Operates a two-stage data treatment process, based on two data treatment functions, and a pass/fail
function which detects outliers. This function is set up to allow any functions to be passed as the
data treatment functions (<code>f1</code> and <code>f2</code>), as well as any function to be passed as the outlier detection
function <code>f_pass</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
Treat(
  x,
  f1,
  f1_para = NULL,
  f2 = NULL,
  f2_para = NULL,
  f_pass,
  f_pass_para = NULL,
  combine_treat = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Treat.numeric_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_f1">f1</code></td>
<td>
<p>First stage data treatment function e.g. as a string.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_f1_para">f1_para</code></td>
<td>
<p>First stage data treatment function parameters as a named list.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_f2">f2</code></td>
<td>
<p>First stage data treatment function as a string.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_f2_para">f2_para</code></td>
<td>
<p>First stage data treatment function parameters as a named list.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_f_pass">f_pass</code></td>
<td>
<p>A string specifying an outlier detection function - see details. Default <code>"check_SkewKurt"</code></p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_f_pass_para">f_pass_para</code></td>
<td>
<p>Any further arguments to pass to <code>f_pass()</code>, as a named list.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_combine_treat">combine_treat</code></td>
<td>
<p>By default, if <code>f1</code> fails to pass <code>f_pass</code>, then <code>f2</code> is applied to the original <code>x</code>,
rather than the treated output of <code>f1</code>. If <code>combine_treat = TRUE</code>, <code>f2</code> will instead be applied to the output
of <code>f1</code>, so the two treatments will be combined.</p>
</td></tr>
<tr><td><code id="Treat.numeric_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arrangement of this function is inspired by a fairly standard data treatment process applied to
indicators, which consists of checking skew and kurtosis, then if the criteria are not met, applying
Winsorisation up to a specified limit. Then if Winsorisation still does not bring skew and kurtosis
within limits, applying a nonlinear transformation such as log or Box-Cox.
</p>
<p>This function generalises this process by using the following general steps:
</p>

<ol>
<li><p> Check if variable passes or fails using <code>f_pass</code>
</p>
</li>
<li><p> If <code>f_pass</code> returns <code>FALSE</code>, apply <code>f1</code>, else return <code>x</code> unmodified
</p>
</li>
<li><p> Check again using *<code>f_pass</code>
</p>
</li>
<li><p> If <code>f_pass</code> still returns <code>FALSE</code>, apply <code>f2</code> (by default to the original <code>x</code>, see <code>combine_treat</code>
parameter)
</p>
</li>
<li><p> Return the modified <code>x</code> as well as other information.
</p>
</li></ol>

<p>For the &quot;typical&quot; case described above <code>f1</code> is a Winsorisation function, <code>f2</code> is a nonlinear transformation
and <code>f_pass</code> is a skew and kurtosis check. Parameters can be passed to each of these three functions in
a named list, for example to specify a maximum number of points to Winsorise, or Box-Cox parameters, or anything
else. The constraints are that:
</p>

<ul>
<li><p> All of <code>f1</code>, <code>f2</code> and <code>f_pass</code> must follow the format <code style="white-space: pre;">&#8288;function(x, f_para)&#8288;</code>, where <code>x</code> is a
numerical vector, and <code>f_para</code> is a list of other function parameters to be passed to the function, which
is specified by <code>f1_para</code> for <code>f1</code> and similarly for the other functions. If the function has no parameters
other than <code>x</code>, then <code>f_para</code> can be omitted.
</p>
</li>
<li> <p><code>f1</code> and <code>f2</code> should return either a list with <code>.$x</code> as the modified numerical vector, and any other information
to be attached to the list, OR, simply <code>x</code> as the only output.
</p>
</li>
<li> <p><code>f_pass</code> must return a logical value, where <code>TRUE</code> indicates that the <code>x</code> passes the criteria (and
therefore doesn't need any (more) treatment), and <code>FALSE</code> means that it fails to meet the criteria.
</p>
</li></ul>

<p>See also <code>vignette("treat")</code>.
</p>


<h3>Value</h3>

<p>A treated vector of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># numbers between 1 and 10
x &lt;- 1:10

# two outliers
x &lt;- c(x, 30, 100)

# check whether passes skew/kurt test
check_SkewKurt(x)

# treat using winsorisation
l_treat &lt;- Treat(x, f1 = "winsorise", f1_para = list(winmax = 2),
                 f_pass = "check_SkewKurt")

# plot original against treated
plot(x, l_treat$x)

</code></pre>

<hr>
<h2 id='Treat.purse'>Treat a purse of coins for outliers</h2><span id='topic+Treat.purse'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+Treat.coin">Treat.coin()</a></code> for each coin in the purse. See the documentation of that function for
details. See also <code>vignette("treat")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'purse'
Treat(
  x,
  dset,
  global_specs = NULL,
  indiv_specs = NULL,
  combine_treat = FALSE,
  write_to = NULL,
  disable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Treat.purse_+3A_x">x</code></td>
<td>
<p>A purse object</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_dset">dset</code></td>
<td>
<p>The data set to treat in each coin.</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_global_specs">global_specs</code></td>
<td>
<p>Default specifications. See details in <code><a href="#topic+Treat.coin">Treat.coin()</a></code>.</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_indiv_specs">indiv_specs</code></td>
<td>
<p>Individual specifications. See details in <code><a href="#topic+Treat.coin">Treat.coin()</a></code>.</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_combine_treat">combine_treat</code></td>
<td>
<p>By default, if <code>f1</code> fails to pass <code>f_pass</code>, then <code>f2</code> is applied to the original <code>x</code>,
rather than the treated output of <code>f1</code>. If <code>combine_treat = TRUE</code>, <code>f2</code> will instead be applied to the output
of <code>f1</code>, so the two treatments will be combined.</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_write_to">write_to</code></td>
<td>
<p>If specified, writes the aggregated data to <code>.$Data[[write_to]]</code>. Default <code>write_to = "Treated"</code>.</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_disable">disable</code></td>
<td>
<p>Logical: if <code>TRUE</code> will disable data treatment completely and write the unaltered data set. This option is mainly useful
in sensitivity and uncertainty analysis (to test the effect of turning imputation on/off).</p>
</td></tr>
<tr><td><code id="Treat.purse_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated purse with new treated data sets added at <code>.$Data$Treated</code> in each coin, plus
analysis information at <code>.$Analysis$Treated</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See `vignette("treat")`.
</code></pre>

<hr>
<h2 id='ucodes_to_unames'>Convert uCodes to uNames</h2><span id='topic+ucodes_to_unames'></span>

<h3>Description</h3>

<p>Convert uCodes to uNames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ucodes_to_unames(coin, uCodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ucodes_to_unames_+3A_coin">coin</code></td>
<td>
<p>A coin</p>
</td></tr>
<tr><td><code id="ucodes_to_unames_+3A_ucodes">uCodes</code></td>
<td>
<p>A vector of uCodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of uNames
</p>

<hr>
<h2 id='winsorise'>Winsorise a vector</h2><span id='topic+winsorise'></span>

<h3>Description</h3>

<p>Follows a &quot;standard&quot; Winsorisation approach: points are successively Winsorised in order to bring
skew and kurtosis thresholds within specified limits. Specifically, aims to bring absolute skew to
below a threshold (default 2.25) and kurtosis below another threshold (default 3.5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsorise(
  x,
  na.rm = FALSE,
  winmax = 5,
  skew_thresh = 2,
  kurt_thresh = 3.5,
  force_win = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsorise_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="winsorise_+3A_na.rm">na.rm</code></td>
<td>
<p>Set <code>TRUE</code> to remove <code>NA</code> values, otherwise returns <code>NA</code>.</p>
</td></tr>
<tr><td><code id="winsorise_+3A_winmax">winmax</code></td>
<td>
<p>Maximum number of points to Winsorise. Default 5. Set <code>NULL</code> to have no limit.</p>
</td></tr>
<tr><td><code id="winsorise_+3A_skew_thresh">skew_thresh</code></td>
<td>
<p>A threshold for absolute skewness (positive). Default 2.25.</p>
</td></tr>
<tr><td><code id="winsorise_+3A_kurt_thresh">kurt_thresh</code></td>
<td>
<p>A threshold for kurtosis. Default 3.5.</p>
</td></tr>
<tr><td><code id="winsorise_+3A_force_win">force_win</code></td>
<td>
<p>Logical: if <code>TRUE</code>, forces winsorisation up to winmax (regardless of skew/kurt).
Default <code>FALSE</code>. Note - this option should be used with care because the direction of Winsorisation
is based on the direction of skew. Successively Winsorising can switch the direction of skew and hence
the direction of Winsorisation, which may not produce the expected behaviour.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Winsorisation here is defined as reassigning the point with the highest/lowest value with the value of the
next highest/lowest point. Whether to Winsorise at the high or low end of the scale is decided by the direction
of the skewness of <code>x</code>.
</p>
<p>This function replaces the now-defunct <code>coin_win()</code> from COINr &lt; v1.0.
</p>


<h3>Value</h3>

<p>A list containing winsorised data, number of winsorised points, and the individual points that
were treated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># numbers between 1 and 10
x &lt;- 1:10

# two outliers
x &lt;- c(x, 30, 100)

# winsorise
l_win &lt;- winsorise(x, skew_thresh = 2, kurt_thresh = 3.5)

# see treated vector, number of winsorised points and details
l_win

</code></pre>

<hr>
<h2 id='WorldDenoms'>World denomination data</h2><span id='topic+WorldDenoms'></span>

<h3>Description</h3>

<p>A small selection of common denominator indicators, which includes GDP, Population, Area, GDP per capita
and income group. All data sourced from the World Bank as of Feb 2021 (data is typically from 2019). Note that this is
intended as example data, and it would be a good idea to use updated data from the World Bank when needed. In this
data set, country names have been altered slightly so as to include no accents - this is simply to make it more
portable between distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WorldDenoms
</code></pre>


<h3>Format</h3>

<p>A data frame with 249 rows and 7 variables.
</p>


<h3>Source</h3>

<p><a href="https://data.worldbank.org/">https://data.worldbank.org/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
