<!DOCTYPE html><html><head><title>Help for package bigsparser</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigsparser}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[,SFBM,ANY,ANY,ANY-method'><p>Accessor methods for class <code>SFBM</code>.</p></a></li>
<li><a href='#bigsparser-package'><p>bigsparser: Sparse Matrix Format with Data on Disk</p></a></li>
<li><a href='#dim,SFBM-method'><p>Dimension and type methods for class <code>SFBM</code>.</p></a></li>
<li><a href='#SFBM_compact-class'><p>Class SFBM_compact</p></a></li>
<li><a href='#SFBM-class'><p>Class SFBM</p></a></li>
<li><a href='#sp_prodVec'><p>Products with a vector</p></a></li>
<li><a href='#sp_solve_sym'><p>Solver for symmetric SFBM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sparse Matrix Format with Data on Disk</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide a sparse matrix format with data stored on disk, to be
    used in both R and C++. This is intended for more efficient use of sparse 
    data in C++ and also when parallelizing, since data on disk does not need
    copying. Only a limited number of features will be implemented. For now,
    conversion can be performed from a 'dgCMatrix' or a 'dsCMatrix' from R 
    package 'Matrix'. A new compact format is also now available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/privefl/bigsparser">https://github.com/privefl/bigsparser</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/privefl/bigsparser/issues">https://github.com/privefl/bigsparser/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, rmio</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, bigassertr, methods, Matrix, rmio (&ge; 0.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-06 06:25:00 UTC; au639593</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Privé [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Privé &lt;florian.prive.21@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-07 04:30:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+2CSFBM+2CANY+2CANY+2CANY-method'>Accessor methods for class <code>SFBM</code>.</h2><span id='topic++5B+2CSFBM+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CSFBM_compact+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Accessor methods for class <code>SFBM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SFBM,ANY,ANY,ANY'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'SFBM_compact,ANY,ANY,ANY'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSFBM+2B2CANY+2B2CANY+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+SFBM-class">SFBM</a> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSFBM+2B2CANY+2B2CANY+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>A vector of indices (or nothing). You can use positive and negative
indices, and also logical indices (that are recycled).</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSFBM+2B2CANY+2B2CANY+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>A vector of indices (or nothing). You can use positive and negative
indices, and also logical indices (that are recycled).</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSFBM+2B2CANY+2B2CANY+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Not used. Just to make <a href="base.html#topic+nargs">nargs</a> work.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSFBM+2B2CANY+2B2CANY+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>Not implemented; always return a sparse matrix (<code>drop = FALSE</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>spmat &lt;- Matrix::Diagonal(4, 0:3)
spmat[4, 2] &lt;- 5
spmat[1, 4] &lt;- 6
spmat[3, 4] &lt;- 7
spmat

X &lt;- as_SFBM(spmat)
X[1:3, 2:3]
X[, 4]   # parameter drop is not implemented
X[-1, 3:4]

X2 &lt;- as_SFBM(spmat, compact = TRUE)
X2[1:3, 2:3]

</code></pre>

<hr>
<h2 id='bigsparser-package'>bigsparser: Sparse Matrix Format with Data on Disk</h2><span id='topic+bigsparser'></span><span id='topic+bigsparser-package'></span>

<h3>Description</h3>

<p>Provide a sparse matrix format with data stored on disk, to be used in both R and C++. This is intended for more efficient use of sparse data in C++ and also when parallelizing, since data on disk does not need copying. Only a limited number of features will be implemented. For now, conversion can be performed from a 'dgCMatrix' or a 'dsCMatrix' from R package 'Matrix'. A new compact format is also now available.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Privé <a href="mailto:florian.prive.21@gmail.com">florian.prive.21@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/privefl/bigsparser">https://github.com/privefl/bigsparser</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/privefl/bigsparser/issues">https://github.com/privefl/bigsparser/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dim+2CSFBM-method'>Dimension and type methods for class <code>SFBM</code>.</h2><span id='topic+dim+2CSFBM-method'></span><span id='topic+length+2CSFBM-method'></span>

<h3>Description</h3>

<p>Dimension and type methods for class <code>SFBM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SFBM'
dim(x)

## S4 method for signature 'SFBM'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim+2B2CSFBM-method_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+SFBM-class">SFBM</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='SFBM_compact-class'>Class SFBM_compact</h2><span id='topic+SFBM_compact-class'></span><span id='topic+SFBM_compact_RC'></span>

<h3>Description</h3>

<p>A reference class for storing and accessing sparse matrix-like data stored
in files on disk, in a compact format (when non-zero values in columns are
contiguous).
</p>


<h3>Details</h3>

<p>It inherits the fields and methods from class <a href="#topic+SFBM-class">SFBM</a>.
</p>

<hr>
<h2 id='SFBM-class'>Class SFBM</h2><span id='topic+SFBM-class'></span><span id='topic+SFBM_RC'></span><span id='topic+as_SFBM'></span>

<h3>Description</h3>

<p>A reference class for storing and accessing sparse matrix-like data stored
in files on disk.
</p>
<p>Convert a 'dgCMatrix' or 'dsCMatrix' to an SFBM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_SFBM(spmat, backingfile = tempfile(), compact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SFBM-class_+3A_spmat">spmat</code></td>
<td>
<p>A 'dgCMatrix' (non-symmetric sparse matrix of type 'double')
or 'dsCMatrix' (symmetric sparse matrix of type 'double').</p>
</td></tr>
<tr><td><code id="SFBM-class_+3A_backingfile">backingfile</code></td>
<td>
<p>Path to file where to store data. Extension <code>.sbk</code> is
automatically added.</p>
</td></tr>
<tr><td><code id="SFBM-class_+3A_compact">compact</code></td>
<td>
<p>Whether to use a compact format? Default is <code>FALSE</code>.
This is useful when non-zero values in columns are contiguous (or almost).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class SFBM has many fields:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$address&#8288;</code>: address of the external pointer containing the underlying
C++ object to be used as a <code style="white-space: pre;">&#8288;XPtr&lt;SFBM&gt;&#8288;</code> in C++ code
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$extptr&#8288;</code>: (internal) use <code style="white-space: pre;">&#8288;$address&#8288;</code> instead
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$nrow&#8288;</code>: number of rows
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$ncol&#8288;</code>: number of columns
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$nval&#8288;</code>: number of non-zero values
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$p&#8288;</code>: vector of column positions
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$backingfile&#8288;</code> or <code style="white-space: pre;">&#8288;$sbk&#8288;</code>: File with extension 'sbk' that stores the
data of the SFBM
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$rds&#8288;</code>: 'rds' file (that may not exist) corresponding to the 'sbk' file
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$is_saved&#8288;</code>: whether this object is stored in <code style="white-space: pre;">&#8288;$rds&#8288;</code>?
</p>
</li></ul>

<p>And some methods:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$save()&#8288;</code>: Save the SFBM object in <code style="white-space: pre;">&#8288;$rds&#8288;</code>. Returns the SFBM.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$add_columns()&#8288;</code>: Add new columns from a 'dgCMatrix' or a 'dsCMatrix'.
</p>
</li></ul>



<h3>Value</h3>

<p>The new <a href="#topic+SFBM-class">SFBM</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spmat2 &lt;- Matrix::Diagonal(4, 0:3)
spmat2[4, 2] &lt;- 5
spmat2[1, 4] &lt;- 6
spmat2[3, 4] &lt;- 7
spmat2

# Stores all (i, x) for x != 0
(X2 &lt;- as_SFBM(spmat2))
matrix(readBin(X2$sbk, what = double(), n = 100), 2)

# Stores only x, but all (even the zero ones) from first to last being not 0
(X3 &lt;- as_SFBM(spmat2, compact = TRUE))
X3$first_i
readBin(X3$sbk, what = double(), n = 100)
</code></pre>

<hr>
<h2 id='sp_prodVec'>Products with a vector</h2><span id='topic+sp_prodVec'></span><span id='topic+sp_cprodVec'></span>

<h3>Description</h3>

<p>Products between an <a href="#topic+SFBM-class">SFBM</a> and a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_prodVec(X, y)

sp_cprodVec(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_prodVec_+3A_x">X</code></td>
<td>
<p>An <a href="#topic+SFBM-class">SFBM</a>.</p>
</td></tr>
<tr><td><code id="sp_prodVec_+3A_y">y</code></td>
<td>
<p>A vector of same size of the number of columns of <code>X</code> for
<code>sp_prodVec()</code> abd as the number of rows of <code>X</code> for <code>sp_cprodVec()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sp_prodVec()</code>: the vector which is equivalent to <code>X %*% y</code>
if <code>X</code> was a dgCMatrix.
</p>
</li>
<li> <p><code>sp_cprodVec()</code>: the vector which is equivalent to <code>Matrix::crossprod(X, y)</code>
if <code>X</code> was a dgCMatrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>spmat &lt;- Matrix::rsparsematrix(1000, 1000, 0.01)
X &lt;- as_SFBM(spmat)
sp_prodVec(X, rep(1, 1000))
sp_cprodVec(X, rep(1, 1000))

</code></pre>

<hr>
<h2 id='sp_solve_sym'>Solver for symmetric SFBM</h2><span id='topic+sp_solve_sym'></span>

<h3>Description</h3>

<p>Solve Ax=b where A is a symmetric SFBM, and b is a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_solve_sym(
  A,
  b,
  add_to_diag = rep(0, ncol(A)),
  tol = 1e-10,
  maxiter = 10 * ncol(A)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_solve_sym_+3A_a">A</code></td>
<td>
<p>A symmetric <a href="#topic+SFBM-class">SFBM</a>.</p>
</td></tr>
<tr><td><code id="sp_solve_sym_+3A_b">b</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="sp_solve_sym_+3A_add_to_diag">add_to_diag</code></td>
<td>
<p>Vector (or single value) to <em>virtually</em> add to
the diagonal of <code>A</code>. Default is 0s.</p>
</td></tr>
<tr><td><code id="sp_solve_sym_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence. Default is <code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="sp_solve_sym_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector x, solution of Ax=b.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
spmat &lt;- Matrix::rsparsematrix(N, N, 0.01, symmetric = TRUE)
X &lt;- bigsparser::as_SFBM(as(spmat, "dgCMatrix"))
b &lt;- runif(N)

test &lt;- tryCatch(as.vector(Matrix::solve(spmat, b)), error = function(e) print(e))
test2 &lt;- tryCatch(sp_solve_sym(X, b), error = function(e) print(e))

test3 &lt;- as.vector(Matrix::solve(spmat + Matrix::Diagonal(N, 1:N), b))
test4 &lt;- sp_solve_sym(X, b, add_to_diag = 1:N)
all.equal(test3, test4)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
