<!DOCTYPE html><html><head><title>Help for package FunWithNumbers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FunWithNumbers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aliquot'>
<p>Generate the Aliquot sequence.</p></a></li>
<li><a href='#benprob'>
<p>Generate random numbers based on the Benford distribution</p></a></li>
<li><a href='#bestFrac'>
<p>Generate a fraction close to the input value.</p></a></li>
<li><a href='#bpp'>
<p>Function which calculates pi, or other irrationals,  using the BaileyBorweinPlouffe formula  ~~</p></a></li>
<li><a href='#collatz'>
<p>Test the Collatz Conjecture. ~~</p></a></li>
<li><a href='#FunWithNumbers-package'>
<p>Fun with Fractions and Number Sequences</p></a></li>
<li><a href='#juggatz'>
<p>Function which calculates the &quot;Juggler&quot; sequence ~~</p></a></li>
<li><a href='#morris'>
<p>Generate the Morris sequence</p></a></li>
<li><a href='#preciseNumbersAsChar'>
<p>High-precision values for some common constants, in character strings.</p></a></li>
<li><a href='#sptable'>
<p>Calculate the number of unique values in the cross-table of sums and products for the input set of numbers</p></a></li>
<li><a href='#vaneck'>
<p>Generate a sequence 'invented' by Jan Ritsema Van Eck</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fun with Fractions and Number Sequences</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of toys to do things like generate Collatz sequences, convert a fraction to "continued fraction" form, calculate a fraction which is a close approximation to some value (e.g., 22/7 or 355/113 for pi), and so on.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rmpfr, gmp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 14:55:25 UTC; cgw</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Witthoft [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Witthoft &lt;cellocgw@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 17:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aliquot'>
Generate the Aliquot sequence.
</h2><span id='topic+aliquot'></span>

<h3>Description</h3>

<p>Each term in the aliquot sequence is generated by summing all proper divisors of the previous term. The value &quot;1&quot; is included in this collection of divisors. 
In number theory, aliquot is closely related to terms such as &quot;sociable&quot; and &quot;amicable&quot; numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aliquot(x, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aliquot_+3A_x">x</code></td>
<td>

<p>An integer or a <code>bigz</code> integer to start the desired sequence
</p>
</td></tr>
<tr><td><code id="aliquot_+3A_maxiter">maxiter</code></td>
<td>

<p>Set a limit on the number of terms to calculate. See Details for reasons why to do so. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While many aliquot sequences terminate in the values c(prime_number, 1, 0), many numbers drop into a short loop or a repeating value (perfect numbers do this).  If the sequence repeats or terminates, the sequence is returned. If either <code>maxiter</code> is reached or the sequence drops into a loop (and thus <code>maxiter</code> will be triggered), a warning notice is generated and the sequence so far is returned. 
</p>


<h3>Value</h3>

<p>A vector of <code>bigz</code> integers ...
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 

</p>


<h3>Examples</h3>

<pre><code class='language-R'>aliquot(20)
# 20 22 14 10 8  7  1
aliquot (95)
# repeats '6' forever
# 95 25 6  6
</code></pre>

<hr>
<h2 id='benprob'>
Generate random numbers based on the Benford distribution
</h2><span id='topic+benprob'></span>

<h3>Description</h3>

<p>This function produces numbers whose distribution is based on  Benford's Law of the occurrence of the values 1 through 9 in the first digit of numbers.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benprob(numsamp = 100, numbase = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="benprob_+3A_numsamp">numsamp</code></td>
<td>

<p>How many values to generate.
</p>
</td></tr>
<tr><td><code id="benprob_+3A_numbase">numbase</code></td>
<td>

<p>Specify the base system (binary, octal, decimal, or whatever is desired) in which to apply the Benford distribution.  The default is &quot;10,&quot; i.e. decimal. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Benford's Law,&quot; <a href="https://en.wikipedia.org/wiki/Benford%27s_law">https://en.wikipedia.org/wiki/Benford%27s_law</a> can be used to assess the &quot;true&quot; randomness of demographic data. Probably its most well-known use has been to detect fraudulent patterns in voting and investment returns claimed by various fund operators.  The probability function is <code>prob(d) = log(d+1) - log(d)</code>, where <code>d</code> can take on the values 1:(log_base_in_use -1) .The data generated with this function can be used to calculate various statistics such as variance, skew, etc., which can then be compared with the real-world sample set being analyzed.
</p>


<h3>Value</h3>

<p>A vector of random values.
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Benford%27s_law">https://en.wikipedia.org/wiki/Benford%27s_law</a>
<a href="https://projecteuclid.org/euclid.ss/1177009869/">https://projecteuclid.org/euclid.ss/1177009869/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samps &lt;- benprob(1000)
 sd(samps)
 hist(samps)
</code></pre>

<hr>
<h2 id='bestFrac'>
Generate a fraction close to the input value.
</h2><span id='topic+bestFrac'></span>

<h3>Description</h3>

<p>Inspired by the well-known approximations to <code>pi</code>, i.e. 22/7 and 355/113, this function allows the user to find the best-match fraction for any number, within the specified maximum magnitude of the numerator and denominator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestFrac(x, intrange)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestFrac_+3A_x">x</code></td>
<td>

<p>A character string representing a number to be &quot;converted&quot; to a fraction of nearly equal value. 
</p>
</td></tr>
<tr><td><code id="bestFrac_+3A_intrange">intrange</code></td>
<td>

<p>If a single value, the function tests all combinations of numerator and denominator between one and <code>intrange</code> . If two values, the 'testing range' is <code>intrange[1]:intrange[2]</code>. Otherwise, whatever vector of values is supplied will be used. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For irrationals and the like, the simplest way to generate the input parameter string <code>x</code> is to use <code><a href="base.html#topic+sprintf">sprintf</a></code> with as many digits to the right of the decimal point as desired. 
The returned values are in reduced form, i.e. the numerator and denominator are relatively prime. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>bestmatch</code></td>
<td>

<p>The numerator and denominator of the best-matching fraction
</p>
</td></tr>
<tr><td><code>goodmatch</code></td>
<td>

<p>An N-by-2 array of the progressively better matches found (numerators and denominators in the columns)
</p>
</td></tr>
<tr><td><code>matcherr</code></td>
<td>

<p>A vector of the  differences between the 'matcherr' fractions and the input value. This is limited in precision to the machine limit for doubles (floats). 
</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gpi &lt;- sprintf("%1.30f", pi) 
bestFrac(gpi, 100)
# $bestmatch
# [1] 22  7
# $goodmatch
#           [,1] [,2]
# goodmatch    0    0
#              1    1
#              2    1
#              3    1
#             13    4
#             16    5
#             19    6
#             22    7
# $matcherr
# [1] 1.000000e+02 6.816901e-01 3.633802e-01 4.507034e-02 3.450713e-02
#     1.859164e-02 7.981306e-03 4.024994e-04
bestFrac(gpi, 100:400)
# $bestmatch
# [1] 355 113
# $goodmatch
#           [,1] [,2]
# goodmatch    0    0
#            100   31
#            100   32
#            101   32
#            104   33
#            107   34
#            110   35  # notice this is 22/7 
#            179   57
#            201   64
#            223   71
#            245   78
#            267   85
#            289   92
#            311   99
#            333  106
#            355  113
# $matcherr
#  [1] 1.000000e+02 2.680608e-02 5.281606e-03 4.665578e-03 3.158429e-03
#      1.739936e-03 4.024994e-04
#  [8] 3.952697e-04 3.080137e-04 2.379631e-04 1.804857e-04 1.324752e-04 
#      9.177057e-05 5.682219e-05
# [15] 2.648963e-05 8.491368e-08)
</code></pre>

<hr>
<h2 id='bpp'>
Function which calculates pi, or other irrationals,  using the BaileyBorweinPlouffe formula  ~~
</h2><span id='topic+bpp'></span>

<h3>Description</h3>

<p>THe BPP algorithm consists of a double summation over specified fractions. Rather than go into the gory details here, please refer to the link in the References section.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpp(k,pdat = c(1,16,8,4,0,0,-2,-1,-1,0,0), init = 0, chunk = 1e4,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpp_+3A_k">k</code></td>
<td>

<p>The number of terms in the series to calculate.  Note that zero is a valid entry. If a single value, the terms <code>0:k</code> are used.  If two values are provided (see information for the input parameter <code>init</code>), then the terms <code>k{1}:k[2]</code> are run.
</p>
</td></tr>
<tr><td><code id="bpp_+3A_pdat">pdat</code></td>
<td>

<p>The parameter <code>P</code> which is used to define the coefficients used in all fractions in each term of the series.  In brief, pdat contains the following BPP parameters:  <code>pdat(s,b,m,A)</code> where <code>A</code>comprises all elements of the vector <code>pdat</code> after the first three.  There are strict rules about the length of <code>A</code>; see the Details section.   
The default value will calculate pi. 
</p>
</td></tr>
<tr><td><code id="bpp_+3A_init">init</code></td>
<td>

<p>If there's a previous value calculated with <code>bpp</code> for a certain value of <code>k</code>, this term allows the user to continue the calculation. Assign the previous output's <code>bppgmp</code> value to  <code>init</code> . Note that one must set up the input <code>k</code> to start at one more than the previous run's maximum &quot;k&quot; value.  
</p>
</td></tr>
<tr><td><code id="bpp_+3A_chunk">chunk</code></td>
<td>
 
<p>There is a call to <code>sum</code> in the main loop of this function. Use <code>chunk</code> to specify how many terms to pass to the sum call at a time, thus reducing the peak memory requirements of this function.  The more RAM available on your machine, the larger this number can be.  Set to a value greater than the argument <code>k</code> to run a single &quot;chunk,&quot; which is the fastest approach if sufficient memory is available. 
</p>
</td></tr>
<tr><td><code id="bpp_+3A_...">...</code></td>
<td>

<p>Optional arguments to pass to <code><a href="Rmpfr.html#topic+.bigq2mpfr">.bigq2mpfr</a></code> . 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BPP algorithm calculates the sumK=0,k, 1/(b^K) * FracSum , where FracSum is defined by the sum(M=1,m, A[M]/(m*K + M)^s) .  This means that the number of elements of <code>A</code> must equal <code>m</code>. Zero values are legal and are used to reject fractions not wanted in the inner sum. 
</p>
<p>The default values for <code>pdat</code> correspond to the coefficients used to generate pi (the sum to infinity is mathematically equal to pi).
Other values have been found to calculate a few other irrationals but there is as yet no known procedure to generate the <code>pdat</code> set for any given number.
</p>


<h3>Value</h3>

<p>A list containing <code>bppgmp</code> , the <code>gmp</code> fraction calculated; <code>bppval</code>, the <code>mpfr</code> decimal representation of said fraction; and <code>kvals</code>, echoing the input <code>k</code>. 
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bailey-Borwein-Plouffe_formula">https://en.wikipedia.org/wiki/Bailey-Borwein-Plouffe_formula</a>   and references cited there. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare the decimal outputs to the first 130 digits of pi, which are:
#  [1] 3 . 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4
#  [26] 3 3 8 3 2 7 9 5 0 2 8 8 4 1 9 7 1 6 9 3 9 9 3 7 5
#  [51] 1 0 5 8 2 0 9 7 4 9 4 4 5 9 2 3 0 7 8 1 6 4 0 6 2
#  [76] 8 6 2 0 8 9 9 8 6 2 8 0 3 4 8 2 5 3 4 2 1 1 7 0 6
# [101] 7 9 8 2 1 4 8 0 8 6 5 1 3 2 8 2 3 0 6 6 4 7 0 9 3
# [126] 8 4 4 6 0

# Lots of precision, but most of the digits are inaccurate.
(bpp(5))

# extend the series.
(bpp(20))

</code></pre>

<hr>
<h2 id='collatz'>
Test the Collatz Conjecture. ~~
</h2><span id='topic+collatz'></span>

<h3>Description</h3>

<p>This function calculates the Collatz (aka Hailstone) sequence based on the selected starting integer.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collatz(x, div=2, mul=3, add= 1, maxKnown=1, maxiter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collatz_+3A_x">x</code></td>
<td>

<p>The integer, or <code>bigz</code> integer to start with. 
</p>
</td></tr>
<tr><td><code id="collatz_+3A_div">div</code></td>
<td>

<p>The integer to divide by. Default is <code>2</code> per the original Collatz formula.
</p>
</td></tr>
<tr><td><code id="collatz_+3A_mul">mul</code></td>
<td>

<p>The integer to multiply by. Default is <code>3</code> per the original Collatz formula.
</p>
</td></tr>
<tr><td><code id="collatz_+3A_add">add</code></td>
<td>

<p>The integer to add after multiply. Default is <code>1</code> per the original Collatz formula.
</p>
</td></tr>
<tr><td><code id="collatz_+3A_maxknown">maxKnown</code></td>
<td>

<p>An integer to use as a &quot;shortcut&quot; if you know that said value converges. This allows the user to avoid repeating previous calculations.  Default value is <code>1</code>, i.e. no previous knowledge of converging numbers. 
</p>
</td></tr>
<tr><td><code id="collatz_+3A_maxiter">maxiter</code></td>
<td>

<p>A &quot;safety switch&quot; to avoid possible lengthy runtimes (when starting with very very large numbers), terminating the function prior to convergence. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Collatz sequence follows simple rules:
If the current number is even, divide it by two; else if it is odd, multiply it by three and add one.   Convergence occurs in  &lt; 200 cycles for initial values &lt; 10 million or so.
Note: a serious Collatz generator would memoize previous successful sequences, thus greatly reducing the calculation time required to test new numbers.  This function is provided &quot;for amusement only.&quot;
</p>


<h3>Value</h3>

<p>A vector of <code>bigz</code> integers representing the sequence, either to convergence or as limited by <code>maxiter</code>
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(collatz(20))
# 20 10 5  16 8  4  2 
(collatz(234568))
# [1] 234568 117284 58642  29321  87964  43982  21991  65974  32987  98962
#  49481  148444 74222  37111 
# [15] 111334 55667 167002 83501 250504 125252 62626 31313 93940 46970 23485
# 70456 35228 17614 
# [29] 8807  26422 13211 39634 19817 59452 29726 14863 44590 22295 66886
# 33443 100330 50165 
# [43] 150496 75248 37624 18812 9406  4703  14110 7055  21166 10583 
#31750 15875 47626 23813 
# [57] 71440 35720 17860 8930  4465  13396 6698  3349  10048 5024  
#  2512  1256  628  314  
# [71] 157  472  236  118  59   178  89   268  134  67   202  101  304  152  
# [85] 76   38   19   58   29   88   44   22   11   34   17   52   26   13  
# [99] 40   20   10   5   16   8   4   2  
</code></pre>

<hr>
<h2 id='FunWithNumbers-package'>
Fun with Fractions and Number Sequences
</h2><span id='topic+FunWithNumbers-package'></span><span id='topic+FunWithNumbers'></span>

<h3>Description</h3>

<p>A collection of toys to do things like generate Collatz sequences, convert a fraction to &quot;continued fraction&quot; form, calculate a fraction which is a close approximation to some value (e.g., 22/7 or 355/113 for pi), and so on.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> FunWithNumbers</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Fun with Fractions and Number Sequences</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-28</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given = "Carl", family = "Witthoft", role = c("aut","cre"), email= "cellocgw@gmail.com"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A collection of toys to do things like generate Collatz sequences, convert a fraction to "continued fraction" form, calculate a fraction which is a close approximation to some value (e.g., 22/7 or 355/113 for pi), and so on.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> FALSE</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rmpfr, gmp</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Carl Witthoft [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Carl Witthoft &lt;cellocgw@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>

<hr>
<h2 id='juggatz'>
Function which calculates the &quot;Juggler&quot; sequence ~~
</h2><span id='topic+juggatz'></span>

<h3>Description</h3>

<p>The &quot;Juggler&quot; sequence is similar to the Collatz sequence, but generates exponential changes rather than multiplicative changes to calculate each term. See Details for the algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juggatz(x, maxiter = 1000, prec = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juggatz_+3A_x">x</code></td>
<td>

<p>The numeric, <code>mpfr</code>, or <code>bigz</code> integer to start with. 
</p>
</td></tr>
<tr><td><code id="juggatz_+3A_maxiter">maxiter</code></td>
<td>

<p>A &quot;safety switch&quot; to avoid possible lengthy runtimes (when starting with very very large numbers), terminating the function prior to convergence. 
</p>
</td></tr>
<tr><td><code id="juggatz_+3A_prec">prec</code></td>
<td>

<p>This specifies the number of binary digits of precision to use when the function converts numeric input <code>x</code> to a <code>mpfr</code> object. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Juggler algorithm uses the following rules: x[j+1] = floor( if even, x[j]^0.5; if odd x[j]^1.5).  
Since the <code>mpfr</code>-class objects represent approximations to the various powers and roots calculated, <code>juggatz</code> dynamically adjusts the number of bits of precision for the next value in the sequence. This ensures that the correct decision as to even or odd is made at each step. 
</p>


<h3>Value</h3>

<p>A vector of <code>mpfr</code> integers representing the sequence, either to convergence or as limited by <code>maxiter</code>
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> (juggatz(10))
# 8 'mpfr' numbers of precision  10 .. 100  bits 
# [1] 10  3  5 11 36  6  2  1
(juggatz(37))
# 18 'mpfr' numbers of precision 10 .. 1000 bits 
# [1]  37  225  3375  196069 86818724  9317
# [7]  899319 852846071 24906114455136 4990602  2233  105519
# [13] 34276462  5854  76  8  2  1
</code></pre>

<hr>
<h2 id='morris'>
Generate the Morris sequence
</h2><span id='topic+morris'></span>

<h3>Description</h3>

<p>The Morris sequence, aka &quot;Look-Say,&quot; is an old puzzler sequence. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morris(x, reps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morris_+3A_x">x</code></td>
<td>

<p>Either a starting value from 1 to 9, or a numeric vector containing a Morris sequence previously generated.  
</p>
</td></tr>
<tr><td><code id="morris_+3A_reps">reps</code></td>
<td>

<p>Specifies the number of new Morris sequences to generate, starting with the input <code>x</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Morris sequence is built by taking the verbal description of a number sequence and converting every number or named numeral to a number in order.  Typically, starting with the integer 1, the spoken description is &quot;One 1,&quot; so the next sequence is c(1,1).  Read that out loud as &quot;Two ones&quot;, so the next sequence is c(2,1) and so on. 
</p>


<h3>Value</h3>

<p>A list variable containing all the sequences generated as numeric vectors. ...
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 

</p>

<hr>
<h2 id='preciseNumbersAsChar'>
High-precision values for some common constants, in character strings. 
</h2><span id='topic+charE'></span><span id='topic+charPhi'></span><span id='topic+charPi'></span><span id='topic+charRoot2'></span>

<h3>Description</h3>

<p>These are provided for use when playing around with some of the functions in this package, e.g., <code>bestFrac</code> or <code>cfrac</code> 
</p>


<h3>Details</h3>

<p>These represent, in order, &quot;e&quot; (natural log base), the golden ratio (1+sqrt(5))/2 aka &quot;phi&quot;, &quot;pi&quot;, and the square root of 2 as generated via <code>rmpfr</code> with 10 000 binary bits of precision.  There are many websites which can provide upwards of a million decimal digits for these constants for those who are interested. 
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>

<hr>
<h2 id='sptable'>
Calculate the number of unique values in the cross-table of sums and products for the input set of numbers
</h2><span id='topic+sptable'></span>

<h3>Description</h3>

<p>This function tests the proposition that the sum of all unique values in the cross-table of sums and products for a set of N input values is &quot;close&quot; to N^2 .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sptable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sptable_+3A_x">x</code></td>
<td>

<p>A vector of integer values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.
</p>
<table>
<tr><td><code>uniqsum</code></td>
<td>

<p>vector of the unique values of the outer sum <code>outer(x,x,'+')</code>
</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>uniqprod</code></td>
<td>

<p>vector of the unique values of the outer product <code>outer(x,x)</code>
</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>spratio</code></td>
<td>

<p>The ratio  <code>uniqsum/uniquprod</code>
</p>
</td></tr>
<tr><td><code>exponentOfN</code></td>
<td>

<p>The (numeric) solution to N^(exponentOfN) = uniqsum+uniqprod. If Erdos is right, this will always be &quot;close&quot; to 2. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 

</p>


<h3>References</h3>

<p>This conjecture is discussed in <a href="https://www.quantamagazine.org/the-sum-product-problem-shows-how-addition-and-multiplication-constrain-each-other-20190206/">https://www.quantamagazine.org/the-sum-product-problem-shows-how-addition-and-multiplication-constrain-each-other-20190206/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(sptable(1:10))
# $uniqsum
# [1] 19
# $uniqprod
# [1] 42
# $spratio
# [1] 0.452381
# $exponentOfN
# [1] 1.78533
set.seed(42)
sptable(sample(1:100,20,rep=FALSE))
# $uniqsum
# [1] 123
# $uniqprod
# [1] 202
# $spratio
# [1] 0.6089109
# $exponentOfN
# [1] 1.930688
</code></pre>

<hr>
<h2 id='vaneck'>
Generate a sequence 'invented' by Jan Ritsema Van Eck
</h2><span id='topic+vaneck'></span>

<h3>Description</h3>

<p>This function generates an interesting (to the author, at least) sequence listed as number A181391 in the <a href="https://oeis.org/">https://oeis.org/</a>. See Details for a full description. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vaneck(howlong = 100, ve = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vaneck_+3A_howlong">howlong</code></td>
<td>

<p>How many terms to generate.
</p>
</td></tr>
<tr><td><code id="vaneck_+3A_ve">ve</code></td>
<td>

<p>Optional argument. Enter a previously generated (&quot;VanEck&quot;) sequence here as a numeric vector, or a single integer to use as an initiator.
</p>
</td></tr>
<tr><td><code id="vaneck_+3A_...">...</code></td>
<td>

<p>reserved for possible future use. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rule here is that you start with 0, and whenever you get to a number you have not seen before, the following term is a 0. But if the number k has appeared previously in the sequence, then you count the number of terms since the last appearance of k, and that number is the following term. In more detail:
</p>
<p>Term 1: The first term is 0 by definition.
Term 2: Since we havent seen 0 before, the second term is 0.
Term 3: Since we have seen a 0 before, one step back, the third term is 1
Term 4: Since we havent seen a 1 before, the fourth term is 0
Term 5: Since we have seen a 0 before, two steps back, the fifth term is 2.
And so on.
As of this release of this R-package, how fast max(sequence) grows, and  whether every number eventually appears,  are open questions. The latest investigations and theorems related to this sequence can be found at <a href="https://oeis.org/A181391/">https://oeis.org/A181391/</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>ve</code></td>
<td>

<p>The vector (ve for &quot;VanEck&quot;) of the sequence values calculated
</p>
</td></tr>
<tr><td><code>uniqs</code></td>
<td>

<p>a vector of the unique values in <code>ve</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 

</p>


<h3>References</h3>

<p><a href="https://oeis.org/A181391/">https://oeis.org/A181391/</a>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>(vaneck(20))
# $ve
#  [1] 0 0 1 0 2 0 2 2 1 6 0 5 0 2 6 5 4 0 5 3 0
# $uniqs
# [1] 0 1 2 6 5 4 3

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
