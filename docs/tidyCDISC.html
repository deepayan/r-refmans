<!DOCTYPE html><html lang="en-US"><head><title>Help for package tidyCDISC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyCDISC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adae'><p>ADAE</p></a></li>
<li><a href='#adlbc'><p>ADLBC</p></a></li>
<li><a href='#adsl'><p>ADSL</p></a></li>
<li><a href='#adtte'><p>ADTTE</p></a></li>
<li><a href='#advs'><p>ADVS</p></a></li>
<li><a href='#app_methods'><p>Find the proper function to apply to</p>
each statistical and column block pairing
and use the metadata associated with
each column block for the function's arguments</a></li>
<li><a href='#col_for_list_expr'><p>GT Column Names</p></a></li>
<li><a href='#common_rownames'><p>Identify Names of Columns</p></a></li>
<li><a href='#data_to_filter'><p>The smallest possible data set we could filter to semi-join later</p></a></li>
<li><a href='#data_to_use_str'><p>Function to clean and combine ADAE dataset with ADSL</p></a></li>
<li><a href='#example_dat1'><p>Example Data Set 1</p></a></li>
<li><a href='#example_dat2'><p>Example Data Set 2</p></a></li>
<li><a href='#get_levels'><p>Get Factor Levels</p></a></li>
<li><a href='#prep_adae'><p>Function to pre-filter the ADAE depending on the stan table selected</p></a></li>
<li><a href='#prep_adsl'><p>Function to pre-filter the ADSL depending on the stan table selected</p></a></li>
<li><a href='#prep_bds'><p>Combine BDS Data Frames</p></a></li>
<li><a href='#pretty_IDs'><p>Create Pretty IDs for TG Table</p></a></li>
<li><a href='#run_app'><p>Run the Shiny Application</p></a></li>
<li><a href='#std_footnote'><p>Create Standard Footnotes for TG Table</p></a></li>
<li><a href='#tg_gt'><p>Prepare the table generator data for output</p></a></li>
<li><a href='#varN_fctr_reorder'><p>Re-order Factor Levels by VARN</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Quick Table Generation &amp; Exploratory Analyses on ADaM-Ish
Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides users a quick exploratory dive into common
    visualizations without writing a single line of code given the users
    data follows the Analysis Data Model (ADaM) standards put forth by the
    Clinical Data Interchange Standards Consortium (CDISC)
    <a href="https://www.cdisc.org">https://www.cdisc.org</a>. Prominent modules/ features of the
    application are the Table Generator, Population Explorer, and the
    Individual Explorer. The Table Generator allows users to drag and drop
    variables and desired statistics (frequencies, means, ANOVA, t-test,
    and other summary statistics) into bins that automagically create
    stunning tables with validated information. The Population Explorer
    offers various plots to visualize general trends in the population
    from various vantage points. Plot modules currently include scatter
    plot, spaghetti plot, box plot, histogram, means plot, and bar plot.
    Each plot type allows the user to plot uploaded variables against one
    another, and dissect the population by filtering out certain subjects.
    Last, the Individual Explorer establishes a cohesive patient
    narrative, allowing the user to interact with patient metrics (params)
    by visit or plotting important patient events on a timeline. All
    modules allow for concise filtering &amp; downloading bulk outputs into
    html or pdf formats to save for later.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Biogen-Inc/tidyCDISC/">https://github.com/Biogen-Inc/tidyCDISC/</a>,
<a href="https://Biogen-Inc.github.io/tidyCDISC/">https://Biogen-Inc.github.io/tidyCDISC/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Biogen-Inc/tidyCDISC/issues">https://github.com/Biogen-Inc/tidyCDISC/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cicerone, config, dplyr, DT, GGally, ggcorrplot, ggplot2,
glue, golem, gt, haven, IDEAFilter, plotly, purrr, rlang,
rmarkdown, shiny, shinyjs, shinyWidgets, sjlabelled, stringr,
survival, tidyr, timevis, tippy (== 0.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, spelling, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-16 13:49:10 UTC; aclark5</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Clark <a href="https://orcid.org/0000-0002-0123-0970"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jeff Thompson [aut],
  Teresa Wilson [aut],
  Nate Mockler [ccp, led],
  Maya Gans [aut],
  Robert Krajcik [ctb],
  Marly Gotti [ctb],
  Biogen Inc [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Clark &lt;clark.aaronchris@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-16 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adae'>ADAE</h2><span id='topic+adae'></span>

<h3>Description</h3>

<p>Adverse Events Analysis Data from PHUSE Test Data Factory Project's GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adae
</code></pre>


<h3>Format</h3>

<p>Data frame with 32,139 features and 34 fields
</p>


<h3>Source</h3>

<p>&lt;https://github.com/phuse-org/TestDataFactory/blob/master/Updated/TDF_ADaM/adae.xpt&gt;, downloaded 2020-06-17
</p>

<hr>
<h2 id='adlbc'>ADLBC</h2><span id='topic+adlbc'></span>

<h3>Description</h3>

<p>Laboratory Results Chemistry Analysis Data from PHUSE Test Data Factory Project's GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adlbc
</code></pre>


<h3>Format</h3>

<p>Data frame with 32,740 features and 58 fields
</p>


<h3>Source</h3>

<p>&lt;https://github.com/phuse-org/TestDataFactory/blob/master/Updated/TDF_ADaM/adlbc.xpt&gt;, downloaded 2020-06-17
</p>

<hr>
<h2 id='adsl'>ADSL</h2><span id='topic+adsl'></span>

<h3>Description</h3>

<p>Subject Level Analysis Data from PHUSE Test Data Factory Project's GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adsl
</code></pre>


<h3>Format</h3>

<p>Data frame with 254 features and 51 fields
</p>


<h3>Source</h3>

<p>&lt;https://github.com/phuse-org/TestDataFactory/blob/master/Updated/TDF_ADaM/adsl.xpt&gt;, downloaded 2020-06-17
</p>

<hr>
<h2 id='adtte'>ADTTE</h2><span id='topic+adtte'></span>

<h3>Description</h3>

<p>Time to Event Analysis Data from PHUSE Test Data Factory Project's GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adtte
</code></pre>


<h3>Format</h3>

<p>Data frame with 32,740 features and 58 fields
</p>


<h3>Source</h3>

<p>&lt;https://github.com/phuse-org/TestDataFactory/blob/master/Updated/TDF_ADaM/adtte.xpt&gt;, downloaded 2021-01-26
</p>

<hr>
<h2 id='advs'>ADVS</h2><span id='topic+advs'></span>

<h3>Description</h3>

<p>Vital Signs Analysis Data from PHUSE Test Data Factory Project's GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advs
</code></pre>


<h3>Format</h3>

<p>Data frame with 32,139 features and 34 fields
</p>


<h3>Source</h3>

<p>&lt;https://github.com/phuse-org/TestDataFactory/blob/master/Updated/TDF_ADaM/advs.xpt&gt;, downloaded 2020-06-17
</p>

<hr>
<h2 id='app_methods'>Find the proper function to apply to 
each statistical and column block pairing
and use the metadata associated with 
each column block for the function's arguments</h2><span id='topic+app_methods'></span>

<h3>Description</h3>

<p>Find the proper function to apply to 
each statistical and column block pairing
and use the metadata associated with 
each column block for the function's arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>app_methods(agg, column, week, group, data, totals, filter = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_methods_+3A_agg">agg</code></td>
<td>
<p>the statistic to apply given the block name</p>
</td></tr>
<tr><td><code id="app_methods_+3A_column">column</code></td>
<td>
<p>the column to apply that statistic too,
and class of the column dictated by the data frame it came from</p>
</td></tr>
<tr><td><code id="app_methods_+3A_week">week</code></td>
<td>
<p>the week if needed for calculation</p>
</td></tr>
<tr><td><code id="app_methods_+3A_group">group</code></td>
<td>
<p>whether to perform a group_by and if so by which column</p>
</td></tr>
<tr><td><code id="app_methods_+3A_data">data</code></td>
<td>
<p>the dataset to perform all functions on</p>
</td></tr>
<tr><td><code id="app_methods_+3A_totals">totals</code></td>
<td>
<p>the totals data frame that contains denominator N's use when
calculating column percentages</p>
</td></tr>
<tr><td><code id="app_methods_+3A_filter">filter</code></td>
<td>
<p>a string denoting the additional filter to apply to the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the table corresponding to the proper function
to perform given the supplied column.
This is used within a map to apply to all blocks
inside the table generator module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  data(example_dat1, package = "tidyCDISC")

  # Create non-missing table section
  app_methods("NON_MISSING", 
             structure("USUBJID", class = c("character", "ADSL")), NA, 
             "TRT01P", example_dat1$AE, example_dat1$totals)
            
  # Create ANOVA table section
  app_methods("ANOVA", 
            structure("TEMP", class = c("character", "BDS")), "Week 2", 
            "TRT01P", example_dat1$BDS, example_dat1$totals)

  # Create change table section
  app_methods("CHG", 
            structure("WEIGHT", class = c("character", "BDS")), "Week 12", 
            "TRT01P", example_dat1$BDS, example_dat1$totals)

  # Create mean table section
  app_methods("MEAN", 
            structure("PULSE", class = c("character", "BDS")), "Baseline", 
            "TRT01P", example_dat1$BDS, example_dat1$totals)
}
</code></pre>

<hr>
<h2 id='col_for_list_expr'>GT Column Names</h2><span id='topic+col_for_list_expr'></span>

<h3>Description</h3>

<p>The function creates the labels for each column using the total function so the columns are now NAME N= X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_for_list_expr(col_names, col_total)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_for_list_expr_+3A_col_names">col_names</code></td>
<td>
<p>A vector of column names</p>
</td></tr>
<tr><td><code id="col_for_list_expr_+3A_col_total">col_total</code></td>
<td>
<p>A vector of column totals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character object of class <code>from_markdown</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_dat2, package = "tidyCDISC")

labels &lt;- col_for_list_expr(example_dat2$col_names, example_dat2$col_totals)
labels

if (interactive()) {
# TG table without nice column labels or totals
example_dat2$TG_table

# TG table with nice column labels and totals
gt::cols_label(example_dat2$TG_table, .list = labels)
}
</code></pre>

<hr>
<h2 id='common_rownames'>Identify Names of Columns</h2><span id='topic+common_rownames'></span>

<h3>Description</h3>

<p>A function to transform the <code>gt</code> row names from generics to the column name and the total N of
each column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_rownames(data, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="common_rownames_+3A_data">data</code></td>
<td>
<p>the data to create columns with</p>
</td></tr>
<tr><td><code id="common_rownames_+3A_group">group</code></td>
<td>
<p>whether to group the data to calculate Ns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adsl, package = "tidyCDISC")

# Values of TRT01P
unique(adsl$TRT01P)

# Common row names based on TRT01P
common_rownames(adsl, "TRT01P")
</code></pre>

<hr>
<h2 id='data_to_filter'>The smallest possible data set we could filter to semi-join later</h2><span id='topic+data_to_filter'></span>

<h3>Description</h3>

<p>The smallest possible data set we could filter to semi-join later
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_filter(datafile, input_filter_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_to_filter_+3A_datafile">datafile</code></td>
<td>
<p>list of ADaM-ish dataframes</p>
</td></tr>
<tr><td><code id="data_to_filter_+3A_input_filter_df">input_filter_df</code></td>
<td>
<p>The name of a dataset stored in 'datafile'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' object based on the reduction of 'datafile' from 'input_filter_df'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
  datalist &lt;- list(ADSL = tidyCDISC::adsl, ADAE = tidyCDISC::adae, 
                   ADVS = tidyCDISC::advs, ADLBC = tidyCDISC::adlbc, 
                   ADTTE = tidyCDISC::adtte)

  # Returns combined dataset
  data_to_filter(datalist, c("ADSL", "ADAE"))
}
</code></pre>

<hr>
<h2 id='data_to_use_str'>Function to clean and combine ADAE dataset with ADSL</h2><span id='topic+data_to_use_str'></span>

<h3>Description</h3>

<p>Function to clean and combine ADAE dataset with ADSL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_use_str(x, ae_data, bds_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_to_use_str_+3A_x">x</code></td>
<td>
<p>string, naming a data.frame.</p>
</td></tr>
<tr><td><code id="data_to_use_str_+3A_ae_data">ae_data</code></td>
<td>
<p>data.frame, of the AE variety</p>
</td></tr>
<tr><td><code id="data_to_use_str_+3A_bds_data">bds_data</code></td>
<td>
<p>data.frame, of the BDS variety</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.frame' object containing data of the AE variety if 'x == &quot;ADAE&quot;' or one of the BDS variety if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
  datalist &lt;- list(ADSL = tidyCDISC::adsl, ADVS = tidyCDISC::advs, 
                   ADAE = tidyCDISC::adae, ADLBC = tidyCDISC::adlbc)
                 
  pre_adsl &lt;- prep_adsl(datalist$ADSL, input_recipe = 'NONE')
  pre_adae &lt;- prep_adae(datalist, pre_adsl$data, 'NONE')
  ae_data &lt;- pre_adae$data
  bds_data &lt;- prep_bds(datalist, ADSL = pre_adsl$data)
  
  all.equal(data_to_use_str("ADAE", ae_data, bds_data), ae_data)
  all.equal(data_to_use_str("ADSL", ae_data, bds_data), bds_data)
}
</code></pre>

<hr>
<h2 id='example_dat1'>Example Data Set 1</h2><span id='topic+example_dat1'></span>

<h3>Description</h3>

<p>Pre-processed data for purposes of demonstrating <a href="#topic+app_methods">app_methods</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_dat1
</code></pre>


<h3>Format</h3>

<p>A list with 3 elements:
</p>

<dl>
<dt>AE</dt><dd><p>data frame, pre-processed AE dataset</p>
</dd>
<dt>BDS</dt><dd><p>data frame, pre-processed BDS dataset</p>
</dd>
<dt>totals</dt><dd><p>data frame, contains totals by grouping variable for pre-processed data</p>
</dd>
</dl>


<hr>
<h2 id='example_dat2'>Example Data Set 2</h2><span id='topic+example_dat2'></span>

<h3>Description</h3>

<p>Pre-processed data for the purposes of demonstrating <a href="#topic+col_for_list_expr">col_for_list_expr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_dat2
</code></pre>


<h3>Format</h3>

<p>A list with 3 elements:
</p>

<dl>
<dt>TG_table</dt><dd><p>data frame, pre-processed <code>gt</code> table object with basic column names</p>
</dd>
<dt>col_names</dt><dd><p>vector, the column names</p>
</dd>
<dt>col_totals</dt><dd><p>vector, totals corresponding to each column</p>
</dd>
</dl>


<hr>
<h2 id='get_levels'>Get Factor Levels</h2><span id='topic+get_levels'></span>

<h3>Description</h3>

<p>Extracts the factor levels of a vector or returns the unique values if the vector is not a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_levels(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_levels_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x vector
</p>


<h3>References</h3>

<p>A character vector containing the levels of the factor/vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adae, package = "tidyCDISC")

# Create levels based on VARN
varN_fctr_adae &lt;- varN_fctr_reorder(adae)

# `adae` does not have factor but `varN_fctr_adae` does
levels(adae$RACE)
levels(varN_fctr_adae$RACE)

# `get_levels()` either creates the factor or retrieves it
get_levels(adae$RACE)
get_levels(varN_fctr_adae$RACE)
</code></pre>

<hr>
<h2 id='prep_adae'>Function to pre-filter the ADAE depending on the stan table selected</h2><span id='topic+prep_adae'></span>

<h3>Description</h3>

<p>Function to pre-filter the ADAE depending on the stan table selected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_adae(datafile, ADSL, input_recipe)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_adae_+3A_datafile">datafile</code></td>
<td>
<p>list of ADaM-ish dataframes</p>
</td></tr>
<tr><td><code id="prep_adae_+3A_adsl">ADSL</code></td>
<td>
<p>an ADSL data.frame</p>
</td></tr>
<tr><td><code id="prep_adae_+3A_input_recipe">input_recipe</code></td>
<td>
<p>The shiny input that keeps track of the recipe selected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'list' containing a 'data.frame' object and character vector specifying the pre-filter applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
  datalist &lt;- list(ADSL = tidyCDISC::adsl, ADVS = tidyCDISC::advs, 
                   ADAE = tidyCDISC::adae, ADLBC = tidyCDISC::adlbc)
                 
  pre_adsl &lt;- prep_adsl(datalist$ADSL, input_recipe = 'NONE')

  # Create AE data set
  prep_adae(datalist, pre_adsl$data, input_recipe = 'NONE')
}
</code></pre>

<hr>
<h2 id='prep_adsl'>Function to pre-filter the ADSL depending on the stan table selected</h2><span id='topic+prep_adsl'></span>

<h3>Description</h3>

<p>Function to pre-filter the ADSL depending on the stan table selected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_adsl(ADSL, input_recipe)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_adsl_+3A_adsl">ADSL</code></td>
<td>
<p>an ADSL data.frame</p>
</td></tr>
<tr><td><code id="prep_adsl_+3A_input_recipe">input_recipe</code></td>
<td>
<p>The shiny input that keeps track of the recipe selected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'list' containing a 'data.frame' object and character vector specifying the pre-filter applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adsl, package = "tidyCDISC")

# Process ADSL data for STAN table

prep_adsl(adsl, input_recipe = 'Table 3: Accounting of Subjects')

# Return ADSL data if no STAN table selected

prep_adsl(adsl, input_recipe = "NONE")
</code></pre>

<hr>
<h2 id='prep_bds'>Combine BDS Data Frames</h2><span id='topic+prep_bds'></span>

<h3>Description</h3>

<p>A function to combine all BDS data frames into one large data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_bds(datafile, ADSL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_bds_+3A_datafile">datafile</code></td>
<td>
<p>list of ADaM-ish data frames</p>
</td></tr>
<tr><td><code id="prep_bds_+3A_adsl">ADSL</code></td>
<td>
<p>A data frame which contains the ADSL data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the BDS data bound by rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
  datalist &lt;- list(ADSL = tidyCDISC::adsl, ADVS = tidyCDISC::advs, 
                   ADAE = tidyCDISC::adae, ADLBC = tidyCDISC::adlbc)
                 
  pre_adsl &lt;- prep_adsl(datalist$ADSL, input_recipe = 'NONE')

  prep_bds(datalist, ADSL = pre_adsl$data)
}
</code></pre>

<hr>
<h2 id='pretty_IDs'>Create Pretty IDs for TG Table</h2><span id='topic+pretty_IDs'></span>

<h3>Description</h3>

<p>Replaces ugly ID patterns of a stat block with pretty replacements for display purposes (e.g. NON_MISSING becomes Subject Count for those with Non Missing values)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_IDs(ID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pretty_IDs_+3A_id">ID</code></td>
<td>
<p>The ID vector of a TG table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of pretty IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List of patterns that can be replaced
patterns &lt;- c("MEAN", "FREQ", "CHG", "Y_FREQ", "MAX_FREQ", "NON_MISSING", 
              "NESTED_FREQ_DSC", "NESTED_FREQ_ABC")
IDs &lt;- paste(patterns, "of VAR")

IDs
pretty_IDs(IDs)
</code></pre>

<hr>
<h2 id='run_app'>Run the Shiny Application</h2><span id='topic+run_app'></span>

<h3>Description</h3>

<p>Run the Shiny Application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_app(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_app_+3A_...">...</code></td>
<td>
<p>A series of options to be used inside the app.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to run the application.
</p>

<hr>
<h2 id='std_footnote'>Create Standard Footnotes for TG Table</h2><span id='topic+std_footnote'></span>

<h3>Description</h3>

<p>Creates a footnote with a source on the left and date run on the right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_footnote(data, source)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std_footnote_+3A_data">data</code></td>
<td>
<p>The 'gt' table object to append the footnote</p>
</td></tr>
<tr><td><code id="std_footnote_+3A_source">source</code></td>
<td>
<p>The source of the data in the table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'gt' object
</p>

<hr>
<h2 id='tg_gt'>Prepare the table generator data for output</h2><span id='topic+tg_gt'></span>

<h3>Description</h3>

<p>Prepare the data.frame so that it's ready for output via 'gt' or other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tg_gt(tg_datalist, blockData, total_df, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tg_gt_+3A_tg_datalist">tg_datalist</code></td>
<td>
<p>A list containing the data frames used to create the table</p>
</td></tr>
<tr><td><code id="tg_gt_+3A_blockdata">blockData</code></td>
<td>
<p>The data for the construction of the blocks in the table</p>
</td></tr>
<tr><td><code id="tg_gt_+3A_total_df">total_df</code></td>
<td>
<p>A data frame containing the totals by grouping variable</p>
</td></tr>
<tr><td><code id="tg_gt_+3A_group">group</code></td>
<td>
<p>A character denoting the grouping variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing output polished for presentation in 'gt'
</p>

<hr>
<h2 id='varN_fctr_reorder'>Re-order Factor Levels by VARN</h2><span id='topic+varN_fctr_reorder'></span>

<h3>Description</h3>

<p>Function to that looks for VARN counterparts to any character or factor VAR
variables in any dataframe and re-orders there factor levels, taking the lead
from VARN's numeric guide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varN_fctr_reorder(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varN_fctr_reorder_+3A_data">data</code></td>
<td>
<p>a dataframe, including one enriched with SAS labels attributes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame after having factor levels re-ordered by VARN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adae, package = "tidyCDISC")

varN_fctr_adae &lt;- varN_fctr_reorder(adae)

unique(adae[,c("AGEGR1", "AGEGR1N")])
levels(adae$AGEGR1)
levels(varN_fctr_adae$AGEGR1)

unique(adae[,c("RACE", "RACEN")])
levels(adae$RACE)
levels(varN_fctr_adae$RACE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
