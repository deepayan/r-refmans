<!DOCTYPE html><html lang="en"><head><title>Help for package DoE.MIParray</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DoE.MIParray}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DoE.MIParray-package'>
<p>Package to Create a MIP Based Array</p></a></li>
<li><a href='#create_MIQP.Rd'>
<p>Internal functions that support the export of (mixed) integer quadratic or linear problems in MPS format</p></a></li>
<li><a href='#dToCount.Rd'>
<p>Functions to switch between count and array representation of an array</p></a></li>
<li><a href='#functionsFromDoE.base'>
<p>Functions from package DoE.base</p></a></li>
<li><a href='#mosek_MIParray'>
<p>Functions to Create a MIP Based Array Using Gurobi or Mosek</p></a></li>
<li><a href='#mosek_MIPcontinue'>
<p>Functions to Continue Optimization from Stored State</p></a></li>
<li><a href='#mosek_MIPsearch'>
<p>Functions to Search for optimum MIP Based Array Using Gurobi or Mosek</p></a></li>
<li><a href='#mosek2gurobi'>
<p>Functions to recast quadratically constrained MIP in different format, and class qco</p></a></li>
<li><a href='#print.oa'>
<p>Function to Print oa Objects with a Lot of Added Info</p></a></li>
<li><a href='#write_MPSILPlist.Rd'>
<p>Functions to create and write lists of (mixed) integer quadratic or linear problems related to orthogonal arrays</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Creation of Arrays by Mixed Integer Programming</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>'CRAN' packages 'DoE.base' and 'Rmosek' and non-'CRAN' package 'gurobi' are enhanced with functionality for the creation of optimized arrays for experimentation, where optimization is in terms of generalized minimum aberration. It is also possible to optimally extend existing arrays to larger run size. The package writes 'MPS' (Mathematical Programming System) files for use with any mixed integer optimization software that can process such files. If at least one of the commercial products 'Gurobi' or 'Mosek' (free academic licenses available for both) is available, the package also creates arrays by optimization. For installing 'Gurobi' and its R package 'gurobi', follow instructions at <a href="https://www.gurobi.com/products/gurobi-optimizer/">https://www.gurobi.com/products/gurobi-optimizer/</a> and <a href="https://www.gurobi.com/documentation/7.5/refman/r_api_overview.html">https://www.gurobi.com/documentation/7.5/refman/r_api_overview.html</a> (or higher version). For installing 'Mosek' and its R package 'Rmosek', follow instructions at <a href="https://www.mosek.com/downloads/">https://www.mosek.com/downloads/</a> and <a href="https://docs.mosek.com/8.1/rmosek/install-interface.html">https://docs.mosek.com/8.1/rmosek/install-interface.html</a>, or use the functionality in the stump CRAN R package 'Rmosek'.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, combinat, DoE.base</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gurobi, Rmosek (&ge; 8.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>slam (&ge; 0.1-9), Matrix (&ge; 1.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 11:24:50 UTC; Grömping</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 12:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='DoE.MIParray-package'>
Package to Create a MIP Based Array
</h2><span id='topic+DoE.MIParray-package'></span><span id='topic+DoE.MIParray'></span>

<h3>Description</h3>

<p>'CRAN' packages 'DoE.base' and 'Rmosek' and non-'CRAN' package 'gurobi' are enhanced with functionality for the creation of optimized arrays for experimentation, where optimization is in terms of generalized minimum aberration. It is also possible to optimally extend existing arrays to larger run size. The package writes 'MPS' (Mathematical Programming System) files for use with any mixed integer optimization software that can process such files. If at least one of the commercial products 'Gurobi' or 'Mosek' (free academic licenses available for both) is available, the package also creates arrays by optimization. For installing 'Gurobi' and its R package 'gurobi', follow instructions at &lt;https://www.gurobi.com/products/gurobi-optimizer/&gt; and &lt;https://www.gurobi.com/documentation/7.5/refman/r_api_overview.html&gt; (or higher version). For installing 'Mosek' and its R package 'Rmosek', follow instructions at &lt;https://www.mosek.com/downloads/&gt; and &lt;https://docs.mosek.com/8.1/rmosek/install-interface.html&gt;, or use the functionality in the stump CRAN R package 'Rmosek'.
</p>


<h3>Details</h3>

<p>The package creates an array with specified minimum resolution and optimized word length pattern, using mixed integer programming (MIP). This is a step in
generalized minimum aberration (GMA) according to Xu and Wu (2001), which is a way to minimize the confounding potential in a factorial design, as measured by the generalized word length pattern (GWLP). Reduction of short words has priority over reduction of long words, because it pertains to confounding of lower order interactions, which is assumed to be more severe than confounding of higher order interactions.
</p>
<p>There is always one word of length zero. An array is said to have strength t (resolution R=t+1), if it has no words of lengths 1,...,t, but has words of length R=t+1; in that case, t-factor interactions are not confounded with the overall mean, (t-1)-factor interactions are not confounded with main effects, and so forth. Groemping and Xu (2014) provided an interpretation of the number of shortest words (i.e. words of length R) in terms of coefficients of determination of linear models with main effects model matrix columns on the LHS and full factorial t-factor models on the right-hand side; for example, in an array of strength 2 with three 3-level factors, the number of words of length 3 is the sum of the two R^2 values obtained from regressing the two main effects model matrix columns of one of the factors on a full model in the other two factors, provided main effect model matrix columns are coded orthogonally (to each other and the overall mean). GMA considers a design better than another one, if it has larger strength or resolution. In case of ties, a design is better if it has fewer shortest words; further ties are resolved by comparing words of lengths t+2, t+3, ...
</p>
<p>Any array found by a function of this package will have the requested resolution (if not possible, an error will be thrown). If desired (default, but can be suppressed), optimization of the number of shortest words will be attempted. If <code>kmax</code> is chosen larger than the resolution, optimization of longer words will also be attempted. Mixed integer optimization is very resource-intensive and often fails to provide a confirmed optimum (see also below). Choosing <code>kmax</code> larger than the resolution is therefore advisable for very small problems only; in most cases, one should attempt an optimization of the number of shortest words only, or even suppress that by <code>find.only=TRUE</code>. Only after this has been achieved, possibly with several sequential attempts, a subsequent attempt to improve the number of longer words should be undertaken.
</p>
<p>Functions <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code> and <code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code> create an array from scratch (<code>start=NULL</code> and <code>forced=NULL</code>), by trying to improve a starting array specified with the argument <code>start</code>, or by restricting a portion of the array to correspond to a pre-existing array with the argument <code>forced</code>. If no starting array is given, the functions initially obtain one by solving a linear optimization problem for obtaining a design with the requested resolution. Subsequently, the number of shortest words of the starting array is optimized, followed by the numbers of words of length up to <code>kmax</code>.
</p>
<p>Where functions <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code> and <code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code> do not easily find an optimal array, it may be worthwhile to consider using functions <code><a href="#topic+gurobi_MIPsearch">gurobi_MIPsearch</a></code> and <code><a href="#topic+mosek_MIPsearch">mosek_MIPsearch</a></code>, which can search over different orderings of the factor levels; these have been provided because a brief search for a fortunate level orderings may be successful where a very long search for an unfortunate level ordering fails.
</p>
<p>The algorithm implemented in the package is explained in Groemping and Fontana (2019); it is a modification of Fontana (2017). Modifications include enforcing the requested resolution via a linear optimization step (much faster than sequentially optimizing all those word lengths until they are zeroes), and using a result on coding invariance from Groemping (2018) for a more parsimonious formulation of constraints. Mixed integer programming can use a lot of time and resources; in particular, the confirmation of the optimality of a solution that has been found can take prohibitively long, even if the optimal solution itself has been found fast (which is also not necessarily so). Functions <code><a href="#topic+gurobi_MIPcontinue">gurobi_MIPcontinue</a></code> and <code><a href="#topic+mosek_MIPcontinue">mosek_MIPcontinue</a></code> can be used to continue optimization for larger problems,
where optimization was previously aborted, e.g. due to a time limit (however, a lot of effort is lost and has to be repeated when continuing a previous attempt). Note that it is possible to continue an optimization effort started with Gurobi using Mosek and vice versa, because the functions <code>gurobi_MIPcontinue</code> and <code>mosek_MIPcontinue</code> can convert problems using the internal functions <code><a href="#topic+mosek2gurobi">mosek2gurobi</a></code> and <code><a href="#topic+gurobi2mosek">gurobi2mosek</a></code>. Groemping (2020) explains the package itself.
</p>
<p>The solver functions in the package use the commercial solvers Mosek and/or Gurobi, which provide free academic licenses. These solvers and their corresponding vendor-provided R packages have to be installed for using the package's solver functions. For users who do not have access to these but to other solvers, the package provides export functions to mps files that can be read by other solvers, for example by IBM CPLEX (<code><a href="#topic+write_MPSMIQP">write_MPSMIQP</a></code>, <code><a href="#topic+write_MPSILPlist">write_MPSILPlist</a></code>).
</p>


<h3>Warning</h3>

<p>Escaping from a Gurobi run will most likely be unsuccessful, might leave R in an unstable state, and usually fails to release the entire CPU usage; thus, one should think carefully about the affordable run times. <br />
Mosek can usually be escaped using the &lt;ESC&gt; key, and one can even hope to get a valid output.
However, after such escapes, it is also advisable to use <span class="pkg">RMosek</span>'s internal clean function
(<code>Rmosek:::mosek_clean()</code>), since computer instabilities after repeated escapes from Mosek have been observed
(the package functions execute the <code>mosek_clean</code> command after conducting Mosek runs).
</p>


<h3>Installation</h3>

<p>Gurobi and Mosek need to be separately installed; please follow vendors' instructions; it is necessary to obtain a license; for academic use, free academic licenses are available in both cases.
</p>
<p>Both Gurobi and Mosek provide R packages (<span class="pkg">gurobi</span> and <span class="pkg">Rmosek</span>) for accessing the software, and they also provide instructions on their installation.
</p>
<p>For Gurobi, the R package <span class="pkg">gurobi</span> is provided with the software installation files and can simply be installed like usual for a non-Web package.
</p>
<p>For Mosek, there is a CRAN package <span class="pkg">Rmosek</span>, which is a stump only and can be used for installing the suitable package <span class="pkg">Rmosek</span> from the Mosek website.
Its installation requires compilation from source.  Several prerequisites are needed, basically the same ones needed for compiling packages.
Make sure to set up the R environment for this purpose (for Windows, see <a href="https://cran.r-project.org/bin/windows/Rtools/">https://cran.r-project.org/bin/windows/Rtools/</a>; you may have to set some paths yourself;
I am not familiar with the proper process for other platforms).  If this is accomplished and package <span class="pkg">Matrix</span> is at the latest level (as recommended in the <span class="pkg">Rmosek</span>
online documentation), install the CRAN package <span class="pkg">Rmosek</span>, whose purpose it is to support installation of the appropriate <span class="pkg">Rmosek</span> package for your platform and Mosek version.
Once this CRAN package is available, run function <code>mosek_attachbuilder</code>, specifying the appropriate path as
pointed out in the function's documentation, and subsequently run the custom-made function <code>install.rmosek</code>.  After this activity (if all went well), the CRAN package <span class="pkg">Rmosek</span>
will have been replaced by a working version of package <span class="pkg">Rmosek</span> whose version number depends on your version of Mosek.  In case of problems,
running the <code>install.packages</code> command provided in the <span class="pkg">Rmosek</span> online documentation for your version of Mosek (Mosek ApS 2017b) may also be worth a try;
if all else fails, you may have to contact <span class="pkg">Rmosek</span> support.
</p>
<p>Don't be confused by Mosek ApS's somewhat strange communication regarding the package <span class="pkg">Rmosek</span>: the CRAN version (stump for the purpose of supporting installation of the working version)
has its own separate numbering that currently starts with &ldquo;1&rdquo;. The working <span class="pkg">Rmosek</span> packages have version numbers whose first digit is kept in sync with the Mosek major version number;
apart from that, version numbers of <span class="pkg">Rmosek</span> versions and Mosek versions are not kept in sync; for example, the current version (July 13 2019) of package Rmosek for Mosek
version 8 is 8.0.69, while the Mosek version is 8.1.0.81 (the revision versions of Mosek change quite frequently).  Whenever Mosek itself is re-installed (at least with a change of minor version
like 8.0 to 8.1), the <span class="pkg">Rmosek</span> sources must be re-compiled, even if their version has not changed;
this is presumably why Mosek ApS speak of a version number for the binary that corresponds to the Mosek version number, while the sources keep their version number
(somewhat confusing for the R community).  From within R, version numbers can be queried by <code>packageVersion("Rmosek")</code> and <code>Rmosek::mosek_version()</code>, respectively.</p>


<h3>Note</h3>

<p>The package is not meant for situations, for which a full factorial design would be huge; the mixed integer problem to be solved has at least <code>prod(nlevels)</code> binary or general integer variables and will likely be untractable, if this number is too large. (For extending an existing designs, since some variables are fixed, the limit moves out a bit.)
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Fontana, R. (2017). Generalized Minimum Aberration mixed-level orthogonal arrays: a general approach based on sequential integer quadratically constrained quadratic programming. <em>Communications in Statistics – Theory Methods</em> <b>46</b>, 4275-4284.
</p>
<p>Groemping, U. and Xu, H. (2014). Generalized resolution for orthogonal arrays. <em>The Annals of Statistics</em> <b>42</b>, 918-939.
</p>
<p>Groemping, U. (2018). Coding Invariance in Factorial Linear Models and a New Tool for Assessing Combinatorial Equivalence of Factorial Designs. <em>Journal of Statistical Planning and Inference</em> <b>193</b>, 1-14.
</p>
<p>Groemping, U. and Fontana R. (2019). An Algorithm for Generating Good Mixed Level Factorial Designs. <em>Computational Statistics &amp; Data Analysis</em> <b>137</b>, 101-114.
</p>
<p>Groemping, U. (2020). DoE.MIParray: an R package for algorithmic creation of orthogonal arrays. <em>Journal of Open Research Software</em>, <b>8: 24</b>. DOI: https://doi.org/10.5334/jors.286
</p>
<p>Gurobi Optimization Inc. (2018). Gurobi Optimizer Reference Manual. <a href="https://www.gurobi.com:443/documentation/">https://www.gurobi.com:443/documentation/</a>.
</p>
<p>Mosek ApS (2017a). MOSEK version w.x.y.z documentation. Accessible at: <a href="https://www.mosek.com/documentation/">https://www.mosek.com/documentation/</a>. This package has been developed using version 8.1.0.23 (accessed August 29 2017).
</p>
<p>Mosek ApS (2017b). MOSEK Rmosek Package 8.1.y.z. <a href="https://docs.mosek.com/8.1/rmosek/index.html">https://docs.mosek.com/8.1/rmosek/index.html</a>.
<em>!!! In normal R speak, this is the documentation of the Rmosek package version 8.0.69, when applied on top of the Mosek version 8.1.y.z (this package has been devoloped with Mosek version 8.1.0.23 and will likely not work for Mosek versions before 8.1). !!! (accessed August 29 2017)</em>
</p>
<p>Xu, H. and Wu, C.F.J. (2001). Generalized minimum aberration for asymmetrical fractional factorial designs. <em>Annals of Statistics</em> <b>29</b>, 549-560.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## ideal sequence of optimization problems
## shown here for Mosek,
## for Gurobi analogous, if necessary increasing maxtime to e.g. 600 or 3600 or ...

## very small problem
plan &lt;- mosek_MIParray(16, rep(2,6), resolution=4, kmax=6)

## an example approach for a larger problem
## optimize shortest word length
plan3 &lt;- mosek_MIParray(24, c(2,4,3,2,2,2,2), resolution=3, maxtime=20)
## feasible solution was found, no confirmed optimum, 7/3 words of length 3
## try to optimize further or confirm optimality (improve=TRUE does this),
##                      give it 10 minutes
plan3b &lt;- mosek_MIPcontinue(plan3, improve=TRUE, maxtime=600)
##     no improvement has been found, and the gap is still very large
##     (the time limit makes the result non-deterministic, of course,
##      because it depends on the computer's power and availability of its resources)

## For large problems, it cannot be expected that a *confirmed* optimum is found.
## Of course, one can put more effort into the optimization, e.g. by running overnight.
## It is also advisable to compare the outcome to other ways for obtaining a good array,
##    e.g. function oa.design from package DoE.base with optimized column allocation.
require(DoE.base)
show.oas(nruns=24, nlevels=c(2,4,3,2,2,2,2), show=Inf)
GWLP(plan_oad &lt;- oa.design(nruns=24, nlevels=c(2,4,3,2,2,2,2), col="min34"))
## here, plan3b has a better A3 than plan_oad

## one might also try to confirm optimality by switching to the other optimizer
plan3c &lt;- gurobi_MIPcontinue(plan3b, improve=TRUE, maxtime=600, MIPFocus=3)
   ## focus on improved bound with option MIPFocus
   ## still same value with very large gap after running this
   ## thus, now assume this as best practically feasible value

## one might now try to improve words of length 4 (improve=FALSE turns to the next word length)
plan4 &lt;- mosek_MIPcontinue(plan3b, improve=FALSE, maxtime=600)
   ## this does not yield any improvement
   ## working on longer words is not considered worthwhile
   ## thus, plan3 or plan3b are used for pragmatic reasons,
   ## without confirmed optimality

## End(Not run)
</code></pre>

<hr>
<h2 id='create_MIQP.Rd'>
Internal functions that support the export of (mixed) integer quadratic or linear problems in MPS format
</h2><span id='topic+write_MPSILP'></span><span id='topic+create_MIQP'></span>

<h3>Description</h3>

<p>create_MIQP creates an MPS format character object,
write_MPSILP saves a single integer linear problem in MPS format (used in the user-visible write_MSPILPlist).
The functions work, if neither Mosek nor Gurobi is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_MIQP(nruns, nlevels, resolution=3, distinct=TRUE,
              start=NULL, forced=NULL, forMosek=FALSE)
write_MPSILP(file, qco=NULL, qcoinfo=NULL,
              cvec=NULL, bvec=NULL, Amat=NULL, bsense=NULL, boundmat=NULL,
              name = "EnforceResolution", commentline="* no comment")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_MIQP.Rd_+3A_nruns">nruns</code></td>
<td>

<p>positive integer; number of runs
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_nlevels">nlevels</code></td>
<td>

<p>vector of integers (&gt;=2); numbers of factor levels
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_resolution">resolution</code></td>
<td>

<p>positive integer; the minimum resolution requested
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_distinct">distinct</code></td>
<td>

<p>logical; if TRUE (default), restricts counting vector to 0/1 entries, which means that the resulting array is requested to have distinct rows; otherwise, duplicate rows are permitted, i.e. the counting vector can have arbitrary non-negative integers. Designs with distinct runs are usually better; in addition, binary variables are easier to handle by the optimization algorithm. Nevertheless, there are occasions where a better array is found faster with option <code>distinct=FALSE</code>, even if it has distinct rows.
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_start">start</code></td>
<td>

<p>a starting value for the algorithm: can be a array matrix with entries 1 to number of levels for each column, or a counting vector for the full factorial in lexicographic order; if specified, <code>start</code> must specify an array with the appropriate number of rows and columns, the requested resolution and, if <code>distinct = TRUE</code>, also contain distinct rows (matrix) or 0/1 elements only. <code>start</code> cannot be combined with <code>search.orders=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_forced">forced</code></td>
<td>

<p>for <code>resolution &gt; 1</code> only;<br />
runs to force into the solution design; can be given as an array matrix with the appropriate number of columns and less than <code>nruns</code> rows or a counting vector for the full factorial in lexicographic order with sum smaller than <code>nruns</code>; if <code>distinct=TRUE</code>, <code>forced</code> must have distinct rows (matrix) or 0/1 elements only.
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_formosek">forMosek</code></td>
<td>

<p>logical</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_file">file</code></td>
<td>

<p>character string that provides the path to the save file
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_qco">qco</code></td>
<td>

<p>an object of class <code>qco</code> that can be used as input for function <code>Rmosek::mosek</code>
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_qcoinfo">qcoinfo</code></td>
<td>

<p>contains information on the <code>qco</code> object (keeping that information in <code>qco</code> itself hinders execution of <code>Rmosek::mosek</code>)
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_cvec">cvec</code></td>
<td>

<p>coefficients of linear objective function
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_bvec">bvec</code></td>
<td>

<p>RHS of the constraints
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_amat">Amat</code></td>
<td>

<p>matrix of coefficients for the LHS of the constraints
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_bsense">bsense</code></td>
<td>

<p>directions of constraints (character vector with elements <code>"E"</code> for equal, <code>"G"</code> for greater, <code>"L"</code> for less or <code>"N"</code> for not restricted.
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_boundmat">boundmat</code></td>
<td>

<p>matrix of lower (first row) and upper (second row) bounds for the variables
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_name">name</code></td>
<td>

<p>name to be written into the name field of the mps file
</p>
</td></tr>
<tr><td><code id="create_MIQP.Rd_+3A_commentline">commentline</code></td>
<td>

<p>comment to be written directly underneath the name (comments have to start with a *)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions do <em>not</em> do any problem solving, they serve the sole purpose of exporting problems so that they can be addressed by solvers other than Mosek or Gurobi. The target solver must be able to process the MPS format.
</p>
<p><code>write_MPSILP</code> writes a single problem to an MPS file. The function is used by function <code><a href="#topic+write_MPSILPlist">write_MPSILPlist</a></code>.
</p>
<p><code>create_MIQP</code> creates a quadratic problem in MPS format, using a general quadratic representation (section <code>Q</code>) for external solvers (default) or Mosek format with conic quadratic constraints (<code>forMosek=TRUE</code>); the function is used by function <code><a href="#topic+write_MPSMIQP">write_MPSMIQP</a></code>.
</p>
<p>The start array for <code>create_MIQP</code> can be made available from a previous linear optimization (though this is not enforced).
If an admissible start array is provided, <code>write_MPSMIQP</code> initially prints the GWLP of that start array.
Otherwise, it warns of inadmissibility. The start value cannot be stored in the MPS file. Instead, for a non-NULL start array,
a separate file (suffix <code>.start</code>) is created, and users have to work out how they can make their solver use that start solution.
Note that the availability of a start array can improve the ability of a solver to find an optimum solution. However, this is not always the case,
there are also instances for which a better solution is found without providing a start solution.
</p>
<p>Note that it can take a long time to write the problems, if the problem has many variables (the number of variables is <code>prod(nlevels)</code>).
</p>


<h3>Value</h3>

<p>Function <code>create_MIPQ</code> creates a list object of class <code>qco</code>, see also section &quot;Details&quot;.
</p>
<p>Function <code>write_MPSILP</code> does not return a value.
</p>


<h3>Note</h3>

<p>The functions are not meant for situations, for which a full factorial design would be huge. Even though the functions do not solve anything, MPS files will be very large and writing them will be quite slow for such cases.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Groemping, U. and Fontana, R. (2019). An Algorithm for Generating Good Mixed Level Factorial Designs. <em>Computational Statistics &amp; Data Analysis</em> <b>137</b>, 101-114. doi:10.1016/j.csda.2019.01.020.
</p>
<p>Mosek ApS (2017a). MOSEK version w.x.y.z documentation. Accessible at: <a href="https://www.mosek.com/documentation/">https://www.mosek.com/documentation/</a>. This package has been developed using version 8.1.0.23 (accessed August 29 2017).
</p>
<p>Mosek ApS (2017b). MOSEK Rmosek Package 8.1.y.z. <a href="https://docs.mosek.com/8.1/rmosek/index.html">https://docs.mosek.com/8.1/rmosek/index.html</a>.
<em>!!! In normal R speak, this is the documentation of the Rmosek package version 8.0.69 (or whatever comes next), when applied on top of the Mosek version 8.1.y.z (this package has been devoloped with Mosek version 8.1.0.23 and will likely not work for Mosek versions before 8.1). !!! (accessed August 29 2017)</em>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+write_MPSILPlist">write_MPSILPlist</a></code> and <code><a href="#topic+write_MPSMIQP">write_MPSMIQP</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## can also be run with gurobi_MIParray instead of mosek_MIParray
## there are of course better ways to obtain good arrays for these parameters
## (e.g. function FrF2 from package FrF2)
problemlist &lt;- create_ILPlist(16, c(2,2,4,8), resolution=2, kmax=4)
feld
names(attributes(feld))
attr(feld, "MIPinfo")$info

## using a start value
start &lt;- DoE.base::L16.2.8.8.1[,1:5]
feld &lt;- mosek_MIParray(16, rep(2,5), resolution=4, start=start)

## counting vector representation of the start value could also be used
DoE.MIParray:::dToCount(start-1)
   ## "-1", because the function requires values starting with 0
   ## 32 elements for the full factorial in lexicographic order, 16 ones for the runs

## extending an existing array
force &lt;- matrix(as.numeric(as.matrix(DoE.base::undesign(DoE.base::oa.design(L8.2.7)))), nrow=8)
feld &lt;- mosek_MIParray(16, rep(2,7), resolution=3, kmax=4, forced=force)
attr(feld, "MIPinfo")$info

## End(Not run)
</code></pre>

<hr>
<h2 id='dToCount.Rd'>
Functions to switch between count and array representation of an array
</h2><span id='topic+dToCount'></span><span id='topic+countToDmixed'></span><span id='topic+ff'></span>

<h3>Description</h3>

<p>dToCount rearranges an array into count vector format. countToDmixed rearranges a count vector representation into an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dToCount(d, nlevels=NULL, startfrom1=FALSE)
countToDmixed(nlevels, count)
ff(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dToCount.Rd_+3A_d">d</code></td>
<td>

<p>an array (matrix with runs as rows and factors as columns)
</p>
</td></tr>
<tr><td><code id="dToCount.Rd_+3A_nlevels">nlevels</code></td>
<td>

<p>vector of integers (&gt;=2); numbers of factor levels
</p>
</td></tr>
<tr><td><code id="dToCount.Rd_+3A_startfrom1">startfrom1</code></td>
<td>

<p>logical; if TRUE, values are from 1 to <code>nlevels</code>; the default is that values are from 0 to <code>nlevel -1</code>
</p>
</td></tr>
<tr><td><code id="dToCount.Rd_+3A_count">count</code></td>
<td>

<p>vector of <code>prod(nlevels)</code> nonnegative integers; <br />
the number of times the respective run of the full factorial in lexicographic order (as produced by <code>ff(nlevels)</code>) occurs in the array
</p>
</td></tr>
<tr><td><code id="dToCount.Rd_+3A_...">...</code></td>
<td>

<p>vector of integers (&gt;=2) or the integers themselves, separated by commata
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dToCount</code> transforms an array into count representation. If all array columns contain all potential factor levels, nlevels does not need to be specified. Otherwise, <code>nlevels</code> is needed.
</p>
<p><code>countToDmixed</code> transforms the count representation of an array (counts refer to the rows of <code>ff(nlevels)</code>) into an array
</p>


<h3>Value</h3>

<p><code>dToCount</code> produces a vector of length <code>prod(nlevels)</code>,<br />
<code>countToDmixed</code> produces a matrix with <code>sum(count)</code> rows and <code>length(nlevels)</code> columns,<br />
<code>countToDmixed</code> produces a matrix with <code>prod(nlevels)</code> rows and <code>length(nlevels)</code> columns.<br />
</p>


<h3>Note</h3>

<p>The size of the full factorial design (produced with <code>ff</code>) is a limiting factor for using the functionality of this package.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Groemping, U. (2020). DoE.MIParray: an R package for algorithmic creation of orthogonal arrays. <em>Journal of Open Research Software</em>, <b>8: 24</b>. DOI: https://doi.org/10.5334/jors.286
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ff(c(2,2,4))[1:6,]   ## first six rows of the full factorial only
d
## the count vector must have 2*2*4=16 elements,
## the first six must be 1, the last ten must be zero
dToCount(d)               ## does not produce the desired result,
                          ## because the first column of d
                          ## does not contain both levels
(d_as_count &lt;- dToCount(d, nlevels=c(2,2,4)))
                          ## corresponds to the above way of creating d
dToCount(d, nlevels=c(2,2,5))  ## would correspond to a different reality,
                               ## where the third factor has in fact 5 levels,
                               ## of which only four are in the array
countToDmixed(c(2,2,4), d_as_count)
                          ## creates d from the count representation
</code></pre>

<hr>
<h2 id='functionsFromDoE.base'>
Functions from package DoE.base
</h2><span id='topic+oa_feasible'></span><span id='topic+lowerbound_AR'></span><span id='topic+length2'></span><span id='topic+length3'></span><span id='topic+length4'></span><span id='topic+length5'></span><span id='topic+contr.XuWu'></span><span id='topic+GWLP'></span><span id='topic+ICFTs'></span><span id='topic+SCFTs'></span>

<h3>Description</h3>

<p>These functions from DoE.base are exported from DoE.MIParray, 
because they are especially important for its use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oa_feasible(nruns, nlevels, strength = 2, verbose = TRUE, returnbound = FALSE)
lowerbound_AR(nruns, nlevels, R, crit = "total")
length2(design, with.blocks = FALSE, J = FALSE)
length3(design, with.blocks = FALSE, J = FALSE, rela = FALSE)
length4(design, with.blocks = FALSE, separate = FALSE, J = FALSE, rela = FALSE)
length5(design, with.blocks = FALSE, J = FALSE, rela = FALSE)
contr.XuWu(n, contrasts=TRUE)
GWLP(design, ...)
SCFTs(design, digits = 3, all = TRUE, resk.only = TRUE, kmin = NULL, kmax = ncol(design),
   regcheck = FALSE, arft = TRUE, cancors = FALSE, with.blocks = FALSE)
ICFTs(design, digits = 3, resk.only = TRUE, kmin = NULL, kmax = ncol(design), 
   detail = FALSE, with.blocks = FALSE, conc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="functionsFromDoE.base_+3A_nruns">nruns</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_nlevels">nlevels</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_strength">strength</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_verbose">verbose</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_returnbound">returnbound</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_r">R</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_crit">crit</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_design">design</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_with.blocks">with.blocks</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_j">J</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_rela">rela</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_n">n</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_contrasts">contrasts</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_separate">separate</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_digits">digits</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_all">all</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_resk.only">resk.only</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_kmin">kmin</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_kmax">kmax</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_regcheck">regcheck</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_arft">arft</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_cancors">cancors</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_detail">detail</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_conc">conc</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
<tr><td><code id="functionsFromDoE.base_+3A_...">...</code></td>
<td>
<p>see <span class="pkg">DoE.base</span></p>
</td></tr>
</table>


<h3>Details</h3>

<p>for documentation of the functions, see the links under &quot;See also&quot;
</p>


<h3>Value</h3>

<p>for documentation of the functions, see the links under &quot;See also&quot;
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>for documentation of the functions, see the links under &quot;See also&quot;
</p>


<h3>See Also</h3>

<p>See also <code><a href="DoE.base.html#topic+oa_feasible">oa_feasible</a></code>, <code><a href="DoE.base.html#topic+lowerbound_AR">lowerbound_AR</a></code>, 
<code><a href="DoE.base.html#topic+length2">length2</a></code>, <code><a href="DoE.base.html#topic+length3">length3</a></code>, <code><a href="DoE.base.html#topic+length4">length4</a></code>, 
<code><a href="DoE.base.html#topic+length5">length5</a></code>, <code><a href="DoE.base.html#topic+GWLP">GWLP</a></code>, <code><a href="DoE.base.html#topic+SCFTs">SCFTs</a></code>, 
<code><a href="DoE.base.html#topic+ICFTs">ICFTs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oa_feasible(24, c(2,3,4,6),2)
lowerbound_AR(24, c(2,3,4,6),2)
</code></pre>

<hr>
<h2 id='mosek_MIParray'>
Functions to Create a MIP Based Array Using Gurobi or Mosek
</h2><span id='topic+mosek_MIParray'></span><span id='topic+gurobi_MIParray'></span>

<h3>Description</h3>

<p>The functions create an array with specified minimum resolution and optionally also optimized word length pattern based on mixed integer programming with the commercial software Gurobi (free academic license available) or Mosek (free academic license available).
Creation is done from scratch, or using a user-specified starting value, or extending an existing array. Important: Installation of Gurobi and/of Mosek as well as the corresponding R packages is necessary. The R package gurobi comes with the software, the current version of the R package Rmosek has to be obtained from vendor's website (CRAN version is outdated!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosek_MIParray(nruns, nlevels, resolution = 3, kmax = max(resolution, 2),
   distinct = TRUE, detailed = 0, start=NULL, forced=NULL, find.only = FALSE,
   maxtime = Inf, nthread=2, mosek.opts = list(verbose = 10, soldetail = 1),
   mosek.params = list(dparam = list(LOWER_OBJ_CUT = 0.5, MIO_TOL_ABS_GAP = 0.2,
      INTPNT_CO_TOL_PFEAS = 1e-05, INTPNT_CO_TOL_INFEAS = 1e-07),
      iparam = list(PRESOLVE_LINDEP_USE="OFF", LOG_MIO_FREQ=100)))
gurobi_MIParray(nruns, nlevels, resolution = 3, kmax = max(resolution, 2),
  distinct = TRUE, detailed = 0, start=NULL, forced=NULL, find.only = FALSE,
  maxtime = 60, nthread = 2, heurist=0.5, MIQCPMethod=0, MIPFocus=1,
  gurobi.params = list(BestObjStop = 0.5, LogFile=""))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosek_MIParray_+3A_nruns">nruns</code></td>
<td>

<p>positive integer; number of runs
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_nlevels">nlevels</code></td>
<td>

<p>vector of integers (&gt;=2); numbers of factor levels
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_resolution">resolution</code></td>
<td>

<p>positive integer; the minimum resolution requested
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_kmax">kmax</code></td>
<td>

<p>integer, <code>kmax &gt;= resolution</code> and <code>kmax &gt;= 2</code> are required; the largest number of words to be optimized (default: <code>kmax = resolution</code>). (If <code>find.only=TRUE</code>, optimization of numbers of words is suppressed.)
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_distinct">distinct</code></td>
<td>

<p>logical; if TRUE (default), restricts counting vector to 0/1 entries, which means that the resulting array is requested to have distinct rows; otherwise, duplicate rows are permitted, i.e. the counting vector can have arbitrary non-negative integers. Designs with distinct runs are usually better; in addition, binary variables are easier to handle by the optimization algorithm. Nevertheless, there are occasions where a better array is found faster with option <code>distinct=FALSE</code>, even if it has distinct rows.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_detailed">detailed</code></td>
<td>

<p>integer (default 0); determines the output detail: positive values imply inclusion of a problem and solution history (attribute <code>history</code>), values of at least 3 add the lists of optimization matrices (Us and Hs, attribute <code>matrices</code>).
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_start">start</code></td>
<td>

<p>for <code>resolution &gt; 1</code> only;<br />
a starting value for the algorithm: can be a array matrix with entries 1 to number of levels for each column, or a counting vector for the full factorial in lexicographic order; if specified, <code>start</code> must specify an array with the appropriate number of rows and columns, the requested resolution and, if <code>distinct = TRUE</code>, also contain distinct rows (matrix) or 0/1 elements only.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_forced">forced</code></td>
<td>

<p>for <code>resolution &gt; 1</code> only;<br />
runs to force into the solution design; can be given as an array matrix with the appropriate number of columns and less than <code>nruns</code> rows or a counting vector for the full factorial in lexicographic order with sum smaller than <code>nruns</code>; if <code>distinct=TRUE</code>, <code>forced</code> must have distinct rows (matrix) or 0/1 elements only.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_find.only">find.only</code></td>
<td>

<p>logical; if FALSE (default), a design of the requested resolution is found, which is subsequently improved in terms of its word lengths up to words of length <code>kmax</code>; otherwise, the function only attempts to find an array of the requested resolution, without optimizing word lenghts.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_maxtime">maxtime</code></td>
<td>

<p>the maximum run time in seconds per Gurobi or Mosek optimization request (the overall run time may become (much) larger); in case of conflict between <code>maxtime</code> and an explicit timing request in
<code>gurobi.params$TimeLimit</code> or <code>mosek.params$dparam$$MIO_MAX_TIME</code>, the stricter request prevails; the default values differ between Gurobi (60) and Mosek (Inf), because Mosek runs can be easily escaped, while Gurobi runs cannot.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_nthread">nthread</code></td>
<td>

<p>the number of threads (=cores) to use;
there are also the Mosek parameter <code>NUM_THREADS</code> and the Gurobi parameter <code>Threads</code>; in case of conflict, the smaller request prevails.
For using Gurobi's or Mosek's default (which is in most cases the use of all available cores), choose <code>nthread=0</code>.<br />
CAUTION: <code>nthread</code> should not be chosen larger than the available number of cores. Gurobi warns that performance will deteriorate, but was observed to perform OK. For Mosek, performance will strongly deteriorate, and for extreme choices the R session might even crash (even for small problems)!
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_mosek.opts">mosek.opts</code></td>
<td>

<p>list of Mosek options; these have to be looked up in Mosek documentation
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_mosek.params">mosek.params</code></td>
<td>

<p>list of mosek parameters, which can have the list-valued elements <code>dparam</code>, <code>iparam</code> and/or <code>sparam</code>; their use has to be looked up in the RMosek documentation.
The arguments <code>maxtime</code> and <code>nthread</code> correspond to the <code>dparam$MIO_MAX_TIME</code> and
<code>iparam$NUM_THREADS</code> specifications. Conflicts are resolved as stated in their documentation.
</p>
<p>The element <code>dparam$LOWER_OBJ_CUT</code> can be used to incorporate a best
bound found in an earlier successless optimization attempt; per default, it is set to 0.5, since
the target function can take on integer values only and cannot be negative.
</p>
<p>If a valid starting value is not accepted by Mosek, it may be worthwhile to increase <code>dparam$INTPNT_CO_TOL_PFEAS</code>.
</p>
<p>Users of Mosek versions 9 and higher may want to play with <code>iparam$MIO_SEED</code>, which was introduced as a new parameter with Mosek version 9 (default: 42);
different seeds modify the path taken through the search space. Varying the seed may be an alternative to searching over different level orderings with function <code><a href="#topic+mosek_MIPsearch">mosek_MIPsearch</a></code>.
</p>
<p>Note that a user specified <code>mosek.params</code> should always contain the specifications shown under Usage. Exceptions: <code>LOWER_OBJ_CUT</code> is always specified to be at least 0.5, i.e. this option can be safely omitted without loosing anything, and intentional changes can of course be made.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_heurist">heurist</code></td>
<td>

<p>the proportion heuristics time used by Gurobi in quadratic objective optimization (default 0.5; Gurobi default is 0.05);
there is also the Gurobi parameter Heuristics; in case of conflict, the larger request prevails;
the setting for heurist is deactivated for the initial linear problem which is always run with the Gurobi default. It can be worthwhile playing with this option for improving the run time for certain settings; for example, with <code>nruns=48</code> and <code>nlevels=c(2,2,3,4,4)</code>, <code>heurist=0.05</code> performs better than the default 0.5.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_miqcpmethod">MIQCPMethod</code></td>
<td>

<p>the method used by Gurobi for quadratically constrained optimization (default 0; other possibilities -1 (Gurobi decides) or 1);
there is also the Gurobi parameter MIQCPMethod; in case of conflict, the method is set to &quot;0&quot;; this choice is made because it proved beneficial in many cases explored (although there also were a few cases which fared better with Gurobi's default).
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_mipfocus">MIPFocus</code></td>
<td>

<p>the strategy used by Gurobi for quadratically constrained optimization (default 1: focus on finding good feasible solutions fast; other possibilities: 0 (Gurobi decides/compromise), 2 or 3 (focus on increasing the lower bound fast));
there is also the Gurobi parameter MIPFocus; in case of conflict, MIPFocus is set to &quot;0&quot;;
the setting for MIPFocus is deactivated for the initial linear problem which is always run with the Gurobi default.
</p>
</td></tr>
<tr><td><code id="mosek_MIParray_+3A_gurobi.params">gurobi.params</code></td>
<td>

<p>list of gurobi parameters; these have to be looked up in Gurobi documentation;
the arguments <code>maxtime</code>, <code>heurist</code>, <code>MIQCPMethod</code> and <code>MIPFocus</code> refer to the Gurobi parameters &quot;TimeLimit&quot;, &quot;Heuristics&quot;, &quot;MIQCPMethod&quot; and &quot;MIPFocus&quot;, respectively. See their documentation for what happens in case of conflict.
</p>
<p>The Gurobi parameter <code>BestObjStop</code> can be used to incorporate a best
bound found in an earlier successless optimization attempt; per default, it is set to 0.5, since
the objective function can take on integer values only and cannot be negative.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions initially solve a linear optimization problem for obtaining a design with the requested resolution;
if a start value is provided, this step is skipped; if <code>find.only=TRUE</code>, the functions stop after this step.
If <code>find.only=FALSE</code>, the number of shortest words is optimized, followed by the numbers of words of length up to <code>kmax</code>.
The argument <code>forced</code> allows to specify an existing array that is to be extended (e.g. to double or triple size;
extension by a small number of runs will usually not be possible) in an optimized way.
</p>
<p>For all but very small problems, it is likely advisable to choose <code>kmax</code> equal to the requested resolution (the default), and to proceed to longer words only after it has been made sure that the shortest word length has been optimized (as far as possible with reasonable effort). Further improvements of the same can be attempted by applying <code>gurobi_MIPcontinue</code> or <code>mosek_MIPcontinue</code> to the result object returned by the function. Note that it is possible to switch from using Mosek to using Gurobi or vice versa.
An example for an optimization sequence can be found in the package overview at <code><a href="#topic+DoE.MIParray">DoE.MIParray</a></code>.
</p>
<p>In case of long run times, escaping from the gurobi run will most likely be unsuccessful and might even leave R in an unstable state; thus, one should think carefully about the affordable run times. On the contrary, it should usually be doable to escape a Mosek run; the remaining code of the function will still be executed and will return the final state.
</p>
<p>Besides the run time, the number of threads is a very important resource control parameter. The default assumes that the user wants to use two of the computer's multiple cores. For using Gurobi's or Mosek's default (which is in most cases the use of all available cores), choose <code>nthread=0</code>.
</p>
<p>The default Gurobi parameters have been chosen after systematic experimentation with a limited set of scenarii und Gurobi version 7.5.1.  The choice of <code>MIQCPMethod=0</code> was instrumental in many cases; changing it to -1 may occasionally be tried. The MIPFocus parameter also appears beneficial in many cases; changing it to 0 (leave choice to Gurobi) can be an option; it was slightly better than choice 1 for mixed level designs with relatively small run sizes, while choice &ldquo;1&rdquo; was substantially better for the other cases. The heuristics proportion has been chosen as 0.5, because this choice seemed the best compromise for the situations considered. Note, however, that these parameters deteriorate performance for very simple cases, e.g. the test cases of Fontana (2017). For such cases, using <code>MIQCPMethod=-1</code>, <code>MIPFocus=0</code> and <code>heurist=0.05</code> will be preferrable; the defaults were chosen in this way, since doubling or even tripling very short run times was decided to be less detrimental than making more difficult problems completely intractable.
</p>
<p>For Gurobi, several optimization parameters are switched off for the initial linear optimization step:
the parameters <code>Heuristics</code> and <code>MIPFocus</code> are reset to their defaults (0.05 and 0).
</p>
<p>Gurobi always stores the file &quot;gurobi.log&quot; in the working directory; even if storage of the log is
suppressed with the default option <code>LogFile=""</code> or directed to another location by specifying a path, the default file &quot;gurobi.log&quot; is created and filled with a small amount of content. Thus, make sure to use a different file name when intentionally storing some log.
</p>
<p>For Mosek, storing log output can be accomplished by directing the printed output to a suitable storing location. Note that the setting <code>iparam$LOG_MIO_FREQ = 100</code> reduces the frequency of printing a log line for branch-and-cut optimization by the factor 10 versus the default. Parallelization in Mosek is not well-protected against interference from screen activity (for example). Thus, one should switch off logging to screen or otherwise, when working with many (all available) threads in parallel (<code>LOG=0</code> instead of <code>LOG_MIO_FREQ = 100</code> in the list <code>iparam</code>).
</p>


<h3>Value</h3>

<p>an array of class <code><a href="DoE.base.html#topic+oa">oa</a></code>, possibly with the following attributes:
<code>MIPinfo</code>, which is either an object of class <code>qco</code> or a simple list with information (which would be the <code>info</code> element of the object of class <code>qco</code> in case the last optimization was not successful), <code>history</code> as a list of problem and solution lists, and <code>matrices</code> as a list of matrix lists. Presence or absence of <code>history</code> and <code>matrices</code> is controlled by option <code>detailed</code>, while <code>MIPInfo</code> is present if the optimization can be potentially improved by improving the last step (stop because of time limit and not because of optimal value) or by improving the number of longer words.
</p>


<h3>Installation</h3>

<p>Gurobi and Mosek need to be separately installed; please follow vendors' instructions; see also <code><a href="#topic+mosek_MIPsearch">mosek_MIPsearch</a></code> for more comments.
</p>


<h3>Note</h3>

<p>The functions are not meant for situations, for which a full factorial design would be huge; the mixed integer problem to be solved has at least <code>prod(nlevels)</code> binary or general integer variables and will likely be untractable, if this number is too large. (For extending an existing designs, since some variables are fixed, the limit moves out a bit.)
</p>
<p>Please be aware that escaping a Gurobi run will be not unlikely to leave the computer in an unstable situation.  If function <code>gurobi_MIParray</code> is successfully interrupted by the &lt;ESC&gt; key or &lt;Ctrl&gt;-&lt;C&gt;, it will usually be necessary to restart R in order to free all CPU usage.
</p>
<p>If a Mosek run is interrupted by the &lt;ESC&gt; key, it is advised to execute the command <code>Rmosek::mosek_clean()</code> afterwards; this may help prevent problems from unclean closes of mosek runs.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Fontana, R. (2017). Generalized Minimum Aberration mixed-level orthogonal arrays: a general approach based on sequential integer quadratically constrained quadratic programming. <em>Communications in Statistics – Theory Methods</em> <b>46</b>, 4275-4284.
</p>
<p>Groemping, U. and Fontana R. (2019). An Algorithm for Generating Good Mixed Level Factorial Designs. <em>Computational Statistics &amp; Data Analysis</em> <b>137</b>, 101-114.
</p>
<p>Groemping, U. (2020). DoE.MIParray: an R package for algorithmic creation of orthogonal arrays. <em>Journal of Open Research Software</em>, <b>8: 24</b>. DOI: https://doi.org/10.5334/jors.286
</p>
<p>Gurobi Optimization Inc. (2017). Gurobi Optimizer Reference Manual. <a href="https://www.gurobi.com:443/documentation/">https://www.gurobi.com:443/documentation/</a>.
</p>
<p>Mosek ApS (2017a). MOSEK version w.x.y.z documentation. Accessible at: <a href="https://www.mosek.com/documentation/">https://www.mosek.com/documentation/</a>. This package has been developed using version 8.1.0.23 (accessed August 29 2017).
</p>
<p>Mosek ApS (2017b). MOSEK Rmosek Package 8.1.y.z. <a href="https://docs.mosek.com/8.1/rmosek/index.html">https://docs.mosek.com/8.1/rmosek/index.html</a>.
<em>!!! In normal R speak, this is the documentation of the Rmosek package version 8.0.69 (or whatever comes next), when applied on top of the Mosek version 8.1.y.z (this package has been devoloped with Mosek version 8.1.0.23 and will likely not work for Mosek versions before 8.1). !!! (accessed August 29 2017)</em>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+mosek_MIPsearch">mosek_MIPsearch</a></code> and <code><a href="#topic+gurobi_MIPsearch">gurobi_MIPsearch</a></code> for searching over <code>nlevels</code> orderings,
<code><a href="#topic+mosek_MIPcontinue">mosek_MIPcontinue</a></code> and <code><a href="#topic+gurobi_MIPcontinue">gurobi_MIPcontinue</a></code> for continuing an uncompleted optimization,
<code><a href="DoE.base.html#topic+show.oas">show.oas</a></code> from package <span class="pkg">DoE.base</span> for catalogued orthogonal arrays,
and <code><a href="DoE.base.html#topic+oa_feasible">oa_feasible</a></code> from package <span class="pkg">DoE.base</span> for checking feasibility of requested array strength (resolution - 1) for combinations of <code>nruns</code> and <code>nlevels</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## can also be run with gurobi_MIParray instead of mosek_MIParray
## there are of course better ways to obtain good arrays for these parameters
## (e.g. function FrF2 from package FrF2)
feld &lt;- mosek_MIParray(16, rep(2,7), resolution=3, kmax=4)
feld
names(attributes(feld))
attr(feld, "MIPinfo")$info

## using a start value
start &lt;- DoE.base::L16.2.8.8.1[,1:5]
feld &lt;- mosek_MIParray(16, rep(2,5), resolution=4, start=start)

## counting vector representation of the start value could also be used
DoE.MIParray:::dToCount(start-1)
   ## "-1", because the function requires values starting with 0
   ## 32 elements for the full factorial in lexicographic order, 16 ones for the runs

## extending an existing array
force &lt;- matrix(as.numeric(as.matrix(DoE.base::undesign(DoE.base::oa.design(L8.2.7)))), nrow=8)
feld &lt;- mosek_MIParray(16, rep(2,7), resolution=3, kmax=4, forced=force)
attr(feld, "MIPinfo")$info

## End(Not run)
</code></pre>

<hr>
<h2 id='mosek_MIPcontinue'>
Functions to Continue Optimization from Stored State
</h2><span id='topic+mosek_MIPcontinue'></span><span id='topic+gurobi_MIPcontinue'></span>

<h3>Description</h3>

<p>These functions continue optimization for a MIP-based array from a stored state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosek_MIPcontinue(qco, improve = TRUE, maxtime = Inf, nthread = 2,
      mosek.opts = list(verbose = 10, soldetail = 1),
      mosek.params = list(dparam = list(LOWER_OBJ_CUT = 0.5,
      MIO_TOL_ABS_GAP = 0.2, INTPNT_CO_TOL_PFEAS = 1e-05,
      INTPNT_CO_TOL_INFEAS = 1e-07),
      iparam = list(PRESOLVE_LINDEP_USE="OFF", LOG_MIO_FREQ=100)))
gurobi_MIPcontinue(qco, improve = TRUE, maxtime = 60, nthread = 2,
      heurist = 0.05, MIQCPMethod = 0, MIPFocus = 0,
      gurobi.params =list(BestObjStop = 0.5, LogFile=""))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosek_MIPcontinue_+3A_qco">qco</code></td>
<td>

<p>object of class <code>qco</code>, created by a function in the package; or object of class <code>oa</code> that has a <code>qco</code> object as its <code>MIPinfo</code> attribute
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_improve">improve</code></td>
<td>

<p>logical; if TRUE (default), try to improve the already obtained solution for word length <code>qco$info$last.k</code>, otherwise optimize the next word length
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_maxtime">maxtime</code></td>
<td>

<p>time in seconds for the optimization call; defaults differ for Mosek (Inf) and Gurobi (60), because a Mosek run can be easily escaped (&lt;ESC&gt;-key), contrary to a Gurobi run
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_nthread">nthread</code></td>
<td>

<p>number of cores to use (0=all cores)<br />
CAUTION: <code>nthread</code> should not exceed the available number of cores. Gurobi warns that performance might deteriorate. For Mosek, performance WILL strongly deteriorate, and for extreme choices the R session might even crash (even for small problems)!
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_heurist">heurist</code></td>
<td>

<p>for <code>gurobi_MIPcontinue</code> only: the percentage of time (number between 0 and 1) spent on heuristics
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_miqcpmethod">MIQCPMethod</code></td>
<td>

<p>for <code>gurobi_MIPcontinue</code> only: the choice of optimization method; the default &quot;0&quot; has been observed to be better than Gurobi's default for most cases (Gurobi version 7.5.1); &quot;-1&quot; leaves the choice to Gurobi, &quot;1&quot; chooses the other method
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_mipfocus">MIPFocus</code></td>
<td>

<p>for <code>gurobi_MIPcontinue</code> only: the choice of strategy; the default &quot;0&quot; leaves this choice to Gurobi; for finding better feasible solutions, &quot;1&quot; is recommended; for improving the speed of increasing the lower bound for eventually proving optimality, &quot;3&quot; can be tried
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_mosek.opts">mosek.opts</code></td>
<td>

<p>mosek options
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_mosek.params">mosek.params</code></td>
<td>

<p>Mosek parameters
</p>
</td></tr>
<tr><td><code id="mosek_MIPcontinue_+3A_gurobi.params">gurobi.params</code></td>
<td>

<p>Gurobi parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that it is possible to continue optimization with Gurobi, if it was started with Mosek, and vice versa. The tool will transform the problem into the respective other format.
</p>
<p>Usage of options is analogous to functions <code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code> and <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code>, respectively, where these are described in more detail.
</p>
<p>For some applications, usability of <code>mosek_MIPcontinue</code> is hampered in Mosek versions up to 8 by the fact that Mosek's presolve routines identify additional integer variables and fail to recognise user-specified starting values for these that are not exactly integer-valued. According to Mosek ApS, this is scheduled to be remedied with Mosek Version 9 (version 9 is now available; I have not checked whether this was indeed fixed).
</p>


<h3>Value</h3>

<p>an array of class <code>link[DoE.base]{oa}</code>, if not optimized to GMA with info for further continuation (see documentation of <code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code> or <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code>)
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+DoE.MIParray">DoE.MIParray</a></code> for examples of the role of the <code>MIPcontinue</code> functions, 
<code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code> and <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code> for more detail on the optimization arguments, 
<code><a href="#topic+mosek_MIPsearch">mosek_MIPsearch</a></code> and <code><a href="#topic+gurobi_MIPsearch">gurobi_MIPsearch</a></code> for searching over <code>nlevels</code> orderings 
(which may be a very successful alternative to trying to improve an initial optimization based on a fixed <code>nlevels</code> vector).
</p>

<hr>
<h2 id='mosek_MIPsearch'>
Functions to Search for optimum MIP Based Array Using Gurobi or Mosek
</h2><span id='topic+mosek_MIPsearch'></span><span id='topic+gurobi_MIPsearch'></span>

<h3>Description</h3>

<p>The functions search through different orderings of the nlevels vector 
with the goal to create an array with minimum resolution and optimized shortest 
word length. They create the orders and call gurobi_MIParray or mosek_MIParray 
for each order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosek_MIPsearch(nruns, nlevels, resolution = 3, maxtime = 60, 
   stopearly=TRUE, listout=FALSE, orders=NULL, 
   distinct = TRUE, detailed = 0, forced=NULL, find.only=TRUE,
   nthread=2, mosek.opts = list(verbose = 1, soldetail = 1),
   mosek.params = list(dparam = list(LOWER_OBJ_CUT = 0.5, MIO_TOL_ABS_GAP = 0.2,
      INTPNT_CO_TOL_PFEAS = 1e-05, INTPNT_CO_TOL_INFEAS = 1e-07),
      iparam = list(PRESOLVE_LINDEP_USE="OFF", LOG_MIO_FREQ=100)))
gurobi_MIPsearch(nruns, nlevels, resolution = 3, maxtime = 60, 
   stopearly=TRUE, listout=FALSE, orders=NULL, 
   distinct = TRUE, detailed = 0, forced=NULL, find.only=TRUE, 
   nthread = 2, heurist=0.5, MIQCPMethod=0, MIPFocus=1,
   gurobi.params = list(BestObjStop = 0.5, OutputFlag=0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosek_MIPsearch_+3A_nruns">nruns</code></td>
<td>

<p>positive integer; number of runs
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_nlevels">nlevels</code></td>
<td>

<p>vector of integers (&gt;=2); numbers of factor levels
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_resolution">resolution</code></td>
<td>

<p>positive integer; the minimum resolution requested
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_maxtime">maxtime</code></td>
<td>

<p>the maximum run time in seconds per Gurobi or Mosek optimization request (the overall run time may become (much) larger); in case of conflict between <code>maxtime</code> and an explicit timing request in
<code>gurobi.params$TimeLimit</code> or <code>mosek.params$dparam$$MIO_MAX_TIME</code>, the stricter request prevails; the default values differ between Gurobi (60) and Mosek (Inf), because Mosek runs can be easily escaped, while Gurobi runs cannot.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_stopearly">stopearly</code></td>
<td>

<p>logical; if TRUE, the search stops if the shortest word length hits the lower bound; set to FALSE if you want longer word lengths to be optimized among several choices with the same shortest word length
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_listout">listout</code></td>
<td>

<p>logical; if TRUE, all experimental plans are stored, instead of only the best one; if <code>stopearly=TRUE</code>, <code>listout=TRUE</code> does not make sense
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_orders">orders</code></td>
<td>

<p>NULL (in which case distinct level orders are automatically determined) or a list of level orders to be searched
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_distinct">distinct</code></td>
<td>

<p>logical; if TRUE (default), restricts counting vector to 0/1 entries, which means that the resulting array is requested to have distinct rows; otherwise, duplicate rows are permitted, i.e. the counting vector can have arbitrary non-negative integers. Designs with distinct runs are usually better; in addition, binary variables are easier to handle by the optimization algorithm. Nevertheless, there are occasions where a better array is found faster with option <code>distinct=FALSE</code>, even if it has distinct rows.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_detailed">detailed</code></td>
<td>

<p>integer (default 0); determines the output detail: positive values imply inclusion of a problem and solution history (attribute <code>history</code>), values of at least 3 add the lists of optimization matrices (Us and Hs, attribute <code>matrices</code>).
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_forced">forced</code></td>
<td>

<p>for <code>resolution &gt; 1</code> only;<br />
runs to force into the solution design; can be given as an array matrix with the appropriate number of columns and less than <code>nruns</code> rows or a counting vector for the full factorial in lexicographic order with sum smaller than <code>nruns</code>; if <code>distinct=TRUE</code>, <code>forced</code> must have distinct rows (matrix) or 0/1 elements only.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_find.only">find.only</code></td>
<td>

<p>logical; if TRUE (default), the function only attempts to find an array of the requested resolution, without optimizing word lenghts; otherwise, a design of the requested resolution is found, which is subsequently improved in terms of its word lengths up to words of length <code>kmax</code>.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_nthread">nthread</code></td>
<td>

<p>the number of threads (=cores) to use;
there are also the Mosek parameter <code>NUM_THREADS</code> and the Gurobi parameter <code>Threads</code>; in case of conflict, the smaller request prevails.
For using Gurobi's or Mosek's default (which is in most cases the use of all available cores), choose <code>nthread=0</code>.<br />
CAUTION: <code>nthread</code> should not be chosen larger than the available number of cores. Gurobi warns that performance will deteriorate, but was observed to perform OK. For Mosek, performance will strongly deteriorate, and for extreme choices the R session might even crash (even for small problems)!
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_mosek.opts">mosek.opts</code></td>
<td>

<p>list of Mosek options; these have to be looked up in Mosek documentation
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_mosek.params">mosek.params</code></td>
<td>

<p>list of mosek parameters, which can have the list-valued elements <code>dparam</code>, <code>iparam</code> and/or <code>sparam</code>; their use has to be looked up in the RMosek documentation.
The arguments <code>maxtime</code> and <code>nthread</code> correspond to the <code>dparam$MIO_MAX_TIME</code> and
<code>iparam$NUM_THREADS</code> specifications. Conflicts are resolved as stated in their documentation.
</p>
<p>The element <code>dparam$LOWER_OBJ_CUT</code> can be used to incorporate a best
bound found in an earlier successless optimization attempt; per default, it is set to 0.5, since
the target function can take on integer values only and cannot be negative.
</p>
<p>If a valid starting value is not accepted by Mosek, it may be worthwhile to increase <code>dparam$INTPNT_CO_TOL_PFEAS</code>.
</p>
<p>Users of Mosek versions 9 and higher may want to play with <code>iparam$MIO_SEED</code>, which was introduced as a new parameter with Mosek version 9 (default: 42); 
different seeds modify the path taken through the search space for a given level ordering; thus, varying seeds can also be the route to choose where searching over level 
orderings is not feasible. 
</p>
<p>Note that a user specified <code>mosek.params</code> should always contain the specifications shown under Usage. Exceptions: <code>LOWER_OBJ_CUT</code> is always specified to be at least 0.5, i.e. this option can be safely omitted without loosing anything, and intentional changes can of course be made.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_heurist">heurist</code></td>
<td>

<p>the proportion heuristics time used by Gurobi in quadratic objective optimization (default 0.5; Gurobi default is 0.05);
there is also the Gurobi parameter Heuristics; in case of conflict, the larger request prevails;
the setting for heurist is deactivated for the initial linear problem which is always run with the Gurobi default. It can be worthwhile playing with this option for improving the run time for certain settings; for example, with <code>nruns=48</code> and <code>nlevels=c(2,2,3,4,4)</code>, <code>heurist=0.05</code> performs better than the default 0.5.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_miqcpmethod">MIQCPMethod</code></td>
<td>

<p>the method used by Gurobi for quadratically constrained optimization (default 0; other possibilities -1 (Gurobi decides) or 1);
there is also the Gurobi parameter MIQCPMethod; in case of conflict, the method is set to &quot;0&quot;; this choice is made because it proved beneficial in many cases explored (although there also were a few cases which fared better with Gurobi's default).
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_mipfocus">MIPFocus</code></td>
<td>

<p>the strategy used by Gurobi for quadratically constrained optimization (default 1: focus on finding good feasible solutions fast; other possibilities: 0 (Gurobi decides/compromise), 2 or 3 (focus on increasing the lower bound fast));
there is also the Gurobi parameter MIPFocus; in case of conflict, MIPFocus is set to &quot;0&quot;;
the setting for MIPFocus is deactivated for the initial linear problem which is always run with the Gurobi default.
</p>
</td></tr>
<tr><td><code id="mosek_MIPsearch_+3A_gurobi.params">gurobi.params</code></td>
<td>

<p>list of gurobi parameters; these have to be looked up in Gurobi documentation;
the arguments <code>maxtime</code>, <code>heurist</code>, <code>MIQCPMethod</code> and <code>MIPFocus</code> refer to the Gurobi parameters &quot;TimeLimit&quot;, &quot;Heuristics&quot;, &quot;MIQCPMethod&quot; and &quot;MIPFocus&quot;, respectively. See their documentation for what happens in case of conflict.
</p>
<p>The Gurobi parameter <code>BestObjStop</code> can be used to incorporate a best
bound found in an earlier successless optimization attempt; per default, it is set to 0.5, since
the objective function can take on integer values only and cannot be negative.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The search functions have been implemented, because the algorithm's behavior may 
strongly depend on the order of factors in case of mixed level arrays. 
In many examples, Mosek quickly improved the objective function which 
then stayed constant for a long time; thus, it may be promising to run 
<code>mosek_MIPsearch</code> with <code>maxtime=60</code> (or even less). See also 
Groemping and Fontana (2019) for examples of successful applications of the search 
functionality.
</p>
<p>Even though Gurobi was less successful as a search tool in the examples that 
were examined so far, it may be helpful for other examples.
</p>
<p>The options suppress printed output from the optimizers themselves.
</p>
<p>Mosek Version 9 has gained a seed argument (<code>iparam$MIO_SEED</code>, 
which implements the Mosek parameter <code>MSK_IPAR_MIO_SEED</code>). 
Playing with seeds in <code>mosek_MIParray</code> may be an alternative to using the search approach, 
because it may lead to different paths through the search space for a fixed ordering of the <code>nlevels</code> vector. 
So far, I have only very little experience with using seeds; user reports are very welcome.
</p>


<h3>Value</h3>

<p>an array of class <code><a href="DoE.base.html#topic+oa">oa</a></code> with the attributes added 
by <code>mosek_MIParray</code> or <code>gurobi_MIParray</code>, resp. <br />
In addition, the attribute <code>optorder</code> contains the vector of level orders that yielded the best design; 
if <code>listout=TRUE</code>, also the attributes <code>orders</code> and <code>allplans</code>.
</p>
<p>Objects with the attribute <code>allplans</code> are quite large. If the attribute is 
no longer needed, it can be removed from an object named <code>obj</code> 
(replace with the name of your object) by the command <br />
<code>attr(obj, "allplans") &lt;- NULL</code>
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Groemping, U. and Fontana R. (2019). An Algorithm for Generating Good Mixed Level Factorial Designs. <em>Computational Statistics &amp; Data Analysis</em> <b>137</b>, 101-114.
</p>
<p>Groemping, U. (2020). DoE.MIParray: an R package for algorithmic creation of orthogonal arrays. <em>Journal of Open Research Software</em>, <b>8: 24</b>. DOI: https://doi.org/10.5334/jors.286
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code> and <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code>,
<code><a href="DoE.base.html#topic+oa_feasible">oa_feasible</a></code> from package <span class="pkg">DoE.base</span> for checking 
feasibility of requested array strength (resolution - 1) 
for combinations of <code>nruns</code> and <code>nlevels</code>, and 
<code><a href="DoE.base.html#topic+lowerbound_AR">lowerbound_AR</a></code> from package <span class="pkg">DoE.base</span> 
for a lower bound for the length R words in a resolution R array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## can also be run with gurobi_MIParray instead of mosek_MIParray
## there are of course better ways to obtain good arrays for these parameters
## (e.g. function FrF2 from package FrF2)
oa_feasible(18, c(2,3,3,3,3), 2)  ## strength 2 array feasible
lowerbound_AR(18, c(2,3,3,3,3), 3)  ## lower bound for A3
## of course not necessary here, the design is found fast
feld &lt;- mosek_MIPsearch(18, c(2,3,3,3,3), stopearly=FALSE, listout=TRUE, maxtime=30)
## even stopearly=TRUE would not stop, because the lower bound 2 is not achievable
feld
names(attributes(feld))
attr(feld, "optorder")
## even for this simple case, running optimization until confirmed optimality 
## would be very slow

## End(Not run)
</code></pre>

<hr>
<h2 id='mosek2gurobi'>
Functions to recast quadratically constrained MIP in different format, and class qco
</h2><span id='topic+mosek2gurobi'></span><span id='topic+gurobi2mosek'></span><span id='topic+qco'></span>

<h3>Description</h3>

<p>The functions recast a Mosek model into Gurobi format and vice versa,
for use with objects of class qco from package DoE.MIParray. The class is also 
documented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosek2gurobi(qco, ...)
gurobi2mosek(qco, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosek2gurobi_+3A_qco">qco</code></td>
<td>

<p>a mixed integer optimization problem of class <code>qco</code>, as generated
from package <span class="pkg">DoE.MIParray</span>
</p>
</td></tr>
<tr><td><code id="mosek2gurobi_+3A_...">...</code></td>
<td>

<p>not used so far
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions treat the special <code>qco</code> objects created by package 
<span class="pkg">DoE.MIParray</span>: these are minimization problems with linear equality 
constraints and possibly conic quadratic constraints, as suitable for the 
problems treated in <span class="pkg">DoE.MIParray</span>.
</p>
<p>Class <code>qco</code> objects on their own only occur as interim results of the 
optimization functions <code>mosek_MIParray</code>, 
<code>mosek_MIPcontinue</code>, 
<code>gurobi_MIParray</code> or <code>gurobi_MIPcontinue</code>. Where it might be useful, 
the class <code>link[DoE.base]{oa}</code> output objects of the optimization functions 
contain an attribute <code>MIPinfo</code> of class <code>qco</code>. For reducing the size of 
an object that is not going to be used for further improvement, 
the following command can be run for extracting the 
the useful information content from the <code>qco</code> object and replacing the large
<code>MIPinfo</code> attribute with this much smaller object: <br />
<code>attr(obj, "MIPinfo") &lt;- attr(obj, "MIPinfo")$info</code><br />
Make sure to only run this command if <code>MIPinfo</code> attribute is indeed of class <code>qco</code> 
and further optimization is not intended.
</p>


<h3>Value</h3>

<p>an object of S3 class <code>qco</code> (see Details section)
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>See Also</h3>

<p>See also as <code><a href="#topic+mosek_MIParray">mosek_MIParray</a></code>, <code><a href="#topic+gurobi_MIParray">gurobi_MIParray</a></code>.
</p>

<hr>
<h2 id='print.oa'>
Function to Print oa Objects with a Lot of Added Info
</h2><span id='topic+print.oa'></span>

<h3>Description</h3>

<p>The function suppresses printing of voluminous info attached as attributes to oa objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.oa_+3A_x">x</code></td>
<td>

<p>the oa object to be printed
</p>
</td></tr>
<tr><td><code id="print.oa_+3A_...">...</code></td>
<td>

<p>further arguments for default print function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently removes all attributes except <code>origin</code>, <code>class</code>, <code>dim</code>, <code>dimnames</code> before printing.<br />
If available, status information from the <code>MIPinfo</code> attribute is printed.<br /> 
Additionally, the names of unusual attributes are printed. 
They can also be printed separately by running <code>names(attributes(x))</code>; to access an attribute, run <code>attr(x, "MIPinfo")</code>, for example.
</p>


<h3>Value</h3>

<p>The function is used for its side effects and does not return anything.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>See Also</h3>

<p>See also <code><a href="base.html#topic+print.default">print.default</a></code> and <code><a href="utils.html#topic+str">str</a></code>
</p>

<hr>
<h2 id='write_MPSILPlist.Rd'>
Functions to create and write lists of (mixed) integer quadratic or linear problems related to orthogonal arrays
</h2><span id='topic+write_MPSILPlist'></span><span id='topic+write_MPSMIQP'></span><span id='topic+create_ILPlist'></span>

<h3>Description</h3>

<p>create_ILPlist creates a list of problems in Mosek formatting.
write_MPSILPlist saves a list of integer linear problems as separate MPS files that are accompanied by a table of content txt file. write_MPSMIQP creates and writes a single quadratic mixed integer problem in MPS format.
All functions work, even if neither Mosek nor Gurobi is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ILPlist(nruns, nlevels, resolution=3, distinct=TRUE,
              search.orders=TRUE, start=NULL, forced=NULL, orders=NULL)
write_MPSILPlist(prefix, qcolist, toc=TRUE)
write_MPSMIQP(prefix, nruns, nlevels, resolution=3, distinct=TRUE, start=NULL,
              forced=NULL, name="ImproveAR", commentline="* quadratic problem")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_MPSILPlist.Rd_+3A_nruns">nruns</code></td>
<td>

<p>positive integer; number of runs
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_nlevels">nlevels</code></td>
<td>

<p>vector of integers (&gt;=2); numbers of factor levels
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_resolution">resolution</code></td>
<td>

<p>positive integer; the minimum resolution requested
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_distinct">distinct</code></td>
<td>

<p>logical; if TRUE (default), restricts counting vector to 0/1 entries, which means that the resulting array is requested to have distinct rows; otherwise, duplicate rows are permitted, i.e. the counting vector can have arbitrary non-negative integers. Designs with distinct runs are usually better; in addition, binary variables are easier to handle by the optimization algorithm. Nevertheless, there are occasions where a better array is found faster with option <code>distinct=FALSE</code>, even if it has distinct rows.
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_search.orders">search.orders</code></td>
<td>

<p>logical (default TRUE); determines whether a list of arrays for different level orderings is produced or a single array is output only
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_start">start</code></td>
<td>

<p>a starting value for the algorithm: can be a matrix with entries 1 to number of levels for each column, or a counting vector for the full factorial in lexicographic order; if specified, <code>start</code> must specify an array with the appropriate number of rows and columns, the requested resolution and, if <code>distinct = TRUE</code>, also contain distinct rows (matrix) or 0/1 elements only. <code>start</code> cannot be combined with <code>search.orders=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_forced">forced</code></td>
<td>

<p>for <code>resolution &gt; 1</code> only;<br />
runs to force into the solution design; can be given as an array matrix with the appropriate number of columns and less than <code>nruns</code> rows or a counting vector for the full factorial in lexicographic order with sum smaller than <code>nruns</code>; if <code>distinct=TRUE</code>, <code>forced</code> must have distinct rows (matrix) or 0/1 elements only.
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_orders">orders</code></td>
<td>

<p>a list of level orderings to be considered; if <code>orders</code> is not specified but <code>search.orders=TRUE</code>, all distinct level orderings
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_prefix">prefix</code></td>
<td>

<p>file name prefix to be supplemented with a number and the .mps suffix later. In addition, a further file with a different suffix may be created (see details).
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_qcolist">qcolist</code></td>
<td>

<p>list of ILP objects in Mosek notation (as e.g. produced by function <code>create_ILPlist</code>)
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_toc">toc</code></td>
<td>

<p>logical (default TRUE) that indicates whether a table of content should be produced (txt file)
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_name">name</code></td>
<td>

<p>name to be written into the name field of the mps file
</p>
</td></tr>
<tr><td><code id="write_MPSILPlist.Rd_+3A_commentline">commentline</code></td>
<td>

<p>comment to be written directly underneath the name (comments have to start with a *)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions do <em>not</em> do any problem solving, they serve the sole purpose of exporting problems so that they can be addressed by solvers other than Mosek or Gurobi. The target solver must be able to process the MPS format.
</p>
<p><code>create_ILPlist</code> creates a list with one or more integer linear problems for creating designs of at least the specified resolution. The problems are in Mosek formatting.
</p>
<p><code>write_MPSILPlist</code> writes a list produced by <code>create_ILPlist</code> to one or several MPS files, one file per list element. If not suppressed, a toc file is also created (suffix <code>_toc.txt</code>), which contains the number of runs, the target resolution and the elements of <code>nlevels</code> for each MPS file.
</p>
<p><code>write_MPSMIQP</code> creates and writes a problem for improving the number of shortest words, in a form that corresponds to general MPS format, without extensions by Mosek or Gurobi. The problem has a quadratic objective like in Groemping and Fontana (2019) Eq.(2Q) (instead of Eq.(2L), which is solved by Gurobi and Mosek).
</p>
<p>The example section demonstrates on a small example how these functions can be used.
</p>
<p>For <code>write_MPSMIQP</code>, a start array can be provided from a previous linear optimization (this is not enforced).
If an admissible start array is provided, <code>write_MPSMIQP</code> initially prints the GWLP of that start array.
Otherwise, it warns of inadmissibility. The start value cannot be stored in the MPS file. Instead, for a non-NULL start array,
a separate file (suffix <code>.start</code>) is created, and users have to work out how they can make their solver use that start solution (which is stored in the form of a counting vector, see example section).
Note that the availability of a start array can improve the ability of a solver to find an optimum solution. However, this is not always the case,
there are also instances for which a better solution is found without providing a start solution.
</p>
<p>For <code>write_MPSMIQP</code>, a lower bound for the objective value
can substantially improve the run time, if the solution achieves that lower bound. The lower bound is not provided in the MPS file, and its detail depends on the optimizer's way to implement quadratic problems (see example section for how to obtain it). Users have to work out how to provide that bound to their optimizer.
</p>
<p>Note that it can take a long time to write the mps files, if the problem has many variables (the number of variables is <code>prod(nlevels)</code>).
</p>


<h3>Value</h3>

<p>Function <code>create_ILPlist</code> creates a list of one or more optimization problems,
which can be used in a call to function <code>write_MPSILPlist</code>.
</p>
<p>Function <code>write_MPSILPlist</code> returns a table of contents matrix for the written files. If <code>toc=TRUE</code>, that value is also written to a separate file with suffix <code>toc</code>.
</p>
<p>Function <code>write_MPSMIQP</code> returns the start vector (in counting vector representation), if <code>start</code> is not NULL; that vector is also written to a separate file with suffix <code>start</code>.
</p>


<h3>Note</h3>

<p>It can take an optimizer a long time to confirm optimality after finding an optimum. For the quadratic problem, it is therefore very beneficial to provide an optimal value to the algorithm, where possible (see example section).
</p>
<p>The functions are not meant for situations, for which a full factorial design would be huge. Even though the functions do not solve anything, MPS files will be very large and writing them will be quite slow for such cases.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Groemping, U. and Fontana, R. (2019). An Algorithm for Generating Good Mixed Level Factorial Designs. <em>Computational Statistics &amp; Data Analysis</em> <b>137</b>, 101-114. doi:10.1016/j.csda.2019.01.020.
</p>
<p>Mosek ApS (2017a). MOSEK version w.x.y.z documentation. Accessible at: <a href="https://www.mosek.com/documentation/">https://www.mosek.com/documentation/</a>. This package has been developed using version 8.1.0.23 (accessed August 29 2017).
</p>
<p>Mosek ApS (2017b). MOSEK Rmosek Package 8.1.y.z. <a href="https://docs.mosek.com/8.1/rmosek/index.html">https://docs.mosek.com/8.1/rmosek/index.html</a>.
<em>!!! In normal R speak, this is the documentation of the Rmosek package version 8.0.69 (or whatever comes next), when applied on top of the Mosek version 8.1.y.z (this package has been devoloped with Mosek version 8.1.0.23 and will likely not work for Mosek versions before 8.1). !!! (accessed August 29 2017)</em>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+create_MIQP">create_MIQP</a></code> and <code><a href="#topic+write_MPSILP">write_MPSILP</a></code> for internal functions that support these exported functions, and <code><a href="#topic+dToCount">dToCount</a></code> and <code><a href="#topic+countToDmixed">countToDmixed</a></code> for switching back and forth between an array and its counting vector representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################################
## an array and its counting vector

## arrays (starting the coding with 1)
## and their counting vectors can be used interchangeably
myarr &lt;- cbind(c(1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2),
               c(1,1,1,1,2,2,2,2,1,1,1,1,2,2,2,2),
               c(1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4),
               c(1,5,3,7,2,6,4,8,8,4,6,2,7,3,5,1))

## we want to see it w.r.t. a 2,2,4,8 level full factorial
## determine the counting vector representation of this array
##     nlevels is needed,
##     because the third column of myarr has only 2 levels
(myarr_cv &lt;- dToCount(myarr, nlevels=c(2,2,4,8), startfrom1=TRUE))

###################################################################
## demo: counting vector represents the array runs
###################################################################
## full factorial in lexicographic order
fullfac &lt;- ff(2,2,4,8) +  1   ### ff levels start with 0
##
## pick the selected runs from fullfac
selfac &lt;- fullfac[which(myarr_cv==1),]
##
## order both variants in the same way and compare them
## (in this case, they are equal without reordering)
ord1 &lt;- DoE.base::ord(selfac)  ## order them
ord2 &lt;- DoE.base::ord(myarr)   ## order them
selfac[ord1,] == myarr[ord2,]
#######################################################

#######################################################
## We go for an array in 16 runs with four factors in
## 2,2,4,8 levels.

## Is a strength 2 oa feasible?
##
oa_feasible(16, c(2,2,4,8), 2)  ## FALSE
##
## consequence: use resolution 2 (=strength 1),
##              minimize number of words of length 2

problemlist &lt;- create_ILPlist(16, nlevels = c(2,2,4,8), resolution = 2)
length(problemlist) ## 12 distinct search orders
names(problemlist[[3]])
problemlist[[3]][-2]  ## ILP is too long for printing
problemlist1 &lt;- create_ILPlist(16, nlevels = c(2,2,4,8),
                  resolution = 2, search.orders = FALSE)
                  ## only the pre-specified search order
problemlist2 &lt;- create_ILPlist(16, nlevels = c(2,2,4,8),
                  resolution = 2, orders = list(c(2,2,4,8),
                                                c(8,2,4,2)))
                  ## the two specified search orders
## Not run: 
write_MPSILPlist(prefix="miniprob", problemlist)
## writes miniprob01.mps, ..., miniprob12.mps and miniprob_toc.txt
write_MPSILPlist(prefix="miniprob", problemlist1, toc=FALSE)
## writes miniprob1.mps

## End(Not run)

## The MPS files can be read by various optimizers.
## The ILP problems aim for a feasible solution.
## Start values are possible, but usually not useful.
## The best solution (lowest target value) can be imported into R.

## the solution  a counting vector
## its format depends on the optimizer
## import it into R and calculated array from it
importedsol &lt;- myarr_cv # for demo only
solarray &lt;- countToDmixed(myarr_cv, nlevels=c(2,2,4,8))
##
## it is crucial to use the order of the levels
## that corresponds to the problem that the solver solved

GWLP(solarray)

#######################################################
## providing a lower bound for the number of
## length 2 words in a strength 1 (resolution 2) array
#######################################################
##
lowerbound_AR(nruns = 16, nlevels = c(2,2,4,8), R = 2)  # 1
##
## In this example, we have immediately hit on a solution
## with optimum A2-value (see GWLP)

#######################################################
## using a quadratic problem for optimizing A2
##
## Not run: 
write_MPSMIQP("quadprob", 16, c(2,2,4,8), resolution=2)
## writes quadprob.mps

## End(Not run)

## Run time for solving the quadratic problem exported by write_MPSMIQP
## may substantially (!) benefit from providing the lower bound of the
## objective function, if that bound is attained.
##
## The lower bound for the minimum of the quadratic problem
##     created by write_MPSMIQP
##   is the lower bound for the word length, multiplied with n^2,
##     here 16 ^ 2 * 1 = 256,
##   or half that value,
##     depending on how the optimizer handles quadratic objectives.
#######################################################

## Depending on the optimizer, it is useful or even crucial to provide a
## starting value to write_MPSMIQP. This starting value can be obtained
## as the solution to a linear problem (that was exported using functions
## create_ILPlist and write_MPSILPlist).

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
