<!DOCTYPE html><html><head><title>Help for package pagoda2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pagoda2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onUnload'><p>Correct unloading of the library</p></a></li>
<li><a href='#areColors'><p>Quick utility to check if given character vector is colors</p>
Thanks to Stackoverflow: http://stackoverflow.com/questions/13289009/check-if-character-string-is-a-valid-color-representation</a></li>
<li><a href='#armaCor'><p>armaCor - matrix column correlations. Allows faster matrix correlations with armadillo. Similar to cor() call, will calculate correlation between matrix columns</p></a></li>
<li><a href='#basicP2proc'><p>Perform basic 'pagoda2' processing, i.e. adjust variance, calculate pca reduction,</p>
make knn graph, identify clusters with multilevel, and generate
largeVis and tSNE embeddings.</a></li>
<li><a href='#basicP2web'><p>Generate a 'pagoda2' web application from a 'Pagoda2' object</p></a></li>
<li><a href='#buildWijMatrix'><p>Rescale the weights in an edge matrix to match a given perplexity.</p>
From 'largeVis', &lt;https://github.com/elbamos/largeVis&gt;</a></li>
<li><a href='#calcMulticlassified'><p>Returns a list vector with the number of cells that are</p>
present in more than one selections in the provided p2 selection object</a></li>
<li><a href='#cellsPerSelectionGroup'><p>Get the number of cells in each selection group</p></a></li>
<li><a href='#cldend2array'><p>Translate cell cluster dendrogram to an array, one row per node with 1/0 cluster membership</p></a></li>
<li><a href='#collapse.aspect.clusters'><p>Collapse aspect patterns into clusters</p></a></li>
<li><a href='#compareClusterings'><p>Compare two different clusterings provided as factors by plotting a normalised heatmap</p></a></li>
<li><a href='#diffExprOnP2FromWebSelection'><p>Perform differential expression on a p2 object given a</p>
set of web selections and two groups to compare</a></li>
<li><a href='#diffExprOnP2FromWebSelectionOneGroup'><p>Perform differential expression on a p2 object given a</p>
set of web selections and one group to compare against everything else</a></li>
<li><a href='#extendedP2proc'><p>Perform extended 'Pagoda2' processing.</p>
Generate organism specific GO environment and calculate pathway overdispersion.</a></li>
<li><a href='#factorFromP2Selection'><p>Returns a factor of cell membership from a p2 selection object</p>
the factor only includes cells present in the selection. If the selection
contains multiclassified cells an error is raised</a></li>
<li><a href='#factorListToMetadata'><p>Converts a list of factors into 'pagoda2' metadata optionally</p>
filtering down to the cells present in the provided 'pagoda2' app.</a></li>
<li><a href='#factorToP2selection'><p>Converts a names factor to a p2 selection object</p>
if colors are provided it assigns those, otherwise uses a rainbow palette</a></li>
<li><a href='#gene.vs.molecule.cell.filter'><p>Filter cells based on gene/molecule dependency</p></a></li>
<li><a href='#generateClassificationAnnotation'><p>Given a cell clustering (partitioning) and a set of user provided selections</p>
generate a cleaned up annotation of cluster groups that can be used for classification</a></li>
<li><a href='#get.control.geneset'><p>Get a control geneset for cell scoring using the method described in</p>
Puram, Bernstein (Cell, 2018)</a></li>
<li><a href='#get.de.geneset'><p>Generate differential expression genesets for the web app given a cell grouping by</p>
calculating DE sets between each cell set and everything else</a></li>
<li><a href='#getCellsInSelections'><p>Returns all the cells that are in the designated selections.</p>
Given a pagoda2 selections object and the names of some selections
in it returns the names of the cells that are in these selections removed any duplicates</a></li>
<li><a href='#getClusterLabelsFromSelection'><p>Assign names to the clusters, given a clustering vector and a set of selections.</p>
This function will use a set of pagoda2 cell seletcion to identify
the clusters in a a named factor. It is meant to be used to import user defined annotations
that are defined as selections into a more formal categorization of cells that are defined by cluster.
To help with this the function allows a percent of cells to have been classified in the selections into
multiple groups, something which may be the result of the users making wrong selections. The percent of
cells allows to be multiselected in any given group is defined by multiClassCutoff. Furthermore
the method will assign each cluster to a selection only if the most popular cluster to the next most popular
exceed the ambiguous.ratio in terms of cell numbers. If a cluster does not satisfy this condtiion it is not
assigned.</a></li>
<li><a href='#getColorsFromP2Selection'><p>Retrieves the colors of each selection from a p2 selection object as a names vector of strings</p></a></li>
<li><a href='#getIntExtNamesP2Selection'><p>Get a mapping form internal to external names for the specified selection object</p></a></li>
<li><a href='#hierDiffToGenesets'><p>Converts the output of hierarchical differential expression aspects</p>
into genesets that can be loaded into a 'pagoda2' web app to retrive the genes
that make the geneset interactively</a></li>
<li><a href='#make.p2.app'><p>Generate a Rook Server app from a 'Pagoda2' object.</p>
This generates a 'pagoda2' web object from a 'Pagoda2' object by automating steps that most
users will want to run. This function is a wrapper about the 'pagoda2' web constructor.
(Advanced users may wish to use that constructor directly.)</a></li>
<li><a href='#minMaxScale'><p>Scale the designated values between the range of 0 and 1</p></a></li>
<li><a href='#Mode'><p>Return the mode of a vector</p></a></li>
<li><a href='#namedNames'><p>Get a vector of the names of an object named by the names themselves.</p>
This is useful with lapply when passing names of objects as it ensures
that the output list is also named.</a></li>
<li><a href='#p2.generate.dr.go'><p>Generate a GO environment for human for overdispersion analysis for the the back end</p></a></li>
<li><a href='#p2.generate.dr.go.web'><p>Generates zebrafish (Danio rerio) GO annotation for the web object</p></a></li>
<li><a href='#p2.generate.go'><p>Generate a GO environment for the organism specified</p></a></li>
<li><a href='#p2.generate.go.web'><p>Generates GO annotation for the web object for any species</p></a></li>
<li><a href='#p2.generate.go.web.fromGOEnv'><p>Generates GO annotation for the web object from the GO environment used for enrichment analysis</p></a></li>
<li><a href='#p2.generate.human.go'><p>Generate a GO environment for human for overdispersion analysis for the the back end</p></a></li>
<li><a href='#p2.generate.human.go.web'><p>Generates human GO annotation for the web object</p></a></li>
<li><a href='#p2.generate.mouse.go'><p>Generate a GO environment for mouse for overdispersion analysis for the the back end</p></a></li>
<li><a href='#p2.generate.mouse.go.web'><p>Generates mouse (Mus musculus) GO annotation for the web object</p></a></li>
<li><a href='#p2.make.pagoda1.app'><p>Create 'PAGODA1' web application from a 'Pagoda2' object</p>
'PAGODA1' found here, with 'SCDE': &lt;https://www.bioconductor.org/packages/release/bioc/html/scde.html&gt;</a></li>
<li><a href='#p2.metadata.from.factor'><p>Generate a list metadata structure that can be passed to a</p>
'pagoda2' web object constructor as additional metadata given a named factor</a></li>
<li><a href='#p2.toweb.hdea'><p>Generate a 'pagoda2' web object from a 'Pagoda2' object using hierarchical differential expression</p></a></li>
<li><a href='#p2ViewPagodaApp'><p>p2ViewPagodaApp R6 class</p></a></li>
<li><a href='#pagoda.reduce.loading.redundancy'><p>Collapse aspects driven by the same combinations of genes.</p>
(Aspects are some pattern across cells e.g. sequencing depth,
or PC corresponding to an undesired process such as ribosomal pathway variation.)
Examines PC loading vectors underlying the identified aspects and clusters of aspects based
on a product of loading and score correlation (raised to corr.power).
Clusters of aspects driven by the same genes are determined based
on the parameter &quot;distance.threshold&quot;.</a></li>
<li><a href='#pagoda.reduce.redundancy'><p>Collapse aspects driven by similar patterns (i.e. separate the same sets of cells)</p>
Examines PC loading vectors underlying the identified aspects and clusters aspects based on score correlation. Clusters of aspects driven by the same patterns are determined based on the distance.threshold.</a></li>
<li><a href='#Pagoda2'><p>Pagoda2 R6 class</p></a></li>
<li><a href='#pagoda2WebApp_arrayToJSON'><p>pagoda2WebApp_arrayToJSON</p></a></li>
<li><a href='#pagoda2WebApp_availableAspectsJSON'><p>pagoda2WebApp_availableAspectsJSON</p></a></li>
<li><a href='#pagoda2WebApp_call'><p>pagoda2WebApp_call</p></a></li>
<li><a href='#pagoda2WebApp_cellmetadataJSON'><p>pagoda2WebApp_cellmetadataJSON</p></a></li>
<li><a href='#pagoda2WebApp_cellOrderJSON'><p>pagoda2WebApp_cellOrderJSON</p></a></li>
<li><a href='#pagoda2WebApp_geneInformationJSON'><p>pagoda2WebApp_geneInformationJSON</p></a></li>
<li><a href='#pagoda2WebApp_generateDendrogramOfGroups'><p>Generate a dendrogram of groups</p></a></li>
<li><a href='#pagoda2WebApp_generateEmbeddingStructure'><p>pagoda2WebApp_generateEmbeddingStructure</p></a></li>
<li><a href='#pagoda2WebApp_generateGeneKnnJSON'><p>pagoda2WebApp_generateGeneKnnJSON</p></a></li>
<li><a href='#pagoda2WebApp_getCompressedEmbedding'><p>pagoda2WebApp_getCompressedEmbedding</p></a></li>
<li><a href='#pagoda2WebApp_packCompressFloat64Array'><p>pagoda2WebApp_packCompressFloat64Array</p></a></li>
<li><a href='#pagoda2WebApp_packCompressInt32Array'><p>pagoda2WebApp_packCompressInt32Array</p></a></li>
<li><a href='#pagoda2WebApp_readStaticFile'><p>pagoda2WebApp_readStaticFile</p></a></li>
<li><a href='#pagoda2WebApp_reducedDendrogramJSON'><p>pagoda2WebApp_reducedDendrogramJSON</p></a></li>
<li><a href='#pagoda2WebApp_serializeToStaticFast'><p>pagoda2WebApp_serializeToStaticFast</p></a></li>
<li><a href='#pagoda2WebApp_serverLog'><p>pagoda2WebApp_serverLog</p></a></li>
<li><a href='#pagoda2WebApp_sparseMatList'><p>pagoda2WebApp_sparseMatList</p></a></li>
<li><a href='#pagoda2WebApp-class'><p>pagoda2WebApp class to create 'pagoda2' web applications via a Rook server</p></a></li>
<li><a href='#papply'><p>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.</p></a></li>
<li><a href='#pathway.pc.correlation.distance'><p>Calculate correlation distance between PC magnitudes given a number of target dimensions</p></a></li>
<li><a href='#plotMulticlassified'><p>Plot multiclassified cells per selection as a percent barplot</p></a></li>
<li><a href='#plotOneWithValues'><p>Plot the embedding of a 'Pagoda2' object with the given values</p></a></li>
<li><a href='#plotSelectionOverlaps'><p>Get a dataframe and plot summarising overlaps between selection of a pagoda2 selection object</p>
ignore self overlaps</a></li>
<li><a href='#projectKNNs'><p>Project a distance matrix into a lower-dimensional space. (from elbamos/largeVis)</p></a></li>
<li><a href='#read.10x.matrices'><p>Quick loading of 10X CellRanger count matrices</p></a></li>
<li><a href='#read10xMatrix'><p>This function reads a matrix generated by the 10x processing pipeline</p>
from the specified directory and returns it. It aborts if one of the required
files in the specified directory do not exist.</a></li>
<li><a href='#readPagoda2SelectionAsFactor'><p>Read a pagoda2 cell selection file and return it as a factor</p>
while removing any mutliclassified cells</a></li>
<li><a href='#readPagoda2SelectionFile'><p>Reads a 'pagoda2' web app exported cell selection file exported as a list</p>
of list objects that contain the name of the selection,
the color (as a hex string) and the identifiers of the individual cells</a></li>
<li><a href='#removeSelectionOverlaps'><p>Remove cells that are present in more than one selection from all the</p>
selections they are in</a></li>
<li><a href='#score.cells.nb0'><p>Score cells by getting mean expression of genes in signatures</p></a></li>
<li><a href='#score.cells.nb1'><p>Score cells after standardising the expression of each gene removing outliers</p></a></li>
<li><a href='#score.cells.puram'><p>Puram, Bernstein (Cell, 2018)</p>
Score cells as described in Puram, Bernstein (Cell, 2018)</a></li>
<li><a href='#sgdBatches'><p>Calculate the default number of batches for a given number of vertices and edges.</p>
The formula used is the one used by the 'largeVis' reference implementation.  This is substantially less than the recommendation <code class="reqn">E * 10000</code> in the original paper.</a></li>
<li><a href='#show.app'><p>Directly open the 'pagoda2' web application and view the 'p2web' application object from our R session</p></a></li>
<li><a href='#sn'><p>Set names equal to values, a stats::setNames wrapper function</p></a></li>
<li><a href='#subsetSignatureToData'><p>Subset a gene signature to the genes in the given matrix</p>
with optional warning if genes are missing</a></li>
<li><a href='#tp2c.view.pathways'><p>View pathway or gene-weighted PCA</p>
'Pagoda2' version of the function pagoda.show.pathways()
Takes in a list of pathways (or a list of genes), runs weighted PCA, optionally showing the result.</a></li>
<li><a href='#validateSelectionsObject'><p>Validates a pagoda2 selection object</p></a></li>
<li><a href='#view.aspects'><p>Internal function to visualize aspects of transcriptional heterogeneity as a heatmap.</p></a></li>
<li><a href='#webP2proc'><p>Generate a 'pagoda2' web object</p></a></li>
<li><a href='#winsorize.matrix'><p>Sets the ncol(mat)*trim top outliers in each row to the next lowest value same for the lowest outliers</p></a></li>
<li><a href='#writeGenesAsPagoda2Selection'><p>Writes a list of genes as a gene selection that can be loaded in the web interface</p></a></li>
<li><a href='#writePagoda2SelectionFile'><p>Writes a pagoda2 selection object as a p2 selection file that be be</p>
loaded to the web interface</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Single Cell Analysis and Differential Expression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.12</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyzing and interactively exploring large-scale single-cell RNA-seq datasets. 'pagoda2' primarily performs normalization and differential gene expression analysis, with an interactive application for exploring single-cell RNA-seq datasets. It performs basic tasks such as cell size normalization, gene variance normalization, and can be used to identify subpopulations and run differential expression within individual samples. 'pagoda2' was written to rapidly process modern large-scale scRNAseq datasets of approximately 1e6 cells. The companion web application allows users to explore which gene expression patterns form the different subpopulations within your data. The package also serves as the primary method for preprocessing data for conos, <a href="https://github.com/kharchenkolab/conos">https://github.com/kharchenkolab/conos</a>. This package interacts with data available through the 'p2data' package, which is available in a 'drat' repository. To access this data package, see the instructions at <a href="https://github.com/kharchenkolab/pagoda2">https://github.com/kharchenkolab/pagoda2</a>. The size of the 'p2data' package is approximately 6 MB.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>See the file COPYRIGHTS for various pagoda2 copyright
details</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix, igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>dendsort, drat, fastcluster, graphics, grDevices, irlba,
magrittr, MASS, mgcv, methods, N2R, parallel, plyr, R.utils,
Rcpp, rjson, rlang, R6, RMTstat, Rook, Rtsne, sccore (&ge;
0.1.1), stats, urltools, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AnnotationDbi, base64enc, BiocGenerics, BiocParallel,
colorRamps, data.table, dbscan, dplyr, ggplot2, GO.db,
gridExtra, KernSmooth, knitr, org.Dr.eg.db, org.Hs.eg.db,
org.Mm.eg.db, pcaMethods, pheatmap, rgl, rmarkdown, robustbase,
scde, testthat, uwot</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kharchenkolab/pagoda2">https://github.com/kharchenkolab/pagoda2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kharchenkolab/pagoda2/issues">https://github.com/kharchenkolab/pagoda2/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppEigen</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolas Barkas [aut],
  Viktor Petukhov [aut],
  Peter Kharchenko [aut],
  Simon Steiger [ctb],
  Rasmus Rydbirk [ctb],
  Evan Biederstedt [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 20:22:22 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-27 00:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onUnload'>Correct unloading of the library</h2><span id='topic+.onUnload'></span>

<h3>Description</h3>

<p>Correct unloading of the library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onUnload(libpath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onUnload_+3A_libpath">libpath</code></td>
<td>
<p>library path</p>
</td></tr>
</table>

<hr>
<h2 id='areColors'>Quick utility to check if given character vector is colors
Thanks to Stackoverflow: http://stackoverflow.com/questions/13289009/check-if-character-string-is-a-valid-color-representation</h2><span id='topic+areColors'></span>

<h3>Description</h3>

<p>Quick utility to check if given character vector is colors
Thanks to Stackoverflow: http://stackoverflow.com/questions/13289009/check-if-character-string-is-a-valid-color-representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areColors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areColors_+3A_x">x</code></td>
<td>
<p>character vector to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean whether character vector is colors
</p>

<hr>
<h2 id='armaCor'>armaCor - matrix column correlations. Allows faster matrix correlations with armadillo. Similar to cor() call, will calculate correlation between matrix columns</h2><span id='topic+armaCor'></span>

<h3>Description</h3>

<p>armaCor - matrix column correlations. Allows faster matrix correlations with armadillo. Similar to cor() call, will calculate correlation between matrix columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armaCor(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="armaCor_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with columns as correlations
</p>

<hr>
<h2 id='basicP2proc'>Perform basic 'pagoda2' processing, i.e. adjust variance, calculate pca reduction,
make knn graph, identify clusters with multilevel, and generate
largeVis and tSNE embeddings.</h2><span id='topic+basicP2proc'></span>

<h3>Description</h3>

<p>Perform basic 'pagoda2' processing, i.e. adjust variance, calculate pca reduction,
make knn graph, identify clusters with multilevel, and generate
largeVis and tSNE embeddings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicP2proc(
  cd,
  n.cores = 1,
  n.odgenes = 3000,
  nPcs = 100,
  k = 30,
  perplexity = 50,
  log.scale = TRUE,
  trim = 10,
  keep.genes = NULL,
  min.cells.per.gene = 0,
  min.transcripts.per.cell = 100,
  get.largevis = TRUE,
  get.tsne = TRUE,
  make.geneknn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicP2proc_+3A_cd">cd</code></td>
<td>
<p>count matrix whereby rows are genes, columns are cells.</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of top overdispersed genes to use (dfault=3e3)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_npcs">nPcs</code></td>
<td>
<p>numeric Number of PCs to use (default=100)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_k">k</code></td>
<td>
<p>numeric Default number of neighbors to use in kNN graph (default=30)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_perplexity">perplexity</code></td>
<td>
<p>numeric Perplexity to use in generating tSNE and largeVis embeddings (default=50)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_log.scale">log.scale</code></td>
<td>
<p>boolean Whether to use log scale normalization (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_trim">trim</code></td>
<td>
<p>numeric Number of cells to trim in winsorization (default=10)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_keep.genes">keep.genes</code></td>
<td>
<p>optional set of genes to keep from being filtered out (even at low counts) (default=NULL)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_min.cells.per.gene">min.cells.per.gene</code></td>
<td>
<p>numeric Minimal number of cells required for gene to be kept (unless listed in keep.genes) (default=0)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_min.transcripts.per.cell">min.transcripts.per.cell</code></td>
<td>
<p>numeric Minimumal number of molecules/reads for a cell to be admitted (default=100)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_get.largevis">get.largevis</code></td>
<td>
<p>boolean Whether to caluclate largeVis embedding (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_get.tsne">get.tsne</code></td>
<td>
<p>boolean Whether to calculate tSNE embedding (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicP2proc_+3A_make.geneknn">make.geneknn</code></td>
<td>
<p>boolean Whether pre-calculate gene kNN (for gene search) (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new 'Pagoda2' object
</p>

<hr>
<h2 id='basicP2web'>Generate a 'pagoda2' web application from a 'Pagoda2' object</h2><span id='topic+basicP2web'></span>

<h3>Description</h3>

<p>Generate a 'pagoda2' web application from a 'Pagoda2' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicP2web(p2, app.title = "Pagoda2", extraWebMetadata = NULL, n.cores = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicP2web_+3A_p2">p2</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
<tr><td><code id="basicP2web_+3A_app.title">app.title</code></td>
<td>
<p>name of application as displayed in the browser title (default='Pagoda2')</p>
</td></tr>
<tr><td><code id="basicP2web_+3A_extrawebmetadata">extraWebMetadata</code></td>
<td>
<p>additional metadata generated by p2.metadata.from.fractor (default=NULL)</p>
</td></tr>
<tr><td><code id="basicP2web_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use for differential expression calculation (default=4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'pagoda2' web object
</p>

<hr>
<h2 id='buildWijMatrix'>Rescale the weights in an edge matrix to match a given perplexity.
From 'largeVis', &lt;https://github.com/elbamos/largeVis&gt;</h2><span id='topic+buildWijMatrix'></span>

<h3>Description</h3>

<p>Rescale the weights in an edge matrix to match a given perplexity.
From 'largeVis', &lt;https://github.com/elbamos/largeVis&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildWijMatrix(x, threads = NULL, perplexity = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildWijMatrix_+3A_x">x</code></td>
<td>
<p>An edgematrix, either an 'edgematrix' object or a sparse matrix.</p>
</td></tr>
<tr><td><code id="buildWijMatrix_+3A_threads">threads</code></td>
<td>
<p>numeric The maximum number of threads to spawn (default=NULL). Determined automatically if NULL (default=NULL)</p>
</td></tr>
<tr><td><code id="buildWijMatrix_+3A_perplexity">perplexity</code></td>
<td>
<p>numeric Given perplexity (default=50)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following components: </p>

<dl>
<dt>'dist'</dt><dd><p>An [N,K] matrix of the distances to the nearest neighbors.</p>
</dd>
<dt>'id'</dt><dd><p>An [N,K] matrix of the node indexes of the neartest neighbors.  Note that this matrix is 1-indexed,
unlike most other matrices in this package.</p>
</dd>
<dt>'k'</dt><dd><p>The number of nearest neighbors.</p>
</dd>
</dl>


<hr>
<h2 id='calcMulticlassified'>Returns a list vector with the number of cells that are
present in more than one selections in the provided p2 selection object</h2><span id='topic+calcMulticlassified'></span>

<h3>Description</h3>

<p>Returns a list vector with the number of cells that are
present in more than one selections in the provided p2 selection object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMulticlassified(sel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcMulticlassified_+3A_sel">sel</code></td>
<td>
<p>a pagoda2 selection as genereated by readPagoda2SelectionFile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list vector with the number of cells that are
present in more than one selections in the provided p2 selection object
</p>

<hr>
<h2 id='cellsPerSelectionGroup'>Get the number of cells in each selection group</h2><span id='topic+cellsPerSelectionGroup'></span>

<h3>Description</h3>

<p>Get the number of cells in each selection group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellsPerSelectionGroup(selection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellsPerSelectionGroup_+3A_selection">selection</code></td>
<td>
<p>a pagoda2 selection list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of cell numbers in each groups
</p>

<hr>
<h2 id='cldend2array'>Translate cell cluster dendrogram to an array, one row per node with 1/0 cluster membership</h2><span id='topic+cldend2array'></span>

<h3>Description</h3>

<p>Translate cell cluster dendrogram to an array, one row per node with 1/0 cluster membership
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cldend2array(d, cells = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cldend2array_+3A_d">d</code></td>
<td>
<p>cell cluster dendrogram</p>
</td></tr>
<tr><td><code id="cldend2array_+3A_cells">cells</code></td>
<td>
<p>character vector of cells (default=NULL). If NULL, determine the total order of cells with unlist(dendrapply(d, attr, 'cells'))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with one row per node with 1/0 cluster membership
</p>

<hr>
<h2 id='collapse.aspect.clusters'>Collapse aspect patterns into clusters</h2><span id='topic+collapse.aspect.clusters'></span>

<h3>Description</h3>

<p>Collapse aspect patterns into clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse.aspect.clusters(d, dw, ct, scale = TRUE, pick.top = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.aspect.clusters_+3A_d">d</code></td>
<td>
<p>matrix of normalized aspect patterns (rows: significant aspects, columns: cells), normally the output $xv in 'tamr', the combined pathways that show similar expression patterns</p>
</td></tr>
<tr><td><code id="collapse.aspect.clusters_+3A_dw">dw</code></td>
<td>
<p>corresponding weight matrix to parameter 'd'</p>
</td></tr>
<tr><td><code id="collapse.aspect.clusters_+3A_ct">ct</code></td>
<td>
<p>clusters, the output of fastcluster::hclust()</p>
</td></tr>
<tr><td><code id="collapse.aspect.clusters_+3A_scale">scale</code></td>
<td>
<p>boolean Whether to scale aspects (default=TRUE)</p>
</td></tr>
<tr><td><code id="collapse.aspect.clusters_+3A_pick.top">pick.top</code></td>
<td>
<p>boolean Whether to pick top aspects (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of clusters from matrix of normalized aspect patterns and clusters from the corresponding weight matrix
</p>

<hr>
<h2 id='compareClusterings'>Compare two different clusterings provided as factors by plotting a normalised heatmap</h2><span id='topic+compareClusterings'></span>

<h3>Description</h3>

<p>Compare two different clusterings provided as factors by plotting a normalised heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareClusterings(cl1, cl2, filename = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareClusterings_+3A_cl1">cl1</code></td>
<td>
<p>clustering 1, a named factor</p>
</td></tr>
<tr><td><code id="compareClusterings_+3A_cl2">cl2</code></td>
<td>
<p>clustering 2, a named factor</p>
</td></tr>
<tr><td><code id="compareClusterings_+3A_filename">filename</code></td>
<td>
<p>an optional filename to save the plot instead of displaying it, will be passed to pheatmap (default=NA)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible summary table that gets plotted
</p>

<hr>
<h2 id='diffExprOnP2FromWebSelection'>Perform differential expression on a p2 object given a
set of web selections and two groups to compare</h2><span id='topic+diffExprOnP2FromWebSelection'></span>

<h3>Description</h3>

<p>Perform differential expression on a p2 object given a
set of web selections and two groups to compare
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffExprOnP2FromWebSelection(p2, sel, group1name, group2name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffExprOnP2FromWebSelection_+3A_p2">p2</code></td>
<td>
<p>a pagoda2 object</p>
</td></tr>
<tr><td><code id="diffExprOnP2FromWebSelection_+3A_sel">sel</code></td>
<td>
<p>a web selection read with readPagoda2SelectionFile()</p>
</td></tr>
<tr><td><code id="diffExprOnP2FromWebSelection_+3A_group1name">group1name</code></td>
<td>
<p>the name of the first selection</p>
</td></tr>
<tr><td><code id="diffExprOnP2FromWebSelection_+3A_group2name">group2name</code></td>
<td>
<p>the names of the second selection</p>
</td></tr>
</table>

<hr>
<h2 id='diffExprOnP2FromWebSelectionOneGroup'>Perform differential expression on a p2 object given a
set of web selections and one group to compare against everything else</h2><span id='topic+diffExprOnP2FromWebSelectionOneGroup'></span>

<h3>Description</h3>

<p>Perform differential expression on a p2 object given a
set of web selections and one group to compare against everything else
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffExprOnP2FromWebSelectionOneGroup(p2, sel, groupname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffExprOnP2FromWebSelectionOneGroup_+3A_p2">p2</code></td>
<td>
<p>a pagoda2 object</p>
</td></tr>
<tr><td><code id="diffExprOnP2FromWebSelectionOneGroup_+3A_sel">sel</code></td>
<td>
<p>a web selection read with readPagoda2SelectionFile()</p>
</td></tr>
<tr><td><code id="diffExprOnP2FromWebSelectionOneGroup_+3A_groupname">groupname</code></td>
<td>
<p>name of group to compare to everything else</p>
</td></tr>
</table>

<hr>
<h2 id='extendedP2proc'>Perform extended 'Pagoda2' processing. 
Generate organism specific GO environment and calculate pathway overdispersion.</h2><span id='topic+extendedP2proc'></span>

<h3>Description</h3>

<p>Perform extended 'Pagoda2' processing. 
Generate organism specific GO environment and calculate pathway overdispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendedP2proc(p2, organism = "hs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extendedP2proc_+3A_p2">p2</code></td>
<td>
<p>the 'Pagoda2' object</p>
</td></tr>
<tr><td><code id="extendedP2proc_+3A_organism">organism</code></td>
<td>
<p>character Organisms hs (Homo Sapiens), mm (M. Musculus, mouse) or dr (D. Rerio, zebrafish) (default='hs')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of a 'Pagoda2' object and go.env
</p>

<hr>
<h2 id='factorFromP2Selection'>Returns a factor of cell membership from a p2 selection object
the factor only includes cells present in the selection. If the selection
contains multiclassified cells an error is raised</h2><span id='topic+factorFromP2Selection'></span>

<h3>Description</h3>

<p>Returns a factor of cell membership from a p2 selection object
the factor only includes cells present in the selection. If the selection
contains multiclassified cells an error is raised
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorFromP2Selection(sel, use.internal.name = FALSE, flatten = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorFromP2Selection_+3A_sel">sel</code></td>
<td>
<p>a pagoda2 selection as genereated by readPagoda2SelectionFile</p>
</td></tr>
<tr><td><code id="factorFromP2Selection_+3A_use.internal.name">use.internal.name</code></td>
<td>
<p>boolean Whether to use field 'internal.name' as factor names (default=FALSE)</p>
</td></tr>
<tr><td><code id="factorFromP2Selection_+3A_flatten">flatten</code></td>
<td>
<p>boolean Whether to ignore multiclassified cells, overwriting randomly (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>factor of cell membership from a p2 selection object. The factor only includes cells present in the selection.
</p>

<hr>
<h2 id='factorListToMetadata'>Converts a list of factors into 'pagoda2' metadata optionally
filtering down to the cells present in the provided 'pagoda2' app.</h2><span id='topic+factorListToMetadata'></span>

<h3>Description</h3>

<p>Converts a list of factors into 'pagoda2' metadata optionally
filtering down to the cells present in the provided 'pagoda2' app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorListToMetadata(factor.list, p2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorListToMetadata_+3A_factor.list">factor.list</code></td>
<td>
<p>list of factors named by the cell identifier</p>
</td></tr>
<tr><td><code id="factorListToMetadata_+3A_p2">p2</code></td>
<td>
<p>'pagoda2' app to filter the factors by, optional (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'pagoda2' web metadata object
</p>

<hr>
<h2 id='factorToP2selection'>Converts a names factor to a p2 selection object
if colors are provided it assigns those, otherwise uses a rainbow palette</h2><span id='topic+factorToP2selection'></span>

<h3>Description</h3>

<p>Converts a names factor to a p2 selection object
if colors are provided it assigns those, otherwise uses a rainbow palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorToP2selection(cl, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorToP2selection_+3A_cl">cl</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="factorToP2selection_+3A_col">col</code></td>
<td>
<p>names vector of colors (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a p2 selection object (list)
</p>

<hr>
<h2 id='gene.vs.molecule.cell.filter'>Filter cells based on gene/molecule dependency</h2><span id='topic+gene.vs.molecule.cell.filter'></span>

<h3>Description</h3>

<p>Filter cells based on gene/molecule dependency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene.vs.molecule.cell.filter(
  countMatrix,
  min.cell.size = 500,
  max.cell.size = 50000,
  p.level = min(0.001, 1/ncol(countMatrix)),
  alpha = 0.1,
  plot = TRUE,
  do.par = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_countmatrix">countMatrix</code></td>
<td>
<p>input count matrix to be filtered</p>
</td></tr>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_min.cell.size">min.cell.size</code></td>
<td>
<p>numeric Min allowed cell size (default=500)</p>
</td></tr>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_max.cell.size">max.cell.size</code></td>
<td>
<p>numeric Max allowed cell size (default=5e4)</p>
</td></tr>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_p.level">p.level</code></td>
<td>
<p>numeric Statistical confidence level for deviation from the main trend, used for cell filtering (default=min(1e-3,1/ncol(countMatrix)))</p>
</td></tr>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_alpha">alpha</code></td>
<td>
<p>numeric Shading of the confidence band (default=0.1)</p>
</td></tr>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_plot">plot</code></td>
<td>
<p>boolean Plot the molecule distribution and the gene/molecule dependency fit (default=TRUE)</p>
</td></tr>
<tr><td><code id="gene.vs.molecule.cell.filter_+3A_do.par">do.par</code></td>
<td>
<p>boolean Reset graphical parameters prior to plotting (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a filtered matrix
</p>

<hr>
<h2 id='generateClassificationAnnotation'>Given a cell clustering (partitioning) and a set of user provided selections
generate a cleaned up annotation of cluster groups that can be used for classification</h2><span id='topic+generateClassificationAnnotation'></span>

<h3>Description</h3>

<p>Given a cell clustering (partitioning) and a set of user provided selections
generate a cleaned up annotation of cluster groups that can be used for classification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateClassificationAnnotation(clustering, selections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateClassificationAnnotation_+3A_clustering">clustering</code></td>
<td>
<p>a factor that provides the clustering</p>
</td></tr>
<tr><td><code id="generateClassificationAnnotation_+3A_selections">selections</code></td>
<td>
<p>a p2 selection object that provided by the web interfact user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named factor that can be used for classification
</p>

<hr>
<h2 id='get.control.geneset'>Get a control geneset for cell scoring using the method described in
Puram, Bernstein (Cell, 2018)</h2><span id='topic+get.control.geneset'></span>

<h3>Description</h3>

<p>Get a control geneset for cell scoring using the method described in
Puram, Bernstein (Cell, 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.control.geneset(data, signature, n.bins = 25, n.genes.per.bin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.control.geneset_+3A_data">data</code></td>
<td>
<p>matrix of expression, rows are cell, columns are genes</p>
</td></tr>
<tr><td><code id="get.control.geneset_+3A_signature">signature</code></td>
<td>
<p>character vector The signature to evaluate, a character vector of genes</p>
</td></tr>
<tr><td><code id="get.control.geneset_+3A_n.bins">n.bins</code></td>
<td>
<p>numeric Number of bins to put the genes in (default=25)</p>
</td></tr>
<tr><td><code id="get.control.geneset_+3A_n.genes.per.bin">n.genes.per.bin</code></td>
<td>
<p>numeric Number of genes to get from each bin (default=100)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector that can be used as a background signature
</p>

<hr>
<h2 id='get.de.geneset'>Generate differential expression genesets for the web app given a cell grouping by
calculating DE sets between each cell set and everything else</h2><span id='topic+get.de.geneset'></span>

<h3>Description</h3>

<p>Generate differential expression genesets for the web app given a cell grouping by
calculating DE sets between each cell set and everything else
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.de.geneset(pagObj, groups, prefix = "de_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.de.geneset_+3A_pagobj">pagObj</code></td>
<td>
<p>pagoda object</p>
</td></tr>
<tr><td><code id="get.de.geneset_+3A_groups">groups</code></td>
<td>
<p>named factor to do the de by</p>
</td></tr>
<tr><td><code id="get.de.geneset_+3A_prefix">prefix</code></td>
<td>
<p>chararcter Prefix to assign to genesets generated (default=&quot;de_&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'pagoda2' web object
</p>

<hr>
<h2 id='getCellsInSelections'>Returns all the cells that are in the designated selections.
Given a pagoda2 selections object and the names of some selections
in it returns the names of the cells that are in these selections removed any duplicates</h2><span id='topic+getCellsInSelections'></span>

<h3>Description</h3>

<p>Returns all the cells that are in the designated selections.
Given a pagoda2 selections object and the names of some selections
in it returns the names of the cells that are in these selections removed any duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellsInSelections(p2selections, selectionNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellsInSelections_+3A_p2selections">p2selections</code></td>
<td>
<p>a p2 selections object</p>
</td></tr>
<tr><td><code id="getCellsInSelections_+3A_selectionnames">selectionNames</code></td>
<td>
<p>the names of some selections in th p2 object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of cell names
</p>

<hr>
<h2 id='getClusterLabelsFromSelection'>Assign names to the clusters, given a clustering vector and a set of selections.
This function will use a set of pagoda2 cell seletcion to identify
the clusters in a a named factor. It is meant to be used to import user defined annotations
that are defined as selections into a more formal categorization of cells that are defined by cluster.
To help with this the function allows a percent of cells to have been classified in the selections into
multiple groups, something which may be the result of the users making wrong selections. The percent of
cells allows to be multiselected in any given group is defined by multiClassCutoff. Furthermore
the method will assign each cluster to a selection only if the most popular cluster to the next most popular
exceed the ambiguous.ratio in terms of cell numbers. If a cluster does not satisfy this condtiion it is not
assigned.</h2><span id='topic+getClusterLabelsFromSelection'></span>

<h3>Description</h3>

<p>Assign names to the clusters, given a clustering vector and a set of selections.
This function will use a set of pagoda2 cell seletcion to identify
the clusters in a a named factor. It is meant to be used to import user defined annotations
that are defined as selections into a more formal categorization of cells that are defined by cluster.
To help with this the function allows a percent of cells to have been classified in the selections into
multiple groups, something which may be the result of the users making wrong selections. The percent of
cells allows to be multiselected in any given group is defined by multiClassCutoff. Furthermore
the method will assign each cluster to a selection only if the most popular cluster to the next most popular
exceed the ambiguous.ratio in terms of cell numbers. If a cluster does not satisfy this condtiion it is not
assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterLabelsFromSelection(
  clustering,
  selections,
  multiClassCutoff = 0.3,
  ambiguous.ratio = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterLabelsFromSelection_+3A_clustering">clustering</code></td>
<td>
<p>a named factor of clusters, where every entry is a cell</p>
</td></tr>
<tr><td><code id="getClusterLabelsFromSelection_+3A_selections">selections</code></td>
<td>
<p>a pagoda2 selection object</p>
</td></tr>
<tr><td><code id="getClusterLabelsFromSelection_+3A_multiclasscutoff">multiClassCutoff</code></td>
<td>
<p>numeric Percent of cells in any one cluster that can be multiassigned (default=0.3)</p>
</td></tr>
<tr><td><code id="getClusterLabelsFromSelection_+3A_ambiguous.ratio">ambiguous.ratio</code></td>
<td>
<p>numeric Ratio of first and second cell numbers for any cluster to produce a valid clustering (default=0.5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with two columns, one for cluster and one for selections, each cluster appears only once
</p>

<hr>
<h2 id='getColorsFromP2Selection'>Retrieves the colors of each selection from a p2 selection object as a names vector of strings</h2><span id='topic+getColorsFromP2Selection'></span>

<h3>Description</h3>

<p>Retrieves the colors of each selection from a p2 selection object as a names vector of strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColorsFromP2Selection(sel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColorsFromP2Selection_+3A_sel">sel</code></td>
<td>
<p>pagoda2 selection object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of hex colours
</p>

<hr>
<h2 id='getIntExtNamesP2Selection'>Get a mapping form internal to external names for the specified selection object</h2><span id='topic+getIntExtNamesP2Selection'></span>

<h3>Description</h3>

<p>Get a mapping form internal to external names for the specified selection object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIntExtNamesP2Selection(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIntExtNamesP2Selection_+3A_x">x</code></td>
<td>
<p>p2 selection object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of names from the specified selection object
</p>

<hr>
<h2 id='hierDiffToGenesets'>Converts the output of hierarchical differential expression aspects
into genesets that can be loaded into a 'pagoda2' web app to retrive the genes
that make the geneset interactively</h2><span id='topic+hierDiffToGenesets'></span>

<h3>Description</h3>

<p>Converts the output of hierarchical differential expression aspects
into genesets that can be loaded into a 'pagoda2' web app to retrive the genes
that make the geneset interactively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierDiffToGenesets(output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierDiffToGenesets_+3A_output">output</code></td>
<td>
<p>output of getHierarchicalDiffExpressionAspects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geneset that can be loaded into p2 web genesets
</p>

<hr>
<h2 id='make.p2.app'>Generate a Rook Server app from a 'Pagoda2' object. 
This generates a 'pagoda2' web object from a 'Pagoda2' object by automating steps that most
users will want to run. This function is a wrapper about the 'pagoda2' web constructor. 
(Advanced users may wish to use that constructor directly.)</h2><span id='topic+make.p2.app'></span>

<h3>Description</h3>

<p>Generate a Rook Server app from a 'Pagoda2' object. 
This generates a 'pagoda2' web object from a 'Pagoda2' object by automating steps that most
users will want to run. This function is a wrapper about the 'pagoda2' web constructor. 
(Advanced users may wish to use that constructor directly.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.p2.app(
  r,
  dendrogramCellGroups,
  additionalMetadata = list(),
  geneSets,
  show.depth = TRUE,
  show.batch = TRUE,
  show.clusters = TRUE,
  appname = "Pagoda2 Application",
  innerOrder = NULL,
  orderDend = FALSE,
  appmetadata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.p2.app_+3A_r">r</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_dendrogramcellgroups">dendrogramCellGroups</code></td>
<td>
<p>a named factor of cell groups, used to generate the main dendrogram, limits zoom in</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_additionalmetadata">additionalMetadata</code></td>
<td>
<p>a list of metadata other than depth, batch and cluster that are automatically added (default=list())</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_genesets">geneSets</code></td>
<td>
<p>a list of genesets to show</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_show.depth">show.depth</code></td>
<td>
<p>boolean Include depth as a metadata row (default=TRUE)</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_show.batch">show.batch</code></td>
<td>
<p>boolean Include batch as a metadata row (default=TRUE)</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_show.clusters">show.clusters</code></td>
<td>
<p>boolean Include clusters as a metadata row (default=TRUE)</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_appname">appname</code></td>
<td>
<p>character Application name (default=&quot;Pagoda2 Application&quot;)</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_innerorder">innerOrder</code></td>
<td>
<p>Ordering of cells inside the clusters provided in dendrogramCellGroups (default=NULL). This should be one of &quot;odPCA&quot;, &quot;reductdist&quot;, &quot;graphbased&quot;, &quot;knn&quot;. Defaults to NULL</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_orderdend">orderDend</code></td>
<td>
<p>boolean Whether to order dendrogram (default=FALSE)</p>
</td></tr>
<tr><td><code id="make.p2.app_+3A_appmetadata">appmetadata</code></td>
<td>
<p>a 'pagoda2' web application metadata (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'pagoda2' web object that presents a Rook compatible interface
</p>

<hr>
<h2 id='minMaxScale'>Scale the designated values between the range of 0 and 1</h2><span id='topic+minMaxScale'></span>

<h3>Description</h3>

<p>Scale the designated values between the range of 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minMaxScale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minMaxScale_+3A_x">x</code></td>
<td>
<p>values to scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the scaled values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_matrix =  matrix(rep(c(1:5), 3), 5)
minMaxScale(example_matrix)

</code></pre>

<hr>
<h2 id='Mode'>Return the mode of a vector</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>Return the mode of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>the vector to return the mode of</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mode elements
</p>

<hr>
<h2 id='namedNames'>Get a vector of the names of an object named by the names themselves. 
This is useful with lapply when passing names of objects as it ensures 
that the output list is also named.</h2><span id='topic+namedNames'></span>

<h3>Description</h3>

<p>Get a vector of the names of an object named by the names themselves. 
This is useful with lapply when passing names of objects as it ensures 
that the output list is also named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namedNames(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namedNames_+3A_g">g</code></td>
<td>
<p>an objects on which we can call names()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with names of object
</p>

<hr>
<h2 id='p2.generate.dr.go'>Generate a GO environment for human for overdispersion analysis for the the back end</h2><span id='topic+p2.generate.dr.go'></span>

<h3>Description</h3>

<p>Generate a GO environment for human for overdispersion analysis for the the back end
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.dr.go(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.dr.go_+3A_r">r</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GO environment object
</p>

<hr>
<h2 id='p2.generate.dr.go.web'>Generates zebrafish (Danio rerio) GO annotation for the web object</h2><span id='topic+p2.generate.dr.go.web'></span>

<h3>Description</h3>

<p>Generates zebrafish (Danio rerio) GO annotation for the web object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.dr.go.web(gene.names, n.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.dr.go.web_+3A_gene.names">gene.names</code></td>
<td>
<p>a character vector of genes to include</p>
</td></tr>
<tr><td><code id="p2.generate.dr.go.web_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
</table>

<hr>
<h2 id='p2.generate.go'>Generate a GO environment for the organism specified</h2><span id='topic+p2.generate.go'></span>

<h3>Description</h3>

<p>Generate a GO environment for the organism specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.go(
  r,
  organism = NULL,
  go2all.egs = NULL,
  eg.alias2eg = NULL,
  min.env.length = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.go_+3A_r">r</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
<tr><td><code id="p2.generate.go_+3A_organism">organism</code></td>
<td>
<p>the organism (default=NULL). Currently 'hs' (human), 'mm' (mouse) and 'dr' (zebrafish) are supported.</p>
</td></tr>
<tr><td><code id="p2.generate.go_+3A_go2all.egs">go2all.egs</code></td>
<td>
<p>mappings between a given GO identifier and all of the Entrez Gene identifiers 
annotated at that GO term or to one of its child nodes in the GO ontology (default=NULL)</p>
</td></tr>
<tr><td><code id="p2.generate.go_+3A_eg.alias2eg">eg.alias2eg</code></td>
<td>
<p>mappings between common gene symbol identifiers and entrez gene identifiers (default=NULL)</p>
</td></tr>
<tr><td><code id="p2.generate.go_+3A_min.env.length">min.env.length</code></td>
<td>
<p>numeric Minimum environment length (default=5)</p>
</td></tr>
</table>

<hr>
<h2 id='p2.generate.go.web'>Generates GO annotation for the web object for any species</h2><span id='topic+p2.generate.go.web'></span>

<h3>Description</h3>

<p>Generates GO annotation for the web object for any species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.go.web(
  gene.names,
  egALIAS2EG = NULL,
  egGO2ALLEGS = NULL,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.go.web_+3A_gene.names">gene.names</code></td>
<td>
<p>a character vector of genes to include</p>
</td></tr>
<tr><td><code id="p2.generate.go.web_+3A_egalias2eg">egALIAS2EG</code></td>
<td>
<p>(default=NULL)</p>
</td></tr>
<tr><td><code id="p2.generate.go.web_+3A_eggo2allegs">egGO2ALLEGS</code></td>
<td>
<p>(default=NULL)</p>
</td></tr>
<tr><td><code id="p2.generate.go.web_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
</table>

<hr>
<h2 id='p2.generate.go.web.fromGOEnv'>Generates GO annotation for the web object from the GO environment used for enrichment analysis</h2><span id='topic+p2.generate.go.web.fromGOEnv'></span>

<h3>Description</h3>

<p>Generates GO annotation for the web object from the GO environment used for enrichment analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.go.web.fromGOEnv(go.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.go.web.fromGOEnv_+3A_go.env">go.env</code></td>
<td>
<p>GO enviroment generated with p2.generate.go</p>
</td></tr>
</table>

<hr>
<h2 id='p2.generate.human.go'>Generate a GO environment for human for overdispersion analysis for the the back end</h2><span id='topic+p2.generate.human.go'></span>

<h3>Description</h3>

<p>Generate a GO environment for human for overdispersion analysis for the the back end
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.human.go(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.human.go_+3A_r">r</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GO environment object
</p>

<hr>
<h2 id='p2.generate.human.go.web'>Generates human GO annotation for the web object</h2><span id='topic+p2.generate.human.go.web'></span>

<h3>Description</h3>

<p>Generates human GO annotation for the web object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.human.go.web(gene.names, n.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.human.go.web_+3A_gene.names">gene.names</code></td>
<td>
<p>a character vector of genes to include</p>
</td></tr>
<tr><td><code id="p2.generate.human.go.web_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
</table>

<hr>
<h2 id='p2.generate.mouse.go'>Generate a GO environment for mouse for overdispersion analysis for the the back end</h2><span id='topic+p2.generate.mouse.go'></span>

<h3>Description</h3>

<p>Generate a GO environment for mouse for overdispersion analysis for the the back end
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.mouse.go(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.mouse.go_+3A_r">r</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GO environment object
</p>

<hr>
<h2 id='p2.generate.mouse.go.web'>Generates mouse (Mus musculus) GO annotation for the web object</h2><span id='topic+p2.generate.mouse.go.web'></span>

<h3>Description</h3>

<p>Generates mouse (Mus musculus) GO annotation for the web object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.generate.mouse.go.web(gene.names, n.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.generate.mouse.go.web_+3A_gene.names">gene.names</code></td>
<td>
<p>a character vector of genes to include</p>
</td></tr>
<tr><td><code id="p2.generate.mouse.go.web_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
</table>

<hr>
<h2 id='p2.make.pagoda1.app'>Create 'PAGODA1' web application from a 'Pagoda2' object
'PAGODA1' found here, with 'SCDE': &lt;https://www.bioconductor.org/packages/release/bioc/html/scde.html&gt;</h2><span id='topic+p2.make.pagoda1.app'></span>

<h3>Description</h3>

<p>Create 'PAGODA1' web application from a 'Pagoda2' object
'PAGODA1' found here, with 'SCDE': &lt;https://www.bioconductor.org/packages/release/bioc/html/scde.html&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.make.pagoda1.app(
  p2,
  col.cols = NULL,
  row.clustering = NULL,
  title = "pathway clustering",
  zlim = NULL,
  embedding = NULL,
  inner.clustering = TRUE,
  groups = NULL,
  clusterType = NULL,
  embeddingType = NULL,
  veloinfo = NULL,
  type = "PCA",
  min.group.size = 1,
  batch.colors = NULL,
  n.cores = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.make.pagoda1.app_+3A_p2">p2</code></td>
<td>
<p>'Pagoda2' object</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_col.cols">col.cols</code></td>
<td>
<p>Matrix of column colors (default=NULL). Useful for visualizing cell annotations such as batch labels.</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_row.clustering">row.clustering</code></td>
<td>
<p>Row dendrogram (default=NULL)</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_title">title</code></td>
<td>
<p>character Title to use (default=&quot;pathway clustering&quot;)</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_zlim">zlim</code></td>
<td>
<p>Range of the normalized gene expression levels (default=NULL). Input as a list: c(lower_bound, upper_bound). Values outside this range will be Winsorized. Useful for increasing the contrast of the heatmap visualizations. If NULL, set to the 5th and 95th percentiles.</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_embedding">embedding</code></td>
<td>
<p>A 2-D embedding of the cells (PCA, tSNE, etc.), passed as a data frame with two columns (two dimensions) and rows corresponding to cells (row names have to match cell names) (default=NULL).</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_inner.clustering">inner.clustering</code></td>
<td>
<p>boolean Whether to get overall cell clustering (default=TRUE).</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_groups">groups</code></td>
<td>
<p>factor describing grouping of different cells. If provided, the cross-fits and the expected expression magnitudes will be determined separately within each group. The factor should have the same length as ncol(counts) (default=NULL).</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_clustertype">clusterType</code></td>
<td>
<p>cluster type (default=NULL). If NULL, takes the latest cluster in the 'Pagoda2' object using 'p2$clusters[[type]][[1]]'</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_embeddingtype">embeddingType</code></td>
<td>
<p>embedding type (default=NULL). If NULL, takes the latest embedding in the 'Pagoda2' object using p2$embeddings[[type]][[1]]</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_veloinfo">veloinfo</code></td>
<td>
<p>cell velocity information, cell velocities (grid and cell) (default=NULL)</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_type">type</code></td>
<td>
<p>character Either 'counts' or a name of a 'reduction' in the 'Pagoda2' object (default='PCA')</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_min.group.size">min.group.size</code></td>
<td>
<p>integer Minimum group size (default=1)</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_batch.colors">batch.colors</code></td>
<td>
<p>colors of the batches, i.e. the factor (corresponding to rows of the model matrix) specifying batch assignment of each cell(default=NULL)</p>
</td></tr>
<tr><td><code id="p2.make.pagoda1.app_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores (default=10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'PAGODA1' web application
</p>

<hr>
<h2 id='p2.metadata.from.factor'>Generate a list metadata structure that can be passed to a
'pagoda2' web object constructor as additional metadata given a named factor</h2><span id='topic+p2.metadata.from.factor'></span>

<h3>Description</h3>

<p>Generate a list metadata structure that can be passed to a
'pagoda2' web object constructor as additional metadata given a named factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.metadata.from.factor(
  metadata,
  displayname = NULL,
  s = 1,
  v = 1,
  start = 0,
  end = NULL,
  pal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.metadata.from.factor_+3A_metadata">metadata</code></td>
<td>
<p>named factor with metadata for individual cells, names must correspond to cells</p>
</td></tr>
<tr><td><code id="p2.metadata.from.factor_+3A_displayname">displayname</code></td>
<td>
<p>character Name to display for the metadata (default=NULL)</p>
</td></tr>
<tr><td><code id="p2.metadata.from.factor_+3A_s">s</code></td>
<td>
<p>numeric Value for rainbow palette (default=1)</p>
</td></tr>
<tr><td><code id="p2.metadata.from.factor_+3A_v">v</code></td>
<td>
<p>numeric Value for rainbow palette (default=1)</p>
</td></tr>
<tr><td><code id="p2.metadata.from.factor_+3A_start">start</code></td>
<td>
<p>numeric Starting value (default=0)</p>
</td></tr>
<tr><td><code id="p2.metadata.from.factor_+3A_end">end</code></td>
<td>
<p>numeric Ending value (default=NULL)</p>
</td></tr>
<tr><td><code id="p2.metadata.from.factor_+3A_pal">pal</code></td>
<td>
<p>optional vector of colours to use, if provided overrides s,v,start and end parameters (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data, levels, palette to be passed to 'pagoda2' web object constructor
</p>

<hr>
<h2 id='p2.toweb.hdea'>Generate a 'pagoda2' web object from a 'Pagoda2' object using hierarchical differential expression</h2><span id='topic+p2.toweb.hdea'></span>

<h3>Description</h3>

<p>Generate a 'pagoda2' web object from a 'Pagoda2' object using hierarchical differential expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2.toweb.hdea(p2, title = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2.toweb.hdea_+3A_p2">p2</code></td>
<td>
<p>p2 object</p>
</td></tr>
<tr><td><code id="p2.toweb.hdea_+3A_title">title</code></td>
<td>
<p>character Name of the pagoda object (default=&quot;&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'pagoda2' web object
</p>

<hr>
<h2 id='p2ViewPagodaApp'>p2ViewPagodaApp R6 class</h2><span id='topic+p2ViewPagodaApp'></span>

<h3>Description</h3>

<p>Modified 'PAGODA1' app (from 'SCDE') for browsing 'pagoda2' results. 
Refer to 'ViewPagodaAppOld' and 'make.pagoda.app()' in 'SCDE'
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>results</code></dt><dd><p>Result object returned by <code>scde.expression.difference()</code> (default=NULL). Note to browse group posterior levels, use <code>return.posteriors = TRUE</code> in the <code>scde.expression.difference()</code> call.</p>
</dd>
<dt><code>type</code></dt><dd><p>Either 'counts' or a name of a 'reduction' in the 'Pagoda2' object</p>
</dd>
<dt><code>genes</code></dt><dd><p>List of genes to display in the Detailed clustering panel (default=list())</p>
</dd>
<dt><code>batch</code></dt><dd><p>Any batch or other known confounders to be included in the visualization as a column color track (default=NULL)</p>
</dd>
<dt><code>pathways</code></dt><dd><p>character vector Pathway or gene names (default=NULL)</p>
</dd>
<dt><code>name</code></dt><dd><p>App name (needs to be altered only if adding more than one app to the server using the 'server' parameter) (default=NULL)</p>
</dd>
<dt><code>trim</code></dt><dd><p>Trim quantity used for Winsorization for visualization</p>
</dd>
<dt><code>embedding</code></dt><dd><p>Embedding information (default=NULL)</p>
</dd>
<dt><code>veloinfo</code></dt><dd><p>Velocity information (default=NULL)</p>
</dd>
<dt><code>goenv</code></dt><dd><p>environment mapping pathways to genes (default=NULL)</p>
</dd>
<dt><code>renv</code></dt><dd><p>Global environment (default=NULL)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>p2ViewPagodaApp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-getgenecldata"><code>p2ViewPagodaApp$getgenecldata()</code></a>
</p>
</li>
<li> <p><a href="#method-call"><code>p2ViewPagodaApp$call()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>p2ViewPagodaApp$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize p2ViewPagodaApp class
</p>


<h5>Usage</h5>

<div class="r"><pre>p2ViewPagodaApp$new(
  results,
  pathways,
  genes,
  goenv,
  batch = NULL,
  name = "pathway overdispersion",
  trim = 1.1/nrow(p2$counts),
  embedding = NULL,
  type,
  veloinfo = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>results</code></dt><dd><p>Result object returned by <code>scde.expression.difference()</code>. Note to browse group posterior levels, use <code>return.posteriors = TRUE</code> in the <code>scde.expression.difference()</code> call.</p>
</dd>
<dt><code>pathways</code></dt><dd><p>character vector Pathway or gene names (default=NULL)</p>
</dd>
<dt><code>genes</code></dt><dd><p>list Genes to display in the Detailed clustering panel (default=list())</p>
</dd>
<dt><code>goenv</code></dt><dd><p>Environment mapping pathways to genes (default=NULL)</p>
</dd>
<dt><code>batch</code></dt><dd><p>Any batch or other known confounders to be included in the visualization as a column color track (default=NULL)</p>
</dd>
<dt><code>name</code></dt><dd><p>string App name (needs to be altered only if adding more than one app to the server using the 'server' parameter) (default=&quot;pathway overdispersion&quot;)</p>
</dd>
<dt><code>trim</code></dt><dd><p>numeric Trim quantity used for Winsorization for visualization (default=1.1/nrow(p2$counts) whereby the 'counts' from the 'Pagoda2' object is the gene count matrix, normalized on total counts (default=NULL)</p>
</dd>
<dt><code>embedding</code></dt><dd><p>Embedding information (default=NULL)</p>
</dd>
<dt><code>type</code></dt><dd><p>Either 'counts' or a name of a 'reduction' in the 'pagoda2' object</p>
</dd>
<dt><code>veloinfo</code></dt><dd><p>Velocity information (default=NULL)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>new 'p2ViewPagodaApp' object
</p>


<hr>
<a id="method-getgenecldata"></a>



<h4>Method <code>getgenecldata()</code></h4>

<p>Helper function to get the heatmap data for a given set of genes
</p>


<h5>Usage</h5>

<div class="r"><pre>p2ViewPagodaApp$getgenecldata(genes = NULL, gcl = NULL, ltrim = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genes</code></dt><dd><p>character vector Gene names (default=NULL)</p>
</dd>
<dt><code>gcl</code></dt><dd><p>pathway or gene-weighted PCA (default=NULL). If NULL, uses tp2c.view.pathways(self$genes, self$results$p2, goenv=goenv, vhc=self$results$hvc, plot=FALSE, trim=ltrim, n.genes=Inf).</p>
</dd>
<dt><code>ltrim</code></dt><dd><p>numeric Winsorization trim that should be applied (default=0)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>heatmap data for a given set of genes
</p>


<hr>
<a id="method-call"></a>



<h4>Method <code>call()</code></h4>

<p>Call Rook application. Using client-side ExtJS framework and Inchlib HTML5 canvas libraries to create the graphical user interface for PAGODA
</p>


<h5>Usage</h5>

<div class="r"><pre>p2ViewPagodaApp$call(env)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>env</code></dt><dd><p>The environment argument is a true R environment object which the application is free to modify. Please see the Rook documentation for more details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>modified 'PAGODA1' app
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>p2ViewPagodaApp$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='pagoda.reduce.loading.redundancy'>Collapse aspects driven by the same combinations of genes.
(Aspects are some pattern across cells e.g. sequencing depth, 
or PC corresponding to an undesired process such as ribosomal pathway variation.)
Examines PC loading vectors underlying the identified aspects and clusters of aspects based
on a product of loading and score correlation (raised to corr.power). 
Clusters of aspects driven by the same genes are determined based 
on the parameter &quot;distance.threshold&quot;.</h2><span id='topic+pagoda.reduce.loading.redundancy'></span>

<h3>Description</h3>

<p>Collapse aspects driven by the same combinations of genes.
(Aspects are some pattern across cells e.g. sequencing depth, 
or PC corresponding to an undesired process such as ribosomal pathway variation.)
Examines PC loading vectors underlying the identified aspects and clusters of aspects based
on a product of loading and score correlation (raised to corr.power). 
Clusters of aspects driven by the same genes are determined based 
on the parameter &quot;distance.threshold&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagoda.reduce.loading.redundancy(
  tam,
  pwpca,
  clpca = NULL,
  plot = FALSE,
  cluster.method = "complete",
  distance.threshold = 0.01,
  corr.power = 4,
  abs = TRUE,
  n.cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_tam">tam</code></td>
<td>
<p>output of pagoda.top.aspects(), i.e. a list structure containing the following items:
xv: a matrix of normalized aspect patterns (rows: significant aspects, columns: cells)
xvw: corresponding weight matrix 
gw: set of genes driving the significant aspects 
df: text table with the significance testing results</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_pwpca">pwpca</code></td>
<td>
<p>output of pagoda.pathway.wPCA(), i.e. a list of weighted PCA info for each valid gene set</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_clpca">clpca</code></td>
<td>
<p>output of pagoda.gene.clusters() (optional) (default=NULL). The output of pagoda.gene.clusters() is 
a list structure containing the following fields:
clusters: alist of genes in each cluster values
xf: extreme value distribution fit for the standardized lambda1 of a randomly generated pattern
tci: index of a top cluster in each random iteration
cl.goc: weighted PCA info for each real gene cluster
varm: standardized lambda1 values for each randomly generated matrix cluster
clvlm: a linear model describing dependency of the cluster lambda1 on a Tracy-Widom lambda1 expectation</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_plot">plot</code></td>
<td>
<p>boolean Whether to plot the resulting clustering (default=FALSE)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_cluster.method">cluster.method</code></td>
<td>
<p>string One of the standard clustering methods to be used (default=&quot;complete&quot;)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>numeric Similarity threshold for grouping interdependent aspects (default=0.01)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_corr.power">corr.power</code></td>
<td>
<p>numeric Power to which the product of loading and score correlation is raised (default=4)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_abs">abs</code></td>
<td>
<p>boolean Whether to use absolute correlation (default=TRUE)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use during processing (default=1)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.loading.redundancy_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to the pagoda.view.aspects() method during plotting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list structure analogous to that returned by pagoda.top.aspects(), but with addition of a $cnam element containing a list of aspects summarized by each row of the new (reduced) $xv and $xvw
</p>

<hr>
<h2 id='pagoda.reduce.redundancy'>Collapse aspects driven by similar patterns (i.e. separate the same sets of cells)
Examines PC loading vectors underlying the identified aspects and clusters aspects based on score correlation. Clusters of aspects driven by the same patterns are determined based on the distance.threshold.</h2><span id='topic+pagoda.reduce.redundancy'></span>

<h3>Description</h3>

<p>Collapse aspects driven by similar patterns (i.e. separate the same sets of cells)
Examines PC loading vectors underlying the identified aspects and clusters aspects based on score correlation. Clusters of aspects driven by the same patterns are determined based on the distance.threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagoda.reduce.redundancy(
  tamr,
  distance.threshold = 0.2,
  cluster.method = "complete",
  distance = NULL,
  weighted.correlation = TRUE,
  plot = FALSE,
  top = Inf,
  trim = 0,
  abs = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda.reduce.redundancy_+3A_tamr">tamr</code></td>
<td>
<p>Combined pathways that show similar expression patterns, output of pagoda.reduce.loading.redundancy()</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>numeric Similarity threshold for grouping interdependent aspects (default=0.2)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_cluster.method">cluster.method</code></td>
<td>
<p>character One of the standard clustering methods to be used (default=&quot;complete&quot;)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_distance">distance</code></td>
<td>
<p>distance matrix (default=NULL)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_weighted.correlation">weighted.correlation</code></td>
<td>
<p>boolean Whether to use a weighted correlation in determining the similarity of patterns (default=TRUE)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_plot">plot</code></td>
<td>
<p>boolean Whether to show plot (default=FALSE)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_top">top</code></td>
<td>
<p>bololean Restrict output to the top N aspects of heterogeneity (default=Inf, i.e. no restriction)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_trim">trim</code></td>
<td>
<p>numeric Winsorization trim to use prior to determining the top aspects (default=0)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_abs">abs</code></td>
<td>
<p>boolean Whether to use absolute correlation (default=FALSE)</p>
</td></tr>
<tr><td><code id="pagoda.reduce.redundancy_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to the pagoda.view.aspects() method during plotting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List structure analogous to that returned by pagoda.top.aspects(), but with addition of a $cnam element containing a list of aspects summarized by each row of the new (reduced) $xv and $xvw
</p>

<hr>
<h2 id='Pagoda2'>Pagoda2 R6 class</h2><span id='topic+Pagoda2'></span>

<h3>Description</h3>

<p>The class encompasses gene count matrices, providing methods for normalization, calculating embeddings, and differential expression.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>counts</code></dt><dd><p>Gene count matrix, normalized on total counts (default=NULL)</p>
</dd>
<dt><code>modelType</code></dt><dd><p>string Model used to normalize count matrices. Only supported values are 'raw', 'plain', and 'linearObs'.
&ndash; 'plain': Normalize by regressing out on the non-zero observations of each gene (default).
&ndash; 'raw': Use the raw count matrices, without normalization. The expression matrix taken &quot;as is&quot; without normalization, although log.scale still applies. 
&ndash; 'linearObs': Fit a linear model of pooled counts across all genes against depth. This approach isn't recommened, as the depth dependency is not completely normalized out.</p>
</dd>
<dt><code>clusters</code></dt><dd><p>Results of clustering (default=list())</p>
</dd>
<dt><code>graphs</code></dt><dd><p>Graph representations of the dataset (default=list())</p>
</dd>
<dt><code>reductions</code></dt><dd><p>Results of reductions, e.g. PCA (default=list())</p>
</dd>
<dt><code>embeddings</code></dt><dd><p>Results of visualization algorithms, t-SNE or largeVis (default=list())</p>
</dd>
<dt><code>diffgenes</code></dt><dd><p>Lists of differentially expressed genes (default=list())</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>number of cores (default=1)</p>
</dd>
<dt><code>misc</code></dt><dd><p>list with additional info (default=list())</p>
</dd>
<dt><code>batch</code></dt><dd><p>Batch factor for the dataset (default=NULL)</p>
</dd>
<dt><code>genegraphs</code></dt><dd><p>Slot to store graphical representations in gene space (i.e. gene kNN graphs) (default=list())</p>
</dd>
<dt><code>depth</code></dt><dd><p>Number of molecules measured per cell (default=NULL)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Pagoda2$new()</code></a>
</p>
</li>
<li> <p><a href="#method-setCountMatrix"><code>Pagoda2$setCountMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-adjustVariance"><code>Pagoda2$adjustVariance()</code></a>
</p>
</li>
<li> <p><a href="#method-makeKnnGraph"><code>Pagoda2$makeKnnGraph()</code></a>
</p>
</li>
<li> <p><a href="#method-getKnnClusters"><code>Pagoda2$getKnnClusters()</code></a>
</p>
</li>
<li> <p><a href="#method-geneKnnbyPCA"><code>Pagoda2$geneKnnbyPCA()</code></a>
</p>
</li>
<li> <p><a href="#method-getHierarchicalDiffExpressionAspects"><code>Pagoda2$getHierarchicalDiffExpressionAspects()</code></a>
</p>
</li>
<li> <p><a href="#method-makeGeneKnnGraph"><code>Pagoda2$makeGeneKnnGraph()</code></a>
</p>
</li>
<li> <p><a href="#method-getDensityClusters"><code>Pagoda2$getDensityClusters()</code></a>
</p>
</li>
<li> <p><a href="#method-getDifferentialGenes"><code>Pagoda2$getDifferentialGenes()</code></a>
</p>
</li>
<li> <p><a href="#method-plotDiffGeneHeatmap"><code>Pagoda2$plotDiffGeneHeatmap()</code></a>
</p>
</li>
<li> <p><a href="#method-getRefinedLibSizes"><code>Pagoda2$getRefinedLibSizes()</code></a>
</p>
</li>
<li> <p><a href="#method-plotGeneHeatmap"><code>Pagoda2$plotGeneHeatmap()</code></a>
</p>
</li>
<li> <p><a href="#method-plotEmbedding"><code>Pagoda2$plotEmbedding()</code></a>
</p>
</li>
<li> <p><a href="#method-getOdGenes"><code>Pagoda2$getOdGenes()</code></a>
</p>
</li>
<li> <p><a href="#method-getNormalizedExpressionMatrix"><code>Pagoda2$getNormalizedExpressionMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-calculatePcaReduction"><code>Pagoda2$calculatePcaReduction()</code></a>
</p>
</li>
<li> <p><a href="#method-expandOdGenes"><code>Pagoda2$expandOdGenes()</code></a>
</p>
</li>
<li> <p><a href="#method-localPcaKnn"><code>Pagoda2$localPcaKnn()</code></a>
</p>
</li>
<li> <p><a href="#method-testPathwayOverdispersion"><code>Pagoda2$testPathwayOverdispersion()</code></a>
</p>
</li>
<li> <p><a href="#method-getEmbedding"><code>Pagoda2$getEmbedding()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Pagoda2$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize Pagoda2 class
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$new(
  x,
  modelType = "plain",
  n.cores = parallel::detectCores(logical = FALSE),
  verbose = TRUE,
  min.cells.per.gene = 0,
  trim = round(min.cells.per.gene/2),
  min.transcripts.per.cell = 10,
  batch = NULL,
  lib.sizes = NULL,
  log.scale = TRUE,
  keep.genes = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>input count matrix</p>
</dd>
<dt><code>modelType</code></dt><dd><p>Model used to normalize count matrices (default='plain'). Only supported values are 'raw', 'plain', and 'linearObs'.</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>min.cells.per.gene</code></dt><dd><p>integer Minimum number of cells per gene, used to subset counts for coverage (default=0)</p>
</dd>
<dt><code>trim</code></dt><dd><p>numeric Parameter used for winsorizing count data (default=round(min.cells.per.gene/2)). If value&gt;0, will winsorize counts in normalized space in the hopes of getting a more stable depth estimates. If value&lt;=0, ignored.</p>
</dd>
<dt><code>min.transcripts.per.cell</code></dt><dd><p>integer Minimum number of transcripts per cells, used to subset counts for coverage (default=10)</p>
</dd>
<dt><code>batch</code></dt><dd><p>fctor Batch factor for the dataset (default=NULL)</p>
</dd>
<dt><code>lib.sizes</code></dt><dd><p>character vector of library sizes (default=NULL)</p>
</dd>
<dt><code>log.scale</code></dt><dd><p>boolean If TRUE, scale counts by log() (default=TRUE)</p>
</dd>
<dt><code>keep.genes</code></dt><dd><p>list of genes to keep in count matrix after filtering out by coverage but before normalization (default=NULL)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>new Pagoda2 object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{ 
## Load pre-generated a dataset of 50 bone marrow cells as matrix
cm &lt;- readRDS(system.file("extdata", "sample_BM1_50.rds", package="pagoda2"))
## Perform QC, i.e. filter any cells that
counts &lt;- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) &lt;- make.unique(rownames(counts))
## Generate Pagoda2 object 
p2_object &lt;- Pagoda2$new(counts, log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
}

</pre>
</div>


<hr>
<a id="method-setCountMatrix"></a>



<h4>Method <code>setCountMatrix()</code></h4>

<p>Provide the initial count matrix, and estimate deviance residual matrix (correcting for depth and batch)
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$setCountMatrix(
  countMatrix,
  depthScale = 1000,
  min.cells.per.gene = 0,
  trim = round(min.cells.per.gene/2),
  min.transcripts.per.cell = 10,
  lib.sizes = NULL,
  log.scale = FALSE,
  keep.genes = NULL,
  verbose = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>countMatrix</code></dt><dd><p>input count matrix</p>
</dd>
<dt><code>depthScale</code></dt><dd><p>numeric Scaling factor for normalizing counts (defaul=1e3). If 'plain', counts are scaled by counts = counts/as.numeric(depth/depthScale).</p>
</dd>
<dt><code>min.cells.per.gene</code></dt><dd><p>integer Minimum number of cells per gene, used to subset counts for coverage (default=0)</p>
</dd>
<dt><code>trim</code></dt><dd><p>numeric Parameter used for winsorizing count data (default=round(min.cells.per.gene/2)). If value&gt;0, will winsorize counts in normalized space in the hopes of getting a more stable depth estimates. If value&lt;=0, ignored.</p>
</dd>
<dt><code>min.transcripts.per.cell</code></dt><dd><p>integer Minimum number of transcripts per cells, used to subset counts for coverage (default=10)</p>
</dd>
<dt><code>lib.sizes</code></dt><dd><p>character vector of library sizes (default=NULL)</p>
</dd>
<dt><code>log.scale</code></dt><dd><p>boolean If TRUE, scale counts by log() (default=TRUE)</p>
</dd>
<dt><code>keep.genes</code></dt><dd><p>list of genes to keep in count matrix after filtering out by coverage but before normalization (default=NULL)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>normalized count matrix (or if modelTye='raw', the unnormalized count matrix)
</p>


<hr>
<a id="method-adjustVariance"></a>



<h4>Method <code>adjustVariance()</code></h4>

<p>Adjust variance of the residual matrix, determine overdispersed sites
This is done to normalize the extent to which genes with (very) different expression magnitudes will contribute to the downstream anlaysis.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$adjustVariance(
  gam.k = 5,
  alpha = 0.05,
  plot = FALSE,
  use.raw.variance = FALSE,
  use.unadjusted.pvals = FALSE,
  do.par = TRUE,
  max.adjusted.variance = 1000,
  min.adjusted.variance = 0.001,
  cells = NULL,
  verbose = TRUE,
  min.gene.cells = 0,
  persist = is.null(cells),
  n.cores = self$n.cores
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>gam.k</code></dt><dd><p>integer The k used for the generalized additive model 'v ~ s(m, k =gam.k)' (default=5). If gam.k&lt;2, linear regression is used 'lm(v ~ m)'.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>numeric The Type I error probability or the significance level (default=5e-2). This is the criterion used to measure statistical significance, i.e. if the p-value &lt; alpha, then it is statistically significant.</p>
</dd>
<dt><code>plot</code></dt><dd><p>boolean Whether to output the plot (default=FALSE)</p>
</dd>
<dt><code>use.raw.variance</code></dt><dd><p>(default=FALSE). If modelType='raw', then this conditional will be used as TRUE.</p>
</dd>
<dt><code>use.unadjusted.pvals</code></dt><dd><p>boolean Whether to use Benjamini-Hochberg adjusted p-values (default=FALSE).</p>
</dd>
<dt><code>do.par</code></dt><dd><p>boolean Whether to put multiple graphs into a signle plot with par() (default=TRUE)</p>
</dd>
<dt><code>max.adjusted.variance</code></dt><dd><p>numeric Maximum adjusted variance (default=1e3). The gene scale factor is defined as sqrt(pmax(min.adjusted.variance,pmin(max.adjusted.variance,df$qv))/exp(df$v))</p>
</dd>
<dt><code>min.adjusted.variance</code></dt><dd><p>numeric Minimum adjusted variance (default=1e-3). The gene scale factor is defined as sqrt(pmax(min.adjusted.variance,pmin(max.adjusted.variance,df$qv))/exp(df$v))</p>
</dd>
<dt><code>cells</code></dt><dd><p>character vector Subset of cells upon which to perform variance normalization with adjustVariance() (default=NULL)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>min.gene.cells</code></dt><dd><p>integer Minimum number of genes per cells (default=0). This parameter is used to filter counts.</p>
</dd>
<dt><code>persist</code></dt><dd><p>boolean Whether to save results (default=TRUE, i.e. is.null(cells)).</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>residual matrix with adjusted variance
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
## Load pre-generated a dataset of 50 bone marrow cells as matrix
cm &lt;- readRDS(system.file("extdata", "sample_BM1_50.rds", package="pagoda2"))
## Perform QC, i.e. filter any cells that
counts &lt;- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) &lt;- make.unique(rownames(counts))
## Generate Pagoda2 object 
p2_object &lt;- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
## Normalize gene expression variance
p2_object$adjustVariance(plot=TRUE, gam.k=10)
}

</pre>
</div>


<hr>
<a id="method-makeKnnGraph"></a>



<h4>Method <code>makeKnnGraph()</code></h4>

<p>Create k-nearest neighbor graph
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$makeKnnGraph(
  k = 30,
  nrand = 1000,
  type = "counts",
  weight.type = "1m",
  odgenes = NULL,
  n.cores = self$n.cores,
  distance = "cosine",
  center = TRUE,
  x = NULL,
  p = NULL,
  var.scale = (type == "counts"),
  verbose = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>integer Number of k clusters for k-NN (default=30)</p>
</dd>
<dt><code>nrand</code></dt><dd><p>numeric Number of randomizations i.e. the gene sets (of the same size) to be evaluated in parallel with each gene set (default=1e3)</p>
</dd>
<dt><code>type</code></dt><dd><p>string Data type of the reduction (default='counts'). If type='counts', this will access the raw counts. Otherwise, 'type' must be name of the reductions.</p>
</dd>
<dt><code>weight.type</code></dt><dd><p>string 'cauchy', 'normal', 'constant', '1m' (default='1m')</p>
</dd>
<dt><code>odgenes</code></dt><dd><p>character vector Overdispersed genes to retrieve (default=NULL)</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>distance</code></dt><dd><p>string Distance metric used: 'cosine', 'L2', 'L1', 'cauchy', 'euclidean' (default='cosine')</p>
</dd>
<dt><code>center</code></dt><dd><p>boolean Whether to use centering when distance='cosine' (default=TRUE). The parameter is ignored otherwise.</p>
</dd>
<dt><code>x</code></dt><dd><p>counts or reduction to use (default=NULL). If NULL, uses counts. Otherwise, checks for the reduction in self$reductions[[type]]</p>
</dd>
<dt><code>p</code></dt><dd><p>(default=NULL)</p>
</dd>
<dt><code>var.scale</code></dt><dd><p>boolean Apply scaling if using raw counts (default=TRUE). If type=&quot;counts&quot;, var.scale is TRUE by default.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>kNN graph, stored in self$graphs
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
## Load pre-generated a dataset of 50 bone marrow cells as matrix
cm &lt;- readRDS(system.file("extdata", "sample_BM1_50.rds", package="pagoda2"))
## Perform QC, i.e. filter any cells that
counts &lt;- gene.vs.molecule.cell.filter(cm, min.cell.size=300)
rownames(counts) &lt;- make.unique(rownames(counts))
## Generate Pagoda2 object   
p2_object &lt;- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
## Normalize gene expression variance
p2_object$adjustVariance(plot=TRUE, gam.k=10)
## Generate a kNN graph of cells that will allow us to identify clusters of cells
p2_object$makeKnnGraph(k=20, center=FALSE, distance='L2')
}

</pre>
</div>


<hr>
<a id="method-getKnnClusters"></a>



<h4>Method <code>getKnnClusters()</code></h4>

<p>Calculate clusters based on the kNN graph
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getKnnClusters(
  type = "counts",
  method = igraph::multilevel.community,
  name = "community",
  n.cores = self$n.cores,
  g = NULL,
  min.cluster.size = 1,
  persist = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>method</code></dt><dd><p>Method to use (default=igraph::multilevel.community). Accepted methods are either 'igraph::infomap.community' or 'igraph::multilevel.community'. 
If NULL, if the number of vertices of the graph is greater than or equal to 2000, 'igraph::multilevel.community' will be used. Otherwise, 'igraph::infomap.community' will be used.</p>
</dd>
<dt><code>name</code></dt><dd><p>string Name of the community structure calculated from 'method' (default='community')</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>g</code></dt><dd><p>Input graph (default=NULL). If NULL, access graph from self$graphs[[type]].</p>
</dd>
<dt><code>min.cluster.size</code></dt><dd><p>Minimum size of clusters (default=1). This parameter is primarily used to remove very small clusters.</p>
</dd>
<dt><code>persist</code></dt><dd><p>boolean Whether to save the clusters and community structure (default=TRUE)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters to pass to 'method'</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the community structure calculated from 'method'
</p>


<hr>
<a id="method-geneKnnbyPCA"></a>



<h4>Method <code>geneKnnbyPCA()</code></h4>

<p>Deprecated function. Use makeGeneKnnGraph() instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$geneKnnbyPCA()</pre></div>


<hr>
<a id="method-getHierarchicalDiffExpressionAspects"></a>



<h4>Method <code>getHierarchicalDiffExpressionAspects()</code></h4>

<p>Take a given clustering and generate a hierarchical clustering
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getHierarchicalDiffExpressionAspects(
  type = "counts",
  groups = NULL,
  clusterName = NULL,
  method = "ward.D",
  dist = "pearson",
  persist = TRUE,
  z.threshold = 2,
  n.cores = self$n.cores,
  min.set.size = 5,
  verbose = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type of the reduction (default='counts'). If type='counts', this will access the raw counts. Otherwise, 'type' must be name of the reductions.</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.</p>
</dd>
<dt><code>clusterName</code></dt><dd><p>string Cluster name to access (default=NULL)</p>
</dd>
<dt><code>method</code></dt><dd><p>string The agglomeration method to be used in stats::hcust(method=method) (default='ward.D'). Accepted values are: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC). For more information, see stats::hclust().</p>
</dd>
<dt><code>dist</code></dt><dd><p>string 'pearson', 'spearman', 'euclidean', 'L2', 'JS' (default='pearson')</p>
</dd>
<dt><code>persist</code></dt><dd><p>boolean Whether to save the clusters and community structure (default=TRUE)</p>
</dd>
<dt><code>z.threshold</code></dt><dd><p>numeric Threshold of z-scores to filter, &gt;=z.threshold are kept (default=2)</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>min.set.size</code></dt><dd><p>integer Minimum threshold of sets to keep (default=5)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>hierarchical clustering
</p>


<hr>
<a id="method-makeGeneKnnGraph"></a>



<h4>Method <code>makeGeneKnnGraph()</code></h4>

<p>Calculates gene Knn network for gene similarity
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$makeGeneKnnGraph(
  nPcs = 100,
  center = TRUE,
  fastpath = TRUE,
  maxit = 1000,
  k = 30,
  n.cores = self$n.cores,
  verbose = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nPcs</code></dt><dd><p>integer Number of principal components (default=100). This is the parameter 'nv' in irlba::irlba(), the number of right singular vectors to estimate.</p>
</dd>
<dt><code>center</code></dt><dd><p>boolean Whether to center the PCA (default=TRUE)</p>
</dd>
<dt><code>fastpath</code></dt><dd><p>boolean Whether to try a (fast) C algorithm implementation if possible (default=TRUE). This parameter is equivalent to 'fastpath' in irlba::irlba().</p>
</dd>
<dt><code>maxit</code></dt><dd><p>integer Maximum number of iterations (default=1000). This parameter is equivalent to 'maxit' in irlba::irlba().</p>
</dd>
<dt><code>k</code></dt><dd><p>integer Number of k clusters for calculating k-NN on the resulting principal components (default=30).</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>graph with gene similarity
</p>


<hr>
<a id="method-getDensityClusters"></a>



<h4>Method <code>getDensityClusters()</code></h4>

<p>Calculate density-based clusters
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getDensityClusters(
  type = "counts",
  embeddingType = NULL,
  name = "density",
  eps = 0.5,
  v = 0.7,
  s = 1,
  verbose = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>embeddingType</code></dt><dd><p>The type of embedding used when calculating with &lsquo;getEmbedding()' (default=NULL). Accepted values are: &rsquo;largeVis', 'tSNE', 'FR', 'UMAP', 'UMAP_graph'</p>
</dd>
<dt><code>name</code></dt><dd><p>string Name fo the clustering (default='density').</p>
</dd>
<dt><code>eps</code></dt><dd><p>numeric value of the eps parameter, fed into dbscan::dbscan(x=emb, eps=eps, ...)</p>
</dd>
<dt><code>v</code></dt><dd><p>numeric The “value” to be used to complete the HSV color descriptions (default=0.7). Equivalent to the 'v' parameter in grDevices::rainbow().</p>
</dd>
<dt><code>s</code></dt><dd><p>numeric The “saturation” to be used to complete the HSV color descriptions (default=1). Equivalent to the 's' parameter in grDevices::rainbow().</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to dbscan::dbscan(emb, ...)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>density-based clusters
</p>


<hr>
<a id="method-getDifferentialGenes"></a>



<h4>Method <code>getDifferentialGenes()</code></h4>

<p>Determine differentially expressed genes, comparing each group against all others using Wilcoxon rank sum test
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getDifferentialGenes(
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  name = "customClustering",
  z.threshold = 3,
  upregulated.only = FALSE,
  verbose = FALSE,
  append.specificity.metrics = TRUE,
  append.auc = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>clusterType</code></dt><dd><p>Optional cluster type to use as a group-defining factor (default=NULL)</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.</p>
</dd>
<dt><code>name</code></dt><dd><p>string Slot to store the results in (default='customClustering')</p>
</dd>
<dt><code>z.threshold</code></dt><dd><p>numeric Minimal absolute Z score (adjusted) to report (default=3)</p>
</dd>
<dt><code>upregulated.only</code></dt><dd><p>boolean Whether to report only genes that are expressed significantly higher in each group (default=FALSE)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=FALSE)</p>
</dd>
<dt><code>append.specificity.metrics</code></dt><dd><p>boolean Whether to append specifity metrics (default=TRUE). Uses the function sccore::appendSpecificityMetricsToDE().</p>
</dd>
<dt><code>append.auc</code></dt><dd><p>boolean If TRUE, append AUC values (default=FALSE). Parameter ignored if append.specificity.metrics is FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List with each element of the list corresponding to a cell group in the provided/used factor (i.e. factor levels) 
Each element of a list is a data frame listing the differentially epxressed genes (row names), with the following columns: 
Z - adjusted Z score, with positive values indicating higher expression in a given group compare to the rest
M - log2 fold change
highest- a boolean flag indicating whether the expression of a given gene in a given vcell group was on average higher than in every other cell group
fe - fraction of cells in a given group having non-zero expression level of a given gene
</p>


<hr>
<a id="method-plotDiffGeneHeatmap"></a>



<h4>Method <code>plotDiffGeneHeatmap()</code></h4>

<p>Plot heatmap of DE results
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$plotDiffGeneHeatmap(
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  n.genes = 100,
  z.score = 2,
  gradient.range.quantile = 0.95,
  inner.clustering = FALSE,
  gradientPalette = NULL,
  v = 0.8,
  s = 1,
  box = TRUE,
  drawGroupNames = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>clusterType</code></dt><dd><p>Optional cluster type to use as a group-defining factor (default=NULL)</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.</p>
</dd>
<dt><code>n.genes</code></dt><dd><p>integer Number of genes to plot (default=100)</p>
</dd>
<dt><code>z.score</code></dt><dd><p>numeric Threshold of z-scores to filter (default=2). Only greater than or equal to this value are kept.</p>
</dd>
<dt><code>gradient.range.quantile</code></dt><dd><p>numeric Trimming quantile (default=0.95)</p>
</dd>
<dt><code>inner.clustering</code></dt><dd><p>boolean Whether to cluster cells within each cluster (default=FALSE)</p>
</dd>
<dt><code>gradientPalette</code></dt><dd><p>palette of colors to use (default=NULL). If NULL, uses 'colorRampPalette(c('gray90','red'), space = &quot;Lab&quot;)(1024)'</p>
</dd>
<dt><code>v</code></dt><dd><p>numeric The “value” to be used to complete the HSV color descriptions (default=0.7). Equivalent to the 'v' parameter in grDevices::rainbow().</p>
</dd>
<dt><code>s</code></dt><dd><p>numeric The “saturation” to be used to complete the HSV color descriptions (default=1). Equivalent to the 's' parameter in grDevices::rainbow().</p>
</dd>
<dt><code>box</code></dt><dd><p>boolean Whether to draw a box around the current plot in the given color and linetype (default=TRUE)</p>
</dd>
<dt><code>drawGroupNames</code></dt><dd><p>boolean Whether to draw group names (default=FALSE)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to internal function used for heatmap plotting, my.heatmap2()</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>heatmap of DE results
</p>


<hr>
<a id="method-getRefinedLibSizes"></a>



<h4>Method <code>getRefinedLibSizes()</code></h4>

<p>Recalculate library sizes using robust regression within clusters
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getRefinedLibSizes(
  clusterType = NULL,
  groups = NULL,
  type = "counts",
  n.cores = self$n.cores
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clusterType</code></dt><dd><p>Name of cluster to access (default=NULL). If NULL, takes the most recently generated clustering. Parameter ignored if groups is not NULL.</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells (default=NULL)</p>
</dd>
<dt><code>type</code></dt><dd><p>string Either 'counts' or the name of a stored embedding, names(self$embeddings) (default=NULL)</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=self$n.cores=1)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>recalculated library sizes
</p>


<hr>
<a id="method-plotGeneHeatmap"></a>



<h4>Method <code>plotGeneHeatmap()</code></h4>

<p>Plot heatmap for a given set of genes
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$plotGeneHeatmap(
  genes,
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  gradient.range.quantile = 0.95,
  cluster.genes = FALSE,
  inner.clustering = FALSE,
  gradientPalette = NULL,
  v = 0.8,
  s = 1,
  box = TRUE,
  drawGroupNames = FALSE,
  useRaster = TRUE,
  smooth.span = max(1, round(nrow(self$counts)/1024)),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genes</code></dt><dd><p>character vector Gene names</p>
</dd>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>clusterType</code></dt><dd><p>Optional cluster type to use as a group-defining factor (default=NULL)</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.</p>
</dd>
<dt><code>gradient.range.quantile</code></dt><dd><p>numeric Trimming quantile (default=0.95)</p>
</dd>
<dt><code>cluster.genes</code></dt><dd><p>boolean Whether to cluster genes within each cluster using stats::hclust() (default=FALSE)</p>
</dd>
<dt><code>inner.clustering</code></dt><dd><p>boolean Whether to cluster cells within each cluster (default=FALSE)</p>
</dd>
<dt><code>gradientPalette</code></dt><dd><p>palette of colors to use (default=NULL). If NULL, uses 'colorRampPalette(c('gray90','red'), space = &quot;Lab&quot;)(1024)'</p>
</dd>
<dt><code>v</code></dt><dd><p>numeric The “value” to be used to complete the HSV color descriptions (default=0.7). Equivalent to the 'v' parameter in grDevices::rainbow().</p>
</dd>
<dt><code>s</code></dt><dd><p>numeric The “saturation” to be used to complete the HSV color descriptions (default=1). Equivalent to the 's' parameter in grDevices::rainbow().</p>
</dd>
<dt><code>box</code></dt><dd><p>boolean Whether to draw a box around the current plot in the given color and linetype (default=TRUE)</p>
</dd>
<dt><code>drawGroupNames</code></dt><dd><p>boolean Whether to draw group names (default=FALSE)</p>
</dd>
<dt><code>useRaster</code></dt><dd><p>boolean If TRUE a bitmap raster is used to plot the image instead of polygons (default=TRUE). The grid must be regular in that case, otherwise an error is raised. For more information, see graphics::image().</p>
</dd>
<dt><code>smooth.span</code></dt><dd><p>(default=max(1,round(nrow(self$counts)/1024)))</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to internal function used for heatmap plotting, my.heatmap2()</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>plot of gene heatmap
</p>


<hr>
<a id="method-plotEmbedding"></a>



<h4>Method <code>plotEmbedding()</code></h4>

<p>Show embedding
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$plotEmbedding(
  type = NULL,
  embeddingType = NULL,
  clusterType = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  plot.theme = ggplot2::theme_bw(),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Either 'counts' or the name of a stored embedding, names(self$embeddings) (default=NULL)</p>
</dd>
<dt><code>embeddingType</code></dt><dd><p>string Embedding type (default=NULL). If NULL, takes the most recently generated embedding.</p>
</dd>
<dt><code>clusterType</code></dt><dd><p>Name of cluster to access (default=NULL). If NULL, takes the most recently generated clustering. Parameter ignored if groups is not NULL.</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells (default=NULL)</p>
</dd>
<dt><code>colors</code></dt><dd><p>character vector List of gene names (default=NULL)</p>
</dd>
<dt><code>gene</code></dt><dd><p>(default=NULL)</p>
</dd>
<dt><code>plot.theme</code></dt><dd><p>(default=ggplot2::theme_bw())</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to sccore::embeddingPlot()</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>plot of the embedding
</p>


<hr>
<a id="method-getOdGenes"></a>



<h4>Method <code>getOdGenes()</code></h4>

<p>Get overdispersed genes
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getOdGenes(
  n.odgenes = NULL,
  alpha = 0.05,
  use.unadjusted.pvals = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n.odgenes</code></dt><dd><p>integer Number of overdispersed genes to retrieve (default=NULL). If NULL, will return all.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>numeric The Type I error probability or the significance level (default=5e-2). This is the criterion used to measure statistical significance, i.e. if the p-value &lt; alpha, then it is statistically significant.</p>
</dd>
<dt><code>use.unadjusted.pvals</code></dt><dd><p>boolean Whether to use Benjamini-Hochberg adjusted p-values (default=FALSE).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of overdispersed genes
</p>


<hr>
<a id="method-getNormalizedExpressionMatrix"></a>



<h4>Method <code>getNormalizedExpressionMatrix()</code></h4>

<p>Return variance-normalized matrix for specified genes or a number of OD genes
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getNormalizedExpressionMatrix(genes = NULL, n.odgenes = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genes</code></dt><dd><p>vector of gene names to explicitly return (default=NULL)</p>
</dd>
<dt><code>n.odgenes</code></dt><dd><p>integer Number of overdispersed genes to retrieve (default=NULL). If NULL, will return all.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>cell by gene matrix
</p>


<hr>
<a id="method-calculatePcaReduction"></a>



<h4>Method <code>calculatePcaReduction()</code></h4>

<p>Calculate PCA reduction of the data
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$calculatePcaReduction(
  nPcs = 20,
  type = "counts",
  name = "PCA",
  use.odgenes = TRUE,
  n.odgenes = NULL,
  odgenes = NULL,
  center = TRUE,
  cells = NULL,
  fastpath = TRUE,
  maxit = 100,
  verbose = TRUE,
  var.scale = (type == "counts"),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nPcs</code></dt><dd><p>numeric Number of principal components (PCs) (default=20)</p>
</dd>
<dt><code>type</code></dt><dd><p>string Dataset view to reduce (counts by default, but can specify a name of an existing reduction) (default='counts')</p>
</dd>
<dt><code>name</code></dt><dd><p>string Name for the PCA reduction to be created (default='PCA')</p>
</dd>
<dt><code>use.odgenes</code></dt><dd><p>boolean Whether pre-calculated set of overdispersed genes should be used (default=TRUE)</p>
</dd>
<dt><code>n.odgenes</code></dt><dd><p>integer Number of overdispersed genes to retrieve (default=NULL). If NULL, will return all.</p>
</dd>
<dt><code>odgenes</code></dt><dd><p>Explicitly specify a set of overdispersed genes to use for the reduction (default=NULL)</p>
</dd>
<dt><code>center</code></dt><dd><p>boolean Whether data should be centered prior to PCA (default=TRUE)</p>
</dd>
<dt><code>cells</code></dt><dd><p>optional subset of cells on which PCA should be run (default=NULL)</p>
</dd>
<dt><code>fastpath</code></dt><dd><p>boolean Use C implementation for speedup (default=TRUE)</p>
</dd>
<dt><code>maxit</code></dt><dd><p>numeric Maximum number of iterations (default=100). For more information, see 'maxit' parameter in irlba::irlba().</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>var.scale</code></dt><dd><p>boolean Apply scaling if using raw counts (default=TRUE). If type=&quot;counts&quot;, var.scale is TRUE by default.</p>
</dd>
<dt><code>...</code></dt><dd><p>additional arguments forwarded to irlba::irlba</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Invisible PCA result (the reduction itself is saved in self$reductions[[name]])&quot;
</p>


<hr>
<a id="method-expandOdGenes"></a>



<h4>Method <code>expandOdGenes()</code></h4>

<p>Reset overdispersed genes 'odgenes' to be a superset of the standard odgene selection (guided by n.odgenes or alpha), 
and a set of recursively determined odgenes based on a given group (or a cluster info)
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$expandOdGenes(
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  min.group.size = 30,
  od.alpha = 0.1,
  use.odgenes = FALSE,
  n.odgenes = NULL,
  odgenes = NULL,
  n.odgene.multiplier = 1,
  gam.k = 10,
  verbose = FALSE,
  n.cores = self$n.cores,
  min.odgenes = 10,
  max.odgenes = Inf,
  recursive = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>clusterType</code></dt><dd><p>Optional cluster type to use as a group-defining factor (default=NULL)</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.</p>
</dd>
<dt><code>min.group.size</code></dt><dd><p>integer Number of minimum cells for filtering out group size (default=30)</p>
</dd>
<dt><code>od.alpha</code></dt><dd><p>numeric The Type I error probability or the significance level for calculating overdispersed genes (default=1e-1). This is the criterion used to measure statistical significance, i.e. if the p-value &lt; alpha, then it is statistically significant.</p>
</dd>
<dt><code>use.odgenes</code></dt><dd><p>boolean Whether pre-calculated set of overdispersed genes should be used (default=FALSE)</p>
</dd>
<dt><code>n.odgenes</code></dt><dd><p>integer Number of overdispersed genes to retrieve (default=NULL). If NULL, will return all.</p>
</dd>
<dt><code>odgenes</code></dt><dd><p>Explicitly specify a set of overdispersed genes to use for the reduction (default=NULL) #' @param odgenes (default=NULL)</p>
</dd>
<dt><code>n.odgene.multiplier</code></dt><dd><p>numeric (default=1)</p>
</dd>
<dt><code>gam.k</code></dt><dd><p>integer The k used for the generalized additive model 'v ~ s(m, k =gam.k)' (default=10). If gam.k&lt;2, linear regression is used 'lm(v ~ m)'.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>min.odgenes</code></dt><dd><p>integer Minimum number of overdispersed genes to use (default=10)</p>
</dd>
<dt><code>max.odgenes</code></dt><dd><p>integer Maximum number of overdispersed genes to use (default=Inf)</p>
</dd>
<dt><code>recursive</code></dt><dd><p>boolean Whether to determine groups for which variance normalization will be rerun (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of overdispersed genes
</p>


<hr>
<a id="method-localPcaKnn"></a>



<h4>Method <code>localPcaKnn()</code></h4>

<p>local PCA implementation
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$localPcaKnn(
  nPcs = 5,
  type = "counts",
  clusterType = NULL,
  groups = NULL,
  k = 30,
  b = 1,
  a = 1,
  min.group.size = 30,
  name = "localPCA",
  od.alpha = 0.1,
  n.odgenes = NULL,
  gam.k = 10,
  verbose = FALSE,
  n.cores = self$n.cores,
  min.odgenes = 5,
  take.top.odgenes = FALSE,
  recursive = TRUE,
  euclidean = FALSE,
  perplexity = k,
  return.pca = FALSE,
  skip.pca = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nPcs</code></dt><dd><p>integer Number of principal components (default=5)</p>
</dd>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>clusterType</code></dt><dd><p>Optional cluster type to use as a group-defining factor (default=NULL)</p>
</dd>
<dt><code>groups</code></dt><dd><p>factor named with cell names specifying the clusters of cells to be compared (one against all) (default=NULL). To compare two cell clusters against each other, simply pass a factor containing only two levels.</p>
</dd>
<dt><code>k</code></dt><dd><p>integer Number of components for kNN graph (default=30)</p>
</dd>
<dt><code>b</code></dt><dd><p>numeric Constant within exp(-b*(ncid/cldsd)^2), used for calculating cell relevance per cluster (default=1)</p>
</dd>
<dt><code>a</code></dt><dd><p>numeric Constant within &quot;(1-exp(-a*(dsq)/(p$pcs$trsd^2)))*(pk /outerproduct pk)&quot; (default=1)</p>
</dd>
<dt><code>min.group.size</code></dt><dd><p>integer Number of minimum cells for filtering out group size (default=30)</p>
</dd>
<dt><code>name</code></dt><dd><p>string Title (default='localPCA')</p>
</dd>
<dt><code>od.alpha</code></dt><dd><p>numeric Significance level for calculating overdispersed genes (default=1e-1). P-values will be filtered by &lt;log(od.alpha).</p>
</dd>
<dt><code>n.odgenes</code></dt><dd><p>integer Number of overdispersed genes to retrieve (default=NULL). If NULL, will return all.</p>
</dd>
<dt><code>gam.k</code></dt><dd><p>integer The k used for the generalized additive model 'v ~ s(m, k =gam.k)' (default=10). If gam.k&lt;2, linear regression is used 'lm(v ~ m)'.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>min.odgenes</code></dt><dd><p>integer Minimum number of overdispersed genes to use (default=5)</p>
</dd>
<dt><code>take.top.odgenes</code></dt><dd><p>boolean Take top overdispersed genes in decreasing order (default=FALSE)</p>
</dd>
<dt><code>recursive</code></dt><dd><p>boolean Whether to recursively determine groups for which variance normalization will be rerun (default=FALSE)</p>
</dd>
<dt><code>euclidean</code></dt><dd><p>boolean Whether to applied euclidean-based distance similarity during variance normalization (default=FALSE)</p>
</dd>
<dt><code>perplexity</code></dt><dd><p>integer Perplexity parameter within Rtsne::Rtsne() (default=k). Please see Rtsne for more details.</p>
</dd>
<dt><code>return.pca</code></dt><dd><p>boolean Whether to return the PCs (default=FALSE)</p>
</dd>
<dt><code>skip.pca</code></dt><dd><p>boolean If TRUE and return.pca=TRUE, will return a list of scale factors, cells, and overdispersed genes, i.e. list(sf=sf, cells=cells, odgenes=odgenes) (default=FALSE). Otherwise, ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>localPcaKnn return here
</p>


<hr>
<a id="method-testPathwayOverdispersion"></a>



<h4>Method <code>testPathwayOverdispersion()</code></h4>

<p>Test pathway overdispersion
Note: this is a compressed version of the PAGODA1 approach in SCDE &lt;https://hms-dbmi.github.io/scde/&gt;
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$testPathwayOverdispersion(
  setenv,
  type = "counts",
  max.pathway.size = 1000,
  min.pathway.size = 10,
  n.randomizations = 5,
  verbose = FALSE,
  n.cores = self$n.cores,
  score.alpha = 0.05,
  plot = FALSE,
  cells = NULL,
  adjusted.pvalues = TRUE,
  z.score = qnorm(0.05/2, lower.tail = FALSE),
  use.oe.scale = FALSE,
  return.table = FALSE,
  name = "pathwayPCA",
  correlation.distance.threshold = 0.2,
  loading.distance.threshold = 0.01,
  top.aspects = Inf,
  recalculate.pca = FALSE,
  save.pca = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>setenv</code></dt><dd><p>Specific environment for pathway analysis</p>
</dd>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>max.pathway.size</code></dt><dd><p>integer Maximum number of observed genes in a valid gene set (default=1e3)</p>
</dd>
<dt><code>min.pathway.size</code></dt><dd><p>integer Minimum number of observed genes that should be contained in a valid gene set (default=10)</p>
</dd>
<dt><code>n.randomizations</code></dt><dd><p>numeric Number of random gene sets (of the same size) to be evaluated in parallel with each gene set (default=5). (This can be kept at 5 or 10, but should be increased to 50-100 if the significance of pathway overdispersion will be determined relative to random gene set models.)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>score.alpha</code></dt><dd><p>numeric Significance level of the confidence interval for determining upper/lower bounds (default=0.05)</p>
</dd>
<dt><code>plot</code></dt><dd><p>boolean Whether to output the plot (default=FALSE)</p>
</dd>
<dt><code>cells</code></dt><dd><p>character vector Specific cells to investigate (default=NULL)</p>
</dd>
<dt><code>adjusted.pvalues</code></dt><dd><p>boolean Whether to use adjusted p-values (default=TRUE)</p>
</dd>
<dt><code>z.score</code></dt><dd><p>numeric Z-score to be used as a cutoff for statistically significant patterns (default=qnorm(0.05/2, lower.tail = FALSE))</p>
</dd>
<dt><code>use.oe.scale</code></dt><dd><p>boolean Whether the variance of the returned aspect patterns should be normalized using observed/expected value instead of the default chi-squared derived variance corresponding to overdispersion Z-score (default=FALSE)</p>
</dd>
<dt><code>return.table</code></dt><dd><p>boolean Whether to return a text table with results (default=FALSE)</p>
</dd>
<dt><code>name</code></dt><dd><p>string Title (default='pathwayPCA')</p>
</dd>
<dt><code>correlation.distance.threshold</code></dt><dd><p>numeric Similarity threshold for grouping interdependent aspects in pagoda.reduce.redundancy() (default=0.2)</p>
</dd>
<dt><code>loading.distance.threshold</code></dt><dd><p>numeric Similarity threshold for grouping interdependent aspects in pagoda.reduce.loading.redundancy() (default=0.2)</p>
</dd>
<dt><code>top.aspects</code></dt><dd><p>Restrict output to the top N aspects of heterogeneity (default=Inf)</p>
</dd>
<dt><code>recalculate.pca</code></dt><dd><p>boolean Whether to recalculate PCA (default=FALSE)</p>
</dd>
<dt><code>save.pca</code></dt><dd><p>boolean Whether to save the PCA results (default=TRUE). If TRUE, caches them in self$misc[['pwpca']].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>pathway output
</p>


<hr>
<a id="method-getEmbedding"></a>



<h4>Method <code>getEmbedding()</code></h4>

<p>Return embedding
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$getEmbedding(
  type = "counts",
  embeddingType = "largeVis",
  name = NULL,
  dims = 2,
  M = 1,
  gamma = 1/M,
  perplexity = 50,
  verbose = TRUE,
  sgd_batches = NULL,
  diffusion.steps = 0,
  diffusion.power = 0.5,
  distance = "pearson",
  n.cores = self$n.cores,
  n.sgd.cores = n.cores,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>string Data type (default='counts'). Currently only 'counts' supported.</p>
</dd>
<dt><code>embeddingType</code></dt><dd><p>string Type of embedding to construct (default='largeVis'). Possible values are: 'largeVis', 'tSNE', 'FR' (Fruchterman–Reingold), 'UMAP', 'UMAP_graph'</p>
</dd>
<dt><code>name</code></dt><dd><p>string Name of the embedding (default=NULL). If NULL, the name = embeddingType.</p>
</dd>
<dt><code>dims</code></dt><dd><p>integer Parameter 'dims' Matrix::sparseMatrix(); a non-negative, integer, dimensions vector of length 2 (default=2). See Matrix package documentation for more details.</p>
</dd>
<dt><code>M</code></dt><dd><p>numeric (largeVis) The number of negative edges to sample for each positive edge (default=5). Parameter only used if embeddingType is 'largeVis'.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>numeric (largeVis) The strength of the force pushing non-neighbor nodes apart (default=7). Parameter only used if embeddingType is 'largeVis'.</p>
</dd>
<dt><code>perplexity</code></dt><dd><p>numeric Parameter 'perplexity' within largeVis::buildWijMatrix() (default=50). Please see the largeVis documentation for more details.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to give verbose output (default=TRUE)</p>
</dd>
<dt><code>sgd_batches</code></dt><dd><p>numeric The number of edges to process during SGD (default=NULL). Passed to projectKNNs(). Defaults to a value set based on the size of the dataset. If the parameter given is
between <code>0</code> and <code>1</code>, the default value will be multiplied by the parameter.</p>
</dd>
<dt><code>diffusion.steps</code></dt><dd><p>integer Iteration steps to use. If 0, no steps are run. (default=0)</p>
</dd>
<dt><code>diffusion.power</code></dt><dd><p>numeric Factor to be used when calculating diffusion, (default=0.5)</p>
</dd>
<dt><code>distance</code></dt><dd><p>string 'pearson', 'spearman', 'euclidean', 'L2', 'JS' (default='pearson')</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=1)</p>
</dd>
<dt><code>n.sgd.cores</code></dt><dd><p>numeric Number of cores to use (default=n.cores)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to embedding functions, Rtsne::Rtsne() if 'L2', uwot::umap() if 'UMAP', embedKnnGraphUmap() if 'UMAP_graph'</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>embedding stored in self$embedding
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pagoda2$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Simon Steiger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Pagoda2$new`
## ------------------------------------------------

 
## Load pre-generated a dataset of 50 bone marrow cells as matrix
cm &lt;- readRDS(system.file("extdata", "sample_BM1_50.rds", package="pagoda2"))
## Perform QC, i.e. filter any cells that
counts &lt;- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) &lt;- make.unique(rownames(counts))
## Generate Pagoda2 object 
p2_object &lt;- Pagoda2$new(counts, log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 



## ------------------------------------------------
## Method `Pagoda2$adjustVariance`
## ------------------------------------------------


## Load pre-generated a dataset of 50 bone marrow cells as matrix
cm &lt;- readRDS(system.file("extdata", "sample_BM1_50.rds", package="pagoda2"))
## Perform QC, i.e. filter any cells that
counts &lt;- gene.vs.molecule.cell.filter(cm, min.cell.size=500)
rownames(counts) &lt;- make.unique(rownames(counts))
## Generate Pagoda2 object 
p2_object &lt;- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
## Normalize gene expression variance
p2_object$adjustVariance(plot=TRUE, gam.k=10)



## ------------------------------------------------
## Method `Pagoda2$makeKnnGraph`
## ------------------------------------------------


## Load pre-generated a dataset of 50 bone marrow cells as matrix
cm &lt;- readRDS(system.file("extdata", "sample_BM1_50.rds", package="pagoda2"))
## Perform QC, i.e. filter any cells that
counts &lt;- gene.vs.molecule.cell.filter(cm, min.cell.size=300)
rownames(counts) &lt;- make.unique(rownames(counts))
## Generate Pagoda2 object   
p2_object &lt;- Pagoda2$new(counts,log.scale=TRUE, min.cells.per.gene=10, n.cores=1) 
## Normalize gene expression variance
p2_object$adjustVariance(plot=TRUE, gam.k=10)
## Generate a kNN graph of cells that will allow us to identify clusters of cells
p2_object$makeKnnGraph(k=20, center=FALSE, distance='L2')


</code></pre>

<hr>
<h2 id='pagoda2WebApp_arrayToJSON'>pagoda2WebApp_arrayToJSON</h2><span id='topic+pagoda2WebApp_arrayToJSON'></span>

<h3>Description</h3>

<p>Serialise an R array to a JSON object
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_arrayToJSON_+3A_arr">arr</code></td>
<td>
<p>An array (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Serialised version of the array in JSON, which includes dimension information as separate fields
</p>

<hr>
<h2 id='pagoda2WebApp_availableAspectsJSON'>pagoda2WebApp_availableAspectsJSON</h2><span id='topic+pagoda2WebApp_availableAspectsJSON'></span>

<h3>Description</h3>

<p>Parse pathways from originalP2object$misc$pathwayOD$xv into JSON
</p>


<h3>Value</h3>

<p>JSON with parsed cell order from mainDendrogram$cellorder
</p>

<hr>
<h2 id='pagoda2WebApp_call'>pagoda2WebApp_call</h2><span id='topic+pagoda2WebApp_call'></span>

<h3>Description</h3>

<p>Handle httpd server calls
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_call_+3A_env">env</code></td>
<td>
<p>The environment argument is a true R environment object which the application is free to modify. Please see the Rook documentation for more details.</p>
</td></tr>
</table>

<hr>
<h2 id='pagoda2WebApp_cellmetadataJSON'>pagoda2WebApp_cellmetadataJSON</h2><span id='topic+pagoda2WebApp_cellmetadataJSON'></span>

<h3>Description</h3>

<p>Parse cellmetadata into JSON
</p>


<h3>Value</h3>

<p>JSON with parsed cellmetadata
</p>

<hr>
<h2 id='pagoda2WebApp_cellOrderJSON'>pagoda2WebApp_cellOrderJSON</h2><span id='topic+pagoda2WebApp_cellOrderJSON'></span>

<h3>Description</h3>

<p>Parse mainDendrogram$cellorder into JSON
</p>


<h3>Value</h3>

<p>JSON with parsed cell order from mainDendrogram$cellorder
</p>

<hr>
<h2 id='pagoda2WebApp_geneInformationJSON'>pagoda2WebApp_geneInformationJSON</h2><span id='topic+pagoda2WebApp_geneInformationJSON'></span>

<h3>Description</h3>

<p>Parse originalP2object$misc$varinfo[,c(&quot;m&quot;,&quot;qv&quot;)] into JSON
</p>


<h3>Value</h3>

<p>JSON with parsed information from genename, dispersion, mean gene expression
</p>

<hr>
<h2 id='pagoda2WebApp_generateDendrogramOfGroups'>Generate a dendrogram of groups</h2><span id='topic+pagoda2WebApp_generateDendrogramOfGroups'></span>

<h3>Description</h3>

<p>Generate a dendrogram of groups
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_generateDendrogramOfGroups_+3A_dendrogramcellgroups">dendrogramCellGroups</code></td>
<td>
<p>Cell groups to input into hclust()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of hcGroups, cellorder, and cluster.sizes
</p>

<hr>
<h2 id='pagoda2WebApp_generateEmbeddingStructure'>pagoda2WebApp_generateEmbeddingStructure</h2><span id='topic+pagoda2WebApp_generateEmbeddingStructure'></span>

<h3>Description</h3>

<p>Generate information about the embeddings we are exporting
</p>


<h3>Value</h3>

<p>List with embeddings
</p>

<hr>
<h2 id='pagoda2WebApp_generateGeneKnnJSON'>pagoda2WebApp_generateGeneKnnJSON</h2><span id='topic+pagoda2WebApp_generateGeneKnnJSON'></span>

<h3>Description</h3>

<p>Generate a JSON list representation of the gene kNN network
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_generateGeneKnnJSON_+3A_graph">graph</code></td>
<td>
<p>Input graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>JSON with gene kNN network
</p>

<hr>
<h2 id='pagoda2WebApp_getCompressedEmbedding'>pagoda2WebApp_getCompressedEmbedding</h2><span id='topic+pagoda2WebApp_getCompressedEmbedding'></span>

<h3>Description</h3>

<p>Compress the embedding
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_getCompressedEmbedding_+3A_reduc">reduc</code></td>
<td>
<p>reduction</p>
</td></tr>
<tr><td><code id="pagoda2WebApp_getCompressedEmbedding_+3A_embed">embed</code></td>
<td>
<p>embedding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>compressed embedding as JSON
</p>

<hr>
<h2 id='pagoda2WebApp_packCompressFloat64Array'>pagoda2WebApp_packCompressFloat64Array</h2><span id='topic+pagoda2WebApp_packCompressFloat64Array'></span>

<h3>Description</h3>

<p>Compress float64 array
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_packCompressFloat64Array_+3A_v">v</code></td>
<td>
<p>float64 array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>compressed array
</p>

<hr>
<h2 id='pagoda2WebApp_packCompressInt32Array'>pagoda2WebApp_packCompressInt32Array</h2><span id='topic+pagoda2WebApp_packCompressInt32Array'></span>

<h3>Description</h3>

<p>Compress int32 array
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_packCompressInt32Array_+3A_v">v</code></td>
<td>
<p>int32 array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>compressed array
</p>

<hr>
<h2 id='pagoda2WebApp_readStaticFile'>pagoda2WebApp_readStaticFile</h2><span id='topic+pagoda2WebApp_readStaticFile'></span>

<h3>Description</h3>

<p>Read a static file from the filesystem, and put in the response
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_readStaticFile_+3A_filename">filename</code></td>
<td>
<p>path to filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Content to display or error page
</p>

<hr>
<h2 id='pagoda2WebApp_reducedDendrogramJSON'>pagoda2WebApp_reducedDendrogramJSON</h2><span id='topic+pagoda2WebApp_reducedDendrogramJSON'></span>

<h3>Description</h3>

<p>Parse dendrogram into JSON
</p>


<h3>Value</h3>

<p>JSON with parsed dendrogram
</p>

<hr>
<h2 id='pagoda2WebApp_serializeToStaticFast'>pagoda2WebApp_serializeToStaticFast</h2><span id='topic+pagoda2WebApp_serializeToStaticFast'></span>

<h3>Description</h3>

<p>Convert serialized file to static file
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_serializeToStaticFast_+3A_binary.filename">binary.filename</code></td>
<td>
<p>path to binary file (default=NULL)</p>
</td></tr>
<tr><td><code id="pagoda2WebApp_serializeToStaticFast_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to give verbose output (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>static file written by WriteListToBinary(expL=exportList, outfile=binary.filename, verbose=verbose)
</p>

<hr>
<h2 id='pagoda2WebApp_serverLog'>pagoda2WebApp_serverLog</h2><span id='topic+pagoda2WebApp_serverLog'></span>

<h3>Description</h3>

<p>Logging function for console
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_serverLog_+3A_message">message</code></td>
<td>
<p>Message to output for the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>printed message
</p>

<hr>
<h2 id='pagoda2WebApp_sparseMatList'>pagoda2WebApp_sparseMatList</h2><span id='topic+pagoda2WebApp_sparseMatList'></span>

<h3>Description</h3>

<p>Create simple List from sparse Matrix with Dimnames as JSON
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagoda2WebApp_sparseMatList_+3A_matsparse">matsparse</code></td>
<td>
<p>Sparse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with slots i, p, x
</p>

<hr>
<h2 id='pagoda2WebApp-class'>pagoda2WebApp class to create 'pagoda2' web applications via a Rook server</h2><span id='topic+pagoda2WebApp-class'></span><span id='topic+pagoda2WebApp'></span>

<h3>Description</h3>

<p>pagoda2WebApp class to create 'pagoda2' web applications via a Rook server
</p>


<h3>Fields</h3>


<dl>
<dt><code>originalP2object</code></dt><dd><p>Input 'Pagoda2' object</p>
</dd>
<dt><code>name</code></dt><dd><p>string Display name for the application</p>
</dd>
<dt><code>mat</code></dt><dd><p>Embedding</p>
</dd>
<dt><code>cellmetadata</code></dt><dd><p>Metadata associated with 'Pagoda2' object</p>
</dd>
<dt><code>mainDendrogram</code></dt><dd><p>Dendrogram from hclust() of all cells in the 'Pagoda2' object</p>
</dd>
<dt><code>geneSets</code></dt><dd><p>Gene sets in the 'Pagoda2' object</p>
</dd>
<dt><code>rookRoot</code></dt><dd><p>Rook server root directory</p>
</dd>
<dt><code>appmetadata</code></dt><dd><p>pagoda2 web application metadata</p>
</dd>
</dl>

<hr>
<h2 id='papply'>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.</h2><span id='topic+papply'></span>

<h3>Description</h3>

<p>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>papply(..., n.cores = parallel::detectCores(), mc.preschedule = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="papply_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to mclapply(), lapply(), or BiocParallel::bplapply()</p>
</td></tr>
<tr><td><code id="papply_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to use (default=parallel::detectCores())</p>
</td></tr>
<tr><td><code id="papply_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>See ?parallel::mclapply (default=FALSE). If TRUE then the computation is first divided to (at most) as many jobs are there are cores and then the jobs are started, each job possibly covering more than one value. If FALSE, then one job is forked for each value of X. The former is better for short computations or large number of values in X, the latter is better for jobs that have high variance of completion time and not too many values of X compared to mc.cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, as returned by lapply
</p>

<hr>
<h2 id='pathway.pc.correlation.distance'>Calculate correlation distance between PC magnitudes given a number of target dimensions</h2><span id='topic+pathway.pc.correlation.distance'></span>

<h3>Description</h3>

<p>Calculate correlation distance between PC magnitudes given a number of target dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathway.pc.correlation.distance(pcc, xv, n.cores = 1, target.ndf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathway.pc.correlation.distance_+3A_pcc">pcc</code></td>
<td>
<p>weighted PC magnitudes e.g. scde::pagoda.pathway.wPCA() gives the weighted PC magnitudes for each gene provided; 
e.g. scde::pagoda.gene.clusters() gives the weighted PC magnitudes for de novo gene sets identified by clustering on expression</p>
</td></tr>
<tr><td><code id="pathway.pc.correlation.distance_+3A_xv">xv</code></td>
<td>
<p>a matrix of normalized aspect patterns (rows: significant aspects, columns: cells)</p>
</td></tr>
<tr><td><code id="pathway.pc.correlation.distance_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
<tr><td><code id="pathway.pc.correlation.distance_+3A_target.ndf">target.ndf</code></td>
<td>
<p>numeric Target dimensions (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation distance matrix, akin to stats dist
</p>

<hr>
<h2 id='plotMulticlassified'>Plot multiclassified cells per selection as a percent barplot</h2><span id='topic+plotMulticlassified'></span>

<h3>Description</h3>

<p>Plot multiclassified cells per selection as a percent barplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMulticlassified(sel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMulticlassified_+3A_sel">sel</code></td>
<td>
<p>pagoda2 selection object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>

<hr>
<h2 id='plotOneWithValues'>Plot the embedding of a 'Pagoda2' object with the given values</h2><span id='topic+plotOneWithValues'></span>

<h3>Description</h3>

<p>Plot the embedding of a 'Pagoda2' object with the given values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOneWithValues(
  p2obj,
  values,
  title = "",
  type = "PCA",
  embeddingType = "tSNE"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOneWithValues_+3A_p2obj">p2obj</code></td>
<td>
<p>the 'Pagoda2' object</p>
</td></tr>
<tr><td><code id="plotOneWithValues_+3A_values">values</code></td>
<td>
<p>the values to plot, fed into p2obj$plotEmbedding(colors=values)</p>
</td></tr>
<tr><td><code id="plotOneWithValues_+3A_title">title</code></td>
<td>
<p>character Title for the plot (default=&quot;&quot;)</p>
</td></tr>
<tr><td><code id="plotOneWithValues_+3A_type">type</code></td>
<td>
<p>character Type reduction on which the embedding is based on (default=&quot;PCA&quot;)</p>
</td></tr>
<tr><td><code id="plotOneWithValues_+3A_embeddingtype">embeddingType</code></td>
<td>
<p>character Type of embedding to plot (default=&quot;tSNE&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, simply updates p2obj$plotEmbedding()
</p>

<hr>
<h2 id='plotSelectionOverlaps'>Get a dataframe and plot summarising overlaps between selection of a pagoda2 selection object
ignore self overlaps</h2><span id='topic+plotSelectionOverlaps'></span>

<h3>Description</h3>

<p>Get a dataframe and plot summarising overlaps between selection of a pagoda2 selection object
ignore self overlaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSelectionOverlaps(sel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSelectionOverlaps_+3A_sel">sel</code></td>
<td>
<p>a pagoda2 selection object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list that contains a ggplot2 object and a datatable with the overlaps data
</p>

<hr>
<h2 id='projectKNNs'>Project a distance matrix into a lower-dimensional space. (from elbamos/largeVis)</h2><span id='topic+projectKNNs'></span>

<h3>Description</h3>

<p>Takes as input a sparse matrix of the edge weights connecting each node to its nearest neighbors, and outputs
a matrix of coordinates embedding the inputs in a lower-dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectKNNs(
  wij,
  dim = 2,
  sgd_batches = NULL,
  M = 5,
  gamma = 7,
  alpha = 1,
  rho = 1,
  coords = NULL,
  useDegree = FALSE,
  momentum = NULL,
  seed = NULL,
  threads = NULL,
  verbose = getOption("verbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectKNNs_+3A_wij">wij</code></td>
<td>
<p>A symmetric sparse matrix of edge weights, in C-compressed format, as created with the <code>Matrix</code> package.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_dim">dim</code></td>
<td>
<p>numeric The number of dimensions for the projection space (default=2)</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_sgd_batches">sgd_batches</code></td>
<td>
<p>numeric The number of edges to process during SGD (default=NULL). Defaults to a value set based on the size of the dataset. If the parameter given is
between <code>0</code> and <code>1</code>, the default value will be multiplied by the parameter.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_m">M</code></td>
<td>
<p>numeric (largeVis) The number of negative edges to sample for each positive edge (default=5).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_gamma">gamma</code></td>
<td>
<p>numeric (largeVis) The strength of the force pushing non-neighbor nodes apart (default=7).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_alpha">alpha</code></td>
<td>
<p>numeric (largeVis) The hyperparameter in the distance function (default=1). The default distance function, <code class="reqn">1 / (1 + \alpha \dot ||y_i - y_j||^2)</code>.
The function relates the distance between points in the low-dimensional projection to the likelihood that the two points are nearest neighbors. Increasing <code class="reqn">\alpha</code> tends
to push nodes and their neighbors closer together; decreasing <code class="reqn">\alpha</code> produces a broader distribution. Setting <code class="reqn">\alpha</code> to zero
enables the alternative distance function. <code class="reqn">\alpha</code> below zero is meaningless.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_rho">rho</code></td>
<td>
<p>(largeVis) numeric Initial learning rate (default=1)</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_coords">coords</code></td>
<td>
<p>An initialized coordinate matrix (default=NULL)</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_usedegree">useDegree</code></td>
<td>
<p>boolean Whether to use vertex degree to determine weights in negative sampling (if TRUE) or the sum of the vertex's edges (if FALSE) (default=FALSE)</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_momentum">momentum</code></td>
<td>
<p>If not NULL, SGD with momentum is used, with this multiplier, which must be between 0 and 1 (default=NULL). Note that
momentum can drastically speed-up training time, at the cost of additional memory consumed.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_seed">seed</code></td>
<td>
<p>numeric Random seed to be passed to the C++ functions (default=NULL). Sampled from hardware entropy pool if <code>NULL</code> (the default).
Note that if the seed is not <code>NULL</code> (the default), the maximum number of threads will be set to 1 in phases of the algorithm
that would otherwise be non-deterministic.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_threads">threads</code></td>
<td>
<p>numeric The maximum number of threads to spawn (default=NULL). Determined automatically if <code>NULL</code> (the default).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbosity (default=getOption(&quot;verbose&quot;, TRUE))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm attempts to estimate a <code>dim</code>-dimensional embedding using stochastic gradient descent and
negative sampling.
</p>
<p>The objective function is: </p>
<p style="text-align: center;"><code class="reqn"> O = \sum_{(i,j)\in E} w_{ij} (\log f(||p(e_{ij} = 1||) + \sum_{k=1}^{M} E_{jk~P_{n}(j)} \gamma \log(1 - f(||p(e_{ij_k} - 1||)))</code>
</p>

<p>where <code class="reqn">f()</code> is a probabilistic function relating the distance between two points in the low-dimensional projection space,
and the probability that they are nearest neighbors.
</p>
<p>The default probabilistic function is <code class="reqn">1 / (1 + \alpha \dot ||x||^2)</code>. If <code class="reqn">\alpha</code> is set to zero,
an alternative probabilistic function, <code class="reqn">1 / (1 + \exp(x^2))</code> will be used instead.
</p>
<p>Note that the input matrix should be symmetric.  If any columns in the matrix are empty, the function will fail.
</p>


<h3>Value</h3>

<p>A dense [N,D] matrix of the coordinates projecting the w_ij matrix into the lower-dimensional space.
</p>


<h3>Note</h3>

<p>If specified, <code>seed</code> is passed to the C++ and used to initialize the random number generator. This will not, however, be
sufficient to ensure reproducible results, because the initial coordinate matrix is generated using the <code>R</code> random number generator.
To ensure reproducibility, call <code><a href="base.html#topic+set.seed">set.seed</a></code> before calling this function, or pass it a pre-allocated coordinate matrix.
</p>
<p>The original paper called for weights in negative sampling to be calculated according to the degree of each vertex, the number of edges
connecting to the vertex. The reference implementation, however, uses the sum of the weights of the edges to each vertex. In experiments, the
difference was imperceptible with small (MNIST-size) datasets, but the results seems aesthetically preferrable using degree. The default
is to use the edge weights, consistent with the reference implementation.
</p>

<hr>
<h2 id='read.10x.matrices'>Quick loading of 10X CellRanger count matrices</h2><span id='topic+read.10x.matrices'></span>

<h3>Description</h3>

<p>Quick loading of 10X CellRanger count matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.10x.matrices(matrixPaths, version = "V3", n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.10x.matrices_+3A_matrixpaths">matrixPaths</code></td>
<td>
<p>a single path to the folder containing matrix.mtx, genes.tsv and barcodes.tsv files, OR a named list of such paths</p>
</td></tr>
<tr><td><code id="read.10x.matrices_+3A_version">version</code></td>
<td>
<p>string Version of 10x output to read (default='V3'). Must be one of 'V2' or 'V3'.</p>
</td></tr>
<tr><td><code id="read.10x.matrices_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Cores to utilize in parallel (default=1)</p>
</td></tr>
<tr><td><code id="read.10x.matrices_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to output verbose output (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sparse matrix representation of the data (or a list of sparse matrices if a list of paths was passed)
</p>

<hr>
<h2 id='read10xMatrix'>This function reads a matrix generated by the 10x processing pipeline
from the specified directory and returns it. It aborts if one of the required
files in the specified directory do not exist.</h2><span id='topic+read10xMatrix'></span>

<h3>Description</h3>

<p>This function reads a matrix generated by the 10x processing pipeline
from the specified directory and returns it. It aborts if one of the required
files in the specified directory do not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read10xMatrix(path, version = "V3", transcript.id = "SYMBOL", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read10xMatrix_+3A_path">path</code></td>
<td>
<p>string Location of 10x output</p>
</td></tr>
<tr><td><code id="read10xMatrix_+3A_version">version</code></td>
<td>
<p>string Version of 10x output to read (default='V3'). Must be one of 'V2' or 'V3'.</p>
</td></tr>
<tr><td><code id="read10xMatrix_+3A_transcript.id">transcript.id</code></td>
<td>
<p>string Transcript identifier to use (default='SYMBOL'). Must be either 'SYMBOL' (e.g. &quot;Sox17&quot;) or 'ENSEMBL' (e.g. &quot;ENSMUSG00000025902&quot;). This value is case-sensitive.</p>
</td></tr>
<tr><td><code id="read10xMatrix_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to return verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parsed 10x outputs into a matrix
</p>

<hr>
<h2 id='readPagoda2SelectionAsFactor'>Read a pagoda2 cell selection file and return it as a factor
while removing any mutliclassified cells</h2><span id='topic+readPagoda2SelectionAsFactor'></span>

<h3>Description</h3>

<p>Read a pagoda2 cell selection file and return it as a factor
while removing any mutliclassified cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPagoda2SelectionAsFactor(filepath, use.internal.name = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readPagoda2SelectionAsFactor_+3A_filepath">filepath</code></td>
<td>
<p>name of the selection file</p>
</td></tr>
<tr><td><code id="readPagoda2SelectionAsFactor_+3A_use.internal.name">use.internal.name</code></td>
<td>
<p>boolean Use field 'internal.name' as factor names (default=FALSE). Passed to factorFromP2Selection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a name factor with the membership of all the cells that are not multiclassified
</p>

<hr>
<h2 id='readPagoda2SelectionFile'>Reads a 'pagoda2' web app exported cell selection file exported as a list
of list objects that contain the name of the selection, 
the color (as a hex string) and the identifiers of the individual cells</h2><span id='topic+readPagoda2SelectionFile'></span>

<h3>Description</h3>

<p>Reads a 'pagoda2' web app exported cell selection file exported as a list
of list objects that contain the name of the selection, 
the color (as a hex string) and the identifiers of the individual cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPagoda2SelectionFile(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readPagoda2SelectionFile_+3A_filepath">filepath</code></td>
<td>
<p>the path of the file load</p>
</td></tr>
</table>

<hr>
<h2 id='removeSelectionOverlaps'>Remove cells that are present in more than one selection from all the
selections they are in</h2><span id='topic+removeSelectionOverlaps'></span>

<h3>Description</h3>

<p>Remove cells that are present in more than one selection from all the
selections they are in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeSelectionOverlaps(selections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeSelectionOverlaps_+3A_selections">selections</code></td>
<td>
<p>a pagoda2 selections list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new list with the duplicated cells removed
</p>

<hr>
<h2 id='score.cells.nb0'>Score cells by getting mean expression of genes in signatures</h2><span id='topic+score.cells.nb0'></span>

<h3>Description</h3>

<p>Score cells by getting mean expression of genes in signatures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.cells.nb0(data, signature)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.cells.nb0_+3A_data">data</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="score.cells.nb0_+3A_signature">signature</code></td>
<td>
<p>the genes in the signature</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cell scores
</p>

<hr>
<h2 id='score.cells.nb1'>Score cells after standardising the expression of each gene removing outliers</h2><span id='topic+score.cells.nb1'></span>

<h3>Description</h3>

<p>Score cells after standardising the expression of each gene removing outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.cells.nb1(data, signature, quantile.cutoff = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.cells.nb1_+3A_data">data</code></td>
<td>
<p>matrix of expression, rows are cell, columns are genes</p>
</td></tr>
<tr><td><code id="score.cells.nb1_+3A_signature">signature</code></td>
<td>
<p>a character vector of genes to use in the signature</p>
</td></tr>
<tr><td><code id="score.cells.nb1_+3A_quantile.cutoff">quantile.cutoff</code></td>
<td>
<p>numeric The quantile extremes to trim before plotting (default=0.0.1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered subset of gene signatures
</p>

<hr>
<h2 id='score.cells.puram'>Puram, Bernstein (Cell, 2018)
Score cells as described in Puram, Bernstein (Cell, 2018)</h2><span id='topic+score.cells.puram'></span>

<h3>Description</h3>

<p>Puram, Bernstein (Cell, 2018)
Score cells as described in Puram, Bernstein (Cell, 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.cells.puram(data, signature, correct = TRUE, show.plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.cells.puram_+3A_data">data</code></td>
<td>
<p>matrix of expression, rows are cell, columns are genes</p>
</td></tr>
<tr><td><code id="score.cells.puram_+3A_signature">signature</code></td>
<td>
<p>character vector The signature to evaluate, a character vector of genes</p>
</td></tr>
<tr><td><code id="score.cells.puram_+3A_correct">correct</code></td>
<td>
<p>boolean Perform background correction by getting a semi-random geneset (default=TRUE)</p>
</td></tr>
<tr><td><code id="score.cells.puram_+3A_show.plot">show.plot</code></td>
<td>
<p>boolean If corrected values are calculated show plot of corrected vs original scores (default=FALSE)</p>
</td></tr>
<tr><td><code id="score.cells.puram_+3A_...">...</code></td>
<td>
<p>options for get.control.geneset()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a score for each cell
</p>

<hr>
<h2 id='sgdBatches'>Calculate the default number of batches for a given number of vertices and edges.
The formula used is the one used by the 'largeVis' reference implementation.  This is substantially less than the recommendation <code class="reqn">E * 10000</code> in the original paper.</h2><span id='topic+sgdBatches'></span>

<h3>Description</h3>

<p>Calculate the default number of batches for a given number of vertices and edges.
The formula used is the one used by the 'largeVis' reference implementation.  This is substantially less than the recommendation <code class="reqn">E * 10000</code> in the original paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdBatches(N, E = 150 * N/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgdBatches_+3A_n">N</code></td>
<td>
<p>Number of vertices</p>
</td></tr>
<tr><td><code id="sgdBatches_+3A_e">E</code></td>
<td>
<p>Number of edges (default = 150*N/2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recommended number of sgd batches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Observe that increasing K has no effect on processing time

N &lt;- 70000 # MNIST
K &lt;- 10:250
plot(K, sgdBatches(rep(N, length(K)), N * K / 2))

# Observe that processing time scales linarly with N
N &lt;- c(seq(from = 1, to = 10000, by = 100), seq(from = 10000, to = 10000000, by = 1000))
plot(N, sgdBatches(N))

</code></pre>

<hr>
<h2 id='show.app'>Directly open the 'pagoda2' web application and view the 'p2web' application object from our R session</h2><span id='topic+show.app'></span>

<h3>Description</h3>

<p>Directly open the 'pagoda2' web application and view the 'p2web' application object from our R session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.app(app, name, port, ip, browse = TRUE, server = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.app_+3A_app">app</code></td>
<td>
<p>'pagoda2' application object</p>
</td></tr>
<tr><td><code id="show.app_+3A_name">name</code></td>
<td>
<p>character Name of the application to view</p>
</td></tr>
<tr><td><code id="show.app_+3A_port">port</code></td>
<td>
<p>numeric Port number</p>
</td></tr>
<tr><td><code id="show.app_+3A_ip">ip</code></td>
<td>
<p>numeric IP address</p>
</td></tr>
<tr><td><code id="show.app_+3A_browse">browse</code></td>
<td>
<p>boolean Whether to load the app into an HTML browser (default=TRUE)</p>
</td></tr>
<tr><td><code id="show.app_+3A_server">server</code></td>
<td>
<p>server If NULL, will grab server with get.scde.server(port=port, ip=ip) (derfault=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>application within browser
</p>

<hr>
<h2 id='sn'>Set names equal to values, a stats::setNames wrapper function</h2><span id='topic+sn'></span>

<h3>Description</h3>

<p>Set names equal to values, a stats::setNames wrapper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sn_+3A_x">x</code></td>
<td>
<p>an object for which names attribute will be meaningful</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with names assigned equal to values
</p>

<hr>
<h2 id='subsetSignatureToData'>Subset a gene signature to the genes in the given matrix
with optional warning if genes are missing</h2><span id='topic+subsetSignatureToData'></span>

<h3>Description</h3>

<p>Subset a gene signature to the genes in the given matrix
with optional warning if genes are missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetSignatureToData(data, signature, raise.warning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetSignatureToData_+3A_data">data</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="subsetSignatureToData_+3A_signature">signature</code></td>
<td>
<p>character vector The gene signature from which to subset a character vector of genes</p>
</td></tr>
<tr><td><code id="subsetSignatureToData_+3A_raise.warning">raise.warning</code></td>
<td>
<p>boolean Warn if genes are missing (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered subset of gene signatures
</p>

<hr>
<h2 id='tp2c.view.pathways'>View pathway or gene-weighted PCA
'Pagoda2' version of the function pagoda.show.pathways()
Takes in a list of pathways (or a list of genes), runs weighted PCA, optionally showing the result.</h2><span id='topic+tp2c.view.pathways'></span>

<h3>Description</h3>

<p>View pathway or gene-weighted PCA
'Pagoda2' version of the function pagoda.show.pathways()
Takes in a list of pathways (or a list of genes), runs weighted PCA, optionally showing the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp2c.view.pathways(
  pathways,
  p2,
  goenv = NULL,
  batch = NULL,
  n.genes = 20,
  two.sided = TRUE,
  n.pc = rep(1, length(pathways)),
  colcols = NULL,
  zlim = NULL,
  labRow = NA,
  vhc = NULL,
  cexCol = 1,
  cexRow = 1,
  nstarts = 50,
  row.order = NULL,
  show.Colv = TRUE,
  plot = TRUE,
  trim = 1.1/nrow(p2$counts),
  showPC = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tp2c.view.pathways_+3A_pathways">pathways</code></td>
<td>
<p>character vector of pathway or gene names</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_p2">p2</code></td>
<td>
<p>'Pagoda2' object</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_goenv">goenv</code></td>
<td>
<p>environment mapping pathways to genes (default=NULL)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_batch">batch</code></td>
<td>
<p>factor (corresponding to rows of the model matrix) specifying batch assignment of each cell, to perform batch correction (default=NULL).</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_n.genes">n.genes</code></td>
<td>
<p>integer Number of genes to show (default=20)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_two.sided">two.sided</code></td>
<td>
<p>boolean If TRUE, the set of shown genes should be split among highest and lowest loading (default=TRUE). If FALSE, genes with highest absolute loading should be shown.</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_n.pc">n.pc</code></td>
<td>
<p>integer vector Number of principal component to show for each listed pathway(default=rep(1, length(pathways)))</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_colcols">colcols</code></td>
<td>
<p>column color matrix (default=NULL)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_zlim">zlim</code></td>
<td>
<p>numeric z color limit (default=NULL)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_labrow">labRow</code></td>
<td>
<p>row labels (default=NA)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_vhc">vhc</code></td>
<td>
<p>cell clustering (default=NULL)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_cexcol">cexCol</code></td>
<td>
<p>positive numbers, used as cex.axis in for the row or column axis labeling(default=1)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_cexrow">cexRow</code></td>
<td>
<p>positive numbers, used as cex.axis in for the row or column axis labeling(default=1)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_nstarts">nstarts</code></td>
<td>
<p>integer Number of random starts to use (default=50)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_row.order">row.order</code></td>
<td>
<p>row order (default=NULL). If NULL, uses order from hclust.</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_show.colv">show.Colv</code></td>
<td>
<p>boolean Whether to show cell dendrogram (default=TRUE)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_plot">plot</code></td>
<td>
<p>boolean Whether to plot (default=TRUE)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_trim">trim</code></td>
<td>
<p>numeric Winsorization trim that should be applied (default=1.1/nrow(p2$counts)). Note that p2 is a 'Pagoda2' object.</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_showpc">showPC</code></td>
<td>
<p>boolean (default=TRUE)</p>
</td></tr>
<tr><td><code id="tp2c.view.pathways_+3A_...">...</code></td>
<td>
<p>parameters to pass to my.heatmap2. Only if plot is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cell scores along the first principal component of shown genes (returned as invisible)
</p>

<hr>
<h2 id='validateSelectionsObject'>Validates a pagoda2 selection object</h2><span id='topic+validateSelectionsObject'></span>

<h3>Description</h3>

<p>Validates a pagoda2 selection object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateSelectionsObject(selections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateSelectionsObject_+3A_selections">selections</code></td>
<td>
<p>the pagoda2 selection object to be validated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating if the object is valid
</p>

<hr>
<h2 id='view.aspects'>Internal function to visualize aspects of transcriptional heterogeneity as a heatmap.</h2><span id='topic+view.aspects'></span>

<h3>Description</h3>

<p>Internal function to visualize aspects of transcriptional heterogeneity as a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view.aspects(
  mat,
  row.clustering = NA,
  cell.clustering = NA,
  zlim = c(-1, 1) * quantile(mat, p = 0.95),
  row.cols = NULL,
  col.cols = NULL,
  cols = colorRampPalette(c("darkgreen", "white", "darkorange"), space = "Lab")(1024),
  show.row.var.colors = TRUE,
  top = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view.aspects_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_row.clustering">row.clustering</code></td>
<td>
<p>Row dendrogram (default=NA)</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_cell.clustering">cell.clustering</code></td>
<td>
<p>Column dendrogram (default=NA)</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_zlim">zlim</code></td>
<td>
<p>numeric Range of the normalized gene expression levels, inputted as a list: c(lower_bound, upper_bound) (default=c(-1, 1)*quantile(mat, p = 0.95)). Values outside this range will be Winsorized. Useful for increasing the contrast of the heatmap visualizations. Default, set to the 5th and 95th percentiles.</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_row.cols">row.cols</code></td>
<td>
<p>Matrix of row colors (default=NULL)</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_col.cols">col.cols</code></td>
<td>
<p>Matrix of column colors (default=NULL). Useful for visualizing cell annotations such as batch labels.</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_cols">cols</code></td>
<td>
<p>Heatmap colors (default=colorRampPalette(c(&quot;darkgreen&quot;, &quot;white&quot;, &quot;darkorange&quot;), space = &quot;Lab&quot;)(1024))</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_show.row.var.colors">show.row.var.colors</code></td>
<td>
<p>boolean Whether to show row variance as a color track (default=TRUE)</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_top">top</code></td>
<td>
<p>integer Restrict output to the top n aspects of heterogeneity (default=Inf)</p>
</td></tr>
<tr><td><code id="view.aspects_+3A_...">...</code></td>
<td>
<p>additional arguments for heatmap plotting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap
</p>

<hr>
<h2 id='webP2proc'>Generate a 'pagoda2' web object</h2><span id='topic+webP2proc'></span>

<h3>Description</h3>

<p>Generate a 'pagoda2' web object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>webP2proc(
  p2,
  additionalMetadata = NULL,
  title = "Pagoda2",
  make.go.sets = TRUE,
  make.de.sets = TRUE,
  go.env = NULL,
  make.gene.graph = TRUE,
  appmetadata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="webP2proc_+3A_p2">p2</code></td>
<td>
<p>a 'Pagoda2' object</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_additionalmetadata">additionalMetadata</code></td>
<td>
<p>'pagoda2' web metadata object (default=NULL)</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_title">title</code></td>
<td>
<p>character string Title for the web app (default='Pagoda2')</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_make.go.sets">make.go.sets</code></td>
<td>
<p>boolean Whether GO sets should be made (default=TRUE)</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_make.de.sets">make.de.sets</code></td>
<td>
<p>boolean Whether differential expression sets should be made (default=TRUE)</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_go.env">go.env</code></td>
<td>
<p>the GO environment used for the overdispersion analysis (default=NULL)</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_make.gene.graph">make.gene.graph</code></td>
<td>
<p>logical specifying if the gene graph should be make, if FALSE the find similar genes functionality will be disabled on the web app</p>
</td></tr>
<tr><td><code id="webP2proc_+3A_appmetadata">appmetadata</code></td>
<td>
<p>'pagoda2' web application metadata (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'pagoda2' web application
</p>

<hr>
<h2 id='winsorize.matrix'>Sets the ncol(mat)*trim top outliers in each row to the next lowest value same for the lowest outliers</h2><span id='topic+winsorize.matrix'></span>

<h3>Description</h3>

<p>Sets the ncol(mat)*trim top outliers in each row to the next lowest value same for the lowest outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsorize.matrix(mat, trim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsorize.matrix_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix</p>
</td></tr>
<tr><td><code id="winsorize.matrix_+3A_trim">trim</code></td>
<td>
<p>numeric Fraction of outliers (on each side) that should be Winsorized, or (if the value is  &gt;= 1) the number of outliers to be trimmed on each side</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Winsorized matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
mat &lt;- matrix( c(rnorm(5*10,mean=0,sd=1), rnorm(5*10,mean=5,sd=1)), 10, 10)  # random matrix
mat[1,1] &lt;- 1000  # make outlier
range(mat)  # look at range of values
win.mat &lt;- winsorize.matrix(mat, 0.1)
range(win.mat)  # note outliers removed

</code></pre>

<hr>
<h2 id='writeGenesAsPagoda2Selection'>Writes a list of genes as a gene selection that can be loaded in the web interface</h2><span id='topic+writeGenesAsPagoda2Selection'></span>

<h3>Description</h3>

<p>Writes a list of genes as a gene selection that can be loaded in the web interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeGenesAsPagoda2Selection(name, genes, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeGenesAsPagoda2Selection_+3A_name">name</code></td>
<td>
<p>the name of the selection</p>
</td></tr>
<tr><td><code id="writeGenesAsPagoda2Selection_+3A_genes">genes</code></td>
<td>
<p>a string vector of the gene names</p>
</td></tr>
<tr><td><code id="writeGenesAsPagoda2Selection_+3A_filename">filename</code></td>
<td>
<p>the filename to save to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, writes to filepath the list of genes as a gene selection that can be loaded in the web interface
</p>

<hr>
<h2 id='writePagoda2SelectionFile'>Writes a pagoda2 selection object as a p2 selection file that be be
loaded to the web interface</h2><span id='topic+writePagoda2SelectionFile'></span>

<h3>Description</h3>

<p>Writes a pagoda2 selection object as a p2 selection file that be be
loaded to the web interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writePagoda2SelectionFile(sel, filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writePagoda2SelectionFile_+3A_sel">sel</code></td>
<td>
<p>pagoda2 selection object</p>
</td></tr>
<tr><td><code id="writePagoda2SelectionFile_+3A_filepath">filepath</code></td>
<td>
<p>name of file to which to write</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, writes to filepath the pagoda2 selection object as a p2 selection file that be be loaded to the web interface
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
