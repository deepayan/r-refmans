<!DOCTYPE html><html><head><title>Help for package rrecsys</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rrecsys}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#_ds-class'>
<p>Dataset class.</p></a></li>
<li><a href='#algAverageClass'>
<p>Baseline algorithms exploiting global/item and user averages.</p></a></li>
<li><a href='#BPRclass'>
<p>Bayesian Personalized Ranking based model.</p></a></li>
<li><a href='#dataChart'>
<p>Visualization of data characteristics.</p></a></li>
<li><a href='#dataSet-class'>
<p>Dataset class.</p></a></li>
<li><a href='#defineData'>
<p>Define dataset.</p></a></li>
<li><a href='#eval_nDCG'>
<p>Normalized Discounted Cumulative Gain</p></a></li>
<li><a href='#evalChart'>
<p>Visualization of data characteristics.</p></a></li>
<li><a href='#evalModel'>
<p>Creating the evaluation model.</p></a></li>
<li><a href='#evalModel-class'>
<p>Evaluation model.</p></a></li>
<li><a href='#evalPred'>
<p>Evaluates the requested prediction algorithm.</p></a></li>
<li><a href='#evalRec'>
<p>Evaluates the requested recommendation algorithm.</p></a></li>
<li><a href='#evalRecResults'>
<p>Evaluation results.</p></a></li>
<li><a href='#getAUC'>
<p>Returns the Area under the ROC curve.</p></a></li>
<li><a href='#histogram'>
<p>Ratings histogram.</p></a></li>
<li><a href='#IBclass'>
<p>Item based model.</p></a></li>
<li><a href='#ml100k'>
<p>Movielens 100K Dataset</p></a></li>
<li><a href='#mlLatest100k'>
<p>Movielens Latest</p></a></li>
<li><a href='#PPLclass'>
<p>Popularity based model.</p></a></li>
<li><a href='#predict'>
<p>Generate predictions.</p></a></li>
<li><a href='#rankScore'>
<p>Rank Score</p></a></li>
<li><a href='#recommend'>
<p>Generate recommendation.</p></a></li>
<li><a href='#rrecsys'>
<p>Create a recommender system.</p></a></li>
<li><a href='#setStoppingCriteria'>
<p>Set stopping criteria.</p></a></li>
<li><a href='#slopeOneClass'>
<p>Slope One model.</p></a></li>
<li><a href='#sparseDataSet-class'>
<p>Dataset class for tuples (user, item, rating).</p></a></li>
<li><a href='#SVDclass'>
<p>SVD model.</p></a></li>
<li><a href='#UBclass'>
<p>Item based model.</p></a></li>
<li><a href='#wALSclass'>
<p>Weighted Alternating Least Squares based model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Environment for Evaluating Recommender Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.7.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-10</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rrecsys.inf.unibz.it/">https://rrecsys.inf.unibz.it/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ludovikcoba/rrecsys/issues">https://github.com/ludovikcoba/rrecsys/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Processes standard recommendation datasets (e.g., a user-item rating matrix) as input and generates rating predictions and lists of recommended items. Standard algorithm implementations which are included in this package are the following: Global/Item/User-Average baselines, Weighted Slope One, Item-Based KNN, User-Based KNN, FunkSVD, BPR and weighted ALS. They can be assessed according to the standard offline evaluation methodology (Shani, et al. (2011) &lt;<a href="https://doi.org/10.1007%2F978-0-387-85820-3_8">doi:10.1007/978-0-387-85820-3_8</a>&gt;) for recommender systems using measures such as MAE, RMSE, Precision, Recall, F1, AUC, NDCG, RankScore and coverage measures. The package (Coba, et al.(2017) &lt;<a href="https://doi.org/10.1007%2F978-3-319-60042-0_36">doi:10.1007/978-3-319-60042-0_36</a>&gt;) is intended for rapid prototyping of recommendation algorithms and education purposes. </td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2), registry, MASS, stats, knitr, ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-09 18:34:13 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Ludovik Çoba [aut, cre, cph],
  Markus Zanker [ctb],
  Panagiotis Symeonidis [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ludovik Çoba &lt;Ludovik.Coba@inf.unibz.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-09 18:45:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='_ds-class'>
Dataset class.
</h2><span id='topic+_ds-class'></span><span id='topic+_ds'></span><span id='topic+show+2C_ds-method'></span><span id='topic+summary+2C_ds-method'></span><span id='topic+rowAverages'></span><span id='topic+colAverages'></span><span id='topic+rowRatings'></span><span id='topic+colRatings'></span><span id='topic+numRatings'></span><span id='topic+sparsity'></span><span id='topic+sparsity+2C_ds-method'></span>

<h3>Description</h3>

<p>Defines a structure for a dataset that distinguishes between binary and non-binary feedback datasets. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>binary</code>:</dt><dd><p>class <code>"logical"</code>, determines if the item dataset contains binary (i.e. 1/0) or non-binary ratings.</p>
</dd>
<dt><code>minimum</code>:</dt><dd><p>class <code>"numeric"</code>, defines the minimal value present in the dataset.</p>
</dd>
<dt><code>maximum</code>:</dt><dd><p>class <code>"numeric"</code>, defines the maximal value present in the dataset.</p>
</dd>
<dt><code>intScale</code>:</dt><dd><p>object of class <code>"logical"</code>, if <b>TRUE</b> the range of ratings in the dataset contains as well half star values.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>signature(object = &quot;_ds&quot;)</p>
</dd>
<dt>sparsity</dt><dd><p>signature(object = &quot;_ds&quot;): returns the sparsity of the dataset.</p>
</dd>
<dt>summary</dt><dd><p>signature(object = &quot;_ds&quot;): summary of the characteristics of the dataset.</p>
</dd>
</dl>


<hr>
<h2 id='algAverageClass'>
Baseline algorithms exploiting global/item and user averages.
</h2><span id='topic+algAverageClass'></span><span id='topic+algAverageClass-class'></span><span id='topic+show+2CalgAverageClass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using any average(global, user or item) based model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>average</code>:</dt><dd><p>average calculated either globally, on user or item, class <code>"matrix"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;algAverageClass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='BPRclass'>
Bayesian Personalized Ranking based model.
</h2><span id='topic+BPRclass'></span><span id='topic+BPRclass-class'></span><span id='topic+show+2CBPRclass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using any Bayesian Personalized Ranking based model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>user(U) and items(V) factors, class <code>"list"</code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>the parameters(such as number of factors <code>k</code>, learning rate <code>lambda</code>, user regularization term <code>regU</code>, positive rated item regularization term <code>regI</code>, negative rated item regularization term <code>regJ</code> and the Boolean <code>updateJ</code> to decide whatever negative updates are required) used in the model, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;BPRclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='dataChart'>
Visualization of data characteristics.
</h2><span id='topic+dataChart'></span>

<h3>Description</h3>

<p>This method visualizes data characteristics on a two dimensional graph, where &quot;x&quot; axes shows either items ordered by descending popularity, or users based on the number of ratings they have submitted. Moreover the &quot;y&quot; axes shows the number of ratings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataChart(data, x = "items", y = "num_of_ratings")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataChart_+3A_data">data</code></td>
<td>
<p>the dataset, class <code>"_ds"</code>.</p>
</td></tr>
<tr><td><code id="dataChart_+3A_x">x</code></td>
<td>
<p>class <code>"character"</code>, is the variable that will be shown on the &quot;x&quot; axis. Possible values are: <code>"items"</code>, <code>"users"</code>.</p>
</td></tr>
<tr><td><code id="dataChart_+3A_y">y</code></td>
<td>
<p>class <code>"character"</code>, is the variable that will be shown on the &quot;y&quot; axis. Possible values are: <code>"num_of_ratings"</code>, <code>"%_of_ratings"</code>.</p>
</td></tr>


</table>


<h3>Value</h3>

<p>Plot results.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+_ds-class">_ds-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mlLatest100k)

a &lt;- defineData(mlLatest100k)

dataChart(a, x = "items", y = "num_of_ratings")

</code></pre>

<hr>
<h2 id='dataSet-class'>
Dataset class.
</h2><span id='topic+dataSet-class'></span><span id='topic+dataSet'></span><span id='topic+nrow+2CdataSet-method'></span><span id='topic+ncol+2CdataSet-method'></span><span id='topic+dim+2CdataSet-method'></span><span id='topic+rowRatings+2CdataSet-method'></span><span id='topic+colRatings+2CdataSet-method'></span><span id='topic+numRatings+2CdataSet-method'></span><span id='topic++5B+2CdataSet+2CANY+2CANY+2Cmissing-method'></span><span id='topic+coerce+2CdataSet+2Cmatrix-method'></span><span id='topic+rowAverages+2CdataSet-method'></span><span id='topic+colAverages+2CdataSet-method'></span>

<h3>Description</h3>

<p>Container for a dense dataset that distinguishes between binary and non-binary feedback datasets. Extends <code><a href="#topic+_ds">_ds</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>the dataset, class <code>"matrix"</code>.</p>
</dd>
<dt><code>binary</code>:</dt><dd><p>class <code>"logical"</code>, determines if the item dataset contains binary (i.e. 1/0) or non-binary ratings.</p>
</dd>
<dt><code>minimum</code>:</dt><dd><p>class <code>"numeric"</code>, defines the minimal value present in the dataset.</p>
</dd>
<dt><code>maximum</code>:</dt><dd><p>class <code>"numeric"</code>, defines the maximal value present in the dataset.</p>
</dd>
<dt><code>intScale</code>:</dt><dd><p>object of class <code>"logical"</code>, if <b>TRUE</b> the range of ratings in the dataset contains as well half star values.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>nrow</dt><dd><p>signature(object = &quot;dataSet&quot;): number of rows of the dataset.</p>
</dd>
<dt>ncol</dt><dd><p>signature(object = &quot;dataSet&quot;): number of columns of the dataset.</p>
</dd>
<dt>dim</dt><dd><p>signature(object = &quot;dataSet&quot;): returns the dimensions of the dataset.</p>
</dd>
<dt>rowRatings</dt><dd><p>signature(object = &quot;dataSet&quot;): returns the number of ratings on each row.</p>
</dd>
<dt>colRatings</dt><dd><p>signature(object = &quot;dataSet&quot;): returns the number of ratings on each column.</p>
</dd>
<dt>numRatings</dt><dd><p>signature(object = &quot;dataSet&quot;): returns the total number of ratings.</p>
</dd>
<dt>[</dt><dd><p>signature(x = &quot;dataSet&quot;, i = &quot;ANY&quot;, j = &quot;ANY&quot;, drop = &quot;ANY&quot;)): returns a subset of the dataset.</p>
</dd>
<dt>coerce</dt><dd><p>signature(from = &quot;dataSet&quot;, to = &quot;matrix&quot;)</p>
</dd>
<dt>rowAverages</dt><dd><p>signature(object = &quot;dataSet&quot;): returns the average rating on each row.</p>
</dd>
<dt>colAverages</dt><dd><p>signature(object = &quot;dataSet&quot;): returns the average rating on each column.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(sample(c(0:5), size = 100, replace = TRUE, 
  prob = c(.6,.08,.08,.08,.08,.08)), nrow = 20, byrow = TRUE)

x &lt;- defineData(x)

colRatings(x)

rowRatings(x)

numRatings(x)

sparsity(x)

a &lt;- x[1:10,2:3]


</code></pre>

<hr>
<h2 id='defineData'>
Define dataset.
</h2><span id='topic+defineData'></span><span id='topic+defineData+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Defines your dataset, if either it is implicit or explicit. 
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineData_+3A_data">data</code></td>
<td>
<p>the dataset, class <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="defineData_+3A_sparsematrix">sparseMatrix</code></td>
<td>
<p>class <code>"logical"</code>. If <code>FALSE</code> implies that the imput is a dense two dimensional matrix. If <code>TRUE</code> implies that the imput is arranges as coordinate list where entries are stored as list of (row, column, value) tuples.</p>
</td></tr>
<tr><td><code id="defineData_+3A_binary">binary</code></td>
<td>
<p>class <code>"logical"</code>, defines if the item dataset consists of binary (i.e. NA/1) or non-binary ratings. Default value <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="defineData_+3A_minimum">minimum</code></td>
<td>
<p>class <code>"numeric"</code>, defines the minimal value present in the dataset. Default value <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="defineData_+3A_maximum">maximum</code></td>
<td>
<p>class <code>"numeric"</code>, defines the maximal value present in the dataset. Default value <code>5</code>.</p>
</td></tr>
<tr><td><code id="defineData_+3A_intscale">intScale</code></td>
<td>
<p>object of class <code>"logical"</code>, if <b>TRUE</b> the range of ratings in the dataset contains as well half star values.  Default value <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="defineData_+3A_positivethreshold">positiveThreshold</code></td>
<td>
<p>class <code>"numeric"</code>, in case <code>binary</code> is <code>TRUE</code>, <code>positiveThreshold</code> defines the threshold value for binarizing the dataset (i.e. any rating value &gt;= <code>positiveThreshold</code> will be transformed to 1 and all other values to <code>NA</code>(corresponding to a not rated item).  Default value <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"dataSet"</code>.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+dataSet-class">dataSet-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mlLatest100k)

a &lt;- defineData(mlLatest100k)

b &lt;- defineData(mlLatest100k,binary = TRUE ,positiveThreshold = 3)

</code></pre>

<hr>
<h2 id='eval_nDCG'>
Normalized Discounted Cumulative Gain
</h2><span id='topic+eval_nDCG'></span>

<h3>Description</h3>

<p>Metric for information retrival where positions are discounted logarithmically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_nDCG(recommendedIDX, testSetIDX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_nDCG_+3A_recommendedidx">recommendedIDX</code></td>
<td>

<p>indices of the recommended items. Object of class <code>numeric</code>.
</p>
</td></tr>
<tr><td><code id="eval_nDCG_+3A_testsetidx">testSetIDX</code></td>
<td>

<p>indices of the items in the test set. Object of class <code>numeric</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nDCG is computed as the ratio between Discounted Cumulative Gain(DCG) and idealized Discounted Cumulative Gain(IDCG): 
</p>
<p style="text-align: center;"><code class="reqn">DGC_{pos} = rel_1 + \sum_{i=2}^{pos} \frac{rel_i}{\log_2i}</code>
</p>

<p style="text-align: center;"><code class="reqn">IDGC_{pos} = rel_1 + \sum_{i=2}^{|h|-1} \frac{rel_i}{\log_2i}</code>
</p>

<p style="text-align: center;"><code class="reqn">nDCG_{pos} = \frac{DCG}{IDCG}</code>
</p>



<h3>References</h3>

<p>Asela Gunawardana, Guy Shani, Evaluating Recommender Systems.
</p>

<hr>
<h2 id='evalChart'>
Visualization of data characteristics.
</h2><span id='topic+evalChart'></span>

<h3>Description</h3>

<p>This method visualizes data characteristics on a two dimensional graph, where &quot;x&quot; axes shows either items ordered by descending popularity, or users based on the number of ratings they have submitted. Moreover the &quot;y&quot; axes shows the number of ratings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalChart(res, x = "items", y = "TP", x_label, y_label, y_lim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalChart_+3A_res">res</code></td>
<td>
<p>evaluation results, class <code>"evalRecResults"</code>.</p>
</td></tr>
<tr><td><code id="evalChart_+3A_x">x</code></td>
<td>
<p>class <code>"character"</code>, is the variable that will be shown on the &quot;x&quot; axis. Possible values are: <code>"items"</code>, <code>"users"</code>.</p>
</td></tr>
<tr><td><code id="evalChart_+3A_y">y</code></td>
<td>
<p>class <code>"character"</code>, is the variable that will be shown on the &quot;y&quot; axis. Possible values are: <code>"num_of_ratings"</code>, <code>"%_of_ratings"</code>.</p>
</td></tr>
<tr><td><code id="evalChart_+3A_x_label">x_label</code></td>
<td>
<p>class <code>"character"</code>, the label to be printed on the &quot;x&quot; axes.</p>
</td></tr>
<tr><td><code id="evalChart_+3A_y_label">y_label</code></td>
<td>
<p>class <code>"character"</code>, the label to be printed on the &quot;y&quot; axes.</p>
</td></tr>
<tr><td><code id="evalChart_+3A_y_lim">y_lim</code></td>
<td>
<p>class <code>"numeric"</code>, scale of the &quot;y&quot; axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot results.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+evalRecResults-class">evalRecResults-class</a></code>.
</p>

<hr>
<h2 id='evalModel'>
Creating the evaluation model.
</h2><span id='topic+evalModel'></span><span id='topic+evalModel+2C_ds-method'></span><span id='topic+evalModel+2CdataSet-method'></span><span id='topic+evalModel+2CsparseDataSet-method'></span>

<h3>Description</h3>

<p>Creates the dataset split for evaluation where ratings of each user are uniformly distributed over k random folds.  The function returns the list of items that are assigned to each fold, such that algorithms can be compared on the same train/test splits.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalModel(data, folds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalModel_+3A_data">data</code></td>
<td>

<p>dataset, of class <code>_ds</code>.
</p>
</td></tr>
<tr><td><code id="evalModel_+3A_folds">folds</code></td>
<td>

<p>The number of folds to use in the k-fold cross validation, of class <code>numeric</code>, default value set to 5.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+evalModel-class">evalModel-class</a></code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evalModel-class">evalModel-class</a></code>, <code><a href="#topic+evalRec">evalRec</a></code>, <code><a href="#topic+_ds">_ds</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(sample(c(0:5), size = 200, replace = TRUE, 
     prob = c(.6,.08,.08,.08,.08,.08)), nrow = 20, byrow = TRUE)

d &lt;- defineData(x)
     
my_2_folds &lt;- evalModel(d, 2)             #output class evalModel.

my_2_folds
# 2 - fold cross validation model on the dataset with 20 users and 10 items.

my_2_folds@data                     #the dataset.
my_2_folds@folds                    #the number of folds in the model.
my_2_folds@fold_indices               #the index of each item in the fold.
     
</code></pre>

<hr>
<h2 id='evalModel-class'>
Evaluation model.
</h2><span id='topic+evalModel-class'></span><span id='topic+show+2CevalModel-method'></span>

<h3>Description</h3>

<p>Class that contains the data and a distribution of the uniform distribution of ratings onto k-folds.  
</p>


<h3>Details</h3>

<p>The fold_indices list contains the indexes to access the dataset on one dimension.  A matrix can be addressed as a one dimensional array, considered as an extension of each column after another.  E.g: in a matrix M with 10 rows and 20 columns, M[10] == M[10, 1]; M[12] == M[2,2].  
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>the dataset, class <code>"matrix"</code>.</p>
</dd>
<dt><code>folds</code>:</dt><dd><p>number of k - folds, class <code>"numeric"</code>.</p>
</dd>
<dt><code>fold_indices</code>:</dt><dd><p>a list with k slots, each slot represents a fold and contains the index of items assigned to that fold, class <code>"list"</code>.</p>
</dd>
<dt><code>fold_indices_x_user</code>:</dt><dd><p>a list that specifies specifically for each user the distribution of the items in the folds, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;evalModel&quot;)</p>
</dd>
</dl>


<hr>
<h2 id='evalPred'>
Evaluates the requested prediction algorithm.
</h2><span id='topic+evalPred'></span><span id='topic+evalPred+2CevalModel-method'></span><span id='topic+evalPred+2CevalModel+2Clist-method'></span>

<h3>Description</h3>

<p>Evaluates the prediction task of an algorithm with a given configuration and based on the given evaluation model. RMSE and MAE are both calculated individually for each user and then averaged over all users (in this case they will be referred as RMSE and MAE) as well as determined as the average error over all predictions (in this case they are named globalRMSE and globalMAE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalPred(model, ...)
## S4 method for signature 'evalModel'
evalPred(model, alg, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalPred_+3A_model">model</code></td>
<td>

<p>Object of type <code>evalModel</code>. See <code><a href="#topic+evalModel-class">evalModel-class</a>.</code>
</p>
</td></tr>
<tr><td><code id="evalPred_+3A_alg">alg</code></td>
<td>

<p>The algorithm to be used in the evaluation. Of type <code>character</code>. 
</p>
</td></tr>
<tr><td><code id="evalPred_+3A_...">...</code></td>
<td>

<p>other attributes specific to the algorithm to be deployed. Refer to <code><a href="#topic+rrecsys">rrecsys</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the <code>RMSE</code>, <code>MAE</code>, <code>globalRMSE</code> and <code>globalMAE</code> for each of the k-folds defined in the evaluation model and an average over all folds.</p>


<h3>References</h3>

<p>F. Ricci, L. Rokach, B. Shapira, and P. B. Kantor, editors. <em>Recommender Systems Handbook</em>. Springer, 2011. ISBN 978-0-387-85819-7. URL <a href="http://www.springerlink.com/content/978-0-387-85819-7">http://www.springerlink.com/content/978-0-387-85819-7</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evalModel-class">evalModel-class</a></code>, <code><a href="#topic+rrecsys">rrecsys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    x &lt;- matrix(sample(c(0:5), size = 200, replace = TRUE, 
        prob = c(.6,.8,.8,.8,.8,.8)), nrow = 20, byrow = TRUE)
  
  x &lt;- defineData(x)
        
  e &lt;- evalModel(x, 2)
  
  SVDEvaluation &lt;- evalPred(e, "FunkSVD", k = 4) 
  
  SVDEvaluation         
  
  
  IBEvaluation &lt;- evalPred(e, "IBKNN", simFunct = "cos", neigh = 5, coRatedThreshold = 2)
  
  IBEvaluation
  
</code></pre>

<hr>
<h2 id='evalRec'>
Evaluates the requested recommendation algorithm.
</h2><span id='topic+evalRec'></span><span id='topic+evalRec+2CevalModel-method'></span><span id='topic+evalRec+2CevalModel+2Clist-method'></span>

<h3>Description</h3>

<p>Evaluates the recommendation task of an algorithm with a given configuration and based on the given evaluation model.  
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalRec_+3A_model">model</code></td>
<td>

<p>Object of type <code>evalModel</code>. See <code><a href="#topic+evalModel-class">evalModel-class</a>.</code>
</p>
</td></tr>
<tr><td><code id="evalRec_+3A_alg">alg</code></td>
<td>

<p>The algorithm to be used in the evaluation. Of class <code>character</code>. 
</p>
</td></tr>
<tr><td><code id="evalRec_+3A_topn">topN</code></td>
<td>
 
<p>Object of class <code>numeric</code>, specifying the number of items to be recommended per user.
</p>
</td></tr>
<tr><td><code id="evalRec_+3A_topngen">topNGen</code></td>
<td>
 
<p>Object of class <code>character</code>, specifying the function used to produce the recommendations. Values: &quot;hpr&quot; and &quot;mf&quot; (currently available only for IB and UB methods). 
</p>
</td></tr>
<tr><td><code id="evalRec_+3A_positivethreshold">positiveThreshold</code></td>
<td>

<p>Object of class <code>numeric</code>, indicating the threshold of the ratings to be considered a good. This attribute is not used when evaluating implicit feedback.
</p>
</td></tr>
<tr><td><code id="evalRec_+3A_alpha">alpha</code></td>
<td>

<p>Object of class <code>numeric</code>, is the half-life parameter for the rankscore metric.
</p>
</td></tr>
<tr><td><code id="evalRec_+3A_...">...</code></td>
<td>

<p>other attributes specific to the algorithm to be deployed. Refer to <code><a href="#topic+rrecsys">rrecsys</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>evalRecResults</code> with the <code>precision</code>, <code>recall</code>, <code>F1</code>, <code>nDCG</code>, <code>RankScore</code>, <code>true positives(TP)</code>, <code>false positives(FP)</code>, <code>true negatives(TN)</code>, <code>false negatives(FN)</code>  for each of the k-folds defined in the evaluation model and the overall average.</p>


<h3>References</h3>

<p>F. Ricci, L. Rokach, B. Shapira, and P. B. Kantor, editors. <em>Recommender Systems Handbook</em>. Springer, 2011. ISBN 978-0-387-85819-7. URL <a href="http://www.springerlink.com/content/978-0-387-85819-7">http://www.springerlink.com/content/978-0-387-85819-7</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evalModel-class">evalModel-class</a></code>, <code><a href="#topic+rrecsys">rrecsys</a></code>, <code><a href="#topic+evalRecResults-class">evalRecResults-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(sample(c(0:5), size = 200, replace = TRUE, 
        prob = c(.6,.8,.8,.8,.8,.8)), nrow = 20, byrow = TRUE)
  
  x &lt;- defineData(x)
        
  e &lt;- evalModel(x, 2)
  
  SVDEvaluation &lt;- evalRec(e, "FunkSVD", positiveThreshold = 4, k = 4) 
  
  SVDEvaluation         
  
  
  
</code></pre>

<hr>
<h2 id='evalRecResults'>
Evaluation results.
</h2><span id='topic+evalRecResults'></span><span id='topic+evalRecResults-class'></span><span id='topic+show+2CevalRecResults-method'></span><span id='topic+results'></span><span id='topic+results+2CevalRecResults-method'></span>

<h3>Description</h3>

<p>Defines a structure for the results obtained by evaluating an algorithm
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>class <code>"_ds"</code>, the dataset.</p>
</dd>
<dt><code>alg</code>:</dt><dd><p>class <code>"character"</code>, the name of the used algorithm.</p>
</dd>
<dt><code>topN</code>:</dt><dd><p>class <code>"numeric"</code>, the number N of Top-N items recommended to each user.</p>
</dd>
<dt><code>topNGen</code>:</dt><dd><p>class <code>"character"</code>, the name of the  recommendation algorithm.</p>
</dd>
<dt><code>positiveThreshold</code>:</dt><dd><p>class <code>"numeric"</code>, indicating the threshold of the ratings to be considered a good. This attribute is not used when evaluating implicit feedback.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>class <code>numeric</code>, is the half-life parameter for the rankscore metric.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>class <code>"list"</code>, parameters used in the configuration of the algorithm.</p>
</dd>
<dt><code>TP</code>:</dt><dd><p>class <code>"numeric"</code>, True Positives count on each fold.</p>
</dd>
<dt><code>FP</code>:</dt><dd><p>class <code>"numeric"</code>, False Positives count on each fold.</p>
</dd>
<dt><code>TN</code>:</dt><dd><p>class <code>"numeric"</code>, True Negatives count on each fold.</p>
</dd>
<dt><code>FN</code>:</dt><dd><p>class <code>"numeric"</code>, False Negatives count on each fold.</p>
</dd>
<dt><code>precision</code>:</dt><dd><p>class <code>"numeric"</code>, precision measured on each fold. </p>
</dd>
<dt><code>recall</code>:</dt><dd><p>class <code>"numeric"</code>, recall measured on each fold.</p>
</dd>
<dt><code>F1</code>:</dt><dd><p>class <code>"numeric"</code>, F1 measured on each fold.</p>
</dd>
<dt><code>nDCG</code>:</dt><dd><p>class <code>"numeric"</code>, nDCG measured on each fold.</p>
</dd>
<dt><code>rankscore</code>:</dt><dd><p>class <code>"numeric"</code>, rankscore measured on each fold.</p>
</dd>
<dt><code>item_coverage</code>:</dt><dd><p>class <code>"numeric"</code>, item coverage.</p>
</dd>
<dt><code>user_coverage</code>:</dt><dd><p>class <code>"numeric"</code>, user coverage.</p>
</dd>
<dt><code>ex.time</code>:</dt><dd><p>class <code>"numeric"</code>, the execution time.</p>
</dd>
<dt><code>TP_count</code>:</dt><dd><p>class <code>"numeric"</code>, True positives count on each item.</p>
</dd>
<dt><code>rec_counts</code>:</dt><dd><p>class <code>"numeric"</code>, counts how many times an item was recommended.</p>
</dd>
<dt><code>rec_popularity</code>:</dt><dd><p>class <code>"numeric"</code>, popularity of recommendations.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;evalRecResults&quot;)</p>
</dd>
<dt><code>results</code></dt><dd><p>signature(object = &quot;evalRecResults&quot;, metrics = &quot;character&quot;): returns a subset of the results based on the required metric.</p>
</dd>
</dl>


<hr>
<h2 id='getAUC'>
Returns the Area under the ROC curve.
</h2><span id='topic+getAUC'></span><span id='topic+getAUC+2CevalModel-method'></span><span id='topic+getAUC+2CevalModel'></span>

<h3>Description</h3>

<p>Computes the Area Under the ROC curve for a recommendation task of an algorithm with its given configuration and based on the given evaluation model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAUC(model, ...)
## S4 method for signature 'evalModel'
getAUC(model, alg, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAUC_+3A_model">model</code></td>
<td>

<p>Object of type <code>evalModel</code>. See <code><a href="#topic+evalModel-class">evalModel-class</a>.</code>
</p>
</td></tr>
<tr><td><code id="getAUC_+3A_alg">alg</code></td>
<td>

<p>The algorithm to be used in the evaluation. Of class <code>character</code>. 
</p>
</td></tr>
<tr><td><code id="getAUC_+3A_...">...</code></td>
<td>

<p>other attributes specific to the algorithm to be deployed. Refer to <code><a href="#topic+rrecsys">rrecsys</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the <code>AUC</code> for each of the k-folds defined in the evaluation model and the overall average.</p>


<h3>References</h3>

<p>T. Fawcett, <em>“ROC Graphs: Notes and Practical Considerations for Data Mining Researchers ROC Graphs : Notes and Practical Considerations for Data Mining Researchers,”</em>, HP Inven., p. 27, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evalModel-class">evalModel-class</a></code>, <code><a href="#topic+rrecsys">rrecsys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(sample(c(NA, 1:5), size = 200, replace = TRUE, 
        prob = c(.6,.8,.8,.8,.8,.8)), nrow = 20, byrow = TRUE)
  
  x &lt;- defineData(x)
        
  e &lt;- evalModel(x, 5)
  
  auc &lt;- getAUC(e, "FunkSVD", k = 4) 
  
  auc         
  
  
</code></pre>

<hr>
<h2 id='histogram'>
Ratings histogram.
</h2><span id='topic+histogram'></span>

<h3>Description</h3>

<p>Histogram of the ratings grouped by value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histogram(data, title = "", x = "Rating values", y = "# of ratings")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histogram_+3A_data">data</code></td>
<td>

<p>class <code>"_ds"</code>, the dataset.
</p>
</td></tr>
<tr><td><code id="histogram_+3A_title">title</code></td>
<td>

<p>class <code>"character"</code>, eventual caption of for the chart.
</p>
</td></tr>
<tr><td><code id="histogram_+3A_x">x</code></td>
<td>

<p>class <code>"character"</code>, label for the x-axis.
</p>
</td></tr>
<tr><td><code id="histogram_+3A_y">y</code></td>
<td>

<p>class <code>"character"</code>, label for the y-axis.
</p>
</td></tr>
</table>

<hr>
<h2 id='IBclass'>
Item based model.
</h2><span id='topic+IBclass'></span><span id='topic+IBclass-class'></span><span id='topic+show+2CIBclass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using any k-nearest neighbor item-based collaborative filtering algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>sim</code>:</dt><dd><p>The item - item similarity matrix, class <code>"matrix"</code>.</p>
</dd>
<dt><code>sim_index_kNN</code>:</dt><dd><p>The index of the k nearest neighbors for each item, class <code>"matrix"</code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>the parameters used in the model, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;IBclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='ml100k'>
Movielens 100K Dataset
</h2><span id='topic+ml100k'></span><span id='topic+ml100k_array'></span>

<h3>Description</h3>

<p>MovieLens data sets were collected by the GroupLens Research Project
at the University of Minnesota.
</p>
<p>This data set consists of:
</p>

<ol>
<li><p> 100,000 ratings (1-5) from 943 users on 1682 movies. 
</p>
</li>
<li><p> Each user has rated at least 20 movies. 
</p>
</li></ol>

<p>The data was collected through the MovieLens web site
(movielens.umn.edu) during the seven-month period from September 19th, 
1997 through April 22nd, 1998. This data has been cleaned up - users
who had less than 20 ratings or did not have complete demographic
information were removed from this data set. Detailed descriptions of
the data file can be found at the end of this file.
</p>


<h3>Source</h3>

<p><a href="http://grouplens.org/datasets/movielens/100k/">http://grouplens.org/datasets/movielens/100k/</a>
</p>

<hr>
<h2 id='mlLatest100k'>
Movielens Latest
</h2><span id='topic+mlLatest100k'></span>

<h3>Description</h3>

<p>This dataset (ml-latest-small) is a 5-star rating dataset from [MovieLens](http://movielens.org), a movie recommendation service of the GroupLens research group at the University of Minnesota. It contains 100234 ratings  across 8927 movies. The data was created by 718 users between March 26, 1996 and August 05, 2015. This dataset was generated on August 06, 2015.
Users were selected at random for inclusion. All selected users had rated at least 20 movies. 
The data is edited and structured as a matrix and distributed as such. Below the usage license of this redistributed data is cited below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mlLatest100k")</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:718, 1:8915] 5 3 0 0 4 4 0 3 0 0 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:718] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
..$ : chr [1:8915] &quot;Toy Story (1995)&quot; &quot;Jumanji (1995)&quot; &quot;GoldenEye (1995)&quot; &quot;Twelve Monkeys (a.k.a. 12 Monkeys) (1995)&quot; ...
</p>


<h3>Source</h3>

<p><a href="http://grouplens.org/datasets/movielens/latest/">http://grouplens.org/datasets/movielens/latest/</a>
</p>

<hr>
<h2 id='PPLclass'>
Popularity based model.
</h2><span id='topic+PPLclass'></span><span id='topic+PPLclass-class'></span><span id='topic+show+2CPPLclass-method'></span>

<h3>Description</h3>

<p>Container for the model learned by an unpersonalized popularity-based algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>indices</code>:</dt><dd><p>the indices of items ordered by popularity, class <code>"integer"</code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>the parameters used in the model, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;PPLclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='predict'>
Generate predictions.
</h2><span id='topic+predict'></span><span id='topic+predict+2CBPRclass-method'></span><span id='topic+predict+2CIBclass-method'></span><span id='topic+predict+2CUBclass-method'></span><span id='topic+predict+2CalgAverageClass-method'></span><span id='topic+predict+2CSVDclass-method'></span><span id='topic+predict+2CwALSclass-method'></span><span id='topic+predict+2C+20slopeOneclass'></span>

<h3>Description</h3>

<p>Generate predictions on any of the previously trained models.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_model">model</code></td>
<td>

<p>A previously trained model, see <code><a href="#topic+rrecsys">rrecsys</a></code>
</p>
</td></tr>
<tr><td><code id="predict_+3A_round">Round</code></td>
<td>

<p>object of class <code>"logical"</code>, if <b>TRUE</b> all the predictions are rounded to integer values, else values are returned as calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All unrated items are predicted and the entire matrix is returned with the new ratings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a></code>, <code><a href="#topic+IBclass">IBclass</a></code>, <code><a href="#topic+SVDclass">SVDclass</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mlLatest100k")

smallMl &lt;- mlLatest100k[1:50, 1:100]

exExpl &lt;- defineData(smallMl)

model1exp &lt;- rrecsys(exExpl, alg = "funk", k = 10, learningRate = 0.01, regCoef = 0.001)

pre1 &lt;- predict(model1exp, Round = TRUE) 
</code></pre>

<hr>
<h2 id='rankScore'>
Rank Score
</h2><span id='topic+rankScore'></span>

<h3>Description</h3>

<p>Rank Score extends the recall metric to take the positions of correct items in a ranked list into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankScore(recommendedIDX, testSetIDX, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankScore_+3A_recommendedidx">recommendedIDX</code></td>
<td>

<p>indices of the recommended items. Object of class <code>numeric</code>.
</p>
</td></tr>
<tr><td><code id="rankScore_+3A_testsetidx">testSetIDX</code></td>
<td>

<p>indices of the items in the test set. Object of class <code>numeric</code>
</p>
</td></tr>
<tr><td><code id="rankScore_+3A_alpha">alpha</code></td>
<td>

<p>is the ranking half life. Object of class <code>numeric</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rank Score is defined as the ratio of the Rank Score of the correct items to best theoretical Rank Score achievable for the user:
</p>
<p style="text-align: center;"><code class="reqn">
rankscore_{p} =\sum_{i\in{h}} 2^{-\frac{rank(i)-1}{\alpha}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
rankscore_{max} =  \sum_{i=1}^{|T|} 2^{-\frac{i-1}{\alpha}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
rankscore = \frac{rankscore_p}{rankscore_{max}}
</code>
</p>


<hr>
<h2 id='recommend'>
Generate recommendation.
</h2><span id='topic+recommendHPR'></span><span id='topic+recommendMF'></span>

<h3>Description</h3>

<p>This method generates top-n recommendations based on a model that has been trained before. Two main methods: recommendHPR, recommendMF. The first method recommends the highest predicted ratings on a user. Instead recommendMF (currently available only for IBKNN and UBKNN), recommends the most frequent item in the user's neighborhood. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recommendHPR(model, topN = 3)
recommendMF(model, topN = 3, pt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recommend_+3A_model">model</code></td>
<td>

<p>the trained model of any algorithm.
</p>
</td></tr>
<tr><td><code id="recommend_+3A_topn">topN</code></td>
<td>

<p>number of items to be recommended per user, class <code>numeric</code>.
</p>
</td></tr>
<tr><td><code id="recommend_+3A_pt">pt</code></td>
<td>

<p>positive threshold, class <code>numeric</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with suggested items for each user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myratings &lt;- matrix(sample(c(0:5), size = 200, replace = TRUE, 
        prob = c(.6,.08,.08,.08,.08,.08)), nrow = 20, byrow = TRUE)

myratings &lt;- defineData(myratings)

r &lt;- rrecsys(myratings, alg = "FunkSVD", k = 2)

rec &lt;- recommendHPR(r)

</code></pre>

<hr>
<h2 id='rrecsys'>
Create a recommender system.
</h2><span id='topic+rrecsys'></span><span id='topic+rrecsys+2C_ds-method'></span><span id='topic+rrecsysRegistry'></span>

<h3>Description</h3>

<p>Based on the specific given algorithm a recommendation model will be trained.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrecsys(data, alg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrecsys_+3A_data">data</code></td>
<td>

<p>Training set of class <code>"matrix"</code>. The columns correspond to items and the rows correspond to users.
</p>
</td></tr>
<tr><td><code id="rrecsys_+3A_alg">alg</code></td>
<td>

<p>A <code>"character"</code> string specifying the recommender algorithm to apply on the data.
</p>
</td></tr>
<tr><td><code id="rrecsys_+3A_...">...</code></td>
<td>

<p>other attributes, see <a href="#topic+rrecsys">details</a>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the value of <em>alg</em> the attributes will have different names and values.  Possible configuration of <code>alg</code> and it's meaning:
</p>

<ol>
<li> <p><b>itemAverage</b>. When <code>alg = "itemAverage"</code> the average rating of an item is used to make predictions and recommendations.
</p>
</li>
<li> <p><b>userAverage</b>. When <code>alg = "userAverage"</code> the average rating of a user is used to make predictions and recommendations.
</p>
</li>
<li> <p><b>globalAverage</b>. When <code>alg = "globalAverage"</code> the overall average of all ratings is used to make predictions and recommendations.
</p>
</li>
<li> <p><b>Mostpopular</b>. The most popular algorithm (<code> alg = "mostpopular"</code>) is the most simple algorithm for recommendations. Item will be ordered based on the number of times that they were rated. Recommendations for a particular user will be the most popular items from the data set which are not contained in the user's training set.
</p>
</li>
<li> <p><b>IBKNN</b>.  As <code> alg = "IBKNN"</code> a k-nearest neighbor item-based collaborative filtering algorithm.  Given two items <em>a</em> and <em>b</em>, we consider them as rating vectors <code class="reqn">\vec{a}</code> and <code class="reqn">\vec{b}</code>. If the argument <em>simFunct</em> is set to &quot;cos&quot; the method computes the cosine similarity as:
</p>
<p style="text-align: center;"><code class="reqn"> sim(\vec{a}, \vec{b}) = cos(\vec{a}, \vec{b}) = \frac{\vec{a} \cdot \vec{b} }{|\vec{a}| \ast |\vec{b}|} </code>
</p>
  
<p>If the argument <em>simFunct</em> is set to &quot;adjCos&quot; the method determines the &quot;adjusted cosine&quot; distance among the items as: </p>
<p style="text-align: center;"><code class="reqn"> sim(\vec{a}, \vec{b}) = \frac{\sum_{u \in U} (r_{u,a} - \overline{r_{u}}) \ast (r_{u,b} - \overline{r_{u}})}{\sqrt{(r_{u,a} - \overline{r_{u}})^2} \ast \sqrt{(r_{u,b} - \overline{r_{u}})^2}}</code>
</p>
  
<p>It extracts, based on the value of the <em>neigh</em> attribute, the number of closest neighbors for each item. 
</p>
</li>
<li> <p><b>UBKNN</b>.  As <code> alg = "UBKNN"</code> a k-nearest neighbor user-based collaborative filtering algorithm.  Given two users <em>u</em> and <em>u</em>, we consider them as rating vectors <code class="reqn">\vec{u}</code> and <code class="reqn">\vec{v}</code>. If the argument <em>simFunct</em> is set to &quot;cos&quot; the method computes the cosine similarity as:
</p>
<p style="text-align: center;"><code class="reqn"> sim(\vec{u}, \vec{v}) = cos(\vec{u}, \vec{v}) = \frac{\vec{u} \cdot \vec{v} }{|\vec{u}| \ast |\vec{v}|} </code>
</p>
  
<p>If the argument <em>simFunct</em> is set to &quot;Pearson&quot; the method determines the &quot;Pearson correlation&quot; among the users as: </p>
<p style="text-align: center;"><code class="reqn">sim(\vec{u}, \vec{v}) = Pearson(\vec{u}, \vec{v}) = \frac{\sum \limits_{i \in I_u \cap I_v} (R_{ui} - \overline{R_{u}}) \ast (R_{vi} - \overline{R_{v}})}{\sqrt{\sum \limits_{i \in I_u \cap I_v}(R_{ui} - \overline{R_{u}})^2 \ast \sum \limits_{i \in I_u \cap I_v}(R_{vi} - \overline{R_{v}})^2}}
</code>
</p>
  
<p>It extracts, based on the value of the <em>neigh</em> attribute, the number of closest neighbors for each item. 
</p>
</li>
<li> <p><b>FunkSVD</b>.  It implements <code> alg = "funkSVD"</code>  a stochastic gradient descent optimization technique. The U(user) and V(item) factor matrices are initialized at small values and cropped to <em>k</em> features.  Each feature is trained until <em>convergence</em> (the convergence value has to be specified by the user, by configuring the <em>steps</em> argument).  On each loop the algorithm predicts <code class="reqn">r'_{ui}</code> and calculates the error as: 
</p>
<p style="text-align: center;"><code class="reqn">r'_{ui} = u_{u} \ast v^{T}_{i}</code>
</p>
 <p style="text-align: center;"><code class="reqn">e_{ui} =r_{ui} - r'_{ui}</code>
</p>
 
<p>The factors are updated: </p>
<p style="text-align: center;"><code class="reqn">v_{ik} \gets v_{ik} + learningRate \ast (e_{ui} \ast u_{uk} - regCoef \ast v_{ik}) </code>
</p>

<p style="text-align: center;"><code class="reqn">u_{uk} \gets u_{uk} + lambda \ast (e_{ui} \ast v_{ik} - gamma \ast u_{uk}) </code>
</p>
<p>. The attribute <em>learningRate</em> represents the learning rate, while <em>regCoef</em> corresponds to the weight of the regularization term.
If the argument <em>biases</em> is TRUE, the biases will be computed to update the features and generate predictions.
</p>
</li>
<li> <p><b>wALS</b>. The <code>alg = "wALS"</code> weighted Alternated Least squares method. For a given non-negative weight matrix <em>W</em> the algorithm will perform updates on the item <em>V</em> and user <em>U</em> feature matrix as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 U_i = R_i \ast \widetilde{W_i} \ast V \ast (V^T \ast \widetilde{W_i} \ast V + lambda (\sum_j W_{ij}) I ) ^{-1}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
V_j = R_j^T \ast \widetilde{W_j} \ast U \ast (V^T \ast \widetilde{W_j} \ast u + lambda (\sum_i W_{ij}) I ) ^{-1} 
</code>
</p>

<p>Initially the <em>V</em> matrix is initialized with Gaussian random numbers with mean zero and small standard deviation. Than <em>U</em> and <em>V</em> are updated until <code>convergence</code>. The attribute <code>scheme</code> must specify the scheme(<code>uni, uo, io, co</code>) to use.
</p>
</li>
<li> <p><b>BPR</b>. In this implementation of BPR (<code>alg = "BPR"</code>) is applied a stochastic gradient descent approach that randomly choose triples from <code class="reqn">D_R</code> and trains the model <code class="reqn">\Theta</code>. In this implementation the BPR optimization criterion is applied on matrix factorization. If <code class="reqn">R = U \times V^T</code>, where <em>U</em> and <em>V</em> are the usual feature matrix cropped to <em>k</em> features, the parameter vector of the model is <code class="reqn">\Theta = \langle U,V \rangle</code>. The Boolean <code>randomInit</code> parameter determines whatever the feature matrix are initialized to a random value or at a static 0.1 value. The algorithm will use three regularization terms, <code>RegU</code> for the user features <em>U</em>, <code>RegI</code> for positive updates and <code>RegJ</code> for negative updates of the item features <em>V</em>, <code>lambda</code> is the learning rate, <code>autoConvergence</code> is a toggle to the auto convergence validation, <code>convergence</code> upper limit to the convergence, and <code>updateJ</code> if true updates negative item features.
</p>
</li>
<li> <p><b>SlopeOne</b> The Weighted Slope One (<code>alg = "slopeOne"</code>) performs prediction for a missing rating <code class="reqn">\hat{r}_{ui}</code> for user <code class="reqn">u</code> on item <code class="reqn">i</code> as the following average:
</p>
<p style="text-align: center;"><code class="reqn">
\hat{r}_{ui} = \frac{\sum_{\forall r_{uj}} (dev_{ij} + r_{uj})c_{ij}}{\sum_{\forall r_{uj}}c_{ij}}.
</code>
</p>

<p>The average deviation rating $dev_ij$ between co-rated items is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
 dev_{ij} = \sum_{\forall u \in users }\frac{r_{ui} - r_{uj}}{c_{ij}}.
</code>
</p>

<p>Where $c_ij$ is the number of co-ratings between items $i$ and $j$ and $r_ui$ is an existing rating for user $u$ on item $i$. The Weighted Slope One takes into account both, information from users who rated the same item and the number of observed ratings.
</p>
</li></ol>

<p>To view a full list of available algorithms and their default configuration execute <code>rrecsysRegistry</code>.
</p>


<h3>Value</h3>

<p>Depending on the <code>alg</code> value it will be either an object of type <code><a href="#topic+SVDclass">SVDclass</a></code> or <code><a href="#topic+IBclass">IBclass</a></code>.
</p>


<h3>References</h3>

<p>D. Jannach, M. Zanker, A. Felfernig, and G. Friedrich. <em>Recommender Systems: An Introduction</em>. Cambridge
University Press, New York, NY, USA, 1st edition, 2010. ISBN 978-0-521-49336-9.
</p>
<p>Funk, S., 2006, <em>Netflix Update: Try This at Home, <a href="http://sifter.org/~simon/journal/20061211.html">http://sifter.org/~simon/journal/20061211.html</a></em>.
</p>
<p>Y. Koren, R. Bell, and C. Volinsky. <em>Matrix Factorization Techniques for Recommender Systems</em>. Computer, 42(8):30–37, Aug. 2009. ISSN 0018-9162. doi: 10.1109/MC.2009.263. <a href="http://dx.doi.org/10.1109/MC.2009.263">http://dx.doi.org/10.1109/MC.2009.263</a>. 
</p>
<p>R. Pan, Y. Zhou, B. Cao, N. Liu, R. Lukose, M. Scholz, and Q. Yang. <em>One-Class Collaborative Filtering</em>. In Data Mining, 2008. ICDM ’08. Eighth IEEE International Conference on, pages 502–511, Dec 2008. doi: 10.1109/ICDM.2008.16.
</p>
<p>S. Rendle, C. Freudenthaler, Z. Gantner, and L. Schmidt-Thieme. <em>BPR: Bayesian Personalized Ranking from Implicit Feedback</em>. In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence, UAI ’09, pages 452–461, Arlington, Virginia, United States, 2009. AUAI Press. ISBN 978-0-9749039-5-8. URL <a href="http://dl.acm.org/citation.cfm?id=1795114.1795167">http://dl.acm.org/citation.cfm?id=1795114.1795167</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myratings &lt;- matrix(sample(c(0:5), size = 200, replace = TRUE, 
        prob = c(.6,.08,.08,.08,.08,.08)), nrow = 20, byrow = TRUE)

myratings &lt;- defineData(myratings)

r &lt;- rrecsys(myratings, alg = "funkSVD", k = 2)

r2 &lt;- rrecsys(myratings, alg = "IBKNN", simFunct = "cos", neigh = 5)

rrecsysRegistry$get_entries()


 </code></pre>

<hr>
<h2 id='setStoppingCriteria'>
Set stopping criteria.
</h2><span id='topic+setStoppingCriteria'></span><span id='topic+showStoppingCriteria'></span><span id='topic+showDeltaError'></span>

<h3>Description</h3>

<p>Define stopping criteria for functions that need a convergence check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setStoppingCriteria(autoConverge = FALSE, 
  deltaErrorThreshold = 1e-05, nrLoops = NULL, minNrLoops = 10)
showStoppingCriteria()
showDeltaError()

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setStoppingCriteria_+3A_autoconverge">autoConverge</code></td>
<td>

<p>class <code>"logical"</code>, turns on the auto-convergence algorithm. 
</p>
</td></tr>
<tr><td><code id="setStoppingCriteria_+3A_deltaerrorthreshold">deltaErrorThreshold</code></td>
<td>

<p>class <code>"numeric"</code>, is the threshold for the auto-convergence algorithm.
</p>
</td></tr>
<tr><td><code id="setStoppingCriteria_+3A_nrloops">nrLoops</code></td>
<td>

<p>class <code>"numeric"</code>, number of loops that will be performed in case <code>autoConvergence</code> is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="setStoppingCriteria_+3A_minnrloops">minNrLoops</code></td>
<td>
<p>class <code>"numeric"</code>, the minimum number of loops to consider before verifying the deltaErrorThreshold.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>autoConvergence = TRUE</code> tells the package to monitor the difference of global RMSE on two consecutive iterations, and to see if it drops below a threshold value. Whenever it drops under the specified value the iteration is considered converged. If <code>FALSE</code> the limit of iterations is delimited by <code>nrLoops</code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>showStoppingCriteria</code></dt><dd><p>Print on console the current configuration of the convergence algorithm.</p>
</dd>
<dt><code>showDeltaError</code></dt><dd><p>Report the delta error on each iteration of the algorithm that requires an auto-convergence algorithm.</p>
</dd>
</dl>



<h3>References</h3>

<p>M. D. Ekstrand, M. Ludwig, J. Kolb, and J. T. Riedl, <em>“LensKit: a modular recommender framework,”</em>, Proc. fifth ACM Conf. Recomm. Syst. - RecSys ’11, p. 349, 2011.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+rrecsys">rrecsys</a></code>, <code><a href="#topic+SVDclass">SVDclass</a></code>, <code><a href="#topic+wALSclass">wALSclass</a></code>, <code><a href="#topic+BPRclass">BPRclass</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
setStoppingCriteria(autoConverge = TRUE)

setStoppingCriteria(nrLoops = 30)

</code></pre>

<hr>
<h2 id='slopeOneClass'>
Slope One model.
</h2><span id='topic+slopeOneClass'></span><span id='topic+slopeOneClass-class'></span><span id='topic+show+2CslopeOneClass-method'></span><span id='topic+predict+2CslopeOneClass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using Slope One algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>devcard</code>:</dt><dd><p>Deviation and Cardinality between columns, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;SVDclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='sparseDataSet-class'>
Dataset class for tuples (user, item, rating).
</h2><span id='topic+sparseDataSet-class'></span><span id='topic+sparseDataSet'></span><span id='topic+nrow+2CsparseDataSet-method'></span><span id='topic+ncol+2CsparseDataSet-method'></span><span id='topic+dim+2CsparseDataSet-method'></span><span id='topic+rowRatings+2CsparseDataSet-method'></span><span id='topic+colRatings+2CsparseDataSet-method'></span><span id='topic+numRatings+2CsparseDataSet-method'></span><span id='topic++5B+2CsparseDataSet+2CANY+2CANY+2Cmissing-method'></span><span id='topic+coerce+2CsparseDataSet+2Cmatrix-method'></span><span id='topic+rowAverages+2CsparseDataSet-method'></span><span id='topic+colAverages+2CsparseDataSet-method'></span>

<h3>Description</h3>

<p>Container for a sparse dataset that distinguishes between binary and non-binary feedback datasets. Data are stored as tuples (user, item, rating). Extends <code><a href="#topic+_ds">_ds</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>the dataset, class <code>"matrix"</code>.</p>
</dd>
<dt><code>binary</code>:</dt><dd><p>class <code>"logical"</code>, determines if the item dataset contains binary (i.e. 1/0) or non-binary ratings.</p>
</dd>
<dt><code>minimum</code>:</dt><dd><p>class <code>"numeric"</code>, defines the minimal value present in the dataset.</p>
</dd>
<dt><code>maximum</code>:</dt><dd><p>class <code>"numeric"</code>, defines the maximal value present in the dataset.</p>
</dd>
<dt><code>intScale</code>:</dt><dd><p>object of class <code>"logical"</code>, if <b>TRUE</b> the range of ratings in the dataset contains as well half star values.</p>
</dd>
<dt><code>userID</code>:</dt><dd><p>class <code>"numeric"</code>, array containing all user IDs.</p>
</dd>
<dt><code>itemID</code>:</dt><dd><p>class <code>"numeric"</code>, array containing all item IDs.</p>
</dd>
<dt><code>userPointers</code>:</dt><dd><p>class <code>"list"</code>, pointer to all users position in the dataset.</p>
</dd>
<dt><code>itemPointers</code>:</dt><dd><p>class <code>"list"</code>, pointer to all items position in the dataset.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>nrow</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): number of rows of the dataset.</p>
</dd>
<dt>ncol</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): number of columns of the dataset.</p>
</dd>
<dt>dim</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): returns the dimensions of the dataset.</p>
</dd>
<dt>rowRatings</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): returns the number of ratings on each row.</p>
</dd>
<dt>colRatings</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): returns the number of ratings on each column.</p>
</dd>
<dt>numRatings</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): returns the total number of ratings.</p>
</dd>
<dt>[</dt><dd><p>signature(x = &quot;sparseDataSet&quot;, i = &quot;ANY&quot;, j = &quot;ANY&quot;, drop = &quot;ANY&quot;)): returns a subset of the dataset.</p>
</dd>
<dt>coerce</dt><dd><p>signature(from = &quot;sparseDataSet&quot;, to = &quot;matrix&quot;)</p>
</dd>
<dt>rowAverages</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): returns the average rating on each row.</p>
</dd>
<dt>colAverages</dt><dd><p>signature(object = &quot;sparseDataSet&quot;): returns the average rating on each column.</p>
</dd>
</dl>


<hr>
<h2 id='SVDclass'>
SVD model.
</h2><span id='topic+SVDclass-class'></span><span id='topic+SVDclass'></span><span id='topic+show+2CSVDclass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using any matrix factorization algorithm.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>user(U) and items(V) factors, class <code>"list"</code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>the parameters used in the model, class <code>"list"</code>.</p>
</dd>
<dt><code>baselines</code>:</dt><dd><p>Global, user and item baselines, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;SVDclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='UBclass'>
Item based model.
</h2><span id='topic+UBclass'></span><span id='topic+UBclass-class'></span><span id='topic+show+2CUBclass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using any k-nearest neighbor item-based collaborative filtering algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>sim</code>:</dt><dd><p>The item - item similarity matrix, class <code>"matrix"</code>.</p>
</dd>
<dt><code>sim_index_kNN</code>:</dt><dd><p>The index of the k nearest neighbors for each item, class <code>"matrix"</code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>the parameters used in the model, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;UBclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

<hr>
<h2 id='wALSclass'>
Weighted Alternating Least Squares based model.
</h2><span id='topic+wALSclass'></span><span id='topic+wALSclass-class'></span><span id='topic+show+2CwALSclass-method'></span>

<h3>Description</h3>

<p>Container for the model learned using any weighted Alternating Least Squares based algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alg</code>:</dt><dd><p>The algorithm denominator, of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>the dataset used for training the model, class <code>"matrix"</code>.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>user(U) and items(V) factors, class <code>"list"</code>.</p>
</dd>
<dt><code>weightScheme</code>:</dt><dd><p>The weighting scheme used in updating the factors, class <code>"matrix"</code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>the parameters(such as number of factors <code>k</code>, learning rate <code>lambda</code>, number of iterations until <code>convergence</code> and the weighting scheme) used in the model, class <code>"list"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p>signature(object = &quot;wALSclass&quot;)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rrecsys">rrecsys</a>.</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
