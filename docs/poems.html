<!DOCTYPE html><html lang="en-AU"><head><title>Help for package poems</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poems}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#poems-package'><p>poems: Pattern-Oriented Ensemble Modeling System</p></a></li>
<li><a href='#DispersalFriction'><p>R6 class representing a dispersal friction.</p></a></li>
<li><a href='#DispersalGenerator'><p>R6 class representing a dispersal generator.</p></a></li>
<li><a href='#DispersalTemplate'><p>R6 class representing a nested container for dispersal generator attributes</p></a></li>
<li><a href='#GenerativeTemplate'><p>R6 class representing a nested container for generator attributes</p></a></li>
<li><a href='#Generator'><p>R6 class representing a dynamic attribute generator</p></a></li>
<li><a href='#GenericClass'><p>R6 class with generic reusable functionality</p></a></li>
<li><a href='#GenericManager'><p>R6 class representing a generic manager.</p></a></li>
<li><a href='#GenericModel'><p>R6 class representing a generic model.</p></a></li>
<li><a href='#LatinHypercubeSampler'><p>R6 class to represent a Latin hypercube sampler.</p></a></li>
<li><a href='#ModelSimulator'><p>R6 class representing a model simulator.</p></a></li>
<li><a href='#poems'><p>poems: Pattern-oriented ensemble modeling and simulation</p></a></li>
<li><a href='#population_density'><p>Nested functions for population density dependence.</p></a></li>
<li><a href='#population_dispersal'><p>Nested functions for population dispersal.</p></a></li>
<li><a href='#population_env_stoch'><p>Nested functions for population environmental stochasticity.</p></a></li>
<li><a href='#population_results'><p>Nested functions for initializing, calculating and collecting population simulator results.</p></a></li>
<li><a href='#population_simulator'><p>Runs a stage-based demographic population model simulation.</p></a></li>
<li><a href='#population_transformation'><p>Nested functions for a user-defined population abundance (and capacity) transformation.</p></a></li>
<li><a href='#population_transitions'><p>Nested functions for stage-based population transitions.</p></a></li>
<li><a href='#PopulationModel'><p>R6 class representing a population model</p></a></li>
<li><a href='#PopulationResults'><p>R6 class representing population simulator results.</p></a></li>
<li><a href='#Region'><p>R6 class representing a study region.</p></a></li>
<li><a href='#ResultsManager'><p>R6 class representing a results manager.</p></a></li>
<li><a href='#SimulationManager'><p>R6 class representing a simulation manager.</p></a></li>
<li><a href='#SimulationModel'><p>R6 class representing a simulation model</p></a></li>
<li><a href='#SimulationResults'><p>R6 class representing simulation results.</p></a></li>
<li><a href='#SimulatorReference'><p>R6 class for a simulator reference</p></a></li>
<li><a href='#SpatialCorrelation'><p>R6 class representing a spatial correlation.</p></a></li>
<li><a href='#SpatialModel'><p>R6 class representing a spatial model</p></a></li>
<li><a href='#tasmania_ibra_data'><p>Thylacine vignette Tasmania IBRA data</p></a></li>
<li><a href='#tasmania_ibra_raster'><p>Thylacine vignette Tasmania IBRA raster</p></a></li>
<li><a href='#tasmania_modifier'><p>Tasmania land-use modifier raster</p></a></li>
<li><a href='#tasmania_raster'><p>Thylacine vignette Tasmania raster</p></a></li>
<li><a href='#thylacine_bounty_record'><p>Thylacine vignette bounty record</p></a></li>
<li><a href='#thylacine_example_matrices'><p>Thylacine vignette demonstration example matrices</p></a></li>
<li><a href='#thylacine_example_matrices_rerun'><p>Thylacine vignette demonstration example (re-run) matrices</p></a></li>
<li><a href='#thylacine_example_metrics'><p>Thylacine vignette demonstration example metrics</p></a></li>
<li><a href='#thylacine_example_metrics_rerun'><p>Thylacine vignette demonstration example (re-run) metrics</p></a></li>
<li><a href='#thylacine_hs_raster'><p>Thylacine vignette habitat suitability raster</p></a></li>
<li><a href='#Validator'><p>R6 class representing a pattern-oriented validator.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pattern-Oriented Ensemble Modeling System</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework of interoperable R6 classes (Chang, 2020, <a href="https://CRAN.R-project.org/package=R6">https://CRAN.R-project.org/package=R6</a>) for building ensembles of viable models via the pattern-oriented modeling (POM) approach (Grimm et al.,2005, &lt;<a href="https://doi.org/10.1126%2Fscience.1116681">doi:10.1126/science.1116681</a>&gt;). The package includes classes for encapsulating and generating model parameters, and managing the POM workflow. The workflow includes: model setup; generating model parameters via Latin hyper-cube sampling (Iman &amp; Conover, 1980, &lt;<a href="https://doi.org/10.1080%2F03610928008827996">doi:10.1080/03610928008827996</a>&gt;); running multiple sampled model simulations; collating summary results; and validating and selecting an ensemble of models that best match known patterns. By default, model validation and selection utilizes an approximate Bayesian computation (ABC) approach (Beaumont et al., 2002, &lt;<a href="https://doi.org/10.1093%2Fgenetics%2F162.4.2025">doi:10.1093/genetics/162.4.2025</a>&gt;), although alternative user-defined functionality could be employed. The package includes a spatially explicit demographic population model simulation engine, which incorporates default functionality for density dependence, correlated environmental stochasticity, stage-based transitions, and distance-based dispersal. The user may customize the simulator by defining functionality for translocations, harvesting, mortality, and other processes, as well as defining the sequence order for the simulator processes. The framework could also be adapted for use with other model simulators by utilizing its extendable (inheritable) base classes.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-AU</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GlobalEcologyLab/poems">https://github.com/GlobalEcologyLab/poems</a>,
<a href="https://globalecologylab.github.io/poems/">https://globalecologylab.github.io/poems/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GlobalEcologyLab/poems/issues">https://github.com/GlobalEcologyLab/poems/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>abc (&ge; 2.1), doParallel (&ge; 1.0.16), foreach (&ge; 1.5.1),
fossil (&ge; 0.4.0), lhs (&ge; 1.1.1), metRology (&ge; 0.9.28.1), R6
(&ge; 2.5.0), raster (&ge; 3.6), trend (&ge; 1.1.4), truncnorm (&ge;
1.0), gdistance, qs</td>
</tr>
<tr>
<td>Collate:</td>
<td>'GenericClass.R' 'Region.R' 'GenericModel.R' 'SpatialModel.R'
'DispersalFriction.R' 'GenerativeTemplate.R'
'DispersalTemplate.R' 'Generator.R' 'DispersalGenerator.R'
'GenericManager.R' 'LatinHypercubeSampler.R' 'ModelSimulator.R'
'SimulationModel.R' 'PopulationModel.R' 'SimulationResults.R'
'PopulationResults.R' 'ResultsManager.R' 'SimulationManager.R'
'SimulatorReference.R' 'SpatialCorrelation.R' 'Validator.R'
'data.R' 'poems-package.R' 'population_density.R'
'population_dispersal.R' 'population_env_stoch.R'
'population_results.R' 'population_transformation.R'
'population_transitions.R' 'population_simulator.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, sf, scales, stringi, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-24 19:43:32 UTC; caryinstitute</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean Haythorne [aut],
  Damien Fordham [aut],
  Stuart Brown <a href="https://orcid.org/0000-0002-0669-1418"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jessie Buettel [aut],
  Barry Brook [aut],
  July Pilowsky <a href="https://orcid.org/0000-0002-6376-2585"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>July Pilowsky &lt;pilowskyj@caryinstitute.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='poems-package'>poems: Pattern-Oriented Ensemble Modeling System</h2><span id='topic+poems-package'></span>

<h3>Description</h3>

<p>A framework of interoperable R6 classes (Chang, 2020, <a href="https://CRAN.R-project.org/package=R6">https://CRAN.R-project.org/package=R6</a>) for building ensembles of viable models via the pattern-oriented modeling (POM) approach (Grimm et al.,2005, <a href="https://doi.org/10.1126/science.1116681">doi:10.1126/science.1116681</a>). The package includes classes for encapsulating and generating model parameters, and managing the POM workflow. The workflow includes: model setup; generating model parameters via Latin hyper-cube sampling (Iman &amp; Conover, 1980, <a href="https://doi.org/10.1080/03610928008827996">doi:10.1080/03610928008827996</a>); running multiple sampled model simulations; collating summary results; and validating and selecting an ensemble of models that best match known patterns. By default, model validation and selection utilizes an approximate Bayesian computation (ABC) approach (Beaumont et al., 2002, <a href="https://doi.org/10.1093/genetics/162.4.2025">doi:10.1093/genetics/162.4.2025</a>), although alternative user-defined functionality could be employed. The package includes a spatially explicit demographic population model simulation engine, which incorporates default functionality for density dependence, correlated environmental stochasticity, stage-based transitions, and distance-based dispersal. The user may customize the simulator by defining functionality for translocations, harvesting, mortality, and other processes, as well as defining the sequence order for the simulator processes. The framework could also be adapted for use with other model simulators by utilizing its extendable (inheritable) base classes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: July Pilowsky <a href="mailto:pilowskyj@caryinstitute.org">pilowskyj@caryinstitute.org</a> (<a href="https://orcid.org/0000-0002-6376-2585">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sean Haythorne <a href="mailto:sean.haythorne@unimelb.edu.au">sean.haythorne@unimelb.edu.au</a>
</p>
</li>
<li><p> Damien Fordham <a href="mailto:damien.fordham@adelaide.edu.au">damien.fordham@adelaide.edu.au</a>
</p>
</li>
<li><p> Stuart Brown <a href="mailto:stuart.brown@sa.gov.au">stuart.brown@sa.gov.au</a> (<a href="https://orcid.org/0000-0002-0669-1418">ORCID</a>)
</p>
</li>
<li><p> Jessie Buettel <a href="mailto:jessie.buettel@utas.edu.au">jessie.buettel@utas.edu.au</a>
</p>
</li>
<li><p> Barry Brook <a href="mailto:barry.brook@utas.edu.au">barry.brook@utas.edu.au</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/GlobalEcologyLab/poems">https://github.com/GlobalEcologyLab/poems</a>
</p>
</li>
<li> <p><a href="https://globalecologylab.github.io/poems/">https://globalecologylab.github.io/poems/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/GlobalEcologyLab/poems/issues">https://github.com/GlobalEcologyLab/poems/issues</a>
</p>
</li></ul>


<hr>
<h2 id='DispersalFriction'>R6 class representing a dispersal friction.</h2><span id='topic+DispersalFriction'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class functionality for modeling sea, ice and other
frictional barriers to dispersal within a spatially-explicit population model. The
dispersal friction model utilizes the
<code><a href="gdistance.html#topic+gdistance">gdistance</a></code> package functionality to
calculate distance multipliers to modify distance-based dispersal rates for
simulated migrations in a spatio-temporal frictional landscape. The frictional
landscape is defined via conductance/permeability values, the inverse of friction,
which ranges from zero (barrier) to one (no friction) with values in-between
representing some friction. For example, a conductance value of 1/5 = 0.2 represents
a landscape in which simulated animals move 5 times slower than a non-friction
landscape. In this example the resultant distance multiplier would be 5, thus
reducing the effective dispersal range.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code>DispersalFriction</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>Number of cores for running the simulations in parallel.</p>
</dd>
<dt><code>write_to_dir</code></dt><dd><p>Directory path for storing distance multipliers when memory performance is an issue.</p>
</dd>
<dt><code>transition_directions</code></dt><dd><p>Number of transition directions or neighbors in which cells are connected: usually 4, 8 (default), or 16 (see <code><a href="gdistance.html#topic+transition">gdistance::transition</a></code>).</p>
</dd>
<dt><code>conductance</code></dt><dd><p>Matrix/raster of conductance (inverse friction) values (range: 0 = barrier; 0 &lt; some friction &lt; 1; 1 = no friction) for each grid cell (rows/cells) at each simulation time step (columns/layers).</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DispersalFriction-calculate_distance_multipliers"><code>DispersalFriction$calculate_distance_multipliers()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalFriction-clone"><code>DispersalFriction$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_names"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_names'><code>poems::GenericModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attributes'><code>poems::GenericModel$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="set_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-set_attributes'><code>poems::GenericModel$set_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SpatialModel" data-id="initialize"><a href='../../poems/html/SpatialModel.html#method-SpatialModel-initialize'><code>poems::SpatialModel$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SpatialModel" data-id="new_clone"><a href='../../poems/html/SpatialModel.html#method-SpatialModel-new_clone'><code>poems::SpatialModel$new_clone()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DispersalFriction-calculate_distance_multipliers"></a>



<h4>Method <code>calculate_distance_multipliers()</code></h4>

<p>Calculates and returns spatio-temporal dispersal distance multipliers for each in-range migration.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalFriction$calculate_distance_multipliers(dispersal_indices, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dispersal_indices</code></dt><dd><p>Two-column integer matrix, data.frame, or array representing the target and source coordinate index for each in-range migration.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Temporal list of dispersal distance multiplier arrays with values for each in-range migration.
</p>


<hr>
<a id="method-DispersalFriction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalFriction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
#' U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster #' full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA #' make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)

#' Dispersal distances
dispersal_gen &lt;- DispersalGenerator$new(region = region)
dispersal_gen$set_attributes(params = list(p = 0.5, b = 700, r = 3000))
distances &lt;- round(dispersal_gen$calculate_distance_matrix()) #' in m
dispersal_gen$calculate_distance_data()
dispersal_indices &lt;- as.matrix(dispersal_gen$distance_data$base[, 1:2])

#' Distance multipliers with friction in cell 4
dispersal_friction &lt;- DispersalFriction$new(
  region = region,
  conductance = c(1, 1, 1, 0.5, 1, 1, 1)
)
multipliers &lt;- dispersal_friction$calculate_distance_multipliers(dispersal_indices)
cbind(dispersal_indices,
  distance = distances[dispersal_indices],
  multiplier = multipliers[[1]]
)

#' Note that crossing the water is avoided.

</code></pre>

<hr>
<h2 id='DispersalGenerator'>R6 class representing a dispersal generator.</h2><span id='topic+DispersalGenerator'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class functionality for modeling dispersals within a
spatially-explicit population model. The model calculates dispersal rates between
population model cells using a distance-based function: <em>p*exp(-distance/b)</em>
for <em>distance &lt;= r</em> (otherwise zero), where <em>p</em> (proportion), <em>b</em>
(breadth or average distance) and <em>r</em> (range or maximum distance) are
configurable model attributes. The dispersal rates are adjusted to limit
emigration from each cell to <em>p</em>. The model also generates data for
constructing compacted dispersal matrices. It dynamically generates attributes
defined as <em>outputs</em> (default: <em>dispersal_data</em>) given sampled
<em>inputs</em> (default: <em>dispersal_proportion</em> and
<em>dispersal_max_distance</em>). An optional <code><a href="#topic+DispersalFriction">DispersalFriction</a></code> object
may be utilized to modify (equivalent) distances given a (spatio-temporal) frictional
landscape. When this landscape includes temporal changes, the generated
<em>dispersal_data</em> will be a temporal list of changing dispersal rates.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code><a href="#topic+Generator">poems::Generator</a></code> -&gt; <code>DispersalGenerator</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>description</code></dt><dd><p>A brief description of what the generator generates.</p>
</dd>
<dt><code>inputs</code></dt><dd><p>An array of input attribute names for the generator.</p>
</dd>
<dt><code>outputs</code></dt><dd><p>An array of output attribute names for the generator.</p>
</dd>
<dt><code>file_templates</code></dt><dd><p>A nested list of file template attributes.</p>
</dd>
<dt><code>function_templates</code></dt><dd><p>A nested list of function template attributes.</p>
</dd>
<dt><code>distribution_templates</code></dt><dd><p>A list of distribution template attributes.</p>
</dd>
<dt><code>uses_correlations</code></dt><dd><p>A boolean to indicate that a <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object is used for generating correlated random deviates.</p>
</dd>
<dt><code>spatial_correlation</code></dt><dd><p>A <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object for generating correlated random deviates.</p>
</dd>
<dt><code>temporal_correlation</code></dt><dd><p>Absolute correlation coefficient between simulation time steps for all grid cells (0-1; default = 1).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Number of decimal places applied to generated data outputs (default: NULL = no rounding).</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for generated (time-series) data outputs.</p>
</dd>
<dt><code>template_attached</code></dt><dd><p>A list of template-nested dynamically attached model attributes that are maintained via shallow or <em>new</em> cloning.</p>
</dd>
<dt><code>dispersal_friction</code></dt><dd><p>A <code><a href="#topic+DispersalFriction">DispersalFriction</a></code> (or inherited class) object for dispersal distance multiplier data.</p>
</dd>
<dt><code>distance_classes</code></dt><dd><p>Vector of distance interval boundaries for calculating discrete dispersal rates.</p>
</dd>
<dt><code>max_distance_classes</code></dt><dd><p>The maximum number of distance classes when they are calculated automatically via the maximum distance (default: 1000).</p>
</dd>
<dt><code>distance_scale</code></dt><dd><p>Scale of distance values in meters (default = 1). Usage: set to 1 for values in meters, or to 1000 for values in kilometers.</p>
</dd>
<dt><code>distance_data</code></dt><dd><p>Data frame of distance classes including indices for the construction of compact matrices (columns: target_pop, source_pop, compact_row, distance_class).</p>
</dd>
<dt><code>dispersal_function_data</code></dt><dd><p>Data frame of discrete dispersal function values. Optional first column may provide distance intervals (non-inclusive lower bounds).</p>
</dd>
<dt><code>dispersal_proportion</code></dt><dd><p>Dispersal function: <em>p*exp(-distance/b)</em> <em>p</em> parameter. Represents the proportion and limit of dispersers between model cells.</p>
</dd>
<dt><code>dispersal_breadth</code></dt><dd><p>Dispersal function: <em>p*exp(-distance/b)</em> <em>b</em> parameter. Represents the breadth of the dispersal between model cells. Typically estimated via average migration distance.</p>
</dd>
<dt><code>dispersal_max_distance</code></dt><dd><p>Dispersal maximum distance or range (<em>r</em>) parameter limits the use of the dispersal function: <em>p*exp(-distance/b)</em>. The function is utilized when <em>distance &lt;= r</em> otherwise the dispersal rate is set to zero.</p>
</dd>
<dt><code>dispersal_index</code></dt><dd><p>Sampled index for the dispersal function data frame (to look-up dispersal function parameters).</p>
</dd>
<dt><code>dispersal_matrix</code></dt><dd><p>Dispersal matrix calculated via dispersal function.</p>
</dd>
<dt><code>dispersal_data</code></dt><dd><p>Data frame of non-zero dispersal rates including indices for the construction of compact matrices (columns: target_pop, source_pop, emigrant_row, immigrant_row, dispersal_rate).</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>generative_template</code></dt><dd><p>A nested <code><a href="#topic+DispersalTemplate">DispersalTemplate</a></code> (or inherited class) object for model attributes that are maintained via shallow or <em>new</em> cloning.</p>
</dd>
<dt><code>generative_requirements</code></dt><dd><p>A list of attribute names and the template setting (<em>&quot;file&quot;</em>, <em>&quot;function&quot;</em>, or <em>&quot;default&quot;</em>) that is required to generate their values.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DispersalGenerator-new"><code>DispersalGenerator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalGenerator-generative_requirements_satisfied"><code>DispersalGenerator$generative_requirements_satisfied()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalGenerator-set_distance_classes"><code>DispersalGenerator$set_distance_classes()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalGenerator-calculate_distance_matrix"><code>DispersalGenerator$calculate_distance_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalGenerator-calculate_distance_data"><code>DispersalGenerator$calculate_distance_data()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalGenerator-calculate_dispersals"><code>DispersalGenerator$calculate_dispersals()</code></a>
</p>
</li>
<li> <p><a href="#method-DispersalGenerator-clone"><code>DispersalGenerator$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_names"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_names'><code>poems::GenericModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="set_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-set_attributes'><code>poems::GenericModel$set_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="add_distribution_template"><a href='../../poems/html/Generator.html#method-Generator-add_distribution_template'><code>poems::Generator$add_distribution_template()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="add_file_template"><a href='../../poems/html/Generator.html#method-Generator-add_file_template'><code>poems::Generator$add_file_template()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="add_function_template"><a href='../../poems/html/Generator.html#method-Generator-add_function_template'><code>poems::Generator$add_function_template()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="add_generative_requirements"><a href='../../poems/html/Generator.html#method-Generator-add_generative_requirements'><code>poems::Generator$add_generative_requirements()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="generate"><a href='../../poems/html/Generator.html#method-Generator-generate'><code>poems::Generator$generate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="get_attributes"><a href='../../poems/html/Generator.html#method-Generator-get_attributes'><code>poems::Generator$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="new_clone"><a href='../../poems/html/Generator.html#method-Generator-new_clone'><code>poems::Generator$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="read_file"><a href='../../poems/html/Generator.html#method-Generator-read_file'><code>poems::Generator$read_file()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="run_function"><a href='../../poems/html/Generator.html#method-Generator-run_function'><code>poems::Generator$run_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Generator" data-id="sample_distribution"><a href='../../poems/html/Generator.html#method-Generator-sample_distribution'><code>poems::Generator$sample_distribution()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DispersalGenerator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets the generative template and requirements, optionally the dispersal friction object, as well as any attributes passed via a <em>params</em> list or individually.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$new(
  generative_template = NULL,
  generative_requirements = NULL,
  dispersal_friction = NULL,
  attribute_aliases = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>generative_template</code></dt><dd><p>Optional nested object for generative attributes that need to be maintained when a new clone object is generated for a sample simulation (usually a ).</p>
</dd>
<dt><code>generative_requirements</code></dt><dd><p>Optional list of attribute names and the template setting (<em>&quot;file&quot;</em> or <em>&quot;function&quot;</em>) that is required to generate their values (otherwise default functionality is used).</p>
</dd>
<dt><code>dispersal_friction</code></dt><dd><p>Optional <code><a href="#topic+DispersalFriction">DispersalFriction</a></code> (or inherited class) object for dispersal distance multiplier data.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>Optional list of extra alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DispersalGenerator-generative_requirements_satisfied"></a>



<h4>Method <code>generative_requirements_satisfied()</code></h4>

<p>Returns a boolean to indicate that all the default, file and/or function template settings that are required for attribute generation are present.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$generative_requirements_satisfied()</pre></div>



<h5>Returns</h5>

<p>Boolean to indicate that the required settings for attribute generation are present.
</p>


<hr>
<a id="method-DispersalGenerator-set_distance_classes"></a>



<h4>Method <code>set_distance_classes()</code></h4>

<p>Sets the distance classes to a sequence of values from minimum to maximum in steps of interval size.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$set_distance_classes(
  minimum = 1,
  maximum = 10,
  interval = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>minimum</code></dt><dd><p>Minimum or first distance class sequence value (default = 1).</p>
</dd>
<dt><code>maximum</code></dt><dd><p>Maximum or last distance class value (default = 10).</p>
</dd>
<dt><code>interval</code></dt><dd><p>Interval or distance class sequence step size  (default = 1).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DispersalGenerator-calculate_distance_matrix"></a>



<h4>Method <code>calculate_distance_matrix()</code></h4>

<p>Returns a matrix with the calculated distance (in meters by default) between each pair of region cells.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$calculate_distance_matrix(use_longlat = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_longlat</code></dt><dd><p>Optional boolean indicating use of (WGS84) coordinates in longitude (degrees West) and latitude (degrees North).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix with distances between region cells.
</p>


<hr>
<a id="method-DispersalGenerator-calculate_distance_data"></a>



<h4>Method <code>calculate_distance_data()</code></h4>

<p>Calculates the distance class for within-range populations using the set/provided distance classes. Also calculates indices for constructing compact matrices.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$calculate_distance_data(distance_matrix = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distance_matrix</code></dt><dd><p>Optional pre-calculated matrix with distances between population cells (population rows by population columns).</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DispersalGenerator-calculate_dispersals"></a>



<h4>Method <code>calculate_dispersals()</code></h4>

<p>Calculates, using the conditional dispersal limiting function for a simulation sample, a dispersal matrix, or a list of data frames of non-zero dispersal rates and indices for constructing a compact dispersal matrix (default), and optional changing rates over time (via <code><a href="#topic+DispersalFriction">DispersalFriction</a></code> object).
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$calculate_dispersals(type = "data")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Optional type selector (<em>&quot;data&quot;</em> or <em>&quot;matrix&quot;</em>) to determine whether to calculate a dispersal matrix or data frame (default).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns character string message when calculation prerequisites are not met (for simulation logging).
</p>


<hr>
<a id="method-DispersalGenerator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalGenerator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)

# Distance-based dispersal generator
dispersal_gen &lt;- DispersalGenerator$new(
  region = region,
  dispersal_max_distance = 3000, # in m
  inputs = c("dispersal_p", "dispersal_b"),
  decimals = 5
)
dispersal_gen$calculate_distance_data() # pre-calculate
dispersal_gen$generate(input_values = list(
  dispersal_p = 0.5,
  dispersal_b = 700
))

</code></pre>

<hr>
<h2 id='DispersalTemplate'>R6 class representing a nested container for dispersal generator attributes</h2><span id='topic+DispersalTemplate'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a nested container for
<code><a href="#topic+DispersalGenerator">DispersalGenerator</a></code> attributes that are maintained when new model clones
are created. The container maintains <em>input</em> and <em>output</em> attribute names,
file, function and distribution templates, correlation parameters (for distribution
generation), rounding decimals, occupancy mask, and other
<code><a href="#topic+DispersalGenerator">DispersalGenerator</a></code> attributes that need to be maintained when cloning.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenerativeTemplate">poems::GenerativeTemplate</a></code> -&gt; <code>DispersalTemplate</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>description</code></dt><dd><p>A brief description of what the generator generates.</p>
</dd>
<dt><code>inputs</code></dt><dd><p>An array of input attribute names for the generator.</p>
</dd>
<dt><code>outputs</code></dt><dd><p>An array of output attribute names for the generator.</p>
</dd>
<dt><code>file_templates</code></dt><dd><p>A nested list of file template attributes.</p>
</dd>
<dt><code>function_templates</code></dt><dd><p>A nested list of function template attributes.</p>
</dd>
<dt><code>distribution_templates</code></dt><dd><p>A list of distribution template attributes.</p>
</dd>
<dt><code>uses_correlations</code></dt><dd><p>A boolean to indicate that a <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object is used for generating correlated random deviates.</p>
</dd>
<dt><code>spatial_correlation</code></dt><dd><p>A <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object for generating correlated random deviates.</p>
</dd>
<dt><code>temporal_correlation</code></dt><dd><p>Absolute correlation coefficient between simulation time steps for all grid cells (0-1; default = 1).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Number of decimal places applied to generated data outputs (default: NULL = no rounding).</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for generated (time-series) data outputs.</p>
</dd>
<dt><code>dispersal_friction</code></dt><dd><p>A <code><a href="#topic+DispersalFriction">DispersalFriction</a></code> (or inherited class) object for dispersal distance multiplier data.</p>
</dd>
<dt><code>distance_classes</code></dt><dd><p>Vector of distance interval boundaries (in km) for calculating discrete dispersal rates.</p>
</dd>
<dt><code>max_distance_classes</code></dt><dd><p>The maximum number of distance classes when they are calculated automatically via the maximum distance (default: 1000).</p>
</dd>
<dt><code>distance_scale</code></dt><dd><p>Scale of distance values in meters (default = 1). Usage: set to 1 for values in meters, or to 1000 for values in kilometers.</p>
</dd>
<dt><code>distance_data</code></dt><dd><p>Data frame of distance classes including indices for the construction of compact matrices (columns: target_pop, source_pop, compact_row, distance_class).</p>
</dd>
<dt><code>dispersal_function_data</code></dt><dd><p>Data frame of discrete dispersal function values. Optional first column may provide distance intervals (non-inclusive lower bounds).</p>
</dd>
<dt><code>dispersal_proportion</code></dt><dd><p>Dispersal function: <em>p*exp(-distance/b)</em> <em>p</em> parameter. Represents the proportion and limit of dispersers between model cells.</p>
</dd>
<dt><code>dispersal_breadth</code></dt><dd><p>Dispersal function: <em>p*exp(-distance/b)</em> <em>b</em> parameter. Represents the breadth of the dispersal between model cells. Typically estimated via average migration distance.</p>
</dd>
<dt><code>dispersal_max_distance</code></dt><dd><p>Dispersal maximum distance or range (<em>r</em>) parameter limits the use of the dispersal function: <em>p*exp(-distance/b)</em>. The function is utilized when <em>distance &lt;= r</em> otherwise the dispersal rate is set to zero.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DispersalTemplate-clone"><code>DispersalTemplate$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenerativeTemplate" data-id="initialize"><a href='../../poems/html/GenerativeTemplate.html#method-GenerativeTemplate-initialize'><code>poems::GenerativeTemplate$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DispersalTemplate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DispersalTemplate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>dispersal_template &lt;- DispersalTemplate$new()
dispersal_template$dispersal_breadth &lt;- 130
dispersal_template$dispersal_proportion &lt;- 0.4
coordinates &lt;- data.frame(x = rep(1:4, 4), y = rep(1:4, each = 4))
dispersal_gen &lt;- DispersalGenerator$new(
  coordinates = coordinates, inputs = c("dispersal_r"),
  generative_template = dispersal_template
)
dispersal_gen$dispersal_breadth
dispersal_gen$dispersal_proportion

</code></pre>

<hr>
<h2 id='GenerativeTemplate'>R6 class representing a nested container for generator attributes</h2><span id='topic+GenerativeTemplate'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a nested container for
<code><a href="#topic+Generator">Generator</a></code> attributes that are maintained when new model clones are
created. The container maintains <em>input</em> and <em>output</em> attribute names,
file, function and distribution templates, correlation parameters (for distribution
generation), rounding decimals, occupancy mask, and any inherited class model
attributes that need to be maintained when cloning.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>description</code></dt><dd><p>A brief description of what the generator generates.</p>
</dd>
<dt><code>inputs</code></dt><dd><p>An array of input attribute names for the generator.</p>
</dd>
<dt><code>outputs</code></dt><dd><p>An array of output attribute names for the generator.</p>
</dd>
<dt><code>file_templates</code></dt><dd><p>A list of file template attributes.</p>
</dd>
<dt><code>function_templates</code></dt><dd><p>A list of function template attributes.</p>
</dd>
<dt><code>distribution_templates</code></dt><dd><p>A list of distribution template attributes.</p>
</dd>
<dt><code>uses_correlations</code></dt><dd><p>A boolean to indicate that a <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object is used for generating correlated random deviates.</p>
</dd>
<dt><code>spatial_correlation</code></dt><dd><p>A <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object for generating correlated random deviates.</p>
</dd>
<dt><code>temporal_correlation</code></dt><dd><p>Absolute correlation coefficient between simulation time steps for all grid cells (0-1; default = 1).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps (default = 1).</p>
</dd>
<dt><code>generate_rasters</code></dt><dd><p>Boolean to indicate if rasters should be generated (default: NULL).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Number of decimal places applied to the generated values (default: NULL = no rounding).</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for generated (time-series) data.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenerativeTemplate-new"><code>GenerativeTemplate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenerativeTemplate-clone"><code>GenerativeTemplate$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenerativeTemplate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method initializes the generator templates.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenerativeTemplate$new()</pre></div>


<hr>
<a id="method-GenerativeTemplate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenerativeTemplate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>gen_template &lt;- GenerativeTemplate$new()
gen_template$occupancy_mask &lt;- array(c(1, 1, 0, 0, 1, 1, 1))
gen_template$decimals &lt;- 4
gen_template$description &lt;- "Test generator"

coordinates &lt;- data.frame(x = c(1:4, 4:2), y = c(1, 1:4, 4:3))

generator &lt;- Generator$new(
  region = Region$new(coordinates = coordinates), attr1 = 1,
  template_attached = gen_template
)
generator$description
generator$occupancy_mask
generator$decimals

</code></pre>

<hr>
<h2 id='Generator'>R6 class representing a dynamic attribute generator</h2><span id='topic+Generator'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a model that dynamically generates
attribute values (<em>outputs</em>) via reading data from files, running assigned
functions, generating sample distributions, or built-in functions (assigned as
<em>default</em> in inherited classes), using simulation sample parameters
(<em>inputs</em>).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code>Generator</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>description</code></dt><dd><p>A brief description of what the generator generates.</p>
</dd>
<dt><code>inputs</code></dt><dd><p>An array of input attribute names for the generator.</p>
</dd>
<dt><code>outputs</code></dt><dd><p>An array of output attribute names for the generator.</p>
</dd>
<dt><code>file_templates</code></dt><dd><p>A nested list of file template attributes.</p>
</dd>
<dt><code>function_templates</code></dt><dd><p>A nested list of function template attributes.</p>
</dd>
<dt><code>distribution_templates</code></dt><dd><p>A list of distribution template attributes.</p>
</dd>
<dt><code>uses_correlations</code></dt><dd><p>A boolean to indicate that a <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object is used for generating correlated random deviates.</p>
</dd>
<dt><code>spatial_correlation</code></dt><dd><p>A <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> (or inherited class) object for generating correlated random deviates.</p>
</dd>
<dt><code>temporal_correlation</code></dt><dd><p>Absolute correlation coefficient between simulation time steps for all grid cells (0-1; default = 1).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>generate_rasters</code></dt><dd><p>Boolean to indicate if rasters should be generated (defaults to TRUE when region uses rasters).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Number of decimal places applied to generated data outputs (default: NULL = no rounding).</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for generated (time-series) data outputs.</p>
</dd>
<dt><code>template_attached</code></dt><dd><p>A list of template-nested dynamically attached model attributes that are maintained via shallow or <em>new</em> cloning.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>generative_template</code></dt><dd><p>A nested <code><a href="#topic+GenerativeTemplate">GenerativeTemplate</a></code> (or inherited class) object for model attributes that are maintained via shallow or <em>new</em> cloning.</p>
</dd>
<dt><code>generative_requirements</code></dt><dd><p>A list of attribute names and the template setting (<em>&quot;file&quot;</em>, <em>&quot;function&quot;</em>, or <em>&quot;default&quot;</em>) that is required to generate their values.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Generator-new"><code>Generator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-new_clone"><code>Generator$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-get_attributes"><code>Generator$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-generate"><code>Generator$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-add_file_template"><code>Generator$add_file_template()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-add_function_template"><code>Generator$add_function_template()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-add_distribution_template"><code>Generator$add_distribution_template()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-read_file"><code>Generator$read_file()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-run_function"><code>Generator$run_function()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-sample_distribution"><code>Generator$sample_distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-add_generative_requirements"><code>Generator$add_generative_requirements()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-generative_requirements_satisfied"><code>Generator$generative_requirements_satisfied()</code></a>
</p>
</li>
<li> <p><a href="#method-Generator-clone"><code>Generator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_names"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_names'><code>poems::GenericModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="set_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-set_attributes'><code>poems::GenericModel$set_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Generator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets the generative template and requirements as well as any attributes passed via a <em>params</em> list or individually.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$new(generative_template = NULL, generative_requirements = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>generative_template</code></dt><dd><p>A <code><a href="#topic+GenerativeTemplate">GenerativeTemplate</a></code> (or inherited class) object containing the file, function and/or distribution templates utilized (facilitates shallow cloning).</p>
</dd>
<dt><code>generative_requirements</code></dt><dd><p>A list of attribute names and the template setting (&quot;file&quot;, &quot;function&quot;, or &quot;distribution&quot;) that is required to generate their values.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Generator-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-Generator-get_attributes"></a>



<h4>Method <code>get_attributes()</code></h4>

<p>Returns a list of existing and template-generated values for selected attributes or attribute aliases (when array of parameter names provided), or all existing attributes (when no params).
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$get_attributes(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Array of attribute names to return, including those to be template-generated (all when NULL).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of selected or all attributes values.
</p>


<hr>
<a id="method-Generator-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Returns a list of generated output values (attributes) corresponding to the sample input values (attributes).
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$generate(input_values = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_values</code></dt><dd><p>List of sample input values for generator attributes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List containing generated model output attributes and/or any error/warning messages.
</p>


<hr>
<a id="method-Generator-add_file_template"></a>



<h4>Method <code>add_file_template()</code></h4>

<p>Adds a file template for reading raster/RData(RDS)/CSV files for a given
model attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$add_file_template(
  param,
  path_template,
  path_params = c(),
  file_type = "GRD"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of model attribute to be read from a file.</p>
</dd>
<dt><code>path_template</code></dt><dd><p>Template string for the file path with placeholders
(see <code><a href="base.html#topic+sprintf">sprintf</a></code>) for simulation sample parameters.</p>
</dd>
<dt><code>path_params</code></dt><dd><p>Array of the names of the simulation sample
parameters to be substituted (in order) into the path template.</p>
</dd>
<dt><code>file_type</code></dt><dd><p>File type raster <em>&quot;GRD&quot;</em> (default), <em>&quot;TIF&quot;</em>,
<em>&quot;RData/RDS&quot;</em>, <em>&quot;QS&quot;</em>, or <em>&quot;CSV&quot;</em> to be read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Generator-add_function_template"></a>



<h4>Method <code>add_function_template()</code></h4>

<p>Adds a function template for running a user-defined function to calculate a given model attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$add_function_template(param, function_def, call_params = c())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of model attribute to be generated using a function.</p>
</dd>
<dt><code>function_def</code></dt><dd><p>Function definition (or path to the file containing the function) in form: <code>function(params)</code>, where <em>params</em> is a list passed to the function.</p>
</dd>
<dt><code>call_params</code></dt><dd><p>Array of the names of the model parameters/attributes to be passed into the function via a list: <em>params</em>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Generator-add_distribution_template"></a>



<h4>Method <code>add_distribution_template()</code></h4>

<p>Adds a distribution template for generating a given model attribute via sampling a distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$add_distribution_template(
  param,
  distr_type = c("uniform", "normal", "lognormal", "beta", "triangular"),
  distr_params = list(),
  sample = NULL,
  random_seed = NULL,
  normalize_threshold = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of model attribute to be generated via sampling a distribution.</p>
</dd>
<dt><code>distr_type</code></dt><dd><p>Distribution type to sample from (uniform, normal, lognormal, beta or triangular).</p>
</dd>
<dt><code>distr_params</code></dt><dd><p>List of distribution parameters and their values or associated model attributes (uniform: lower, upper; normal: mean, sd; lognormal: meanlog, sdlog (or mean, sd); beta: alpha, beta (or mean, sd); triangular: lower, mode, upper).</p>
</dd>
<dt><code>sample</code></dt><dd><p>Model attribute(s) name(s) or values associated with single sample probabilities (0-1), or bounds as a vector (e.g. <code>sample = c("p_lower", "p_upper")</code>), or as a list (e.g. <code>sample = list(mid = "p", window = 0.2)</code> for bounds p +/- 0.1).</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>Random seed utilized when sample probability is generated internally, via bounds, and/or correlated deviates.</p>
</dd>
<dt><code>normalize_threshold</code></dt><dd><p>Optional normalization threshold is utilized when generated values are to be normalized with a fixed upper limit/threshold.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Generator-read_file"></a>



<h4>Method <code>read_file()</code></h4>

<p>Reads and returns the value of a model attribute from a file using the corresponding file template and simulation sample parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$read_file(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of model attribute to be read from the file.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Model attribute value read from a file.
</p>


<hr>
<a id="method-Generator-run_function"></a>



<h4>Method <code>run_function()</code></h4>

<p>Returns the calculated value of a model attribute using the corresponding function template and model simulation sample parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$run_function(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of model attribute to be calculated using a function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Model attribute value calculated using a function.
</p>


<hr>
<a id="method-Generator-sample_distribution"></a>



<h4>Method <code>sample_distribution()</code></h4>

<p>Returns the calculated value of a model attribute using the corresponding distribution template and simulation sample parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$sample_distribution(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of model attribute to be calculated using a sampling distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Model attribute value calculated via distribution sampling.
</p>


<hr>
<a id="method-Generator-add_generative_requirements"></a>



<h4>Method <code>add_generative_requirements()</code></h4>

<p>Adds attribute names and the template setting (<em>&quot;file&quot;</em>, <em>&quot;function&quot;</em> or <em>&quot;distribution&quot;</em>) that is required to generate their values (via a <em>params</em> list or individually).
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$add_generative_requirements(params = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Parameters passed via a list (e.g. <code>params = list(attr1 = "file", attr2 = "function", attr3 = "distribution")</code>).</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed individually (e.g. <code>attr3 = "file"</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Generator-generative_requirements_satisfied"></a>



<h4>Method <code>generative_requirements_satisfied()</code></h4>

<p>Returns a boolean to indicate that all the file, function and/or distribution template settings that are required for attribute generation are present.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$generative_requirements_satisfied()</pre></div>



<h5>Returns</h5>

<p>Boolean to indicate that the required settings for attribute generation are present.
</p>


<hr>
<a id="method-Generator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Generator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
coordinates &lt;- coordinates[c(7, 9, 12, 14, 17:19), ]
region &lt;- Region$new(coordinates = coordinates, use_raster = FALSE)
# Spatial correlation
spatial_correlation &lt;- SpatialCorrelation$new(
  region = region, correlation_amplitude = 0.6,
  correlation_breadth = 300
)
spatial_correlation$calculate_compact_decomposition(decimals = 4)
# Example habitat suitability in file
saveRDS(
  array(c(0.5, 0.3, 0.7, 0.9, 0.6, 0.7, 0.8), c(7, 5)),
  file.path(tempdir(), "hs_mean_1.RData")
)
# Generator
capacity_gen &lt;- Generator$new(
  description = "capacity",
  region = region,
  time_steps = 5,
  spatial_correlation = spatial_correlation,
  temporal_correlation = 0.9,
  hs_sd = 0.1, # template attached
  inputs = c("hs_file", "density_max", "initial_n"),
  outputs = c("initial_abundance", "carrying_capacity")
)
capacity_gen$add_generative_requirements(list(
  hs_mean = "file",
  hs_sample = "distribution",
  carrying_capacity = "function",
  initial_abundance = "function"
))
# File template for mean habitat suitability
capacity_gen$add_file_template("hs_mean",
  path_template = file.path(tempdir(), "hs_mean_%s.RData"),
  path_params = c("hs_file"), file_type = "RDS"
)
# Distribution template for sampling habitat suitability
capacity_gen$add_distribution_template("hs_sample",
  distr_type = "beta",
  distr_params = list(
    mean = "hs_mean",
    sd = "hs_sd"
  )
)
# Function templates for initial abundance and carrying capacity
capacity_gen$add_function_template("initial_abundance",
  function_def = function(params) {
    stats::rmultinom(1,
      size = params$initial_n,
      prob = params$hs_sample[, 1]
    )
  },
  call_params = c("initial_n", "hs_sample")
)
capacity_gen$add_function_template("carrying_capacity",
  function_def = function(params) {
    round(params$density_max * params$hs_sample)
  },
  call_params = c("density_max", "hs_sample")
)
# Generation
capacity_gen$generate(input_values = list(
  hs_file = 1,
  initial_n = 400,
  density_max = 100
))

</code></pre>

<hr>
<h2 id='GenericClass'>R6 class with generic reusable functionality</h2><span id='topic+GenericClass'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class with generic (abstract) new cloning functionality.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>object_generator</code></dt><dd><p>Class object generator used to create new clones, particularly for user inheritance.</p>
</dd>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericClass-new"><code>GenericClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClass-new_clone"><code>GenericClass$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClass-clone"><code>GenericClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenericClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method saves an object generator for new cloning.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClass$new(object_generator = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object_generator</code></dt><dd><p>Class object generator used to create new clones, particularly for user inheritance.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed individually (ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericClass-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClass$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-GenericClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>object1 &lt;- GenericClass$new()
class(object1)
# Referencing
object_ref &lt;- object1
object_ref$attached$a &lt;- 1
object1$attached
# Cloning
object2 &lt;- object1$clone()
object2$attached$b &lt;- 2
object1$attached
object2$attached
# New cloning
object3 &lt;- object1$new_clone()
object3$attached$c &lt;- 3
object1$attached
object3$attached

</code></pre>

<hr>
<h2 id='GenericManager'>R6 class representing a generic manager.</h2><span id='topic+GenericManager'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class to represent a generic (abstract) manager for
generating or processing simulation results, as well as optionally generating values
via generators.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code>GenericManager</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>sample_data</code></dt><dd><p>A data frame of sampled parameters for each simulation/result.</p>
</dd>
<dt><code>generators</code></dt><dd><p>A list of generators (<code><a href="#topic+Generator">Generator</a></code> or inherited class) objects for generating simulation model values.</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>Number of cores for running the simulations in parallel.</p>
</dd>
<dt><code>results_dir</code></dt><dd><p>Results directory path.</p>
</dd>
<dt><code>results_ext</code></dt><dd><p>Result file extension (default is .RData).</p>
</dd>
<dt><code>results_filename_attributes</code></dt><dd><p>A vector of: prefix (optional); attribute names (from the sample data frame); postfix (optional); utilized to construct results filenames.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericManager-new"><code>GenericManager$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericManager-get_attribute"><code>GenericManager$get_attribute()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericManager-get_message_sample"><code>GenericManager$get_message_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericManager-get_results_filename"><code>GenericManager$get_results_filename()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericManager-clone"><code>GenericManager$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericClass" data-id="new_clone"><a href='../../poems/html/GenericClass.html#method-GenericClass-new_clone'><code>poems::GenericClass$new_clone()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GenericManager-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets any included attributes (<em>sample_data</em>, <em>generators</em>, <em>parallel_cores</em>, <em>results_dir</em>, <em>results_filename_attributes</em>) and attaches other attributes individually listed.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericManager$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters listed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericManager-get_attribute"></a>



<h4>Method <code>get_attribute()</code></h4>

<p>Returns a named manager or attached attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericManager$get_attribute(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Character string name of the attribute.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Selected attribute value.
</p>


<hr>
<a id="method-GenericManager-get_message_sample"></a>



<h4>Method <code>get_message_sample()</code></h4>

<p>Substitutes the specified sample details into a status message (using sprintf) and returns the result.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericManager$get_message_sample(status_message, sample_index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status_message</code></dt><dd><p>Character string message with a placeholder for sample details.</p>
</dd>
<dt><code>sample_index</code></dt><dd><p>Row index of sample data frame containing details of substitution parameters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Status message with substituted sample details.
</p>


<hr>
<a id="method-GenericManager-get_results_filename"></a>



<h4>Method <code>get_results_filename()</code></h4>

<p>Constructs and returns the results filename based on the sample data frame index and results filename attributes.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericManager$get_results_filename(sample_index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample_index</code></dt><dd><p>Row index of sample data frame containing details of substitution parameters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Results filename with substituted sample details.
</p>


<hr>
<a id="method-GenericManager-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericManager$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>generic_manager &lt;- GenericManager$new(
 attr1 = 22:23,
 results_filename_attributes = c("attr1", "example")
)
generic_manager$get_results_filename(1)
generic_manager$get_results_filename(2)

</code></pre>

<hr>
<h2 id='GenericModel'>R6 class representing a generic model.</h2><span id='topic+GenericModel'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class with generic (abstract) functionality for toolset
models, including model attribute get and set methods that resolve attribute scope
(<em>public</em>, <em>active</em>, <em>attached</em>), attribute aliases, attribute
attachment, and error and warning message attributes.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code>GenericModel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericModel-new"><code>GenericModel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-new_clone"><code>GenericModel$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-get_attribute_names"><code>GenericModel$get_attribute_names()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-get_attributes"><code>GenericModel$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-get_attribute"><code>GenericModel$get_attribute()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-get_attribute_aliases"><code>GenericModel$get_attribute_aliases()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-set_attributes"><code>GenericModel$set_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModel-clone"><code>GenericModel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenericModel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets given attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$new(
  model_attributes = NULL,
  attribute_aliases = NULL,
  params = list(),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>params</code></dt><dd><p>Parameters passed via a list.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericModel-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-GenericModel-get_attribute_names"></a>



<h4>Method <code>get_attribute_names()</code></h4>

<p>Returns an array of all attribute names including public and private model attributes, as well as attached attributes, error and warning messages.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$get_attribute_names()</pre></div>



<h5>Returns</h5>

<p>Array of all attribute names.
</p>


<hr>
<a id="method-GenericModel-get_attributes"></a>



<h4>Method <code>get_attributes()</code></h4>

<p>Returns a list of values for selected attributes or attribute aliases (when array of parameter names provided) or all attributes (when no params).
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$get_attributes(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Array of attribute names to return (all when NULL).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of selected or all attributes values.
</p>


<hr>
<a id="method-GenericModel-get_attribute"></a>



<h4>Method <code>get_attribute()</code></h4>

<p>Returns the value of an attribute via character name or attribute alias.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$get_attribute(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Character string name of the attribute.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Attribute value.
</p>


<hr>
<a id="method-GenericModel-get_attribute_aliases"></a>



<h4>Method <code>get_attribute_aliases()</code></h4>

<p>Returns an array of attribute names and aliases for specified or all attributes.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$get_attribute_aliases(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Array of attribute names for names/aliases to return (all when NULL).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Array of selected or all attribute names and aliases.
</p>


<hr>
<a id="method-GenericModel-set_attributes"></a>



<h4>Method <code>set_attributes()</code></h4>

<p>Sets given attributes (optionally via alias names) individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$set_attributes(params = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>List of parameters/attributes.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters/attributes passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>model1 &lt;- GenericModel$new(
  model_attributes = c("a", "b", "c"),
  attribute_aliases = list(A = "a"),
  params = list(a = 1, b = 2), c = 3
)
# Get/set attributes
model1$get_attribute_names()
model1$set_attributes(d = 4)
model1$get_attributes()
model1$get_attribute("A")
model1$get_attribute("B")
model1$get_attribute_aliases() # all attribute names
# New cloning
model2 &lt;- model1$new_clone(e = 5)
model2$get_attributes()
model2$modelattributes
model2$attribute_aliases

</code></pre>

<hr>
<h2 id='LatinHypercubeSampler'>R6 class to represent a Latin hypercube sampler.</h2><span id='topic+LatinHypercubeSampler'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class that generates Latin hypercube samples (using
<code><a href="lhs.html#topic+randomLHS">randomLHS</a></code>) for parameters drawn from configured
distributions: <code><a href="stats.html#topic+Uniform">uniform</a></code>, <code><a href="stats.html#topic+Poisson">Poisson</a></code>,
<code><a href="stats.html#topic+Normal">normal</a></code>, <code><a href="stats.html#topic+Lognormal">lognormal</a></code>,
<code><a href="stats.html#topic+Beta">beta</a></code>, <code><a href="truncnorm.html#topic+qtruncnorm">truncated normal</a></code> or
<code><a href="metRology.html#topic+qtri">triangular</a></code>.
It generates a data frame of sample values.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code>LatinHypercubeSampler</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>parameter_names</code></dt><dd><p>A vector of sample parameter names.</p>
</dd>
<dt><code>parameter_distributions</code></dt><dd><p>A list of sample distribution values (nested list with appropriate parameters).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LatinHypercubeSampler-new"><code>LatinHypercubeSampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_class_parameter"><code>LatinHypercubeSampler$set_class_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_uniform_parameter"><code>LatinHypercubeSampler$set_uniform_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_normal_parameter"><code>LatinHypercubeSampler$set_normal_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_poisson_parameter"><code>LatinHypercubeSampler$set_poisson_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_lognormal_parameter"><code>LatinHypercubeSampler$set_lognormal_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_beta_parameter"><code>LatinHypercubeSampler$set_beta_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_truncnorm_parameter"><code>LatinHypercubeSampler$set_truncnorm_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-set_triangular_parameter"><code>LatinHypercubeSampler$set_triangular_parameter()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-generate_samples"><code>LatinHypercubeSampler$generate_samples()</code></a>
</p>
</li>
<li> <p><a href="#method-LatinHypercubeSampler-clone"><code>LatinHypercubeSampler$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericClass" data-id="new_clone"><a href='../../poems/html/GenericClass.html#method-GenericClass-new_clone'><code>poems::GenericClass$new_clone()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LatinHypercubeSampler-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets parameter names when provided.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$new(parameter_names = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_names</code></dt><dd><p>Optional vector of sample parameter names.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_class_parameter"></a>



<h4>Method <code>set_class_parameter()</code></h4>

<p>Sets a parameter to sampled from a vector of classes.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_class_parameter(parameter_name, classes)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>classes</code></dt><dd><p>Vector of class values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_uniform_parameter"></a>



<h4>Method <code>set_uniform_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="stats.html#topic+Uniform">uniform</a></code> distribution with lower and upper bounds, optionally rounded to a specified number of decimal places.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_uniform_parameter(
  parameter_name,
  lower = 0,
  upper = 1,
  decimals = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the uniform distribution (default = 0).</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the uniform distribution (default = 1).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimals applied to generated samples.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_normal_parameter"></a>



<h4>Method <code>set_normal_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="stats.html#topic+Normal">normal</a></code> distribution with mean and standard deviation, optionally rounded to a specified number of decimal places.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_normal_parameter(
  parameter_name,
  mean = 0,
  sd = 1,
  decimals = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>mean</code></dt><dd><p>Mean parameter for the normal distribution (default = 0).</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation parameter for the normal distribution (default = 1).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimals applied to generated samples.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_poisson_parameter"></a>



<h4>Method <code>set_poisson_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="stats.html#topic+Poisson">Poisson</a></code> distribution with lambda parameter. Produces integers.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_poisson_parameter(parameter_name, lambda = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Lambda parameter for the Poisson distribution. Must be positive (default = 1).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_lognormal_parameter"></a>



<h4>Method <code>set_lognormal_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="stats.html#topic+Lognormal">lognormal</a></code> distribution with log mean and log standard deviation, optionally expressed as regular mean and SD (overriding log mean/sd), and optionally rounded to a specified number of decimal places.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_lognormal_parameter(
  parameter_name,
  meanlog = 0,
  sdlog = 1,
  mean = NULL,
  sd = NULL,
  decimals = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>meanlog</code></dt><dd><p>Log mean parameter for the lognormal distribution (default = 0).</p>
</dd>
<dt><code>sdlog</code></dt><dd><p>Log standard deviation parameter for the lognormal distribution (default = 1).</p>
</dd>
<dt><code>mean</code></dt><dd><p>Optional (overriding) regular mean parameter for the lognormal distribution (default = NULL).</p>
</dd>
<dt><code>sd</code></dt><dd><p>Optional (overriding) standard deviation parameter for the lognormal distribution (default = NULL).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimals applied to generated samples.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_beta_parameter"></a>



<h4>Method <code>set_beta_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="stats.html#topic+Beta">beta</a></code> distribution configured with alpha and beta parameters, or optionally with mean and standard deviation (overriding alpha and beta), and optionally rounded to a specified number of decimal places.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_beta_parameter(
  parameter_name,
  alpha = 1,
  beta = 1,
  mean = NULL,
  sd = NULL,
  decimals = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Shaping (towards 1) parameter (&gt; 0) for the beta distribution (default = 1).</p>
</dd>
<dt><code>beta</code></dt><dd><p>Shaping (towards 0) parameter (&gt; 0) for the beta distribution (default = 1).</p>
</dd>
<dt><code>mean</code></dt><dd><p>Optional (overriding) mean parameter for the beta distribution (default = NULL).</p>
</dd>
<dt><code>sd</code></dt><dd><p>Optional (overriding) standard deviation parameter for the beta distribution (default = NULL).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimals applied to generated samples.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_truncnorm_parameter"></a>



<h4>Method <code>set_truncnorm_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="truncnorm.html#topic+qtruncnorm">truncated normal</a></code> distribution with mean, standard deviation, and lower and upper bounds, optionally rounded to a specified number of decimal places.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_truncnorm_parameter(
  parameter_name,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  decimals = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>mean</code></dt><dd><p>Mean parameter of the truncated normal distribution (default = 0).</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation of the truncated normal distribution (default = 1).</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the truncated normal distribution (default = -Inf, meaning no lower bound).</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the truncated normal distribution (default = Inf, meaning no upper bound).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimals that generated samples are rounded to.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-set_triangular_parameter"></a>



<h4>Method <code>set_triangular_parameter()</code></h4>

<p>Sets a parameter to be sampled from a <code><a href="metRology.html#topic+qtri">triangular</a></code> distribution with lower and upper bounds and mode (peak), optionally rounded to a specified number of decimal places.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$set_triangular_parameter(
  parameter_name,
  lower = 0,
  upper = 1,
  mode = (lower + upper)/2,
  decimals = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_name</code></dt><dd><p>Character string name of sample parameter.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the triangular distribution (default = 0).</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the triangular distribution (default = 1).</p>
</dd>
<dt><code>mode</code></dt><dd><p>Mode (or peak) of the triangular distribution (default = (lower + upper)/2).</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimals applied to generated samples.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LatinHypercubeSampler-generate_samples"></a>



<h4>Method <code>generate_samples()</code></h4>

<p>Generates Latin hypercube sample data (via <code><a href="lhs.html#topic+randomLHS">randomLHS</a></code>) for the set parameters using corresponding distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$generate_samples(number = 10, random_seed = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>number</code></dt><dd><p>Number of samples to generate (default = 10).</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>Optional seed for the random generation of samples.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of generated sample values.
</p>


<hr>
<a id="method-LatinHypercubeSampler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatinHypercubeSampler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>lhs_gen &lt;- LatinHypercubeSampler$new(parameter_names = c("size", "age", "km", "price"))
lhs_gen$set_class_parameter("size", c("small", "medium", "large"))
lhs_gen$set_uniform_parameter("age", lower = 18, upper = 70, decimals = 0)
lhs_gen$set_poisson_parameter("offspring", lambda = 2)
lhs_gen$set_normal_parameter("km", mean = 50000, sd = 20000, decimals = 0)
lhs_gen$set_truncnorm_parameter("kg", mean = 75, sd = 20, lower = 0, upper = Inf, decimals = 2)
lhs_gen$set_lognormal_parameter("price", mean = 30000, sd = 10000, decimals = 0)
lhs_gen$set_beta_parameter("tread", mean = 0.7, sd = 0.1, decimals = 2)
lhs_gen$set_triangular_parameter("rating",
  lower = 0, upper = 10, mode = 5,
  decimals = 1
)
lhs_gen$generate_samples(number = 10, random_seed = 123)

</code></pre>

<hr>
<h2 id='ModelSimulator'>R6 class representing a model simulator.</h2><span id='topic+ModelSimulator'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class for running individual model simulations via a
simulation function, storing results, and generating success/error statuses.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code>ModelSimulator</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>simulation_model</code></dt><dd><p>A SimulationModel object or an inherited class object.</p>
</dd>
<dt><code>simulation_function</code></dt><dd><p>Name (character string) or direct assignment (assigned or loaded via source path) of the simulation function, which takes a <code><a href="#topic+SimulationModel">SimulationModel</a></code> (or inherited class) as an input and returns the simulation results.</p>
</dd>
<dt><code>sample_id</code></dt><dd><p>An identifier for the simulation sample.</p>
</dd>
<dt><code>results</code></dt><dd><p>A list of result structures.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ModelSimulator-new"><code>ModelSimulator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ModelSimulator-new_clone"><code>ModelSimulator$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-ModelSimulator-get_attribute"><code>ModelSimulator$get_attribute()</code></a>
</p>
</li>
<li> <p><a href="#method-ModelSimulator-run"><code>ModelSimulator$run()</code></a>
</p>
</li>
<li> <p><a href="#method-ModelSimulator-clone"><code>ModelSimulator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ModelSimulator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets the population model, and optionally the simulation function, the sample ID, and any attached attributes listed individually.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModelSimulator$new(
  simulation_model = NULL,
  simulation_function = NULL,
  sample_id = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation_model</code></dt><dd><p>A <code><a href="#topic+SimulationModel">SimulationModel</a></code> (or inherited class) object (can be set later).</p>
</dd>
<dt><code>simulation_function</code></dt><dd><p>Optional name (character string) or direct assignment (assigned or loaded via source path) of the simulation function, which takes a <code><a href="#topic+SimulationModel">SimulationModel</a></code> (or inherited class) as an input and returns the simulation results.</p>
</dd>
<dt><code>sample_id</code></dt><dd><p>Optional identifier for the simulation sample.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed individually are attached.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ModelSimulator-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModelSimulator$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-ModelSimulator-get_attribute"></a>



<h4>Method <code>get_attribute()</code></h4>

<p>Returns selected named simulator or attached attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModelSimulator$get_attribute(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>Name of the parameter/attribute.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Selected parameter/attribute value.
</p>


<hr>
<a id="method-ModelSimulator-run"></a>



<h4>Method <code>run()</code></h4>

<p>Runs a model simulator (function), stores the results, and creates a status log entry as a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModelSimulator$run()</pre></div>



<h5>Returns</h5>

<p>A list representing a simulation log entry with a <em>successful</em> boolean and a status message template (with a placeholder for the sample identifier).
</p>


<hr>
<a id="method-ModelSimulator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModelSimulator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Simulation model
model1 &lt;- SimulationModel$new(
  time_steps = 10,
  model_attributes = c("time_steps", "a", "b"),
  params = list(a = 1:7)
)
model1$required_attributes &lt;- model1$model_attributes
# Simulation function
test_simulator &lt;- function(model) {
  sum(unlist(model$get_attributes(model$required_attributes)))
}
# Model simulator
simulator1 &lt;- ModelSimulator$new(
  simulation_model = model1,
  simulation_function = test_simulator
)
simulator1$run()
model1$set_attributes(a = 1:10, b = 15)
model1$get_attributes(model1$required_attributes)
simulator1$run()
simulator1$results

</code></pre>

<hr>
<h2 id='poems'>poems: Pattern-oriented ensemble modeling and simulation</h2><span id='topic+poems'></span>

<h3>Description</h3>

<p>The <em>poems</em> package provides a framework of interoperable
<code><a href="R6.html#topic+R6Class">R6</a></code> classes for building ensembles of viable models via the
pattern-oriented modeling (POM) approach (Grimm et al., 2005). The package includes
classes for encapsulating and generating model parameters, and managing the POM
workflow. The workflow includes: model setup; generating model parameters via
Latin hypercube sampling; running multiple sampled model simulations; collating
summary results; and validating and selecting an ensemble of models that best match
known patterns. By default, model validation and selection utilizes an approximate
Bayesian computation (ABC) approach (Beaumont, Zhang, &amp; Balding, 2002), although
alternative user-defined functionality could be employed. The package also includes
a spatially explicit demographic population model simulation engine, which includes
default functionality for density dependence, correlated environmental stochasticity,
stage-based transitions, and distance-based dispersal. The user may customize the
simulator by defining functionality for translocations, harvesting, mortality,
and other processes, as well as defining the sequence order for the simulator
processes. The framework could also be adapted for use with other model simulators
by utilizing its extendable (inheritable) base classes.
</p>


<h3>Framework and workflow</h3>

<p>The <em>poems</em> framework utilizes a hierarchy  of extendable (inheritable)
<code><a href="R6.html#topic+R6Class">R6</a></code> class objects that work together to manage a POM
workflow for building an ensemble of simulation models.

<img src="../help/figures/framework.png" alt="framework.png" />
</p>
<p> The workflow is summarized in the following steps:
</p>
<ol>
<li><p> Create a simulation model template (a <code><a href="#topic+SimulationModel">SimulationModel</a></code> or
inherited class object) with appropriate fixed parameters for the study domain.
Also define a study region via the <code><a href="#topic+Region">Region</a></code> class if the
simulations are to be spatially explicit.
</p>
</li>
<li><p> Create generators (<code><a href="#topic+Generator">Generator</a></code> or inherited class objects) for
dynamically generating (non-singular) model parameters represented by data
structures, such as arrays or lists.
</p>
</li>
<li><p> Generate a data frame of sampled variable model parameters using the
<code><a href="#topic+LatinHypercubeSampler">LatinHypercubeSampler</a></code>. This will include singular model parameter
values as well as input parameters for the generators.
</p>
</li>
<li><p> Create a <code><a href="#topic+SimulationManager">SimulationManager</a></code> object configured with the
simulation model (template), the generators, and the sample parameter data
frame. Running this manager sets and runs the models via the simulator function
for each set (row) of sampled parameters, utilising the generators when
required. The results of each model simulation run are written to a file. A
simulation log file is also created.
</p>
</li>
<li><p> Create a <code><a href="#topic+ResultsManager">ResultsManager</a></code> object configured with the sample
parameter data and result file details. Running this manager constructs a data
frame of configured summary metrics, one row for each simulation result file.
The manager utilizes the <code><a href="#topic+SimulationResults">SimulationResults</a></code> (or inherited) class
to encapsulate, and dynamically generate additional derived, results. The
metrics are generated via user-defined specifications and functions for
calculating each metric from the results (objects).
</p>
</li>
<li><p> Create a <code><a href="#topic+Validator">Validator</a></code> object configured with the sample
parameter data, summary metrics, and target (observed) pattern values for each
metric. By default, the validator utilizes an approximate Bayesian computation
(ABC) validation method via the <code><a href="abc.html#topic+abc">abc</a></code> library, although
the validator (call) function can be configured to utilize other library or
user-defined functions. Running the validator (with appropriate call function
configuration) produces an ensemble of models (indices to sampled parameters)
that were found to best match the targets. Diagnostic outputs may also be
produced (depending on the call function and its configuration).
</p>
</li>
<li><p> The selected models may then be utilized for further studies, such as
alternative model scenarios or counterfactuals. This can be achieved by
utilizing the selected subset of parameter samples to form inputs for further
model simulations (by repeating the steps above).
</p>
</li></ol>



<h3>Population modeling components</h3>

<p> The spatially explicit demographic population model
simulation engine and its associated classes are summarized by the following:
</p>
<ul>
<li> <p><code><a href="#topic+population_simulator">population_simulator</a></code> function: The simulation engine's main
function processes the model input parameters, controls the flow, calling other
function modules as required, and returns the results of each simulation.
</p>
</li>
<li> <p><code><a href="#topic+population_density">population_density</a></code> function: Module for configuring
and performing density dependence calculations at each simulation time step.
A user-defined function may be utilized.
</p>
</li>
<li> <p><code><a href="#topic+population_env_stoch">population_env_stoch</a></code> function: Module for configuring and
stochastically applying environmental variability to stage-based population
transition rates at each simulation time step.
</p>
</li>
<li> <p><code><a href="#topic+population_transitions">population_transitions</a></code> function: Module for configuring and
performing stage-based demographic transitions of population abundances at each
simulation time step.
</p>
</li>
<li> <p><code><a href="#topic+population_transformation">population_transformation</a></code> function: Module for configuring and
performing user-defined transformations to staged population abundances. This
functionality is utilized when defining functions for <code>translocation</code>,
<code>harvest</code>, <code>mortality</code>, or other custom transformative functions.
</p>
</li>
<li> <p><code><a href="#topic+population_dispersal">population_dispersal</a></code> function: Module for configuring and
performing dispersal calculations at each simulation time step. A user-defined
function may be utilized.
</p>
</li>
<li> <p><code><a href="#topic+population_results">population_results</a></code> function: Module for configuring,
initializing, and collating simulation results.
</p>
</li>
<li> <p><code><a href="#topic+PopulationModel">PopulationModel</a></code> class: Inherited from
<code><a href="#topic+SimulationModel">SimulationModel</a></code>, this class encapsulates the input parameters
utilized by the <code><a href="#topic+population_simulator">population_simulator</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> class: This simple
<code><a href="R6.html#topic+R6Class">R6</a></code> class enables user-defined functionality to maintain
persistent (attached) attributes and to write to the simulator results.
</p>
</li>
<li> <p><code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> class: Provides functionality for
generating parameters that can be utilized when optionally applying a spatial
correlation within the simulator's environmental variability calculations.
</p>
</li>
<li> <p><code><a href="#topic+DispersalGenerator">DispersalGenerator</a></code> class: Inherited from
<code><a href="#topic+Generator">Generator</a></code>, this class provides functionality for generating
distance-based dispersal parameters that can be utilized when performing
dispersal calculations.
</p>
</li>
<li> <p><code><a href="#topic+DispersalFriction">DispersalFriction</a></code> class: Provides functionality for
adjusting the (equivalent) distance between population cells given a
spatio-temporal frictional landscape. These adjustments may be utilized by the
<code><a href="#topic+DispersalGenerator">DispersalGenerator</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+PopulationResults">PopulationResults</a></code> class: Inherited from
<code><a href="#topic+SimulationResults">SimulationResults</a></code>, this class encapsulates the results generated
by the <code><a href="#topic+population_simulator">population_simulator</a></code>, as well as dynamically generating
additional derived results.
</p>
</li></ul>



<h3>References</h3>

<p>Beaumont, M. A., Zhang, W., &amp; Balding, D. J. (2002). 'Approximate Bayesian
computation in population genetics'. <em>Genetics</em>, vol. 162, no. 4, pp, 20252035.
</p>
<p>Grimm, V., Revilla, E., Berger, U., Jeltsch, F., Mooij, W. M., Railsback, S. F.,
Thulke, H. H., Weiner, J., Wiegand, T., DeAngelis, D. L., (2005). 'Pattern-Oriented
Modeling of Agent-Based Complex Systems: Lessons from Ecology'. <em>Science</em>
vol. 310, no. 5750, pp. 987991.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here we demonstrate building and running a simple population model. For a
# demonstration of the POM workflow with the model, see vignette("simple_example").

# Demonstration example region (U Island) and initial abundance
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
initial_abundance &lt;- seq(0, 300, 50)
raster::plot(region$raster_from_values(initial_abundance),
  main = "Initial abundance", xlab = "Longitude (degrees)",
  ylab = "Latitude (degrees)", zlim = c(0, 300), colNA = "blue"
)

# Set population model
pop_model &lt;- PopulationModel$new(
  region = region,
  time_steps = 5,
  populations = 7,
  initial_abundance = initial_abundance,
  stage_matrix = matrix(c(
    0, 2.5, # Leslie/Lefkovitch matrix
    0.8, 0.5
  ), nrow = 2, ncol = 2, byrow = TRUE),
  carrying_capacity = rep(200, 7),
  density_dependence = "logistic",
  dispersal = (!diag(nrow = 7, ncol = 7)) * 0.05,
  result_stages = c(1, 2)
)

# Run single simulation
results &lt;- population_simulator(pop_model)
results # examine
raster::plot(region$raster_from_values(results$abundance[, 5]),
  main = "Final abundance", xlab = "Longitude (degrees)",
  ylab = "Latitude (degrees)", zlim = c(0, 300), colNA = "blue"
)

</code></pre>

<hr>
<h2 id='population_density'>Nested functions for population density dependence.</h2><span id='topic+population_density'></span>

<h3>Description</h3>

<p>Modular functions for the population simulator for performing density dependent
adjustments to transition rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_density(
  populations,
  stage_matrix,
  fecundity_mask,
  fecundity_max,
  density_dependence,
  growth_rate_max,
  density_affects,
  density_stages,
  density_precision,
  simulator
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_density_+3A_populations">populations</code></td>
<td>
<p>Number of populations.</p>
</td></tr>
<tr><td><code id="population_density_+3A_stage_matrix">stage_matrix</code></td>
<td>
<p>Matrix of transition (fecundity &amp; survival) rates between stages at each time step (Leslie/Lefkovitch matrix).</p>
</td></tr>
<tr><td><code id="population_density_+3A_fecundity_mask">fecundity_mask</code></td>
<td>
<p>Matrix of 0-1 to indicate which (proportions) of transition rates refer to fecundity.</p>
</td></tr>
<tr><td><code id="population_density_+3A_fecundity_max">fecundity_max</code></td>
<td>
<p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</td></tr>
<tr><td><code id="population_density_+3A_density_dependence">density_dependence</code></td>
<td>
<p>Density dependence can be &quot;ceiling&quot; (default), &quot;logistic&quot; (Ricker), or a user-defined function (optionally nested in a list with additional attributes) for adjusting transition rates: <code>function(params)</code>, where <em>params</em> is a list passed to the function containing:
</p>

<dl>
<dt><code>transition_array</code></dt><dd><p>3D array of transition rates: stages by stages by populations.</p>
</dd>
<dt><code>fecundity_mask</code></dt><dd><p>Matrix of 0-1 to indicate which (proportions) of transition rates refer to fecundity.</p>
</dd>
<dt><code>fecundity_max</code></dt><dd><p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundance for each stage (rows) and population (columns).</p>
</dd>
<dt><code>population_abundance</code></dt><dd><p>Array of summed population abundances for all stages.</p>
</dd>
<dt><code>density_abundance</code></dt><dd><p>Array of summed population abundances for stages affected by density.</p>
</dd>
<dt><code>growth_rate_max</code></dt><dd><p>Maximum growth rate value or array for populations.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at (current) time step.</p>
</dd>
<dt><code>calculate_multipliers</code></dt><dd><p>Function (<code>function(growth_rates)</code>) for finding multipliers (when stages &gt; 1) to apply to affected transitions that result in target growth rates (dominant eigenvalues).</p>
</dd>
<dt><code>apply_multipliers</code></dt><dd><p>Function (<code>function(transition_array, multipliers</code>) for applying (when stages &gt; 1) multipliers to the affected transition rates within a transition array (returns multiplied transition array).</p>
</dd>
<dt><code>simulator</code></dt><dd><p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</dd>
<dt><code>additional attributes</code></dt><dd><p>Additional attributes when density dependence is optionally nested in a list.</p>
</dd>
</dl>

<p>returns an adjusted transition array for occupied populations</p>
</td></tr>
<tr><td><code id="population_density_+3A_growth_rate_max">growth_rate_max</code></td>
<td>
<p>Maximum growth rate (utilized by density dependence processes).</p>
</td></tr>
<tr><td><code id="population_density_+3A_density_affects">density_affects</code></td>
<td>
<p>Matrix of booleans or numeric (0-1) indicating the transition vital rates affected by density (default is all).</p>
</td></tr>
<tr><td><code id="population_density_+3A_density_stages">density_stages</code></td>
<td>
<p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density (default is all).</p>
</td></tr>
<tr><td><code id="population_density_+3A_density_precision">density_precision</code></td>
<td>
<p>Numeric precision of the calculated multipliers (used when stages &gt; 1) applied to affected transition rates (default is 3 decimal places).</p>
</td></tr>
<tr><td><code id="population_density_+3A_simulator">simulator</code></td>
<td>
<p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density dependent calculation function, either:
</p>

<dl>
<dt><code>function(carrying_capacity, stage_abundance)</code></dt><dd><p>For ceiling density dependence function, OR</p>
</dd>
<dt><code>function(transition_array, carrying_capacity, stage_abundance, occupied_indices)</code></dt><dd><p>For user-defined density dependence function, where:
</p>

<dl>
<dt><code>transition_array</code></dt><dd><p>3D array of transition rates: stages by stages by populations.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundance for each stage (rows) and population (columns).</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Ceiling density dependence
stage_matrix &lt;- array(c(0, 0.5, 0, 3, 0, 0.7, 4, 0, 0.8), c(3, 3))
fecundity_mask &lt;- array(c(0, 0, 0, 1, 0, 0, 1, 0, 0), c(3, 3))
simulator &lt;- SimulatorReference$new()
density_function &lt;- population_density(
 populations = 7, stage_matrix = stage_matrix, fecundity_mask = fecundity_mask,
 fecundity_max = NULL, density_dependence = "ceiling",
 growth_rate_max = NULL, density_affects = NULL, density_stages = c(0, 1, 1),
 density_precision = NULL, simulator = simulator
)
carrying_capacity &lt;- rep(10, 7)
stage_abundance &lt;- matrix(c(
 7, 13, 0, 26, 0, 39, 47,
 2, 0, 6, 8, 0, 12, 13,
 0, 3, 4, 6, 0, 9, 10
), nrow = 3, ncol = 7, byrow = TRUE)

# Life cycle stages 2 and 3 (rows 2 and 3) all add up to 10 or less
density_function(carrying_capacity, stage_abundance)

</code></pre>

<hr>
<h2 id='population_dispersal'>Nested functions for population dispersal.</h2><span id='topic+population_dispersal'></span>

<h3>Description</h3>

<p>Modular functions for the population simulator for performing dispersal of stage
abundance at a specified time step via dispersal rates provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_dispersal(
  replicates,
  time_steps,
  years_per_step,
  populations,
  demographic_stochasticity,
  density_stages,
  dispersal,
  dispersal_stages,
  dispersal_source_n_k = NULL,
  dispersal_target_k = NULL,
  dispersal_target_n = NULL,
  dispersal_target_n_k = NULL,
  simulator
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_dispersal_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicate simulation runs.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_time_steps">time_steps</code></td>
<td>
<p>Number of simulation time steps.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_years_per_step">years_per_step</code></td>
<td>
<p>Number of years per time step.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_populations">populations</code></td>
<td>
<p>Number of populations.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_demographic_stochasticity">demographic_stochasticity</code></td>
<td>
<p>Boolean for optionally choosing demographic stochasticity for the transformation.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_density_stages">density_stages</code></td>
<td>
<p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_dispersal">dispersal</code></td>
<td>
<p>Either a matrix of dispersal rates between populations (source columns to target rows) or a list of data frames of non-zero dispersal rates and indices for constructing a compact dispersal matrix, and optional changing rates over time (as per class <code><a href="#topic+DispersalGenerator">DispersalGenerator</a></code> <em>dispersal_data</em> attribute). Alternatively a user-defined function (optionally nested in a list with additional attributes) may be used: <code>function(params)</code>, where <em>params</em> is a list passed to the function containing:
</p>

<dl>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of populations.</p>
</dd>
<dt><code>stages</code></dt><dd><p>Number of life cycle stages.</p>
</dd>
<dt><code>demographic_stochasticity</code></dt><dd><p>Boolean for optionally choosing demographic stochasticity for the transformation.</p>
</dd>
<dt><code>density_stages</code></dt><dd><p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density.</p>
</dd>
<dt><code>dispersal_stages</code></dt><dd><p>Array of relative dispersal (0-1) for each stage to indicate the degree to which each stage participates in dispersal.</p>
</dd>
<dt><code>dispersal_source_n_k</code></dt><dd><p>Dispersal proportion (p) density dependence via source population abundance divided by carrying capacity (n/k), where p is reduced via a linear slope (defined by two list items) from n/k &lt;= <em>cutoff</em> (p = 0) to n/k &gt;= <em>threshold</em>.</p>
</dd>
<dt><code>dispersal_target_k</code></dt><dd><p>Dispersal rate (r) density dependence via target population carrying capacity (k), where r is reduced via a linear slope (through the origin) when k &lt;= <em>threshold</em>.</p>
</dd>
<dt><code>dispersal_target_n</code></dt><dd><p>Dispersal rate (r) density dependence via target population abundance (n), where r is reduced via a linear slope (defined by two list items) from n &gt;= <em>threshold</em> to n &lt;= <em>cutoff</em> (r = 0) or vice versa.</p>
</dd>
<dt><code>dispersal_target_n_k</code></dt><dd><p>Dispersal rate (r) density dependence via target population abundance divided by carrying capacity (n/k), where r is reduced via a linear slope (defined by two list items) from n/k &gt;= <em>threshold</em> to n/k &lt;= <em>cutoff</em> (r = 0) or vice versa.</p>
</dd>
<dt><code>r</code></dt><dd><p>Simulation replicate.</p>
</dd>
<dt><code>tm</code></dt><dd><p>Simulation time step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population at time step.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundance for each stage (rows) and population (columns) at time step.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at time step.</p>
</dd>
<dt><code>simulator</code></dt><dd><p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</dd>
<dt><code>additional attributes</code></dt><dd><p>Additional attributes when the transformation is optionally nested in a list.</p>
</dd>
</dl>

<p>returns the post-dispersal abundance matrix</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_dispersal_stages">dispersal_stages</code></td>
<td>
<p>Array of relative dispersal (0-1) for each stage to indicate the degree to which each stage participates in dispersal (default is 1 for all stages).</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_dispersal_source_n_k">dispersal_source_n_k</code></td>
<td>
<p>Dispersal proportion (p) density dependence via source population abundance divided by carrying capacity (n/k), where p is reduced via a linear slope (defined by two list items) from n/k &lt;= <em>cutoff</em> (p = 0) to n/k &gt;= <em>threshold</em> or vice versa.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_dispersal_target_k">dispersal_target_k</code></td>
<td>
<p>Dispersal rate (r) density dependence via target population carrying capacity (k), where r is reduced via a linear slope (through the origin) when k &lt;= <em>threshold</em>.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_dispersal_target_n">dispersal_target_n</code></td>
<td>
<p>Dispersal rate (r) density dependence via target population abundance (n), where r is reduced via a linear slope (defined by two list items) from n &gt;= <em>threshold</em> to n &lt;= <em>cutoff</em> (r = 0) or visa-versa.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_dispersal_target_n_k">dispersal_target_n_k</code></td>
<td>
<p>Dispersal rate (r) density dependence via target population abundance divided by carrying capacity (n/k), where r is reduced via a linear slope (defined by two list items) from n/k &gt;= <em>threshold</em> to n/k &lt;= <em>cutoff</em> (r = 0) or vice versa.</p>
</td></tr>
<tr><td><code id="population_dispersal_+3A_simulator">simulator</code></td>
<td>
<p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dispersal function: <code>function(r, tm, carrying_capacity, stage_abundance, occupied_indices)</code>, where:
</p>

<dl>
<dt><code>r</code></dt><dd><p>Simulation replicate.</p>
</dd>
<dt><code>tm</code></dt><dd><p>Simulation time step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population at time step.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundance for each stage (rows) and population (columns) at time step.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at time step.</p>
</dd>
<dt><code>returns</code></dt><dd><p>New stage abundance matrix with dispersal applied.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># User-defined dispersal: one-quarter of dispersing stages move one population over
simulator &lt;- SimulatorReference$new()
example_function &lt;- function(params) {
  params$simulator$attached$params &lt;- params # attach to reference object
  emigrants &lt;- round(params$stage_abundance * params$dispersal_stages * 0.25)
  return(params$stage_abundance - emigrants + emigrants[, c(7, 1:6)])
}
dispersal_function &lt;- population_dispersal(
 replicates = 4,
 time_steps = 10,
 years_per_step = 1,
 populations = 7,
 demographic_stochasticity = TRUE,
 density_stages = c(0, 1, 1),
 dispersal = example_function,
 dispersal_stages = c(0, 1, 0.5),
 dispersal_source_n_k = list(cutoff = -0.5, threshold = 1.5),
 dispersal_target_k = 5,
 dispersal_target_n = list(threshold = 10, cutoff = 15),
 simulator = simulator
)
carrying_capacity &lt;- rep(10, 7)
stage_abundance &lt;- matrix(
 c(
   7, 13, 0, 26, 0, 39, 47,
   2, 0, 6, 8, 0, 12, 13,
   0, 3, 4, 6, 0, 9, 10
 ),
 nrow = 3,
 ncol = 7,
 byrow = TRUE
)
occupied_indices &lt;- (1:7)[-5]
dispersal_function(r = 2, tm = 6, carrying_capacity, stage_abundance,
                   occupied_indices)

</code></pre>

<hr>
<h2 id='population_env_stoch'>Nested functions for population environmental stochasticity.</h2><span id='topic+population_env_stoch'></span>

<h3>Description</h3>

<p>Modular functions for the population simulator for performing correlated
environmentally stochastic adjustments to transition rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_env_stoch(
  populations,
  fecundity_matrix,
  fecundity_max,
  survival_matrix,
  standard_deviation,
  correlation
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_env_stoch_+3A_populations">populations</code></td>
<td>
<p>Number of populations.</p>
</td></tr>
<tr><td><code id="population_env_stoch_+3A_fecundity_matrix">fecundity_matrix</code></td>
<td>
<p>Matrix of transition fecundity rates (Leslie/Lefkovitch matrix with non-zero fecundities only).</p>
</td></tr>
<tr><td><code id="population_env_stoch_+3A_fecundity_max">fecundity_max</code></td>
<td>
<p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</td></tr>
<tr><td><code id="population_env_stoch_+3A_survival_matrix">survival_matrix</code></td>
<td>
<p>Matrix of transition survival rates (Leslie/Lefkovitch matrix with non-zero survivals only).</p>
</td></tr>
<tr><td><code id="population_env_stoch_+3A_standard_deviation">standard_deviation</code></td>
<td>
<p>Standard deviation matrix for applying environmental stochasticity to transition rates.</p>
</td></tr>
<tr><td><code id="population_env_stoch_+3A_correlation">correlation</code></td>
<td>
<p>List containing either an environmental correlation matrix (correlation_matrix), a pre-calculated transposed (Cholesky) decomposition matrix (t_decomposition_matrix), or a compact transposed (Cholesky) decomposition matrix (t_decomposition_compact_matrix) and a corresponding map of population indices (t_decomposition_compact_map), as per <em>SpatialCorrelation</em> class attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Environmental stochasticity calculation function: <code>function(fecundity_array, survival_array, occupied_indices)</code>, where:
</p>

<dl>
<dt><code>fecundity_array</code></dt><dd><p>3D array of fecundity rates (<em>stages</em> rows by <em>stages</em> columns by <em>populations</em> deep).</p>
</dd>
<dt><code>survival_array</code></dt><dd><p>3D array of survival rates (<em>stages</em> rows by <em>stages</em> columns by <em>populations</em> deep).</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for those populations occupied.</p>
</dd>
<dt><code>returns</code></dt><dd><p>List containing stochastically varied fecundity and survival arrays.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>fecundity_matrix &lt;- array(c(0, 0, 0, 3, 0, 0, 4, 0, 0), c(3, 3))
survival_matrix &lt;- array(c(0, 0.5, 0, 0, 0, 0.7, 0, 0, 0.8), c(3, 3))
standard_deviation &lt;- (fecundity_matrix + survival_matrix) * 0.3
variation_array &lt;- array(rep(seq(0.85, 1.15, 0.05), each = 9), c(3, 3, 7))
fecundity_array &lt;- array(fecundity_matrix, c(3, 3, 7)) * variation_array
survival_array &lt;- array(survival_matrix, c(3, 3, 7)) * variation_array
stage_abundance &lt;- matrix(c(
   7, 13, 0, 26, 0, 39, 47,
   2, 0, 6, 8, 0, 12, 13,
   0, 3, 4, 6, 0, 9, 10
), nrow = 3, ncol = 7, byrow = TRUE)
occupied_indices &lt;- (1:7)[-5]
env_stoch_function &lt;- population_env_stoch(
  populations = 7, fecundity_matrix, fecundity_max = NULL, survival_matrix,
  standard_deviation, correlation = NULL
)
env_stoch_function(fecundity_array, survival_array, occupied_indices)

</code></pre>

<hr>
<h2 id='population_results'>Nested functions for initializing, calculating and collecting population simulator results.</h2><span id='topic+population_results'></span>

<h3>Description</h3>

<p>Modular functions for the population simulator for initializing, calculating and
collecting simulator results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_results(
  replicates,
  time_steps,
  coordinates,
  initial_abundance,
  results_selection = NULL,
  result_stages = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_results_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicate simulation runs.</p>
</td></tr>
<tr><td><code id="population_results_+3A_time_steps">time_steps</code></td>
<td>
<p>Number of simulation time steps.</p>
</td></tr>
<tr><td><code id="population_results_+3A_coordinates">coordinates</code></td>
<td>
<p>Data frame (or matrix) of X-Y population coordinates.</p>
</td></tr>
<tr><td><code id="population_results_+3A_initial_abundance">initial_abundance</code></td>
<td>
<p>Matrix of initial abundances at each stage (in rows) for each population (in columns).</p>
</td></tr>
<tr><td><code id="population_results_+3A_results_selection">results_selection</code></td>
<td>
<p>List of results selection from: &quot;abundance&quot; (default), &quot;ema&quot;, &quot;extirpation&quot;, &quot;extinction_location&quot;, &quot;harvested&quot;, &quot;occupancy&quot;; &quot;summarize&quot; (default) or &quot;replicate&quot;.</p>
</td></tr>
<tr><td><code id="population_results_+3A_result_stages">result_stages</code></td>
<td>
<p>Array of booleans or numeric (0, 1, 2, ...) for each stage to indicate which stages are included/combined (each unique digit &gt; 0; optionally named) in the results (default is 1 for all stages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of result functions:
</p>

<dl>
<dt><code>initialize_attributes = function())</code></dt><dd><p>Constructs and returns an initialized nested list for the selected result attributes.</p>
</dd>
<dt><code>initialize_replicate = function(results)</code></dt><dd><p>Initializes and returns nested result attributes at the start of each replicate.</p>
</dd>
<dt><code>calculate_at_timestep = function(r, tm, stage_abundance, harvested, results)</code></dt><dd><p>Appends and calculates (non-NULL) results and returns nested result attributes at the end of each time step (tm) within replicate (r).</p>
</dd>
<dt><code>finalize_attributes = function(results)</code></dt><dd><p>Finalizes result calculations at the end of the simulation.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>coordinates &lt;- array(c(1:4, 4:1), c(7, 2))
initial_abundance &lt;- matrix(c(
  7, 13, 0, 26, 0, 39, 47,
  2, 0, 6, 8, 0, 12, 13,
  0, 3, 4, 6, 0, 9, 10
), nrow = 3, ncol = 7, byrow = TRUE)
results_selection &lt;- c("abundance", "ema", "extirpation", 
                        "extinction_location", "harvested", "occupancy")
result_functions &lt;- population_results(
  replicates = 1, time_steps = 10, coordinates, initial_abundance,
  results_selection = results_selection, result_stages = c(0, 1, 1)
)
result_functions$initialize_attributes()

</code></pre>

<hr>
<h2 id='population_simulator'>Runs a stage-based demographic population model simulation.</h2><span id='topic+population_simulator'></span>

<h3>Description</h3>

<p>Simulates a stage-based demographic population model and returns simulation results
across multiple replicate runs. Processes run at each simulation time-step include:
</p>

<ol>
<li><p> Density dependence calculations (ceiling, logistic, or user-defined)
</p>
</li>
<li><p> Environmental stochasticity calculations
</p>
</li>
<li><p> Stage transition (stochastic) calculations
</p>
</li>
<li><p> Translocation calculations (user-defined)
</p>
</li>
<li><p> Harvest calculations (user-defined)
</p>
</li>
<li><p> Mortality calculations (user-defined)
</p>
</li>
<li><p> Dispersal calculations (default or user-defined)
</p>
</li>
<li><p> Results collection
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>population_simulator(inputs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_simulator_+3A_inputs">inputs</code></td>
<td>
<p>Nested list/object with named elements:
</p>

<dl>
<dt><code>random_seed</code></dt><dd><p>Number to seed the random number generation for stochasticity.</p>
</dd>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs (default is 1).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps. Required input.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step (default is 1).</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of populations. Required input.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population coordinates.</p>
</dd>
<dt><code>stages</code></dt><dd><p>Number of life cycle stages.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> object
defining the study region.</p>
</dd>
<dt><code>initial_abundance</code></dt><dd><p>Array (or matrix) of initial abundances (at each stage in rows) for each population (in columns). If there is only one stage and a region object is attached, then initial
abundance may be provided in the form of a raster with the same specs as
the region raster. A vector can be provided that will be forced to a matrix. Required input.</p>
</dd>
<dt><code>stage_matrix</code></dt><dd><p>Matrix of transition (fecundity &amp; survival) rates between stages at each time step (Leslie/Lefkovitch matrix). Required input.</p>
</dd>
<dt><code>fecundity_mask</code></dt><dd><p>Matrix of 0-1 to indicate which (proportions) of transition rates refer to fecundity.</p>
</dd>
<dt><code>fecundity_max</code></dt><dd><p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</dd>
<dt><code>demographic_stochasticity</code></dt><dd><p>Boolean for choosing demographic stochasticity for transition, dispersal, harvest and/or other processes (default is TRUE).</p>
</dd>
<dt><code>standard_deviation</code></dt><dd><p>Standard deviation matrix (or single value) for applying environmental stochasticity to transition rates.</p>
</dd>
<dt><code>correlation</code></dt><dd><p>List containing either an environmental correlation matrix (correlation_matrix), a pre-calculated transposed (Cholesky) decomposition matrix (t_decomposition_matrix), or a compact transposed (Cholesky) decomposition matrix (t_decomposition_compact_matrix) and a corresponding map of population indices (t_decomposition_compact_map), as per <code><a href="#topic+SpatialCorrelation">SpatialCorrelation</a></code> class attributes.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array (matrix) of carrying capacity values at each population cell (<em>populations</em> rows by <em>time_steps</em> columns when across time). Required input.</p>
</dd>
<dt><code>density_dependence</code></dt><dd><p>Density dependence can be &quot;ceiling&quot; (default), &quot;logistic&quot; (Ricker), or a user-defined function (optionally nested in a list with additional attributes) for adjusting transition rates: <code>function(params)</code>, where <em>params</em> is a list passed to the function containing:
</p>

<dl>
<dt><code>transition_array</code></dt><dd><p>3D array of transition rates: stages by stages by populations.</p>
</dd>
<dt><code>fecundity_mask</code></dt><dd><p>Matrix of 0-1 to indicate which (proportions) of transition rates refer to fecundity.</p>
</dd>
<dt><code>fecundity_max</code></dt><dd><p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundances for each stage (rows) and population (columns).</p>
</dd>
<dt><code>population_abundance</code></dt><dd><p>Array of summed population abundances for all stages.</p>
</dd>
<dt><code>density_abundance</code></dt><dd><p>Array of summed population abundances for stages affected by density.</p>
</dd>
<dt><code>growth_rate_max</code></dt><dd><p>Maximum growth rate value or array for populations.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at (current) time step.</p>
</dd>
<dt><code>calculate_multipliers</code></dt><dd><p>Function (<code>function(growth_rates)</code>) for finding multipliers (when stages &gt; 1) to apply to affected transitions that result in target growth rates (dominant eigenvalues).</p>
</dd>
<dt><code>apply_multipliers</code></dt><dd><p>Function (<code>function(transition_array, multipliers</code>) for applying multipliers (when stages &gt; 1) to the affected transition rates within a transition array (returns multiplied array).</p>
</dd>
<dt><code>simulator</code></dt><dd><p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</dd>
<dt><code>optional attributes</code></dt><dd><p>Additional numeric attributes when density dependence is optionally nested in a list.</p>
</dd>
</dl>

<p>returns a transformed transition 3D array
</p>
</dd>
<dt><code>growth_rate_max</code></dt><dd><p>Maximum growth rate (utilized by density dependence processes).</p>
</dd>
<dt><code>density_affects</code></dt><dd><p>Matrix of booleans or numeric (0-1) indicating the transition vital rates affected by density (default is all).</p>
</dd>
<dt><code>density_stages</code></dt><dd><p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density (default is all).</p>
</dd>
<dt><code>density_precision</code></dt><dd><p>Numeric precision of the calculated multipliers (used when stages &gt; 1) applied to affected transition rates (default is 3 decimal places).</p>
</dd>
<dt><code>translocation</code></dt><dd><p>An optional user-defined function (optionally nested in a list with additional attributes) for applying translocation or spatio-temporal management (to abundances): <code>function(params)</code>, where <em>params</em> is a list passed to the function containing:
</p>

<dl>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of populations.</p>
</dd>
<dt><code>stages</code></dt><dd><p>Number of lifecycle stages.</p>
</dd>
<dt><code>demographic_stochasticity</code></dt><dd><p>Boolean for optionally choosing demographic stochasticity for the transformation.</p>
</dd>
<dt><code>density_stages</code></dt><dd><p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density.</p>
</dd>
<dt><code>r</code></dt><dd><p>Simulation replicate.</p>
</dd>
<dt><code>tm</code></dt><dd><p>Simulation time step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population at time step.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of (current) abundance for each stage (rows) and population (columns) at time step.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at (current) time step.</p>
</dd>
<dt><code>simulator</code></dt><dd><p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</dd>
<dt><code>additional attributes</code></dt><dd><p>Additional attributes when the transformation is optionally nested in a list.</p>
</dd>
</dl>

<p>returns a transformed stage abundance matrix (or a list with stage abundance and carrying capacity)
</p>
</dd>
<dt><code>harvest</code></dt><dd><p>An optional user-defined function (optionally nested in a list with additional attributes) for applying harvesting (to abundances): <code>function(params)</code> as per translocation.</p>
</dd>
<dt><code>mortality</code></dt><dd><p>An optional user-defined function (optionally nested in a list with additional attributes) for applying mortality (to abundances): <code>function(params)</code> as per translocation.</p>
</dd>
<dt><code>dispersal</code></dt><dd><p>Either a matrix of dispersal rates between populations (source columns to target rows) or a list of data frames of non-zero dispersal rates and indices for constructing a compact dispersal matrix, and optional changing rates over time (as per class <code><a href="#topic+DispersalGenerator">DispersalGenerator</a></code> <em>dispersal_data</em> attribute). Alternatively a user-defined function (optionally nested in a list with additional attributes) may be used: <code>function(params)</code>, where <em>params</em> is a list passed to the function containing:
</p>

<dl>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of populations.</p>
</dd>
<dt><code>demographic_stochasticity</code></dt><dd><p>Boolean for optionally choosing demographic stochasticity for the transformation.</p>
</dd>
<dt><code>density_stages</code></dt><dd><p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density.</p>
</dd>
<dt><code>dispersal_stages</code></dt><dd><p>Array of relative dispersal (0-1) for each stage to indicate the degree to which each stage participates in dispersal.</p>
</dd>
<dt><code>r</code></dt><dd><p>Simulation replicate.</p>
</dd>
<dt><code>tm</code></dt><dd><p>Simulation time step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population at time step.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundance for each stage (rows) and population (columns) at time step.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at time step.</p>
</dd>
<dt><code>simulator</code></dt><dd><p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</dd>
<dt><code>additional attributes</code></dt><dd><p>Additional attributes when the transformation is optionally nested in a list.</p>
</dd>
</dl>

<p>returns the post-dispersal abundance matrix
</p>
</dd>
<dt><code>dispersal_stages</code></dt><dd><p>Array of relative dispersal (0-1) for each stage to indicate the degree to which each stage participates in dispersal (default is 1 for all stages).</p>
</dd>
<dt><code>dispersal_source_n_k</code></dt><dd><p>Dispersal proportion (p) density dependence via source population abundance divided by carrying capacity (n/k), where p is reduced via a linear slope (defined by two list items) from n/k &lt;= <em>cutoff</em> (p = 0) to n/k &gt;= <em>threshold</em> (aliases: <em>dispersal_n_k_cutoff</em> &amp; <em>dispersal_n_k_threshold</em>).</p>
</dd>
<dt><code>dispersal_target_k</code></dt><dd><p>Dispersal rate (r) density dependence via target population carrying capacity (k), where r is reduced via a linear slope (through the origin) when k &lt;= <em>threshold</em> (alias: <em>dispersal_k_threshold</em>).</p>
</dd>
<dt><code>dispersal_target_n</code></dt><dd><p>Dispersal rate (r) density dependence via target population abundance (n), where r is reduced via a linear slope (defined by two list items) from n &gt;= <em>threshold</em> to n &lt;= <em>cutoff</em> (r = 0) or vice versa (aliases: <em>dispersal_n_threshold</em> &amp; <em>dispersal_n_cutoff</em>).</p>
</dd>
<dt><code>dispersal_target_n_k</code></dt><dd><p>Dispersal rate (r) density dependence via target population abundance divided by carrying capacity (n/k), where r is reduced via a linear slope (defined by two list items) from n/k &gt;= <em>threshold</em> to n/k &lt;= <em>cutoff</em> (r = 0) or vica versa.</p>
</dd>
<dt><code>abundance_threshold</code></dt><dd><p>Abundance threshold (that needs to be exceeded) for each population to persist.</p>
</dd>
<dt><code>simulation_order</code></dt><dd><p>A vector of simulation process names in configured order of execution (default is &quot;transition&quot;, &quot;translocation&quot;, &quot;harvest&quot; (plus harvested results), &quot;mortality&quot;, &quot;dispersal&quot;, &quot;results&quot; (except harvested).</p>
</dd>
<dt><code>additional transformation functions</code></dt><dd><p>Additional user-defined abundance transformation functions (optionally nested in lists with additional attributes) are utilised when listed in <em>simulation_order</em> (function as per translocation).</p>
</dd>
<dt><code>results_selection</code></dt><dd><p>List of results selection from: &quot;abundance&quot; (default), &quot;ema&quot;, &quot;extirpation&quot;, &quot;extinction_location&quot;, &quot;harvested&quot;, &quot;occupancy&quot;; &quot;summarize&quot; (default) or &quot;replicate&quot;.</p>
</dd>
<dt><code>result_stages</code></dt><dd><p>Array of booleans or numeric (0, 1, 2, ...) for each stage to indicate which stages are included/combined (each unique digit &gt; 0; optionally named) in the results (default is 1 for all stages).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Selected simulation results as a nested list summarized (mean, sd, min, max) across multiple replicates (default), or 2-3D arrays including results for each replicate:
</p>

<dl>
<dt><code>abundance</code></dt><dd><p>Matrix or 3D array of simulation abundance: <em>populations</em> rows by <em>time_steps</em> columns (by <em>replicates</em> deep).</p>
</dd>
<dt><code>abundance_stages</code></dt><dd><p>List of matrices or 3D arrays of simulation abundance for unique stage combinations when present: each <em>populations</em> rows by <em>time_steps</em> columns (by <em>replicates</em> deep).</p>
</dd>
<dt><code>all$abundance</code></dt><dd><p>Array or matrix of total abundance across populations: <em>time_steps</em> (rows by <em>replicates</em> columns).</p>
</dd>
<dt><code>all$abundance_stages</code></dt><dd><p>List of arrays or matrices of total abundance across populations for unique stage combinations when present: each <em>time_steps</em> (rows by <em>replicates</em> columns).</p>
</dd>
<dt><code>all$ema</code></dt><dd><p>Array of expected minimum abundance at each time step (averaged across replicates).</p>
</dd>
<dt><code>extirpation</code></dt><dd><p>Array or matrix of extirpation times: <em>populations</em> (rows by <em>replicates</em> columns).</p>
</dd>
<dt><code>all$extirpation</code></dt><dd><p>Array of extirpation time across populations for each replicate.</p>
</dd>
<dt><code>all$extinction_location</code></dt><dd><p>The weighted centroid of cells occupied in the time-step prior to the extirpation of all populations (if it occurred) for each replicate.</p>
</dd>
<dt><code>harvested</code></dt><dd><p>Matrix or 3D array of individuals harvested: <em>populations</em> rows by <em>time_steps</em> columns (by <em>replicates</em> deep).</p>
</dd>
<dt><code>harvested_stages</code></dt><dd><p>List of matrices or 3D arrays of individuals harvested for unique stage combinations when present: each <em>populations</em> rows by <em>time_steps</em> columns (by <em>replicates</em> deep).</p>
</dd>
<dt><code>all$harvested</code></dt><dd><p>Array or matrix of individuals harvested across populations: <em>time_steps</em> (rows by <em>replicates</em> columns).</p>
</dd>
<dt><code>all$harvested_stages</code></dt><dd><p>List of arrays or matrices of individuals harvested across populations for unique stage combinations when present: each <em>time_steps</em> (rows by <em>replicates</em> columns).</p>
</dd>
<dt><code>all$occupancy</code></dt><dd><p>Array or matrix of the number of populations occupied at each time-step: <em>time_steps</em> (rows by <em>replicates</em> columns).</p>
</dd>
<dt><code>additional results</code></dt><dd><p>Additional results may be attached via user-defined functions (using <code>params$simulator$results</code>).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
# Harvest function
harvest &lt;- list(
  rate = 0.3,
  function(params) round(params$stage_abundance * (1 - params$rate))
)
# Population model
stage_matrix &lt;- matrix(c(
  0, 2.5, # Leslie/Lefkovitch matrix
  0.8, 0.5
), nrow = 2, ncol = 2, byrow = TRUE)
pop_model &lt;- PopulationModel$new(
  region = region,
  time_steps = 10, # years
  populations = region$region_cells, # 7
  stage_matrix = stage_matrix,
  initial_abundance = rep(10, 7),
  carrying_capacity = array(70:1, c(7, 10)),
  harvest = harvest,
  results_selection = c("abundance", "harvested")
)
# Simulations
population_simulator(pop_model) # model
inputs &lt;- pop_model$get_attributes()
population_simulator(inputs) # list

</code></pre>

<hr>
<h2 id='population_transformation'>Nested functions for a user-defined population abundance (and capacity) transformation.</h2><span id='topic+population_transformation'></span>

<h3>Description</h3>

<p>Modular functions for the population simulator for performing a transformation of
the stage abundance (and optionally carrying capacity) at a specified time step via
a user-defined function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_transformation(
  replicates,
  time_steps,
  years_per_step,
  populations,
  demographic_stochasticity,
  density_stages,
  transformation,
  simulator,
  name = "transformation"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_transformation_+3A_replicates">replicates</code></td>
<td>
<p>Number of replicate simulation runs.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_time_steps">time_steps</code></td>
<td>
<p>Number of simulation time steps.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_years_per_step">years_per_step</code></td>
<td>
<p>Number of years per time step.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_populations">populations</code></td>
<td>
<p>Number of populations.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_demographic_stochasticity">demographic_stochasticity</code></td>
<td>
<p>Boolean for optionally choosing demographic stochasticity for the transformation.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_density_stages">density_stages</code></td>
<td>
<p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_transformation">transformation</code></td>
<td>
<p>A user-defined function (optionally nested in a list with additional attributes) for performing transformation: <code>function(params)</code>, where <em>params</em> is a list passed to the function containing:
</p>

<dl>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of populations.</p>
</dd>
<dt><code>stages</code></dt><dd><p>Number of life cycle stages.</p>
</dd>
<dt><code>demographic_stochasticity</code></dt><dd><p>Boolean for optionally choosing demographic stochasticity for the transformation.</p>
</dd>
<dt><code>density_stages</code></dt><dd><p>Array of booleans or numeric (0,1) for each stage to indicate which stages are affected by density.</p>
</dd>
<dt><code>r</code></dt><dd><p>Simulation replicate.</p>
</dd>
<dt><code>tm</code></dt><dd><p>Simulation time step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population at time step.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of (current) abundance for each stage (rows) and population (columns) at time step.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at (current) time step.</p>
</dd>
<dt><code>simulator</code></dt><dd><p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</dd>
<dt><code>additional attributes</code></dt><dd><p>Additional attributes when the transformation is optionally nested in a list.</p>
</dd>
</dl>

<p>returns a transformed stage abundance matrix (or a list with stage abundance and carrying capacity)</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_simulator">simulator</code></td>
<td>
<p><code><a href="#topic+SimulatorReference">SimulatorReference</a></code> object with dynamically accessible <em>attached</em> and <em>results</em> lists.</p>
</td></tr>
<tr><td><code id="population_transformation_+3A_name">name</code></td>
<td>
<p>Optional name for the transformation (default is &quot;transformation&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Abundance (and capacity) transformation function: <code>function(r, tm, carrying_capacity, stage_abundance, occupied_indices)</code>, where:
</p>

<dl>
<dt><code>r</code></dt><dd><p>Simulation replicate.</p>
</dd>
<dt><code>tm</code></dt><dd><p>Simulation time step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array of carrying capacity values for each population at time step.</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of abundance for each stage (rows) and population (columns) at time step.</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for populations occupied at time step.</p>
</dd>
<dt><code>returns</code></dt><dd><p>List with transformed stage abundance matrix (and optionally carrying capacity).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>simulator &lt;- SimulatorReference$new()
# Example transformation: a random population is chosen for a severe disturbance event
# (only life cycle stage 3 individuals survive)
disturbance_function &lt;- function(params) {
  params$simulator$attached$params &lt;- params # attach to reference object
  random_population &lt;- sample(params$occupied_indices, 1)
  new_stage_abundance &lt;- params$stage_abundance
  new_stage_abundance[1:2, random_population] &lt;- 0
  return(new_stage_abundance)
}
transformation_function &lt;- population_transformation(
  replicates = 4, time_steps = 10, years_per_step = 1,
  populations = 7, demographic_stochasticity = TRUE,
  density_stages = c(0, 1, 1), transformation = disturbance_function,
  simulator
)
carrying_capacity &lt;- rep(10, 7)
carrying_capacity &lt;- rep(10, 7)
stage_abundance &lt;- matrix(c(
 7, 13, 0, 26, 0, 39, 47,
 2, 0, 6, 8, 0, 12, 13,
 0, 3, 4, 6, 0, 9, 10
), nrow = 3, ncol = 7, byrow = TRUE)
occupied_indices &lt;- (1:7)[-5]
transformation_function(r = 2, tm = 6, carrying_capacity, stage_abundance,
                        occupied_indices)

</code></pre>

<hr>
<h2 id='population_transitions'>Nested functions for stage-based population transitions.</h2><span id='topic+population_transitions'></span>

<h3>Description</h3>

<p>Modular functions for the population simulator for performing staged-based
(Leslie/Lefkovitch matrix) transitions via 3D survival and fecundity arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_transitions(
  populations,
  demographic_stochasticity,
  fecundity_matrix,
  fecundity_max,
  survival_matrix
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="population_transitions_+3A_populations">populations</code></td>
<td>
<p>Number of populations.</p>
</td></tr>
<tr><td><code id="population_transitions_+3A_demographic_stochasticity">demographic_stochasticity</code></td>
<td>
<p>Boolean for choosing demographic stochasticity for transitions.</p>
</td></tr>
<tr><td><code id="population_transitions_+3A_fecundity_matrix">fecundity_matrix</code></td>
<td>
<p>Matrix of transition fecundity rates (Leslie/Lefkovitch matrix with non-zero fecundities only).</p>
</td></tr>
<tr><td><code id="population_transitions_+3A_fecundity_max">fecundity_max</code></td>
<td>
<p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</td></tr>
<tr><td><code id="population_transitions_+3A_survival_matrix">survival_matrix</code></td>
<td>
<p>Matrix of transition survival rates (Leslie/Lefkovitch matrix with non-zero survivals only).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transition calculation function: <code>function(fecundity_array, survival_array, stage_abundance, occupied_indices)</code>, where:
</p>

<dl>
<dt><code>fecundity_array</code></dt><dd><p>3D array of fecundity rates (<em>stages</em> rows by <em>stages</em> columns by <em>populations</em> deep).</p>
</dd>
<dt><code>survival_array</code></dt><dd><p>3D array of survival rates (<em>stages</em> rows by <em>stages</em> columns by <em>populations</em> deep).</p>
</dd>
<dt><code>stage_abundance</code></dt><dd><p>Matrix of stage abundances for each population at time step (<em>stages</em> rows by <em>populations</em> columns).</p>
</dd>
<dt><code>occupied_indices</code></dt><dd><p>Array of indices for those populations occupied.</p>
</dd>
<dt><code>returns</code></dt><dd><p>Transitioned stage abundances.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Deterministic transition (no stochasticity)
fecundity_matrix &lt;- array(c(0, 0, 0, 3, 0, 0, 4, 0, 0), c(3, 3))
survival_matrix &lt;- array(c(0, 0.5, 0, 0, 0, 0.7, 0, 0, 0.8), c(3, 3))
variation_array &lt;- array(rep(seq(0.85, 1.15, 0.05), each = 9), c(3, 3, 7))
fecundity_array &lt;- array(fecundity_matrix, c(3, 3, 7)) * variation_array
survival_array &lt;- array(survival_matrix, c(3, 3, 7)) * variation_array
stage_abundance &lt;- matrix(c(
  7, 13, 0, 26, 0, 39, 47,
  2, 0, 6, 8, 0, 12, 13,
 0, 3, 4, 6, 0, 9, 10
), nrow = 3, ncol = 7, byrow = TRUE)
occupied_indices &lt;- (1:7)[-5]
transition_function &lt;- population_transitions(
  populations = 7, demographic_stochasticity = FALSE,
  fecundity_matrix = fecundity_matrix, fecundity_max = NULL,
  survival_matrix = survival_matrix
)
transition_function(fecundity_array, survival_array, stage_abundance, 
                    occupied_indices)

</code></pre>

<hr>
<h2 id='PopulationModel'>R6 class representing a population model</h2><span id='topic+PopulationModel'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a spatially-explicit
demographic-based population model. It extends the <code><a href="#topic+SimulationModel">SimulationModel</a></code>
class with parameters for the <code><a href="#topic+population_simulator">population_simulator</a></code> function. It
inherits functionality for creating a nested model, whereby a nested template model
with fixed parameters is maintained when a model is cloned for various sampled
parameters. Also provided are extensions to the methods for checking the consistency
and completeness of model parameters.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code><a href="#topic+SimulationModel">poems::SimulationModel</a></code> -&gt; <code>PopulationModel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>simulation_function</code></dt><dd><p>Name (character string) or source path of the default simulation function, which takes a model as an input and returns the simulation results.</p>
</dd>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>Number to seed the random number generation for stochasticity.</p>
</dd>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of population cells.</p>
</dd>
<dt><code>stages</code></dt><dd><p>Number of life cycle stages.</p>
</dd>
<dt><code>initial_abundance</code></dt><dd><p>Array (matrix) or raster (stack) of initial abundance values at each population cell (for each age/stage).</p>
</dd>
<dt><code>stage_matrix</code></dt><dd><p>Matrix of transition (fecundity &amp; survival) rates between stages at each time step (Leslie/Lefkovitch matrix).</p>
</dd>
<dt><code>fecundity_mask</code></dt><dd><p>Matrix of 0-1 to indicate which (proportions) of transition rates refer to fecundity.</p>
</dd>
<dt><code>fecundity_max</code></dt><dd><p>Maximum transition fecundity rate (in Leslie/Lefkovitch matrix).</p>
</dd>
<dt><code>demographic_stochasticity</code></dt><dd><p>Boolean for choosing demographic stochasticity for transition, dispersal, harvest and/or other processes.</p>
</dd>
<dt><code>standard_deviation</code></dt><dd><p>Standard deviation matrix (or single value) for applying environmental stochasticity to transition rates.</p>
</dd>
<dt><code>correlation</code></dt><dd><p>Simulator-dependent attribute or list of attributes for describing/parameterizing the correlation strategy utilized when applying environmental stochasticity and/or other processes (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array (matrix), or raster (stack) of carrying capacity values at each population cell (across time).</p>
</dd>
<dt><code>density_dependence</code></dt><dd><p>Simulator-dependent function, attribute or list of attributes for describing/parameterizing the density dependence strategy utilized (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>growth_rate_max</code></dt><dd><p>Maximum growth rate (utilized by density dependence processes).</p>
</dd>
<dt><code>density_affects</code></dt><dd><p>Transition vital rates that are affected by density, including <em>&quot;fecundity&quot;</em>, <em>&quot;survival&quot;</em>, or a matrix of booleans or numeric (0-1) indicating vital rates affected (default is all).</p>
</dd>
<dt><code>density_stages</code></dt><dd><p>Array of booleans or numeric (0-1) for each stage to indicate (the degree to) which stages are affected by density (default is 1 for all stages).</p>
</dd>
<dt><code>translocation</code></dt><dd><p>Simulator-dependent function, attribute or list of attributes for describing/parameterizing translocation (management) strategies utilized (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>harvest</code></dt><dd><p>Simulator-dependent function, attribute or list of attributes for describing/parameterizing a harvest (organism removal/hunting) strategy (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>mortality</code></dt><dd><p>Simulator-dependent function, attribute or list of attributes to describe/parameterize a spatio-temporal mortality strategy (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>dispersal</code></dt><dd><p>Simulator-dependent function, attribute or list of attributes for describing/parameterizing the dispersal (migration) strategy utilized (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>dispersal_stages</code></dt><dd><p>Array of relative dispersal (0-1) for each stage to indicate the degree to which each stage participates in dispersal (default is 1 for all stages).</p>
</dd>
<dt><code>dispersal_source_n_k</code></dt><dd><p>Simulator-dependent attribute for describing/parameterizing dispersal dependent on source population abundance divided by carrying capacity (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>dispersal_target_k</code></dt><dd><p>Simulator-dependent attribute for describing/parameterizing dispersal dependent on target population carrying capacity (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>dispersal_target_n</code></dt><dd><p>Simulator-dependent attribute (default is list with <em>threshold</em> and <em>cutoff</em>) of attributes for describing/parameterizing dispersal dependent on target population abundance (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>dispersal_target_n_k</code></dt><dd><p>Simulator-dependent attribute (default is list with <em>threshold</em> and <em>cutoff</em>) of attributes for describing/parameterizing dispersal dependent on target population abundance/capacity (see <code><a href="#topic+population_simulator">population_simulator</a></code>).</p>
</dd>
<dt><code>abundance_threshold</code></dt><dd><p>Abundance threshold (that needs to be exceeded) for each population to persist.</p>
</dd>
<dt><code>simulation_order</code></dt><dd><p>A vector of simulation process names in configured order of execution (default is &quot;transition&quot;, &quot;translocation&quot;, &quot;harvest&quot;, &quot;mortality&quot;, &quot;dispersal&quot;, &quot;results&quot;).</p>
</dd>
<dt><code>results_selection</code></dt><dd><p>List of attributes to be included in the returned results of each simulation run, selected from: &quot;abundance&quot;, &quot;ema&quot;, &quot;extirpation&quot;, &quot;extinction_location&quot;, &quot;harvested&quot;, &quot;occupancy&quot;; &quot;summarize&quot; or &quot;replicate&quot;.</p>
</dd>
<dt><code>result_stages</code></dt><dd><p>Array of booleans or numeric (0, 1, 2, ...) for each stage to indicate which stages are included/combined (each unique digit &gt; 0; optionally named) in the results (default is 1 for all stages).</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>template_model</code></dt><dd><p>Nested template model for fixed (non-sampled) attributes for shallow cloning.</p>
</dd>
<dt><code>sample_attributes</code></dt><dd><p>Vector of sample attribute names (only).</p>
</dd>
<dt><code>required_attributes</code></dt><dd><p>Vector of required attribute names (only), i.e. those needed to run a simulation.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PopulationModel-new"><code>PopulationModel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PopulationModel-list_consistency"><code>PopulationModel$list_consistency()</code></a>
</p>
</li>
<li> <p><a href="#method-PopulationModel-clone"><code>PopulationModel$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="get_attribute_names"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-get_attribute_names'><code>poems::SimulationModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="get_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-get_attributes'><code>poems::SimulationModel$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="incomplete_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-incomplete_attributes'><code>poems::SimulationModel$incomplete_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="inconsistent_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-inconsistent_attributes'><code>poems::SimulationModel$inconsistent_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="is_complete"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-is_complete'><code>poems::SimulationModel$is_complete()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="is_consistent"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-is_consistent'><code>poems::SimulationModel$is_consistent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="list_completeness"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-list_completeness'><code>poems::SimulationModel$list_completeness()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="new_clone"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-new_clone'><code>poems::SimulationModel$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="set_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-set_attributes'><code>poems::SimulationModel$set_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="set_sample_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-set_sample_attributes'><code>poems::SimulationModel$set_sample_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PopulationModel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets default aliases and given attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>PopulationModel$new(attribute_aliases = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PopulationModel-list_consistency"></a>



<h4>Method <code>list_consistency()</code></h4>

<p>Returns a boolean to indicate if (optionally selected or all) model attributes (such as dimensions) are consistent.
</p>


<h5>Usage</h5>

<div class="r"><pre>PopulationModel$list_consistency(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Optional array of parameter/attribute names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of booleans (or NAs) to indicate consistency of selected/all attributes.
</p>


<hr>
<a id="method-PopulationModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PopulationModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
# Harvest function
harvest &lt;- list(
  rate = NA, # set later
  function(params) round(params$stage_abundance * (1 - params$rate))
)
harvest_rate_alias &lt;- list(harvest_rate = "harvest$rate")
# Template model
stage_matrix &lt;- matrix(c(
  0, 2.5, # Leslie/Lefkovitch matrix
  0.8, 0.5
), nrow = 2, ncol = 2, byrow = TRUE)
template_model &lt;- PopulationModel$new(
  region = region,
  time_steps = 10, # years
  populations = region$region_cells, # 7
  stage_matrix = stage_matrix,
  harvest = harvest,
  results_selection = c("abundance", "harvested"),
  attribute_aliases = harvest_rate_alias
)
template_model$model_attributes
template_model$required_attributes
# Nested model
nested_model &lt;- PopulationModel$new(template_model = template_model)
nested_model$incomplete_attributes()
nested_model$set_sample_attributes(
  initial_abundance = rep(10, 7),
  carrying_capacity = array(70:1, c(10, 7)),
  harvest_rate = 0.3
)
nested_model$inconsistent_attributes()
nested_model$carrying_capacity &lt;- array(70:1, c(7, 10))
nested_model$is_consistent()
nested_model$is_complete()
nested_model$harvest$rate

</code></pre>

<hr>
<h2 id='PopulationResults'>R6 class representing population simulator results.</h2><span id='topic+PopulationResults'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class encapsulating and dynamically generating
spatially-explicit <code><a href="#topic+population_simulator">population_simulator</a></code> results, as well as optional
re-generated <code><a href="#topic+Generator">Generator</a></code> outputs.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code><a href="#topic+SimulationResults">poems::SimulationResults</a></code> -&gt; <code>PopulationResults</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>burn_in_steps</code></dt><dd><p>Optional number of initial 'burn-in' time steps to be ignored.</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for each cell at each time-step of the simulation including burn-in.</p>
</dd>
<dt><code>trend_interval</code></dt><dd><p>Optional time-step range (indices) for trend calculations (assumes indices begin after the burn-in when utilized).</p>
</dd>
<dt><code>abundance</code></dt><dd><p>Population abundance across simulation time-steps (summary list or replicate array).</p>
</dd>
<dt><code>abundance_stages</code></dt><dd><p>Population abundance for combined stages across simulation time-steps (list of summary lists or replicate arrays for each combined stage).</p>
</dd>
<dt><code>abundance_trend</code></dt><dd><p>Trend or average Sen's <code><a href="trend.html#topic+sens.slope">slope</a></code> of abundance (optionally across a time-step interval).</p>
</dd>
<dt><code>ema</code></dt><dd><p>Array of population expected minimum abundance (EMA) across simulation time-steps.</p>
</dd>
<dt><code>extirpation</code></dt><dd><p>Array of population extirpation times.</p>
</dd>
<dt><code>extinction_location</code></dt><dd><p>The weighted centroid of cells occupied in the time-step prior to the extirpation of all populations (if it occurred).</p>
</dd>
<dt><code>harvested</code></dt><dd><p>Number of animals harvested from each population across simulation time-steps (summary list or replicate array).</p>
</dd>
<dt><code>harvested_stages</code></dt><dd><p>Number of animals harvested from each population for combined stages across simulation time-steps (list of summary lists or replicate arrays for each combined stage).</p>
</dd>
<dt><code>occupancy</code></dt><dd><p>Array of the number of populations occupied at each time-step.</p>
</dd>
<dt><code>all</code></dt><dd><p>Nested simulation results for all cells.</p>
</dd>
<dt><code>parent</code></dt><dd><p>Parent simulation results for individual cells.</p>
</dd>
<dt><code>default</code></dt><dd><p>Default value/attribute utilized when applying primitive metric functions (e.g. max) to the results.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PopulationResults-clone"><code>PopulationResults$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="get_attribute_names"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-get_attribute_names'><code>poems::SimulationResults$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="get_attributes"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-get_attributes'><code>poems::SimulationResults$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="initialize"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-initialize'><code>poems::SimulationResults$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="new_clone"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-new_clone'><code>poems::SimulationResults$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="set_attributes"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-set_attributes'><code>poems::SimulationResults$set_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PopulationResults-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PopulationResults$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)
# Sample results occupancy (ignore cell 2 in last 5 time steps)
occupancy_raster &lt;- region$raster_from_values(array(1, c(7, 13)))
occupancy_raster[region$region_indices][2, 9:13] &lt;- 0
occupancy_raster[region$region_indices]
# Population simulation example results
example_results &lt;- list(abundance = t(apply(matrix(11:17), 1, function(n) {
  c(rep(n, 3), round(n * exp(-(0:9) / 2)))
})))
example_results$harvested &lt;- round(example_results$abundance * 0.3)
example_results
# Population results object
pop_results &lt;- PopulationResults$new(
  region = region,
  time_steps = 13,
  burn_in_steps = 3,
  occupancy_mask = occupancy_raster,
  trend_interval = 1:5
)
pop_results$get_attribute_names(all = TRUE)
# Clone (for each population simulation results)
results_clone &lt;- pop_results$new_clone(results = example_results)
results_clone$all$get_attribute("abundance")
results_clone$get_attributes(c(
  "abundance", "all$abundance",
  "abundance_trend", "all$abundance_trend",
  "all$ema", # only defined for all
  "extirpation", "all$extirpation",
  "all$extinction_location", # only defined for all
  "harvested", "all$harvested",
  "occupancy", "all$occupancy"
))

</code></pre>

<hr>
<h2 id='Region'>R6 class representing a study region.</h2><span id='topic+Region'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a study region of spatial grid cells
defined via a list of longitude/latitude cell coordinates (WGS84), or a
<em>RasterLayer</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>).
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code>Region</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>region_raster</code></dt><dd><p>A <em>RasterLayer</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>) defining the region with finite values (NAs elsewhere).</p>
</dd>
<dt><code>use_raster</code></dt><dd><p>Boolean to indicate that a raster is to be used to define the region (default TRUE).</p>
</dd>
<dt><code>strict_consistency</code></dt><dd><p>Boolean to indicate that, as well as resolution, extent and CRS, consistency checks also ensure that a raster's finite/occupiable cells are the same or a subset of those defined by the region (default TRUE).</p>
</dd>
<dt><code>region_cells</code></dt><dd><p>Dynamically calculated number of region coordinates or raster cells with finite/non-NA values.</p>
</dd>
<dt><code>region_indices</code></dt><dd><p>Dynamically calculated region indices for raster cells with finite/non-NA values (all if not a raster).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Region-new"><code>Region$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Region-raster_is_consistent"><code>Region$raster_is_consistent()</code></a>
</p>
</li>
<li> <p><a href="#method-Region-raster_from_values"><code>Region$raster_from_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Region-clone"><code>Region$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericClass" data-id="new_clone"><a href='../../poems/html/GenericClass.html#method-GenericClass-new_clone'><code>poems::GenericClass$new_clone()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Region-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets coordinates or raster for region.
</p>


<h5>Usage</h5>

<div class="r"><pre>Region$new(
  coordinates = NULL,
  template_raster = NULL,
  region_raster = NULL,
  use_raster = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y coordinates (WGS84) in longitude (degrees West) and latitude (degrees North).</p>
</dd>
<dt><code>template_raster</code></dt><dd><p>A <em>RasterLayer</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>) defining the region with example finite values (NAs elsewhere)</p>
</dd>
<dt><code>region_raster</code></dt><dd><p>A <em>RasterLayer</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>) defining the region with finite cell indices (NAs elsewhere).</p>
</dd>
<dt><code>use_raster</code></dt><dd><p>Boolean to indicate that a raster is to be used to define the region (default TRUE).</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Region-raster_is_consistent"></a>



<h4>Method <code>raster_is_consistent()</code></h4>

<p>Returns a boolean to indicate if a raster is consistent with the region raster (matching extent, resolution, and finite/NA cells).
</p>


<h5>Usage</h5>

<div class="r"><pre>Region$raster_is_consistent(check_raster)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>check_raster</code></dt><dd><p>A <em>RasterLayer</em>, <em>RasterStack</em> or <em>RasterBrick</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>) to check for consistency with the region raster.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Boolean to indicate if the raster is consistent with the region raster.
</p>


<hr>
<a id="method-Region-raster_from_values"></a>



<h4>Method <code>raster_from_values()</code></h4>

<p>Converts an array (or matrix) of values into a raster (or stack) consistent with the region raster (matching extent, resolution, and finite/NA cells).
</p>


<h5>Usage</h5>

<div class="r"><pre>Region$raster_from_values(values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>An array (or matrix) of values to be placed in the raster (or stack) having dimensions consistent with the region cell number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <em>RasterLayer</em> (or <em>RasterStack/Brick</em>) object consistent with the region raster.
</p>


<hr>
<a id="method-Region-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Region$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (cell indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)
region$region_cells
region$coordinates
# Generate value layers
value_brick &lt;- region$raster_from_values(array(8:28, c(7, 3)))
raster::plot(value_brick,
  main = "Example value layers",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)
value_brick[region$region_indices]

</code></pre>

<hr>
<h2 id='ResultsManager'>R6 class representing a results manager.</h2><span id='topic+ResultsManager'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class to represent a manager for generating summary
metrics and/or matrices from simulation results, as well as optionally regenerating
values via generators.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericManager">poems::GenericManager</a></code> -&gt; <code>ResultsManager</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>sample_data</code></dt><dd><p>A data frame of sampled parameters for each simulation/result.</p>
</dd>
<dt><code>simulation_results</code></dt><dd><p>An object of a class inherited from the <code><a href="#topic+SimulationResults">SimulationResults</a></code> class for encapsulating and dynamically generating simulation results.</p>
</dd>
<dt><code>generators</code></dt><dd><p>A list of generators (<code><a href="#topic+Generator">Generator</a></code> or inherited class) objects for (optionally) regenerating simulation model values.</p>
</dd>
<dt><code>result_attachment_functions</code></dt><dd><p>A list of functions for attaching intermediate values to the simulation results prior to generation.</p>
</dd>
<dt><code>summary_metrics</code></dt><dd><p>An array of names for summary metrics, each of which are calculated as single values for each simulation. These should refer to list names for the summary functions.</p>
</dd>
<dt><code>summary_matrices</code></dt><dd><p>An array of names for summary matrices, each of which are calculated as a single matrix row for each simulation. These should refer to list names for the summary functions.</p>
</dd>
<dt><code>summary_functions</code></dt><dd><p>A list of functions, result attributes, or constants for transforming individual simulation results to single summary metric values stored in the metric data frame, or to matrix rows stored in the summary matrix list.</p>
</dd>
<dt><code>summary_metric_data</code></dt><dd><p>A data frame of generated summary metrics (one row per simulation).</p>
</dd>
<dt><code>summary_matrix_list</code></dt><dd><p>A list of generated matrices of summary results (each having one row per simulation).</p>
</dd>
<dt><code>summary_matrix_weighted_averages</code></dt><dd><p>A list of calculated weighted averages for each of the summary matrices (using the sample data <em>weight</em> column).</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>Number of cores for running the simulations in parallel.</p>
</dd>
<dt><code>results_dir</code></dt><dd><p>Results directory path.</p>
</dd>
<dt><code>results_ext</code></dt><dd><p>Result file extension (default is .RData).</p>
</dd>
<dt><code>results_filename_attributes</code></dt><dd><p>A vector of: prefix (optional); attribute names (from the sample data frame); postfix (optional); utilized to construct results filenames.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResultsManager-new"><code>ResultsManager$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultsManager-generate"><code>ResultsManager$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultsManager-calculate_result_attachments"><code>ResultsManager$calculate_result_attachments()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultsManager-calculate_summaries"><code>ResultsManager$calculate_summaries()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultsManager-log_generation"><code>ResultsManager$log_generation()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultsManager-calculate_summary_weighted_averages"><code>ResultsManager$calculate_summary_weighted_averages()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultsManager-clone"><code>ResultsManager$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericClass" data-id="new_clone"><a href='../../poems/html/GenericClass.html#method-GenericClass-new_clone'><code>poems::GenericClass$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericManager" data-id="get_attribute"><a href='../../poems/html/GenericManager.html#method-GenericManager-get_attribute'><code>poems::GenericManager$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericManager" data-id="get_message_sample"><a href='../../poems/html/GenericManager.html#method-GenericManager-get_message_sample'><code>poems::GenericManager$get_message_sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericManager" data-id="get_results_filename"><a href='../../poems/html/GenericManager.html#method-GenericManager-get_results_filename'><code>poems::GenericManager$get_results_filename()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResultsManager-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method optionally copies attributes from a simulation (results) manager, sets any included attributes (<em>sample_data</em>, <em>simulation_results</em>, <em>generators</em>, <em>result_attachment_functions</em>, <em>summary_metrics</em>, <em>summary_functions</em>, <em>parallel_cores</em>, <em>results_dir</em>, <em>results_ext</em>, <em>results_filename_attributes</em>), and attaches other attributes individually listed.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$new(simulation_manager = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation_manager</code></dt><dd><p>Optional <code><a href="#topic+SimulationManager">SimulationManager</a></code> object (or an object inherited from the <code><a href="#topic+GenericManager">GenericManager</a></code> class), from which simulation attributes can be copied.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters listed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultsManager-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generates the summary metric data and/or matrix list via the summary functions for each simulation sample, and creates/writes a generation log.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$generate(results_dir = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>results_dir</code></dt><dd><p>Results directory path (must be present if not already set within manager class object).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Generation log as a list.
</p>


<hr>
<a id="method-ResultsManager-calculate_result_attachments"></a>



<h4>Method <code>calculate_result_attachments()</code></h4>

<p>Calculates and attaches intermediate values to the sample result model (via the result attachment functions).
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$calculate_result_attachments(simulation_results)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation_results</code></dt><dd><p>The sample simulation results, an object of a class inherited from <code><a href="#topic+SimulationResults">SimulationResults</a></code>, to which the intermediate results are attached.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultsManager-calculate_summaries"></a>



<h4>Method <code>calculate_summaries()</code></h4>

<p>Calculates the summary metrics and/or matrices for the results of a sample simulation (via the summary functions).
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$calculate_summaries(simulation_results, sample_index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation_results</code></dt><dd><p>The sample simulation results, an object of a class inherited from <code><a href="#topic+SimulationResults">SimulationResults</a></code>.</p>
</dd>
<dt><code>sample_index</code></dt><dd><p>Index of sample from data frame.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Generation log entry as a (nested) list, including generated summary metric data and (optionally) matrices.
</p>


<hr>
<a id="method-ResultsManager-log_generation"></a>



<h4>Method <code>log_generation()</code></h4>

<p>Summarizes the log generated within the generate method and writes it to a text file in the results directory.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$log_generation(generation_log)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>generation_log</code></dt><dd><p>Nested list of log entries generated via the generate method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Extended generation log as a nested with added summary and failure/warning indices.
</p>


<hr>
<a id="method-ResultsManager-calculate_summary_weighted_averages"></a>



<h4>Method <code>calculate_summary_weighted_averages()</code></h4>

<p>Calculates the weighted averages for each of the summary matrices (providing the sample data has a <em>weight</em> column).
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$calculate_summary_weighted_averages(na_replacements = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>na_replacements</code></dt><dd><p>List of values or functions (form: <code>modified_matrix &lt;- function(matrix)</code>) for dealing with NA values in each summary matrix (default NULL will ignore NAs).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultsManager-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultsManager$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)
# Results manager
results_manager &lt;- ResultsManager$new(
  sample_data = data.frame(index = 1:3),
  simulation_results = PopulationResults$new(region = region),
  summary_metrics = c("trend_n", "total_h"),
  summary_matrices = c("n", "h"),
  summary_functions = list(
    trend_n = function(results) {
      round(results$all$abundance_trend, 2)
    },
    total_h = function(results) {
      sum(results$harvested)
    },
    n = "all$abundance", # string
    h = "all$harvested"
  ),
  parallel_cores = 2,
  results_dir = tempdir()
)
# Write example result files
results &lt;- list()
for (i in 1:3) {
  results[[i]] &lt;- list(abundance = t(apply(
    matrix(11:17), 1,
    function(n) round(n * exp(-(0:9) / i))
  )))
  results[[i]]$harvested &lt;- round(results[[i]]$abundance * i / 7)
  file_name &lt;- paste0(results_manager$get_results_filename(i), ".RData")
  saveRDS(results[[i]], file.path(tempdir(), file_name))
}
# Generate result metrics and matrices
gen_output &lt;- results_manager$generate()
gen_output$summary
dir(tempdir(), "*.txt") # plus generation log
results_manager$summary_metric_data
results_manager$summary_matrix_list

</code></pre>

<hr>
<h2 id='SimulationManager'>R6 class representing a simulation manager.</h2><span id='topic+SimulationManager'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class to represent a manager for running multiple model
simulations and saving results.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericManager">poems::GenericManager</a></code> -&gt; <code>SimulationManager</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>sample_data</code></dt><dd><p>A data frame of sampled parameters for each simulation/result.</p>
</dd>
<dt><code>model_template</code></dt><dd><p>A <code><a href="#topic+SimulationModel">SimulationModel</a></code> (or inherited class) object with parameters common to all simulations.</p>
</dd>
<dt><code>nested_model</code></dt><dd><p>A <code><a href="#topic+SimulationModel">SimulationModel</a></code> (or inherited class) object with empty sample parameters and a nested model template common to all simulations.</p>
</dd>
<dt><code>generators</code></dt><dd><p>A list of generators (<code><a href="#topic+Generator">Generator</a></code> or inherited class) objects for generating simulation model values.</p>
</dd>
<dt><code>model_simulator</code></dt><dd><p>A <code><a href="#topic+ModelSimulator">ModelSimulator</a></code> (or inherited class) object for running the simulations.</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>Number of cores for running the simulations in parallel.</p>
</dd>
<dt><code>results_dir</code></dt><dd><p>Results directory path.</p>
</dd>
<dt><code>results_ext</code></dt><dd><p>Result file extension (default is .RData).</p>
</dd>
<dt><code>results_filename_attributes</code></dt><dd><p>A vector of: prefix (optional); attribute names (from the sample data frame); postfix (optional); utilized to construct results filenames.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimulationManager-new"><code>SimulationManager$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationManager-run"><code>SimulationManager$run()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationManager-set_model_sample"><code>SimulationManager$set_model_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationManager-log_simulation"><code>SimulationManager$log_simulation()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationManager-clone"><code>SimulationManager$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericClass" data-id="new_clone"><a href='../../poems/html/GenericClass.html#method-GenericClass-new_clone'><code>poems::GenericClass$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericManager" data-id="get_attribute"><a href='../../poems/html/GenericManager.html#method-GenericManager-get_attribute'><code>poems::GenericManager$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericManager" data-id="get_message_sample"><a href='../../poems/html/GenericManager.html#method-GenericManager-get_message_sample'><code>poems::GenericManager$get_message_sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericManager" data-id="get_results_filename"><a href='../../poems/html/GenericManager.html#method-GenericManager-get_results_filename'><code>poems::GenericManager$get_results_filename()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimulationManager-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets any included attributes (<em>sample_data</em>, <em>model_template</em>, <em>generators</em>, <em>model_simulator</em>, <em>parallel_cores</em>, <em>results_dir</em>, <em>results_filename_attributes</em>) and attaches other attributes individually listed.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationManager$new(model_template = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model_template</code></dt><dd><p>A SimulationModel (or inherited class) object with parameters common to all simulations.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters listed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationManager-run"></a>



<h4>Method <code>run()</code></h4>

<p>Runs the multiple population simulations (via the set function), stores the results, and creates/writes a simulation log.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationManager$run(results_dir = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>results_dir</code></dt><dd><p>Results directory path (must be present if not already set within manager class object).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Simulator log as a list.
</p>


<hr>
<a id="method-SimulationManager-set_model_sample"></a>



<h4>Method <code>set_model_sample()</code></h4>

<p>Sets the model sample attributes via the sample data frame and the generators.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationManager$set_model_sample(model, sample_index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p><code><a href="#topic+SimulationModel">SimulationModel</a></code> (or inherited class) object (clone) to receive sample attributes.</p>
</dd>
<dt><code>sample_index</code></dt><dd><p>Index of sample from data frame.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationManager-log_simulation"></a>



<h4>Method <code>log_simulation()</code></h4>

<p>Summarizes the simulation log generated within the run method and writes it to a text file in the results directory.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationManager$log_simulation(simulation_log)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation_log</code></dt><dd><p>Nested list of simulation log entries generated via the run method.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationManager-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationManager$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)
# Example population model template
model_template &lt;- PopulationModel$new(
  region = region,
  time_steps = 10, # years
  populations = region$region_cells, # 7
  stage_matrix = 1
)
# Example generators for initial abundance and carrying capacity
hs_matrix &lt;- c(0.5, 0.3, 0.7, 0.9, 0.6, 0.7, 0.8)
initial_gen &lt;- Generator$new(
  description = "initial abundance",
  region = region,
  hs_matrix = hs_matrix, # template attached
  inputs = c("initial_n"),
  outputs = c("initial_abundance")
)
initial_gen$add_generative_requirements(list(initial_abundance = "function"))
initial_gen$add_function_template("initial_abundance",
  function_def = function(params) {
    stats::rmultinom(1,
      size = params$initial_n,
      prob = params$hs_matrix
    )[, 1]
  },
  call_params = c("initial_n", "hs_matrix")
)
capacity_gen &lt;- Generator$new(
  description = "carrying capacity",
  region = region,
  hs_matrix = hs_matrix, # template attached
  inputs = c("density_max"),
  outputs = c("carrying_capacity")
)
capacity_gen$add_generative_requirements(list(carrying_capacity = "function"))
capacity_gen$add_function_template("carrying_capacity",
  function_def = function(params) {
    round(params$density_max * params$hs_matrix)
  },
  call_params = c("density_max", "hs_matrix")
)
# Sample input parameters
sample_data &lt;- data.frame(initial_n = c(40, 60, 80), density_max = c(15, 20, 25))
# Simulation manager
sim_manager &lt;- SimulationManager$new(
  sample_data = sample_data,
  model_template = model_template,
  generators = list(initial_gen, capacity_gen),
  parallel_cores = 2,
  results_dir = tempdir()
)
run_output &lt;- sim_manager$run()
run_output$summary
dir(tempdir(), "*.RData") # includes 3 result files
for (i in 1:3) {
  print(paste("Run", i, "results:"))
  file_name &lt;- paste0(sim_manager$get_results_filename(i), ".RData")
  print(readRDS(file.path(tempdir(), file_name)))
}
dir(tempdir(), "*.txt") # plus simulation log

</code></pre>

<hr>
<h2 id='SimulationModel'>R6 class representing a simulation model</h2><span id='topic+SimulationModel'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a spatially-explicit simulation
model. It extends the <code><a href="#topic+SpatialModel">SpatialModel</a></code> class with a range of common
simulation parameters and functionality for creating a nested model, whereby a nested
template model with fixed parameters is maintained when a model is cloned for various
sampled parameters. Also provided are methods for checking the consistency and
completeness of model parameters.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code>SimulationModel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>simulation_function</code></dt><dd><p>Name (character string) or source path of the default simulation function, which takes a model as an input and returns the simulation results.</p>
</dd>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>Number to seed the random number generation for stochasticity.</p>
</dd>
<dt><code>replicates</code></dt><dd><p>Number of replicate simulation runs.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>results_selection</code></dt><dd><p>List of simulator-dependent attributes to be included in the returned results of each simulation run.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>template_model</code></dt><dd><p>Nested template model for fixed (non-sampled) attributes for shallow cloning.</p>
</dd>
<dt><code>sample_attributes</code></dt><dd><p>Vector of sample attribute names (only).</p>
</dd>
<dt><code>required_attributes</code></dt><dd><p>Vector of required attribute names (only), i.e. those needed to run a simulation.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimulationModel-new"><code>SimulationModel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-new_clone"><code>SimulationModel$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-get_attribute_names"><code>SimulationModel$get_attribute_names()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-get_attributes"><code>SimulationModel$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-set_attributes"><code>SimulationModel$set_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-set_sample_attributes"><code>SimulationModel$set_sample_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-is_consistent"><code>SimulationModel$is_consistent()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-list_consistency"><code>SimulationModel$list_consistency()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-inconsistent_attributes"><code>SimulationModel$inconsistent_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-is_complete"><code>SimulationModel$is_complete()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-list_completeness"><code>SimulationModel$list_completeness()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-incomplete_attributes"><code>SimulationModel$incomplete_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationModel-clone"><code>SimulationModel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimulationModel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets template model and sets given attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$new(template = NULL, required_attributes = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>template</code></dt><dd><p>Template simulation model (nested) containing fixed (non-sampled) attributes.</p>
</dd>
<dt><code>required_attributes</code></dt><dd><p>Vector of required attribute names (only), i.e. those needed to run a simulation.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationModel-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-SimulationModel-get_attribute_names"></a>



<h4>Method <code>get_attribute_names()</code></h4>

<p>Returns a list of all attribute names including public and private model attributes, as well as attached attributes (including those from the template model).
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$get_attribute_names()</pre></div>



<h5>Returns</h5>

<p>List of all attribute names.
</p>


<hr>
<a id="method-SimulationModel-get_attributes"></a>



<h4>Method <code>get_attributes()</code></h4>

<p>Returns a list of values for selected attributes or attribute aliases (when array of parameter names provided) or all attributes (when no params).
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$get_attributes(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Array of attribute names to return (all when NULL).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of selected or all attributes values.
</p>


<hr>
<a id="method-SimulationModel-set_attributes"></a>



<h4>Method <code>set_attributes()</code></h4>

<p>Sets given attributes (optionally via alias names) individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$set_attributes(params = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>List of parameters/attributes.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters/attributes passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationModel-set_sample_attributes"></a>



<h4>Method <code>set_sample_attributes()</code></h4>

<p>Sets the names (only - when <em>params</em> is a vector) and values (when <em>params</em> is a list and/or when name-value pairs are provided) of the sample attributes for the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$set_sample_attributes(params = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>List of parameters/attributes (names and values) or array of names only.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters/attributes passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationModel-is_consistent"></a>



<h4>Method <code>is_consistent()</code></h4>

<p>Returns a boolean to indicate if (optionally selected or all) model attributes (such as dimensions) are consistent/valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$is_consistent(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Optional array of parameter/attribute names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Boolean to indicate consistency of selected/all attributes.
</p>


<hr>
<a id="method-SimulationModel-list_consistency"></a>



<h4>Method <code>list_consistency()</code></h4>

<p>Returns a boolean to indicate if (optionally selected or all) model attributes (such as dimensions) are consistent/valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$list_consistency(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Optional array of parameter/attribute names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of booleans (or NAs) to indicate consistency of selected/all attributes.
</p>


<hr>
<a id="method-SimulationModel-inconsistent_attributes"></a>



<h4>Method <code>inconsistent_attributes()</code></h4>

<p>Returns a list of attributes necessary to simulate the model that are inconsistent/invalid.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$inconsistent_attributes(include_nas = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_nas</code></dt><dd><p>Optional boolean indicating whether of not to include attributes with unknown consistency (NA).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of inconsistent attributes which prevent the model simulation (and optionally those where consistency is not available).
</p>


<hr>
<a id="method-SimulationModel-is_complete"></a>



<h4>Method <code>is_complete()</code></h4>

<p>Returns a boolean to indicate if all attributes necessary to simulate the model have been set and are consistent/valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$is_complete()</pre></div>



<h5>Returns</h5>

<p>Boolean to indicate model completeness (and consistency).
</p>


<hr>
<a id="method-SimulationModel-list_completeness"></a>



<h4>Method <code>list_completeness()</code></h4>

<p>Returns a list of booleans (or NAs) for each parameter to indicate attributes that are necessary to simulate the model have been set and are consistent/valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$list_completeness()</pre></div>



<h5>Returns</h5>

<p>List of booleans (or NAs) for each parameter to indicate to indicate completeness (and consistency).
</p>


<hr>
<a id="method-SimulationModel-incomplete_attributes"></a>



<h4>Method <code>incomplete_attributes()</code></h4>

<p>Returns a list of attributes necessary to simulate the model that are incomplete/inconsistent/invalid.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$incomplete_attributes(include_nas = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_nas</code></dt><dd><p>Optional boolean indicating whether of not to include attributes with unknown completeness (NA).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of incomplete attributes which prevent the model simulation (and optionally those where completeness is not available).
</p>


<hr>
<a id="method-SimulationModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
# Model template
template_model &lt;- SimulationModel$new(
  simulation_function = "test_simulator",
  region = region, time_steps = 10
)
template_model$model_attributes &lt;- c(
  template_model$model_attributes,
  "a", "b", "c", "d"
)
template_model$model_attributes
template_model$required_attributes &lt;- c(
  template_model$required_attributes[1:2],
  "a", "b", "c", "d"
)
template_model$required_attributes
template_model$get_attributes(template_model$required_attributes)
template_model$simulation_function
# Nested model
nested_model &lt;- SimulationModel$new(template_model = template_model)
nested_model$region$region_cells
nested_model$set_sample_attributes(a = 1:7, b = 1:10, c = 1:15)
nested_model$sample_attributes
nested_model$get_attributes(c("a", "b", "c", "d"))
# Completeness and consistency
nested_model$is_complete()
nested_model$incomplete_attributes()
nested_model$is_consistent()
nested_model$inconsistent_attributes()
nested_model$set_attributes(c = array(1:70, c(7, 10)), d = 15)
nested_model$is_complete()
nested_model$is_consistent()
# Attached attributes
nested_model$attached
template_model$attached

</code></pre>

<hr>
<h2 id='SimulationResults'>R6 class representing simulation results.</h2><span id='topic+SimulationResults'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class for encapsulating and dynamically generating
spatially-explicit simulation results, as well as optional re-generated
<code><a href="#topic+Generator">Generator</a></code> outputs.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code>SimulationResults</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>burn_in_steps</code></dt><dd><p>Optional number of initial 'burn-in' time steps to be ignored.</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for each cell at each time-step of the simulation including burn-in.</p>
</dd>
<dt><code>all</code></dt><dd><p>Nested simulation results for all cells.</p>
</dd>
<dt><code>parent</code></dt><dd><p>Parent simulation results for individual cells.</p>
</dd>
<dt><code>default</code></dt><dd><p>Default value/attribute utilized when applying primitive metric functions (e.g. max) to the results.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimulationResults-new"><code>SimulationResults$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationResults-new_clone"><code>SimulationResults$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationResults-get_attribute_names"><code>SimulationResults$get_attribute_names()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationResults-get_attributes"><code>SimulationResults$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationResults-set_attributes"><code>SimulationResults$set_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimulationResults-clone"><code>SimulationResults$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimulationResults-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets attributes from a results list or file, and sets object attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationResults$new(results = NULL, parent = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>results</code></dt><dd><p>A list containing results or a file path to simulation results.</p>
</dd>
<dt><code>parent</code></dt><dd><p>Parent simulation results for individual cells (used when nesting a simulation results clone for all cells).</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationResults-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationResults$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-SimulationResults-get_attribute_names"></a>



<h4>Method <code>get_attribute_names()</code></h4>

<p>Returns an array of all attribute names including public and private model attributes, as well as attached attributes, error and warning messages.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationResults$get_attribute_names(all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>Boolean to indicate if a nested list for all cells (when present) should be also listed (default is FALSE).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Array of all attribute names with optional inclusion of attribute names of nested results for all cells.
</p>


<hr>
<a id="method-SimulationResults-get_attributes"></a>



<h4>Method <code>get_attributes()</code></h4>

<p>Returns a list of values for selected attributes or attribute aliases (when array of parameter names provided) or all attributes (when no params).
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationResults$get_attributes(params = NULL, remove_burn_in = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Array of attribute names to return (all when NULL).</p>
</dd>
<dt><code>remove_burn_in</code></dt><dd><p>Boolean to indicate whether or not to remove burn-in steps from the attribute values (default = TRUE; mostly for internal use).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of selected or all attributes values.
</p>


<hr>
<a id="method-SimulationResults-set_attributes"></a>



<h4>Method <code>set_attributes()</code></h4>

<p>Sets given attributes (optionally via alias names) individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationResults$set_attributes(params = list(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>List of parameters/attributes.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters/attributes passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimulationResults-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulationResults$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
raster::plot(region$region_raster,
  main = "Example region (indices)",
  xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
  colNA = "blue"
)
# Sample results occupancy (ignore cell 2 in last 3 time steps)
occupancy_raster &lt;- region$raster_from_values(array(1, c(7, 13)))
occupancy_raster[region$region_indices][2, 11:13] &lt;- 0
occupancy_raster[region$region_indices]
# Simulation example results
example_results &lt;- list(abundance = region$raster_from_values(
  t(apply(
    matrix(11:17), 1,
    function(n) c(rep(n, 3), round(n * exp(-(0:9) / log(n))))
  ))
))
example_results$abundance[region$region_indices]
# Simulation results object
sim_results &lt;- SimulationResults$new(
  region = region,
  time_steps = 13,
  burn_in_steps = 3,
  occupancy_mask = occupancy_raster
)
# Clone (for each simulation results)
results_clone &lt;- sim_results$new_clone(results = example_results)
results_clone$get_attribute("abundance")
results_clone$get_attribute("abundance")[region$region_indices]
results_clone$all$get_attribute("abundance")
results_clone$get_attribute("all$abundance")

</code></pre>

<hr>
<h2 id='SimulatorReference'>R6 class for a simulator reference</h2><span id='topic+SimulatorReference'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class for dynamically attaching simulator attributes
and results (passed by reference).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached simulator attributes (name-value pairs).</p>
</dd>
<dt><code>results</code></dt><dd><p>A list of dynamically accessed simulator results (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimulatorReference-clone"><code>SimulatorReference$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SimulatorReference-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimulatorReference$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>test_class &lt;- SimulatorReference$new()
test_class$attached$attr1 &lt;- "example1"
test_class$results$attr1 &lt;- "example2"
str(test_class)

</code></pre>

<hr>
<h2 id='SpatialCorrelation'>R6 class representing a spatial correlation.</h2><span id='topic+SpatialCorrelation'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class functionality for modeling spatial correlations
within a spatially-explicit model. It provides functionality for calculating
correlations between region cells using a distance-based function:
<em>a*exp(-distance/b)</em>, where <em>a</em> (amplitude) and <em>b</em> (breadth) are
configurable model attributes. It then calculates the Cholesky decomposition of
the correlation matrix (via <code><a href="base.html#topic+chol">chol</a></code>), which is utilized to
generate (optionally temporal) correlated normal deviates. A compacted version of
the decomposed matrix can also generated for computational efficiency.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code>SpatialCorrelation</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>distance_scale</code></dt><dd><p>Scale of distance values in meters (default = 1). Usage: set to 1 for values in meters, or to 1000 for values in kilometers.</p>
</dd>
<dt><code>correlation_amplitude</code></dt><dd><p>Correlation function: <em>a*exp(-distance/b)</em> <em>a</em> parameter. Represents the amplitude or maximum magnitude of correlation values between model cells.</p>
</dd>
<dt><code>correlation_breadth</code></dt><dd><p>Correlation function: <em>a*exp(-distance/b)</em> <em>b</em> parameter. Represents the breadth of the correlation between region cells. Typically estimated via average distance between correlated region cells.</p>
</dd>
<dt><code>correlation_matrix</code></dt><dd><p>Correlation matrix calculated via correlation function: <em>a*exp(-distance/b)</em>.</p>
</dd>
<dt><code>t_decomposition_matrix</code></dt><dd><p>The transposed Cholesky decomposition of the correlation matrix (see <code><a href="base.html#topic+chol">chol</a></code>).</p>
</dd>
<dt><code>compact_only</code></dt><dd><p>Boolean to indicate that only the compact versions of matrices will be maintained once calculated.</p>
</dd>
<dt><code>t_decomposition_compact_matrix</code></dt><dd><p>A compact (rows) version of the transposed Cholesky decomposition of the correlation matrix.</p>
</dd>
<dt><code>t_decomposition_compact_map</code></dt><dd><p>A map of the original region cell rows for the compact transposed decomposition matrix.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpatialCorrelation-new"><code>SpatialCorrelation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-calculate_distance_matrix"><code>SpatialCorrelation$calculate_distance_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-calculate_correlations"><code>SpatialCorrelation$calculate_correlations()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-calculate_cholesky_decomposition"><code>SpatialCorrelation$calculate_cholesky_decomposition()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-calculate_compact_decomposition"><code>SpatialCorrelation$calculate_compact_decomposition()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-get_compact_decomposition"><code>SpatialCorrelation$get_compact_decomposition()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-generate_correlated_normal_deviates"><code>SpatialCorrelation$generate_correlated_normal_deviates()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialCorrelation-clone"><code>SpatialCorrelation$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_names"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_names'><code>poems::GenericModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attributes'><code>poems::GenericModel$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="set_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-set_attributes'><code>poems::GenericModel$set_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SpatialModel" data-id="new_clone"><a href='../../poems/html/SpatialModel.html#method-SpatialModel-new_clone'><code>poems::SpatialModel$new_clone()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SpatialCorrelation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets given attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$new(compact_only = TRUE, attribute_aliases = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>compact_only</code></dt><dd><p>Boolean to indicate that only the compact versions of matrices will be maintained once calculated.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>Optional list of extra alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SpatialCorrelation-calculate_distance_matrix"></a>



<h4>Method <code>calculate_distance_matrix()</code></h4>

<p>Returns a matrix with the calculated distance (in meters by default) between each pair of region cells.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$calculate_distance_matrix(use_longlat = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_longlat</code></dt><dd><p>Optional boolean indicating use of (WGS84) coordinates in longitude (degrees West) and latitude (degrees North).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix with distances between region cells.
</p>


<hr>
<a id="method-SpatialCorrelation-calculate_correlations"></a>



<h4>Method <code>calculate_correlations()</code></h4>

<p>Calculates the correlation matrix by applying the distance-based correlation function.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$calculate_correlations(
  distance_matrix = NULL,
  decimals = NULL,
  threshold = 1e-07,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distance_matrix</code></dt><dd><p>Optional pre-calculated matrix with distances between region cells.</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimal places for correlation values.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>Optional threshold (minimum value) for correlation values (default 0.0000001).</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SpatialCorrelation-calculate_cholesky_decomposition"></a>



<h4>Method <code>calculate_cholesky_decomposition()</code></h4>

<p>Calculates the transposed Cholesky decomposition of the correlation matrix (via <code><a href="base.html#topic+chol">chol</a></code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$calculate_cholesky_decomposition(
  distance_matrix = NULL,
  decimals = NULL,
  threshold = 1e-07,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distance_matrix</code></dt><dd><p>Optional pre-calculated matrix with distances between region cells.</p>
</dd>
<dt><code>decimals</code></dt><dd><p>Optional number of decimal places for correlation values.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>Optional threshold (minimum value) for correlation values (default 0.0000001).</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SpatialCorrelation-calculate_compact_decomposition"></a>



<h4>Method <code>calculate_compact_decomposition()</code></h4>

<p>Compacts the transposed Cholesky decomposition of the correlation matrix into the minimal number of rows, which are mapped to the original matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$calculate_compact_decomposition(distance_matrix = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distance_matrix</code></dt><dd><p>Optional pre-calculated matrix with distances between region cells.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SpatialCorrelation-get_compact_decomposition"></a>



<h4>Method <code>get_compact_decomposition()</code></h4>

<p>Returns a compact transposed Cholesky decomposition of the correlation matrix and a corresponding map of region cell indices in a list with names: matrix, map.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$get_compact_decomposition(distance_matrix = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distance_matrix</code></dt><dd><p>Optional pre-calculated matrix with distances between region cells.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List containing a compact Cholesky decomposition matrix and a corresponding map of region cell indices (for the compacted rows).
</p>


<hr>
<a id="method-SpatialCorrelation-generate_correlated_normal_deviates"></a>



<h4>Method <code>generate_correlated_normal_deviates()</code></h4>

<p>Generates correlated normal deviates using the spatial correlation, utilizing the optional random seed and optional temporal correlation across time steps.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$generate_correlated_normal_deviates(
  random_seed = NULL,
  temporal_correlation = 1,
  time_steps = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>random_seed</code></dt><dd><p>Optional seed for the random generation of correlated deviates.</p>
</dd>
<dt><code>temporal_correlation</code></dt><dd><p>Optional temporal correlation coefficient (0-1; default = 1).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Optional number of time steps for temporal correlation (default = 1 or none).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Array (non-temporal) or matrix (temporal) of correlated normal deviates.
</p>


<hr>
<a id="method-SpatialCorrelation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialCorrelation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
# Spatial correlation
env_corr &lt;- SpatialCorrelation$new(region = region, amplitude = 0.4, breadth = 500)
env_corr$calculate_distance_matrix() # m
env_corr$calculate_correlations(decimals = 5)
env_corr$correlation_matrix
env_corr$calculate_cholesky_decomposition(decimals = 2)
env_corr$t_decomposition_matrix
env_corr$get_compact_decomposition()
# Scale to km
env_corr$distance_scale &lt;- 1000
env_corr$calculate_distance_matrix() # km

</code></pre>

<hr>
<h2 id='SpatialModel'>R6 class representing a spatial model</h2><span id='topic+SpatialModel'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a generic (abstract)
spatially-explicit model. It extends <code><a href="#topic+GenericModel">GenericModel</a></code> with the addition of
a study region specification.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code>SpatialModel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpatialModel-new"><code>SpatialModel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialModel-new_clone"><code>SpatialModel$new_clone()</code></a>
</p>
</li>
<li> <p><a href="#method-SpatialModel-clone"><code>SpatialModel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_names"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_names'><code>poems::GenericModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attributes'><code>poems::GenericModel$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="set_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-set_attributes'><code>poems::GenericModel$set_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SpatialModel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets given attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialModel$new(region = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>region</code></dt><dd><p>A <code><a href="#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SpatialModel-new_clone"></a>



<h4>Method <code>new_clone()</code></h4>

<p>Creates a new (re-initialized) object of the current (inherited) object class with optionally passed parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialModel$new_clone(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via the inherited class constructor (defined in initialize and run via new).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New object of the current (inherited) class.
</p>


<hr>
<a id="method-SpatialModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpatialModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># U Island example region
coordinates &lt;- data.frame(
  x = rep(seq(177.01, 177.05, 0.01), 5),
  y = rep(seq(-18.01, -18.05, -0.01), each = 5)
)
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
template_raster[][-c(7, 9, 12, 14, 17:19)] &lt;- NA # make U Island
region &lt;- Region$new(template_raster = template_raster)
# Example spatial model
model1 &lt;- SpatialModel$new(region = region, a_layers = 3)
model1$coordinates
model1$set_attributes(a_values = array(8:28, c(7, 3)))
model1$region$raster_from_values(model1$get_attribute("a_values"))

</code></pre>

<hr>
<h2 id='tasmania_ibra_data'>Thylacine vignette Tasmania IBRA data</h2><span id='topic+tasmania_ibra_data'></span>

<h3>Description</h3>

<p>A dataset describing the nine Interim Bioregionalisation of Australia (IBRA)
bioregions for the Tasmanian study region of the Thylacine example vignette.
</p>


<h3>Format</h3>

<p>A data frame with 9 rows and 4 variables:
</p>

<dl>
<dt>index</dt><dd><p>Cross-reference index for each bioregion</p>
</dd>
<dt>key</dt><dd><p>Additional alphabetical cross-reference for each bioregion</p>
</dd>
<dt>abbr</dt><dd><p>Abbreviated name for each bioregion</p>
</dd>
<dt>name</dt><dd><p>Full name for each bioregion</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://doi.org/10.1111/2041-210X.13720
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tasmania_ibra_data)
data(tasmania_ibra_raster)
raster::values(tasmania_ibra_raster)[!is.na(raster::values(tasmania_ibra_raster))] |&gt; 
 table() |&gt; as.data.frame() |&gt; 
 merge(tasmania_ibra_data, by.x = "Var1", by.y = "index")

</code></pre>

<hr>
<h2 id='tasmania_ibra_raster'>Thylacine vignette Tasmania IBRA raster</h2><span id='topic+tasmania_ibra_raster'></span>

<h3>Description</h3>

<p>A <em>raster</em> dataset defining the grid cells of the nine Interim
Bioregionalisation of Australia (IBRA) bioregions for the Tasmanian study region of
the Thylacine example vignette.
</p>


<h3>Format</h3>

<p>A <em>raster::RasterLayer</em> object:
</p>

<dl>
<dt>dimensions</dt><dd><p>32 rows by 40 columns grid</p>
</dd>
<dt>resolution</dt><dd><p>0.1 by 0.1 degree grid cells</p>
</dd>
<dt>extent</dt><dd><p>longitude 144.5 to 148.5 degrees; latitude -43.8025 to -40.6025 degrees</p>
</dd>
<dt>CRS</dt><dd><p>WGS84 longitude-latitude</p>
</dd>
<dt>values</dt><dd><p>IBRA bioregions defined by cells with values 1 to 9 (as per <code>index</code> in <code><a href="#topic+tasmania_ibra_data">tasmania_ibra_data</a></code>)</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://doi.org/10.1111/2041-210X.13720
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tasmania_ibra_raster)
data(tasmania_raster)
tasmania_region &lt;- Region$new(
  template_raster = tasmania_raster
)
tasmania_region$raster_is_consistent(tasmania_ibra_raster)
raster::plot(tasmania_ibra_raster)

</code></pre>

<hr>
<h2 id='tasmania_modifier'>Tasmania land-use modifier raster</h2><span id='topic+tasmania_modifier'></span>

<h3>Description</h3>

<p>A <em>raster</em> dataset (11 timesteps) defining the intensity land-use cover for each
grid-cell in the Tasmania study region. NB. This dataset is projected and will not natively overlay
the other <em>raster</em> datasets contained in <em>poems</em>.
</p>


<h3>Format</h3>

<p>A <em>raster::RasterBrick</em> object:
</p>

<dl>
<dt>dimensions</dt><dd><p>36 rows, 34 columns, 11 layers</p>
</dd>
<dt>resolution</dt><dd><p>10km by 10km grid cells</p>
</dd>
<dt>extent</dt><dd><p>-211571.8, 128428.2, -182583.2, 177416.8  (xmin, xmax, ymin, ymax)</p>
</dd>
<dt>CRS</dt><dd><p>+proj=laea +lat_0=-42.2 +lon_0=147 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs</p>
</dd>
<dt>values</dt><dd><p>region defined by 1224 cells with values between 0-1. Values of 1 indicate extensive land use modification)</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://doi.org/10.1111/2041-210X.13720
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tasmania_raster)
data(tasmania_modifier)
tasmania_region &lt;- Region$new(
  template_raster = tasmania_modifier[[1]]
)
tasmania_region$raster_is_consistent(tasmania_raster)
raster::plot(tasmania_modifier)

</code></pre>

<hr>
<h2 id='tasmania_raster'>Thylacine vignette Tasmania raster</h2><span id='topic+tasmania_raster'></span>

<h3>Description</h3>

<p>A <em>raster</em> dataset defining the grid cells of the Tasmanian study region for the
Thylacine example vignette.
</p>


<h3>Format</h3>

<p>A <em>raster::RasterLayer</em> object:
</p>

<dl>
<dt>dimensions</dt><dd><p>32 rows by 40 columns grid</p>
</dd>
<dt>resolution</dt><dd><p>0.1 by 0.1 degree grid cells</p>
</dd>
<dt>extent</dt><dd><p>longitude 144.5 to 148.5 degrees; latitude -43.8025 to -40.6025 degrees</p>
</dd>
<dt>CRS</dt><dd><p>WGS84 longitude-latitude</p>
</dd>
<dt>values</dt><dd><p>region defined by 795 cells with value of 1 (surrounded by non-region <code>NA</code> values)</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://doi.org/10.1111/2041-210X.13720
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tasmania_raster)
tasmania_region &lt;- Region$new(
  template_raster = tasmania_raster
)
raster::plot(tasmania_region$region_raster)

</code></pre>

<hr>
<h2 id='thylacine_bounty_record'>Thylacine vignette bounty record</h2><span id='topic+thylacine_bounty_record'></span>

<h3>Description</h3>

<p>A dataset containing the historical record of the Thylacine bounty numbers submitted
across the Tasmanian study region, and for each of the nine Interim Bioregionalisation
of Australia (IBRA) bioregions for Thylacine example vignette.
</p>


<h3>Format</h3>

<p>A data frame with 22 rows and 11 variables:
</p>

<dl>
<dt>Year</dt><dd><p>Year during bounty period from 1888 to 1909</p>
</dd>
<dt>Total</dt><dd><p>Total Tasmania-wide bounty submitted</p>
</dd>
<dt>FUR</dt><dd><p>Bounty submitted in IBRA bioregion: Furneaux</p>
</dd>
<dt>BEN</dt><dd><p>Bounty submitted in IBRA bioregion: Ben Lomond</p>
</dd>
<dt>TNM</dt><dd><p>Bounty submitted in IBRA bioregion: Tasmanian Northern Midlands</p>
</dd>
<dt>TSE</dt><dd><p>Bounty submitted in IBRA bioregion: Tasmanian South East</p>
</dd>
<dt>TW</dt><dd><p>Bounty submitted in IBRA bioregion: Tasmanian West</p>
</dd>
<dt>TNS</dt><dd><p>Bounty submitted in IBRA bioregion: Tasmanian Northern Slopes</p>
</dd>
<dt>TSR</dt><dd><p>Bounty submitted in IBRA bioregion: Tasmanian Southern Ranges</p>
</dd>
<dt>TCH</dt><dd><p>Bounty submitted in IBRA bioregion: Tasmanian Central Highlands</p>
</dd>
<dt>KIN</dt><dd><p>Bounty submitted in IBRA bioregion: King</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://doi.org/10.1111/2041-210X.13720
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thylacine_bounty_record)
summary(thylacine_bounty_record)
# Assuming your data frame is named thylacine_bounty_record
plot(thylacine_bounty_record$Year, thylacine_bounty_record$Total, type="l", 
    main="Change in Total Bounties Over Time", 
    xlab="Year", 
    ylab="Total Bounties")

</code></pre>

<hr>
<h2 id='thylacine_example_matrices'>Thylacine vignette demonstration example matrices</h2><span id='topic+thylacine_example_matrices'></span>

<h3>Description</h3>

<p>A dataset containing precalculated summary matrices for use when running the
Thylacine example vignette in demonstration mode. The values were obtained by running
the vignette code for 20,000 model simulations with <code>DEMONSTRATION = FALSE</code>.
Note that some matrices were only stored for the selected 'best' 200 models.
</p>


<h3>Format</h3>

<p>A list containing the following matrices:
</p>

<dl>
<dt>extirpation</dt><dd><p>200 row by 795 column matrix of cell extirpation dates for the 'best' 200 models</p>
</dd>
<dt>total_bounty</dt><dd><p>200 row by 80 column matrix of bounty submitted each year for the 'best' 200 models</p>
</dd>
<dt>ibra_bounty</dt><dd><p>200 row by 9 column matrix of total bounty submitted each IBRA bioregion for the 'best' 200 models</p>
</dd>
<dt>bounty_slope</dt><dd><p>20,000 row by 3 column matrix of calculated slope of total bounty submitted across 3 intervals for each sample simulation</p>
</dd>
<dt>ibra_extirpation</dt><dd><p>20,000 row by 9 column matrix of extirpation dates for each IBRA bioregion for each sample simulation</p>
</dd>
</dl>



<h3>Source</h3>

<p>Precalculated demonstration via example simulation runs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thylacine_example_matrices)
data(tasmania_raster)
region &lt;- Region$new(template_raster = tasmania_raster)
region$raster_from_values(thylacine_example_matrices$extirpation[1,]) |&gt;
 raster::plot(colNA = "blue")

</code></pre>

<hr>
<h2 id='thylacine_example_matrices_rerun'>Thylacine vignette demonstration example (re-run) matrices</h2><span id='topic+thylacine_example_matrices_rerun'></span>

<h3>Description</h3>

<p>A dataset containing precalculated (re-run) summary matrices for use when running the
Thylacine example vignette in demonstration mode. The values were obtained by running
the vignette code for 10 replicate re-runs of the selected 'best' 200 model
simulations with <code>DEMONSTRATION = FALSE</code>.
</p>


<h3>Format</h3>

<p>A list containing the following matrices:
</p>

<dl>
<dt>bounty_slope</dt><dd><p>2,000 row by 3 column matrix of calculated slope of total bounty submitted across 3 intervals for each sample simulation</p>
</dd>
<dt>ibra_extirpation</dt><dd><p>2,000 row by 9 column matrix of extirpation dates for each IBRA bioregion for each sample simulation</p>
</dd>
</dl>



<h3>Source</h3>

<p>Precalculated demonstration via example simulation re-runs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thylacine_example_matrices_rerun)
rowMeans(thylacine_example_matrices_rerun$bounty_slope)
rowMeans(thylacine_example_matrices_rerun$ibra_extirpation)

</code></pre>

<hr>
<h2 id='thylacine_example_metrics'>Thylacine vignette demonstration example metrics</h2><span id='topic+thylacine_example_metrics'></span>

<h3>Description</h3>

<p>A dataset containing precalculated summary metrics for use when running the Thylacine
example vignette in demonstration mode. The values were obtained by running the
vignette code for 20,000 model simulations with <code>DEMONSTRATION = FALSE</code>.
</p>


<h3>Format</h3>

<p>A data frame with 20,000 rows and 4 variables:
</p>

<dl>
<dt>index</dt><dd><p>Example simulation number from 1 to 20,000</p>
</dd>
<dt>bounty_slope_error</dt><dd><p>Root mean squared error (RMSE) from estimated total bounty submitted across three intervals (see vignette)</p>
</dd>
<dt>ibra_extirpation_error</dt><dd><p>RMSE from estimated extirpation date for each IBRA bioregion (see vignette)</p>
</dd>
<dt>total_extinction</dt><dd><p>Total extinction date for each example simulation (<code>NA</code> when persistent beyond 1967)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Precalculated demonstration via example simulation runs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thylacine_example_metrics)
hist(thylacine_example_metrics$bounty_slope_error)
hist(thylacine_example_metrics$ibra_extirpation_error)
hist(thylacine_example_metrics$total_extinction)

</code></pre>

<hr>
<h2 id='thylacine_example_metrics_rerun'>Thylacine vignette demonstration example (re-run) metrics</h2><span id='topic+thylacine_example_metrics_rerun'></span>

<h3>Description</h3>

<p>A dataset containing precalculated (re-run) summary metrics for use when running the
Thylacine example vignette in demonstration mode. The values were obtained by running
the vignette code for 10 replicate re-runs of the selected 'best' 200 model
simulations with <code>DEMONSTRATION = FALSE</code>.
</p>


<h3>Format</h3>

<p>A data frame with 2,000 rows and 4 variables:
</p>

<dl>
<dt>index</dt><dd><p>Example simulation number from 1 to 2,000</p>
</dd>
<dt>bounty_slope_error</dt><dd><p>Root mean squared error (RMSE) from estimated total bounty submitted across three intervals (see vignette)</p>
</dd>
<dt>ibra_extirpation_error</dt><dd><p>RMSE from estimated extirpation date for each IBRA bioregion (see vignette)</p>
</dd>
<dt>total_extinction</dt><dd><p>Total extinction date for each example simulation (<code>NA</code> when persistent beyond 1967)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Precalculated demonstration via example simulation re-runs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thylacine_example_metrics_rerun)
hist(thylacine_example_metrics_rerun$bounty_slope_error)
hist(thylacine_example_metrics_rerun$ibra_extirpation_error)
hist(thylacine_example_metrics_rerun$total_extinction)

</code></pre>

<hr>
<h2 id='thylacine_hs_raster'>Thylacine vignette habitat suitability raster</h2><span id='topic+thylacine_hs_raster'></span>

<h3>Description</h3>

<p>A <em>raster</em> dataset defining estimated habitat suitability values for each grid
cells of the Tasmanian study region of the Thylacine example vignette.
</p>


<h3>Format</h3>

<p>A <em>raster::RasterLayer</em> object:
</p>

<dl>
<dt>dimensions</dt><dd><p>32 rows by 40 columns grid</p>
</dd>
<dt>resolution</dt><dd><p>0.1 by 0.1 degree grid cells</p>
</dd>
<dt>extent</dt><dd><p>longitude 144.5 to 148.5 degrees; latitude -43.8025 to -40.6025 degrees</p>
</dd>
<dt>CRS</dt><dd><p>WGS84 longitude-latitude</p>
</dd>
<dt>values</dt><dd><p>Estimated habitat suitability values of 0 to 1</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://doi.org/10.1111/2041-210X.13720
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thylacine_hs_raster)
raster::plot(thylacine_hs_raster, colNA = "blue")

</code></pre>

<hr>
<h2 id='Validator'>R6 class representing a pattern-oriented validator.</h2><span id='topic+Validator'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class for pattern-oriented validation and simulation
model ensemble selection. Pattern-oriented validation is a statistical
approach to compare patterns generated in simulations against observed
empirical patterns.
</p>
<p>The class wraps functionality for the validation approach,
typically utilizing an external library, the default being the approximate Bayesian
computation (ABC) <code><a href="abc.html#topic+abc">abc</a></code> library, and includes methods for
resolving non-finite metrics, centering and scaling the validator inputs, running
the validator analysis, and generating diagnostics (see <code><a href="abc.html#topic+abc">abc</a></code>).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code>Validator</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>simulation_parameters</code></dt><dd><p>A data frame of sample model parameters for each simulation.</p>
</dd>
<dt><code>simulation_summary_metrics</code></dt><dd><p>A data frame of result summary metrics for each simulation.</p>
</dd>
<dt><code>observed_metric_targets</code></dt><dd><p>A vector of observed targets for each summary metric.</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>A seed for randomizing the order of the simulation samples (no randomization is utilized when left NULL).</p>
</dd>
<dt><code>random_indices</code></dt><dd><p>Randomized simulation sample indices for the validator inputs and consequently the validator results when random seed is used.</p>
</dd>
<dt><code>non_finite_replacements</code></dt><dd><p>A list of numeric values or function names (character strings) or direct assignments (assigned or loaded via source paths) for replacing NAs in specified (list names) summary metrics.</p>
</dd>
<dt><code>input_center_scale_values</code></dt><dd><p>A nested list of center and scale values for validator input parameters/metrics.</p>
</dd>
<dt><code>output_dir</code></dt><dd><p>Directory path for validator (default: <code><a href="abc.html#topic+abc">abc</a></code>) regression diagnostic and other outputs.</p>
</dd>
<dt><code>validation_call_function</code></dt><dd><p>Dynamically assigned function: <code>function(observed_metric_targets, simulation_parameters, simulation_summary_metrics, tolerance, method, ...)</code> for calling the validation function (default calls <code><a href="abc.html#topic+abc">abc</a></code> library function).</p>
</dd>
<dt><code>validator_return_object</code></dt><dd><p>Object returned by the validator function (see <code><a href="abc.html#topic+abc">abc</a></code> documentation if using default).</p>
</dd>
<dt><code>selected_simulations</code></dt><dd><p>A data frame of simulation sample indices and weights selected/assigned by the validation function (<code><a href="abc.html#topic+abc">abc</a></code> by default).</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Validator-new"><code>Validator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Validator-run"><code>Validator$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Validator-resolve_nonfinite_metrics"><code>Validator$resolve_nonfinite_metrics()</code></a>
</p>
</li>
<li> <p><a href="#method-Validator-center_scale_inputs"><code>Validator$center_scale_inputs()</code></a>
</p>
</li>
<li> <p><a href="#method-Validator-generate_diagnostics"><code>Validator$generate_diagnostics()</code></a>
</p>
</li>
<li> <p><a href="#method-Validator-clone"><code>Validator$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_names"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_names'><code>poems::GenericModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attributes'><code>poems::GenericModel$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="new_clone"><a href='../../poems/html/GenericModel.html#method-GenericModel-new_clone'><code>poems::GenericModel$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="set_attributes"><a href='../../poems/html/GenericModel.html#method-GenericModel-set_attributes'><code>poems::GenericModel$set_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Validator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets given attributes individually and/or from a list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Validator$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed via a <em>params</em> list or individually.</p>
</dd>
<dt><code>template</code></dt><dd><p>Template population model containing fixed (non-sampled) attributes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Validator-run"></a>



<h4>Method <code>run()</code></h4>

<p>Pre-processes inputs, runs validator function for input parameters, and stores the function (and optionally diagnostic) outputs (see <code><a href="abc.html#topic+abc">abc</a></code> documentation if using the default).
</p>


<h5>Usage</h5>

<div class="r"><pre>Validator$run(
  simulation_parameters = NULL,
  simulation_summary_metrics = NULL,
  observed_metric_targets = NULL,
  tolerance = 0.01,
  method = "neuralnet",
  output_diagnostics = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation_parameters</code></dt><dd><p>A data frame of sample model parameters for each simulation.</p>
</dd>
<dt><code>simulation_summary_metrics</code></dt><dd><p>A data frame of result summary metrics for each simulation.</p>
</dd>
<dt><code>observed_metric_targets</code></dt><dd><p>A vector of observed targets for each summary metric.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>Tolerance or proportion of models to select.</p>
</dd>
<dt><code>method</code></dt><dd><p>Validator algorithm to be applied (default is a neural network algorithm - see <code><a href="abc.html#topic+abc">abc</a></code> documentation) .</p>
</dd>
<dt><code>output_diagnostics</code></dt><dd><p>Boolean to indicate whether or not to output diagnostics (PDF file - default is FALSE).</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional validator parameters passed individually (see <code><a href="abc.html#topic+abc">abc</a></code> documentation if using default).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Validator-resolve_nonfinite_metrics"></a>



<h4>Method <code>resolve_nonfinite_metrics()</code></h4>

<p>Attempts to resolve any non-finite simulation summary metric values (and optionally changing them to NAs) via the non finite replacements parameter (a list of values/functions for replacing non-finite values).
</p>


<h5>Usage</h5>

<div class="r"><pre>Validator$resolve_nonfinite_metrics(use_nas = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_nas</code></dt><dd><p>Boolean to indicate whether or not to replace all non-finite values with NAs (default is TRUE).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Validator-center_scale_inputs"></a>



<h4>Method <code>center_scale_inputs()</code></h4>

<p>Centers and scales the model parameters, result summary metrics and observed targets.
</p>


<h5>Usage</h5>

<div class="r"><pre>Validator$center_scale_inputs()</pre></div>


<hr>
<a id="method-Validator-generate_diagnostics"></a>



<h4>Method <code>generate_diagnostics()</code></h4>

<p>Generates the validation diagnostics (see <code><a href="abc.html#topic+abc">abc</a></code> documentation if using default) as a PDF file in the output directory.
</p>


<h5>Usage</h5>

<div class="r"><pre>Validator$generate_diagnostics(output_dir = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output_dir</code></dt><dd><p>Output directory path for the diagnostics PDF file (must be present if not already set within validator class object).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Validator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Validator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Example parameter sample data
sample_data &lt;- data.frame(
  growth_rate_max = round(log(seq(1.11, 1.30, 0.01)), 3),
  harvest_rate = seq(0.11, 0.30, 0.01),
  initial_n = seq(105, 200, 5),
  density_max = seq(132, 170, 2)
)
# Example simulation result summary metrics
summary_metric_data &lt;- data.frame(
  trend_n = seq(10, -9, -1),
  total_h = seq(70, 355, 15)
)
# Create a validator for selecting the 'best' example models
validator &lt;- Validator$new(
  simulation_parameters = sample_data,
  simulation_summary_metrics = summary_metric_data,
  observed_metric_targets = c(trend_n = 0, total_h = 250),
  output_dir = tempdir()
)
suppressWarnings(validator$run(tolerance = 0.25, output_diagnostics = TRUE))
dir(tempdir(), "*.pdf") # plus validation diagnostics (see abc library documentation)
validator$selected_simulations # top 5 models

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
