<!DOCTYPE html><html><head><title>Help for package SLEMI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SLEMI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aux_deleteNA_df'><p>Removing NAs observations from a data frame</p></a></li>
<li><a href='#aux_theme_publ'><p>Tuning GGplot Themes</p></a></li>
<li><a href='#aux_x_log_y'><p>Calculation of expression <code class="reqn">x\cdot \log y</code></p></a></li>
<li><a href='#capacity_logreg_algorithm'><p>Main algorithm to calculate channel capacity by SLEMI approach</p></a></li>
<li><a href='#capacity_logreg_main'><p>Estimate channel capacity between discrete input and continuous output</p></a></li>
<li><a href='#capacity_logreg_testing'><p>Testing procedures for estimation of channel capacity</p></a></li>
<li><a href='#capacity_output_graph_boxplots'><p>Plotting output of capacity estimation. Auxiliary functions.</p></a></li>
<li><a href='#data_example1'><p>Exemplary data set I</p></a></li>
<li><a href='#data_example2'><p>Exemplary data set II</p></a></li>
<li><a href='#data_nfkb'><p>Data from experiment with NFkB pathway</p></a></li>
<li><a href='#func_formula_generator'><p>Formula generator for logistic regression algorithm</p></a></li>
<li><a href='#func_input_checks'><p>Initial verification of input</p></a></li>
<li><a href='#func_iterative_logreg_update'><p>Iterative updating of prior probabilities in logistic regression estimator</p></a></li>
<li><a href='#func_signal_transform'><p>Initial verification and transformation of input variable</p></a></li>
<li><a href='#mi_logreg_algorithm'><p>Main algorithm to calculate mutual information by SLEMI approach</p></a></li>
<li><a href='#mi_logreg_main'><p>Estimate mutual information between discrete input and continuous output</p></a></li>
<li><a href='#mi_logreg_testing'><p>Testing procedures for estimation of mutual information</p></a></li>
<li><a href='#output_graphs_main'><p>Plotting output of capacity estimation and additional exploratory graphs.</p></a></li>
<li><a href='#prob_discr_pairwise'><p>Calculates Probability of pairwise discrimination</p></a></li>
<li><a href='#sampling_bootstrap'><p>Sampling procedures used for testing capacity algorithm</p></a></li>
<li><a href='#SLEMI-package'><p>SLEMI: Statistical Learning Based Estimation of Mutual Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Learning Based Estimation of Mutual Information</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The implementation of the algorithm for estimation of mutual information and channel capacity from experimental data by classification procedures (logistic regression). Technically, it allows to estimate information-theoretic measures between finite-state input and multivariate, continuous output. Method described in Jetka et al. (2019) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1007132">doi:10.1371/journal.pcbi.1007132</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TJetka/SLEMI">https://github.com/TJetka/SLEMI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TJetka/SLEMI/issues">https://github.com/TJetka/SLEMI/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, ggplot2, gridExtra, nnet, Hmisc, reshape2, stringr,
doParallel, caret, corrplot, foreach, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), data.table, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-19 18:32:06 UTC; tomasz_jetka</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomasz Jetka [aut, cre],
  Karol Nienaltowski [ctb],
  Michal Komorowski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tomasz Jetka &lt;t.jetka@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-19 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aux_deleteNA_df'>Removing NAs observations from a data frame</h2><span id='topic+aux_deleteNA_df'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_deleteNA_df(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_deleteNA_df_+3A_data">data</code></td>
<td>
<p>is a data.frame object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object with the same structure as data and no observation with missing (NA) values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df=data.frame(x=c(rnorm(10),NA,NA),y=c(NA,NA,rnorm(10)))
SLEMI:::aux_deleteNA_df(df)
</code></pre>

<hr>
<h2 id='aux_theme_publ'>Tuning GGplot Themes</h2><span id='topic+aux_theme_publ'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_theme_publ(base_size = 12, base_family = "sans", version = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_theme_publ_+3A_base_size">base_size</code></td>
<td>
<p>integer that sets the default size of font used in the plot</p>
</td></tr>
<tr><td><code id="aux_theme_publ_+3A_base_family">base_family</code></td>
<td>
<p>character that indicates what type of font should be used</p>
</td></tr>
<tr><td><code id="aux_theme_publ_+3A_version">version</code></td>
<td>
<p>integer that changes the characteristic of the plot, values 1,2 and 3 accepted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the theme of plots created with the use of ggplot package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(data=data.frame(x=1:10,y=rnorm(10)),aes(x=x,y=y))+
geom_point()+SLEMI:::aux_theme_publ(version=2)
</code></pre>

<hr>
<h2 id='aux_x_log_y'>Calculation of expression <code class="reqn">x\cdot \log y</code></h2><span id='topic+aux_x_log_y'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_x_log_y(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_x_log_y_+3A_x">x</code></td>
<td>
<p>is a numeric vector</p>
</td></tr>
<tr><td><code id="aux_x_log_y_+3A_y">y</code></td>
<td>
<p>is a numeric vector (the same length of x)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function calculates the value of expression <code class="reqn">x\cdot \log y</code> element-wise in a numerically stable way. 
The result is a numeric vector of the same length as x. It is assumed that <code class="reqn">0\cdot \log 0 = 0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SLEMI:::aux_x_log_y(1,2)
SLEMI:::aux_x_log_y(0,0)
SLEMI:::aux_x_log_y(1000,100)
</code></pre>

<hr>
<h2 id='capacity_logreg_algorithm'>Main algorithm to calculate channel capacity by SLEMI approach</h2><span id='topic+capacity_logreg_algorithm'></span>

<h3>Description</h3>

<p>Additional parameters: lr_maxit and maxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users). It is recommended to conduct estimation by calling capacity_logreg_main.R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity_logreg_algorithm(
  data,
  signal = "signal",
  response = "response",
  side_variables = NULL,
  formula_string = NULL,
  model_out = TRUE,
  cc_maxit = 100,
  lr_maxit = 1000,
  MaxNWts = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity_logreg_algorithm_+3A_data">data</code></td>
<td>
<p>must be a data.frame object. Cannot contain NA values.</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_model_out">model_out</code></td>
<td>
<p>is the logical indicating if the calculated logistic regression model should be included in output list</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_cc_maxit">cc_maxit</code></td>
<td>
<p>is the number of iteration of iterative optimisation of the algorithm to estimate channel capacity. Default is 100.</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="capacity_logreg_algorithm_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements:
</p>

<ul>
<li><p> output$cc         - channel capacity in bits
</p>
</li>
<li><p> output$p_opt      - optimal probability distribution
</p>
</li>
<li><p> output$regression - confusion matrix of logistic regression predictions
</p>
</li>
<li><p> output$model      - nnet object describing logistic regression model (if model_out=TRUE)
</p>
</li></ul>



<h3>References</h3>

<p>[1] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tempdata=data_example1 
outputCLR1=capacity_logreg_algorithm(data=tempdata, signal="signal",
response="response",cc_maxit=3,model_out=FALSE,
formula_string = "signal~response")

</code></pre>

<hr>
<h2 id='capacity_logreg_main'>Estimate channel capacity between discrete input and continuous output</h2><span id='topic+capacity_logreg_main'></span>

<h3>Description</h3>

<p>The main wrapping function for basic usage of SLEMI package for estimation of channel capacity. Firstly, data is pre-processed
(all arguments are checked, observation with NAs are removed, variables are scaled and centered (if scale=TRUE)). Then basic estimation is carried out
and (if testing=TRUE) diagnostic tests are computed. If output directory path is given (output_path is not NULL), graphs visualising the data and the analysis
are saved there, together with a compressed output object (as .rds file) with full estimation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity_logreg_main(
  dataRaw,
  signal = "input",
  response = NULL,
  output_path = NULL,
  side_variables = NULL,
  formula_string = NULL,
  cc_maxit = 100,
  lr_maxit = 1000,
  MaxNWts = 5000,
  testing = FALSE,
  model_out = TRUE,
  scale = TRUE,
  TestingSeed = 1234,
  testing_cores = 1,
  boot_num = 10,
  boot_prob = 0.8,
  sidevar_num = 10,
  traintest_num = 10,
  partition_trainfrac = 0.6,
  plot_width = 6,
  plot_height = 4,
  data_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity_logreg_main_+3A_dataraw">dataRaw</code></td>
<td>
<p>must be a data.frame object</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_output_path">output_path</code></td>
<td>
<p>is the directory in which output will be saved</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_cc_maxit">cc_maxit</code></td>
<td>
<p>is the number of iteration of iterative optimisation of the algorithm to estimate channel capacity. Default is 100.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_testing">testing</code></td>
<td>
<p>is the logical indicating if the testing procedures should be executed</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_model_out">model_out</code></td>
<td>
<p>is the logical indicating if the calculated logistic regression model should be included in output list</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_scale">scale</code></td>
<td>
<p>is a logical indicating if the response variables should be scaled and centered before fitting logistic regression</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_testingseed">TestingSeed</code></td>
<td>
<p>is the seed for random number generator used in testing procedures</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_testing_cores">testing_cores</code></td>
<td>
<p>- number of cores to be used in parallel computing (via doParallel package)</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_boot_num">boot_num</code></td>
<td>
<p>is the number of bootstrap tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_boot_prob">boot_prob</code></td>
<td>
<p>is the proportion of initial size of data to be used in bootstrap</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_sidevar_num">sidevar_num</code></td>
<td>
<p>is the number of re-shuffling tests of side variables to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_traintest_num">traintest_num</code></td>
<td>
<p>is the number of overfitting tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_partition_trainfrac">partition_trainfrac</code></td>
<td>
<p>is the fraction of data to be used as a training dataset</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_plot_width">plot_width</code></td>
<td>
<p>-  basic dimensions (width) of plots, in inches</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_plot_height">plot_height</code></td>
<td>
<p>-  basic dimensions (height) of plots, in inches</p>
</td></tr>
<tr><td><code id="capacity_logreg_main_+3A_data_out">data_out</code></td>
<td>
<p>is the logical indicating if the data should be included in output list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a typical experiment aimed to quantify information flow a given signaling system, input values <code class="reqn">x_1\leq x_2 \ldots... \leq x_m</code>, ranging from 0 to saturation are considered.
Then, for each input level, <code class="reqn">x_i</code>, <code class="reqn">n_i</code> observations are collected, which are represented as vectors 
</p>
<p style="text-align: center;"><code class="reqn">y^i_j \sim P(Y|X = x_i)</code>
</p>

<p>Within information theory the degree of information transmission is measured as the mutual information
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) = \sum_{i=1}^{m} P(x_i)\int_{R^k} P(y|X = x_i)log_2\frac{P(y|X = x_i)}{P(y)}dy,</code>
</p>

<p>where <code class="reqn">P(y)</code> is the marginal distribution of the output. MI is expressed in bits and <code class="reqn">2^{MI}</code> can be interpreted as the number of 
inputs that the system can resolve on average.
</p>
<p>The maximization of mutual information with respect to the input distribution, <code class="reqn">P(X)</code>,
defines the information capacity, C. Formally,
</p>
<p style="text-align: center;"><code class="reqn">C^* = max_{P(X)} MI(X,Y)</code>
</p>

<p>Information capacity is expressed in bits and <code class="reqn">2^{C^*}</code> can be interpreted as the maximal number of inputs that the system can
effectively resolve.
</p>
<p>In contrast to existing approaches, instead of estimating, possibly highly dimensional, conditional output distributions P(Y|X =x_i), we propose to estimate the discrete, conditional input distribution, 
<code class="reqn">P(x_i |Y = y)</code>, which is known to be a simpler problem. Estimation of the MI using estimates of <code class="reqn">P(x_i |Y = y)</code>, denoted here as <code class="reqn">\hat{P}(x_i|Y = y)</code>, is possible as the MI, can be
alternatively written as
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) = \sum_{i=1}^{m} P(x_i)\int_{R^k} P(y|X = x_i)log_2\frac{P(x_i|Y = y)}{P(x_i)}dy</code>
</p>

<p>The expected value (as in above expression) with respect to distribution <code class="reqn">P(Y|X = x_i)</code> can be approximated by the average with respect to data
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) \approx \sum_{i=1}^{m} P(x_i)\frac{1}{n_i} \sum_{j=1}^{n_i} P(y|X = x_i)log_2\frac{\hat{P}(x_i|Y = y^i_j)}{P(x_i)}dy</code>
</p>

<p>Here, we propose to use logistic regression as <code class="reqn">\hat{P}(x_i|Y = y^i_j)</code>. Specifically,
</p>
<p style="text-align: center;"><code class="reqn">log\frac{P(x_i |Y = y)}{P(x_m|Y = y)} \approx \alpha_i +\beta_iy</code>
</p>

<p>Following this approach, channel capacity can be calculated by optimising MI with respect to the input distribution, <code class="reqn">P(X)</code>.
However, this, potentially difficult problem, can be divided into two simpler maximization problems, for which explicit solutions exist. 
Therefore, channel capacity can be obtained from the two explicit solutions in an iterative procedure known as alternate maximization (similarly as in Blahut-Arimoto algorithm) [1].
</p>
<p>Additional parameters: lr_maxit and maxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users). Preliminary scaling of  data (argument scale) should be used similarly as in other 
data-driven approaches, e.g. if response variables are comparable, scaling (scale=FALSE) can be omitted, while if they represent 
different phenomenon (varying by units and/or magnitude) scaling is recommended.
</p>


<h3>Value</h3>

<p>a list with several elements:
</p>

<ul>
<li><p> output$regression - confusion matrix of logistic regression predictions
</p>
</li>
<li><p> output$cc         - channel capacity in bits
</p>
</li>
<li><p> output$p_opt      - optimal probability distribution
</p>
</li>
<li><p> output$model      - nnet object describing logistic regression model (if model_out=TRUE)
</p>
</li>
<li><p> output$params     - parameters used in algorithm
</p>
</li>
<li><p> output$time       - computation time of calculations
</p>
</li>
<li><p> output$testing    - a 2- or 4-element output list of testing procedures (if testing=TRUE)
</p>
</li>
<li><p> output$testing_pv - one-sided p-values of testing procedures (if testing=TRUE)
</p>
</li>
<li><p> output$data       - raw data used in analysis
</p>
</li></ul>



<h3>References</h3>

<p>[1] Csiszar I, Tusnady G, Information geometry and alternating minimization procedures, Statistics &amp; Decisions 1 Supplement 1 (1984), 205â€“237.
</p>
<p>[2] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tempdata=data_example1
outputCLR1=capacity_logreg_main(dataRaw=tempdata,
signal="signal", response="response",cc_maxit = 10,
formula_string = "signal~response")

tempdata=data_example2
outputCLR2=capacity_logreg_main(dataRaw=tempdata,
signal="signal", response=c("X1","X2"),cc_maxit = 10,
formula_string = "signal~X1+X2") 

#For further details see vignette
</code></pre>

<hr>
<h2 id='capacity_logreg_testing'>Testing procedures for estimation of channel capacity</h2><span id='topic+capacity_logreg_testing'></span>

<h3>Description</h3>

<p>Diagnostic procedures that allows to compute the  uncertainty of estimation of channel capacity by SLEMI approach. Two main procedures are implemented:
bootstrap, which execute estimation with using a fraction of data and overfitting test, which divides data into two parts: training and testing. Each of them
is repeated specified number of times to obtain a distribution of our estimators. It is recommended to conduct estimation by calling capacity_logreg_main.R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity_logreg_testing(
  data,
  signal = "signal",
  response = "response",
  side_variables = NULL,
  cc_maxit = 100,
  lr_maxit = 1000,
  MaxNWts = 5000,
  formula_string = NULL,
  TestingSeed = 1234,
  testing_cores = 1,
  boot_num = 10,
  boot_prob = 0.8,
  sidevar_num = 10,
  traintest_num = 10,
  partition_trainfrac = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity_logreg_testing_+3A_data">data</code></td>
<td>
<p>must be a data.frame object. Cannot contain NA values.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_cc_maxit">cc_maxit</code></td>
<td>
<p>is the number of iteration of iterative optimisation of the algorithm to estimate channel capacity. Default is 100.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_testingseed">TestingSeed</code></td>
<td>
<p>is the seed for random number generator used in testing procedures</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_testing_cores">testing_cores</code></td>
<td>
<p>- number of cores to be used in parallel computing (via doParallel package)</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_boot_num">boot_num</code></td>
<td>
<p>is the number of bootstrap tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_boot_prob">boot_prob</code></td>
<td>
<p>is the proportion of initial size of data to be used in bootstrap. Default is 0.8.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_sidevar_num">sidevar_num</code></td>
<td>
<p>is the number of re-shuffling tests of side variables to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_traintest_num">traintest_num</code></td>
<td>
<p>is the number of overfitting tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="capacity_logreg_testing_+3A_partition_trainfrac">partition_trainfrac</code></td>
<td>
<p>is the fraction of data to be used as a training dataset. Default is 0.6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If side variables are added within the analysis (side_variables is not NULL), two additional procedures are carried out:
reshuffling test and reshuffling with bootstrap test, which are based on permutation of side variables values within the dataset.  
Additional parameters: lr_maxit and MaxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users).
</p>


<h3>Value</h3>

<p>a list with four elements:
</p>

<ul>
<li><p> output$bootstrap - confusion matrix of logistic regression predictions
</p>
</li>
<li><p> output$resamplingMorph          - channel capacity in bits
</p>
</li>
<li><p> output$traintest      - optimal probability distribution
</p>
</li>
<li><p> output$bootResampMorph      - nnet object describing logistic regression model (if model_out=TRUE)
</p>
</li></ul>

<p>Each of above is a list, where an element is an output of a single repetition of the channel capacity algorithm
</p>


<h3>References</h3>

<p>[1] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please set boot_num and traintest_num with larger numbers 
## for a more reliable testing
tempdata=data_example1
outputCLR1_testing=capacity_logreg_testing(data=tempdata,
signal="signal", response="response",cc_maxit=10,
TestingSeed=11111, boot_num=1,boot_prob=0.8,testing_cores=1,
traintest_num=1,partition_trainfrac=0.6)

</code></pre>

<hr>
<h2 id='capacity_output_graph_boxplots'>Plotting output of capacity estimation. Auxiliary functions.</h2><span id='topic+capacity_output_graph_boxplots'></span><span id='topic+capacity_output_graph_violinMean'></span><span id='topic+capacity_output_graph_boxplotsSideVar'></span><span id='topic+capacity_output_graph_capacity'></span>

<h3>Description</h3>

<p>INPUT:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity_output_graph_boxplots(
  data,
  signal,
  response,
  path,
  height = 4,
  width = 6
)

capacity_output_graph_violinMean(
  data,
  signal,
  response,
  path,
  height = 4,
  width = 6
)

capacity_output_graph_boxplotsSideVar(
  data,
  signal,
  side_variables,
  path,
  height = 4,
  width = 6
)

capacity_output_graph_capacity(cc_output, path, height = 4, width = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity_output_graph_boxplots_+3A_data">data</code></td>
<td>
<p>is a data.frame object</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_signal">signal</code></td>
<td>
<p>is a character object that indicates columns of data that should be treated as channel's input</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_response">response</code></td>
<td>
<p>is a character vector that indicates columns of data that should be treated as channel's output</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_path">path</code></td>
<td>
<p>character giving the directory, where graphs should be saved</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_height">height</code></td>
<td>
<p>integer indicating the height of a single plot</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_width">width</code></td>
<td>
<p>integer indicating the width of a single plot</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_side_variables">side_variables</code></td>
<td>
<p>is a character vector that indicates side variables' columns of data</p>
</td></tr>
<tr><td><code id="capacity_output_graph_boxplots_+3A_cc_output">cc_output</code></td>
<td>
<p>a list that is the output of capacity_logreg_algorithm function</p>
</td></tr>
</table>

<hr>
<h2 id='data_example1'>Exemplary data set I</h2><span id='topic+data_example1'></span>

<h3>Description</h3>

<p>A dataset describing simple one dimensional input - one dimensional output channel 
with 500 observations per input. In addition, each observation is assigned to one of three types
that occurs with propensities (0.6,0.3,0.1), respectively 
Conditional output distributions are Gaussian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_example1
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 rows and 3 variables:
</p>

<dl>
<dt>signal</dt><dd><p>Label of input</p>
</dd>
<dt>response</dt><dd><p>The value of output</p>
</dd>
<dt>sideVar</dt><dd><p>Label of the type of given observation</p>
</dd>
</dl>



<h3>Source</h3>

<p>synthetic
</p>

<hr>
<h2 id='data_example2'>Exemplary data set II</h2><span id='topic+data_example2'></span>

<h3>Description</h3>

<p>A dataset describing a channel with 3 possible inputs and 3-dimensional output
with 500 observations per input.
Conditional output distributions are multivariate Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_example2
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 rows and 4 variables:
</p>

<dl>
<dt>signal</dt><dd><p>Label of input</p>
</dd>
<dt>X1</dt><dd><p>The value of first dimension of output</p>
</dd>
<dt>X2</dt><dd><p>The value of second dimension of output</p>
</dd>
<dt>X3</dt><dd><p>The value of third dimension of output</p>
</dd>
</dl>



<h3>Source</h3>

<p>synthetic
</p>

<hr>
<h2 id='data_nfkb'>Data from experiment with NFkB pathway</h2><span id='topic+data_nfkb'></span>

<h3>Description</h3>

<p>In the paper describing methodological aspects of our algorithm we present the analysis of information transmission 
in NfkB pathway upon the stimulation of TNF-<code class="reqn">\alpha</code>. Experimental data from this experiment in the form of single-cell 
time series are attached to the package as a data.frame object and can be accessed using 'data_nfkb' variable.
Each row of &lsquo;data_nfkb' represents a single observation of a cell. Column &rsquo;signal' indicates the level of TNF-<code class="reqn">\alpha</code>
stimulation for a given cell, while columns 'response_T', gives the normalised ratio of nuclear and cytoplasmic transcription 
factor as described in Supplementary Methods of the corresponding publication. In the CRAN version of the package
we included only a subset of the data (5 time measurements). For the full datasets, please access GitHub pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_nfkb
</code></pre>


<h3>Format</h3>

<p>A data frame with 15632 rows and 6 variables:
</p>

<dl>
<dt>signal</dt><dd><p>Level of TNFa stimulation</p>
</dd>
<dt>response_0</dt><dd><p>The concentration of normalised NfkB transcription factor, measured at time 0</p>
</dd>
<dt>response_3</dt><dd><p>The concentration of normalised NfkB transcription factor, measured at time 3</p>
</dd>
<dt>response_21</dt><dd><p>The concentration of normalised NfkB transcription factor, measured at time 21</p>
</dd>
<dt>response_90</dt><dd><p>The concentration of normalised NfkB transcription factor, measured at time 90</p>
</dd>
<dt>response_120</dt><dd><p>The concentration of normalised NfkB transcription factor, measured at time 120</p>
</dd>
</dl>
<p>#' 
</p>


<h3>Details</h3>

<p>For each concentration, there are at least 1000 single-cell observation (with the exception of 0.5ng stimulation, 
where the number of identified cells is almost 900)
</p>


<h3>Source</h3>

<p>in-house experimental data
</p>

<hr>
<h2 id='func_formula_generator'>Formula generator for logistic regression algorithm</h2><span id='topic+func_formula_generator'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>func_formula_generator(
  signal = "signal",
  response = "response",
  side_variables = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="func_formula_generator_+3A_signal">signal</code></td>
<td>
<p>is a character object that indicates columns of data to be treated as channel's input</p>
</td></tr>
<tr><td><code id="func_formula_generator_+3A_response">response</code></td>
<td>
<p>is a character vector that indicates columns of data to be treated as channel's output</p>
</td></tr>
<tr><td><code id="func_formula_generator_+3A_side_variables">side_variables</code></td>
<td>
<p>is a character vector that indicates side variables' columns of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character object that includes a standard formula syntax to use in algorithm for capacity calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SLEMI:::func_formula_generator(signal="signal",response="response", side_variables=NULL)
SLEMI:::func_formula_generator(signal="inputX",response="responseY", side_variables="SV1")
SLEMI:::func_formula_generator(signal="signalX",response=c("r_1","r_2","r_5"), side_variables="SV")
</code></pre>

<hr>
<h2 id='func_input_checks'>Initial verification of input</h2><span id='topic+func_input_checks'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>func_input_checks(data, signal, response, side_variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="func_input_checks_+3A_data">data</code></td>
<td>
<p>is an input object that should be a data.frame</p>
</td></tr>
<tr><td><code id="func_input_checks_+3A_signal">signal</code></td>
<td>
<p>is a character object that indicates input columns of data</p>
</td></tr>
<tr><td><code id="func_input_checks_+3A_response">response</code></td>
<td>
<p>is a character vector that indicates output's columns of data</p>
</td></tr>
<tr><td><code id="func_input_checks_+3A_side_variables">side_variables</code></td>
<td>
<p>is a character vector that indicates side variables' columns of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all initial data is valid, string &quot;ok&quot; is returned. Otherwise, error is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data=data_example1
SLEMI:::func_input_checks(data=data,signal="signal",
response="response",side_variables="sideVar")

# The following examples will give errors, because  the data has 
# inconsistent format for the analysis. Only to check the adequacy of
# initial checks. 
# data=as.matrix(data_example1)
# SLEMI:::func_input_checks(data=data,signal="signal",
# response="response",side_variables="sideVar")
# data=data_example1
# SLEMI:::func_input_checks(data=data,signal="input",
# response="response",side_variables="sideVar")
</code></pre>

<hr>
<h2 id='func_iterative_logreg_update'>Iterative updating of prior probabilities in logistic regression estimator</h2><span id='topic+func_iterative_logreg_update'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>func_iterative_logreg_update(prob_lr, p0, cell_id, signal_levels, cc_maxit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="func_iterative_logreg_update_+3A_prob_lr">prob_lr</code></td>
<td>
<p>is a matrix of class probabilities for each observation</p>
</td></tr>
<tr><td><code id="func_iterative_logreg_update_+3A_p0">p0</code></td>
<td>
<p>is a numeric vector of prior probabilities used for logistic regression estimation</p>
</td></tr>
<tr><td><code id="func_iterative_logreg_update_+3A_cell_id">cell_id</code></td>
<td>
<p>a list of logical vectors indicating class labels of each observation</p>
</td></tr>
<tr><td><code id="func_iterative_logreg_update_+3A_signal_levels">signal_levels</code></td>
<td>
<p>is a vector of class labels</p>
</td></tr>
<tr><td><code id="func_iterative_logreg_update_+3A_cc_maxit">cc_maxit</code></td>
<td>
<p>is the number of iteration of procedure to be carried out</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<ol>
<li><p> p_opt - a numeric vectors with estimated optimal input probabilities
</p>
</li>
<li><p> MI_opt -  a numerical value of estimated channel capacity
</p>
</li></ol>


<hr>
<h2 id='func_signal_transform'>Initial verification and transformation of input variable</h2><span id='topic+func_signal_transform'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>func_signal_transform(data, signal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="func_signal_transform_+3A_data">data</code></td>
<td>
<p>is a data.frame</p>
</td></tr>
<tr><td><code id="func_signal_transform_+3A_signal">signal</code></td>
<td>
<p>is a character that indicates columns of data that include the labels of input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that is a copy of data provided with signal column transformed to factor class. 
If signal has been numeric initially, additional column is created &quot;signal_RAW&quot; that is an exact
copy of original column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data=data_example1
data1=SLEMI:::func_signal_transform(data,"signal")
data$signal=as.character(data$signal)
data2=SLEMI:::func_signal_transform(data,"signal")
data$signal=as.numeric(data$signal)
data3=SLEMI:::func_signal_transform(data,"signal")
</code></pre>

<hr>
<h2 id='mi_logreg_algorithm'>Main algorithm to calculate mutual information by SLEMI approach</h2><span id='topic+mi_logreg_algorithm'></span>

<h3>Description</h3>

<p>Additional parameters: lr_maxit and maxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users). It is recommended to conduct estimation by calling mi_logreg_main.R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi_logreg_algorithm(
  data,
  signal = "signal",
  response = "response",
  side_variables = NULL,
  pinput = NULL,
  formula_string = NULL,
  lr_maxit = 1000,
  MaxNWts = 5000,
  model_out = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_logreg_algorithm_+3A_data">data</code></td>
<td>
<p>must be a data.frame object. Cannot contain NA values.</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_pinput">pinput</code></td>
<td>
<p>is a numeric vector with prior probabilities of the input values. Uniform distribution is assumed as default (pinput=NULL).</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="mi_logreg_algorithm_+3A_model_out">model_out</code></td>
<td>
<p>is the logical indicating if the calculated logistic regression model should be included in output list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements:
</p>

<ul>
<li><p> output$mi         - mutual information in bits
</p>
</li>
<li><p> output$pinput     - prior probabilities used in estimation
</p>
</li>
<li><p> output$regression - confusion matrix of logistic regression model
</p>
</li>
<li><p> output$model      - nnet object describing logistic regression model (if model_out=TRUE)
</p>
</li></ul>



<h3>References</h3>

<p>[1] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate mutual information directly
temp_data=data_example1
output=mi_logreg_algorithm(data=data_example1,
                   signal = "signal",
                   response = "response")

</code></pre>

<hr>
<h2 id='mi_logreg_main'>Estimate mutual information between discrete input and continuous output</h2><span id='topic+mi_logreg_main'></span>

<h3>Description</h3>

<p>The main wrapping function for basic usage of SLEMI package for estimation of mutual information. Firstly, data is pre-processed
(all arguments are checked, observation with NAs are removed, variables are scaled and centered (if scale=TRUE)). Then basic estimation is carried out
and (if testing=TRUE) diagnostic tests are computed. If output directory path is given (output_path is not NULL), graphs visualising the data and the analysis
are saved there, together with a compressed output object (as .rds file) with full estimation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi_logreg_main(
  dataRaw,
  signal = "input",
  response = NULL,
  output_path = NULL,
  side_variables = NULL,
  pinput = NULL,
  formula_string = NULL,
  lr_maxit = 1000,
  MaxNWts = 5000,
  testing = FALSE,
  model_out = TRUE,
  scale = TRUE,
  TestingSeed = 1234,
  testing_cores = 1,
  boot_num = 10,
  boot_prob = 0.8,
  sidevar_num = 10,
  traintest_num = 10,
  partition_trainfrac = 0.6,
  plot_width = 6,
  plot_height = 4,
  data_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_logreg_main_+3A_dataraw">dataRaw</code></td>
<td>
<p>must be a data.frame object</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_output_path">output_path</code></td>
<td>
<p>is the directory in which output will be saved</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_pinput">pinput</code></td>
<td>
<p>is a numeric vector with prior probabilities of the input values. Uniform distribution is assumed as default (pinput=NULL).</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_testing">testing</code></td>
<td>
<p>is the logical indicating if the testing procedures should be executed</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_model_out">model_out</code></td>
<td>
<p>is the logical indicating if the calculated logistic regression model should be included in output list</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_scale">scale</code></td>
<td>
<p>is a logical indicating if the response variables should be scaled and centered before fitting logistic regression</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_testingseed">TestingSeed</code></td>
<td>
<p>is the seed for random number generator used in testing procedures</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_testing_cores">testing_cores</code></td>
<td>
<p>- number of cores to be used in parallel computing (via doParallel package)</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_boot_num">boot_num</code></td>
<td>
<p>is the number of bootstrap tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_boot_prob">boot_prob</code></td>
<td>
<p>is the proportion of initial size of data to be used in bootstrap</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_sidevar_num">sidevar_num</code></td>
<td>
<p>is the number of re-shuffling tests of side variables to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_traintest_num">traintest_num</code></td>
<td>
<p>is the number of overfitting tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_partition_trainfrac">partition_trainfrac</code></td>
<td>
<p>is the fraction of data to be used as a training dataset</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_plot_width">plot_width</code></td>
<td>
<p>-  basic dimensions (width) of plots, in inches</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_plot_height">plot_height</code></td>
<td>
<p>-  basic dimensions (height) of plots, in inches</p>
</td></tr>
<tr><td><code id="mi_logreg_main_+3A_data_out">data_out</code></td>
<td>
<p>is the logical indicating if the data should be included in output list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a typical experiment aimed to quantify information flow a given signaling system, input values <code class="reqn">x_1\leq x_2 \ldots... \leq x_m</code>, ranging from 0 to saturation are considered.
Then, for each input level, <code class="reqn">x_i</code>, <code class="reqn">n_i</code> observations are collected, which are represented as vectors 
</p>
<p style="text-align: center;"><code class="reqn">y^i_j \sim P(Y|X = x_i)</code>
</p>

<p>Within information theory the degree of information transmission is measured as the mutual information
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) = \sum_{i=1}^{m} P(x_i)\int_{R^k} P(y|X = x_i)log_2\frac{P(y|X = x_i)}{P(y)}dy,</code>
</p>

<p>where <code class="reqn">P(y)</code> is the marginal distribution of the output. MI is expressed in bits and <code class="reqn">2^{MI}</code> can be interpreted as the number of 
inputs that the system can resolve on average.
</p>
<p>In contrast to existing approaches, instead of estimating, possibly highly dimensional, conditional output distributions <code class="reqn">P(Y|X =x_i)</code>, we propose to estimate the discrete, conditional input distribution, 
<code class="reqn">P(x_i |Y = y)</code>, which is known to be a simpler problem. Estimation of the MI using estimates of <code class="reqn">P(x_i |Y = y)</code>, denoted here as <code class="reqn">\hat{P}(x_i|Y = y)</code>, is possible as the MI, can be
alternatively written as
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) = \sum_{i=1}^{m} P(x_i)\int_{R^k} P(y|X = x_i)log_2\frac{P(x_i|Y = y)}{P(x_i)}dy</code>
</p>

<p>The expected value (as in above expression) with respect to distribution <code class="reqn">P(Y|X = x_i)</code> can be approximated by the average with respect to data
</p>
<p style="text-align: center;"><code class="reqn">MI(X,Y) \approx \sum_{i=1}^{m} P(x_i)\frac{1}{n_i} \sum_{j=1}^{n_i} P(y|X = x_i)log_2\frac{\hat{P}(x_i|Y = y^i_j)}{P(x_i)}dy</code>
</p>

<p>Here, we propose to use logistic regression as <code class="reqn">\hat{P}(x_i|Y = y^i_j)</code>. Specifically,
</p>
<p style="text-align: center;"><code class="reqn">log\frac{P(x_i |Y = y)}{P(x_m|Y = y)} \approx \alpha_i +\beta_iy</code>
</p>

<p>Additional parameters: lr_maxit and maxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users). Preliminary scaling of  data (argument scale) should be used similarly as in other 
data-driven approaches, e.g. if response variables are comparable, scaling (scale=FALSE) can be omitted, while if they represent 
different phenomenon (varying by units and/or magnitude) scaling is recommended.
</p>


<h3>Value</h3>

<p>a list with several elements:
</p>

<ul>
<li><p> output$regression - confusion matrix of logistic regression predictions
</p>
</li>
<li><p> output$mi         - mutual information in bits
</p>
</li>
<li><p> output$model      - nnet object describing logistic regression model (if model_out=TRUE)
</p>
</li>
<li><p> output$params     - parameters used in algorithm
</p>
</li>
<li><p> output$time       - computation time of calculations
</p>
</li>
<li><p> output$testing    - a 2- or 4-element output list of testing procedures (if testing=TRUE)
</p>
</li>
<li><p> output$testing_pv - one-sided p-values of testing procedures (if testing=TRUE)
</p>
</li>
<li><p> output$data       - raw data used in analysis
</p>
</li></ul>



<h3>References</h3>

<p>[1] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tempdata=data_example1
outputCLR1=mi_logreg_main(dataRaw=tempdata, signal="signal", response="response")

tempdata=data_example2
outputCLR2=mi_logreg_main(dataRaw=tempdata, signal="signal", response=c("X1","X2","X3")) 

#For further details see vignette
</code></pre>

<hr>
<h2 id='mi_logreg_testing'>Testing procedures for estimation of mutual information</h2><span id='topic+mi_logreg_testing'></span>

<h3>Description</h3>

<p>Diagnostic procedures that allows to compute the  uncertainty of estimation of mutual information by SLEMI approach. Two main procedures are implemented:
bootstrap, which execute estimation with using a fraction of data and overfitting test, which divides data into two parts: training and testing. Each of them
is repeated specified number of times to obtain a distribution of our estimators. It is recommended to call this function from mi_logreg_main.R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi_logreg_testing(
  data,
  signal = "signal",
  response = "response",
  side_variables = NULL,
  pinput = NULL,
  lr_maxit = 1000,
  MaxNWts = 5000,
  formula_string = NULL,
  TestingSeed = 1234,
  testing_cores = 1,
  boot_num = 10,
  boot_prob = 0.8,
  sidevar_num = 10,
  traintest_num = 10,
  partition_trainfrac = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_logreg_testing_+3A_data">data</code></td>
<td>
<p>must be a data.frame object. Cannot contain NA values.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_pinput">pinput</code></td>
<td>
<p>is a numeric vector with prior probabilities of the input values. Uniform distribution is assumed as default (pinput=NULL).</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_testingseed">TestingSeed</code></td>
<td>
<p>is the seed for random number generator used in testing procedures</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_testing_cores">testing_cores</code></td>
<td>
<p>- number of cores to be used in parallel computing (via doParallel package)</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_boot_num">boot_num</code></td>
<td>
<p>is the number of bootstrap tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_boot_prob">boot_prob</code></td>
<td>
<p>is the proportion of initial size of data to be used in bootstrap</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_sidevar_num">sidevar_num</code></td>
<td>
<p>is the number of re-shuffling tests of side variables to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_traintest_num">traintest_num</code></td>
<td>
<p>is the number of overfitting tests to be performed. Default is 10, but it is recommended to use at least 50 for reliable estimates.</p>
</td></tr>
<tr><td><code id="mi_logreg_testing_+3A_partition_trainfrac">partition_trainfrac</code></td>
<td>
<p>is the fraction of data to be used as a training dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If side variables are added within the analysis (side_variables is not NULL), two additional procedures are carried out:
reshuffling test and reshuffling with bootstrap test, which are based on permutation of side variables values within the dataset.  
Additional parameters: lr_maxit and MaxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users).
</p>


<h3>Value</h3>

<p>a list with elements:
</p>

<ul>
<li><p> output$bootstrap - bootstrap test
</p>
</li>
<li><p> output$traintest - overfitting test
</p>
</li>
<li><p> output$reshuffling_sideVar - (if side_variables is not NULL) re-shuffling test
</p>
</li>
<li><p> output$bootstrap_Reshuffling_sideVar - (if side_variables is not NULL) re-shuffling test with a bootstrap
</p>
</li></ul>

<p>Each of the above is a list, where an element is a standard output of a single mi_logreg_algorithm run.
</p>


<h3>References</h3>

<p>[1] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute  uncertainty of mutual information estimator using 1 core
## Set boot_num and traintest_num with larger numbers for more reliable testing
tempdata=data_example1
output=mi_logreg_testing(data=tempdata,
                   signal = "signal",
                   response = "response",
                   testing_cores = 1,boot_num=1,traintest_num=1)
</code></pre>

<hr>
<h2 id='output_graphs_main'>Plotting output of capacity estimation and additional exploratory graphs.</h2><span id='topic+output_graphs_main'></span>

<h3>Description</h3>

<p>INPUT:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_graphs_main(
  data,
  signal,
  response,
  side_variables,
  cc_output,
  output_path,
  height = 4,
  width = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_graphs_main_+3A_data">data</code></td>
<td>
<p>is a data.frame object</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_signal">signal</code></td>
<td>
<p>is a character object that indicates columns of data that should be treated as channel's input</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_response">response</code></td>
<td>
<p>is a character vector that indicates columns of data that should be treated as channel's output</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_side_variables">side_variables</code></td>
<td>
<p>is a character vector that indicates side variables' columns of data</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_cc_output">cc_output</code></td>
<td>
<p>a list that is a standard output of capacity_logreg_algorithm function</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_output_path">output_path</code></td>
<td>
<p>character giving the directory, where graphs should be saved</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_height">height</code></td>
<td>
<p>integer indicating the height of a single plot</p>
</td></tr>
<tr><td><code id="output_graphs_main_+3A_width">width</code></td>
<td>
<p>integer indicating the width of a single plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with ggplot or gtable object. Each plot is also saved in 'output_path' directory in separate pdfs files which include:
</p>

<ul>
<li><p> MainPlot.pdf - a simple summary plot with basic distribution visualization and capacity estimate
</p>
</li>
<li><p> MainPlot_full.pdf - a comprehensive summary plot with distribution visualization and capacity estimate
</p>
</li>
<li><p> capacity.pdf - a diagram presenting the capacity estimates
</p>
</li>
<li><p> io_relation.pdf - a graph with input-output relation
</p>
</li>
<li><p> kdensities.pdf - kernel density estimator of data distribution
</p>
</li>
<li><p> histograms.pdf - histograms of data
</p>
</li>
<li><p> boxplots.pdf - boxplots of data
</p>
</li>
<li><p> violin.pdf - violin plots of data
</p>
</li></ul>


<hr>
<h2 id='prob_discr_pairwise'>Calculates Probability of pairwise discrimination</h2><span id='topic+prob_discr_pairwise'></span>

<h3>Description</h3>

<p>Estimates probabilities of correct discrimination (PCDs) between each pair of input/signal values using a logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_discr_pairwise(
  dataRaw,
  signal = "input",
  response = NULL,
  side_variables = NULL,
  formula_string = NULL,
  output_path = NULL,
  scale = TRUE,
  lr_maxit = 1000,
  MaxNWts = 5000,
  diagnostics = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_discr_pairwise_+3A_dataraw">dataRaw</code></td>
<td>
<p>must be a data.frame object</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_signal">signal</code></td>
<td>
<p>is a character object with names of columns of dataRaw to be treated as channel's input.</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_response">response</code></td>
<td>
<p>is a character vector with names of columns of dataRaw  to be treated as channel's output</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_side_variables">side_variables</code></td>
<td>
<p>(optional) is a character vector that indicates side variables' columns of data, if NULL no side variables are included</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_formula_string">formula_string</code></td>
<td>
<p>(optional) is a character object that includes a formula syntax to use in logistic regression model. 
If NULL, a standard additive model of response variables is assumed. Only for advanced users.</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_output_path">output_path</code></td>
<td>
<p>is a directory where a pie chart with calculated probabilities will be saved. If NULL, the graph will not be created.</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_scale">scale</code></td>
<td>
<p>is a logical indicating if the response variables should be scaled and centered before fitting logistic regression</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_lr_maxit">lr_maxit</code></td>
<td>
<p>is a maximum number of iteration of fitting algorithm of logistic regression. Default is 1000.</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>is a maximum acceptable number of weights in logistic regression algorithm. Default is 5000.</p>
</td></tr>
<tr><td><code id="prob_discr_pairwise_+3A_diagnostics">diagnostics</code></td>
<td>
<p>is a logical indicating if details of logistic regression fitting should be included in output list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to estimate PCDs, for a given pair of input values <code class="reqn">x_i</code> and <code class="reqn">x_j</code>, we propose to fit a logistic regression model
using response data corresponding to the two considered inputs, i.e. <code class="reqn">y^l_u</code>, for <code class="reqn">l\in\{i,j\}</code> and <code class="reqn">u</code> ranging from 
1 to <code class="reqn">n_l</code>. 
To ensure that both inputs have equal contribution to the calculated discriminability, equal probabilities should be assigned,
<code class="reqn">P(X) = (P(x_i),P(x_j))=(1/2,1/2)</code>. Once the regression model is fitted, probability of assigning a given cellular response, 
<code class="reqn">y</code>,
to the correct input value is estimated as
</p>
<p style="text-align: center;"><code class="reqn">\max \{ \hat{P}_{lr}(x_i|Y=y;P(X)), \hat{P}_{lr}(x_j|Y=y;P(X))\}.</code>
</p>

<p>Note that <code class="reqn">P(x_j|Y=y)=1-P(x_i|Y=y)</code> as well as <code class="reqn">\hat{P}_{lr}(x_j|Y=y;P(X))=1-\hat{P}_{lr}(x_i|Y=y;P(X))</code>
The average of the above probabilities over all observations <code class="reqn">y^i_l</code> yields PCDs
</p>
<p style="text-align: center;"><code class="reqn">PCD_{x_i,x_j}=\frac{1}{2}\frac{1}{n_i}\sum_{l=1}^{n_i}\max\{ \hat{P}_{lr}(x_i|Y=y_i^l;P(X)),\hat{P}_{lr}(x_i^l|Y=y;P(X))\} + </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{1}{2}  \frac{1}{n_j} \sum_{l=1}^{n_j} \max \{ \hat{P}_{lr}(x_i|Y=y_j^l;P(X)), \hat{P}_{lr}(x_j|Y=y_j^l;P(X))\}.</code>
</p>

<p>Additional parameters: lr_maxit and maxNWts are the same as in definition of multinom function from nnet package. An alternative
model formula (using formula_string arguments) should be provided if  data are not suitable for description by logistic regression
(recommended only for advanced users). Preliminary scaling of  data (argument scale) should be used similarly as in other 
data-driven approaches, e.g. if response variables are comparable, scaling (scale=FALSE) can be omitted, while if they represent 
different phenomenon (varying by units and/or magnitude) scaling is recommended.
</p>


<h3>Value</h3>

<p>a list with two elements:
</p>

<ul>
<li><p> output$prob_matr - a <code class="reqn">n\times n</code> matrix, where <code class="reqn">n</code> is the number of inputs, with probabilities of correct 
discrimination between pairs of input values. 
</p>
</li>
<li><p> output$diagnostics     - (if diagnostics=TRUE) a list corresponding to logistic regression models fitted for each 
pair of input values. Each element consists of three sub-elements: 1) nnet_model - nnet object summarising logistic regression model; 
2) prob_lr - probabilities of assignment obtained from logistic regression model; 
3) confusion_matrix - confusion matrix of classificator.
</p>
</li></ul>



<h3>References</h3>

<p>[1] Jetka T, Nienaltowski K, Winarski T, Blonski S, Komorowski M,  
Information-theoretic analysis of multivariate single-cell signaling responses using SLEMI,
<em>PLoS Comput Biol</em>, 15(7): e1007132, 2019, https://doi.org/10.1371/journal.pcbi.1007132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate probabilities of discrimination for nfkb dataset
 it=21 # choose from 0, 3, 6, ..., 120 for measurements at other time points
 output=prob_discr_pairwise(dataRaw=data_nfkb[data_nfkb$signal%in%c("0ng","1ng","100ng"),],
                            signal = "signal",
                           response = paste0("response_",it))

</code></pre>

<hr>
<h2 id='sampling_bootstrap'>Sampling procedures used for testing capacity algorithm</h2><span id='topic+sampling_bootstrap'></span><span id='topic+sampling_shuffle'></span><span id='topic+sampling_partition'></span>

<h3>Description</h3>

<p>Internal, auxiliary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_bootstrap(data, prob = 1, dataDiv)

sampling_shuffle(data, side_variables)

sampling_partition(data, dataDiv, partition_trainfrac)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampling_bootstrap_+3A_data">data</code></td>
<td>
<p>is a data.frame to be resampled</p>
</td></tr>
<tr><td><code id="sampling_bootstrap_+3A_prob">prob</code></td>
<td>
<p>is numeric for the portion of data that should be sampled from the whole dataset (only in sampling_bootstrap)</p>
</td></tr>
<tr><td><code id="sampling_bootstrap_+3A_datadiv">dataDiv</code></td>
<td>
<p>a character indicating column of data, with respect to which, data should be split before bootstrap</p>
</td></tr>
<tr><td><code id="sampling_bootstrap_+3A_side_variables">side_variables</code></td>
<td>
<p>is a vector of characters indicating columns of data the will be reshuffled (only in sampling_shuffle)</p>
</td></tr>
<tr><td><code id="sampling_bootstrap_+3A_partition_trainfrac">partition_trainfrac</code></td>
<td>
<p>is a numeric for the portion of data that will be used as a training and testing datasets</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function allow to re-sample, bootstrap and divide initial dataset
</p>


<h3>Value</h3>

<p>Function sampling_bootstrap returns a data.frame with the same structure as initial data object, but with prob proportion
of observations for each dataDiv level. Function sampling_shuffle returns a data.frame with the same structure as initial data object with 
shuffled values of columns given in side_variables argument. Function sampling_partition returns a list of two data.frame objects - 
train and test that has the same structure as initial data argument with partition_trainfrac and 1-partition_trainfrac observations, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data=data_example1
dataBootstrap = SLEMI:::sampling_bootstrap(data=data,prob=0.8,data$signal)
dataShuffle = SLEMI:::sampling_shuffle(data=data,"sideVar")
dataTrainTest = SLEMI:::sampling_partition(data=data,dataDiv=data$signal,partition_trainfrac=0.6)
</code></pre>

<hr>
<h2 id='SLEMI-package'>SLEMI: Statistical Learning Based Estimation of Mutual Information</h2><span id='topic+SLEMI'></span><span id='topic+SLEMI-package'></span>

<h3>Description</h3>

<p>The implementation of the algorithm for estimation of mutual information and channel capacity from experimental data by classification procedures (logistic regression). Technically, it allows to estimate information-theoretic measures between finite-state input and multivariate, continuous output. Method described in Jetka et al. (2019) <a href="https://doi.org/10.1371/journal.pcbi.1007132">doi:10.1371/journal.pcbi.1007132</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tomasz Jetka <a href="mailto:t.jetka@gmail.com">t.jetka@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Karol Nienaltowski [contributor]
</p>
</li>
<li><p> Michal Komorowski [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/TJetka/SLEMI">https://github.com/TJetka/SLEMI</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TJetka/SLEMI/issues">https://github.com/TJetka/SLEMI/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
