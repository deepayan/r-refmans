<!DOCTYPE html><html><head><title>Help for package tourr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tourr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tourr-package'><p>tourr: Tour Methods for Multivariate Data Visualisation</p></a></li>
<li><a href='#anaglyph'><p>Draw anaglyphs with base graphics.</p></a></li>
<li><a href='#anchored_orthogonal_distance'><p>Calculate orthogonal distances</p></a></li>
<li><a href='#andrews'><p>Compute Andrews' curves</p></a></li>
<li><a href='#angular_breaks'><p>Returns n equidistant bins between -pi and pi</p></a></li>
<li><a href='#animate'><p>Animate a tour path.</p></a></li>
<li><a href='#areColors'><p>Test if all entries are colors</p></a></li>
<li><a href='#bases_little'><p>Generate bases for the little tour</p></a></li>
<li><a href='#basis_init'><p>Generate initial basis.</p></a></li>
<li><a href='#basis_nearby'><p>Generate nearby bases, e.g. for simulated annealing.</p></a></li>
<li><a href='#basis_random'><p>Generate a random basis</p></a></li>
<li><a href='#blank_plot'><p>Set up a blank plot to display data projections</p></a></li>
<li><a href='#center'><p>Center a numeric vector by subtracting off its mean.</p></a></li>
<li><a href='#check_freezer_safe'><p>Check matrix is a valid frozen matrix</p></a></li>
<li><a href='#cmass'><p>Central mass index.</p></a></li>
<li><a href='#compute_v_rel'><p>If not set, compute epsilon based on half_range</p></a></li>
<li><a href='#correct_orientation'><p>check if the current and target bases are of the same orientation</p></a></li>
<li><a href='#cumulative_radial'><p>Calculate radial cumulative distribtuion</p></a></li>
<li><a href='#dcor2d'><p>Distance correlation index.</p></a></li>
<li><a href='#dependence_tour'><p>A dependence tour path.</p></a></li>
<li><a href='#display_andrews'><p>Andrews' curves tour path animation.</p></a></li>
<li><a href='#display_density2d'><p>Display tour path with a density and scatterplot</p></a></li>
<li><a href='#display_depth'><p>Display 3d projection with depth cues</p></a></li>
<li><a href='#display_dist'><p>1d distribution tour path animation.</p></a></li>
<li><a href='#display_faces'><p>Chernoff faces tour path animation.</p></a></li>
<li><a href='#display_groupxy'><p>Display 2D tour projections displayed separately by groups</p></a></li>
<li><a href='#display_idx'><p>Display a 1D linear aggregation index</p></a></li>
<li><a href='#display_image'><p>Image tour path animation.</p></a></li>
<li><a href='#display_pca'><p>Display tour path with principal component scores with original axes</p></a></li>
<li><a href='#display_pcp'><p>Parallel coordinates tour path animation.</p></a></li>
<li><a href='#display_sage'><p>Display tour path with a sage scatterplot</p></a></li>
<li><a href='#display_scatmat'><p>Scatterplot matrix tour path animation.</p></a></li>
<li><a href='#display_slice'><p>Display tour path with a sliced scatterplot</p></a></li>
<li><a href='#display_stars'><p>Star glyph tour path animation.</p></a></li>
<li><a href='#display_stereo'><p>Anaglpyh tour path animation.</p></a></li>
<li><a href='#display_trails'><p>Display tour path with trails</p></a></li>
<li><a href='#display_xy'><p>Display tour path with a scatterplot</p></a></li>
<li><a href='#draw_slice_center'><p>Draw slice center guide with base graphics</p></a></li>
<li><a href='#draw_tour_axes'><p>Draw tour axes on the projected data with base graphics</p></a></li>
<li><a href='#estimate_eps'><p>Estimate cutoff eps for section pursuit.</p></a></li>
<li><a href='#eucl_norm_sq'><p>Calculate the squared Euclidean norm of a vector x</p></a></li>
<li><a href='#find_best_dir'><p>Find the most promising direction to travel in.</p></a></li>
<li><a href='#find_best_frozen_dir'><p>Find most promising direction in frozen space.</p></a></li>
<li><a href='#find_frozen_path_peak'><p>Find most highest peak along frozen geodesic.</p></a></li>
<li><a href='#find_path_peak'><p>Find the most interesting projection along a geodesic.</p></a></li>
<li><a href='#find_platform'><p>Find the platform</p>
Find the platform being used by the user</a></li>
<li><a href='#Flea+20measurements'><p>Flea beatle measurements</p></a></li>
<li><a href='#freeze'><p>Freeze and thaw matrices</p></a></li>
<li><a href='#frozen_guided_tour'><p>The frozen guided tour</p></a></li>
<li><a href='#frozen_tour'><p>A frozen tour path.</p></a></li>
<li><a href='#geodesic_info'><p>Calculate information required to interpolate along a geodesic path between</p>
two frames.</a></li>
<li><a href='#geodesic_path'><p>Generate geodesic path.</p></a></li>
<li><a href='#grand_tour'><p>A grand tour path.</p></a></li>
<li><a href='#guided_section_tour'><p>A guided section tour path.</p></a></li>
<li><a href='#guided_tour'><p>A guided tour path.</p></a></li>
<li><a href='#holes'><p>Holes index.</p></a></li>
<li><a href='#interpolate'><p>Interpolate geodesically between bases.</p></a></li>
<li><a href='#is_orthonormal'><p>Test if a numeric matrix is orthonormal.</p></a></li>
<li><a href='#Laser+20measurements'><p>Turnable laser measurements from Bellcore</p></a></li>
<li><a href='#lda_pp'><p>LDA projection pursuit index.</p></a></li>
<li><a href='#linear_breaks'><p>Returns n equidistant bins between a and b</p></a></li>
<li><a href='#little_tour'><p>A little tour path.</p></a></li>
<li><a href='#local_tour'><p>A local tour path.</p></a></li>
<li><a href='#manual_slice'><p>Manually slice along a variable axis.</p></a></li>
<li><a href='#mapColors'><p>Map vector of factors to color</p></a></li>
<li><a href='#mapShapes'><p>Map vector of factors to pch</p></a></li>
<li><a href='#new_geodesic_path'><p>Generate a geodesic path between bases supplied by generator</p></a></li>
<li><a href='#new_tour'><p>Create a new tour.</p></a></li>
<li><a href='#norm_bin'><p>Normality index.</p></a></li>
<li><a href='#normalise'><p>Normalise a numeric matrix.</p></a></li>
<li><a href='#Olive+20oil+20measurements'><p>Olive oil samples from Italy</p></a></li>
<li><a href='#orthonormalise'><p>Orthonormalise using modified Gram-Schmidt process.</p></a></li>
<li><a href='#orthonormalise_by'><p>Orthonormalise one matrix by another.</p></a></li>
<li><a href='#Ozone+20measurements'><p>Monthly ozone measurements over Central America</p></a></li>
<li><a href='#path_curves'><p>Draw the path that the geodesics took.</p></a></li>
<li><a href='#path_dist'><p>Compute distance matrix from bases.</p></a></li>
<li><a href='#path_index'><p>Compute index values for a tour history.</p></a></li>
<li><a href='#paths_index'><p>Compute index value for many histories.</p></a></li>
<li><a href='#pda_pp'><p>PDA projection pursuit index.</p></a></li>
<li><a href='#Places+20Ratings'><p>Ratings of different locations across North America</p></a></li>
<li><a href='#planned_tour'><p>A planned tour path.</p></a></li>
<li><a href='#plot.path_curve'><p>Plot history curves.</p></a></li>
<li><a href='#plot.path_index'><p>Plot history index with ggplot2.</p></a></li>
<li><a href='#proj_dist'><p>Calculate the distance between two bases.</p></a></li>
<li><a href='#project3d'><p>Stereographic projection</p></a></li>
<li><a href='#radial_bin_weight_inv'><p>Inverse weights for rescaling counts in radial bins.</p></a></li>
<li><a href='#radial_tour'><p>A radial tour path.</p></a></li>
<li><a href='#Rat+20CNS'><p>Rat CNS Gene Expression</p></a></li>
<li><a href='#render'><p>Render frames of animation to disk</p></a></li>
<li><a href='#render_anim'><p>Render a set of animation frames</p></a></li>
<li><a href='#render_gif'><p>Render frames of animation to a gif file</p></a></li>
<li><a href='#render_proj'><p>Render plotly animation frame</p></a></li>
<li><a href='#rescale'><p>Rescale a matrix or data frame</p></a></li>
<li><a href='#save_history'><p>Save tour history.</p></a></li>
<li><a href='#search_better'><p>Search for a better projection near the current projection.</p></a></li>
<li><a href='#search_better_random'><p>Search for a better projection using simulated annealing</p></a></li>
<li><a href='#search_frozen_geodesic'><p>A pseudo-derivative, line search algorithm along frozen geodesics.</p></a></li>
<li><a href='#search_geodesic'><p>A pseudo-derivative, line search algorithm.</p></a></li>
<li><a href='#search_polish'><p>Search very locally to find slightly better projections to polish a broader search.</p></a></li>
<li><a href='#search_posse'><p>Search for a better projection based on Poss, 1995</p></a></li>
<li><a href='#slice_binning'><p>Separately binning observations inside and outside the slice.</p></a></li>
<li><a href='#slice_index'><p>Section pursuit index.</p></a></li>
<li><a href='#sphere_data'><p>Sphere a matrix (or data frame) by transforming variables to</p>
principal components.</a></li>
<li><a href='#splines2d'><p>Spline based index.</p></a></li>
<li><a href='#step_angle'><p>Step along an interpolated path by angle in radians.</p></a></li>
<li><a href='#step_fraction'><p>Step along an interpolated path by fraction of path length.</p></a></li>
<li><a href='#t1'><p>Saved history of guided tour with holes</p></a></li>
<li><a href='#to_stop'><p>Prints information on how to stop the output</p></a></li>
<li><a href='#Tropical+20Atmosphere+20Ocean'><p>Tropical Atmosphere Ocean data</p></a></li>
<li><a href='#weights_bincount_radial'><p>Computes weights for the rescaling of radial bin counts.</p></a></li>
<li><a href='#xnul'><p>A null function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tour Methods for Multivariate Data Visualisation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements geodesic interpolation and basis
    generation functions that allow you to create new tour
    methods from R.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, tibble, dplyr, stats, utils, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>TeachingDemos, ash, energy, testthat, colorspace, ggplot2,
mgcv, gifski, geozoo, knitr, rmarkdown, tidyr, covr, plotly</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ggobi/tourr">https://github.com/ggobi/tourr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ggobi/tourr/issues">https://github.com/ggobi/tourr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 23:07:58 UTC; cookd</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Dianne Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Nick Spyrison <a href="https://orcid.org/0000-0002-8417-0212"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ursula Laa <a href="https://orcid.org/0000-0002-0249-6439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  H. Sherry Zhang <a href="https://orcid.org/0000-0002-7122-1463"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Stuart Lee <a href="https://orcid.org/0000-0003-1179-8436"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dianne Cook &lt;dicook@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tourr-package'>tourr: Tour Methods for Multivariate Data Visualisation</h2><span id='topic+tourr'></span><span id='topic+tourr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Implements geodesic interpolation and basis generation functions that allow you to create new tour methods from R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dianne Cook <a href="mailto:dicook@monash.edu">dicook@monash.edu</a> (<a href="https://orcid.org/0000-0002-3813-7155">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:h.wickham@gmail.com">h.wickham@gmail.com</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>) [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nick Spyrison <a href="mailto:nicholas.spyrison@monash.edu">nicholas.spyrison@monash.edu</a> (<a href="https://orcid.org/0000-0002-8417-0212">ORCID</a>) [contributor]
</p>
</li>
<li><p> Ursula Laa <a href="mailto:ursula.laa@boku.ac.at">ursula.laa@boku.ac.at</a> (<a href="https://orcid.org/0000-0002-0249-6439">ORCID</a>) [contributor]
</p>
</li>
<li><p> H. Sherry Zhang <a href="mailto:huizezhangsh@gmail.com">huizezhangsh@gmail.com</a> (<a href="https://orcid.org/0000-0002-7122-1463">ORCID</a>) [contributor]
</p>
</li>
<li><p> Stuart Lee <a href="mailto:stuart.lee1@monash.edu">stuart.lee1@monash.edu</a> (<a href="https://orcid.org/0000-0003-1179-8436">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ggobi/tourr">https://github.com/ggobi/tourr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ggobi/tourr/issues">https://github.com/ggobi/tourr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='anaglyph'>Draw anaglyphs with base graphics.</h2><span id='topic+anaglyph'></span>

<h3>Description</h3>

<p>Draw anaglyphs with base graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anaglyph(d3, blue, red, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anaglyph_+3A_d3">d3</code></td>
<td>
<p>3d numeric matrix giving position of points</p>
</td></tr>
<tr><td><code id="anaglyph_+3A_blue">blue</code></td>
<td>
<p>blue colour (for right eye)</p>
</td></tr>
<tr><td><code id="anaglyph_+3A_red">red</code></td>
<td>
<p>red colour (for left eye)</p>
</td></tr>
<tr><td><code id="anaglyph_+3A_cex">cex</code></td>
<td>
<p>size of the point to be plotted.  Defaults to 1.</p>
</td></tr>
</table>

<hr>
<h2 id='anchored_orthogonal_distance'>Calculate orthogonal distances</h2><span id='topic+anchored_orthogonal_distance'></span>

<h3>Description</h3>

<p>For each datapoint this function calculates the orthogonal distance from the
anchored projection plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchored_orthogonal_distance(plane, data, anchor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anchored_orthogonal_distance_+3A_plane">plane</code></td>
<td>
<p>matrix specifying the projection plane</p>
</td></tr>
<tr><td><code id="anchored_orthogonal_distance_+3A_data">data</code></td>
<td>
<p>data frame or matrix</p>
</td></tr>
<tr><td><code id="anchored_orthogonal_distance_+3A_anchor">anchor</code></td>
<td>
<p>A vector specifying the reference point to anchor the plane
If NULL (default) the slice will be anchored at the origin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance vector
</p>

<hr>
<h2 id='andrews'>Compute Andrews' curves</h2><span id='topic+andrews'></span>

<h3>Description</h3>

<p>This function takes a numeric vector of input, and returns a function which
allows you to compute the value of the Andrew's curve at every point along
its path from -pi to pi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>andrews(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="andrews_+3A_x">x</code></td>
<td>
<p>input a new parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with single argument, theta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- andrews(1:2)
a(0)
a(-pi)
grid &lt;- seq(-pi, pi, length = 50)
a(grid)

plot(grid, andrews(1:2)(grid), type = "l")
plot(grid, andrews(runif(5))(grid), type = "l")
</code></pre>

<hr>
<h2 id='angular_breaks'>Returns n equidistant bins between -pi and pi</h2><span id='topic+angular_breaks'></span>

<h3>Description</h3>

<p>Returns n equidistant bins between -pi and pi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angular_breaks(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angular_breaks_+3A_n">n</code></td>
<td>
<p>number of bins</p>
</td></tr>
</table>

<hr>
<h2 id='animate'>Animate a tour path.</h2><span id='topic+animate'></span>

<h3>Description</h3>

<p>This is the function that powers all of the tour animations.  If you want
to write your own tour animation method, the best place to
start is by looking at the code for animation methods that have already
implemented in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate(
  data,
  tour_path = grand_tour(),
  display = display_xy(),
  start = NULL,
  aps = 1,
  fps = 10,
  max_frames = Inf,
  rescale = FALSE,
  sphere = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="animate_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
<tr><td><code id="animate_+3A_display">display</code></td>
<td>
<p>takes the display that is suppose to be used, defaults to
the xy display</p>
</td></tr>
<tr><td><code id="animate_+3A_start">start</code></td>
<td>
<p>projection to start at, if not specified, uses default
associated with tour path</p>
</td></tr>
<tr><td><code id="animate_+3A_aps">aps</code></td>
<td>
<p>target angular velocity (in radians per second)</p>
</td></tr>
<tr><td><code id="animate_+3A_fps">fps</code></td>
<td>
<p>target frames per second (defaults to 15, to accommodate RStudio graphics device)</p>
</td></tr>
<tr><td><code id="animate_+3A_max_frames">max_frames</code></td>
<td>
<p>the maximum number of bases to generate.  Defaults to
Inf for interactive use (must use Ctrl + C to terminate), and 1 for
non-interactive use.</p>
</td></tr>
<tr><td><code id="animate_+3A_rescale">rescale</code></td>
<td>
<p>Default FALSE. If TRUE, rescale all variables to range [0,1]?</p>
</td></tr>
<tr><td><code id="animate_+3A_sphere">sphere</code></td>
<td>
<p>if true, sphere all variables</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+render">render</a></code> to render animations to disk.
</p>


<h3>Value</h3>

<p>an (invisible) list of bases visited during this tour
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- flea[, 1:6]
animate(f, grand_tour(), display_xy())
# or in short
animate(f)
animate(f, max_frames = 30)

animate(f, max_frames = 10, fps = 1, aps = 0.1)

</code></pre>

<hr>
<h2 id='areColors'>Test if all entries are colors</h2><span id='topic+areColors'></span>

<h3>Description</h3>

<p>Test if all entries are colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areColors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areColors_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
</table>

<hr>
<h2 id='bases_little'>Generate bases for the little tour</h2><span id='topic+bases_little'></span>

<h3>Description</h3>

<p>Generate bases for the little tour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bases_little(p, d = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bases_little_+3A_p">p</code></td>
<td>
<p>dimensionality of data</p>
</td></tr>
<tr><td><code id="bases_little_+3A_d">d</code></td>
<td>
<p>dimensionality of target projection</p>
</td></tr>
</table>

<hr>
<h2 id='basis_init'>Generate initial basis.</h2><span id='topic+basis_init'></span>

<h3>Description</h3>

<p>First two variables are projected on first two axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_init(n, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_init_+3A_n">n</code></td>
<td>
<p>dimensionality of data</p>
</td></tr>
<tr><td><code id="basis_init_+3A_d">d</code></td>
<td>
<p>dimensionality of target projection</p>
</td></tr>
</table>

<hr>
<h2 id='basis_nearby'>Generate nearby bases, e.g. for simulated annealing.</h2><span id='topic+basis_nearby'></span>

<h3>Description</h3>

<p>Generate nearby bases, e.g. for simulated annealing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_nearby(current, alpha = 0.5, method = "linear")
</code></pre>

<hr>
<h2 id='basis_random'>Generate a random basis</h2><span id='topic+basis_random'></span>

<h3>Description</h3>

<p>Generate a random basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_random(n, d = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_random_+3A_n">n</code></td>
<td>
<p>dimensionality of data</p>
</td></tr>
<tr><td><code id="basis_random_+3A_d">d</code></td>
<td>
<p>dimensionality of target projection</p>
</td></tr>
</table>

<hr>
<h2 id='blank_plot'>Set up a blank plot to display data projections</h2><span id='topic+blank_plot'></span>

<h3>Description</h3>

<p>Set up a blank plot to display data projections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blank_plot(...)
</code></pre>

<hr>
<h2 id='center'>Center a numeric vector by subtracting off its mean.</h2><span id='topic+center'></span>

<h3>Description</h3>

<p>Center a numeric vector by subtracting off its mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='check_freezer_safe'>Check matrix is a valid frozen matrix</h2><span id='topic+check_freezer_safe'></span>

<h3>Description</h3>

<p>Check matrix is a valid frozen matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_freezer_safe(frozen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_freezer_safe_+3A_frozen">frozen</code></td>
<td>
<p>matrix to check for freezability</p>
</td></tr>
</table>

<hr>
<h2 id='cmass'>Central mass index.</h2><span id='topic+cmass'></span>

<h3>Description</h3>

<p>Calculates the central mass index.  See Cook and Swayne (2007)
Interactive and Dynamic Graphics for Data Analysis for equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmass()
</code></pre>

<hr>
<h2 id='compute_v_rel'>If not set, compute epsilon based on half_range</h2><span id='topic+compute_v_rel'></span>

<h3>Description</h3>

<p>If not set, compute epsilon based on half_range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_v_rel(v_rel, half_range, n)
</code></pre>

<hr>
<h2 id='correct_orientation'>check if the current and target bases are of the same orientation</h2><span id='topic+correct_orientation'></span>

<h3>Description</h3>

<p>check if the current and target bases are of the same orientation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_orientation(current, target)
</code></pre>

<hr>
<h2 id='cumulative_radial'>Calculate radial cumulative distribtuion</h2><span id='topic+cumulative_radial'></span>

<h3>Description</h3>

<p>Calculate fraction of volume of a pD sphere with radius R projected
within the projected radius r.
</p>
<p>Fraction of points within radius r given 2D projection of a
hypersphere with radius R in p dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_radial(r, R, p)

cumulative_radial(r, R, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_radial_+3A_r">r</code></td>
<td>
<p>projected radius</p>
</td></tr>
<tr><td><code id="cumulative_radial_+3A_r">R</code></td>
<td>
<p>radius of pD sphere</p>
</td></tr>
<tr><td><code id="cumulative_radial_+3A_p">p</code></td>
<td>
<p>input dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fraction of volume
</p>

<hr>
<h2 id='dcor2d'>Distance correlation index.</h2><span id='topic+dcor2d'></span>

<h3>Description</h3>

<p>Computes the distance correlation based index on
2D projections of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcor2d()
</code></pre>

<hr>
<h2 id='dependence_tour'>A dependence tour path.</h2><span id='topic+dependence_tour'></span>

<h3>Description</h3>

<p>The dependence tour combines a set of independent 1d tours to produce
a nd tour.  For the special case of 2d, this is known as a correlation
tour.  This tour corresponds to the multivariate method known as
generalised canonical correlation, and is used to investigate dependence
between groups of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dependence_tour(pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dependence_tour_+3A_pos">pos</code></td>
<td>
<p>a numeric vector describing which variables are mapped to
which dimensions: 1 corresponds to first, 2 to second etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:3], dependence_tour(c(1, 2, 2)))
animate_xy(flea[, 1:4], dependence_tour(c(1, 2, 1, 2)))
animate_pcp(flea[, 1:6], dependence_tour(c(1, 2, 3, 2, 1, 3)))
</code></pre>

<hr>
<h2 id='display_andrews'>Andrews' curves tour path animation.</h2><span id='topic+display_andrews'></span><span id='topic+animate_andrews'></span>

<h3>Description</h3>

<p>Animate a nD tour path with Andrews' curves.  For more details about
Andrew's curves, see <code><a href="#topic+andrews">andrews</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_andrews(col = "black", palette = "Zissou 1", ...)

animate_andrews(data, tour_path = grand_tour(3), col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_andrews_+3A_col">col</code></td>
<td>
<p>color to be plotted.  Defaults to &quot;black&quot;</p>
</td></tr>
<tr><td><code id="display_andrews_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_andrews_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_andrews_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_andrews_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_andrews(flea[, 1:6])
animate_andrews(flea[, 1:6], grand_tour(d = 3))
animate_andrews(flea[, 1:6], grand_tour(d = 6))

# It's easy to experiment with different tour paths:
animate_andrews(flea[, 1:6], guided_tour(cmass()))
</code></pre>

<hr>
<h2 id='display_density2d'>Display tour path with a density and scatterplot</h2><span id='topic+display_density2d'></span><span id='topic+animate_density2d'></span>

<h3>Description</h3>

<p>Animate a 2D tour path with density contour(s) and a scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_density2d(
  center = TRUE,
  axes = "center",
  half_range = NULL,
  col = "black",
  pch = 20,
  cex = 1,
  contour_quartile = c(0.25, 0.5, 0.75),
  edges = NULL,
  palette = "Zissou 1",
  ...
)

animate_density2d(data, tour_path = grand_tour(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_density2d_+3A_center">center</code></td>
<td>
<p>if TRUE, centers projected data to (0,0).  This pins the
center of data cloud and make it easier to focus on the changing shape
rather than position.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_pch">pch</code></td>
<td>
<p>shape of the point to be plotted.  Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_cex">cex</code></td>
<td>
<p>size of the point to be plotted.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_contour_quartile">contour_quartile</code></td>
<td>
<p>Vector of quartiles to plot the contours at. Defaults to 5.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_edges">edges</code></td>
<td>
<p>A two column integer matrix giving indices of ends of lines.</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_density2d">display_density2d</a></code></p>
</td></tr>
<tr><td><code id="display_density2d_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_density2d_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_density2d(flea[, 1:6])
animate(flea[, 1:6], tour_path = grand_tour(), display = display_density2d())
animate(flea[, 1:6],
  tour_path = grand_tour(),
  display = display_density2d(axes = "bottomleft")
)
animate(flea[, 1:6],
  tour_path = grand_tour(),
  display = display_density2d(half_range = 0.5)
)
animate_density2d(flea[, 1:6], tour_path = little_tour())

animate_density2d(flea[, 1:3], tour_path = guided_tour(holes()), sphere = TRUE)
animate_density2d(flea[, 1:6], center = FALSE)

# The default axes are centered, like a biplot, but there are other options
animate_density2d(flea[, 1:6], axes = "bottomleft")
animate_density2d(flea[, 1:6], axes = "off")
animate_density2d(flea[, 1:6], dependence_tour(c(1, 2, 1, 2, 1, 2)),
  axes = "bottomleft"
)

animate_density2d(flea[, -7], col = flea$species)

# You can also draw lines
edges &lt;- matrix(c(1:5, 2:6), ncol = 2)
animate(
  flea[, 1:6], grand_tour(),
  display_density2d(axes = "bottomleft", edges = edges)
)
</code></pre>

<hr>
<h2 id='display_depth'>Display 3d projection with depth cues</h2><span id='topic+display_depth'></span><span id='topic+animate_depth'></span>

<h3>Description</h3>

<p>Suggestion to use gray background and colour saturation (instead of
gray shading) by Graham Wills.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_depth(center = TRUE, half_range = NULL, ...)

animate_depth(data, tour_path = grand_tour(3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_depth_+3A_center">center</code></td>
<td>
<p>should projected data be centered to have mean zero (default:
TRUE). This pins the centre of the data to the same place, and makes it
easier to focus on the shape.</p>
</td></tr>
<tr><td><code id="display_depth_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_depth_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_depth_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_depth_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_depth(flea[, 1:6])
</code></pre>

<hr>
<h2 id='display_dist'>1d distribution tour path animation.</h2><span id='topic+display_dist'></span><span id='topic+animate_dist'></span>

<h3>Description</h3>

<p>Animate a 1d tour path with a density plot or histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_dist(
  method = "density",
  center = TRUE,
  half_range = NULL,
  col = "black",
  rug = FALSE,
  palette = "Zissou 1",
  density_max = 3,
  bw = 0.2,
  scale_density = FALSE,
  ...
)

animate_dist(data, tour_path = grand_tour(1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_dist_+3A_method">method</code></td>
<td>
<p>display method, histogram or density plot</p>
</td></tr>
<tr><td><code id="display_dist_+3A_center">center</code></td>
<td>
<p>should 1d projection be centered to have mean zero (default: TRUE).
This pins the centre of distribution to the same place, and makes it
easier to focus on the shape of the distribution.</p>
</td></tr>
<tr><td><code id="display_dist_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_dist_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_dist_+3A_rug">rug</code></td>
<td>
<p>draw rug plot showing position of actual data points?</p>
</td></tr>
<tr><td><code id="display_dist_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_dist_+3A_density_max">density_max</code></td>
<td>
<p>allow control of the y range for density plot</p>
</td></tr>
<tr><td><code id="display_dist_+3A_bw">bw</code></td>
<td>
<p>binwidth for histogram and density, between 0-1, default 0.2</p>
</td></tr>
<tr><td><code id="display_dist_+3A_scale_density">scale_density</code></td>
<td>
<p>Height of density is scaled at each projection, default FALSE</p>
</td></tr>
<tr><td><code id="display_dist_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_dist_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_dist_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_dist(flea[, 1:6])

# Change inputs, to color by group, fix y axis, change bin width
# and scale bar height or density at each projection
animate_dist(flea[, 1:6], col=flea$species, density_max=5)
animate_dist(flea[, 1:6], col=flea$species, density_max=5, bw=0.1)
animate_dist(flea[, 1:6], col=flea$species, scale_density=TRUE)

# When the distribution is not centred, it tends to wander around in a
# distracting manner
animate_dist(flea[, 1:6], center = FALSE)

# Alternatively, you can display the distribution with a histogram
animate_dist(flea[, 1:6], method = "hist")
</code></pre>

<hr>
<h2 id='display_faces'>Chernoff faces tour path animation.</h2><span id='topic+display_faces'></span><span id='topic+animate_faces'></span>

<h3>Description</h3>

<p>Animate a nD tour path with Chernoff's faces.  Can display up to 18
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_faces(...)

animate_faces(data, tour_path = grand_tour(3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_faces_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_faces_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_faces_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <code>TeachingDemos</code> package to draw the
Chernoff faces.  See <code><a href="TeachingDemos.html#topic+faces2">faces2</a></code> for more details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The drawing code is fairly slow, so this animation works best with a
# limited number of cases
flea_s &lt;- rescale(flea[,1:6])
animate_faces(flea_s[1:2, 1:6])
animate_faces(flea_s[1:4, 1:6])

animate_faces(flea_s[1:2, 1:6], grand_tour(5))
</code></pre>

<hr>
<h2 id='display_groupxy'>Display 2D tour projections displayed separately by groups</h2><span id='topic+display_groupxy'></span><span id='topic+animate_groupxy'></span>

<h3>Description</h3>

<p>This function is designed to allow comparisons across multiple groups,
especially for examining things like two (or more) different models
on the same data. The primary display is a scatterplot, with lines or
contours overlaid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_groupxy(
  centr = TRUE,
  axes = "center",
  half_range = NULL,
  col = "black",
  pch = 20,
  cex = 1,
  edges = NULL,
  edges.col = "black",
  edges.width = 1,
  group_by = NULL,
  plot_xgp = TRUE,
  palette = "Zissou 1",
  ...
)

animate_groupxy(data, tour_path = grand_tour(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_groupxy_+3A_centr">centr</code></td>
<td>
<p>if TRUE, centers projected data to (0,0).  This pins the
center of data cloud and make it easier to focus on the changing shape
rather than position.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_pch">pch</code></td>
<td>
<p>shape of the point to be plotted.  Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_cex">cex</code></td>
<td>
<p>size of the point to be plotted.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_edges">edges</code></td>
<td>
<p>A two column integer matrix giving indices of ends of lines.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_edges.col">edges.col</code></td>
<td>
<p>colour of edges to be plotted, Defaults to &quot;black&quot;</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_edges.width">edges.width</code></td>
<td>
<p>line width for edges, default 1</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_group_by">group_by</code></td>
<td>
<p>variable to group by. Must have less than 25 unique values.</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_plot_xgp">plot_xgp</code></td>
<td>
<p>if TRUE, plots points from other groups in light grey</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_groupxy">display_groupxy</a></code></p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_groupxy_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_groupxy(flea[, 1:6], col = flea$species,
  pch = flea$species, group_by = flea$species)
animate_groupxy(flea[, 1:6], col = flea$species,
  pch = flea$species, group_by = flea$species,
  plot_xgp = FALSE)
# Edges example
x &lt;- data.frame(x1=runif(10, -1, 1), x2=runif(10, -1, 1), x3=runif(10, -1, 1))
x$cl &lt;- factor(c(rep("A", 3), rep("B", 3), rep("C", 4)))
x.edges &lt;- cbind(from=c(1,2, 4,5, 7,8,9), to=c(2,3, 5,6, 8,9,10))
x.edges.col &lt;- factor(c(rep("A", 2), rep("B", 2), rep("C", 3)))
animate_groupxy(x[,1:3], col=x$cl, group_by=x$cl, edges=x.edges, edges.col=x.edges.col)
</code></pre>

<hr>
<h2 id='display_idx'>Display a 1D linear aggregation index</h2><span id='topic+display_idx'></span><span id='topic+animate_idx'></span>

<h3>Description</h3>

<p>Animate a 1D tour path for data where individuals are ranked
by a multivariate index. Allows one to examine the sensitivity
of the ranking on the linear combination. Variables should be
scaled to be between 0-1. This is only designed to work with
a local tour, or a radial tour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_idx(
  center = FALSE,
  half_range = NULL,
  abb_vars = TRUE,
  col = "red",
  cex = 3,
  panel_height_ratio = c(3, 2),
  label_x_pos = 0.7,
  label = NULL,
  label_cex = 1,
  label_col = "grey80",
  add_ref_line = TRUE,
  axis_bar_col = "#000000",
  axis_bar_lwd = 3,
  axis_label_cex_upper = 1,
  axis_label_cex_lower = 1,
  axis_bar_label_cex = 1,
  axis_bar_label_col = "#000000",
  axis_var_cex = 1,
  axis_var_col = "#000000",
  palette = "Zissou 1",
  ...
)

animate_idx(data, tour_path = grand_tour(1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_idx_+3A_center">center</code></td>
<td>
<p>should 1d projection be centered to have mean zero (default: TRUE).
This pins the centre of distribution to the same place, and makes it
easier to focus on the shape of the distribution.</p>
</td></tr>
<tr><td><code id="display_idx_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_idx_+3A_abb_vars">abb_vars</code></td>
<td>
<p>logical, whether to abbreviate the variable name, if long</p>
</td></tr>
<tr><td><code id="display_idx_+3A_col">col</code></td>
<td>
<p>the color used for points, can be a vector or hexcolors or a
factor, default to &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="display_idx_+3A_cex">cex</code></td>
<td>
<p>the size used for points, default to 0.5</p>
</td></tr>
<tr><td><code id="display_idx_+3A_panel_height_ratio">panel_height_ratio</code></td>
<td>
<p>input to the height argument in
[graphics::layout()] for the height of data and axis panel.</p>
</td></tr>
<tr><td><code id="display_idx_+3A_label_x_pos">label_x_pos</code></td>
<td>
<p>the x position of text label, currently labels are
positioned at a fixed x value for each observation</p>
</td></tr>
<tr><td><code id="display_idx_+3A_label">label</code></td>
<td>
<p>the text label, a vector</p>
</td></tr>
<tr><td><code id="display_idx_+3A_label_cex">label_cex</code></td>
<td>
<p>the size for text labels</p>
</td></tr>
<tr><td><code id="display_idx_+3A_label_col">label_col</code></td>
<td>
<p>the color for text labels</p>
</td></tr>
<tr><td><code id="display_idx_+3A_add_ref_line">add_ref_line</code></td>
<td>
<p>whether to add a horizontal reference line for each
observation, logical default to TRUE</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_bar_col">axis_bar_col</code></td>
<td>
<p>the color of the axis bar</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_bar_lwd">axis_bar_lwd</code></td>
<td>
<p>the width of the axis bar</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_label_cex_upper">axis_label_cex_upper</code></td>
<td>
<p>the size of the axis label in the upper panel</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_label_cex_lower">axis_label_cex_lower</code></td>
<td>
<p>the size of the axis label in the lower panel</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_bar_label_cex">axis_bar_label_cex</code></td>
<td>
<p>the size of the axis label</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_bar_label_col">axis_bar_label_col</code></td>
<td>
<p>the color of the axis label</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_var_cex">axis_var_cex</code></td>
<td>
<p>the size of the variable name
to the right of the axis panel</p>
</td></tr>
<tr><td><code id="display_idx_+3A_axis_var_col">axis_var_col</code></td>
<td>
<p>the color of the variable name
to the right of the axis panel</p>
</td></tr>
<tr><td><code id="display_idx_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by
<code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_idx_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="display_idx_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_idx_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(places)
places_01 &lt;- apply(places[1:10,1:9], 2, function(x) (x-min(x))/(max(x)-min(x)))
b &lt;- matrix(rep(1/sqrt(9), 9), ncol=1)
places_init &lt;- cbind(places_01, idx = as.vector(as.matrix(places_01) %*% b))
places_sorted &lt;- places_init[order(places_init[,10]), 1:9]
animate_idx(places_sorted, tour_path = local_tour(b, angle=pi/8),
            label=as.character(places$stnum[1:9]),
            label_x_pos = 0)
</code></pre>

<hr>
<h2 id='display_image'>Image tour path animation.</h2><span id='topic+display_image'></span><span id='topic+animate_image'></span>

<h3>Description</h3>

<p>Animate a 1d tour path with an image plot.  This animation requires a
different input data structure, a 3d array.  The first two dimensions are
locations on a grid, and the 3rd dimension gives the observations to be
mixed with the tour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_image(xs, ys, ...)

animate_image(data, tour_path = grand_tour(1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_image_+3A_xs">xs</code></td>
<td>
<p>x limit that is used in making the size of the plot</p>
</td></tr>
<tr><td><code id="display_image_+3A_ys">ys</code></td>
<td>
<p>y limit that is used in making the size of the plot</p>
</td></tr>
<tr><td><code id="display_image_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_image_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_image_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ozone)
animate_image(ozone)
</code></pre>

<hr>
<h2 id='display_pca'>Display tour path with principal component scores with original axes</h2><span id='topic+display_pca'></span><span id='topic+animate_pca'></span>

<h3>Description</h3>

<p>Animate a 2D tour path on data that has been transformed into
principal components, and also show the original variable axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_pca(
  center = TRUE,
  axes = "center",
  half_range = NULL,
  col = "black",
  pch = 20,
  cex = 1,
  pc_coefs = NULL,
  edges = NULL,
  edges.col = "black",
  palette = "Zissou 1",
  ...
)

animate_pca(data, tour_path = grand_tour(), rescale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_pca_+3A_center">center</code></td>
<td>
<p>if TRUE, centers projected data to (0,0).  This pins the
center of data cloud and make it easier to focus on the changing shape
rather than position.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_pca_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_pch">pch</code></td>
<td>
<p>shape of the point to be plotted.  Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_cex">cex</code></td>
<td>
<p>size of the point to be plotted.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_pc_coefs">pc_coefs</code></td>
<td>
<p>coefficients relating the original variables to
principal components. This is required.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_edges">edges</code></td>
<td>
<p>A two column integer matrix giving indices of ends of lines.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_edges.col">edges.col</code></td>
<td>
<p>colour of edges to be plotted, Defaults to &quot;black.</p>
</td></tr>
<tr><td><code id="display_pca_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_pca_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_slice">display_slice</a></code></p>
</td></tr>
<tr><td><code id="display_pca_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_pca_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
<tr><td><code id="display_pca_+3A_rescale">rescale</code></td>
<td>
<p>Default FALSE. If TRUE, rescale all variables to range [0,1].</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>flea_std &lt;- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))
flea_pca &lt;- prcomp(flea_std, center = FALSE, )
flea_coefs &lt;- flea_pca$rotation[, 1:3]
flea_scores &lt;- flea_pca$x[, 1:3]
animate_pca(flea_scores, pc_coefs = flea_coefs)
</code></pre>

<hr>
<h2 id='display_pcp'>Parallel coordinates tour path animation.</h2><span id='topic+display_pcp'></span><span id='topic+animate_pcp'></span>

<h3>Description</h3>

<p>Animate a nD tour path with a parallel coordinates plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_pcp(...)

animate_pcp(data, tour_path = grand_tour(3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_pcp_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_pcp_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_pcp_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lines show the observations, and the points, the values of the
projection matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_pcp(flea[, 1:6], grand_tour(3))
animate_pcp(flea[, 1:6], grand_tour(5))
</code></pre>

<hr>
<h2 id='display_sage'>Display tour path with a sage scatterplot</h2><span id='topic+display_sage'></span><span id='topic+animate_sage'></span>

<h3>Description</h3>

<p>Animate a 2D tour path with a sage scatterplot that
uses a radial transformation on the projected points to re-allocate
the volume projected across the 2D plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_sage(
  axes = "center",
  half_range = NULL,
  col = "black",
  pch = 20,
  gam = 1,
  R = NULL,
  palette = "Zissou 1",
  ...
)

animate_sage(data, tour_path = grand_tour(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_sage_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_sage_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_sage_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_sage_+3A_pch">pch</code></td>
<td>
<p>marker for points. Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_sage_+3A_gam">gam</code></td>
<td>
<p>scaling of the effective dimensionality for rescaling. Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_sage_+3A_r">R</code></td>
<td>
<p>scale for the radial transformation.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_sage_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_sage_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_sage">display_sage</a></code></p>
</td></tr>
<tr><td><code id="display_sage_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_sage_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate uniform samples in a 10d sphere using the geozoo package
sphere10 &lt;- geozoo::sphere.solid.random(10)$points
# Columns need to be named before launching the tour
colnames(sphere10) &lt;- paste0("x", 1:10)
# Standard grand tour display, points cluster near center
animate_xy(sphere10)
# Sage display, points are uniformly distributed across the disk
animate_sage(sphere10)
</code></pre>

<hr>
<h2 id='display_scatmat'>Scatterplot matrix tour path animation.</h2><span id='topic+display_scatmat'></span><span id='topic+animate_scatmat'></span>

<h3>Description</h3>

<p>Animate a nD tour path with a scatterplot matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_scatmat(...)

animate_scatmat(data, tour_path = grand_tour(3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_scatmat_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_scatmat_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_scatmat_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lines show the observations, and the points, the values of the
projection matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_scatmat(flea[, 1:6], grand_tour(2))
animate_scatmat(flea[, 1:6], grand_tour(6))
</code></pre>

<hr>
<h2 id='display_slice'>Display tour path with a sliced scatterplot</h2><span id='topic+display_slice'></span><span id='topic+animate_slice'></span>

<h3>Description</h3>

<p>Animate a 2D tour path with a sliced scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_slice(
  center = TRUE,
  axes = "center",
  half_range = NULL,
  col = "black",
  pch_slice = 20,
  pch_other = 46,
  cex_slice = 2,
  cex_other = 1,
  v_rel = NULL,
  anchor = NULL,
  anchor_nav = "off",
  edges = NULL,
  edges.col = "black",
  palette = "Zissou 1",
  ...
)

animate_slice(data, tour_path = grand_tour(), rescale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_slice_+3A_center">center</code></td>
<td>
<p>if TRUE, centers projected data to (0,0).  This pins the
center of data cloud and make it easier to focus on the changing shape
rather than position.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_slice_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_pch_slice">pch_slice</code></td>
<td>
<p>marker for plotting points inside the slice.
Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_pch_other">pch_other</code></td>
<td>
<p>marker for plotting points outside the slice.
Defaults to 46.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_cex_slice">cex_slice</code></td>
<td>
<p>size of the points inside the slice. Defaults to 2.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_cex_other">cex_other</code></td>
<td>
<p>size if the points outside the slice. Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_v_rel">v_rel</code></td>
<td>
<p>relative volume of the slice. If not set, suggested value
is calculated and printed to the screen.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_anchor">anchor</code></td>
<td>
<p>A vector specifying the reference point to anchor the slice.
If NULL (default) the slice will be anchored at the data center.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_anchor_nav">anchor_nav</code></td>
<td>
<p>position of the anchor: center, topright or off</p>
</td></tr>
<tr><td><code id="display_slice_+3A_edges">edges</code></td>
<td>
<p>A two column integer matrix giving indices of ends of lines.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_edges.col">edges.col</code></td>
<td>
<p>colour of edges to be plotted, Defaults to &quot;black.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_slice_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_slice">display_slice</a></code></p>
</td></tr>
<tr><td><code id="display_slice_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_slice_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
<tr><td><code id="display_slice_+3A_rescale">rescale</code></td>
<td>
<p>Default FALSE. If TRUE, rescale all variables to range [0,1].</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate samples on a 3d and 5d hollow sphere using the geozoo package
sphere3 &lt;- geozoo::sphere.hollow(3)$points
sphere5 &lt;- geozoo::sphere.hollow(5)$points

# Columns need to be named before launching the tour
colnames(sphere3) &lt;- c("x1", "x2", "x3")
colnames(sphere5) &lt;- c("x1", "x2", "x3", "x4", "x5")

# Animate with the slice display using the default parameters
animate_slice(sphere3)
animate_slice(sphere5)

# Animate with off-center anchoring
anchor3 &lt;- matrix(rep(0.7, 3), ncol=3)
anchor5 &lt;- matrix(rep(0.3, 5), ncol=5)
animate_slice(sphere3, anchor = anchor3)
# Animate with thicker slice to capture more points in each view
animate_slice(sphere5, anchor = anchor5, v_rel = 0.02)
</code></pre>

<hr>
<h2 id='display_stars'>Star glyph tour path animation.</h2><span id='topic+display_stars'></span><span id='topic+animate_stars'></span>

<h3>Description</h3>

<p>Animate a nD tour path with star glyphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_stars(...)

animate_stars(data, tour_path = grand_tour(3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_stars_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="graphics.html#topic+stars">stars</a></code></p>
</td></tr>
<tr><td><code id="display_stars_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_stars_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, scaling doesn't seem to be computed absolutely correctly, as
centres move around as well as outside points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code> for options that apply to all animations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_stars(flea[1:10, 1:6])
animate_stars(flea[1:10, 1:6], grand_tour(5))
animate_stars(flea[, 1:6], grand_tour(5))
animate_stars(flea[1:10, 1:6], grand_tour(5),
  col.stars = rep("grey50", 10), radius = FALSE
)
</code></pre>

<hr>
<h2 id='display_stereo'>Anaglpyh tour path animation.</h2><span id='topic+display_stereo'></span><span id='topic+animate_stereo'></span>

<h3>Description</h3>

<p>Uses red-blue anaglyphs to display a 3d tour path.  You'll need some red-
blue glasses to get much out of this displays!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_stereo(blue, red, cex = 1, ...)

animate_stereo(
  data,
  tour_path = grand_tour(3),
  blue = rgb(0, 0.91, 0.89),
  red = rgb(0.98, 0.052, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_stereo_+3A_blue">blue</code></td>
<td>
<p>blue colour (for right eye)</p>
</td></tr>
<tr><td><code id="display_stereo_+3A_red">red</code></td>
<td>
<p>red colour (for left eye)</p>
</td></tr>
<tr><td><code id="display_stereo_+3A_cex">cex</code></td>
<td>
<p>size of the point to be plotted.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_stereo_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code></p>
</td></tr>
<tr><td><code id="display_stereo_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_stereo_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_stereo(flea[, 1:6])
</code></pre>

<hr>
<h2 id='display_trails'>Display tour path with trails</h2><span id='topic+display_trails'></span><span id='topic+animate_trails'></span>

<h3>Description</h3>

<p>Animate a 2D tour path with a point trails
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_trails(
  center = TRUE,
  axes = "center",
  half_range = NULL,
  col = "black",
  pch = 20,
  cex = 1,
  past = 3,
  ...
)

animate_trails(data, tour_path = grand_tour(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_trails_+3A_center">center</code></td>
<td>
<p>if TRUE, centers projected data to (0,0).  This pins the
center of data cloud and make it easier to focus on the changing shape
rather than position.</p>
</td></tr>
<tr><td><code id="display_trails_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_trails_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_trails_+3A_col">col</code></td>
<td>
<p>color to be plotted.  Defaults to &quot;black&quot;</p>
</td></tr>
<tr><td><code id="display_trails_+3A_pch">pch</code></td>
<td>
<p>shape of the point to be plotted.  Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_trails_+3A_cex">cex</code></td>
<td>
<p>magnification of plotting text relative to default. Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_trails_+3A_past">past</code></td>
<td>
<p>draw line between current projection and projection <code>past</code>
steps ago</p>
</td></tr>
<tr><td><code id="display_trails_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_xy">display_xy</a></code></p>
</td></tr>
<tr><td><code id="display_trails_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_trails_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_trails(flea[,1:6], col=flea$species)

</code></pre>

<hr>
<h2 id='display_xy'>Display tour path with a scatterplot</h2><span id='topic+display_xy'></span><span id='topic+animate_xy'></span>

<h3>Description</h3>

<p>Animate a 2D tour path with a scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_xy(
  center = TRUE,
  axes = "center",
  half_range = NULL,
  col = "black",
  pch = 20,
  cex = 1,
  edges = NULL,
  edges.col = "black",
  edges.width = 1,
  obs_labels = NULL,
  palette = "Zissou 1",
  ...
)

animate_xy(data, tour_path = grand_tour(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_xy_+3A_center">center</code></td>
<td>
<p>if TRUE, centers projected data to (0,0).  This pins the
center of data cloud and make it easier to focus on the changing shape
rather than position.</p>
</td></tr>
<tr><td><code id="display_xy_+3A_axes">axes</code></td>
<td>
<p>position of the axes: center, bottomleft or off</p>
</td></tr>
<tr><td><code id="display_xy_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="display_xy_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="display_xy_+3A_pch">pch</code></td>
<td>
<p>shape of the point to be plotted, can be a factor or integer.  Defaults to 20.</p>
</td></tr>
<tr><td><code id="display_xy_+3A_cex">cex</code></td>
<td>
<p>size of the point to be plotted.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="display_xy_+3A_edges">edges</code></td>
<td>
<p>A two column integer matrix giving indices of ends of lines.</p>
</td></tr>
<tr><td><code id="display_xy_+3A_edges.col">edges.col</code></td>
<td>
<p>colour of edges to be plotted, Defaults to &quot;black&quot;</p>
</td></tr>
<tr><td><code id="display_xy_+3A_edges.width">edges.width</code></td>
<td>
<p>line width for edges, default 1</p>
</td></tr>
<tr><td><code id="display_xy_+3A_obs_labels">obs_labels</code></td>
<td>
<p>vector of text labels to display</p>
</td></tr>
<tr><td><code id="display_xy_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="display_xy_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+animate">animate</a></code> and
<code><a href="#topic+display_xy">display_xy</a></code></p>
</td></tr>
<tr><td><code id="display_xy_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="display_xy_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator, defaults to 2d grand tour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:6])
animate(flea[, 1:6], tour_path = grand_tour(), display = display_xy())
animate(flea[, 1:6],
  tour_path = grand_tour(),
  display = display_xy(),
  scale = TRUE
)
animate(flea[, 1:6],
  tour_path = grand_tour(),
  display = display_xy(half_range = 0.5)
)
animate_xy(flea[, 1:6], tour_path = little_tour())
animate_xy(flea[, 1:3], tour_path = guided_tour(holes()), sphere = TRUE)
animate_xy(flea[, 1:6], center = FALSE)

# The default axes are centered, like a biplot, but there are other options
animate_xy(flea[, 1:6], axes = "bottomleft")
animate_xy(flea[, 1:6], axes = "off")
animate_xy(flea[, 1:6], dependence_tour(c(1, 2, 1, 2, 1, 2)),
  axes = "bottomleft"
)

animate_xy(flea[, -7], col = flea$species)
animate_xy(flea[, -7], col = flea$species,
             pch = flea$species)

animate_xy(flea[, -7], col = flea$species,
  obs_labels=as.character(1:nrow(flea)), axes="off")

# You can also draw lines
edges &lt;- matrix(c(1:5, 2:6), ncol = 2)
animate(
  flea[, 1:6], grand_tour(),
  display_xy(axes = "bottomleft", edges = edges)
)
</code></pre>

<hr>
<h2 id='draw_slice_center'>Draw slice center guide with base graphics</h2><span id='topic+draw_slice_center'></span>

<h3>Description</h3>

<p>Draw slice center guide with base graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_slice_center(anchor, rng, limits, anchor_nav, ...)
</code></pre>

<hr>
<h2 id='draw_tour_axes'>Draw tour axes on the projected data with base graphics</h2><span id='topic+draw_tour_axes'></span>

<h3>Description</h3>

<p>Draw tour axes on the projected data with base graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_tour_axes(proj, labels, limits = 1, position = "center", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_tour_axes_+3A_proj">proj</code></td>
<td>
<p>matrix of projection coefficients</p>
</td></tr>
<tr><td><code id="draw_tour_axes_+3A_labels">labels</code></td>
<td>
<p>variable names for the axes, of length the same
as the number of rows of proj</p>
</td></tr>
<tr><td><code id="draw_tour_axes_+3A_limits">limits</code></td>
<td>
<p>value setting the lower and upper limits of
projected data, default 1</p>
</td></tr>
<tr><td><code id="draw_tour_axes_+3A_position">position</code></td>
<td>
<p>position of the axes: center (default),
bottomleft or off</p>
</td></tr>
<tr><td><code id="draw_tour_axes_+3A_...">...</code></td>
<td>
<p>other arguments passed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(flea)
flea_std &lt;- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))
prj &lt;- basis_random(ncol(flea[,1:6]), 2)
flea_prj &lt;- as.data.frame(as.matrix(flea_std) %*% prj)
par(pty = "s", mar = rep(0.1, 4))
plot(flea_prj$V1, flea_prj$V2,
     xlim = c(-3, 3), ylim = c(-3, 3),
     xlab="P1", ylab="P2")
draw_tour_axes(prj, colnames(flea)[1:6], limits=3)

plot(flea_prj$V1, flea_prj$V2,
     xlim = c(-3, 3), ylim = c(-3, 3),
     xlab="P1", ylab="P2")
draw_tour_axes(prj, colnames(flea)[1:6], limits=3, position="bottomleft")
</code></pre>

<hr>
<h2 id='estimate_eps'>Estimate cutoff eps for section pursuit.</h2><span id='topic+estimate_eps'></span>

<h3>Description</h3>

<p>Estimate cutoff eps for section pursuit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_eps(N, p, res, K, K_theta, r_breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_eps_+3A_n">N</code></td>
<td>
<p>total number of points in the input data.</p>
</td></tr>
<tr><td><code id="estimate_eps_+3A_p">p</code></td>
<td>
<p>number of dimensions of the input data.</p>
</td></tr>
<tr><td><code id="estimate_eps_+3A_res">res</code></td>
<td>
<p>resolution, (slice radius)/(data radius)</p>
</td></tr>
<tr><td><code id="estimate_eps_+3A_k">K</code></td>
<td>
<p>total number of bins</p>
</td></tr>
<tr><td><code id="estimate_eps_+3A_k_theta">K_theta</code></td>
<td>
<p>number of angular bins</p>
</td></tr>
<tr><td><code id="estimate_eps_+3A_r_breaks">r_breaks</code></td>
<td>
<p>boundaries of the radial bins</p>
</td></tr>
</table>

<hr>
<h2 id='eucl_norm_sq'>Calculate the squared Euclidean norm of a vector x</h2><span id='topic+eucl_norm_sq'></span>

<h3>Description</h3>

<p>Calculate the squared Euclidean norm of a vector x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eucl_norm_sq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eucl_norm_sq_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='find_best_dir'>Find the most promising direction to travel in.</h2><span id='topic+find_best_dir'></span>

<h3>Description</h3>

<p>Starting from the current projection, pick <code>counter</code> random location
and take a small step towards and away from each location.  The most
promising direction has the highest value of the <code>index</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_dir(old, index, dist = 0.01, counter = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_best_dir_+3A_old">old</code></td>
<td>
<p>current projection</p>
</td></tr>
<tr><td><code id="find_best_dir_+3A_index">index</code></td>
<td>
<p>interestingness index function</p>
</td></tr>
<tr><td><code id="find_best_dir_+3A_dist">dist</code></td>
<td>
<p>step size in radians, should be small</p>
</td></tr>
<tr><td><code id="find_best_dir_+3A_counter">counter</code></td>
<td>
<p>of random steps to take</p>
</td></tr>
</table>

<hr>
<h2 id='find_best_frozen_dir'>Find most promising direction in frozen space.</h2><span id='topic+find_best_frozen_dir'></span>

<h3>Description</h3>

<p>Find most promising direction in frozen space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_frozen_dir(old, frozen, index, dist = 0.01, counter = 5)
</code></pre>

<hr>
<h2 id='find_frozen_path_peak'>Find most highest peak along frozen geodesic.</h2><span id='topic+find_frozen_path_peak'></span>

<h3>Description</h3>

<p>Find most highest peak along frozen geodesic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_frozen_path_peak(old, new, frozen, index, max_dist = pi/4)
</code></pre>

<hr>
<h2 id='find_path_peak'>Find the most interesting projection along a geodesic.</h2><span id='topic+find_path_peak'></span>

<h3>Description</h3>

<p>Use <code><a href="stats.html#topic+optimize">optimize</a></code> to find the most interesting projection amongst
all projections on a geodesic.  This method assumes that the function is
continuous with a single maximum, but seems to do ok even if there are
multiple maxima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_path_peak(old, new, index, max_dist = pi/4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_path_peak_+3A_old">old</code></td>
<td>
<p>currention project</p>
</td></tr>
<tr><td><code id="find_path_peak_+3A_new">new</code></td>
<td>
<p>projection that gives direction to travel in</p>
</td></tr>
<tr><td><code id="find_path_peak_+3A_index">index</code></td>
<td>
<p>interestingness index function</p>
</td></tr>
<tr><td><code id="find_path_peak_+3A_max_dist">max_dist</code></td>
<td>
<p>maximum distance to travel along in radians</p>
</td></tr>
</table>

<hr>
<h2 id='find_platform'>Find the platform
Find the platform being used by the user</h2><span id='topic+find_platform'></span>

<h3>Description</h3>

<p>Find the platform
Find the platform being used by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_platform()
</code></pre>

<hr>
<h2 id='Flea+20measurements'>Flea beatle measurements</h2><span id='topic+Flea+20measurements'></span><span id='topic+flea'></span>

<h3>Description</h3>

<p>This data is from a paper by A. A. Lubischew, &quot;On the Use of Discriminant
Functions in Taxonomy&quot;, Biometrics, Dec 1962, pp.455-477.
</p>


<h3>Format</h3>

<p>A 74 x 7 numeric array
</p>


<h3>Details</h3>


<ul>
<li><p> tars1, width of the first joint of the first tarsus in microns
(the sum of measurements for both tarsi)
</p>
</li>
<li><p> tars2, the same for the second joint
</p>
</li>
<li><p> head, the maximal width of the head between the external edges of the
eyes in 0.01 mm
</p>
</li>
<li><p> ade1, the maximal width of the aedeagus in the fore-part in microns
</p>
</li>
<li><p> ade2, the front angle of the aedeagus ( 1 unit = 7.5 degrees)
</p>
</li>
<li><p> ade3, the aedeagus width from the side in microns
</p>
</li>
<li><p> species, which species is being examined - concinna, heptapotamica, heikertingeri
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
head(flea)
animate_xy(flea[, -7])
animate_xy(flea[, -7], col = flea[, 7])
</code></pre>

<hr>
<h2 id='freeze'>Freeze and thaw matrices</h2><span id='topic+freeze'></span><span id='topic+thaw'></span>

<h3>Description</h3>

<p>Some terminology:
* frozen variables: the variables that have fixed values
* warm variables: the remaining variables that vary freely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freeze(input, frozen)

thaw(input, frozen)
</code></pre>


<h3>Details</h3>

<p>A frozen matrix specifies which variables to fix in a projection matrix.
Warm variables should be missing (<code>NA</code>) while frozen variables should
be set to their fixed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frozen &lt;- matrix(NA, nrow = 4, ncol = 2)
frozen[3, ] &lt;- .5

input &lt;- basis_random(4, 2)
freeze(input, frozen)
thaw(input, frozen)
freeze(basis_random(4, 2), frozen)
</code></pre>

<hr>
<h2 id='frozen_guided_tour'>The frozen guided tour</h2><span id='topic+frozen_guided_tour'></span>

<h3>Description</h3>

<p>The frozen guided tour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frozen_guided_tour(frozen, index_f, d = 2, max.tries = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frozen_guided_tour_+3A_frozen">frozen</code></td>
<td>
<p>matrix of frozen variables, as described in
<code><a href="#topic+freeze">freeze</a></code></p>
</td></tr>
<tr><td><code id="frozen_guided_tour_+3A_index_f">index_f</code></td>
<td>
<p>the index function to optimise.</p>
</td></tr>
<tr><td><code id="frozen_guided_tour_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
<tr><td><code id="frozen_guided_tour_+3A_max.tries">max.tries</code></td>
<td>
<p>the maximum number of unsuccessful attempts to find
a better projection before giving up</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cmass">cmass</a></code>, <code><a href="#topic+holes">holes</a></code> and <code><a href="#topic+lda_pp">lda_pp</a></code>
for examples of index functions.  The function should take a numeric
matrix and return a single number, preferrably between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frozen &lt;- matrix(NA, nrow = 4, ncol = 2)
frozen[3, ] &lt;- .5
animate_xy(flea[, 1:4], frozen_guided_tour(frozen, holes()))
</code></pre>

<hr>
<h2 id='frozen_tour'>A frozen tour path.</h2><span id='topic+frozen_tour'></span>

<h3>Description</h3>

<p>A frozen tour fixes some of the values of the orthonormal projection
matrix and allows the others to vary freely according to any of the
other tour methods.  This frozen tour is a frozen grand tour.  See
<code><a href="#topic+frozen_guided_tour">frozen_guided_tour</a></code> for a frozen guided tour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frozen_tour(d = 2, frozen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frozen_tour_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
<tr><td><code id="frozen_tour_+3A_frozen">frozen</code></td>
<td>
<p>matrix of frozen variables, as described in
<code><a href="#topic+freeze">freeze</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frozen &lt;- matrix(NA, nrow = 4, ncol = 2)
frozen[3, ] &lt;- .5
animate_xy(flea[, 1:4], frozen_tour(2, frozen))

frozen &lt;- matrix(NA, nrow = 4, ncol = 2)
frozen[1, 1] &lt;- 0.5
animate_xy(flea[, 1:4], frozen_tour(2, frozen))

# Doesn't work - a bug?
frozen &lt;- matrix(NA, nrow = 4, ncol = 2)
frozen[1:2, 1] &lt;- 1 / 4
animate_xy(flea[, 1:4], frozen_tour(2, frozen))

## Not run: 
# This freezes one entire direction which causes a problem,
# and is caught by error handling.
# If you want to do this it would be best with a dependence
# tour, with one variable set one axis, eg 3rd variable to
# x axis would be indicated from the code below
frozen &lt;- matrix(NA, nrow = 4, ncol = 2)
frozen[3, ] &lt;- c(0, 1)
animate_xy(flea[, 1:4], frozen_tour(2, frozen))

## End(Not run)

# Two frozen variables in five.
frozen &lt;- matrix(NA, nrow = 5, ncol = 2)
frozen[3, ] &lt;- .5
frozen[4, ] &lt;- c(-.2, .2)
animate_xy(flea[, 1:5], frozen_tour(2, frozen))
</code></pre>

<hr>
<h2 id='geodesic_info'>Calculate information required to interpolate along a geodesic path between
two frames.</h2><span id='topic+geodesic_info'></span>

<h3>Description</h3>

<p>The methdology is outlined in
<a href="http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-algs.pdf">http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-algs.pdf</a>
and
<a href="http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-math.pdf">http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-math.pdf</a>,
and the code follows the notation outlined in those papers:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic_info(Fa, Fz, epsilon = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodesic_info_+3A_fa">Fa</code></td>
<td>
<p>starting frame, will be orthonormalised if necessary</p>
</td></tr>
<tr><td><code id="geodesic_info_+3A_fz">Fz</code></td>
<td>
<p>target frame, will be orthonormalised if necessary</p>
</td></tr>
<tr><td><code id="geodesic_info_+3A_epsilon">epsilon</code></td>
<td>
<p>epsilon used to determine if an angle is effectively equal
to 0</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> p = dimension of data
</p>
</li>
<li><p> d = target dimension
</p>
</li>
<li><p> F = frame, an orthonormal p x d matrix
</p>
</li>
<li><p> Fa = starting frame, Fz = target frame
</p>
</li>
<li><p> Fa'Fz = Va lamda  Vz' (svd)
</p>
</li>
<li><p> Ga = Fa Va, Gz = Fz Vz
</p>
</li>
<li><p> tau = principle angles
</p>
</li></ul>


<hr>
<h2 id='geodesic_path'>Generate geodesic path.</h2><span id='topic+geodesic_path'></span>

<h3>Description</h3>

<p>Wrap basis generation method with a function that computes the
geodesic interpolation from the previous frame to the next frame, and
provides convenient access to all the information about the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic_path(current, target, frozen = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodesic_path_+3A_current">current</code></td>
<td>
<p>starting projection</p>
</td></tr>
<tr><td><code id="geodesic_path_+3A_target">target</code></td>
<td>
<p>ending projection</p>
</td></tr>
<tr><td><code id="geodesic_path_+3A_frozen">frozen</code></td>
<td>
<p>matrix giving frozen variables, as described in
<code><a href="#topic+freeze">freeze</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frozen variables allow us to keep certain values of the projection
fixed and generate a geodesic across the subspace generated by those
</p>


<h3>Value</h3>

<table>
<tr><td><code>interpolate</code></td>
<td>
<p>A function with single parameter in [0, 1] that
returns an interpolated frame between the current and future frames.
0 gives the current plane, 1 gives the new target frame in plane of
current frame.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>The distance, in radians, between the current and target
frames.</p>
</td></tr>
<tr><td><code>Fa</code></td>
<td>
<p>The current frame.</p>
</td></tr>
<tr><td><code>Fz</code></td>
<td>
<p>The new target frame.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The principle angles between the current and target frames.</p>
</td></tr>
<tr><td><code>Ga</code></td>
<td>
<p>The current plane.</p>
</td></tr>
<tr><td><code>Gz</code></td>
<td>
<p>The target plane.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- basis_random(4, 2)
b &lt;- basis_random(4, 2)
path &lt;- geodesic_path(a, b)

path$dist
all.equal(a, path$interpolate(0))
# Not true generally - a rotated into plane of b
all.equal(b, path$interpolate(1))
</code></pre>

<hr>
<h2 id='grand_tour'>A grand tour path.</h2><span id='topic+grand_tour'></span>

<h3>Description</h3>

<p>This method generates target bases by randomly sampling on
the space of all d-dimensional planes in p-space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grand_tour(d = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grand_tour_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
<tr><td><code id="grand_tour_+3A_...">...</code></td>
<td>
<p>arguments sent to the generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All animation methods use the grand tour path by default
animate_dist(flea[, 1:6])
animate_xy(flea[, 1:6])
animate_pcp(flea[, 1:6])
animate_pcp(flea[, 1:6], grand_tour(4))

# The grand tour is a function:
tour2d &lt;- grand_tour(2)
is.function(tour2d)

# with two parameters, the previous projection and the data set
args(tour2d)
# if the previous projection is null, it will generate a starting
# basis, otherwise the argument is ignored
tour2d(NULL, mtcars)
# the data argument is just used to determine the correct dimensionality
# of the output matrix
tour2d(NULL, mtcars[, 1:2])
</code></pre>

<hr>
<h2 id='guided_section_tour'>A guided section tour path.</h2><span id='topic+guided_section_tour'></span>

<h3>Description</h3>

<p>The guided section tour is a variation of the guided tour that is
using a section pursuit index for the selection of target planes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guided_section_tour(
  index_f,
  d = 2,
  alpha = 0.5,
  cooling = 0.99,
  max.tries = 25,
  max.i = Inf,
  v_rel = NULL,
  anchor = NULL,
  search_f = search_geodesic,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guided_section_tour_+3A_index_f">index_f</code></td>
<td>
<p>the section purusit index function to optimise. The function
needs to take three arguments, the projected data, the vector of distances
from the current projection plane, and the slice thickness h.</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_alpha">alpha</code></td>
<td>
<p>the initial size of the search window, in radians</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_cooling">cooling</code></td>
<td>
<p>the amount the size of the search window should be adjusted
by after each step</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_max.tries">max.tries</code></td>
<td>
<p>the maximum number of unsuccessful attempts to find
a better projection before giving up</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_max.i">max.i</code></td>
<td>
<p>the maximum index value, stop search if a larger value is found</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_v_rel">v_rel</code></td>
<td>
<p>relative volume of the slice. If not set, suggested value
is caluclated and printed to the screen.</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_anchor">anchor</code></td>
<td>
<p>A vector specifying the reference point to anchor the slice.
If NULL (default) the slice will be anchored at the data center.</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_search_f">search_f</code></td>
<td>
<p>the search strategy to use</p>
</td></tr>
<tr><td><code id="guided_section_tour_+3A_...">...</code></td>
<td>
<p>arguments sent to the search_f</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate_slice">animate_slice</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice_index">slice_index</a></code> for an example of an index functions.
<code><a href="#topic+search_geodesic">search_geodesic</a></code>, <code><a href="#topic+search_better">search_better</a></code>,
<code><a href="#topic+search_better_random">search_better_random</a></code> for different search strategies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate samples on a 3d hollow sphere using the geozoo package
set.seed(12345)
sphere3 &lt;- geozoo::sphere.hollow(3)$points
# Columns need to be named before launching the tour
colnames(sphere3) &lt;- c("x1", "x2", "x3")
# Off-center anchoring
anchor3 &lt;- matrix(rep(0.75, 3), ncol=3)
# Index setup
r_breaks &lt;- linear_breaks(5, 0, 1)
a_breaks &lt;- angular_breaks(10)
eps &lt;- estimate_eps(nrow(sphere3), ncol(sphere3), 0.1 / 1, 5 * 10, 10, r_breaks)
idx &lt;- slice_index(r_breaks, a_breaks, eps, bintype = "polar", power = 1, reweight = TRUE, p = 3)
# Running the guided section tour select sections showing a big hole in the center
animate_slice(sphere3, guided_section_tour(idx, v_rel = 0.1, anchor = anchor3, max.tries = 5),
  v_rel = 0.1, anchor = anchor3
)
</code></pre>

<hr>
<h2 id='guided_tour'>A guided tour path.</h2><span id='topic+guided_tour'></span>

<h3>Description</h3>

<p>Instead of choosing new projections at random like the grand tour, the
guided tour always tries to find a projection that is more interesting
than the current projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guided_tour(
  index_f,
  d = 2,
  alpha = 0.5,
  cooling = 0.99,
  max.tries = 25,
  max.i = Inf,
  search_f = search_geodesic,
  n_sample = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guided_tour_+3A_index_f">index_f</code></td>
<td>
<p>the index function to optimise.</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_alpha">alpha</code></td>
<td>
<p>the initial size of the search window, in radians</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_cooling">cooling</code></td>
<td>
<p>the amount the size of the search window should be adjusted
by after each step</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_max.tries">max.tries</code></td>
<td>
<p>the maximum number of unsuccessful attempts to find
a better projection before giving up</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_max.i">max.i</code></td>
<td>
<p>the maximum index value, stop search if a larger value is found</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_search_f">search_f</code></td>
<td>
<p>the search strategy to use: <code><a href="#topic+search_geodesic">search_geodesic</a></code>, <code><a href="#topic+search_better">search_better</a></code>,
<code><a href="#topic+search_better_random">search_better_random</a></code>, <code><a href="#topic+search_polish">search_polish</a></code>. Default is <code><a href="#topic+search_geodesic">search_geodesic</a></code>.</p>
</td></tr>
<tr><td><code id="guided_tour_+3A_n_sample">n_sample</code></td>
<td>
<p>number of samples to generate if <code>search_f</code> is <code><a href="#topic+search_polish">search_polish</a></code></p>
</td></tr>
<tr><td><code id="guided_tour_+3A_...">...</code></td>
<td>
<p>arguments sent to the search_f</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the index functions only work in 2d.
</p>
<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmass">cmass</a></code>, <code><a href="#topic+holes">holes</a></code> and <code><a href="#topic+lda_pp">lda_pp</a></code>
for examples of index functions.  The function should take a numeric
matrix and return a single number, preferably between 0 and 1.
<code><a href="#topic+search_geodesic">search_geodesic</a></code>, <code><a href="#topic+search_better">search_better</a></code>,
<code><a href="#topic+search_better_random">search_better_random</a></code> for different search strategies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flea_std &lt;- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))
animate_xy(flea_std, guided_tour(holes()), sphere = TRUE)

animate_xy(flea_std, guided_tour(holes(), search_f = search_better_random), sphere = TRUE)
animate_dist(flea_std, guided_tour(holes(), 1), sphere = TRUE)
animate_xy(flea_std, guided_tour(lda_pp(flea$species)), sphere = TRUE, col = flea$species)

# save_history is particularly useful in conjunction with the
# guided tour as it allows us to look at the tour path in many different
# ways
f &lt;- flea_std[, 1:3]
tries &lt;- replicate(5, save_history(f, guided_tour(holes())), simplify = FALSE)

</code></pre>

<hr>
<h2 id='holes'>Holes index.</h2><span id='topic+holes'></span>

<h3>Description</h3>

<p>Calculates the holes index. See Cook and Swayne (2007)
Interactive and Dynamic Graphics for Data Analysis for equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holes()
</code></pre>

<hr>
<h2 id='interpolate'>Interpolate geodesically between bases.</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>This function takes a set of bases and produces a tour by geodesically
interpolating between each basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(basis_set, angle = 0.05, cycle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_basis_set">basis_set</code></td>
<td>
<p>input basis set</p>
</td></tr>
<tr><td><code id="interpolate_+3A_angle">angle</code></td>
<td>
<p>target distance (in radians) between bases</p>
</td></tr>
<tr><td><code id="interpolate_+3A_cycle">cycle</code></td>
<td>
<p>For <code><a href="#topic+planned_tour">planned_tour</a></code> cycle through continuously (TRUE) or stop after first pass (FALSE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- save_history(flea[, 1:6], grand_tour(1), max = 3)
dim(t1)
dim(interpolate(t1, 0.01))
dim(interpolate(t1, 0.05))
dim(interpolate(t1, 0.1))
t2 &lt;- save_history(flea[, 1:6], grand_tour(2), max = 2)
dim(interpolate(t2, 0.05))
</code></pre>

<hr>
<h2 id='is_orthonormal'>Test if a numeric matrix is orthonormal.</h2><span id='topic+is_orthonormal'></span>

<h3>Description</h3>

<p>Test if a numeric matrix is orthonormal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_orthonormal(x, tol = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_orthonormal_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="is_orthonormal_+3A_tol">tol</code></td>
<td>
<p>tolerance used to test floating point differences</p>
</td></tr>
</table>

<hr>
<h2 id='Laser+20measurements'>Turnable laser measurements from Bellcore</h2><span id='topic+Laser+20measurements'></span><span id='topic+laser'></span>

<h3>Description</h3>

<p>This data came from an investigation of an experimental laser at Bellcore.
It was a tunable laser, in the sense that both its wavelength and power
output were controllable.
</p>


<h3>Format</h3>

<p>A 64 x 4 numeric array
</p>


<h3>Details</h3>

<p>Rotation helped the experimental physicists to characterize the laser, which
turned out not to be a very good one, due to its unstable operating region.
</p>
<p>This data initially came to the statistics research group when Janette
Cooper asked Paul Tukey to help her analyze the data she had collected to
describe the laser.
</p>

<ul>
<li><p> ifront, current applied to the front of the laser
</p>
</li>
<li><p> iback, current applied to the back of the laser
</p>
</li>
<li><p> power, output power
</p>
</li>
<li><p> lambda, output wavelength
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
head(laser)
animate_xy(laser[, -4])
</code></pre>

<hr>
<h2 id='lda_pp'>LDA projection pursuit index.</h2><span id='topic+lda_pp'></span>

<h3>Description</h3>

<p>Calculate the LDA projection pursuit index.  See Cook and Swayne (2007)
Interactive and Dynamic Graphics for Data Analysis for equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lda_pp(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lda_pp_+3A_cl">cl</code></td>
<td>
<p>class to be used.  Such as &quot;color&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='linear_breaks'>Returns n equidistant bins between a and b</h2><span id='topic+linear_breaks'></span>

<h3>Description</h3>

<p>Returns n equidistant bins between a and b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_breaks(n, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_breaks_+3A_n">n</code></td>
<td>
<p>number of bins</p>
</td></tr>
<tr><td><code id="linear_breaks_+3A_a">a</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="linear_breaks_+3A_b">b</code></td>
<td>
<p>upper bound</p>
</td></tr>
</table>

<hr>
<h2 id='little_tour'>A little tour path.</h2><span id='topic+little_tour'></span>

<h3>Description</h3>

<p>The little tour is a planned tour that travels between all axis parallel
projections. (John McDonald named this type of tour.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>little_tour(d = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="little_tour_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:6], little_tour())
animate_pcp(flea[, 1:6], little_tour(3))
animate_scatmat(flea[, 1:6], little_tour(3))
animate_pcp(flea[, 1:6], little_tour(4))
</code></pre>

<hr>
<h2 id='local_tour'>A local tour path.</h2><span id='topic+local_tour'></span>

<h3>Description</h3>

<p>The local tour alternates between the starting position and a
nearby random projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_tour(start, angle = pi/4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_tour_+3A_start">start</code></td>
<td>
<p>initial projection matrix</p>
</td></tr>
<tr><td><code id="local_tour_+3A_angle">angle</code></td>
<td>
<p>distance in radians to stay within</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:3], local_tour(basis_init(3, 2)))
animate_xy(flea[, 1:3], local_tour(basis_init(3, 2), 0.2))
animate_xy(flea[, 1:3], local_tour(basis_random(3, 2), 0.2))
</code></pre>

<hr>
<h2 id='manual_slice'>Manually slice along a variable axis.</h2><span id='topic+manual_slice'></span>

<h3>Description</h3>

<p>The manual slice tour takes the current projection, with display_slice,
and changes the slice center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manual_slice(
  data,
  proj,
  var = 1,
  nsteps = 20,
  v_rel = 0.01,
  rescale = FALSE,
  sphere = FALSE,
  col = "black",
  half_range = NULL,
  anchor_nav = "topright",
  palette = "Zissou 1",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manual_slice_+3A_data">data</code></td>
<td>
<p>numeric matrix, with n rows and p columns</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_proj">proj</code></td>
<td>
<p>projection from which slices are constructed</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_var">var</code></td>
<td>
<p>variable axis to run the center along: 1, ..., p</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_nsteps">nsteps</code></td>
<td>
<p>number of changes in center to make</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_v_rel">v_rel</code></td>
<td>
<p>relative volume of the slice. If not set, suggested value
is calculated and printed to the screen.</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_rescale">rescale</code></td>
<td>
<p>Default FALSE. If TRUE, rescale all variables to range [0,1]?</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_sphere">sphere</code></td>
<td>
<p>if true, sphere all variables</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_col">col</code></td>
<td>
<p>color to use for points, can be a vector or hexcolors or a factor.  Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_half_range">half_range</code></td>
<td>
<p>half range to use when calculating limits of projected.
If not set, defaults to maximum distance from origin to each row of data.</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_anchor_nav">anchor_nav</code></td>
<td>
<p>position of the anchor: center, topright or off</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
<tr><td><code id="manual_slice_+3A_...">...</code></td>
<td>
<p>other options passed to output device</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Note that you might need to use the quartz()
# on OSX to see the animation
sphere5 &lt;- data.frame(geozoo::sphere.hollow(5)$points)
proj &lt;- basis_random(5, 2)
manual_slice(sphere5, proj, var=3, nsteps=10, rescale=TRUE, half_range=1.5)
</code></pre>

<hr>
<h2 id='mapColors'>Map vector of factors to color</h2><span id='topic+mapColors'></span>

<h3>Description</h3>

<p>Map vector of factors to color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapColors(x, palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapColors_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="mapColors_+3A_palette">palette</code></td>
<td>
<p>name of color palette for point colour, used by <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>, default &quot;Zissou 1&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='mapShapes'>Map vector of factors to pch</h2><span id='topic+mapShapes'></span>

<h3>Description</h3>

<p>Map vector of factors to pch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapShapes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapShapes_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
</table>

<hr>
<h2 id='new_geodesic_path'>Generate a geodesic path between bases supplied by generator</h2><span id='topic+new_geodesic_path'></span>

<h3>Description</h3>

<p>A tour path is a function that when called with the current projection
and data set, generates sequence of <code><a href="#topic+geodesic_path">geodesic_path</a></code>s.  The
path can either span the whole space of orthonormal matrices, the default
or be restricted to a subspace with the frozen argument.  More details
are given in the documentation for <code><a href="#topic+freeze">freeze</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_geodesic_path(name, generator, frozen = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_geodesic_path_+3A_name">name</code></td>
<td>
<p>name to give tour path</p>
</td></tr>
<tr><td><code id="new_geodesic_path_+3A_generator">generator</code></td>
<td>
<p>basis generator function</p>
</td></tr>
<tr><td><code id="new_geodesic_path_+3A_frozen">frozen</code></td>
<td>
<p>matrix giving frozen variables, as described in
<code><a href="#topic+freeze">freeze</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subsequent frames are guaranteed to be at least 0.001 radians away from
the current frame.  If after 10 tries the generator does not give a new
basis at least this far away then we give up.
</p>
<p>If a suitable new basis can not be found, the path function returns NULL
indicating that the tour should stop.
</p>

<hr>
<h2 id='new_tour'>Create a new tour.</h2><span id='topic+new_tour'></span>

<h3>Description</h3>

<p>The tour function provides the common machinery behind all tour methods:
interpolating from basis to basis, and generating new bases when necessary.
You should not have to call this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_tour(data, tour_path, start = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_tour_+3A_data">data</code></td>
<td>
<p>the data matrix to be projected</p>
</td></tr>
<tr><td><code id="new_tour_+3A_tour_path">tour_path</code></td>
<td>
<p>basis generator, a function that generates a new basis,
called with the previous projection and the data set.  For more
complicated tour paths, this will need to be a closure with local
variables.  Should return NULL if the tour should terminate</p>
</td></tr>
<tr><td><code id="new_tour_+3A_start">start</code></td>
<td>
<p>starting projection, if omitted will use default projection
from generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are intended to call <code>new_tour()</code> from the global environment, try <code>save_history()</code> and then animate with a <code>planned_tour()</code>. See <code><a href="#topic+save_history">save_history</a></code> for examples on this.
</p>


<h3>Value</h3>

<p>a function with single argument, step_size.  This function returns
a list containing the new projection, the current target and the number
of steps taken towards the target.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_history">save_history</a></code>, <code><a href="#topic+render">render</a></code> and
<code><a href="#topic+animate">animate</a></code> for examples of functions that use this function
to run dynamic tours.
</p>

<hr>
<h2 id='norm_bin'>Normality index.</h2><span id='topic+norm_bin'></span><span id='topic+norm_kol'></span>

<h3>Description</h3>

<p>Compares the similarity between the projected distribution and a normal distribution.
</p>

<ul>
<li><p>norm_bin compares the count in 100 histogram bins
</p>
</li>
<li><p>norm_kol compares the cdf based on the Kolmogorov–Smirnov test (KS test)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>norm_bin(nr)

norm_kol(nr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_bin_+3A_nr">nr</code></td>
<td>
<p>The number of rows in the target matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># manually compute the norm_kol index
# create the index function
set.seed(123)
index &lt;- norm_kol(nrow(flea[, 1:3]))
# create the projection
proj &lt;- matrix(c(1, 0, 0), nrow = 3)
# pre-process the example data
flea_s &lt;- sphere_data(flea[, 1:3])
# produce the index value
index(flea_s %*% proj)
</code></pre>

<hr>
<h2 id='normalise'>Normalise a numeric matrix.</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Ensure that columns of a numeric matrix have norm 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_+3A_x">x</code></td>
<td>
<p>numeric matrix or vector</p>
</td></tr>
</table>

<hr>
<h2 id='Olive+20oil+20measurements'>Olive oil samples from Italy</h2><span id='topic+Olive+20oil+20measurements'></span><span id='topic+olive'></span>

<h3>Description</h3>

<p>This data is from a paper by Forina, Armanino, Lanteri, Tiscornia (1983)
Classification of Olive Oils from their Fatty Acid Composition, in Martens
and Russwurm (ed) Food Research and Data Anlysis. We thank Prof. Michele
Forina, University of Genova, Italy for making this dataset available.
</p>


<h3>Format</h3>

<p>A 572 x 10 numeric array
</p>


<h3>Details</h3>


<ul>
<li><p> region Three super-classes of Italy: North, South and the
island of Sardinia
</p>
</li>
<li><p> area Nine collection areas: three from North, four from South
and 2 from Sardinia
</p>
</li>
<li><p> palmitic, palmitoleic, stearic, oleic, linoleic, linolenic,
arachidic, eicosenoic fatty acids percent x 100
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
head(olive)
animate_xy(olive[, c(7, 9, 10)])
animate_xy(olive[, c(7, 9, 10)], col = olive[, 1])
</code></pre>

<hr>
<h2 id='orthonormalise'>Orthonormalise using modified Gram-Schmidt process.</h2><span id='topic+orthonormalise'></span>

<h3>Description</h3>

<p>Orthonormalise using modified Gram-Schmidt process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthonormalise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthonormalise_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>

<hr>
<h2 id='orthonormalise_by'>Orthonormalise one matrix by another.</h2><span id='topic+orthonormalise_by'></span>

<h3>Description</h3>

<p>This ensures that each column in x is orthogonal to the corresponding
column in by.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthonormalise_by(x, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthonormalise_by_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="orthonormalise_by_+3A_by">by</code></td>
<td>
<p>numeric matrix, same size as x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>orthonormal numeric matrix
</p>

<hr>
<h2 id='Ozone+20measurements'>Monthly ozone measurements over Central America</h2><span id='topic+Ozone+20measurements'></span><span id='topic+ozone'></span>

<h3>Description</h3>

<p>This data set is a subset of the data from the 2006 ASA Data expo challenge.
The data are monthly ozone averages on a very coarse 24 by 24 grid covering
Central America, from Jan 1995 to Dec 2000. The data is stored in a 3d area
with the first two dimensions representing latitude and longitude, and the
third representing
time.
</p>


<h3>Format</h3>

<p>A 24 x 24 x 72 numeric array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(display_image)
</code></pre>

<hr>
<h2 id='path_curves'>Draw the path that the geodesics took.</h2><span id='topic+path_curves'></span>

<h3>Description</h3>

<p>This computes the projected values of each observation at each step, and
allows you to recreate static views of the animated plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_curves(history, data = attr(history, "data"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_curves_+3A_history">history</code></td>
<td>
<p>list of bases produced by <code><a href="#topic+save_history">save_history</a></code>
(or otherwise)</p>
</td></tr>
<tr><td><code id="path_curves_+3A_data">data</code></td>
<td>
<p>dataset to be projected on to bases</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>path1d &lt;- save_history(flea[, 1:6], grand_tour(1), 3)
path2d &lt;- save_history(flea[, 1:6], grand_tour(2), 3)

if (require("ggplot2")) {
  plot(path_curves(path1d))
  plot(path_curves(interpolate(path1d)))

  plot(path_curves(path2d))
  plot(path_curves(interpolate(path2d)))

  # Instead of relying on the built in plot method, you might want to
  # generate your own.  Here are few examples of alternative displays:

  df &lt;- path_curves(path2d)
  ggplot(data = df, aes(x = step, y = value, group = obs:var, colour = var)) +
    geom_line() +
    facet_wrap(~obs)

  library(tidyr)
  ggplot(
    data = pivot_wider(df,
      id_cols = c(obs, step),
      names_from = var, names_prefix = "Var",
      values_from = value
    ),
    aes(x = Var1, y = Var2)
  ) +
    geom_point() +
    facet_wrap(~step) +
    coord_equal()
}
</code></pre>

<hr>
<h2 id='path_dist'>Compute distance matrix from bases.</h2><span id='topic+path_dist'></span>

<h3>Description</h3>

<p>Compute distance matrix from bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_dist(history)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_dist_+3A_history">history</code></td>
<td>
<p>history of the plots</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># This code is to be used as an example but you should increase
# the max from 2 to 50, say, to check tour coverage.
flea_std &lt;- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))
grand &lt;- interpolate(save_history(flea_std, max = 2), 0.2)
# The grand tour  -----------------------------
# Look at the tour path in a tour, how well does it cover a sphere
# Using MDS to summarise the high-d space of projections
# Last basis is a duplicate, needs removing
d &lt;- path_dist(grand[,,-dim(grand)[[3]]])
ord &lt;- as.data.frame(MASS::isoMDS(d)$points)
require(ggplot2)
ggplot(data = ord, aes(x=V1, y=V2)) +
  geom_path() +
  coord_equal() +
  labs(x = NULL, y = NULL)

# Compare five guided tours  -----------------------------
holes1d &lt;- guided_tour(holes(), 1)
tour_reps &lt;- replicate(5, save_history(flea_std, holes1d, max = 2),
  simplify = FALSE
)
tour_reps2 &lt;- lapply(tour_reps, interpolate, 0.2)

bases &lt;- unlist(lapply(tour_reps2, as.list), recursive = FALSE)
class(bases) &lt;- "history_list"
index_values &lt;- paths_index(tour_reps2, holes())
index_values$step &lt;- index_values$step.1
d &lt;- path_dist(bases)
ord &lt;- as.data.frame(cmdscale(d, 2))

info &lt;- cbind(ord, index_values)
ggplot(data = info, aes(x = step, y = value, group = try)) +
  geom_line()
##ggplot(data = info, aes(x = V1, y = V2, group = try)) +
##  geom_path() +
##  geom_point(aes(size = value)) +
##  coord_equal()
##last_plot() + facet_wrap(~try)
</code></pre>

<hr>
<h2 id='path_index'>Compute index values for a tour history.</h2><span id='topic+path_index'></span>

<h3>Description</h3>

<p>Compute index values for a tour history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_index(history, index_f, data = attr(history, "data"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_index_+3A_history">history</code></td>
<td>
<p>list of bases produced by <code><a href="#topic+save_history">save_history</a></code>
(or otherwise)</p>
</td></tr>
<tr><td><code id="path_index_+3A_index_f">index_f</code></td>
<td>
<p>index function to apply to each basis</p>
</td></tr>
<tr><td><code id="path_index_+3A_data">data</code></td>
<td>
<p>dataset to be projected on to bases</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+save_history">save_history</a></code> for options to save history
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fl_holes &lt;- save_history(flea[, 1:6], guided_tour(holes()), sphere = TRUE)
path_index(fl_holes, holes())
## path_index(fl_holes, cmass())

plot(path_index(fl_holes, holes()), type = "l")
## plot(path_index(fl_holes, cmass()), type = "l")


# Use interpolate to show all intermediate bases as well
hi &lt;- path_index(interpolate(fl_holes), holes())
hi
plot(hi)

</code></pre>

<hr>
<h2 id='paths_index'>Compute index value for many histories.</h2><span id='topic+paths_index'></span>

<h3>Description</h3>

<p>This is a convenience method that returns a data frame summarising the
index values for multiple tour paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths_index(bases_list, index_f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paths_index_+3A_bases_list">bases_list</code></td>
<td>
<p>list of histories produced by <code><a href="#topic+save_history">save_history</a></code></p>
</td></tr>
<tr><td><code id="paths_index_+3A_index_f">index_f</code></td>
<td>
<p>index function to apply to each projection</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># The max.tries is low for satisfying CRAN checks
# Increase it for using in practice
holes1d &lt;- guided_tour(holes(), 1, max.tries=2)
# Perform guided tour 5 times, saving results
tries &lt;- replicate(5, save_history(flea[, 1:6], holes1d), simplify = FALSE)
# Interpolate between target bases
itries &lt;- lapply(tries, interpolate)

paths &lt;- paths_index(itries, holes())
head(paths)

if (require(ggplot2)) {
  ggplot(data = paths, aes(x=step, y=value, group = try)) + geom_line()
  ## ggplot(data = paths, aes(x=step, y=improvement, group = try)) + geom_line()
}
</code></pre>

<hr>
<h2 id='pda_pp'>PDA projection pursuit index.</h2><span id='topic+pda_pp'></span>

<h3>Description</h3>

<p>Calculate the PDA projection pursuit index.  See Lee and Cook (2009)
A Projection Pursuit Index for Large p, Small n Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pda_pp(cl, lambda = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pda_pp_+3A_cl">cl</code></td>
<td>
<p>class to be used.  Such as &quot;color&quot;</p>
</td></tr>
<tr><td><code id="pda_pp_+3A_lambda">lambda</code></td>
<td>
<p>shrinkage parameter (0 = no shrinkage, 1 = full shrinkage)</p>
</td></tr>
</table>

<hr>
<h2 id='Places+20Ratings'>Ratings of different locations across North America</h2><span id='topic+Places+20Ratings'></span><span id='topic+places'></span>

<h3>Description</h3>

<p>The &quot;places data&quot; were distributed to interested ASA members a few years ago
so that they could apply contemporary data analytic methods to describe
these data and then present results in a poster session at the ASA annual
conference.  Latitude and longitude have been added by Paul Tukey.
</p>


<h3>Format</h3>

<p>A 329 x 14 numeric array
</p>


<h3>Details</h3>

<p>____________________________________________________________________
</p>
<p>The first dataset is taken from the Places Rated Almanac, by Richard Boyer
and David Savageau, copyrighted and published by Rand McNally. This book
order (SBN) number is 0-528-88008-X, and it retails for $14.95 .  The data
are reproduced on disk by kind permission of the publisher, and with the
request that the copyright notice of Rand McNally, and the names of the
authors appear in any paper or presentation using these data.
</p>
<p>The nine rating criteria used by Places Rated Almanac are: Climate and
Terrain Housing Health Care and Environment Crime Transportation Education
The Arts Recreation Economics
</p>
<p>For all but two of the above criteria, the higher the score, the better.
For Housing and Crime, the lower the score the better.
</p>
<p>The scores are computed using the following component statistics for each
criterion (see the Places Rated Almanac for details):
</p>
<p>Climate and Terrain: very hot and very cold months, seasonal temperature
variation, heating- and cooling-degree days, freezing days, zero-degree
days, ninety-degree days.
</p>
<p>Housing: utility bills, property taxes, mortgage payments.
</p>
<p>Health Care and Environment: per capita physicians, teaching hospitals,
medical schools, cardiac rehabilitation centers, comprehensive cancer
treatment centers, hospices, insurance/hospitalization costs index,
flouridation of drinking water, air pollution.
</p>
<p>Crime: violent crime rate, property crime rate.
</p>
<p>Transportation: daily commute, public transportation, Interstate highways,
air service, passenger rail service.
</p>
<p>Education: pupil/teacher ratio in the public K-12 system, effort index in
K-12, accademic options in higher education.
</p>
<p>The Arts: museums, fine arts and public radio stations, public television
stations, universities offering a degree or degrees in the arts, symphony
orchestras, theatres, opera companies, dance companies, public libraries.
</p>
<p>Recreation: good restaurants, public golf courses, certified lanes for
tenpin bowling, movie theatres, zoos, aquariums, family theme parks,
sanctioned automobile race tracks, pari-mutuel betting attractions, major-
and minor- league professional sports teams, NCAA Division I football and
basketball teams, miles of ocean or Great Lakes coastline, inland water,
national forests, national parks, or national wildlife refuges, Consolidated
Metropolitan Statistical Area access.
</p>
<p>Economics: average household income adjusted for taxes and living costs,
income growth, job growth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(places)
animate_xy(places[, 1:9])
</code></pre>

<hr>
<h2 id='planned_tour'>A planned tour path.</h2><span id='topic+planned_tour'></span><span id='topic+planned2_tour'></span>

<h3>Description</h3>

<p>The planned tour takes you from one basis to the next in a
set order.  Once you have visited all the planned bases, you either stop
or start from the beginning once more (if <code>cycle = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planned_tour(basis_set, cycle = FALSE)

planned2_tour(basis_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planned_tour_+3A_basis_set">basis_set</code></td>
<td>
<p>the set of bases as a list of projection matrices
or a 3d array</p>
</td></tr>
<tr><td><code id="planned_tour_+3A_cycle">cycle</code></td>
<td>
<p>cycle through continuously (<code>TRUE</code>) or stop after
first pass (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+little_tour">little_tour</a></code>, a special type of planned tour
which cycles between all axis parallel projections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twod &lt;- save_history(flea[, 1:3], max = 5)
str(twod)
animate_xy(flea[, 1:3], planned_tour(twod))
animate_xy(flea[, 1:3], planned_tour(twod, TRUE))

oned &lt;- save_history(flea[, 1:6], grand_tour(1), max = 3)
animate_dist(flea[, 1:6], planned_tour(oned))
</code></pre>

<hr>
<h2 id='plot.path_curve'>Plot history curves.</h2><span id='topic+plot.path_curve'></span>

<h3>Description</h3>

<p>The default plot method is a line plot with step on the x axis and
value on the y axis.  Each observation is drawn with a different line
line and the plot is facetted by variable.  This is rather similar in
spirit to a parallel coordinates plot or Andrews curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'path_curve'
plot(x, ...)
</code></pre>


<h3>Details</h3>

<p>For alternative ways of plotting this data, see
<code><a href="#topic+path_curves">path_curves</a></code>
</p>

<hr>
<h2 id='plot.path_index'>Plot history index with ggplot2.</h2><span id='topic+plot.path_index'></span>

<h3>Description</h3>

<p>Plot history index with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'path_index'
plot(x, ...)
</code></pre>

<hr>
<h2 id='proj_dist'>Calculate the distance between two bases.</h2><span id='topic+proj_dist'></span>

<h3>Description</h3>

<p>Computes the Frobenius norm between two bases, in radians.  This is
equals to the Euclidean norm of the vector of principal angles between
the two subspaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_dist_+3A_x">x</code></td>
<td>
<p>projection matrix a</p>
</td></tr>
<tr><td><code id="proj_dist_+3A_y">y</code></td>
<td>
<p>projection matrix b</p>
</td></tr>
</table>

<hr>
<h2 id='project3d'>Stereographic projection</h2><span id='topic+project3d'></span>

<h3>Description</h3>

<p>Math from http://dogfeathers.com/java/3dproj.html
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project3d(d3, length = par("din")[1] * 25.4, z0 = 300, d = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project3d_+3A_d3">d3</code></td>
<td>
<p>3d numeric matrix giving position of points</p>
</td></tr>
<tr><td><code id="project3d_+3A_length">length</code></td>
<td>
<p>width of plot, mm</p>
</td></tr>
<tr><td><code id="project3d_+3A_z0">z0</code></td>
<td>
<p>distance from eye to screen, mm</p>
</td></tr>
<tr><td><code id="project3d_+3A_d">d</code></td>
<td>
<p>half interpupilary distance, mm</p>
</td></tr>
</table>

<hr>
<h2 id='radial_bin_weight_inv'>Inverse weights for rescaling counts in radial bins.</h2><span id='topic+radial_bin_weight_inv'></span>

<h3>Description</h3>

<p>Inverse weights for rescaling counts in radial bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radial_bin_weight_inv(r1, r2, R, p)
</code></pre>

<hr>
<h2 id='radial_tour'>A radial tour path.</h2><span id='topic+radial_tour'></span>

<h3>Description</h3>

<p>The radial tour rotates a chosen variable axis out of the current
projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radial_tour(start, mvar = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radial_tour_+3A_start">start</code></td>
<td>
<p>initial projection matrix</p>
</td></tr>
<tr><td><code id="radial_tour_+3A_mvar">mvar</code></td>
<td>
<p>variable(s) chosen to rotate out</p>
</td></tr>
<tr><td><code id="radial_tour_+3A_...">...</code></td>
<td>
<p>additional arguments for drawing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="#topic+animate">animate</a></code>,
<code><a href="#topic+save_history">save_history</a></code> or <code><a href="#topic+render">render</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:6], radial_tour(basis_random(6, 2), mvar = 4))
animate_xy(flea[, 1:6], radial_tour(basis_random(6, 2), mvar = c(3,4)))
animate_dist(flea[, 1:6], radial_tour(basis_random(6, 1), mvar = 4))
animate_scatmat(flea[, 1:6], radial_tour(basis_random(6, 3), mvar = 4))
</code></pre>

<hr>
<h2 id='Rat+20CNS'>Rat CNS Gene Expression</h2><span id='topic+Rat+20CNS'></span><span id='topic+ratcns'></span>

<h3>Description</h3>

<p>Columns:
</p>


<h3>Format</h3>

<p>A 112 x 11 numeric array
</p>


<h3>Details</h3>

<p>e11  e13  e15  e18  e21   p0   p7  p14    a class1 class2
</p>

<ul>
<li><p> e11, an ebryonic timepoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> e13, an ebryonic timepoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> e15, an ebryonic timepoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> e18, an ebryonic timepoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> e21, an ebryonic timepoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> p0, a postnatal timpoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> p7, a postnatal timpoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> p14, a postnatal timpoint from the original data with the number
corresponding to the day
</p>
</li>
<li><p> a, a postnatal timpoint from the original data. It is equivalent to
p90.
</p>
</li>
<li><p> class1, is the high-level class: its range is 1:4
</p>
</li>
<li><p> class2, breaks down the high-level classes, so its range is 1:14
</p>
</li></ul>

<p>Rows: Each case is a gene (or gene family?) And each cell is the gene
expression level for that gene at time t, averaging a few measured values
and normalizing using the maximum expression value for that gene.
</p>
<p>Reference (available on the web at pnas.org): Large-scale temporal gene
expression mapping of central nervous system development by X. Wen, S.
Fuhrman, G. S. Michaels, D. B. Carr, S. Smith, J. L. Barker, R. Somogyi in
the Proceedings of the National Academy of Science, Vol 95, pp. 334-339,
January 1998
</p>


<h3>References</h3>

<p>https://www.pnas.org
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(ratcns)
animate_xy(ratcns[, 1:8], col = ratcns[, 10])
</code></pre>

<hr>
<h2 id='render'>Render frames of animation to disk</h2><span id='topic+render'></span>

<h3>Description</h3>

<p>Render frames of animation to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render(
  data,
  tour_path,
  display,
  dev,
  ...,
  apf = 1/10,
  frames = 50,
  rescale = FALSE,
  sphere = FALSE,
  start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="render_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator</p>
</td></tr>
<tr><td><code id="render_+3A_display">display</code></td>
<td>
<p>the method used to render the projected data,
e.g. <code><a href="#topic+display_xy">display_xy</a></code>, <code><a href="#topic+display_pcp">display_pcp</a></code></p>
</td></tr>
<tr><td><code id="render_+3A_dev">dev</code></td>
<td>
<p>name of output device to use (e.g. <code><a href="grDevices.html#topic+png">png</a></code>,
<code><a href="grDevices.html#topic+pdf">pdf</a></code>)</p>
</td></tr>
<tr><td><code id="render_+3A_...">...</code></td>
<td>
<p>other options passed to output device</p>
</td></tr>
<tr><td><code id="render_+3A_apf">apf</code></td>
<td>
<p>angle (in radians) per frame</p>
</td></tr>
<tr><td><code id="render_+3A_frames">frames</code></td>
<td>
<p>number of frames in output</p>
</td></tr>
<tr><td><code id="render_+3A_rescale">rescale</code></td>
<td>
<p>default FALSE. If TRUE, rescale all variables to range [0,1]</p>
</td></tr>
<tr><td><code id="render_+3A_sphere">sphere</code></td>
<td>
<p>if true, sphere all variables</p>
</td></tr>
<tr><td><code id="render_+3A_start">start</code></td>
<td>
<p>starting projection.  If <code>NULL</code>, uses path default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp_path &lt;- tempdir()
render(flea[, 1:6], grand_tour(), display_xy(), "pdf",
  frames = 3,
  file.path(tmp_path, "test.pdf")
)
render(flea[, 1:6], grand_tour(), display_xy(), "png",
  frames = 3,
  file.path(tmp_path, "test-%03d.png")
)

</code></pre>

<hr>
<h2 id='render_anim'>Render a set of animation frames</h2><span id='topic+render_anim'></span>

<h3>Description</h3>

<p>This function takes a set of frames as produced by
save_history(), and creates the projected data and axes
in for format needed to create the animation using plotly.
It will be useful for showing a tour where mouseover can
be used to identify points.
Note that for now this only works for 2D projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_anim(
  data,
  vars = NULL,
  frames,
  edges = NULL,
  axis_labels = NULL,
  obs_labels = NULL,
  limits = 1,
  position = "center"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_anim_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns,
should be standardised to have mean 0, sd 1</p>
</td></tr>
<tr><td><code id="render_anim_+3A_vars">vars</code></td>
<td>
<p>numeric columns of data to be projected, as a vector, eg 1:4</p>
</td></tr>
<tr><td><code id="render_anim_+3A_frames">frames</code></td>
<td>
<p>array of projection matrices, should be interpolated already</p>
</td></tr>
<tr><td><code id="render_anim_+3A_edges">edges</code></td>
<td>
<p>to and from of row id's to connect with an line</p>
</td></tr>
<tr><td><code id="render_anim_+3A_axis_labels">axis_labels</code></td>
<td>
<p>labels of the axes to be displayed</p>
</td></tr>
<tr><td><code id="render_anim_+3A_obs_labels">obs_labels</code></td>
<td>
<p>labels of the observations to be available for interactive mouseover</p>
</td></tr>
<tr><td><code id="render_anim_+3A_limits">limits</code></td>
<td>
<p>value setting the lower and upper limits of
projected data, default 1</p>
</td></tr>
<tr><td><code id="render_anim_+3A_position">position</code></td>
<td>
<p>position of the axes: center (default),
left of data or off</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing indexed projected data, edges, circle and segments for axes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(flea)
flea_std &lt;- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))
t1 &lt;- save_history(flea_std, max=2)
t1i &lt;- tourr::interpolate(t1, 0.1)
p &lt;- render_anim(data=flea_std, frames=t1i)
if (require(ggplot2)) {
  pg &lt;- ggplot() +
    geom_path(data=p$circle, aes(x=c1, y=c2, frame=frame)) +
    geom_segment(data=p$axes, aes(x=x1, y=y1, xend=x2, yend=y2, frame=frame)) +
    geom_text(data=p$axes, aes(x=x2, y=y2, frame=frame, label=axis_labels)) +
    geom_point(data=p$frames, aes(x=P1, y=P2, frame=frame, label=obs_labels)) +
    coord_equal() +
    theme_bw() +
    theme(axis.text=element_blank(),
        axis.title=element_blank(),
        axis.ticks=element_blank(),
        panel.grid=element_blank())
  if (interactive()) {
    require(plotly)
    ggplotly(pg, width=500, height=500) |&gt;
      animation_button(label="Go") |&gt;
      animation_slider(len=0.8, x=0.5, xanchor="center") |&gt;
      animation_opts(easing="linear", transition=0, redraw=FALSE)
  }
}
</code></pre>

<hr>
<h2 id='render_gif'>Render frames of animation to a gif file</h2><span id='topic+render_gif'></span>

<h3>Description</h3>

<p>Render frames of animation to a gif file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_gif(
  data,
  tour_path,
  display,
  gif_file = "animation.gif",
  ...,
  apf = 1/10,
  frames = 50,
  rescale = FALSE,
  sphere = FALSE,
  start = NULL,
  loop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_gif_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="render_gif_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator</p>
</td></tr>
<tr><td><code id="render_gif_+3A_display">display</code></td>
<td>
<p>the method used to render the projected data,
e.g. <code><a href="#topic+display_xy">display_xy</a></code>, <code><a href="#topic+display_pcp">display_pcp</a></code></p>
</td></tr>
<tr><td><code id="render_gif_+3A_gif_file">gif_file</code></td>
<td>
<p>Name of gif file (default = &quot;animation.gif&quot;)</p>
</td></tr>
<tr><td><code id="render_gif_+3A_...">...</code></td>
<td>
<p>other options passed to <code><a href="grDevices.html#topic+png">png</a></code></p>
</td></tr>
<tr><td><code id="render_gif_+3A_apf">apf</code></td>
<td>
<p>angle (in radians) per frame</p>
</td></tr>
<tr><td><code id="render_gif_+3A_frames">frames</code></td>
<td>
<p>number of frames in output</p>
</td></tr>
<tr><td><code id="render_gif_+3A_rescale">rescale</code></td>
<td>
<p>default FALSE. If TRUE, rescale all variables to range [0,1]</p>
</td></tr>
<tr><td><code id="render_gif_+3A_sphere">sphere</code></td>
<td>
<p>if true, sphere all variables</p>
</td></tr>
<tr><td><code id="render_gif_+3A_start">start</code></td>
<td>
<p>starting projection.  If <code>NULL</code>, uses path default.</p>
</td></tr>
<tr><td><code id="render_gif_+3A_loop">loop</code></td>
<td>
<p>Logical for gifski to loop or not, default=TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# gifski needs to be installed to render a gif
if (requireNamespace("gifski", quietly = TRUE)) {
  gif_file &lt;- file.path(tempdir(), "test.gif")
  render_gif(flea[, 1:6], grand_tour(), display_xy(), gif_file)
  utils::browseURL(gif_file)
  unlink(gif_file)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='render_proj'>Render plotly animation frame</h2><span id='topic+render_proj'></span>

<h3>Description</h3>

<p>This function takes a projection matrix as produced by
save_history(), and draws it on the projected data
like a biplot. This will product the data objects needed
in order for the user to plot with base or ggplot2.
Note that for now this only works for 2D projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_proj(
  data,
  prj,
  axis_labels = NULL,
  obs_labels = NULL,
  limits = 1,
  position = "center"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_proj_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns,
should be standardised to have mean 0, sd 1</p>
</td></tr>
<tr><td><code id="render_proj_+3A_prj">prj</code></td>
<td>
<p>projection matrix</p>
</td></tr>
<tr><td><code id="render_proj_+3A_axis_labels">axis_labels</code></td>
<td>
<p>of the axes to be displayed</p>
</td></tr>
<tr><td><code id="render_proj_+3A_obs_labels">obs_labels</code></td>
<td>
<p>labels of the observations to be available for interactive mouseover</p>
</td></tr>
<tr><td><code id="render_proj_+3A_limits">limits</code></td>
<td>
<p>value setting the lower and upper limits of
projected data, default 1</p>
</td></tr>
<tr><td><code id="render_proj_+3A_position">position</code></td>
<td>
<p>position of the axes: center (default),
bottomleft or off</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing projected data, circle and segments for axes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(flea)
flea_std &lt;- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))
prj &lt;- basis_random(ncol(flea[,1:6]), 2)
p &lt;- render_proj(flea_std, prj)
if (require("ggplot2")) {
  ggplot() +
    geom_path(data=p$circle, aes(x=c1, y=c2)) +
    geom_segment(data=p$axes, aes(x=x1, y=y1, xend=x2, yend=y2)) +
    geom_text(data=p$axes, aes(x=x2, y=y2, label=rownames(p$axes))) +
    geom_point(data=p$data_prj, aes(x=P1, y=P2)) +
    xlim(-1,1) + ylim(-1, 1) +
    theme_bw() +
    theme(aspect.ratio=1,
       axis.text=element_blank(),
       axis.title=element_blank(),
       axis.ticks=element_blank(),
       panel.grid=element_blank())
}
</code></pre>

<hr>
<h2 id='rescale'>Rescale a matrix or data frame</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Standardise each column to have range [0, 1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_df">df</code></td>
<td>
<p>data frame or matrix</p>
</td></tr>
</table>

<hr>
<h2 id='save_history'>Save tour history.</h2><span id='topic+save_history'></span>

<h3>Description</h3>

<p>Save a tour path so it can later be displayed in many different ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_history(
  data,
  tour_path = grand_tour(),
  max_bases = 100,
  start = NULL,
  rescale = FALSE,
  sphere = FALSE,
  step_size = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_history_+3A_data">data</code></td>
<td>
<p>matrix, or data frame containing numeric columns</p>
</td></tr>
<tr><td><code id="save_history_+3A_tour_path">tour_path</code></td>
<td>
<p>tour path generator</p>
</td></tr>
<tr><td><code id="save_history_+3A_max_bases">max_bases</code></td>
<td>
<p>maximum number of new bases to generate.  Some tour paths
(like the guided tour) may generate less than the maximum.</p>
</td></tr>
<tr><td><code id="save_history_+3A_start">start</code></td>
<td>
<p>starting projection, if you want to specify one</p>
</td></tr>
<tr><td><code id="save_history_+3A_rescale">rescale</code></td>
<td>
<p>Default FALSE. If TRUE, rescale all variables to range [0,1]?</p>
</td></tr>
<tr><td><code id="save_history_+3A_sphere">sphere</code></td>
<td>
<p>if true, sphere all variables</p>
</td></tr>
<tr><td><code id="save_history_+3A_step_size">step_size</code></td>
<td>
<p>distance between each step - defaults to <code>Inf</code> which
forces new basis generation at each step.</p>
</td></tr>
<tr><td><code id="save_history_+3A_...">...</code></td>
<td>
<p>additional arguments passed to tour path</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># You can use a saved history to replay tours with different visualisations

t1 &lt;- save_history(flea[, 1:6], max = 3)
animate_xy(flea[, 1:6], planned_tour(t1))
## andrews_history(t1)
## andrews_history(interpolate(t1))

## t1 &lt;- save_history(flea[, 1:6], grand_tour(4), max = 3)
## animate_pcp(flea[, 1:6], planned_tour(t1))
## animate_scatmat(flea[, 1:6], planned_tour(t1))

## t1 &lt;- save_history(flea[, 1:6], grand_tour(1), max = 3)
## animate_dist(flea[, 1:6], planned_tour(t1))

testdata &lt;- matrix(rnorm(100 * 3), ncol = 3)
testdata[1:50, 1] &lt;- testdata[1:50, 1] + 10
testdata &lt;- sphere_data(testdata)
t2 &lt;- save_history(testdata, guided_tour(holes(), max.tries = 10),
  max = 5
)
animate_xy(testdata, planned_tour(t2))

# Or you can use saved histories to visualise the path that the tour took.
plot(path_index(interpolate(t2), holes()))
</code></pre>

<hr>
<h2 id='search_better'>Search for a better projection near the current projection.</h2><span id='topic+search_better'></span>

<h3>Description</h3>

<p>Search for a better projection near the current projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_better(
  current,
  alpha = 0.5,
  index,
  tries,
  max.tries = Inf,
  ...,
  method = "linear",
  cur_index = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_better_+3A_current">current</code></td>
<td>
<p>starting projection</p>
</td></tr>
<tr><td><code id="search_better_+3A_alpha">alpha</code></td>
<td>
<p>the angle used to search the target basis from the current basis</p>
</td></tr>
<tr><td><code id="search_better_+3A_index">index</code></td>
<td>
<p>index function</p>
</td></tr>
<tr><td><code id="search_better_+3A_tries">tries</code></td>
<td>
<p>the counter of the outer loop of the opotimiser</p>
</td></tr>
<tr><td><code id="search_better_+3A_max.tries">max.tries</code></td>
<td>
<p>maximum number of iteration before giving up</p>
</td></tr>
<tr><td><code id="search_better_+3A_...">...</code></td>
<td>
<p>other arguments being passed into the <code>search_better()</code></p>
</td></tr>
<tr><td><code id="search_better_+3A_method">method</code></td>
<td>
<p>whether the nearby bases are found by a linear/ geodesic formulation</p>
</td></tr>
<tr><td><code id="search_better_+3A_cur_index">cur_index</code></td>
<td>
<p>the index value of the current basis</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:6], guided_tour(holes(), search_f = search_better))
</code></pre>

<hr>
<h2 id='search_better_random'>Search for a better projection using simulated annealing</h2><span id='topic+search_better_random'></span>

<h3>Description</h3>

<p>Given an initial <code class="reqn">t0</code>, the cooling scheme updates temperature at </p>
<p style="text-align: center;"><code class="reqn">T = t0 /\log(i + 1)</code>
</p>

<p>The candidate basis is sampled via </p>
<p style="text-align: center;"><code class="reqn">B_j = (1 - \alpha) * B_i + \alpha * B</code>
</p>
<p> where alpha defines the neighbourhood, <code class="reqn">B_i</code> is the current basis, B is a randomly generated basis
The acceptance probability is calculated as </p>
<p style="text-align: center;"><code class="reqn">prob = \exp{-abs(I(B_i) - I(B_j))/ T}</code>
</p>

<p>For more information, see
<a href="https://projecteuclid.org/download/pdf_1/euclid.ss/1177011077">https://projecteuclid.org/download/pdf_1/euclid.ss/1177011077</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_better_random(
  current,
  alpha = 0.5,
  index,
  tries,
  max.tries = Inf,
  method = "linear",
  cur_index = NA,
  t0 = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_better_random_+3A_current">current</code></td>
<td>
<p>starting projection</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_alpha">alpha</code></td>
<td>
<p>the angle used to search the target basis from the current basis</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_index">index</code></td>
<td>
<p>index function</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_tries">tries</code></td>
<td>
<p>the counter of the outer loop of the opotimiser</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_max.tries">max.tries</code></td>
<td>
<p>maximum number of iteration before giving up</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_method">method</code></td>
<td>
<p>whether the nearby bases are found by a linear/ geodesic formulation</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_cur_index">cur_index</code></td>
<td>
<p>the index value of the current basis</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_t0">t0</code></td>
<td>
<p>initial decrease in temperature</p>
</td></tr>
<tr><td><code id="search_better_random_+3A_...">...</code></td>
<td>
<p>other arguments being passed into the <code>search_better_random()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:6], guided_tour(holes(), search_f = search_better_random))
</code></pre>

<hr>
<h2 id='search_frozen_geodesic'>A pseudo-derivative, line search algorithm along frozen geodesics.</h2><span id='topic+search_frozen_geodesic'></span>

<h3>Description</h3>

<p>A pseudo-derivative, line search algorithm along frozen geodesics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_frozen_geodesic(
  current,
  index,
  tries,
  max.tries = 5,
  n = 5,
  frozen,
  cur_index = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_frozen_geodesic_+3A_current">current</code></td>
<td>
<p>starting projection</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_index">index</code></td>
<td>
<p>index function</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_tries">tries</code></td>
<td>
<p>the counter of the outer loop of the opotimiser</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_max.tries">max.tries</code></td>
<td>
<p>maximum number of iteration before giving up</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_n">n</code></td>
<td>
<p>number of random steps to take to find best direction</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_frozen">frozen</code></td>
<td>
<p>a matrix of frozen variables</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_cur_index">cur_index</code></td>
<td>
<p>the index value of the current basis</p>
</td></tr>
<tr><td><code id="search_frozen_geodesic_+3A_...">...</code></td>
<td>
<p>other arguments being passed into the <code>search_frozen_geodesic()</code>
These three functions perform a corresponding role to
<code><a href="#topic+search_geodesic">search_geodesic</a></code>, <code><a href="#topic+find_best_dir">find_best_dir</a></code> and
<code><a href="#topic+find_path_peak">find_path_peak</a></code> but for the frozen tour.  They work by
zero'ing out the frozen variables and travelling in that restricted
subspace.</p>
</td></tr>
</table>


<h3>To do</h3>

<p>eliminate these functions
</p>

<hr>
<h2 id='search_geodesic'>A pseudo-derivative, line search algorithm.</h2><span id='topic+search_geodesic'></span>

<h3>Description</h3>

<p>This is a novel method for finding more interesting projections for the
guided tour.  It works by first taking a small step in <code>n</code> random
directions, and then picking the direction that looks most promising
(based on the height of the index function), which is effectively a gradient search.
Then it performs a linear search along the geodesic in that direction,
traveling up to half way around the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_geodesic(
  current,
  alpha = 1,
  index,
  tries,
  max.tries = 5,
  ...,
  n = 5,
  delta = 0.01,
  cur_index = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_geodesic_+3A_current">current</code></td>
<td>
<p>starting projection</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_alpha">alpha</code></td>
<td>
<p>maximum distance to travel (currently ignored)</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_index">index</code></td>
<td>
<p>interestingness index function</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_tries">tries</code></td>
<td>
<p>the counter of the outer loop of the opotimiser</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_max.tries">max.tries</code></td>
<td>
<p>maximum number of failed attempts before giving up</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_...">...</code></td>
<td>
<p>other arguments being passed into the <code>search_geodesic()</code></p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_n">n</code></td>
<td>
<p>number of random steps to take to find best direction</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_delta">delta</code></td>
<td>
<p>step size for evaluation of best direction</p>
</td></tr>
<tr><td><code id="search_geodesic_+3A_cur_index">cur_index</code></td>
<td>
<p>index value for starting projection, set NA if it needs to
be calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You should not to have call this function directly, but should supply it
to the <code><a href="#topic+guided_tour">guided_tour</a></code> as a search strategy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>animate_xy(flea[, 1:6], guided_tour(holes(), search_f = search_geodesic))
</code></pre>

<hr>
<h2 id='search_polish'>Search very locally to find slightly better projections to polish a broader search.</h2><span id='topic+search_polish'></span>

<h3>Description</h3>

<p>Search very locally to find slightly better projections to polish a broader search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_polish(
  current,
  alpha = 0.5,
  index,
  tries,
  polish_max_tries = 30,
  cur_index = NA,
  n_sample = 100,
  polish_cooling = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_polish_+3A_current">current</code></td>
<td>
<p>the current projection basis</p>
</td></tr>
<tr><td><code id="search_polish_+3A_alpha">alpha</code></td>
<td>
<p>the angle used to search the target basis from the current basis</p>
</td></tr>
<tr><td><code id="search_polish_+3A_index">index</code></td>
<td>
<p>index function</p>
</td></tr>
<tr><td><code id="search_polish_+3A_tries">tries</code></td>
<td>
<p>the counter of the outer loop of the opotimiser</p>
</td></tr>
<tr><td><code id="search_polish_+3A_polish_max_tries">polish_max_tries</code></td>
<td>
<p>maximum number of iteration before giving up</p>
</td></tr>
<tr><td><code id="search_polish_+3A_cur_index">cur_index</code></td>
<td>
<p>the index value of the current basis</p>
</td></tr>
<tr><td><code id="search_polish_+3A_n_sample">n_sample</code></td>
<td>
<p>number of samples to generate</p>
</td></tr>
<tr><td><code id="search_polish_+3A_polish_cooling">polish_cooling</code></td>
<td>
<p>percentage of reduction in polish_alpha when no better basis is found</p>
</td></tr>
<tr><td><code id="search_polish_+3A_...">...</code></td>
<td>
<p>other arguments being passed into the <code>search_polish()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(t1)
best_proj &lt;- t1[, , dim(t1)[3]]
attr(best_proj, "data") &lt;- NULL
best_proj &lt;- unclass(drop(best_proj))
animate_xy(
  flea[, 1:6],
  guided_tour(holes()),
    search_f = search_polish(
         polish_max_tries = 5),
  start = best_proj
)
</code></pre>

<hr>
<h2 id='search_posse'>Search for a better projection based on Poss, 1995</h2><span id='topic+search_posse'></span>

<h3>Description</h3>

<p>Search for a better projection based on Poss, 1995
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_posse(
  current,
  alpha = 0.5,
  index,
  tries,
  max.tries = 300,
  cur_index = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_posse_+3A_current">current</code></td>
<td>
<p>starting projection</p>
</td></tr>
<tr><td><code id="search_posse_+3A_alpha">alpha</code></td>
<td>
<p>the angle used to search the target basis from the current basis</p>
</td></tr>
<tr><td><code id="search_posse_+3A_index">index</code></td>
<td>
<p>index function</p>
</td></tr>
<tr><td><code id="search_posse_+3A_tries">tries</code></td>
<td>
<p>the counter of the outer loop of the opotimiser</p>
</td></tr>
<tr><td><code id="search_posse_+3A_max.tries">max.tries</code></td>
<td>
<p>maximum number of iteration before giving up</p>
</td></tr>
<tr><td><code id="search_posse_+3A_cur_index">cur_index</code></td>
<td>
<p>the index value of the current basis</p>
</td></tr>
<tr><td><code id="search_posse_+3A_...">...</code></td>
<td>
<p>other arguments being passed into the <code>search_better()</code></p>
</td></tr>
</table>

<hr>
<h2 id='slice_binning'>Separately binning observations inside and outside the slice.</h2><span id='topic+slice_binning'></span>

<h3>Description</h3>

<p>Separately binning observations inside and outside the slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_binning(mat, dists, h, breaks_x, breaks_y, bintype = "square")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_binning_+3A_mat">mat</code></td>
<td>
<p>projected data points</p>
</td></tr>
<tr><td><code id="slice_binning_+3A_dists">dists</code></td>
<td>
<p>vector of all point distances from the projection plane.</p>
</td></tr>
<tr><td><code id="slice_binning_+3A_h">h</code></td>
<td>
<p>slice thickness.</p>
</td></tr>
<tr><td><code id="slice_binning_+3A_breaks_x">breaks_x</code></td>
<td>
<p>binning on the first variable (x or radius).</p>
</td></tr>
<tr><td><code id="slice_binning_+3A_breaks_y">breaks_y</code></td>
<td>
<p>binning on the second variable (y or angle).</p>
</td></tr>
<tr><td><code id="slice_binning_+3A_bintype">bintype</code></td>
<td>
<p>select polar (default) or square binning.</p>
</td></tr>
</table>

<hr>
<h2 id='slice_index'>Section pursuit index.</h2><span id='topic+slice_index'></span>

<h3>Description</h3>

<p>Calculates a section pursuit index that compares the distribution
inside and outside a slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_index(
  breaks_x,
  breaks_y,
  eps,
  bintype = "polar",
  power = 1,
  flip = 1,
  reweight = FALSE,
  p = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_index_+3A_breaks_x">breaks_x</code></td>
<td>
<p>binning on the first variable (x or radius).</p>
</td></tr>
<tr><td><code id="slice_index_+3A_breaks_y">breaks_y</code></td>
<td>
<p>binning on the second variable (y or angle).</p>
</td></tr>
<tr><td><code id="slice_index_+3A_eps">eps</code></td>
<td>
<p>cutoff values to suppress summing up small differences.
Vector with one entry for each bin, can be estimated
using <code><a href="#topic+estimate_eps">estimate_eps</a></code>.</p>
</td></tr>
<tr><td><code id="slice_index_+3A_bintype">bintype</code></td>
<td>
<p>select polar (default) or square binning.</p>
</td></tr>
<tr><td><code id="slice_index_+3A_power">power</code></td>
<td>
<p>exponent q used in the index compuatation.</p>
</td></tr>
<tr><td><code id="slice_index_+3A_flip">flip</code></td>
<td>
<p>sign of the index computation, select +1 when searching
for low densities and -1 when searching for high densities.</p>
</td></tr>
<tr><td><code id="slice_index_+3A_reweight">reweight</code></td>
<td>
<p>if TRUE will reweight according to the expected distribution
in a uniform hypersphere (default is FALSE).</p>
</td></tr>
<tr><td><code id="slice_index_+3A_p">p</code></td>
<td>
<p>number of variables in the data (needed for accurate reweighting,
default is 4).</p>
</td></tr>
</table>

<hr>
<h2 id='sphere_data'>Sphere a matrix (or data frame) by transforming variables to
principal components.</h2><span id='topic+sphere_data'></span>

<h3>Description</h3>

<p>Sphering is often useful in conjunction with the guided tour, as it
removes simpler patterns that may conceal more interesting findings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere_data(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_data_+3A_df">df</code></td>
<td>
<p>data frame or matrix</p>
</td></tr>
</table>

<hr>
<h2 id='splines2d'>Spline based index.</h2><span id='topic+splines2d'></span>

<h3>Description</h3>

<p>Compares the variance in residuals of a fitted
spline model to the overall variance to find
functional dependence in 2D projections
of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splines2d()
</code></pre>

<hr>
<h2 id='step_angle'>Step along an interpolated path by angle in radians.</h2><span id='topic+step_angle'></span>

<h3>Description</h3>

<p>Step along an interpolated path by angle in radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_angle(interp, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_angle_+3A_interp">interp</code></td>
<td>
<p>interpolated path</p>
</td></tr>
<tr><td><code id="step_angle_+3A_angle">angle</code></td>
<td>
<p>angle, in radians</p>
</td></tr>
</table>

<hr>
<h2 id='step_fraction'>Step along an interpolated path by fraction of path length.</h2><span id='topic+step_fraction'></span>

<h3>Description</h3>

<p>Step along an interpolated path by fraction of path length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_fraction(interp, fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_fraction_+3A_interp">interp</code></td>
<td>
<p>interpolated path</p>
</td></tr>
<tr><td><code id="step_fraction_+3A_fraction">fraction</code></td>
<td>
<p>fraction of distance between start and end planes</p>
</td></tr>
</table>

<hr>
<h2 id='t1'>Saved history of guided tour with holes</h2><span id='topic+t1'></span>

<h3>Description</h3>

<p>This data was generated from the following code:
set.seed(2020)
t1 &lt;- save_history(flea[, 1:6], guided_tour(holes()), max = 100)
attr(t1, &quot;class&quot;) &lt;- NULL
And used as an example for search_polish() to start
optimising from the best projection from search_geodesic.
t1 is a 3D array or 2D projections.
</p>

<hr>
<h2 id='to_stop'>Prints information on how to stop the output</h2><span id='topic+to_stop'></span>

<h3>Description</h3>

<p>This function prints the corresponding information on how to stop the plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_stop()
</code></pre>

<hr>
<h2 id='Tropical+20Atmosphere+20Ocean'>Tropical Atmosphere Ocean data</h2><span id='topic+Tropical+20Atmosphere+20Ocean'></span><span id='topic+tao'></span>

<h3>Description</h3>

<p>This is a subset of data taken from the NOAA web site
https://www.pmel.noaa.gov/tao/. The data is generated from recording
instruments on a grid of buoys laid out over the Pacific Ocean.  The grid
was setup to monitor El Nino and La Nina events. This subset contains
measurements from 5 locations (0deg/110W, 2S/110W, 0deg/95W,2S/95W,5S/95W)
and two time points Nov-Jan 1993 (normal), 1997 (El Nino). There are missing
values in this data set, which need to be removed, or imputed before running
a tour.
</p>


<h3>Format</h3>

<p>A 736 x 8 numeric array
</p>


<h3>References</h3>

<p>https://www.pmel.noaa.gov/tao/
</p>

<hr>
<h2 id='weights_bincount_radial'>Computes weights for the rescaling of radial bin counts.</h2><span id='topic+weights_bincount_radial'></span>

<h3>Description</h3>

<p>Computes weights for the rescaling of radial bin counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_bincount_radial(histo, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights_bincount_radial_+3A_histo">histo</code></td>
<td>
<p>input histogram (for bin definitions)</p>
</td></tr>
<tr><td><code id="weights_bincount_radial_+3A_p">p</code></td>
<td>
<p>number of variables</p>
</td></tr>
</table>

<hr>
<h2 id='xnul'>A null function</h2><span id='topic+xnul'></span><span id='topic+nul'></span>

<h3>Description</h3>

<p>This function does nothing, and is a useful default callback function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nul(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xnul_+3A_...">...</code></td>
<td>
<p>all arguments to <code>...</code> are ignore</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
