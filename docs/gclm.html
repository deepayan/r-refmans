<!DOCTYPE html><html><head><title>Help for package gclm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gclm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anti_t'><p>Anti transpose (internal)</p></a></li>
<li><a href='#B0'><p>Generate a naive stable matrix</p></a></li>
<li><a href='#clyap'><p>Solve continuous-time Lyapunov equations</p></a></li>
<li><a href='#gclm'><p>l1 penalized loss estimation for GCLM</p></a></li>
<li><a href='#gclm.lowertri'><p>Recover lower triangular GCLM</p></a></li>
<li><a href='#listInverseBlocks'><p>List all the inverse matrices of the leading sub-matrix of P=Sigma^-1</p>
(INTERNAL)</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Continuous Lyapunov Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of covariance matrices as solutions of 
             continuous time Lyapunov equations. 
             Sparse coefficient matrix and diagonal noise are estimated 
             with a proximal gradient 
             method for an l1-penalized loss minimization problem.
             Varando G, Hansen NR (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2005.10483">doi:10.48550/arXiv.2005.10483</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gherardovarando/gclm">https://github.com/gherardovarando/gclm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gherardovarando/gclm/issues">https://github.com/gherardovarando/gclm/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-25 06:55:33 UTC; gherardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Gherardo Varando <a href="https://orcid.org/0000-0002-6708-1103"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Niels Richard Hansen
    <a href="https://orcid.org/0000-0003-3883-365X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gherardo Varando &lt;gherardo.varando@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-04 08:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='anti_t'>Anti transpose (internal)</h2><span id='topic+anti_t'></span>

<h3>Description</h3>

<p>Anti transpose (internal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anti_t(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anti_t_+3A_m">m</code></td>
<td>
<p>square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the anti transpose of <code>m</code>
</p>

<hr>
<h2 id='B0'>Generate a naive stable matrix</h2><span id='topic+B0'></span>

<h3>Description</h3>

<p>Generate a naive stable matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B0(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B0_+3A_p">p</code></td>
<td>
<p>dimension of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a stable matrix with off-diagonal entries equal to 1 and
diagonal entries equal to <code>-p</code>
</p>

<hr>
<h2 id='clyap'>Solve continuous-time Lyapunov equations</h2><span id='topic+clyap'></span>

<h3>Description</h3>

<p><code>clyap</code> solve the continuous-time Lyapunov equations
</p>
<p style="text-align: center;"><code class="reqn">BX + XB' + C=0</code>
</p>

<p>Using the Bartels-Stewart algorithm with Hessenbergâ€“Schur
decomposition. Optionally the Hessenberg-Schur
decomposition can be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clyap(B, C, Q = NULL, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clyap_+3A_b">B</code></td>
<td>
<p>Square matrix</p>
</td></tr>
<tr><td><code id="clyap_+3A_c">C</code></td>
<td>
<p>Square matrix</p>
</td></tr>
<tr><td><code id="clyap_+3A_q">Q</code></td>
<td>
<p>Square matrix, the orthogonal matrix used
to transform the original equation</p>
</td></tr>
<tr><td><code id="clyap_+3A_all">all</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the matrix <code>Q</code> is set then the matrix <code>B</code>
is assumed to be in upper quasi-triangular form
(Hessenberg-Schur canonical form),
as required by LAPACK subroutine <code>DTRSYL</code> and <code>Q</code> is
the orthogonal matrix associated with the Hessenberg-Schur form
of <code>B</code>.
Usually the matrix <code>Q</code> and the appropriate form of <code>B</code>
are obtained by a first call to <code>clyap(B, C, all = TRUE)</code>
</p>
<p><code>clyap</code> uses lapack subroutines:
</p>

<ul>
<li> <p><code>DGEES</code>
</p>
</li>
<li> <p><code>DTRSYL</code>
</p>
</li>
<li> <p><code>DGEMM</code>
</p>
</li></ul>



<h3>Value</h3>

<p>The solution matrix <code>X</code> if <code>all = FALSE</code>. If
<code>all = TRUE</code> a list with components <code>X</code>, <code>B</code>
and <code>Q</code>. Where <code>B</code> and <code>Q</code> are the
Hessenberg-Schur form of the original matrix <code>B</code>
and the orthogonal matrix that performed the transformation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- matrix(data = rnorm(9), nrow = 3)
## make B negative diagonally dominant, thus stable:
diag(B) &lt;- - 3 * max(B) 
C &lt;- diag(runif(3))
X &lt;- clyap(B, C)
## check X is a solution:
max(abs(B %*% X + X %*% t(B) + C)) 
</code></pre>

<hr>
<h2 id='gclm'>l1 penalized loss estimation for GCLM</h2><span id='topic+gclm'></span><span id='topic+gclm.path'></span>

<h3>Description</h3>

<p>Estimates a sparse continuous time Lyapunov
parametrization of a covariance matrix using a lasso
(L1) penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gclm(
  Sigma,
  B = -0.5 * diag(ncol(Sigma)),
  C = rep(1, ncol(Sigma)),
  C0 = rep(1, ncol(Sigma)),
  loss = "loglik",
  eps = 0.01,
  alpha = 0.5,
  maxIter = 100,
  lambda = 0,
  lambdac = 0,
  job = 0
)

gclm.path(
  Sigma,
  lambdas = NULL,
  B = -0.5 * diag(ncol(Sigma)),
  C = rep(1, ncol(Sigma)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gclm_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="gclm_+3A_b">B</code></td>
<td>
<p>initial B matrix</p>
</td></tr>
<tr><td><code id="gclm_+3A_c">C</code></td>
<td>
<p>diagonal of initial C matrix</p>
</td></tr>
<tr><td><code id="gclm_+3A_c0">C0</code></td>
<td>
<p>diagonal of penalization matrix</p>
</td></tr>
<tr><td><code id="gclm_+3A_loss">loss</code></td>
<td>
<p>one of &quot;loglik&quot; (default) or &quot;frobenius&quot;</p>
</td></tr>
<tr><td><code id="gclm_+3A_eps">eps</code></td>
<td>
<p>convergence threshold</p>
</td></tr>
<tr><td><code id="gclm_+3A_alpha">alpha</code></td>
<td>
<p>parameter line search</p>
</td></tr>
<tr><td><code id="gclm_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="gclm_+3A_lambda">lambda</code></td>
<td>
<p>penalization coefficient for B</p>
</td></tr>
<tr><td><code id="gclm_+3A_lambdac">lambdac</code></td>
<td>
<p>penalization coefficient for C</p>
</td></tr>
<tr><td><code id="gclm_+3A_job">job</code></td>
<td>
<p>integer 0,1,10 or 11</p>
</td></tr>
<tr><td><code id="gclm_+3A_lambdas">lambdas</code></td>
<td>
<p>sequence of lambda</p>
</td></tr>
<tr><td><code id="gclm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>gclm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gclm</code> performs proximal gradient descent for the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">argmin L(\Sigma(B,C)) + \lambda \rho(B) + \lambda_C ||C - C0||_F^2</code>
</p>

<p>subject to <code class="reqn">B</code> stable and <code class="reqn">C</code> diagonal, where <code class="reqn">\rho(B)</code> is the l1 norm
of the off-diagonal element of <code class="reqn">B</code>.
</p>
<p><code>gclm.path</code> simply calls iteratively <code>gclm</code>
with different <code>lambda</code> values. Warm start is used, that
is in the i-th call to <code>gclm</code> the <code>B</code> and <code>C</code>
matrices are initialized as the one obtained in the (i-1)th
call.
</p>


<h3>Value</h3>

<p>for <code>gclm</code>: a list with the result of the optimization
</p>
<p>for <code>gclm.path</code>: a list of the same length of
<code>lambdas</code> with the results of the optimization for
the different <code>lambda</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(50*20),ncol=20)
S &lt;- cov(x)

## l1 penalized log-likelihood
res &lt;- gclm(S, eps = 0, lambda = 0.1, lambdac = 0.01)

## l1 penalized log-likelihood with fixed C
res &lt;- gclm(S, eps = 0, lambda = 0.1, lambdac = -1)

## l1 penalized frobenius loss
res &lt;- gclm(S, eps = 0, lambda = 0.1, loss = "frobenius")
</code></pre>

<hr>
<h2 id='gclm.lowertri'>Recover lower triangular GCLM</h2><span id='topic+gclm.lowertri'></span>

<h3>Description</h3>

<p>Recover the only lower triangular stable matrix B such that
<code>Sigma</code> (<code class="reqn">\Sigma</code>)
is the solution of the associated continuous Lyapunov equation:
</p>
<p style="text-align: center;"><code class="reqn">B\Sigma + \Sigma B' + C = 0</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>gclm.lowertri(Sigma, P = solve(Sigma), C = diag(nrow = nrow(Sigma)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gclm.lowertri_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="gclm.lowertri_+3A_p">P</code></td>
<td>
<p>the inverse of the  covariance matrix</p>
</td></tr>
<tr><td><code id="gclm.lowertri_+3A_c">C</code></td>
<td>
<p>symmetric positive definite matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stable lower triangular matrix
</p>

<hr>
<h2 id='listInverseBlocks'>List all the inverse matrices of the leading sub-matrix of P=Sigma^-1
(INTERNAL)</h2><span id='topic+listInverseBlocks'></span>

<h3>Description</h3>

<p>List all the inverse matrices of the leading sub-matrix of P=Sigma^-1
(INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listInverseBlocks(Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listInverseBlocks_+3A_sigma">Sigma</code></td>
<td>
<p>an invertible  matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the inverse of the leading sub-matrices of Sigma^(-1)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
