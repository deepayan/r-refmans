<!DOCTYPE html><html><head><title>Help for package bigutilsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigutilsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_model_matrix'><p>Transform a data frame</p></a></li>
<li><a href='#bigutilsr-package'><p>bigutilsr: Utility Functions for Large-scale Data</p></a></li>
<li><a href='#covRob'><p>Deprecated</p></a></li>
<li><a href='#covrob_ogk'><p>Robust Location and Scatter Estimation - Ortogonalized Gnanadesikan-Kettenring (OGK)</p></a></li>
<li><a href='#geometric_median'><p>Geometric median</p></a></li>
<li><a href='#hist_out'><p>Outlier detection (histogram)</p></a></li>
<li><a href='#knn_parallel'><p>Find K nearest neighbours for multiple query points</p></a></li>
<li><a href='#LOF'><p>Local Outlier Factor (LOF)</p></a></li>
<li><a href='#maha_trans'><p>Transform matrix</p></a></li>
<li><a href='#nclass.scottRob'><p>Compute the Number of Classes for a Histogram</p></a></li>
<li><a href='#pca_nspike'><p>Number of spikes in PCA</p></a></li>
<li><a href='#pca_OADP_proj'><p>OADP projection</p></a></li>
<li><a href='#predict.Procrustes'><p>Predict method</p></a></li>
<li><a href='#prob_dist'><p>Probabilistic set distance</p></a></li>
<li><a href='#procrustes'><p>Procrustes transform</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rollmean'><p>Gaussian smoothing</p></a></li>
<li><a href='#tukey_mc_up'><p>Outlier detection threshold (upper)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utility Functions for Large-scale Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility functions for large-scale data. For now, package 'bigutilsr'
    mainly includes functions for outlier detection and unbiased PCA projection.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/privefl/bigutilsr">https://github.com/privefl/bigutilsr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/privefl/bigutilsr/issues">https://github.com/privefl/bigutilsr/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>bigassertr (&ge; 0.1.1), bigparallelr (&ge; 0.2.3), nabor, Rcpp,
robustbase, RSpectra, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, Gmedian, mvtnorm, rrcov, spelling, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-08 11:17:27 UTC; au639593</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Privé [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Privé &lt;florian.prive.21@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-13 22:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_model_matrix'>Transform a data frame</h2><span id='topic+as_model_matrix'></span>

<h3>Description</h3>

<p>Transform a data frame into a matrix using one hot encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_model_matrix(df, intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_model_matrix_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="as_model_matrix_+3A_intercept">intercept</code></td>
<td>
<p>Whether to have a column with all <code>1</code>s. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- as_model_matrix(iris)
str(mat)
</code></pre>

<hr>
<h2 id='bigutilsr-package'>bigutilsr: Utility Functions for Large-scale Data</h2><span id='topic+bigutilsr'></span><span id='topic+bigutilsr-package'></span>

<h3>Description</h3>

<p>Utility functions for large-scale data. For now, package 'bigutilsr'
mainly includes functions for outlier detection and unbiased PCA projection.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Privé <a href="mailto:florian.prive.21@gmail.com">florian.prive.21@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/privefl/bigutilsr">https://github.com/privefl/bigutilsr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/privefl/bigutilsr/issues">https://github.com/privefl/bigutilsr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='covRob'>Deprecated</h2><span id='topic+covRob'></span>

<h3>Description</h3>

<p>Deprecated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covRob(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRob_+3A_data">data</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="covRob_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+covrob_ogk">covrob_ogk()</a></code> <code><a href="#topic+dist_ogk">dist_ogk()</a></code>
</p>

<hr>
<h2 id='covrob_ogk'>Robust Location and Scatter Estimation - Ortogonalized Gnanadesikan-Kettenring (OGK)</h2><span id='topic+covrob_ogk'></span><span id='topic+dist_ogk'></span>

<h3>Description</h3>

<p>Computes a robust multivariate location and scatter estimate with a high
breakdown point, using the pairwise algorithm proposed by Marona and
Zamar (2002) which in turn is based on the pairwise robust estimator
proposed by Gnanadesikan-Kettenring (1972).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covrob_ogk(U, niter = 2, beta = 0.9)

dist_ogk(U, niter = 2, beta = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covrob_ogk_+3A_u">U</code></td>
<td>
<p>A matrix with no missing values and at least 2 columns.</p>
</td></tr>
<tr><td><code id="covrob_ogk_+3A_niter">niter</code></td>
<td>
<p>Number of number of iterations for the first step of the algorithm,
usually 1 or 2 since iterations beyond the second do not lead to improvement.</p>
</td></tr>
<tr><td><code id="covrob_ogk_+3A_beta">beta</code></td>
<td>
<p>Coverage parameter for the final reweighted estimate.
Default is <code>0.9</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method proposed by Marona and Zamar (2002) allowes to obtain
positive-definite and almost affine equivariant robust scatter matrices
starting from any pairwise robust scatter matrix. The default robust estimate
of covariance between two random vectors used is the one proposed by
Gnanadesikan and Kettenring (1972) but the user can choose any other method by
redefining the function in slot <code>vrob</code> of the control object
<code>CovControlOgk</code>. Similarly, the function for computing the robust
univariate location and dispersion used is the <code>tau scale</code> defined
in Yohai and Zamar (1998) but it can be redefined in the control object.
</p>
<p>The estimates obtained by the OGK method, similarly as in <code>CovMcd</code> are returned
as 'raw' estimates. To improve the estimates a reweighting step is performed using
the coverage parameter <code>beta</code> and these reweighted estimates are returned as
'final' estimates.
</p>


<h3>Value</h3>

<p><code>covrob_ogk()</code>: list of robust estimates, <code style="white-space: pre;">&#8288;$cov&#8288;</code> and <code style="white-space: pre;">&#8288;$center&#8288;</code>.
</p>
<p><code>dist_ogk()</code>: vector of robust Mahalanobis (squared) distances.
</p>


<h3>References</h3>

<p>Maronna, R.A. and Zamar, R.H. (2002)
Robust estimates of location and dispersion of high-dimensional datasets;
<em>Technometrics</em> <b>44</b>(4), 307&ndash;317.
</p>
<p>Yohai, R.A. and Zamar, R.H. (1998)
High breakdown point estimates of regression by means of the minimization of efficient scale
<em>JASA</em> <b>86</b>, 403&ndash;413.
</p>
<p>Gnanadesikan, R. and John R. Kettenring (1972)
Robust estimates, residuals, and outlier detection with multiresponse data.
<em>Biometrics</em> <b>28</b>, 81&ndash;124.
</p>
<p>Todorov V &amp; Filzmoser P (2009),
An Object Oriented Framework for Robust Multivariate Analysis.
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
URL <a href="https://www.jstatsoft.org/v32/i03/">https://www.jstatsoft.org/v32/i03/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="rrcov.html#topic+CovOgk">rrcov::CovOgk()</a></code>
</p>
<p><code><a href="stats.html#topic+mahalanobis">stats::mahalanobis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- readRDS(system.file("testdata", "three-pops.rds", package = "bigutilsr"))
svd &lt;- svds(scale(X), k = 5)

U &lt;- svd$u
dist &lt;- dist_ogk(U)
str(dist)
</code></pre>

<hr>
<h2 id='geometric_median'>Geometric median</h2><span id='topic+geometric_median'></span>

<h3>Description</h3>

<p>Compute the geometric median, i.e. the point that minimizes the sum of all
Euclidean distances to the observations (rows of <code>U</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometric_median(U, tol = 1e-10, maxiter = 1000, by_grp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometric_median_+3A_u">U</code></td>
<td>
<p>A matrix (e.g. PC scores).</p>
</td></tr>
<tr><td><code id="geometric_median_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion. Default is <code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="geometric_median_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="geometric_median_+3A_by_grp">by_grp</code></td>
<td>
<p>Possibly a vector for splitting rows of <code>U</code> into groups before
computing the geometric mean for each group. Default is <code>NULL</code> (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The geometric median of all rows of <code>U</code>, a vector of the same size
as <code>ncol(U)</code>. If providing <code>by_grp</code>, then a matrix with rows being the
geometric median within each group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- readRDS(system.file("testdata", "three-pops.rds", package = "bigutilsr"))
pop &lt;- rep(1:3, c(143, 167, 207))

svd &lt;- svds(scale(X), k = 5)
U &lt;- sweep(svd$u, 2, svd$d, '*')
plot(U, col = pop, pch = 20)

med_all &lt;- geometric_median(U)
points(t(med_all), pch = 20, col = "blue", cex = 4)

med_pop &lt;- geometric_median(U, by_grp = pop)
points(med_pop, pch = 20, col = "blue", cex = 2)

</code></pre>

<hr>
<h2 id='hist_out'>Outlier detection (histogram)</h2><span id='topic+hist_out'></span>

<h3>Description</h3>

<p>Outlier detection based on departure from histogram.
Suitable for compact values (need a space between main values and outliers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_out(x, breaks = nclass.scottRob, pmax_out = 0.2, nboot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_out_+3A_x">x</code></td>
<td>
<p>Numeric vector (with compact values).</p>
</td></tr>
<tr><td><code id="hist_out_+3A_breaks">breaks</code></td>
<td>
<p>Same parameter as for <code>hist()</code>. Default uses a robust version
of Scott's rule. You can also use <code>"FD"</code> or <code>nclass.FD</code> for a bit more bins.</p>
</td></tr>
<tr><td><code id="hist_out_+3A_pmax_out">pmax_out</code></td>
<td>
<p>Percentage at each side that can be considered outliers at
each step. Default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="hist_out_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replicates to estimate limits more robustly.
Default is <code>NULL</code> (no bootstrap, even if <strong>I would recommend to use it</strong>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>

<ul>
<li> <p><code>x</code>: the initial vector, whose outliers have been removed,
</p>
</li>
<li> <p><code>lim</code>: lower and upper limits for outlier removal,
</p>
</li>
<li> <p><code>all_lim</code>: all bootstrap replicates for <code>lim</code> (if <code>nboot</code> not <code>NULL</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rnorm(1000)
str(hist_out(x))

# Easy to separate
x2 &lt;- c(x, rnorm(50, mean = 7))
hist(x2, breaks = nclass.scottRob)
str(hist_out(x2))

# More difficult to separate
x3 &lt;- c(x, rnorm(50, mean = 6))
hist(x3, breaks = nclass.scottRob)
str(hist_out(x3))
str(hist_out(x3, nboot = 999))

</code></pre>

<hr>
<h2 id='knn_parallel'>Find K nearest neighbours for multiple query points</h2><span id='topic+knn_parallel'></span>

<h3>Description</h3>

<p>Find K nearest neighbours for multiple query points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_parallel(data, query = data, k, ..., ncores = bigparallelr::nb_cores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_parallel_+3A_data">data</code></td>
<td>
<p>Mxd matrix of M target points with dimension d</p>
</td></tr>
<tr><td><code id="knn_parallel_+3A_query">query</code></td>
<td>
<p>Nxd matrix of N query points with dimension d (nb <code>data</code> 
and <code>query</code> must have same dimension). If missing defaults to 
<code>data</code> i.e. a self-query.</p>
</td></tr>
<tr><td><code id="knn_parallel_+3A_k">k</code></td>
<td>
<p>an integer number of nearest neighbours to find</p>
</td></tr>
<tr><td><code id="knn_parallel_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="nabor.html#topic+knn">nabor::knn</a></code>
</p>

<dl>
<dt><code>eps</code></dt><dd><p>An approximate error bound. The default of 0 implies exact 
matching.</p>
</dd>
<dt><code>searchtype</code></dt><dd><p>A character vector or integer indicating the search type. 
The default value of <code>1L</code> is equivalent to &quot;auto&quot;. See details.</p>
</dd>
<dt><code>radius</code></dt><dd><p>Maximum radius search bound. The default of 0 implies no radius
bound.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="knn_parallel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default uses <code><a href="bigparallelr.html#topic+nb_cores">bigparallelr::nb_cores()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>nn.idx</code> (1-indexed indices) and 
<code>nn.dists</code> (distances), both of which are N x k matrices. See details
for the results obtained with1 invalid inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: knn_parallel(matrix(1:4, 2), k = 2, ncores = 2)

</code></pre>

<hr>
<h2 id='LOF'>Local Outlier Factor (LOF)</h2><span id='topic+LOF'></span>

<h3>Description</h3>

<p>LOF: Identifying Density-Based Local Outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOF(
  U,
  seq_k = c(4, 10, 30),
  combine = max,
  robMaha = FALSE,
  log = TRUE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOF_+3A_u">U</code></td>
<td>
<p>A matrix, from which to detect outliers (rows). E.g. PC scores.</p>
</td></tr>
<tr><td><code id="LOF_+3A_seq_k">seq_k</code></td>
<td>
<p>Sequence of numbers of nearest neighbors to use.
If multiple <code>k</code> are provided, this returns the combination of statistics.
Default is <code>c(4, 10, 30)</code> and use <code>max</code> to combine (see <code>combine</code>).</p>
</td></tr>
<tr><td><code id="LOF_+3A_combine">combine</code></td>
<td>
<p>How to combine results for multiple <code>k</code>? Default uses <code>max</code>.</p>
</td></tr>
<tr><td><code id="LOF_+3A_robmaha">robMaha</code></td>
<td>
<p>Whether to use a robust Mahalanobis distance instead of the
normal euclidean distance? Default is <code>FALSE</code>, meaning using euclidean.</p>
</td></tr>
<tr><td><code id="LOF_+3A_log">log</code></td>
<td>
<p>Whether to return the logarithm of LOFs? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LOF_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Breunig, Markus M., et al. &quot;LOF: identifying density-based local outliers.&quot;
ACM sigmod record. Vol. 29. No. 2. ACM, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob_dist">prob_dist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- readRDS(system.file("testdata", "three-pops.rds", package = "bigutilsr"))
svd &lt;- svds(scale(X), k = 10)

llof &lt;- LOF(svd$u)
hist(llof, breaks = nclass.scottRob)
tukey_mc_up(llof)

llof_maha &lt;- LOF(svd$u, robMaha = TRUE)
hist(llof_maha, breaks = nclass.scottRob)
tukey_mc_up(llof_maha)

lof &lt;- LOF(svd$u, log = FALSE)
hist(lof, breaks = nclass.scottRob)
str(hist_out(lof))
str(hist_out(lof, nboot = 100))
str(hist_out(lof, nboot = 100, breaks = "FD"))

</code></pre>

<hr>
<h2 id='maha_trans'>Transform matrix</h2><span id='topic+maha_trans'></span>

<h3>Description</h3>

<p>Transform matrix to use Mahalanobis distance instead of Euclidean one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maha_trans(U, estim = covrob_ogk(U))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maha_trans_+3A_u">U</code></td>
<td>
<p>A matrix (e.g. PC scores).</p>
</td></tr>
<tr><td><code id="maha_trans_+3A_estim">estim</code></td>
<td>
<p>List of location and scatter estimates, <code style="white-space: pre;">&#8288;$cov&#8288;</code> and <code style="white-space: pre;">&#8288;$center&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>U</code>, transformed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- readRDS(system.file("testdata", "three-pops.rds", package = "bigutilsr"))
svd &lt;- svds(scale(X), k = 5)

U &lt;- svd$u
dist1 &lt;- dist_ogk(U)

U.maha &lt;- maha_trans(U)
dist2 &lt;- rowSums(U.maha^2)
all.equal(dist2, dist1)

</code></pre>

<hr>
<h2 id='nclass.scottRob'>Compute the Number of Classes for a Histogram</h2><span id='topic+nclass.scottRob'></span>

<h3>Description</h3>

<p>Compute the Number of Classes for a Histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nclass.scottRob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nclass.scottRob_+3A_x">x</code></td>
<td>
<p>a data vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The suggested number of classes.
</p>


<h3>References</h3>

<p>Scott, D. W. (1979). On optimal and data-based histograms.
Biometrika, 66, 605–610. doi: 10.2307/2335182.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
hist(x, breaks = nclass.scott)
hist(x, breaks = nclass.scottRob)

x2 &lt;- c(x, rnorm(50, mean = 50))
hist(x2, breaks = nclass.scott)
hist(x2, breaks = nclass.scott,    xlim = c(-5, 5))
hist(x2, breaks = nclass.scottRob, xlim = c(-5, 5))

</code></pre>

<hr>
<h2 id='pca_nspike'>Number of spikes in PCA</h2><span id='topic+pca_nspike'></span>

<h3>Description</h3>

<p>Estimate the number of distant spikes based on the histogram of eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_nspike(eigval, breaks = "FD", nboot = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_nspike_+3A_eigval">eigval</code></td>
<td>
<p>Eigenvalues (squared singular values).</p>
</td></tr>
<tr><td><code id="pca_nspike_+3A_breaks">breaks</code></td>
<td>
<p>Same parameter as for <code>hist()</code>. Default uses a robust version
of Scott's rule. You can also use <code>"FD"</code> or <code>nclass.FD</code> for a bit more bins.</p>
</td></tr>
<tr><td><code id="pca_nspike_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replicates to estimate limits more robustly.
Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated number of distant spikes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 400; M &lt;- 2000; K &lt;- 8
U &lt;- matrix(0, N, K); U[] &lt;- rnorm(length(U))
V &lt;- matrix(0, M, K); V[] &lt;- rnorm(length(V))
# X = U V^T + E
X &lt;- tcrossprod(U, V) + 15 * rnorm(N * M)
pca &lt;- prcomp(X)
eigval &lt;- pca$sdev^2
plot(head(eigval, -1), log = "xy", pch = 20)
pca_nspike(eigval)

</code></pre>

<hr>
<h2 id='pca_OADP_proj'>OADP projection</h2><span id='topic+pca_OADP_proj'></span><span id='topic+pca_OADP_proj2'></span>

<h3>Description</h3>

<p>Online Augmentation, Decomposition, and Procrustes (OADP) projection of
PC loadings onto some study data <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_OADP_proj(X, loadings, sval)

pca_OADP_proj2(XV, X_norm, sval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_OADP_proj_+3A_x">X</code></td>
<td>
<p>Data to get PC loadings into.</p>
</td></tr>
<tr><td><code id="pca_OADP_proj_+3A_loadings">loadings</code></td>
<td>
<p>PC loadings of the reference PCA to project.</p>
</td></tr>
<tr><td><code id="pca_OADP_proj_+3A_sval">sval</code></td>
<td>
<p>Singular values of the reference PCA (sqrt of the eigen values).
Only the <code>ncol(loadings)</code> first ones will be used.</p>
</td></tr>
<tr><td><code id="pca_OADP_proj_+3A_xv">XV</code></td>
<td>
<p><code>X %*% loadings</code></p>
</td></tr>
<tr><td><code id="pca_OADP_proj_+3A_x_norm">X_norm</code></td>
<td>
<p>Vector of sums of squared rows (e.g. <code>rowSums(X^2)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pca_OADP_proj()</code>: A list with the simple projection <code>X %*% loadings</code>
and the projection based on OADP.
</p>
</li></ul>


<ul>
<li> <p><code>pca_OADP_proj2()</code>: The projection based on OADP only
(a matrix of same size of <code>XV</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- readRDS(system.file("testdata", "three-pops.rds", package = "bigutilsr"))
N &lt;- 400; M &lt;- ncol(X)
ind &lt;- sample(nrow(X), N)

# Compute SVD using one part of samples
svd &lt;- svds(X[ind, ], k = 5)
U &lt;- sweep(svd$u, 2, svd$d, '*')
col &lt;- 2:3
plot(U[, col])
points(cbind(0, 0), pch = 8, col = "green", cex = 2)

# Projecting other samples
proj &lt;- pca_OADP_proj(X = X[-ind, ], loadings = svd$v, sval = svd$d)
points(proj$simple_proj[, col], col = "red", pch = 20)     # shrunk towards 0
points(proj$OADP_proj[, col], col = "blue", pch = 20)      # unshrunk

</code></pre>

<hr>
<h2 id='predict.Procrustes'>Predict method</h2><span id='topic+predict.Procrustes'></span>

<h3>Description</h3>

<p>Predict method for class <code>Procrustes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Procrustes'
predict(object, X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.Procrustes_+3A_object">object</code></td>
<td>
<p>Object of class <code>Procrustes</code>.</p>
</td></tr>
<tr><td><code id="predict.Procrustes_+3A_x">X</code></td>
<td>
<p>New matrix to transform.</p>
</td></tr>
<tr><td><code id="predict.Procrustes_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>X</code>, transformed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procrustes">procrustes()</a></code>.
</p>

<hr>
<h2 id='prob_dist'>Probabilistic set distance</h2><span id='topic+prob_dist'></span>

<h3>Description</h3>

<p>Probabilistic set distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_dist(U, kNN = 5, robMaha = FALSE, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_dist_+3A_u">U</code></td>
<td>
<p>A matrix, from which to detect outliers (rows). E.g. PC scores.</p>
</td></tr>
<tr><td><code id="prob_dist_+3A_knn">kNN</code></td>
<td>
<p>Number of nearest neighbors to use. Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="prob_dist_+3A_robmaha">robMaha</code></td>
<td>
<p>Whether to use a robust Mahalanobis distance instead of the
normal euclidean distance? Default is <code>FALSE</code>, meaning using euclidean.</p>
</td></tr>
<tr><td><code id="prob_dist_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kriegel, Hans-Peter, et al. &quot;LoOP: local outlier probabilities.&quot; Proceedings
of the 18th ACM conference on Information and knowledge management. ACM, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOF">LOF()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- readRDS(system.file("testdata", "three-pops.rds", package = "bigutilsr"))
svd &lt;- svds(scale(X), k = 10)
U &lt;- svd$u

test &lt;- prob_dist(U)
plof &lt;- test$dist.self / test$dist.nn
plof_ish &lt;- test$dist.self / sqrt(test$dist.nn)
plot(U[, 1:2], col = (plof_ish &gt; tukey_mc_up(plof_ish)) + 1, pch = 20)
plot(U[, 3:4], col = (plof_ish &gt; tukey_mc_up(plof_ish)) + 1, pch = 20)
plot(U[, 5:6], col = (plof_ish &gt; tukey_mc_up(plof_ish)) + 1, pch = 20)

</code></pre>

<hr>
<h2 id='procrustes'>Procrustes transform</h2><span id='topic+procrustes'></span>

<h3>Description</h3>

<p>Procrustes transform Y = pXR (after centering), where p is a scaling
coefficient and R is a rotation matrix that minimize ||Y - pXR||_F.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrustes(Y, X, n_iter_max = 1000, epsilon_min = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procrustes_+3A_y">Y</code></td>
<td>
<p>Reference matrix.</p>
</td></tr>
<tr><td><code id="procrustes_+3A_x">X</code></td>
<td>
<p>Matrix to transform (<code>ncol(X) &gt;= ncol(Y)</code>).</p>
</td></tr>
<tr><td><code id="procrustes_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>Maximum number of iterations. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="procrustes_+3A_epsilon_min">epsilon_min</code></td>
<td>
<p>Convergence criterion. Default is <code>1e-7</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;procrustes&quot;, a list with the following elements:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$R&#8288;</code>: the rotation matrix to apply to <code>X</code>,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$rho&#8288;</code>: the scaling coefficient to apply to <code>X</code>,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$c&#8288;</code>: the column centering to apply to the resulting matrix,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$diff&#8288;</code>: the average difference between <code>Y</code> and <code>X</code> transformed.
</p>
</li></ul>

<p>You can use method <code>predict()</code> to apply this transformation to other data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(200), ncol = 20)
B &lt;- matrix(rnorm(length(A)), nrow = nrow(A))

proc &lt;- procrustes(B, A)
str(proc)
plot(B, predict(proc, A)); abline(0, 1, col = "red")

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+svds'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>RSpectra</dt><dd><p><code><a href="RSpectra.html#topic+svds">svds</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rollmean'>Gaussian smoothing</h2><span id='topic+rollmean'></span>

<h3>Description</h3>

<p>Gaussian smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmean(x, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmean_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="rollmean_+3A_size">size</code></td>
<td>
<p>Radius of the smoothing (smaller than half of the length of <code>x</code>).
If using <code>size = 0</code>, it returns <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>, smoothed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- rnorm(10))
rollmean(x, 3)
</code></pre>

<hr>
<h2 id='tukey_mc_up'>Outlier detection threshold (upper)</h2><span id='topic+tukey_mc_up'></span>

<h3>Description</h3>

<p>Outlier detection threshold (upper) based on Tukey's rule, corrected for
skewness using the 'medcouple', and possibly corrected for multiple testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukey_mc_up(x, coef = NULL, alpha = 0.05, a = -4, b = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukey_mc_up_+3A_x">x</code></td>
<td>
<p>Numeric vector. Should be somewhat normally distributed.</p>
</td></tr>
<tr><td><code id="tukey_mc_up_+3A_coef">coef</code></td>
<td>
<p>number determining how far 'whiskers' extend out from the box.
If <code>NULL</code> (default), this is computed to get an type-I error of <code>alpha</code>,
after adjusting for multiple testing. A standard value to use is <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="tukey_mc_up_+3A_alpha">alpha</code></td>
<td>
<p>See <code>coef</code>. Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="tukey_mc_up_+3A_a">a</code></td>
<td>
<p>scaling factors multiplied by the medcouple
<code><a href="robustbase.html#topic+mc">mc</a>()</code> to determine outlyer boundaries; see the references.</p>
</td></tr>
<tr><td><code id="tukey_mc_up_+3A_b">b</code></td>
<td>
<p>scaling factors multiplied by the medcouple
<code><a href="robustbase.html#topic+mc">mc</a>()</code> to determine outlyer boundaries; see the references.</p>
</td></tr>
</table>


<h3>References</h3>





<p>Hubert, M. and Vandervieren, E. (2008).
An adjusted boxplot for skewed distributions,
<em>Computational Statistics and Data Analysis</em> <b>52</b>, 5186&ndash;5201.
</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+adjbox">robustbase::adjbox()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(x &lt;- c(rnorm(3, m = 6), rnorm(1e4, m = 0)))
(q &lt;- tukey_mc_up(x))
abline(v = q, col = "red")
which(x &gt; q)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
