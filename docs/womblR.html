<!DOCTYPE html><html><head><title>Help for package womblR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {womblR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diagnostics'><p>diagnostics</p></a></li>
<li><a href='#GarwayHeath'><p>Garway-Heath angles for the HFA-II</p></a></li>
<li><a href='#HFAII_Queen'><p>HFAII Queen Adjacency Matrix</p></a></li>
<li><a href='#HFAII_QueenHF'><p>HFAII Queen Hemisphere Adjacency Matrix</p></a></li>
<li><a href='#HFAII_Rook'><p>HFAII Rook Adjacency Matrix</p></a></li>
<li><a href='#is.PosteriorAdj'><p>is.PosteriorAdj</p></a></li>
<li><a href='#is.STBDwDM'><p>is.STBDwDM</p></a></li>
<li><a href='#PlotAdjacency'><p>PlotAdjacency</p></a></li>
<li><a href='#PlotSensitivity'><p>PlotSensitivity</p></a></li>
<li><a href='#PlotVfTimeSeries'><p>PlotVfTimeSeries</p></a></li>
<li><a href='#PosteriorAdj'><p>PosteriorAdj</p></a></li>
<li><a href='#predict.STBDwDM'><p>predict.STBDwDM</p></a></li>
<li><a href='#STBDwDM'><p>MCMC sampler for spatiotemporal boundary detection with dissimilarity metric.</p></a></li>
<li><a href='#VFSeries'><p>Visual field series for one patient.</p></a></li>
<li><a href='#womblR'><p>womblR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatiotemporal Boundary Detection Model for Areal Unit Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a spatiotemporal boundary detection model with a dissimilarity
    metric for areal data with inference in a Bayesian setting using Markov chain
    Monte Carlo (MCMC). The response variable can be modeled as Gaussian (no nugget),
    probit or Tobit link and spatial correlation is introduced at each time point
    through a conditional autoregressive (CAR) prior. Temporal correlation is introduced
    through a hierarchical structure and can be specified as exponential or first-order
    autoregressive. Full details of the package can be found in the accompanying vignette.
    Furthermore, the details of the package can be found in "Diagnosing Glaucoma 
    Progression with Visual Field Data Using a Spatiotemporal Boundary Detection Method", 
    by Berchuck et al (2018), &lt;<a href="https://arxiv.org/abs/1805.11636">arXiv:1805.11636</a>&gt;. The paper is in press at the Journal of 
    the American Statistical Association.</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-04</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, msm (&ge; 1.0.0), mvtnorm (&ge; 1.0-0), Rcpp
(&ge; 0.12.9), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, classInt, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.7.500.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-05 00:34:59 UTC; sib2</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel I. Berchuck
    <a href="https://orcid.org/0000-0001-5705-3144"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel I. Berchuck &lt;sib2@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-05 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='diagnostics'>diagnostics</h2><span id='topic+diagnostics'></span>

<h3>Description</h3>

<p>Calculates diagnostic metrics using output from the <code><a href="#topic+STBDwDM">STBDwDM</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostics(
  obj,
  diags = c("dic", "dinf", "waic"),
  keepDeviance = FALSE,
  keepPPD = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+STBDwDM">STBDwDM</a></code> model object for which diagnostics
are desired from.</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_diags">diags</code></td>
<td>
<p>A vector of character strings indicating the diagnostics to compute.
Options include: Deviance Information Criterion (&quot;dic&quot;), d-infinity (&quot;dinf&quot;) and
Watanabe-Akaike information criterion (&quot;waic&quot;). At least one option must be included.
Note: The probit model cannot compute the DIC or WAIC diagnostics due to computational
issues with computing the multivariate normal CDF.</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_keepdeviance">keepDeviance</code></td>
<td>
<p>A logical indicating whether the posterior deviance distribution
is returned (default = FALSE).</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_keepppd">keepPPD</code></td>
<td>
<p>A logical indicating whether the posterior predictive distribution
at each observed location is returned (default = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To assess model fit, DIC, d-infinity and WAIC are used. DIC is based on the
deviance statistic and penalizes for the complexity of a model with an effective
number of parameters estimate pD (Spiegelhalter et al 2002). The d-infinity posterior
predictive measure is an alternative diagnostic tool to DIC, where d-infinity=P+G.
The G term decreases as goodness of fit increases, and P, the penalty term, inflates
as the model becomes over-fit, so small values of both of these terms and, thus, small
values of d-infinity are desirable (Gelfand and Ghosh 1998). WAIC is invariant to
parametrization and is asymptotically equal to Bayesian cross-validation
(Watanabe 2010). WAIC = -2 * (lppd - p_waic_2). Where lppd is the log pointwise
predictive density and p_waic_2 is the estimated effective number of parameters
based on the variance estimator from Vehtari et al. 2016. (p_waic_1 is the mean
estimator).
</p>


<h3>Value</h3>

<p><code>diagnostics</code> returns a list containing the diagnostics requested and
possibly the deviance and/or posterior predictive distribution objects.
</p>


<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>


<h3>References</h3>

<p>Gelfand, A. E., &amp; Ghosh, S. K. (1998). Model choice: a minimum posterior predictive loss approach. Biometrika, 1-11.
</p>
<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P., &amp; Van Der Linde, A. (2002). Bayesian measures of model complexity and fit. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 64(4), 583-639.
</p>
<p>Vehtari, A., Gelman, A., &amp; Gabry, J. (2016). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing, 1-20.
</p>
<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely applicable information criterion in singular learning theory. Journal of Machine Learning Research, 11(Dec), 3571-3594.
</p>

<hr>
<h2 id='GarwayHeath'>Garway-Heath angles for the HFA-II</h2><span id='topic+GarwayHeath'></span>

<h3>Description</h3>

<p>These Garway-Heath angles are used as the dissimilarity metric when implementing the boundary
detection model for a longitudinal series of visual fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GarwayHeath)
</code></pre>


<h3>Format</h3>

<p>A vector with length 54, where each entry represents the angle (in degrees) that the
underlying retinal nerve fiber enters the optic nerve head. The measure ranges from 0-360,
where 0  is designated at the 9-o’clock position (right eye) and angles are counted counter
clockwise. These angles are estimates for the Humphrey Field Analyzer-II (Carl Zeiss Meditec
Inc., Dublin, CA). The 26th and 35th entries are missing as they correspond to a natural
blind spot.
</p>


<h3>References</h3>

<p>Garway-Heath, et al. (2000). Ophthalmology 107:10:1809–1815.
(<a href="https://pubmed.ncbi.nlm.nih.gov/11013178/">PubMed</a>)
</p>

<hr>
<h2 id='HFAII_Queen'>HFAII Queen Adjacency Matrix</h2><span id='topic+HFAII_Queen'></span>

<h3>Description</h3>

<p>Binary adjacency matrix for the Humphrey Field Analyzer-II (Carl Zeiss Meditec Inc., Dublin, CA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HFAII_Queen)
</code></pre>


<h3>Format</h3>

<p>This adjacency matrix is formated using queen neighbor criteria, meaning two locations on
the visual field are only considered neighbors if they share an edge or corner. The adjacency matrix is a
54 x 54 dimensional binary object with zeros on the diagonal and the column and row sums are equal
to the number of neighbors.
</p>

<hr>
<h2 id='HFAII_QueenHF'>HFAII Queen Hemisphere Adjacency Matrix</h2><span id='topic+HFAII_QueenHF'></span>

<h3>Description</h3>

<p>Binary adjacency matrix for the Humphrey Field Analyzer-II (Carl Zeiss Meditec Inc., Dublin, CA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HFAII_QueenHF)
</code></pre>


<h3>Format</h3>

<p>This adjacency matrix is formated using queen neighbor criteria, meaning two locations on
the visual field are only considered neighbors if they share an edge or corner. An additional criterion
is included that locations are not considered neighbors if they fall within different hemispheres on the
visual field. The adjacency matrix is a 54 x 54 dimensional binary object with zeros on the diagonal and
the column and row sums are equal to the number of neighbors.
</p>

<hr>
<h2 id='HFAII_Rook'>HFAII Rook Adjacency Matrix</h2><span id='topic+HFAII_Rook'></span>

<h3>Description</h3>

<p>Binary adjacency matrix for the Humphrey Field Analyzer-II (Carl Zeiss Meditec Inc., Dublin, CA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HFAII_Rook)
</code></pre>


<h3>Format</h3>

<p>This adjacency matrix is formated using rook neighbor criteria, meaning two locations on
the visual field are only considered neighbors if they share an edge. The adjacency matrix is a
54 x 54 dimensional binary object with zeros on the diagonal and the column and row sums are equal
to the number of neighbors.
</p>

<hr>
<h2 id='is.PosteriorAdj'>is.PosteriorAdj</h2><span id='topic+is.PosteriorAdj'></span>

<h3>Description</h3>

<p><code>is.PosteriorAdj</code> is a general test of an object being interpretable as a
<code><a href="#topic+PosteriorAdj">PosteriorAdj</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.PosteriorAdj(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.PosteriorAdj_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+PosteriorAdj">PosteriorAdj</a></code> class is defined as the posterior adjacency
object that results from the <code><a href="#topic+PosteriorAdj">PosteriorAdj</a></code> function.
</p>

<hr>
<h2 id='is.STBDwDM'>is.STBDwDM</h2><span id='topic+is.STBDwDM'></span>

<h3>Description</h3>

<p><code>is.STBDwDM</code> is a general test of an object being interpretable as a
<code><a href="#topic+STBDwDM">STBDwDM</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.STBDwDM(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.STBDwDM_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+STBDwDM">STBDwDM</a></code> class is defined as the regression object that
results from the <code><a href="#topic+STBDwDM">STBDwDM</a></code> regression function.
</p>

<hr>
<h2 id='PlotAdjacency'>PlotAdjacency</h2><span id='topic+PlotAdjacency'></span>

<h3>Description</h3>

<p>Plots a heat map of the differential light sensitivity on the Humphrey Field
Analyzer-II visual field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotAdjacency(
  Wij,
  Visit = 1,
  stat = "mean",
  main = "Estimated Adjacencies",
  color.scheme = c("Black", "White"),
  edgewidth = 2,
  cornerwidth = 1/4,
  lwd.border = 3,
  color.bs = "gray",
  zlim = c(0, 1),
  legend = TRUE,
  DM = NULL,
  W = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotAdjacency_+3A_wij">Wij</code></td>
<td>
<p>a <code><a href="#topic+PosteriorAdj">PosteriorAdj</a></code> object.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_visit">Visit</code></td>
<td>
<p>either an integer <code>(1,...,Nu)</code> indicating the visit number for which
you want to get the adjacencies to plot or NA. If NA, then the plot will produce the
dissimilarity metric at each adjacency.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_stat">stat</code></td>
<td>
<p>either &quot;mean&quot; or &quot;sd&quot; (only used for Visit != NA).</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_color.scheme">color.scheme</code></td>
<td>
<p>a vector of colors to be used to show the adjacencies changing.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_edgewidth">edgewidth</code></td>
<td>
<p>a scalar indicating the width of the edges.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_cornerwidth">cornerwidth</code></td>
<td>
<p>a scalar indicating the width of the corners.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_lwd.border">lwd.border</code></td>
<td>
<p>a scalar indicating width of the visual field border.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_color.bs">color.bs</code></td>
<td>
<p>one color specifying the blind spot.</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_zlim">zlim</code></td>
<td>
<p>the limits used for the legend (default are c(0,1)).</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_legend">legend</code></td>
<td>
<p>logical, indicating whether the legend should be present (default = TRUE).</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_dm">DM</code></td>
<td>
<p>a dissimilarity metric to be plotted at each location on the visual field (default = NULL).</p>
</td></tr>
<tr><td><code id="PlotAdjacency_+3A_w">W</code></td>
<td>
<p>an adjacency matrix that specifies the visual field, required if Wij is not provided (default = NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PlotAdjacency</code> is used in the application of glaucoma progression to
plot the posterior mean and standard deviation neighborhood adjacencies across the
visual field.
</p>


<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Define blind spot locations on the HFA-II
blind_spot &lt;- c(26, 35)

###Load visual field adjacency matrix
W &lt;- HFAII_Queen[ -blind_spot, -blind_spot]

###Load Garway-Heath angles for dissimiliarity metric
DM &lt;- GarwayHeath[-blind_spot] #Uses Garway-Heath angles object "GarwayHeath"

###Adjacency plots
PlotAdjacency(W = W, DM = DM, zlim = c(0, 180), Visit = NA,
              main = "Garway-Heath dissimilarity metric\n across the visual field")

</code></pre>

<hr>
<h2 id='PlotSensitivity'>PlotSensitivity</h2><span id='topic+PlotSensitivity'></span>

<h3>Description</h3>

<p>Plots a heat map of the differential light sensitivity on the Humphrey Field
Analyzer-II visual field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSensitivity(
  Y = Y,
  main = "Sensitivity Estimate (dB) at each \nlocation on visual field",
  legend.lab = "DLS (dB)",
  zlim = c(10, 35),
  bins = 200,
  border = TRUE,
  legend = TRUE,
  color = c("yellow", "orange", "red"),
  col.bs = "grey",
  legend.round = 0,
  legend.vals = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSensitivity_+3A_y">Y</code></td>
<td>
<p>variable to be plotted on the visual field (e.g. differential light sensitivity).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_legend.lab">legend.lab</code></td>
<td>
<p>a label for the legend (default = &quot;DLS (dB)&quot;).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_zlim">zlim</code></td>
<td>
<p>the limits used for the legend (default are the minimum and maximum of Y).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_bins">bins</code></td>
<td>
<p>the number of bins used to refine the color palette for the figure and legend.</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_border">border</code></td>
<td>
<p>logical, indicating whether there should be a border around the visual field (default = TRUE).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_legend">legend</code></td>
<td>
<p>logical, indicating whether the legend should be present (default = TRUE).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_color">color</code></td>
<td>
<p>a vector of character strings representing the color palette.</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_col.bs">col.bs</code></td>
<td>
<p>color of the blind spot locations (default = &quot;grey&quot;).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_legend.round">legend.round</code></td>
<td>
<p>integer, indicating the digits that the legend labels are rounded to
(default = 0).</p>
</td></tr>
<tr><td><code id="PlotSensitivity_+3A_legend.vals">legend.vals</code></td>
<td>
<p>integer, indicating the number of labels values to be included on the legend (default = 5).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PlotSensitivity</code> is used in the application of glaucoma progression to
plot a variable across the visual field in the form of a heat map.
</p>


<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VFSeries)
PlotSensitivity(Y = VFSeries$DLS[VFSeries$Visit == 1],
                  main = "Sensitivity estimate (dB) at each \n location on visual field",
                  legend.lab = "DLS (dB)",
                  zlim = c(10, 35),
                  bins = 250)
</code></pre>

<hr>
<h2 id='PlotVfTimeSeries'>PlotVfTimeSeries</h2><span id='topic+PlotVfTimeSeries'></span>

<h3>Description</h3>

<p>Plots a time series at each location of the Humphrey Field Analyzer-II visual field .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotVfTimeSeries(
  Y,
  Location,
  Time,
  main = "Visual field sensitivity time series \n at each location",
  xlab = "Time from first visit (days)",
  ylab = "Sensitivity (dB)",
  line.col = "red",
  line.reg = TRUE,
  line.type = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotVfTimeSeries_+3A_y">Y</code></td>
<td>
<p>a time series variable to be plotted.</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_location">Location</code></td>
<td>
<p>a variable corresponding to the location on the visual field
that the time series variable was observed.</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_time">Time</code></td>
<td>
<p>a variable corresponding to the time that the time series variable
was observed.</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis.</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis.</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_line.col">line.col</code></td>
<td>
<p>color for the regression line, either character string corresponding
to a color or a integer (default = &quot;red&quot;).</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_line.reg">line.reg</code></td>
<td>
<p>logical, determines if there are regression lines printed (default = TRUE).</p>
</td></tr>
<tr><td><code id="PlotVfTimeSeries_+3A_line.type">line.type</code></td>
<td>
<p>integer, specifies the type of regression line printed (default = 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PlotVfTimeSeries</code> is used in the application of glaucoma progression.
In each cell is the observed DLS at each location over visits, with the red line
representing a linear regression trend.
</p>


<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VFSeries)
PlotVfTimeSeries(Y = VFSeries$DLS,
                  Location = VFSeries$Location,
                  Time = VFSeries$Time,
                  main = "Visual field sensitivity time series \n at each location",
                  xlab = "Days from baseline visit",
                  ylab = "Differential light sensitivity (dB)")


</code></pre>

<hr>
<h2 id='PosteriorAdj'>PosteriorAdj</h2><span id='topic+PosteriorAdj'></span>

<h3>Description</h3>

<p>Calculates the posterior mean and standard deviation for the neighborhood adjacencies
from the <code><a href="#topic+STBDwDM">STBDwDM</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PosteriorAdj(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PosteriorAdj_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+STBDwDM">STBDwDM</a></code> model object for which predictions
are desired from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PosteriorAdj</code> calculates the posterior mean and standard
deviation of the neighborhood adjacencies for each pairwise location. The neighborhood
structure used to do this comes from Berchuck et al. 2017.
</p>


<h3>Value</h3>

<p><code>PosteriorAdj</code> returns a matrix containing the following columns.
</p>

<dl>
<dt><code>i</code></dt><dd><p>Location <code>i</code> (i.e. which row/column on the adjacency matrix W).</p>
</dd>
<dt><code>j</code></dt><dd><p>Location <code>j</code> (i.e. which row/column on the adjacency matrix W).</p>
</dd>
<dt><code>DM</code></dt><dd><p>The dissimilarity metric between locations <code>i</code> and <code>j</code>.</p>
</dd>
<dt><code>meant</code></dt><dd><p>The posterior mean of the neighborhood adjacency between location
<code>i</code> and <code>j</code> at time <code>t, t = 1, ... , Nu</code>.</p>
</dd>
<dt><code>sdt</code></dt><dd><p>The posterior mean of the neighborhood adjacency between location
<code>i</code> and <code>j</code> at time <code>t, t = 1, ... , Nu</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>

<hr>
<h2 id='predict.STBDwDM'>predict.STBDwDM</h2><span id='topic+predict.STBDwDM'></span>

<h3>Description</h3>

<p>Predicts future observations from the <code><a href="#topic+STBDwDM">STBDwDM</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STBDwDM'
predict(object, NewTimes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.STBDwDM_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+STBDwDM">STBDwDM</a></code> model object for which predictions
are desired from.</p>
</td></tr>
<tr><td><code id="predict.STBDwDM_+3A_newtimes">NewTimes</code></td>
<td>
<p>a numeric vector including desired time(s) points for prediction.</p>
</td></tr>
<tr><td><code id="predict.STBDwDM_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.STBDwDM</code> uses Bayesian krigging to predict vectors at future
time points. The function returns the krigged observed outcomes along with the
observational level parameters (<code>mu</code>, <code>tau</code>, and <code>alpha</code>).
</p>


<h3>Value</h3>

<p><code>predict.STBDwDM</code> returns a list containing the following objects.
</p>

<dl>
<dt><code>MuTauAlpha</code></dt><dd><p>A <code>list</code> containing three matrices, <code>mu</code>,
<code>tau</code> and <code>alpha</code>. Each matrix is dimension <code>NKeep x s</code>, where
<code>s</code> is the number of new time points. Each matrix contains posterior
samples obtained by Bayesian krigging.</p>
</dd>
<dt><code>Y</code></dt><dd><p>A <code>list</code> containing <code>s</code> posterior predictive distribution
matrices. Each matrix is dimension <code>NKeep x s</code>, where <code>s</code>
is the number of new time points. Each matrix is obtained through Bayesian krigging.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>

<hr>
<h2 id='STBDwDM'>MCMC sampler for spatiotemporal boundary detection with dissimilarity metric.</h2><span id='topic+STBDwDM'></span>

<h3>Description</h3>

<p><code>STBDwDM</code> is a Markov chain Monte Carlo (MCMC) sampler for a spatiotemporal
boundary detection model using the Bayesian hierarchical framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STBDwDM(
  Y,
  DM,
  W,
  Time,
  Starting = NULL,
  Hypers = NULL,
  Tuning = NULL,
  MCMC = NULL,
  Family = "tobit",
  TemporalStructure = "exponential",
  Distance = "circumference",
  Weights = "continuous",
  Rho = 0.99,
  ScaleY = 10,
  ScaleDM = 100,
  Seed = 54
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STBDwDM_+3A_y">Y</code></td>
<td>
<p>An <code>N</code> dimensional vector containing the observed outcome data.
Here, <code>N = M * Nu</code>, where <code>M</code> represents the number of spatial locations
and <code>Nu</code> the number of temporal visits. The observations in <code>Y</code> must be first
ordered spatially and then temporally, meaning the first <code>M</code> observations
in <code>Y</code> should come from the initial time point.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_dm">DM</code></td>
<td>
<p>An <code>M</code> dimensional vector containing a dissimilarity metric
for each spatial location. The order of the spatial locations must match the order from
<code>Y</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_w">W</code></td>
<td>
<p>An <code>M x M</code> dimensional binary adjacency matrix for dictating the
spatial neigborhood structure.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_time">Time</code></td>
<td>
<p>A <code>Nu</code> dimensional vector containing the observed time points for each
vector of outcomes in increasing order.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_starting">Starting</code></td>
<td>
<p>Either <code>NULL</code> or a <code>list</code> containing starting values
to be specified for the MCMC sampler. If <code>NULL</code> is not chosen then none, some or all
of the starting values may be specified.
</p>
<p>When <code>NULL</code> is chosen then default starting values are automatically generated.
Otherwise a <code>list</code> must be provided with names <code>Delta</code>, <code>T</code> or
<code>Phi</code> containing appropriate objects. <code>Delta</code> must be a <code>3</code> dimensional
vector, <code>T</code> a <code>3 x 3</code> dimensional matrix and <code>Phi</code> a scalar.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_hypers">Hypers</code></td>
<td>
<p>Either <code>NULL</code> or a <code>list</code> containing hyperparameter values
to be specified for the MCMC sampler. If <code>NULL</code> is not chosen then none, some or all
of the hyperparameter values may be specified.
</p>
<p>When <code>NULL</code> is chosen then default hyperparameter values are automatically
generated. These default hyperparameters are described in detail in (Berchuck et al.).
Otherwise a <code>list</code> must be provided with names <code>Delta</code>, <code>T</code> or
<code>Phi</code> containing further hyperparameter information. These objects are themselves
<code>lists</code> and may be constructed as follows.
</p>
<p><code>Delta</code> is a <code>list</code> with two objects, <code>MuDelta</code> and <code>OmegaDelta</code>.
<code>MuDelta</code> represents the mean component of the multivariate normal hyperprior and
must be a <code>3</code> dimensional vector, while <code>OmegaDelta</code> represents the covariance
and must be a <code>3 x 3</code> dimensional matrix.
</p>
<p><code>T</code> is a <code>list</code> with two objects, <code>Xi</code> and <code>Psi</code>. <code>Xi</code>
represents the degrees of freedom parameter for the inverse-Wishart hyperprior and
must be a real number scalar, while <code>Psi</code> represents the scale matrix
and must be a <code>3 x 3</code> dimensional positive definite matrix.
</p>
<p><code>Phi</code> is a <code>list</code> with two objects, <code>APhi</code> and <code>BPhi</code>. <code>APhi</code>
represents the lower bound for the uniform hyperprior, while <code>BPhi</code> represents
the upper bound. The bounds must be specified carefully. For example, if the exponential
temporal correlation structure is chosen both bounds must be restricted to be non-negative.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_tuning">Tuning</code></td>
<td>
<p>Either <code>NULL</code> or a <code>list</code> containing tuning values
to be specified for the MCMC Metropolis steps. If <code>NULL</code> is not chosen then all
of the tuning values must be specified.
</p>
<p>When <code>NULL</code> is chosen then default tuning values are automatically generated to
<code>1</code>. Otherwise a <code>list</code> must be provided with names <code>Theta2</code>,
<code>Theta3</code> and <code>Phi</code>. <code>Theta2</code> and <code>Theta3</code> must be
<code>Nu</code> dimensional vectors and <code>Phi</code> a scalar. Each containing tuning variances
for their corresponding Metropolis updates.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_mcmc">MCMC</code></td>
<td>
<p>Either <code>NULL</code> or a <code>list</code> containing input values to be used
for implementing the MCMC sampler. If <code>NULL</code> is not chosen then all
of the MCMC input values must be specified.
</p>
<p><code>NBurn</code>: The number of sampler scans included in the burn-in phase. (default =
<code>10,000</code>)
</p>
<p><code>NSims</code>: The number of post-burn-in scans for which to perform the
sampler. (default = <code>100,000</code>)
</p>
<p><code>NThin</code>: Value such that during the post-burn-in phase, only every
<code>NThin</code>-th scan is recorded for use in posterior inference (For return values
we define, NKeep = NSims / NThin (default = <code>10</code>).
</p>
<p><code>NPilot</code>: The number of times during the burn-in phase that pilot adaptation
is performed (default = <code>20</code>)</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_family">Family</code></td>
<td>
<p>Character string indicating the distribution of the observed data. Options
include: <code>"normal"</code>, <code>"probit"</code>, <code>"tobit"</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_temporalstructure">TemporalStructure</code></td>
<td>
<p>Character string indicating the temporal structure of the
time observations. Options include: <code>"exponential"</code> and <code>"ar1"</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_distance">Distance</code></td>
<td>
<p>Character string indicating the distance metric for computing the
dissimilarity metric. Options include: <code>"euclidean"</code> and <code>"circumference"</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_weights">Weights</code></td>
<td>
<p>Character string indicating the type of weight used. Options include:
<code>"continuous"</code> and <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_rho">Rho</code></td>
<td>
<p>A scalar in <code>(0,1)</code> that dictates the magnitude of local spatial sharing.
By default it is fixed at <code>0.99</code> as suggested by Lee and Mitchell (2012).</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_scaley">ScaleY</code></td>
<td>
<p>A positive scalar used for scaling the observed data, <code>Y</code>. This is
used to aid numerically for MCMC convergence, as scaling large observations often
stabilizes chains. By default it is fixed at <code>10</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_scaledm">ScaleDM</code></td>
<td>
<p>A positive scalar used for scaling the dissimilarity metric distances,
<code>DM</code>. This is used to aid numerically for MCMC convergence. as scaling spatial
distances is often used for improved MCMC convergence. By default it is fixed at <code>100</code>.</p>
</td></tr>
<tr><td><code id="STBDwDM_+3A_seed">Seed</code></td>
<td>
<p>An integer value used to set the seed for the random number generator
(default = 54).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the underlying statistical model can be found in the article by
Berchuck et al. (2018), &quot;Diagnosing Glaucoma Progression with Visual Field Data Using
a Spatiotemporal Boundary Detection Method&quot;, &lt;arXiv:1805.11636&gt;.
</p>


<h3>Value</h3>

<p><code>STBDwDM</code> returns a list containing the following objects
</p>

<dl>
<dt><code>mu</code></dt><dd><p><code>NKeep x Nu</code> <code>matrix</code> of posterior samples for <code>mu</code>. The
t-th column contains posterior samples from the the t-th time point.</p>
</dd>
<dt><code>tau2</code></dt><dd><p><code>NKeep x Nu</code> <code>matrix</code> of posterior samples for <code>tau2</code>.
The t-th column contains posterior samples from the the t-th time point.</p>
</dd>
<dt><code>alpha</code></dt><dd><p><code>NKeep x Nu</code> <code>matrix</code> of posterior samples for <code>alpha</code>.
The t-th column contains posterior samples from the the t-th time point.</p>
</dd>
<dt><code>delta</code></dt><dd><p><code>NKeep x 3</code> <code>matrix</code> of posterior samples for <code>delta</code>.
The columns have names that describe the samples within them.</p>
</dd>
<dt><code>T</code></dt><dd><p><code>NKeep x 6</code> <code>matrix</code> of posterior samples for <code>T</code>. The
columns have names that describe the samples within them. The row is listed first, e.g.,
<code>t32</code> refers to the entry in row <code>3</code>, column <code>2</code>.</p>
</dd>
<dt><code>phi</code></dt><dd><p><code>NKeep x 1</code> <code>matrix</code> of posterior samples for <code>phi</code>.</p>
</dd>
<dt><code>metropolis</code></dt><dd><p><code>(2 * Nu + 1) x 2</code> <code>matrix</code> of metropolis
acceptance rates and tuners that result from the pilot adaptation. The first <code>Nu</code>
correspond to the <code>Theta2</code> (i.e. <code>tau2</code>) parameters, the next <code>Nu</code> correspond to
the <code>Theta3</code> (i.e. <code>alpha</code>) parameters and the last row give the <code>phi</code> values.</p>
</dd>
<dt><code>runtime</code></dt><dd><p>A <code>character</code> string giving the runtime of the MCMC sampler.</p>
</dd>
<dt><code>datobj</code></dt><dd><p>A <code>list</code> of data objects that are used in future <code>STBDwDM</code> functions
and should be ignored by the user.</p>
</dd>
<dt><code>dataug</code></dt><dd><p>A <code>list</code> of data augmentation objects that are used in future
<code>STBDwDM</code> functions and should be ignored by the user.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Samuel I. Berchuck
</p>


<h3>References</h3>

<p>Berchuck et al. (2018), &quot;Diagnosing Glaucoma Progression with Visual Field Data Using
a Spatiotemporal Boundary Detection Method&quot;, &lt;arXiv:1805.11636&gt;.
</p>

<hr>
<h2 id='VFSeries'>Visual field series for one patient.</h2><span id='topic+VFSeries'></span>

<h3>Description</h3>

<p>A dataset containing 9 visual field series from a patient of the Vein Pulsation Study
Trial in Glaucoma and the Lions Eye Institute trial registry, Perth, Western Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VFSeries)
</code></pre>


<h3>Format</h3>

<p>A data frame with 486 rows and 4 variables:
</p>

<dl>
<dt>Visit</dt><dd><p>The visual field test visit number, (1, 2, ... , 9).</p>
</dd>
<dt>DLS</dt><dd><p>The observed outcome variable, differential light sensitivity (DLS).</p>
</dd>
<dt>Time</dt><dd><p>The time of the visual field test (in days from baseline).</p>
</dd>
<dt>Location</dt><dd><p>The location on the visual field of a Humphrey Field Analyzer-II
(Carl Zeiss Meditec Inc., Dublin, CA) (1, 2, ... , 54).</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://anzctr.org.au/Trial/Registration/TrialReview.aspx?ACTRN=12608000274370">https://anzctr.org.au/Trial/Registration/TrialReview.aspx?ACTRN=12608000274370</a>
</p>

<hr>
<h2 id='womblR'>womblR</h2><span id='topic+womblR'></span>

<h3>Description</h3>

<p>This package implements a spatiotemporal boundary detection
with a dissimilarity metric for areal data with inference in a Bayesian setting
using Markov chain Monte Carlo (MCMC). The response variable can be modeled as
Gaussian (no nugget), probit or Tobit link and spatial correlation is introduced
at each time point through a conditional autoregressive (CAR) prior. Temporal
correlation is introduced through a hierarchical structure and can be specified as
exponential or first-order autoregressive. Full details of the the package can be found
in the accompanying vignette. Furthermore, the details of the package can be found in
&quot;Diagnosing Glaucoma Progression with Visual Field Data Using a Spatiotemporal Boundary
Detection Method&quot;, by Berchuck et al (2018), &lt;arXiv:1805.11636&gt;. The paper is in press
at the Journal of the American Statistical Association.
</p>


<h3>Author(s)</h3>

<p>Samuel I. Berchuck <a href="mailto:sib2@duke.edu">sib2@duke.edu</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
