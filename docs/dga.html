<!DOCTYPE html><html><head><title>Help for package dga</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dga}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dga-package'><p>Capture-Recapture Estimation using Bayesian Model Averaging</p></a></li>
<li><a href='#bma.cr'><p>Bayesiam Model Averaging for Capture-Recapture</p></a></li>
<li><a href='#cfunction'><p>A Helper Function for make.strata</p></a></li>
<li><a href='#check.strata'><p>Checks Each Stratum for Suitability for Capture-Recapture</p></a></li>
<li><a href='#circle'><p>A Helper Function Used in venn3</p></a></li>
<li><a href='#circle.ind'><p>A Helper Function for venn3</p></a></li>
<li><a href='#CompLogML'><p>Computes Marginal Likelihoods for Each Clique and Value of Nmissing</p></a></li>
<li><a href='#ellipse'><p>A Helper Function Used by Venn4 to Define the Perimeter of an Ellipse</p></a></li>
<li><a href='#ellipse.ind'><p>A Helper Function Used by Venn4</p></a></li>
<li><a href='#graphs3'><p>All Decomposable Graphical Models on Three Lists</p></a></li>
<li><a href='#graphs4'><p>All Decomposable Graphical Models on Four Lists</p></a></li>
<li><a href='#graphs5'><p>All Decomposable Graphical Models on Five Lists</p></a></li>
<li><a href='#integer.base.b'><p>Base Converter</p></a></li>
<li><a href='#make.strata'><p>Transforms Records to List Intersection Counts by Stratum</p></a></li>
<li><a href='#MakeCompMatrix'><p>Component-wise Matrix of Log Marginal Likelihoods</p></a></li>
<li><a href='#plotPosteriorN'><p>Plots Posterior Distribution of Nmissing</p></a></li>
<li><a href='#remove.close'><p>A Helper Function to Tell Which Points Are Near the Boundary of a Circle</p></a></li>
<li><a href='#remove.close.ellipse'><p>A Helper Function to Tell Which Points are Near the Boundary of the Ellipse</p></a></li>
<li><a href='#sfunction'><p>A Helper Function for make.strata.</p></a></li>
<li><a href='#venn3'><p>Three List Venn Diagram</p></a></li>
<li><a href='#venn4'><p>Four List Venn Diagram</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Capture-Recapture Estimation using Bayesian Model Averaging</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs Bayesian model averaging for capture-recapture. This includes code to stratify records, check the strata for suitable overlap to be used for capture-recapture, and some functions to plot the estimated population size. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>chron, Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-04 20:21:44 UTC; ob37</td>
</tr>
<tr>
<td>Author:</td>
<td>James Johndrow [aut],
  Kristian Lum [aut],
  Patrick Ball [aut],
  Olivier Binette [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olivier Binette &lt;olivier.binette@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-10 16:22:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='dga-package'>Capture-Recapture Estimation using Bayesian Model Averaging</h2><span id='topic+dga-package'></span><span id='topic+_PACKAGE'></span><span id='topic+dga'></span>

<h3>Description</h3>

<p>Performs Bayesian model averaging over all decomposable graphical models,
each representing a different list dependence structure, with the goal of
estimating the number of uncounted elements from the universe of elements
that could have been recorded or &ldquo;captured&quot;.  The code here is an
implementation of the model described in Madigan and York (1997).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> dga</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.2</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2015-04-16</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL &gt;=2 </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>James Johndrow <a href="mailto:james.johndrow@gmail.com">james.johndrow@gmail.com</a>, Kristian Lum
<a href="mailto:kl@hrdag.org">kl@hrdag.org</a>, and Patrick Ball <a href="mailto:pball@hrdag.org">pball@hrdag.org</a>
</p>
<p>Maintainer: Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>References</h3>

<p>Madigan, David, and Jeremy C. York. &quot;Bayesian methods for
estimation of the size of a closed population.&quot;  Biometrika 84.1 (1997):
19-31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### This simulated example goes through the whole process for 3 lists.###
library(chron)
# Simulate some data
N &lt;- 1000 # true population size
num.lists &lt;- 3 # number of lists

# simulate 3 lists independently 'capturing'
l1 &lt;- rbinom(N, 1, .2)
l2 &lt;- rbinom(N, 1, .25)
l3 &lt;- rbinom(N, 1, .3)

overlaps &lt;- data.frame(l1, l2, l3)

# simulate dates of recording
dates &lt;- paste(
  rep(2015, N), "-", sample(1:4, N, replace = TRUE), "-",
  sample(1:28, N, replace = TRUE)
)
dates &lt;- chron(dates, format = c(dates = "y-m-d"))

# save true number in each stratum for comparison later
truth &lt;- table((months(dates)))[1:4]

# remove dates of unrecorded elements
dates &lt;- dates[apply(overlaps, 1, sum) &gt; 0]

# remove individuals not recorded on any list
overlaps &lt;- overlaps[apply(overlaps, 1, sum) &gt; 0, ]

# stratify by date
strata &lt;- make.strata(overlaps, dates = dates, date.defs = "monthly")

# check to make sure that all strata are OK
check &lt;- check.strata(strata)

# look at strata, just to make sure
par(mfrow = c(2, 2), mar = rep(1, 4))
for (i in 1:nrow(strata$overlap.counts)) {
  venn3(strata$overlap.counts[i, ],
    main = rownames(strata$overlap.counts)[i],
    cex.main = 1
  )
}


# load the graphs to make the estimates
data(graphs3)

# select expansion factor defining the largest number of unrecorded elements.
# this makes Nmissing &lt;- 0:(sum(Y)*fac)
fac &lt;- 5

# set prior
delta &lt;- 1 / 2^num.lists

# loop over strata to calculate posterior distributions of
# the total population size for each stratum
par(mfrow = c(2, 2), mar = rep(1.75, 4))
# if using Rstudio, make sure your plot window is pretty big here!
for (i in 1:nrow(strata$overlap.counts)) {
  Nmissing &lt;- 0:(sum(strata$overlap.counts[i, ]) * fac)
  Y &lt;- array(strata$overlap.counts[i, ], dim = rep(2, num.lists))
  weights &lt;- bma.cr(Y, Nmissing, delta, graphs3)
  plotPosteriorN(weights, Nmissing + sum(strata$overlap.counts[i, ]),
    main = rownames(strata$overlap.counts)[i]
  )
  points(truth[i], .5 * max(weights), col = "red", pch = 16, cex = 2)
}
</code></pre>

<hr>
<h2 id='bma.cr'>Bayesiam Model Averaging for Capture-Recapture</h2><span id='topic+bma.cr'></span>

<h3>Description</h3>

<p>This function averages over all decomposable graphical models for p lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bma.cr(
  Y,
  Nmissing,
  delta,
  graphs,
  logprior = NULL,
  log.prior.model.weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bma.cr_+3A_y">Y</code></td>
<td>
<p>a <code>2^p</code> array of list intersection counts. See details.</p>
</td></tr>
<tr><td><code id="bma.cr_+3A_nmissing">Nmissing</code></td>
<td>
<p>A vector of all possible values for the number of
individuals that appear on no list.</p>
</td></tr>
<tr><td><code id="bma.cr_+3A_delta">delta</code></td>
<td>
<p>The hyper-parameter for the hyper-Dirichlet prior distribution
on list intersection probabilities. A smaller value indicates fewer prior
observations per cell. A suggested default is <code>2^-p</code></p>
</td></tr>
<tr><td><code id="bma.cr_+3A_graphs">graphs</code></td>
<td>
<p>A pre-computed list of all decomposable graphical models for
<code>p</code> lists. These should be loaded using data(graphsp); see example.
Currently, this package includes a list of graphs for three, four, or five
lists.</p>
</td></tr>
<tr><td><code id="bma.cr_+3A_logprior">logprior</code></td>
<td>
<p>The log of the prior probability of each value in Nmissing.
If left blank, this will default to the -log(Nmissing).</p>
</td></tr>
<tr><td><code id="bma.cr_+3A_log.prior.model.weights">log.prior.model.weights</code></td>
<td>
<p>Prior weights on the graphs. This should be a
vector of length length(graphs).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function in this package.  It performs capture-recapture
(or multiple systems estimation) using Bayesian model averaging as outlined
in Madigan and York (1997).
</p>
<p>Y can be created by the array() command from a vector that is ordered
lexigraphically by the cell names, e.g., c(x000, x001, x010, x011, x100,
x101, x110, x111).
</p>


<h3>Value</h3>

<p>This function returns a matrix of weights, where rows correspond to
models and columns correspond to values of Nmissing. Thus, the <code>ij</code>th
entry of the matrix is the posterior probability of the <code>i</code>th model and
the <code>j</code>th entry of Nmissing. Row sums return posterior probabilities by
model.Column sums return posterior probabilities by value of Nmissing.
</p>


<h3>Note</h3>

<p>This function is pretty robust relative to the more common log-linear
model approach to capture-recapture. It will not fail (or issue a numerical
warning) even if there are no overlaps among the lists. The user should take
care that there is adequate list overlap and that there are sufficient cases
in the stratum.
</p>


<h3>Author(s)</h3>

<p>James Johndrow <a href="mailto:james.johndrow@gmail.com">james.johndrow@gmail.com</a> and Kristian Lum
(kl@hrdag.org)
</p>


<h3>References</h3>

<p>Madigan, David, and Jeremy C. York. &quot;Bayesian methods for
estimation of the size of a closed population.&quot;  Biometrika 84.1 (1997):
19-31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### 5 list example from M &amp; Y ##########
delta &lt;- .5
Y &lt;- c(0, 27, 37, 19, 4, 4, 1, 1, 97, 22, 37, 25, 2, 1, 3, 5,
       83, 36, 34, 18, 3, 5, 0, 2, 30, 5, 23, 8, 0, 3, 0, 2)
Y &lt;- array(Y, dim = c(2, 2, 2, 2, 2))
Nmissing &lt;- 1:300
N &lt;- Nmissing + sum(Y)
data(graphs5)
weights &lt;- bma.cr(Y, Nmissing, delta, graphs5)
plotPosteriorN(weights, N)

##### 3 list example from M &amp; Y #######
Y &lt;- c(0, 60, 49, 4, 247, 112, 142, 12)
Y &lt;- array(Y, dim = c(2, 2, 2))

delta &lt;- 1
a &lt;- 13.14
b &lt;- 55.17


Nmissing &lt;- 1:300
N &lt;- Nmissing + sum(Y)

logprior &lt;- N * log(b) - (N + a) * log(1 + b) + lgamma(N + a) - lgamma(N + 1) - lgamma(a)

data(graphs3)
weights &lt;- bma.cr(Y, Nmissing, delta, graphs3, logprior)
plotPosteriorN(weights, N)
</code></pre>

<hr>
<h2 id='cfunction'>A Helper Function for make.strata</h2><span id='topic+cfunction'></span>

<h3>Description</h3>

<p>A helper function used in make.strata to make list overlap counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfunction(x, nlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfunction_+3A_x">x</code></td>
<td>
<p>capture histories, transformed from binary to decimal</p>
</td></tr>
<tr><td><code id="cfunction_+3A_nlist">nlist</code></td>
<td>
<p>the number of lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table of the number of records with each capture history
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## The function is currently defined as
cfunction &lt;- function(x, nlist) {
  out &lt;- table(c(x, 0:(2^nlist - 1))) - 1
}
</code></pre>

<hr>
<h2 id='check.strata'>Checks Each Stratum for Suitability for Capture-Recapture</h2><span id='topic+check.strata'></span>

<h3>Description</h3>

<p>Takes in list intersection counts and source list totals as produced by
make.strata. It then checks whether there are between three and five lists,
whether all of the lists are non-empty, and whether all of the lists overlap
with some other list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.strata(strata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.strata_+3A_strata">strata</code></td>
<td>
<p>A list of list overlaps and source countsin the format of the
output of make.strata. list.overlaps contains a data frame of list overlaps
by stratum. source.counts contains the number of records by source and
stratum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean indicating whether any serious problems have been found
with the strata.
</p>


<h3>Note</h3>

<p>This does not issue a warning for cases where some subset of lists is
not connected to the others, e.g. Lists A and B have overlap with each
other, lists C and D have overlap with each other, but no records from A or
B overlap with lists C or D. We suggest that you examine the list
intersection counts manually as well.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(chron)

N &lt;- 1000
overlaps &lt;- data.frame(l1 = rbinom(N, 1, .5), l2 = rbinom(N, 1, .5), l3 = rbinom(N, 1, .5))
dates &lt;- paste(
  rep(2015, N), "-", sample(1:12, N, replace = TRUE), "-",
  sample(1:28, N, replace = TRUE)
)
dates &lt;- chron(dates, format = c(dates = "y-m-d"))
locations &lt;- sample(c("A", "B", "C", "D"), N, replace = TRUE)

# Aggregate only by week:
strata &lt;- make.strata(overlaps, dates, date.def = "weekly")
check &lt;- check.strata(strata)
</code></pre>

<hr>
<h2 id='circle'>A Helper Function Used in venn3</h2><span id='topic+circle'></span>

<h3>Description</h3>

<p>Takes the parameters of a circle and returns points on its perimeter to be
plotted to make circles for a venn diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle(x, y, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle_+3A_x">x</code></td>
<td>
<p>the x coordinate of the center of the circle.</p>
</td></tr>
<tr><td><code id="circle_+3A_y">y</code></td>
<td>
<p>the y coordinate of the center of the circle.</p>
</td></tr>
<tr><td><code id="circle_+3A_r">r</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>inds</code></td>
<td>
<p>the x,y coordinates of the periphery of a circle, to be
used in venn3. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(dga:::circle(0, 0, 1), type = "l")
</code></pre>

<hr>
<h2 id='circle.ind'>A Helper Function for venn3</h2><span id='topic+circle.ind'></span>

<h3>Description</h3>

<p>Used in venn3 to tell whether proposed points are inside of the given
circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle.ind(ps, x, y, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle.ind_+3A_ps">ps</code></td>
<td>
<p>a n x 2 matrix of coordinates.</p>
</td></tr>
<tr><td><code id="circle.ind_+3A_x">x</code></td>
<td>
<p>the x coordinate of the center of the circle.</p>
</td></tr>
<tr><td><code id="circle.ind_+3A_y">y</code></td>
<td>
<p>the y coordinate of the center of the circle.</p>
</td></tr>
<tr><td><code id="circle.ind_+3A_r">r</code></td>
<td>
<p>the radius of the circle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length n vector telling whether each row of ps is inside the given
circle.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


ps &lt;- cbind(runif(100), runif(100))
plot(dga:::circle(0, 0, 1), type = "l")
inds &lt;- dga:::circle.ind(ps, 0, 0, 1)
points(inds)
</code></pre>

<hr>
<h2 id='CompLogML'>Computes Marginal Likelihoods for Each Clique and Value of Nmissing</h2><span id='topic+CompLogML'></span>

<h3>Description</h3>

<p>Assembles all of the pieces of the marginal likelihoods to be used to
calculate the posterior probability of each model/value of Nmissing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompLogML(D, Nmissing, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompLogML_+3A_d">D</code></td>
<td>
<p>A marginal array of the list overlap counts.</p>
</td></tr>
<tr><td><code id="CompLogML_+3A_nmissing">Nmissing</code></td>
<td>
<p>The vector of possible values for the missing cell.</p>
</td></tr>
<tr><td><code id="CompLogML_+3A_delta">delta</code></td>
<td>
<p>The prior hyper parameter for the Dirichlet distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log marginal likelihood of the marginal table.
</p>


<h3>Author(s)</h3>

<p>James Johndrow <a href="mailto:james.johndrow@gmail.com">james.johndrow@gmail.com</a> and Kristian Lum
<a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>References</h3>

<p>Madigan, David, and Jeremy C. York. &quot;Bayesian methods for
estimation of the size of a closed population.&quot;  Biometrika 84.1 (1997):
19-31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y &lt;- c(0, 27, 37, 19, 4, 4, 1, 1, 97, 22, 37, 25, 2, 1, 3, 5,
       83, 36, 34, 18, 3, 5, 0, 2, 30, 5, 23, 8, 0, 3, 0, 2)
Y &lt;- array(Y, dim = c(2, 2, 2, 2, 2))

# Compute marginal array over lists 1 and 3
D &lt;- apply(Y, c(1, 3), sum)

dga:::CompLogML(D, 1:300, 0.5)
</code></pre>

<hr>
<h2 id='ellipse'>A Helper Function Used by Venn4 to Define the Perimeter of an Ellipse</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Draws the ellipses used in venn4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(x, y, a, b, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_x">x</code></td>
<td>
<p>the x coordinate of the center of the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_y">y</code></td>
<td>
<p>the y coordinate of the center of the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_a">a</code></td>
<td>
<p>the x-direction radius.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_b">b</code></td>
<td>
<p>the y-direction radius.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_alpha">alpha</code></td>
<td>
<p>the angle of rotation of the ellipse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>points that define the perimeter of an ellipse.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(dga:::ellipse(0, 0, .5, .2, 1))
</code></pre>

<hr>
<h2 id='ellipse.ind'>A Helper Function Used by Venn4</h2><span id='topic+ellipse.ind'></span>

<h3>Description</h3>

<p>Takes potential points to be plotted in the venn diagrams and returns
whether the point is inside or outside of the ellipse described by x, y, a,
b, and alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse.ind(ps, x, y, a, b, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse.ind_+3A_ps">ps</code></td>
<td>
<p>a n x 2 matrix of coordinates.</p>
</td></tr>
<tr><td><code id="ellipse.ind_+3A_x">x</code></td>
<td>
<p>the x coordinate of the center of the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse.ind_+3A_y">y</code></td>
<td>
<p>the y coordinate of the center of the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse.ind_+3A_a">a</code></td>
<td>
<p>the x-radius of the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse.ind_+3A_b">b</code></td>
<td>
<p>the y-radius of the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse.ind_+3A_alpha">alpha</code></td>
<td>
<p>the angle of rotation of the ellipse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length n vector indicating whether each point is inside the
ellipse.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## The function is currently defined as
ps &lt;- cbind(runif(100), runif(100))
plot(dga:::ellipse(0, 0, .5, .3, 0), type = "l")
inds &lt;- dga:::ellipse.ind(ps, 0, 0, .5, .3, 0)
points(inds)
</code></pre>

<hr>
<h2 id='graphs3'>All Decomposable Graphical Models on Three Lists</h2><span id='topic+graphs3'></span>

<h3>Description</h3>

<p>This dataset contains all of the cliques and separators for each of the
decomposable graphical models on three lists. On three lists, this is all of
the models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graphs3)
</code></pre>


<h3>Format</h3>

<p>A list of lists. graphs3[[i]] is the <code>i</code>th model under
consideration. This consists of graphs3[[i]]$C, all of the cliques in that
model, and graphs3[[i]]$S, the separators.
</p>

<hr>
<h2 id='graphs4'>All Decomposable Graphical Models on Four Lists</h2><span id='topic+graphs4'></span>

<h3>Description</h3>

<p>This dataset contains all of the cliques and separators for each of the
decomposable graphical models on four lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graphs4)
</code></pre>


<h3>Format</h3>

<p>A list of lists. graphs4[[i]] is the <code>i</code>th model under
consideration. This consists of graphs4[[i]]$C, all of the cliques in that
model, and graphs4[[i]]$S, the separators.
</p>

<hr>
<h2 id='graphs5'>All Decomposable Graphical Models on Five Lists</h2><span id='topic+graphs5'></span>

<h3>Description</h3>

<p>This dataset contains all of the cliques and separators for each of the
decomposable graphical models on five lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graphs5)
</code></pre>


<h3>Format</h3>

<p>A list of lists. graphs5[[i]] is the <code>i</code>th model under
consideration. This consists of graphs5[[i]]$C, all of the cliques in that
model, and graphs5[[i]]$S, the separators.
</p>

<hr>
<h2 id='integer.base.b'>Base Converter</h2><span id='topic+integer.base.b'></span>

<h3>Description</h3>

<p>Takes a decimal number and converts it to base b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integer.base.b(x, b = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integer.base.b_+3A_x">x</code></td>
<td>
<p>A number.</p>
</td></tr>
<tr><td><code id="integer.base.b_+3A_b">b</code></td>
<td>
<p>The desired base.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This was harvested from the internet here:
https://stat.ethz.ch/pipermail/r-help/2003-September/038978.html. Posted by
Spencer Graves.
</p>


<h3>Value</h3>

<p>A number in base b.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>https://stat.ethz.ch/pipermail/r-help/2003-September/038978.html
</p>

<hr>
<h2 id='make.strata'>Transforms Records to List Intersection Counts by Stratum</h2><span id='topic+make.strata'></span>

<h3>Description</h3>

<p>Helps you to create list overlaps in the correct order to be used in bma.cr.
This function also does some of the heavy lifting to stratify records by
time (date, etc.) and other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.strata(
  overlaps,
  dates = NULL,
  locations = NULL,
  demographics = NULL,
  date.defs = "monthly",
  loc.defs = NULL,
  demog.defs = NULL,
  start.date = NULL,
  end.date = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.strata_+3A_overlaps">overlaps</code></td>
<td>
<p>a data frame that tells whether the i'th record appears on
the j'th lists, where n is the total number of sampled elements and p is the
number of lists. For example, if the [3,2] entry is 1, then the third
element appeared on the second list. If it is zero, then the third element
did NOT appear on the second list.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_dates">dates</code></td>
<td>
<p>record dates, in identical row oder to overlaps. This must be a
chron object. Do not include this if you don't want to stratify by time.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_locations">locations</code></td>
<td>
<p>record locations, though unlike the dates, there is nothing
special about the type that would prevent you from using any other variable
type to stratify by here. Do not include this unless you want to stratify by
the factor you include here.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_demographics">demographics</code></td>
<td>
<p>record demographic variables. Like locations, there is
nothing specific to this that requires this be demographic. This should be a
factor. Do not incude this unless you want to stratify by this factor.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_date.defs">date.defs</code></td>
<td>
<p>how you'd like to stratify by date. This defaults to
&quot;monthly&quot;. Other options are &quot;weekly&quot;, &quot;daily&quot;, and &quot;yearly&quot;. If you enter
an integer (k) instead of one of these options, the data will be stratified
into blocks of size k days.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_loc.defs">loc.defs</code></td>
<td>
<p>How to divide up all of the levels of locations into groups.
e.g. if locations has levels A, B, and C, and you'd like to stratify so that
A and B are one strata and C is another, input loc.defs = list(g1 = c('A',
'B'), g2 = c('C')). If this is left as NULL, each level will be put into its
own stratum.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_demog.defs">demog.defs</code></td>
<td>
<p>Similar to loc.defs. Same format. Including both just
allows you to stratify along two dimensions.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_start.date">start.date</code></td>
<td>
<p>A chron object of one date.  This gives the date of
earliest record we want to include. If NULL, this defaults to the earliest
record in the dataset.</p>
</td></tr>
<tr><td><code id="make.strata_+3A_end.date">end.date</code></td>
<td>
<p>a chron object of one date. This gives the date of the
latest record to be included. If NULL, this defaults to the latest record in
the dataset. This can only be included if dates are given.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>overlap.counts</code></td>
<td>
<p> a data frame where each row gives the list
intersection counts that can be used in bma.cr</p>
</td></tr> <tr><td><code>source.counts</code></td>
<td>
<p> a data
frame that gives the total number of records by each data source and
stratum. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(chron)
N &lt;- 10000
overlaps &lt;- data.frame(l1 = rbinom(N, 1, .5), l2 = rbinom(N, 1, .5), l3 = rbinom(N, 1, .5))
dates &lt;- paste(
  rep(2015, N), "-", sample(1:12, N, replace = TRUE), "-",
  sample(1:28, N, replace = TRUE)
)
dates &lt;- chron(dates, format = c(dates = "y-m-d"))
locations &lt;- sample(c("A", "B", "C", "D"), N, replace = TRUE)

# Aggregate only by week:
make.strata(overlaps, dates, date.def = "weekly")

# Aggregate by year and location, where locations are not grouped:
make.strata(overlaps, dates, date.def = "yearly", locations)

# Aggregate by 2 day increments and location, where there are unique location levels
#       A, B, C, and D and locations A and B are in group 1
#       and locations C and D are in group 2.
loc.defs &lt;- list("g1" = c("A", "B"), "g2" = c("C", "D"))
make.strata(overlaps, dates, date.def = 2, locations, loc.defs = loc.defs)
# Aggregate by demographic (sex) only, where sex takes values M, F, A, NA, and U
#       and we would like to group these as M, F, and other.
sex &lt;- sample(c("M", "F", "A", NA, "U"),
  prob = c(.4, .4, .1, .05, .05),
  N, replace = TRUE
)
demog.defs &lt;- list("M" = "M", "F" = "F", "Other" = c("A", NA, "U"))
make.strata(overlaps, demographics = sex, demog.defs = demog.defs)
</code></pre>

<hr>
<h2 id='MakeCompMatrix'>Component-wise Matrix of Log Marginal Likelihoods</h2><span id='topic+MakeCompMatrix'></span>

<h3>Description</h3>

<p>Calls CompLogML to create a matrix of number of possible components by
length(Nmissing) log marginal likelihoods. Calculates the log marginal
likehood of each possible marginal table for every value of Nmissing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeCompMatrix(p, delta, Y, Nmissing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeCompMatrix_+3A_p">p</code></td>
<td>
<p>Number of lists</p>
</td></tr>
<tr><td><code id="MakeCompMatrix_+3A_delta">delta</code></td>
<td>
<p>Prior hyperparameter of the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="MakeCompMatrix_+3A_y">Y</code></td>
<td>
<p>The <code>2^k</code> matrix of list intersection counts.</p>
</td></tr>
<tr><td><code id="MakeCompMatrix_+3A_nmissing">Nmissing</code></td>
<td>
<p>The vector of possible values for the missing cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of log marginal likelihoods.
</p>


<h3>Author(s)</h3>

<p>James Johndrow <a href="mailto:james.johndrow@gmail.com">james.johndrow@gmail.com</a> and Kristian Lum
<a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>

<hr>
<h2 id='plotPosteriorN'>Plots Posterior Distribution of Nmissing</h2><span id='topic+plotPosteriorN'></span>

<h3>Description</h3>

<p>Plots the model averaged posterior distribution of the total number of
elements (the solid line) and the contribution to the posterior of each of
the models (dotted lines)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPosteriorN(weights, N, main = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPosteriorN_+3A_weights">weights</code></td>
<td>
<p>The output of BMAfunction.</p>
</td></tr>
<tr><td><code id="plotPosteriorN_+3A_n">N</code></td>
<td>
<p>N + Nmissing. Or, if you prefer, just Nmissing. The former shows
the posterior distribution of the total population size; the latter shows
the posterior distribution of the number of missing elements.</p>
</td></tr>
<tr><td><code id="plotPosteriorN_+3A_main">main</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##### 5 list example from M &amp; Y #######

delta &lt;- .5
Y &lt;- c(0, 27, 37, 19, 4, 4, 1, 1, 97, 22, 37, 25, 2, 1, 3, 5,
       83, 36, 34, 18, 3, 5, 0, 2, 30, 5, 23, 8, 0, 3, 0, 2)
Y &lt;- array(Y, dim = c(2, 2, 2, 2, 2))
Nmissing &lt;- 1:300
N &lt;- Nmissing + sum(Y)
data(graphs5)
weights &lt;- bma.cr(Y, Nmissing, delta, graphs5)
plotPosteriorN(weights, N)


##### 3 list example from M &amp; Y #######
Y &lt;- c(0, 60, 49, 4, 247, 112, 142, 12)
Y &lt;- array(Y, dim = c(2, 2, 2))

delta &lt;- 1
a &lt;- 13.14
b &lt;- 55.17


Nmissing &lt;- 1:300
N &lt;- Nmissing + sum(Y)

logprior &lt;- N * log(b) - (N + a) * log(1 + b) + lgamma(N + a) - lgamma(N + 1) - lgamma(a)

data(graphs3)
weights &lt;- bma.cr(Y, Nmissing, delta, graphs3, logprior)
plotPosteriorN(weights, N)
</code></pre>

<hr>
<h2 id='remove.close'>A Helper Function to Tell Which Points Are Near the Boundary of a Circle</h2><span id='topic+remove.close'></span>

<h3>Description</h3>

<p>Used in venn3 to tell which of the potential points to be plotted are near
the boundary of the circle defned by x, y, and r.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.close(ps, x, y, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.close_+3A_ps">ps</code></td>
<td>
<p>an n x 2 matrix of potential points.</p>
</td></tr>
<tr><td><code id="remove.close_+3A_x">x</code></td>
<td>
<p>the x coordinate of the center of the circle.</p>
</td></tr>
<tr><td><code id="remove.close_+3A_y">y</code></td>
<td>
<p>the y coordinate of the center of the circle.</p>
</td></tr>
<tr><td><code id="remove.close_+3A_r">r</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>inds</code></td>
<td>
<p>tells which points are too close to the edge of the
circle. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


ps &lt;- cbind(runif(100), runif(100))
inds &lt;- dga:::remove.close(ps, .5, .5, .1)
</code></pre>

<hr>
<h2 id='remove.close.ellipse'>A Helper Function to Tell Which Points are Near the Boundary of the Ellipse</h2><span id='topic+remove.close.ellipse'></span>

<h3>Description</h3>

<p>A helper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.close.ellipse(ps, x, y, a, b, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.close.ellipse_+3A_ps">ps</code></td>
<td>
<p>an n x 2 matrix of potential points.</p>
</td></tr>
<tr><td><code id="remove.close.ellipse_+3A_x">x</code></td>
<td>
<p>the x coordinate of the center of the ellipse.</p>
</td></tr>
<tr><td><code id="remove.close.ellipse_+3A_y">y</code></td>
<td>
<p>the y coordinate of the center of the ellipse.</p>
</td></tr>
<tr><td><code id="remove.close.ellipse_+3A_a">a</code></td>
<td>
<p>the x-radius of the ellipse.</p>
</td></tr>
<tr><td><code id="remove.close.ellipse_+3A_b">b</code></td>
<td>
<p>the y-radius of the ellipse.</p>
</td></tr>
<tr><td><code id="remove.close.ellipse_+3A_alpha">alpha</code></td>
<td>
<p>the angle of rotation of the ellipse.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>inds</code></td>
<td>
<p>a vector of length nrow(ps) that tells whether each row
of ps is near the border of the ellipse defined by x,y,a,b, and alpha. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## The function is currently defined as
ps &lt;- cbind(runif(100), runif(100))
inds &lt;- dga:::remove.close.ellipse(ps, .5, .5, .1, .3, 1)
</code></pre>

<hr>
<h2 id='sfunction'>A Helper Function for make.strata.</h2><span id='topic+sfunction'></span>

<h3>Description</h3>

<p>This is the simplest function ever. It's just an apply to sum across
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfunction(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfunction_+3A_x">x</code></td>
<td>
<p>capture histories, as numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>apply(x, 2, sum)
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## The function is currently defined as
sfunction &lt;- function(x) {
  out &lt;- apply(x, 2, sum)
}
</code></pre>

<hr>
<h2 id='venn3'>Three List Venn Diagram</h2><span id='topic+venn3'></span>

<h3>Description</h3>

<p>A function that plots a venn diagram of 3 lists. One point is plotted in
each region for each record that falls into the corresponding list overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venn3(
  overlap.counts,
  main = NULL,
  num.test.points = 1e+05,
  p.cex = 0.75,
  write_numbers = FALSE,
  t.cex = 1.25,
  cex.main = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="venn3_+3A_overlap.counts">overlap.counts</code></td>
<td>
<p>A vector of length <code>2^3</code> that gives the number of
records in each overlap in lexicographic order, i.e. 001, 010, 011, 100,
etc.</p>
</td></tr>
<tr><td><code id="venn3_+3A_main">main</code></td>
<td>
<p>the title of the graph</p>
</td></tr>
<tr><td><code id="venn3_+3A_num.test.points">num.test.points</code></td>
<td>
<p>how many test points to generate as potentials to be
plotted in the circles.</p>
</td></tr>
<tr><td><code id="venn3_+3A_p.cex">p.cex</code></td>
<td>
<p>the size of the points to be plotted</p>
</td></tr>
<tr><td><code id="venn3_+3A_write_numbers">write_numbers</code></td>
<td>
<p>indicates whether to print the number of points in each
region.</p>
</td></tr>
<tr><td><code id="venn3_+3A_t.cex">t.cex</code></td>
<td>
<p>the size of the text to write the numbers.</p>
</td></tr>
<tr><td><code id="venn3_+3A_cex.main">cex.main</code></td>
<td>
<p>the size of the title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3-way venn diagram with points inside of each segment representing
the number of records on each list overlap.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

overlap.counts &lt;- rpois(8, 30)
venn3(overlap.counts, main = "example diagram")
</code></pre>

<hr>
<h2 id='venn4'>Four List Venn Diagram</h2><span id='topic+venn4'></span>

<h3>Description</h3>

<p>A function that plots a venn diagram of 4 lists. One point is plotted in
each region for each record that falls into the corresponding list overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venn4(
  overlap.counts,
  main = NULL,
  num.test.points = 1e+05,
  p.cex = 0.75,
  cex.main = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="venn4_+3A_overlap.counts">overlap.counts</code></td>
<td>
<p>A vector of length <code>2^4</code> that gives the number of
records in each overlap in lexicographic order, i.e. 0000, 0001, 0010, 0011,
0100, etc.</p>
</td></tr>
<tr><td><code id="venn4_+3A_main">main</code></td>
<td>
<p>the title of the graph</p>
</td></tr>
<tr><td><code id="venn4_+3A_num.test.points">num.test.points</code></td>
<td>
<p>how many test points to generate as potentials to be
plotted in the circles.</p>
</td></tr>
<tr><td><code id="venn4_+3A_p.cex">p.cex</code></td>
<td>
<p>the size of the points to be plotted</p>
</td></tr>
<tr><td><code id="venn4_+3A_cex.main">cex.main</code></td>
<td>
<p>the size of the title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A venn diagram of the list overlap structure for four lists. Each
region of the plot contains points representing each record in that list
intersection.
</p>


<h3>Author(s)</h3>

<p>Kristian Lum <a href="mailto:kl@hrdag.org">kl@hrdag.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

overlap.counts &lt;- rpois(16, 50)
venn4(overlap.counts, main = "example diagram")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
