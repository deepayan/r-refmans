<!DOCTYPE html><html><head><title>Help for package KFPCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KFPCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CD4'><p>CD4 cell counts</p></a></li>
<li><a href='#FPCscoreLSE'><p>Least square estimates of functional principal component scores</p></a></li>
<li><a href='#GenDataKL'><p>Generate functional/longitudinal data via KL expansion</p></a></li>
<li><a href='#GetGCVbw1D'><p>Bandwidth selection through GCV for one-dimension cases</p></a></li>
<li><a href='#GetGCVbw2D'><p>Bandwidth selection through GCV for two-dimension cases</p></a></li>
<li><a href='#kernfun'><p>Kernel Functions</p></a></li>
<li><a href='#KFPCA'><p>Kendall Functional Principal Component Analysis (KFPCA) for sparse design</p></a></li>
<li><a href='#KFPCA_reg'><p>Kendall Functional Principal Component Analysis (KFPCA) for dense and regular design</p></a></li>
<li><a href='#MeanEst'><p>Local linear estimates of mean function</p></a></li>
<li><a href='#predict.KFPCA'><p>Predict FPC scores</p></a></li>
<li><a href='#SparsePlot'><p>Sparse plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Kendall Functional Principal Component Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation for Kendall functional principal component analysis. Kendall functional principal component analysis is a robust functional principal component analysis technique for non-Gaussian functional/longitudinal data. The crucial function of this package is KFPCA() and KFPCA_reg(). Moreover, least square estimates of functional principal component scores are also provided. Refer to Rou Zhong, Shishi Liu, Haocheng Li, Jingxiao Zhang. (2021) &lt;<a href="https://arxiv.org/abs/2102.01286">arXiv:2102.01286</a>&gt;. Rou Zhong, Shishi Liu, Haocheng Li, Jingxiao Zhang. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2021.104864">doi:10.1016/j.jmva.2021.104864</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>kader, utils, pracma, fdapace, fda, stats, graphics</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-04 11:09:41 UTC; 11013</td>
</tr>
<tr>
<td>Author:</td>
<td>Rou Zhong [aut, cre],
  Jingxiao Zhang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rou Zhong &lt;zhong_rou@163.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-04 11:30:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='CD4'>CD4 cell counts</h2><span id='topic+CD4'></span>

<h3>Description</h3>

<p>A dataset containing the logarithm of CD4 cell counts for 190 patients with AIDS from June 1997 to January 2002. The data come from a human immunodeficiency virus (HIV) study by Wohl et al. (2005) and can be obtained from Cao et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CD4
</code></pre>


<h3>Format</h3>

<p>A data frame with 741 rows and 3 variables:
</p>

<dl>
<dt>PATIENT</dt><dd><p>Patient ID.</p>
</dd>
<dt>CD4OBS</dt><dd><p>Logarithm of CD4 cell counts.</p>
</dd>
<dt>CD4DATE</dt><dd><p>Day of measurement.</p>
</dd>
</dl>



<h3>References</h3>

<p><cite>David A. Wohl, Donglin Zeng, Paul Stewart, Nicolas Glomb, Timothy Alcorn, Suzanne Jones, Jean Handy, Susan Fiscus, Adriana Weinberg, Deepthiman Gowda, and Charles van der Horst (2005). &quot;Cytomegalovirus viremia, mortality, and end-organ disease among patients with aids receiving potent antiretroviral therapies.&quot; Journal of Acquired Immune Deficiency Syndromes, 38(5):538-544.</cite>
</p>
<p><cite>Hongyuan Cao, Donglin Zeng, and Jason P. Fine (2015). &quot;Regression analysis of sparse asynchronous longitudinal data.&quot; Journal of The Royal Statistical Society Series B-statistical Methodology, 77(4):755-776.</cite>
</p>

<hr>
<h2 id='FPCscoreLSE'>Least square estimates of functional principal component scores</h2><span id='topic+FPCscoreLSE'></span>

<h3>Description</h3>

<p>Least square estimates (LSE) of functional principal component scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FPCscoreLSE(Lt, Ly, kern, bw, FPC_dis, RegGrid, more = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FPCscoreLSE_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code id="FPCscoreLSE_+3A_ly">Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td></tr>
<tr><td><code id="FPCscoreLSE_+3A_kern">kern</code></td>
<td>
<p>A <code>character</code> denoting the kernel type; 'epan'(Epanechnikov), 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="FPCscoreLSE_+3A_bw">bw</code></td>
<td>
<p>A scalar denoting the bandwidth for mean function estimate.</p>
</td></tr>
<tr><td><code id="FPCscoreLSE_+3A_fpc_dis">FPC_dis</code></td>
<td>
<p>A <code>nRegGrid</code> by <code>nK</code> <code>matrix</code> containing the eigenfunction estimates at <code>RegGrid</code>, where <code>nRegGrid</code> is the length of <code>RegGrid</code> and <code>nK</code> is the number of FPCs.</p>
</td></tr>
<tr><td><code id="FPCscoreLSE_+3A_reggrid">RegGrid</code></td>
<td>
<p>A <code>vector</code> of the equally spaced time points in the support interval.</p>
</td></tr>
<tr><td><code id="FPCscoreLSE_+3A_more">more</code></td>
<td>
<p>Logical; If <code>FALSE</code>, only the estimates of FPC scores are returned. If <code>TRUE</code>, the mean function estimates and the eigenfunction estimates at all observation time points are also returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>more = FALSE</code>, a <em>n</em> by <code>nK</code> <code>matrix</code> containing the estimates of the FPC scores is returned, where <em>n</em> is the sample size. If <code>more = TRUE</code>, a <code>list</code> containing the following components is returned:
</p>
<table>
<tr><td><code>score</code></td>
<td>
<p>a <em>n</em> by <code>nK</code> <code>matrix</code> containing the estimates of the FPC scores.</p>
</td></tr>
<tr><td><code>meanest_fine</code></td>
<td>
<p>Mean function estimates at all observation time points.</p>
</td></tr>
<tr><td><code>FPC_dis_fine</code></td>
<td>
<p>Eigenfunction estimates at all observation time points.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 3:5, regular = FALSE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
basis &lt;- fda::create.bspline.basis(interval, nbasis = 13, norder = 4,
                              breaks = seq(0, 10, length.out = 11))
Klist &lt;- KFPCA(DataNew$Lt, DataNew$Ly, interval, nK = 2, bw = 1,
               nRegGrid = 51, fdParobj = basis)
# Just an example to explain the use of FPCscoreLSE().
# One can obtain FPC scores estimates for KFPCA method
# by KFPCA() directly. Note that FPCscoreLSE() can also be used
# to estimate FPC scores for methods except KFPCA.
scoreKFPCA &lt;- FPCscoreLSE(DataNew$Lt, DataNew$Ly, kern = "epan",
                          bw = Klist$bwmean, FPC_dis = Klist$FPC_dis,
                          RegGrid = seq(interval[1], interval[2], length.out = 51))
</code></pre>

<hr>
<h2 id='GenDataKL'>Generate functional/longitudinal data via KL expansion</h2><span id='topic+GenDataKL'></span>

<h3>Description</h3>

<p>Generate functional/longitudinal data via Karhunen–Loève expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenDataKL(n, interval, sparse, regular, meanfun, score, eigfun, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenDataKL_+3A_n">n</code></td>
<td>
<p>number of sample size.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_interval">interval</code></td>
<td>
<p>A <code>vector</code> of length two denoting the supporting interval.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_sparse">sparse</code></td>
<td>
<p>A <code>vector</code> denoting the possible numbers of observation size. The elements are chosen with equal chance. The length of <code>sparse</code> must be one if <code>regular = TRUE</code>.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_regular">regular</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the observation grids are equally-spaced.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_meanfun">meanfun</code></td>
<td>
<p>A function for the mean.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_score">score</code></td>
<td>
<p>A <em>n</em> by <code>nK</code> <code>matrix</code> containing the estimates of the FPC scores, where <code>nK</code> is the number of FPCs.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_eigfun">eigfun</code></td>
<td>
<p>A <code>list</code> containing the eigenfunctions.</p>
</td></tr>
<tr><td><code id="GenDataKL_+3A_sd">sd</code></td>
<td>
<p>A scalar denoting the standard deviation of measurement errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code>Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
</code></pre>

<hr>
<h2 id='GetGCVbw1D'>Bandwidth selection through GCV for one-dimension cases</h2><span id='topic+GetGCVbw1D'></span>

<h3>Description</h3>

<p>Bandwidth selection through generalized cross-validation (GCV) for one-dimension cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetGCVbw1D(Lt, Ly, kern, dataType = "Sparse")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetGCVbw1D_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code id="GetGCVbw1D_+3A_ly">Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td></tr>
<tr><td><code id="GetGCVbw1D_+3A_kern">kern</code></td>
<td>
<p>A <code>character</code> denoting the kernel type; 'epan'(Epanechnikov), 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="GetGCVbw1D_+3A_datatype">dataType</code></td>
<td>
<p>A <code>character</code> denoting the data type; 'Sparse'-default, 'Dense'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar denoting the optimal bandwidth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
# Optimal bandwidth for mean function estimate
bwOpt &lt;- GetGCVbw1D(DataNew$Lt, DataNew$Ly, kern = "epan")
</code></pre>

<hr>
<h2 id='GetGCVbw2D'>Bandwidth selection through GCV for two-dimension cases</h2><span id='topic+GetGCVbw2D'></span>

<h3>Description</h3>

<p>Bandwidth selection through generalized cross-validation (GCV) for two-dimension cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetGCVbw2D(tPairs, yin, Lt, kern, ObsGrid, RegGrid, dataType = "Sparse")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetGCVbw2D_+3A_tpairs">tPairs</code></td>
<td>
<p>A <code>matrix</code> with two columns containing the pairs of time points.</p>
</td></tr>
<tr><td><code id="GetGCVbw2D_+3A_yin">yin</code></td>
<td>
<p>A <code>vector</code> denoting the corresponding values.</p>
</td></tr>
<tr><td><code id="GetGCVbw2D_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code id="GetGCVbw2D_+3A_kern">kern</code></td>
<td>
<p>A <code>character</code> denoting the kernel type; 'epan'(Epanechnikov), 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="GetGCVbw2D_+3A_obsgrid">ObsGrid</code></td>
<td>
<p>A <code>vector</code> containing all observation grids in ascending order.</p>
</td></tr>
<tr><td><code id="GetGCVbw2D_+3A_reggrid">RegGrid</code></td>
<td>
<p>A <code>vector</code> of the equally spaced time points in the support interval.</p>
</td></tr>
<tr><td><code id="GetGCVbw2D_+3A_datatype">dataType</code></td>
<td>
<p>A <code>character</code> denoting the data type; 'Sparse'-default, 'Dense'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar denoting the optimal bandwidth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
# Optimal bandwidth for the estimate of
# E{X(s)X(t)} = cov(X(s), X(t)) + mu(s) * mu(t)
xin2D &lt;- NULL
yin2D &lt;- NULL
for(i in 1:n){
  xin2D &lt;- rbind(xin2D, t(utils::combn(DataNew$Lt[[i]], 2)))
  yin2D &lt;- rbind(yin2D, t(utils::combn(DataNew$Ly[[i]], 2)))
}
tPairs &lt;- xin2D
yin &lt;- yin2D[,1] * yin2D[, 2]
bwOpt &lt;- GetGCVbw2D(tPairs = tPairs, yin = yin, Lt = DataNew$Lt,
                    kern = "epan", ObsGrid = sort(unique(unlist(DataNew$Lt))),
                    RegGrid = seq(interval[1], interval[2], length.out = 51))
</code></pre>

<hr>
<h2 id='kernfun'>Kernel Functions</h2><span id='topic+kernfun'></span>

<h3>Description</h3>

<p>Some common-used kernel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernfun(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernfun_+3A_type">type</code></td>
<td>
<p>A <code>character</code> denoting the kernel type; 'epan'(Epanechnikov), 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding kernel function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-2, 2, 0.01)
par(mfrow = c(2,2))
plot(x, kernfun("epan")(x), type = "l", main = "Epanechnikov")
plot(x, kernfun("unif")(x), type = "l", main = "Uniform")
plot(x, kernfun("quar")(x), type = "l", main = "Quartic")
plot(x, kernfun("gauss")(x), type = "l", main = "Gaussian")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='KFPCA'>Kendall Functional Principal Component Analysis (KFPCA) for sparse design</h2><span id='topic+KFPCA'></span>

<h3>Description</h3>

<p>KFPCA for non-Gaussian functional data with sparse design or longitudinal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KFPCA(
  Lt,
  Ly,
  interval,
  dataType = "Sparse",
  nK,
  kern = "epan",
  bw,
  kernK = "epan",
  bwK = "GCV",
  kernmean = "epan",
  bwmean = "GCV",
  nRegGrid,
  fdParobj,
  more = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KFPCA_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_ly">Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_interval">interval</code></td>
<td>
<p>A <code>vector</code> of length two denoting the supporting interval.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_datatype">dataType</code></td>
<td>
<p>A <code>character</code> denoting the data type; 'Sparse'-default, 'Dense'.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_nk">nK</code></td>
<td>
<p>An integer denoting the number of FPCs.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_kern">kern</code></td>
<td>
<p>A <code>character</code> denoting the kernel type for the Nadaraya-Watson estimators; 'epan'(Epanechnikov)-default, 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_bw">bw</code></td>
<td>
<p>A scalar denoting the bandwidth for the Nadaraya-Watson estimators.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_kernk">kernK</code></td>
<td>
<p>A <code>character</code> denoting the kernel type for the estimation of the Kendall's tau function; 'epan'(Epanechnikov)-default, 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_bwk">bwK</code></td>
<td>
<p>The bandwidth for the estimation of the Kendall's tau function. If <code>is.numeric(bwK) == T</code>, <code>bwK</code> is exactly the bandwidth. If <code>bwK == "GCV"</code>, the bandwidth is chosen by GCV. (default: &quot;GCV&quot;)</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_kernmean">kernmean</code></td>
<td>
<p>A <code>character</code> denoting the kernel type for the estimation of the mean function; 'epan'(Epanechnikov)-default, 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_bwmean">bwmean</code></td>
<td>
<p>The bandwidth for the estimation of the mean function. If <code>is.numeric(bwmean) == T</code>, <code>bwmean</code> is exactly the bandwidth. If <code>bwmean == "GCV"</code>, the bandwidth is chosen by GCV. (default: &quot;GCV&quot;)</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_nreggrid">nRegGrid</code></td>
<td>
<p>An integer denoting the number of equally spaced time points in the supporting interval. The eigenfunctions and mean function are estimated at these equally spaced time points.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_fdparobj">fdParobj</code></td>
<td>
<p>A functional parameter object for the smoothing of the eigenfunctions. For more detail, see <code><a href="fda.html#topic+smooth.basis">smooth.basis</a></code>.</p>
</td></tr>
<tr><td><code id="KFPCA_+3A_more">more</code></td>
<td>
<p>Logical; If <code>FALSE</code>, estimates of FPC scores and predictions of trajectories are not returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>ObsGrid</code></td>
<td>
<p>A <code>vector</code> containing all observation time points in ascending order.</p>
</td></tr>
<tr><td><code>RegGrid</code></td>
<td>
<p>A <code>vector</code> of the equally spaced time points in the support interval.</p>
</td></tr>
<tr><td><code>bwmean</code></td>
<td>
<p>A scalar denoting the bandwidth for the mean function estimate.</p>
</td></tr>
<tr><td><code>kernmean</code></td>
<td>
<p>A <code>character</code> denoting the kernel type for the estimation of the mean function</p>
</td></tr>
<tr><td><code>bwK</code></td>
<td>
<p>A scalar denoting the bandwidth for the Kendall's tau function estimate.</p>
</td></tr>
<tr><td><code>kernK</code></td>
<td>
<p>A <code>character</code> denoting the kernel type for the estimation of the Kendall's tau function</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A <code>vector</code> of length <code>nRegGrid</code> denoting the mean function estimate.</p>
</td></tr>
<tr><td><code>KendFun</code></td>
<td>
<p>A <code>nRegGrid</code> by <code>nRegGrid</code> <code>matrix</code> denoting the Kendall's tau function estimate.</p>
</td></tr>
<tr><td><code>FPC_dis</code></td>
<td>
<p>A <code>nRegGrid</code> by <code>nK</code> <code>matrix</code> containing the eigenfunction estimates at <code>RegGrid</code>.</p>
</td></tr>
<tr><td><code>FPC_smooth</code></td>
<td>
<p>A functional data object for the eigenfunction estimates.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>A <em>n</em> by <code>nK</code> <code>matrix</code> containing the estimates of the FPC scores, where <em>n</em> is the sample size. The results are returned when <code>more = TRUE</code>.</p>
</td></tr>
<tr><td><code>X_fd</code></td>
<td>
<p>A functional data object for the prediction of trajectories. The results are returned when <code>more = TRUE</code>.</p>
</td></tr>
<tr><td><code>Xest_ind</code></td>
<td>
<p>A <code>list</code> containing the prediction of each trajectory at their own observation time points. The results are returned when <code>more = TRUE</code>.</p>
</td></tr>
<tr><td><code>Lt</code></td>
<td>
<p>The input 'Lt'.</p>
</td></tr>
<tr><td><code>Ly</code></td>
<td>
<p>The input 'Ly'.</p>
</td></tr>
<tr><td><code>CompTime</code></td>
<td>
<p>A scalar denoting the computation time.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Rou Zhong, Shishi Liu, Haocheng Li, Jingxiao Zhang (2021). &quot;Robust Functional Principal Component Analysis for Non-Gaussian Longitudinal Data.&quot; Journal of Multivariate Analysis, https://doi.org/10.1016/j.jmva.2021.104864.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
basis &lt;- fda::create.bspline.basis(interval, nbasis = 13, norder = 4,
                              breaks = seq(0, 10, length.out = 11))
# KFPCA
Klist &lt;- KFPCA(DataNew$Lt, DataNew$Ly, interval, nK = 2, bw = 1,
               nRegGrid = 51, fdParobj = basis)
plot(Klist$FPC_smooth)
</code></pre>

<hr>
<h2 id='KFPCA_reg'>Kendall Functional Principal Component Analysis (KFPCA) for dense and regular design</h2><span id='topic+KFPCA_reg'></span>

<h3>Description</h3>

<p>KFPCA for non-Gaussian functional data with dense and regular design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KFPCA_reg(Lt, Ly, nGrid, nK, fdParobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KFPCA_reg_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject. The observation times are the same for each subject.</p>
</td></tr>
<tr><td><code id="KFPCA_reg_+3A_ly">Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td></tr>
<tr><td><code id="KFPCA_reg_+3A_ngrid">nGrid</code></td>
<td>
<p>An integer denoting the number of observation time for each subject.</p>
</td></tr>
<tr><td><code id="KFPCA_reg_+3A_nk">nK</code></td>
<td>
<p>An integer denoting the number of FPCs.</p>
</td></tr>
<tr><td><code id="KFPCA_reg_+3A_fdparobj">fdParobj</code></td>
<td>
<p>A functional parameter object for the smoothing of mean function and eigenfunctions. For more detail, see <code><a href="fda.html#topic+smooth.basis">smooth.basis</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>meanfd</code></td>
<td>
<p>A functional data object for the mean function estimates.</p>
</td></tr>
<tr><td><code>FPC_list</code></td>
<td>
<p>A <code>list</code> containing <code>nK</code> functional data objects, which are the eigenfunction estimates.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>A <em>n</em> by <code>nK</code> <code>matrix</code> containing the estimates of the FPC scores, where <em>n</em> is the sample size.</p>
</td></tr>
<tr><td><code>CompTime</code></td>
<td>
<p>A scalar denoting the computation time.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Rou Zhong, Shishi Liu, Haocheng Li, Jingxiao Zhang (2021). &quot;Functional principal component analysis estimator for non-Gaussian data.&quot; &lt;arXiv: https://arxiv.org/abs/2102.01286&gt;.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 16 #the first eigenvalue
lambda_2 &lt;- 9 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 51, regular = TRUE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.25))
basis &lt;- fda::create.bspline.basis(interval, nbasis = 13, norder = 4,
                              breaks = seq(0, 10, length.out = 11))
#KFPCA
Klist &lt;- KFPCA_reg(DataNew$Lt, DataNew$Ly, nGrid = 51, nK = 2, fdParobj = basis)
plot(Klist$FPC_list[[1]])
plot(Klist$FPC_list[[2]])

</code></pre>

<hr>
<h2 id='MeanEst'>Local linear estimates of mean function</h2><span id='topic+MeanEst'></span>

<h3>Description</h3>

<p>Local linear estimates of mean function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanEst(Lt, Ly, kern, bw, gridout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeanEst_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code id="MeanEst_+3A_ly">Ly</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of each subject at the observation time correspond to <code>Lt</code>.</p>
</td></tr>
<tr><td><code id="MeanEst_+3A_kern">kern</code></td>
<td>
<p>A <code>character</code> denoting the kernel type; 'epan'(Epanechnikov), 'unif'(Uniform), 'quar'(Quartic), 'gauss'(Gaussian).</p>
</td></tr>
<tr><td><code id="MeanEst_+3A_bw">bw</code></td>
<td>
<p>A scalar denoting the bandwidth.</p>
</td></tr>
<tr><td><code id="MeanEst_+3A_gridout">gridout</code></td>
<td>
<p>A <code>vector</code> denoting the time points that the mean function need to be estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>Grid</code></td>
<td>
<p>A <code>vector</code> denoting the time points that the mean function need to be estimated.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A <code>vector</code> containing the mean function estimates.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                     meanfun = function(x){x}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
# Mean function estimate at all observation time points
bwOpt &lt;- GetGCVbw1D(DataNew$Lt, DataNew$Ly, kern = "epan")
meanest &lt;- MeanEst(DataNew$Lt, DataNew$Ly, kern = "epan", bw = bwOpt,
                   gridout = sort(unique(unlist(DataNew$Lt))))
plot(meanest$Grid, meanest$mean)
</code></pre>

<hr>
<h2 id='predict.KFPCA'>Predict FPC scores</h2><span id='topic+predict.KFPCA'></span>

<h3>Description</h3>

<p>Predict FPC scores using least square estimate (LSE) for a new sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KFPCA'
predict(object, newLt, newLy, nK, more = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.KFPCA_+3A_object">object</code></td>
<td>
<p>A KFPCA object obtained from <code><a href="#topic+KFPCA">KFPCA</a></code>.</p>
</td></tr>
<tr><td><code id="predict.KFPCA_+3A_newlt">newLt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the new sample size. Each entry contains the observation time in ascending order for each new subject.</p>
</td></tr>
<tr><td><code id="predict.KFPCA_+3A_newly">newLy</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the new sample size. Each entry contains the measurements of each new subject at the observation time correspond to <code>newLt</code>.</p>
</td></tr>
<tr><td><code id="predict.KFPCA_+3A_nk">nK</code></td>
<td>
<p>An integer denoting the number of FPCs.</p>
</td></tr>
<tr><td><code id="predict.KFPCA_+3A_more">more</code></td>
<td>
<p>Logical; If <code>FALSE</code>, only the predictions of FPC scores are returned. If <code>TRUE</code>, the mean function estimates and the eigenfunction estimates at the new observation time points are also returned.</p>
</td></tr>
<tr><td><code id="predict.KFPCA_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>more = FALSE</code>, a <em>n</em> by <code>nK</code> <code>matrix</code> containing the predictions of the FPC scores is returned, where <em>n</em> is the new sample size. If <code>more = TRUE</code>, a <code>list</code> containing the following components is returned:
</p>
<table>
<tr><td><code>score_new</code></td>
<td>
<p>a <em>n</em> by <code>nK</code> <code>matrix</code> containing the predictions of the FPC scores.</p>
</td></tr>
<tr><td><code>meanest_new</code></td>
<td>
<p>Mean function estimates at the new observation time points.</p>
</td></tr>
<tr><td><code>FPC_dis_new</code></td>
<td>
<p>Eigenfunction estimates at the new observation time points.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate training data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
DataNew &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                     meanfun = function(x){0}, score = score,
                     eigfun = eigfun, sd = sqrt(0.1))
basis &lt;- fda::create.bspline.basis(interval, nbasis = 13, norder = 4,
                              breaks = seq(0, 10, length.out = 11))
Klist &lt;- KFPCA(DataNew$Lt, DataNew$Ly, interval, nK = 2, bw = 1,
               nRegGrid = 51, fdParobj = basis)
# Generate test data
n_test &lt;- 20
score_test &lt;- cbind(rnorm(n_test, 0, sqrt(lambda_1)),
                    rnorm(n_test, 0, sqrt(lambda_2)))
Data_test &lt;- GenDataKL(n_test, interval = interval, sparse = 6:8, regular = FALSE,
                       meanfun = function(x){0}, score = score_test,
                       eigfun = eigfun, sd = sqrt(0.1))
# Prediction
score_pre &lt;- predict(Klist, Data_test$Lt, Data_test$Ly, nK = 2)
plot(score_test[,1], score_pre[,1])
</code></pre>

<hr>
<h2 id='SparsePlot'>Sparse plot</h2><span id='topic+SparsePlot'></span>

<h3>Description</h3>

<p>Create sparse plot to see the sparsity of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparsePlot(Lt, interval, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparsePlot_+3A_lt">Lt</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation time in ascending order for each subject.</p>
</td></tr>
<tr><td><code id="SparsePlot_+3A_interval">interval</code></td>
<td>
<p>A <code>vector</code> of length two denoting the supporting interval.</p>
</td></tr>
<tr><td><code id="SparsePlot_+3A_...">...</code></td>
<td>
<p>Other arguments passed into <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the sparse plot, x-axis is the observation time while y-axis represents various subjects.
</p>


<h3>Value</h3>

<p>Create the corresponding sparse plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 100
interval &lt;- c(0, 10)
lambda_1 &lt;- 9 #the first eigenvalue
lambda_2 &lt;- 1.5 #the second eigenvalue
eigfun &lt;- list()
eigfun[[1]] &lt;- function(x){cos(pi * x/10)/sqrt(5)}
eigfun[[2]] &lt;- function(x){sin(pi * x/10)/sqrt(5)}
score &lt;- cbind(rnorm(n, 0, sqrt(lambda_1)), rnorm(n, 0, sqrt(lambda_2)))
# DataNew1 and DataNew2 have different sparsity
DataNew1 &lt;- GenDataKL(n, interval = interval, sparse = 6:8, regular = FALSE,
                      meanfun = function(x){0}, score = score,
                      eigfun = eigfun, sd = sqrt(0.1))
DataNew2 &lt;- GenDataKL(n, interval = interval, sparse = 2:4, regular = FALSE,
                      meanfun = function(x){0}, score = score,
                      eigfun = eigfun, sd = sqrt(0.1))
# Create sparse plots
par(mfrow = c(1, 2))
SparsePlot(DataNew1$Lt, interval = interval)
SparsePlot(DataNew2$Lt, interval = interval)
par(mfrow = c(1, 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
