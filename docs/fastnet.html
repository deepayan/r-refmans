<!DOCTYPE html><html><head><title>Help for package fastnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#degree.collect'><p>Degrees of nodes</p></a></li>
<li><a href='#degree.dist'><p>Plot of the degree distribution of a network</p></a></li>
<li><a href='#degree.hist'><p>Histogram of the degree distribution of a network</p></a></li>
<li><a href='#draw.net'><p>Plot of a small network</p></a></li>
<li><a href='#from.adjacency'><p>Adjacency Matrix to <code>fastnet</code></p></a></li>
<li><a href='#from.edgelist'><p>Edgelist to <code>fastnet</code></p></a></li>
<li><a href='#from.igraph'><p>Transform an <code>igraph</code> object to a <code>fastnet</code> object</p></a></li>
<li><a href='#from.statnet'><p><code>statnet</code>  to <code>fastnet</code></p></a></li>
<li><a href='#get.neighbors'><p>Neighbors of an agent in a network</p></a></li>
<li><a href='#metric.cluster.global'><p>Global Clustering Coefficient</p></a></li>
<li><a href='#metric.cluster.mean'><p>Mean Local Clustering Coefficient</p></a></li>
<li><a href='#metric.cluster.median'><p>Median Local Clustering Coefficient</p></a></li>
<li><a href='#metric.degree.effective'><p>Effective Degree</p></a></li>
<li><a href='#metric.degree.entropy'><p>Degree Entropy</p></a></li>
<li><a href='#metric.degree.max'><p>Maximal Degree</p></a></li>
<li><a href='#metric.degree.max.efficient'><p>Efficient Maximal Degree</p></a></li>
<li><a href='#metric.degree.mean'><p>Mean Degree</p></a></li>
<li><a href='#metric.degree.median'><p>Median Degree</p></a></li>
<li><a href='#metric.degree.min'><p>Minimal Degree</p></a></li>
<li><a href='#metric.degree.sd'><p>Standard Deviation of Degree Distribution</p></a></li>
<li><a href='#metric.distance.apl'><p>Average Path Length</p></a></li>
<li><a href='#metric.distance.diameter'><p>Diameter</p></a></li>
<li><a href='#metric.distance.effdia'><p>Effective Diameter</p></a></li>
<li><a href='#metric.distance.meanecc'><p>Mean Eccentricity</p></a></li>
<li><a href='#metric.distance.medianecc'><p>Median Eccentricity</p></a></li>
<li><a href='#metric.distance.mpl'><p>Median Path Length</p></a></li>
<li><a href='#metric.eigen.mean'><p>Mean Eigenvalue Centrality</p></a></li>
<li><a href='#metric.eigen.median'><p>Median Eigenvalue Centrality</p></a></li>
<li><a href='#metric.eigen.value'><p>Eigenvalue Score</p></a></li>
<li><a href='#metric.graph.density'><p>Graph Density</p></a></li>
<li><a href='#net.barabasi.albert'><p>Barabasi-Albert Scale-free Graph</p></a></li>
<li><a href='#net.caveman'><p>Caveman Network</p></a></li>
<li><a href='#net.cluster.affiliation'><p>Generate a cluster-affiliation graph</p></a></li>
<li><a href='#net.complete'><p>Complete Network</p></a></li>
<li><a href='#net.degree.constraint'><p>Generate a degree-constraint graph</p></a></li>
<li><a href='#net.erdos.renyi.gnm'><p>Directed / Undirected Erdos-Renyi <code class="reqn">G(n,m)</code> network using a fix edge size.</p></a></li>
<li><a href='#net.erdos.renyi.gnp'><p>Directed / Undirected Erdos-Renyi <code class="reqn">G(n,p)</code> network</p></a></li>
<li><a href='#net.holme.kim'><p>Holme-Kim Network</p></a></li>
<li><a href='#net.random.plc'><p>Random Network with a Power-law Degree Distribution that Has An Exponential Cutoff</p></a></li>
<li><a href='#net.rewired.caveman'><p>Rewired (Connected) Caveman Network</p></a></li>
<li><a href='#net.ring.lattice'><p><em>k</em> - regular ring lattice</p></a></li>
<li><a href='#net.watts.strogatz'><p>Watts-Strogatz Small-world Network</p></a></li>
<li><a href='#preview.deg'><p>Preview of the degree distribution of a network</p></a></li>
<li><a href='#preview.net'><p>Preview of a network</p></a></li>
<li><a href='#to.edgelist'><p><code>fastnet</code> to edgelist</p></a></li>
<li><a href='#to.igraph'><p><code>fastnet</code> to <code>igraph</code></p></a></li>
<li><a href='#to.tidygraph'><p><code>fastnet</code> to <code>tidygraph</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Large-Scale Social Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>We present an implementation of the algorithms required to simulate
  large-scale social networks and retrieve their most relevant metrics. Details 
  can be found in the accompanying scientific paper on the Journal 
  of Statistical Software, &lt;<a href="https://doi.org/10.18637%2Fjss.v096.i07">doi:10.18637/jss.v096.i07</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel (&ge; 1.0.0), foreach (&ge; 1.5.0), igraph (&ge; 1.2.0),
tidygraph(&ge; 1.2.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/networkgroupR/fastnet/issues">https://github.com/networkgroupR/fastnet/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-01 02:20:58 UTC; xu</td>
</tr>
<tr>
<td>Author:</td>
<td>Nazrul Shaikh [aut, cre],
  Xu Dong [aut],
  Luis Castro [aut],
  Christian Llano [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nazrul Shaikh &lt;networkgroupr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-01 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='degree.collect'>Degrees of nodes</h2><span id='topic+degree.collect'></span>

<h3>Description</h3>

<p>Collect the degrees for all nodes in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree.collect(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.collect_+3A_net">net</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtain the degrees for all nodes.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x.deg &lt;- degree.collect(x)
summary(x.deg)
## End(Not run)
</code></pre>

<hr>
<h2 id='degree.dist'>Plot of the degree distribution of a network</h2><span id='topic+degree.dist'></span>

<h3>Description</h3>

<p>Plot the degree distribution of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree.dist(net, cumulative = TRUE, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.dist_+3A_net">net</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="degree.dist_+3A_cumulative">cumulative</code></td>
<td>
<p>A logical index asking whether a cumulative distribution should be returned.</p>
</td></tr>
<tr><td><code id="degree.dist_+3A_log">log</code></td>
<td>
<p>A logical index asking whether a logarithm-scaled distribution should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the degree distribution of a network.
</p>


<h3>Value</h3>

<p>A .gif plot.
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)

## Plot the standard degree distribution of x.
degree.dist(x, cumulative = FALSE, log = FALSE)

## Plot the degree distribution of x, with a logarithm scale.
degree.dist(x, cumulative = FALSE, log = TRUE)

## Plot the cumulative degree distribution of x.
degree.dist(x, cumulative = TRUE, log = FALSE)

## Plot the cumulative degree distribution of x, with a logarithm scale.
degree.dist(x, cumulative = TRUE, log = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='degree.hist'>Histogram of the degree distribution of a network</h2><span id='topic+degree.hist'></span>

<h3>Description</h3>

<p>Plot the histogram of all degrees of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree.hist(g, breaks = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.hist_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="degree.hist_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of cells for the histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the histogram of all degrees of a network.
</p>


<h3>Value</h3>

<p>A .gif plot.
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.05)
degree.hist(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='draw.net'>Plot of a small network</h2><span id='topic+draw.net'></span>

<h3>Description</h3>

<p>Plot a small network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.net(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.net_+3A_net">net</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot a small network.
</p>


<h3>Value</h3>

<p>A .gif plot.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.ring.lattice(12,4)
draw.net(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='from.adjacency'>Adjacency Matrix to <code>fastnet</code></h2><span id='topic+from.adjacency'></span>

<h3>Description</h3>

<p>Transform an adjacency matrix to an ego-centric list form used in <code>fastnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from.adjacency(adj.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from.adjacency_+3A_adj.mat">adj.mat</code></td>
<td>
<p>The input adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Christian Llano.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj.mat &lt;- matrix(c(0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0), nrow = 4, ncol = 4)
g &lt;- from.adjacency(adj.mat)

</code></pre>

<hr>
<h2 id='from.edgelist'>Edgelist to <code>fastnet</code></h2><span id='topic+from.edgelist'></span>

<h3>Description</h3>

<p>Transform an edgelist to an ego-centric list form used in <code>fastnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from.edgelist(edgelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from.edgelist_+3A_edgelist">edgelist</code></td>
<td>
<p>A 2-column data frame, in which the 1st column represents the start nodes, and the 2nd column represents the destination nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most network data repositories choose to store the data in an edgelist form. This function helps user to load it in <code>fastnet</code>.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edgelist &lt;- data.frame(from=c(1, 3, 2, 3, 3), to=c(4, 5, 6, 5, 7))
g &lt;- from.edgelist(edgelist)
</code></pre>

<hr>
<h2 id='from.igraph'>Transform an <code>igraph</code> object to a <code>fastnet</code> object</h2><span id='topic+from.igraph'></span>

<h3>Description</h3>

<p>Transform an <code>igraph</code> object to an ego-centric list form used in <code>fastnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from.igraph(net.igraph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from.igraph_+3A_net.igraph">net.igraph</code></td>
<td>
<p>The input <code>igraph</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("igraph")
net.igraph &lt;- erdos.renyi.game(100,0.1)
g &lt;- from.igraph(net.igraph)
## End(Not run)
</code></pre>

<hr>
<h2 id='from.statnet'><code>statnet</code>  to <code>fastnet</code></h2><span id='topic+from.statnet'></span>

<h3>Description</h3>

<p>Import a <code>statnet</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from.statnet(net.statnet, ncores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from.statnet_+3A_net.statnet">net.statnet</code></td>
<td>
<p>The input <code>statnet</code> object.</p>
</td></tr>
<tr><td><code id="from.statnet_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("ergm")
library("doParallel")
data("flo")
nflo &lt;- network(flo, loops = TRUE)
fflo &lt;- from.statnet(nflo)
## End(Not run)
</code></pre>

<hr>
<h2 id='get.neighbors'>Neighbors of an agent in a network</h2><span id='topic+get.neighbors'></span>

<h3>Description</h3>

<p>Presents all neighbors of a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.neighbors(net, NodeID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.neighbors_+3A_net">net</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="get.neighbors_+3A_nodeid">NodeID</code></td>
<td>
<p>The ID of the input node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neighbors of a node are nodes that directly connects to this node.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.ring.lattice(12,4)
get.neighbors(x,2)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.cluster.global'>Global Clustering Coefficient</h2><span id='topic+metric.cluster.global'></span>

<h3>Description</h3>

<p>Calculate the global clustering coefficient of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.cluster.global(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.cluster.global_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The global clustering coefficient measures the ratio of (closed) triples versus the total number of all possible triples in network <em>g</em>. <code>metric.cluster.global()</code> calculates the global clustering coefficient of <em>g</em>.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Wasserman, Stanley, and Katherine Faust. Social network analysis: Methods and applications. Vol. 8. Cambridge university press, 1994.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.cluster.global(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.cluster.mean'>Mean Local Clustering Coefficient</h2><span id='topic+metric.cluster.mean'></span>

<h3>Description</h3>

<p>Calculate the average local clustering coefficient of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.cluster.mean(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.cluster.mean_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local clustering coefficient of a node is the ratio of the triangles connected to the node and the triples centered on the <code>node.metric.cluster.mean()</code> calculates the (estimated) average clustering coefficient for all nodes in graph <em>g</em> with a justified error.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Wasserman, Stanley, and Katherine Faust. Social network analysis: Methods and applications. Vol. 8. Cambridge university press, 1994.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(n = 1000, ncores = 3, p =  0.06)
metric.cluster.mean(x) 
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.cluster.median'>Median Local Clustering Coefficient</h2><span id='topic+metric.cluster.median'></span>

<h3>Description</h3>

<p>Calculate the median local clustering coefficient of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.cluster.median(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.cluster.median_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local clustering coefficient of a node is the ratio of the triangles connected to the node and the triples centered on the <code>node.metric.cluster.median()</code> calculates the (estimated) median clustering coefficient for all nodes in graph <em>g</em> with a justified error.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Wasserman, Stanley, and Katherine Faust. Social network analysis: Methods and applications. Vol. 8. Cambridge university press, 1994.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.1)
metric.cluster.median(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.effective'>Effective Degree</h2><span id='topic+metric.degree.effective'></span>

<h3>Description</h3>

<p>Calculate the effective degree of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.effective(g, effective_rate = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.effective_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.degree.effective_+3A_effective_rate">effective_rate</code></td>
<td>
<p>The effective rate (0.9 is set by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective degree
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
metric.degree.effective(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.entropy'>Degree Entropy</h2><span id='topic+metric.degree.entropy'></span>

<h3>Description</h3>

<p>Calculate the degree entropy of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.entropy(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.entropy_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the degree entropy of graph g, i.e. </p>
<p style="text-align: center;"><code class="reqn">Entropy(g) = - \sum_{i=1}^{n} i*\log _2(i)</code>
</p>



<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Anand, Kartik, and Ginestra Bianconi. &quot;Entropy measures for networks: Toward an information theory of complex topologies.&quot; Physical Review E 80, no. 4 (2009): 045102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.degree.entropy(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.max'>Maximal Degree</h2><span id='topic+metric.degree.max'></span>

<h3>Description</h3>

<p>Calculate the maximal degree of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.max(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.max_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximal degree.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
metric.degree.max(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.max.efficient'>Efficient Maximal Degree</h2><span id='topic+metric.degree.max.efficient'></span>

<h3>Description</h3>

<p>Calculate the efficient maximal degree of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.max.efficient(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.max.efficient_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The efficient maximal degree is the 90
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.degree.max.efficient(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.mean'>Mean Degree</h2><span id='topic+metric.degree.mean'></span>

<h3>Description</h3>

<p>Calculate the mean degree of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.mean(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.mean_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean degree is the average value of the degrees of all nodes in graph g.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.degree.mean(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.median'>Median Degree</h2><span id='topic+metric.degree.median'></span>

<h3>Description</h3>

<p>Calculate the median degree of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.median(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.median_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The median degree is the median value of the degrees of all nodes in graph g.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.degree.median(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.min'>Minimal Degree</h2><span id='topic+metric.degree.min'></span>

<h3>Description</h3>

<p>Calculate the minimal degree of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.min(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.min_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimal degree.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
metric.degree.min(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.degree.sd'>Standard Deviation of Degree Distribution</h2><span id='topic+metric.degree.sd'></span>

<h3>Description</h3>

<p>Calculate the standard deviation of all degrees of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.degree.sd(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.degree.sd_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard deviation of all degrees of a network.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
metric.degree.sd(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.distance.apl'>Average Path Length</h2><span id='topic+metric.distance.apl'></span>

<h3>Description</h3>

<p>Calculate the average path length of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.distance.apl(
  Network,
  probability = 0.95,
  error = 0.03,
  Cores = detectCores(),
  full.apl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.distance.apl_+3A_network">Network</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.distance.apl_+3A_probability">probability</code></td>
<td>
<p>The confidence level probability.</p>
</td></tr>
<tr><td><code id="metric.distance.apl_+3A_error">error</code></td>
<td>
<p>The sampling error.</p>
</td></tr>
<tr><td><code id="metric.distance.apl_+3A_cores">Cores</code></td>
<td>
<p>Number of cores to use in the computations. By default uses <em>parallel</em> function <code>detecCores()</code>.</p>
</td></tr>
<tr><td><code id="metric.distance.apl_+3A_full.apl">full.apl</code></td>
<td>
<p>It will calculate the sampling version by default. If it is set to true,
the population APL will be calculated and the rest of the parameters will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average path length (APL) is the average shortest path lengths of all
pairs of nodes in graph <em>Network</em>. <code>metric.distance.apl</code> calculates
the population APL and estimated APL of graph g with a sampling error set by the user.
</p>
<p>The calculation uses a parallel load balancing approach,
distributing jobs equally among the cores defined by the user.
</p>


<h3>Value</h3>

<p>A real value.
</p>


<h3>Author(s)</h3>

<p>Luis Castro, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>E. W. Dijkstra. 1959. A note on two problems in connexion with graphs. Numer. Math. 1, 1 (December 1959), 269-271.
</p>
<p>Castro L, Shaikh N. Estimation of Average Path Lengths
of Social Networks via Random Node Pair Sampling.
Department of Industrial Engineering, University of Miami. 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Default function
x &lt;-  net.erdos.renyi.gnp(1000,0.01)
metric.distance.apl(x)
##Population APL
metric.distance.apl(x, full.apl=TRUE)
##Sampling at 99% level with an error of 10% using 5 cores
metric.distance.apl(Network = x, probability=0.99, error=0.1, Cores=5)

## End(Not run)

</code></pre>

<hr>
<h2 id='metric.distance.diameter'>Diameter</h2><span id='topic+metric.distance.diameter'></span>

<h3>Description</h3>

<p>Calculate the diameter of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.distance.diameter(
  Network,
  probability = 0.95,
  error = 0.03,
  Cores = detectCores(),
  full = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.distance.diameter_+3A_network">Network</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.distance.diameter_+3A_probability">probability</code></td>
<td>
<p>The confidence level probability</p>
</td></tr>
<tr><td><code id="metric.distance.diameter_+3A_error">error</code></td>
<td>
<p>The sampling error</p>
</td></tr>
<tr><td><code id="metric.distance.diameter_+3A_cores">Cores</code></td>
<td>
<p>Number of cores to use in the computations. By default uses <em>parallel</em> function <code>detecCores()</code>.</p>
</td></tr>
<tr><td><code id="metric.distance.diameter_+3A_full">full</code></td>
<td>
<p>It will calculate the popular full version by default.
If it is set to FALSE, the estimated diameter will be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diameter is the largest shortest path lengths of all pairs of nodes in
graph <em>Network</em>.
</p>
<p><code>metric.distance.diameter</code> calculates the (estimated) diameter
of graph <em>Network</em> with a justified error.
</p>


<h3>Value</h3>

<p>A real value.
</p>


<h3>Author(s)</h3>

<p>Luis Castro, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>E. W. Dijkstra. 1959. A note on two problems in connexion with graphs. Numer. Math. 1, 1 (December 1959), 269-271.
</p>
<p>Castro L, Shaikh N. Estimation of Average Path Lengths of Social
Networks via Random Node Pair Sampling. Department of Industrial Engineering, University of Miami. 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Default function
x &lt;-  net.erdos.renyi.gnp(1000,0.01)
metric.distance.diameter(x)
##Population APL
metric.distance.diameter(x, full=TRUE)
##Sampling at 99% level with an error of 10% using 5 cores
metric.distance.diameter(Network = x, probability=0.99, error=0.1, Cores=5)

## End(Not run)

</code></pre>

<hr>
<h2 id='metric.distance.effdia'>Effective Diameter</h2><span id='topic+metric.distance.effdia'></span>

<h3>Description</h3>

<p>Calculate the effective diameter of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.distance.effdia(
  Network,
  probability = 0.95,
  error = 0.03,
  effective_rate = 0.9,
  Cores = detectCores(),
  full = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.distance.effdia_+3A_network">Network</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.distance.effdia_+3A_probability">probability</code></td>
<td>
<p>The confidence level probability</p>
</td></tr>
<tr><td><code id="metric.distance.effdia_+3A_error">error</code></td>
<td>
<p>The sampling error</p>
</td></tr>
<tr><td><code id="metric.distance.effdia_+3A_effective_rate">effective_rate</code></td>
<td>
<p>The effective rate (by default it is set to be 0.9)</p>
</td></tr>
<tr><td><code id="metric.distance.effdia_+3A_cores">Cores</code></td>
<td>
<p>Number of cores to use in the computations. By default uses <em>parallel</em> function <code>detecCores()</code>.</p>
</td></tr>
<tr><td><code id="metric.distance.effdia_+3A_full">full</code></td>
<td>
<p>It will calculate the popular full version by default.
If it is set to FALSE, the estimated diameter will be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diameter is the largest shortest path lengths of all pairs of nodes in
graph <em>Network</em>. <code>metric.distance.diameter</code> calculates the (estimated)
diameter of graph <em>Network</em> with a justified error.
</p>


<h3>Value</h3>

<p>A real value.
</p>


<h3>Author(s)</h3>

<p>Luis Castro, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Dijkstra EW. A note on two problems in connexion with
graphs:(numerische mathematik, _1 (1959), p 269-271). 1959.
</p>
<p>Castro L, Shaikh N. Estimation of Average Path Lengths of Social
Networks via Random Node Pair Sampling. Department of Industrial Engineering, University of Miami. 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Default function
x &lt;-  net.erdos.renyi.gnp(1000,0.01)
metric.distance.effdia(x)
##Population APL
metric.distance.effdia(x, full=TRUE)
##Sampling at 99% level with an error of 10% using 5 cores
metric.distance.effdia(Network = x, probability=0.99, error=0.1, Cores=5)

## End(Not run)

</code></pre>

<hr>
<h2 id='metric.distance.meanecc'>Mean Eccentricity</h2><span id='topic+metric.distance.meanecc'></span>

<h3>Description</h3>

<p>Calculate the mean eccentricity of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.distance.meanecc(g, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.distance.meanecc_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.distance.meanecc_+3A_p">p</code></td>
<td>
<p>The sampling probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean eccentricities of all nodes in graph <em>g</em>. Calculates the (estimated) mean eccentricity of graph <em>g</em> with a justified error.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>West, Douglas Brent. Introduction to graph theory. Vol. 2. Upper Saddle River: Prentice Hall, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.distance.meanecc(x, 0.01)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.distance.medianecc'>Median Eccentricity</h2><span id='topic+metric.distance.medianecc'></span>

<h3>Description</h3>

<p>Calculate the (estimated) median eccentricity of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.distance.medianecc(g, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.distance.medianecc_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.distance.medianecc_+3A_p">p</code></td>
<td>
<p>The sampling probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is the median eccentricities of all nodes in graph <em>g</em>.
<code>metric.distance.medianecc</code> calculates the (estimated) median eccentricity of graph <em>g</em> with a justified error.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>West, Douglas Brent. Introduction to graph theory. Vol. 2. Upper Saddle River: Prentice hall, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.distance.medianecc(x, 0.01)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.distance.mpl'>Median Path Length</h2><span id='topic+metric.distance.mpl'></span>

<h3>Description</h3>

<p>Calculate the median path length (MPL) of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.distance.mpl(
  Network,
  probability = 0.95,
  error = 0.03,
  Cores = detectCores(),
  full = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.distance.mpl_+3A_network">Network</code></td>
<td>
<p>The input network.</p>
</td></tr>
<tr><td><code id="metric.distance.mpl_+3A_probability">probability</code></td>
<td>
<p>The confidence level probability</p>
</td></tr>
<tr><td><code id="metric.distance.mpl_+3A_error">error</code></td>
<td>
<p>The sampling error</p>
</td></tr>
<tr><td><code id="metric.distance.mpl_+3A_cores">Cores</code></td>
<td>
<p>Number of cores to use in the computations. By default <code>detecCores()</code> from <em>parallel</em>.</p>
</td></tr>
<tr><td><code id="metric.distance.mpl_+3A_full">full</code></td>
<td>
<p>It calculates the sampling version by default. If it is set to true, the population MPL will be calculated and the rest of the parameters will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The median path length (MPL) is the median shortest path lengths of all pairs of nodes in <em>Network</em>.
<em>metric.distance.mpl(g)</em> calculates the population MPL OR estimated MPL of network g with a sampling error set by the user. The calculation uses a parallel load balancing approach, distributing jobs equally among the cores defined by the user.
</p>


<h3>Value</h3>

<p>A real integer
</p>


<h3>Author(s)</h3>

<p>Luis Castro, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>E. W. Dijkstra. 1959. A note on two problems in connexion with graphs. Numer. Math. 1, 1 (December 1959), 269-271.
</p>
<p>Castro L, Shaikh N. Estimation of Average Path Lengths of Social Networks via Random Node Pair Sampling. Department of Industrial Engineering, University of Miami. 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Default function
x &lt;-  net.erdos.renyi.gnp(1000,0.01)
metric.distance.mpl(x)
##Population MPL
metric.distance.mpl(x, full=TRUE)
##Sampling at 99% level with an error of 10% using 5 cores
metric.distance.mpl(Network = x, probability=0.99, error=0.1, Cores=5)

## End(Not run)

</code></pre>

<hr>
<h2 id='metric.eigen.mean'>Mean Eigenvalue Centrality</h2><span id='topic+metric.eigen.mean'></span>

<h3>Description</h3>

<p>Calculate the mean eigenvalue centrality of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.eigen.mean(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.eigen.mean_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>metric.eigen.mean</code> calculates the mean eigenvalue centrality score of graph <em>g</em>.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Bonacich, Phillip, and Paulette Lloyd. &quot;Eigenvector-like measures of centrality for asymmetric relations.&quot; Social networks 23, no. 3 (2001): 191-201.
</p>
<p>Borgatti, Stephen P. &quot;Centrality and network flow.&quot; Social networks 27, no. 1 (2005): 55-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.eigen.mean(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.eigen.median'>Median Eigenvalue Centrality</h2><span id='topic+metric.eigen.median'></span>

<h3>Description</h3>

<p>Calculate the median eigenvalue centrality of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.eigen.median(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.eigen.median_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>metric.eigen.median</code> calculates the median eigenvalue centrality score of graph <em>g</em>.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Bonacich, Phillip, and Paulette Lloyd. &quot;Eigenvector-like measures of centrality for asymmetric relations.&quot; Social networks 23, no. 3 (2001): 191-201.
</p>
<p>Borgatti, Stephen P. &quot;Centrality and network flow.&quot; Social networks 27, no. 1 (2005): 55-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.eigen.median(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.eigen.value'>Eigenvalue Score</h2><span id='topic+metric.eigen.value'></span>

<h3>Description</h3>

<p>Calculate the eigenvalue centrality score of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.eigen.value(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.eigen.value_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>metric.eigen.value</code> calculates the eigenvalue centrality score of graph <em>g</em>.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Bonacich, Phillip, and Paulette Lloyd. &quot;Eigenvector-like measures of centrality for asymmetric relations.&quot; Social networks 23, no. 3 (2001): 191-201.
</p>
<p>Borgatti, Stephen P. &quot;Centrality and network flow.&quot; Social networks 27, no. 1 (2005): 55-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.eigen.value(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='metric.graph.density'>Graph Density</h2><span id='topic+metric.graph.density'></span>

<h3>Description</h3>

<p>Calculate the density of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric.graph.density(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.graph.density_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the ratio of the number of edges and the number of possible edges.
</p>


<h3>Value</h3>

<p>A real constant.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.erdos.renyi.gnp(1000, 0.01)
metric.graph.density(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.barabasi.albert'>Barabasi-Albert Scale-free Graph</h2><span id='topic+net.barabasi.albert'></span>

<h3>Description</h3>

<p>Simulate a scale-free network using a preferential attachment mechanism (Barabasi and Albert, 1999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.barabasi.albert(n, m, ncores = detectCores(), d = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.barabasi.albert_+3A_n">n</code></td>
<td>
<p>Number of nodes of the network.</p>
</td></tr>
<tr><td><code id="net.barabasi.albert_+3A_m">m</code></td>
<td>
<p>Number of nodes to which a new node connects at each iteration.</p>
</td></tr>
<tr><td><code id="net.barabasi.albert_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores, by default <code>detectCores()</code> from <code>parallel</code>.</p>
</td></tr>
<tr><td><code id="net.barabasi.albert_+3A_d">d</code></td>
<td>
<p>A logical value determining whether the generated network is a directed or undirected (default) network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting with <em>m</em> nodes, the preferential attachment mechaism adds one node and <em>m</em> edges in each step. The edges will be placed with one end on the newly-added node and the other end on the existing nodes, according to probabilities that associate with their current degrees.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Luis Castro, Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Barabasi, A.- L. and Albert R. 1999. Emergence of scaling in random networks. Science, 286 509-512.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.barabasi.albert(1000, 20) # using default ncores 
## End(Not run)
</code></pre>

<hr>
<h2 id='net.caveman'>Caveman Network</h2><span id='topic+net.caveman'></span>

<h3>Description</h3>

<p>Simulate a (connected) caveman network of <em>m</em> cliques of size <em>k</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.caveman(m, k, ncores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.caveman_+3A_m">m</code></td>
<td>
<p>Number of cliques (or caves) in the network.</p>
</td></tr>
<tr><td><code id="net.caveman_+3A_k">k</code></td>
<td>
<p>Number of nodes per clique.</p>
</td></tr>
<tr><td><code id="net.caveman_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores, by default <code>detectCores()</code> from <code>parallel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (connected) caveman network is formed by connecting a set of isolated <em>k</em> - cliques
(or &quot;caves&quot;), neighbor by neighbor and head to toe,  using one edge that removed from each
clique such that all <em>m</em> cliques form a single circle (Watts 1999). The total number of nodes, i.e. <em>n</em>, in this network is given by <code class="reqn">k*m</code>.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Watts, D. J. Networks, Dynamics, and the Small-World Phenomenon. Amer. J. Soc. 105, 493-527, 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.caveman(50, 20) #using ncores by default 
## End(Not run)
</code></pre>

<hr>
<h2 id='net.cluster.affiliation'>Generate a cluster-affiliation graph</h2><span id='topic+net.cluster.affiliation'></span>

<h3>Description</h3>

<p>Generate a cluster-affiliation graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.cluster.affiliation(
  DEG,
  community_affiliation_alpha,
  community_affiliation_lambda,
  community_affiliation_min,
  community_size_alpha,
  community_size_lambda,
  community_size_min
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.cluster.affiliation_+3A_deg">DEG</code></td>
<td>
<p>Degree sequence.</p>
</td></tr>
<tr><td><code id="net.cluster.affiliation_+3A_community_affiliation_alpha">community_affiliation_alpha</code></td>
<td>
<p>First scaling parameter of the membership distribution.</p>
</td></tr>
<tr><td><code id="net.cluster.affiliation_+3A_community_affiliation_lambda">community_affiliation_lambda</code></td>
<td>
<p>Second scaling parameter of the membership distribution.</p>
</td></tr>
<tr><td><code id="net.cluster.affiliation_+3A_community_affiliation_min">community_affiliation_min</code></td>
<td>
<p>Minimal membership.</p>
</td></tr>
<tr><td><code id="net.cluster.affiliation_+3A_community_size_alpha">community_size_alpha</code></td>
<td>
<p>First scaling parameter of the cluster-size distribution.</p>
</td></tr>
<tr><td><code id="net.cluster.affiliation_+3A_community_size_lambda">community_size_lambda</code></td>
<td>
<p>Second scaling parameter of the cluster-size distribution.</p>
</td></tr>
<tr><td><code id="net.cluster.affiliation_+3A_community_size_min">community_size_min</code></td>
<td>
<p>Minimal size of a cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated network has multiple (overlapping) densely-connected clusters.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Dong X, Castro L, Shaikh N (2020). “fastnet: An R Package for Fast Simulation and Analysis of Large-Scale Social Networks.” Journal of Statistical Software, 96(7), 1-23. doi:10.18637/jss.v096.i07 (URL: https://doi.org/10.18637/jss.v096.i07)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DEG &lt;- sample(seq(5,15),100, replace=TRUE)
x &lt;- net.cluster.affiliation(DEG,
                             community_affiliation_alpha=1.5,
                             community_affiliation_lambda=10,
                             community_affiliation_min=1,
                             community_size_alpha=2.5,
                             community_size_lambda=40,
                             community_size_min=3)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.complete'>Complete Network</h2><span id='topic+net.complete'></span>

<h3>Description</h3>

<p>Simulate a complete (or full) network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.complete(n, ncores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.complete_+3A_n">n</code></td>
<td>
<p>Number of nodes of the network.</p>
</td></tr>
<tr><td><code id="net.complete_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores, by default <code>detectCores()</code> from <code>parallel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>n</em> nodes in the network are fully connected.
</p>
<p>Note that the input <em>n</em> should not excess 10000, for the sake of memory overflow.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.complete(1000) #using ncores by default
## End(Not run)
</code></pre>

<hr>
<h2 id='net.degree.constraint'>Generate a degree-constraint graph</h2><span id='topic+net.degree.constraint'></span>

<h3>Description</h3>

<p>Generate a degree-constraint graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.degree.constraint(DEG, c.alpha, c.min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.degree.constraint_+3A_deg">DEG</code></td>
<td>
<p>Degree sequence.</p>
</td></tr>
<tr><td><code id="net.degree.constraint_+3A_c.alpha">c.alpha</code></td>
<td>
<p>Scaling parameter of the community-size distribution.</p>
</td></tr>
<tr><td><code id="net.degree.constraint_+3A_c.min">c.min</code></td>
<td>
<p>Minimal size of a community.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated network has a pre-defined degree sequence with multiple (overlapping) communities.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Dong X, Castro L, Shaikh N (2020). “fastnet: An R Package for Fast Simulation and Analysis of Large-Scale Social Networks.” Journal of Statistical Software, 96(7), 1-23. doi:10.18637/jss.v096.i07 (URL: https://doi.org/10.18637/jss.v096.i07)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DEG &lt;- sample(seq(5,15),100, replace=TRUE)
x &lt;- net.degree.constraint(DEG, c.alpha=2, c.min=3)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.erdos.renyi.gnm'>Directed / Undirected Erdos-Renyi <code class="reqn">G(n,m)</code> network using a fix edge size.</h2><span id='topic+net.erdos.renyi.gnm'></span>

<h3>Description</h3>

<p>Simulate a random network with <em>n</em> nodes and <em>m</em> edges, according to Erdos and Renyi (1959).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.erdos.renyi.gnm(n, m, ncores = detectCores(), d = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.erdos.renyi.gnm_+3A_n">n</code></td>
<td>
<p>Number of nodes of the network.</p>
</td></tr>
<tr><td><code id="net.erdos.renyi.gnm_+3A_m">m</code></td>
<td>
<p>Number of edges of the network.</p>
</td></tr>
<tr><td><code id="net.erdos.renyi.gnm_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores, by default <code>detectCores()</code> from <code>parallel</code>.</p>
</td></tr>
<tr><td><code id="net.erdos.renyi.gnm_+3A_d">d</code></td>
<td>
<p>A logical value determining whether is a network directed (default) or indirected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this (simplest) random network, <em>m</em> edges are formed at random among <em>n</em> nodes.
When <code>d = TRUE</code> is a directed network.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Erdos, P. and Renyi, A., On random graphs, Publicationes Mathematicae 6, 290-297 (1959).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.erdos.renyi.gnm(1000, 100) 
## End(Not run)
</code></pre>

<hr>
<h2 id='net.erdos.renyi.gnp'>Directed / Undirected Erdos-Renyi <code class="reqn">G(n,p)</code> network</h2><span id='topic+net.erdos.renyi.gnp'></span>

<h3>Description</h3>

<p>Simulate a random network with <em>n</em> nodes and a link connecting probability of <em>p</em>, according to Edos and Renyi (1959).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.erdos.renyi.gnp(n, p, ncores = detectCores(), d = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.erdos.renyi.gnp_+3A_n">n</code></td>
<td>
<p>Number of nodes of the network.</p>
</td></tr>
<tr><td><code id="net.erdos.renyi.gnp_+3A_p">p</code></td>
<td>
<p>Connecting probability.</p>
</td></tr>
<tr><td><code id="net.erdos.renyi.gnp_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores, by default <code>detectCores()</code> from <code>parallel</code>.</p>
</td></tr>
<tr><td><code id="net.erdos.renyi.gnp_+3A_d">d</code></td>
<td>
<p>A logical value determining whether is a network directed (default) or indirected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this (simplest) random network, each edge is formed at random with a constant probability.
When <code>d = TRUE</code> is a directed network.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Luis Castro, Xu Dong, Nazrul Shaikh.
</p>


<h3>References</h3>

<p>Erdos, P. and Renyi, A., On random graphs, Publicationes Mathematicae 6, 290-297 (1959).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.erdos.renyi.gnp(1000, 0.01)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.holme.kim'>Holme-Kim Network</h2><span id='topic+net.holme.kim'></span>

<h3>Description</h3>

<p>Simulate a scale-free network with relatively high clustering, comparing to B-A networks (Holme and Kim, 1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.holme.kim(n, m, pt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.holme.kim_+3A_n">n</code></td>
<td>
<p>Number of nodes of the network.</p>
</td></tr>
<tr><td><code id="net.holme.kim_+3A_m">m</code></td>
<td>
<p>Number of nodes to which a new node connects at each iteration.</p>
</td></tr>
<tr><td><code id="net.holme.kim_+3A_pt">pt</code></td>
<td>
<p>Triad formation probability after each preferential attachment mechanism.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Holme-Kim network model is a simple extension of B-A model. It adds an additional step, called &quot;Triad formation&quot;, with the probability <em>pt</em> that compensates the low clustering in B-A networks.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Holme, Petter, and Beom Jun Kim. &quot;Growing scale-free networks with tunable clustering.&quot;Physical review E65, no. 2 (2002): 026107.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.holme.kim (1000, 20, 0.1)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.random.plc'>Random Network with a Power-law Degree Distribution that Has An Exponential Cutoff</h2><span id='topic+net.random.plc'></span>

<h3>Description</h3>

<p>Simulate a random network with a power-law degree distribution that has an exponential cutoff, according to Newman et al. (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.random.plc(n, cutoff, exponent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.random.plc_+3A_n">n</code></td>
<td>
<p>The number of the nodes in the network.</p>
</td></tr>
<tr><td><code id="net.random.plc_+3A_cutoff">cutoff</code></td>
<td>
<p>Exponential cutoff of the degree distribution of the network.</p>
</td></tr>
<tr><td><code id="net.random.plc_+3A_exponent">exponent</code></td>
<td>
<p>Exponent of the degree distribution of the network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated random network has a power-law degree distribution with an exponential degree cutoff.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Newman, Mark EJ, Steven H. Strogatz, and Duncan J. Watts. &quot;Random graphs with arbitrary degree distributions and their applications.&quot; Physical review E 64, no. 2 (2001): 026118.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.random.plc(1000, 10, 2)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.rewired.caveman'>Rewired (Connected) Caveman Network</h2><span id='topic+net.rewired.caveman'></span>

<h3>Description</h3>

<p>Simulate a rewired caveman network of m cliques of size k, and with a link rewiring probability p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.rewired.caveman(nc, m, p, seed = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.rewired.caveman_+3A_nc">nc</code></td>
<td>
<p>Number of cliques (or caves) in the network.</p>
</td></tr>
<tr><td><code id="net.rewired.caveman_+3A_m">m</code></td>
<td>
<p>Number of nodes per clique.</p>
</td></tr>
<tr><td><code id="net.rewired.caveman_+3A_p">p</code></td>
<td>
<p>Link rewiring probability.</p>
</td></tr>
<tr><td><code id="net.rewired.caveman_+3A_seed">seed</code></td>
<td>
<p>A random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rewired caveman network is built on the corresponding regular caveman network with m cliques of size k. Then the links in this caveman network are rewired with probability p.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Watts, D. J. Networks, Dynamics, and the Small-World Phenomenon. Amer. J. Soc. 105, 493-527, 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.rewired.caveman(50, 20, 0.0005)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.ring.lattice'><em>k</em> - regular ring lattice</h2><span id='topic+net.ring.lattice'></span>

<h3>Description</h3>

<p>Simulate a network with a <em>k</em> -regular ring lattice structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.ring.lattice(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.ring.lattice_+3A_n">n</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="net.ring.lattice_+3A_k">k</code></td>
<td>
<p>Number of edges per node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>n</em> nodes are placed on a circle and each node is connected to the nearest <em>k</em> neighbors.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Duncan J Watts and Steven H Strogatz: Collective dynamics of 'small world' networks, Nature 393, 440-442, 1998.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.ring.lattice(1000, 10)
## End(Not run)
</code></pre>

<hr>
<h2 id='net.watts.strogatz'>Watts-Strogatz Small-world Network</h2><span id='topic+net.watts.strogatz'></span>

<h3>Description</h3>

<p>Simulate a small-world network according to the model of Watts and Strogatz (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.watts.strogatz(n, k, re)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.watts.strogatz_+3A_n">n</code></td>
<td>
<p>The number of the nodes in the network (or lattice).</p>
</td></tr>
<tr><td><code id="net.watts.strogatz_+3A_k">k</code></td>
<td>
<p>Number of edges per node.</p>
</td></tr>
<tr><td><code id="net.watts.strogatz_+3A_re">re</code></td>
<td>
<p>Rewiring probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formation of Watts-Strogatz network starts with a ring lattice with <em>n</em> nodes and <em>k</em> edges per node, then each edge is rewired at random with probability <em>re</em>.
</p>


<h3>Value</h3>

<p>A list containing the nodes of the network and their respective neighbors.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh
</p>


<h3>References</h3>

<p>Duncan J. Watts and Steven H. Strogatz: Collective dynamics of 'small world' networks, Nature 393, 440-442, 1998.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- net.watts.strogatz(1000, 10, 0.05)
## End(Not run)
</code></pre>

<hr>
<h2 id='preview.deg'>Preview of the degree distribution of a network</h2><span id='topic+preview.deg'></span>

<h3>Description</h3>

<p>Present the first 10 degrees of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview.deg(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preview.deg_+3A_g">g</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Present the first 10 degrees of a network.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.ring.lattice(12,4)
preview.deg(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='preview.net'>Preview of a network</h2><span id='topic+preview.net'></span>

<h3>Description</h3>

<p>Present the first 10 ego-centric lists of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview.net(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preview.net_+3A_net">net</code></td>
<td>
<p>The input network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the connection condition of the first 10 nodes in a network.
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Xu Dong, Nazrul Shaikh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;-  net.ring.lattice(12,4)
preview.net(x)
## End(Not run)
</code></pre>

<hr>
<h2 id='to.edgelist'><code>fastnet</code> to edgelist</h2><span id='topic+to.edgelist'></span>

<h3>Description</h3>

<p>Coerce a fastnet object to edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.edgelist(network, ncores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.edgelist_+3A_network">network</code></td>
<td>
<p>A fastnet object.</p>
</td></tr>
<tr><td><code id="to.edgelist_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-column list with each row representing an edge, from source to destination
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- net.erdos.renyi.gnp(100, 0.1)
el &lt;- to.edgelist(g)
## End(Not run)
</code></pre>

<hr>
<h2 id='to.igraph'><code>fastnet</code> to <code>igraph</code></h2><span id='topic+to.igraph'></span>

<h3>Description</h3>

<p>Coerce a fastnet object to an igraph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.igraph(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.igraph_+3A_g">g</code></td>
<td>
<p>A fastnet object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>

<hr>
<h2 id='to.tidygraph'><code>fastnet</code> to <code>tidygraph</code></h2><span id='topic+to.tidygraph'></span>

<h3>Description</h3>

<p>Coerce a fastnet object to a tidygraph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.tidygraph(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.tidygraph_+3A_g">g</code></td>
<td>
<p>A fastnet object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidygraph object
</p>


<h3>Author(s)</h3>

<p>Xu Dong
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
