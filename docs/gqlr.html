<!DOCTYPE html><html><head><title>Help for package gqlr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gqlr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_R6'><p>As R6</p></a></li>
<li><a href='#ErrorList'><p>ErrorList</p></a></li>
<li><a href='#execute_request'><p>Execute GraphQL server response</p></a></li>
<li><a href='#gqlr_schema'><p>Create Schema definitions</p></a></li>
<li><a href='#parse_ast'><p>Parse AST</p></a></li>
<li><a href='#Schema'><p>GraphQL Schema object</p></a></li>
<li><a href='#server'><p>Run basic GraphQL server</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'GraphQL' Server in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Server implementation of 'GraphQL' <a href="http://graphql.github.io/graphql-spec/">http://graphql.github.io/graphql-spec/</a>,
    a query language originally created by Facebook for describing data requirements on complex application
    data models.  Visit <a href="http://graphql.org">http://graphql.org</a> to learn more about 'GraphQL'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schloerke/gqlr">https://github.com/schloerke/gqlr</a>,
<a href="http://graphql.github.io/graphql-spec/">http://graphql.github.io/graphql-spec/</a>, <a href="http://graphql.org">http://graphql.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schloerke/gqlr/issues">https://github.com/schloerke/gqlr/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphql (&ge; 1.3), magrittr, pryr, R6, jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plumber, roxygen2 (&ge; 7.0.0), testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AAA-utils.R' 'R6--aaa-utils.R' 'S3--aaa-setup.R'
'R6--definition.R' 'R6-3.1.1-types-scalars.R'
'R6-6.1-executing-requests.R' 'R6-Schema.R' 'R6z-from-json.R'
'graphql_json.R' 'R6-3.2-directives.R' 'gqlr_schema.R'
'R6-4-introspection.R' 'R6-6.2-executing-operations.R'
'R6-6.3-executing-selection-sets.R' 'R6-6.4-executing-fields.R'
'R6-7-response.R' 'R6-ErrorList.R' 'R6-ObjectHelpers.R'
'R6-Result.R' 'R6-VariableValdationHelper.R'
'S3-3.1.2.3-validation-object-type.R' 'S3-str.R'
'gqlr-package.R' 'server.R' 'upgrade_query_remove_fragments.R'
'validation-arguments.R' 'validation-input-coercion.R'
'validation-selection-set-can-merge.R' 'validation-query.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-02 16:03:59 UTC; barret</td>
</tr>
<tr>
<td>Author:</td>
<td>Barret Schloerke [aut, cre],
  Ryan Hafen [ths],
  GraphQL [cph] (http://graphql.github.io/graphql-spec/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barret Schloerke &lt;schloerke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-02 16:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_R6'>As R6</h2><span id='topic+as_R6'></span>

<h3>Description</h3>

<p>Debug method that strips all gqlr classes and assigns the class as <code>'R6'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_R6(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_R6_+3A_x">x</code></td>
<td>
<p>any object. If it inherits <code>'R6'</code>, then the class of <code>x</code> is set to <code>'R6'</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Int &lt;- getFromNamespace("Int", "gqlr")$clone()
print(Int)
print(as_R6(Int))
</code></pre>

<hr>
<h2 id='ErrorList'>ErrorList</h2><span id='topic+ErrorList'></span>

<h3>Description</h3>

<p>Handles all errors that occur during query validation. This object is returned from execute request function (<code>ans &lt;- <a href="#topic+execute_request">execute_request</a>(query, schema)</code>) under the field 'error_list' (<code>ans$error_list</code>).
</p>


<h3>Usage</h3>

<pre>answer &lt;- execute_request(my_request, my_schema)
answer$error_list
</pre>


<h3>Initialize</h3>


<dl>
<dt>verbose</dt><dd><p>boolean that determines if errors will be printed on occurrence.  Defaults to <code>TRUE</code></p>
</dd>
</dl>



<h3>Details</h3>

<p><code>$n</code> count of errors received
</p>
<p><code>$errors</code> list of error information
</p>
<p><code>$verbose</code> boolean that determines of errors are printed when received
</p>
<p><code>$has_no_errors()</code> helper method to determine if there are no errors
</p>
<p><code>$has_any_errors()</code> helper method to determine if there are any errors
</p>
<p><code>$get_sub_source(loc)</code> helper method to display a subsection of source text given Location information
</p>
<p><code>$add(rule_code, ...)</code> add a new error according to the <code>rule_code</code> provided. Remaining arguments are passed directly to <code>paste(..., sep = "")</code> with extra error rule information
</p>
<p><code>$.format(...)</code> formats the error list into user friendly text. Remaining arguments are ignored
</p>
<p><code>$print(...)</code> prints the error list by calling <code>self$format(...)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>error_list &lt;- ErrorList$new()
error_list
error_list$has_any_errors() # FALSE
error_list$has_no_errors() # TRUE

error_list$add("3.1.1", "Multiple part", " error about Scalars")
error_list
error_list$has_any_errors() # TRUE
error_list$has_no_errors() # FALSE

</code></pre>

<hr>
<h2 id='execute_request'>Execute GraphQL server response</h2><span id='topic+execute_request'></span>

<h3>Description</h3>

<p>Executes a GraphQL server request with the provided request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execute_request(
  request,
  schema,
  operation_name = NULL,
  variables = list(),
  initial_value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execute_request_+3A_request">request</code></td>
<td>
<p>a valid GraphQL string</p>
</td></tr>
<tr><td><code id="execute_request_+3A_schema">schema</code></td>
<td>
<p>a character string (to be used along side <code>initial_value</code>)
or a schema object created from <code><a href="#topic+gqlr_schema">gqlr_schema</a></code></p>
</td></tr>
<tr><td><code id="execute_request_+3A_operation_name">operation_name</code></td>
<td>
<p>name of request operation to execute. If not value is
provided it will use the operation in the request string. If more than one
operations exist, an error will be produced.  See
<a href="https://graphql.github.io/graphql-spec/October2016/#GetOperation()">https://graphql.github.io/graphql-spec/October2016/#GetOperation()</a></p>
</td></tr>
<tr><td><code id="execute_request_+3A_variables">variables</code></td>
<td>
<p>a named list containing variable values.
<a href="https://graphql.github.io/graphql-spec/October2016/#sec-Language.Variables">https://graphql.github.io/graphql-spec/October2016/#sec-Language.Variables</a></p>
</td></tr>
<tr><td><code id="execute_request_+3A_initial_value">initial_value</code></td>
<td>
<p>default value for executing requests.  This value can
either be provided and/or combined with the resolve method of the query
root type or mutation root type.  The value provided should be a named list
of the field name (key) and a value matching that field name type.  The
value may be a function that returns a value of the field name type.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://graphql.github.io/graphql-spec/October2016/#sec-Execution">https://graphql.github.io/graphql-spec/October2016/#sec-Execution</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# bare bones
schema &lt;- gqlr_schema("
  type Person {
    name: String
    friends: [Person]
  }
  schema {
    query: Person
  }
")

data &lt;- list(
  name = "Barret",
  friends = list(
    list(name = "Ryan", friends = list(list(name = "Bill"), list(name = "Barret"))),
    list(name = "Bill", friends = list(list(name = "Ryan")))
  )
)

ans &lt;- execute_request("{ name }", schema, initial_value = data)
ans$as_json()

execute_request("
  {
    name
    friends {
      name
      friends {
        name
        friends {
          name
        }
      }
    }
  }",
  schema,
  initial_value = data
)$as_json()






# Using resolve method to help with recursion
people &lt;- list(
  "id_Barret" = list(name = "Barret", friends = list("id_Ryan", "id_Bill")),
  "id_Ryan" = list(name = "Ryan", friends = list("id_Barret", "id_Bill")),
  "id_Bill" = list(name = "Bill", friends = list("id_Ryan"))
)
schema &lt;- gqlr_schema("
    type Person {
      name: String
      friends: [Person]
    }
    schema {
      query: Person
    }
  ",
  Person = list(
    resolve = function(name, schema, ...) {
      if (name %in% names(people)) {
        people[[name]]
      } else {
        NULL
      }
    }
  )
)

ans &lt;- execute_request("{ name }", schema, initial_value = "id_Barret")
ans$as_json()

execute_request("
  {
    name
    friends {
      name
      friends {
        name
        friends {
          name
        }
      }
    }
  }",
  schema,
  initial_value = "id_Barret"
)$as_json()

</code></pre>

<hr>
<h2 id='gqlr_schema'>Create Schema definitions</h2><span id='topic+gqlr_schema'></span>

<h3>Description</h3>

<p>Creates a Schema object from the defined GraphQL string and
inserts the provided descriptions, resolve methods, resolve_type methods
into the appropriate place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gqlr_schema(schema, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gqlr_schema_+3A_schema">schema</code></td>
<td>
<p>GraphQL schema string or Schema object</p>
</td></tr>
<tr><td><code id="gqlr_schema_+3A_...">...</code></td>
<td>
<p>named lists of information to help produce the schema definition.
See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ... should be named arguments whose values are lists of
information.  What information is needed for each type is described below.
</p>
<p>ScalarTypeDefinition: </p>
 <dl>
<dt>resolve</dt><dd><p>function with two
parameters: <code>x</code> (the raw to be parsed, such as 5.0) and <code>schema</code>
(the full Schema definition). Should return a parsed value</p>
</dd>
<dt>description</dt><dd><p>(optional) single character value that describes the
Scalar definition</p>
</dd> <dt>parse_ast</dt><dd><p>(optional) function with two
parameters: <code>obj</code> (a GraphQL wrapped raw value, such as an object of
class IntValue with value 5) and <code>schema</code> (the full Schema
definition).  If the function returns <code>NULL</code> then the AST could not be
parsed.</p>
</dd> </dl>

<p>EnumTypeDefinition: </p>
 <dl>
<dt>resolve</dt><dd><p>(optional) function with two
parameters: <code>x</code> and <code>schema</code> (the full Schema definition). Should
return the value <code>x</code> represents, such as the Star Wars Episode enum
value &quot;4&quot; could represent Episode &quot;NEWHOPE&quot;. By default,
EnumTypeDefinitions will return the current value.</p>
</dd>
<dt>description</dt><dd><p>(optional) single character value that describes the
Enum definition</p>
</dd> <dt>values</dt><dd><p>(optional) named list of enum value
descriptions. Such as <code>values = list(ENUMA = "description for ENUMA",
  ENUMZ = "description for ENUMZ")</code></p>
</dd> </dl>

<p>ObjectTypeDefinition: </p>
 <dl>
<dt>resolve</dt><dd><p>function with two
parameters: <code>x</code> (place holder value to be expanded into a named list)
and <code>schema</code> (the full Schema definition). By using the resolve
method, recursive relationships, such as friends, can easily be handled.
The resolve function should return a fully named list of all the fields the
definition defines.  Missing fields are automatically interpreted as
<code>NULL</code>.
</p>
<p>Values in the returned list may be a function of the form
<code>function(obj, args, schema) {...}</code>.  This allows for fields to be
determined dynamically and lazily. See how <code>add_human</code> makes a field
for <code>totalCredits</code>, while the <code>add_droid</code> pre computes the
information.</p>
</dd> <dt>description</dt><dd><p>(optional) single character value that
describes the object</p>
</dd> <dt>fields</dt><dd><p>(optional) named list of field
descriptions. Such as <code>fields = list(fieldA = "description for field
  A", fieldB = "description for field B")</code></p>
</dd> </dl>

<p>InterfaceTypeDefinition and UnionTypeDefinition: </p>

<dl>
<dt>resolve_type</dt><dd><p>function with two parameters: <code>x</code> (a pre-resolved
object value) and <code>schema</code> (the full Schema definition). This function
is required to determine which object type is being used.
<code>resolve_type</code> is called before any ObjectTypeDefinition
<code>resolve</code> methods are called.</p>
</dd> <dt>description</dt><dd><p>(optional) single
character value that describes the object</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
library(magrittr)

## Set up data
add_human &lt;- function(human_data, id, name, appear, home, friend) {
  human &lt;- list(id = id, name = name, appearsIn = appear, friends = friend, homePlanet = home)
  # set up a function to be calculated if the field totalCredits is required
  human$totalCredits &lt;- function(obj, args, schema) {
    length(human$appearsIn)
  }
  human_data[[id]] &lt;- human
  human_data
}
add_droid &lt;- function(droid_data, id, name, appear, pf, friend) {
  droid &lt;- list(id = id, name = name, appearsIn = appear, friends = friend, primaryFunction = pf)
  # set extra fields manually
  droid$totalCredits &lt;- length(droid$appearsIn)
  droid_data[[id]] &lt;- droid
  droid_data
}

human_data &lt;- list() %&gt;%
  add_human("1000", "Luke Skywalker", c(4, 5, 6), "Tatooine", c("1002", "1003", "2000", "2001")) %&gt;%
  add_human("1002", "Han Solo",       c(4, 5, 6), "Corellia", c("1000", "1003", "2001")) %&gt;%
  add_human("1003", "Leia Organa",    c(4, 5, 6), "Alderaan", c("1000", "1002", "2000", "2001"))

droid_data &lt;- list() %&gt;%
  add_droid("2000", "C-3PO", c(4, 5, 6), "Protocol", c("1000", "1002", "1003", "2001")) %&gt;%
  add_droid("2001", "R2-D2", c(4, 5, 6), "Astromech", c("1000", "1002", "1003"))

all_characters &lt;- list() %&gt;% append(human_data) %&gt;% append(droid_data) %&gt;% print()
## End data set up



# Define the schema using GraphQL code
star_wars_schema &lt;- Schema$new()

"
enum Episode { NEWHOPE, EMPIRE, JEDI }
" %&gt;%
  gqlr_schema(
    Episode = list(
      resolve = function(episode_id, schema) {
        switch(as.character(episode_id),
          "4" = "NEWHOPE",
          "5" = "EMPIRE",
          "6" = "JEDI",
          "UNKNOWN_EPISODE"
        )
      }
    )
  ) -&gt;
episode_schema
# display the schema
episode_schema$get_schema()
# add the episode definitions to the Star Wars schema
star_wars_schema$add(episode_schema)


"
interface Character {
  id: String!
  name: String
  friends: [Character]
  appearsIn: [Episode]
}
" %&gt;%
  gqlr_schema(
    Character = list(
      resolve_type = function(id, schema) {
        if (id %in% names(droid_data)) {
          "Droid"
        } else {
          "Human"
        }
      }
    )
  ) -&gt;
character_schema
# print the Character schema with no extra formatting
character_schema$get_schema() %&gt;% format() %&gt;% cat("\n")
star_wars_schema$add(character_schema)


"
type Droid implements Character {
  id: String!
  name: String
  friends: [Character]
  appearsIn: [Episode]
  primaryFunction: String
}
type Human implements Character {
  id: String!
  name: String
  friends: [Character]
  appearsIn: [Episode]
  homePlanet: String
}
" %&gt;%
  gqlr_schema(
    Human = list(
      # Add a resolve method for type Human that takes in an id and returns the human data
      resolve = function(id, args, schema) {
        human_data[[id]]
      }
    ),
    Droid = list(
      # description for Droid
      description = "A mechanical creature in the Star Wars universe.",
      # Add a resolve method for type Droid that takes in an id and returns the droid data
      resolve = function(id, schema) {
        droid_data[[id]]
      }
    )
  ) -&gt;
human_and_droid_schema
human_and_droid_schema$get_schema()
star_wars_schema$add(human_and_droid_schema)


"
type Query {
  hero(episode: Episode): Character
  human(id: String!): Human
  droid(id: String!): Droid
}
# the schema type must be provided if a query or mutation is to be executed
schema {
  query: Query
}
" %&gt;%
  gqlr_schema(
    Query = function(null, schema) {
      list(
        # return a function for key 'hero'
        # the id will be resolved by the appropriate resolve() method of Droid or Human
        hero = function(obj, args, schema) {
          episode &lt;- args$episode
          if (identical(episode, 5) || identical(episode, "EMPIRE")) {
            "1000" # Luke Skywalker
          } else {
            "2001" # R2-D2
          }
        },
        # the id will be resolved by the Human resolve() method
        human = function(obj, args, schema) {
          args$id
        },
        # the id will be resolved by the Droid resolve() method
        droid = function(obj, args, schema) {
          args$id
        }
      )
    }
  ) -&gt;
schema_def
# print Schema with no extra formatting
schema_def$get_schema() %&gt;% format() %&gt;% cat("\n")
star_wars_schema$add(schema_def)


# view the final schema definitiion
star_wars_schema$get_schema()

</code></pre>

<hr>
<h2 id='parse_ast'>Parse AST</h2><span id='topic+parse_ast'></span>

<h3>Description</h3>

<p>This is a helper function for Scalars.  Given a particular kind and a resolve
function, it produces a function that will only parse values of a particular
kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_ast(kind, resolve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_ast_+3A_kind">kind</code></td>
<td>
<p>single character name of a class to parse</p>
</td></tr>
<tr><td><code id="parse_ast_+3A_resolve">resolve</code></td>
<td>
<p>function to parse the value if the kind is correct</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, <code>kind</code> is the same as the class of the Scalar.  When making a
new Scalar, parse_ast defaults to use the name of the scalar and the scalar's
parse value function.
</p>
<p>This function should only need to be used when defining a schema in
<code><a href="#topic+gqlr_schema">gqlr_schema</a>()</code>
</p>


<h3>Value</h3>

<p>function that takes <code>obj</code> and <code>schema</code> that will only parse
the value if the <code>kind</code> is inherited in the <code>obj</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_date_value &lt;- function(obj, schema) {
  as.Date(obj)
}
parse_ast("Date", parse_date_value)

# Example from Int scalar
parse_int &lt;- function(value, ...) {
  MAX_INT &lt;-  2147483647
  MIN_INT &lt;- -2147483648
  num &lt;- suppressWarnings(as.integer(value))
  if (!is.na(num)) {
    if (num &lt;= MAX_INT &amp;&amp; num &gt;= MIN_INT) {
      return(num)
    }
  }
  return(NULL)
}
parse_ast("IntValue", parse_int)
</code></pre>

<hr>
<h2 id='Schema'>GraphQL Schema object</h2><span id='topic+Schema'></span>

<h3>Description</h3>

<p>Manages a GraphQL schema definition.  A Schema can add more GraphQL type definitions, assist in determining definition types, retrieve particular definitions, and can combine with other schema definitions.
</p>
<p>Typically, Schema class objects are created using <code><a href="#topic+gqlr_schema">gqlr_schema</a></code>.  Creating a <code>Schema$new()</code> object should be reserved for when multiple Schema objects are combined.
</p>


<h3>Usage</h3>

<pre>
## using star_wars_schema from
# example(gqlr_schema)
star_wars_schema$get_schema()
star_wars_schema$is_enum("Episode") # TRUE
star_wars_schema$is_object("Episode") # FALSE
execute_request("{ hero { name } }", star_wars_schema)
</pre>


<h3>Initialize</h3>


<dl>
<dt>schema</dt><dd><p>Either a character GraphQL definition of a schema or another Schema object.  Extending methods and descriptions should be added with <code>gqlr_schema</code></p>
</dd></dl>
<p>.

</p>
<p>The initialize function will automatically add </p>

<ul>
<li><p>Scalars: Int, Float, String, Boolean
</p>
</li>
<li><p>Directives: @skip and @include
</p>
</li>
<li><p>Introspection Capabilities
</p>
</li></ul>



<h3>Details</h3>

<p><code>$add(obj)</code>: function to add either another Schema's definitions or Document of definitions.  <code>obj</code> must inherit class of either <code>'Schema'</code> or <code>'Document'</code>
</p>
<p><code>$is_scalar(name)</code>, <code>$is_enum(name)</code>, <code>$is_object(name)</code>, <code>$is_interface(name)</code>, <code>$is_union(name)</code>, <code>$is_input_object(name)</code>, <code>$is_directive(name)</code>, <code>$is_value(name)</code>: methods to determine if there is a definition of the corresponding definition type for the provided name.
</p>
<p><code>$get_scalar(name)</code>, <code>$get_enum(name)</code>, <code>$get_object(name)</code>, <code>$get_interface(name)</code>, <code>$get_union(name)</code>, <code>$get_input_object(name)</code>, <code>$get_directive(name)</code>, <code>$get_value(name)</code>: methods to retrieve a definition of the corresponding definition type for the provided name. If the object can't be found, <code>NULL</code> is returned. When printed, it quickly conveys all known information of the definition.  Due to the nature of R6 objects, definitions may be retrieved and altered after retrieval.  This is helpful for adding descriptions or resolve after the initialization.
</p>
<p><code>$get_scalars(name)</code>, <code>$get_enums(name)</code>, <code>$get_objects(name)</code>, <code>$get_interfaces(name)</code>, <code>$get_unions(name)</code>, <code>$get_input_objects(name)</code>, <code>$get_directives(name)</code>, <code>$get_values(name)</code>: methods to retrieve all definitions of the corresponding definition type.
</p>
<p><code>$get_type(name)</code>: method to retrieve an object of unknown type. If the object can't be found, <code>NULL</code> is returned. When printed, it quickly conveys all known information of the definition.
</p>
<p><code>$get_type(name)</code>: method to retrieve an object of unknown type. If the object can't be found, <code>NULL</code> is returned.
</p>
<p><code>$get_schema()</code>: method to retrieve full definition of schema. When printed, it quickly conveys all types in the schema.
</p>
<p><code>$get_query_object()</code>, <code>$get_mutation_object()</code>: helper method to retrieve the schema definition query or mutation object.
</p>
<p><code>$implements_interface()</code>: helper method to retrieve all objects who implement a particular interface.
</p>
<p><code>$is_valid</code>: boolean that determines if a Schema object has been validated.  All Schema objects are validated at the time of request execution.  The Schema will remain valid until new definitions are added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gqlr_schema">gqlr_schema</a></code>
</p>

<hr>
<h2 id='server'>Run basic GraphQL server</h2><span id='topic+server'></span>

<h3>Description</h3>

<p>Run a basic GraphQL server using plumber.  This server is provided to show basic interaction with GraphQL.  The server will run until the function execution is canceled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server(schema, port = 8000L, log = TRUE, initial_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="server_+3A_schema">schema</code></td>
<td>
<p>Schema object to use execute requests</p>
</td></tr>
<tr><td><code id="server_+3A_port">port</code></td>
<td>
<p>web port to serve the server from.  Set port to <code>NULL</code> to not run the plumber server and return it.</p>
</td></tr>
<tr><td><code id="server_+3A_log">log</code></td>
<td>
<p>boolean that determines if server logging is done.  Defaults to TRUE</p>
</td></tr>
<tr><td><code id="server_+3A_initial_value">initial_value</code></td>
<td>
<p>default value to use in <code><a href="#topic+execute_request">execute_request</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>server()</code> implements the basic necessities described in <a href="http://graphql.org/learn/serving-over-http/">http://graphql.org/learn/serving-over-http/</a>.  There are three routes implemented:
</p>

<dl>
<dt><code>'/'</code></dt><dd><p>GET. Returns a GraphQL formatted schema definition</p>
</dd>
<dt><code>'/graphql'</code></dt><dd><p>GET. Executes a query.  The parameter <code>'query'</code> (which contains a GraphQL formatted query string) must be included.  Optional parameters include: <code>'variables'</code> a JSON string containing a dictionary of variables (defaults to an empty named list), <code>'operationName'</code> name of the particular query operation to execute (defaults to NULL), and <code>'pretty'</code> boolean to determine if the response should be compact (FALSE, default) or expanded (TRUE)</p>
</dd>
<dt><code>'/graphql'</code></dt><dd><p>POST. Executes a query.  Must provide Content-Type of either 'application/json' or 'application/graphql'.
</p>
<p>If 'application/json' is provided, a named JSON list containing 'query', 'operationName' (optional, default = <code>NULL</code>), 'variables' (optional, default = list()) and 'pretty' (optional, default = <code>TRUE</code>).  The information will used just the same as the GET-'/graphql' route.
</p>
<p>If 'application/graphql' is provided, the POST body will be interpreted as the query string.  All other possible parameters will take on their default value.
</p>
</dd>
</dl>

<p>Using bash's curl, we can ask the server questions:
</p>
<pre> #R
  # load Star Wars schema from 'execute_request' example
  example(gqlr_schema)
  # run server
  server(star_wars_schema, port = 8000)
</pre>
<pre> #bash
  # GET Schema definition
  curl '127.0.0.1:8000/'

  ## POST for R2-D2 and his friends' names
  # defaults to parse as JSON
  curl --data '{"query":"{hero{name, friends { name }}}", "pretty": true}' '127.0.0.1:8000/graphql'
  # send json header
  curl --data '{"query":"{hero{name, friends { name }}}"}' '127.0.0.1:8000/graphql' --header "Content-Type:application/json"
  # send graphql header
  curl --data '{hero{name, friends { name }}}' '127.0.0.1:8000/graphql' --header "Content-Type:application/graphql"
  # use variables
  curl --data '{"query":"query Droid($someId: String!) {droid(id: $someId) {name, friends { name }}}", "variables": {"someId": "2001"}}' '127.0.0.1:8000/graphql'

  # GET R2-D2 and his friends' names
  curl '127.0.0.1:8000/graphql?query=
  # ... using a variable
  curl '127.0.0.1:8000/graphql?query=query

</pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
