<!DOCTYPE html><html><head><title>Help for package freesurferformats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freesurferformats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust.face.indices.to'><p>Adjust integer matrix to target min value.</p></a></li>
<li><a href='#annot.max.region.idx'><p>Get max region index of an fs.annot instance.</p></a></li>
<li><a href='#annot.unique'><p>Make the region names and indices unique across hemispheres for a parcellation.</p></a></li>
<li><a href='#assert.surface'><p>Stop unless surf is an fs.surface</p></a></li>
<li><a href='#bvsmp'><p>Create new bvsmp instance encoding morph data for Brainvoyager.</p></a></li>
<li><a href='#cdata'><p>Create CDATA element string from string.</p></a></li>
<li><a href='#check_data_and_settings_consistency'><p>Warn about common errors in combining data and datatype.</p></a></li>
<li><a href='#check.dtype.for.data'><p>Check whether the dtype is suitable for the data.</p></a></li>
<li><a href='#closest.vert.to.point'><p>Find vertex index closest to given query coordinate using Euclidean distance.</p></a></li>
<li><a href='#colortable.from.annot'><p>Extract color lookup table (LUT) from annotation.</p></a></li>
<li><a href='#coord.to.key'><p>Turn coordinate vector into string.</p></a></li>
<li><a href='#delete_all_opt_data'><p>Delete all data in the package cache.</p></a></li>
<li><a href='#doapply.transform.mtx'><p>Apply a spatial transformation matrix to the given coordinates.</p></a></li>
<li><a href='#download_opt_data'><p>Download optional data for the freesurferformats package.</p></a></li>
<li><a href='#euclidian.dist'><p>Compute Euclidean distance.</p></a></li>
<li><a href='#faces.quad.to.tris'><p>Convert quadrangular faces or polygons to triangular ones.</p></a></li>
<li><a href='#faces.tris.to.quad'><p>Convert tris faces to quad faces by simple merging.</p></a></li>
<li><a href='#fileopen.gz.or.not'><p>Get connection to a binary file, gz or not.</p></a></li>
<li><a href='#filepath.ends.with'><p>Check whether filepath ends with extension.</p></a></li>
<li><a href='#fixed.vec.format.int'><p>Write fixed width integers to one or several lines.</p></a></li>
<li><a href='#flip2D'><p>Flip a 2D matrix.</p></a></li>
<li><a href='#flip3D'><p>Flip a 3D array along an axis.</p></a></li>
<li><a href='#fread3'><p>Read 3-byte integer.</p></a></li>
<li><a href='#fs.get.morph.file.ext.for.format'><p>Determine morphometry file extension from format</p></a></li>
<li><a href='#fs.get.morph.file.format.from.filename'><p>Determine morphometry file format from filename</p></a></li>
<li><a href='#fs.patch'><p>Constructor for fs.patch</p></a></li>
<li><a href='#fs.surface.to.tmesh3d'><p>Get an rgl tmesh3d instance from a brain surface mesh.</p></a></li>
<li><a href='#fwrite3'><p>Write 3-byte integer.</p></a></li>
<li><a href='#get_opt_data_filepath'><p>Access a single file from the package cache by its file name.</p></a></li>
<li><a href='#get.dti.trk.endianness'><p>Determine endianness of TRK file.</p></a></li>
<li><a href='#get.slice.orientation'><p>Compute MGH orientation string and direction</p></a></li>
<li><a href='#gifti_writer'><p>Write data to a gifti file.</p></a></li>
<li><a href='#gifti_xml'><p>Get GIFTI XML representation of data.</p></a></li>
<li><a href='#gifti_xml_add_global_metadata'><p>Add metadata to GIFTI XML tree.</p></a></li>
<li><a href='#gifti_xml_write'><p>Write XML tree to a gifti file.</p></a></li>
<li><a href='#giftixml_add_labeltable_from_annot'><p>Add a label tabel from an annotation to a GIFTI XML tree.</p></a></li>
<li><a href='#giftixml_add_labeltable_posneg'><p>Add a standard label tabel for to a GIFTI XML tree.</p></a></li>
<li><a href='#guess.filename.is.gzipped'><p>Guess whether a file is gzipped.</p></a></li>
<li><a href='#has_pandoc'><p>Check for pandoc availability on system.</p></a></li>
<li><a href='#int.to.col.brainvoyager'><p>Convert 32 bit integer to RGB color as described in Brainvoyager SRF file spec.</p></a></li>
<li><a href='#is.bvsmp'><p>Check whether object is a bvsmp instance.</p></a></li>
<li><a href='#is.fs.annot'><p>Check whether object is an fs.annot</p></a></li>
<li><a href='#is.fs.label'><p>Check whether object is an fs.label</p></a></li>
<li><a href='#is.fs.surface'><p>Check whether object is an fs.surface</p></a></li>
<li><a href='#is.fs.volume'><p>Check whether object is an fs.volume</p></a></li>
<li><a href='#is.mghheader'><p>Check whether object is an mghheader</p></a></li>
<li><a href='#linesplit.fixed'><p>Split a string into fixed-length parts.</p></a></li>
<li><a href='#list_opt_data'><p>Get file names available in package cache.</p></a></li>
<li><a href='#mgh.is.conformed'><p>Determine whether an MGH volume is conformed.</p></a></li>
<li><a href='#mghheader'><p>Constructor to init MGH header instance.</p></a></li>
<li><a href='#mghheader.centervoxelRAS.from.firstvoxelRAS'><p>Compute RAS coords of center voxel.</p></a></li>
<li><a href='#mghheader.crs.orientation'><p>Compute MGH volume orientation string.</p></a></li>
<li><a href='#mghheader.is.conformed'><p>Determine whether an MGH volume is conformed.</p></a></li>
<li><a href='#mghheader.is.ras.valid'><p>Check whether header contains valid ras information</p></a></li>
<li><a href='#mghheader.primary.slice.direction'><p>Compute MGH primary slice direction</p></a></li>
<li><a href='#mghheader.ras2vox'><p>Compute ras2vox matrix from basic MGH header fields.</p></a></li>
<li><a href='#mghheader.ras2vox.tkreg'><p>Compute ras2vox-tkreg matrix from basic MGH header fields.</p></a></li>
<li><a href='#mghheader.scanner2tkreg'><p>Compute scanner-RAS 2 tkreg-RAS matrix from basic MGH header fields.</p></a></li>
<li><a href='#mghheader.tkreg2scanner'><p>Compute tkreg-RAS to scanner-RAS matrix from basic MGH header fields.</p></a></li>
<li><a href='#mghheader.update.from.vox2ras'><p>Update mghheader fields from vox2ras matrix.</p></a></li>
<li><a href='#mghheader.vox2ras'><p>Compute vox2ras matrix from basic MGH header fields.</p></a></li>
<li><a href='#mghheader.vox2ras.tkreg'><p>Compute vox2ras-tkreg matrix from basic MGH header fields.</p></a></li>
<li><a href='#mghheader.vox2vox'><p>Compute vox2vox matrix between two volumes.</p></a></li>
<li><a href='#mni152reg'><p>Get fsaverage (MNI305) to MNI152 transformation matrix.</p></a></li>
<li><a href='#mri_dtype_numbytes'><p>Get size of MRI dtype in bytes.</p></a></li>
<li><a href='#ni1header.for.data'><p>Create NIFTI v1 header suitable for given data.</p></a></li>
<li><a href='#ni1header.template'><p>Create a template NIFTI v1 header. You will have to adapt it for your use case.</p></a></li>
<li><a href='#ni2header.for.data'><p>Create NIFTI v2 header suitable for given data.</p></a></li>
<li><a href='#ni2header.template'><p>Create a template NIFTI v2 header. You will have to adapt it for your use case.</p></a></li>
<li><a href='#nifti.datadim.from.dimfield'><p>Compute data dimensions from the 'dim' field of the NIFTI (v1 or v2) header.</p></a></li>
<li><a href='#nifti.datadim.to.dimfield'><p>Compute NIFTI dim field for data dimension.</p></a></li>
<li><a href='#nifti.dtype.info'><p>Compute NIFTI v1 data type info from datatype and bitpix header field.</p></a></li>
<li><a href='#nifti.field.check.length'><p>Check whether vector has expected length.</p></a></li>
<li><a href='#nifti.field.check.nchar.max'><p>Check whether character string fields have less than or equal to expected length.</p></a></li>
<li><a href='#nifti.file.uses.fshack'><p>Determine whether a NIFTI file uses the FreeSurfer hack.</p></a></li>
<li><a href='#nifti.file.version'><p>Determine NIFTI file version information and whether file is a NIFTI file.</p></a></li>
<li><a href='#nifti.header.check'><p>Perform basic sanity checks on NIFTI header data. These are in no way meant to be exhaustive.</p></a></li>
<li><a href='#nifti.space.info'><p>Compute NIFTI space unit info from xyzt_units header field.</p></a></li>
<li><a href='#nifti.time.info'><p>Compute NIFTI time unit info from xyzt_units header field.</p></a></li>
<li><a href='#nifti.transform.type.name'><p>Get the name of the transform type from a form code.</p></a></li>
<li><a href='#parse.stl.ascii.face'><p>Parse a single ASCII STL face.</p></a></li>
<li><a href='#parse.transform.matrix.lines'><p>Parse matrix from text file lines.</p></a></li>
<li><a href='#ply.header.lines'><p>Generate PLY format header lines</p></a></li>
<li><a href='#polygon.soup.to.indexed.mesh'><p>Turn polygon soup into indexed mesh.</p></a></li>
<li><a href='#print.fs.annot'><p>Print description of a brain atlas or annotation.</p></a></li>
<li><a href='#print.fs.label'><p>Print description of a brain surface label.</p></a></li>
<li><a href='#print.fs.patch'><p>Print description of a brain surface patch.</p></a></li>
<li><a href='#print.fs.surface'><p>Print description of a brain surface.</p></a></li>
<li><a href='#print.fs.volume'><p>Print description of a brain volume.</p></a></li>
<li><a href='#ras.to.surfaceras'><p>Translate RAS coordinates, as used in volumes by applying vox2ras, to surface RAS.</p></a></li>
<li><a href='#ras.to.talairachras'><p>Compute MNI talairach coordinates from RAS coords.</p></a></li>
<li><a href='#read_nisurface'><p>Read a surface, based on the file path without extension.</p></a></li>
<li><a href='#read_nisurfacefile'><p>S3 method to read a neuroimaging surface file.</p></a></li>
<li><a href='#read_nisurfacefile.fsascii'><p>Read a FreeSurfer ASCII surface file.</p></a></li>
<li><a href='#read_nisurfacefile.fsnative'><p>Read a FreeSurfer ASCII surface file.</p></a></li>
<li><a href='#read_nisurfacefile.gifti'><p>Read a gifti file as a surface.</p></a></li>
<li><a href='#read.dti.tck'><p>Read DTI tracking data from file in MRtrix 'TCK' format.</p></a></li>
<li><a href='#read.dti.trk'><p>Read fiber tracks from Diffusion Toolkit in trk format.</p></a></li>
<li><a href='#read.dti.tsf'><p>Read DTI tracking per-coord data from file in MRtrix 'TSF' format.</p></a></li>
<li><a href='#read.element.counts.ply.header'><p>Determine element counts from PLY file header.</p></a></li>
<li><a href='#read.fixed.char.binary'><p>Read fixed length char, possibly containing embedded zeroes, from binary file.</p></a></li>
<li><a href='#read.fs.annot'><p>Read file in FreeSurfer annotation format</p></a></li>
<li><a href='#read.fs.annot.gii'><p>Read an annotation or label in GIFTI format.</p></a></li>
<li><a href='#read.fs.colortable'><p>Read colortable file in FreeSurfer ASCII LUT format.</p></a></li>
<li><a href='#read.fs.curv'><p>Read file in FreeSurfer curv format</p></a></li>
<li><a href='#read.fs.gca'><p>Read FreeSurfer GCA file.</p></a></li>
<li><a href='#read.fs.label'><p>Read a label file.</p></a></li>
<li><a href='#read.fs.label.gii'><p>Read a label from a GIFTI label/annotation file.</p></a></li>
<li><a href='#read.fs.label.native'><p>Read file in FreeSurfer label format</p></a></li>
<li><a href='#read.fs.mgh'><p>Read file in FreeSurfer MGH or MGZ format</p></a></li>
<li><a href='#read.fs.morph'><p>Read morphometry data file in any FreeSurfer format.</p></a></li>
<li><a href='#read.fs.morph.asc'><p>Read morphometry data from ASCII curv format file</p></a></li>
<li><a href='#read.fs.morph.bvsmp'><p>Read Brainvoyager vertex-wise statistical surface data from SMP file.</p></a></li>
<li><a href='#read.fs.morph.cifti'><p>Read surface morphometry data from CIFTI dscalar files.</p></a></li>
<li><a href='#read.fs.morph.gii'><p>Read morphometry data file in GIFTI format.</p></a></li>
<li><a href='#read.fs.morph.ni1'><p>Read morphometry data from FreeSurfer NIFTI v1 format files.</p></a></li>
<li><a href='#read.fs.morph.ni2'><p>Read morphometry data from FreeSurfer NIFTI v2 format files.</p></a></li>
<li><a href='#read.fs.morph.nii'><p>Read morphometry data from FreeSurfer NIFTI format files, determine NIFTI version automatically.</p></a></li>
<li><a href='#read.fs.morph.txt'><p>Read morphometry data from plain text file</p></a></li>
<li><a href='#read.fs.patch'><p>Read FreeSurfer binary or ASCII patch file.</p></a></li>
<li><a href='#read.fs.patch.asc'><p>Read FreeSurfer ASCII format patch.</p></a></li>
<li><a href='#read.fs.surface'><p>Read file in FreeSurfer surface format or various mesh formats.</p></a></li>
<li><a href='#read.fs.surface.asc'><p>Read FreeSurfer ASCII format surface.</p></a></li>
<li><a href='#read.fs.surface.bvsrf'><p>Read Brainvoyager srf format (.srf) mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.byu'><p>Read mesh in BYU format.</p></a></li>
<li><a href='#read.fs.surface.geo'><p>Read GEO format mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.gii'><p>Read GIFTI format mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.ico'><p>Read ICO format mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.mz3'><p>Read surface mesh in mz3 format, used by Surf-Ice.</p></a></li>
<li><a href='#read.fs.surface.obj'><p>Read OBJ format mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.off'><p>Read Object File Format (OFF) mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.ply'><p>Read Stanford PLY format mesh as surface.</p></a></li>
<li><a href='#read.fs.surface.stl'><p>Read mesh in STL format, auto-detecting ASCII versus binary format version.</p></a></li>
<li><a href='#read.fs.surface.stl.ascii'><p>Read surface mesh in STL ASCII format.</p></a></li>
<li><a href='#read.fs.surface.stl.bin'><p>Read surface mesh in STL binary format.</p></a></li>
<li><a href='#read.fs.surface.vtk'><p>Read VTK ASCII format mesh as surface.</p></a></li>
<li><a href='#read.fs.transform'><p>Load transformation matrix from a file.</p></a></li>
<li><a href='#read.fs.transform.dat'><p>Load transformation matrix from a tkregister dat file.</p></a></li>
<li><a href='#read.fs.transform.lta'><p>Load transformation matrix from a FreeSurfer linear transform array (LTA) file.</p></a></li>
<li><a href='#read.fs.transform.xfm'><p>Load transformation matrix from an XFM file.</p></a></li>
<li><a href='#read.fs.volume'><p>Read volume file in MGH, MGZ or NIFTI format</p></a></li>
<li><a href='#read.fs.volume.nii'><p>Turn a 3D or 4D 'oro.nifti' instance into an 'fs.volume' instance with complete header.</p></a></li>
<li><a href='#read.fs.weight'><p>Read file in FreeSurfer weight or w format</p></a></li>
<li><a href='#read.fs.weight.asc'><p>Read ASCII version of FreeSurfer weight file.</p></a></li>
<li><a href='#read.mesh.brainvoyager'><p>Read Brainvoyager srf format (.srf) mesh.</p></a></li>
<li><a href='#read.nifti1.data'><p>Read raw NIFTI v1 data from file (which may contain the FreeSurfer hack).</p></a></li>
<li><a href='#read.nifti1.header'><p>Read NIFTI v1 header from file (which may contain the FreeSurfer hack).</p></a></li>
<li><a href='#read.nifti1.header.internal'><p>Read NIFTI v1 header from file (which may contain the FreeSurfer hack).</p></a></li>
<li><a href='#read.nifti2.data'><p>Read raw data from NIFTI v2 file.</p></a></li>
<li><a href='#read.nifti2.header'><p>Read NIFTI v2 header from file.</p></a></li>
<li><a href='#read.nifti2.header.internal'><p>Read NIFTI v2 header from file.</p></a></li>
<li><a href='#read.smp.brainvoyager'><p>Read Brainvoyager statistical surface results from SMP file.</p></a></li>
<li><a href='#read.smp.brainvoyager.v1or2'><p>Read Brainvoyager statistical surface results from v1 or v2 SMP file.</p></a></li>
<li><a href='#read.smp.brainvoyager.v3'><p>Read Brainvoyager statistical surface results from v3 SMP file.</p></a></li>
<li><a href='#read.smp.brainvoyager.v4or5'><p>Read Brainvoyager statistical surface results from v4 or v5 SMP file.</p></a></li>
<li><a href='#readable.files'><p>Find files with the given base name and extensions that exist.</p></a></li>
<li><a href='#readcolortable'><p>Read binary colortable in v2 format.</p></a></li>
<li><a href='#readcolortable_oldformat'><p>Read binary colortable in old format.</p></a></li>
<li><a href='#rotate2D'><p>Rotate a 2D matrix in 90 degree steps.</p></a></li>
<li><a href='#rotate3D'><p>Rotate a 3D array in 90 degree steps.</p></a></li>
<li><a href='#rotate90'><p>Rotate 2D matrix clockwise in 90 degree steps.</p></a></li>
<li><a href='#scann'><p>Scan exactly n values from source string.</p></a></li>
<li><a href='#sm0to1'><p>Adapt spatial transformation matrix for 1-based indices.</p></a></li>
<li><a href='#sm1to0'><p>Adapt spatial transformation matrix for 0-based indices.</p></a></li>
<li><a href='#stl.format.file.is.ascii'><p>Guess whether a mesh file in STL format is the ASCII or the binary version.</p></a></li>
<li><a href='#surfaceras.to.ras'><p>Translate surface RAS coordinates, as used in surface vertices and surface labels, to volume RAS.</p></a></li>
<li><a href='#surfaceras.to.talairach'><p>Compute Talairach RAS for surface RAS (e.g., vertex coordinates).</p></a></li>
<li><a href='#talairachras.to.ras'><p>Compute MNI talairach coordinates from RAS coords.</p></a></li>
<li><a href='#translate.mri.dtype'><p>Translate between code and name of MRI data types.</p></a></li>
<li><a href='#vertex.euclid.dist'><p>Compute Euclidean distance between two vertices v1 and v2.</p></a></li>
<li><a href='#vertexdists.to.point'><p>Compute Euclidean distance from all mesh vertices to given point.</p></a></li>
<li><a href='#write.fs.annot'><p>Write annotation to binary file.</p></a></li>
<li><a href='#write.fs.annot.gii'><p>Write annotation to GIFTI file.</p></a></li>
<li><a href='#write.fs.colortable'><p>Write colortable file in FreeSurfer ASCII LUT format.</p></a></li>
<li><a href='#write.fs.curv'><p>Write file in FreeSurfer curv format</p></a></li>
<li><a href='#write.fs.label'><p>Write vertex indices to file in FreeSurfer label format</p></a></li>
<li><a href='#write.fs.label.gii'><p>Write a binary surface label in GIFTI format.</p></a></li>
<li><a href='#write.fs.mgh'><p>Write file in FreeSurfer MGH or MGZ format</p></a></li>
<li><a href='#write.fs.morph'><p>Write morphometry data in a format derived from the given file name.</p></a></li>
<li><a href='#write.fs.morph.asc'><p>Write file in FreeSurfer ASCII curv format</p></a></li>
<li><a href='#write.fs.morph.gii'><p>Write morphometry data in GIFTI format.</p></a></li>
<li><a href='#write.fs.morph.ni1'><p>Write morphometry data in NIFTI v1 format.</p></a></li>
<li><a href='#write.fs.morph.ni2'><p>Write morphometry data in NIFTI v2 format.</p></a></li>
<li><a href='#write.fs.morph.smp'><p>Write morphometry data in Brainvoyager SMP format.</p></a></li>
<li><a href='#write.fs.morph.txt'><p>Write curv data to file in simple text format</p></a></li>
<li><a href='#write.fs.patch'><p>Write a surface patch</p></a></li>
<li><a href='#write.fs.surface'><p>Write mesh to file in FreeSurfer binary surface format</p></a></li>
<li><a href='#write.fs.surface.asc'><p>Write mesh to file in FreeSurfer ASCII surface format</p></a></li>
<li><a href='#write.fs.surface.bvsrf'><p>Write surface to Brainvoyager SRF file.</p></a></li>
<li><a href='#write.fs.surface.byu'><p>Write mesh to file in BYU ASCII format.</p></a></li>
<li><a href='#write.fs.surface.gii'><p>Write mesh to file in GIFTI surface format</p></a></li>
<li><a href='#write.fs.surface.mz3'><p>Write mesh to file in mz3 binary format.</p></a></li>
<li><a href='#write.fs.surface.obj'><p>Write mesh to file in Wavefront object (.obj) format</p></a></li>
<li><a href='#write.fs.surface.off'><p>Write mesh to file in Object File Format (.off)</p></a></li>
<li><a href='#write.fs.surface.off.ply2'><p>Write mesh to file in Object File Format (.off) or PLY2 format.</p></a></li>
<li><a href='#write.fs.surface.ply'><p>Write mesh to file in PLY format (.ply)</p></a></li>
<li><a href='#write.fs.surface.ply2'><p>Write mesh to file in PLY2 File Format (.ply2)</p></a></li>
<li><a href='#write.fs.surface.vtk'><p>Write mesh to file in VTK ASCII format</p></a></li>
<li><a href='#write.fs.weight'><p>Write file in FreeSurfer weight format</p></a></li>
<li><a href='#write.fs.weight.asc'><p>Write file in FreeSurfer weight ASCII format</p></a></li>
<li><a href='#write.nifti1'><p>Write header and data to a file in NIFTI v1 format.</p></a></li>
<li><a href='#write.nifti2'><p>Write header and data to a file in NIFTI v2 format.</p></a></li>
<li><a href='#write.smp.brainvoyager'><p>Write a brainvoyager SMP file.</p></a></li>
<li><a href='#write.smp.brainvoyager.v2'><p>Write a brainvoyager v2 SMP file.</p></a></li>
<li><a href='#write.smp.brainvoyager.v3or4or5'><p>Write a brainvoyager v3, v4 or v5 SMP file.</p></a></li>
<li><a href='#xml_node_gifti_coordtransform'><p>Create XML GIFTI CoordinateSystemTransformMatrix node.</p></a></li>
<li><a href='#xml_node_gifti_label'><p>Create XML GIFTI Label node.</p></a></li>
<li><a href='#xml_node_gifti_label_table'><p>Create XML GIFTI LabelTable node.</p></a></li>
<li><a href='#xml_node_gifti_label_table_from_annot'><p>Compute LabelTable node from annotation.</p></a></li>
<li><a href='#xml_node_gifti_MD'><p>Create XML GIFTI metadata node.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write 'FreeSurfer' Neuroimaging File Formats</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Schäfer &lt;ts+code@rcmd.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to read and write neuroimaging data in various file formats, with a focus on 'FreeSurfer' <a href="http://freesurfer.net/">http://freesurfer.net/</a> formats. This includes, but is not limited to, the following file formats: 1) MGH/MGZ format files, which can contain multi-dimensional images or other data. Typically they contain time-series of three-dimensional brain scans acquired by magnetic resonance imaging (MRI). They can also contain vertex-wise measures of surface morphometry data. The MGH format is named after the Massachusetts General Hospital, and the MGZ format is a compressed version of the same format. 2) 'FreeSurfer' morphometry data files in binary 'curv' format. These contain vertex-wise surface measures, i.e., one scalar value for each vertex of a brain surface mesh. These are typically values like the cortical thickness or brain surface area at each vertex. 3) Annotation file format. This contains a brain surface parcellation derived from a cortical atlas. 4) Surface file format. Contains a brain surface mesh, given by a list of vertices and a list of faces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dfsp-spirit/freesurferformats">https://github.com/dfsp-spirit/freesurferformats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dfsp-spirit/freesurferformats/issues">https://github.com/dfsp-spirit/freesurferformats/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, pkgfilecache (&ge; 0.1.1), xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, curl, testthat (&ge; 2.1.0), oro.nifti (&ge;
0.9), gifti (&ge; 0.7.5), cifti (&ge; 0.4.5)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 21:40:20 UTC; spirit</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Schäfer <a href="https://orcid.org/0000-0002-3683-8070"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust.face.indices.to'>Adjust integer matrix to target min value.</h2><span id='topic+adjust.face.indices.to'></span>

<h3>Description</h3>

<p>This takes a matrix of integers, and adjusts the values such that the minimal value is the 'target_min_index' value. It is used to adjust from 0-based to 1-based indices in meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.face.indices.to(faces, target_min_index = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust.face.indices.to_+3A_faces">faces</code></td>
<td>
<p>3xn integer matrix, the vertex indices of the faces</p>
</td></tr>
<tr><td><code id="adjust.face.indices.to_+3A_target_min_index">target_min_index</code></td>
<td>
<p>integer, one of 1L or 0L. The target minimal value that the data should have afterwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3xn integer matrix, the adjusted values
</p>


<h3>Note</h3>

<p>The current and the target min values must be 0 or 1.
</p>

<hr>
<h2 id='annot.max.region.idx'>Get max region index of an fs.annot instance.</h2><span id='topic+annot.max.region.idx'></span>

<h3>Description</h3>

<p>Get max region index of an fs.annot instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annot.max.region.idx(annot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annot.max.region.idx_+3A_annot">annot</code></td>
<td>
<p>fs.annot instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the max region index. They typically start with 0 and are consecutive, but this is not enforced or checked in any way.
</p>


<h3>Note</h3>

<p>This is a helper function to be used with <code>annot.unique</code>, see the example there.
</p>

<hr>
<h2 id='annot.unique'>Make the region names and indices unique across hemispheres for a parcellation.</h2><span id='topic+annot.unique'></span>

<h3>Description</h3>

<p>Sometimes you need an annotation to use unique IDs and region names across hemispheres, but that is not the case for the standard FreeSurfer parcellations. So what you need to do is change the codes and names for one hemi. Typically the left hemi annot will be left as is, and the right hemi annot will be modified using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annot.unique(
  annot,
  add_to_region_indices,
  region_name_prefix = "rh_",
  region_name_suffix = NULL,
  set_first_idx_zero = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annot.unique_+3A_annot">annot</code></td>
<td>
<p>the annot in which to change the ids and names.</p>
</td></tr>
<tr><td><code id="annot.unique_+3A_add_to_region_indices">add_to_region_indices</code></td>
<td>
<p>integer, a single value to add to the region indices. This is typically equal to the number of regions in the left hemisphere plus one (e.g., 36+1=37 for the 'aparc' atlas), as the region indices typically start at 0 and are consecutive, but you may want to check the maximal region id of the left hemi is in doubt. Pass <code>0</code> to leave the IDs intact.</p>
</td></tr>
<tr><td><code id="annot.unique_+3A_region_name_prefix">region_name_prefix</code></td>
<td>
<p>character string, a prefix to modify the region names to make them unique. Pass 'NULL' if you do not want a prefix.</p>
</td></tr>
<tr><td><code id="annot.unique_+3A_region_name_suffix">region_name_suffix</code></td>
<td>
<p>character string, a suffix to modify the region names to make them unique.  Pass 'NULL' if you do not want a suffix.</p>
</td></tr>
<tr><td><code id="annot.unique_+3A_set_first_idx_zero">set_first_idx_zero</code></td>
<td>
<p>logical, whether to apply special treatment to first region (the 'unknown' region) in annot and set its ID to <code>0</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not part of the official API and should not be used. It is currently broken.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lh_annot = read.fs.annot("~/data/study1/subject1/label/lh.aparc.annot");
lh_annot; # shows info including region IDs
rh_annot = read.fs.annot("~/data/study1/subject1/label/rh.aparc.annot");
rh_annot_mod = annot.unique(rh_annot, annot.max.region.idx(lh_annot)+1L, region_name_prefix='rh_');

## End(Not run)

</code></pre>

<hr>
<h2 id='assert.surface'>Stop unless surf is an fs.surface</h2><span id='topic+assert.surface'></span>

<h3>Description</h3>

<p>Stop unless surf is an fs.surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert.surface(surface, param_name = "surface")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert.surface_+3A_surface">surface</code></td>
<td>
<p>fs.surface instance or anything else</p>
</td></tr>
<tr><td><code id="assert.surface_+3A_param_name">param_name</code></td>
<td>
<p>character string, used in stop message to identify the parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for the side effect of stopping if surface is not an fs.surface instance.
</p>

<hr>
<h2 id='bvsmp'>Create new bvsmp instance encoding morph data for Brainvoyager.</h2><span id='topic+bvsmp'></span>

<h3>Description</h3>

<p>Create new bvsmp instance encoding morph data for Brainvoyager.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvsmp(morph_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvsmp_+3A_morph_data">morph_data</code></td>
<td>
<p>numeric vector, the morphometry data to store in the bvsmp instance (one value per mesh vertex).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bvsmp instance, can be used to write Brainvoyager SMP format morphometry files using <code><a href="#topic+write.smp.brainvoyager">write.smp.brainvoyager</a></code>. Modify as needed before writing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   morph_data = rnorm(100L, 3.0, 1.0);
   mybvsmp = bvsmp(morph_data);
   mybvsmp$smp_version;

</code></pre>

<hr>
<h2 id='cdata'>Create CDATA element string from string.</h2><span id='topic+cdata'></span>

<h3>Description</h3>

<p>Create CDATA element string from string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdata(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdata_+3A_string">string</code></td>
<td>
<p>character string, the input string, freeform text. Must not contain the cdata start and end tags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the input wrapped in the cdata tags
</p>


<h3>Note</h3>

<p>This returns a string, not an XML node. See <code><a href="xml2.html#topic+xml_cdata">xml_cdata</a></code> if you want a node.
</p>

<hr>
<h2 id='check_data_and_settings_consistency'>Warn about common errors in combining data and datatype.</h2><span id='topic+check_data_and_settings_consistency'></span>

<h3>Description</h3>

<p>Warn about common errors in combining data and datatype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_and_settings_consistency(
  index,
  data,
  datatype,
  intent,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_and_settings_consistency_+3A_index">index</code></td>
<td>
<p>positive integer, the dataarray index to report. Makes it easier for the user to find the broken one.</p>
</td></tr>
<tr><td><code id="check_data_and_settings_consistency_+3A_data">data</code></td>
<td>
<p>vector or matrix, the data to write to the GIFTI file. Checked against the datatype.</p>
</td></tr>
<tr><td><code id="check_data_and_settings_consistency_+3A_datatype">datatype</code></td>
<td>
<p>NIFTI datatype string, the datatype to use when writing to the GIFTI file. Checked against the data.</p>
</td></tr>
<tr><td><code id="check_data_and_settings_consistency_+3A_intent">intent</code></td>
<td>
<p>NIFTI intent string, checked independently. In no way do we check whether it makes sense for the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The checks in here are in no way exhaustive.
</p>

<hr>
<h2 id='check.dtype.for.data'>Check whether the dtype is suitable for the data.</h2><span id='topic+check.dtype.for.data'></span>

<h3>Description</h3>

<p>This function provides an educated guess on whether the given dtype is suitable for the data. It is usually called for the site effect of printing warnings in case something seems off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.dtype.for.data(mridata, mri_dtype_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.dtype.for.data_+3A_mridata">mridata</code></td>
<td>
<p>the data to check, a vector, matrix or array typically</p>
</td></tr>
<tr><td><code id="check.dtype.for.data_+3A_mri_dtype_code">mri_dtype_code</code></td>
<td>
<p>integer, the MRI data type code. See <code><a href="#topic+translate.mri.dtype">translate.mri.dtype</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the dtype could be suitable. This is only a guess, as the checks are in no way complete.
</p>

<hr>
<h2 id='closest.vert.to.point'>Find vertex index closest to given query coordinate using Euclidean distance.</h2><span id='topic+closest.vert.to.point'></span>

<h3>Description</h3>

<p>Find vertex index closest to given query coordinate using Euclidean distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest.vert.to.point(surface, point_coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest.vert.to.point_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance or a nx3 numerical matrix representing mesh points.</p>
</td></tr>
<tr><td><code id="closest.vert.to.point_+3A_point_coords">point_coords</code></td>
<td>
<p>nx3 matrix of query coords. If a vector, will be transformed <code>byrow</code> to such a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'vertex_id' integer vector, the index of the closest vertex, and 'dist': double vector, the Euclidean distance to that vertex.
</p>


<h3>See Also</h3>

<p>Other Euclidean distance util functions: 
<code><a href="#topic+vertex.euclid.dist">vertex.euclid.dist</a>()</code>,
<code><a href="#topic+vertexdists.to.point">vertexdists.to.point</a>()</code>
</p>

<hr>
<h2 id='colortable.from.annot'>Extract color lookup table (LUT) from annotation.</h2><span id='topic+colortable.from.annot'></span>

<h3>Description</h3>

<p>Extract a colortable lookup table (LUT) from an annotation. Such a LUT can also be read from files like &lsquo;FREESURFER_HOME/FreeSurferColorLUT.txt' or saved as a file, check the &rsquo;See Also' section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colortable.from.annot(annot, compute_colorcode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colortable.from.annot_+3A_annot">annot</code></td>
<td>
<p>An annotation, as returned by <code><a href="#topic+read.fs.annot">read.fs.annot</a></code>. If you want to assign specific indices, you can add a column named 'struct_index' to the data.frame <code>annot$colortable_df</code>. If there is no such columns, the indices will be created automatically in the order of the regions, starting at zero.</p>
</td></tr>
<tr><td><code id="colortable.from.annot_+3A_compute_colorcode">compute_colorcode</code></td>
<td>
<p>logical, indicates whether the unique color codes should be computed and added to the returned data.frame as an extra integer column named 'code'. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the colortable data.frame extracted from the annotation.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+read.fs.annot">read.fs.annot</a>()</code>,
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>,
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.annot">write.fs.annot</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>
<p>Other colorLUT functions: 
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    annotfile = system.file("extdata", "lh.aparc.annot.gz",
     package = "freesurferformats", mustWork = TRUE);
    annot = read.fs.annot(annotfile);
    colortable = colortable.from.annot(annot);
    head(colortable);

</code></pre>

<hr>
<h2 id='coord.to.key'>Turn coordinate vector into string.</h2><span id='topic+coord.to.key'></span>

<h3>Description</h3>

<p>Turn coordinate vector into string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord.to.key(coord, digits = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord.to.key_+3A_coord">coord</code></td>
<td>
<p>double vector of length 3, the xyz coord</p>
</td></tr>
<tr><td><code id="coord.to.key_+3A_digits">digits</code></td>
<td>
<p>integer, the number of digits (after the decimal separator) to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string
</p>

<hr>
<h2 id='delete_all_opt_data'>Delete all data in the package cache.</h2><span id='topic+delete_all_opt_data'></span>

<h3>Description</h3>

<p>Delete all data in the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_all_opt_data()
</code></pre>


<h3>Value</h3>

<p>integer. The return value of the unlink() call: 0 for success, 1 for failure. See the unlink() documentation for details.
</p>

<hr>
<h2 id='doapply.transform.mtx'>Apply a spatial transformation matrix to the given coordinates.</h2><span id='topic+doapply.transform.mtx'></span>

<h3>Description</h3>

<p>Apply a spatial transformation matrix to the given coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doapply.transform.mtx(coords, mtx, as_mat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doapply.transform.mtx_+3A_coords">coords</code></td>
<td>
<p>nx3 (cartesian) or nx4 (homogeneous) numerical matrix, the input coordinates. If nx4, left as is for homogeneous notation, if nx3 (cartesian) a 1 will be appended as the 4th position.</p>
</td></tr>
<tr><td><code id="doapply.transform.mtx_+3A_mtx">mtx</code></td>
<td>
<p>a 4x4 numerical transformation matrix</p>
</td></tr>
<tr><td><code id="doapply.transform.mtx_+3A_as_mat">as_mat</code></td>
<td>
<p>logical, whether to force the output coords into a matrix (even if the input was a vector/a single coordinate triple).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coords after applying the transformation. If coords was nx3, nx3 is returned, otherwise nx4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    coords_tf = doapply.transform.mtx(c(1.0, 1.0, 1.0), mni152reg());
    coords_tf;
    doapply.transform.mtx(coords_tf, solve(mni152reg()));

</code></pre>

<hr>
<h2 id='download_opt_data'>Download optional data for the freesurferformats package.</h2><span id='topic+download_opt_data'></span>

<h3>Description</h3>

<p>Ensure that the optional data is available locally in the package cache. Will try to download the data only if it is not available. This data is not required for the package to work, but it is used in the examples, in the unit tests and also in the example code from the vignette. Downloading it is highly recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_opt_data()
</code></pre>


<h3>Value</h3>

<p>Named list. The list has entries: &quot;available&quot;: vector of strings. The names of the files that are available in the local file cache. You can access them using get_optional_data_file(). &quot;missing&quot;: vector of strings. The names of the files that this function was unable to retrieve.
</p>

<hr>
<h2 id='euclidian.dist'>Compute Euclidean distance.</h2><span id='topic+euclidian.dist'></span>

<h3>Description</h3>

<p>Compute Euclidean distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidian.dist(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidian.dist_+3A_x1">x1</code></td>
<td>
<p>numerical vector, coords of first point</p>
</td></tr>
<tr><td><code id="euclidian.dist_+3A_x2">x2</code></td>
<td>
<p>numerical vector, coords of second point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Euclidean distance between x1 and x2.
</p>

<hr>
<h2 id='faces.quad.to.tris'>Convert quadrangular faces or polygons to triangular ones.</h2><span id='topic+faces.quad.to.tris'></span>

<h3>Description</h3>

<p>Convert quadrangular faces or polygons to triangular ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faces.quad.to.tris(quad_faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces.quad.to.tris_+3A_quad_faces">quad_faces</code></td>
<td>
<p>nx4 integer matrix, the indices of the vertices making up the *n* quad faces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>*2nx3* integer matrix, the indices of the vertices making up the *2n* tris faces.
</p>


<h3>Note</h3>

<p>This function does no fancy remeshing, it simply splits each quad into two triangles.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='faces.tris.to.quad'>Convert tris faces to quad faces by simple merging.</h2><span id='topic+faces.tris.to.quad'></span>

<h3>Description</h3>

<p>This is experimental. Note that it can only work if the number of 'tris_faces' is even, as two consecutive tris-faces will be merged into one quad face. We could set the index to NA in that case, but I do not know how FreeSurfer handles this, so we do not guess.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faces.tris.to.quad(tris_faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces.tris.to.quad_+3A_tris_faces">tris_faces</code></td>
<td>
<p>*nx3* integer matrix, the indices of the vertices making up the *n* tris faces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n/2x4 integer matrix, the indices of the vertices making up the *n* quad faces.
</p>


<h3>Note</h3>

<p>This function does not implement proper remeshing of tri-meshes to quad-meshes. Use a proper mesh library if you need that.
</p>

<hr>
<h2 id='fileopen.gz.or.not'>Get connection to a binary file, gz or not.</h2><span id='topic+fileopen.gz.or.not'></span>

<h3>Description</h3>

<p>Get connection to a binary file, gz or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileopen.gz.or.not(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fileopen.gz.or.not_+3A_filepath">filepath</code></td>
<td>
<p>path to the binary file.</p>
</td></tr>
</table>

<hr>
<h2 id='filepath.ends.with'>Check whether filepath ends with extension.</h2><span id='topic+filepath.ends.with'></span>

<h3>Description</h3>

<p>Check whether filepath ends with extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filepath.ends.with(filepath, extensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filepath.ends.with_+3A_filepath">filepath</code></td>
<td>
<p>string. Path to a file, including filename and extension.</p>
</td></tr>
<tr><td><code id="filepath.ends.with_+3A_extensions">extensions</code></td>
<td>
<p>list of strings. A list of suffixes to check. Case does not matter. Example: <code>extensions=c('.gz', '.mgz')</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the filepath end with one of the extensions.
</p>

<hr>
<h2 id='fixed.vec.format.int'>Write fixed width integers to one or several lines.</h2><span id='topic+fixed.vec.format.int'></span>

<h3>Description</h3>

<p>Write fixed width integers to one or several lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed.vec.format.int(
  vdata,
  num_chars_per_entry,
  max_entries_per_line = NULL,
  align_right = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed.vec.format.int_+3A_vdata">vdata</code></td>
<td>
<p>integer vector, the data</p>
</td></tr>
<tr><td><code id="fixed.vec.format.int_+3A_num_chars_per_entry">num_chars_per_entry</code></td>
<td>
<p>field length of a single formatted integer in characters</p>
</td></tr>
<tr><td><code id="fixed.vec.format.int_+3A_max_entries_per_line">max_entries_per_line</code></td>
<td>
<p>integer, how many entries are allowed per line. Leave at NULL for no limit, which will return all in a single line.</p>
</td></tr>
<tr><td><code id="fixed.vec.format.int_+3A_align_right">align_right</code></td>
<td>
<p>logical, whether to align the integers to the right. As you may have guessed, set to 'FALSE' to align to the left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, the formatted data lines.
</p>

<hr>
<h2 id='flip2D'>Flip a 2D matrix.</h2><span id='topic+flip2D'></span>

<h3>Description</h3>

<p>Flip a 2D matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip2D(slice, how = "horizontally")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip2D_+3A_slice">slice</code></td>
<td>
<p>a 2D matrix</p>
</td></tr>
<tr><td><code id="flip2D_+3A_how">how</code></td>
<td>
<p>character string, one of 'vertically' / 'v' or 'horizontally' / 'h'. Note that flipping *horizontally* means that the image will be mirrored along the central *vertical* axis. If 'NULL' is passed, the passed value is returned unaltered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2D matrix, the flipped matrix.
</p>

<hr>
<h2 id='flip3D'>Flip a 3D array along an axis.</h2><span id='topic+flip3D'></span>

<h3>Description</h3>

<p>Flip the slice of an 3D array horizontally or vertically along an axis. This leads to an output array with identical dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip3D(volume, axis = 1L, how = "horizontally")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip3D_+3A_volume">volume</code></td>
<td>
<p>a 3D image volume</p>
</td></tr>
<tr><td><code id="flip3D_+3A_axis">axis</code></td>
<td>
<p>positive integer in range 1L..3L or an axis name, the axis to use.</p>
</td></tr>
<tr><td><code id="flip3D_+3A_how">how</code></td>
<td>
<p>character string, one of 'horizontally' / 'h' or 'vertically' / 'v'. How to flip the 2D slices. Note that flipping *horizontally* means that the image will be mirrored along the central *vertical* axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D image volume, flipped around the axis. The dimensions are identical to the dimensions of the input image.
</p>


<h3>See Also</h3>

<p>Other volume math: 
<code><a href="#topic+rotate3D">rotate3D</a>()</code>
</p>

<hr>
<h2 id='fread3'>Read 3-byte integer.</h2><span id='topic+fread3'></span>

<h3>Description</h3>

<p>Read a 3-byte integer from a binary file handle. Advances the pointer accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread3(filehandle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread3_+3A_filehandle">filehandle</code></td>
<td>
<p>file handle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, The read integer.
</p>

<hr>
<h2 id='fs.get.morph.file.ext.for.format'>Determine morphometry file extension from format</h2><span id='topic+fs.get.morph.file.ext.for.format'></span>

<h3>Description</h3>

<p>Given a morphometry file format, derive the proper file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.get.morph.file.ext.for.format(format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs.get.morph.file.ext.for.format_+3A_format">format</code></td>
<td>
<p>string. One of c(&quot;mgh&quot;, &quot;mgz&quot;, &quot;curv&quot;, &quot;gii&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>file ext, string. The standard file extension for the format. (May be an empty string for some formats.)
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='fs.get.morph.file.format.from.filename'>Determine morphometry file format from filename</h2><span id='topic+fs.get.morph.file.format.from.filename'></span>

<h3>Description</h3>

<p>Given a morphometry file name, derive the proper file format, based on the end of the string. Case is ignored, i.e., cast to lowercase before checks. If the filepath ends with &quot;mgh&quot;, returns format &quot;mgh&quot;. For suffix &quot;mgz&quot;, returns &quot;mgz&quot; format. For all others, returns &quot;curv&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.get.morph.file.format.from.filename(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs.get.morph.file.format.from.filename_+3A_filepath">filepath</code></td>
<td>
<p>string. A path to a file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format, string. The format, one of c(&quot;mgz&quot;, &quot;mgh&quot;, &quot;curv&quot;, &quot;gii&quot;, &quot;smp&quot;).
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='fs.patch'>Constructor for fs.patch</h2><span id='topic+fs.patch'></span>

<h3>Description</h3>

<p>Constructor for fs.patch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.patch(vertices, faces = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs.patch_+3A_vertices">vertices</code></td>
<td>
<p>numerical *n*x5 matrix (or *n*x7 matrix), see <code><a href="#topic+read.fs.patch">read.fs.patch</a></code> for details. If it has 5 columns, columns 6-7 will be computed automatically from the first 5 columns (from column 1 and 5).</p>
</td></tr>
<tr><td><code id="fs.patch_+3A_faces">faces</code></td>
<td>
<p>numerical *n*x5 matrix, see <code><a href="#topic+read.fs.patch.asc">read.fs.patch.asc</a></code> for details. Can be 'NULL'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>instance of class 'fs.patch'
</p>


<h3>See Also</h3>

<p>Other patch functions: 
<code><a href="#topic+read.fs.patch.asc">read.fs.patch.asc</a>()</code>,
<code><a href="#topic+read.fs.patch">read.fs.patch</a>()</code>,
<code><a href="#topic+write.fs.patch">write.fs.patch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    num_vertices = 6L;   # a tiny patch
    vertices = matrix(rep(0., num_vertices*5), ncol=5);
    vertices[,1] = seq.int(num_vertices);  # 1-based vertex indices
    vertices[,2:4] = matrix(rnorm(num_vertices*3, 8, 2), ncol=3);  # vertex coords
    vertices[,5] = rep(0L, num_vertices);  # is_border
    vertices[3,5] = 1L;  # set a vertex to be a border vertex
    patch = fs.patch(vertices);
    patch;

</code></pre>

<hr>
<h2 id='fs.surface.to.tmesh3d'>Get an rgl tmesh3d instance from a brain surface mesh.</h2><span id='topic+fs.surface.to.tmesh3d'></span>

<h3>Description</h3>

<p>Convert <code>fs.surface</code> to <code>tmesh</code> without the <code>rgl</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.surface.to.tmesh3d(surface)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs.surface.to.tmesh3d_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, as returned <code>freesurferformats::read.fs.surface</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tmesh3d</code> instance representing the surface, see <code>rgl::tmesh3d</code> for details. It has classes <code>mesh3d</code> and <code>shape3d</code>.
</p>

<hr>
<h2 id='fwrite3'>Write 3-byte integer.</h2><span id='topic+fwrite3'></span>

<h3>Description</h3>

<p>Write a 3-byte integer to a binary file handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwrite3(filehandle, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwrite3_+3A_filehandle">filehandle</code></td>
<td>
<p>file handle (connection)</p>
</td></tr>
<tr><td><code id="fwrite3_+3A_data">data</code></td>
<td>
<p>number to write</p>
</td></tr>
</table>

<hr>
<h2 id='get_opt_data_filepath'>Access a single file from the package cache by its file name.</h2><span id='topic+get_opt_data_filepath'></span>

<h3>Description</h3>

<p>Access a single file from the package cache by its file name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_opt_data_filepath(filename, mustWork = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_opt_data_filepath_+3A_filename">filename</code></td>
<td>
<p>string. The filename of the file in the package cache.</p>
</td></tr>
<tr><td><code id="get_opt_data_filepath_+3A_mustwork">mustWork</code></td>
<td>
<p>logical. Whether an error should be created if the file does not exist. If mustWork=FALSE and the file does not exist, the empty string is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string. The full path to the file in the package cache or the empty string if there is no such file available. Use this in your application code to open the file.
</p>

<hr>
<h2 id='get.dti.trk.endianness'>Determine endianness of TRK file.</h2><span id='topic+get.dti.trk.endianness'></span>

<h3>Description</h3>

<p>Determine endianness of TRK file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dti.trk.endianness(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dti.trk.endianness_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in trk format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>endina character string. one of 'little' or 'big'.
</p>


<h3>Note</h3>

<p>This function checks endiannes via the header size field of the file header, which must be 1000 for TRK files when read with correct enianness. It will stop if the file is not in TRK format, i.e., if the field is not 1000 in any endianness.
</p>

<hr>
<h2 id='get.slice.orientation'>Compute MGH orientation string and direction</h2><span id='topic+get.slice.orientation'></span>

<h3>Description</h3>

<p>Compute MGH orientation string and direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.slice.orientation(Mdc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.slice.orientation_+3A_mdc">Mdc</code></td>
<td>
<p>numeric 3x3 matrix, typically from the <code>header$internal$Mdc</code> field as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: &lsquo;orientation_string': character string of length 3, one uppercase letter per axis. 'direction_name': slice direction, character string, one of &rsquo;sagittal', 'coronal', 'axial' or 'unknown'.
</p>

<hr>
<h2 id='gifti_writer'>Write data to a gifti file.</h2><span id='topic+gifti_writer'></span>

<h3>Description</h3>

<p>Write data to a gifti file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gifti_writer(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gifti_writer_+3A_filepath">filepath</code></td>
<td>
<p>path to the output gifti file</p>
</td></tr>
<tr><td><code id="gifti_writer_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+gifti_xml">gifti_xml</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.nitrc.org/frs/download.php/2871/GIFTI_Surface_Format.pdf">https://www.nitrc.org/frs/download.php/2871/GIFTI_Surface_Format.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  outfile = tempfile(fileext = '.gii');
  dataarrays = list(rep(3.1, 3L), matrix(seq(6), nrow=2L));
  gifti_writer(outfile, dataarrays, datatype=c('NIFTI_TYPE_FLOAT32', 'NIFTI_TYPE_INT32'));

## End(Not run)

</code></pre>

<hr>
<h2 id='gifti_xml'>Get GIFTI XML representation of data.</h2><span id='topic+gifti_xml'></span>

<h3>Description</h3>

<p>Creates a GIFTI XML tree from your datasets (vectors and matrices). The tree can be further modified to add additional data, or written to a file as is to produce a valid GIFTI file (see <code><a href="#topic+gifti_xml_write">gifti_xml_write</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gifti_xml(
  data_array,
  intent = "NIFTI_INTENT_SHAPE",
  datatype = "NIFTI_TYPE_FLOAT32",
  encoding = "GZipBase64Binary",
  endian = "LittleEndian",
  transform_matrix = NULL,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gifti_xml_+3A_data_array">data_array</code></td>
<td>
<p>list of data vectors and/or data matrices.</p>
</td></tr>
<tr><td><code id="gifti_xml_+3A_intent">intent</code></td>
<td>
<p>vector of NIFTI intent strings for the data vectors in 'data_array' parameter, see <code><a href="gifti.html#topic+convert_intent">convert_intent</a></code>. Example: 'NIFTI_INTENT_SHAPE'. See https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/group__NIFTI1__INTENT__CODES.html.</p>
</td></tr>
<tr><td><code id="gifti_xml_+3A_datatype">datatype</code></td>
<td>
<p>vector of NIFTI datatype strings. Example: 'NIFTI_TYPE_FLOAT32'. Should be suitable for your data.</p>
</td></tr>
<tr><td><code id="gifti_xml_+3A_encoding">encoding</code></td>
<td>
<p>vector of encoding definition strings. One of 'ASCII', 'Base64Binary', 'GZipBase64Binary'.</p>
</td></tr>
<tr><td><code id="gifti_xml_+3A_endian">endian</code></td>
<td>
<p>vector of endian definition strings. One of 'LittleEndian' or 'BigEndian'. See <code><a href="gifti.html#topic+convert_endian">convert_endian</a></code>.</p>
</td></tr>
<tr><td><code id="gifti_xml_+3A_transform_matrix">transform_matrix</code></td>
<td>
<p>optional, a list of transformation matrices, one for each data_array. If one of the data arrays has none, pass &lsquo;NA'. Each transformation matrix in the outer list has to be a 4x4 matrix or given as a named list with entries &rsquo;transform_matrix', 'data_space', and 'transformed_space'. Here is an example: <code>list('transform_matrix'=diag(4), 'data_space'='NIFTI_XFORM_UNKNOWN', 'transformed_space'='NIFTI_XFORM_UNKNOWN')</code>.</p>
</td></tr>
<tr><td><code id="gifti_xml_+3A_force">force</code></td>
<td>
<p>logical, whether to force writing the data, even if issues like a mismatch of datatype and data values are detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xml tree, see xml2 package. One could modify this tree as needed using xml2 functions, e.g., add metadata.
</p>


<h3>Note</h3>

<p>Unless you want to modify the returned tree manually, you should not need to call this function. Use <code><a href="#topic+gifti_writer">gifti_writer</a></code> instead.
</p>


<h3>References</h3>

<p>See https://www.nitrc.org/frs/download.php/2871/GIFTI_Surface_Format.pdf
</p>


<h3>See Also</h3>

<p>The example for <code><a href="#topic+gifti_xml_write">gifti_xml_write</a></code> shows how to modify the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  my_data_sets = list(rep(3.1, 3L), matrix(seq(6)+0.1, nrow=2L));
  transforms = list(NA, list('transform_matrix'=diag(4), 'data_space'='NIFTI_XFORM_UNKNOWN',
   'transformed_space'='NIFTI_XFORM_UNKNOWN'));
  xmltree = gifti_xml(my_data_sets, datatype='NIFTI_TYPE_FLOAT32', transform_matrix=transforms);
  # Verify that the tree is a valid GIFTI file:
  gifti_xsd = "https://www.nitrc.org/frs/download.php/158/gifti.xsd";
  xml2::xml_validate(xmltree, xml2::read_xml(gifti_xsd));

## End(Not run)

</code></pre>

<hr>
<h2 id='gifti_xml_add_global_metadata'>Add metadata to GIFTI XML tree.</h2><span id='topic+gifti_xml_add_global_metadata'></span>

<h3>Description</h3>

<p>Add metadata to GIFTI XML tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gifti_xml_add_global_metadata(xmltree, metadata_named_list, as_cdata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gifti_xml_add_global_metadata_+3A_xmltree">xmltree</code></td>
<td>
<p>XML tree from xml2</p>
</td></tr>
<tr><td><code id="gifti_xml_add_global_metadata_+3A_metadata_named_list">metadata_named_list</code></td>
<td>
<p>named list, the metadata entries</p>
</td></tr>
<tr><td><code id="gifti_xml_add_global_metadata_+3A_as_cdata">as_cdata</code></td>
<td>
<p>logical, whether to wrap the value in cdata tags</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified tree.
</p>


<h3>Note</h3>

<p>Assumes that there already exists a global MetaData node. Also not that this is not supposed to be used for adding metadata to datarrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  xmltree = gifti_xml(list(rep(3.1, 3L), matrix(seq(6)+0.1, nrow=2L)));
  newtree = gifti_xml_add_global_metadata(xmltree, list("User"="Me", "Weather"="Great"));
  gifti_xsd = "https://www.nitrc.org/frs/download.php/158/gifti.xsd";
  xml2::xml_validate(newtree, xml2::read_xml(gifti_xsd));

## End(Not run)
</code></pre>

<hr>
<h2 id='gifti_xml_write'>Write XML tree to a gifti file.</h2><span id='topic+gifti_xml_write'></span>

<h3>Description</h3>

<p>Write XML tree to a gifti file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gifti_xml_write(filepath, xmltree, options = c("as_xml", "format"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gifti_xml_write_+3A_filepath">filepath</code></td>
<td>
<p>path to the output gifti file</p>
</td></tr>
<tr><td><code id="gifti_xml_write_+3A_xmltree">xmltree</code></td>
<td>
<p>XML tree from xml2</p>
</td></tr>
<tr><td><code id="gifti_xml_write_+3A_options">options</code></td>
<td>
<p>output options passed to <code><a href="xml2.html#topic+write_xml">write_xml</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.nitrc.org/frs/download.php/2871/GIFTI_Surface_Format.pdf">https://www.nitrc.org/frs/download.php/2871/GIFTI_Surface_Format.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  outfile = tempfile(fileext = '.gii');
  my_data_sets = list(rep(3.1, 3L), matrix(seq(6)+0.1, nrow=2L));
  xmltree = gifti_xml(my_data_sets, datatype='NIFTI_TYPE_FLOAT32');
  # Here we add global metadata:
  xmltree = gifti_xml_add_global_metadata(xmltree, list("User"="Me", "Day"="Monday"));
  # Validating your XML never hurts
  gifti_xsd = "https://www.nitrc.org/frs/download.php/158/gifti.xsd";
  xml2::xml_validate(xmltree, xml2::read_xml(gifti_xsd));
  gifti_xml_write(outfile, xmltree);  # Write your custom tree to a file.

## End(Not run)

</code></pre>

<hr>
<h2 id='giftixml_add_labeltable_from_annot'>Add a label tabel from an annotation to a GIFTI XML tree.</h2><span id='topic+giftixml_add_labeltable_from_annot'></span>

<h3>Description</h3>

<p>Computes the LabelTable XML node for the given annotation and adds it to the XML tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giftixml_add_labeltable_from_annot(xmltree, annot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="giftixml_add_labeltable_from_annot_+3A_xmltree">xmltree</code></td>
<td>
<p>an XML tree from xml2, typically the return value from <code><a href="#topic+gifti_xml">gifti_xml</a></code>.</p>
</td></tr>
<tr><td><code id="giftixml_add_labeltable_from_annot_+3A_annot">annot</code></td>
<td>
<p>an fs.annotation, the included data will be used to compute the LabelTable node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML tree from xml2, the modified tree with the LabelTable added below the root node.
</p>

<hr>
<h2 id='giftixml_add_labeltable_posneg'>Add a standard label tabel for to a GIFTI XML tree.</h2><span id='topic+giftixml_add_labeltable_posneg'></span>

<h3>Description</h3>

<p>This label table is suitable for labels in the FreeSurfer sense, i.e., if only a positive label (1) and a negative label (0) exist in the label data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giftixml_add_labeltable_posneg(xmltree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="giftixml_add_labeltable_posneg_+3A_xmltree">xmltree</code></td>
<td>
<p>an XML tree from xml2, typically the return value from <code><a href="#topic+gifti_xml">gifti_xml</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML tree from xml2, the modified tree with the LabelTable added below the root node.
</p>

<hr>
<h2 id='guess.filename.is.gzipped'>Guess whether a file is gzipped.</h2><span id='topic+guess.filename.is.gzipped'></span>

<h3>Description</h3>

<p>Guess whether a file is gzipped, based on the file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.filename.is.gzipped(filepath, gz_extensions = c(".gz", ".mgz"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess.filename.is.gzipped_+3A_filepath">filepath</code></td>
<td>
<p>string. Path to a file.</p>
</td></tr>
<tr><td><code id="guess.filename.is.gzipped_+3A_gz_extensions">gz_extensions</code></td>
<td>
<p>list of strings. A list of suffixes that is considered indicative for the file being gzipped. Defaults to c(&quot;.gz&quot;, &quot;.mgz&quot;). Case does not matter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether this function thinks the file is gzipped.
</p>

<hr>
<h2 id='has_pandoc'>Check for pandoc availability on system.</h2><span id='topic+has_pandoc'></span>

<h3>Description</h3>

<p>Check for pandoc availability on system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_pandoc()
</code></pre>


<h3>Value</h3>

<p>logical, whether Pandoc is available.
</p>

<hr>
<h2 id='int.to.col.brainvoyager'>Convert 32 bit integer to RGB color as described in Brainvoyager SRF file spec.</h2><span id='topic+int.to.col.brainvoyager'></span>

<h3>Description</h3>

<p>Convert 32 bit integer to RGB color as described in Brainvoyager SRF file spec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int.to.col.brainvoyager(int_val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int.to.col.brainvoyager_+3A_int_val">int_val</code></td>
<td>
<p>the 32 bit integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an rgb color
</p>

<hr>
<h2 id='is.bvsmp'>Check whether object is a bvsmp instance.</h2><span id='topic+is.bvsmp'></span>

<h3>Description</h3>

<p>Check whether object is a bvsmp instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bvsmp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bvsmp_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is an bvsmp instane (that is, has &quot;bvsmp&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.fs.annot'>Check whether object is an fs.annot</h2><span id='topic+is.fs.annot'></span>

<h3>Description</h3>

<p>Check whether object is an fs.annot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fs.annot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fs.annot_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a brain surface annotation (that is, has &quot;fs.annot&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.fs.label'>Check whether object is an fs.label</h2><span id='topic+is.fs.label'></span>

<h3>Description</h3>

<p>Check whether object is an fs.label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fs.label(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fs.label_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a brain surface label (that is, has 'fs.label' amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.fs.surface'>Check whether object is an fs.surface</h2><span id='topic+is.fs.surface'></span>

<h3>Description</h3>

<p>Check whether object is an fs.surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fs.surface(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fs.surface_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a brain surface (that is, has &quot;fs.surface&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.fs.volume'>Check whether object is an fs.volume</h2><span id='topic+is.fs.volume'></span>

<h3>Description</h3>

<p>Check whether object is an fs.volume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fs.volume(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fs.volume_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a brain volume (that is, has &quot;fs.volume&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.mghheader'>Check whether object is an mghheader</h2><span id='topic+is.mghheader'></span>

<h3>Description</h3>

<p>Check whether object is an mghheader
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mghheader(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mghheader_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is an MGH header (that is, has &quot;mghheader&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='linesplit.fixed'>Split a string into fixed-length parts.</h2><span id='topic+linesplit.fixed'></span>

<h3>Description</h3>

<p>Split a string into fixed-length parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesplit.fixed(
  cline,
  length_per_part,
  num_parts_expected = NULL,
  error_tag = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linesplit.fixed_+3A_cline">cline</code></td>
<td>
<p>character string, the input line</p>
</td></tr>
<tr><td><code id="linesplit.fixed_+3A_length_per_part">length_per_part</code></td>
<td>
<p>integer, number of characters per part</p>
</td></tr>
<tr><td><code id="linesplit.fixed_+3A_num_parts_expected">num_parts_expected</code></td>
<td>
<p>integer, the number of parts. Leave at NULL if this is not known.</p>
</td></tr>
<tr><td><code id="linesplit.fixed_+3A_error_tag">error_tag</code></td>
<td>
<p>optional character string, how to identify the line in a parsing error message. Could be the line number, or whatever. Only relevant if 'num_parts_expected' is not matched.</p>
</td></tr>
</table>

<hr>
<h2 id='list_opt_data'>Get file names available in package cache.</h2><span id='topic+list_opt_data'></span>

<h3>Description</h3>

<p>Get file names of optional data files which are available in the local package cache. You can access these files with get_optional_data_file().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_opt_data()
</code></pre>


<h3>Value</h3>

<p>vector of strings. The file names available, relative to the package cache.
</p>

<hr>
<h2 id='mgh.is.conformed'>Determine whether an MGH volume is conformed.</h2><span id='topic+mgh.is.conformed'></span>

<h3>Description</h3>

<p>In the FreeSurfer sense, *conformed* means that the volume is in coronal primary slice direction, has dimensions 256x256x256 and a voxel size of 1 mm in all 3 directions. The slice direction can only be determined if the header contains RAS information, if it does not, the volume is not conformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgh.is.conformed(mgh_header, voxel_size_tolerance = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgh.is.conformed_+3A_mgh_header">mgh_header</code></td>
<td>
<p>Header of the mgh datastructure, as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
<tr><td><code id="mgh.is.conformed_+3A_voxel_size_tolerance">voxel_size_tolerance</code></td>
<td>
<p>double, the tolerance to accept when comparing the voxel size to the required value of '1.0'. Defaults to '1e-4'. Leave this alone unless you know what you are doing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the volume is *conformed*.
</p>

<hr>
<h2 id='mghheader'>Constructor to init MGH header instance.</h2><span id='topic+mghheader'></span>

<h3>Description</h3>

<p>Constructor to init MGH header instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader(dims, mri_dtype_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader_+3A_dims">dims</code></td>
<td>
<p>integer vector of length 4, the header dimensions. Example: <code>c(256L, 256L, 256L, 1L)</code>.</p>
</td></tr>
<tr><td><code id="mghheader_+3A_mri_dtype_code">mri_dtype_code</code></td>
<td>
<p>integer, a valid MRI datatype. See <code><a href="#topic+translate.mri.dtype">translate.mri.dtype</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list representing the header
</p>

<hr>
<h2 id='mghheader.centervoxelRAS.from.firstvoxelRAS'>Compute RAS coords of center voxel.</h2><span id='topic+mghheader.centervoxelRAS.from.firstvoxelRAS'></span>

<h3>Description</h3>

<p>Compute RAS coords of center voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.centervoxelRAS.from.firstvoxelRAS(header, first_voxel_RAS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.centervoxelRAS.from.firstvoxelRAS_+3A_header">header</code></td>
<td>
<p>Header of the mgh datastructure, as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>. The 'c_r', 'c_a' and 'c_s' values in the header do not matter of course, they are what is computed by this function.</p>
</td></tr>
<tr><td><code id="mghheader.centervoxelRAS.from.firstvoxelRAS_+3A_first_voxel_ras">first_voxel_RAS</code></td>
<td>
<p>numerical vector of length 3, the RAS coordinate of the first voxel in the volume. The first voxel is the voxel with 'CRS=1,1,1' in R, or 'CRS=0,0,0' in C/FreeSurfer. This value is also known as *P0 RAS*.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector of length 3, the RAS coordinate of the center voxel. Also known as *CRAS* or *center RAS*.
</p>

<hr>
<h2 id='mghheader.crs.orientation'>Compute MGH volume orientation string.</h2><span id='topic+mghheader.crs.orientation'></span>

<h3>Description</h3>

<p>Compute MGH volume orientation string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.crs.orientation(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.crs.orientation_+3A_header">header</code></td>
<td>
<p>Header of the mgh datastructure, as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of length 3, one uppercase letter per axis. Each of the three position is a letter from the alphabet: 'LRISAP?'. The meaning is 'L' for left, 'R' for right, 'I' for inferior, 'S' for superior, 'P' for posterior, 'A' for anterior. If the direction cannot be computed, all three characters are '?' for unknown. Of course, each axis ('L/R', 'I/S', 'A/P') is only represented once in the string.
</p>

<hr>
<h2 id='mghheader.is.conformed'>Determine whether an MGH volume is conformed.</h2><span id='topic+mghheader.is.conformed'></span>

<h3>Description</h3>

<p>In the FreeSurfer sense, *conformed* means that the volume is in coronal primary slice direction, has dimensions 256x256x256 and a voxel size of 1 mm in all 3 directions. The slice direction can only be determined if the header contains RAS information, if it does not, the volume is not conformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.is.conformed(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.is.conformed_+3A_header">header</code></td>
<td>
<p>Header of the mgh datastructure, as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the volume is *conformed*.
</p>

<hr>
<h2 id='mghheader.is.ras.valid'>Check whether header contains valid ras information</h2><span id='topic+mghheader.is.ras.valid'></span>

<h3>Description</h3>

<p>Check whether header contains valid ras information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.is.ras.valid(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.is.ras.valid_+3A_header">header</code></td>
<td>
<p>mgh header or 'fs.volume' instance with header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether header contains valid ras information (according to the 'ras_good_flag').
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.is.ras.valid(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.primary.slice.direction'>Compute MGH primary slice direction</h2><span id='topic+mghheader.primary.slice.direction'></span>

<h3>Description</h3>

<p>Compute MGH primary slice direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.primary.slice.direction(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.primary.slice.direction_+3A_header">header</code></td>
<td>
<p>Header of the mgh datastructure, as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the slice direction. One of 'sagittal', 'coronal', 'axial' or 'unknown'.
</p>

<hr>
<h2 id='mghheader.ras2vox'>Compute ras2vox matrix from basic MGH header fields.</h2><span id='topic+mghheader.ras2vox'></span>

<h3>Description</h3>

<p>This is also known as the 'scanner' or 'native' ras2vox. It is the inverse of the respective vox2ras, see <code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.ras2vox(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.ras2vox_+3A_header">header</code></td>
<td>
<p>the MGH header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm1to0">sm1to0</a></code>
</p>
<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.ras2vox(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.ras2vox.tkreg'>Compute ras2vox-tkreg matrix from basic MGH header fields.</h2><span id='topic+mghheader.ras2vox.tkreg'></span>

<h3>Description</h3>

<p>This is also known as the 'tkreg' ras2vox. It is the inverse of the respective vox2ras, see <code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.ras2vox.tkreg(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.ras2vox.tkreg_+3A_header">header</code></td>
<td>
<p>the MGH header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm1to0">sm1to0</a></code>
</p>
<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.ras2vox.tkreg(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.scanner2tkreg'>Compute scanner-RAS 2 tkreg-RAS matrix from basic MGH header fields.</h2><span id='topic+mghheader.scanner2tkreg'></span>

<h3>Description</h3>

<p>This is also known as the 'scanner2tkreg' matrix. Note that this is a RAS-to-RAS matrix. It is the inverse of the 'tkreg2scanner' matrix, see <code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.scanner2tkreg(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.scanner2tkreg_+3A_header">header</code></td>
<td>
<p>the MGH header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.scanner2tkreg(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.tkreg2scanner'>Compute tkreg-RAS to scanner-RAS matrix from basic MGH header fields.</h2><span id='topic+mghheader.tkreg2scanner'></span>

<h3>Description</h3>

<p>This is also known as the 'tkreg2scanner' matrix. Note that this is a RAS-to-RAS matrix. It is the inverse of the 'scanner2tkreg' matrix, see <code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.tkreg2scanner(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.tkreg2scanner_+3A_header">header</code></td>
<td>
<p>the MGH header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.tkreg2scanner(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.update.from.vox2ras'>Update mghheader fields from vox2ras matrix.</h2><span id='topic+mghheader.update.from.vox2ras'></span>

<h3>Description</h3>

<p>Update mghheader fields from vox2ras matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.update.from.vox2ras(header, vox2ras)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.update.from.vox2ras_+3A_header">header</code></td>
<td>
<p>Header of the mgh datastructure, as returned by <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
<tr><td><code id="mghheader.update.from.vox2ras_+3A_vox2ras">vox2ras</code></td>
<td>
<p>4x4 numerical matrix, the vox2ras transformation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list representing the header
</p>

<hr>
<h2 id='mghheader.vox2ras'>Compute vox2ras matrix from basic MGH header fields.</h2><span id='topic+mghheader.vox2ras'></span>

<h3>Description</h3>

<p>This is also known as the 'scanner' or 'native' vox2ras.  It is the inverse of the respective ras2vox, see <code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.vox2ras(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.vox2ras_+3A_header">header</code></td>
<td>
<p>the MGH header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm0to1">sm0to1</a></code>
</p>
<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.vox2ras(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.vox2ras.tkreg'>Compute vox2ras-tkreg matrix from basic MGH header fields.</h2><span id='topic+mghheader.vox2ras.tkreg'></span>

<h3>Description</h3>

<p>This is also known as the 'tkreg' vox2ras. It is the inverse of the respective ras2vox, see <code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.vox2ras.tkreg(header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.vox2ras.tkreg_+3A_header">header</code></td>
<td>
<p>the MGH header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm0to1">sm0to1</a></code>
</p>
<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    mghheader.vox2ras.tkreg(vdh$header);

</code></pre>

<hr>
<h2 id='mghheader.vox2vox'>Compute vox2vox matrix between two volumes.</h2><span id='topic+mghheader.vox2vox'></span>

<h3>Description</h3>

<p>Compute vox2vox matrix between two volumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mghheader.vox2vox(header_from, header_to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mghheader.vox2vox_+3A_header_from">header_from</code></td>
<td>
<p>the MGH header of the source volume</p>
</td></tr>
<tr><td><code id="mghheader.vox2vox_+3A_header_to">header_to</code></td>
<td>
<p>the MGH header of the target volume</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>

<hr>
<h2 id='mni152reg'>Get fsaverage (MNI305) to MNI152 transformation matrix.</h2><span id='topic+mni152reg'></span>

<h3>Description</h3>

<p>The uses the 4x4 matrix from the FreeSurfer CoordinateSystems documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mni152reg()
</code></pre>


<h3>Note</h3>

<p>There are better ways to achieve this transformation than using this matrix, see Wu et al., 'Accurate nonlinear mapping between MNI volumetric and FreeSurfer surface coordinate system', Hum Brain Mapp. 2018 Sep; 39(9): 3793–3808. doi: 10.1002/hbm.24213. The mentioned method is available in R from the 'regfusionr' package (GitHub only atom, not on CRAN).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    coords_tf = doapply.transform.mtx(c(10.0, -20.0, 35.0), mni152reg());
    coords_tf; #  10.695, -18.409, 36.137
    doapply.transform.mtx(coords_tf, solve(mni152reg()));

</code></pre>

<hr>
<h2 id='mri_dtype_numbytes'>Get size of MRI dtype in bytes.</h2><span id='topic+mri_dtype_numbytes'></span>

<h3>Description</h3>

<p>Get size of MRI dtype in bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mri_dtype_numbytes(mri_dtype_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mri_dtype_numbytes_+3A_mri_dtype_code">mri_dtype_code</code></td>
<td>
<p>integer, the MRI data type code. See <code><a href="#topic+translate.mri.dtype">translate.mri.dtype</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the number of bytes
</p>

<hr>
<h2 id='ni1header.for.data'>Create NIFTI v1 header suitable for given data.</h2><span id='topic+ni1header.for.data'></span>

<h3>Description</h3>

<p>Create NIFTI v1 header suitable for given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ni1header.for.data(niidata, allow_fshack = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ni1header.for.data_+3A_niidata">niidata</code></td>
<td>
<p>array of numeric (integer or double) data, can have up to 7 dimensions.</p>
</td></tr>
<tr><td><code id="ni1header.for.data_+3A_allow_fshack">allow_fshack</code></td>
<td>
<p>logical, whether to allow data in which the first dimension is larger than 32767, and use the FreeSurfer NIFTI v1 hack to support his. The hack will be used only if needed. WARNING: Files written with the hack do not conform to the NIFTI v1 standard and will not be read correctly by most software. All FreeSurfer tools and the Python 'nibabel' module support it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NIFTI v1 header (see <code><a href="#topic+ni1header.template">ni1header.template</a></code>) in which the datatype, bitpix, dim and dim_raw fields have been set to values suitable for the given data. Feel free to change the other fields.
</p>

<hr>
<h2 id='ni1header.template'>Create a template NIFTI v1 header. You will have to adapt it for your use case.</h2><span id='topic+ni1header.template'></span>

<h3>Description</h3>

<p>Create a template NIFTI v1 header. You will have to adapt it for your use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ni1header.template()
</code></pre>


<h3>Value</h3>

<p>named list, the NIFTI v1 header. All fields are present and filled with values of a proper type. Whether or not they make sense is up to you, but you will most likely have to adapt at least the following fields to your data: 'dim_raw', 'datatype', 'bitpix'.
</p>


<h3>Note</h3>

<p>Commonly used data type settings are: for signed integers datatype = '8L' and bitpix = '32L'; for floats datatype = '16L' and bitpix = '32L'. See the NIFTI v1 standard for more options.  You may want to call <code><a href="#topic+ni1header.for.data">ni1header.for.data</a></code> instead of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ni1header.for.data">ni1header.for.data</a></code>
</p>

<hr>
<h2 id='ni2header.for.data'>Create NIFTI v2 header suitable for given data.</h2><span id='topic+ni2header.for.data'></span>

<h3>Description</h3>

<p>Create NIFTI v2 header suitable for given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ni2header.for.data(niidata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ni2header.for.data_+3A_niidata">niidata</code></td>
<td>
<p>array of numeric (integer or double) data, can have up to 7 dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NIFTI v2 header (see <code><a href="#topic+ni2header.template">ni2header.template</a></code>) in which the datatype, bitpix, dim and dim_raw fields have been set to values suitable for the given data. Feel free to change the other fields.
</p>

<hr>
<h2 id='ni2header.template'>Create a template NIFTI v2 header. You will have to adapt it for your use case.</h2><span id='topic+ni2header.template'></span>

<h3>Description</h3>

<p>Create a template NIFTI v2 header. You will have to adapt it for your use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ni2header.template()
</code></pre>


<h3>Value</h3>

<p>named list, the NIFTI v2 header. All fields are present and filled with values of a proper type. Whether or not they make sense is up to you, but you will most likely have to adapt at least the following fields to your data: 'dim_raw', 'datatype', 'bitpix'.
</p>


<h3>Note</h3>

<p>Commonly used data type settings are: for signed integers datatype = '8L' and bitpix = '32L'; for floats datatype = '16L' and bitpix = '32L'. See the NIFTI v2 standard for more options. You may want to call <code><a href="#topic+ni2header.for.data">ni2header.for.data</a></code> instead of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ni2header.for.data">ni2header.for.data</a></code>
</p>

<hr>
<h2 id='nifti.datadim.from.dimfield'>Compute data dimensions from the 'dim' field of the NIFTI (v1 or v2) header.</h2><span id='topic+nifti.datadim.from.dimfield'></span>

<h3>Description</h3>

<p>Compute data dimensions from the 'dim' field of the NIFTI (v1 or v2) header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.datadim.from.dimfield(dimfield)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.datadim.from.dimfield_+3A_dimfield">dimfield</code></td>
<td>
<p>integer vector of length 8, the 'dim' field of a NIFTI v1 or v2 header, as returned by <code><a href="#topic+read.nifti2.header">read.nifti2.header</a></code> or <code><a href="#topic+read.nifti1.header">read.nifti1.header</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length &lt;= 7. The lengths of the used data dimensions. The 'dim' field always has length 8, and the first entry is the number of actually used dimensions. The return value is constructed by stripping the first field and returning the used fields.
</p>


<h3>See Also</h3>

<p>Other NIFTI helper functions: 
<code><a href="#topic+nifti.datadim.to.dimfield">nifti.datadim.to.dimfield</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   nifti.datadim.from.dimfield(c(3, 256, 256, 256, 1, 1, 1, 1));

</code></pre>

<hr>
<h2 id='nifti.datadim.to.dimfield'>Compute NIFTI dim field for data dimension.</h2><span id='topic+nifti.datadim.to.dimfield'></span>

<h3>Description</h3>

<p>Compute NIFTI dim field for data dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.datadim.to.dimfield(datadim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.datadim.to.dimfield_+3A_datadim">datadim</code></td>
<td>
<p>integer vector, the result of calling 'dim' on your data. The length must be &lt;= 7.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NIFTI header 'dim' field, an integer vector of length 8
</p>


<h3>See Also</h3>

<p>Other NIFTI helper functions: 
<code><a href="#topic+nifti.datadim.from.dimfield">nifti.datadim.from.dimfield</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   nifti.datadim.to.dimfield(c(256, 256, 256));

</code></pre>

<hr>
<h2 id='nifti.dtype.info'>Compute NIFTI v1 data type info from datatype and bitpix header field.</h2><span id='topic+nifti.dtype.info'></span>

<h3>Description</h3>

<p>Compute NIFTI v1 data type info from datatype and bitpix header field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.dtype.info(datatype, bitpix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.dtype.info_+3A_datatype">datatype</code></td>
<td>
<p>integer, the 'datatype' NIFTI v1 header field</p>
</td></tr>
<tr><td><code id="nifti.dtype.info_+3A_bitpix">bitpix</code></td>
<td>
<p>integer, the 'bitpix' NIFTI v1 header field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'mri_dtype': the MRI data type, as used by FreeSurfer for MGH files, 'r_dtype': the R data type.
</p>

<hr>
<h2 id='nifti.field.check.length'>Check whether vector has expected length.</h2><span id='topic+nifti.field.check.length'></span>

<h3>Description</h3>

<p>Check whether vector has expected length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.field.check.length(niiheader, fields, dlength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.field.check.length_+3A_niiheader">niiheader</code></td>
<td>
<p>named list, representing a NIFTI v1 or v2 header</p>
</td></tr>
<tr><td><code id="nifti.field.check.length_+3A_fields">fields</code></td>
<td>
<p>vector of character string, the field names to check</p>
</td></tr>
<tr><td><code id="nifti.field.check.length_+3A_dlength">dlength</code></td>
<td>
<p>integer, the expected length of all fields</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the checks were okay
</p>

<hr>
<h2 id='nifti.field.check.nchar.max'>Check whether character string fields have less than or equal to expected length.</h2><span id='topic+nifti.field.check.nchar.max'></span>

<h3>Description</h3>

<p>Check whether character string fields have less than or equal to expected length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.field.check.nchar.max(niiheader, fields, dlength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.field.check.nchar.max_+3A_niiheader">niiheader</code></td>
<td>
<p>named list, representing a NIFTI v1 or v2 header</p>
</td></tr>
<tr><td><code id="nifti.field.check.nchar.max_+3A_fields">fields</code></td>
<td>
<p>vector of character string, the field names to check</p>
</td></tr>
<tr><td><code id="nifti.field.check.nchar.max_+3A_dlength">dlength</code></td>
<td>
<p>integer, the max length of all fields</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the checks were okay
</p>

<hr>
<h2 id='nifti.file.uses.fshack'>Determine whether a NIFTI file uses the FreeSurfer hack.</h2><span id='topic+nifti.file.uses.fshack'></span>

<h3>Description</h3>

<p>Determine whether a NIFTI file uses the FreeSurfer hack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.file.uses.fshack(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.file.uses.fshack_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v1 file (single file version), which can contain the FreeSurfer hack.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the file header contains the FreeSurfer format hack. See <code><a href="#topic+read.nifti1.header">read.nifti1.header</a></code> for details. This function detects NIFTI v2 files, but as they cannot contain the hack, it will always return 'FALSE' for them.
</p>


<h3>Note</h3>

<p>Applying this function to files which are not in NIFTI format will result in an error. See <code><a href="#topic+nifti.file.version">nifti.file.version</a></code> to determine whether a file is a NIFTI file.
</p>

<hr>
<h2 id='nifti.file.version'>Determine NIFTI file version information and whether file is a NIFTI file.</h2><span id='topic+nifti.file.version'></span>

<h3>Description</h3>

<p>Determine NIFTI file version information and whether file is a NIFTI file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.file.version(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.file.version_+3A_filepath">filepath</code></td>
<td>
<p>path to a file in NIFTI v1 or v2 format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the NIFTI file version. One if '1' for NIFTI v1 files, '2' for NIFTI v2 files, or 'NULL' if the file is not a NIFTI file.
</p>

<hr>
<h2 id='nifti.header.check'>Perform basic sanity checks on NIFTI header data. These are in no way meant to be exhaustive.</h2><span id='topic+nifti.header.check'></span>

<h3>Description</h3>

<p>Perform basic sanity checks on NIFTI header data. These are in no way meant to be exhaustive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.header.check(niiheader, nifti_version = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.header.check_+3A_niiheader">niiheader</code></td>
<td>
<p>named list, the NIFTI header.</p>
</td></tr>
<tr><td><code id="nifti.header.check_+3A_nifti_version">nifti_version</code></td>
<td>
<p>integer, one of 1L or 2L. The NIFTI format version.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the check was okay
</p>

<hr>
<h2 id='nifti.space.info'>Compute NIFTI space unit info from xyzt_units header field.</h2><span id='topic+nifti.space.info'></span>

<h3>Description</h3>

<p>Compute NIFTI space unit info from xyzt_units header field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.space.info(xyzt_units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.space.info_+3A_xyzt_units">xyzt_units</code></td>
<td>
<p>a single character, the 'xyzt_units' NIFTI header field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'code': the NIFTI unit code as a decimal integer, 'name': character string, the unit name, 'scaling': float, the scaling factor for the unit, relative to the FreeSurfer space unit ('mm').
</p>

<hr>
<h2 id='nifti.time.info'>Compute NIFTI time unit info from xyzt_units header field.</h2><span id='topic+nifti.time.info'></span>

<h3>Description</h3>

<p>Compute NIFTI time unit info from xyzt_units header field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.time.info(xyzt_units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.time.info_+3A_xyzt_units">xyzt_units</code></td>
<td>
<p>a single character, the 'xyzt_units' NIFTI header field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'code': the NIFTI unit code as a decimal integer, 'name': character string, the unit name, 'scaling': float, the scaling factor for the unit, relative to the FreeSurfer time unit  ('ms').
</p>

<hr>
<h2 id='nifti.transform.type.name'>Get the name of the transform type from a form code.</h2><span id='topic+nifti.transform.type.name'></span>

<h3>Description</h3>

<p>The form code is a code stored in the 'sform_code' and/or 'qform_code' NIFTI header fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti.transform.type.name(form_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti.transform.type.name_+3A_form_code">form_code</code></td>
<td>
<p>integer, the value retrieved from the 'sform_code' or the 'qform_code' NIFTI header fields</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the meaning of the code. Usually this expresses to what the data will be aligned after application of the vox2ras transformation method. (The type of transformation to perform in order to achieve this alignment depends on whether the value was retrieved from the 'sform' or the 'qform' field and does not matter here.)
</p>

<hr>
<h2 id='parse.stl.ascii.face'>Parse a single ASCII STL face.</h2><span id='topic+parse.stl.ascii.face'></span>

<h3>Description</h3>

<p>Parse a single ASCII STL face.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.stl.ascii.face(stl_face_lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.stl.ascii.face_+3A_stl_face_lines">stl_face_lines</code></td>
<td>
<p>vector of exactly 7 character strings, the lines from an STL ASCII file defining a triangular face.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'face_normal': double matrix with 1 row and 3 columns, the face normal. 'vertex_coords': double matrix with 3 rows and 3 columns, the 3x3 vertex coordinates of the face, each row contain the x, y, and z coordinate of a vertex.
</p>

<hr>
<h2 id='parse.transform.matrix.lines'>Parse matrix from text file lines.</h2><span id='topic+parse.transform.matrix.lines'></span>

<h3>Description</h3>

<p>Parse matrix from text file lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.transform.matrix.lines(file_lines, ignore_line_suffix = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.transform.matrix.lines_+3A_file_lines">file_lines</code></td>
<td>
<p>vector of 3 character strings, the matrix lines. The separator is assumed to be a single space.</p>
</td></tr>
<tr><td><code id="parse.transform.matrix.lines_+3A_ignore_line_suffix">ignore_line_suffix</code></td>
<td>
<p>character string, a line suffix that will be stripped from the end of each line if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical 4x4 matrix, the parsed matrix
</p>

<hr>
<h2 id='ply.header.lines'>Generate PLY format header lines</h2><span id='topic+ply.header.lines'></span>

<h3>Description</h3>

<p>Generate PLY format header lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ply.header.lines(num_verts, num_faces, use_vertex_colors)
</code></pre>

<hr>
<h2 id='polygon.soup.to.indexed.mesh'>Turn polygon soup into indexed mesh.</h2><span id='topic+polygon.soup.to.indexed.mesh'></span>

<h3>Description</h3>

<p>Some mesh file formats like STL do not store the faces as indices into a vertex list ('indexed mesh'), but repeat all vertex coordinates for each face ('polygon soup'). This function creates an indexed mesh from a polysoup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon.soup.to.indexed.mesh(faces_vertex_coords, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygon.soup.to.indexed.mesh_+3A_faces_vertex_coords">faces_vertex_coords</code></td>
<td>
<p>numerical matrix with *n* rows and 3 columns, the vertex coordinates of the faces. Each row contains the x,y,z coordinates of a single vertex, and three consecutive vertex rows form a triangular face.</p>
</td></tr>
<tr><td><code id="polygon.soup.to.indexed.mesh_+3A_digits">digits</code></td>
<td>
<p>the precision (number of digits after decimal separator) to use when to determine whether two x,y,z coords define the same vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an indexed mesh, as an 'fs.surface' instance (see <code><a href="#topic+read.fs.surface">read.fs.surface</a></code>).
</p>

<hr>
<h2 id='print.fs.annot'>Print description of a brain atlas or annotation.</h2><span id='topic+print.fs.annot'></span>

<h3>Description</h3>

<p>Print description of a brain atlas or annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.annot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fs.annot_+3A_x">x</code></td>
<td>
<p>brain surface annotation or atlas with class 'fs.annot'.</p>
</td></tr>
<tr><td><code id="print.fs.annot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.fs.label'>Print description of a brain surface label.</h2><span id='topic+print.fs.label'></span>

<h3>Description</h3>

<p>Print description of a brain surface label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.label'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fs.label_+3A_x">x</code></td>
<td>
<p>brain surface label with class 'fs.label'.</p>
</td></tr>
<tr><td><code id="print.fs.label_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.fs.patch'>Print description of a brain surface patch.</h2><span id='topic+print.fs.patch'></span>

<h3>Description</h3>

<p>Print description of a brain surface patch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.patch'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fs.patch_+3A_x">x</code></td>
<td>
<p>brain surface patch with class 'fs.patch'.</p>
</td></tr>
<tr><td><code id="print.fs.patch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.fs.surface'>Print description of a brain surface.</h2><span id='topic+print.fs.surface'></span>

<h3>Description</h3>

<p>Print description of a brain surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.surface'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fs.surface_+3A_x">x</code></td>
<td>
<p>brain surface with class 'fs.surface'.</p>
</td></tr>
<tr><td><code id="print.fs.surface_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.fs.volume'>Print description of a brain volume.</h2><span id='topic+print.fs.volume'></span>

<h3>Description</h3>

<p>Print description of a brain volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.volume'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fs.volume_+3A_x">x</code></td>
<td>
<p>brain volume with class 'fs.volume'.</p>
</td></tr>
<tr><td><code id="print.fs.volume_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='ras.to.surfaceras'>Translate RAS coordinates, as used in volumes by applying vox2ras, to surface RAS.</h2><span id='topic+ras.to.surfaceras'></span>

<h3>Description</h3>

<p>Translate RAS coordinates, as used in volumes by applying vox2ras, to surface RAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras.to.surfaceras(header_cras, ras_coords, first_voxel_RAS = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ras.to.surfaceras_+3A_header_cras">header_cras</code></td>
<td>
<p>an MGH header instance from which to extract the cras (center RAS), or the cras vector, i.e., a numerical vector of length 3</p>
</td></tr>
<tr><td><code id="ras.to.surfaceras_+3A_ras_coords">ras_coords</code></td>
<td>
<p>nx3 numerical vector, the input surface RAS coordinates. Could be the vertex coordinates of an 'fs.surface' instance, or the RAS coords from a surface label.</p>
</td></tr>
<tr><td><code id="ras.to.surfaceras_+3A_first_voxel_ras">first_voxel_RAS</code></td>
<td>
<p>the RAS of the first voxel, see <code><a href="#topic+mghheader.centervoxelRAS.from.firstvoxelRAS">mghheader.centervoxelRAS.from.firstvoxelRAS</a></code> for details. Ignored if 'header_cras' is a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the surface RAS coords for the input RAS coords
</p>


<h3>Note</h3>

<p>The RAS can be computed from Surface RAS by adding the center RAS coordinates, i.e., it is nothing but a translation.
</p>

<hr>
<h2 id='ras.to.talairachras'>Compute MNI talairach coordinates from RAS coords.</h2><span id='topic+ras.to.talairachras'></span>

<h3>Description</h3>

<p>Compute MNI talairach coordinates from RAS coords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras.to.talairachras(ras_coords, talairach, invert_transform = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ras.to.talairachras_+3A_ras_coords">ras_coords</code></td>
<td>
<p>nx3 numerical vector, the input surface RAS coordinates. Could be the vertex coordinates of an 'fs.surface' instance, or the RAS coords from a surface label.</p>
</td></tr>
<tr><td><code id="ras.to.talairachras_+3A_talairach">talairach</code></td>
<td>
<p>the 4x4 numerical talairach matrix, or a character string which will be interpreted as the path to an xfm file containing the matrix (typically '$SUBJECTS_DIR/$subject/mri/transforms/talairach.xfm').</p>
</td></tr>
<tr><td><code id="ras.to.talairachras_+3A_invert_transform">invert_transform</code></td>
<td>
<p>logical, whether to invert the transform. Do not use this, call <code>link{talairachras.to.ras}</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Talairach RAS coordinates for the given RAS coordinates
</p>


<h3>Note</h3>

<p>You can use this to compute the Talairach coordinate of a voxel, based on its RAS coordinate.
</p>

<hr>
<h2 id='read_nisurface'>Read a surface, based on the file path without extension.</h2><span id='topic+read_nisurface'></span>

<h3>Description</h3>

<p>Tries to read all files which can be constructed from the base path and the given extensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nisurface(filepath_noext, extensions = c("", ".asc", ".gii"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_nisurface_+3A_filepath_noext">filepath_noext</code></td>
<td>
<p>character string, the full path to the input surface file without file extension.</p>
</td></tr>
<tr><td><code id="read_nisurface_+3A_extensions">extensions</code></td>
<td>
<p>vector of character strings, the file extensions to try.</p>
</td></tr>
<tr><td><code id="read_nisurface_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a></code>. Allows you to set the 'methods'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of 'fs.surface', read from the file. See <code><a href="#topic+read.fs.surface">read.fs.surface</a></code> for details. If none of the reader methods succeed, an error is raised.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    surface_filepath_noext =
     paste(get_optional_data_filepath("subjects_dir/subject1/surf/"),
     'lh.white', sep="");
    mesh = read_nisurface(surface_filepath_noext);
    mesh;
 
## End(Not run)

</code></pre>

<hr>
<h2 id='read_nisurfacefile'>S3 method to read a neuroimaging surface file.</h2><span id='topic+read_nisurfacefile'></span>

<h3>Description</h3>

<p>Tries to read the file with all implemented surface format reader methods. The file must exist. With the default settings, one can read files in the following surface formats: 1) FreeSurfer binary surface format (e.g., 'surf/lh.white'). 2) FreeSurfer ASCII surface format (e.g., 'surf/lh.white,asc'). 3) GIFTI surface format, only if package 'gifti' is installed. See <code>gifti::read_gifti</code> for details. Feel free to implement additional methods. Hint:keep in mind that they should return one-based indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nisurfacefile(filepath, methods = c("fsnative", "fsascii", "gifti"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_nisurfacefile_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the input surface file.</p>
</td></tr>
<tr><td><code id="read_nisurfacefile_+3A_methods">methods</code></td>
<td>
<p>list of character strings, the formats to try. Each of these must have a function called <code>read_nisurface.&lt;method&gt;</code>, which must return an 'fs.surface' instance on success.</p>
</td></tr>
<tr><td><code id="read_nisurfacefile_+3A_...">...</code></td>
<td>
<p>parameters passed on to the individual methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of 'fs.surface', read from the file. See <code><a href="#topic+read.fs.surface">read.fs.surface</a></code> for details. If none of the reader methods succeed, an error is raised.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    surface_file = system.file("extdata", "lh.tinysurface",
                            package = "freesurferformats", mustWork = TRUE);
    mesh = read_nisurface(surface_file);
    mesh;

</code></pre>

<hr>
<h2 id='read_nisurfacefile.fsascii'>Read a FreeSurfer ASCII surface file.</h2><span id='topic+read_nisurfacefile.fsascii'></span>

<h3>Description</h3>

<p>Read a FreeSurfer ASCII surface file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsascii'
read_nisurfacefile(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_nisurfacefile.fsascii_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the input surface file.</p>
</td></tr>
<tr><td><code id="read_nisurfacefile.fsascii_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of 'fs.surface', read from the file. See <code><a href="#topic+read.fs.surface">read.fs.surface</a></code> for details. If none of the reader methods succeed, an error is raised.
</p>

<hr>
<h2 id='read_nisurfacefile.fsnative'>Read a FreeSurfer ASCII surface file.</h2><span id='topic+read_nisurfacefile.fsnative'></span>

<h3>Description</h3>

<p>Read a FreeSurfer ASCII surface file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsnative'
read_nisurfacefile(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_nisurfacefile.fsnative_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the input surface file.</p>
</td></tr>
<tr><td><code id="read_nisurfacefile.fsnative_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+read.fs.surface">read.fs.surface</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of 'fs.surface', read from the file. See <code><a href="#topic+read.fs.surface">read.fs.surface</a></code> for details. If none of the reader methods succeed, an error is raised.
</p>

<hr>
<h2 id='read_nisurfacefile.gifti'>Read a gifti file as a surface.</h2><span id='topic+read_nisurfacefile.gifti'></span>

<h3>Description</h3>

<p>Read a gifti file as a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gifti'
read_nisurfacefile(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_nisurfacefile.gifti_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the input surface file.</p>
</td></tr>
<tr><td><code id="read_nisurfacefile.gifti_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of 'fs.surface', read from the file. See <code><a href="#topic+read.fs.surface">read.fs.surface</a></code> for details. If none of the reader methods succeed, an error is raised.
</p>

<hr>
<h2 id='read.dti.tck'>Read DTI tracking data from file in MRtrix 'TCK' format.</h2><span id='topic+read.dti.tck'></span>

<h3>Description</h3>

<p>Read DTI tracking data from file in MRtrix 'TCK' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dti.tck(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dti.tck_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the <code>TCK</code> file to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries 'header' and 'tracks'. The tracks are organized into a list of matrices. Each n x 3 matrix represents the coordinates for the n points of one track, the values in each row are the xyz coords.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 tckf = "~/simple.tck";
 tck = read.dti.tck(tckf);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.dti.trk'>Read fiber tracks from Diffusion Toolkit in trk format.</h2><span id='topic+read.dti.trk'></span>

<h3>Description</h3>

<p>Read fiber tracks from Diffusion Toolkit in trk format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dti.trk(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dti.trk_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in trk format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the parsed file data. The naming of the variables follows the spec at <code>http://trackvis.org/docs/?subsect=fileformat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
trk = read.dti.trk("~/simple.trk");
trk2 = read.dti.trk("~/standard.trk");
trk3 = read.dti.trk("~/complex_big_endian.trk");

## End(Not run)

</code></pre>

<hr>
<h2 id='read.dti.tsf'>Read DTI tracking per-coord data from file in MRtrix 'TSF' format.</h2><span id='topic+read.dti.tsf'></span>

<h3>Description</h3>

<p>Read DTI tracking per-coord data from file in MRtrix 'TSF' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dti.tsf(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dti.tsf_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the <code>TSF</code> file to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries 'header' and 'scalars'. The scala data are available in 2 representations: 'merged': a vector of all values (requires external knowledge on track borders), and 'scalar_list': organized into a list of vectors. Each vector represents the values for the points of one track.
</p>


<h3>Note</h3>

<p>The data in such a file is one value per track point, the tracks are not part of the file but come in the matching TCK file.
</p>


<h3>See Also</h3>

<p><code>read.dti.tck</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 tsff = "~/simple.tsf";
 tsf = read.dti.tsf(tsff);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.element.counts.ply.header'>Determine element counts from PLY file header.</h2><span id='topic+read.element.counts.ply.header'></span>

<h3>Description</h3>

<p>Determine element counts from PLY file header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.element.counts.ply.header(ply_lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.element.counts.ply.header_+3A_ply_lines">ply_lines</code></td>
<td>
<p>vector character strings, all lines of the PLY file</p>
</td></tr>
</table>

<hr>
<h2 id='read.fixed.char.binary'>Read fixed length char, possibly containing embedded zeroes, from binary file.</h2><span id='topic+read.fixed.char.binary'></span>

<h3>Description</h3>

<p>Read fixed length char, possibly containing embedded zeroes, from binary file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fixed.char.binary(filehandle, n, to = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fixed.char.binary_+3A_filehandle">filehandle</code></td>
<td>
<p>connection to read.</p>
</td></tr>
<tr><td><code id="read.fixed.char.binary_+3A_n">n</code></td>
<td>
<p>the number of bytes to read.</p>
</td></tr>
<tr><td><code id="read.fixed.char.binary_+3A_to">to</code></td>
<td>
<p>the target character encoding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the string in the target encoding, with the embedded zeroes removed.
</p>


<h3>Author(s)</h3>

<p>The original version was written by Brandon Whitcher and Volker Schmid. See the source for the full legal info. The coding style was adapted to freesurferformats and the docs were added by Tim Schäfer.
</p>

<hr>
<h2 id='read.fs.annot'>Read file in FreeSurfer annotation format</h2><span id='topic+read.fs.annot'></span>

<h3>Description</h3>

<p>Read a data annotation file in FreeSurfer format. Such a file assigns a label and a color to each vertex of a brain surface. The assignment of labels to vertices is based on at atlas or brain parcellation file. Typically the atlas is available for some standard template subject, and the labels are assigned to another subject by registering it to the template.
For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/label/lh.aparc.annot', which contains the annotation based on the Desikan-Killiany Atlas for the left hemisphere of bert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.annot(
  filepath,
  empty_label_name = "empty",
  metadata = list(),
  default_label_name = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.annot_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input annotation file. Note: gzipped files are supported and gz format is assumed if the filepath ends with &quot;.gz&quot;.</p>
</td></tr>
<tr><td><code id="read.fs.annot_+3A_empty_label_name">empty_label_name</code></td>
<td>
<p>character string, a base name to use to rename regions with empty name in the label table. This should not occur, and you can ignore this parameter setting. A warning will be thrown if this ever triggers. Not to be confused with parameter <code>default_label_name</code>, see below.</p>
</td></tr>
<tr><td><code id="read.fs.annot_+3A_metadata">metadata</code></td>
<td>
<p>named list of arbitrary metadata to store in the instance.</p>
</td></tr>
<tr><td><code id="read.fs.annot_+3A_default_label_name">default_label_name</code></td>
<td>
<p>character string, the label name to use for vertices which have a label code that does not occur in the label table. This is typically the case for the 'unknown' region, which often has code <code>0</code>. You can set this to avoid empty region label names. The typical setting would be 'unknown', however by default we leave the names as-is, so that annots which are read and then written back to files with this library do not differ.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, entries are: &quot;vertices&quot; vector of n vertex indices, starting with 0. &quot;label_codes&quot;: vector of n integers, each entry is a color code, i.e., a value from the 5th column in the table structure included in the &quot;colortable&quot; entry (see below). &quot;label_names&quot;: the n brain structure names for the vertices, already retrieved from the colortable using the code. &quot;hex_colors_rgb&quot;: Vector of hex color for each vertex.
The &quot;colortable&quot; is another named list with 3 entries: &quot;num_entries&quot;: int, number of brain structures. &quot;struct_names&quot;: vector of strings, the brain structure names. &quot;table&quot;: numeric matrix with num_entries rows and 5 colums. The 5 columns are: 1 = color red channel, 2=color blue channel, 3=color green channel, 4=color alpha channel, 5=unique color code. &quot;colortable_df&quot;: The same information as a dataframe. Contains the extra columns &quot;hex_color_string_rgb&quot; and &quot;hex_color_string_rgba&quot; that hold the color as an RGB(A) hex string, like &quot;#rrggbbaa&quot;.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>,
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.annot">write.fs.annot</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    annot_file = system.file("extdata", "lh.aparc.annot.gz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    annot = read.fs.annot(annot_file);
    print(annot);

</code></pre>

<hr>
<h2 id='read.fs.annot.gii'>Read an annotation or label in GIFTI format.</h2><span id='topic+read.fs.annot.gii'></span>

<h3>Description</h3>

<p>Read an annotation or label in GIFTI format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.annot.gii(
  filepath,
  element_index = 1L,
  labels_only = FALSE,
  rgb_column_names = c("Red", "Green", "Blue", "Alpha"),
  key_column_name = "Key",
  empty_label_name = "unknown"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.annot.gii_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input label file in GIFTI format.</p>
</td></tr>
<tr><td><code id="read.fs.annot.gii_+3A_element_index">element_index</code></td>
<td>
<p>positive integer, the index of the dataarray to return. Ignored unless the file contains several dataarrays.</p>
</td></tr>
<tr><td><code id="read.fs.annot.gii_+3A_labels_only">labels_only</code></td>
<td>
<p>logical, whether to ignore the colortable and region names. The returned annotation will only contain the a vector that contains one integer label per vertex (as entry 'label_codes'), but no region names and colortable information.</p>
</td></tr>
<tr><td><code id="read.fs.annot.gii_+3A_rgb_column_names">rgb_column_names</code></td>
<td>
<p>vector of exactly 4 character strings, order is important. The column names for the red, green, blue and alpha channels in the lable table. If a column does not exist, pass NA. If you do not know the column names, just call the function, it will print them. See 'labels_only' if you do not care.</p>
</td></tr>
<tr><td><code id="read.fs.annot.gii_+3A_key_column_name">key_column_name</code></td>
<td>
<p>character string, the column name for the key column in the lable table. This is the column that holds the label value from the raw vector (see 'labels_only') that links a label value to a row in the label table. Without it, one cannot recostruct the region name and color of an entry. Passing NA has the same effect as setting 'labels_only' to TRUE.</p>
</td></tr>
<tr><td><code id="read.fs.annot.gii_+3A_empty_label_name">empty_label_name</code></td>
<td>
<p>character string, a base name to use to rename regions with empty name in the label table. This should not occur, and you can ignore this parameter setting. A warning will be thrown if this ever triggers. Not to be confused with parameter <code>default_label_name</code>, see below.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other gifti readers: 
<code><a href="#topic+read.fs.label.gii">read.fs.label.gii</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>
</p>

<hr>
<h2 id='read.fs.colortable'>Read colortable file in FreeSurfer ASCII LUT format.</h2><span id='topic+read.fs.colortable'></span>

<h3>Description</h3>

<p>Read a colortable from a text file in FreeSurfer ASCII colortable lookup table (LUT) format. An example file is 'FREESURFER_HOME/FreeSurferColorLUT.txt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.colortable(filepath, compute_colorcode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.colortable_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output colormap file.</p>
</td></tr>
<tr><td><code id="read.fs.colortable_+3A_compute_colorcode">compute_colorcode</code></td>
<td>
<p>logical, indicates whether the unique color codes should be computed and added to the returned data.frame as an extra integer column named 'code'. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data.frame that was read from the LUT file. It contains the following columns that were read from the file: 'struct_index': integer, index of the struct entry. 'struct_name': character string, the label name. 'r': integer in range 0-255, the RGBA color value for the red channel. 'g': same for green channel. 'b': same for blue channel. 'a': same for alpha (transparency) channel. If 'compute_colorcode' is TRUE, it also contains the following columns which were computed from the color values: 'code': integer, unique color identifier computed from the RGBA values.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+read.fs.annot">read.fs.annot</a>()</code>,
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.annot">write.fs.annot</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>
<p>Other colorLUT functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   lutfile = system.file("extdata", "colorlut.txt", package = "freesurferformats", mustWork = TRUE);
   colortable = read.fs.colortable(lutfile, compute_colorcode=TRUE);
   head(colortable);

</code></pre>

<hr>
<h2 id='read.fs.curv'>Read file in FreeSurfer curv format</h2><span id='topic+read.fs.curv'></span>

<h3>Description</h3>

<p>Read vertex-wise brain morphometry data from a file in FreeSurfer 'curv' format. Both the binary and ASCII versions are supported.
For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/surf/lh.thickness', which contains n values. Each value represents the cortical thickness at the respective vertex in the brain surface mesh of bert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.curv(filepath, format = "auto", with_header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.curv_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input curv file. Note: gzipped binary curv files are supported and gz binary format is assumed if the filepath ends with &quot;.gz&quot;.</p>
</td></tr>
<tr><td><code id="read.fs.curv_+3A_format">format</code></td>
<td>
<p>one of 'auto', 'asc', 'bin', 'nii' or 'txt'. The format to assume. If set to 'auto' (the default), binary format will be used unless the filepath ends with '.asc' or '.txt'. The latter is just one float value per line in a text file.</p>
</td></tr>
<tr><td><code id="read.fs.curv_+3A_with_header">with_header</code></td>
<td>
<p>logical, whether to return named list with 'header' and 'data' parts. Only valid with FreeSurfer binary curv format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data vector of floats. The brain morphometry data, one value per vertex.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    curvfile = system.file("extdata", "lh.thickness",
                            package = "freesurferformats", mustWork = TRUE);
    ct = read.fs.curv(curvfile);
    cat(sprintf("Read data for %d vertices. Values: min=%f, mean=%f, max=%f.\n",
                            length(ct), min(ct), mean(ct), max(ct)));

</code></pre>

<hr>
<h2 id='read.fs.gca'>Read FreeSurfer GCA file.</h2><span id='topic+read.fs.gca'></span>

<h3>Description</h3>

<p>Read FreeSurfer GCA file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.gca(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.gca_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to a file in binary GCA format. Stores array of Gaussian classifiers for probabilistic atlas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the file fields. The GCA data is in the data field.
</p>


<h3>Author(s)</h3>

<p>This function is based on Matlab code by Bruce Fischl, published under the FreeSurfer Open Source License available at <a href="https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense">https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense</a>. The R version was written by Tim Schaefer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gca_file = file.path(Sys.getenv('FREESURFER_HOME'), 'average', 'face.gca');
gca = read.fs.gca(gca_file);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.fs.label'>Read a label file.</h2><span id='topic+read.fs.label'></span>

<h3>Description</h3>

<p>Read a label file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.label(filepath, format = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.label_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input label file.</p>
</td></tr>
<tr><td><code id="read.fs.label_+3A_format">format</code></td>
<td>
<p>character string, one of 'auto' to detect by file extension, 'asc' for native FreeSurfer ASCII label format, or 'gii' for GIFTI label format.</p>
</td></tr>
<tr><td><code id="read.fs.label_+3A_...">...</code></td>
<td>
<p>extra paramters passed to the respective label function for the format</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="#topic+read.fs.label.native">read.fs.label.native</a></code> for more details, including important information on loading FreeSurfer volume labels.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+read.fs.label.gii">read.fs.label.gii</a>()</code>,
<code><a href="#topic+read.fs.label.native">read.fs.label.native</a>()</code>,
<code><a href="#topic+write.fs.label">write.fs.label</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    labelfile = system.file("extdata", "lh.entorhinal_exvivo.label",
      package = "freesurferformats", mustWork = TRUE);
    label = read.fs.label(labelfile);
</code></pre>

<hr>
<h2 id='read.fs.label.gii'>Read a label from a GIFTI label/annotation file.</h2><span id='topic+read.fs.label.gii'></span>

<h3>Description</h3>

<p>Read a label from a GIFTI label/annotation file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.label.gii(filepath, label_value = 1L, element_index = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.label.gii_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input label file.</p>
</td></tr>
<tr><td><code id="read.fs.label.gii_+3A_label_value">label_value</code></td>
<td>
<p>integer, the label value of interest to extract from the annotation: the indices of the vertices with this value will be returned. See the note for details.. It is important to set this correctly, otherwise you may accidently load the vertices which are *not* part of the label.</p>
</td></tr>
<tr><td><code id="read.fs.label.gii_+3A_element_index">element_index</code></td>
<td>
<p>positive integer, the index of the data array to return. Ignored unless the file contains several data arrays.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector,  the vertex indices of the label
</p>


<h3>Note</h3>

<p>A GIFTI label is more like a FreeSurfer annotation, as it assigns a label integer (region code) to each vertex of the surface instead of listing only the set of 'positive' vertex indices. If you are not sure about the contents of the label file, it is recommended to read it with <code><a href="#topic+read.fs.annot.gii">read.fs.annot.gii</a></code> instead. The 'read.fs.label.gii' function only extracts one of the regions from the annotation as a label, while <code><a href="#topic+read.fs.annot.gii">read.fs.annot.gii</a></code> reads the whole annotation and gives you access to the label table, which should assign region names to each region, making it clearer which 'label_value' you want.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+read.fs.label.native">read.fs.label.native</a>()</code>,
<code><a href="#topic+read.fs.label">read.fs.label</a>()</code>,
<code><a href="#topic+write.fs.label">write.fs.label</a>()</code>
</p>
<p>Other gifti readers: 
<code><a href="#topic+read.fs.annot.gii">read.fs.annot.gii</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>
</p>

<hr>
<h2 id='read.fs.label.native'>Read file in FreeSurfer label format</h2><span id='topic+read.fs.label.native'></span>

<h3>Description</h3>

<p>Read a mask in FreeSurfer label format. A label defines a list of vertices (of an associated surface or morphometry file) which are part of it. All others are not. You can think of it as binary mask. Label files are ASCII text files, which have 5 columns (vertex index, coord1, coord2, coord3, value), but only the vertex indices are of interest. A label can also contain voxels, in that case the indices are -1 and the coordinates are important.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.label.native(
  filepath,
  return_one_based_indices = TRUE,
  full = FALSE,
  metadata = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.label.native_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input label file.</p>
</td></tr>
<tr><td><code id="read.fs.label.native_+3A_return_one_based_indices">return_one_based_indices</code></td>
<td>
<p>logical. Whether the indices should be 1-based. Indices are stored zero-based in the file, but R uses 1-based indices. Defaults to TRUE, which means that 1 will be added to all indices read from the file before returning them. Notice that for volume labels, the indices are negative (-1), and the coord fields contain the *positions* of the voxels it tkras space (**not** the voxel *indices* in a volume). If a file contains negative indices, they will NOT be incremented, no matter what this is set to.</p>
</td></tr>
<tr><td><code id="read.fs.label.native_+3A_full">full</code></td>
<td>
<p>logical, whether to return a full object of class &lsquo;fs.label' instead of only a vector containing the vertex indices. If TRUE, a named list with the following two entries is returned: &rsquo;one_based_indices': logical, whether the vertex indices are one-based. 'vertexdata': a data.frame with the following columns: 'vertex_index': integer, see parameter 'return_one_based_indices', 'coord1', 'coord2', 'coord3': float coordinates, 'value': float, scalar data for the vertex, can mean anything. This parameter defaults to FALSE.</p>
</td></tr>
<tr><td><code id="read.fs.label.native_+3A_metadata">metadata</code></td>
<td>
<p>named list of arbitrary metadata to store in the instance, ignored unless the paramter 'full' is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of integers or 'fs.label' instance (see parameter 'full'). The vertex indices from the label file. See the parameter 'return_one_based_indices' for important information regarding the start index.
</p>


<h3>Note</h3>

<p>To load volume/voxel labels, you will have to set the 'full' parameter to 'TRUE'.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+read.fs.label.gii">read.fs.label.gii</a>()</code>,
<code><a href="#topic+read.fs.label">read.fs.label</a>()</code>,
<code><a href="#topic+write.fs.label">write.fs.label</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    labelfile = system.file("extdata", "lh.entorhinal_exvivo.label",
      package = "freesurferformats", mustWork = TRUE);
    label = read.fs.label(labelfile);

</code></pre>

<hr>
<h2 id='read.fs.mgh'>Read file in FreeSurfer MGH or MGZ format</h2><span id='topic+read.fs.mgh'></span>

<h3>Description</h3>

<p>Read multi-dimensional brain imaging data from a file in FreeSurfer binary MGH or MGZ format. The MGZ format is just a gzipped version of the MGH format. For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/mri/T1.mgz', which contains a 3D brain scan of bert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.mgh(
  filepath,
  is_gzipped = "AUTO",
  flatten = FALSE,
  with_header = FALSE,
  drop_empty_dims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.mgh_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input MGZ or MGH file.</p>
</td></tr>
<tr><td><code id="read.fs.mgh_+3A_is_gzipped">is_gzipped</code></td>
<td>
<p>a logical value or the string 'AUTO'. Whether to treat the input file as gzipped, i.e., MGZ instead of MGH format. Defaults to 'AUTO', which tries to determine this from the last three characters of the 'filepath' parameter. Files with extensions 'mgz' and '.gz' (in arbitrary case) are treated as MGZ format, all other files are treated as MGH. In the special case that 'filepath' has less than three characters, MGH is assumed.</p>
</td></tr>
<tr><td><code id="read.fs.mgh_+3A_flatten">flatten</code></td>
<td>
<p>logical. Whether to flatten the return volume to a 1D vector. Useful if you know that this file contains 1D morphometry data.</p>
</td></tr>
<tr><td><code id="read.fs.mgh_+3A_with_header">with_header</code></td>
<td>
<p>logical. Whether to return the header as well. If TRUE, return an instance of class 'fs.volume' for data with at least 3 dimensions, a named list with entries &quot;data&quot; and &quot;header&quot;. The latter is another named list which contains the header data. These header entries exist: &quot;dtype&quot;: int, one of: 0=MRI_UCHAR; 1=MRI_INT; 3=MRI_FLOAT; 4=MRI_SHORT. &quot;voldim&quot;: integer vector. The volume (=data) dimensions. E.g., c(256, 256, 256, 1). These header entries may exist: &quot;vox2ras_matrix&quot; (exists if &quot;ras_good_flag&quot; is 1), &quot;mr_params&quot; (exists if &quot;has_mr_params&quot; is 1). See the 'mghheader.*' functions, like <code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a></code>, to compute more information from the header fields.</p>
</td></tr>
<tr><td><code id="read.fs.mgh_+3A_drop_empty_dims">drop_empty_dims</code></td>
<td>
<p>logical, whether to drop empty dimensions of the returned data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data, multi-dimensional array. The brain imaging data, one value per voxel. The data type and the dimensions depend on the data in the file, they are read from the header. If the parameter flatten is 'TRUE', a numeric vector is returned instead. Note: The return value changes if the parameter with_header is 'TRUE', see parameter description.
</p>


<h3>See Also</h3>

<p>To derive more information from the header, see the 'mghheader.*' functions, like <code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a></code>.
</p>
<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vd = read.fs.mgh(brain_image);
    cat(sprintf("Read voxel data with dimensions %s. Values: min=%d, mean=%f, max=%d.\n",
                 paste(dim(vd), collapse = ' '), min(vd), mean(vd), max(vd)));
    # Read it again with full header data:
    vdh = read.fs.mgh(brain_image, with_header = TRUE);
    # Use the vox2ras matrix from the header to compute RAS coordinates at CRS voxel (0, 0, 0):
    vdh$header$vox2ras_matrix %*% c(0,0,0,1);

</code></pre>

<hr>
<h2 id='read.fs.morph'>Read morphometry data file in any FreeSurfer format.</h2><span id='topic+read.fs.morph'></span>

<h3>Description</h3>

<p>Read vertex-wise brain surface data from a file. The file can be in any of the supported formats, and the format will be determined from the file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph(filepath, format = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input file. The suffix determines the expected format as follows: &quot;.mgz&quot; and &quot;.mgh&quot; will be read with the read.fs.mgh function, all other file extensions will be read with the read.fs.curv function.</p>
</td></tr>
<tr><td><code id="read.fs.morph_+3A_format">format</code></td>
<td>
<p>character string, the format to use. One of c(&quot;auto&quot;, &quot;mgh&quot;, &quot;mgz&quot;, &quot;curv&quot;, &quot;gii&quot;). The default setting &quot;auto&quot; will determine the format from the file extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data, vector of floats. The brain morphometry data, one value per vertex.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    curvfile = system.file("extdata", "lh.thickness",
                            package = "freesurferformats", mustWork = TRUE);
    ct = read.fs.morph(curvfile);
    cat(sprintf("Read data for %d vertices. Values: min=%f, mean=%f, max=%f.\n",
                            length(ct), min(ct), mean(ct), max(ct)));


    mghfile = system.file("extdata", "lh.curv.fwhm10.fsaverage.mgz",
                            package = "freesurferformats", mustWork = TRUE);
    curv = read.fs.morph(mghfile);
    cat(sprintf("Read data for %d vertices. Values: min=%f, mean=%f, max=%f.\n",
                            length(ct), min(ct), mean(ct), max(ct)));

</code></pre>

<hr>
<h2 id='read.fs.morph.asc'>Read morphometry data from ASCII curv format file</h2><span id='topic+read.fs.morph.asc'></span>

<h3>Description</h3>

<p>Read morphometry data from ASCII curv format file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.asc(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.asc_+3A_filepath">filepath</code></td>
<td>
<p>path to a file in FreeSurfer ASCII curv format. Such a file contains, on each line, the following fields, separated by spaces: vertex_index, vertex_coord_x,  vertex_coord_y,  vertex_coord_z,  morph_data_value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, the curv data
</p>


<h3>Note</h3>

<p>This format is also known as *dpv* (data-per-vertex) format.
</p>

<hr>
<h2 id='read.fs.morph.bvsmp'>Read Brainvoyager vertex-wise statistical surface data from SMP file.</h2><span id='topic+read.fs.morph.bvsmp'></span>

<h3>Description</h3>

<p>Read Brainvoyager vertex-wise statistical surface data from SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.bvsmp(filepath, map_index = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.bvsmp_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in Brainvoyager SMP file format. Alternatively, a 'bvsmp' instance read with <code><a href="#topic+read.smp.brainvoyager">read.smp.brainvoyager</a></code>.</p>
</td></tr>
<tr><td><code id="read.fs.morph.bvsmp_+3A_map_index">map_index</code></td>
<td>
<p>positive integer or character string, the surface value map to load (an SMP file can contain several values per vertex, i.e., several surface maps). If an integer, interpreted as the index of the map. If a character string, as the name of the map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, the values from the respective map.
</p>

<hr>
<h2 id='read.fs.morph.cifti'>Read surface morphometry data from CIFTI dscalar files.</h2><span id='topic+read.fs.morph.cifti'></span>

<h3>Description</h3>

<p>Used the 'cifti' package to load the full data from a CIFTI file, then extracts and reconstructs the data for a surface, based on the metadata like vertex counts, indices and offset in the CIFTI file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.cifti(
  filepath,
  brain_structure = "CIFTI_STRUCTURE_CORTEX_LEFT",
  data_column = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.cifti_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to a file in CIFTI 2 format, should end with '.dscalar.nii'. Note that this is NOT a NIFTI file, despite the '.nii' part. It uses a CIFTIv2 header though. See the spec for details.</p>
</td></tr>
<tr><td><code id="read.fs.morph.cifti_+3A_brain_structure">brain_structure</code></td>
<td>
<p>character string or integer, the brain structure for which the data should be extracted from the file. Can be a CIFTI brain structure string (one of 'CIFTI_STRUCTURE_CORTEX_LEFT' or 'CIFTI_STRUCTURE_CORTEX_RIGHT'), or simply one of 'lh', 'rh' (which are used as aliases for the former). If you specify 'both', the concatenated data for 'lh' (first) and 'rh' will be returned, but you will get no information on hemi boundaries. If it is an integer, it will be interpreted as an index into the list of structures within the CIFTI file, use with care.</p>
</td></tr>
<tr><td><code id="read.fs.morph.cifti_+3A_data_column">data_column</code></td>
<td>
<p>integer, the data column to return. A CIFTI file can contain several measures in different data columns (e.g., cortical thickness and surface area) in a single file. This specifies which column/measure you want. The columns are not named, so you will need to know this in advance if the file has several measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reconstructed data for the given surface, one value per vertex in the surface. The value for vertices which did not have a value in the CIFTI data is set to 'NA'.
</p>


<h3>Note</h3>

<p>This function calls code from the 'cifti' package by John Muschelli: <a href="https://CRAN.R-project.org/package=cifti">https://CRAN.R-project.org/package=cifti</a>.
</p>


<h3>References</h3>

<p>See <a href="https://www.nitrc.org/forum/attachment.php?attachid=341&amp;group_id=454&amp;forum_id=1955">https://www.nitrc.org/forum/attachment.php?attachid=341&amp;group_id=454&amp;forum_id=1955</a> for the CIFTI 2 file format spec. See <a href="https://www.nitrc.org/projects/cifti/">https://www.nitrc.org/projects/cifti/</a> for more details on CIFTI, including example files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Downloaded CIFTI2 example data from https://www.nitrc.org/projects/cifti/
cifti_example_data_dir = "~/data/cifti";
cii_file = file.path(cifti_example_data_dir,
 "Conte69.MyelinAndCorrThickness.32k_fs_LR.dscalar.nii");
sf_lh = freesurferformats::read.fs.surface(file.path(cifti_example_data_dir,
 "Conte69.L.inflated.32k_fs_LR.surf.gii"));
sf_rh = freesurferformats::read.fs.surface(file.path(cifti_example_data_dir,
"Conte69.R.inflated.32k_fs_LR.surf.gii"));
morph_lh = read.fs.morph.cifti(cii_file, 'lh'); # Myelin data
morph_rh = read.fs.morph.cifti(cii_file, 'rh');
morph2_lh = read.fs.morph.cifti(cii_file, 'lh', 2); # Cortical Thickness data
morph2_rh = read.fs.morph.cifti(cii_file, 'rh', 2L);
# fsbrain::vis.fs.surface(sf_lh, per_vertex_data = morph_lh);
# fsbrain::vis.fs.surface(sf_rh, per_vertex_data = morph_rh);
# fsbrain::vis.fs.surface(list('lh'=sf_lh, 'rh'=sf_rh),
# per_vertex_data = list('lh'=morph2_lh, 'rh'=morph2_rh));

## End(Not run)

</code></pre>

<hr>
<h2 id='read.fs.morph.gii'>Read morphometry data file in GIFTI format.</h2><span id='topic+read.fs.morph.gii'></span>

<h3>Description</h3>

<p>Read vertex-wise brain surface data from a GIFTI file. The file must be a GIFTI *func* file (not a GIFTI *surf* file containing a mesh, use <code><a href="#topic+read_nisurface">read_nisurface</a></code> for loading GIFTI surf files).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.gii(filepath, element_index = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.gii_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input GIFTI file.</p>
</td></tr>
<tr><td><code id="read.fs.morph.gii_+3A_element_index">element_index</code></td>
<td>
<p>integer, the element to load in case the GIFTI file containes several datasets (usually time series). Defaults to the first element, 1L.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data, vector of double or integer. The brain morphometry data, one value per vertex. The data type depends on the data type in the file.
</p>


<h3>Note</h3>

<p>This function requires the 'gifti' package, which is an optional dependency, to be installed. It also assumes that the dataset contains a vector or a matrix/array in which all dimensions except for 1 are empty.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>
<p>Other gifti readers: 
<code><a href="#topic+read.fs.annot.gii">read.fs.annot.gii</a>()</code>,
<code><a href="#topic+read.fs.label.gii">read.fs.label.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>
</p>

<hr>
<h2 id='read.fs.morph.ni1'>Read morphometry data from FreeSurfer NIFTI v1 format files.</h2><span id='topic+read.fs.morph.ni1'></span>

<h3>Description</h3>

<p>Read morphometry data from FreeSurfer NIFTI v1 format files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.ni1(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.ni1_+3A_filepath">filepath</code></td>
<td>
<p>path to a file in FreeSurfer NIFTI v1 format, potentially with the FreeSurfer hack. See <code><a href="#topic+read.nifti1.data">read.nifti1.data</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, the morphometry data
</p>


<h3>Note</h3>

<p>This function uses our internal NIFTI reader that supports NIFTI v1 files with the FreeSurfer hack. This function assumes that the data in a file is a 1D vector and flattens it accordingly. It is not suitable to load NIFTI files with arbitrary dimensions.
</p>

<hr>
<h2 id='read.fs.morph.ni2'>Read morphometry data from FreeSurfer NIFTI v2 format files.</h2><span id='topic+read.fs.morph.ni2'></span>

<h3>Description</h3>

<p>Read morphometry data from FreeSurfer NIFTI v2 format files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.ni2(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.ni2_+3A_filepath">filepath</code></td>
<td>
<p>path to a file in FreeSurfer NIFTI v2 format, potentially with the FreeSurfer hack. See <code><a href="#topic+read.nifti2.data">read.nifti2.data</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, the morphometry data
</p>

<hr>
<h2 id='read.fs.morph.nii'>Read morphometry data from FreeSurfer NIFTI format files, determine NIFTI version automatically.</h2><span id='topic+read.fs.morph.nii'></span>

<h3>Description</h3>

<p>Read morphometry data from FreeSurfer NIFTI format files, determine NIFTI version automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.nii(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.nii_+3A_filepath">filepath</code></td>
<td>
<p>path to a file in FreeSurfer NIFTI v1 or v2 format, potentially with the FreeSurfer hack for v1. See <code><a href="#topic+read.nifti1.data">read.nifti1.data</a></code> and <code><a href="#topic+read.nifti2.data">read.nifti2.data</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, the morphometry data
</p>

<hr>
<h2 id='read.fs.morph.txt'>Read morphometry data from plain text file</h2><span id='topic+read.fs.morph.txt'></span>

<h3>Description</h3>

<p>Read morphometry data from plain text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.morph.txt(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.morph.txt_+3A_filepath">filepath</code></td>
<td>
<p>path to a file in plain text format. Such a file contains, on each line, a single float value. This very simply and limited *format* is used by the LGI tool by Lyu et al., and easy to generate in shell scripts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, the curv data
</p>

<hr>
<h2 id='read.fs.patch'>Read FreeSurfer binary or ASCII patch file.</h2><span id='topic+read.fs.patch'></span>

<h3>Description</h3>

<p>A patch is a subset of a surface. Note that the contents of ASCII and binary patch format files is different. A binary format patch contains vertices only, without connection (face) information. ASCII patch files can also contain face data. See the return value description for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.patch(filepath, format = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.patch_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input patch file. An example file is 'FREESURFER_HOME/subjects/fsaverage/surf/lh.cortex.patch.3d'.</p>
</td></tr>
<tr><td><code id="read.fs.patch_+3A_format">format</code></td>
<td>
<p>one of 'auto', 'asc', or 'bin'. The format to assume. If set to 'auto' (the default), binary format will be used unless the filepath ends with '.asc'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with 2 entries: &quot;faces&quot;: can be NULL, only available if the format is ASCII, see return value of <code><a href="#topic+read.fs.patch.asc">read.fs.patch.asc</a></code>. &quot;vertices&quot;: numerical *n*x7 matrix. The columns are named, and appear in the following order: 'vert_index1': the one-based (R-style) vertex index. 'x', 'y', 'z': float vertex coordinates. 'is_border': integer, 1 if the vertex lies on the patch border, 0 otherwise (treat as logical). 'raw_vtx': integer, the raw vtx value encoding index and border. 'vert_index0': the zero-based (C-style) vertex index.
</p>


<h3>See Also</h3>

<p>Other patch functions: 
<code><a href="#topic+fs.patch">fs.patch</a>()</code>,
<code><a href="#topic+read.fs.patch.asc">read.fs.patch.asc</a>()</code>,
<code><a href="#topic+write.fs.patch">write.fs.patch</a>()</code>
</p>

<hr>
<h2 id='read.fs.patch.asc'>Read FreeSurfer ASCII format patch.</h2><span id='topic+read.fs.patch.asc'></span>

<h3>Description</h3>

<p>An ASCII format patch is a part of a brain surface mesh, and is a mesh itself. It consists of vertices and faces. The ASCII patch format is very similar to the ASCII surface format. **Note:** The contents of ASCII and binary patch format files is different. The ASCII patch format is not ideal for parsing, and loading such files is currently quite slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.patch.asc(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.patch.asc_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input patch file in ASCII patch format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: see return value of <code><a href="#topic+read.fs.patch">read.fs.patch</a></code>. &quot;faces&quot;: numerical *n*x5 matrix. The columns are named, and appear in the following order: 'face_index1': the one-based (R-style) face index. 'vert1_index1', 'vert2_index1', 'vert3_index1': integer vertex indices of the face, they are one-based (R-style). 'face_index0': the zero-based (C-style) face index.
</p>


<h3>See Also</h3>

<p>Other patch functions: 
<code><a href="#topic+fs.patch">fs.patch</a>()</code>,
<code><a href="#topic+read.fs.patch">read.fs.patch</a>()</code>,
<code><a href="#topic+write.fs.patch">write.fs.patch</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface'>Read file in FreeSurfer surface format or various mesh formats.</h2><span id='topic+read.fs.surface'></span>

<h3>Description</h3>

<p>Read a brain surface mesh consisting of vertex and face data from a file in FreeSurfer binary or ASCII surface format. For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/surf/lh.white'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface(filepath, format = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file. Note: gzipped files are supported and gz format is assumed if the filepath ends with &quot;.gz&quot;.</p>
</td></tr>
<tr><td><code id="read.fs.surface_+3A_format">format</code></td>
<td>
<p>one of 'auto', 'asc', 'vtk', 'ply', 'gii', 'mz3', 'stl', 'byu', 'geo', 'ico', 'tri', 'obj', 'off' or 'bin'. The format to assume. If set to 'auto' (the default), binary format will be used unless the filepath ends with '.asc'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. This datastructure is known as a is a *face index set*. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    surface_file = system.file("extdata", "lh.tinysurface",
                            package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);
    cat(sprintf("Read data for %d vertices and %d faces. \n",
                            nrow(mesh$vertices), nrow(mesh$faces)));

</code></pre>

<hr>
<h2 id='read.fs.surface.asc'>Read FreeSurfer ASCII format surface.</h2><span id='topic+read.fs.surface.asc'></span>

<h3>Description</h3>

<p>Read FreeSurfer ASCII format surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.asc(filepath, with_values = TRUE, header_numlines = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.asc_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in ASCII surface format.</p>
</td></tr>
<tr><td><code id="read.fs.surface.asc_+3A_with_values">with_values</code></td>
<td>
<p>logical, whether to read per-vertex and per-face values.</p>
</td></tr>
<tr><td><code id="read.fs.surface.asc_+3A_header_numlines">header_numlines</code></td>
<td>
<p>scalar positive integer, the number of header lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>Note</h3>

<p>This is also known as *srf* format.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.bvsrf'>Read Brainvoyager srf format (.srf) mesh as surface.</h2><span id='topic+read.fs.surface.bvsrf'></span>

<h3>Description</h3>

<p>Read a mesh and associated data like color and normals from a binary file in BrainVoyager SRF mesh format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.bvsrf(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.bvsrf_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in SRF mesh format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fs.surface instance
</p>


<h3>References</h3>

<p>The srf format spec is at https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/344-users-guide-2-3-the-format-of-srf-files.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.byu'>Read mesh in BYU format.</h2><span id='topic+read.fs.surface.byu'></span>

<h3>Description</h3>

<p>The BYU or Brigham Young University format is an old ASCII mesh format that is based on fixed character positions in lines (as opposed to whitespace-separated elements). I consider it a bit counter-intuitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.byu(filepath, part = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.byu_+3A_filepath">filepath</code></td>
<td>
<p>full path of the file in BYU format.</p>
</td></tr>
<tr><td><code id="read.fs.surface.byu_+3A_part">part</code></td>
<td>
<p>positive integer, the index of the mesh that should be loaded from the file. Only relevant if the file contains more than one mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'fs.surface' instance, aka a mesh
</p>


<h3>References</h3>

<p>See http://www.eg-models.de/formats/Format_Byu.html for a format description.
</p>

<hr>
<h2 id='read.fs.surface.geo'>Read GEO format mesh as surface.</h2><span id='topic+read.fs.surface.geo'></span>

<h3>Description</h3>

<p>This reads meshes from text files in GEO mesh format. This is an ASCII format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.geo(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.geo_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in GEO mesh format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>Note</h3>

<p>This is a fixed width format.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.gii'>Read GIFTI format mesh as surface.</h2><span id='topic+read.fs.surface.gii'></span>

<h3>Description</h3>

<p>Read GIFTI format mesh as surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.gii(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.gii_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in GIFTI format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>
<p>Other gifti readers: 
<code><a href="#topic+read.fs.annot.gii">read.fs.annot.gii</a>()</code>,
<code><a href="#topic+read.fs.label.gii">read.fs.label.gii</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.ico'>Read ICO format mesh as surface.</h2><span id='topic+read.fs.surface.ico'></span>

<h3>Description</h3>

<p>This reads meshes from text files in ICO / TRI mesh format. This format is not to be confused with the the image format used to store tiny icons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.ico(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.ico_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in ICO or TRI mesh format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>Note</h3>

<p>This is a fixed width format.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.mz3'>Read surface mesh in mz3 format, used by Surf-Ice.</h2><span id='topic+read.fs.surface.mz3'></span>

<h3>Description</h3>

<p>The mz3 format is a binary file format that can store a mesh (vertices and faces), and optionally per-vertex colors or scalars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.mz3(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.mz3_+3A_filepath">filepath</code></td>
<td>
<p>full path to surface mesh file in mz3 format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;fs.surface' instance. If the mz3 file contained RGBA per-vertex colors or scalar per-vertex data, these are available in the &rsquo;metadata' property.
</p>


<h3>References</h3>

<p>See https://github.com/neurolabusc/surf-ice for details on the format.
</p>

<hr>
<h2 id='read.fs.surface.obj'>Read OBJ format mesh as surface.</h2><span id='topic+read.fs.surface.obj'></span>

<h3>Description</h3>

<p>This reads meshes from text files in Wavefront OBJ mesh format. This is an ASCII format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.obj(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.obj_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in Wavefront object mesh format. Files with non-standard vertex colors (3 additional float fields after the vertex coordinates in order R, G, B) are supported, and the colors will be returned in the field 'vertex_colors' if present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>Note</h3>

<p>This is a simple but very common mesh format supported by many applications, well suited for export.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.off'>Read Object File Format (OFF) mesh as surface.</h2><span id='topic+read.fs.surface.off'></span>

<h3>Description</h3>

<p>This reads meshes from text files in OFF mesh format. This is an ASCII format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.off(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.off_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in OFF mesh format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.ply'>Read Stanford PLY format mesh as surface.</h2><span id='topic+read.fs.surface.ply'></span>

<h3>Description</h3>

<p>This reads meshes from text files in PLY format. Note that this does not read arbitrary data from PLY files, i.e., PLY files can store data that is not supported by this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.ply(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.ply_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in Stanford Triangle (PLY) format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>Note</h3>

<p>This is by far not a complete PLY format reader. It can read PLY mesh files which were written by <code><a href="#topic+write.fs.surface.ply">write.fs.surface.ply</a></code> and Blender. Vertex colors and Blender vertex normals are currently ignored (but files with them are supported in the sense that the mesh data will be read correctly).
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.surface.stl'>Read mesh in STL format, auto-detecting ASCII versus binary format version.</h2><span id='topic+read.fs.surface.stl'></span>

<h3>Description</h3>

<p>Read mesh in STL format, auto-detecting ASCII versus binary format version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.stl(filepath, digits = 6L, is_ascii = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.stl_+3A_filepath">filepath</code></td>
<td>
<p>full path to surface mesh file in STL format.</p>
</td></tr>
<tr><td><code id="read.fs.surface.stl_+3A_digits">digits</code></td>
<td>
<p>the precision (number of digits after decimal separator) to use when determining whether two x,y,z coords define the same vertex. This is used when the polygon soup is turned into an indexed mesh.</p>
</td></tr>
<tr><td><code id="read.fs.surface.stl_+3A_is_ascii">is_ascii</code></td>
<td>
<p>logical, whether the file is in the ASCII version of the STL format (as opposed to the binary version). Can also be the character string 'auto', in which case the function will try to auto-detect the format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'fs.surface' instance, the mesh.
</p>


<h3>Note</h3>

<p>The mesh is stored in the file as a polygon soup, which is transformed into an index mesh by this function.
</p>

<hr>
<h2 id='read.fs.surface.stl.ascii'>Read surface mesh in STL ASCII format.</h2><span id='topic+read.fs.surface.stl.ascii'></span>

<h3>Description</h3>

<p>The STL format is a mesh format that is often used for 3D printing, it stores geometry information. It is known as stereolithography format. A binary and an ASCII version exist. This function reads the ASCII version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.stl.ascii(filepath, digits = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.stl.ascii_+3A_filepath">filepath</code></td>
<td>
<p>full path to surface mesh file in STL format.</p>
</td></tr>
<tr><td><code id="read.fs.surface.stl.ascii_+3A_digits">digits</code></td>
<td>
<p>the precision (number of digits after decimal separator) to use when determining whether two x,y,z coords define the same vertex. This is used when the polygon soup is turned into an indexed mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;fs.surface' instance. The normals are available in the &rsquo;metadata' property.
</p>


<h3>Note</h3>

<p>The STL format does not use indices into a vertex list to define faces, instead it repeats vertex coords in each face ('polygon soup'). Therefore, the mesh needs to be reconstructed, which requires the 'misc3d' package.
</p>


<h3>References</h3>

<p>See https://en.wikipedia.org/wiki/STL_(file_format) for a format description.
</p>

<hr>
<h2 id='read.fs.surface.stl.bin'>Read surface mesh in STL binary format.</h2><span id='topic+read.fs.surface.stl.bin'></span>

<h3>Description</h3>

<p>The STL format is a mesh format that is often used for 3D printing, it stores geometry information. It is known as stereolithography format. A binary and an ASCII version exist. This function reads the binary version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.stl.bin(filepath, digits = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.stl.bin_+3A_filepath">filepath</code></td>
<td>
<p>full path to surface mesh file in STL format.</p>
</td></tr>
<tr><td><code id="read.fs.surface.stl.bin_+3A_digits">digits</code></td>
<td>
<p>the precision (number of digits after decimal separator) to use when determining whether two x,y,z coords define the same vertex. This is used when the polygon soup is turned into an indexed mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'fs.surface' instance.
</p>


<h3>Note</h3>

<p>The STL format does not use indices into a vertex list to define faces, instead it repeats vertex coords in each face ('polygon soup').
</p>


<h3>References</h3>

<p>See https://en.wikipedia.org/wiki/STL_(file_format) for the format spec.
</p>

<hr>
<h2 id='read.fs.surface.vtk'>Read VTK ASCII format mesh as surface.</h2><span id='topic+read.fs.surface.vtk'></span>

<h3>Description</h3>

<p>This reads meshes (vtk polygon datasets) from text files in VTK ASCII format. See https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf for format spec. Note that this function does **not** read arbitrary VTK datasets, i.e., it supports only a subset of the possible contents of VTK files (i.e., polygon meshes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.surface.vtk(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.surface.vtk_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in VTK ASCII format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list. The list has the following named entries: &quot;vertices&quot;: nx3 double matrix, where n is the number of vertices. Each row contains the x,y,z coordinates of a single vertex. &quot;faces&quot;: nx3 integer matrix. Each row contains the vertex indices of the 3 vertices defining the face. WARNING: The indices are returned starting with index 1 (as used in GNU R). Keep in mind that you need to adjust the index (by substracting 1) to compare with data from other software.
</p>


<h3>Note</h3>

<p>This is by far not a complete VTK format reader.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.fs.transform'>Load transformation matrix from a file.</h2><span id='topic+read.fs.transform'></span>

<h3>Description</h3>

<p>Load transformation matrix from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.transform(filepath, format = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.transform_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the transform file.</p>
</td></tr>
<tr><td><code id="read.fs.transform_+3A_format">format</code></td>
<td>
<p>character string, the file format. Currently 'auto' (guess based on file extension), 'xfm' (for xform format) or 'dat' (for tkregister style, e.g. register.dat) are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the 'matrix field contains a '4x4 numerical matrix, the transformation matrix. Other fields may exist, depending on the parsed format.
</p>


<h3>Note</h3>

<p>Currently this function has been tested with linear transformation files only, all others are unsupported.
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    tf_file = system.file("extdata", "talairach.xfm",
                               package = "freesurferformats",
                               mustWork = TRUE);
    transform = read.fs.transform(tf_file);
    transform$matrix;

</code></pre>

<hr>
<h2 id='read.fs.transform.dat'>Load transformation matrix from a tkregister dat file.</h2><span id='topic+read.fs.transform.dat'></span>

<h3>Description</h3>

<p>Load transformation matrix from a tkregister dat file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.transform.dat(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.transform.dat_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the transform file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    tf_file = system.file("extdata", "register.dat",
                               package = "freesurferformats",
                               mustWork = TRUE);
    transform = read.fs.transform.dat(tf_file);
    transform$matrix;

</code></pre>

<hr>
<h2 id='read.fs.transform.lta'>Load transformation matrix from a FreeSurfer linear transform array (LTA) file.</h2><span id='topic+read.fs.transform.lta'></span>

<h3>Description</h3>

<p>Load transformation matrix from a FreeSurfer linear transform array (LTA) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.transform.lta(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.transform.lta_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the transform file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>Note</h3>

<p>I found no spec for the LTA file format, only example files, so this function should be used with care. If you have a file that is not parsed correctly, please open an issue and attach it.
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    tf_file = system.file("extdata", "talairach.lta",
     package = "freesurferformats", mustWork = TRUE);
    transform = read.fs.transform.lta(tf_file);
    transform$matrix;

</code></pre>

<hr>
<h2 id='read.fs.transform.xfm'>Load transformation matrix from an XFM file.</h2><span id='topic+read.fs.transform.xfm'></span>

<h3>Description</h3>

<p>Load transformation matrix from an XFM file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.transform.xfm(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.transform.xfm_+3A_filepath">filepath</code></td>
<td>
<p>character string, the full path to the transform file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, the transformation matrix
</p>


<h3>Note</h3>

<p>Currently this function has been tested with linear transformation files only, all others are unsupported.
</p>


<h3>See Also</h3>

<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    tf_file = system.file("extdata", "talairach.xfm",
                               package = "freesurferformats",
                               mustWork = TRUE);
    transform = read.fs.transform.xfm(tf_file);
    transform$matrix;

</code></pre>

<hr>
<h2 id='read.fs.volume'>Read volume file in MGH, MGZ or NIFTI format</h2><span id='topic+read.fs.volume'></span>

<h3>Description</h3>

<p>Read multi-dimensional brain imaging data from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.volume(
  filepath,
  format = "auto",
  flatten = FALSE,
  with_header = FALSE,
  drop_empty_dims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.volume_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input MGZ, MGH or NIFTI file.</p>
</td></tr>
<tr><td><code id="read.fs.volume_+3A_format">format</code></td>
<td>
<p>character string, one one of 'auto', 'nii', 'mgh' or 'mgz'. The format to assume. If set to 'auto' (the default), the format will be derived from the file extension.</p>
</td></tr>
<tr><td><code id="read.fs.volume_+3A_flatten">flatten</code></td>
<td>
<p>logical. Whether to flatten the return volume to a 1D vector. Useful if you know that this file contains 1D morphometry data.</p>
</td></tr>
<tr><td><code id="read.fs.volume_+3A_with_header">with_header</code></td>
<td>
<p>logical. Whether to return the header as well. If TRUE, return an instance of class 'fs.volume' for data with at least 3 dimensions, a named list with entries &quot;data&quot; and &quot;header&quot;. The latter is another named list which contains the header data. These header entries exist: &quot;dtype&quot;: int, one of: 0=MRI_UCHAR; 1=MRI_INT; 3=MRI_FLOAT; 4=MRI_SHORT. &quot;voldim&quot;: integer vector. The volume (=data) dimensions. E.g., c(256, 256, 256, 1). These header entries may exist: &quot;vox2ras_matrix&quot; (exists if &quot;ras_good_flag&quot; is 1), &quot;mr_params&quot; (exists if &quot;has_mr_params&quot; is 1). See the 'mghheader.*' functions, like <code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a></code>, to compute more information from the header fields.</p>
</td></tr>
<tr><td><code id="read.fs.volume_+3A_drop_empty_dims">drop_empty_dims</code></td>
<td>
<p>logical, whether to drop empty dimensions of the returned data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data, multi-dimensional array. The brain imaging data, one value per voxel. The data type and the dimensions depend on the data in the file, they are read from the header. If the parameter flatten is 'TRUE', a numeric vector is returned instead. Note: The return value changes if the parameter with_header is 'TRUE', see parameter description.
</p>


<h3>See Also</h3>

<p>To derive more information from the header, see the 'mghheader.*' functions, like <code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a></code>.
</p>
<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    brain_image = system.file("extdata", "brain.mgz",
                               package = "freesurferformats",
                               mustWork = TRUE);
    vd = read.fs.volume(brain_image);
    cat(sprintf("Read voxel data with dimensions %s. Values: min=%d, mean=%f, max=%d.\n",
                 paste(dim(vd), collapse = ' '), min(vd), mean(vd), max(vd)));
    # Read it again with full header data:
    vdh = read.fs.volume(brain_image, with_header = TRUE);
    # Use the vox2ras matrix from the header to compute RAS coordinates at CRS voxel (0, 0, 0):
    vox2ras_matrix = mghheader.vox2ras(vdh)
    vox2ras_matrix %*% c(0,0,0,1);

</code></pre>

<hr>
<h2 id='read.fs.volume.nii'>Turn a 3D or 4D 'oro.nifti' instance into an 'fs.volume' instance with complete header.</h2><span id='topic+read.fs.volume.nii'></span>

<h3>Description</h3>

<p>This is work in progress. This function takes an 'oro.nifti' instance and computes the MGH header fields from the NIFTI header data, allowing for proper orientation of the contained image data (see <code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a></code> and related functions). Currently only few datatypes are supported, and the 'sform' header field needs to be present in the NIFTI instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.volume.nii(
  filepath,
  flatten = FALSE,
  with_header = FALSE,
  drop_empty_dims = FALSE,
  do_rotate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.volume.nii_+3A_filepath">filepath</code></td>
<td>
<p>instance of class 'nifti' from the 'oro.nifti' package, or a path to a NIFTI file as a character string.</p>
</td></tr>
<tr><td><code id="read.fs.volume.nii_+3A_flatten">flatten</code></td>
<td>
<p>logical. Whether to flatten the return volume to a 1D vector. Useful if you know that this file contains 1D morphometry data.</p>
</td></tr>
<tr><td><code id="read.fs.volume.nii_+3A_with_header">with_header</code></td>
<td>
<p>logical. Whether to return the header as well. If TRUE, return an instance of class 'fs.volume' for data with at least 3 dimensions, a named list with entries &quot;data&quot; and &quot;header&quot;. The latter is another named list which contains the header data. These header entries exist: &quot;dtype&quot;: int, one of: 0=MRI_UCHAR; 1=MRI_INT; 3=MRI_FLOAT; 4=MRI_SHORT. &quot;voldim&quot;: integer vector. The volume (=data) dimensions. E.g., c(256, 256, 256, 1). These header entries may exist: &quot;vox2ras_matrix&quot; (exists if &quot;ras_good_flag&quot; is 1), &quot;mr_params&quot; (exists if &quot;has_mr_params&quot; is 1). See the 'mghheader.*' functions, like <code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a></code>, to compute more information from the header fields.</p>
</td></tr>
<tr><td><code id="read.fs.volume.nii_+3A_drop_empty_dims">drop_empty_dims</code></td>
<td>
<p>logical, whether to drop empty dimensions of the returned data</p>
</td></tr>
<tr><td><code id="read.fs.volume.nii_+3A_do_rotate">do_rotate</code></td>
<td>
<p>logical, whether to rotate 3D volumes to compensate for storage order. WIP.</p>
</td></tr>
<tr><td><code id="read.fs.volume.nii_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code>oro.nifti::readNIfTI</code>. Leave this alone unless you know what you are doing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'fs.volume' instance. The 'header' fields are computed from the NIFTI header. The 'data' array is rotated into FreeSurfer storage order, but otherwise returned as present in the input NIFTI instance, i.e., no values are changed in any way.
</p>


<h3>Note</h3>

<p>This is not supposed to be used to read 1D morphometry data from NIFTI files generated by FreeSurfer (e.g., by converting 'lh.thickness' to NIFTI using 'mri_convert'): the FreeSurfer NIFTI hack is not supported by oro.nifti.
</p>


<h3>References</h3>

<p>See https://nifti.nimh.nih.gov/nifti-1/ for the NIfTI-1 data format spec.
</p>


<h3>See Also</h3>

<p><code>oro.nifti::readNIfTI</code>, <code><a href="#topic+read.fs.mgh">read.fs.mgh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   base_file = "~/data/subject1_only/subject1/mri/brain";  # missing file ext.
   mgh_file = paste(base_file, '.mgz', sep='');  # the standard MGH/MGZ file
   nii_file = paste(base_file, '.nii', sep='');   # NIFTI file generated with mri_convert
   brain_mgh = read.fs.mgh(mgh_file, with_header = TRUE);
   brain_nii = read.fs.volume.nii(nii_file, with_header = TRUE);

   all(brain_nii$data == brain_mgh$data);                              # output: TRUE
   all(mghheader.vox2ras(brain_nii) == mghheader.vox2ras(brain_mgh))   # output: TRUE

## End(Not run)

</code></pre>

<hr>
<h2 id='read.fs.weight'>Read file in FreeSurfer weight or w format</h2><span id='topic+read.fs.weight'></span>

<h3>Description</h3>

<p>Read morphometry data in weight format (aka 'w' files). A weight format file contains morphometry data for a set of vertices, defined by their index in a surface. This can be only a **subset** of the surface vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.weight(filepath, format = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.weight_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input weight file. Weight files typically have the file extension '.w', but that is not enforced.</p>
</td></tr>
<tr><td><code id="read.fs.weight_+3A_format">format</code></td>
<td>
<p>one of 'auto', 'asc', or 'bin'. The format to assume. If set to 'auto' (the default), binary format will be used unless the filepath ends with '.asc'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indices and weight data, as a named list. Entries: &quot;vertex_indices&quot;: vector of *n* vertex indices. They are stored zero-based in the file, but are returned one-based (R-style). &quot;value&quot;: double vector of length *n*, the morphometry data for the vertices. The data can be whatever you want.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='read.fs.weight.asc'>Read ASCII version of FreeSurfer weight file.</h2><span id='topic+read.fs.weight.asc'></span>

<h3>Description</h3>

<p>Read ASCII version of FreeSurfer weight file. Called by <code><a href="#topic+read.fs.weight">read.fs.weight</a></code> if parameter &lsquo;format' is set to &rsquo;asc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fs.weight.asc(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fs.weight.asc_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input weight file, must be in ASCII weight format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indices and weight data, as a named list. Entries: &quot;vertex_indices&quot;: vector of *n* vertex indices. They are stored zero-based in the file, but are returned one-based (R-style). &quot;value&quot;: double vector of length *n*, the morphometry data for the vertices. The data can be whatever you want.
</p>

<hr>
<h2 id='read.mesh.brainvoyager'>Read Brainvoyager srf format (.srf) mesh.</h2><span id='topic+read.mesh.brainvoyager'></span>

<h3>Description</h3>

<p>Read a mesh and associated data like color and normals from a binary file in BrainVoyager SRF mesh format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mesh.brainvoyager(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mesh.brainvoyager_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the input surface file in SRF mesh format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of the elements in the file.
</p>


<h3>References</h3>

<p>The srf format spec is at https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/344-users-guide-2-3-the-format-of-srf-files.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>

<hr>
<h2 id='read.nifti1.data'>Read raw NIFTI v1 data from file (which may contain the FreeSurfer hack).</h2><span id='topic+read.nifti1.data'></span>

<h3>Description</h3>

<p>Read raw NIFTI v1 data from file (which may contain the FreeSurfer hack).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nifti1.data(filepath, drop_empty_dims = TRUE, header = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nifti1.data_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v1 file (single file version), which can contain the FreeSurfer hack.</p>
</td></tr>
<tr><td><code id="read.nifti1.data_+3A_drop_empty_dims">drop_empty_dims</code></td>
<td>
<p>logical, whether to drop empty dimensions in the loaded data array.</p>
</td></tr>
<tr><td><code id="read.nifti1.data_+3A_header">header</code></td>
<td>
<p>optional nifti header obtained from <code><a href="#topic+read.nifti1.header">read.nifti1.header</a></code>. Will be loaded automatically if left at 'NULL'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data in the NIFTI v1 file. Note that the NIFTI v1 header information (scaling, units, etc.) is not applied in any way: the data are returned raw, as read from the file. The information in the header is used to read the data with the proper data type and size.
</p>


<h3>Note</h3>

<p>The FreeSurfer hack is a non-standard way to save long vectors (one dimension greater than 32k entries) in NIFTI v1 files. Files with this hack are produced when converting MGH or MGZ files containing such long vectors with the FreeSurfer 'mri_convert' tool.
</p>

<hr>
<h2 id='read.nifti1.header'>Read NIFTI v1 header from file (which may contain the FreeSurfer hack).</h2><span id='topic+read.nifti1.header'></span>

<h3>Description</h3>

<p>Read NIFTI v1 header from file (which may contain the FreeSurfer hack).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nifti1.header(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nifti1.header_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v1 file (single file version), which can contain the FreeSurfer hack.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with NIFTI 1 header fields.
</p>


<h3>Note</h3>

<p>The FreeSurfer hack is a non-standard way to save long vectors (one dimension greater than 32767 entries) in NIFTI v1 files. Files with this hack are produced when converting MGH or MGZ files containing such long vectors with the FreeSurfer 'mri_convert' tool.
</p>

<hr>
<h2 id='read.nifti1.header.internal'>Read NIFTI v1 header from file (which may contain the FreeSurfer hack).</h2><span id='topic+read.nifti1.header.internal'></span>

<h3>Description</h3>

<p>Read NIFTI v1 header from file (which may contain the FreeSurfer hack).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nifti1.header.internal(filepath, little_endian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nifti1.header.internal_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v1 file (single file version), which can contain the FreeSurfer hack.</p>
</td></tr>
<tr><td><code id="read.nifti1.header.internal_+3A_little_endian">little_endian</code></td>
<td>
<p>internal logical, leave this alone. Endianness will be figured out automatically, messing with this parameter only hurts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with NIFTI 1 header fields.
</p>

<hr>
<h2 id='read.nifti2.data'>Read raw data from NIFTI v2 file.</h2><span id='topic+read.nifti2.data'></span>

<h3>Description</h3>

<p>Read raw data from NIFTI v2 file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nifti2.data(filepath, header = NULL, drop_empty_dims = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nifti2.data_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v2 file.</p>
</td></tr>
<tr><td><code id="read.nifti2.data_+3A_header">header</code></td>
<td>
<p>optional nifti v2 header obtained from <code><a href="#topic+read.nifti2.header">read.nifti2.header</a></code>. Will be loaded automatically if left at 'NULL'.</p>
</td></tr>
<tr><td><code id="read.nifti2.data_+3A_drop_empty_dims">drop_empty_dims</code></td>
<td>
<p>logical, whether to drop empty dimensions in the loaded data array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data in the NIFTI v2 file. Note that the NIFTI v2 header information (scaling, units, etc.) is not applied in any way: the data are returned raw, as read from the file. The information in the header is used to read the data with the proper data type and size.
</p>

<hr>
<h2 id='read.nifti2.header'>Read NIFTI v2 header from file.</h2><span id='topic+read.nifti2.header'></span>

<h3>Description</h3>

<p>Read NIFTI v2 header from file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nifti2.header(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nifti2.header_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v2 file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with NIFTI 2 header fields.
</p>

<hr>
<h2 id='read.nifti2.header.internal'>Read NIFTI v2 header from file.</h2><span id='topic+read.nifti2.header.internal'></span>

<h3>Description</h3>

<p>Read NIFTI v2 header from file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nifti2.header.internal(filepath, little_endian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nifti2.header.internal_+3A_filepath">filepath</code></td>
<td>
<p>path to a NIFTI v2 file.</p>
</td></tr>
<tr><td><code id="read.nifti2.header.internal_+3A_little_endian">little_endian</code></td>
<td>
<p>internal logical, leave this alone. Endianness will be figured out automatically, messing with this parameter only hurts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with NIFTI 2 header fields.
</p>


<h3>Note</h3>

<p>See https://nifti.nimh.nih.gov/pub/dist/data/nifti2/ for test data. Thanks to Anderson Winkler for his post at https://brainder.org/2015/04/03/the-nifti-2-file-format/.
</p>

<hr>
<h2 id='read.smp.brainvoyager'>Read Brainvoyager statistical surface results from SMP file.</h2><span id='topic+read.smp.brainvoyager'></span>

<h3>Description</h3>

<p>Read Brainvoyager statistical surface results from SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.smp.brainvoyager(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.smp.brainvoyager_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in Brainvoyager SMP file format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of file contents
</p>


<h3>Note</h3>

<p>Currently only SMP file versions 1 to 5 are supported, as these are the only ones for which a spec is available. The version is encoded in the file header.
</p>


<h3>References</h3>

<p>see <a href="https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/40-the-format-of-smp-files">https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/40-the-format-of-smp-files</a> for the spec
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # Surface mesh, requires BV demo dataset from website:
 sf = read.fs.surface.bvsrf("~/data/BrainTutorData/CG_LHRH_D65534.srf");
 # Surface map of cortical thickness. Needs to be created in BV.
 smp_file = "~/data/BrainTutorData/CG_LHRH_D65534_Thickness.smp";
 smp = read.smp.brainvoyager(smp_file);
 smp_data = read.fs.morph.bvsmp(smp); # could also pass smp_file.
 fsbrain::vis.fs.surface(sf, per_vertex_data = smp_data);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.smp.brainvoyager.v1or2'>Read Brainvoyager statistical surface results from v1 or v2 SMP file.</h2><span id='topic+read.smp.brainvoyager.v1or2'></span>

<h3>Description</h3>

<p>Read Brainvoyager statistical surface results from v1 or v2 SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.smp.brainvoyager.v1or2(filepath, version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.smp.brainvoyager.v1or2_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in Brainvoyager SMP file format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of file contents
</p>


<h3>Note</h3>

<p>Do not call this, call <code>read.smp.brainvoyager</code> instead, which will figure out the version and call the appropriate function.
</p>

<hr>
<h2 id='read.smp.brainvoyager.v3'>Read Brainvoyager statistical surface results from v3 SMP file.</h2><span id='topic+read.smp.brainvoyager.v3'></span>

<h3>Description</h3>

<p>Read Brainvoyager statistical surface results from v3 SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.smp.brainvoyager.v3(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.smp.brainvoyager.v3_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in Brainvoyager SMP file format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of file contents
</p>


<h3>Note</h3>

<p>Do not call this, call <code>read.smp.brainvoyager</code> instead, which will figure out the version and call the appropriate function.
</p>

<hr>
<h2 id='read.smp.brainvoyager.v4or5'>Read Brainvoyager statistical surface results from v4 or v5 SMP file.</h2><span id='topic+read.smp.brainvoyager.v4or5'></span>

<h3>Description</h3>

<p>Read Brainvoyager statistical surface results from v4 or v5 SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.smp.brainvoyager.v4or5(filepath, version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.smp.brainvoyager.v4or5_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to file in Brainvoyager SMP file format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of file contents
</p>


<h3>Note</h3>

<p>Do not call this, call <code>read.smp.brainvoyager</code> instead, which will figure out the version and call the appropriate function.
</p>

<hr>
<h2 id='readable.files'>Find files with the given base name and extensions that exist.</h2><span id='topic+readable.files'></span>

<h3>Description</h3>

<p>Note that in the current implementation, the case of the filepath and the extension must match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readable.files(
  filepath,
  precedence = c(".mgh", ".mgz"),
  error_if_none = TRUE,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readable.files_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to a file without extension</p>
</td></tr>
<tr><td><code id="readable.files_+3A_precedence">precedence</code></td>
<td>
<p>vector of character strings, the file extensions to check. Must include the dot (if you expect one).</p>
</td></tr>
<tr><td><code id="readable.files_+3A_error_if_none">error_if_none</code></td>
<td>
<p>logical, whether to raise an error if none of the files exist</p>
</td></tr>
<tr><td><code id="readable.files_+3A_return_all">return_all</code></td>
<td>
<p>logical, whether to return all readable files instead of just the first one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the path to the first existing file (or 'NULL' if none of them exists).
</p>

<hr>
<h2 id='readcolortable'>Read binary colortable in v2 format.</h2><span id='topic+readcolortable'></span>

<h3>Description</h3>

<p>Read a v2 format colortable from a connection to a binary file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readcolortable(fh, ctable_num_entries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readcolortable_+3A_fh">fh</code></td>
<td>
<p>file handle</p>
</td></tr>
<tr><td><code id="readcolortable_+3A_ctable_num_entries">ctable_num_entries</code></td>
<td>
<p>number of entries to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the color table. The named entries are: &quot;num_entries&quot;: int, number of brain structures. &quot;struct_names&quot;: vector of strings, the brain structure names. &quot;table&quot;: numeric matrix with num_entries rows and 5 colums. The 5 columns are: 1 = color red channel, 2=color blue channel, 3=color green channel, 4=color alpha channel, 5=unique color code.
</p>

<hr>
<h2 id='readcolortable_oldformat'>Read binary colortable in old format.</h2><span id='topic+readcolortable_oldformat'></span>

<h3>Description</h3>

<p>Read an oldformat colortable from a connection to a binary file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readcolortable_oldformat(fh, ctable_num_entries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readcolortable_oldformat_+3A_fh">fh</code></td>
<td>
<p>file handle</p>
</td></tr>
<tr><td><code id="readcolortable_oldformat_+3A_ctable_num_entries">ctable_num_entries</code></td>
<td>
<p>number of entries to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the color table. The named entries are: &quot;num_entries&quot;: int, number of brain structures. &quot;struct_names&quot;: vector of strings, the brain structure names. &quot;table&quot;: numeric matrix with num_entries rows and 5 colums. The 5 columns are: 1 = color red channel, 2=color blue channel, 3=color green channel, 4=color alpha channel, 5=unique color code.
</p>

<hr>
<h2 id='rotate2D'>Rotate a 2D matrix in 90 degree steps.</h2><span id='topic+rotate2D'></span>

<h3>Description</h3>

<p>Rotate a 2D matrix in 90 degree steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate2D(slice, degrees = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate2D_+3A_slice">slice</code></td>
<td>
<p>a 2D matrix</p>
</td></tr>
<tr><td><code id="rotate2D_+3A_degrees">degrees</code></td>
<td>
<p>integer, must be a (positive or negative) multiple of 90</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2D matrix, the rotated matrix
</p>

<hr>
<h2 id='rotate3D'>Rotate a 3D array in 90 degree steps.</h2><span id='topic+rotate3D'></span>

<h3>Description</h3>

<p>Rotate a 3D array in 90 degree steps along an axis. This leads to an array with different dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate3D(volume, axis = 1L, degrees = 90L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate3D_+3A_volume">volume</code></td>
<td>
<p>a 3D image volume</p>
</td></tr>
<tr><td><code id="rotate3D_+3A_axis">axis</code></td>
<td>
<p>positive integer in range 1L..3L or an axis name, the axis to use.</p>
</td></tr>
<tr><td><code id="rotate3D_+3A_degrees">degrees</code></td>
<td>
<p>integer, must be a (positive or negative) multiple of 90L.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D image volume, rotated around the axis. The dimensions may or may not be different from the input image, depending on the rotation angle.
</p>


<h3>See Also</h3>

<p>Other volume math: 
<code><a href="#topic+flip3D">flip3D</a>()</code>
</p>

<hr>
<h2 id='rotate90'>Rotate 2D matrix clockwise in 90 degree steps.</h2><span id='topic+rotate90'></span>

<h3>Description</h3>

<p>Rotate 2D matrix clockwise in 90 degree steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate90(mtx, times = 1L, clockwise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate90_+3A_mtx">mtx</code></td>
<td>
<p>a 2D matrix</p>
</td></tr>
<tr><td><code id="rotate90_+3A_times">times</code></td>
<td>
<p>integer, how often to rotate in 90 degree steps. Example: pass '3L' to rotate '270' degrees.</p>
</td></tr>
<tr><td><code id="rotate90_+3A_clockwise">clockwise</code></td>
<td>
<p>logical, whether to rotate clockwise.</p>
</td></tr>
</table>

<hr>
<h2 id='scann'>Scan exactly n values from source string.</h2><span id='topic+scann'></span>

<h3>Description</h3>

<p>Scan exactly n values from source string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scann(cstring, num = 1L, what = integer(), line_number = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scann_+3A_cstring">cstring</code></td>
<td>
<p>the input character string</p>
</td></tr>
<tr><td><code id="scann_+3A_num">num</code></td>
<td>
<p>integer, the number of expected resulting items.</p>
</td></tr>
<tr><td><code id="scann_+3A_line_number">line_number</code></td>
<td>
<p>optional integer, the line number (if the string represents a line from a text file). Will be printed in error message, if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of type integer or double
</p>

<hr>
<h2 id='sm0to1'>Adapt spatial transformation matrix for 1-based indices.</h2><span id='topic+sm0to1'></span>

<h3>Description</h3>

<p>Adapt spatial transformation matrix for 1-based indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm0to1(tf_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm0to1_+3A_tf_matrix">tf_matrix</code></td>
<td>
<p>4x4 numerical matrix, the input spatial transformation matrix, suitable for 0-based indices. Typically this is a vox2ras matrix obtained from functions like <code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, adapted spatial transformation matrix, suitable for 1-based indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm1to0">sm1to0</a></code> for the inverse operation
</p>
<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm1to0">sm1to0</a>()</code>
</p>

<hr>
<h2 id='sm1to0'>Adapt spatial transformation matrix for 0-based indices.</h2><span id='topic+sm1to0'></span>

<h3>Description</h3>

<p>Adapt spatial transformation matrix for 0-based indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm1to0(tf_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm1to0_+3A_tf_matrix">tf_matrix</code></td>
<td>
<p>4x4 numerical matrix, the input spatial transformation matrix, suitable for 1-based indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 numerical matrix, adapted spatial transformation matrix, suitable for 0-based indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm0to1">sm0to1</a></code> for the inverse operation
</p>
<p>Other header coordinate space: 
<code><a href="#topic+mghheader.is.ras.valid">mghheader.is.ras.valid</a>()</code>,
<code><a href="#topic+mghheader.ras2vox.tkreg">mghheader.ras2vox.tkreg</a>()</code>,
<code><a href="#topic+mghheader.ras2vox">mghheader.ras2vox</a>()</code>,
<code><a href="#topic+mghheader.scanner2tkreg">mghheader.scanner2tkreg</a>()</code>,
<code><a href="#topic+mghheader.tkreg2scanner">mghheader.tkreg2scanner</a>()</code>,
<code><a href="#topic+mghheader.vox2ras.tkreg">mghheader.vox2ras.tkreg</a>()</code>,
<code><a href="#topic+mghheader.vox2ras">mghheader.vox2ras</a>()</code>,
<code><a href="#topic+read.fs.transform.dat">read.fs.transform.dat</a>()</code>,
<code><a href="#topic+read.fs.transform.lta">read.fs.transform.lta</a>()</code>,
<code><a href="#topic+read.fs.transform.xfm">read.fs.transform.xfm</a>()</code>,
<code><a href="#topic+read.fs.transform">read.fs.transform</a>()</code>,
<code><a href="#topic+sm0to1">sm0to1</a>()</code>
</p>

<hr>
<h2 id='stl.format.file.is.ascii'>Guess whether a mesh file in STL format is the ASCII or the binary version.</h2><span id='topic+stl.format.file.is.ascii'></span>

<h3>Description</h3>

<p>Guess whether a mesh file in STL format is the ASCII or the binary version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stl.format.file.is.ascii(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stl.format.file.is.ascii_+3A_filepath">filepath</code></td>
<td>
<p>full path to surface mesh file in STL format.</p>
</td></tr>
</table>

<hr>
<h2 id='surfaceras.to.ras'>Translate surface RAS coordinates, as used in surface vertices and surface labels, to volume RAS.</h2><span id='topic+surfaceras.to.ras'></span>

<h3>Description</h3>

<p>Translate surface RAS coordinates, as used in surface vertices and surface labels, to volume RAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceras.to.ras(
  header_cras,
  sras_coords,
  first_voxel_RAS = c(1, 1, 1),
  invert_transform = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceras.to.ras_+3A_header_cras">header_cras</code></td>
<td>
<p>an MGH header instance from which to extract the cras (center RAS), or the cras vector, i.e., a numerical vector of length 3</p>
</td></tr>
<tr><td><code id="surfaceras.to.ras_+3A_sras_coords">sras_coords</code></td>
<td>
<p>nx3 numerical vector, the input surface RAS coordinates. Could be the vertex coordinates of an 'fs.surface' instance, or the RAS coords from a surface label. Use the orig surfaces.</p>
</td></tr>
<tr><td><code id="surfaceras.to.ras_+3A_first_voxel_ras">first_voxel_RAS</code></td>
<td>
<p>the RAS of the first voxel, see <code><a href="#topic+mghheader.centervoxelRAS.from.firstvoxelRAS">mghheader.centervoxelRAS.from.firstvoxelRAS</a></code> for details. Ignored if 'header_cras' is a vector.</p>
</td></tr>
<tr><td><code id="surfaceras.to.ras_+3A_invert_transform">invert_transform</code></td>
<td>
<p>logical, whether to invert the transform. Do not use this, call <code>link{ras.to.surfaceras}</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the RAS coords for the input sras_coords
</p>


<h3>Note</h3>

<p>The RAS can be computed from Surface RAS by adding the center RAS coordinates, i.e., it is nothing but a translation.
</p>

<hr>
<h2 id='surfaceras.to.talairach'>Compute Talairach RAS for surface RAS (e.g., vertex coordinates).</h2><span id='topic+surfaceras.to.talairach'></span>

<h3>Description</h3>

<p>Compute Talairach RAS for surface RAS (e.g., vertex coordinates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceras.to.talairach(
  sras_coords,
  talairach,
  header_cras,
  first_voxel_RAS = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceras.to.talairach_+3A_sras_coords">sras_coords</code></td>
<td>
<p>nx3 numerical vector, the input surface RAS coordinates. Could be the vertex coordinates of an 'fs.surface' instance, or the RAS coords from a surface label. Use the orig surfaces.</p>
</td></tr>
<tr><td><code id="surfaceras.to.talairach_+3A_talairach">talairach</code></td>
<td>
<p>the 4x4 numerical talairach matrix, or a character string which will be interpreted as the path to an xfm file containing the matrix (typically '$SUBJECTS_DIR/$subject/mri/transforms/talairach.xfm').</p>
</td></tr>
<tr><td><code id="surfaceras.to.talairach_+3A_header_cras">header_cras</code></td>
<td>
<p>an MGH header instance from which to extract the cras (center RAS), or the cras vector, i.e., a numerical vector of length 3</p>
</td></tr>
<tr><td><code id="surfaceras.to.talairach_+3A_first_voxel_ras">first_voxel_RAS</code></td>
<td>
<p>the RAS of the first voxel, see <code><a href="#topic+mghheader.centervoxelRAS.from.firstvoxelRAS">mghheader.centervoxelRAS.from.firstvoxelRAS</a></code> for details. Ignored if 'header_cras' is a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Talairach RAS coordinates for the vertices of the orig surfaces (or coords in surface RAS space). Based on linear transform.
</p>

<hr>
<h2 id='talairachras.to.ras'>Compute MNI talairach coordinates from RAS coords.</h2><span id='topic+talairachras.to.ras'></span>

<h3>Description</h3>

<p>Compute MNI talairach coordinates from RAS coords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>talairachras.to.ras(tal_ras_coords, talairach)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="talairachras.to.ras_+3A_tal_ras_coords">tal_ras_coords</code></td>
<td>
<p>coordinate matrix in Talairach RAS space</p>
</td></tr>
<tr><td><code id="talairachras.to.ras_+3A_talairach">talairach</code></td>
<td>
<p>the 4x4 numerical talairach matrix, or a character string which will be interpreted as the path to an xfm file containing the matrix (typically '$SUBJECTS_DIR/$subject/mri/transforms/talairach.xfm').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Talairach RAS coordinates for the given RAS coordinates. They are based on a linear transform.
</p>


<h3>Note</h3>

<p>You can use this to compute the Talairach coordinate of a voxel, based on its RAS coordinate.
</p>


<h3>References</h3>

<p>see <a href="https://en.wikipedia.org/wiki/Talairach_coordinates">https://en.wikipedia.org/wiki/Talairach_coordinates</a>
</p>

<hr>
<h2 id='translate.mri.dtype'>Translate between code and name of MRI data types.</h2><span id='topic+translate.mri.dtype'></span>

<h3>Description</h3>

<p>Translate between code and name of MRI data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate.mri.dtype(dtype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate.mri.dtype_+3A_dtype">dtype</code></td>
<td>
<p>character string (one of c('MRI_FLOAT') or integer, one of c(0L, 1L, 3L, 4L). Numeric values will be converted to integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'dtype' is a character string, the respective integer code. If it is numeric, the respective character string.
</p>

<hr>
<h2 id='vertex.euclid.dist'>Compute Euclidean distance between two vertices v1 and v2.</h2><span id='topic+vertex.euclid.dist'></span>

<h3>Description</h3>

<p>Compute Euclidean distance between two vertices v1 and v2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex.euclid.dist(surface, v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex.euclid.dist_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance</p>
</td></tr>
<tr><td><code id="vertex.euclid.dist_+3A_v1">v1</code></td>
<td>
<p>positive integer, vertex index of v1</p>
</td></tr>
<tr><td><code id="vertex.euclid.dist_+3A_v2">v2</code></td>
<td>
<p>positive integer, vertex index of v2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double, the Euclidean distance between v1 and v2
</p>


<h3>See Also</h3>

<p>Other Euclidean distance util functions: 
<code><a href="#topic+closest.vert.to.point">closest.vert.to.point</a>()</code>,
<code><a href="#topic+vertexdists.to.point">vertexdists.to.point</a>()</code>
</p>

<hr>
<h2 id='vertexdists.to.point'>Compute Euclidean distance from all mesh vertices to given point.</h2><span id='topic+vertexdists.to.point'></span>

<h3>Description</h3>

<p>Compute Euclidean distance from all mesh vertices to given point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertexdists.to.point(surface, point_coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertexdists.to.point_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance</p>
</td></tr>
<tr><td><code id="vertexdists.to.point_+3A_point_coords">point_coords</code></td>
<td>
<p>double vector of length 3, the xyz coords of a single point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double vector of distances
</p>


<h3>See Also</h3>

<p>Other Euclidean distance util functions: 
<code><a href="#topic+closest.vert.to.point">closest.vert.to.point</a>()</code>,
<code><a href="#topic+vertex.euclid.dist">vertex.euclid.dist</a>()</code>
</p>

<hr>
<h2 id='write.fs.annot'>Write annotation to binary file.</h2><span id='topic+write.fs.annot'></span>

<h3>Description</h3>

<p>Write an annotation to a FreeSurfer binary format annotation file in the new format (v2). An annotation (or brain parcellation) assigns each vertex to a label (or region). One of the regions is often called 'unknown' or similar and all vertices which are not relevant for the parcellation are assigned this label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.annot(
  filepath,
  num_vertices = NULL,
  colortable = NULL,
  labels_as_colorcodes = NULL,
  labels_as_indices_into_colortable = NULL,
  fs.annot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.annot_+3A_filepath">filepath</code></td>
<td>
<p>string, path to the output file</p>
</td></tr>
<tr><td><code id="write.fs.annot_+3A_num_vertices">num_vertices</code></td>
<td>
<p>integer, the number of vertices of the surface. Must be given unless parameter 'fs.annot' is not NULL.</p>
</td></tr>
<tr><td><code id="write.fs.annot_+3A_colortable">colortable</code></td>
<td>
<p>dataframe that contains one region per row. Required columns are: 'struct_name': character string, the region name. 'r': integer in range 0-255, the RGB color value for the red channel. 'g': same for the green channel. 'b': same for the blue channel. 'a': the alpha (transparency) channel value. Optional columns are: 'code': the color code. Will be computed if not set. Note that you can pass the dataframe returned by <code><a href="#topic+read.fs.annot">read.fs.annot</a></code> as 'colortable_df'. Only required if 'labels_as_indices_into_colortable' is used.</p>
</td></tr>
<tr><td><code id="write.fs.annot_+3A_labels_as_colorcodes">labels_as_colorcodes</code></td>
<td>
<p>vector of *n* integers. The first way to specify the labels. Each integer is a colorcode, that has been computed from the RGBA color values of the regions in the colortable as <code>r + g*2^8 + b*2^16 + a*2^24</code>. If you do not already have these color codes, it is way easier to set this to NULL and define the labels as indices into the colortable, see parameter 'labels_as_indices_into_colortable'.</p>
</td></tr>
<tr><td><code id="write.fs.annot_+3A_labels_as_indices_into_colortable">labels_as_indices_into_colortable</code></td>
<td>
<p>vector of *n* integers, the second way to specify the labels. Each integer is an index into the rows of the colortable. Indices start with 1. This parameter and 'labels_as_colorcodes' are mutually exclusive, but required.</p>
</td></tr>
<tr><td><code id="write.fs.annot_+3A_fs.annot">fs.annot</code></td>
<td>
<p>instance of class 'fs.annot'. If passed, this takes precedence over all other parameters and they should all be NULL (with the exception of 'filepath').</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+read.fs.annot">read.fs.annot</a>()</code>,
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>,
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # Load annotation
   annot_file = system.file("extdata", "lh.aparc.annot.gz",
                               package = "freesurferformats",
                               mustWork = TRUE);
   annot = read.fs.annot(annot_file);

   # New method: write the annotation instance:
   write.fs.annot(tempfile(fileext=".annot"), fs.annot=annot);

   # Old method: write it from its parts:
   write.fs.annot(tempfile(fileext=".annot"), length(annot$vertices),
    annot$colortable_df, labels_as_colorcodes=annot$label_codes);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.annot.gii'>Write annotation to GIFTI file.</h2><span id='topic+write.fs.annot.gii'></span>

<h3>Description</h3>

<p>Write an annotation to a GIFTI XML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.annot.gii(filepath, annot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.annot.gii_+3A_filepath">filepath</code></td>
<td>
<p>string, path to the output file.</p>
</td></tr>
<tr><td><code id="write.fs.annot.gii_+3A_annot">annot</code></td>
<td>
<p>fs.annot instance, an annotation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function does not write a GIFTI file that is valid according to the specification: it stores extra color data in the Label nodes, and there is more than one Label in the LabelTable node.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+read.fs.annot">read.fs.annot</a>()</code>,
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>,
<code><a href="#topic+write.fs.annot">write.fs.annot</a>()</code>,
<code><a href="#topic+write.fs.colortable">write.fs.colortable</a>()</code>
</p>
<p>Other gifti writers: 
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # Load annotation
   annot_file = system.file("extdata", "lh.aparc.annot.gz",
                               package = "freesurferformats",
                               mustWork = TRUE);
   annot = read.fs.annot(annot_file);

   # New method: write the annotation instance:
   write.fs.annot.gii(tempfile(fileext=".annot"), annot);


## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.colortable'>Write colortable file in FreeSurfer ASCII LUT format.</h2><span id='topic+write.fs.colortable'></span>

<h3>Description</h3>

<p>Write the colortable to a text file in FreeSurfer ASCII colortable lookup table (LUT) format. An example file is 'FREESURFER_HOME/FreeSurferColorLUT.txt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.colortable(filepath, colortable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.colortable_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output colormap file.</p>
</td></tr>
<tr><td><code id="write.fs.colortable_+3A_colortable">colortable</code></td>
<td>
<p>data.frame, a colortable as read by <code><a href="#topic+read.fs.colortable">read.fs.colortable</a></code>. Must contain the following columns: 'struct_name': character string, the label name. 'r': integer in range 0-255, the RGBA color value for the red channel. 'g': same for green channel. 'b': same for blue channel. 'a': same for alpha (transparency) channel. Can contain the following column: 'struct_index': integer, index of the struct entry. If this column does not exist, sequential indices starting at zero are created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the written dataframe, invisible. Note that this is will contain a column named 'struct_index', no matter whether the input colortable contained it or not.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+read.fs.annot">read.fs.annot</a>()</code>,
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>,
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.annot">write.fs.annot</a>()</code>
</p>
<p>Other colorLUT functions: 
<code><a href="#topic+colortable.from.annot">colortable.from.annot</a>()</code>,
<code><a href="#topic+read.fs.colortable">read.fs.colortable</a>()</code>
</p>

<hr>
<h2 id='write.fs.curv'>Write file in FreeSurfer curv format</h2><span id='topic+write.fs.curv'></span>

<h3>Description</h3>

<p>Write vertex-wise brain surface data to a file in FreeSurfer binary 'curv' format.
For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/surf/lh.thickness', which contains n values. Each value represents the cortical thickness at the respective vertex in the brain surface mesh of bert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.curv(filepath, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.curv_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output curv file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.curv_+3A_data">data</code></td>
<td>
<p>vector of doubles. The brain morphometry data to write, one value per vertex.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.fs.label'>Write vertex indices to file in FreeSurfer label format</h2><span id='topic+write.fs.label'></span>

<h3>Description</h3>

<p>Write vertex coordinates and vertex indices defining faces to a file in FreeSurfer binary surface format.
For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/label/lh.cortex'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.label(
  filepath,
  vertex_indices,
  vertex_coords = NULL,
  vertex_data = NULL,
  indices_are_one_based = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.label_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output label file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.label_+3A_vertex_indices">vertex_indices</code></td>
<td>
<p>instance of class 'fs.label' or an integer vector, the label. The vertex indices included in the label. As returned by <code><a href="#topic+read.fs.label">read.fs.label</a></code>.</p>
</td></tr>
<tr><td><code id="write.fs.label_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>an *n* x 3 float matrix of vertex coordinates, where *n* is the number of 'vertex_indices'. Optional, defaults to NULL, which will write placeholder data. The vertex coordinates are not used by any software I know (you should get them from the surface file). Will be used from 'fs.label' instance if given.</p>
</td></tr>
<tr><td><code id="write.fs.label_+3A_vertex_data">vertex_data</code></td>
<td>
<p>a numerical vector of length *n*, where *n* is the number of 'vertex_indices'. Optional, defaults to NULL, which will write placeholder data. The vertex data are not used by any software I know (you should get them from a morphometry file). Will be used from 'fs.label' instance if given.</p>
</td></tr>
<tr><td><code id="write.fs.label_+3A_indices_are_one_based">indices_are_one_based</code></td>
<td>
<p>logical, whether the given indices are one-based, as is standard in R. Indices are stored zero-based in label files, so if this is TRUE, all indices will be incremented by one before writing them to the file. Defaults to TRUE. If FALSE, it is assumed that they are zero-based and they are written to the file as-is.  Will be used from 'fs.label' instance if given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe, the dataframe that was written to the file (after the header lines).
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+read.fs.label.gii">read.fs.label.gii</a>()</code>,
<code><a href="#topic+read.fs.label.native">read.fs.label.native</a>()</code>,
<code><a href="#topic+read.fs.label">read.fs.label</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Write a simple label containing only vertex indices:
    label_vertices = c(1,2,3,4,5,1000,2000,2323,34,34545,42);
    write.fs.label(tempfile(fileext=".label"), label_vertices);

    # Load a full label, write it back to a file:
    labelfile = system.file("extdata", "lh.entorhinal_exvivo.label",
     package = "freesurferformats", mustWork = TRUE);
    label = read.fs.label(labelfile, full=TRUE);
    write.fs.label(tempfile(fileext=".label"), label);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.label.gii'>Write a binary surface label in GIFTI format.</h2><span id='topic+write.fs.label.gii'></span>

<h3>Description</h3>

<p>The data will be written with intent 'NIFTI_INTENT_LABEL' and as datatype 'NIFTI_TYPE_INT32'. The label table will include entries 'positive' (label value 0), and 'negative' (label value 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.label.gii(filepath, vertex_indices, num_vertices_in_surface)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.label.gii_+3A_filepath">filepath</code></td>
<td>
<p>string, the full path of the output GIFTI file.</p>
</td></tr>
<tr><td><code id="write.fs.label.gii_+3A_vertex_indices">vertex_indices</code></td>
<td>
<p>integer vector, the vertex indices which are part of the label (positive). All others not listed, up to num_vertices_in_surface, will be set to be negative.</p>
</td></tr>
<tr><td><code id="write.fs.label.gii_+3A_num_vertices_in_surface">num_vertices_in_surface</code></td>
<td>
<p>integer, the total number of vertices in the surface mesh. A GIFTI label is more like a mask/an annotation, so we need to know the number of vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format, string. The format that was used to write the data: &quot;gii&quot;.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>
<p>Other gifti writers: 
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  label = c(1L, 23L, 44L); # the positive vertex indices
  outfile = tempfile(fileext=".gii");
  write.fs.label.gii(outfile, label, 50L);

</code></pre>

<hr>
<h2 id='write.fs.mgh'>Write file in FreeSurfer MGH or MGZ format</h2><span id='topic+write.fs.mgh'></span>

<h3>Description</h3>

<p>Write brain data to a file in FreeSurfer binary MGH or MGZ format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.mgh(
  filepath,
  data,
  vox2ras_matrix = NULL,
  mr_params = c(0, 0, 0, 0, 0),
  mri_dtype = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.mgh_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output curv file. If this ends with &quot;.mgz&quot;, the file will be written gzipped (i.e., in MGZ instead of MGH format).</p>
</td></tr>
<tr><td><code id="write.fs.mgh_+3A_data">data</code></td>
<td>
<p>matrix or array of numerical values. The brain data to write. Must be integers or doubles. (The data type is set automatically to MRI_INT for integers and MRI_FLOAT for doubles in the MGH header).</p>
</td></tr>
<tr><td><code id="write.fs.mgh_+3A_vox2ras_matrix">vox2ras_matrix</code></td>
<td>
<p>4x4 matrix. An affine transformation matrix for the RAS transform that maps voxel indices in the volume to coordinates, such that for y(i1,i2,i3) (i.e., a voxel defined by 3 indices in the volume), the xyz coordinates are vox2ras_matrix*[i1 i2 i3 1]. If no matrix is given (or a NULL value), the ras_good flag will be 0 in the file. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="write.fs.mgh_+3A_mr_params">mr_params</code></td>
<td>
<p>double vector of length four (without fov) or five. The acquisition parameters, in order: tr, flipangle, te, ti, fov. Spelled out: repetition time, flip angle, echo time, inversion time, field-of-view. The unit for the three times is ms, the angle unit is radians. Defaults to c(0., 0., 0., 0., 0.) if omitted. Pass NULL if you do not want to write them at all.</p>
</td></tr>
<tr><td><code id="write.fs.mgh_+3A_mri_dtype">mri_dtype</code></td>
<td>
<p>character string representing an MRI data type code or 'auto'. Valid strings are 'MRI_UCHAR' (1 byte unsigned integer), 'MRI_SHORT' (2 byte signed integer), 'MRI_INT' (4 byte signed integer) and 'MRI_FLOAT' (4 byte signed floating point). The default value 'auto' will determine the data type from the type of the 'data' parameter. It will use MRI_INT for integers, so you may be able to save space by manually settings the dtype if the range of your data does not require that. WARNING: If manually specified, no sanitation of any kind is performed. Leave this alone if in doubt.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph'>Write morphometry data in a format derived from the given file name.</h2><span id='topic+write.fs.morph'></span>

<h3>Description</h3>

<p>Given data and a morphometry file name, derive the proper format from the file extension and write the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph(filepath, data, format = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph_+3A_filepath">filepath</code></td>
<td>
<p>string. The full file name. The format to use will be derived from the last characters, the suffix. Supported suffixes are &quot;mgh&quot; for MGH format, &quot;mgz&quot; for MGZ format, &quot;smp&quot; for Brainvoyager SMP format, &quot;nii&quot; or &quot;nii.gz&quot; for NIFTI v1 format, &quot;gii&quot; or &quot;gii.gz&quot; for GIFTI format, everything else will be treated as curv format.</p>
</td></tr>
<tr><td><code id="write.fs.morph_+3A_data">data</code></td>
<td>
<p>numerical vector. The data to write.</p>
</td></tr>
<tr><td><code id="write.fs.morph_+3A_format">format</code></td>
<td>
<p>character string, the format to use. One of c(&quot;auto&quot;, &quot;mgh&quot;, &quot;mgz&quot;, &quot;curv&quot;, &quot;n1&quot;, &quot;ni2&quot;, &quot;gii&quot;). The default setting &quot;auto&quot; will determine the format from the file extension.</p>
</td></tr>
<tr><td><code id="write.fs.morph_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to the respective writer function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string. The format that was used to write the data. One of c(&quot;auto&quot;, &quot;mgh&quot;, &quot;mgz&quot;, &quot;curv&quot;, &quot;ni1&quot;, &quot;ni2&quot;, &quot;gii&quot;).
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph.asc'>Write file in FreeSurfer ASCII curv format</h2><span id='topic+write.fs.morph.asc'></span>

<h3>Description</h3>

<p>Write vertex-wise brain surface data to a file in FreeSurfer ascii 'curv' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph.asc(filepath, data, coords = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph.asc_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output curv file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.morph.asc_+3A_data">data</code></td>
<td>
<p>vector of doubles. The brain morphometry data to write, one value per vertex.</p>
</td></tr>
<tr><td><code id="write.fs.morph.asc_+3A_coords">coords</code></td>
<td>
<p>optional, nx3 matrix of x,y,z coordinates, one row per vertex in 'data'. If 'NULL', all zeroes will be written instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph.gii'>Write morphometry data in GIFTI format.</h2><span id='topic+write.fs.morph.gii'></span>

<h3>Description</h3>

<p>The data will be written with intent 'NIFTI_INTENT_SHAPE' and as datatype 'NIFTI_TYPE_FLOAT32'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph.gii(filepath, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph.gii_+3A_filepath">filepath</code></td>
<td>
<p>string, the full path of the output GIFTI file.</p>
</td></tr>
<tr><td><code id="write.fs.morph.gii_+3A_data">data</code></td>
<td>
<p>numerical vector, the data to write. Will be coerced to double.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format, string. The format that was used to write the data: &quot;gii&quot;.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>
<p>Other gifti writers: 
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph.ni1'>Write morphometry data in NIFTI v1 format.</h2><span id='topic+write.fs.morph.ni1'></span>

<h3>Description</h3>

<p>Write morphometry data in NIFTI v1 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph.ni1(filepath, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph.ni1_+3A_filepath">filepath</code></td>
<td>
<p>string, the full path of the output NIFTI file. Should end with '.nii' or '.nii.gz'.</p>
</td></tr>
<tr><td><code id="write.fs.morph.ni1_+3A_data">data</code></td>
<td>
<p>numerical vector, the data to write. Will be coerced to double.</p>
</td></tr>
<tr><td><code id="write.fs.morph.ni1_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code><a href="#topic+write.nifti1">write.nifti1</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format, string. The format that was used to write the data: &quot;ni1&quot;.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>
<p>Other nifti1 writers: 
<code><a href="#topic+write.nifti1">write.nifti1</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph.ni2'>Write morphometry data in NIFTI v2 format.</h2><span id='topic+write.fs.morph.ni2'></span>

<h3>Description</h3>

<p>Write morphometry data in NIFTI v2 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph.ni2(filepath, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph.ni2_+3A_filepath">filepath</code></td>
<td>
<p>string, the full path of the output NIFTI file. Should end with '.nii' or '.nii.gz'.</p>
</td></tr>
<tr><td><code id="write.fs.morph.ni2_+3A_data">data</code></td>
<td>
<p>numerical vector, the data to write. Will be coerced to double.</p>
</td></tr>
<tr><td><code id="write.fs.morph.ni2_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code><a href="#topic+write.nifti2">write.nifti2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format, string. The format that was used to write the data: &quot;ni2&quot;.
</p>


<h3>Note</h3>

<p>Not many software packages support NIFTI v2 format. If possible with your data, you may want to use NIFTI v1 instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nifti.file.version">nifti.file.version</a></code> can be used to check whether a file is NIFTI v1 or v2 file.
</p>
<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>
<p>Other nifti2 writers: 
<code><a href="#topic+write.nifti2">write.nifti2</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph.smp'>Write morphometry data in Brainvoyager SMP format.</h2><span id='topic+write.fs.morph.smp'></span>

<h3>Description</h3>

<p>Write morphometry data in Brainvoyager SMP format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph.smp(filepath, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph.smp_+3A_filepath">filepath</code></td>
<td>
<p>string, the full path of the output SMP file.</p>
</td></tr>
<tr><td><code id="write.fs.morph.smp_+3A_data">data</code></td>
<td>
<p>numerical vector, the data to write. Will be coerced to double.</p>
</td></tr>
<tr><td><code id="write.fs.morph.smp_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code><a href="#topic+write.smp.brainvoyager">write.smp.brainvoyager</a></code>. Allows yout to save in specific format versions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format, string. The format that was used to write the data.
</p>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.fs.morph.txt'>Write curv data to file in simple text format</h2><span id='topic+write.fs.morph.txt'></span>

<h3>Description</h3>

<p>Write vertex-wise brain surface data to a file in a simple text format: one value per line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.morph.txt(filepath, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.morph.txt_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output curv file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.morph.txt_+3A_data">data</code></td>
<td>
<p>vector of doubles. The brain morphometry data to write, one value per vertex.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.fs.patch'>Write a surface patch</h2><span id='topic+write.fs.patch'></span>

<h3>Description</h3>

<p>Write a surface patch, i.e. a set of vertices and patch border information, to a binary patch file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.patch(filepath, patch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.patch_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output patch file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.patch_+3A_patch">patch</code></td>
<td>
<p>an instance of class 'fs.patch', see <code><a href="#topic+read.fs.patch">read.fs.patch</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the patch, invisible
</p>


<h3>See Also</h3>

<p>Other patch functions: 
<code><a href="#topic+fs.patch">fs.patch</a>()</code>,
<code><a href="#topic+read.fs.patch.asc">read.fs.patch.asc</a>()</code>,
<code><a href="#topic+read.fs.patch">read.fs.patch</a>()</code>
</p>

<hr>
<h2 id='write.fs.surface'>Write mesh to file in FreeSurfer binary surface format</h2><span id='topic+write.fs.surface'></span>

<h3>Description</h3>

<p>Write vertex coordinates and vertex indices defining faces to a file in FreeSurfer binary surface format.
For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/surf/lh.white'. This function writes the triangle version of the surface file format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface(filepath, vertex_coords, faces, format = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output curv file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.surface_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
<tr><td><code id="write.fs.surface_+3A_format">format</code></td>
<td>
<p>character string, the format to use. One of 'bin' for FreeSurfer binary surface format, 'asc' for FreeSurfer ASCII format, 'vtk' for VTK ASCII legacy format, 'ply' for Standford PLY format, 'off' for Object File Format, 'obj' for Wavefront object format, 'gii' for GIFTI format, 'mz3' for Surf-Ice MZ3 fomat, 'byu' for Brigham Young University (BYU) mesh format, or 'auto' to derive the format from the file extension given in parameter 'filepath'. With 'auto', a path ending in '.asc' is interpreted as 'asc', a path ending in '.vtk' as vtk, and so on for the other formats. Everything not matching any of these is interpreted as 'bin', i.e., FreeSurfer binary surface format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>
</p>
<p>Other mesh export functions: 
<code><a href="#topic+write.fs.surface.obj">write.fs.surface.obj</a>()</code>,
<code><a href="#topic+write.fs.surface.off.ply2">write.fs.surface.off.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.off">write.fs.surface.off</a>()</code>,
<code><a href="#topic+write.fs.surface.ply2">write.fs.surface.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.ply">write.fs.surface.ply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface(tempfile(), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.asc'>Write mesh to file in FreeSurfer ASCII surface format</h2><span id='topic+write.fs.surface.asc'></span>

<h3>Description</h3>

<p>Write vertex coordinates and vertex indices defining faces to a file in FreeSurfer ASCII surface format.
For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/surf/lh.white.asc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.asc(filepath, vertex_coords, faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.asc_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.asc', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.asc_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.asc_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.asc(tempfile(fileext=".asc"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.bvsrf'>Write surface to Brainvoyager SRF file.</h2><span id='topic+write.fs.surface.bvsrf'></span>

<h3>Description</h3>

<p>Write surface to Brainvoyager SRF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.bvsrf(
  filepath,
  vertex_coords,
  faces,
  normals = NULL,
  neighborhoods = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.bvsrf_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output curv file. If it ends with &quot;.gz&quot;, the file is written in gzipped format. Note that this is not common, and that other software may not handle this transparently.</p>
</td></tr>
<tr><td><code id="write.fs.surface.bvsrf_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.bvsrf_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
<tr><td><code id="write.fs.surface.bvsrf_+3A_normals">normals</code></td>
<td>
<p>matrix of nx3 vertex normals (x,y,z)</p>
</td></tr>
<tr><td><code id="write.fs.surface.bvsrf_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>list of integer lists, the indices of the nearest neighbors for each vertex (an adjacency list). The sub list at index n contains the indices of the vertices in the 1-neighborhood of vertex n. The vertex indices in the sub lists must be zero-based.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is experimental. Only SRF file format version 4 is supported.
</p>

<hr>
<h2 id='write.fs.surface.byu'>Write mesh to file in BYU ASCII format.</h2><span id='topic+write.fs.surface.byu'></span>

<h3>Description</h3>

<p>Write mesh to file in BYU ASCII format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.byu(filepath, vertex_coords, faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.byu_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.byu', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.byu_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.byu_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>Note</h3>

<p>This is a fixed field length ASCII format. Keep in mind that the BYU format expects the coordinates to be in the cube -1 to +1 on all three axes.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.byu(tempfile(fileext=".byu"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.gii'>Write mesh to file in GIFTI surface format</h2><span id='topic+write.fs.surface.gii'></span>

<h3>Description</h3>

<p>Write vertex coordinates and vertex indices defining faces to a file in GIFTI surface format. For a subject (MRI image pre-processed with FreeSurfer) named 'bert', an example file would be 'bert/surf/lh.white.asc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.gii(filepath, vertex_coords, faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.gii_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.asc', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.gii_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.gii_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>
<p>Other gifti writers: 
<code><a href="#topic+write.fs.annot.gii">write.fs.annot.gii</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.gii(tempfile(fileext=".gii"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.mz3'>Write mesh to file in mz3 binary format.</h2><span id='topic+write.fs.surface.mz3'></span>

<h3>Description</h3>

<p>Write mesh to file in mz3 binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.mz3(filepath, vertex_coords, faces, gzipped = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.mz3_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.mz3', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.mz3_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.mz3_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
<tr><td><code id="write.fs.surface.mz3_+3A_gzipped">gzipped</code></td>
<td>
<p>logical, whether to write a gzip compressed file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>Note</h3>

<p>This format is used by the surf-ice renderer. The format spec is at https://github.com/neurolabusc/surf-ice/tree/master/mz3.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.vtk">write.fs.surface.vtk</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.mz3(tempfile(fileext=".mz3"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.obj'>Write mesh to file in Wavefront object (.obj) format</h2><span id='topic+write.fs.surface.obj'></span>

<h3>Description</h3>

<p>The wavefront object format is a simply ASCII format for storing meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.obj(filepath, vertex_coords, faces, vertex_colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.obj_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.vtk', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.obj_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.obj_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
<tr><td><code id="write.fs.surface.obj_+3A_vertex_colors">vertex_colors</code></td>
<td>
<p>vector of vertex colors. Will be written after the x, y, z coords on vertex lines. WARNING: This is NOT part of the official OBJ standard, and may not work with other software and even break some parsers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>Note</h3>

<p>Do not confuse the Wavefront object file format (.obj) with the OFF format (.off), they are not identical.
</p>


<h3>See Also</h3>

<p>Other mesh export functions: 
<code><a href="#topic+write.fs.surface.off.ply2">write.fs.surface.off.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.off">write.fs.surface.off</a>()</code>,
<code><a href="#topic+write.fs.surface.ply2">write.fs.surface.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.ply">write.fs.surface.ply</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.obj(tempfile(fileext=".obj"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.off'>Write mesh to file in Object File Format (.off)</h2><span id='topic+write.fs.surface.off'></span>

<h3>Description</h3>

<p>The Object File Format is a simply ASCII format for storing meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.off(filepath, vertex_coords, faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.off_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.off', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.off_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.off_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>Note</h3>

<p>Do not confuse the OFF format (.off) with the Wavefront object file format (.obj), they are not identical.
</p>


<h3>See Also</h3>

<p>Other mesh export functions: 
<code><a href="#topic+write.fs.surface.obj">write.fs.surface.obj</a>()</code>,
<code><a href="#topic+write.fs.surface.off.ply2">write.fs.surface.off.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.ply2">write.fs.surface.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.ply">write.fs.surface.ply</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.off(tempfile(fileext=".off"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.off.ply2'>Write mesh to file in Object File Format (.off) or PLY2 format.</h2><span id='topic+write.fs.surface.off.ply2'></span>

<h3>Description</h3>

<p>The two formats are very similar, they only differ in the header lines. This function can write both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.off.ply2(filepath, vertex_coords, faces, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.off.ply2_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.off', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.off.ply2_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.off.ply2_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
<tr><td><code id="write.fs.surface.off.ply2_+3A_format">format</code></td>
<td>
<p>character string, the format to write. One of 'ply2' or 'off'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>Note</h3>

<p>Do not confuse the OFF format (.off) with the Wavefront object file format (.obj), they are not identical.
</p>


<h3>See Also</h3>

<p>Other mesh export functions: 
<code><a href="#topic+write.fs.surface.obj">write.fs.surface.obj</a>()</code>,
<code><a href="#topic+write.fs.surface.off">write.fs.surface.off</a>()</code>,
<code><a href="#topic+write.fs.surface.ply2">write.fs.surface.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.ply">write.fs.surface.ply</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.off(tempfile(fileext=".off"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.ply'>Write mesh to file in PLY format (.ply)</h2><span id='topic+write.fs.surface.ply'></span>

<h3>Description</h3>

<p>The PLY format is a versatile ASCII format for storing meshes. Also known as Polygon File Format or Stanford Triangle Format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.ply(filepath, vertex_coords, faces, vertex_colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.ply_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.vtk', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.ply_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.ply_+3A_faces">faces</code></td>
<td>
<p>m x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
<tr><td><code id="write.fs.surface.ply_+3A_vertex_colors">vertex_colors</code></td>
<td>
<p>optional, matrix of RGBA vertex colors, number of rows must be the same as for vertex_coords. Color values must be integers in range 0-255. Alternatively, a vector of *n* RGB color strings can be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>References</h3>

<p>See http://paulbourke.net/dataformats/ply/ for the PLY format spec.
</p>


<h3>See Also</h3>

<p>Other mesh export functions: 
<code><a href="#topic+write.fs.surface.obj">write.fs.surface.obj</a>()</code>,
<code><a href="#topic+write.fs.surface.off.ply2">write.fs.surface.off.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.off">write.fs.surface.off</a>()</code>,
<code><a href="#topic+write.fs.surface.ply2">write.fs.surface.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.ply(tempfile(fileext=".ply"), mesh$vertices, mesh$faces);

    # save a version with RGBA vertex colors
    vertex_colors = matrix(rep(82L, 5*4), ncol=4);
    write.fs.surface.ply(tempfile(fileext=".ply"), mesh$vertices,
     mesh$faces, vertex_colors=vertex_colors);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.ply2'>Write mesh to file in PLY2 File Format (.ply2)</h2><span id='topic+write.fs.surface.ply2'></span>

<h3>Description</h3>

<p>The PLY2 file format is a simply ASCII format for storing meshes. It is very similar to OFF and by far not as flexible as PLY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.ply2(filepath, vertex_coords, faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.ply2_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.off', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.ply2_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.ply2_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>See Also</h3>

<p>Other mesh export functions: 
<code><a href="#topic+write.fs.surface.obj">write.fs.surface.obj</a>()</code>,
<code><a href="#topic+write.fs.surface.off.ply2">write.fs.surface.off.ply2</a>()</code>,
<code><a href="#topic+write.fs.surface.off">write.fs.surface.off</a>()</code>,
<code><a href="#topic+write.fs.surface.ply">write.fs.surface.ply</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.ply2(tempfile(fileext=".ply2"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.surface.vtk'>Write mesh to file in VTK ASCII format</h2><span id='topic+write.fs.surface.vtk'></span>

<h3>Description</h3>

<p>Write mesh to file in VTK ASCII format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.surface.vtk(filepath, vertex_coords, faces)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.surface.vtk_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output surface file, should end with '.vtk', but that is not enforced.</p>
</td></tr>
<tr><td><code id="write.fs.surface.vtk_+3A_vertex_coords">vertex_coords</code></td>
<td>
<p>n x 3 matrix of doubles. Each row defined the x,y,z coords for a vertex.</p>
</td></tr>
<tr><td><code id="write.fs.surface.vtk_+3A_faces">faces</code></td>
<td>
<p>n x 3 matrix of integers. Each row defined the 3 vertex indices that make up the face. WARNING: Vertex indices should be given in R-style, i.e., the index of the first vertex is 1. However, they will be written in FreeSurfer style, i.e., all indices will have 1 substracted, so that the index of the first vertex will be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string the format that was written. One of &quot;tris&quot; or &quot;quads&quot;. Currently only triangular meshes are supported, so always 'tris'.
</p>


<h3>See Also</h3>

<p>Other mesh functions: 
<code><a href="#topic+faces.quad.to.tris">faces.quad.to.tris</a>()</code>,
<code><a href="#topic+read.fs.surface.asc">read.fs.surface.asc</a>()</code>,
<code><a href="#topic+read.fs.surface.bvsrf">read.fs.surface.bvsrf</a>()</code>,
<code><a href="#topic+read.fs.surface.geo">read.fs.surface.geo</a>()</code>,
<code><a href="#topic+read.fs.surface.gii">read.fs.surface.gii</a>()</code>,
<code><a href="#topic+read.fs.surface.ico">read.fs.surface.ico</a>()</code>,
<code><a href="#topic+read.fs.surface.obj">read.fs.surface.obj</a>()</code>,
<code><a href="#topic+read.fs.surface.off">read.fs.surface.off</a>()</code>,
<code><a href="#topic+read.fs.surface.ply">read.fs.surface.ply</a>()</code>,
<code><a href="#topic+read.fs.surface.vtk">read.fs.surface.vtk</a>()</code>,
<code><a href="#topic+read.fs.surface">read.fs.surface</a>()</code>,
<code><a href="#topic+read.mesh.brainvoyager">read.mesh.brainvoyager</a>()</code>,
<code><a href="#topic+read_nisurfacefile">read_nisurfacefile</a>()</code>,
<code><a href="#topic+read_nisurface">read_nisurface</a>()</code>,
<code><a href="#topic+write.fs.surface.asc">write.fs.surface.asc</a>()</code>,
<code><a href="#topic+write.fs.surface.byu">write.fs.surface.byu</a>()</code>,
<code><a href="#topic+write.fs.surface.gii">write.fs.surface.gii</a>()</code>,
<code><a href="#topic+write.fs.surface.mz3">write.fs.surface.mz3</a>()</code>,
<code><a href="#topic+write.fs.surface">write.fs.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Read a surface from a file:
    surface_file = system.file("extdata", "lh.tinysurface",
     package = "freesurferformats", mustWork = TRUE);
    mesh = read.fs.surface(surface_file);

    # Now save it:
    write.fs.surface.vtk(tempfile(fileext=".vtk"), mesh$vertices, mesh$faces);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.fs.weight'>Write file in FreeSurfer weight format</h2><span id='topic+write.fs.weight'></span>

<h3>Description</h3>

<p>Write vertex-wise brain data for a set of vertices to file in *weight* format. This format is also known as *paint* format or simply as *w* format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.weight(filepath, vertex_indices, values, format = "bin")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.weight_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output weight file.</p>
</td></tr>
<tr><td><code id="write.fs.weight_+3A_vertex_indices">vertex_indices</code></td>
<td>
<p>vector of integers, the vertex indices. Must be one-based (R-style). This function will substract 1, as they need to be stored zero-based in the file.</p>
</td></tr>
<tr><td><code id="write.fs.weight_+3A_values">values</code></td>
<td>
<p>vector of floats. The brain morphometry data to write, one value per vertex.</p>
</td></tr>
<tr><td><code id="write.fs.weight_+3A_format">format</code></td>
<td>
<p>character string, one of 'bin' or 'asc'. The weight format type, there is a binary version of the format and an ASCII version.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight.asc">write.fs.weight.asc</a>()</code>
</p>

<hr>
<h2 id='write.fs.weight.asc'>Write file in FreeSurfer weight ASCII format</h2><span id='topic+write.fs.weight.asc'></span>

<h3>Description</h3>

<p>Write vertex-wise brain data for a set of vertices to an ASCII file in *weight* format. This format is also known as *paint* format or simply as *w* format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fs.weight.asc(filepath, vertex_indices, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fs.weight.asc_+3A_filepath">filepath</code></td>
<td>
<p>string. Full path to the output ASCII weight file.</p>
</td></tr>
<tr><td><code id="write.fs.weight.asc_+3A_vertex_indices">vertex_indices</code></td>
<td>
<p>vector of integers, the vertex indices. Must be one-based (R-style). This function will substract 1, as they need to be stored zero-based in the file.</p>
</td></tr>
<tr><td><code id="write.fs.weight.asc_+3A_values">values</code></td>
<td>
<p>vector of floats. The brain morphometry data to write, one value per vertex.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other morphometry functions: 
<code><a href="#topic+fs.get.morph.file.ext.for.format">fs.get.morph.file.ext.for.format</a>()</code>,
<code><a href="#topic+fs.get.morph.file.format.from.filename">fs.get.morph.file.format.from.filename</a>()</code>,
<code><a href="#topic+read.fs.curv">read.fs.curv</a>()</code>,
<code><a href="#topic+read.fs.mgh">read.fs.mgh</a>()</code>,
<code><a href="#topic+read.fs.morph.gii">read.fs.morph.gii</a>()</code>,
<code><a href="#topic+read.fs.morph">read.fs.morph</a>()</code>,
<code><a href="#topic+read.fs.volume">read.fs.volume</a>()</code>,
<code><a href="#topic+read.fs.weight">read.fs.weight</a>()</code>,
<code><a href="#topic+write.fs.curv">write.fs.curv</a>()</code>,
<code><a href="#topic+write.fs.label.gii">write.fs.label.gii</a>()</code>,
<code><a href="#topic+write.fs.mgh">write.fs.mgh</a>()</code>,
<code><a href="#topic+write.fs.morph.asc">write.fs.morph.asc</a>()</code>,
<code><a href="#topic+write.fs.morph.gii">write.fs.morph.gii</a>()</code>,
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>,
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>,
<code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a>()</code>,
<code><a href="#topic+write.fs.morph.txt">write.fs.morph.txt</a>()</code>,
<code><a href="#topic+write.fs.morph">write.fs.morph</a>()</code>,
<code><a href="#topic+write.fs.weight">write.fs.weight</a>()</code>
</p>

<hr>
<h2 id='write.nifti1'>Write header and data to a file in NIFTI v1 format.</h2><span id='topic+write.nifti1'></span>

<h3>Description</h3>

<p>Write header and data to a file in NIFTI v1 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.nifti1(filepath, niidata, niiheader = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.nifti1_+3A_filepath">filepath</code></td>
<td>
<p>the file to write. The extension should be '.nii' or '.nii.gz'.</p>
</td></tr>
<tr><td><code id="write.nifti1_+3A_niidata">niidata</code></td>
<td>
<p>array of numeric or integer data, with up to 7 dimensions. Will be written to the file with the datatype and bitpix specified in the 'niiheader' argument. Set to &lsquo;NULL' and pass a &rsquo;niiheader' to write only the header, and remember to adapt 'magic' in the header.</p>
</td></tr>
<tr><td><code id="write.nifti1_+3A_niiheader">niiheader</code></td>
<td>
<p>an optional NIFTI v1 header that is suitable for the passed 'niidata'. If not given, one will be generated with <code><a href="#topic+ni1header.for.data">ni1header.for.data</a></code>.</p>
</td></tr>
<tr><td><code id="write.nifti1_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+ni1header.for.data">ni1header.for.data</a></code>. Only used if 'niiheader' is 'NULL'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other nifti1 writers: 
<code><a href="#topic+write.fs.morph.ni1">write.fs.morph.ni1</a>()</code>
</p>

<hr>
<h2 id='write.nifti2'>Write header and data to a file in NIFTI v2 format.</h2><span id='topic+write.nifti2'></span>

<h3>Description</h3>

<p>Write header and data to a file in NIFTI v2 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.nifti2(filepath, niidata, niiheader = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.nifti2_+3A_filepath">filepath</code></td>
<td>
<p>the file to write. The extension should be '.nii' or '.nii.gz'.</p>
</td></tr>
<tr><td><code id="write.nifti2_+3A_niidata">niidata</code></td>
<td>
<p>array of numeric or integer data, with up to 7 dimensions. Will be written to the file with the datatype and bitpix specified in the 'niiheader' argument.</p>
</td></tr>
<tr><td><code id="write.nifti2_+3A_niiheader">niiheader</code></td>
<td>
<p>an optional NIFTI v2 header that is suitable for the passed 'niidata'. If not given, one will be generated with <code><a href="#topic+ni2header.for.data">ni2header.for.data</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other nifti2 writers: 
<code><a href="#topic+write.fs.morph.ni2">write.fs.morph.ni2</a>()</code>
</p>

<hr>
<h2 id='write.smp.brainvoyager'>Write a brainvoyager SMP file.</h2><span id='topic+write.smp.brainvoyager'></span>

<h3>Description</h3>

<p>Write a brainvoyager SMP file, which contains one or more vertex-wise data maps (stats or morphometry data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.smp.brainvoyager(filepath, bvsmp, smp_version = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.smp.brainvoyager_+3A_filepath">filepath</code></td>
<td>
<p>character string, the output file</p>
</td></tr>
<tr><td><code id="write.smp.brainvoyager_+3A_bvsmp">bvsmp</code></td>
<td>
<p>bvsmp instance, a named list as returned by <code><a href="#topic+read.smp.brainvoyager">read.smp.brainvoyager</a></code>.</p>
</td></tr>
<tr><td><code id="write.smp.brainvoyager_+3A_smp_version">smp_version</code></td>
<td>
<p>integer, the SMP file format version to use when writing. Versions 2 to 5 are supported, but only versions 2 and 3 have been tested properly. Please report any problems you encounter. When converting between file versions (e.g., loading a v2 file and saving the result as a v5 file), some required fields may be missing, and for those without a default value according to the official spec, you will have to manually add the value you want in the bvsmp object before writing.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+write.fs.morph.smp">write.fs.morph.smp</a></code>
</p>

<hr>
<h2 id='write.smp.brainvoyager.v2'>Write a brainvoyager v2 SMP file.</h2><span id='topic+write.smp.brainvoyager.v2'></span>

<h3>Description</h3>

<p>Write a brainvoyager v2 SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.smp.brainvoyager.v2(filepath, bvsmp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.smp.brainvoyager.v2_+3A_filepath">filepath</code></td>
<td>
<p>character string, the output file</p>
</td></tr>
<tr><td><code id="write.smp.brainvoyager.v2_+3A_bvsmp">bvsmp</code></td>
<td>
<p>bvsmp instance, a named list as returned by <code><a href="#topic+read.smp.brainvoyager">read.smp.brainvoyager</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by <code><a href="#topic+write.smp.brainvoyager">write.smp.brainvoyager</a></code>.
</p>
<p>The map_type and num_lags of the first vertex map will be used for the top header,i.e., for all maps. The v2 format does not support per-map settings for these values. Also min_alg, max_lag and cc_overlay are ignored.
</p>

<hr>
<h2 id='write.smp.brainvoyager.v3or4or5'>Write a brainvoyager v3, v4 or v5 SMP file.</h2><span id='topic+write.smp.brainvoyager.v3or4or5'></span>

<h3>Description</h3>

<p>Write a brainvoyager v3, v4 or v5 SMP file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.smp.brainvoyager.v3or4or5(filepath, bvsmp, smp_version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.smp.brainvoyager.v3or4or5_+3A_filepath">filepath</code></td>
<td>
<p>character string, the output file</p>
</td></tr>
<tr><td><code id="write.smp.brainvoyager.v3or4or5_+3A_bvsmp">bvsmp</code></td>
<td>
<p>bvsmp instance, a named list as returned by <code><a href="#topic+read.smp.brainvoyager">read.smp.brainvoyager</a></code>.</p>
</td></tr>
<tr><td><code id="write.smp.brainvoyager.v3or4or5_+3A_smp_version">smp_version</code></td>
<td>
<p>integer, the SMP file format version to use when writing. Versions 2 to 5 are supported, but only versions 2 and 3 have been tested properly. Please report any problems you encounter. When converting between file versions (e.g., loading a v2 file and saving the result as a v5 file), some required fields may be missing, and for those without a default value according to the official spec, you will have to manually add the value you want in the bvsmp object before writing.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by <code><a href="#topic+write.smp.brainvoyager">write.smp.brainvoyager</a></code>.
</p>

<hr>
<h2 id='xml_node_gifti_coordtransform'>Create XML GIFTI CoordinateSystemTransformMatrix node.</h2><span id='topic+xml_node_gifti_coordtransform'></span>

<h3>Description</h3>

<p>Create XML GIFTI CoordinateSystemTransformMatrix node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_node_gifti_coordtransform(
  transform_matrix,
  data_space = "NIFTI_XFORM_UNKNOWN",
  transformed_space = "NIFTI_XFORM_UNKNOWN",
  as_cdata = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_node_gifti_coordtransform_+3A_transform_matrix">transform_matrix</code></td>
<td>
<p>numerical 4x4 matrix, the transformation matrix from 'data_space' to 'transformed_space'.</p>
</td></tr>
<tr><td><code id="xml_node_gifti_coordtransform_+3A_data_space">data_space</code></td>
<td>
<p>character string, the space used by the data before transformation.</p>
</td></tr>
<tr><td><code id="xml_node_gifti_coordtransform_+3A_transformed_space">transformed_space</code></td>
<td>
<p>character string, the space reached after application of the transformation matrix.</p>
</td></tr>
<tr><td><code id="xml_node_gifti_coordtransform_+3A_as_cdata">as_cdata</code></td>
<td>
<p>logical, whether to wrap text attributes ('data_space' and 'transformed_space') in cdata tags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML node from xml2
</p>

<hr>
<h2 id='xml_node_gifti_label'>Create XML GIFTI Label node.</h2><span id='topic+xml_node_gifti_label'></span>

<h3>Description</h3>

<p>Create XML GIFTI Label node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_node_gifti_label(value, attributes = list(), as_cdata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_node_gifti_label_+3A_value">value</code></td>
<td>
<p>the text contents of the node, usually the region name</p>
</td></tr>
<tr><td><code id="xml_node_gifti_label_+3A_attributes">attributes</code></td>
<td>
<p>named list, the attributes</p>
</td></tr>
<tr><td><code id="xml_node_gifti_label_+3A_as_cdata">as_cdata</code></td>
<td>
<p>logical, whether to wrap the value in cdata tags</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML node from xml2
</p>

<hr>
<h2 id='xml_node_gifti_label_table'>Create XML GIFTI LabelTable node.</h2><span id='topic+xml_node_gifti_label_table'></span>

<h3>Description</h3>

<p>Create XML GIFTI LabelTable node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_node_gifti_label_table(attributes = list())
</code></pre>


<h3>Value</h3>

<p>XML node from xml2
</p>

<hr>
<h2 id='xml_node_gifti_label_table_from_annot'>Compute LabelTable node from annotation.</h2><span id='topic+xml_node_gifti_label_table_from_annot'></span>

<h3>Description</h3>

<p>Compute LabelTable node from annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_node_gifti_label_table_from_annot(annot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_node_gifti_label_table_from_annot_+3A_annot">annot</code></td>
<td>
<p>an fs.annotation, the included data will be used to compute the LabelTable node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML tree from xml2, the LabelTable and its child nodes
</p>

<hr>
<h2 id='xml_node_gifti_MD'>Create XML GIFTI metadata node.</h2><span id='topic+xml_node_gifti_MD'></span>

<h3>Description</h3>

<p>Create XML GIFTI metadata node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_node_gifti_MD(name, value, as_cdata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_node_gifti_MD_+3A_name">name</code></td>
<td>
<p>character string, the metadata name</p>
</td></tr>
<tr><td><code id="xml_node_gifti_MD_+3A_value">value</code></td>
<td>
<p>character string, the metadata value</p>
</td></tr>
<tr><td><code id="xml_node_gifti_MD_+3A_as_cdata">as_cdata</code></td>
<td>
<p>logical, whether to wrap the value in cdata tags</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XML tree from xml2
</p>


<h3>Note</h3>

<p>This creates an MD note, not the outer MetaData node.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
