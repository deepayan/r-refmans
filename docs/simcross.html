<!DOCTYPE html><html lang="en"><head><title>Help for package simcross</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simcross}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AILped'><p>Example AIL pedigree</p></a></li>
<li><a href='#calc_Lstar'><p>Calculate adjusted chromosome length for obligate chiasma</p></a></li>
<li><a href='#CCcolors'><p>Collaborative Cross colors</p></a></li>
<li><a href='#check_pedigree'><p>Check a pedigree for errors</p></a></li>
<li><a href='#collapse_do_alleles'><p>Collapse alleles for simulated DO genotypes</p></a></li>
<li><a href='#convert2geno'><p>Convert continuous allele information into marker genotypes</p></a></li>
<li><a href='#convert2geno_allchr'><p>Convert continuous allele information into marker genotypes for</p>
multiple chromosomes</a></li>
<li><a href='#create_parent'><p>Create a parent object</p></a></li>
<li><a href='#cross'><p>Cross two individuals</p></a></li>
<li><a href='#get_geno'><p>Get genotype at a single position</p></a></li>
<li><a href='#mouseL_cox'><p>Mouse chromosome lengths</p></a></li>
<li><a href='#mouseL_mgi'><p>Mouse chromosome lengths</p></a></li>
<li><a href='#plot_crosslines'><p>Plot cross lines</p></a></li>
<li><a href='#plot_ind'><p>Plot an individual</p></a></li>
<li><a href='#sim_4way_pedigree'><p>Simulate pedigree for 4-way intercross</p></a></li>
<li><a href='#sim_ail_pedigree'><p>Simulate AIL pedigree</p></a></li>
<li><a href='#sim_ail_pedigree_fix_n'><p>Simulate AIL pedigree with fixed n</p></a></li>
<li><a href='#sim_crossovers'><p>Simulate crossover locations using the Stahl model</p></a></li>
<li><a href='#sim_do_pedigree'><p>Simulate a pedigree for Diversity Outbred mice</p></a></li>
<li><a href='#sim_do_pedigree_fix_n'><p>Simulate a pedigree for Diversity Outbreds for a target sample size</p></a></li>
<li><a href='#sim_dof1_pedigree'><p>Simulate pedigree for F1 between diversity outbreds and another inbred line</p></a></li>
<li><a href='#sim_from_pedigree'><p>Simulate genotypes for pedigree</p></a></li>
<li><a href='#sim_from_pedigree_allchr'><p>Simulate genotypes for pedigree for multiple chromosomes</p></a></li>
<li><a href='#sim_meiosis'><p>Simulate meiosis</p></a></li>
<li><a href='#sim_ril_pedigree'><p>Generate a ril pedigree</p></a></li>
<li><a href='#where_het'><p>Find heterozygous regions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate Experimental Crosses</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate and plot general experimental crosses. The focus is on simulating genotypes with an aim towards flexibility rather than speed. Meiosis is simulated following the Stahl model, in which chiasma locations are the superposition of two processes: a proportion p coming from a process exhibiting no interference, and the remainder coming from a process following the chi-square model.</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl W Broman <a href="https://orcid.org/0000-0002-4914-6671"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl W Broman &lt;broman@wisc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, Rcpp (&ge; 0.12.17)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>qtl, knitr, rmarkdown, testthat, devtools, roxygen2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kbroman.org/simcross/">https://kbroman.org/simcross/</a>, <a href="https://github.com/kbroman/simcross">https://github.com/kbroman/simcross</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kbroman/simcross/issues">https://github.com/kbroman/simcross/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 12:12:02 UTC; kbroman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 12:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='AILped'>Example AIL pedigree</h2><span id='topic+AILped'></span>

<h3>Description</h3>

<p>Example matrix describing the pedigree for advanced intercross lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AILped)
</code></pre>


<h3>Format</h3>

<p>A data frame with five columns: individual id, mom, dad, sex (0
for females and 1 for males) and generation.
</p>


<h3>Source</h3>

<p>Derived from the pedF8 dataset in the QTLRel package,
<a href="https://cran.r-project.org/package=QTLRel">https://cran.r-project.org/package=QTLRel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AILped)
x &lt;- sim_from_pedigree(AILped)
</code></pre>

<hr>
<h2 id='calc_Lstar'>Calculate adjusted chromosome length for obligate chiasma</h2><span id='topic+calc_Lstar'></span>

<h3>Description</h3>

<p>Calculate the reduced chromosome length that will give the target
expected number of chiasmata when conditioning on there being at
least one chiasma on the four-strand bundle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Lstar(L, m = 0, p = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_Lstar_+3A_l">L</code></td>
<td>
<p>Length of chromosome (in cM); must be &gt; 50</p>
</td></tr>
<tr><td><code id="calc_Lstar_+3A_m">m</code></td>
<td>
<p>Interference parameter for chi-square model</p>
</td></tr>
<tr><td><code id="calc_Lstar_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata coming from no-interference
process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted length of chromosome
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross()</a></code>, <code><a href="#topic+sim_meiosis">sim_meiosis()</a></code>,
<code><a href="#topic+sim_crossovers">sim_crossovers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_Lstar(100, 0, 0)
calc_Lstar(60, 10, 0.1)
</code></pre>

<hr>
<h2 id='CCcolors'>Collaborative Cross colors</h2><span id='topic+CCcolors'></span>

<h3>Description</h3>

<p>Get the vector of colors for the Collaborative Cross
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCcolors(palette = c("new", "original", "official"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CCcolors_+3A_palette">palette</code></td>
<td>
<p>Which version of the colors to use? (New or original)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of eight colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CCcolors()
</code></pre>

<hr>
<h2 id='check_pedigree'>Check a pedigree for errors</h2><span id='topic+check_pedigree'></span>

<h3>Description</h3>

<p>Perform a series of checks on the tabular data for a pedigree,
checking for problems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pedigree(pedigree, ignore_sex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_pedigree_+3A_pedigree">pedigree</code></td>
<td>
<p>Numeric matrix or data frame with four columns: ID,
mom ID, dad ID, sex. Sex is coded as <code>0</code>=female,
<code>1</code>=male. There can be additional columns, but they'll be
ignored.</p>
</td></tr>
<tr><td><code id="check_pedigree_+3A_ignore_sex">ignore_sex</code></td>
<td>
<p>If TRUE, ignore the sex values completely
(appropriate for hermaphroditic species.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parents should be listed before any of their
offspring. Founders should have 0's for mother and father; all
others should have non-zero values for the parents, and the parents
should appear in the pedigree. Father should be male and mothers
should be female (unless <code>ignore_sex=TRUE</code>). Individual
identifiers should be unique and non-zero. There should be no
missing values anywhere. (<code>NA</code>s are allowed in the sex column
if <code>ignore_sex=TRUE</code>.)
</p>


<h3>Value</h3>

<p>TRUE (invisibly) if everything is okay; otherwise gives an
error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_ril_pedigree(7)
check_pedigree(tab)

</code></pre>

<hr>
<h2 id='collapse_do_alleles'>Collapse alleles for simulated DO genotypes</h2><span id='topic+collapse_do_alleles'></span>

<h3>Description</h3>

<p>When simulating Diversity Outbreds, we need to specify parents
1-16, with 9-16 being the males from strains 1-8.  This function
collapses replaces alleles 9-16 with 1-8, to make the result
ordinary DO-type data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_do_alleles(xodata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_do_alleles_+3A_xodata">xodata</code></td>
<td>
<p>The sort of detailed genotype/crossover data
generated by <code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object, with alleles 9-16 replaced by 1-8.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_do_pedigree">sim_do_pedigree()</a></code>, <code><a href="#topic+sim_do_pedigree_fix_n">sim_do_pedigree_fix_n()</a></code>,
<code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate DO pedigree
tab &lt;- sim_do_pedigree(8)

# simulate genotypes for that pedigree
dat &lt;- sim_from_pedigree(tab)
# collapse to alleles 1-8
dat &lt;- collapse_do_alleles(dat)

# also works with data on multiple chromosomes
dat &lt;- sim_from_pedigree(tab, c("1"=100, "2"=75, "X"=100), xchr="X")
dat &lt;- collapse_do_alleles(dat)
</code></pre>

<hr>
<h2 id='convert2geno'>Convert continuous allele information into marker genotypes</h2><span id='topic+convert2geno'></span>

<h3>Description</h3>

<p>Convert the continuous crossover location information produced by
sim_from_pedigree to marker genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2geno(xodat, map, founder_geno = NULL, shift_map = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2geno_+3A_xodat">xodat</code></td>
<td>
<p>The sort of detailed genotype/crossover data generated by
<code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code></p>
</td></tr>
<tr><td><code id="convert2geno_+3A_map">map</code></td>
<td>
<p>vector of marker locations; can also be a list of such
vectors (one per chromosome), in which case xodat and founder_geno
must be lists with the same length.</p>
</td></tr>
<tr><td><code id="convert2geno_+3A_founder_geno">founder_geno</code></td>
<td>
<p>Optional matrix (size <code>n_founders</code> x
<code>length(map)</code>) of founder genotypes. If coded as 1/2 (or 1/3),
results are 1/2/3 genotypes. If coded as A/T/G/C/N, results are
A/T/G/C/N/H genotypes. If coded as letters A-H for the 8 founders,
results are two-letter genotypes AA-HH with 36 possible values.</p>
</td></tr>
<tr><td><code id="convert2geno_+3A_shift_map">shift_map</code></td>
<td>
<p>If TRUE, shift genetic map to start at 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>founder_geno</code> is provided or there are just two
founders, the result is a numeric matrix of genotypes, individuals
x markers, with genotypes 1/2/3 codes for 11/12/22 genotypes.
</p>
<p>If <code>founder_geno</code> is not provided and there are more than two
founders, the result is a 3-dimensional array, individuals x
markers x alleles, with the third dimensional corresponding to the
maternal and paternal allele.
</p>
<p>If the input <code>map</code> is a list (the components being
chromosomes), then <code>xodat</code> and <code>founder_geno</code> must be
lists of the same length, and the result will be a list of
matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_geno">get_geno()</a></code>, <code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate AIL pedigree
tab &lt;- sim_ail_pedigree(12, 30)
# simulate data from that pedigree
dat &lt;- sim_from_pedigree(tab)
# marker map (could also use sim.map in R/qtl)
map &lt;- seq(0, 100, by=5)
names(map) &lt;- paste0("marker", seq(along=map))
# convert data to marker genotypes
geno &lt;- convert2geno(dat, map)


# AIL with multiple chromosomes
dat &lt;- sim_from_pedigree(tab, c("1"=100, "2"=75, "X"=100), xchr="X")
# marker map
multmap &lt;- list("1"=seq(0, 100, by=5),
                "2"=seq(0, 75, by=5),
                "X"=seq(0, 100, by=5))
for(i in 1:3)
  names(multmap[[i]]) &lt;- paste0("marker", i, "_", 1:length(map[[i]]))
geno &lt;- convert2geno(dat, multmap)

# simulate DO pedigree
tab &lt;- sim_do_pedigree(8)
# simulate data from that pedigree
dat &lt;- sim_from_pedigree(tab)
# simulate founder snp alleles
fg &lt;- matrix(sample(1:2, 8*length(map), repl=TRUE), nrow=8)
# for DO, need female &amp; male founders (to deal with X chr)
fg &lt;- rbind(fg, fg)
# convert dat to SNP genotypes
geno &lt;- convert2geno(dat, map, fg)
# if fg not provided, result is a 3d array
genoarray &lt;- convert2geno(dat, map)
</code></pre>

<hr>
<h2 id='convert2geno_allchr'>Convert continuous allele information into marker genotypes for
multiple chromosomes</h2><span id='topic+convert2geno_allchr'></span>

<h3>Description</h3>

<p>Wrap up of convert2geno to adequate multiple chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2geno_allchr(
  xodat,
  map,
  id = NULL,
  founder_geno = NULL,
  return.matrix = TRUE,
  shift_map = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2geno_allchr_+3A_xodat">xodat</code></td>
<td>
<p>The sort of detailed genotype/crossover data generated
by <code><a href="#topic+sim_from_pedigree_allchr">sim_from_pedigree_allchr()</a></code></p>
</td></tr>
<tr><td><code id="convert2geno_allchr_+3A_map">map</code></td>
<td>
<p>marker locations, a list with elements for each
chromosome</p>
</td></tr>
<tr><td><code id="convert2geno_allchr_+3A_id">id</code></td>
<td>
<p>ids for which individuals genotypes is desired</p>
</td></tr>
<tr><td><code id="convert2geno_allchr_+3A_founder_geno">founder_geno</code></td>
<td>
<p>Optional list of matrices (one per chromosome)
of size <code>n_founders</code> x <code>n_markers</code>, with the founder genotypes.
If coded as 1/2 (or 1/3), results are 1/2/3
genotypes. If coded as A/T/G/C/N, results are A/T/G/C/N/H
genotypes. If coded as letters A-H (in the case of 8 founders), results are
two-letter genotypes AA-HH with 36 possible values.</p>
</td></tr>
<tr><td><code id="convert2geno_allchr_+3A_return.matrix">return.matrix</code></td>
<td>
<p>If FALSE, the result is a list of length
<code>n_chrs</code>, otherwise it is converted into a matrix if size
<code>length(id)</code> x <code>n_markers</code>.</p>
</td></tr>
<tr><td><code id="convert2geno_allchr_+3A_shift_map">shift_map</code></td>
<td>
<p>If TRUE, shift genetic map to start at 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>founder_geno</code> is provided or there are just two
founders, the result is a numeric matrix of genotypes, individuals
x markers, with genotypes 1/2/3 codes for 11/12/22 genotypes. If
there are more than two founders and <code>founder_geno</code> are
letters, the result is a character matrix, too.
</p>
<p>If <code>founder_geno</code> is not provided and there are more than two
founders, the result is a 3-dimensional array, individuals x
markers x alleles, with the third dimensional corresponding to the
maternal and paternal allele.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert2geno">convert2geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
# marker map
map &lt;- sim.map(len=rep(100, 19), n.mar=10, include.x=FALSE)
# simulate AIL pedigree
tab &lt;- sim_ail_pedigree(12, 30)
# simulate data from that pedigree
dat &lt;- sim_from_pedigree_allchr(tab, map)
names(map) &lt;- paste0("marker", seq(along=map))
# convert data to marker genotypes
id &lt;- which(tab[, "gen"]==12)
geno &lt;- convert2geno_allchr(dat, map, id)

</code></pre>

<hr>
<h2 id='create_parent'>Create a parent object</h2><span id='topic+create_parent'></span>

<h3>Description</h3>

<p>Create a parent object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_parent(L, allele = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_parent_+3A_l">L</code></td>
<td>
<p>chromosome length in cM</p>
</td></tr>
<tr><td><code id="create_parent_+3A_allele">allele</code></td>
<td>
<p>vector of integers for alleles, of length 1 or 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components, for the individual's two
chromosomes.  Each is a list with alleles in chromosome intervals
(as integers) and locations of the right endpoints of those
intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross">cross()</a></code>, <code><a href="#topic+sim_meiosis">sim_meiosis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_parent(100, 1)
create_parent(100, 1:2)
</code></pre>

<hr>
<h2 id='cross'>Cross two individuals</h2><span id='topic+cross'></span>

<h3>Description</h3>

<p>Simulate the cross of two individuals to create a
single progeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(
  mom,
  dad,
  m = 10,
  p = 0,
  xchr = FALSE,
  male = FALSE,
  obligate_chiasma = FALSE,
  Lstar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_+3A_mom">mom</code></td>
<td>
<p>An individual object, as produced by
<code><a href="#topic+create_parent">create_parent()</a></code> or this function.</p>
</td></tr>
<tr><td><code id="cross_+3A_dad">dad</code></td>
<td>
<p>An individual object, as produced by
<code><a href="#topic+create_parent">create_parent()</a></code> or this function.</p>
</td></tr>
<tr><td><code id="cross_+3A_m">m</code></td>
<td>
<p>interference parameter for chi-square model</p>
</td></tr>
<tr><td><code id="cross_+3A_p">p</code></td>
<td>
<p>proportion of crossovers coming from no-interference process</p>
</td></tr>
<tr><td><code id="cross_+3A_xchr">xchr</code></td>
<td>
<p>If TRUE, simulate X chromosome</p>
</td></tr>
<tr><td><code id="cross_+3A_male">male</code></td>
<td>
<p>If TRUE, simulate a male (matters only if
<code>xchr=TRUE</code>)</p>
</td></tr>
<tr><td><code id="cross_+3A_obligate_chiasma">obligate_chiasma</code></td>
<td>
<p>If TRUE, require an obligate chiasma on the
4-strand bundle at meiosis.</p>
</td></tr>
<tr><td><code id="cross_+3A_lstar">Lstar</code></td>
<td>
<p>Adjusted chromosome length, if
<code>obligate_chiasma=TRUE</code>. Calculated if not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulations are under the Stahl model with the
interference parameter being an integer. This is an extension of
the chi-square model, but with chiasmata being the superposition of
two processes, one following the chi-square model and the other
exhibiting no interference.
</p>


<h3>Value</h3>

<p>A list with two components, for the individual's two
chromosomes.  Each is a list with alleles in chromosome intervals
(as integers) and locations of the right endpoints of those
intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_parent">create_parent()</a></code>, <code><a href="#topic+sim_meiosis">sim_meiosis()</a></code>,
<code><a href="#topic+sim_crossovers">sim_crossovers()</a></code>, <code><a href="#topic+calc_Lstar">calc_Lstar()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mom &lt;- create_parent(100, 1:2)
dad &lt;- create_parent(100, 1:2)
child &lt;- cross(mom, dad)
</code></pre>

<hr>
<h2 id='get_geno'>Get genotype at a single position</h2><span id='topic+get_geno'></span>

<h3>Description</h3>

<p>With data on the continuous crossover location information produced by
sim_from_pedigree, grab the genotype at a given position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geno(xodat, position)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_geno_+3A_xodat">xodat</code></td>
<td>
<p>The sort of detailed genotype/XO data generated by
<code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code></p>
</td></tr>
<tr><td><code id="get_geno_+3A_position">position</code></td>
<td>
<p>Position (in cM) for which to obtain genotypes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with two columns: the maternal and
paternal allele for each individual.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>, <code><a href="#topic+convert2geno">convert2geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate AIL pedigree
tab &lt;- sim_ail_pedigree(12, 30)
# simulate data from that pedigree
dat &lt;- sim_from_pedigree(tab)
# get genotype at position 30 cM
geno &lt;- get_geno(dat, 30)
</code></pre>

<hr>
<h2 id='mouseL_cox'>Mouse chromosome lengths</h2><span id='topic+mouseL_cox'></span>

<h3>Description</h3>

<p>Mouse chromosome lengths in cM from the Cox et al. map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mouseL_cox)
</code></pre>


<h3>Format</h3>

<p>A numeric vector with lengths in cM for the 20 mouse chromosomes.
</p>


<h3>Source</h3>

<p>Taken from Table 1 of Cox et al. (2009) A new standard
genetic map for the laboratory mouse. Genetics 182:1335-1344.
<a href="https://doi.org/10.1534/genetics.109.105486">doi:10.1534/genetics.109.105486</a>
</p>


<h3>See Also</h3>

<p>mouseL_mgi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouseL_cox)
</code></pre>

<hr>
<h2 id='mouseL_mgi'>Mouse chromosome lengths</h2><span id='topic+mouseL_mgi'></span>

<h3>Description</h3>

<p>Mouse chromosome lengths in cM from the Mouse Genome Informatics
(MGI) standard map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mouseL_mgi)
</code></pre>


<h3>Format</h3>

<p>A numeric vector with lengths in cM for the 20 mouse chromosomes.
</p>


<h3>Source</h3>

<p>Taken from Table 1 of Cox et al. (2009) A new standard
genetic map for the laboratory mouse. Genetics 182:1335-1344.
<a href="https://doi.org/10.1534/genetics.109.105486">doi:10.1534/genetics.109.105486</a>
</p>


<h3>See Also</h3>

<p>mouseL_cox
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouseL_mgi)
</code></pre>

<hr>
<h2 id='plot_crosslines'>Plot cross lines</h2><span id='topic+plot_crosslines'></span>

<h3>Description</h3>

<p>Add lines for a cross
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_crosslines(
  momloc,
  dadloc,
  kidsloc,
  gap = 3,
  chrlength = 30,
  cex = 1.5,
  lwd = 2,
  arrow_length = 0.1,
  col = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_crosslines_+3A_momloc">momloc</code></td>
<td>
<p>An (x,y) vector with center location for mother</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_dadloc">dadloc</code></td>
<td>
<p>An (x,y) vector with center location for mother</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_kidsloc">kidsloc</code></td>
<td>
<p>Either an (x,y) vector with center location for a
kid, or a list of such for multiple kids</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_gap">gap</code></td>
<td>
<p>Gap arrows and points/rectangles</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_chrlength">chrlength</code></td>
<td>
<p>Length of chromosomes</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_cex">cex</code></td>
<td>
<p>Character expansion for x point</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_lwd">lwd</code></td>
<td>
<p>Line width for points, segments, and arrows</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_arrow_length">arrow_length</code></td>
<td>
<p>The <code>length</code> parameter in the call to
<code><a href="graphics.html#topic+arrows">graphics::arrows()</a></code></p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_col">col</code></td>
<td>
<p>Color of lines and points</p>
</td></tr>
<tr><td><code id="plot_crosslines_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to arrows() and segments()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_ind">plot_ind()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mom &lt;- create_parent(100, 1:2)
dad &lt;- create_parent(100, 3:4)
kids &lt;- lapply(1:4, function(junk) cross(mom, dad))
plot(0,0, type="n", xlim=c(0, 100), ylim=c(0,100),
     xaxt="n", yaxt="n", xlab="", ylab="")
loc &lt;- list(c(25,75), c(75,75), c(12.5,25), c(37.5,25), c(62.5, 25), c(87.5,25))
plot_ind(mom, loc[[1]])
plot_ind(dad, loc[[2]])
for(i in 1:4) plot_ind(kids[[i]], loc[[i+2]])
plot_crosslines(loc[[1]], loc[[2]], loc[3:6])
</code></pre>

<hr>
<h2 id='plot_ind'>Plot an individual</h2><span id='topic+plot_ind'></span>

<h3>Description</h3>

<p>Add an individual, as a pair of chromosomes, to a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ind(
  ind,
  center,
  chrlength = 30,
  chrwidth = 3,
  gap = 3,
  col = CCcolors(),
  border = "black",
  lend = 1,
  ljoin = 1,
  allborders = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ind_+3A_ind">ind</code></td>
<td>
<p>An individual object, as output by
<code><a href="#topic+create_parent">create_parent()</a></code> or <code><a href="#topic+cross">cross()</a></code></p>
</td></tr>
<tr><td><code id="plot_ind_+3A_center">center</code></td>
<td>
<p>(x,y) vector for the center of the individual</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_chrlength">chrlength</code></td>
<td>
<p>Length of chromosomes (Can be a vector of length
2, in which case the two chromosomes will be different lengths,
aligned at the top. This is for the X chromosome.)</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_chrwidth">chrwidth</code></td>
<td>
<p>Width of chromosomes</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_col">col</code></td>
<td>
<p>Vector of colors</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_border">border</code></td>
<td>
<p>Color for border</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_lend">lend</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+rect">graphics::rect()</a></code></p>
</td></tr>
<tr><td><code id="plot_ind_+3A_ljoin">ljoin</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+rect">graphics::rect()</a></code></p>
</td></tr>
<tr><td><code id="plot_ind_+3A_allborders">allborders</code></td>
<td>
<p>If TRUE, put borders around all segments</p>
</td></tr>
<tr><td><code id="plot_ind_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to rect()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_crosslines">plot_crosslines()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mom &lt;- create_parent(100, 1:2)
dad &lt;- create_parent(100, 3:4)
kid &lt;- cross(mom, dad)
plot(0,0, type="n", xlim=c(0, 100), ylim=c(0,100),
     xaxt="n", yaxt="n", xlab="", ylab="")
loc &lt;- list(c(25,75), c(75,75), c(50,25))
plot_ind(mom, loc[[1]])
plot_ind(dad, loc[[2]])
plot_ind(kid, loc[[3]])
plot_crosslines(loc[[1]], loc[[2]], loc[[3]])
</code></pre>

<hr>
<h2 id='sim_4way_pedigree'>Simulate pedigree for 4-way intercross</h2><span id='topic+sim_4way_pedigree'></span>

<h3>Description</h3>

<p>Simulate a 4-way cross, among four inbred lines (a table of
individual, mom, dad, sex)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_4way_pedigree(ngen = 1, nsibs = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_4way_pedigree_+3A_ngen">ngen</code></td>
<td>
<p>Number of intercross generations (1 or 2)</p>
</td></tr>
<tr><td><code id="sim_4way_pedigree_+3A_nsibs">nsibs</code></td>
<td>
<p>Vector with number of siblings in the sibships in the
last generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We start with a set of 4 individuals (representing four
inbred lines), and make a pair of crosses to generate a pair of
heterozygous individuals.  These are then crosses to generate a set
of F1 individuals. If <code>ngen==1</code>, we stop there, with
<code>sum(nsibs)</code> individuals in this last generation.  If
<code>gen==2</code>, we generate <code>length(nsibs)</code> male/female pairs
of F1 offspring; these are intercrossed to generate a set of
sibships, with lengths defined by the values in <code>nsibs</code>.
Individuals in the last generation are alternating female/male.
</p>


<h3>Value</h3>

<p>A data frame with five columns: individual ID, mother ID,
father ID, sex, and generation.  Founders have <code>0</code> for mother
and father ID. Sex is coded 0 for female and 1 for male.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_do_pedigree">sim_do_pedigree()</a></code>,
<code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 100 F1s between heterozygous parents
tab &lt;- sim_4way_pedigree(1, 100)
# could also do this
tab2 &lt;- sim_4way_pedigree(1, rep(10, 10))

# 120 F2s in 10 sibships each of size 12
tab3 &lt;- sim_4way_pedigree(ngen=2, rep(12, 10))
</code></pre>

<hr>
<h2 id='sim_ail_pedigree'>Simulate AIL pedigree</h2><span id='topic+sim_ail_pedigree'></span>

<h3>Description</h3>

<p>Simulate a pedigree for advanced intercross lines (a table of
individual, mom, dad, sex)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ail_pedigree(
  ngen = 12,
  npairs = 30,
  nkids_per = 5,
  design = c("nosib", "random")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_ail_pedigree_+3A_ngen">ngen</code></td>
<td>
<p>Number of generations of outbreeding</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_+3A_npairs">npairs</code></td>
<td>
<p>Number of breeding pairs at each generation</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_+3A_nkids_per">nkids_per</code></td>
<td>
<p>Number of offspring per pair for the last
generation</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_+3A_design">design</code></td>
<td>
<p>How to choose crosses: either random but avoiding
siblings, or completely at random</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Advanced intercross lines (AIL) are generated from a pair of inbred lines.
We cross them and then cross the F1 to generate <code>npair</code> breeding pairs.
The subsequent <code>ngen</code> outbreeding generations then proceed by
crossing a male and female from the preceding generation (mated
completely at random, with <code>design="random"</code>, or avoiding
siblings, with <code>design="nosib"</code>). Each breeding pair gives a
single female and a single male to the next generation, except at
the last generation <code>nkids_per</code> offspring are mated, in equal
numbers male and female. (If <code>nkids_per</code> is an odd number, the
number of males and females in each sibship will differ by one,
alternating between sibships, with one additional female and then
one additional male.
</p>


<h3>Value</h3>

<p>A data frame with five columns: individual ID, mother ID,
father ID, sex, and generation.  Founders have <code>0</code> for mother
and father ID. Sex is coded 0 for female and 1 for male.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_do_pedigree">sim_do_pedigree()</a></code>,
<code><a href="#topic+sim_4way_pedigree">sim_4way_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_ail_pedigree(12, 30)
</code></pre>

<hr>
<h2 id='sim_ail_pedigree_fix_n'>Simulate AIL pedigree with fixed n</h2><span id='topic+sim_ail_pedigree_fix_n'></span>

<h3>Description</h3>

<p>Simulate a pedigree for advanced intercross lines (a table of
individual, mom, dad, sex) so that the last generation reaches a
desired sample size n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ail_pedigree_fix_n(
  ngen = 12,
  nkids_per = 5,
  nsample_ngen = 150,
  npairs = NULL,
  method = c("last2", "sub2"),
  design = c("nosib", "random")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_ail_pedigree_fix_n_+3A_ngen">ngen</code></td>
<td>
<p>Number of generations of outbreeding</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_fix_n_+3A_nkids_per">nkids_per</code></td>
<td>
<p>Number of offspring per pair for the last
generation</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_fix_n_+3A_nsample_ngen">nsample_ngen</code></td>
<td>
<p>Number of individuals desired at the last
generation</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_fix_n_+3A_npairs">npairs</code></td>
<td>
<p>Number of breeding pairs at each generation. If
missing, we use 30 when <code>method="last2"</code> and 300 when
<code>method="sub2"</code>.</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_fix_n_+3A_method">method</code></td>
<td>
<p>Method used to generate pedigree: either expand at the last
two generations or generate a pedigree with a large number of pairs and
select a subset to have the desired sample size.</p>
</td></tr>
<tr><td><code id="sim_ail_pedigree_fix_n_+3A_design">design</code></td>
<td>
<p>How to choose crosses: either random but avoiding
siblings, or completely at random</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value for <code>npairs</code> depends on the choice of <code>method</code>.
For <code>method="last2"</code>, we use a default of <code>npairs=30</code>; for
<code>method="sub2"</code>, we use a default of <code>npairs=300</code>.
</p>


<h3>Value</h3>

<p>A data frame with five columns: individual ID, mother ID,
father ID, sex, and generation.  Founders have <code>0</code> for mother
and father ID. Sex is coded 0 for female and 1 for male.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>,
<code><a href="#topic+sim_do_pedigree">sim_do_pedigree()</a></code>, <code><a href="#topic+sim_4way_pedigree">sim_4way_pedigree()</a></code>,
<code><a href="#topic+sim_do_pedigree_fix_n">sim_do_pedigree_fix_n()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_ail_pedigree_fix_n(12)
</code></pre>

<hr>
<h2 id='sim_crossovers'>Simulate crossover locations using the Stahl model</h2><span id='topic+sim_crossovers'></span>

<h3>Description</h3>

<p>Simulate crossover locations on a single meiotic product using the
Stahl model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_crossovers(L, m = 10, p = 0, obligate_chiasma = FALSE, Lstar = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_crossovers_+3A_l">L</code></td>
<td>
<p>length of chr in cM</p>
</td></tr>
<tr><td><code id="sim_crossovers_+3A_m">m</code></td>
<td>
<p>Interference parameter (<code>m=0</code> is no interference)</p>
</td></tr>
<tr><td><code id="sim_crossovers_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata from no-interference mechanism
(<code>p=0</code> gives pure chi-square model)</p>
</td></tr>
<tr><td><code id="sim_crossovers_+3A_obligate_chiasma">obligate_chiasma</code></td>
<td>
<p>If TRUE, require an obligate chiasma on the
4-strand bundle at meiosis.</p>
</td></tr>
<tr><td><code id="sim_crossovers_+3A_lstar">Lstar</code></td>
<td>
<p>Adjusted chromosome length, if
<code>obligate_chiasma=TRUE</code>. Calculated if not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chiasma locations are a superposition of two
processes: a proportion p exhibiting no interference, and a
proportion (1-p) following the chi-square model with interference
parameter m.  Crossover locations are derived by thinning the
chiasma locations with probability 1/2.
</p>
<p>Simulations are under the Stahl model with the
interference parameter being an integer. This is an extension of
the chi-square model, but with chiasmata being the superposition of
two processes, one following the chi-square model and the other
exhibiting no interference.
</p>


<h3>Value</h3>

<p>Numeric vector of crossover locations, in cM
</p>


<h3>References</h3>

<p>Copenhaver, G. P., Housworth, E. A. and Stahl, F. W. (2002) Crossover
interference in arabidopsis.  <em>Genetics</em> <b>160</b>, 1631&ndash;1639.
</p>
<p>Foss, E., Lande, R., Stahl, F. W. and Steinberg, C. M. (1993) Chiasma
interference as a function of genetic distance. <em>Genetics</em>
<b>133</b>, 681&ndash;691.
</p>
<p>Zhao, H., Speed, T. P. and McPeek, M. S. (1995) Statistical analysis
of crossover interference using the chi-square model.  <em>Genetics</em>
<b>139</b>, 1045&ndash;1056.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim_crossovers(200, 10, 0)
x &lt;- sim_crossovers(200, 10, 0.04)
x &lt;- sim_crossovers(100, 0, 0, obligate_chiasma=TRUE)

</code></pre>

<hr>
<h2 id='sim_do_pedigree'>Simulate a pedigree for Diversity Outbred mice</h2><span id='topic+sim_do_pedigree'></span>

<h3>Description</h3>

<p>Simulate a pedigree for generating Diversity Outbred (DO) mice (a
table of individual, mom, dad, sex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_do_pedigree(
  ngen = 12,
  npairs = 144,
  ccgen = rep(4:12, c(21, 64, 24, 10, 5, 9, 5, 3, 3)),
  nkids_per = 5,
  design = c("nosib", "random")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_do_pedigree_+3A_ngen">ngen</code></td>
<td>
<p>Number of generations of outbreeding</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_+3A_npairs">npairs</code></td>
<td>
<p>Number of breeding pairs at each generation</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_+3A_ccgen">ccgen</code></td>
<td>
<p>Vector of length <code>npairs</code>, with the number of
generations for each CC line. If length 1, it is repeated to a
vector of length <code>npairs</code>.</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_+3A_nkids_per">nkids_per</code></td>
<td>
<p>Number of offspring per pair for the last
generation</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_+3A_design">design</code></td>
<td>
<p>How to choose crosses: either random but avoiding
siblings, or completely at random</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diversity outbred (DO) mice are generated from a set of 8 inbred
lines. We need two individuals from each line (one female and one
male) as the order of the initial crosses will be randomized; for
example, sometimes the individual from line 1 will be a mother and
sometimes a father. The founders are numbered 1-8 for the females
from the 8 lines, and 9-16 for the corresponding males.
</p>
<p>Diversity Outbred mice are generated by first creating a panel of
partially-inbred 8-way RIL (the so-called pre-CC, for
pre-Collaborative Cross). The <code>ccgen</code> argument specifies the
number of inbreeding generations for each of the CC lines. We
generate a pre-CC line for each of the <code>npairs</code> breeding
pairs, and generate a sibling pair from each as the starting
material.
</p>
<p>The subsequent <code>ngen</code> outbreeding generations then proceed by
crossing a male and female from the preceding generation (mated
completely at random, with <code>design="random"</code>, or avoiding
siblings, with <code>design="nosib"</code>). Each breeding pair gives a
single female and a single male to the next generation, except at
the last generation <code>nkids_per</code> offspring are mated, in equal
numbers male and female. (If <code>nkids_per</code> is an odd number, the
number of males and females in each sibship will differ by one,
alternating between sibships, with one additional female and then
one additional male.
</p>
<p>The default for <code>ccgen</code> is taken from Figure 1 of Svenson et
al. (2012).
</p>


<h3>Value</h3>

<p>A data frame with six columns: individual ID, mother ID, father
ID, sex, generation, and TRUE/FALSE indicator for whether DO or pre-DO.
Founders have <code>0</code> for mother and father ID. Sex is coded 0 for
female and 1 for male.
</p>


<h3>References</h3>

<p>Svenson KL, Gatti DM, Valdar W, Welsh CE, Cheng R, Chesler EJ,
Palmer AA, McMillan L, Churchill GA (2012) High-resolution genetic
mapping using the mouse Diversity Outbred population. Genetics
190:437-447
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>,
<code><a href="#topic+sim_4way_pedigree">sim_4way_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_do_pedigree(8)
</code></pre>

<hr>
<h2 id='sim_do_pedigree_fix_n'>Simulate a pedigree for Diversity Outbreds for a target sample size</h2><span id='topic+sim_do_pedigree_fix_n'></span>

<h3>Description</h3>

<p>Simulate a pedigree for Diversity Outbred (DO) mice (a table of
individual, mom, dad, sex) so that the last generation reaches a
desired sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_do_pedigree_fix_n(
  ngen = 12,
  nkids_per = 5,
  nccgen = 15,
  nsample_ngen = 150,
  npairs = NULL,
  method = c("last2", "sub2", "fixcc"),
  design = c("nosib", "random"),
  selc.method = c("byfamily", "byindiv")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_do_pedigree_fix_n_+3A_ngen">ngen</code></td>
<td>
<p>Number of generations of outbreeding</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_nkids_per">nkids_per</code></td>
<td>
<p>Number of offspring per pair for the last
generation</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_nccgen">nccgen</code></td>
<td>
<p>The number of generations for each CC line, only used
when <code>method</code> is not <code>"fixcc"</code>.</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_nsample_ngen">nsample_ngen</code></td>
<td>
<p>Number of individuals desired at the last
generation</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_npairs">npairs</code></td>
<td>
<p>Number of breeding pairs at each generation. If
missing, we use 30 when <code>method="last2"</code> and 300 when
<code>method="sub2"</code>.</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_method">method</code></td>
<td>
<p>Method used to generate the pedigree: either expand
at the last two generations or generate a pedigree with a large
number of pairs and then select a subset to have the desired sample
size. With <code>method="fixcc"</code>, we use the pre-CC generations as performed at the
Jackson Lab.</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_design">design</code></td>
<td>
<p>How to choose crosses: either random but avoiding
siblings, or completely at random</p>
</td></tr>
<tr><td><code id="sim_do_pedigree_fix_n_+3A_selc.method">selc.method</code></td>
<td>
<p>Method used to select the individuals from last
generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default number of breeding pairs depends on the chosen
<code>method</code>. With <code>method="last2"</code>, the default is <code>npairs=30</code>;
with <code>method="sub2"</code>, the default is <code>npairs=300</code>;
with <code>method="fixcc"</code>, <code>npairs</code> is ignored and is fixed at 144.
</p>


<h3>Value</h3>

<p>A data frame with six columns: individual ID, mother ID, father
ID, sex, generation, and TRUE/FALSE indicator for whether DO or pre-DO.
Founders have <code>0</code> for mother and father ID. Sex is coded 0 for
female and 1 for male.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>,
<code><a href="#topic+sim_do_pedigree">sim_do_pedigree()</a></code>, <code><a href="#topic+sim_4way_pedigree">sim_4way_pedigree()</a></code>,
<code><a href="#topic+sim_ail_pedigree_fix_n">sim_ail_pedigree_fix_n()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_do_pedigree_fix_n(8)
</code></pre>

<hr>
<h2 id='sim_dof1_pedigree'>Simulate pedigree for F1 between diversity outbreds and another inbred line</h2><span id='topic+sim_dof1_pedigree'></span>

<h3>Description</h3>

<p>Simulate a pedigree for a set of DOF1 individuals: the F1 offspring
of a set of diversity outbred mice and another inbred strain (such
as a mutant line).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dof1_pedigree(
  ngen = 12,
  npairs = 144,
  ccgen = rep(4:12, c(21, 64, 24, 10, 5, 9, 5, 3, 3)),
  nkids_per = 5,
  design = c("nosib", "random")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_dof1_pedigree_+3A_ngen">ngen</code></td>
<td>
<p>Number of generations of outbreeding</p>
</td></tr>
<tr><td><code id="sim_dof1_pedigree_+3A_npairs">npairs</code></td>
<td>
<p>Number of breeding pairs at each generation</p>
</td></tr>
<tr><td><code id="sim_dof1_pedigree_+3A_ccgen">ccgen</code></td>
<td>
<p>Vector of length <code>npairs</code>, with the number of
generations for each CC line. If length 1, it is repeated to a
vector of length <code>npairs</code>.</p>
</td></tr>
<tr><td><code id="sim_dof1_pedigree_+3A_nkids_per">nkids_per</code></td>
<td>
<p>Number of offspring per pair for the last
DO generation (each will be crossed to produce one F1)</p>
</td></tr>
<tr><td><code id="sim_dof1_pedigree_+3A_design">design</code></td>
<td>
<p>How to choose crosses: either random but avoiding
siblings, or completely at random</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diversity outbred (DO) mice are generated from a set of 8 inbred
lines. We need two individuals from each line (one female and one
male) as the order of the initial crosses will be randomized; for
example, sometimes the individual from line 1 will be a mother and
sometimes a father. The founders are numbered 1-8 for the females
from the 8 lines, and 9-16 for the corresponding males.
</p>
<p>Diversity Outbred mice are generated by first creating a panel of
partially-inbred 8-way RIL (the so-called pre-CC, for
pre-Collaborative Cross). The <code>ccgen</code> argument specifies the
number of inbreeding generations for each of the CC lines. We
generate a pre-CC line for each of the <code>npairs</code> breeding
pairs, and generate a sibling pair from each as the starting
material.
</p>
<p>The subsequent <code>ngen</code> outbreeding generations then proceed by
crossing a male and female from the preceding generation (mated
completely at random, with <code>design="random"</code>, or avoiding
siblings, with <code>design="nosib"</code>). Each breeding pair gives a
single female and a single male to the next generation, except at
the last generation <code>nkids_per</code> offspring are mated, in equal
numbers male and female. (If <code>nkids_per</code> is an odd number, the
number of males and females in each sibship will differ by one,
alternating between sibships, with one additional female and then
one additional male.
</p>
<p>The default for <code>ccgen</code> is taken from Figure 1 of Svenson et
al. (2012).
</p>
<p>We assume that the F1 offspring are all from a cross DO female x
line 17 male, and so the last generation of the DO is taken to be
all females.
</p>


<h3>Value</h3>

<p>A data frame with seven columns: individual ID, mother ID,
father ID, sex, generation, a TRUE/FALSE indicator for whether DO
or pre-DO, and a TRUE/FALSE indicator for whether DOF1.  Founders
have <code>0</code> for mother and father ID. Sex is coded 0 for female
and 1 for male.
</p>


<h3>References</h3>

<p>Svenson KL, Gatti DM, Valdar W, Welsh CE, Cheng R, Chesler EJ,
Palmer AA, McMillan L, Churchill GA (2012) High-resolution genetic
mapping using the mouse Diversity Outbred population. Genetics
190:437-447
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>,
<code><a href="#topic+sim_4way_pedigree">sim_4way_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_dof1_pedigree(8)
</code></pre>

<hr>
<h2 id='sim_from_pedigree'>Simulate genotypes for pedigree</h2><span id='topic+sim_from_pedigree'></span>

<h3>Description</h3>

<p>Simulate genotypes along one chromosome for a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_from_pedigree(
  pedigree,
  L = 100,
  xchr = FALSE,
  m = 10,
  p = 0,
  obligate_chiasma = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_from_pedigree_+3A_pedigree">pedigree</code></td>
<td>
<p>Matrix or data frame describing a pedigree, with first four
columns being individual ID, mom ID, dad ID, and sex (female as
<code>0</code>, male as <code>1</code>).</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_+3A_l">L</code></td>
<td>
<p>Length of chromosome in cM (or a vector of chromosome lengths)</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_+3A_xchr">xchr</code></td>
<td>
<p>If TRUE, simulate X chromosome. (If <code>L</code> is a
vector, this should be a vector of TRUE/FALSE values, of the same
length as <code>L</code>, or a character string with the name of the X
chromosome, in <code>L</code>.)</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_+3A_m">m</code></td>
<td>
<p>Crossover interference parameter, for chi-square model
(m=0 corresponds to no interference).</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_+3A_p">p</code></td>
<td>
<p>proportion of crossovers coming from no-interference process</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_+3A_obligate_chiasma">obligate_chiasma</code></td>
<td>
<p>If TRUE, require an obligate chiasma on the
4-strand bundle at meiosis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with each component being the data for one
individual, as produced by the <code><a href="#topic+cross">cross()</a></code> function.  Those
results are a list with two components, corresponding to the
maternal and paternal chromosomes. The chromosomes are represented
as lists with two components: an integer vector of alleles in
chromosome intervals, and a numeric vector of locations of the
right-endpoints of those intervals; these two vectors should have
the same length.
</p>
<p>If the input <code>L</code> is a vector, in order to simulate multiple
chromosomes at once, then the output will be a list with length
<code>length(L)</code>, each component being a chromosome and having the
form described above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_pedigree">check_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>,
<code><a href="#topic+sim_from_pedigree_allchr">sim_from_pedigree_allchr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate AIL pedigree
tab &lt;- sim_ail_pedigree(12, 30)
# simulate data from that pedigree
dat &lt;- sim_from_pedigree(tab)
# simulate multiple chromosomes
dat &lt;- sim_from_pedigree(tab, c("1"=100, "2"=75, "X"=100), xchr="X")
</code></pre>

<hr>
<h2 id='sim_from_pedigree_allchr'>Simulate genotypes for pedigree for multiple chromosomes</h2><span id='topic+sim_from_pedigree_allchr'></span>

<h3>Description</h3>

<p>Simulate genotypes along all chromosomes for a pedigree. This is a
wrap up of sim_from_pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_from_pedigree_allchr(
  pedigree,
  map,
  m = 10,
  p = 0,
  obligate_chiasma = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_from_pedigree_allchr_+3A_pedigree">pedigree</code></td>
<td>
<p>Matrix or data frame describing a pedigree, with first four
columns being individual ID, mom ID, dad ID, and sex (female as
<code>0</code>, male as <code>1</code>).</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_allchr_+3A_map">map</code></td>
<td>
<p>marker locations, a list with elements for each
chromosome</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_allchr_+3A_m">m</code></td>
<td>
<p>Crossover interference parameter, for chi-square model
(m=0 corresponds to no interference).</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_allchr_+3A_p">p</code></td>
<td>
<p>proportion of crossovers coming from no-interference process</p>
</td></tr>
<tr><td><code id="sim_from_pedigree_allchr_+3A_obligate_chiasma">obligate_chiasma</code></td>
<td>
<p>If TRUE, require an obligate chiasma on the
4-strand bundle at meiosis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with each component being the result from
<code>sim_from_pedigree</code>, of length same as <code>map</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_pedigree">check_pedigree()</a></code>,
<code><a href="#topic+sim_ril_pedigree">sim_ril_pedigree()</a></code>, <code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>
<code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
# marker map
map &lt;- sim.map(len=rep(100, 19), n.mar=10, include.x=FALSE)
# simulate AIL pedigree
tab &lt;- sim_ail_pedigree(12, 30)
# simulate data from that pedigree
dat &lt;- sim_from_pedigree_allchr(tab, map)

</code></pre>

<hr>
<h2 id='sim_meiosis'>Simulate meiosis</h2><span id='topic+sim_meiosis'></span>

<h3>Description</h3>

<p>Output a random meiotic product from an input individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_meiosis(parent, m = 10, p = 0, obligate_chiasma = FALSE, Lstar = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_meiosis_+3A_parent">parent</code></td>
<td>
<p>An individual object, as output by
<code><a href="#topic+create_parent">create_parent()</a></code> or <code><a href="#topic+cross">cross()</a></code></p>
</td></tr>
<tr><td><code id="sim_meiosis_+3A_m">m</code></td>
<td>
<p>interference parameter for chi-square model</p>
</td></tr>
<tr><td><code id="sim_meiosis_+3A_p">p</code></td>
<td>
<p>Proportion of chiasmata coming from no-interference process.</p>
</td></tr>
<tr><td><code id="sim_meiosis_+3A_obligate_chiasma">obligate_chiasma</code></td>
<td>
<p>If TRUE, require an obligate chiasma on the
4-strand bundle at meiosis.</p>
</td></tr>
<tr><td><code id="sim_meiosis_+3A_lstar">Lstar</code></td>
<td>
<p>Adjusted chromosome length, if
<code>obligate_chiasma=TRUE</code>. Calculated if not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulations are under the Stahl model with the
interference parameter being an integer. This is an extension of
the chi-square model, but with chiasmata being the superposition of
two processes, one following the chi-square model and the other
exhibiting no interference.
</p>


<h3>Value</h3>

<p>A list with alleles in chromosome intervals (as integers)
and locations of the right endpoints of those intervals.
</p>


<h3>References</h3>

<p>Copenhaver, G. P., Housworth, E. A. and Stahl, F. W. (2002) Crossover
interference in arabidopsis.  <em>Genetics</em> <b>160</b>, 1631&ndash;1639.
</p>
<p>Foss, E., Lande, R., Stahl, F. W. and Steinberg, C. M. (1993) Chiasma
interference as a function of genetic distance. <em>Genetics</em>
<b>133</b>, 681&ndash;691.
</p>
<p>Zhao, H., Speed, T. P. and McPeek, M. S. (1995) Statistical analysis
of crossover interference using the chi-square model.  <em>Genetics</em>
<b>139</b>, 1045&ndash;1056.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_parent">create_parent()</a></code>, <code><a href="#topic+cross">cross()</a></code>,
<code><a href="#topic+sim_crossovers">sim_crossovers()</a></code>, <code><a href="#topic+calc_Lstar">calc_Lstar()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind &lt;- create_parent(100, 1:2)
prod &lt;- sim_meiosis(ind)
</code></pre>

<hr>
<h2 id='sim_ril_pedigree'>Generate a ril pedigree</h2><span id='topic+sim_ril_pedigree'></span>

<h3>Description</h3>

<p>Generate a pedigree for multi-way recombinant inbred lines (a table
of individual, mom, dad, sex)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ril_pedigree(
  ngen = 20,
  selfing = FALSE,
  parents = 1:2,
  firstind = max(parents) + 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_ril_pedigree_+3A_ngen">ngen</code></td>
<td>
<p>Number of generations of inbreeding</p>
</td></tr>
<tr><td><code id="sim_ril_pedigree_+3A_selfing">selfing</code></td>
<td>
<p>If TRUE, use selfing</p>
</td></tr>
<tr><td><code id="sim_ril_pedigree_+3A_parents">parents</code></td>
<td>
<p>Vector of the parents' IDs. Should be integers, and
length must be a power of 2 (i.e., 2, 4, 8, ...)</p>
</td></tr>
<tr><td><code id="sim_ril_pedigree_+3A_firstind">firstind</code></td>
<td>
<p>Positive integer to assign to the first child. Must
be greater than <code>max(parents)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with five columns: individual ID, mother ID,
father ID, sex, and generation.  Founders have <code>0</code> for mother
and father ID. Sex is coded 0 for female and 1 for male.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+sim_ail_pedigree">sim_ail_pedigree()</a></code>, <code><a href="#topic+sim_do_pedigree">sim_do_pedigree()</a></code>,
<code><a href="#topic+sim_4way_pedigree">sim_4way_pedigree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- sim_ril_pedigree(7)
</code></pre>

<hr>
<h2 id='where_het'>Find heterozygous regions</h2><span id='topic+where_het'></span>

<h3>Description</h3>

<p>Find regions of heterozygosity in an individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where_het(ind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="where_het_+3A_ind">ind</code></td>
<td>
<p>An individual object, as output be
<code><a href="#topic+create_parent">create_parent()</a></code> or <code><a href="#topic+cross">cross()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns; each row indicates the start and
end of a region where the individual is heterozygous
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_from_pedigree">sim_from_pedigree()</a></code>,
<code><a href="#topic+convert2geno">convert2geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mom &lt;- create_parent(100, 1:2)
dad &lt;- create_parent(100, 1:2)
child &lt;- cross(mom, dad)
where_het(child)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
