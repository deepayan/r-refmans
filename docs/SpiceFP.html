<!DOCTYPE html><html><head><title>Help for package SpiceFP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpiceFP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpiceFP-package'><p>A Sparse and Structured Procedure to Identify Combined Effects of Functional Predictors</p></a></li>
<li><a href='#candidates'><p>candidates</p></a></li>
<li><a href='#coef_spicefp'><p>coef_spicefp</p></a></li>
<li><a href='#evaluate.candidates'><p>evaluate.candidates</p></a></li>
<li><a href='#FerariIndex_Difference'><p>FerariIndex_Difference of vine dataset</p></a></li>
<li><a href='#finemeshed2d'><p>finemeshed2d</p></a></li>
<li><a href='#finemeshed3d'><p>finemeshed3d</p></a></li>
<li><a href='#getD3dSparse'><p>getD3dSparse</p></a></li>
<li><a href='#hist_2d'><p>hist_2d</p></a></li>
<li><a href='#hist_3d'><p>hist_3d</p></a></li>
<li><a href='#Irradiance'><p>Photosynthetic Photon Flux Density PPFD (PPFD) measurements of vine dataset</p></a></li>
<li><a href='#logbreaks'><p>logbreaks</p></a></li>
<li><a href='#meancoef'><p>meancoef</p></a></li>
<li><a href='#spicefp'><p>spicefp</p></a></li>
<li><a href='#Temperature'><p>Temperature measurements of vine dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Method to Identify Joint Effects of Functional Predictors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Girault Gnanguenon Guesse &lt;girault.gnanguenon@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions allowing to implement the 'SpiceFP' approach
  which is iterative. It involves transformation of functional predictors into
  several candidate explanatory matrices (based on contingency tables), to which
  relative edge matrices with contiguity constraints are associated. Generalized
  Fused Lasso regression are performed in order to identify the best candidate
  matrix, the best class intervals and related coefficients at each iteration.
  The approach is stopped when the maximal number of iterations is reached or
  when retained coefficients are zeros. Supplementary functions allow to get
  coefficients of any candidate matrix or mean of coefficients of many candidates.
  The methods in this package are describing in Girault Gnanguenon Guesse, 
  Patrice Loisel, Bénedicte Fontez, Thierry Simonneau, Nadine Hilgert (2021)
  "An exploratory penalized regression to identify combined effects of functional
  variables -Application to agri-environmental issues" 
  <a href="https://hal.archives-ouvertes.fr/hal-03298977">https://hal.archives-ouvertes.fr/hal-03298977</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, stringr, tidyr, Matrix, genlasso, purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-31 14:06:46 UTC; gnanguen</td>
</tr>
<tr>
<td>Author:</td>
<td>Girault Gnanguenon Guesse [aut, cre],
  Patrice Loisel [aut],
  Benedicte Fontez [aut],
  Nadine Hilgert [aut],
  Thierry Simonneau [ctr],
  Isabelle Sanchez [ctr]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-01 09:10:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpiceFP-package'>A Sparse and Structured Procedure to Identify Combined Effects of Functional Predictors</h2><span id='topic+SpiceFP'></span><span id='topic+SpiceFP-package'></span>

<h3>Description</h3>

<p>A set of functions allowing to implement the 'SpiceFP' approach which is iterative. It involves transformation of functional predictors into several candidate explanatory matrices (based on contingency tables), to which relative edge matrices with contiguity constraints are associated. Generalized Fused Lasso regression are performed in order to identify the best candidate matrix, the best class intervals and related coefficients at each iteration. The approach is stopped when the maximal number of iterations is reached or when retained coefficients are zeros. Supplementary functions allow to get coefficients of any candidate matrix or mean of coefficients of many candidates. The methods in this package are describing in Girault Gnanguenon Guesse, Patrice Loisel, Bénedicte Fontez, Thierry Simonneau, Nadine Hilgert (2021) &quot;An exploratory penalized regression to identify combined effects of functional variables -Application to agri-environmental issues&quot; <a href="https://hal.archives-ouvertes.fr/hal-03298977">https://hal.archives-ouvertes.fr/hal-03298977</a>.
</p>


<h3>Details</h3>

<p>The main function of the package is the <code><a href="#topic+spicefp">spicefp</a></code> function. It directly
performs the three main steps of the SpiceFP approach, by using intermediate functions of the package. <br />
1) At he first step, contingency tables are constructed by
defining joint modalities using class intervals or bins. Several candidate
partitions are then defined.
For each statistical individual <code class="reqn">i</code> and each candidate partition (denoted <code class="reqn">u</code> here), the 2 (resp. 3)
functional predictors are transformed into frequency bi(resp. tri)-variate histograms (or contingency tables),
stored as row vectors. The combination of these row vectors for all individuals enables the construction of a
candidate explanatory matrix indexed by <code class="reqn">u</code> (denoted here <code class="reqn">X^u</code>).
The function <code><a href="#topic+candidates">candidates</a></code> is designed to build these candidate matrices. <br />
2) At the second step, for each candidate explanatory matrix, an edge matrix is defined to
represent the contiguity constraints between modalities of the contingency table. <br />
3) Finally at the last step, the best class intervals and related
regression coefficients are defined by: i) performing a Generalized Fused Lasso
using each candidate explanatory matrix. The SpiceFP model is the following
</p>
<p style="text-align: center;"><code class="reqn">y_i  = X_i^u \beta^u + \varepsilon_i,</code>
</p>

<p>where <code class="reqn">\beta^u</code> is the coefficient to be estimated on the 2D (resp. 3D) intervals.
The estimator of <code class="reqn">\beta</code> is obtained as follows:
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\beta}^{u,\gamma}(\lambda) = argmin \frac{1}{2} \|y - X^u \beta\|_2^2 + \lambda \|D ^{u,\gamma} \beta\|_1,</code>
</p>

<p>where <code class="reqn">\lambda</code> is a penalty parameter that controls the smoothness of the coefficients, and
<code class="reqn">\gamma</code> is the ratio between the regularization parameters of parsimony and fusion.
ii) choosing the best candidate matrix
and selecting its variables using an information criterion and checking the
shutdown conditions to stop the approach. Indeed, SpiceFP  may be used in an iterative way. It
therefore allows to identify up to K best candidate matrices and related coefficients.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Girault Gnanguenon Guesse <a href="mailto:girault.gnanguenon@gmail.com">girault.gnanguenon@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Patrice Loisel <a href="mailto:patrice.loisel@inrae.fr">patrice.loisel@inrae.fr</a>
</p>
</li>
<li><p> Benedicte Fontez <a href="mailto:benedicte.fontez@supagro.fr">benedicte.fontez@supagro.fr</a>
</p>
</li>
<li><p> Nadine Hilgert <a href="mailto:nadine.hilgert@inrae.fr">nadine.hilgert@inrae.fr</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Thierry Simonneau <a href="mailto:thierry.simonneau@inrae.fr">thierry.simonneau@inrae.fr</a> [contractor]
</p>
</li>
<li><p> Isabelle Sanchez <a href="mailto:isabelle.sanchez@inrae.fr">isabelle.sanchez@inrae.fr</a> [contractor]
</p>
</li></ul>


<hr>
<h2 id='candidates'>candidates</h2><span id='topic+candidates'></span>

<h3>Description</h3>

<p>The &quot;candidates&quot; function essentially provides the candidate matrices and
their characteristics. These candidate matrices can be constructed from 2 or
3 functional predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>candidates(
  fp1,
  fp2,
  fp3 = NULL,
  fun1,
  fun2,
  fun3 = NULL,
  parlists,
  ncores = parallel::detectCores() - 1,
  xcentering = TRUE,
  xscaling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="candidates_+3A_fp1">fp1</code></td>
<td>
<p>numerical matrix with in columns observations of one statistical
individual to partition. Each column corresponds to the functional predictor
observation for one statistical individual. The order of statistical
individuals is the same as in fp2. It is assumed that no data are
missing and that all functional predictors are observed on an equidistant (time) scale.</p>
</td></tr>
<tr><td><code id="candidates_+3A_fp2">fp2</code></td>
<td>
<p>numerical matrix with the same number of columns and rows as fp1.
Columns are also observations. The order of statistical individuals is
the same as in fp1.</p>
</td></tr>
<tr><td><code id="candidates_+3A_fp3">fp3</code></td>
<td>
<p>NULL by default. numerical matrix with the same number of columns and
rows as fp1 and fp2. The order of statistical individuals is the same
as in fp1 and fp2.</p>
</td></tr>
<tr><td><code id="candidates_+3A_fun1">fun1</code></td>
<td>
<p>a function object with 2 arguments. First argument is fp1 and
the second is a list of parameters that will help to partition fp1, such as
the number of class intervals, etc. For example, the list of parameters for using 
the logbreaks function is equivalent to list(alpha, J). All arguments
to be varied for the creation of different candidate matrices must
be stored in the parameter list. The other arguments must be set by default.</p>
</td></tr>
<tr><td><code id="candidates_+3A_fun2">fun2</code></td>
<td>
<p>a function object with 2 arguments. First argument is fp2 and
the second is a list of parameters.</p>
</td></tr>
<tr><td><code id="candidates_+3A_fun3">fun3</code></td>
<td>
<p>NULL by default. Same as fun1 and fun2, a function with 2
arguments fp3 and a list of parameters.</p>
</td></tr>
<tr><td><code id="candidates_+3A_parlists">parlists</code></td>
<td>
<p>list of 2 elements when fp3 and fun3 are equal to NULL or of 3
elements when fp3 and fun3 are provided. All elements of parlists are
lists that have the same length. Each list contains all the lists of
parameters required to create different candidates. The first
element of parlists concerns the list of parameters required for fun1, the second
element is relative to fun2 and the third to fun3. See Example 2 below.</p>
</td></tr>
<tr><td><code id="candidates_+3A_ncores">ncores</code></td>
<td>
<p>numbers of cores that will be used for parallel computation. By default, it is equal
to detectCores()-1.</p>
</td></tr>
<tr><td><code id="candidates_+3A_xcentering">xcentering</code></td>
<td>
<p>TRUE by default. Defined whether or not the variables in
the new candidate matrices should be centered.</p>
</td></tr>
<tr><td><code id="candidates_+3A_xscaling">xscaling</code></td>
<td>
<p>FALSE by default. Defined whether or not the variables in
the candidate matrices should be scaled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function begins by partitioning each of the functional
predictors using the function and associated parameter lists. Once the class
intervals are obtained for each predictor, a contingency table is created
for each statistical individual. This table counts the components of the
observation variable (time for time series). The contingency table is then
transformed into a row vector that corresponds to a row of the candidate
matrix created.  The number of candidate matrices is equal to the length of
each element contained in parlists. For a fixed index, the functional
predictors (fp1, fp2, fp3), the functions (fun1, fun2, fun3) and the lists
of parameters associated to the index in each element of parlists
allow to create a single candidate matrix. In addition to constructing
the candidate matrices, the function associates with each matrix a vector
containing the index and the numbers of class intervals used per predictor.
</p>


<h3>Value</h3>

<p>The function returns a list with:
</p>

<dl>
<dt>spicefp.dimension</dt><dd><p>the dimension of the approach. Equal to 2 if fp3=NULL and 3 if not</p>
</dd>
<dt>candidates</dt><dd><p>a list that has the same length as the elements of parlists. Each element of this list contains
a candidate matrix and a vector with index and  the numbers of class intervals used per predictor</p>
</dd>
<dt>fp1, fp2, fp3, fun1, fun2, fun3, parlists, xcentering, xscaling</dt><dd><p>same as inputs</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>##linbreaks: a function allowing to obtain equidistant breaks
linbreaks&lt;-function(x,n){
    sort(round(seq(trunc(min(x)),
         ceiling(max(x)+0.001),
         length.out =unlist(n)+1),
         1)
    )
}

p&lt;-expand.grid(c(12,15),c(15,20))
pl&lt;-list(split(p[,1], seq(nrow(p))),
         split(p[,2], seq(nrow(p))))

# Setting ncores=2 for this example check purpose
test&lt;-candidates(fp1=matrix(rnorm(1000,52,15),ncol=10),
                 fp2=matrix(rpois(1000,50),ncol=10),
                 fun1=linbreaks,
                 fun2=linbreaks,
                 parlists=pl,
                 xcentering = FALSE,
                 xscaling = FALSE,
                 ncores=2)
str(test)
names(test)

# Example 2 from the spiceFP data
tpr.nclass=seq(10,16,2)
irdc.nclass=seq(20,24,2)
irdc.alpha=c(0.01,0.02,0.03)
p2&lt;-expand.grid(tpr.nclass, irdc.alpha, irdc.nclass)
parlist.tpr&lt;-split(p2[,1], seq(nrow(p2)))
parlist.irdc&lt;-split(p2[,2:3], seq(nrow(p2)))
parlist.irdc&lt;-lapply(
  parlist.irdc,function(x){
    list(x[[1]],x[[2]])}
)
m.irdc &lt;- as.matrix(Irradiance[,-c(1)])
m.tpr &lt;- as.matrix(Temperature[,-c(1)])
test2&lt;-candidates(fp1=m.irdc,
                  fp2=m.tpr,
                  fun1=logbreaks,
                  fun2=linbreaks,
                  parlists=list(parlist.irdc,
                                parlist.tpr),
                  xcentering = TRUE,
                  xscaling = FALSE,
                  ncores=2)
length(test2$candidates)
class(test2$candidates)
#View(test2$candidates[[1]][[1]])
dim(test2$candidates[[1]][[1]])
test2$candidates[[1]][[2]]

# Closing the connections for the example check purpose
closeAllConnections()
</code></pre>

<hr>
<h2 id='coef_spicefp'>coef_spicefp</h2><span id='topic+coef_spicefp'></span>

<h3>Description</h3>

<p>This function allows to obtain the coefficients of a model (involving a
candidate matrix and 2 regularization parameters). There are two possible options to
use this function: 1/ by minimizing an information criterion and selecting a number
of model (option by default), or 2/ directly by providing the parameters of the
model(s) that the user wishes to reconstruct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_spicefp(
  spicefp.result,
  iter_,
  criterion = "AIC_",
  nmodels = 1,
  model.parameters = NULL,
  dim.finemesh = NULL,
  ncores = parallel::detectCores() - 1,
  write.external.file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_spicefp_+3A_spicefp.result">spicefp.result</code></td>
<td>
<p>List. Outputs of the spicefp function.</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_iter_">iter_</code></td>
<td>
<p>integer. number of the iteration of interest.</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_criterion">criterion</code></td>
<td>
<p>character. One of &quot;AIC_&quot;, &quot;BIC_&quot;, &quot;Cp_&quot;. Can be NULL,
&quot;AIC_&quot; by default. If specified, nmodels must also be provided.</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_nmodels">nmodels</code></td>
<td>
<p>integer. Equal to 1 by default. Represents the number of best
models, according to the information criterion used.
Should be NULL if criterion = NULL.</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_model.parameters">model.parameters</code></td>
<td>
<p>data.frame. NULL by default. One or more rows
contained in the file where the model statistics were stored. Be careful to
use the file related to the selected iteration. Names used in
model.parameters shoud be the same in the file.</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_dim.finemesh">dim.finemesh</code></td>
<td>
<p>numeric vector of length 2 or 3. This vector informs
about the dimension of the fine-mesh arrays (or matrices).</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_ncores">ncores</code></td>
<td>
<p>numbers of cores that will be used for parallel computation. By default, it is equal
to detectCores()-1.</p>
</td></tr>
<tr><td><code id="coef_spicefp_+3A_write.external.file">write.external.file</code></td>
<td>
<p>logical. indicates whether the result table related
to each iteration has been written as a file (txt) in your working directory.
This argument must be equal to the argument with the same name in the spicefp
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By providing criterion and nmodels, the function returns the
coefficients of the nmodels best models chosen by the selected information
criterion. When model.parameters is instead provided, it returns the
coefficients of the models described on each row of the data.frame.
</p>


<h3>Value</h3>

<p>Returns a list of 2 elements:
</p>

<dl>
<dt>Model.parameters</dt><dd><p>data.frame where each row contains statistics related to the
models of interest. Same as input if model.parameters is provided.</p>
</dd>
<dt>coef.list</dt><dd><p>List of length nmodels or the number of rows in Model.parameters.
Each element of this list contains the  model results as provided by the genlasso
package, its coefficients without and with NA, a fine-mesh array with the coefficients,
and the estimation of <code class="reqn">X \beta</code>. Coefficients with NA are coefficient vector
where the coefficient value of never-observed joint modalities is NA.  </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>

##linbreaks: a function allowing to obtain equidistant breaks
linbreaks&lt;-function(x,n){
       sort(round(seq(trunc(min(x)),
                ceiling(max(x)+0.001),
                length.out =unlist(n)+1),
            1)
           )
}
# In this example, we will evaluate 2 candidates with 14 temperature
# classes and 15 irradiance classes. The irradiance breaks are obtained
# according to a log scale (logbreaks function) with different alpha
# parameters for each candidate (0.005, 0.01).
## Data and inputs
tpr.nclass=14
irdc.nclass=15
irdc.alpha=c(0.005, 0.01)
p2&lt;-expand.grid(tpr.nclass, irdc.alpha, irdc.nclass)
parlist.tpr&lt;-split(p2[,1], seq(nrow(p2)))
parlist.irdc&lt;-split(p2[,2:3], seq(nrow(p2)))
parlist.irdc&lt;-lapply(
     parlist.irdc,function(x){
     list(x[[1]],x[[2]])}
)
m.irdc &lt;- as.matrix(Irradiance[,-c(1)])
m.tpr &lt;- as.matrix(Temperature[,-c(1)])

# For the constructed models, only two regularization parameter ratios
# penratios=c(1/25,5) is used. In a real case, we will have to evaluate
# more candidates and regularization parameters ratio.
ex_sp&lt;-spicefp(y=FerariIndex_Difference$fi_dif,
              fp1=m.irdc,
              fp2=m.tpr,
              fun1=logbreaks,
              fun2=linbreaks,
              parlists=list(parlist.irdc,
                            parlist.tpr),
              penratios=c(1/25,5),
              appropriate.df=NULL,
              nknots = 100,
              ncores =2,
              write.external.file = FALSE)

# coef_spicefp
## coefficients based on the parameters of the model
## focus on model selected by Mallows's Cp at iteration 1

start_time_spc &lt;- Sys.time()
results.eval.iter1&lt;-ex_sp$Evaluations[[1]]$Evaluation.results$evaluation.result
c.mdl &lt;- coef_spicefp(ex_sp, iter_=1,
                      criterion =NULL,
                      nmodels=NULL,
  model.parameters=results.eval.iter1[which.min(results.eval.iter1$Cp_),],
                      ncores = 1,
                      write.external.file =FALSE)

g1&lt;-c.mdl$coef.list$'231'$Candidate.coef.NA.finemeshed
g1.x&lt;-as.numeric(rownames(g1))
g1.y&lt;-as.numeric(colnames(g1))
duration_spc &lt;- Sys.time() - start_time_spc

#library(fields)
#plot(c(10,2000),c(15,45),type= "n", axes = FALSE,
#     xlab = "Irradiance (mmol/m2/s - Logarithmic scale)",
#     ylab = "Temperature (deg C)",log = "x")
#rect(min(g1.x),min(g1.y),max(g1.x),max(g1.y), col="black", border=NA)
#image.plot(g1.x,g1.y,g1, horizontal = FALSE,
#           col=designer.colors(64, c("blue","white")),
#           add = TRUE)
#axis(1) ; axis(2)

## Let's visualize the same model from other arguments of coef_spicefp
c.crit &lt;- coef_spicefp(ex_sp, iter_=1,
                       criterion ="Cp_",nmodels=1,
                       ncores = 1,
                       write.external.file =FALSE)
g2&lt;-c.crit$coef.list$'231'$Candidate.coef.NA.finemeshed
g2.x&lt;-as.numeric(rownames(g2))
g2.y&lt;-as.numeric(colnames(g2))
#plot(c(10,2000),c(15,45),type= "n", axes = FALSE,
#     xlab = "Irradiance (mmol/m2/s - Logarithmic scale)",
#     ylab = "Temperature (deg C)",log = "x")
#rect(min(g2.x),min(g2.y),max(g2.x),max(g2.y), col="black", border=NA)
#image.plot(g2.x,g2.y,g2, horizontal = FALSE,
#           col=designer.colors(64, c("blue","white")),
#           add = TRUE)
#axis(1) ; axis(2)
closeAllConnections()


</code></pre>

<hr>
<h2 id='evaluate.candidates'>evaluate.candidates</h2><span id='topic+evaluate.candidates'></span>

<h3>Description</h3>

<p>This function performs for each candidate matrix, a Generalized Fused Lasso
(sparse fused lasso 2d or 3d) and computes various statistics and
information criteria related to the constructed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate.candidates(
  candmatrices,
  y,
  penratios,
  nknots,
  appropriate.df = NULL,
  ncores = parallel::detectCores() - 1,
  penfun = NULL,
  file_name = "parametertable",
  write.external.file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.candidates_+3A_candmatrices">candmatrices</code></td>
<td>
<p>List. Output of the &quot;candidates&quot; function. The spicefp
dimension is the first element. The second contains many lists of one
candidate matrix and related vector with index and numbers of class
intervals used per predictor. The other elements of the lists are the
inputs of &quot;candidates&quot; function. If the user does not need the &quot;candidates&quot;
function for the creation of candmatrices, it is possible to build a list
provided that it respects the same structure as well as the names
of the outputs of the &quot;candidates&quot; function. In this case only the first two
elements of the list are essential: spicefp.dimension and candidates.
The remaining elements can be NULL.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_y">y</code></td>
<td>
<p>numerical vector. Contains the dependent variable. This vector will
be used as response variable in the construction of models involving each
candidate matrix.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_penratios">penratios</code></td>
<td>
<p>numeric vector with values greater than or equal to 0. It
represents the ratio between the regularization parameters of parsimony and
fusion. When penratios=0, it corresponds to the pure fusion. The higher
its value, the more parsimonious the model is.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_nknots">nknots</code></td>
<td>
<p>integer. For one value in penratios vector, it represents the
number of models that will be constructed for each candidate matrix. It is
the argument &quot;nlam&quot; of  <code><a href="genlasso.html#topic+coef.genlasso">coef.genlasso</a></code>
function. This argument can also be NULL. In this case, the argument
appropriate.df must be provided.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_appropriate.df">appropriate.df</code></td>
<td>
<p>(appropriate degree of freedom) NULL by default.
Numerical vector with values greater than or equal to 1. The degree of
freedom of generalized fused problem is equal the number of connected
components. A connected component gives information on a group of non-zero
coefficients sharing the same value and connected by a contiguity matrix.
More simply, it can be interpreted as a group of coefficients that have a
unique influence. When the user has a prior idea of the number of zones of
influence that the desired solution could contain, it is advisable to provide
appropriate.df, a vector of appropriate degrees of freedom. In this case,
nknots must be NULL.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_ncores">ncores</code></td>
<td>
<p>numbers of cores that will be used for parallel computation.
By default, it is equal to detectCores()-1.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_penfun">penfun</code></td>
<td>
<p>function with 2 arguments (dim1, dim2) when dealing with 2
dimensional spiceFP or 3 arguments (dim1, dim2, dim3) when dealing with 3
dimensional spiceFP. The argument order in the penalty function is
associated with the order of numbers of class intervals used per predictor
in the second element of candmatrices argument. NULL by default.
When penfun=NULL, getD2dSparse of genlasso or getD3dSparse is used according
to the dimension of spiceFP.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_file_name">file_name</code></td>
<td>
<p>character. It is the name of the file in which the
evaluation summary of all the candidate matrices is stored.
This file is saved in your working directory.</p>
</td></tr>
<tr><td><code id="evaluate.candidates_+3A_write.external.file">write.external.file</code></td>
<td>
<p>logical. Indicates whether the result table should
be written as a file (txt) in your working directory. It is recommended to use
write.external.file=TRUE when evaluating a large number of candidate matrices
(more than 100) in order to keep memory available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mainly returns statistics on the models built based
on the candidate matrices. For each candidate matrix,
length(penratios) x nknots or length(penratios) x length(appropriate.df)
models are constructed in order to estimate the regularization parameters
and to perform a variable selection. The computed statistics provide
information on the quality of the models. For obvious reasons of memory
management, the coefficients related to each of these models are not stored.
The statistics are stored in a file named via the argument file_name and
can be consulted to get an idea of the state of progress of the program.
The genlasso package is used for the implementation of the
Generalized Fused Lasso.
</p>


<h3>Value</h3>

<p>The output is a list with :
</p>

<dl>
<dt>evaluation.result</dt><dd><p>Same as file_name. The file contains a matrix with in columns : the candidate index (Candidate_id),
the value of penratios used for this model (Pen_ratio), the parameter that penalizes the difference in related coefficients
(PenPar_fusion), the degree of freedom of the model (Df_), the residual sum of squares (RSS_), the Akaike information criterion
(AIC_), the Bayesian information criterion (BIC_), the Mallows' Cp
(Cp_), the Generalized Cross Validation (GCV_), the slope of the regression lm(<code class="reqn">y</code> ~ <code class="reqn">X \beta</code>) (Slope_), the ratio <code class="reqn">var(y-X \beta)/var(y)</code>
(Var_ratio).</p>
</dd>
<dt>response.variable, penalty.ratios, nknots, appropriate.df, penalty.function</dt><dd><p>Exactly the inputs y, penratios, nknots,
appropriate.df, penfun</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Constructing 2 candidates for spiceFP data (temperature and Irradiance)
linbreaks&lt;-function(x,n){
     sort(round(seq(trunc(min(x)),
                ceiling(max(x)+0.001),
                length.out =unlist(n)+1),
            1)
         )
}
# In this example, we will evaluate 2 candidates (each having 10
# temperature classes and respectively 10 and 20 irradiance classes).
# Only one value is used for alpha (logbreaks argument)
tpr.nclass=10
irdc.nclass=c(10,20)
irdc.alpha=0.005
p2&lt;-expand.grid(tpr.nclass, irdc.alpha, irdc.nclass)
parlist.tpr&lt;-split(p2[,1], seq(nrow(p2)))
parlist.irdc&lt;-split(p2[,2:3], seq(nrow(p2)))
parlist.irdc&lt;-lapply(
   parlist.irdc,function(x){
   list(x[[1]],x[[2]])}
)
m.irdc &lt;- as.matrix(Irradiance[,-c(1)])
m.tpr &lt;- as.matrix(Temperature[,-c(1)])
test2&lt;-candidates(fp1=m.irdc,
                 fp2=m.tpr,
                 fun1=logbreaks,
                 fun2=linbreaks,
                 parlists=list(parlist.irdc,
                               parlist.tpr),
                 xcentering = TRUE,
                 xscaling = FALSE,
                 ncores=2)
# Evaluating candidates
# For the constructed models, only one regularization parameter ratio
# penratios=c(1) is used. In a real case, we will have to evaluate
# more candidates and regularization parameters ratio.
start_time_ev &lt;- Sys.time()
evcand&lt;-evaluate.candidates(candmatrices = test2,
                           y=FerariIndex_Difference$fi_dif,
                           penratios=c(1),
                           appropriate.df=NULL,
                           nknots = 100,
                           ncores=2,
                           write.external.file = FALSE)
duration_ev &lt;- Sys.time() - start_time_ev
tab_res&lt;-evcand$evaluation.result
dim(tab_res)
tab_res[which.min(tab_res$AIC_),]

closeAllConnections()


</code></pre>

<hr>
<h2 id='FerariIndex_Difference'>FerariIndex_Difference of vine dataset</h2><span id='topic+FerariIndex_Difference'></span>

<h3>Description</h3>

<p>Data were collected during an experiment conducted on a vineyard
of the INRAE/Institut Agro campus at Montpellier in 2014 (Syrah vines). The objective
of the experiment was to study the influence of the micro-climate (temperature and
irradiance) at the grape level on the anthocyanin contents of the berries indicated by
the Ferari index. This dataset contains Ferari index differences between August 01,
2014 at 09:00 am and July 24th, 2014 at 09:00 am. The
individuals are in rows. The individuals' names (Indiv1,...,Indiv32) are used to name the rows. 
The same individuals are also
present in the irradiance and temperaure datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FerariIndex_Difference
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations and 1 variable.
</p>

<dl>
<dt>fi_dif</dt><dd><p>numeric. Ferari index differences between July 24th, 2014 at 09:00 am 
and August 01, 2014 at 09:00 am.</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data were acquired during the Innovine project, funded by the Seventh
Framework Programme of the European Community (FP7/2007-2013), under Grant Agreement
No. FP7-311775.
</p>

<hr>
<h2 id='finemeshed2d'>finemeshed2d</h2><span id='topic+finemeshed2d'></span>

<h3>Description</h3>

<p>Function that helps to transform  a vector into a matrix (with a fine mesh). In the implementation of the spiceFP approach,
it allows to transform matrices of coefficients having different dimensions into matrices of the
same dimension in order to perform arithmetic operations. In practice, the matrix to be transformed is
associated with a contingency table, which implies numerical variables for which classes have been created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finemeshed2d(
  x,
  n.breaks1 = 1000,
  n.breaks2 = 1000,
  round.breaks1 = 9,
  round.breaks2 = 9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finemeshed2d_+3A_x">x</code></td>
<td>
<p>vector or one column matrix to scale. This vector comes from the vectorization of the
matrices to be transformed. x is named using the concatenation of the names of the rows and
the names of the columns of the matrix to be transformed, as shown in the example below.</p>
</td></tr>
<tr><td><code id="finemeshed2d_+3A_n.breaks1">n.breaks1</code></td>
<td>
<p>integer. Number of breaks needed for the first variable.
The variable for which classes are in first position when constructing x's names is the first variable.</p>
</td></tr>
<tr><td><code id="finemeshed2d_+3A_n.breaks2">n.breaks2</code></td>
<td>
<p>integer. Number of breaks needed for the second variable. The variable for which classes are
in second position when constructing x's names is the second variable.</p>
</td></tr>
<tr><td><code id="finemeshed2d_+3A_round.breaks1">round.breaks1</code></td>
<td>
<p>integer. Number of decimals for breaks of the first variable.</p>
</td></tr>
<tr><td><code id="finemeshed2d_+3A_round.breaks2">round.breaks2</code></td>
<td>
<p>integer. Number of decimals for breaks of the second variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to return a fine meshed matrix and breaks associated.
In order to obtain a fine mesh, a high number of breaks must be fixed.
</p>


<h3>Value</h3>

<p>Returns:
</p>

<dl>
<dt>finemeshed.matrix</dt><dd><p>Matrix of dimension n.breaks2 x n.breaks1. The row and column names of finemeshed.matrix are the
breaks created from each variable and the associated n.breaks. Each value of finemeshed.matrix is equal to the value of
x indexed by the classes containing the row and column names of finemeshed.matrix</p>
</dd>
<dt>finemeshed.values1</dt><dd><p>First variable breaks</p>
</dd>
<dt>finemeshed.values2</dt><dd><p>Second variable breaks</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(45)
count_table&lt;- hist_2d(x = rnorm(1000),
                      y = rnorm( 1000,5,0.1),
                      breaks_x = seq(-4, 4, by =1),
                      breaks_y = seq(2, 8, by =1))$Hist.Values

df.x&lt;-as.data.frame.table(count_table)
x&lt;-df.x$Freq
names(x)&lt;-paste0(df.x$Var1,"_",df.x$Var2)

res.fm2d &lt;- finemeshed2d(x,100,100)
dim(res.fm2d$finemeshed.matrix)
</code></pre>

<hr>
<h2 id='finemeshed3d'>finemeshed3d</h2><span id='topic+finemeshed3d'></span>

<h3>Description</h3>

<p>Function that helps to transform  a vector into a 3 dimensional array (with a fine
mesh). In the implementation of the spiceFP approach, it allows to transform
matrices of coefficients having different dimensions into matrices of the
same dimension in order to perform arithmetic operations. In practice, the
3d array to be transformed is associated with a contingency table, which
implies numerical variables for which classes have been created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finemeshed3d(
  x,
  n.breaks1 = 10,
  n.breaks2 = 1000,
  n.breaks3 = 500,
  round.breaks1 = 9,
  round.breaks2 = 9,
  round.breaks3 = 9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finemeshed3d_+3A_x">x</code></td>
<td>
<p>vector or one column matrix to scale. This vector comes from the
vectorization of the 3d array to be transformed. x is named using the
concatenation of the names of the dimension of the array to be transformed,
as shown in the example below.</p>
</td></tr>
<tr><td><code id="finemeshed3d_+3A_n.breaks1">n.breaks1</code></td>
<td>
<p>integer. Number of breaks needed for the first variable
The variable for which classes are in first position when constructing x's
names is the first variable.</p>
</td></tr>
<tr><td><code id="finemeshed3d_+3A_n.breaks2">n.breaks2</code></td>
<td>
<p>integer. Number of breaks needed for the second variable.
The variable for which classes are in second position when constructing x's
names is the second variable.</p>
</td></tr>
<tr><td><code id="finemeshed3d_+3A_n.breaks3">n.breaks3</code></td>
<td>
<p>integer. Number of breaks needed for the third variable.
The variable for which classes are in third position when constructing x's
names is the third variable.</p>
</td></tr>
<tr><td><code id="finemeshed3d_+3A_round.breaks1">round.breaks1</code></td>
<td>
<p>integer. Number of decimals for breaks of the first
variable.</p>
</td></tr>
<tr><td><code id="finemeshed3d_+3A_round.breaks2">round.breaks2</code></td>
<td>
<p>integer. Number of decimals for breaks of the second
variable.</p>
</td></tr>
<tr><td><code id="finemeshed3d_+3A_round.breaks3">round.breaks3</code></td>
<td>
<p>integer. Number of decimals for breaks of the third
variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to return a 3d fine meshed array and
breaks associated.
In order to obtain a fine mesh, a high number of breaks must be fixed.
</p>


<h3>Value</h3>

<p>Returns:
</p>

<dl>
<dt>finemeshed.array</dt><dd><p>Array of dimension n.breaks1 x n.breaks2 x n.breaks3.
The dimension names of finemeshed.array are the breaks created from each
variable and the associated n.breaks. Each value of finemeshed.array is
equal to the value of x indexed by the classes containing the row and column
names of finemeshed.array</p>
</dd>
<dt>finemeshed.values1</dt><dd><p>First variable breaks</p>
</dd>
<dt>finemeshed.values2</dt><dd><p>Second variable breaks</p>
</dd>
<dt>finemeshed.values3</dt><dd><p>Third variable breaks</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4)
count_table&lt;-hist_3d(x = rnorm(1000),
                     y = rnorm( 1000,5,0.1),
                     z = rnorm( 1000,2,1),
                     breaks_x = seq(-4, 4, by =1),
                     breaks_y = seq(2, 8, by =1),
                     breaks_z = seq(-3, 6, by =1))$Hist.Values

df.x&lt;-as.data.frame.table(count_table)
x&lt;-df.x$Freq
names(x)&lt;-paste0(df.x$Var1,"_",df.x$Var2,"_",df.x$Var3)

res.fm3d&lt;- finemeshed3d(x,10,50,100)
dim(res.fm3d$finemeshed.array)
</code></pre>

<hr>
<h2 id='getD3dSparse'>getD3dSparse</h2><span id='topic+getD3dSparse'></span>

<h3>Description</h3>

<p>getD3dSparse is a function that helps to construct generalized lasso
penalty matrix D when using the <code><a href="genlasso.html#topic+fusedlasso">fusedlasso</a></code>
function over a 3 dimensional grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getD3dSparse(dim1, dim2, dim3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getD3dSparse_+3A_dim1">dim1</code></td>
<td>
<p>positive integer. Based on a 3 dimensional grid, dim1 represents
the number of units represented on the first dimension</p>
</td></tr>
<tr><td><code id="getD3dSparse_+3A_dim2">dim2</code></td>
<td>
<p>positive integer which represents the number of units represented
on the second dimension</p>
</td></tr>
<tr><td><code id="getD3dSparse_+3A_dim3">dim3</code></td>
<td>
<p>positive integer which represents the number of units represented
on the third dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a sparse penalty matrix providing information
on the connections between the variables during the implementation of a
generalizad fused lasso.
</p>


<h3>Value</h3>

<p>a matrix with dim1 x dim2 x dim3 columns. Each row represents an
edge (a link between 2 variables) and is constructed with the couple (-1, 1),
relative to these 2 variables and 0 for all others. In the context of a
generalized fused lasso, this matrix penalizes only the differences in
coefficients (fusion). To obtain parsimony in addition to the fusion, a
diagonal matrix with the same number of columns must be bound to the
penalty matrix constructed by getD3dSparse. This matrix will contain
diagonally the ratio: parsimony penalty parameter on fusion penalty
parameter. When using <code><a href="genlasso.html#topic+fusedlasso">fusedlasso</a></code>
function, this operation is performed when you provide the argument gamma.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(genlasso)
library(Matrix)
D&lt;-getD3dSparse(2,3,2)
plot(getGraph(D))

</code></pre>

<hr>
<h2 id='hist_2d'>hist_2d</h2><span id='topic+hist_2d'></span>

<h3>Description</h3>

<p>This function results from a modification of the hist2d
function of the gplots package in order
to build the 2D histogram with breaks directly provided as inputs of the
new function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_2d(
  x,
  y,
  breaks_x,
  breaks_y,
  same.scale = FALSE,
  na.rm = TRUE,
  FUN = base::length
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_2d_+3A_x">x</code></td>
<td>
<p>either a numerical vector to be partitioned or a matrix of 2 numerical columns to
be partitioned.</p>
</td></tr>
<tr><td><code id="hist_2d_+3A_y">y</code></td>
<td>
<p>a numerical vector to be partitioned. Not required if x is a matrix.</p>
</td></tr>
<tr><td><code id="hist_2d_+3A_breaks_x">breaks_x</code></td>
<td>
<p>a numerical vector. Contains the breaks related to x for the
histogram</p>
</td></tr>
<tr><td><code id="hist_2d_+3A_breaks_y">breaks_y</code></td>
<td>
<p>a numerical vector. Contains the breaks related to y for the
histogram</p>
</td></tr>
<tr><td><code id="hist_2d_+3A_same.scale">same.scale</code></td>
<td>
<p>logical. Default to FALSE. If TRUE, breaks_x will be used
for x and y</p>
</td></tr>
<tr><td><code id="hist_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Default to TRUE. Indicates whether missing values
should be removed</p>
</td></tr>
<tr><td><code id="hist_2d_+3A_fun">FUN</code></td>
<td>
<p>function used to summarize bin contents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default function used for the argument FUN is the function
length. When another function is used, it is applied on x, or on the first column of x
if this is a two-column matrix. The lower limit of each class interval is
included in the class and the upper limit is not.
</p>


<h3>Value</h3>

<p>Using a given set of breaks per each variable, the function returns :
</p>

<dl>
<dt>Hist.Values</dt><dd><p>a matrix with in rows class intervals of x and in columns
class intervals of y. Contingency table is returned if FUN=length</p>
</dd>
<dt>breaks_x, breaks_y </dt><dd><p> same as the inputs of the function </p>
</dd>
<dt>Midpoints.x, Midpoints.y </dt><dd><p>the midpoints for each bin per variable </p>
</dd>
<dt>nobs.x , nobs.y </dt><dd><p>number of observations of x and y  </p>
</dd>
<dt>n.bins </dt><dd><p> vector of 2 elements containing the number of bins for
x and y </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(45)
hist_2d(x = rnorm(1000),
        y = rnorm( 1000,5,0.1),
        breaks_x = seq(-4, 4, by =1),
        breaks_y = seq(2, 8, by =1))
</code></pre>

<hr>
<h2 id='hist_3d'>hist_3d</h2><span id='topic+hist_3d'></span>

<h3>Description</h3>

<p>This function can be used in order to construct a 3D histogram based on 3
variables and relative breaks directly provided as inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_3d(
  x,
  y,
  z,
  breaks_x,
  breaks_y,
  breaks_z,
  same.scale = FALSE,
  na.rm = TRUE,
  FUN = length
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_3d_+3A_x">x</code></td>
<td>
<p>either a numerical vector to be partitioned or a matrix with 3 numerical 
columns to be partitioned.</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_y">y</code></td>
<td>
<p>a numerical vector to be partitioned. Not required if x is a matrix.</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_z">z</code></td>
<td>
<p>a numerical vector to be partitioned. Not required if x is a matrix</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_breaks_x">breaks_x</code></td>
<td>
<p>a numerical vector. Contains the breaks related to x for the
histogram</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_breaks_y">breaks_y</code></td>
<td>
<p>a numerical vector. Contains the breaks related to y for the
histogram</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_breaks_z">breaks_z</code></td>
<td>
<p>a numerical vector. Contains the breaks related to z for the
histogram</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_same.scale">same.scale</code></td>
<td>
<p>logical. Default to FALSE. If TRUE, breaks_x will be used
for x, y and z</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Default to TRUE. Indicates whether missing values
should be removed</p>
</td></tr>
<tr><td><code id="hist_3d_+3A_fun">FUN</code></td>
<td>
<p>function used to summarize bin contents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default function used for the argument FUN is the function
length. When another function is used, it is applied on x or on the first column
of x if this is a three-column matrix. The lower limit of each class interval is
included in the class and the upper limit is not.
</p>


<h3>Value</h3>

<p>Using a given set of breaks per each variable, the function returns :
</p>

<dl>
<dt>Hist.Values</dt><dd><p>a 3 dimensional array. The 1st (respectively 2nd, 3rd) dimension  is 
related to the class intervals of x (resp. y, z). Contingency table is returned if
FUN=length</p>
</dd>
<dt>breaks_x, breaks_y, breaks_z </dt><dd><p> same as the inputs of the function</p>
</dd>
<dt>Midpoints.x, Midpoints.y, Midpoints.z </dt><dd><p>the midpoints for each bin
per variable</p>
</dd>
<dt>nobs.x , nobs.y, nobs.z </dt><dd><p>number of observations of x, y and z</p>
</dd>
<dt>n.bins</dt><dd><p> vector of 3 elements containing the number of bins for x, y
and z </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4)
hist_3d(x = rnorm(1000),
        y = rnorm( 1000,5,0.1),
        z = rnorm( 1000,2,1),
        breaks_x = seq(-4, 4, by =1),
        breaks_y = seq(2, 8, by =1),
        breaks_z = seq(-2, 6, by =1))
</code></pre>

<hr>
<h2 id='Irradiance'>Photosynthetic Photon Flux Density PPFD (PPFD) measurements of vine dataset</h2><span id='topic+Irradiance'></span>

<h3>Description</h3>

<p>Data were collected during an experiment conducted on a vineyard
of the INRAE/Institut Agro campus at Montpellier in 2014 (Syrah vines). The objective
of the experiment was to study the influence of the micro-climate (temperature and
irradiance) at the grape level on the anthocyanin contents of the berries indicated by
the Ferari index. This dataset is related to irradiance measurements in
the morning (sunrise to twelve am) between July 24th, 2014 at 09:00 am and August 01,
2014 at 09:00 am. These observations are made at the same time (every 12 minutes) as the
temperature observations. The individuals are in columns while the observation times
are in rows. The same
individuals are also present in the Temperature and FerariIndex_Difference datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Irradiance
</code></pre>


<h3>Format</h3>

<p>A data frame (of one functionnal variable) with 127 rows (observation times)
and 33 columns: the 1st one is a character vector which corresponds to date-time 
in format &quot;yyyy-mm-dd hh:mm:ss&quot;, the others are numeric vectors made of the 
observations of irradiance (PPFD) measured in <code class="reqn">10^{-6}mol.m^{-2}.s^{-1}</code> on each of 
the 32 statistical individuals Indiv1,...,Indiv32.  Irradiance corresponds to the number of incident 
photons useful for photosynthesis, received per unit of time on a horizontal surface unit.
</p>


<h3>Source</h3>

<p>These data were acquired during the Innovine project, funded by the Seventh
Framework Programme of the European Community (FP7/2007-2013), under Grant Agreement
No. FP7-311775.
</p>

<hr>
<h2 id='logbreaks'>logbreaks</h2><span id='topic+logbreaks'></span>

<h3>Description</h3>

<p>A function that allows to obtain histogram class limits following a
logarithmic scale. It also has a parameter that allows to set the scale at
your convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logbreaks(
  x,
  parlist = list(alpha, J),
  round_breaks = 0,
  plot_breaks = FALSE,
  effect.threshold.begin = NA,
  effect.threshold.end = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logbreaks_+3A_x">x</code></td>
<td>
<p>either a numeric vector to be partitioned or a numeric vector
containing the minimum and maximum of the vector to be partitioned.</p>
</td></tr>
<tr><td><code id="logbreaks_+3A_parlist">parlist</code></td>
<td>
<p>a list of 2 elements. The first one is alpha, a numeric and
positive value. It is a parameter affecting the number of breaks closed to
the minimum. The second one is J. It is a nonnegative and nonzero integer and
represent the selected number of classes.</p>
</td></tr>
<tr><td><code id="logbreaks_+3A_round_breaks">round_breaks</code></td>
<td>
<p>a nonnegative integer. Equal to 0 by default, it is the
number of decimal values of the breaks.</p>
</td></tr>
<tr><td><code id="logbreaks_+3A_plot_breaks">plot_breaks</code></td>
<td>
<p>logical. FALSE by default. If TRUE, the breaks are
plotted.</p>
</td></tr>
<tr><td><code id="logbreaks_+3A_effect.threshold.begin">effect.threshold.begin</code></td>
<td>
<p>NA by default. Numeric value between the
minimum and maximum of x. If it isn't NA, the first class is created with
xmin and effect.threshold.begin.</p>
</td></tr>
<tr><td><code id="logbreaks_+3A_effect.threshold.end">effect.threshold.end</code></td>
<td>
<p>NA by default. Numeric value between the minimum
and maximum of x. If it isn't NA, the last class is created with xmax and
effect.threshold.end.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The breaks are obtained as follows: 
</p>
<p style="text-align: center;"><code class="reqn">L(w) = \min(x) + \frac{e^{\alpha \frac{w-1}{J}} - 1 }{e^{\alpha}-1} 
(\max(x) -\min(x)), \  w= 1, \ldots, J+1.</code>
</p>



<h3>Value</h3>

<p>The return is a numeric vector of length J+1 with the breaks
obtained following a log scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logbreaks(c(10,1000), parlist=list(0.2,5))
logbreaks(c(10,1000), parlist=list(0.2,5),plot_breaks=TRUE)
</code></pre>

<hr>
<h2 id='meancoef'>meancoef</h2><span id='topic+meancoef'></span>

<h3>Description</h3>

<p>This function can be used to compute the mean of coefficients from different
partitions in the context of the spicefp approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meancoef(coef.list, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meancoef_+3A_coef.list">coef.list</code></td>
<td>
<p>list. The second element of the coef_spicefp function
outputs. It has the same name as the argument.</p>
</td></tr>
<tr><td><code id="meancoef_+3A_weight">weight</code></td>
<td>
<p>a numerical vector of weights with the same length as
coef.list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here, the fine-mesh coefficients are weighted and a weighted mean is deduced. 
If the user wishes, he can use as weights the slopes associated with the qualities
of the models concerned.
</p>


<h3>Value</h3>

<p>Returns a list of :
</p>

<dl>
<dt>weighted_mean</dt><dd><p>fine-mesh matrix or array with the weighted mean of the
coefficients</p>
</dd>
<dt>y.estimated</dt><dd><p>weighted estimation of <code class="reqn">X \beta</code></p>
</dd>
<dt>coefficients.array</dt><dd><p>An array with all the fine-mesh coefficients that
will be used to compute the weighted mean</p>
</dd>
<dt>weight</dt><dd><p>same as inputs</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
##linbreaks: a function allowing to obtain breaks linearly
linbreaks&lt;-function(x,n){
     sort(round(seq(trunc(min(x)),
                ceiling(max(x)+0.001),
                length.out =unlist(n)+1),
            1)
          )
}
# In this example, we will evaluate 2 candidates with 14 temperature
# classes and 15 irradiance classes. The irradiance breaks are obtained
# according to a log scale (logbreaks function) with different alpha
# parameters for each candidate (0.005, 0.01).
## Data and inputs
tpr.nclass=14
irdc.nclass=15
irdc.alpha=c(0.005, 0.01)
p2&lt;-expand.grid(tpr.nclass, irdc.alpha, irdc.nclass)
parlist.tpr&lt;-split(p2[,1], seq(nrow(p2)))
parlist.irdc&lt;-split(p2[,2:3], seq(nrow(p2)))
parlist.irdc&lt;-lapply(
   parlist.irdc,function(x){
   list(x[[1]],x[[2]])}
)
m.irdc &lt;- as.matrix(Irradiance[,-c(1)])
m.tpr &lt;- as.matrix(Temperature[,-c(1)])

# For the constructed models, only two regularization parameter ratios
# penratios=c(1/25,5) is used. In a real case, more candidates 
# and regularization parameter ratios should be evaluated.
ex_sp&lt;-spicefp(y=FerariIndex_Difference$fi_dif,
              fp1=m.irdc,
              fp2=m.tpr,
              fun1=logbreaks,
              fun2=linbreaks,
              parlists=list(parlist.irdc,
                            parlist.tpr),
              penratios=c(1/25,5),
              appropriate.df=NULL,
              nknots = 100,
              ncores =2,
              write.external.file = FALSE)

## Focus on the 2 best models retained by the AIC criterion at iteration 1
c.mdls &lt;- coef_spicefp(ex_sp, iter_=1, criterion ="AIC_",
                      nmodels=2, ncores = 2,
                      dim.finemesh=c(1000,1000),
                      write.external.file = FALSE)

# meancoef
# Compute the mean of the coefficients of these models
mean.c.mdls&lt;-meancoef(c.mdls$coef.list,
                     weight = c.mdls$Model.parameters$Slope_)
g3&lt;-mean.c.mdls$weighted_mean
g3.x&lt;-as.numeric(rownames(g3))
g3.y&lt;-as.numeric(colnames(g3))


#library(fields)
#plot(c(10,2000),c(15,45),type= "n", axes = FALSE,
#     xlab = "Irradiance (mmol/m2/s - Logarithmic scale)",
#     ylab = "Temperature (deg C)",log = "x")
#rect(min(g3.x),min(g3.y),max(g3.x),max(g3.y), col="black", border=NA)
#image.plot(g3.x,g3.y,g3, horizontal = FALSE,
#           col=designer.colors(256, c("blue","white","red")),
#           add = TRUE)
#axis(1) ; axis(2)

closeAllConnections()



</code></pre>

<hr>
<h2 id='spicefp'>spicefp</h2><span id='topic+spicefp'></span>

<h3>Description</h3>

<p>This function is used to implement the spiceFP approach. This approach
transforms 2 (by default) or 3 functional predictors into candidate explonatory matrices in order to
identify joint classes of influence. It can take functional predictors and
partitioning functions as inputs in order to create candidate matrices to be
evaluated. The user can choose among the existing partitioning functions (as logbreaks) or provide
his own partitioning functions specific to the functional predictors under consideration. The user
can also directly provide candidate matrices already constructed as desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spicefp(
  y,
  fp1,
  fp2,
  fp3 = NULL,
  fun1,
  fun2,
  fun3 = NULL,
  parlists,
  xcentering = TRUE,
  xscaling = FALSE,
  candmatrices = NULL,
  K = 2,
  criterion = "AIC_",
  penratios = c(1/10, 1/5, 1/2, 1, 2, 5, 10),
  nknots = 50,
  appropriate.df = NULL,
  penfun = NULL,
  dim.finemesh = c(1000, 1000),
  file_name = paste0("parametertable", 1:2),
  ncores = parallel::detectCores() - 1,
  write.external.file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spicefp_+3A_y">y</code></td>
<td>
<p>a numerical vector. Contains the dependent variable. This vector will
be used as response variable in the construction of models involving each
candidate matrix.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_fp1">fp1</code></td>
<td>
<p>a numerical matrix with in columns observations of one statistical
individual to partition. Each column corresponds to the functional
predictor observation for one statistical individual. The order of the
statistical individuals is the same as in fp2. It is assumed that no
data are missing and that all functional predictors are observed on an equidistant (time) scale.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_fp2">fp2</code></td>
<td>
<p>a numerical matrix with the same number of columns and rows as fp1.
Columns are also observations.
The order of the statistical individuals is the same as in fp1.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_fp3">fp3</code></td>
<td>
<p>NULL by default. A numerical matrix with the same number of columns and
rows as fp1 and fp2.
The order of the statistical individuals is the same as in fp1 and fp2.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_fun1">fun1</code></td>
<td>
<p>a function object with 2 arguments. First argument is fp1 and
the second is a list of parameters that will help to partition fp1, such as
the number of class intervals, etc. For example using the logbreaks function,
the list of parameters is equivalent to list(alpha, J). All the arguments
to be varied for the creation of different candidate matrices must
be stored in the parameter list. The other arguments must be set by default.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_fun2">fun2</code></td>
<td>
<p>a function object with 2 arguments. First argument is fp2 and the
second is a list of parameters.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_fun3">fun3</code></td>
<td>
<p>NULL by default. Same as fun1 and fun2, a function with 2
arguments fp3 and a list of parameters.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_parlists">parlists</code></td>
<td>
<p>a list of 2 elements when fp3 and fun3 are equal to NULL or of 3
elements when fp3 and fun3 are provided.
All the elements of parlists are lists that have the same length. Each list
contains all the lists of parameters that have to be used to create different
candidates. The first element of parlists concerns the first functional
predictor fp1, the second element is relative to fp2 and the third to fp3.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_xcentering">xcentering</code></td>
<td>
<p>TRUE by default. Defined whether or not the variables in
the new candidate matrices should be centered.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_xscaling">xscaling</code></td>
<td>
<p>FALSE by default. Defined whether or not the variables in
the candidate matrices should be scaled.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_candmatrices">candmatrices</code></td>
<td>
<p>NULL by default. List. Output of the &quot;candidates&quot;
function. The spiceFP dimension is its first element. The second contains
many lists of one candidate matrix and related vector with index and numbers
of class intervals used per predictor. The other elements of the lists are
the inputs of &quot;candidates&quot; function. If the user does not need the
&quot;candidates&quot; function for the creation of candmatrices, it is possible to
build a list while making sure that it respects the same structure as well as
the names of the outputs of the &quot;candidates&quot; function. In this case, only the
first two elements of the list are essential: spicefp.dimension and
candidates. The remaining elements can be NULL.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_k">K</code></td>
<td>
<p>number of iterations of the spiceFP approach. Equal to 2 by default.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_criterion">criterion</code></td>
<td>
<p>character. One of &quot;AIC_&quot;, &quot;BIC_&quot;, &quot;Cp_&quot;. The
criterion to be used in each iteration in order to identify the best
candidate matrix and to estimate the regulation parameters. This criterion
is used to perform model selection as well as variable selection.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_penratios">penratios</code></td>
<td>
<p>a numeric vector with values greater than or equal to 0. It
represents the ratio between the regularization parameters of parsimony and
fusion. When penratios=0, it corresponds to the pure fusion. The higher its
value, the more parsimonious the model is.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_nknots">nknots</code></td>
<td>
<p>integer. For one value in penratios vector, it represents the
number of models that will be constructed for each candidate matrix. It is
the argument &quot;nlam&quot; of <code><a href="genlasso.html#topic+coef.genlasso">coef.genlasso</a></code>
function.
This argument can be also NULL. In this case, the argument appropriate.df
must be provided.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_appropriate.df">appropriate.df</code></td>
<td>
<p>(appropriate degree of freedom) NULL by default. When used, 
nknots must be NULL. It is
the argument &quot;df&quot; of <code><a href="genlasso.html#topic+coef.genlasso">coef.genlasso</a></code>
function. When the user has a prior idea of the number of zones of influence that the
solution could contain, it is advisable to provide appropriate.df,
a vector of appropriate degrees of freedom. 
appropriate.df is a numerical vector with values greater than or equal to 1.
The degree of freedom of generalized fused Lasso models is equal to the number of
connected components. A connected component gives information on a group of
non-zero coefficients sharing the same value and connected by a contiguity
matrix. More simply, it can be interpreted as a group of coefficients that
have a unique influence.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_penfun">penfun</code></td>
<td>
<p>function with 2 arguments (dim1, dim2) when dealing with 2
dimensional spiceFP, or with 3 arguments (dim1, dim2, dim3) when dealing with
3 dimensional spiceFP. The argument order in the penalty function is
associated with the order of numbers of class intervals used per predictor
in the second element of candmatrices argument. NULL by default.
When penfun=NULL, getD2dSparse of genlasso or getD3dSparse is used according
to the dimension of spiceFP.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_dim.finemesh">dim.finemesh</code></td>
<td>
<p>numeric vector of length 2 or 3. This vector informs
about the dimension of the fine-mesh arrays (or matrices) that will be used
for the visualization of the sum of the coefficients selected at different
iterations.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_file_name">file_name</code></td>
<td>
<p>character vector. Of length K, it contains the list of
names that will be used to name the files containing informations on the
candidate matrix models</p>
</td></tr>
<tr><td><code id="spicefp_+3A_ncores">ncores</code></td>
<td>
<p>numbers of cores that will be used for parallel computation. By default, it is equal
to detectCores()-1.</p>
</td></tr>
<tr><td><code id="spicefp_+3A_write.external.file">write.external.file</code></td>
<td>
<p>logical. indicates whether the result table related
to each iteration should be written as a file (txt) in your working directory.
It is recommended to use write.external.file=TRUE when evaluating a large
number of candidate matrices (more than 100) in order to keep memory available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three main steps are involved to implement spiceFP: transformation
of functional predictors, creation of a graph of contiguity constraints and
identification of the best class intervals and related regression
coefficients.
</p>


<h3>Value</h3>

<p>Returns a list with:
</p>

<dl>
<dt>Candidate.Matrices</dt><dd><p>a list with candidate matrices and their
characteristics. same as candmatrices if it has been provided.</p>
</dd>
<dt>Evaluations</dt><dd><p>List of length less than or equal to K. Each element of
the list contains information about an iteration. Contains the results
related to the evaluation of the candidate matrices. These include the name
of the file where the model information is stored, the best candidate matrix
and related coefficients, the partition vector that indexes it, the <code class="reqn">X \beta</code>
estimation, the residuals, etc.</p>
</dd>
<dt>coef.NA</dt><dd><p>List of length less than or equal to K. For each iteration,
it contains the coefficient vector where the coefficient value of
never-observed joint modalities is NA</p>
</dd>
<dt>coef.NA.finemeshed</dt><dd><p>List of length less than or equal to K. For each
iteration, the coefficient vector is transformed into fine-mesh array or
matrix allowing arithmetic operations to be performed between coefficients
coming from different partitions</p>
</dd>
<dt>spicefp.coef</dt><dd><p>fine-mesh array or matrix. Sum of the coefficients
selected at all iterations</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
##linbreaks: a function allowing to obtain breaks linearly
linbreaks&lt;-function(x,n){
    sort(round(seq(trunc(min(x)),
                ceiling(max(x)+0.001),
                length.out =unlist(n)+1),
            1)
        )
}

# In this example, we will evaluate 2 candidates with 14 temperature
# classes and 15 irradiance classes. The irradiance breaks are obtained
# according to a log scale (logbreaks function) with different alpha
# parameters for each candidate (0.005, 0.01).
## Data and inputs
tpr.nclass=14
irdc.nclass=15
irdc.alpha=c(0.005, 0.01)
p2&lt;-expand.grid(tpr.nclass, irdc.alpha, irdc.nclass)
parlist.tpr&lt;-split(p2[,1], seq(nrow(p2)))
parlist.irdc&lt;-split(p2[,2:3], seq(nrow(p2)))
parlist.irdc&lt;-lapply(
   parlist.irdc,function(x){
   list(x[[1]],x[[2]])}
)
m.irdc &lt;- as.matrix(Irradiance[,-c(1)])
m.tpr &lt;- as.matrix(Temperature[,-c(1)])

# For the constructed models, only two regularization parameter ratios
# penratios=c(1/25,5) are used. In a real case, we will have to evaluate
# more candidates and regularization parameters ratio.
start_time_sp &lt;- Sys.time()
ex_sp&lt;-spicefp(y=FerariIndex_Difference$fi_dif,
              fp1=m.irdc,
              fp2=m.tpr,
              fun1=logbreaks,
              fun2=linbreaks,
              parlists=list(parlist.irdc,
                            parlist.tpr),
              penratios=c(1/25,5),
              appropriate.df=NULL,
              nknots = 100,
              ncores =2,
              write.external.file=FALSE)

duration_sp &lt;- Sys.time() - start_time_sp
# View(ex_sp$Evaluations[[1]]$Evaluation.results$evaluation.result)
# View(ex_sp$Evaluations[[2]]$Evaluation.results$evaluation.result)
# Visualization of the coefficients
g&lt;-ex_sp$spicefp.coef
g.x&lt;-as.numeric(rownames(g))
g.y&lt;-as.numeric(colnames(g))

#library(fields)
#plot(c(10,2000),c(15,45),type= "n", axes = FALSE,
#     xlab = "Irradiance (mmol/m²/s - Logarithmic scale)",
#     ylab = "Temperature (°C)",log = "x")
#rect(min(g.x),min(g.y),max(g.x),max(g.y), col="black", border=NA)
#image.plot(g.x,g.y,g, horizontal = FALSE,
#           col=designer.colors(256, c("blue","white","red")),
#           add = TRUE)
#axis(1) ; axis(2)

closeAllConnections()



</code></pre>

<hr>
<h2 id='Temperature'>Temperature measurements of vine dataset</h2><span id='topic+Temperature'></span>

<h3>Description</h3>

<p>Data were collected during an experiment conducted on a vineyard
of the INRAE/Institut Agro campus at Montpellier in 2014 (Syrah vines). The objective
of the experiment was to study the influence of the micro-climate (temperature and
irradiance) at the grape level on the anthocyanin contents of the berries indicated by
the Ferari index. This dataset is related to temperature measurements in the morning
(sunrise to twelve am) between July 24th, 2014 at 09:00 am and August 01, 2014 at
09:00 am. These observations are made at the same time (every 12 minutes) as the
irradiance observations. The individuals are in columns while the observation times
are in rows. The same
individuals are also present in the Irradiance and FerariIndex_Difference datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Temperature
</code></pre>


<h3>Format</h3>

<p>A data frame (of one functionnal variable) with 127 rows (observation times)
and 33 columns: the 1st one is a character vector which corresponds to date-time 
in format &quot;yyyy-mm-dd hh:mm:ss&quot;, the others are numeric vectors made of the 
observations of temperature measured in degree celsius on each of the 32 statistical individuals 
Indiv1,...,Indiv32.
</p>


<h3>Source</h3>

<p>These data were acquired during the Innovine project, funded by the Seventh
Framework Programme of the European Community (FP7/2007-2013), under Grant Agreement
No. FP7-311775.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
