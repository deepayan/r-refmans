<!DOCTYPE html><html><head><title>Help for package cointmonitoR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cointmonitoR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cointmonitoR-package'><p>The cointmonitoR package</p></a></li>
<li><a href='#monitorCointegration'><p>Procedure for Monitoring Level and Trend Cointegration</p></a></li>
<li><a href='#monitorStationarity'><p>Procedure for Monitoring Level and Trend Stationarity</p></a></li>
<li><a href='#plot.cointmonitoR'><p>Plot Method for Monitoring Procedures.</p></a></li>
<li><a href='#print.cointmonitoR'><p>Print Method for Monitoring Procedures.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Consistent Monitoring of Stationarity and Cointegrating
Relationships</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-14</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>We propose a consistent monitoring procedure to detect a
    structural change from a cointegrating relationship to a spurious
    relationship. The procedure is based on residuals from modified least
    squares estimation, using either Fully Modified, Dynamic or Integrated
    Modified OLS. It is inspired by Chu et al. (1996) &lt;<a href="https://doi.org/10.2307%2F2171955">doi:10.2307/2171955</a>&gt; in
    that it is based on parameter estimation on a pre-break "calibration" period
    only, rather than being based on sequential estimation over the full sample.
    See the discussion paper &lt;<a href="https://doi.org/10.2139%2Fssrn.2624657">doi:10.2139/ssrn.2624657</a>&gt; for further information.
    This package provides the monitoring procedures for both the cointegration
    and the stationarity case (while the latter is just a special case of the
    former one) as well as printing and plotting methods for a clear
    presentation of the results.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aschersleben/cointmonitoR">https://github.com/aschersleben/cointmonitoR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aschersleben/cointmonitoR/issues">https://github.com/aschersleben/cointmonitoR/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>cointReg (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, matrixStats (&ge; 0.14.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-06-14 13:52:21 UTC; Aschersleben</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp Aschersleben [aut, cre],
  Martin Wagner [aut] (Author of underlying paper.),
  Dominik Wied [aut] (Author of underlying paper.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philipp Aschersleben &lt;aschersleben@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-06-14 20:34:46</td>
</tr>
</table>
<hr>
<h2 id='cointmonitoR-package'>The cointmonitoR package</h2><span id='topic+cointmonitoR-package'></span>

<h3>Description</h3>

<p>Consistent Monitoring of Stationarity and Cointegrating Relationships
</p>


<h3>Details</h3>

<p>See the vignette:<br />
<code>vignette("cointmonitoR")</code>
</p>
<p>See the DESCRIPTION:<br />
<code>help(package = cointmonitoR)</code>
</p>
<p>See the README:<br />
<a href="https://github.com/aschersleben/cointmonitoR/blob/master/README.md">https://github.com/aschersleben/cointmonitoR/blob/master/README.md</a>
</p>
<p>Open the package documentation page:<br />
<code>package?cointmonitoR</code>
</p>
<p>Further information and bug reporting:<br />
<a href="https://github.com/aschersleben/cointmonitoR">https://github.com/aschersleben/cointmonitoR</a>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code><a href="#topic+monitorCointegration">monitorCointegration</a></code><br />
This procedure is able to monitor a cointegration model for level or
trend cointegration and returns the corresponding break point, if
available. It is based on parameter estimation on a pre-break
&quot;calibration&quot; period at the beginning of the sample that is known or
assumed to be free of structural change.
</p>
</li>
<li> <p><code><a href="#topic+monitorStationarity">monitorStationarity</a></code><br />
This procedure is a special case of <code>monitorCointegration</code>,
since it's able to monitor a one-dimensional vector for level or
trend stationarity.
</p>
</li>
<li> <p><code><a href="#topic+print.cointmonitoR">print</a></code><br />
Print clear results.
</p>
</li>
<li> <p><code><a href="#topic+plot.cointmonitoR">plot</a></code><br />
Plot the test statitics and the values/residuals of a
<code>cointmonitoR</code> model.
</p>
</li></ul>



<h3>Dependencies</h3>

<p>This package mainly depends on our
<a href="https://cran.r-project.org/package=cointReg"><code>cointReg</code></a> package.
</p>

<hr>
<h2 id='monitorCointegration'>Procedure for Monitoring Level and Trend Cointegration</h2><span id='topic+monitorCointegration'></span>

<h3>Description</h3>

<p>This procedure is able to monitor a cointegration model for level or
trend cointegration and returns the corresponding break point, if available.
It is based on parameter estimation on a pre-break &quot;calibration&quot; period
at the beginning of the sample that is known or assumed to be free of
structural change and can be specified exactly via the <code>m</code> argument
(see Details for further information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monitorCointegration(x, y, m = 0.25, model = c("FM", "D", "IM"),
  trend = FALSE, kernel = c("ba", "pa", "qs", "tr"), bandwidth = c("and",
  "nw"), D.options = NULL, signif.level = 0.05, return.stats = TRUE,
  return.input = TRUE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monitorCointegration_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
Data on which to apply the monitoring procedure (RHS).</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
Data on which to apply the monitoring procedure (LHS).
Has to be one-dimensional. If <code>matrix</code>, it may
have only one row or column, if <code>data.frame</code> just one column.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_m">m</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Length of calibration period as fraction of the data's length
(between 0.1 and 0.9) or as number of observations (see Details).</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_model">model</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The model to be used for modified OLS calculations. Should be one of
FM-OLS (<code>"FM"</code>), D-OLS (<code>"D"</code>) or IM-OLS (<code>"IM"</code>).</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_trend">trend</code></td>
<td>
<p>[<code>logical</code>]<br />
Should an intercept and a linear trend be included?
If <code>FALSE</code> (default), only an intercept is included.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for calculating the long-run variance.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>character(1)</code> | <code>numeric(1)</code>]<br />
The bandwidth to use for calculating the long-run variance.
Default is Andrews (1991) (<code>"and"</code>), an alternative is Newey West
(1994) (<code>"nw"</code>). You can also set the bandwidth manually.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_d.options">D.options</code></td>
<td>
<p>[<code>list</code> | <code>NULL</code>]<br />
Options for the D-OLS calculations. A list with elements <code>n.lead</code>,
<code>n.lag</code>, <code>kmax</code> and <code>info.crit</code> &ndash; or <code>NULL</code> (then
default arguments are the same as in <code><a href="cointReg.html#topic+cointRegD">cointRegD</a></code>.
See that help page for further information.)
Missing list elements will be replaced automatically.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_signif.level">signif.level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Level of significance (between 0.01 and 0.1).
Detection time will be calculated only if the estimated
p-value is smaller than <code>signif.level</code>. Default is 0.05.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_return.stats">return.stats</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to return all test statistics. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_return.input">return.input</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to return the input data, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="cointReg.html#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="monitorCointegration_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="cointReg.html#topic+getBandwidthNW">getBandwidthNW</a></code> (<code>inter</code>,
<code>weights</code>), if <code>bandwidth = "nw"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calibration period can be set by setting the argument <code>m</code> to the
number of the last observation, that should be inside this period.
The corresponding fraction of the data's length will be calculated
automatically. Alternatively you can set <code>m</code> directly to the fitting
fraction value, but you should pay attention to the fact, that the
calibration period may become smaller than intended: The last observation
is calculated as <code>floor(m * N)</code> (with <code>N</code> the length of x).
</p>
<p>The kernel that is used for calculating the long-run variance can be
one of the following:
</p>

<ul>
<li> <p><code>"ba"</code>: Bartlett kernel
</p>
</li>
<li> <p><code>"pa"</code>: Parzen kernel
</p>
</li>
<li> <p><code>"qs"</code>: Quadratic Spectral kernel
</p>
</li>
<li> <p><code>"tr"</code>: Truncated kernel
</p>
</li></ul>



<h3>Value</h3>

<p>[<code>cointmonitoR</code>] object with components:
</p>

<dl>
<dt><code>Hsm</code> [<code>numeric(1)</code>]</dt><dd>
<p>value of the test statistic</p>
</dd>
<dt><code>time</code> [<code>numeric(1)</code>]</dt><dd>
<p>detected time of structural break</p>
</dd>
<dt><code>p.value</code> [<code>numeric(1)</code>]</dt><dd>
<p>estimated p-value of the test (between 0.01 and 0.1)</p>
</dd>
<dt><code>cv</code> [<code>numeric(1)</code>]</dt><dd>
<p>critical value of the test</p>
</dd>
<dt><code>sig</code> [<code>numeric(1)</code>]</dt><dd>
<p>significance level used for the test</p>
</dd>
<dt><code>residuals</code> [<code>numeric</code>]</dt><dd>
<p>residuals of the modified OLS model to be used for calculating the
test statistics</p>
</dd>
<dt><code>model</code> [<code>character(1)</code>]</dt><dd>
<p><code>cointOLS</code> model (&quot;FM&quot;, &quot;D&quot;, or &quot;IM&quot;)</p>
</dd>
<dt><code>trend</code> [<code>character(1)</code>]</dt><dd>
<p>trend model (&quot;level&quot; or &quot;trend&quot;)</p>
</dd>
<dt><code>name</code> [<code>character(1)</code>]</dt><dd>
<p>name(s) of data</p>
</dd>
<dt><code>m</code> [<code>list(2)</code>]</dt><dd>
<p>list with components:<br />
<code>$m.frac</code> [<code>numeric(1)</code>]: calibration period (fraction)<br />
<code>$m.index</code> [<code>numeric(1)</code>]: calibration period (length)</p>
</dd>
<dt><code>kernel</code> [<code>character(1)</code>]</dt><dd>
<p>kernel function</p>
</dd>
<dt><code>bandwidth</code> [<code>list(2)</code>]</dt><dd>
<p><code>$name</code> [<code>character(1)</code>]: bandwidth function (name)<br />
<code>$number</code> [<code>numeric(1)</code>]: bandwidth</p>
</dd>
<dt><code>statistics</code> [<code>numeric</code>]</dt><dd>
<p>values of test statistics with the same length as data, but <code>NA</code>
during calibration period (available if <code>return.stats = TRUE</code>)</p>
</dd>
<dt><code>input</code> [<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]</dt><dd>
<p>copy of input data (available if <code>return.stats = TRUE</code>)</p>
</dd>
<dt><code>D.options</code> [<code>list</code>]</dt><dd>
<p>information about further parameters (available if <code>model = "D"</code>)</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Wagner, M. and D. Wied (2015): &quot;Monitoring Stationarity and
Cointegration,&quot; <em>Discussion Paper</em>,
<a href="http://dx.doi.org/10.2139/ssrn.2624657">DOI:10.2139/ssrn.2624657</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other cointmonitoR: <code><a href="#topic+monitorStationarity">monitorStationarity</a></code>,
<code><a href="#topic+plot.cointmonitoR">plot.cointmonitoR</a></code>,
<code><a href="#topic+print.cointmonitoR">print.cointmonitoR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x = data.frame(x1 = cumsum(rnorm(200)), x2 = cumsum(rnorm(200)))
eps1 = rnorm(200, sd = 2)
eps2 = c(eps1[1:100], cumsum(eps1[101:200]))

y = x$x1 - x$x2 + 10 + eps1
monitorCointegration(x = x, y = y, m = 0.5, model = "FM")

y2 = y + seq(1, 30, length = 200)
monitorCointegration(x = x, y = y2, m = 0.5, model = "FM")
monitorCointegration(x = x, y = y2, m = 0.5, trend = TRUE, model = "FM")

y3 = x$x1 - x$x2 + 10 + eps2
monitorCointegration(x = x, y = y3, m = 0.5, model = "FM")
monitorCointegration(x = x, y = y3, m = 0.5, model = "D")
monitorCointegration(x = x, y = y3, m = 0.5, model = "IM")

</code></pre>

<hr>
<h2 id='monitorStationarity'>Procedure for Monitoring Level and Trend Stationarity</h2><span id='topic+monitorStationarity'></span>

<h3>Description</h3>

<p>This procedure is able to monitor a one-dimensional vector for level or
trend stationarity and returns the corresponding break point, if available.
It is based on parameter estimation on a pre-break &quot;calibration&quot; period
at the beginning of the sample that is known or assumed to be free of
structural change and can be specified exactly via the <code>m</code> argument
(see Details for further information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monitorStationarity(x, m = 0.25, trend = FALSE, kernel = c("ba", "pa",
  "qs", "tr"), bandwidth = c("and", "nw"), signif.level = 0.05,
  return.stats = TRUE, return.input = TRUE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monitorStationarity_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
Data on which to apply the monitoring procedure. If <code>matrix</code>, it may
have only one row or column, if <code>data.frame</code> just one column.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_m">m</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Length of calibration period as fraction of the data's length
(between 0.1 and 0.9) or as number of observations (see Details).</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_trend">trend</code></td>
<td>
<p>[<code>logical</code>]<br />
Should an intercept and a linear trend be included?
If <code>FALSE</code> (default), only an intercept is included.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for calculating the long-run variance.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>character(1)</code> | <code>numeric(1)</code>]<br />
The bandwidth to use for calculating the long-run variance.
Default is Andrews (1991) (<code>"and"</code>), an alternative is Newey West
(1994) (<code>"nw"</code>). You can also set the bandwidth manually.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_signif.level">signif.level</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Level of significance (between 0.01 and 0.1).
Detection time will be calculated only if the estimated
p-value is smaller than <code>signif.level</code>. Default is 0.05.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_return.stats">return.stats</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to return all test statistics. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_return.input">return.input</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to return the input data, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="cointReg.html#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="monitorStationarity_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="cointReg.html#topic+getBandwidthNW">getBandwidthNW</a></code> (<code>inter</code>,
<code>weights</code>), if <code>bandwidth = "nw"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calibration period can be specified by setting the argument <code>m</code>
to the number of its last observation.
The corresponding fraction of the data's length will be calculated
automatically. Alternatively you can set <code>m</code> directly to the fitting
fraction value. Attention: The calibration period may become smaller than
intended: The last observation is calculated as <code>floor(m * N)</code>
(with <code>N</code> = length of <code>x</code>).
</p>
<p>The kernel that is used for calculating the long-run variance can be
one of the following:
</p>

<ul>
<li> <p><code>"ba"</code>: Bartlett kernel
</p>
</li>
<li> <p><code>"pa"</code>: Parzen kernel
</p>
</li>
<li> <p><code>"qs"</code>: Quadratic Spectral kernel
</p>
</li>
<li> <p><code>"tr"</code>: Truncated kernel
</p>
</li></ul>



<h3>Value</h3>

<p>[<code>cointmonitoR</code>] object with components:
</p>

<dl>
<dt><code>Hsm</code> [<code>numeric(1)</code>]</dt><dd>
<p>value of the test statistic</p>
</dd>
<dt><code>time</code> [<code>numeric(1)</code>]</dt><dd>
<p>detected time of structural break</p>
</dd>
<dt><code>p.value</code> [<code>numeric(1)</code>]</dt><dd>
<p>estimated p-value of the test (between 0.01 and 0.1)</p>
</dd>
<dt><code>cv</code> [<code>numeric(1)</code>]</dt><dd>
<p>critical value of the test</p>
</dd>
<dt><code>sig</code> [<code>numeric(1)</code>]</dt><dd>
<p>significance level used for the test</p>
</dd>
<dt><code>trend</code> [<code>character(1)</code>]</dt><dd>
<p>trend model (&quot;level&quot; or &quot;trend&quot;)</p>
</dd>
<dt><code>name</code> [<code>character(1)</code>]</dt><dd>
<p>name(s) of data</p>
</dd>
<dt><code>m</code> [<code>list(2)</code>]</dt><dd>
<p>list with components:<br />
<code>$m.frac</code> [<code>numeric(1)</code>]: calibration period (fraction)<br />
<code>$m.index</code> [<code>numeric(1)</code>]: calibration period (length)</p>
</dd>
<dt><code>kernel</code> [<code>character(1)</code>]</dt><dd>
<p>kernel function</p>
</dd>
<dt><code>bandwidth</code> [<code>list(2)</code>]</dt><dd>
<p><code>$name</code> [<code>character(1)</code>]: bandwidth function (name)<br />
<code>$number</code> [<code>numeric(1)</code>]: bandwidth</p>
</dd>
<dt><code>statistics</code> [<code>numeric</code>]</dt><dd>
<p>values of test statistics with the same length as data, but <code>NA</code>
during calibration period (available if <code>return.stats = TRUE</code>)</p>
</dd>
<dt><code>input</code> [<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]</dt><dd>
<p>copy of input data (available if <code>return.stats = TRUE</code>)</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Wagner, M. and D. Wied (2015): &quot;Monitoring Stationarity and
Cointegration,&quot; <em>Discussion Paper</em>,
<a href="http://dx.doi.org/10.2139/ssrn.2624657">DOI:10.2139/ssrn.2624657</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other cointmonitoR: <code><a href="#topic+monitorCointegration">monitorCointegration</a></code>,
<code><a href="#topic+plot.cointmonitoR">plot.cointmonitoR</a></code>,
<code><a href="#topic+print.cointmonitoR">print.cointmonitoR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x &lt;- rnorm(200)
x2 &lt;- c(x[1:100], cumsum(x[101:200]) / 2)

# Specify the calibration period
# as fraction of the total length of x:
monitorStationarity(x, m = 0.25)
monitorStationarity(x2, m = 0.465)

# Specify the calibration period
# by setting its last observation exactly:
monitorStationarity(x, m = 50)
monitorStationarity(x2, m = 93)

</code></pre>

<hr>
<h2 id='plot.cointmonitoR'>Plot Method for Monitoring Procedures.</h2><span id='topic+plot.cointmonitoR'></span>

<h3>Description</h3>

<p>Plotting objects of class <code>"cointmonitoR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cointmonitoR'
plot(x, what = "test", type, main, xlab, ylab,
  axes = TRUE, legend = TRUE, main.val, xlab.val, ylab.val, lines = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cointmonitoR_+3A_x">x</code></td>
<td>
<p>[<code>cointmonitoR</code>]<br />
Object of class <code>"cointmonitoR"</code>, i.e. the result of
<code><a href="#topic+monitorStationarity">monitorStationarity</a></code> or
<code><a href="#topic+monitorCointegration">monitorCointegration</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_what">what</code></td>
<td>
<p>[<code>character</code>]<br />
Whether to plot test statistics (<code>"test"</code>) (default) or the
values/residuals of the tested time series (<code>"values"</code> or
<code>"residuals"</code>) or <code>"both"</code>. Works only,
if <code>return.stats = TRUE</code> in the called function that to get <code>x</code>
(default setting).</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_type">type</code></td>
<td>
<p>[<code>character</code>]<br />
Plot type (from <code><a href="base.html#topic+plot">plot</a></code>). Default is <code>"l"</code>.</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_main">main</code>, <code id="plot.cointmonitoR_+3A_xlab">xlab</code>, <code id="plot.cointmonitoR_+3A_ylab">ylab</code></td>
<td>
<p>[<code>character</code>]<br />
Title and axis titles (from <code><a href="base.html#topic+plot">plot</a></code>). Default values will be
generated from the contents of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_axes">axes</code>, <code id="plot.cointmonitoR_+3A_legend">legend</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to add axes (from <code><a href="base.html#topic+plot">plot</a></code>) and a legend to the plot.</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_main.val">main.val</code>, <code id="plot.cointmonitoR_+3A_xlab.val">xlab.val</code>, <code id="plot.cointmonitoR_+3A_ylab.val">ylab.val</code></td>
<td>
<p>[<code>character</code>]<br />
Title and axis titles (from <code><a href="base.html#topic+plot">plot</a></code>) for the second plot,
if generating both plots in one step (see argument <code>what</code>).
Default values will be generated from the contents of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_lines">lines</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to add lines and annotations to the plot. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.cointmonitoR_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br />
Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cointmonitoR: <code><a href="#topic+monitorCointegration">monitorCointegration</a></code>,
<code><a href="#topic+monitorStationarity">monitorStationarity</a></code>,
<code><a href="#topic+print.cointmonitoR">print.cointmonitoR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Monitoring stationarity (no break):
set.seed(1909)
x = rnorm(200)
test = monitorStationarity(x, m = 0.5)
plot(test)

oldpar = par(mfrow = c(2, 1), mar = c(4, 4, 1, 1))
plot(test, what = "both", legend = FALSE, main = "", main.val = "")
par(oldpar)


### Monitoring stationarity (break):
x = c(x[1:100], cumsum(rnorm(100, sd = 0.5)) + x[101:200])
test2 = monitorStationarity(x, m = 0.5)
plot(test2)

oldpar = par(mfrow = c(2, 1), mar = c(4, 4, 1, 1))
plot(test2, what = "both", legend = FALSE, main = "", main.val = "")
par(oldpar)


### Monitoring cointegration (no break):
set.seed(42)
x = data.frame(x1 = cumsum(rnorm(200)), x2 = cumsum(rnorm(200)))
eps1 = rnorm(200, sd = 2)
y = x$x1 - x$x2 + 10 + eps1
test3 = monitorCointegration(x = x, y = y, m = 0.5, model = "FM")
plot(test3)

oldpar = par(mfrow = c(2, 1), mar = c(4, 4, 1, 1))
plot(test3, what = "both", legend = FALSE, main = "", main.val = "")
par(oldpar)


### Monitoring cointegration (break):
eps2 = c(eps1[1:100], cumsum(eps1[101:200]))
y = x$x1 - x$x2 + 10 + eps2
test4 = monitorCointegration(x = x, y = y, m = 0.5, model = "FM")
plot(test4)

oldpar = par(mfrow = c(2, 1), mar = c(4, 4, 1, 1))
plot(test4, what = "both", legend = FALSE, main = "", main.val = "")
par(oldpar)

</code></pre>

<hr>
<h2 id='print.cointmonitoR'>Print Method for Monitoring Procedures.</h2><span id='topic+print.cointmonitoR'></span>

<h3>Description</h3>

<p>Printing objects of class <code>"cointmonitoR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cointmonitoR'
print(x, ..., digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cointmonitoR_+3A_x">x</code></td>
<td>
<p>[<code>cointmonitoR</code>]<br />
Object of class <code>"cointmonitoR"</code>, i.e. the result of
<code>monitorStationarity()</code> or <code>monitorCointegration()</code>.</p>
</td></tr>
<tr><td><code id="print.cointmonitoR_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="print.cointmonitoR_+3A_digits">digits</code></td>
<td>
<p>[<code>numeric</code>]<br />
Number of significant digits to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The invisible <code>x</code> object.
</p>


<h3>See Also</h3>

<p>Other cointmonitoR: <code><a href="#topic+monitorCointegration">monitorCointegration</a></code>,
<code><a href="#topic+monitorStationarity">monitorStationarity</a></code>,
<code><a href="#topic+plot.cointmonitoR">plot.cointmonitoR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
test = monitorStationarity(rnorm(100), m = 0.5)
print(test)

x = data.frame(x1 = cumsum(rnorm(200)), x2 = cumsum(rnorm(200)))
eps1 = rnorm(200, sd = 2)
eps2 = c(eps1[1:100], cumsum(eps1[101:200]))
y1 = x$x1 - x$x2 + 10 + eps1
y2 = x$x1 - x$x2 + 10 + eps2
test1 = monitorCointegration(x = x, y = y1, m = 0.5, model = "FM")
print(test1)
test2 = monitorCointegration(x = x, y = y2, m = 0.5, model = "FM")
print(test2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
