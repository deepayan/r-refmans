<!DOCTYPE html><html lang="en"><head><title>Help for package HSAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HSAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Beijingdistricts'><p>Boundaries of districts in Beijing</p></a></li>
<li><a href='#depmunic'><p>Municipality departments of Athens</p></a></li>
<li><a href='#hsar'><p>Hierarchical SAR model estimation</p></a></li>
<li><a href='#land'><p>The spatial locations of the Beijing land price data</p></a></li>
<li><a href='#landprice'><p>Leased residential land parcels, from 2003 to 2009 in Beijing, China</p></a></li>
<li><a href='#properties'><p>Dataset of properties in the municipality of Athens</p></a></li>
<li><a href='#sar'><p>SAR model estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Hierarchical Spatial Autoregressive Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A Hierarchical Spatial Autoregressive Model (HSAR), based on a Bayesian Markov Chain Monte Carlo (MCMC) algorithm (Dong and Harris (2014) &lt;<a href="https://doi.org/10.1111%2Fgean.12049">doi:10.1111/gean.12049</a>&gt;). The creation of this package was supported by the Economic and Social Research Council (ESRC) through the Applied Quantitative Methods Network: Phase II, grant number ES/K006460/1.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://spatlyu.github.io/HSAR/">https://spatlyu.github.io/HSAR/</a>, <a href="https://github.com/spatlyu/HSAR">https://github.com/spatlyu/HSAR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatlyu/HSAR/issues">https://github.com/spatlyu/HSAR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spdep, spatialreg, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, Matrix, RColorBrewer, Rcpp, RcppArmadillo, rmarkdown,
sdsfun, sf, tidyverse</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-20 02:26:53 UTC; dell</td>
</tr>
<tr>
<td>Author:</td>
<td>Guanpeng Dong <a href="https://orcid.org/0000-0003-3420-9622"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Wenbo Lv <a href="https://orcid.org/0009-0002-6003-3800"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Richard Harris [aut],
  Angelos Mimis [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenbo Lv &lt;lyu.geosocial@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-23 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Beijingdistricts'>Boundaries of districts in Beijing</h2><span id='topic+Beijingdistricts'></span>

<h3>Description</h3>

<p>Boundaries of districts in Beijing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Beijingdistricts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 111 rows and 2 columns.
</p>

<hr>
<h2 id='depmunic'>Municipality departments of Athens</h2><span id='topic+depmunic'></span>

<h3>Description</h3>

<p>Municipality departments of Athens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depmunic
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 7 rows and 8 columns.
</p>


<h3>Details</h3>

<p>An sf object of 7 polygons with the following 7 variables:
</p>

<dl>
<dt>num_dep</dt><dd><p>An unique identifier for each municipality department.</p>
</dd>
<dt>airbnb</dt><dd><p>The number of airbnb properties in 2017</p>
</dd>
<dt>museums</dt><dd><p>The number of museums</p>
</dd>
<dt>population</dt><dd><p>The population recorded in census at 2011.</p>
</dd>
<dt>pop_rest</dt><dd><p>The number of citizens that the origin is a non european country.</p>
</dd>
<dt>greensp</dt><dd><p>The area of green spaces (unit: square meters).</p>
</dd>
<dt>area</dt><dd><p>The area of the polygon (unit: square kilometers). </p>
</dd>
</dl>


<hr>
<h2 id='hsar'>Hierarchical SAR model estimation</h2><span id='topic+hsar'></span>

<h3>Description</h3>

<p>The specification of a HSAR model is as follows:
</p>
<p style="text-align: center;"><code class="reqn">y_{i,j} = \rho *\mathbf{W}_i *\mathbf{y} + \mathbf{x}^\prime_{i,j} * \mathbf{\beta} +
   \mathbf{z}^\prime_j * \mathbf{\gamma} + \theta_j + \epsilon_{i,j}  </code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j = \lambda * \mathbf{M}_j * \mathbf{\theta} + \mu_j  </code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_{i,j} \sim N(0,\sigma_e^2), \hspace{2cm} \mu_j \sim N(0,\sigma_u^2)</code>
</p>

<p>where <code class="reqn">i=1,2,...,n_j</code> and <code class="reqn">j=1,2,...,J</code> are indicators of lower- and higher-level spatial units. <code class="reqn">n_j</code> is the number of lower-level units in the <code class="reqn">j-th</code> higher level unit and <code class="reqn">\sum_{j=1}^J=\mathbf{N}</code>. <code class="reqn">\mathbf{x}^\prime_{i,j}</code> and <code class="reqn">\mathbf{z}^\prime_j</code> represent vectors of lower- and higher-level independent variables. <code class="reqn">\mathbf{\beta}</code> and <code class="reqn">\mathbf{\gamma}</code> are regression coefficients to estimate. <code class="reqn">\mathbf{\theta}</code>, a <code class="reqn">N \times J</code> vector of higher-level random effects, also follows a simultaneous autoregressive process. <code class="reqn">\mathbf{W}</code> and <code class="reqn">\mathbf{M}</code> are two spatial weights matrices (or neighbourhood connection matrices) at the lower and higher levels, defining how spatial units at each level are connected. <code class="reqn">\rho</code> and <code class="reqn">\lambda</code> are two spatial autoregressive parameters measuring the strength of the dependencies/correlations at the two spatial scales.
A succinct matrix formulation of the model is,
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y} = \rho * \mathbf{W} * \mathbf{y} + \mathbf{X} * \mathbf{\beta} +
   \mathbf{Z} * \mathbf{\gamma} + \Delta * \mathbf{\theta} + \mathbf{\epsilon} </code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{\theta} = \lambda * \mathbf{M} * \mathbf{\theta} + \mathbf{\mu}</code>
</p>

<p>It is also useful to note that the HSAR model nests a standard (random intercept) multilevel model model when <code class="reqn">\rho</code> and <code class="reqn">\lambda</code> are both equal to zero and a standard spaital econometric model when <code class="reqn">\lambda</code> and <code class="reqn">\sigma^2_u</code> are both equal to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsar(
  formula,
  data = NULL,
  W = NULL,
  M = NULL,
  Delta,
  burnin = 5000,
  Nsim = 10000,
  thinning = 1,
  parameters.start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hsar_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to fit. A formula for the covariate part of the model using the syntax of the lm() function fitting standard linear regression models. Neither the response variable nor the explanatory variables are allowed to contain NA values.</p>
</td></tr>
<tr><td><code id="hsar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing variables used in the formula object.</p>
</td></tr>
<tr><td><code id="hsar_+3A_w">W</code></td>
<td>
<p>The N by N lower-level spatial weights matrix or neighbourhood matrix where N is the total number of lower-level spatial units. The formulation of W could be based on geographical distances separating units or based on geographical contiguity. To ensure the maximum value of the spatial autoregressive parameter <code class="reqn">\rho</code> less than 1,
W should be row-normalised before running the HSAR model. As in most cases, spatial weights matrix is very sparse, therefore W here should be converted to a sparse matrix before imported into the <code>hsar()</code> function to save computational burden and reduce computing time. More specifically, W should be a column-oriented numeric sparse matrices of
a <code>dgCMatrix</code> class defined in the <code>Matrix</code> package. The converion between a dense numeric matrix and a sparse numeric matrix is made quite convenient through the <code>Matrix</code>library.</p>
</td></tr>
<tr><td><code id="hsar_+3A_m">M</code></td>
<td>
<p>The J by J higher-level spatial weights matrix or neighbourhood matrix where J is the total number of higher-level spatial units. Similar with W, the formulation of M could be based on geographical distances separating units or based on geographical contiguity. To ensure the maximum value of the spatial autoregressive parameter <code class="reqn">\lambda</code>
less than 1, M is also row-normalised before running the HSAR model. As with W, M should also be a column-oriented numeric sparse matrices.</p>
</td></tr>
<tr><td><code id="hsar_+3A_delta">Delta</code></td>
<td>
<p>The N by J random effect design matrix that links the J by 1 higher-level random effect vector back to the N by 1 response variable under investigation. It is simply how lower-level units are grouped into each high-level units with columns of the matrix being each higher-level units. As with W and M, <code class="reqn">\delta</code> should also be a
column-oriented numeric sparse matrices.</p>
</td></tr>
<tr><td><code id="hsar_+3A_burnin">burnin</code></td>
<td>
<p>The number of MCMC samples to discard as the burnin period.</p>
</td></tr>
<tr><td><code id="hsar_+3A_nsim">Nsim</code></td>
<td>
<p>The total number of MCMC samples to generate.</p>
</td></tr>
<tr><td><code id="hsar_+3A_thinning">thinning</code></td>
<td>
<p>MCMC thinning factor.</p>
</td></tr>
<tr><td><code id="hsar_+3A_parameters.start">parameters.start</code></td>
<td>
<p>A list with names &quot;rho&quot;, &quot;lambda&quot;, &quot;sigma2e&quot;, &quot;sigma2u&quot; and &quot;beta&quot; corresponding to initial values for the model parameters <code class="reqn">\rho, \lambda, \sigma^2_e, \sigma^2_u</code> and the regression coefficients respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code>.
</p>

<dl>
<dt>cbetas</dt><dd><p>A matrix with the MCMC samples of the draws for the coefficients.</p>
</dd>
<dt>Mbetas</dt><dd><p>A vector of estimated mean values of regression coefficients. </p>
</dd>
<dt>SDbetas</dt><dd><p>The standard deviations of estimated regression coefficients.</p>
</dd>
<dt>Mrho</dt><dd><p>The estimated mean of the lower-level spatial autoregressive parameter <code class="reqn">\rho</code>.</p>
</dd>
<dt>SDrho</dt><dd><p>The standard deviation of the estimated lower-level spatial autoregressive parameter.</p>
</dd>
<dt>Mlamda</dt><dd><p>The estimated mean of the higher-level spatial autoregressive parameter <code class="reqn">\lambda</code>.</p>
</dd>
<dt>SDlambda</dt><dd><p>The standard deviation of the estimated higher-level spatial autoregressive parameter.</p>
</dd>
<dt>Msigma2e</dt><dd><p>The estimated mean of the lower-level variance parameter <code class="reqn">\sigma^2_e</code>.</p>
</dd>
<dt>SDsigma2e</dt><dd><p>The standard deviation of the estimated lower-level variance parameter <code class="reqn">\sigma^{2}_{e} </code>.</p>
</dd>
<dt>Msigma2u</dt><dd><p>The estimated mean of the higher-level variance parameter <code class="reqn">\sigma^2_u</code>.</p>
</dd>
<dt>SDsigma2u</dt><dd><p>The standard deviation of the estimated higher-level variance parameter <code class="reqn">\sigma^2_u</code>.</p>
</dd>
<dt>Mus</dt><dd><p>Mean values of <code class="reqn">\theta</code> </p>
</dd>
<dt>SDus</dt><dd><p>Standard deviation of <code class="reqn">\theta</code> </p>
</dd>
<dt>DIC</dt><dd><p>The deviance information criterion (DIC) of the fitted model.</p>
</dd>
<dt>pd</dt><dd><p>The effective number of parameters of the fitted model.  </p>
</dd>
<dt>Log_Likelihood</dt><dd><p>The log-likelihood of the fitted model. </p>
</dd>
<dt>R_Squared</dt><dd><p>A pseudo R square model fit indicator.   </p>
</dd>
<dt>impact_direct</dt><dd><p>Summaries of the direct impact of a covariate effect on the outcome variable.</p>
</dd>
<dt>impact_idirect</dt><dd><p>Summaries of the indirect impact of a covariate effect on the outcome variable. </p>
</dd>
<dt>impact_total</dt><dd><p>Summaries of the total impact of a covariate effect on the outcome variable.</p>
</dd>
</dl>



<h3>Note</h3>

<p>In order to use the hsar() function, users need to specify the two spatial weights matrices W and M and the random effect design matrix <code class="reqn">\delta</code>. However, it is very easy to extract such spatial weights matrices from spatial data using the package <span class="pkg">spdep</span>. Geographic distance-based or contiguity-based spatial weights matrix for both spatial points data and spatial polygons data are available in the <span class="pkg">spdep</span> package.
Before the extraction of W and M, it is better to first sort the data using the higher-level unit identifier. Then, the random effect design matrix can be extracted simply (see the following example) and so are the two spatial weights matrices. Make sure the order of higher-level units in the weights matrix M is in line with that in the <code class="reqn">\delta</code> matrix.
Two simpler versions of the HSAR model can also be fitted using the hsar() function. The first is a HSAR model with <code class="reqn">\lambda</code> equal to zero, indicating an assumption of independence in the higher-level random effect <code class="reqn">\mathbf{\theta}</code>. The second is a HSAR with <code class="reqn">\rho</code> equal to zero, indicating an independence assumption in the outcome variable conditioning on the hgiher-level random effect. This model is useful in situations where we are interested in the neighbourhood/contextual effect on individual's outcomes and have good reasons to suspect the effect from geographical contexts upon individuals to be dependent. Meanwhile we have no information on how lower-level units are connnected.
</p>


<h3>References</h3>

<p>Dong, G. and Harris, R. 2015. Spatial Autoregressive Models for Geographically Hierarchical Data Structures. <em>Geographical Analysis</em>, 47:173-191.
</p>
<p>LeSage, J. P., and R. K. Pace. (2009). <em>Introduction to Spatial Econometrics</em>. Boca Raton, FL: CRC Press/Taylor &amp; Francis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)

# Running the hsar() function using the Beijing land price data
data(landprice)

# load shapefiles of Beijing districts and land parcels
data(Beijingdistricts)
data(land)

plot(Beijingdistricts,border="green")
plot(land,add=TRUE,col="red",pch=16,cex=0.8)

# Define the random effect matrix
model.data &lt;- landprice[order(landprice$district.id),]
head(model.data,50)

# the number of individuals within each neighbourhood
MM &lt;- as.data.frame(table(model.data$district.id))
# the total number of neighbourhood, 100
Utotal &lt;- dim(MM)[1]
Unum &lt;- MM[,2]
Uid &lt;- rep(c(1:Utotal),Unum)

n &lt;- nrow(model.data)
Delta &lt;- matrix(0,nrow=n,ncol=Utotal)
for(i in 1:Utotal) {
  Delta[Uid==i,i] &lt;- 1
}
rm(i)
# Delta[1:50,1:10]
Delta &lt;- as(Delta,"dgCMatrix")

# extract the district level spatial weights matrix using the queen's rule
nb.list &lt;- spdep::poly2nb(Beijingdistricts)
mat.list &lt;- spdep::nb2mat(nb.list,style="W")
M &lt;- as(mat.list,"dgCMatrix")

# extract the land parcel level spatial weights matrix
nb.25 &lt;- spdep::dnearneigh(land,0,2500)
# to a weights matrix
dist.25 &lt;- spdep::nbdists(nb.25,land)
dist.25 &lt;- lapply(dist.25,function(x) exp(-0.5 * (x / 2500)^2))
mat.25 &lt;- spdep::nb2mat(nb.25,glist=dist.25,style="W")
W &lt;- as(mat.25,"dgCMatrix")


## run the hsar() function
res.formula &lt;- lnprice ~ lnarea + lndcbd + dsubway + dpark + dele +
  popden + crimerate + as.factor(year)

betas= coef(lm(formula=res.formula,data=landprice))
pars=list( rho = 0.5,lambda = 0.5, sigma2e = 2.0, sigma2u = 2.0, betas = betas )


  res &lt;- hsar(res.formula, data=landprice, W=W, M=M, Delta=Delta,
              burnin=500, Nsim=1000, thinning = 1, parameters.start=pars)
  summary(res)

  # visualise the district level random effect
  groups &lt;- sdsfun::discretize_vector(res$Mus,n = 4,method = "natural")
  palette &lt;- RColorBrewer::brewer.pal(4, "Blues")
  plot(Beijingdistricts,col=palette[groups],border="grey")

</code></pre>

<hr>
<h2 id='land'>The spatial locations of the Beijing land price data</h2><span id='topic+land'></span>

<h3>Description</h3>

<p>The spatial locations of the Beijing land price data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>land
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1117 rows and 3 columns.
</p>

<hr>
<h2 id='landprice'>Leased residential land parcels, from 2003 to 2009 in Beijing, China</h2><span id='topic+landprice'></span>

<h3>Description</h3>

<p>Leased residential land parcels, from 2003 to 2009 in Beijing, China
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landprice
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1117 rows and 11 columns.
</p>


<h3>Details</h3>

<p>A <code>data.frame</code> with 1117 observations on the following 11 variables.
</p>

<dl>
<dt>obs</dt><dd><p>An unique identifier for each land parcel.</p>
</dd>
<dt>lnprice</dt><dd><p>The log of the leasing price per square metre of each residential land parcel (unit: RMB, Chinese yuan) </p>
</dd>
<dt>dsubway</dt><dd><p>The log of the distance of each land parcel to the nearest railway station (unit:meters)</p>
</dd>
<dt>dele</dt><dd><p>The log of the distance of each land parcel to the nearest elementary school (unit:meters) </p>
</dd>
<dt>dpark</dt><dd><p>The log of the distance of each land parcel to the nearest green park (unit:meters) </p>
</dd>
<dt>lnarea</dt><dd><p>The log of the size of each land parcel (unit: square meters).</p>
</dd>
<dt>lndcbd</dt><dd><p>The log of the distance of each land parcel to the CBD (centre business district) in Beijing (unit:meters) </p>
</dd>
<dt>year</dt><dd><p>The year when each land parcel was leased with values of 0,1,2,3,4,5,6 representing year 2003,2004,2005,2006,2007,2008,2009</p>
</dd>
<dt>popden</dt><dd><p>The population density of each district (unit: 1000 persons per square kilometers) </p>
</dd>
<dt>crimerate</dt><dd><p>The number of reported serious crimes committed in each district per 1000 persons.</p>
</dd>
<dt>district.id</dt><dd><p>The identifier of the district where each land parcel is located.</p>
</dd>
</dl>


<hr>
<h2 id='properties'>Dataset of properties in the municipality of Athens</h2><span id='topic+properties'></span>

<h3>Description</h3>

<p>A dataset of apartments in the municipality of Athens for 2017. Point location of the properties is given
together with their main characteristics and the distance to the closest metro/train station.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>properties
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1000 rows and 7 columns.
</p>


<h3>Details</h3>

<p>An sf object of 1000 points with the following 6 variables.
</p>

<dl>
<dt>id</dt><dd><p>An unique identifier for each property.</p>
</dd>
<dt>size</dt><dd><p>The size of the property (unit: square meters)</p>
</dd>
<dt>price</dt><dd><p>The asking price (unit: euros) </p>
</dd>
<dt>prpsqm</dt><dd><p>The asking price per squre meter (unit: euroes/square meter).</p>
</dd>
<dt>age</dt><dd><p>Age of property in 2017 (unit: years).</p>
</dd>
<dt>dist_metro</dt><dd><p>The distance to closest train/metro station (unit: meters).</p>
</dd>
</dl>


<hr>
<h2 id='sar'>SAR model estimation</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p>The <code>sar()</code> function implements a standard spatial econometrics model (SAR) or a spatially lagged dependent
variable model using the Markov chain Monte Carlo (McMC) simulation approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(
  formula,
  data = NULL,
  W,
  burnin = 5000,
  Nsim = 10000,
  thinning = 1,
  parameters.start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to fit. A formula for the covariate part of the model
using the syntax of the <code>stats::lm()</code> function fitting standard linear regression models. Neither the
response variable nor the explanatory variables are allowed to contain NA values.</p>
</td></tr>
<tr><td><code id="sar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing variables used in the formula object.</p>
</td></tr>
<tr><td><code id="sar_+3A_w">W</code></td>
<td>
<p>The N by N spatial weights matrix or neighbourhood matrix where N is the number of spatial units.
The formulation of W could be based on geographical distances separating units or based on geographical contiguity.
To ensure the maximum value of the spatial autoregressive parameter <code class="reqn">\rho</code> less than 1, W is usually row-normalised
before implementing the SAR model. As in most cases, spatial weights matrix is very sparse, therefore W here should be
converted to a sparse matrix before imported into the <code>sar()</code> function to save computational burden and reduce computing
time. More specifically, W should be a column-oriented numeric sparse matrices of a <code>dgCMatrix</code> class defined in the
<code>Matrix</code> package. The converion between a dense numeric matrix and a sparse numeric matrix is made quite convenient through
the <code>Matrix</code> library.</p>
</td></tr>
<tr><td><code id="sar_+3A_burnin">burnin</code></td>
<td>
<p>The number of McMC samples to discard as the burnin period.</p>
</td></tr>
<tr><td><code id="sar_+3A_nsim">Nsim</code></td>
<td>
<p>The total number of McMC samples to generate.</p>
</td></tr>
<tr><td><code id="sar_+3A_thinning">thinning</code></td>
<td>
<p>MCMC thinning factor.</p>
</td></tr>
<tr><td><code id="sar_+3A_parameters.start">parameters.start</code></td>
<td>
<p>A list with names &quot;rho&quot;, &quot;sigma2e&quot;, and &quot;beta&quot; corresponding to initial values for the model parameters
<code class="reqn">\rho, \sigma^2_e</code> and the regression coefficients respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code>.
</p>

<dl>
<dt>cbetas</dt><dd><p>A matrix with the MCMC samples of the draws for the coefficients.</p>
</dd>
<dt>Mbetas</dt><dd><p>A vector of estimated mean values of regression coefficients.</p>
</dd>
<dt>SDbetas</dt><dd><p>The standard deviations of estimated regression coefficients.</p>
</dd>
<dt>Mrho</dt><dd><p>The estimated mean of the lower-level spatial autoregressive parameter <code class="reqn">\rho</code>.</p>
</dd>
<dt>SDrho</dt><dd><p>The standard deviation of the estimated lower-level spatial autoregressive parameter.</p>
</dd>
<dt>Msigma2e</dt><dd><p>The estimated mean of the lower-level variance parameter <code class="reqn">\sigma^{2}_{e} </code>.</p>
</dd>
<dt>SDsigma2e</dt><dd><p>The standard deviation of the estimated lower-level variance parameter <code class="reqn">\sigma^{2}_{e} </code>.</p>
</dd>
<dt>DIC</dt><dd><p>The deviance information criterion (DIC) of the fitted model.</p>
</dd>
<dt>pd</dt><dd><p>The effective number of parameters of the fitted model. </p>
</dd>
<dt>Log_Likelihood</dt><dd><p>The log-likelihood of the fitted model.</p>
</dd>
<dt>R_Squared</dt><dd><p>A pseudo R square model fit indicator.  </p>
</dd>
<dt>impact_direct</dt><dd><p>Summaries of the direct impact of a covariate effect on the outcome variable.  </p>
</dd>
<dt>impact_idirect</dt><dd><p>Summaries of the indirect impact of a covariate effect on the outcome variable. </p>
</dd>
<dt>impact_total</dt><dd><p> Summaries of the total impact of a covariate effect on the outcome variable. </p>
</dd>
</dl>



<h3>References</h3>

<p>Anselin, L. (1988). <em>Spatial Econometrics: Methods and Models</em>. Dordrecht: Kluwer Academic Publishers.
</p>
<p>LeSage, J. P., and R. K. Pace. (2009). <em>Introduction to Spatial Econometrics</em>. Boca Raton, FL: CRC Press/Taylor &amp; Francis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(landprice)
head(landprice)
data(land)

# extract the land parcel level spatial weights matrix
library(spdep)
library(Matrix)
nb.25 &lt;- spdep::dnearneigh(land,0,2500)
# to a weights matrix
dist.25 &lt;- spdep::nbdists(nb.25,land)
dist.25 &lt;- lapply(dist.25,function(x) exp(-0.5 * (x / 2500)^2))
mat.25 &lt;- spdep::nb2mat(nb.25,glist=dist.25,style="W")
W &lt;- as(mat.25,"dgCMatrix")

## run the sar() function
res.formula &lt;- lnprice ~ lnarea + lndcbd + dsubway + dpark + dele +
                popden + crimerate + as.factor(year)
betas= coef(lm(formula=res.formula,data=landprice))
pars=list(rho = 0.5, sigma2e = 2.0, betas = betas)

res &lt;- sar(res.formula,data=landprice,W=W,
           burnin=500, Nsim=1000, thinning=1,
           parameters.start=pars)
summary(res)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
