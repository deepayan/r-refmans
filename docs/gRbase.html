<!DOCTYPE html><html><head><title>Help for package gRbase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gRbase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_pairs'><p>Create all possible pairs</p></a></li>
<li><a href='#all_subsets'><p>Create all subsets</p></a></li>
<li><a href='#api_tabSlice'><p>Array slices</p></a></li>
<li><a href='#api-array-07'><p>Array operations (2007)</p></a></li>
<li><a href='#api-array-properties'><p>Check if object is array</p></a></li>
<li><a href='#api-cell'><p>Table cell operations.</p></a></li>
<li><a href='#api-cell_'><p>Low level table cell operations implemented in c++</p></a></li>
<li><a href='#api-parray'><p>Representation of and operations on multidimensional arrays</p></a></li>
<li><a href='#api-pct-operations'><p>Array algebra</p></a></li>
<li><a href='#api-tabDist'><p>Marginalize and condition in multidimensional array.</p></a></li>
<li><a href='#api-tabNew'><p>Create multidimensional arrays</p></a></li>
<li><a href='#api-tabX'><p>Interface - operations on multidimensional arrays.</p></a></li>
<li><a href='#api-tabX_'><p>Table operations implemented in c++</p></a></li>
<li><a href='#array-simulate'><p>Simulate data from array.</p></a></li>
<li><a href='#compareModels'><p>Generic function for model comparison</p></a></li>
<li><a href='#cov2pcor'><p>Partial correlation (matrix)</p></a></li>
<li><a href='#data_cad'><p>Coronary artery disease data</p></a></li>
<li><a href='#data_handling'><p>Utilities for data handling</p></a></li>
<li><a href='#data-ashtrees'><p>Crown dieback in ash trees</p></a></li>
<li><a href='#data-BodyFat'><p>Body Fat Data</p></a></li>
<li><a href='#data-breastcancer'><p>Gene expression signatures for p53 mutation status in 250 breast cancer</p>
samples</a></li>
<li><a href='#data-carcass'><p>Lean meat contents of 344 pig carcasses</p></a></li>
<li><a href='#data-chestSim'><p>Simulated data from the Chest Clinic example</p></a></li>
<li><a href='#data-dietox'><p>Growth curves of pigs in a 3x3 factorial experiment</p></a></li>
<li><a href='#data-dumping'><p>Gastric Dumping</p></a></li>
<li><a href='#data-lizard'><p>Lizard behaviour</p></a></li>
<li><a href='#data-mathmark'><p>Mathematics marks for students</p></a></li>
<li><a href='#data-mildew'><p>Mildew fungus</p></a></li>
<li><a href='#data-milkcomp'><p>Milk composition data</p></a></li>
<li><a href='#data-Nutrimouse'><p>The Nutrimouse Dataset</p></a></li>
<li><a href='#data-personality'><p>Personality traits</p></a></li>
<li><a href='#data-rats'><p>Weightloss of rats</p></a></li>
<li><a href='#data-reinis'><p>Risk factors for coronary heart disease.</p></a></li>
<li><a href='#data-wine'><p>Chemical composition of wine</p></a></li>
<li><a href='#downstream-aliases'><p>Downstream aliases</p></a></li>
<li><a href='#edge_matrix'><p>Coerce dag to edge matrix</p></a></li>
<li><a href='#fastcombn'><p>Generate All Combinations of n Elements Taken m at a Time</p></a></li>
<li><a href='#gmwr_book'><p>Functions from Graphical Modelling with R book</p></a></li>
<li><a href='#graph_coerce_list'><p>Coercion of graphs represented as lists</p></a></li>
<li><a href='#graph_iplot'><p>Function for plotting graphs using the 'igraph' package.</p></a></li>
<li><a href='#graph_is'><p>Check properties of graphs.</p></a></li>
<li><a href='#graph_query'><p>Query a graph</p></a></li>
<li><a href='#graph_topo_sort'><p>Topological sort of vertices in directed acyclic graph</p></a></li>
<li><a href='#graph_vpar'><p>List of vertices and their parents for graph.</p></a></li>
<li><a href='#graph-clique'><p>Get cliques of an undirected graph</p></a></li>
<li><a href='#graph-coerce'><p>Graph coercion</p></a></li>
<li><a href='#graph-coerce-api'><p>API for coercing graph representations</p></a></li>
<li><a href='#graph-create'><p>Create undirected and directed graphs</p></a></li>
<li><a href='#graph-edgeList'><p>Find edges in a graph and edges not in a graph.</p></a></li>
<li><a href='#graph-gcproperties'><p>Properties of a generating class (for defining a graph).</p></a></li>
<li><a href='#graph-mcs'><p>Maximum cardinality search on undirected graph.</p></a></li>
<li><a href='#graph-min-triangulate'><p>Minimal triangulation of an undirected graph</p></a></li>
<li><a href='#graph-moralize'><p>Moralize a directed acyclic graph</p></a></li>
<li><a href='#graph-mpd'><p>Maximal prime subgraph decomposition</p></a></li>
<li><a href='#graph-randomdag'><p>Random directed acyclic graph</p></a></li>
<li><a href='#graph-rip'><p>Create RIP ordering of the cliques of  an undirected graph;</p>
create junction tree.</a></li>
<li><a href='#graph-triangulate'><p>Triangulation of an undirected graph</p></a></li>
<li><a href='#gRbase'>
<p>The package &lsquo;gRbase&rsquo;: summary information</p></a></li>
<li><a href='#grbase_generics'><p>Compile and propagate functions</p></a></li>
<li><a href='#grbase-utilities'><p>gRbase utilities</p></a></li>
<li><a href='#internal'><p>Internal functions for the gRbase package</p></a></li>
<li><a href='#prostate'><p>Prostate Tumor Gene Expression Dataset</p></a></li>
<li><a href='#set-operations'><p>Suite of set operations</p></a></li>
<li><a href='#ug2dag'><p>Coerce between undirected and directed graphs when possible</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Title:</td>
<td>A Package for Graphical Modelling in R</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'gRbase' package provides graphical modelling features
    used by e.g. the packages 'gRain', 'gRim' and 'gRc'. 'gRbase' implements
    graph algorithms including (i) maximum cardinality search (for marked
    and unmarked graphs).
    (ii) moralization, (iii) triangulation, (iv) creation of junction tree.
    'gRbase' facilitates array operations,
    'gRbase' implements functions for testing for conditional independence.
    'gRbase' illustrates how hierarchical log-linear models may be
    implemented and describes concept of graphical meta
    data. 
    The facilities of the package are documented in the book by Højsgaard,
    Edwards and Lauritzen (2012,
    &lt;<a href="https://doi.org/10.1007%2F978-1-4614-2299-0">doi:10.1007/978-1-4614-2299-0</a>&gt;) and in the paper by 
    Dethlefsen and Højsgaard, (2005, &lt;<a href="https://doi.org/10.18637%2Fjss.v014.i17">doi:10.18637/jss.v014.i17</a>&gt;).
    Please see 'citation("gRbase")' for citation details. </td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.math.aau.dk/~sorenh/software/gR/">https://people.math.aau.dk/~sorenh/software/gR/</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats4, igraph, Matrix, Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), microbenchmark, markdown, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.1), RcppEigen, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-05 06:45:00 UTC; sorenh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-05 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_pairs'>Create all possible pairs</h2><span id='topic+all_pairs'></span><span id='topic+names2pairs'></span>

<h3>Description</h3>

<p>Create all possible pairs of two character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_pairs(x, y = character(0), sort = FALSE, result = "matrix")

names2pairs(x, y = NULL, sort = TRUE, result = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_pairs_+3A_x">x</code>, <code id="all_pairs_+3A_y">y</code></td>
<td>
<p>Character vectors.</p>
</td></tr>
<tr><td><code id="all_pairs_+3A_sort">sort</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="all_pairs_+3A_result">result</code></td>
<td>
<p>A list or a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTICE: If y is not NULL then x and y must be disjoint (no
checks are made); otherwise pairs of identical elements wil also be obtained.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- letters[1:4]
y &lt;- letters[5:7]

all_pairs(x)
all_pairs(x, result="matrix")

all_pairs(x, y)
all_pairs(x, y, result="matrix")
</code></pre>

<hr>
<h2 id='all_subsets'>Create all subsets</h2><span id='topic+all_subsets'></span><span id='topic+all_subsets0'></span>

<h3>Description</h3>

<p>Create all subsets of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_subsets(x)

all_subsets0(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_subsets_+3A_x">x</code></td>
<td>
<p>Vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

<hr>
<h2 id='api_tabSlice'>Array slices</h2><span id='topic+api_tabSlice'></span><span id='topic+tabSlice'></span><span id='topic+tabSlice2'></span><span id='topic+tabSlicePrim'></span><span id='topic+tabSliceMult'></span><span id='topic+tabSlice2Entries'></span>

<h3>Description</h3>

<p>Functions for extracting slices of arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabSlice(
  tab,
  slice = NULL,
  margin = names(slice),
  drop = TRUE,
  as.array = FALSE
)

tabSlice2(tab, slice, margin.idx, drop = TRUE, as.array = FALSE)

tabSlicePrim(tab, slice, drop = TRUE)

tabSliceMult(tab, slice, val = 1, comp = 0)

tabSlice2Entries(tab, slice, complement = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api_tabSlice_+3A_tab">tab</code></td>
<td>
<p>An array with named dimnames.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_slice">slice</code></td>
<td>
<p>A list defining the slice.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_margin">margin</code></td>
<td>
<p>Names of variables in slice.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_drop">drop</code></td>
<td>
<p>If TRUE then dimensions with only one level will be
dropped from the output.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_as.array">as.array</code></td>
<td>
<p>If the resulting array is one-dimensional the
result will by default be a vector with no dim attribute unless
as.array is TRUE.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_margin.idx">margin.idx</code></td>
<td>
<p>Indec of variables in slice.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_val">val</code></td>
<td>
<p>The values that entries in the slice will be multiplied
with.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_comp">comp</code></td>
<td>
<p>The values that entries NOT in the slice will be
multiplied with.</p>
</td></tr>
<tr><td><code id="api_tabSlice_+3A_complement">complement</code></td>
<td>
<p>If TRUE the complement of the entries are
returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = HairEyeColor
s = list(Hair=c("Black", "Brown"), Eye=c("Brown", "Blue"))

s1 = tabSlice(x, slice=s); s1

tabSlice2Entries(x, slice=s)
tabSlice2Entries(x, slice=s, complement=TRUE)

## tabSliceMult 
s2 = tabSliceMult(x, slice=s); s2

sp = list(c(1,2), c(1,2), TRUE)
tabSlicePrim(x, slice=sp)
tabSlice(x, slice=s)
</code></pre>

<hr>
<h2 id='api-array-07'>Array operations (2007)</h2><span id='topic+api-array-07'></span><span id='topic+tablePerm'></span><span id='topic+tableMult'></span><span id='topic+tableDiv'></span><span id='topic+tableOp'></span><span id='topic+tableOp2'></span><span id='topic+tableOp0'></span><span id='topic+tableSlice'></span><span id='topic+tableSlicePrim'></span><span id='topic+tableMargin'></span><span id='topic+tableGetSliceIndex'></span><span id='topic+tableSetSliceValue'></span>

<h3>Description</h3>

<p>Array operations; created to facilitate the gRain
package in 2007. Now largely replaceable by other (often
faster) functions implemented in Rcpp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tablePerm(tab, perm, resize = TRUE, keep.class = FALSE)

tableMult(tab1, tab2)

tableDiv(tab1, tab2)

tableOp(tab1, tab2, op = "*")

tableOp2(tab1, tab2, op = `*`, restore = FALSE)

tableOp0(tab1, tab2, op = `*`)

tableSlice(tab, margin, level, impose)

tableSlicePrim(tab, mar.idx, lev.idx)

tableMargin(tab, margin, keep.class = FALSE)

tableGetSliceIndex(tab, margin, level, complement = FALSE)

tableSetSliceValue(tab, margin, level, complement = FALSE, value = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-array-07_+3A_tab">tab</code>, <code id="api-array-07_+3A_tab1">tab1</code>, <code id="api-array-07_+3A_tab2">tab2</code></td>
<td>
<p>Arrays with named dimnames.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_perm">perm</code></td>
<td>
<p>A permutation; either indices or names.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_resize">resize</code></td>
<td>
<p>A flag indicating whether the vector should be
resized as well as having its elements reordered (default
TRUE).</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_keep.class">keep.class</code></td>
<td>
<p>Obsolete argument.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_op">op</code></td>
<td>
<p>The operation; choices are <code>"*"</code>, <code>"/"</code>, <code>"+"</code>, <code>"-"</code>.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_restore">restore</code></td>
<td>
<p>Not so clear anymore.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_margin">margin</code></td>
<td>
<p>Index or name of margin.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_level">level</code></td>
<td>
<p>Corresponding level of margin.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_impose">impose</code></td>
<td>
<p>Value to be imposed.</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_mar.idx">mar.idx</code></td>
<td>
<p>Index of margin</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_lev.idx">lev.idx</code></td>
<td>
<p>Index of level</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_complement">complement</code></td>
<td>
<p>Should values be set for the complement?</p>
</td></tr>
<tr><td><code id="api-array-07_+3A_value">value</code></td>
<td>
<p>Which value should be set</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tableOp0</code> is brute force implementation based on
dataframes. It is very slow, but useful for error checking.
</p>

<hr>
<h2 id='api-array-properties'>Check if object is array</h2><span id='topic+api-array-properties'></span><span id='topic+is.named.array'></span><span id='topic+is_named_array_'></span><span id='topic+is_number_vector_'></span><span id='topic+is_dimnames_'></span><span id='topic+dimnames_match'></span>

<h3>Description</h3>

<p>Check if object is array (that it is a vector with a
dim attribute) and that the object has dimnames and that
dimnames are named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.named.array(obj)

is_named_array_(obj)

is_number_vector_(obj)

is_dimnames_(obj)

dimnames_match(a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-array-properties_+3A_obj">obj</code></td>
<td>
<p>Some R object.</p>
</td></tr>
<tr><td><code id="api-array-properties_+3A_a1">a1</code>, <code id="api-array-properties_+3A_a2">a2</code></td>
<td>
<p>Arrays with named dimnames.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.named.array( HairEyeColor )
is.named.array( matrix(1:4, nrow=2) )
is_named_array_( HairEyeColor )
is_named_array_( matrix(1:4, nrow=2) )
is_number_vector_(1:4)
is_number_vector_(list(1:4))

ar1 = tabNew(c("a", "b"), levels=c(2, 3))
ar2 = tabNew(c("c", "a"), levels=c(2, 2))
ar1
ar2
## dimension a has levels a1,a2 in both ar1 and ar2.
# Hence we have a match.
dimnames_match(ar1, ar2)

ar1 = tabNew(c("a", "b"), levels=c(2, 3))
ar2 = tabNew(c("c", "a"), levels=c(2, 3))
ar1
ar2
## dimension a has levels a1,a2 in ar1 and levels a1,a2,a3 in ar2.
# Hence we do not have a match.
dimnames_match(ar1, ar2)

ar2 = tabNew(c("c", "a"), levels=list(c=c("c1", "c2"), a=c("a2", "a1")))
ar2
## dimension a has levels a1,a2 in ar1 and levels a2,a1 in ar2.
# Hence we do not have a match.
dimnames_match(ar1, ar2)
</code></pre>

<hr>
<h2 id='api-cell'>Table cell operations.</h2><span id='topic+api-cell'></span><span id='topic+cell2entry'></span><span id='topic+entry2cell'></span><span id='topic+next_cell'></span><span id='topic+next_cell2'></span><span id='topic+next_cell_slice'></span><span id='topic+slice2entry'></span><span id='topic+cell2entry_perm'></span><span id='topic+perm_cell_entries'></span><span id='topic+fact_grid'></span>

<h3>Description</h3>

<p>Low level table cell operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell2entry(cell, dim)

entry2cell(entry, dim)

next_cell(cell, dim)

next_cell2(cell, dim)

next_cell_slice(cell, dim, slice_marg)

slice2entry(slice_cell, slice_marg, dim)

cell2entry_perm(cell, dim, perm)

perm_cell_entries(perm, dim)

fact_grid(dim, slice_cell = NULL, slice_marg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-cell_+3A_cell">cell</code></td>
<td>
<p>Vector giving the cell, e.g. c(1, 1, 2) in 3-way table.</p>
</td></tr>
<tr><td><code id="api-cell_+3A_dim">dim</code></td>
<td>
<p>Vector giving array dimension, eg c(2, 2, 2).</p>
</td></tr>
<tr><td><code id="api-cell_+3A_entry">entry</code></td>
<td>
<p>An entry in an array (a number indexing a vector).</p>
</td></tr>
<tr><td><code id="api-cell_+3A_slice_marg">slice_marg</code></td>
<td>
<p>Vector giving the margin of a table, eg. c(2, 3)</p>
</td></tr>
<tr><td><code id="api-cell_+3A_slice_cell">slice_cell</code></td>
<td>
<p>Vector giving the corresponding cell of marginal
table, e.g. c(1, 2)</p>
</td></tr>
<tr><td><code id="api-cell_+3A_perm">perm</code></td>
<td>
<p>Vector giving permutaion of array, eg. c(1, 3, 2).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
di &lt;- c(2, 2, 3)

cell2entry(c(1, 1, 1), dim=di)
cell2entry(c(2, 2, 3), dim=di)

entry2cell(1, dim=di)
entry2cell(12, dim=di)

next_cell(c(1, 1, 1), dim=di)
next_cell(c(2, 1, 1), dim=di)

## The first two entries are kept fixed
next_cell_slice(c(2, 1, 1), dim=di, slice_marg=c(1, 2))
next_cell_slice(c(2, 1, 2), dim=di, slice_marg=c(1, 2))

## Cell (2, 2, 1) corresponds to entry 4
cell2entry(c(2, 2, 1), dim=di)
## Same as
cell2entry_perm(c(2, 2, 1), dim=di, perm=c(1, 2, 3))
## If the table dimensions are permuted as (3, 1, 2)
## the entry becomes
cell2entry_perm(c(2, 2, 1), dim=di, perm=c(3, 1, 2))
</code></pre>

<hr>
<h2 id='api-cell_'>Low level table cell operations implemented in c++</h2><span id='topic+api-cell_'></span><span id='topic+cell2entry_'></span><span id='topic+make_plevels_'></span><span id='topic+entry2cell_'></span><span id='topic+next_cell_'></span><span id='topic+next_cell2_'></span><span id='topic+next_cell_slice_'></span><span id='topic+slice2entry_'></span><span id='topic+cell2entry_perm_'></span><span id='topic+perm_cell_entries_'></span>

<h3>Description</h3>

<p>Corresponding R
functions without the trailing underscore exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell2entry_(cell, dim)

make_plevels_(dim)

entry2cell_(entry, dim)

next_cell_(cell, dim)

next_cell2_(cell, dim)

next_cell_slice_(cell, dim, slice_marg)

slice2entry_(slice_cell, slice_marg, dim)

cell2entry_perm_(cell, dim, perm)

perm_cell_entries_(perm, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-cell__+3A_cell">cell</code></td>
<td>
<p>Vector giving the cell, e.g. c(1, 1, 2) in 3-way table.</p>
</td></tr>
<tr><td><code id="api-cell__+3A_dim">dim</code></td>
<td>
<p>Vector giving array dimension, eg c(2, 2, 2).</p>
</td></tr>
<tr><td><code id="api-cell__+3A_entry">entry</code></td>
<td>
<p>An entry in an array (a number indexing a vector).</p>
</td></tr>
<tr><td><code id="api-cell__+3A_slice_marg">slice_marg</code></td>
<td>
<p>Vector giving the margin of a table, eg. c(2, 3)</p>
</td></tr>
<tr><td><code id="api-cell__+3A_slice_cell">slice_cell</code></td>
<td>
<p>Vector giving the corresponding cell of marginal
table, e.g. c(1, 2)</p>
</td></tr>
<tr><td><code id="api-cell__+3A_perm">perm</code></td>
<td>
<p>Vector giving permutaion of array, eg. c(1, 3, 2).</p>
</td></tr>
</table>

<hr>
<h2 id='api-parray'>Representation of and operations on multidimensional arrays</h2><span id='topic+api-parray'></span><span id='topic+parray'></span><span id='topic+as.parray'></span><span id='topic+data2parray'></span><span id='topic+makeDimNames'></span>

<h3>Description</h3>

<p>General representation of multidimensional arrays
(with named dimnames, also called named arrays.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parray(varNames, levels, values = 1, normalize = "none", smooth = 0)

as.parray(values, normalize = "none", smooth = 0)

data2parray(data, varNames = NULL, normalize = "none", smooth = 0)

makeDimNames(varNames, levels, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-parray_+3A_varnames">varNames</code></td>
<td>
<p>Names of variables defining table; can be a right hand sided
formula.</p>
</td></tr>
<tr><td><code id="api-parray_+3A_levels">levels</code></td>
<td>
<p>Either 1) a vector with number of levels of the factors in
varNames or 2) a list with specification of the levels of the factors in
varNames. See 'examples' below.</p>
</td></tr>
<tr><td><code id="api-parray_+3A_values">values</code></td>
<td>
<p>Values to go into the array</p>
</td></tr>
<tr><td><code id="api-parray_+3A_normalize">normalize</code></td>
<td>
<p>Either &quot;none&quot;, &quot;first&quot; or &quot;all&quot;. Should result be
normalized, see 'Details' below.</p>
</td></tr>
<tr><td><code id="api-parray_+3A_smooth">smooth</code></td>
<td>
<p>Should values be smoothed, see 'Details' below.</p>
</td></tr>
<tr><td><code id="api-parray_+3A_data">data</code></td>
<td>
<p>Data to be coerced to a <code>parray</code>; can be <code>data.frame</code>,
<code>table</code>, <code>xtabs</code>, <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="api-parray_+3A_sep">sep</code></td>
<td>
<p>Desired separator in dim names; defaults to &quot;&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A named array object represents a table defined by a set of
variables and their levels, together with the values of the
table. E.g. f(a,b,c) can be a table with a,b,c representing levels
of binary variable
</p>
<p>If <code>normalize="first"</code> then for each configuration of all
other variables than the first, the probabilities are normalized to
sum to one.  Thus f(a,b,c) becomes a conditional probability table
of the form p(a|b,c).
</p>
<p>If <code>normalize="all"</code> then the sum over all entries of f(a,b,c)
is one.
</p>
<p>If <code>smooth</code> is positive then <code>smooth</code> is added to
<code>values</code> before normalization takes place.
</p>


<h3>Value</h3>

<p>A a named array.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.named.array">is.named.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
t1 &lt;- parray(c("gender","answer"), list(c('male','female'),c('yes','no')), values=1:4)
t1 &lt;- parray(~gender:answer, list(c('male','female'),c('yes','no')), values=1:4)
t1 &lt;- parray(~gender:answer, c(2,2), values=1:4)

t2 &lt;- parray(c("answer","category"), list(c('yes','no'),c(1,2)), values=1:4+10)
t3 &lt;- parray(c("category","foo"), c(2,2), values=1:4+100)

varNames(t1)
nLevels(t1)
valueLabels(t1)

## Create 1-dimensional vector with dim and dimnames
x1 &lt;- 1:5
as.parray(x1)
x2 &lt;- parray("x", levels=length(x1), values=x1)
dim(x2)
dimnames(x2)

## Matrix
x1 &lt;- matrix(1:6, nrow=2)
as.parray(x1)
parray(~a:b, levels=dim(x1), values=x1)

## Extract parrays from data
## 1) a dataframe
data(cad1) 
data2parray(cad1, ~Sex:AngPec:AMI)
data2parray(cad1, c("Sex","AngPec","AMI"))
data2parray(cad1, c(1,2,3))
## 2) a table
data2parray(UCBAdmissions,c(1,2), normalize="first")
</code></pre>

<hr>
<h2 id='api-pct-operations'>Array algebra</h2><span id='topic+api-pct-operations'></span><span id='topic++25a+2B+25'></span><span id='topic++25a-+25'></span><span id='topic++25a+2A+25'></span><span id='topic++25a+2F+25'></span><span id='topic++25a+2F0+25'></span><span id='topic++25a_+25'></span><span id='topic++25a+3D+3D+25'></span><span id='topic++25a+5E+25'></span><span id='topic++25aperm+25'></span><span id='topic++aalign+'></span><span id='topic++25aslice+25'></span><span id='topic++25aslice+2A+25'></span><span id='topic++25amarg+25'></span>

<h3>Description</h3>

<p>Addition, subtraction etc. of arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a1 %a+% a2

a1 %a-% a2

a1 %a*% a2

a1 %a/% a2

a1 %a/0% a2

tab1 %a_% marg

tab1 %a==% tab2

tab1 %a^% extra

tab1 %aperm% perm

tab1 %aalign% tab2

tab1 %aslice% slice

tab1 %aslice*% slice

tab1 %amarg% marg
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-pct-operations_+3A_tab1">tab1</code>, <code id="api-pct-operations_+3A_tab2">tab2</code></td>
<td>
<p>Multidimensional arrays with named dimnames
(we call them 'named arrays').</p>
</td></tr>
<tr><td><code id="api-pct-operations_+3A_marg">marg</code></td>
<td>
<p>A vector of indices or dimnames or a right hand sided
formula giving the desired marginal.</p>
</td></tr>
<tr><td><code id="api-pct-operations_+3A_extra">extra</code></td>
<td>
<p>List defining the extra dimensions.</p>
</td></tr>
<tr><td><code id="api-pct-operations_+3A_perm">perm</code></td>
<td>
<p>A vector of indices or dimnames or a right hand sided
formula giving the desired permutiation.</p>
</td></tr>
<tr><td><code id="api-pct-operations_+3A_slice">slice</code></td>
<td>
<p>A list of the form name=value.</p>
</td></tr>
<tr><td><code id="api-pct-operations_+3A_a">a</code>, <code id="api-pct-operations_+3A_a1">a1</code>, <code id="api-pct-operations_+3A_a2">a2</code></td>
<td>
<p>Arrays (with named dimnames)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hec &lt;- HairEyeColor
a1 &lt;- tabMarg(hec, c("Hair", "Eye"))
a2 &lt;- tabMarg(hec, c("Hair", "Sex"))
a3 &lt;- tabMarg(hec, c("Eye", "Sex"))

## Binary operations
a1 %a+% a2
a1 %a-% a2
a1 %a*% a2
a1 %a/% a2
</code></pre>

<hr>
<h2 id='api-tabDist'>Marginalize and condition in multidimensional array.</h2><span id='topic+api-tabDist'></span><span id='topic+tabDist'></span>

<h3>Description</h3>

<p>Marginalize and condition in a multidimensional array
which is assumed to represent a discrete multivariate
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabDist(tab, marg = NULL, cond = NULL, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-tabDist_+3A_tab">tab</code></td>
<td>
<p>Multidimensional array with dimnames.</p>
</td></tr>
<tr><td><code id="api-tabDist_+3A_marg">marg</code></td>
<td>
<p>A specification of the desired margin; a character vector, a
numeric vector or a right hand sided formula.</p>
</td></tr>
<tr><td><code id="api-tabDist_+3A_cond">cond</code></td>
<td>
<p>A specification of what is conditioned on. Can take two forms:
Form one is a a character vector, a numeric vector or a right hand sided
formula. Form two is as a simple slice of the array, which is a list of
the form var1=value1, var2=value2 etc.</p>
</td></tr>
<tr><td><code id="api-tabDist_+3A_normalize">normalize</code></td>
<td>
<p>Should the result be normalized to sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multidimensional array.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hec &lt;- HairEyeColor

is.named.array( hec )
## We need dimnames, and names on the dimnames

## Marginalize:
tabDist(hec, marg= ~Hair + Eye)
tabDist(hec, marg= ~Hair:Eye)
tabDist(hec, marg= c("Hair", "Eye"))
tabDist(hec, marg= 1:2)

tabDist(hec, marg= ~Hair + Eye, normalize=FALSE)

## Condition
tabDist(hec, cond= ~Sex + Hair)
tabDist(hec, cond= ~Sex:Hair)
tabDist(hec, cond= c("Sex", "Hair"))
tabDist(hec, cond= c(3,1))

tabDist(hec, cond= list(Hair="Black"))
tabDist(hec, cond= list(Hair=1))

## Not run: 
## This will fail
tabDist(hec, cond= list(Hair=c("Black", "Brown")))
tabDist(hec, cond= list(Hair=1:2))

## End(Not run)
## But this will do the trick
a &lt;- tabSlice(hec, slice=list(Hair=c("Black", "Brown")))
tabDist(a, cond=~Hair)

## Combined
tabDist(hec, marg=~Hair+Eye, cond=~Sex)
tabDist(hec, marg=~Hair+Eye, cond="Sex")

tabDist(hec, marg=~Hair+Eye, cond=list(Sex="Male"))
tabDist(hec, marg=~Hair+Eye, cond=list(Sex="Male"), normalize=FALSE)

tabDist(hec, cond=list(Sex="Male"))
tabDist(hec, cond=list(Sex="Male"), normalize=FALSE)

</code></pre>

<hr>
<h2 id='api-tabNew'>Create multidimensional arrays</h2><span id='topic+api-tabNew'></span><span id='topic+tabNew'></span>

<h3>Description</h3>

<p>Alternative ways of creating arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabNew(names, levels, values, normalize = "none", smooth = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-tabNew_+3A_names">names</code></td>
<td>
<p>Names of variables defining table; either a character
vector or a right hand sided formula.</p>
</td></tr>
<tr><td><code id="api-tabNew_+3A_levels">levels</code></td>
<td>

<ol>
<li><p> a list with specification of the levels of the
factors in <code>names</code> or 2) a vector with number of levels of
the factors in <code>names</code>. See 'examples' below.
</p>
</li></ol>
</td></tr>
<tr><td><code id="api-tabNew_+3A_values">values</code></td>
<td>
<p>values to go into the array.</p>
</td></tr>
<tr><td><code id="api-tabNew_+3A_normalize">normalize</code></td>
<td>
<p>Either &quot;none&quot;, &quot;first&quot; or &quot;all&quot;. Should result be
normalized, see 'Details' below.</p>
</td></tr>
<tr><td><code id="api-tabNew_+3A_smooth">smooth</code></td>
<td>
<p>Should values be smoothed, see 'Details' below.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> If <code>normalize="first"</code> then for each configuration of all
other variables than the first, the probabilities are
normalized to sum to one.  Thus f(a, b, c) becomes a
conditional probability table of the form p(a | b, c).
</p>
</li>
<li><p> If <code>normalize="all"</code> then the sum over all entries of
f(a,b,c) is one.
</p>
</li>
<li><p> If <code>smooth</code> is positive then <code>smooth</code> is added to
<code>values</code> BEFORE normalization takes place.
</p>
</li></ol>



<h3>Value</h3>

<p>An array.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
universe &lt;- list(gender=c('male', 'female'),
                 answer=c('yes', 'no'),
                 rain=c('yes', 'no'))
t1 &lt;- tabNew(c("gender", "answer"), levels=universe, values=1:4)
t1
t2 &lt;- tabNew(~gender:answer, levels=universe, values=1:4)
t2
t3 &lt;- tabNew(~gender:answer, c(2, 2), values=1:4)
t3
</code></pre>

<hr>
<h2 id='api-tabX'>Interface - operations on multidimensional arrays.</h2><span id='topic+api-tabX'></span><span id='topic+tabAdd'></span><span id='topic+tabAlign'></span><span id='topic+tabDiv'></span><span id='topic+tabDiv0'></span><span id='topic+tabOp'></span><span id='topic+tabEqual'></span><span id='topic+tabExpand'></span><span id='topic+tabMult'></span><span id='topic+tabSubt'></span><span id='topic+tabListMult'></span><span id='topic+tabListAdd'></span><span id='topic+tabPerm'></span><span id='topic+tabMarg'></span><span id='topic+tabSum'></span><span id='topic+tabProd'></span><span id='topic+tabNormalize'></span>

<h3>Description</h3>

<p>Interface functions and minor extensions to cpp functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabAdd(tab1, tab2)

tabAlign(tab1, tab2)

tabDiv(tab1, tab2)

tabDiv0(tab1, tab2)

tabOp(tab1, tab2, op = "*")

tabEqual(tab1, tab2, eps = 1e-12)

tabExpand(tab, aux, type = 0L)

tabMult(tab1, tab2)

tabSubt(tab1, tab2)

tabListMult(lst)

tabListAdd(lst)

tabPerm(tab, perm)

tabMarg(tab, marg = NULL)

tabSum(tab, ...)

tabProd(tab, ...)

tabNormalize(tab, type = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-tabX_+3A_op">op</code></td>
<td>
<p>The algebraic operation to be carried out.</p>
</td></tr>
<tr><td><code id="api-tabX_+3A_eps">eps</code></td>
<td>
<p>Criterion for checking equality of two arrays.</p>
</td></tr>
<tr><td><code id="api-tabX_+3A_tab">tab</code>, <code id="api-tabX_+3A_tab1">tab1</code>, <code id="api-tabX_+3A_tab2">tab2</code>, <code id="api-tabX_+3A_...">...</code></td>
<td>
<p>Arrays with named dimnames (we call them
'named arrays').</p>
</td></tr>
<tr><td><code id="api-tabX_+3A_aux">aux</code></td>
<td>
<p>Either a list with names and dimnames or a named array
from which such a list can be extracted.</p>
</td></tr>
<tr><td><code id="api-tabX_+3A_type">type</code></td>
<td>
<p>If 0 then entries are duplicated. If 3 then averages
are computed. If 2 then 0 slices are inserted.</p>
</td></tr>
<tr><td><code id="api-tabX_+3A_lst">lst</code></td>
<td>
<p>List of arrays.</p>
</td></tr>
<tr><td><code id="api-tabX_+3A_perm">perm</code>, <code id="api-tabX_+3A_marg">marg</code></td>
<td>
<p>A vector of indices or dimnames or a right hand
sided formula giving the desired permutation/margin.</p>
</td></tr>
</table>

<hr>
<h2 id='api-tabX_'>Table operations implemented in c++</h2><span id='topic+api-tabX_'></span><span id='topic+tab_perm_'></span><span id='topic+tab_expand_'></span><span id='topic+tab_align_'></span><span id='topic+tab_marg_'></span><span id='topic+tab_op_'></span><span id='topic+tab_add_'></span><span id='topic+tab_subt_'></span><span id='topic+tab_mult_'></span><span id='topic+tab_div_'></span><span id='topic+tab_div0_'></span><span id='topic+tab_equal_'></span><span id='topic+tab_list_mult_'></span><span id='topic+tab_list_add_'></span>

<h3>Description</h3>

<p>Table operations implemented in c++. Corresponding R
functions without the trailing underscore exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab_perm_(tab, perm)

tab_expand_(tab, aux, type = 0L)

tab_align_(tab1, tab2)

tab_marg_(tab, marg)

tab_op_(tab1, tab2, op = "*")

tab_add_(tab1, tab2)

tab_subt_(tab1, tab2)

tab_mult_(tab1, tab2)

tab_div_(tab1, tab2)

tab_div0_(tab1, tab2)

tab_equal_(tab1, tab2, eps = 1e-12)

tab_list_mult_(lst)

tab_list_add_(lst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="api-tabX__+3A_tab">tab</code>, <code id="api-tabX__+3A_tab1">tab1</code>, <code id="api-tabX__+3A_tab2">tab2</code></td>
<td>
<p>Tables (arrays)</p>
</td></tr>
<tr><td><code id="api-tabX__+3A_perm">perm</code>, <code id="api-tabX__+3A_marg">marg</code></td>
<td>
<p>A vector of indices or dimnames or a right hand
sided formula giving the desired permutation/margin.</p>
</td></tr>
<tr><td><code id="api-tabX__+3A_aux">aux</code></td>
<td>
<p>Either a list with names and dimnames or a named array
from which such a list can be extracted.</p>
</td></tr>
<tr><td><code id="api-tabX__+3A_type">type</code></td>
<td>
<p>If 0 then entries are duplicated. If 3 then averages
are computed. If 2 then 0 slices are inserted.</p>
</td></tr>
<tr><td><code id="api-tabX__+3A_op">op</code></td>
<td>
<p>The operation to be carried out; &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="api-tabX__+3A_eps">eps</code></td>
<td>
<p>Criterion for checking equality of two arrays.</p>
</td></tr>
<tr><td><code id="api-tabX__+3A_lst">lst</code></td>
<td>
<p>List of arrays.</p>
</td></tr>
</table>

<hr>
<h2 id='array-simulate'>Simulate data from array.</h2><span id='topic+array-simulate'></span><span id='topic+simulateArray'></span><span id='topic+simulate.table'></span><span id='topic+simulate.xtabs'></span><span id='topic+simulate.array'></span>

<h3>Description</h3>

<p>Simulate data (slice of) an array: Simulate n
observations from the array x conditional on the variables in
margin (a vector of indices) takes values given by margin.value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateArray(x, nsim = 1, margin, value.margin, seed = NULL)

## S3 method for class 'table'
simulate(object, nsim = 1, seed = NULL, margin, value.margin, ...)

## S3 method for class 'xtabs'
simulate(object, nsim = 1, seed = NULL, margin, value.margin, ...)

## S3 method for class 'array'
simulate(object, nsim = 1, seed = NULL, margin, value.margin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array-simulate_+3A_x">x</code>, <code id="array-simulate_+3A_object">object</code></td>
<td>
<p>An array.</p>
</td></tr>
<tr><td><code id="array-simulate_+3A_nsim">nsim</code></td>
<td>
<p>Number of cases to simulate.</p>
</td></tr>
<tr><td><code id="array-simulate_+3A_margin">margin</code>, <code id="array-simulate_+3A_value.margin">value.margin</code></td>
<td>
<p>Specification of slice of array to
simulate from.</p>
</td></tr>
<tr><td><code id="array-simulate_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for random number generation.</p>
</td></tr>
<tr><td><code id="array-simulate_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>The current implementation is fragile in the sense that it is
not checked that the input argument <code>x</code> is an array.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2x2 array
x &lt;- parray(c("a", "b"), levels=c(2, 2), values=1:4)

## Simulate from entire array
s &lt;- simulateArray(x, 1000)
xtabs(~., as.data.frame(s))

## Simulate from slice defined by that dimension 1 is fixed at level 2
s &lt;-simulateArray(x, 6000, 1, 2)
xtabs(~., as.data.frame(s))

## 2 x 2 x 2 array
x &lt;- parray(c("a", "b", "c"), levels=c(2, 2, 2), values=1:8)
## Simulate from entire array
s &lt;-simulateArray(x, 36000)
xtabs(~., as.data.frame(s))

## Simulate from slice defined by that dimension 3 is fixed at level 1
s &lt;-simulateArray(x, 10000, 3, 1)
xtabs(~., as.data.frame(s))


</code></pre>

<hr>
<h2 id='compareModels'>Generic function for model comparison</h2><span id='topic+compareModels'></span>

<h3>Description</h3>

<p><code>compareModels</code> is a generic functions which
invoke particular methods which depend on the class of the
first argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareModels(object, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareModels_+3A_object">object</code>, <code id="compareModels_+3A_object2">object2</code></td>
<td>
<p>Model objects</p>
</td></tr>
<tr><td><code id="compareModels_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the first
argument.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

<hr>
<h2 id='cov2pcor'>Partial correlation (matrix)</h2><span id='topic+cov2pcor'></span><span id='topic+conc2pcor'></span>

<h3>Description</h3>

<p><code>cov2pcor</code> calculates the partial correlation
matrix from an (empirical) covariance matrix while
<code>conc2pcor</code> calculates the partial correlation matrix from
a concentration matrix (inverse covariance matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov2pcor(V)

conc2pcor(K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov2pcor_+3A_v">V</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code id="cov2pcor_+3A_k">K</code></td>
<td>
<p>Concentration matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same dimension as V.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(math)
S &lt;- cov.wt(math)$cov
cov2pcor(S)

</code></pre>

<hr>
<h2 id='data_cad'>Coronary artery disease data</h2><span id='topic+data_cad'></span><span id='topic+cad1'></span><span id='topic+cad2'></span>

<h3>Description</h3>

<p>A cross classified table with observational data from a Danish
heart clinic.  The response variable is CAD (coronary artery
disease, some times called heart attack).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cad1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 236 observations on the following 14 variables.
</p>

<dl>
<dt><code>Sex</code></dt><dd><p>Sex; a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>AngPec</code></dt><dd><p>Angina pectoris (chest pain attacks); a
factor with levels <code>Atypical</code> <code>None</code> <code>Typical</code></p>
</dd>
<dt><code>AMI</code></dt><dd><p>Acute myocardic infarct; a factor with
levels <code>Definite</code> <code>NotCertain</code></p>
</dd>
<dt><code>QWave</code></dt><dd><p>A reading from an electrocardiogram; a
factor with levels <code>No</code> <code>Yes</code>; Yes means pathological and is a sign of previous myocardial infarction. </p>
</dd>
<dt><code>QWavecode</code></dt><dd><p>a factor with levels <code>Nonusable</code>
<code>Usable</code>. An assesment of whether QWave is reliable.</p>
</dd>
<dt><code>STcode</code></dt><dd><p>a factor with levels
<code>Nonusable</code> <code>Usable</code>. An assesment of whether STchange is reliable.</p>
</dd>
<dt><code>STchange</code></dt><dd><p>A reading from an electrocardiogram; a factor
with levels <code>No</code> <code>Yes</code>. An STchange indicates a blockage of the coronary artery.</p>
</dd>
<dt><code>SuffHeartF</code></dt><dd><p>Sufficient heart frequency; a factor with levels <code>No</code>, <code>Yes</code></p>
</dd>
<dt><code>Hypertrophi</code></dt><dd><p>a factor with levels <code>No</code>, <code>Yes</code>. Hypertrophy refers to an
increased size of the heart muscle due to exercise. </p>
</dd>
<dt><code>Hyperchol</code></dt><dd><p>a factor with levels <code>No</code> <code>Yes</code>. Hypercholesterolemia, also called high cholesterol,
is the presence of high levels of cholesterol in the blood.</p>
</dd>
<dt><code>Smoker</code></dt><dd><p>Is the patient a smoker; a factor with levels <code>No</code>, <code>Yes</code>.</p>
</dd>
<dt><code>Inherit</code></dt><dd><p>Hereditary predispositions for CAD; a factor with levels  <code>No</code>, <code>Yes</code>.</p>
</dd>
<dt><code>Heartfail</code></dt><dd><p>Previous heart failures; a factor with  levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>CAD</code></dt><dd><p>Coronary Artery Disease; a factor with levels
<code>No</code> <code>Yes</code></p>
</dd></dl>
<p>.  CAD refers to a reduction of blood flow
to the heart muscle (commonly known as a heart attack). The
diagnosis made from biopsies.
</p>



<h3>Details</h3>

<p>Notice that data are collected at a heart clinic, so data do not
represent the population, but are conditional on patients having
ended up at the clinic.
</p>

<ul>
<li><p> cad1: Complete dataset, 236 cases.
</p>
</li>
<li><p> cad2: Incomplete dataset, 67 cases. Information on (some of) the
variables 'Hyperchol', 'Smoker' and 'Inherit' is missing.
</p>
</li></ul>



<h3>References</h3>

<p>Hansen, J. F. (1980). The clinical diagnoisis of ichaeme heart disease du to
coronary artery disease. Danish Medical Bulletin
</p>
<p>Højsgaard, Søren and Thiesson, Bo (1995). BIFROST - Block
recursive models Induced From Relevant knowledge, Observations and
Statistical Techniques. Computational Statistics and Data Analysis, vol. 19,
p. 155-175
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cad1)
## maybe str(cad1) ; plot(cad1) ...

</code></pre>

<hr>
<h2 id='data_handling'>Utilities for data handling</h2><span id='topic+data_handling'></span><span id='topic+valueLabels'></span><span id='topic+valueLabels.default'></span><span id='topic+varNames'></span><span id='topic+varNames.default'></span><span id='topic+nLevels'></span><span id='topic+nLevels.default'></span>

<h3>Description</h3>

<p>Utilities for data handling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valueLabels(x)

## Default S3 method:
valueLabels(x)

varNames(x)

## Default S3 method:
varNames(x)

nLevels(x)

## Default S3 method:
nLevels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_handling_+3A_x">x</code></td>
<td>
<p>Data, typically a dataframe.</p>
</td></tr>
</table>

<hr>
<h2 id='data-ashtrees'>Crown dieback in ash trees</h2><span id='topic+data-ashtrees'></span><span id='topic+ashtrees'></span>

<h3>Description</h3>

<p>This dataset comes from a study of symptoms of crown dieback, cankers and
symptoms caused by other pathogens and pests in ash trees (Fraxinus
excelsior). In all 454 trees were observed in two plots. There are 8
categorical variables, 6 of which are binary and two are trichotomous with
values representing increasing severity of symptoms, and one continuous
variable, tree diameter at breast height (DBH).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ashtrees)
</code></pre>


<h3>Format</h3>

<p>A data frame with 454 observations on the following 9 variables.
</p>

<dl>
<dt><code>plot</code></dt><dd><p>a factor with levels <code>2</code> <code>6</code></p>
</dd>
<dt><code>dieback</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code> <code>2</code></p>
</dd>
<dt><code>dead50</code></dt><dd><p>a factor with levels <code>0</code> <code>0.5</code> <code>1</code></p>
</dd>
<dt><code>bushy</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>canker</code></dt><dd><p>a factor with levels <code>BRNCH</code> <code>MAIN</code> <code>NONE</code></p>
</dd>
<dt><code>wilt</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>roses</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>discolour</code></dt><dd><p>a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>dbh</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Skovgaard JP, Thomsen IM, Skovgaard IM and Martinussen
T (2009).  Associations among symptoms of dieback in even-aged
stands of ash (Fraxinus excelsior L.). Forest Pathology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ashtrees)
head(ashtrees)

</code></pre>

<hr>
<h2 id='data-BodyFat'>Body Fat Data</h2><span id='topic+data-BodyFat'></span><span id='topic+BodyFat'></span>

<h3>Description</h3>

<p>Estimates of the percentage of body fat determined by underwater weighing
and various body circumference measurements for 252 men.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BodyFat)

data(BodyFat)
</code></pre>


<h3>Format</h3>

<p>A data frame with 252 observations on the following 15
variables.
</p>

<dl>
<dt><code>Density</code></dt><dd><p>Density determined from underwater weighing, a numeric vector</p>
</dd>
<dt><code>BodyFat</code></dt><dd><p>Percent body fat from Siri's (1956) equation, a numeric vector</p>
</dd>
<dt><code>Age</code></dt><dd><p>in years, a numeric vector</p>
</dd>
<dt><code>Weight</code></dt><dd><p>in lbs, a numeric vector</p>
</dd>
<dt><code>Height</code></dt><dd><p>in inches, a numeric vector</p>
</dd>
<dt><code>Neck</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Chest</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Abdomen</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Hip</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Thigh</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Knee</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Ankle</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Biceps</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Forearm</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
<dt><code>Wrist</code></dt><dd><p>circumference in cm, a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>For more information see
https://lib.stat.cmu.edu/datasets/bodyfat
</p>


<h3>References</h3>

<p>Bailey, Covert (1994). <em>Smart Exercise: Burning Fat,
Getting Fit</em>, Houghton-Mifflin Co., Boston, pp. 179-186.
</p>
<p>Behnke, A.R. and Wilmore, J.H. (1974). <em>Evaluation and Regulation
of Body Build and Composition</em>, Prentice-Hall, Englewood Cliffs,
N.J.
</p>
<p>Siri, W.E. (1956), &quot;Gross composition of the body&quot;, in <em>Advances in
Biological and Medical Physics</em>, vol. IV, edited by J.H. Lawrence
and C.A.  Tobias, Academic Press, Inc., New York.
</p>
<p>Katch, Frank and McArdle, William (1977). <em>Nutrition, Weight
Control, and Exercise</em>, Houghton Mifflin Co., Boston.
</p>
<p>Wilmore, Jack (1976). <em>Athletic Training and Physical Fitness:
Physiological Principles of the Conditioning Process</em>, Allyn and
Bacon, Inc., Boston.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BodyFat)
head(BodyFat)

</code></pre>

<hr>
<h2 id='data-breastcancer'>Gene expression signatures for p53 mutation status in 250 breast cancer
samples</h2><span id='topic+data-breastcancer'></span><span id='topic+breastcancer'></span>

<h3>Description</h3>

<p>Perturbations of the p53 pathway are associated with more aggressive and
therapeutically refractory tumours. We preprocessed the data using Robust
Multichip Analysis (RMA). Dataset has been truncated to the 1000 most
informative genes (as selected by Wilcoxon test statistics) to simplify
computation. The genes have been standardised to have zero mean and unit
variance (i.e. z-scored).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breastcancer)
</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on 1001 variables. The
first 1000 columns are numerical variables; the last column
(named <code>code</code>) is a factor with levels <code>case</code> and
<code>control</code>.
</p>


<h3>Details</h3>

<p>The factor <code>code</code> defines whether there was a mutation in the p53
sequence (code=case) or not (code=control).
</p>


<h3>Source</h3>

<p>Dr. Chris Holmes, c.holmes at stats
dot. ox . ac .uk
</p>


<h3>References</h3>

<p>Miller et al (2005, PubMed
ID:16141321)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(breastcancer)
## maybe str(breastcancer) ; plot(breastcancer) ...

</code></pre>

<hr>
<h2 id='data-carcass'>Lean meat contents of 344 pig carcasses</h2><span id='topic+data-carcass'></span><span id='topic+carcass'></span><span id='topic+carcassall'></span>

<h3>Description</h3>

<p>Measurement of lean meat percentage of 344 pig carcasses together with
auxillary information collected at three Danish slaughter houses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carcass)
</code></pre>


<h3>Format</h3>

<p>carcassall: A data frame with 344 observations on the following 17
variables.
</p>

<dl>
<dt><code>weight</code></dt><dd><p>Weight of carcass</p>
</dd>
<dt><code>lengthc</code></dt><dd><p>Length of carcass from back toe to head (when
the carcass hangs in the back legs)</p>
</dd>
<dt><code>lengthf</code></dt><dd><p>Length of carcass from back toe to front leg
(that is, to the shoulder)</p>
</dd>
<dt><code>lengthp</code></dt><dd><p>Length of carcass from back toe to the pelvic bone</p>
</dd>
<dt><code>Fat02, Fat03, Fat11, Fat12, Fat13, Fat14, Fat16</code></dt><dd><p>Thickness of fat
layer at different locations on the back of the carcass (FatXX
refers to thickness at (or rather next to) rib no. XX. Notice that
02 is closest to the head</p>
</dd>
<dt><code>Meat11, Meat12, Meat13</code></dt><dd><p>Thickness of meat layer at different
locations on the back of the carcass, see description above</p>
</dd>
<dt><code>LeanMeat</code></dt><dd><p>Lean meat percentage determined by dissection</p>
</dd>
<dt><code>slhouse</code></dt><dd><p>Slaughter house; a factor with levels <code>a</code> <code>b</code> <code>c</code></p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex of the pig; a factor with <code>a</code> <code>b</code>
<code>c</code>. Notice that it is no an error to have three levels; the
third level refers to castrates</p>
</dd>
</dl>



<h3>Note</h3>

<p>carcass: Contains only the variables Fat11, Fat12, Fat13,
Meat11, Meat12, Meat13, LeanMeat
</p>


<h3>Source</h3>

<p>Busk, H., Olsen, E. V., Brøndum, J. (1999) Determination of
lean meat in pig carcasses with the Autofom classification
system, Meat Science, 52, 307-314
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carcass)
head(carcass)

</code></pre>

<hr>
<h2 id='data-chestSim'>Simulated data from the Chest Clinic example</h2><span id='topic+data-chestSim'></span><span id='topic+chestSim500'></span><span id='topic+chestSim1000'></span><span id='topic+chestSim10000'></span><span id='topic+chestSim50000'></span><span id='topic+chestSim100000'></span>

<h3>Description</h3>

<p>Simulated data from the Chest Clinic example (also known as the Asia
example) from Lauritzen and Spiegelhalter, 1988 (see reference below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chestSim500)
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 8 variables.
</p>

<dl>
<dt><code>asia</code></dt><dd><p>Recent visit to Asia?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>tub</code></dt><dd><p>Has tuberculosis?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>smoke</code></dt><dd><p>Is a smoker?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>lung</code></dt><dd><p>Has lung cancer?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>bronc</code></dt><dd><p>Has bronchitis?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>either</code></dt><dd><p>Either lung cancer or tuberculosis?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>xray</code></dt><dd><p>Positive x-ray? a factor with levels <code>yes</code> <code>no</code></p>
</dd>
<dt><code>dysp</code></dt><dd><p>Dyspnoea (shortness of breath)?; a factor with levels <code>yes</code> <code>no</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Notice that the chest clinic example is a contrieved
example; it does not originate from an empirical study.
</p>


<h3>References</h3>

<p>Lauritzen and Spiegelhalter (1988) Local Computations
with Probabilities on Graphical Structures and their
Application to Expert Systems (with
Discussion). J. Roy. Stat. Soc. 50, p. 157-224.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chestSim500)
## maybe str(chestSim500) ; plot(chestSim500) ...

</code></pre>

<hr>
<h2 id='data-dietox'>Growth curves of pigs in a 3x3 factorial experiment</h2><span id='topic+data-dietox'></span><span id='topic+dietox'></span>

<h3>Description</h3>

<p>The <code>dietox</code> data frame has 861 rows and 7 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dietox)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: Weight,
Feed, Time, Pig, Evit, Cu, Litter.
</p>


<h3>Source</h3>

<p>Lauridsen, C., Højsgaard, S., Sørensen, M.T. C. (1999)
Influence of Dietary Rapeseed Oli, Vitamin E, and Copper on
Performance and Antioxidant and Oxidative Status of
Pigs. J. Anim. Sci.77:906-916
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox)

</code></pre>

<hr>
<h2 id='data-dumping'>Gastric Dumping</h2><span id='topic+data-dumping'></span><span id='topic+dumping'></span>

<h3>Description</h3>

<p>A contingency table relating surgical operation, centre and severity of
gastric dumping, a syndrome associated with gastric surgery.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dumping)
</code></pre>


<h3>Format</h3>

<p>A 3x4x4 table of counts cross-classified by Symptom
(none/slight/moderate), Operation (Vd/Va/Vh/Gr) and Centre (1:4).
</p>


<h3>Details</h3>

<p>Gastric dumping syndrome is a condition where ingested foods bypass the
stomach too rapidly and enter the small intestine largely undigested. It is
an undesirable side-effect of gastric surgery. The table summarizes the
results of a study comparing four different surgical operations on patients
with duodenal ulcer, carried out in four centres, as described in Grizzle et
al (1969). The four operations were: vagotomy and drainage, vagotomy and
antrectomy (removal of 25\
(removal of 50\
75\
</p>


<h3>Source</h3>

<p>Grizzle JE, Starmer CF, Koch GG (1969) Analysis of categorical data
by linear models. Biometrics 25(3):489-504.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dumping) 
plot(dumping) 

</code></pre>

<hr>
<h2 id='data-lizard'>Lizard behaviour</h2><span id='topic+data-lizard'></span><span id='topic+lizard'></span><span id='topic+lizardRAW'></span><span id='topic+lizardAGG'></span>

<h3>Description</h3>

<p>In a study of lizard behaviour, characteristics of 409 lizards were
recorded, namely species (S), perch diameter (D) and perch height
(H). Perch means preferred place to settle down (a branch on a
tree).  The focus of interest is in how the propensities of the
lizards to choose perch height and diameter are related, and
whether and how these depend on species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lizard)
</code></pre>


<h3>Format</h3>

<p>A 3&ndash;dimensional array with factors diam: &quot;&lt;=4&quot; &quot;&gt;4&quot; height: &quot;&gt;4.75&quot;
&quot;&lt;=4.75&quot; species: &quot;anoli&quot; &quot;dist&quot;
</p>


<h3>References</h3>

<p>Schoener TW (1968) The anolis lizards of bimini: Resource
partitioning in a complex fauna. Ecology 49:704-726
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lizard)

# Datasets lizardRAW and lizardDF are generated with the following code
#lizardAGG &lt;- as.data.frame(lizard)
#f   &lt;- lizardAGG$Freq
#idx &lt;- unlist(mapply(function(i, n) rep(i, n), 1:8, f))
#set.seed(0805)
#idx &lt;- sample(idx)
#lizardRAW &lt;- as.data.frame(lizardAGG[idx, 1:3])
#rownames(lizardRAW) &lt;- 1:NROW(lizardRAW)


</code></pre>

<hr>
<h2 id='data-mathmark'>Mathematics marks for students</h2><span id='topic+data-mathmark'></span><span id='topic+mathmark'></span><span id='topic+math'></span>

<h3>Description</h3>

<p>The <code>mathmark</code> data frame has 88 rows and 5 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mathmark)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: mechanics, vectors,
algebra, analysis, statistics.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>David Edwards, An Introduction to Graphical Modelling, Second
Edition, Springer Verlag, 2000
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mathmark)

</code></pre>

<hr>
<h2 id='data-mildew'>Mildew fungus</h2><span id='topic+data-mildew'></span><span id='topic+mildew'></span>

<h3>Description</h3>

<p>The data stem from a cross between two isolates of the barley powdery mildew
fungus. For each offspring 6 binary characteristics, each corresponding to a
single locus, were recorded. The object of the analysis is to determine the
order of the loci along the chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mildew)
</code></pre>


<h3>Format</h3>

<p>A 6 dimensional array where each variable has levels &quot;1&quot; and &quot;2&quot;.
The variables are: <code>la10</code>, <code>locc</code>, <code>mp58</code>, <code>c365</code>, <code>p53a</code> and <code>a365</code>.
</p>


<h3>References</h3>

<p>Christiansen, S.K., Giese, H (1991) Genetic analysis of
obligate barley powdery mildew fungus based on RFLP and
virulence loci. Theor. Appl.  Genet. 79:705-712
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mildew)
## maybe str(mildew) ; plot(mildew) ...

</code></pre>

<hr>
<h2 id='data-milkcomp'>Milk composition data</h2><span id='topic+data-milkcomp'></span><span id='topic+milkcomp'></span><span id='topic+milkcomp1'></span>

<h3>Description</h3>

<p>Data from an experiment on composition of sow milk. Milk composition is
measured on four occasions during lactation on a number of sows. The
treatments are different types of fat added to the sows feed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(milkcomp)
</code></pre>


<h3>Format</h3>

<p>A data frame with 214 observations on the following 7 variables.
</p>

<dl>
<dt><code>sow</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>lactime</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>treat</code></dt><dd><p>a factor with levels <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code> <code>g</code></p>
</dd>
<dt><code>fat</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>protein</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>dm</code></dt><dd><p>(dry matter) a numeric vector</p>
</dd>
<dt><code>lactose</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>a</code> is the control, i.e. no fat has been added.
</p>
<p><code>fat</code> + <code>protein</code> + <code>lactose</code> almost add up to <code>dm</code> (dry
matter)
</p>


<h3>References</h3>

<p>Charlotte Lauridsen and Viggo Danielsen (2004):
Lactational dietary fat levels and sources influence milk
composition and performance of sows and their progeny Livestock
Production Science 91 (2004) 95-105
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(milkcomp)
## maybe str(milk) ; plot(milk) ...

</code></pre>

<hr>
<h2 id='data-Nutrimouse'>The Nutrimouse Dataset</h2><span id='topic+data-Nutrimouse'></span><span id='topic+Nutrimouse'></span>

<h3>Description</h3>

<p>The data come from a study of the effects of five dietary regimens with
different fatty acid compositions on liver lipids and hepatic gene
expression in 40 mice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Nutrimouse)
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on 143 variables of which two are factors and 141 are numeric.
</p>

<dl>
<dt><code>genotype</code></dt><dd><p>a factor with levels <code>wt</code>
<code>ppar</code></p>
</dd>
<dt><code>diet</code></dt><dd><p>a factor with levels <code>coc</code>
<code>fish</code> <code>lin</code> <code>ref</code> <code>sun</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The data come from a study of the effects of five dietary regimens with
different fatty acid compositions on liver lipids and hepatic gene
expression in wild-type and PPAR-alpha-deficient mice (Martin et al., 2007).
</p>
<p>There were 5 replicates per genotype and diet combination.
</p>
<p>There are two design variables: (i) genotype, a factor with two levels:
wild-type (wt) and PPAR-alpha-deficient (ppar), and (ii) diet, a factor with
five levels. The oils used for experimental diet preparation were: corn and
colza oils (50/50) for a reference diet (ref); hydrogenated coconut oil for
a saturated fatty acid diet (coc); sunflower oil for an Omega6 fatty
acid-rich diet (sun); linseed oil for an Omega3-rich diet (lin); and
corn/colza/enriched (43/43/14) fish oils (fish).
</p>
<p>There are 141 response variables: (i) the log-expression levels of 120 genes
measured in liver cells, and (ii) the concentrations (in percentages) of 21
hepatic fatty acids measured by gas chromatography.
</p>


<h3>Source</h3>

<p>The data were provided by Pascal Martin from the Toxicology
and Pharmacology Laboratory, National Institute for Agronomic
Research, France.
</p>


<h3>References</h3>

<p>Martin, P. G. P., Guillou, H., Lasserre, F., D'jean,
S., Lan, A., Pascussi, J.-M., San Cristobal, M., Legrand, P.,
Besse, P. and Pineau, T. (2007). Novel aspects of
PPARa-mediated regulation of lipid and xenobiotic metabolism
revealed through a multrigenomic study. Hepatology 54, 767-777.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Nutrimouse)

</code></pre>

<hr>
<h2 id='data-personality'>Personality traits</h2><span id='topic+data-personality'></span><span id='topic+personality'></span>

<h3>Description</h3>

<p>The <code>peronality</code> dataframe has 240 rows and 32 columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(personality)
</code></pre>


<h3>Format</h3>

<p>This dataframe has recordings on the following 32
variables: distant, talkatv, carelss, hardwrk, anxious,
agreebl, tense, kind, opposng, relaxed, disorgn, outgoin,
approvn, shy, discipl, harsh, persevr, friendl, worryin,
respnsi, contrar, sociabl, lazy, coopera, quiet, organiz,
criticl, lax, laidbck, withdrw, givinup, easygon
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Origin unclear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(personality)
str(personality)
</code></pre>

<hr>
<h2 id='data-rats'>Weightloss of rats</h2><span id='topic+data-rats'></span><span id='topic+rats'></span>

<h3>Description</h3>

<p>An artificial dataset. 24 rats (12 female, 12 male) have been randomized to
use one of three drugs (products for loosing weight). The weightloss for
each rat is noted after one and two weeks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rats)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 4 variables. Sex: &quot;M&quot; (male), &quot;F&quot; (female). Drug:
&quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot; (three types). W1 weightloss, week one. W2 weightloss, week
2.
</p>


<h3>References</h3>

<p>Morrison, D.F. (1976). Multivariate Statistical Methods.
McGraw-Hill, USA.
</p>
<p>Edwards, D. (1995). Introduction to Graphical Modelling, Springer-Verlag.
New York.
</p>

<hr>
<h2 id='data-reinis'>Risk factors for coronary heart disease.</h2><span id='topic+data-reinis'></span><span id='topic+reinis'></span>

<h3>Description</h3>

<p>Data collected at the beginning of a 15 year follow-up study of probable
risk factors for coronary thrombosis. Data are from all men employed in a
car factory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reinis)
</code></pre>


<h3>Format</h3>

<p>A table with 6 discrete variables. A: smoking, B: strenous
mental work, D: strenuous physical work, E: systolic blood
pressure, F: ratio of lipoproteins, G: Family anamnesis of
coronary heart disease.
</p>


<h3>References</h3>

<p>Edwards and Havranek (1985): A fast procedure for model
search in multidimensional contingency tables. Biometrika, 72:
339-351.
</p>
<p>Reinis et al (1981): Prognostic significance of the risk profile in the
prevention of coronary heart disease. Bratis. lek. Listy. 76: 137-150.
</p>

<hr>
<h2 id='data-wine'>Chemical composition of wine</h2><span id='topic+data-wine'></span><span id='topic+wine'></span>

<h3>Description</h3>

<p>Using chemical analysis determine the origin of wines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)
</code></pre>


<h3>Format</h3>

<p>A data frame with 178 observations on the following 14 variables.
</p>

<dl>
<dt><code>Cult</code></dt><dd><p>a factor with levels <code>v1</code> <code>v2</code>
<code>v3</code>: 3 different graph varieties</p>
</dd>
<dt><code>Alch</code></dt><dd><p>Alcohol</p>
</dd>
<dt><code>Mlca</code></dt><dd><p>Malic acid</p>
</dd>
<dt><code>Ash</code></dt><dd><p>Ash</p>
</dd>
<dt><code>Aloa</code></dt><dd><p>Alcalinity of ash</p>
</dd>
<dt><code>Mgns</code></dt><dd><p>Magnesium</p>
</dd>
<dt><code>Ttlp</code></dt><dd><p>Total phenols</p>
</dd>
<dt><code>Flvn</code></dt><dd><p>Flavanoids</p>
</dd>
<dt><code>Nnfp</code></dt><dd><p>Nonflavanoid phenols</p>
</dd>
<dt><code>Prnt</code></dt><dd><p>Proanthocyanins</p>
</dd>
<dt><code>Clri</code></dt><dd><p>Color intensity</p>
</dd>
<dt><code>Hue</code></dt><dd><p>Hue</p>
</dd>
<dt><code>Oodw</code></dt><dd><p>OD280/OD315 of diluted wines</p>
</dd>
<dt><code>Prln</code></dt><dd><p>Proline</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data comes from the UCI Machine Learning Repository. The grape variety
<code>Cult</code> is the class identifier.
</p>


<h3>Source</h3>

<p>Frank, A. &amp; Asuncion, A. (2010). UCI Machine Learning
Repository <a href="https://archive.ics.uci.edu/ml/">https://archive.ics.uci.edu/ml/</a>. Irvine, CA:
University of California, School of Information and Computer
Science.
</p>


<h3>References</h3>

<p>See references at
<a href="https://archive.ics.uci.edu/ml/datasets/Wine/">https://archive.ics.uci.edu/ml/datasets/Wine/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(wine)
## maybe str(wine) ; plot(wine) ...

</code></pre>

<hr>
<h2 id='downstream-aliases'>Downstream aliases</h2><span id='topic+downstream-aliases'></span><span id='topic+ell'></span><span id='topic+ellK'></span>

<h3>Description</h3>

<p>Downstream aliases for other graphical modelling
packages.  Will be deprecated in due course.
</p>

<hr>
<h2 id='edge_matrix'>Coerce dag to edge matrix</h2><span id='topic+edge_matrix'></span><span id='topic+dag2edge_matrix'></span><span id='topic+edge_matrix2dag'></span>

<h3>Description</h3>

<p>A DAG can be represented as a triangular matrix of regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag2edge_matrix(object, out = 1)

edge_matrix2dag(edge_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_matrix_+3A_object">object</code></td>
<td>
<p>A graph, either an igraph object or an adjacency matrix.</p>
</td></tr>
<tr><td><code id="edge_matrix_+3A_out">out</code></td>
<td>
<p>Format of the output, can be 1, 2, 3 or 4.</p>
</td></tr>
<tr><td><code id="edge_matrix_+3A_edge_matrix">edge_matrix</code></td>
<td>
<p>Lower triangular matrix representing a dag</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- dag(~x2|x1 + x3|x1:x2 + x4|x3)
dag2edge_matrix(g, out=1)
dag2edge_matrix(g, out=2)
dag2edge_matrix(g, out=3)
dag2edge_matrix(g, out=4)
d2 &lt;- dag(~c|a:b+d:c)
dag2edge_matrix(d2)

</code></pre>

<hr>
<h2 id='fastcombn'>Generate All Combinations of n Elements Taken m at a Time</h2><span id='topic+fastcombn'></span><span id='topic+combn_prim'></span>

<h3>Description</h3>

<p>Generate all combinations of the elements of x taken m
at a time.  If x is a positive integer, returns all
combinations of the elements of seq(x) taken m at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcombn(x, m, FUN = NULL, simplify = TRUE, ...)

combn_prim(x, m, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastcombn_+3A_x">x</code></td>
<td>
<p>vector source for combinations, or integer n for x &lt;-
seq(n).</p>
</td></tr>
<tr><td><code id="fastcombn_+3A_m">m</code></td>
<td>
<p>number of elements to choose.</p>
</td></tr>
<tr><td><code id="fastcombn_+3A_fun">FUN</code></td>
<td>
<p>function to be applied to each combination; default ‘NULL’
means the identity, i.e., to return the combination (vector
of length ‘m’).</p>
</td></tr>
<tr><td><code id="fastcombn_+3A_simplify">simplify</code></td>
<td>
<p>logical indicating if the result should be
simplified to a matrix; if FALSE, the function returns a list.</p>
</td></tr>
<tr><td><code id="fastcombn_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Factors <code>x</code> are accepted.
</p>
</li>
<li> <p><code>combn_prim</code> is a simplified (but faster) version of the <code>combn</code>
function. Does nok take the <code>FUN</code> argument.
</p>
</li>
<li> <p><code>fastcombn</code> is intended to be a faster version of the <code>combn</code>
function.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix or a list.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+combn">combn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- letters[1:5]; m &lt;- 3

fastcombn(x, m)
combn(x, m)
combn_prim(x, m)

x &lt;- letters[1:4]; m &lt;- 3
fastcombn(x, m, simplify=FALSE)
combn(x, m, simplify=FALSE)
combn_prim(x, m, simplify=FALSE)

x &lt;- 1:10; m &lt;- 3
fastcombn(x, m, min)
combn(x, m, min)

x &lt;- factor(letters[1:8]); m &lt;- 5

if (require(microbenchmark)){
  microbenchmark(
    combn(x, m, simplify=FALSE),
    combn_prim(x, m, simplify=FALSE),
    fastcombn(x, m, simplify=FALSE),
    times=50
  )
}

</code></pre>

<hr>
<h2 id='gmwr_book'>Functions from Graphical Modelling with R book</h2><span id='topic+gmwr_book'></span><span id='topic+as.adjMAT'></span>

<h3>Description</h3>

<p>Functions that must be retained to make code from
gmwr-book work
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.adjMAT(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmwr_book_+3A_object">object</code></td>
<td>
<p>An object to be coerced.</p>
</td></tr>
</table>

<hr>
<h2 id='graph_coerce_list'>Coercion of graphs represented as lists</h2><span id='topic+graph_coerce_list'></span><span id='topic+g_ugl2ig_'></span><span id='topic+g_ugl2dm_'></span><span id='topic+g_ugl2sm_'></span><span id='topic+g_ugl2XX_'></span><span id='topic+g_dagl2ig_'></span><span id='topic+g_dagl2dm_'></span><span id='topic+g_dagl2sm_'></span><span id='topic+g_dagl2XX_'></span><span id='topic+g_adl2ig_'></span><span id='topic+g_adl2dm_'></span><span id='topic+g_adl2sm_'></span><span id='topic+g_adl2XX_'></span><span id='topic+g_M2adl_'></span><span id='topic+g_M2ugl_'></span><span id='topic+g_M2dagl_'></span><span id='topic+g_ugl2M_'></span><span id='topic+g_dagl2M_'></span><span id='topic+g_adl2M_'></span>

<h3>Description</h3>

<p>Coercion of graphs represented as lists to various
graph formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_ugl2ig_(zz, vn = NULL)

g_ugl2dm_(zz, vn = NULL)

g_ugl2sm_(zz, vn = NULL)

g_ugl2XX_(zz, outtype, vn = NULL)

g_dagl2ig_(zz, vn = NULL)

g_dagl2dm_(zz, vn = NULL)

g_dagl2sm_(zz, vn = NULL)

g_dagl2XX_(zz, outtype, vn = NULL)

g_adl2ig_(zz)

g_adl2dm_(zz)

g_adl2sm_(zz)

g_adl2XX_(zz, outtype)

g_M2adl_(amat)

g_M2ugl_(amat)

g_M2dagl_(amat)

g_ugl2M_(glist, vn = NULL, result = "matrix")

g_dagl2M_(glist, vn = NULL, result = "matrix")

g_adl2M_(alist, result = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_coerce_list_+3A_zz">zz</code></td>
<td>
<p>An object representing a graph.</p>
</td></tr>
<tr><td><code id="graph_coerce_list_+3A_vn">vn</code></td>
<td>
<p>The names of the vertices in the graphs. These will be
the row and column names of the matrix.</p>
</td></tr>
<tr><td><code id="graph_coerce_list_+3A_outtype">outtype</code></td>
<td>
<p>What should a list be coerced to.</p>
</td></tr>
<tr><td><code id="graph_coerce_list_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix (dense or sparse dgCMatrix).</p>
</td></tr>
<tr><td><code id="graph_coerce_list_+3A_glist">glist</code></td>
<td>
<p>A list of generators where a generator is a character
vector. If interpreted as generators of an undirected graph, a
generator is a complete set of vertices in the graph. If
interpreted as generators of a dag, a generator (v1,...,vn)
means that there will be arrows from v2,...,vn to v1.</p>
</td></tr>
<tr><td><code id="graph_coerce_list_+3A_result">result</code></td>
<td>
<p>A graph object.</p>
</td></tr>
<tr><td><code id="graph_coerce_list_+3A_alist">alist</code></td>
<td>
<p>An adjacency list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sparse and dense adjacency matrices converted to adjacency list 
g1 &lt;- ug(~a:b + b:c + c:d, result="matrix")
g2 &lt;- ug(~a:b + b:c + c:d, result="dgCMatrix")
g_M2adl_( g1 )

## Sparse and dense adjacency matrices converted to cliques
g_M2ugl_( g1 )

## Sparse and dense adjacency matrices converted to cliques
g_M2dagl_( g1 )

## g_M2adl_( g2 ) ## FIXME FAILS for sparse matrix
## g_M2ugl_( g2 ) ## FIXME Is there an issue here??
## g_M2dagList( g2 ) ## Fails for sparse matrix

</code></pre>

<hr>
<h2 id='graph_iplot'>Function for plotting graphs using the 'igraph' package.</h2><span id='topic+graph_iplot'></span><span id='topic+iplot'></span><span id='topic+iplot.igraph'></span>

<h3>Description</h3>

<p>Generic function for plotting graphs using the
'igraph' package and a plot method for graphNEL objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iplot(x, ...)

## S3 method for class 'igraph'
iplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_iplot_+3A_x">x</code></td>
<td>
<p>A graph object to be plotted.</p>
</td></tr>
<tr><td><code id="graph_iplot_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
UG &lt;- ug(~a:b+b:c:d)
iplot(UG)

</code></pre>

<hr>
<h2 id='graph_is'>Check properties of graphs.</h2><span id='topic+graph_is'></span><span id='topic+is_dag'></span><span id='topic+is_dagMAT'></span><span id='topic+is_ug'></span><span id='topic+is_ugMAT'></span><span id='topic+is_tug'></span><span id='topic+is_tugMAT'></span><span id='topic+is_dg'></span><span id='topic+is_dgMAT'></span><span id='topic+is_adjMAT'></span><span id='topic+is.adjMAT'></span><span id='topic+is.TUG'></span><span id='topic+is.DAG'></span><span id='topic+is.DG'></span><span id='topic+is.UG'></span>

<h3>Description</h3>

<p>Check if a graph is 1) a directed acyclic graph (DAG),
2) a directed graph (DG), 3) an undirected graph (UG), 4) a
triangulated (chordal) undirected graph (TUG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dag(object)

is_dagMAT(object)

is_ug(object)

is_ugMAT(object)

is_tug(object)

is_tugMAT(object)

is_dg(object)

is_dgMAT(object)

is_adjMAT(object)

is.adjMAT(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_is_+3A_object">object</code></td>
<td>
<p>A graph represented as a <code>graphNEL</code> (graph package),
an <code>igraph</code> (igraph package), an adjacency matrix or a sparse
adjacency matrix (a <code>dgCMatrix</code> from the Matrix package).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> A non-zero value at entry (i,j) in an adjacency matrix A for a
graph means that there is an edge from i to j. If also (j,i) is
non-zero there is also an edge from j to i. In this case we may
think of a bidirected edge between i and j or we may think of the
edge as being undirected.  We do not distinguish between undirected
and bidirected edges in the gRbase package.  On the other hand,
graphNEL objects from the graph package makes such a distinction
(the function <code>edgemode()</code> will tell if edges are &quot;directed&quot;
or &quot;undirected&quot; in a graphNEL object).
</p>
</li>
<li><p> The function <code>is_ug()</code> checks if the adjacency matrix is
symmetric (If applied to a graphNEL, the adjacency matrix is
created and checked for symmetry.)
</p>
</li>
<li><p> The function <code>is_tug()</code> checks if the graph is undirected and
triangulated (also called chordal) by checking if the adjacency matrix is
symmetric and the vertices can be given a perfect ordering using maximum
cardinality seach.
</p>
</li>
<li><p> The function <code>is_dg()</code> checks if a graph is directed, i.e., that there
are no undirected edges. This is done by computing the elementwise product
of A and the transpose of A; if there are no non&ndash;zero entries in this
product then the graph is directed.
</p>
</li>
<li><p> The function <code>is_dag()</code> will return <code>TRUE</code> if all edges are
directed and if there are no cycles in the graph. (This is checked by
checking if the vertices in the graph can be given a topological ordering
which is based on identifying an undirected edge with a bidrected edge).
</p>
</li>
<li><p> There is a special case, namely if the graph has no edges at all (such that
the adjacency matrix consists only of zeros). Such a graph is both
undirected, triangulated, directed and directed acyclic.
</p>
</li></ul>



<h3>Synonymous functions</h3>

<p>The functions
</p>

<ul>
<li> <p><code>is.TUG</code>/<code>is.DAG</code>/<code>is.DG</code>/<code>is.UG</code>/<code>is.adjMAT</code>
</p>
</li></ul>

<p>are synonymous with
</p>

<ul>
<li> <p><code>is_tug</code>/<code>is_dag</code>/<code>is_dg</code>/<code>is_ug</code>/<code>is_adjMAT</code>.
</p>
</li></ul>

<p>The <code>is.X</code> group of functions will be deprecated.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag">dag</a></code>, <code><a href="#topic+ug">ug</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## DAGs
dag_  &lt;- dag(~ a:b:c + c:d:e)

## Undirected graphs
ug_  &lt;- ug(~a:b:c + c:d:e)

## Is graph a DAG?
is_dag(dag_)
is_dag(ug_)

## Is graph an undirected graph
is_ug(dag_)
is_ug(ug_)
 
## Is graph a triangulated (i.e. chordal) undirected graph
is_tug(dag_)
is_tug(ug_)

## Example where the graph is not triangulated
ug2_  &lt;- ug(~ a:b + b:c + c:d + d:a)
is_tug(ug2_)

</code></pre>

<hr>
<h2 id='graph_query'>Query a graph</h2><span id='topic+graph_query'></span><span id='topic+querygraph'></span><span id='topic+qgraph'></span><span id='topic+ancestors'></span><span id='topic+subGraph'></span><span id='topic+is.triangulated'></span><span id='topic+connComp'></span><span id='topic+ancestralSet'></span><span id='topic+ancestralGraph'></span><span id='topic+parents'></span><span id='topic+children'></span><span id='topic+separates'></span><span id='topic+closure'></span><span id='topic+adj'></span><span id='topic+is.simplicial'></span><span id='topic+simplicialNodes'></span><span id='topic+is.complete'></span><span id='topic+is.decomposition'></span><span id='topic+nodes_'></span><span id='topic+nodes'></span><span id='topic+nodes+2Cigraph-method'></span><span id='topic+edges'></span><span id='topic+edges_'></span><span id='topic+addEdge'></span><span id='topic+removeEdge'></span>

<h3>Description</h3>

<p>Unified approach to query a graph about its properties
(based partly on functionality from gRbase and functionality
imported from RBGL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>querygraph(object, op, set = NULL, set2 = NULL, set3 = NULL)

qgraph(object, op, set = NULL, set2 = NULL, set3 = NULL)

ancestors(set, object)

subGraph(set, object)

is.triangulated(object)

connComp(object)

ancestralSet(set, object)

ancestralGraph(set, object)

parents(set, object)

children(set, object)

separates(set, set2, set3, object)

closure(set, object)

adj(object, set)

is.simplicial(set, object)

simplicialNodes(object)

is.complete(object, set = NULL)

is.decomposition(set, set2, set3, object)

nodes_(object)

nodes(object, ...)

## S4 method for signature 'igraph'
nodes(object, ...)

edges(object)

edges_(object)

addEdge(v1, v2, object)

removeEdge(v1, v2, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_query_+3A_object">object</code></td>
<td>
<p>A graph.</p>
</td></tr>
<tr><td><code id="graph_query_+3A_op">op</code></td>
<td>
<p>The operation or query.</p>
</td></tr>
<tr><td><code id="graph_query_+3A_set">set</code>, <code id="graph_query_+3A_set2">set2</code>, <code id="graph_query_+3A_set3">set3</code></td>
<td>
<p>Sets of nodes in graph.</p>
</td></tr>
<tr><td><code id="graph_query_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="graph_query_+3A_v1">v1</code>, <code id="graph_query_+3A_v2">v2</code></td>
<td>
<p>Vertex names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ug0 &lt;- ug(~a:b + b:c:d + e)

separates("a", "d", c("b", "c"), ug0)
separates("a", "d", "c", ug0) 
is.simplicial("b", ug0)
simplicialNodes(ug0)

simplicialNodes(ug0)
</code></pre>

<hr>
<h2 id='graph_topo_sort'>Topological sort of vertices in directed acyclic graph</h2><span id='topic+graph_topo_sort'></span><span id='topic+topo_sort'></span><span id='topic+topo_sortMAT'></span><span id='topic+topoSort'></span><span id='topic+topoSortMAT'></span>

<h3>Description</h3>

<p>A topological ordering of a directed graph is a linear
ordering of its vertices such that, for every edge (u-&gt;v), u
comes before v in the ordering.  A topological ordering is
possible if and only if the graph has no directed cycles, that
is, if it is a directed acyclic graph (DAG). Any DAG has at
least one topological ordering. Can hence be used for checking
if a graph is a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topo_sort(object, index = FALSE)

topo_sortMAT(amat, index = FALSE)

topoSort(object, index = FALSE)

topoSortMAT(amat, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_topo_sort_+3A_object">object</code></td>
<td>
<p>An graph represented either as a <code>graphNEL</code>
object, an <code>igraph</code>, a (dense) <code>matrix</code>, a (sparse)
<code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="graph_topo_sort_+3A_index">index</code></td>
<td>
<p>If FALSE, an ordering is returned if it exists and
<code>character(0)</code> otherwise. If TRUE, the index of the
variables in an adjacency matrix is returned and <code>-1</code>
otherwise.</p>
</td></tr>
<tr><td><code id="graph_topo_sort_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If FALSE, an ordering is returned if it exists and
<code>character(0)</code> otherwise. If TRUE, the index of the
variables in an adjacency matrix is returned and <code>-1</code>
otherwise.
</p>


<h3>Synonymous functions</h3>

<p>The functions <code>topo_sort</code> / <code>topoSort</code> are synonymous with <code>topo_sortMAT</code> /
<code>topoSortMAT</code>. One of the groups may be deprecated in the future.
</p>


<h3>Note</h3>

<p>The workhorse is the <code>topo_sortMAT</code> function which takes
an adjacency matrix as input.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag">dag</a></code>, <code><a href="#topic+ug">ug</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dagMAT  &lt;- dag(~a:b:c + c:d:e, result="matrix")
dagMATS &lt;- as(dagMAT, "dgCMatrix")

topo_sort(dagMAT)
topo_sort(dagMATS)
</code></pre>

<hr>
<h2 id='graph_vpar'>List of vertices and their parents for graph.</h2><span id='topic+graph_vpar'></span><span id='topic+vchi'></span><span id='topic+vchiMAT'></span><span id='topic+vpar'></span><span id='topic+vparMAT'></span>

<h3>Description</h3>

<p>Get list of vertices and their parents for graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vchi(object, getv = TRUE, forceCheck = TRUE)

vchiMAT(object, getv = TRUE, forceCheck = TRUE)

vpar(object, getv = TRUE, forceCheck = TRUE)

vparMAT(object, getv = TRUE, forceCheck = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_vpar_+3A_object">object</code></td>
<td>
<p>An object representing a graph. Valid objects are an
adjacency matrix or an igraph.</p>
</td></tr>
<tr><td><code id="graph_vpar_+3A_getv">getv</code></td>
<td>
<p>The result is by default a list of vectors of the form
<code>(v, pa1, pa2, ... paN)</code> where <code>pa1, pa2, ... paN</code>
are the parents of <code>v</code>. If <code>getv</code> is <code>FALSE</code>
then the vectors will have the form <code>(pa1, pa2, ... paN)</code></p>
</td></tr>
<tr><td><code id="graph_vpar_+3A_forcecheck">forceCheck</code></td>
<td>
<p>Logical indicating if it should be checked that
the object is a DAG.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors where each vector will have the form
<code>(v, pa1, pa2, ... paN)</code> where <code>pa1, pa2, ... paN</code>
are the parents of <code>v</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag">dag</a></code>, <code><a href="#topic+ug">ug</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## DAGs
dag_mat &lt;- dag(~a:b:c + c:d:e, result="matrix")
dag_ig &lt;- dag(~a:b:c + c:d:e)
vpar(dag_mat)
vpar(dag_ig)
vpar(dag_mat, getv=FALSE)
vpar(dag_ig, getv=FALSE)
## Undirected graphs
ug_mat &lt;- ug(~a:b:c + c:d:e, result="matrix")
ug_ig &lt;- ug(~a:b:c + c:d:e)
## Not run: 
## This will fail because the adjacency matrix is symmetric and the
## graph has undirected edges
vpar(ug_mat)
vpar(ug_ig)

## End(Not run)
## When forceCheck is FALSE, it will not be detected that the
#g raphs are undirected.
vpar(ug_mat, forceCheck=FALSE)
vpar(ug_ig, forceCheck=FALSE)
</code></pre>

<hr>
<h2 id='graph-clique'>Get cliques of an undirected graph</h2><span id='topic+graph-clique'></span><span id='topic+get_cliques'></span><span id='topic+max_cliqueMAT'></span><span id='topic+getCliques'></span><span id='topic+maxCliqueMAT'></span><span id='topic+maxClique'></span>

<h3>Description</h3>

<p>Return a list of (maximal) cliques of an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cliques(object)

max_cliqueMAT(amat)

getCliques(object)

maxCliqueMAT(amat)

maxClique(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-clique_+3A_object">object</code></td>
<td>
<p>An undirected graph represented either as an <code>igraph</code>
object, a (dense) <code>matrix</code>, a (sparse) <code>dgCMatrix</code></p>
</td></tr>
<tr><td><code id="graph-clique_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In graph theory, a clique is often a complete subset of a
graph. A maximal clique is a clique which can not be
enlarged. In statistics (and that is the convention we follow
here) a clique is usually understood to be a maximal clique.
</p>
<p>Finding the cliques of a general graph is an NP complete problem. Finding
the cliques of triangualted graph is linear in the number of cliques.
</p>
<p>The workhorse is the <code>max_cliqueMAT</code> function which calls the
<code>maxClique</code> function in the <code>RBGL</code> package.
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>Synonymous functions</h3>

<p>For backward compatibility with downstream packages we have the
following synonymous functions:
</p>

<ul>
<li><p> getCliques = get_cliques
</p>
</li>
<li><p> maxCliqueMAT = max_cliqueMAT
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ug">ug</a></code>, <code><a href="#topic+dag">dag</a></code>, <code><a href="#topic+mcs">mcs</a></code>,
<code><a href="#topic+mcsMAT">mcsMAT</a></code>, <code><a href="#topic+rip">rip</a></code>, <code><a href="#topic+ripMAT">ripMAT</a></code>,
<code><a href="#topic+moralize">moralize</a></code>, <code><a href="#topic+moralizeMAT">moralizeMAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uG0 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a)
get_cliques(uG0)

uG1 &lt;- as(uG0, "igraph")
get_cliques(uG1)

uG2 &lt;- as(uG0, "matrix") 
get_cliques(uG2)

uG3 &lt;- as(uG1, "dgCMatrix") 
get_cliques(uG3)
</code></pre>

<hr>
<h2 id='graph-coerce'>Graph coercion</h2><span id='topic+graph-coerce'></span><span id='topic+coerceGraph'></span><span id='topic+graph_as'></span>

<h3>Description</h3>

<p>Methods for changing graph representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerceGraph(object, class)

graph_as(object, outtype, intype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-coerce_+3A_object">object</code></td>
<td>
<p>A graph object</p>
</td></tr>
<tr><td><code id="graph-coerce_+3A_class">class</code></td>
<td>
<p>The desired output class</p>
</td></tr>
<tr><td><code id="graph-coerce_+3A_outtype">outtype</code></td>
<td>
<p>The desired output outtype</p>
</td></tr>
<tr><td><code id="graph-coerce_+3A_intype">intype</code></td>
<td>
<p>The desired output outtype (only relevant if object is a list)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>coerceGraph is used in the book &quot;Graphical models with R&quot;.
A more generic approach is as().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- ug(~a:b+b:c)
as(g1, "igraph")
as(g1, "matrix")
as(g1, "Matrix")
as(g1, "dgCMatrix")

## graph_as(g1, "ugList") ## Fails
## getCliques(g1)         ## Works

l1 &lt;- list(c("a" ,"b"), c("b", "c"))
graph_as(l1, "graphNEL", "ugList")

</code></pre>

<hr>
<h2 id='graph-coerce-api'>API for coercing graph representations</h2><span id='topic+graph-coerce-api'></span><span id='topic+g_dm2sm_'></span><span id='topic+g_dm2ig_'></span><span id='topic+g_sm2dm_'></span><span id='topic+g_sm2ig_'></span><span id='topic+g_ig2dm_'></span><span id='topic+g_ig2sm_'></span><span id='topic+g_xm2ig_'></span><span id='topic+g_xm2dm_'></span><span id='topic+g_xm2sm_'></span><span id='topic+g_xm2xm_'></span>

<h3>Description</h3>

<p>API for coercing graph representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_dm2sm_(object)

g_dm2ig_(object)

g_sm2dm_(object)

g_sm2ig_(object)

g_ig2dm_(object)

g_ig2sm_(object)

g_xm2ig_(object)

g_xm2dm_(object)

g_xm2sm_(object)

g_xm2xm_(object, result = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-coerce-api_+3A_object">object</code></td>
<td>
<p>An object representing a graph</p>
</td></tr>
<tr><td><code id="graph-coerce-api_+3A_result">result</code></td>
<td>
<p>Either 'matrix' (dense) or 'dgCMatrix' (sparse, can
be abbreviated to 'Matrix').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No checking is made. In the function the following names are used:
</p>

<ul>
<li><p> &quot;ig&quot;: &quot;igraph&quot;;
</p>
</li>
<li><p> &quot;gn&quot;: &quot;graphNEL&quot;;
</p>
</li>
<li><p> &quot;sm&quot;: &quot;dgCMatrix&quot; (sparse matrix);
</p>
</li>
<li><p> &quot;dm&quot;: &quot;matrix&quot; (dense matrix)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ug">ug</a></code>, <code><a href="#topic+dag">dag</a></code>
</p>

<hr>
<h2 id='graph-create'>Create undirected and directed graphs</h2><span id='topic+graph-create'></span><span id='topic+ug'></span><span id='topic+ugi'></span><span id='topic+ugList'></span><span id='topic+dag'></span><span id='topic+dagi'></span><span id='topic+dagList'></span>

<h3>Description</h3>

<p>These functions are wrappers for creation of graphs as
implemented by graphNEL objects in the <code>graph</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ug(..., result = "igraph")

ugi(...)

ugList(x, result = "igraph")

dag(..., result = "igraph", forceCheck = FALSE)

dagi(..., forceCheck = FALSE)

dagList(x, result = "igraph", forceCheck = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-create_+3A_...">...</code></td>
<td>
<p>A generating class for a graph, see examples below</p>
</td></tr>
<tr><td><code id="graph-create_+3A_result">result</code></td>
<td>
<p>The format of the graph. The possible choices are
&quot;graphNEL&quot; (for a <code>graphNEL</code> object), &quot;igraph&quot; (for an <code>igraph</code>
object), &quot;matrix&quot; (for an adjacency matrix), &quot;dgCMatrix&quot; (for a
sparse matrix).</p>
</td></tr>
<tr><td><code id="graph-create_+3A_x">x</code></td>
<td>
<p>A list or individual components from which a graph can be
created.</p>
</td></tr>
<tr><td><code id="graph-create_+3A_forcecheck">forceCheck</code></td>
<td>
<p>Logical determining if it should be checked if
the graph is acyclical. Yes, one can specify graphs with cycles
using the <code>dag()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions <code>ug()</code>, and <code>dag()</code> can return a
<code>graphNEL</code> object, an <code>igraph</code> object, a sparse or a dense
adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The following specifications of undirected graphs are equivalent:
uG1 &lt;- ug(~ a:b:c + c:d)
uG2 &lt;- ug(c("a", "b", "c"), c("c", "d"))
uG3 &lt;- ug(c("a", "b"), c("a", "c"), c("b", "c"), c("c", "d"))

## The following specifications of directed acyclig graphs are equivalent:
daG1 &lt;- dag(~ a:b:c + b:c + c:d)
daG2 &lt;- dag(c("a", "b", "c"), c("b", "c"), c("c", "d"))

## dag() allows to specify directed graphs with cycles:
daG4 &lt;- dag(~ a:b + b:c + c:a) # A directed graph but with cycles

## A check for acyclicity can be done with
## daG5 &lt;- dag(~ a:b + b:c + c:a, forceCheck=TRUE) 

## A check for acyclicity is provided by topoSort
topo_sort( daG2 )
topo_sort( daG4 )

## Different representations
uG7 &lt;- ug(~a:b:c + c:d, result="igraph")    # igraph
uG8 &lt;- ug(~a:b:c + c:d, result="matrix")    # dense matrix
uG9 &lt;- ug(~a:b:c + c:d, result="dgCMatrix") # sparse matrix
</code></pre>

<hr>
<h2 id='graph-edgeList'>Find edges in a graph and edges not in a graph.</h2><span id='topic+graph-edgeList'></span><span id='topic+edgeList'></span><span id='topic+edgeListMAT'></span><span id='topic+nonEdgeList'></span><span id='topic+nonEdgeListMAT'></span>

<h3>Description</h3>

<p>Returns the edges of a graph (or edges not in a graph)
where the graph can be either a <code>graphNEL</code> object, an <code>igraph</code>
object or an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeList(object, matrix = FALSE)

edgeListMAT(adjmat, matrix = FALSE)

nonEdgeList(object, matrix = FALSE)

nonEdgeListMAT(adjmat, matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-edgeList_+3A_object">object</code></td>
<td>
<p>An <code>igraph</code> object, a dense
matrix or a sparse <code>dgCMatrix</code> (the two latter representing an
adjacency matrix).</p>
</td></tr>
<tr><td><code id="graph-edgeList_+3A_matrix">matrix</code></td>
<td>
<p>If TRUE the result is a matrix; otherwise the result
is a list.</p>
</td></tr>
<tr><td><code id="graph-edgeList_+3A_adjmat">adjmat</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## A graph with edges
g  &lt;- ug(~a:b + b:c + c:d)
gm &lt;- as(g, "matrix")
edgeList(g)
edgeList(gm)
edgeListMAT(gm)
edgeList(g, matrix=TRUE)
edgeList(gm, matrix=TRUE)
edgeListMAT(gm, matrix=TRUE)
nonEdgeList(g)
nonEdgeList(gm)
nonEdgeListMAT(gm)
## A graph without edges
g  &lt;- ug(~a + b + c)
gm &lt;- as(g, "matrix")
edgeList(g)
edgeList(gm)
edgeListMAT(gm)
edgeList(g, matrix=TRUE)
edgeList(gm, matrix=TRUE)
edgeListMAT(gm, matrix=TRUE)
nonEdgeList(g)
nonEdgeList(gm)
nonEdgeListMAT(gm)

</code></pre>

<hr>
<h2 id='graph-gcproperties'>Properties of a generating class (for defining a graph).</h2><span id='topic+graph-gcproperties'></span><span id='topic+isGraphical'></span><span id='topic+isGraphical.default'></span><span id='topic+isDecomposable.default'></span><span id='topic+isDecomposable'></span>

<h3>Description</h3>

<p>A set of generators define an undirected graph, here
called a dependence graph. Given a set of generators it is
checked 1) if the dependence dependence graph is in
1-1-correspondance with the genrators (such that the
corresponding model is graphical) and 2) if the dependence
graph is chordal (triangulated) (such that the corresponding
model is decomposable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isGraphical(x)

isDecomposable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-gcproperties_+3A_x">x</code></td>
<td>
<p>A generating class given as right hand sided formula or a
list; see <code>examples</code> below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of sets of variables, say A_1, A_2, ... A_K is
called a generating class for a graph with vertices V and edges
E. If two variables a,b are in the same generator, say A_j,
then a and b are vertices in the graph and there is an
undirected edge between a and b.
</p>
<div class="sourceCode"><pre>The graph induced by \code{g1 = ~a:b + a:c + b:c + c:d} has
edges \code{ab, ac, bc, cd}. The
cliques of this graph are \code{abc, cd}. Hence there is not a
1-1-correspondance between the graph and the generators.

On the other hand, \code{g2 &lt;- ~a:b:c + c:d} induces the same
graph in this case there is a 1-1-correspondance.

The graph induced by \code{g3 &lt;- ~a:b + b:c + c:d + d:a} is in
1-1-correspondance with its dependence graph, but the graph is
not chordal.
</pre></div>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcs">mcs</a></code>, <code><a href="#topic+rip">rip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- ~a:b + a:c + b:c + c:d
g2 &lt;- ~a:b:c + c:d
g3 &lt;- ~a:b + b:c + c:d + d:a

isGraphical( g1 ) # FALSE
isGraphical( g2 ) # TRUE
isGraphical( g3 ) # TRUE

isDecomposable( g1 ) # FALSE
isDecomposable( g2 ) # TRUE
isDecomposable( g3 ) # TRUE

## A generating class can be given as a list:
f &lt;- list(c("a","b"), c("b","c"), c("a","c"))
isGraphical( f )
isDecomposable( f )

</code></pre>

<hr>
<h2 id='graph-mcs'>Maximum cardinality search on undirected graph.</h2><span id='topic+graph-mcs'></span><span id='topic+mcs'></span><span id='topic+mcs.default'></span><span id='topic+mcsMAT'></span><span id='topic+mcs_marked'></span><span id='topic+mcs_marked.default'></span><span id='topic+mcs_markedMAT'></span>

<h3>Description</h3>

<p>Returns (if it exists) a perfect ordering of the
vertices in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs(object, root = NULL, index = FALSE)

## Default S3 method:
mcs(object, root = NULL, index = FALSE)

mcsMAT(amat, vn = colnames(amat), root = NULL, index = FALSE)

mcs_marked(object, discrete = NULL, index = FALSE)

## Default S3 method:
mcs_marked(object, discrete = NULL, index = FALSE)

mcs_markedMAT(amat, vn = colnames(amat), discrete = NULL, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-mcs_+3A_object">object</code></td>
<td>
<p>An undirected graph represented either as a
<code>graphNEL</code> object, an <code>igraph</code>, a (dense)
<code>matrix</code>, a (sparse) <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="graph-mcs_+3A_root">root</code></td>
<td>
<p>A vector of variables. The first variable in the
perfect ordering will be the first variable on 'root'. The
ordering of the variables given in 'root' will be followed as
far as possible.</p>
</td></tr>
<tr><td><code id="graph-mcs_+3A_index">index</code></td>
<td>
<p>If TRUE, then a permutation is returned</p>
</td></tr>
<tr><td><code id="graph-mcs_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
<tr><td><code id="graph-mcs_+3A_vn">vn</code></td>
<td>
<p>Nodes in the graph given by adjacency matrix</p>
</td></tr>
<tr><td><code id="graph-mcs_+3A_discrete">discrete</code></td>
<td>
<p>A vector indicating which of the nodes are
discrete. See 'details' for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An undirected graph is decomposable iff there exists a
perfect ordering of the vertices. The maximum cardinality
search algorithm returns a perfect ordering of the vertices if
it exists and hence this algorithm provides a check for
decomposability. The <code>mcs()</code> functions finds such an
ordering if it exists.
</p>
<div class="sourceCode"><pre>The notion of strong decomposability is used in connection with
e.g. mixed interaction models where some vertices represent
discrete variables and some represent continuous
variables. Such graphs are said to be marked. The
\code{mcsmarked()} function will return a perfect ordering iff
the graph is strongly decomposable. As graphs do not know about
whether vertices represent discrete or continuous variables,
this information is supplied in the \code{discrete} argument.
</pre></div>


<h3>Value</h3>

<p>A vector with a linear ordering (obtained by maximum
cardinality search) of the variables or character(0) if such an
ordering can not be created.
</p>


<h3>Note</h3>

<p>The workhorse is the <code>mcsMAT</code> function.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moralize">moralize</a></code>, <code><a href="#topic+junction_tree">junction_tree</a></code>,
<code><a href="#topic+rip">rip</a></code>, <code><a href="#topic+ug">ug</a></code>, <code><a href="#topic+dag">dag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
uG &lt;- ug(~ me:ve + me:al + ve:al + al:an + al:st + an:st)
mcs(uG)
mcsMAT(as(uG, "matrix"))
## Same as
uG &lt;- ug(~ me:ve + me:al + ve:al + al:an + al:st + an:st, result="matrix")
mcsMAT(uG)

## Marked graphs
uG1 &lt;- ug(~ a:b + b:c + c:d)
uG2 &lt;- ug(~ a:b + a:d + c:d)
## Not strongly decomposable:
mcs_marked(uG1, discrete=c("a","d"))
## Strongly decomposable:
mcs_marked(uG2, discrete=c("a","d"))

</code></pre>

<hr>
<h2 id='graph-min-triangulate'>Minimal triangulation of an undirected graph</h2><span id='topic+graph-min-triangulate'></span><span id='topic+minimal_triang'></span><span id='topic+minimal_triangMAT'></span>

<h3>Description</h3>

<p>An undirected graph uG is triangulated (or chordal) if
it has no cycles of length &gt;= 4 without a chord which is
equivalent to that the vertices can be given a perfect
ordering. Any undirected graph can be triangulated by adding
edges to the graph, so called fill-ins which gives the graph
TuG.  A triangulation TuG is minimal if no fill-ins can be
removed without breaking the property that TuG is triangulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal_triang(
  object,
  tobject = triangulate(object),
  result = NULL,
  details = 0
)

minimal_triangMAT(amat, tamat = triangulateMAT(amat), details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-min-triangulate_+3A_object">object</code></td>
<td>
<p>An undirected graph represented either as a <code>graphNEL</code>
object, a (dense) <code>matrix</code>, a (sparse) <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="graph-min-triangulate_+3A_tobject">tobject</code></td>
<td>
<p>Any triangulation of <code>object</code>; must be of the same
representation.</p>
</td></tr>
<tr><td><code id="graph-min-triangulate_+3A_result">result</code></td>
<td>
<p>The type (representation) of the result. Possible values are
<code>"graphNEL"</code>, <code>"matrix"</code>, <code>"dgCMatrix"</code>. Default is the
same as the type of <code>object</code>.</p>
</td></tr>
<tr><td><code id="graph-min-triangulate_+3A_details">details</code></td>
<td>
<p>The amount of details to be printed.</p>
</td></tr>
<tr><td><code id="graph-min-triangulate_+3A_amat">amat</code></td>
<td>
<p>The undirected graph which is to be triangulated; a symmetric
adjacency matrix.</p>
</td></tr>
<tr><td><code id="graph-min-triangulate_+3A_tamat">tamat</code></td>
<td>
<p>Any triangulation of <code>object</code>; a symmetric adjacency
matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given triangulation tobject it may be so that some
of the fill-ins are superflous in the sense that they can be
removed from tobject without breaking the property that tobject
is triangulated. The graph obtained by doing so is a minimal
triangulation.
</p>
<div class="sourceCode"><pre>Notice: A related concept is the minimum
triangulation, which is the the graph with the smallest number
of fill-ins. The minimum triangulation is unique. Finding the
minimum triangulation is NP-hard.
</pre></div>


<h3>Value</h3>

<p><code>minimal_triang()</code> returns a graphNEL object while
<code>minimal_triangMAT()</code> returns an adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>Clive Bowsher <a href="mailto:C.Bowsher@statslab.cam.ac.uk">C.Bowsher@statslab.cam.ac.uk</a> with modifications by
Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Kristian G. Olesen and Anders L. Madsen (2002): Maximal Prime
Subgraph Decomposition of Bayesian Networks. IEEE TRANSACTIONS ON
SYSTEMS, MAN AND CYBERNETICS, PART B: CYBERNETICS, VOL. 32, NO. 1,
FEBRUARY 2002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpd">mpd</a></code>, <code><a href="#topic+rip">rip</a></code>, <code><a href="#topic+triangulate">triangulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## An igraph object
g1 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + a:f + b:e, result="igraph")
x &lt;- minimal_triang(g1)

tt &lt;- ug(~a:b:e:f + b:e:c:d, result="igraph")
x &lt;- minimal_triang(g1, tobject=tt)

## g2 is a triangulation of g1 but it is not minimal
g2 &lt;- ug(~a:b:e:f + b:c:d:e, result="igraph")
x &lt;- minimal_triang(g1, tobject=g2)

## An adjacency matrix
g1m &lt;- ug(~a:b + b:c + c:d + d:e + e:f + a:f + b:e, result="matrix")
x &lt;- minimal_triangMAT(g1m)

</code></pre>

<hr>
<h2 id='graph-moralize'>Moralize a directed acyclic graph</h2><span id='topic+graph-moralize'></span><span id='topic+moralize'></span><span id='topic+moralize.default'></span><span id='topic+moralizeMAT'></span>

<h3>Description</h3>

<p>Moralize a directed acyclic graph which means marrying
parents and dropping directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moralize(object, ...)

## Default S3 method:
moralize(object, result = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-moralize_+3A_object">object</code></td>
<td>
<p>A directed acyclic graph represented either as a
<code>graphNEL</code> object, an <code>igraph</code>, a (dense)
<code>matrix</code>, a (sparse) <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="graph-moralize_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used</p>
</td></tr>
<tr><td><code id="graph-moralize_+3A_result">result</code></td>
<td>
<p>The representation of the moralized graph.  When NULL
the representation will be the same as the input object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A moralized graph represented either as a <code>graphNEL</code>, a
dense <code>matrix</code> or a sparse <code>dgCMatrix</code>.
</p>


<h3>Note</h3>

<p>The workhorse is the <code>moralizeMAT</code> function.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcs">mcs</a></code>, <code><a href="#topic+junction_tree">junction_tree</a></code>, <code><a href="#topic+rip">rip</a></code>,
<code><a href="#topic+ug">ug</a></code>, <code><a href="#topic+dag">dag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daG &lt;- dag(~me+ve,~me+al,~ve+al,~al+an,~al+st,~an+st)
moralize(daG)

daG &lt;- dag(~me+ve,~me+al,~ve+al,~al+an,~al+st,~an+st, result="matrix")
moralizeMAT(daG)

if (require(igraph)){
M &lt;- matrix(c(1,2,3,3), nrow=2)
G &lt;- graph.edgelist(M)
G
V(G)$name
moralize(G)
}

</code></pre>

<hr>
<h2 id='graph-mpd'>Maximal prime subgraph decomposition</h2><span id='topic+graph-mpd'></span><span id='topic+mpd'></span><span id='topic+mpd.default'></span><span id='topic+mpdMAT'></span>

<h3>Description</h3>

<p>Finding a junction tree representation of the MPD
(maximal prime subgraph decomposition) of an undirected graph
The maximal prime subgraph decomposition of a graph is the
smallest subgraphs into which the graph can be decomposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpd(object, tobject = minimal_triang(object), details = 0)

## Default S3 method:
mpd(object, tobject = triangulate(object), details = 0)

mpdMAT(amat, tamat = minimal_triangMAT(amat), details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-mpd_+3A_object">object</code></td>
<td>
<p>An undirected graph; a graphNEL object, an igraph or
an adjacency matrix.</p>
</td></tr>
<tr><td><code id="graph-mpd_+3A_tobject">tobject</code></td>
<td>
<p>Any minimal triangulation of object; a graphNEL
object, an igraph or an adjacency matrix.</p>
</td></tr>
<tr><td><code id="graph-mpd_+3A_details">details</code></td>
<td>
<p>The amount of details to be printed.</p>
</td></tr>
<tr><td><code id="graph-mpd_+3A_amat">amat</code></td>
<td>
<p>An undirected graph; a symmetric adjacency matrix</p>
</td></tr>
<tr><td><code id="graph-mpd_+3A_tamat">tamat</code></td>
<td>
<p>Any minimal triangulation of object; a symmetric
adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components &quot;nodes&quot;, &quot;cliques&quot;, &quot;separators&quot;,
&quot;parents&quot;, &quot;children&quot;, &quot;nLevels&quot;. The component &quot;cliques&quot;
defines the subgraphs.
</p>


<h3>Author(s)</h3>

<p>Clive Bowsher <a href="mailto:C.Bowsher@statslab.cam.ac.uk">C.Bowsher@statslab.cam.ac.uk</a> with
modifications by Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Kristian G. Olesen and Anders L. Madsen (2002): Maximal Prime
Subgraph Decomposition of Bayesian Networks. IEEE TRANSACTIONS ON
SYSTEMS, MAN AND CYBERNETICS, PART B: CYBERNETICS, VOL. 32, NO. 1,
FEBRUARY 2002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcs">mcs</a></code>, <code><a href="#topic+mcsMAT">mcsMAT</a></code>,
<code><a href="#topic+minimal_triang">minimal_triang</a></code>, <code><a href="#topic+minimal_triangMAT">minimal_triangMAT</a></code>,
<code><a href="#topic+rip">rip</a></code>, <code><a href="#topic+ripMAT">ripMAT</a></code>, <code><a href="#topic+triangulate">triangulate</a></code>,
<code><a href="#topic+triangulateMAT">triangulateMAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Maximal prime subgraph decomposition - a graphNEL object
g1 &lt;- ug(~ a:b + b:c + c:d + d:e + e:f + a:f + b:e)
if (interactive()) plot(g1)
x &lt;- mpd(g1)

## Maximal prime subgraph decomposition - an adjacency matrix
g1m &lt;- ug(~ a:b + b:c + c:d + d:e + e:f + a:f + b:e, result="matrix")
if (interactive()) plot(as(g1m, "graphNEL"))
x &lt;- mpdMAT(g1m)

</code></pre>

<hr>
<h2 id='graph-randomdag'>Random directed acyclic graph</h2><span id='topic+graph-randomdag'></span><span id='topic+random_dag'></span>

<h3>Description</h3>

<p>Generate a random directed acyclic graph (DAG)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_dag(V, maxpar = 3, wgt = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-randomdag_+3A_v">V</code></td>
<td>
<p>The set of vertices.</p>
</td></tr>
<tr><td><code id="graph-randomdag_+3A_maxpar">maxpar</code></td>
<td>
<p>The maximum number of parents each node can have</p>
</td></tr>
<tr><td><code id="graph-randomdag_+3A_wgt">wgt</code></td>
<td>
<p>A parameter controlling how likely it is for a node to
have a certain number of parents; see 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the maximum number of parents for a node is, say 3 and
wgt=0.1, then the probability of the node ending up with
0,1,2,3 parents is proportional to 0.1^0, 0.1^1, 0.1^2, 0.1^3.
</p>


<h3>Value</h3>

<p>An igraph object.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dg   &lt;- random_dag(1:1000, maxpar=5, wgt=.9)
table(sapply(vpar(dg),length))

dg   &lt;- random_dag(1:1000, maxpar=5, wgt=.5)
table(sapply(vpar(dg),length))

dg   &lt;- random_dag(1:1000, maxpar=5, wgt=.1)
table(sapply(vpar(dg),length))

</code></pre>

<hr>
<h2 id='graph-rip'>Create RIP ordering of the cliques of  an undirected graph;
create junction tree.</h2><span id='topic+graph-rip'></span><span id='topic+rip'></span><span id='topic+rip.default'></span><span id='topic+ripMAT'></span><span id='topic+junction_tree'></span><span id='topic+junction_tree.default'></span><span id='topic+junction_treeMAT'></span><span id='topic+jTree'></span><span id='topic+junctionTree'></span>

<h3>Description</h3>

<p>A RIP (running intersection property) ordering of the
cliques is also called a perfect ordering. If the graph is not
chordal, then no such ordering exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rip(object, ...)

## Default S3 method:
rip(object, root = NULL, nLevels = NULL, ...)

ripMAT(amat, root = NULL, nLevels = rep(2, ncol(amat)))

junction_tree(object, ...)

## Default S3 method:
junction_tree(object, nLevels = NULL, ...)

junction_treeMAT(amat, nLevels = rep(2, ncol(amat)), ...)

jTree(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-rip_+3A_object">object</code></td>
<td>
<p>An undirected graph represented either as a
<code>graphNEL</code> object, an <code>igraph</code>, a (dense)
<code>matrix</code>, a (sparse) <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="graph-rip_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used</p>
</td></tr>
<tr><td><code id="graph-rip_+3A_root">root</code></td>
<td>
<p>A vector of variables. The first variable in the
perfect ordering will be the first variable on 'root'. The
ordering of the variables given in 'root' will be followed as
far as possible.</p>
</td></tr>
<tr><td><code id="graph-rip_+3A_nlevels">nLevels</code></td>
<td>
<p>Typically, the number of levels of the variables
(nodes) when these are discrete. Used in determining the
triangulation using a &quot;minimum clique weight heuristic&quot;. See
section 'details'.</p>
</td></tr>
<tr><td><code id="graph-rip_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RIP ordering of the cliques of a decomposable
(i.e. chordal) graph is obtained by first ordering the
variables linearly with maximum cardinality search (by
<code>mcs</code>). The root argument is transfered to <code>mcs</code> as a
way of controlling which clique will be the first in the RIP
ordering.  The <code>junction_tree()</code> (and
<code>junction_tree()</code>) (for &quot;junction tree&quot;) is just a wrapper
for a call of <code>triangulate()</code> followed by a call of
<code>rip()</code>.
</p>


<h3>Value</h3>

<p><code>rip</code> returns a list (an object of class
<code>ripOrder</code>. A print method exists for such objects.)
</p>


<h3>Synonymous functions</h3>

<p>For backward compatibility with downstream packages we have the
following synonymous functions:
</p>

<ul>
<li><p> jTree = junction_tree (Used in rags2ridges)
</p>
</li>
<li><p> junctionTree = junction_tree
</p>
</li></ul>



<h3>Note</h3>

<p>The workhorse is the <code>ripMAT()</code> function. The
<code>nLevels</code> argument to the <code>rip</code> functions has no
meaning.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcs">mcs</a></code>, <code><a href="#topic+triangulate">triangulate</a></code>,
<code><a href="#topic+moralize">moralize</a></code>, <code><a href="#topic+ug">ug</a></code>, <code><a href="#topic+dag">dag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## graphNEL
uG &lt;- ug(~me:ve + me:al + ve:al + al:an + al:st + an:st)
mcs(uG)
rip(uG)
junction_tree(uG)

## Adjacency matrix
uG &lt;- ug(~me:ve:al + al:an:st, result="matrix")
mcs(uG)
rip(uG)
junction_tree(uG)

## Sparse adjacency matrix
uG &lt;- ug(c("me", "ve", "al"), c("al", "an", "st"), result="dgCMatrix")
mcs(uG)
rip(uG)
junction_tree(uG)

## Non--decomposable graph
uG &lt;- ug(~1:2 + 2:3 + 3:4 + 4:5 + 5:1)
mcs(uG)
rip(uG)
junction_tree(uG)


</code></pre>

<hr>
<h2 id='graph-triangulate'>Triangulation of an undirected graph</h2><span id='topic+graph-triangulate'></span><span id='topic+triangulate'></span><span id='topic+triangulate.default'></span><span id='topic+triangulateMAT'></span><span id='topic+triang_mcwh'></span><span id='topic+triang_elo'></span><span id='topic+triang'></span><span id='topic+triang.default'></span><span id='topic+triang_mcwh.default'></span><span id='topic+triang_elo.default'></span><span id='topic+triang_mcwhMAT_'></span><span id='topic+triang_eloMAT_'></span><span id='topic+triang_eloMAT'></span>

<h3>Description</h3>

<p>This function will triangulate an undirected graph by
adding fill-ins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate(object, ...)

## Default S3 method:
triangulate(object, nLevels = NULL, result = NULL, check = TRUE, ...)

triang_mcwh(object, ...)

triang_elo(object, ...)

triang(object, ...)

## Default S3 method:
triang(object, control = list(), ...)

## Default S3 method:
triang_mcwh(object, nLevels = NULL, result = NULL, check = TRUE, ...)

## Default S3 method:
triang_elo(object, order = NULL, result = NULL, check = TRUE, ...)

triangulateMAT(amat, nLevels = rep(2, ncol(amat)), ...)

triang_mcwhMAT_(amat, nLevels = rep(2, ncol(amat)), ...)

triang_eloMAT_(amat, order)

triang_eloMAT(amat, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph-triangulate_+3A_object">object</code></td>
<td>
<p>An undirected graph represented either as a <code>graphNEL</code>
object, an <code>igraph</code>, a (dense) <code>matrix</code>, a (sparse)
<code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_nlevels">nLevels</code></td>
<td>
<p>The number of levels of the variables (nodes) when these are
discrete. Used in determining the triangulation using a
&quot;minimum clique weight heuristic&quot;. See section 'details'.</p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_result">result</code></td>
<td>
<p>The type (representation) of the result. Possible values are
<code>"graphNEL"</code>, <code>"igraph"</code>, <code>"matrix"</code>, <code>"dgCMatrix"</code>.
Default is the same as the type of <code>object</code>.</p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_check">check</code></td>
<td>
<p>If <code>TRUE</code> (the default) it is checked whether the graph is
triangulated before doing the triangulation; gives a speed up if <code>FALSE</code></p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_control">control</code></td>
<td>
<p>A list controlling the triangulation; see 'examples'.</p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_order">order</code></td>
<td>
<p>Elimation order; a character vector or numeric vector.</p>
</td></tr>
<tr><td><code id="graph-triangulate_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix; a (dense) <code>matrix</code>, or a (sparse)
<code>dgCMatrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two type of functions: <code>triang</code> and <code>triangulate</code>
</p>
<p>The workhorse is the <code>triangulateMAT</code> function.
</p>
<p>The triangulation is made so as the total state space is kept low
by applying a minimum clique weight heuristic: When a fill-in is
necessary, the algorithm will search for an edge to add such that
the complete set to be formed will have as small a state-space as
possible. It is in this connection that the <code>nLevels</code> values
are used.
</p>
<p>Default (when <code>nLevels=NULL</code>) is to take <code>nLevels=2</code> for all
nodes. If <code>nLevels</code> is the same for all nodes then the heuristic aims
at keeping the clique sizes small.
</p>


<h3>Value</h3>

<p>A triangulated graph represented either as a <code>graphNEL</code>, a
(dense) <code>matrix</code> or a (sparse) <code>dgCMatrix</code>.
</p>


<h3>Note</h3>

<p>Care should be taken when specifying <code>nLevels</code> for other
representations than adjacency matrices: Since the <code>triangulateMAT</code>
function is the workhorse, any other representation is transformed to an
adjacency matrix and the order of values in <code>nLevels</code> most come in
the order of the nodes in the adjacency matrix representation.
</p>
<p>Currently there is no check for that the graph is undirected.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ug">ug</a></code>, <code><a href="#topic+dag">dag</a></code>, <code><a href="#topic+mcs">mcs</a></code>,
<code><a href="#topic+mcsMAT">mcsMAT</a></code>, <code><a href="#topic+rip">rip</a></code>, <code><a href="#topic+ripMAT">ripMAT</a></code>,
<code><a href="#topic+moralize">moralize</a></code>, <code><a href="#topic+moralizeMAT">moralizeMAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## graphNEL
uG1 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a)
uG2 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="matrix")
uG3 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="dgCMatrix")

## Default triangulation: minimum clique weight heuristic
# (default is that each node is given the same weight):

tuG1 &lt;- triang(uG1)
## Same as
triang_mcwh(uG1)

## Alternative: Triangulation from a desired elimination order
# (default is that the order is order of the nodes in the graph):

triang(uG1, control=list(method="elo"))
## Same as:
triang_elo(uG1)

## More control: Define the number of levels for each node:
tuG1 &lt;- triang(uG1, control=list(method="mcwh", nLevels=c(2, 3, 2, 6, 4, 9))) 
tuG1 &lt;- triang_mcwh(uG1, nLevels=c(2, 3, 2, 6, 4, 9))

tuG1 &lt;- triang(uG1, control=list(method="elo", order=c("a", "e", "f")))
tuG1 &lt;- triang_elo(uG1, order=c("a", "e", "f"))

## graphNEL
uG1 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a)
tuG1 &lt;- triangulate(uG1)

## adjacency matrix
uG2 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="matrix")
tuG2 &lt;- triangulate(uG2)

## adjacency matrix (sparse)
uG2 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="dgCMatrix")
tuG2 &lt;- triangulate(uG2)

</code></pre>

<hr>
<h2 id='gRbase'>
The package &lsquo;gRbase&rsquo;: summary information
</h2><span id='topic+gRbase'></span>

<h3>Description</h3>

<p>This package provides a basis for graphical modelling in R and in
particular for other graphical modelling packages, most notably
<span class="pkg">gRim</span>, <span class="pkg">gRain</span> and <span class="pkg">gRc</span>.
</p>


<h3>Details</h3>

<p><span class="pkg">gRbase</span> provides the following:
</p>

<ul>
<li><p> Implementation of various graph algorithms, including maximum
cardinality search, maximal prime subgraph decomposition,
triangulation. See the vignette <code>graphs</code>.
</p>
</li>
<li><p> Implementation of various &quot;high level&quot; array operations, including
multiplication/division, marginalization, slicing, permutation. See
the vignette <code>ArrayOps</code>.
</p>
</li>
<li><p> Implementation of various &quot;low level&quot; array operations. See
the vignette <code>ArrayOpsPrim</code>. 
</p>
</li>
<li><p> A collection of datasets
</p>
</li>
<li><p> A general framework for setting up data and model structures
and provide examples for fitting hierarchical log linear 
models for contingency tables and graphical Gaussian models for the
multivariate normal distribution. (Notice: This last part is not maintained / developed further.)
</p>
</li></ul>



<h3>Authors</h3>

<p>Soren Hojsgaard, Department of Mathematical Sciences, Aalborg
University, Denmark
</p>
<p>Contributions from Claus Dethlefsen, Clive  Bowsher, David Edwards.
</p>


<h3>Acknowledgements</h3>

<p>Thanks to the other members of the gR initiative, in particular to
David Edwards for providing functions for formula-manipulation.
</p>


<h3>References</h3>

<p>Hojsgaard, S., Edwards, D., Lauritzen, S. (2012) Graphical models with
R. Springer. ISBN: 978-1-4614-2298-3
</p>
<p>Lauritzen, S. L. (2002). gRaphical Models in R.
<em>R News</em>, 3(2)39.
</p>

<hr>
<h2 id='grbase_generics'>Compile and propagate functions</h2><span id='topic+grbase_generics'></span><span id='topic+fit'></span><span id='topic+compile'></span><span id='topic+propagate'></span><span id='topic+stepwise'></span>

<h3>Description</h3>

<p><code>compile</code> and <code>propagate</code> are generic
functions which invoke particular methods which depend on the
class of the first argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(object, ...)

compile(object, ...)

propagate(object, ...)

stepwise(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grbase_generics_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="grbase_generics_+3A_...">...</code></td>
<td>
<p>Additional arguments which depends on the class of the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the first argument.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Højsgaard, Søren; Edwards, David; Lauritzen, Steffen (2012):
Graphical Models with R, Springer
</p>

<hr>
<h2 id='grbase-utilities'>gRbase utilities</h2><span id='topic+grbase-utilities'></span><span id='topic+rhsFormula2list'></span><span id='topic+matrix2list'></span><span id='topic+rowmat2list'></span><span id='topic+colmat2list'></span><span id='topic+pairs2num'></span><span id='topic+rhsf2list'></span><span id='topic+rhsf2vec'></span><span id='topic+listify_dots'></span><span id='topic+list2rhsFormula'></span><span id='topic+list2rhsf'></span><span id='topic+which.arr.index'></span><span id='topic+which_matrix_index'></span><span id='topic+rowSumsPrim'></span><span id='topic+colSumsPrim'></span><span id='topic+colwiseProd'></span><span id='topic+lapplyV2I'></span><span id='topic+lapplyI2V'></span>

<h3>Description</h3>

<p>Various utility functions for gRbase. Includes 'faster
versions' of certain standard R functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhsFormula2list(form)

rhsf2list(form)

rhsf2vec(form)

listify_dots(dots)

list2rhsFormula(form)

list2rhsf(form)

rowmat2list(X)

colmat2list(X)

matrix2list(X, byrow = TRUE)

which.arr.index(X)

which_matrix_index(X)

rowSumsPrim(X)

colSumsPrim(X)

colwiseProd(v, X)

lapplyV2I(setlist, item)

lapplyI2V(setlist, item)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grbase-utilities_+3A_form">form</code></td>
<td>
<p>Formula specification (a right-hand sided formula, a
numeric/character vector or a list of vectors).</p>
</td></tr>
<tr><td><code id="grbase-utilities_+3A_dots">dots</code></td>
<td>
<p>dot-arguments to be turned into a list</p>
</td></tr>
<tr><td><code id="grbase-utilities_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="grbase-utilities_+3A_byrow">byrow</code></td>
<td>
<p>Should the split be by row or by column.</p>
</td></tr>
<tr><td><code id="grbase-utilities_+3A_v">v</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="grbase-utilities_+3A_setlist">setlist</code></td>
<td>
<p>A list of atomic vectors</p>
</td></tr>
<tr><td><code id="grbase-utilities_+3A_item">item</code></td>
<td>
<p>An atomic vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>which.arr.ind</code>: Returns matrix n x 2 matrix with
indices of non-zero entries in matrix <code>X</code>. Notice
<code>which_matrix_index__</code> is cpp implementation.
</p>
<p><code>colwiseProd</code>: multiplies a vector v and a matrix X
columnwise (as opposed to rowwise which is achieved by
<code>v * X</code>). Hence <code>colwiseProd</code> does the same as
<code>t(v * t(X))</code> - but it does so faster for numeric values.
</p>

<ul>
<li><p> lapplyV2I: same as but much faster than <code>lapply(setlist, function(elt) match(elt, item))</code>
</p>
</li>
<li><p> lapplyI2V: same as but faster than <code>lapply(setlist, function(elt) item[elt])</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## colwiseProd
X &lt;- matrix(1:16, nrow=4)
v &lt;- 1:4
t(v * t(X))
colwiseProd(v, X)
## Not run: 
system.time(for (ii in 1:100000)  t(v * t(X)))
system.time(for (ii in 1:100000)  colwiseProd(v, X))

## End(Not run)


setlist &lt;- list(c(1,2,3), c(2,3,4), c(2,4,5))
item &lt;- c(2,3)

lapplyV2I(setlist, item)
lapply(setlist, function(gg) match(gg, item))

lapplyI2V(setlist, item)
lapply(setlist, function(x) item[x])

if (require(microbenchmark)){
microbenchmark(
  lapplyV2I(setlist, item),
  lapply(setlist, function(elt) match(elt, item)))

microbenchmark::microbenchmark(
  lapplyI2V(setlist, item),
  lapply(setlist, function(elt) item[elt]))
}
</code></pre>

<hr>
<h2 id='internal'>Internal functions for the gRbase package</h2><span id='topic+internal'></span><span id='topic+ggm'></span><span id='topic++25+3E+25'></span><span id='topic+MAT2ftM_'></span><span id='topic+isGSD_glist'></span><span id='topic+solveSPD'></span><span id='topic+randomGraph'></span><span id='topic+addEdge.gModel'></span><span id='topic+dropEdge.gModel'></span><span id='topic+extract.power'></span><span id='topic+processFormula'></span><span id='topic+selectOrder'></span><span id='topic+symMAT2ftM_'></span><span id='topic+setdiffPrim'></span><span id='topic+unlistPrim'></span><span id='topic+intersectPrim'></span><span id='topic+outerPrim'></span><span id='topic+uniquePrim'></span><span id='topic+matchPrim'></span>

<h3>Description</h3>

<p>These functions are not intended to be called directly.
</p>

<hr>
<h2 id='prostate'>Prostate Tumor Gene Expression Dataset</h2><span id='topic+prostate'></span>

<h3>Description</h3>

<p>This is the Prostate Tumor Gene Expression dataset used in Chung and Keles (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(prostate) </code></pre>


<h3>Format</h3>

<p>A list with two components:
</p>

<dl>
<dt>x</dt><dd><p> Gene expression data. A matrix with 102 rows and 6033 columns.</p>
</dd>
<dt>y</dt><dd><p> Class index. A vector with 102 elements.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The prostate dataset consists of 52 prostate tumor and 50 normal samples.
Normal and tumor classes are coded in 0 and 1, respectively, in <code>y</code> vector.
Matrix <code>x</code> is gene expression data and
arrays were normalized, log transformed, and standardized 
to zero mean and unit variance across genes as described
in Dettling (2004) and Dettling and Beuhlmann (2002).
See Chung and Keles (2010) for more details. 
</p>


<h3>Source</h3>

<p>Singh D, Febbo P, Ross K, Jackson D, Manola J, Ladd C, Tamayo P, Renshaw A,
DAmico A, Richie J, Lander E, Loda M, Kantoff P, Golub T, and Sellers W (2002),
&quot;Gene expression correlates of clinical prostate cancer behavior&quot;, <em>Cancer Cell</em>, 
Vol. 1, pp. 203&ndash;209.
</p>


<h3>References</h3>

<p>Chung D and Keles S (2010), 
&quot;Sparse partial least squares classification for high dimensional data&quot;,
<em>Statistical Applications in Genetics and Molecular Biology</em>, Vol. 9, Article 17.
</p>
<p>Dettling M (2004), &quot;BagBoosting for tumor classification with gene expression data&quot;,
<em>Bioinformatics</em>, Vol. 20, pp. 3583&ndash;3593.
</p>
<p>Dettling M and Beuhlmann P (2002), &quot;Supervised clustering of genes&quot;, <em>Genome Biology</em>,
Vol. 3, pp. research0069.1&ndash;0069.15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(prostate)
prostate$x[1:5,1:5]
prostate$y
</code></pre>

<hr>
<h2 id='set-operations'>Suite of set operations</h2><span id='topic+set-operations'></span><span id='topic+maximal_sets'></span><span id='topic+minimal_sets'></span><span id='topic+remove_redundant'></span><span id='topic+is_inset'></span><span id='topic+filter_maximal_vectors'></span><span id='topic+get_subset'></span><span id='topic+get_superset'></span><span id='topic+is_subsetof'></span><span id='topic+is.subsetof'></span><span id='topic+subsetof'></span>

<h3>Description</h3>

<p>Set operations for gRbase and related packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximal_sets(setlist, index = FALSE)

minimal_sets(setlist, index = FALSE)

remove_redundant(setlist, maximal = TRUE, index = FALSE)

is_inset(x, setlist, index = FALSE)

filter_maximal_vectors(setlist, index = FALSE)

get_subset(x, setlist, all = FALSE)

get_superset(x, setlist, all = FALSE)

is_subsetof(set, set2)

is.subsetof(x, set)

subsetof(x, set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set-operations_+3A_setlist">setlist</code></td>
<td>
<p>List of vectors (representing a set of subsets)</p>
</td></tr>
<tr><td><code id="set-operations_+3A_index">index</code></td>
<td>
<p>Logical; should indices (in setlist) be returned or a
set of subsets.</p>
</td></tr>
<tr><td><code id="set-operations_+3A_maximal">maximal</code></td>
<td>
<p>Logical; see section 'Details' for a description.</p>
</td></tr>
<tr><td><code id="set-operations_+3A_x">x</code>, <code id="set-operations_+3A_set">set</code>, <code id="set-operations_+3A_set2">set2</code></td>
<td>
<p>Vector representing a set.</p>
</td></tr>
<tr><td><code id="set-operations_+3A_all">all</code></td>
<td>
<p>Logical; see section 'Details' for a description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'setlist' is a list of vectors representing a set of subsets;
i.e. V1,...VQ where Vk is a subset of some base set V.
</p>
<p>'all' If true, <code>get_superset</code> will return index of all
vectors containing the element; otherwise only the first index is
returned.
</p>
<p><code>is_inset</code>: Checks if the set
x is in one of the Vk's.
</p>
<p><code>remove_redundant</code>: Returns those Vk which are not contained
in other subsets; i.e. gives the maximal sets. If maximal is FALSE
then returns the minimal sets; i.e. Vk is returned if Vk is
contained in one of the other sets Vl and there are no set Vn
contained in Vk.
</p>
<p>Notice that the comparisons are made by turning the elements into
characters and then comparing these. Hence 1 is identical to &quot;1&quot;.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set &lt;- list(c(1, 2), c(1, 2, 3), c(2, 3, 6), c(2, 4), c(5, 6), 5)            
                                                            
el1 &lt;- c(2, 1)                                               
el2 &lt;- c(2, 3)                                               
el3 &lt;- c(4, 3)                                               
el4 &lt;- c(2, 1, 3)                                             
                                                            
maximal_sets(set)                                           
minimal_sets(set)                                           
                                                            
remove_redundant(set)                                       
remove_redundant(set, maximal=FALSE)                        
                                                            
is_inset(el1, set)                                          
is_inset(el2, set)                                          
is_inset(el3, set)                                          
                                                            
get_subset(el1, set)
get_subset(el1, set)                                        
get_subset(el2, set)                                        
get_subset(el3, set)                                        

get_superset(el1, set)                                      
get_superset(el1, set, all=TRUE)                                      
get_superset(el2, set)                                      
get_superset(el3, set)

is_subsetof(el1, el1)                                       
is_subsetof(el1, el2)                                       
is_subsetof(el1, el4)

</code></pre>

<hr>
<h2 id='ug2dag'>Coerce between undirected and directed graphs when possible</h2><span id='topic+ug2dag'></span>

<h3>Description</h3>

<p>An undirected graph G can be converted to a dag if G
is chordal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ug2dag(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ug2dag_+3A_object">object</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
