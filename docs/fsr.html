<!DOCTYPE html><html><head><title>Help for package fsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_tibble.pgeometry'><p>Convert a <code>pgeometry</code> object into tabular data (<code>data.frame</code> or <code>tibble</code>)</p></a></li>
<li><a href='#component-class'><p>An S4 Class for representing a component of a spatial plateau object</p></a></li>
<li><a href='#create_empty_pgeometry'><p>Create an empty <code>pgeometry</code> object</p></a></li>
<li><a href='#create_pgeometry'><p>Create a <code>pgeometry</code> object with components</p></a></li>
<li><a href='#fsi_add_cs'><p>Add the consequent to an FSI model</p></a></li>
<li><a href='#fsi_add_fsa'><p>Add an antecedent to an FSI model</p></a></li>
<li><a href='#fsi_add_rules'><p>Add fuzzy rules to an FSI model</p></a></li>
<li><a href='#fsi_create'><p>Create an empty fuzzy spatial inference model</p></a></li>
<li><a href='#fsi_eval'><p>Evaluate a point inference query</p></a></li>
<li><a href='#fsi_qw_eval'><p>Evaluate region inference methods</p></a></li>
<li><a href='#fsr_components'><p>Create a component</p></a></li>
<li><a href='#fsr_diff_operators'><p>Compute fuzzy difference operators</p></a></li>
<li><a href='#fsr_eval_modes'><p>Evaluate a membership degree</p></a></li>
<li><a href='#fsr_filter_operations'><p>Return a crisp spatial object formed by geometric parts of a <code>pgeometry</code> object</p></a></li>
<li><a href='#fsr_geometric_operations'><p>Compute fuzzy geometric set operations</p></a></li>
<li><a href='#fsr_numerical_operations'><p>Compute fuzzy numerical operations</p></a></li>
<li><a href='#fsr_topological_relationships'><p>Compute fuzzy topological relationships</p></a></li>
<li><a href='#pcollection_to_pcomposition'><p>Convert a plateau collection object into a plateau composition object</p></a></li>
<li><a href='#pcollection-class'><p>An S4 Class for representing plateau collections (subclass of <code>pgeometry</code>)</p></a></li>
<li><a href='#pcomposition-class'><p>An S4 Class for representing plateau compositions (subclass of <code>pgeometry</code>)</p></a></li>
<li><a href='#pgeometry-class'><p>An S4 Class for representing spatial plateau data types</p></a></li>
<li><a href='#pline-class'><p>An S4 Class for representing plateau lines (subclass of <code>pgeometry</code>)</p></a></li>
<li><a href='#plot'><p>Graphically visualize <code>pgeometry</code> objects</p></a></li>
<li><a href='#ppoint-class'><p>An S4 Class for representing plateau points (subclass of <code>pgeometry</code>)</p></a></li>
<li><a href='#pregion-class'><p>An S4 Class for representing plateau regions (subclass of <code>pgeometry</code>)</p></a></li>
<li><a href='#PWKT'><p>Return PWKT representation of a spatial plateau object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#spa_add_component'><p>Add components to a <code>pgeometry</code> object</p></a></li>
<li><a href='#spa_boundary'><p>Capture the fuzzy boundary of a spatial plateau object</p></a></li>
<li><a href='#spa_boundary_pregion'><p>Capture the fuzzy boundary of a plateau region object</p></a></li>
<li><a href='#spa_contour'><p>Capture the frontier of a plateau region object</p></a></li>
<li><a href='#spa_core'><p>Get the core of a <code>pgeometry</code> object</p></a></li>
<li><a href='#spa_creator'><p>Build <code>pgeometry</code> objects from a point dataset</p></a></li>
<li><a href='#spa_eval'><p>Evaluate the membership degree of a point in a <code>pgeometry</code> object</p></a></li>
<li><a href='#spa_exact_equal'><p>Check two spatial plateau objects for exact equality</p></a></li>
<li><a href='#spa_exact_inside'><p>Check two spatial plateau objects for exact containment</p></a></li>
<li><a href='#spa_flatten'><p>Flatten a plateau collection object</p></a></li>
<li><a href='#spa_get_type'><p>Get the type of a spatial plateau object</p></a></li>
<li><a href='#spa_is_empty'><p>Check if a <code>pgeometry</code> object is empty</p></a></li>
<li><a href='#spa_set_classification'><p>Set a new classification for fuzzy topological relationships</p></a></li>
<li><a href='#spa_support'><p>Get the support of a <code>pgeometry</code> object</p></a></li>
<li><a href='#visitation'><p>Visitation: An example of FSI model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handling Fuzzy Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://accarniel.github.io/fsr/">https://accarniel.github.io/fsr/</a>, <a href="https://github.com/accarniel/fsr">https://github.com/accarniel/fsr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/accarniel/fsr/issues">https://github.com/accarniel/fsr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.4.11), methods (&ge; 2.0.0), sf (&ge; 1.0.15), dplyr
(&ge; 1.0.6), ggplot2 (&ge; 3.3.5), stringr (&ge; 1.4.0), tibble (&ge;
3.0.1), pso (&ge; 1.0.3), e1071 (&ge; 1.7.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lwgeom (&ge; 0.2.6)</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for fuzzy spatial objects, their operations, and fuzzy spatial inference models based on Spatial Plateau Algebra. 
    It employs fuzzy set theory and fuzzy logic as foundation to deal with spatial fuzziness. 
    It mainly implements underlying concepts defined in the following research papers: 
    (i) "Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types" &lt;<a href="https://doi.org/10.1109%2FFUZZ-IEEE.2018.8491565">doi:10.1109/FUZZ-IEEE.2018.8491565</a>&gt;; 
    (ii) "A Systematic Approach to Creating Fuzzy Region Objects from Real Spatial Data Sets" &lt;<a href="https://doi.org/10.1109%2FFUZZ-IEEE.2019.8858878">doi:10.1109/FUZZ-IEEE.2019.8858878</a>&gt;; 
    (iii) "Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions" &lt;<a href="https://doi.org/10.1109%2FFUZZ48607.2020.9177620">doi:10.1109/FUZZ48607.2020.9177620</a>&gt;;
    (iv) "Fuzzy Inference on Fuzzy Spatial Objects (FIFUS) for Spatial Decision Support Systems" &lt;<a href="https://doi.org/10.1109%2FFUZZ-IEEE.2017.8015707">doi:10.1109/FUZZ-IEEE.2017.8015707</a>&gt;;
    (v) "Evaluating Region Inference Methods by Using Fuzzy Spatial Inference Models" &lt;<a href="https://doi.org/10.1109%2FFUZZ-IEEE55066.2022.9882658">doi:10.1109/FUZZ-IEEE55066.2022.9882658</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'data_types.R' 'internal_functions.R' 'basic_functions.R'
'construction_module.R' 'general_operations.R'
'fuzzy_numerical_operations.R' 'fuzzy_geom_set_operations.R'
'fuzzy_topological_relations.R' 'fsi_module.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 21:04:46 UTC; Anderson</td>
</tr>
<tr>
<td>Author:</td>
<td>Anderson Carniel <a href="https://orcid.org/0000-0002-8297-9894"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rth, aut, cre, cph],
  Pedro Ven√¢ncio <a href="https://orcid.org/0000-0003-4665-562X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Markus Schneider [rth]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anderson Carniel &lt;accarniel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 21:33:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_tibble.pgeometry'>Convert a <code>pgeometry</code> object into tabular data (<code>data.frame</code> or <code>tibble</code>)</h2><span id='topic+as_tibble.pgeometry'></span><span id='topic+as.data.frame.pgeometry'></span>

<h3>Description</h3>

<p>These functions convert a <code>pgeometry</code> object into a tabular format, such as a <code>tibble</code> or <code>data.frame</code> object,
where the components of the <code>pgeometry</code> object compose the rows of the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgeometry'
as_tibble(x, ...)

## S3 method for class 'pgeometry'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.pgeometry_+3A_x">x</code></td>
<td>
<p>A <code>pgeometry</code> object.</p>
</td></tr>
<tr><td><code id="as_tibble.pgeometry_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are S3 methods for <code>pgeometry</code>.
The <code>as_tibble()</code> function converts a <code>pgeometry</code> object into a <code>tibble</code>, which is a data frame with class <code>tbl_df</code>.
This allows us to get the internal components of the <code>pgeometry</code> object
(i.e., spatial features objects and membership degrees) as a data frame with
two separate columns: (i) <code>geometry</code> (an <code>sfc</code> object) and (ii) <code>md</code> (<em>membership degree</em>).
Therefore, each row of this tibble represents a component of the original <code>pgeometry</code> object.
</p>
<p>It is also possible to call the S3 method <code>as.data.frame()</code> to convert a <code>pgeometry</code> object into a <code>data.frame</code> object.
</p>


<h3>Value</h3>

<p>A tabular object (<code>data.frame</code> or <code>tibble</code>) with the number of rows corresponding to the number of components of
the <code>pgeometry</code> object given as input and two columns in the format <code style="white-space: pre;">&#8288;(geometry, md)&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcomp1 &lt;- create_component("MULTIPOINT(1 2, 3 2)", 0.4)
pcomp2 &lt;- create_component("POINT(2 1)", 0.3)
pcomp3 &lt;- create_component("MULTIPOINT(5 1, 0 0)", 1)
ppoint &lt;- create_pgeometry(list(pcomp1, pcomp2, pcomp3), "PLATEAUPOINT")

# Converting the pgeometry object into a tibble object
ppoint_tibble &lt;- as_tibble(ppoint)
ppoint_tibble

# Converting it into data.frame
ppoint_df &lt;- as.data.frame(ppoint)
ppoint_df
</code></pre>

<hr>
<h2 id='component-class'>An S4 Class for representing a component of a spatial plateau object</h2><span id='topic+component-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing a component of a spatial plateau object
</p>


<h3>Details</h3>

<p>A <code>component</code> object is composed of two attributes. The first one is a crisp spatial
object and the second one is the membership degree in ]0, 1] of this  <code>component</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>obj</code></dt><dd><p>An <code>sfg</code> object.</p>
</dd>
<dt><code>md</code></dt><dd><p>The membership degree of the component.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>

<hr>
<h2 id='create_empty_pgeometry'>Create an empty <code>pgeometry</code> object</h2><span id='topic+create_empty_pgeometry'></span>

<h3>Description</h3>

<p><code>create_empty_pgeometry()</code> builds an empty <code>pgeometry</code> object of a specific type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_empty_pgeometry(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_empty_pgeometry_+3A_type">type</code></td>
<td>
<p>A character value indicating the spatial plateau data type of the <code>pgeometry</code> object.
It can be either <code>"PLATEAUPOINT"</code>, <code>"PLATEAULINE"</code>, <code>"PLATEAUREGION"</code>, <code>"PLATEAUCOMPOSITION"</code> or <code>"PLATEAUCOLLECTION"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>create_empty_pgeometry()</code> function creates a new <code>pgeometry</code> object with no components. To add new components to this object, you
should use <code>spa_add_component()</code>. The components added to this object must be compatible with the type of the empty <code>pgeometry</code> object.
</p>


<h3>Value</h3>

<p>An empty <code>pgeometry</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating an empty plateau point object
empty_plateau_point &lt;- create_empty_pgeometry("PLATEAUPOINT")
empty_plateau_point

# Creating an empty plateau line object
empty_plateau_line &lt;- create_empty_pgeometry("PLATEAULINE")
empty_plateau_line

# Creating an empty plateau region object
empty_plateau_region &lt;- create_empty_pgeometry("PLATEAUREGION")
empty_plateau_region

# Creating an empty plateau composition object
empty_plateau_composition &lt;- create_empty_pgeometry("PLATEAUCOMPOSITION")
empty_plateau_composition

# Creating an empty plateau collection object
empty_plateau_collection &lt;- create_empty_pgeometry("PLATEAUCOLLECTION")
empty_plateau_collection
</code></pre>

<hr>
<h2 id='create_pgeometry'>Create a <code>pgeometry</code> object with components</h2><span id='topic+create_pgeometry'></span>

<h3>Description</h3>

<p><code>create_pgeometry()</code> creates a <code>pgeometry</code> object from a <code>data.frame</code> or <code>tibble</code> object, a list of components, or a list of spatial plateau objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_pgeometry(x, type, is_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_pgeometry_+3A_x">x</code></td>
<td>
<p>A list of <code>component</code> objects, a list of <code>pgeometry</code> objects or a <code>data.frame</code>/<code>tibble</code> object. For <code>PLATEAUPOINT</code>, <code>PLATEAULINE</code> and <code>PLATEAUREGION</code>, the type of each component must be the same for all components.</p>
</td></tr>
<tr><td><code id="create_pgeometry_+3A_type">type</code></td>
<td>
<p>A character value that indicates the type of the desired <code>pgeometry</code> object.
It should be either <code>"PLATEAUPOINT"</code>, <code>"PLATEAULINE"</code>, <code>"PLATEAUREGION"</code>, <code>"PLATEAUCOMPOSITION"</code>, or <code>"PLATEAUCOLLECTION"</code>.
It must be compatible with the components given in <code>x</code> parameter.</p>
</td></tr>
<tr><td><code id="create_pgeometry_+3A_is_valid">is_valid</code></td>
<td>
<p>A Boolean value to check whether the user wants to validate the created spatial plateau object at the end. If <code>is_valid = TRUE</code>, it calls <code>validObject()</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>create_pgeometry()</code> is a flexible function that creates a <code>pgeometry</code> object by using the values given in <code>x</code>.
This object is built by using either a list of <code>component</code> objects, a list of <code>pgeometry</code> objects or a <code>data.frame</code> (or <code>tibble</code>) object.
If a <code>data.frame</code> or <code>tibble</code> object is given as input, its columns must have the following format: (i) first column is an <code>sfc</code> object, and
(ii) the second columns consists of the membership degree of each respective object of the <code>sfc</code> column.
</p>
<p>By default, this function checks if the resulting spatial plateau object is valid.
That is, it checks whether all constraints defined by the Spatial Plateau Algebra are satisfied.
For instance, the components of a plateau point, plateau line, or plateau region must be adjacent or disjoint from each other and have to be unique membership degrees.
</p>
<p>If you are sure that the component objects provided to this function satisfy all the constraints, then you can use <code>is_valid = FALSE</code> to improve the performance of this function.
</p>


<h3>Value</h3>

<p>A <code>pgeometry</code> object.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of spatial plateau data types are explained in detail in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Creating some components
pts &lt;- rbind(c(0, 2), c(4, 2))
# Point components
pcp1 &lt;- create_component(st_multipoint(pts), 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)
lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)

# Creating spatial plateau objects from lists of components
pp &lt;- create_pgeometry(list(pcp1, pcp2, pcp3), "PLATEAUPOINT")
pl &lt;- create_pgeometry(list(lcp1, lcp3, lcp4), "PLATEAULINE")
pr &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")
pcm &lt;- create_pgeometry(list(pcp1, pcp2, lcp1, lcp2, lcp3, rcp2), "PLATEAUCOMPOSITION")

# Creating a spatial plateau objects from a list of spatial plateau objects
pcl &lt;- create_pgeometry(list(pp, pr, pcm), "PLATEAUCOLLECTION")

# Converting pp into a tibble
pp
tibble_pp &lt;- as_tibble(pp)
tibble_pp

# Creating a spatial plateau point from the previous tibble
equivalent_pp &lt;- create_pgeometry(tibble_pp, "PLATEAUPOINT")
equivalent_pp
</code></pre>

<hr>
<h2 id='fsi_add_cs'>Add the consequent to an FSI model</h2><span id='topic+fsi_add_cs'></span>

<h3>Description</h3>

<p><code>fsi_add_cs()</code> adds the consequent to a fuzzy spatial inference (FSI) model. It consists of a set of membership functions labeled with linguistic values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi_add_cs(fsi, lvar, lvals, mfs, bounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_add_cs_+3A_fsi">fsi</code></td>
<td>
<p>The FSI model instantiated with the <code>fsi_create()</code> function.</p>
</td></tr>
<tr><td><code id="fsi_add_cs_+3A_lvar">lvar</code></td>
<td>
<p>A character value that represents a linguistic variable of the consequent.</p>
</td></tr>
<tr><td><code id="fsi_add_cs_+3A_lvals">lvals</code></td>
<td>
<p>A character vector that contains linguistic values of the linguistic variable of the consequent.</p>
</td></tr>
<tr><td><code id="fsi_add_cs_+3A_mfs">mfs</code></td>
<td>
<p>A vector of membership functions (see examples below).</p>
</td></tr>
<tr><td><code id="fsi_add_cs_+3A_bounds">bounds</code></td>
<td>
<p>A numeric vector that represents the lower and upper bounds of the consequent domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsi_add_cs()</code> function adds the consequent to an FSI model.
Each linguistic value defined in <code>lvals</code> has a corresponding membership function defined in <code>mfs</code>.
Thus, these two parameters must have the same length.
For instance, the first value of <code>lvals</code> defines the linguistic value of the first membership function in <code>mfs</code>.
In <code>bounds</code>, the lower and upper values correspond to the first and second parameter, respectively.
</p>


<h3>Value</h3>

<p>An FSI model populated with a consequent.
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and formal definitions of FSI models are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8015707">Carniel, A. C.; Schneider, M. Fuzzy inference on fuzzy spatial objects (FIFUS) for spatial decision support systems. In Proceedings of the 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Defining two different types of membership functions
trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

trim_mf &lt;- function(a, b, c) {
  function(x) {
    pmax(pmin((x - a)/(b - a), (c - x)/(c - b), na.rm = TRUE), 0)
  }
}

# Creating the FSI model
fsi &lt;- fsi_create("To visit or not to visit, that is the question", 
                   default_conseq = trim_mf(10, 30, 60))

# Creating the vector with the linguistic values of the linguistic variable "visiting experience"
lvals_visiting_exp &lt;- c("awful", "average", "great")

# Defining the membership function for each linguistic value
awful_mf &lt;- trim_mf(0, 0, 20)
average_mf &lt;- trim_mf(10, 30, 60)
great_mf &lt;- trap_mf(40, 80, 100, 100)

# Adding the consequent to the FSI model
fsi &lt;- fsi_add_cs(fsi, "visiting experience", lvals_visiting_exp,
                  c(awful_mf, average_mf, great_mf), c(0, 100))
</code></pre>

<hr>
<h2 id='fsi_add_fsa'>Add an antecedent to an FSI model</h2><span id='topic+fsi_add_fsa'></span>

<h3>Description</h3>

<p><code>fsi_add_fsa()</code> adds a fuzzy spatial antecedent to a fuzzy spatial inference (FSI) model.
A fuzzy spatial antecedent corresponds to a layer of fuzzy spatial objects (i.e., spatial plateau objects) that describe the different characteristics of the problem.
The antecedent has a linguistic variable and its fuzzy spatial objects have linguistic values so that they are used in the IF part of fuzzy rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi_add_fsa(fsi, lvar, tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_add_fsa_+3A_fsi">fsi</code></td>
<td>
<p>The FSI model instantiated with the <code>fsi_create()</code> function.</p>
</td></tr>
<tr><td><code id="fsi_add_fsa_+3A_lvar">lvar</code></td>
<td>
<p>A character value that represents a linguistic variable of the antecedent.</p>
</td></tr>
<tr><td><code id="fsi_add_fsa_+3A_tbl">tbl</code></td>
<td>
<p>A tibble with spatial plateau objects annotated with linguistic values of the linguistic variable specified by the above <code>lvar</code> parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsi_add_fsa()</code> function adds a fuzzy spatial antecedent composed of a linguistic variable and its corresponding <code>pgeometry</code> objects annotated by linguistic values.
The format of <code>tbl</code> is the same as the output of the function <code>spa_creator()</code>, allowing users to directly provide plateau region objects as input when designing FSI models.
</p>


<h3>Value</h3>

<p>An FSI model populated with a fuzzy spatial antecedent.
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and formal definitions of FSI models are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8015707">Carniel, A. C.; Schneider, M. Fuzzy inference on fuzzy spatial objects (FIFUS) for spatial decision support systems. In Proceedings of the 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

trim_mf &lt;- function(a, b, c) {
  function(x) {
    pmax(pmin((x - a)/(b - a), (c - x)/(c - b), na.rm = TRUE), 0)
  }
}

# Creating spatial plateau objects for the linguistic variable "accommodation price"
lvals_accom_price &lt;- c("cut-rate", "affordable", "expensive")
cut_rate_mf &lt;- trap_mf(0, 0, 10, 48)
affordable_mf &lt;- trap_mf(10, 48, 80, 115)
expensive_mf &lt;- trap_mf(80, 115, 10000, 10000)

# Example of point dataset
accom_price &lt;- tibble(longitude = c(-74.0, -74.0, -74.0), 
                      latitude = c(40.8, 40.75, 40.7),
                      price = c(150, 76, 60))
 
accom_price_layer &lt;- spa_creator(accom_price, classes = lvals_accom_price, 
                         mfs = c(cut_rate_mf, affordable_mf, expensive_mf))
                         
# Creating the FSI model
fsi &lt;- fsi_create("To visit or not to visit, that is the question", 
                  default_conseq = trim_mf(10, 30, 60))

# Adding the fuzzy spatial antecedent to the FSI model
fsi &lt;- fsi_add_fsa(fsi, "accommodation price", accom_price_layer) 
</code></pre>

<hr>
<h2 id='fsi_add_rules'>Add fuzzy rules to an FSI model</h2><span id='topic+fsi_add_rules'></span>

<h3>Description</h3>

<p><code>fsi_add_rules()</code> adds the fuzzy rules set to a fuzzy spatial inference (FSI) model.
A fuzzy rule must contain only linguistic variables and values included in the antecedent parts and consequent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi_add_rules(fsi, rules, weights = rep(1, length(rules)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_add_rules_+3A_fsi">fsi</code></td>
<td>
<p>An FSI model instantiated with the <code>fsi_create()</code> function.</p>
</td></tr>
<tr><td><code id="fsi_add_rules_+3A_rules">rules</code></td>
<td>
<p>A character vector containing the rules defined by the user. It follows a specific format, as detailed below.</p>
</td></tr>
<tr><td><code id="fsi_add_rules_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weight values for each rule. Default values are 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsi_add_rules()</code> function adds fuzzy rules to an FSI model.
The definition of a fuzzy rule is user-friendly since users can write it by using the <em>linguistic variables</em> and <em>linguistic values</em> previously defined and added to the FSI model (via <code>fsi_add_fsa()</code> and <code>fsi_add_cs()</code>).
</p>
<p>A fuzzy rule has the format <code style="white-space: pre;">&#8288;IF A THEN B&#8288;</code>, where <code>A</code> is called the antecedent and <code>B</code> the consequent of the rule such that <code>A</code> implies <code>B</code>.
Further, <code>A</code> and <code>B</code> are statements that combine fuzzy propositions by using logical connectives like <code>AND</code> or <code>OR</code>.
Each fuzzy proposition has the format <code style="white-space: pre;">&#8288;LVar is LVal&#8288;</code> where <code>LVal</code> is a linguistic value in the scope of the linguistic variable <code>LVar</code>.
</p>
<p>To avoid possible contradictions keep in mind the following items when specifying the rules:
</p>

<ul>
<li><p> the order of the statements in the antecedent is not relevant.
</p>
</li>
<li><p> each linguistic variable has to appear at most one time in each fuzzy rule.
</p>
</li>
<li><p> only one kind of logical connective (i.e., <code>AND</code> or <code>OR</code>) must be used in the statements of the antecedent.
</p>
</li></ul>



<h3>Value</h3>

<p>An FSI model populated with a fuzzy rules set.
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and formal definitions of FSI models are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8015707">Carniel, A. C.; Schneider, M. Fuzzy inference on fuzzy spatial objects (FIFUS) for spatial decision support systems. In Proceedings of the 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Creating the FSI model from an example
fsi &lt;- visitation()

# Creating a vector of fuzzy rules
## note that we make use of the linguistic variables and linguistic values previously defined
rules &lt;- c(
 "IF accommodation review is reasonable AND 
    food safety is low 
  THEN visiting experience is awful",
 "IF accommodation price is expensive AND 
    accommodation review is reasonable 
  THEN visiting experience is awful",
 "IF accommodation price is affordable AND 
    accommodation review is good AND 
    food safety is medium 
  THEN visiting experience is average",
 "IF accommodation price is affordable AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great",
 "IF accommodation price is cut-rate AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great")

# Adding these rules to the FSI model previously instantiated
fsi &lt;- fsi_add_rules(fsi, rules)
</code></pre>

<hr>
<h2 id='fsi_create'>Create an empty fuzzy spatial inference model</h2><span id='topic+fsi_create'></span>

<h3>Description</h3>

<p><code>fsi_create()</code> builds a fuzzy spatial inference (FSI) model without elements of the data source component (i.e., spatial plateau objects, fuzzy rules set, and fuzzy sets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi_create(name, and_method = "min", or_method = "max",
           imp_method = "min", agg_method = "max", 
           defuzz_method = "centroid", default_conseq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_create_+3A_name">name</code></td>
<td>
<p>A character value that specifies the name of the FSI model.</p>
</td></tr>
<tr><td><code id="fsi_create_+3A_and_method">and_method</code></td>
<td>
<p>A character value that defines the operator for the logical connective AND. Default value is <code>"min"</code>.</p>
</td></tr>
<tr><td><code id="fsi_create_+3A_or_method">or_method</code></td>
<td>
<p>A character value that defines the operator for the logical connective OR. Default value is <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="fsi_create_+3A_imp_method">imp_method</code></td>
<td>
<p>A character value that defines the implication operator. Default value is <code>"min"</code>.</p>
</td></tr>
<tr><td><code id="fsi_create_+3A_agg_method">agg_method</code></td>
<td>
<p>A character value that defines the aggregation operator. Default value is <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="fsi_create_+3A_defuzz_method">defuzz_method</code></td>
<td>
<p>A character value that determines the defuzzification technique. Default value is the centroid technique.</p>
</td></tr>
<tr><td><code id="fsi_create_+3A_default_conseq">default_conseq</code></td>
<td>
<p>A function object that corresponds to a membership function of the consequent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsi_create()</code> function creates an empty FSI model and its default parameter values will implement a model using Mamdani's method.
</p>
<p>The possible values for the parameters <code>and_method</code> and <code>imp_method</code> are: <code>"min"</code>, <code>"prod"</code>. The name of a user-defined t-norm function can also be informed here.
The possible value for the parameters <code>or_method</code> and <code>agg_method</code> is: <code>"max"</code>.  The name of a user-defined t-conorm function can also be informed here.
The possible values for the parameter <code>defuzz_method</code> are <code>"centroid"</code> (default value), <code>"bisector"</code>, <code>"mom"</code>, <code>"som"</code>, and <code>"lom"</code>.
The parameter <code>default_conseq</code> defines the default behavior of the FSI model when there is no fuzzy rule with a degree of fulfillment greater than 0 returned by the FSI model.
</p>
<p>After creating an empty FSI model, you have to call the functions <code>fsi_add_fsa()</code>, <code>fsi_add_cs()</code>, and <code>fsi_add_rules()</code> to fulfill the FSI model with the needed information before performing inferences.
</p>


<h3>Value</h3>

<p>An empty named FSI model that is ready to be populated with data source component (i.e., spatial plateau objects, fuzzy rules set, and fuzzy sets).
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and formal definitions of FSI models are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8015707">Carniel, A. C.; Schneider, M. Fuzzy inference on fuzzy spatial objects (FIFUS) for spatial decision support systems. In Proceedings of the 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>trim_mf &lt;- function(a, b, c) {
  function(x) {
    pmax(pmin((x - a)/(b - a), (c - x)/(c - b), na.rm = TRUE), 0)
  }
}

# Creating the FSI model
fsi &lt;- fsi_create("To visit or not to visit, that is the question", 
                  default_conseq = trim_mf(10, 30, 60)) 
</code></pre>

<hr>
<h2 id='fsi_eval'>Evaluate a point inference query</h2><span id='topic+fsi_eval'></span>

<h3>Description</h3>

<p><code>fsi_eval()</code> evaluates a point inference query.
Considering an FSI model, it answers the following question: what is the inferred value for a given single point location?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi_eval(fsi, point, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_eval_+3A_fsi">fsi</code></td>
<td>
<p>An FSI model built with the <code>fsi_create()</code> and populated by <code>fsi_add_fsa()</code>, <code>fsi_add_cs()</code>, and <code>fsi_add_rules()</code>.</p>
</td></tr>
<tr><td><code id="fsi_eval_+3A_point">point</code></td>
<td>
<p>An <code>sfg</code> object of the type <code>POINT</code>.</p>
</td></tr>
<tr><td><code id="fsi_eval_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Informs the <code>fsi_eval</code> how the elements of the resulting fuzzy set should be discretized if the user does not want the default configuration (see below). Default values: <code>discret_by</code> is 0.5 and <code>discret_length</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsi_eval()</code> function evaluates a point inference query by using an FSI model populated with its fuzzy spatial antecedent, consequent, and fuzzy rules set.
This evaluation is based on the algorithm specified by the references below.
</p>
<p>The default behavior of <code>fsi_eval()</code> in the parameter <code>...</code> is to consider a discrete interval of values with an increment of 0.5 between lower and upper values for the consequent domain (i.e., defined by <code>fsi_add_cs()</code> with the parameter <code>bounds</code>).
</p>
<p>The user can modify the default behavior by using one of the following two ways:
</p>

<ul>
<li><p> define a value for the parameter <code>discret_by</code> by changing the incremental value.
</p>
</li>
<li><p> define a desired length for the sequence of values domain of the consequent by using the parameter <code>discret_length</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric value that belongs to the domain of the consequent of the FSI model and represents the result of a point inference query
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and definitions on the evaluation of point inference queries are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/9882658">Carniel, A. C.; Galdino, F.; Schneider, M. Evaluating Region Inference Methods by Using Fuzzy Spatial Inference Models. In Proceedings of the 2022 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2022), pp. 1-8, 2022.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/8015707">Carniel, A. C.; Schneider, M. Fuzzy inference on fuzzy spatial objects (FIFUS) for spatial decision support systems. In Proceedings of the 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Creating the FSI model from an example
fsi &lt;- visitation()

# Creating a vector of fuzzy rules
## note that we make use of the linguistic variables and linguistic values previously defined
rules &lt;- c(
 "IF accommodation review is reasonable AND 
    food safety is low 
  THEN visiting experience is awful",
 "IF accommodation price is expensive AND 
    accommodation review is reasonable 
  THEN visiting experience is awful",
 "IF accommodation price is affordable AND 
    accommodation review is good AND 
    food safety is medium 
  THEN visiting experience is average",
 "IF accommodation price is affordable AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great",
 "IF accommodation price is cut-rate AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great")

# Adding these rules to the FSI model previously instantiated
fsi &lt;- fsi_add_rules(fsi, rules)

# Evaluating a point inference query
fsi_eval(fsi, st_point(c(-74.0, 40.7)))
## Not run: 
# Changing the default discretization
fsi_eval(fsi, st_point(c(-74.0, 40.7)), discret_by = 0.8)
fsi_eval(fsi, st_point(c(-74.0, 40.7)), discret_length = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsi_qw_eval'>Evaluate region inference methods</h2><span id='topic+fsi_qw_eval'></span>

<h3>Description</h3>

<p><code>fsi_qw_eval()</code> implements two methods for evaluating region inference (RI) queries: (i) Linguistic value-based RI query, and (ii) Optimal RI query.
The objective of these queries is to capture all points that intersect a search object (e.g., a query window) and
whose inferred values fulfill some specific user requirements (e.g., the points with the maximum or minimum inferred values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi_qw_eval(fsi, qw, approach = "discretization", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_qw_eval_+3A_fsi">fsi</code></td>
<td>
<p>An FSI model built with the <code>fsi_create()</code> function and populated by the functions <code>fsi_add_fsa()</code>, <code>fsi_add_cs()</code>, and <code>fsi_add_rules()</code>.</p>
</td></tr>
<tr><td><code id="fsi_qw_eval_+3A_qw">qw</code></td>
<td>
<p>An <code>sfg</code> object representing the search object (e.g., a query window). It has to be an axis-aligned rectangle represented by a simple polygon object of 5 points (since the last coordinate pair closes the external ring of the rectangle).</p>
</td></tr>
<tr><td><code id="fsi_qw_eval_+3A_approach">approach</code></td>
<td>
<p>Defines which approach is employed to perform the region inference: <code>"discretization"</code> or <code>"pso"</code>. Default value is <code>"discretization"</code>.</p>
</td></tr>
<tr><td><code id="fsi_qw_eval_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Different set of parameters required depending on the chosen approach (see more in details below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsi_qw_eval()</code> function evaluates two types of RI queries:
</p>

<ul>
<li> <p><em>Linguistic value-based RI query</em>, which answers the following type of question: what are the points that intersect a given search object and have inferred values that belong to a target linguistic value?
</p>
</li>
<li> <p><em>Optimal RI query</em>, which answers the following type of question: what are the points that intersect a given search object and have the maximum (or minimum) inferred values?
</p>
</li></ul>

<p><code>fsi_qw_eval()</code> offers two different methods to answer these questions: (i) <em>discretization</em> method, and (ii) <em>optimization</em> method.
Comparative analyses (see reference below) indicate that the discretization method should be employed to process linguistic value-based RI queries, while
the optimization method is more adequate for processing optimal RI queries. The details below describe how to use these methods.
</p>
<p>For the <em>discretization</em> method, two additional parameters are needed and must be informed by using the three-dots parameter <code>...</code>:
</p>

<ul>
<li> <p><code>target_lval</code>: A character value that indicates the target linguistic value from the linguistic variable of the consequent.
</p>
</li>
<li> <p><code>k</code>: A numeric value that defines the number of points that will be captured from the query window and evaluated by <code>fsi_eval()</code>.
Its square root has to an integer value.
Alternatively, you can inform the number of columns and rows of the regular grid to be created on the query window by informing numeric values for <code>n_col</code> and <code>n_row</code>, respectively.
Thus, these parameters can be given instead of the number <code>k</code>.
</p>
</li></ul>

<p>The <em>optimization</em> method employs the particle swarm optimization (PSO) algorithm. Thus, the parameter <code>approach = "pso"</code> must be set together with the following parameters:
</p>

<ul>
<li> <p><code>what</code>: A character value that defines the user's goal, which can be either <strong>maximize</strong> or <strong>minimize</strong> inferred values.
Thus, this parameter can be either <code>"max"</code> or <code>"min"</code>. The default value is <code>"max"</code>.
</p>
</li>
<li> <p><code>max_depth</code>: A numeric value that refers to the number of times that the query window is divided into subquadrants.
The default value is equal to 2. For instance, a <code>max_depth = 2</code> means that the query window will be split into four subquadrants, where the PSO will be applied to each one as its search space.
</p>
</li></ul>

<p>In addition, the PSO algorithm has its own set of parameters:
</p>

<ul>
<li> <p><code>maxit</code>: A numeric value that defines the maximum number of iterations. Default value is 50.
</p>
</li>
<li> <p><code>population</code>: A numeric value that defines the number of particles. Default value is 10.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble in the format <code style="white-space: pre;">&#8288;(points, inferred_values)&#8288;</code>, where <code>points</code> is an <code>sfc</code> object and <code>inferred_values</code> are inferred values in the domain of the consequent of the FSI model.
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and definitions on the evaluation of region inference methods are explained in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/9882658">Carniel, A. C.; Galdino, F.; Schneider, M. Evaluating Region Inference Methods by Using Fuzzy Spatial Inference Models. In Proceedings of the 2022 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2022), pp. 1-8, 2022.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Creating the FSI model from an example
fsi &lt;- visitation()

# Creating a vector of fuzzy rules
## note that we make use of the linguistic variables and linguistic values previously defined
rules &lt;- c(
 "IF accommodation review is reasonable AND 
    food safety is low 
  THEN visiting experience is awful",
 "IF accommodation price is expensive AND 
    accommodation review is reasonable 
  THEN visiting experience is awful",
 "IF accommodation price is affordable AND 
    accommodation review is good AND 
    food safety is medium 
  THEN visiting experience is average",
 "IF accommodation price is affordable AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great",
 "IF accommodation price is cut-rate AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great")

# Adding these rules to the FSI model previously instantiated
fsi &lt;- fsi_add_rules(fsi, rules)

# Defining the query window
pts_qw1 &lt;- rbind(c(-73.92, 40.68527), c(-73.75, 40.68527), 
                 c(-73.75, 40.75), c(-73.92, 40.75), c(-73.92, 40.68527))
qw1 &lt;- st_polygon(list(pts_qw1))

# Recall that our running example is based on a small set of point datasets
# This means that inferred values will likely be the same

## Not run: 
# Example using the discretization method
fsi_qw_eval(fsi, qw1, approach = "discretization", target_lval = "great", k = 25)

# Example using the optimization method
fsi_qw_eval(fsi, qw1, approach = "pso", max_depth = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsr_components'>Create a component</h2><span id='topic+fsr_components'></span><span id='topic+create_component'></span><span id='topic+component_from_sfg'></span>

<h3>Description</h3>

<p><code>create_component()</code> builds an object of class <code>component</code>.
A component consists of a crisp spatial object (<code>sfg</code> object) labeled with a membership degree in ]0, 1].
It is a flexible function since the crisp spatial object can be provided by using different formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_component(obj, md, ...)

component_from_sfg(sfg, md)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_components_+3A_obj">obj</code></td>
<td>
<p>A crisp spatial object in a specific format (see details below).</p>
</td></tr>
<tr><td><code id="fsr_components_+3A_md">md</code></td>
<td>
<p>A numeric value indicating the membership degree of the component. It must be a value in ]0, 1].</p>
</td></tr>
<tr><td><code id="fsr_components_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Different parameters that are used to convert a crisp spatial object from a specific representation (see more in details below).</p>
</td></tr>
<tr><td><code id="fsr_components_+3A_sfg">sfg</code></td>
<td>
<p>An <code>sfg</code> object. It should be either of type <code>POINT</code>, <code>MULTIPOINT</code>, <code>LINESTRING</code>,
<code>MULTILINESTRING</code>, <code>POLYGON</code> or <code>MULTIPOLYGON</code>. Other types of spatial objects are not allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>create_component()</code> function creates a <code>component</code> object. Internally, it is a pair of an <code>sfg</code> object and a membership degree in ]0, 1].
</p>
<p><code>obj</code> can be either (see restrictions regarding its data type below):
</p>

<ul>
<li><p> an <code>sfg</code> object.
</p>
</li>
<li><p> a character vector containing the WKT representation of a crisp spatial object.
</p>
</li>
<li><p> a structure of class <code>"WKB"</code> with the WKB or EWKB representation of a crisp spatial object. If the EWKB representation is used, then you have to provide the additional parameter <code>EWKB = TRUE</code> in <code>...</code>.
</p>
</li>
<li><p> a vector, list, or matrix containing coordinate pairs to be used when creating the <code>sfg</code> object.
This means that it has a similar behavior to the family of functions <code>st</code> of the <code>sf</code> package (e.g., <code>st_point()</code>, <code>st_multipoint()</code>, etc.).
Thus, you have to provide the additional parameter <code>type</code> in <code>...</code>, which should be either <code>"POINT"</code>, <code>"LINE"</code>, or <code>"REGION"</code>.
</p>
</li></ul>

<p>It is important to emphasize that the crisp spatial object must be a simple or complex point, line, or region (i.e., polygon) object.
That is, it should be a <code>POINT</code>, <code>MULTIPOINT</code>, <code>LINESTRING</code>, <code>MULTILINESTRING</code>, <code>POLYGON</code> or <code>MULTIPOLYGON</code> object.
If other types of crisp spatial objects are given, an error will be thrown.
</p>
<p>The <code>component_from_sfg()</code> function is deprecated.
</p>


<h3>Value</h3>

<p>A <code>component</code> object that can be added to a spatial plateau object (i.e., a <code>pgeometry</code> object).
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first way: providing sfg objects
library(sf)

pts &lt;- rbind(c(1, 2), c(3, 2))
comp1 &lt;- create_component(st_multipoint(pts), 0.2) 

lpts &lt;- rbind(c(2, 2), c(3, 3))
comp2 &lt;- create_component(st_linestring(lpts), 0.1) 

matrix_obj &lt;- matrix(c(1,1,8,1,8,8,1,8,1,1), ncol = 2, byrow = TRUE)
rpts &lt;- list(matrix_obj)
comp3 &lt;- create_component(st_polygon(rpts), 0.4)

# second way: providing WKT representations
comp4 &lt;- create_component("POINT(10 35)", 0.5)
comp5 &lt;- create_component("MULTILINESTRING((-29 -27, -36 -31, -45 -33), (-45 -33, -46 -32))", 0.9)
comp6 &lt;- create_component("POLYGON((75 29, 77 29, 77 29, 75 29))", 1)

# third way: providing WKB representations
wkb = structure(list("0x0101000020e610000000000000000000000000000000000040"), class = "WKB")
comp7 &lt;- create_component(wkb, 0.8, EWKB = TRUE)

# fourth way: providing coordinate pairs
coords1 = rbind(c(2,2), c(3,3))
coords2 = rbind(c(1,1), c(3,2))

comp8 &lt;- create_component(coords1, 0.45, type = "LINE")
comp9 &lt;- create_component(coords2, 0.32, type = "POINT")
</code></pre>

<hr>
<h2 id='fsr_diff_operators'>Compute fuzzy difference operators</h2><span id='topic+fsr_diff_operators'></span><span id='topic+f_diff'></span><span id='topic+f_bound_diff'></span><span id='topic+f_symm_diff'></span><span id='topic+f_abs_diff'></span>

<h3>Description</h3>

<p>Fuzzy difference operations are set operations that generalize Boolean difference operations.
This family of functions implements some operators that help us to define different fuzzy difference operations.
These operators receive two numerical values in [0, 1] as input and calculates another numerical value in [0, 1] as output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_diff(x, y)

f_bound_diff(x, y)

f_symm_diff(x, y)

f_abs_diff(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_diff_operators_+3A_x">x</code></td>
<td>
<p>A numerical vector whose values are in [0, 1].</p>
</td></tr>
<tr><td><code id="fsr_diff_operators_+3A_y">y</code></td>
<td>
<p>A numerical vector whose values are in [0, 1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate the resulting membership degree of a fuzzy difference operator applied on two numerical values in the interval [0, 1].
The following fuzzy difference operators are available:
</p>

<ul>
<li> <p><code>f_diff()</code>: The standard <em>fuzzy set difference</em> operator defined as the intersection of <code>x</code> and the complement of <code>y</code>, that is, <code>min(x, 1 - y)</code>.
</p>
</li>
<li> <p><code>f_bound_diff()</code>: The <em>fuzzy bounded difference</em> operator defined as <code>x</code> minus <code>y</code> with upper bound equal to 0, that is, <code>max(0, x - y)</code>.
</p>
</li>
<li> <p><code>f_symm_diff()</code>: The <em>fuzzy symmetric difference</em> operator defined as the union of the difference of <code>x</code> and <code>y</code> and the difference of <code>y</code> and <code>x</code>, that is, <code>max(f_diff(x, y), f_diff(y, x))</code>.
</p>
</li>
<li> <p><code>f_abs_diff()</code>: The <em>fuzzy absolute difference</em> operator defined as the absolute difference of <code>x</code> and <code>y</code>, that is, <code>abs(x - y)</code>.
</p>
</li></ul>

<p>The name of these functions can be used in the parameter <code>dtype</code> of the <code>spa_difference()</code> function.
</p>


<h3>Value</h3>

<p>A numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.1, 0.3, 0.6, 0.8)
y &lt;- c(0.9, 0.7, 0.4, 0.2)

f_diff(x, y)
f_bound_diff(x, y)
f_symm_diff(x, y)
f_abs_diff(x, y)
</code></pre>

<hr>
<h2 id='fsr_eval_modes'>Evaluate a membership degree</h2><span id='topic+fsr_eval_modes'></span><span id='topic+soft_eval'></span><span id='topic+strict_eval'></span><span id='topic+alpha_eval'></span><span id='topic+soft_alpha_eval'></span>

<h3>Description</h3>

<p>This family of functions implements evaluation modes
that returns a Boolean value for a given degree in [0, 1] obtained from a membership function of a linguistic value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soft_eval(degree)

strict_eval(degree)

alpha_eval(degree, alpha)

soft_alpha_eval(degree, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_eval_modes_+3A_degree">degree</code></td>
<td>
<p>A numerical vector whose values are in [0, 1].</p>
</td></tr>
<tr><td><code id="fsr_eval_modes_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric value in [0, 1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions yield a Boolean value that indicates whether the membership degree matches an expected interpretation (according to the meaning of an evaluation mode).
That is, the parameter <code>degree</code> is a value in [0, 1] and an evaluation mode &quot;translates&quot; the meaning of this degree of truth as a Boolean value.
</p>
<p>There are some different ways to make this translation:
</p>

<ul>
<li> <p><code>soft_eval()</code> returns <code>TRUE</code> if <code>degree</code> is greater than 0.
</p>
</li>
<li> <p><code>strict_eval()</code> returns <code>TRUE</code> if <code>degree</code> is equal to 1.
</p>
</li>
<li> <p><code>alpha_eval()</code> returns <code>TRUE</code> if <code>degree</code> is greater than or equal to another value (named <code>alpha</code>).
</p>
</li>
<li> <p><code>soft_alpha_eval()</code> returns <code>TRUE</code> if <code>degree</code> is greater than another value (named <code>alpha</code>).
</p>
</li></ul>

<p>These operators are employed to process the evaluation modes of fuzzy topological relationships (parameter <code>eval_mode</code>) that are processed as Boolean predicates.
</p>


<h3>Value</h3>

<p>A Boolean vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, 0.1, 0.3, 0.6, 1, 0.8)

soft_eval(x)
strict_eval(x)
alpha_eval(x, 0.3)
soft_alpha_eval(x, 0.3)
</code></pre>

<hr>
<h2 id='fsr_filter_operations'>Return a crisp spatial object formed by geometric parts of a <code>pgeometry</code> object</h2><span id='topic+fsr_filter_operations'></span><span id='topic+spa_range'></span><span id='topic+spa_alpha_cut'></span><span id='topic+spa_strict_alpha_cut'></span>

<h3>Description</h3>

<p>These functions yield a crisp spatial object (as an <code>sfg</code> object) formed by the geometric parts of the components of the <code>pgeometry</code> given as input that satisfy a filter condition based on their membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_range(pgo, lvalue, rvalue, lside_closed = TRUE, rside_closed = TRUE)

spa_alpha_cut(pgo, alpha)

spa_strict_alpha_cut(pgo, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_filter_operations_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="fsr_filter_operations_+3A_lvalue">lvalue</code></td>
<td>
<p>A numeric value denoting the left side of an interval in [0, 1].</p>
</td></tr>
<tr><td><code id="fsr_filter_operations_+3A_rvalue">rvalue</code></td>
<td>
<p>A numeric value denoting the right side of an interval in [0, 1].</p>
</td></tr>
<tr><td><code id="fsr_filter_operations_+3A_lside_closed">lside_closed</code></td>
<td>
<p>A Boolean value indicating whether the left side is closed or not. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fsr_filter_operations_+3A_rside_closed">rside_closed</code></td>
<td>
<p>A Boolean value indicating whether the right side is closed or not. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fsr_filter_operations_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value. For <code>spa_alpha_cut()</code>, it must be in [0, 1]. For <code>spa_strict_alpha_cut()</code>, it must be in ]0, 1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a spatial plateau object as input, these functions return a crisp spatial object formed by the geometric parts of the components of the input that satisfy a filter
condition based on their membership degrees. The filter condition of each function is detailed as follows:
</p>

<ul>
<li> <p><code>spa_alpha_cut()</code> selects all components that have membership degrees greater than or equal to a given value in [0, 1] indicated by the parameter <code>alpha</code>.
</p>
</li>
<li> <p><code>spa_strict_alpha_cut()</code> picks a subset of components that have membership values greater than the parameter <code>alpha</code> (a value in ]0, 1]).
</p>
</li>
<li> <p><code>spa_range()</code> generalizes these two operations and allows one to pick all components that have membership degrees belonging to a given open or closed interval.
The parameters <code>lside_closed</code> and <code>rside_closed</code>, respectively, determine whether the left and right side (parameters <code>lvalue</code> and <code>rvalue</code>) of the interval is open (<code>FALSE</code>) or closed (<code>TRUE</code>).
For example, to represent the right open interval [0.5, 0.8[, the following parameter values should be given: <code style="white-space: pre;">&#8288;lvalue = 0.5, rvalue = 0.8, lside_closed = TRUE, rside_closed = FALSE&#8288;</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>sfg</code> object that represents the geometric union of the components extracted after applying the specific filter condition.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((1 2), (2 1), (3 2))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0.5), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3.5))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (4 2))", 0.4)

# Creating a plateau point object
ppoint &lt;- create_pgeometry(list(pcp1, pcp2, pcp3, pcp4, pcp5), "PLATEAUPOINT")
ppoint

# Processing the alpha-cut, strict alpha-cut, and range
spa_alpha_cut(ppoint, 0.7)
spa_strict_alpha_cut(ppoint, 0.7)
spa_range(ppoint, 0.4, 0.8)
</code></pre>

<hr>
<h2 id='fsr_geometric_operations'>Compute fuzzy geometric set operations</h2><span id='topic+fsr_geometric_operations'></span><span id='topic+spa_intersection'></span><span id='topic+spa_union'></span><span id='topic+spa_difference'></span><span id='topic+spa_common_points'></span>

<h3>Description</h3>

<p>The spatial plateau set operations <em>plateau intersection</em>, <em>plateau union</em>, and <em>plateau difference</em> implement
the respective operations <em>fuzzy geometric intersection</em>, <em>fuzzy geometric union</em>, and <em>fuzzy geometric difference</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_intersection(pgo1, pgo2, itype = "min", as_pcomposition = FALSE)

spa_union(pgo1, pgo2, utype = "max", as_pcomposition = FALSE)

spa_difference(pgo1, pgo2, dtype = "f_diff", as_pcomposition = FALSE)

spa_common_points(pline1, pline2, itype = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_geometric_operations_+3A_pgo1">pgo1</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_pgo2">pgo2</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_itype">itype</code></td>
<td>
<p>A character value that indicates the name of a function implementing a t-norm. The default value is <code>"min"</code>, which is the standard operator of the intersection.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_as_pcomposition">as_pcomposition</code></td>
<td>
<p>A logical value; if <code>TRUE</code>, it returns a spatial plateau composition object.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_utype">utype</code></td>
<td>
<p>A character value that refers to a t-conorm. The default value is <code>"max"</code>, which is the standard operator of the union.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_dtype">dtype</code></td>
<td>
<p>A character value that indicates the name of a difference operator. The default value is <code>"f_diff"</code>, which implements the standard fuzzy difference.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_pline1">pline1</code></td>
<td>
<p>A <code>pgeometry</code> object of the type <code>PLATEAULINE</code>.</p>
</td></tr>
<tr><td><code id="fsr_geometric_operations_+3A_pline2">pline2</code></td>
<td>
<p>A <code>pgeometry</code> object of the type <code>PLATEAULINE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They receive two <code>pgeometry</code> objects of the <em>any type</em> as input and yield another <code>pgeometry</code> object as output.
The family of fuzzy geometric set operations consists of the following functions:
</p>

<ul>
<li> <p><code>spa_intersection()</code> computes the geometric intersection of two spatial plateau objects.
The membership degree of common points are calculated by using a t-norm operator given by the parameter <code>itype</code>. Currently, it can assume <code>"min"</code> (default) or <code>"prod"</code>.
</p>
</li>
<li> <p><code>spa_union()</code> computes the geometric union of two spatial plateau objects.
The membership degree of common points are calculated by using a t-conorm operator given by the parameter <code>utype</code>. Currently, it can assume <code>"max"</code> (default).
</p>
</li>
<li> <p><code>spa_difference()</code> computes the geometric difference of two spatial plateau objects.
The membership degree of common points are calculated by using a difference operator given by the parameter <code>dtype</code>.
Currently, it can assume <code>"f_diff"</code> (default fuzzy difference), <code>"f_bound_diff"</code> (fuzzy bounded difference), <code>"f_symm_diff"</code> (fuzzy symmetric difference), or <code>"f_abs_diff"</code> (fuzzy absolute difference).
</p>
</li></ul>

<p>Other t-norms, t-conorms, and difference operators can be implemented and given as values for the parameters <code>itype</code>, <code>utype</code>, and <code>dtype</code>, respectively.
For this, the following steps should be performed:
</p>

<ol>
<li><p> Implement your function that accepts two numeric values in [0, 1] as inputs and yields another numeric value in [0, 1] as output. Recall that t-norms and t-conorms must have some specific properties according to the fuzzy set theory.
</p>
</li>
<li><p> Use the name of your function as the character value of the corresponding parameter <code>itype</code>, <code>utype</code>, or <code>dtype</code>.
</p>
</li></ol>

<p>An example of operator is the source code of <code>f_bound_diff()</code>:
</p>
<p><code>f_bound_diff &lt;- function(x, y) { max(0, (x - y)) }</code>
</p>
<p>The <code>spa_common_points()</code> is deprecated. In the past, it computed the common points of two plateau line objects; now, you can use <code>spa_intersection()</code>.
</p>


<h3>Value</h3>

<p>A <code>pgeometry</code> object that is the result of a fuzzy geometric set operation.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of spatial plateau set operations are explained in detail in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

# Point components
pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)

pcp4 &lt;- create_component("MULTIPOINT((2 2), (2 4), (3 2))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (4 2))", 0.4)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)

lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
lcp5 &lt;- create_component("LINESTRING(-1 1, 2 2)", 0.9)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)

# Creating plateau point objects
ppoint1 &lt;- create_pgeometry(list(pcp1, pcp2, pcp3), "PLATEAUPOINT")
ppoint2 &lt;- create_pgeometry(list(pcp4, pcp5, pcp6, pcp7), "PLATEAUPOINT")
# Creating plateau line objects
pline1 &lt;- create_pgeometry(list(lcp1, lcp2, lcp3), "PLATEAULINE")
pline2 &lt;- create_pgeometry(list(lcp4, lcp5), "PLATEAULINE")
# Creating a plateau region objects
pregion &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")

# Defining a wrapper to combine plots side by side, for convenience
combine_plots &lt;- function(plot1, plot2, plot3) {
  # setting the same range of coordinates and removing the legend of plot1 and plot2
  plot1 &lt;- plot1 + coord_sf(xlim = c(0, 4), ylim = c(0, 4)) + theme(legend.position = "none")
  plot2 &lt;- plot2 + coord_sf(xlim = c(0, 4), ylim = c(0, 4)) + theme(legend.position = "none")
  plot3 &lt;- plot3 + coord_sf(xlim = c(0, 4), ylim = c(0, 4))
  ggplot() +
    annotation_custom(ggplotGrob(plot1), xmin = 0, xmax = 0.5, ymin = 0.5, ymax = 1) +
    annotation_custom(ggplotGrob(plot2), xmin = 0.5, xmax = 1, ymin = 0.5, ymax = 1) +
    annotation_custom(ggplotGrob(plot3), xmin = 0, xmax = 1, ymin = 0, ymax = 0.5) +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
    theme_void()
}

plot_ppoint1 &lt;- plot(ppoint1) + ggtitle("Plateau point 1")
plot_ppoint2 &lt;- plot(ppoint2) + ggtitle("Plateau point 2")
plot_pline1 &lt;- plot(pline1) + ggtitle("Plateau line 1")
plot_pline2 &lt;- plot(pline2) + ggtitle("Plateau line 2")
plot_pregion &lt;- plot(pregion) + ggtitle("Plateau region")

# Computing the intersection
ppoints_intersec &lt;- spa_intersection(ppoint1, ppoint2)
plot_inter &lt;- plot(ppoints_intersec) + ggtitle("Intersection")
combine_plots(plot_ppoint1, plot_ppoint2, plot_inter)

## Not run: 
# varying the t-norm 
ppoints_intersec &lt;- spa_intersection(ppoint1, ppoint2, itype = "prod")
plot_inter &lt;- plot(ppoints_intersec) + ggtitle("Intersection (prod)")
combine_plots(plot_ppoint1, plot_ppoint2, plot_inter)

plines_intersec &lt;- spa_intersection(pline1, pline2)
plot_inter &lt;- plot(plines_intersec) + ggtitle("Intersection")
combine_plots(plot_pline1, plot_pline2, plot_inter)

pregion_pline_intersec &lt;- spa_intersection(pline1, pregion)
plot_inter &lt;- plot(pregion_pline_intersec) + ggtitle("Intersection")
combine_plots(plot_pline1, plot_pregion, plot_inter)

# Computing the union
ppoints_union &lt;- spa_union(ppoint1, ppoint2)
plot_union &lt;- plot(ppoints_union) + ggtitle("Union")
combine_plots(plot_ppoint1, plot_ppoint2, plot_union)

plines_union &lt;- spa_union(pline1, pline2)
plot_union &lt;- plot(plines_union) + ggtitle("Union")
combine_plots(plot_pline1, plot_pline2, plot_union)

pregion_pline_union &lt;- spa_union(pline1, pregion)
plot_union &lt;- plot(pregion_pline_union) + ggtitle("Union")
combine_plots(plot_pline1, plot_pregion, plot_union)

# Computing the difference
ppoints_diff &lt;- spa_difference(ppoint1, ppoint2)
plot_diff &lt;- plot(ppoints_diff) + ggtitle("Difference")
combine_plots(plot_ppoint1, plot_ppoint2, plot_diff)

plines_diff &lt;- spa_difference(pline1, pline2)
plot_diff &lt;- plot(plines_diff) + ggtitle("Difference")
combine_plots(plot_pline1, plot_pline2, plot_diff)

pregion_pline_diff &lt;- spa_difference(pline1, pregion)
plot_diff &lt;- plot(pregion_pline_diff) + ggtitle("Difference")
combine_plots(plot_pline1, plot_pregion, plot_diff)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsr_numerical_operations'>Compute fuzzy numerical operations</h2><span id='topic+fsr_numerical_operations'></span><span id='topic+spa_avg_degree'></span><span id='topic+spa_ncomp'></span><span id='topic+spa_area'></span><span id='topic+spa_perimeter'></span><span id='topic+spa_length'></span>

<h3>Description</h3>

<p>Fuzzy numerical operations are implemented by spatial plateau numerical operations, which
extract geometric measurements from spatial plateau objects,
such as the area of a plateau region object and the length of a plateau line object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_avg_degree(pgo)

spa_ncomp(pgo)

spa_area(pgo)

spa_perimeter(pgo)

spa_length(pgo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_numerical_operations_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of the type <code>PLATEAULINE</code>, <code>PLATEAUCOMPOSITION</code>, or <code>PLATEAUCOLLECTION</code>. It throws a warning if a different type is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate numerical properties from spatial plateau objects (i.e., <code>pgeometry</code> objects).
Some of them are <em>type-independent</em>. This means that the parameter can be a <code>pgeometry</code> object of any type.
The type-independent functions are:
</p>

<ul>
<li> <p><code>spa_avg_degree()</code> calculates the average membership degree of a spatial plateau object.
</p>
</li>
<li> <p><code>spa_ncomp()</code> returns the number of components of a spatial plateau object.
</p>
</li></ul>

<p>The remaining functions are <em>type-dependent</em>. This means that the parameter have to be of a specific type.
The type-dependent functions are:
</p>

<ul>
<li> <p><code>spa_area()</code> computes the area of a plateau region, plateau composition, or plateau collection object.
</p>
</li>
<li> <p><code>spa_perimeter()</code> computes the perimeter of a plateau region, plateau composition, or plateau collection.
</p>
</li>
<li> <p><code>spa_length()</code> computes the length of a plateau line, plateau composition, or plateau collection object.
</p>
</li></ul>

<p>For the aforementioned functions, if the input has the incorrect data type, it throws a warning message and returns 0.
</p>


<h3>Value</h3>

<p>A numerical value.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of some spatial plateau numerical operations are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Point components
pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((1 2), (2 1), (3 2))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0.5), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3.5))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (4 2))", 0.4)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)
lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
lcp5 &lt;- create_component("LINESTRING(-1 1, 2 2)", 0.9)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)

# Creating spatial plateau objects
ppoint &lt;- create_pgeometry(list(pcp1, pcp2, pcp3, pcp4, pcp5), "PLATEAUPOINT")
pline &lt;- create_pgeometry(list(lcp1, lcp2, lcp3), "PLATEAULINE")
pregion &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")
pcomp &lt;- create_pgeometry(list(pcp6, pcp7, lcp4, lcp5), "PLATEAUCOMPOSITION")
pcol &lt;- create_pgeometry(list(ppoint, pline, pregion, pcomp), "PLATEAUCOLLECTION")

spa_avg_degree(ppoint)
spa_avg_degree(pline)
spa_avg_degree(pregion)
spa_avg_degree(pcomp)
spa_avg_degree(pcol)

spa_ncomp(ppoint)
spa_ncomp(pline)
spa_ncomp(pregion)
spa_ncomp(pcomp)
spa_ncomp(pcol)

spa_area(pregion)
spa_area(pcomp)
spa_area(pcol)

spa_perimeter(pregion)
spa_perimeter(pcomp)
spa_perimeter(pcol)

spa_length(pline)
spa_length(pcomp)
spa_length(pcol)
</code></pre>

<hr>
<h2 id='fsr_topological_relationships'>Compute fuzzy topological relationships</h2><span id='topic+fsr_topological_relationships'></span><span id='topic+spa_overlap'></span><span id='topic+spa_meet'></span><span id='topic+spa_disjoint'></span><span id='topic+spa_equal'></span><span id='topic+spa_inside'></span><span id='topic+spa_contains'></span>

<h3>Description</h3>

<p>Fuzzy topological relationships are implemented by spatial plateau topological relationships.
A fuzzy topological relationship expresses a particular relative position of two spatial plateau objects.
Such a topological relationship determines the degree to which it holds for any two spatial plateau objects by a real value in the interval [0, 1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_overlap(pgo1, pgo2, itype = "min", ret = "degree", ...)

spa_meet(pgo1, pgo2, itype = "min", ret = "degree", ...)

spa_disjoint(pgo1, pgo2, itype = "min", ret = "degree", ...)

spa_equal(pgo1, pgo2, utype = "max", ret = "degree", ...)

spa_inside(pgo1, pgo2, utype = "max", ret = "degree", ...)

spa_contains(pgo1, pgo2, utype = "max", ret = "degree", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsr_topological_relationships_+3A_pgo1">pgo1</code></td>
<td>
<p>A <code>pregion</code> object.</p>
</td></tr>
<tr><td><code id="fsr_topological_relationships_+3A_pgo2">pgo2</code></td>
<td>
<p>A <code>pregion</code> object.</p>
</td></tr>
<tr><td><code id="fsr_topological_relationships_+3A_itype">itype</code></td>
<td>
<p>A character value that indicates the name of a function implementing a t-norm. The default value is <code>"min"</code>, which is the standard operator of the intersection.</p>
</td></tr>
<tr><td><code id="fsr_topological_relationships_+3A_ret">ret</code></td>
<td>
<p>A character value that indicates the return type of the fuzzy topological relationship. The default value is <code>"degree"</code> and other possible values are <code>"list"</code> and <code>"bool"</code>.</p>
</td></tr>
<tr><td><code id="fsr_topological_relationships_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; If <code>ret = "bool"</code>, two additional parameters have to be informed, as described below.</p>
</td></tr>
<tr><td><code id="fsr_topological_relationships_+3A_utype">utype</code></td>
<td>
<p>A character value that indicates the name of a function implementing a t-conorm. The default value is <code>"max"</code>, which is the standard operator of the union.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement the spatial plateau topological relationships between plateau region objects.
The key idea of these relationships is to consider point subsets resulting from the combination of spatial plateau
set operations and spatial plateau metric operations on spatial plateau objects for computing the resulting degree.
The resulting degree can be also interpreted as a linguistic value.
</p>
<p>The spatial plateau topological relationships are implemented by the following functions:
</p>

<ul>
<li> <p><code>spa_overlap()</code> computes the overlapping degree of two plateau region objects.
Since it uses the intersection operation, a t-norm operator can be given by the parameter <code>itype</code>. Currently, it can assume <code>"min"</code> (default) or <code>"prod"</code>.
</p>
</li>
<li> <p><code>spa_meet()</code> computes the meeting degree of two plateau region objects.
Similarly to <code>spa_overlap</code>, a t-norm operator can be given by the parameter <code>itype</code>.
</p>
</li>
<li> <p><code>spa_disjoint()</code> computes the disjointedness degree of two plateau region objects.
Similarly to <code>spa_overlap</code> and <code>spa_meet</code>, a t-norm operator can be given by the parameter <code>itype</code>.
</p>
</li>
<li> <p><code>spa_equal()</code> computes how equal are two plateau region objects.
Since it uses the union operation, a t-conorm operator can be given by the parameter <code>utype</code>. Currently, it can assume <code>"max"</code> (default).
</p>
</li>
<li> <p><code>spa_inside()</code> computes the containment degree of <code>pgo1</code> in <code>pgo2</code>.
Similarly to <code>spa_equal()</code>, a t-conorm operator can be given by the parameter <code>utype</code>.
</p>
</li>
<li> <p><code>spa_contains()</code> changes the order of the operations <code>pgo1</code> ad <code>pgo2</code> when invoking <code>spa_inside()</code>.
</p>
</li></ul>

<p>The parameter <code>ret</code> determines the returning value of a fuzzy topological relationship.
The default value is <code>"degree"</code> (default), which indicates that the function will return a value in [0, 1] that represents the degree of truth of a given topological relationship.
</p>
<p>For the remainder possible values, the functions make use of a set of linguistic values that characterize the different situations of topological relationships.
Each linguistic value has an associated membership function defined in the domain [0, 1].
The <code>fsr</code> package has a default set of linguistic values. You can use the function <code>spa_set_classification()</code> to change this set of linguistic values.
</p>
<p>The remainder possible values for the parameter <code>ret</code> are:
</p>

<ul>
<li> <p><code>ret = "list"</code> indicates that the function will return a named list containing the membership degree of the result of the predicate for each linguistic value (i.e., it employs the membership functions of the linguistic values).
</p>
</li>
<li> <p><code>ret = "bool"</code> indicates that the function will return a Boolean value indicating whether the degree returned by the topological relationship matches a given linguistic value according to an <em>evaluation mode</em>.
The evaluation mode and the linguistic values have to be informed by using the parameters <code>eval_mode</code> and <code>lval</code>, respectively.
The possible values for <code>eval_mode</code> are: <code>"soft_eval"</code>, <code>"strict_eval"</code>, <code>"alpha_eval"</code>, and <code>"soft_alpha_eval"</code>.
They have different behavior in how computing the Boolean value from the membership function of a linguistic value.
See the documentation of the functions <code>soft_eval()</code>, <code>strict_eval()</code>, <code>alpha_eval()</code>, and <code>soft_alpha_eval()</code> for more details.
Note that the parameter <code>lval</code> only accept a character value belonging to the set of linguistic values that characterize the different situations of topological relationships.
</p>
</li></ul>



<h3>Value</h3>

<p>The returning value is determined by the parameter <code>ret</code>, as described above.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of spatial plateau topological relationships and fuzzy topological relationships are respectively introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/7737976">Carniel, A. C.; Schneider, M. A Conceptual Model of Fuzzy Topological Relationships for Fuzzy Regions. In Proceedings of the 2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(sf)

set.seed(456)

# Generating some random points to create pgeometry objects by using spa_creator()
tbl = tibble(x = runif(10, min= 0, max = 30), 
             y = runif(10, min = 0, max = 30), 
             z = runif(10, min = 0, max = 50))

# Getting the convex hull on the points to clip plateau region objects during their constructions
pts &lt;- st_as_sf(tbl, coords = c(1, 2))
ch &lt;- st_convex_hull(do.call(c, st_geometry(pts)))

pregions &lt;- spa_creator(tbl, base_poly = ch, fuzz_policy = "fcp", k = 2)

plot(pregions$pgeometry[[1]])
plot(pregions$pgeometry[[2]])

## Not run:  
# Showing the different types of returning values
spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]])
spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")
spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "bool", 
           eval_mode = "soft_eval", lval = "mostly")

## Examples for evaluating the other fuzzy topological relationships
spa_meet(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")
spa_disjoint(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")
spa_equal(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")
spa_inside(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")
spa_contains(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")

## End(Not run)
</code></pre>

<hr>
<h2 id='pcollection_to_pcomposition'>Convert a plateau collection object into a plateau composition object</h2><span id='topic+pcollection_to_pcomposition'></span>

<h3>Description</h3>

<p><code>pcollection_to_pcomposition()</code> converts a plateau collection object into an equivalent plateau composition object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcollection_to_pcomposition(pcol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcollection_to_pcomposition_+3A_pcol">pcol</code></td>
<td>
<p>A <code>pcollection</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pcollection_to_pcomposition()</code> function yields a <code>pcomposition</code> object that is equivalent to the <code>pcollection</code> object given as input by
aggregating all spatial plateau objects by type.
</p>


<h3>Value</h3>

<p>A <code>pcomposition</code> object.
</p>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Point components
pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((10 10), (9 8), (7 7))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (2 3))", 0.4)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)
lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
lcp5 &lt;- create_component("LINESTRING(-1 1, 2 2)", 0.9)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)

# Creating plateau point objects
ppoint1 &lt;- create_pgeometry(list(pcp1, pcp2, pcp3), "PLATEAUPOINT")
ppoint2 &lt;- create_pgeometry(list(pcp4, pcp5), "PLATEAUPOINT")
ppoint3 &lt;- create_pgeometry(list(pcp4, pcp5), "PLATEAUPOINT")
ppoint4 &lt;- create_pgeometry(list(pcp6, pcp7), "PLATEAUPOINT")
# Creating plateau line objects
pline1 &lt;- create_pgeometry(list(lcp1, lcp3), "PLATEAULINE")
pline2 &lt;- create_pgeometry(list(lcp2, lcp4), "PLATEAULINE")
pline3 &lt;- create_pgeometry(list(lcp5), "PLATEAULINE")
# Creating a plateau region objects
pregion &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")
# Creating a plateau composition object
pcomposition &lt;- create_pgeometry(list(ppoint4, pline3), "PLATEAUCOMPOSITION")
# Creating plateau collection objects
pcol1 &lt;- create_pgeometry(list(ppoint1, ppoint2, ppoint3, pline1), "PLATEAUCOLLECTION")
pcol2 &lt;- create_pgeometry(list(pline2, pregion, pcomposition, pcol1), "PLATEAUCOLLECTION")
pcol2
plot(pcol2)
## Not run: 
converted_pcomp &lt;- pcollection_to_pcomposition(pcol2)
converted_pcomp
plot(converted_pcomp)

## End(Not run)
</code></pre>

<hr>
<h2 id='pcollection-class'>An S4 Class for representing plateau collections (subclass of <code>pgeometry</code>)</h2><span id='topic+pcollection-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing plateau collections (subclass of <code>pgeometry</code>)
</p>


<h3>Details</h3>

<p>A <code>pcollection</code> object is composed of a list of spatial plateau objects and inherits
the attribute <code>supp</code> from the class <code>pgeometry</code> (i.e., the support).
</p>


<h3>Slots</h3>


<dl>
<dt><code>supp</code></dt><dd><p>It is inherited from <code>pgeometry</code>.</p>
</dd>
<dt><code>pgos</code></dt><dd><p>A list of spatial plateau objects.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>

<hr>
<h2 id='pcomposition-class'>An S4 Class for representing plateau compositions (subclass of <code>pgeometry</code>)</h2><span id='topic+pcomposition-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing plateau compositions (subclass of <code>pgeometry</code>)
</p>


<h3>Details</h3>

<p>A <code>pcomposition</code> object is composed of a <code>ppoint</code> object, <code>pline</code> object, <code>pregion</code> object and inherits
the attribute <code>supp</code> from the class <code>pgeometry</code> (i.e., the support).
</p>


<h3>Slots</h3>


<dl>
<dt><code>supp</code></dt><dd><p>It is inherited from <code>pgeometry</code>.</p>
</dd>
<dt><code>ppoint</code></dt><dd><p>A plateau point object.</p>
</dd>
<dt><code>pline</code></dt><dd><p>A plateau line object.</p>
</dd>
<dt><code>pregion</code></dt><dd><p>A plateau region object.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>

<hr>
<h2 id='pgeometry-class'>An S4 Class for representing spatial plateau data types</h2><span id='topic+pgeometry-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing spatial plateau data types
</p>


<h3>Details</h3>

<p>It is a superclass for representing spatial plateau data types. A <code>pgeometry</code> object stores an <code>sfg</code> object that represents the union
of all crisp spatial objects of its components (i.e., the support).
</p>


<h3>Slots</h3>


<dl>
<dt><code>supp</code></dt><dd><p>An <code>sfg</code> object that stores the union of all spatial objects of the components of the spatial plateau object.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>

<hr>
<h2 id='pline-class'>An S4 Class for representing plateau lines (subclass of <code>pgeometry</code>)</h2><span id='topic+pline-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing plateau lines (subclass of <code>pgeometry</code>)
</p>


<h3>Details</h3>

<p>A <code>pline</code> object is composed of a list of <code>component</code> objects and inherits
the attribute <code>supp</code> from the class <code>pgeometry</code> (i.e., the support).
</p>


<h3>Slots</h3>


<dl>
<dt><code>supp</code></dt><dd><p>It is inherited from <code>pgeometry</code>.</p>
</dd>
<dt><code>component</code></dt><dd><p>A list of components.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>

<hr>
<h2 id='plot'>Graphically visualize <code>pgeometry</code> objects</h2><span id='topic+plot'></span><span id='topic+fsr_plot'></span><span id='topic+plot+2Cpgeometry+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>fsr_plot()</code> function (and the S4 method <code>plot()</code>) plots a <code>pgeometry</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsr_plot(pgo, base_poly = NULL, add_base_poly = TRUE, low = "white", high = "black", 
         crs = NA, clip = FALSE, line_lwd = 1, region_lwd = 1, ...)

## S4 method for signature 'pgeometry,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="plot_+3A_base_poly">base_poly</code></td>
<td>
<p>An <code>sfg</code> object of the type <code>POLYGON</code> or <code>MULTIPOLYGON</code>. It can also be an <code>sfc</code> object with only one element of the type <code>POLYGON</code> or <code>MULTIPOLYGON</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_add_base_poly">add_base_poly</code></td>
<td>
<p>A Boolean value that indicates whether <code>base_poly</code> will added to the visualization.</p>
</td></tr>
<tr><td><code id="plot_+3A_low">low</code></td>
<td>
<p>A character value that indicates the color for the lowest membership degree (i.e., 0). Default is <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_high">high</code></td>
<td>
<p>A character value that indicates the color for the highest membership degree (i.e., 1). Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_crs">crs</code></td>
<td>
<p>A numerical value that denotes the coordinate reference system (i.e., EPSG code) of the visualization. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_clip">clip</code></td>
<td>
<p>A Boolean value that indicates whether the boundaries of the components must be clipped by the <code>sfg</code> object <code>base_poly</code> (if it is not <code>null</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_line_lwd">line_lwd</code></td>
<td>
<p>A numeric value that specifies the line width of linear components.</p>
</td></tr>
<tr><td><code id="plot_+3A_region_lwd">region_lwd</code></td>
<td>
<p>A numeric value that specifies the line width of the boundaries of polygonal components.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Optional parameters. They can be the same as the parameters of <code>geom_sf()</code> function from <code>ggplot2</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>Not applicable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fsr_plot()</code> function uses a <code>ggplot2</code> package to built the resulting plot. It receives a <code>pgeometry</code> object as input (if it is empty, an empty graphics
in obtained).
</p>
<p>The <code>low</code> and <code>high</code> parameters are the colors for the minimum and maximum limits of the membership degrees. The
default colors are <code>"white"</code> and <code>"black"</code>, respectively. Other colors can be given in the same way that colors are informed
to visualizations produced by the <code>ggplot2</code> package.
</p>
<p>It is possible to clip the geometric format of the components by using the parameter <code>base_poly</code>. The boundaries of this object
can also be included in the visualization if the parameter <code>add_base_poly</code> is <code>TRUE</code>.
</p>
<p>Since the returned value is a <code>ggplot</code> object, it can be further be customized (see examples below).
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

pts &lt;- rbind(c(0, 2), c(4, 2))
# Point components
pcp1 &lt;- create_component(st_multipoint(pts), 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)
lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)
# Creating spatial plateau objects
pp &lt;- create_pgeometry(list(pcp1, pcp2, pcp3), "PLATEAUPOINT")
pl &lt;- create_pgeometry(list(lcp1, lcp3, lcp4), "PLATEAULINE")
pr &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")
pcm &lt;- create_pgeometry(list(pcp1, pcp2, lcp1, lcp2, lcp3, rcp2), "PLATEAUCOMPOSITION")
pcl &lt;- create_pgeometry(list(pp, pr, pcm), "PLATEAUCOLLECTION")

# Displaying their textual representations
pp
pl
pr
pcm
pcl

# Plotting them
plot(pp)
plot(pl)
plot(pr)
plot(pcm)
plot(pcl)
## Not run: 
# Custom colors
fsr_plot(pr, low = "green", high = "blue")

# Changing the line width of line components
fsr_plot(pl, line_lwd = 2)

# Changing the line width of boundary lines of region components
fsr_plot(pr, region_lwd = 2)

# Changing the line width of boundary lines of region components and its color
fsr_plot(pr, region_lwd = 2, color = "blue")

# You can customize the whole visualization using ggplot
library(ggplot2)

fsr_plot(pp, size = 5) +   
  theme(legend.position = "none") +
  theme(text=element_text(size=20, family = "serif", color = "black"),
        axis.text=element_text(color="black")) +
  scale_x_continuous(breaks = c(0, 1, 2, 3, 4)) +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4))

## End(Not run)
</code></pre>

<hr>
<h2 id='ppoint-class'>An S4 Class for representing plateau points (subclass of <code>pgeometry</code>)</h2><span id='topic+ppoint-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing plateau points (subclass of <code>pgeometry</code>)
</p>


<h3>Details</h3>

<p>A <code>ppoint</code> object is composed of a list of <code>component</code> objects and inherits
the attribute <code>supp</code> from the class <code>pgeometry</code> (i.e., the support).
</p>


<h3>Slots</h3>


<dl>
<dt><code>supp</code></dt><dd><p>It is inherited from <code>pgeometry</code>.</p>
</dd>
<dt><code>component</code></dt><dd><p>A list of components.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>

<hr>
<h2 id='pregion-class'>An S4 Class for representing plateau regions (subclass of <code>pgeometry</code>)</h2><span id='topic+pregion-class'></span>

<h3>Description</h3>

<p>An S4 Class for representing plateau regions (subclass of <code>pgeometry</code>)
</p>


<h3>Details</h3>

<p>A <code>pregion</code> object is composed of a list of <code>component</code> objects and inherits
the attribute <code>supp</code> from the class <code>pgeometry</code> (i.e., the support).
</p>


<h3>Slots</h3>


<dl>
<dt><code>supp</code></dt><dd><p>It is inherited from <code>pgeometry</code>.</p>
</dd>
<dt><code>component</code></dt><dd><p>A list of components.</p>
</dd>
</dl>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>

<hr>
<h2 id='PWKT'>Return PWKT representation of a spatial plateau object</h2><span id='topic+PWKT'></span><span id='topic+spa_pwkt'></span><span id='topic+format.pgeometry'></span><span id='topic+show+2Cpgeometry-method'></span><span id='topic+as.character+2Cpgeometry-method'></span>

<h3>Description</h3>

<p>These functions give the Plateau Well-Known Text (PWKT) representation of a <code>pgeometry</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_pwkt(pgo)

## S3 method for class 'pgeometry'
format(x, ..., width = 30)

## S4 method for signature 'pgeometry'
show(object)

## S4 method for signature 'pgeometry'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PWKT_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="PWKT_+3A_x">x</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="PWKT_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Unused.</p>
</td></tr>
<tr><td><code id="PWKT_+3A_width">width</code></td>
<td>
<p>An integer value that indicates the number of characters to be printed. If it is 0 <code>NULL</code> or <code>NA</code>, then it will print everything.</p>
</td></tr>
<tr><td><code id="PWKT_+3A_object">object</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return the textual representation of a <code>pgeometry</code> object,
which combines the Well-Known Text (WKT) representation for crisp vector geometry
objects and the formal definitions of spatial plateau data types.
(i.e. <code>PLATEAUPOINT</code>, <code>PLATEAULINE</code>, <code>PLATEAUREGION</code>, <code>PLATEAUCOMPOSITION</code>, and <code>PLATEAUCOLLECTION</code>).
</p>


<h3>Value</h3>

<p>A character object (i.e., string) with the textual representation of a given <code>pgeometry</code> object.
</p>


<h3>References</h3>

<p>The formal definition of PWKT is given in:
</p>

<ul>
<li> <p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
</li></ul>

<p>Underlying concepts and formal definitions of spatial plateau data types are explained in detail in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pcomp1 &lt;- create_component("MULTIPOINT(1 2, 3 2)", 0.4)
pcomp2 &lt;- create_component("POINT(2 1)", 0.3)
ppoint &lt;- create_pgeometry(list(pcomp1, pcomp2), "PLATEAUPOINT")

# using spa_pwkt()
spa_pwkt(ppoint) 
# using show() to display the content of ppoint
ppoint
# using format with width = 30 (default value)
format(ppoint)

lcomp1 &lt;- create_component("LINESTRING(1 2, 3 3, 3 4)", 1)
lcomp2 &lt;- create_component("LINESTRING(0 0, 5 5)", 0.5)
pline &lt;- create_pgeometry(list(lcomp1, lcomp2), "PLATEAULINE")

spa_pwkt(pline)

rcomp1 &lt;- create_component("POLYGON((40 40, 20 48, 48 35, 40 40))", 0.8)
rcomp2 &lt;- create_component("POLYGON((10 0, 40 18, 10 20, 5 18, 10 0))", 0.2)
pregion &lt;- create_pgeometry(list(rcomp1, rcomp2), "PLATEAUREGION")

spa_pwkt(pregion)

pcomposition &lt;- create_pgeometry(list(ppoint, pline, pregion), "PLATEAUCOMPOSITION")

spa_pwkt(pcomposition)

pcomp3 &lt;- create_component("POINT(10 15)", 0.3)
ppoint2 &lt;- create_pgeometry(list(pcomp3), "PLATEAUPOINT")

pcollection &lt;- create_pgeometry(list(pcomposition, ppoint2), "PLATEAUCOLLECTION")

spa_pwkt(pcollection)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as_tibble'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='spa_add_component'>Add components to a <code>pgeometry</code> object</h2><span id='topic+spa_add_component'></span>

<h3>Description</h3>

<p><code>spa_add_component()</code> inserts components into a spatial plateau object (i.e., <code>pgeometry</code> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_add_component(pgo, components, is_valid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_add_component_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="spa_add_component_+3A_components">components</code></td>
<td>
<p>A <code>component</code> object or a list of <code>component</code> objects.</p>
</td></tr>
<tr><td><code id="spa_add_component_+3A_is_valid">is_valid</code></td>
<td>
<p>A Boolean value to check if the user wants to validate the updated spatial plateau object at the end. If <code>is_valid = TRUE</code>, it calls <code>validObject()</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code class="reqn">\odot</code> operator defined by Spatial Plateau Algebra.
The goal of this function is to insert a component or a list of components into a <code>pgeometry</code> object.
The crisp spatial object of the component must be compatible with the type of the plateau spatial object.
For instance, a <code>pregion</code> object accepts only components containing polygons (e.g., <code>POLYGON</code> or <code>MULTIPOLYGON</code>).
In the case of <code>pcomposition</code> object any type of component is compatible to be added.
For instance, a point component is added to the plateau point sub-object of the plateau composition object.
On the other hand, as a <code>pcollection</code> object can have multiple spatial objects of the same type, this function is not applicable to it.
</p>
<p>The insertion is based on the membership degree of the component. Thus, it preserves the properties of a spatial plateau object.
However, <code>spa_add_component()</code> assumes that the geometric format of the component is valid (i.e., it does not overlap with existing components).
</p>


<h3>Value</h3>

<p>A <code>pgeometry</code> object containing the <code>component</code> objects.
</p>


<h3>References</h3>

<p>The formal definition of the <code class="reqn">\odot</code> operator is described in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>comp1 &lt;- create_component("MULTIPOINT(1 1, 2 2)", 0.2) 
comp2 &lt;- create_component("POINT(1 5)", 0.8)  

# appending these components into an empty pgeometry object
pp &lt;- create_empty_pgeometry("PLATEAUPOINT")
pp &lt;- spa_add_component(pp, list(comp1, comp2))
pp

# inserting components with existing membership degrees are merged
comp3 &lt;- create_component("MULTIPOINT(0 0, 4 4)", 0.2)
pp &lt;- spa_add_component(pp, comp3)
pp

comp4 &lt;- create_component("MULTIPOINT(0 1, 3 4)", 1)
pc &lt;- create_pgeometry(list(comp4), "PLATEAUCOMPOSITION")
pc

# appending these components into pc
comp5 &lt;- create_component("LINESTRING(-1 1, 2 2)", 0.9)
comp6 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
pc &lt;- spa_add_component(pc, list(comp5, comp6))
pc
</code></pre>

<hr>
<h2 id='spa_boundary'>Capture the fuzzy boundary of a spatial plateau object</h2><span id='topic+spa_boundary'></span>

<h3>Description</h3>

<p><code>spa_boundary()</code> yields the fuzzy boundary of a homogeneous spatial plateau object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_boundary(pgo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_boundary_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of type <code>ppoint</code>, <code>pline</code>, or <code>pregion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_boundary()</code> function employs the definition of <em>fuzzy boundary</em> in the context of Spatial Plateau Algebra.
The <em>fuzzy boundary</em> of a fuzzy spatial object has a heterogeneous nature. For instance, the fuzzy boundary of a plateau region object consists of two parts:
</p>

<ul>
<li><p> a plateau line object that corresponds to the boundary of the core of <code>A</code>.
</p>
</li>
<li><p> a plateau region object that comprises all points of <code>A</code> with a membership degree greater than 0 and less than 1.
</p>
</li></ul>

<p>This means that <code>spa_boundary()</code> returns a <code>pcomposition</code> object.
</p>


<h3>Value</h3>

<p>A <code>pcomposition</code> object that represents a fuzzy boundary of the <code>pgeometry</code> object given as input.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Concepts and formal definitions of fuzzy boundary are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/7737976">Carniel, A. C.; Schneider, M. A Conceptual Model of Fuzzy Topological Relationships for Fuzzy Regions. In Proceedings of the 2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(sf)
library(ggplot2)

# defining two different types of membership functions
trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

set.seed(7)
tbl = tibble(x = runif(20, min = 0, max = 30), 
             y = runif(20, min = 0, max = 50), 
             z = runif(20, min = 0, max = 100))
classes &lt;- c("cold", "hot")
cold_mf &lt;- trap_mf(0, 10, 20, 35)
hot_mf &lt;- trap_mf(20, 50, 100, 100)

# Getting the convex hull on the points to clip plateau region objects during their constructions
pts &lt;- st_as_sf(tbl, coords = c(1, 2))
ch &lt;- st_convex_hull(do.call(c, st_geometry(pts)))

# Using the standard fuzzification policy based on fuzzy sets
pregions &lt;- spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf), base_poly = ch)
## Not run: 
pregions
plot(pregions$pgeometry[[1]]) + ggtitle("Cold")
plot(pregions$pgeometry[[2]]) + ggtitle("Hot")

## End(Not run)
# capturing and showing the boundary of each pgeometry object previously created
boundary_cold &lt;- spa_boundary(pregions$pgeometry[[1]])
boundary_hot &lt;- spa_boundary(pregions$pgeometry[[2]])
## Not run: 
plot(boundary_cold) + ggtitle("Boundary (Cold)")
plot(boundary_hot) + ggtitle("Boundary (Hot)")

## End(Not run)
</code></pre>

<hr>
<h2 id='spa_boundary_pregion'>Capture the fuzzy boundary of a plateau region object</h2><span id='topic+spa_boundary_pregion'></span>

<h3>Description</h3>

<p><code>spa_boundary_pregion()</code> yields a specific part of the fuzzy boundary of a plateau region object. This function is deprecated; use <code>spa_boundary()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_boundary_pregion(pregion, bound_part = "region")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_boundary_pregion_+3A_pregion">pregion</code></td>
<td>
<p>A <code>pregion</code> object. It throws an error if a different type is given.</p>
</td></tr>
<tr><td><code id="spa_boundary_pregion_+3A_bound_part">bound_part</code></td>
<td>
<p>A character value that indicates the part of the fuzzy boundary to be returned. It can be <code>"region"</code> or <code>"line"</code>. See below for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_boundary_pregion()</code> function employs the definition of <em>fuzzy boundary</em> of a fuzzy region object in the context of Spatial Plateau Algebra.
The <em>fuzzy boundary</em> of a fuzzy region object <code>A</code> has a heterogeneous nature since it consists of two parts:
</p>

<ul>
<li><p> a fuzzy line object that corresponds to the boundary of the core of <code>A</code>.
</p>
</li>
<li><p> a fuzzy region object that comprises all points of <code>A</code> with a membership degree greater than 0 and less than 1.
</p>
</li></ul>

<p>This means that <code>spa_boundary_pregion()</code> can yield one specific part of the fuzzy boundary of a plateau region object.
If <code>boundary = "line"</code>, then the function returns the boundary plateau line of <code>pregion</code> (i.e., returns a <code>pline</code> object).
Else if <code>boundary = "region"</code> (the default value), then the function returns the boundary plateau region of <code>pregion</code> (i.e., returns a <code>pregion</code> object).
</p>
<p>This function is deprecated; use <code>spa_boundary()</code>.
</p>


<h3>Value</h3>

<p>A <code>pgeometry</code> object that represents a specific part of the fuzzy boundary of <code>pgeometry</code> object given as input.
</p>


<h3>References</h3>

<p>Concepts of fuzzy boundary of plateau region objects are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/7737976">Carniel, A. C.; Schneider, M. A Conceptual Model of Fuzzy Topological Relationships for Fuzzy Regions. In Proceedings of the 2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tibble)
library(sf)
library(ggplot2)

# defining two different types of membership functions
trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

trim_mf &lt;- function(a, b, c) {
  function(x) {
    pmax(pmin((x - a)/(b - a), (c - x)/(c - b), na.rm = TRUE), 0)
  }
}

set.seed(7)
tbl = tibble(x = runif(10, min = 0, max = 30), 
             y = runif(10, min = 0, max = 50), 
             z = runif(10, min = 0, max = 100))
classes &lt;- c("cold", "hot")
cold_mf &lt;- trap_mf(0, 10, 20, 35)
hot_mf &lt;- trim_mf(35, 50, 100)

# Getting the convex hull on the points to clip plateau region objects during their constructions
pts &lt;- st_as_sf(tbl, coords = c(1, 2))
ch &lt;- st_convex_hull(do.call(c, st_geometry(pts)))

# Using the standard fuzzification policy based on fuzzy sets
pregions &lt;- spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf), base_poly = ch)
plot(pregions$pgeometry[[1]]) + ggtitle("Cold")
plot(pregions$pgeometry[[2]]) + ggtitle("Hot")

# these functions are now deprecated, use `spa_boundary()`

# capturing and showing the boundary plateau line of each pgeometry object previously created
(spa_boundary_pregion(pregions$pgeometry[[1]], bound_part = "line")) 
(spa_boundary_pregion(pregions$pgeometry[[2]], bound_part = "line"))
# this part of the boundary is empty because there is no core! 
# capturing and showing the boundary plateau region (this is the default behavior)
(spa_boundary_pregion(pregions$pgeometry[[1]]))
(spa_boundary_pregion(pregions$pgeometry[[2]]))

## End(Not run)
</code></pre>

<hr>
<h2 id='spa_contour'>Capture the frontier of a plateau region object</h2><span id='topic+spa_contour'></span>

<h3>Description</h3>

<p><code>spa_contour()</code> extracts the frontier (i.e., linear boundary) of a plateau region object by maintaining its membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_contour(pregion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_contour_+3A_pregion">pregion</code></td>
<td>
<p>A <code>pregion</code> object. It throws an error if a different type is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_contour()</code> function implements the definition of <em>fuzzy frontier</em> of a fuzzy region object in the context of Spatial Plateau Algebra.
The <em>fuzzy frontier</em> of a fuzzy region object <code>A</code> collects all single points of <code>A</code>, preserving its membership degrees, that are not in the interior of its support.
</p>
<p>Note that fuzzy frontier is different from fuzzy boundary (see <code>spa_boundary()</code>).
</p>


<h3>Value</h3>

<p>A <code>pline</code> object that represents the contour (i.e. frontier) of a plateau region object given as input.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/7737976">Carniel, A. C.; Schneider, M. A Conceptual Model of Fuzzy Topological Relationships for Fuzzy Regions. In Proceedings of the 2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(sf)
library(ggplot2)

# defining two different types of membership functions
trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

set.seed(7)
tbl = tibble(x = runif(20, min = 0, max = 30), 
             y = runif(20, min = 0, max = 50), 
             z = runif(20, min = 0, max = 100))
classes &lt;- c("cold", "hot")
cold_mf &lt;- trap_mf(0, 10, 20, 35)
hot_mf &lt;- trap_mf(20, 50, 100, 100)

# Getting the convex hull on the points to clip plateau region objects during their constructions
pts &lt;- st_as_sf(tbl, coords = c(1, 2))
ch &lt;- st_convex_hull(do.call(c, st_geometry(pts)))

# Using the standard fuzzification policy based on fuzzy sets
pregions &lt;- spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf), base_poly = ch)
pregions
## Not run: 
plot(pregions$pgeometry[[1]]) + ggtitle("Cold")
plot(pregions$pgeometry[[2]]) + ggtitle("Hot")

## End(Not run)
# capturing and showing the frontier of each pgeometry object previously created
cold_contour &lt;- spa_contour(pregions$pgeometry[[1]])
hot_contour &lt;- spa_contour(pregions$pgeometry[[2]])
## Not run: 
plot(cold_contour) + ggtitle("Frontier (Cold)")
plot(hot_contour) + ggtitle("Frontier (Hot)")

## End(Not run)
</code></pre>

<hr>
<h2 id='spa_core'>Get the core of a <code>pgeometry</code> object</h2><span id='topic+spa_core'></span>

<h3>Description</h3>

<p><code>spa_core()</code> yields a crisp spatial object (as an <code>sfg</code> object) that corresponds to the core of a <code>pgeometry</code> object given as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_core(pgo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_core_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_core()</code> function employs the classical definition of <em>core</em> from the fuzzy set theory in the context of Spatial Plateau Algebra.
The <em>core</em> only comprises the points with membership degree equal to 1.
Hence, this operation returns the <code>sfg</code> object that represents the component labeled with
membership degree equal to 1 of the <code>pgeometry</code> object given as input. If the <code>pgeometry</code> object has no core, then an empty <code>sfg</code> object is returned.
</p>


<h3>Value</h3>

<p>An <code>sfg</code> object that represents the core of <code>pgo</code>. It can be an empty object, if <code>pgo</code> does not have a component with membership degree 1.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of Spatial Plateau Algebra are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((1 2), (2 1), (3 2))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0.5), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3.5))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (4 2))", 0.4)

# Creating a plateau point object
ppoint &lt;- create_pgeometry(list(pcp1, pcp2, pcp3, pcp4, pcp5), "PLATEAUPOINT")
ppoint

# Getting its core
spa_core(ppoint)

# Getting the core of an empty pgeometry
spa_core(create_empty_pgeometry("PLATEAUREGION"))
</code></pre>

<hr>
<h2 id='spa_creator'>Build <code>pgeometry</code> objects from a point dataset</h2><span id='topic+spa_creator'></span>

<h3>Description</h3>

<p><code>spa_creator()</code> builds a set of spatial plateau objects from a given point dataset assigned with domain-specific numerical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_creator(tbl, fuzz_policy = "fsp", const_policy = "voronoi", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_creator_+3A_tbl">tbl</code></td>
<td>
<p>A <code>data.frame</code> or <code>tibble</code> object with three columns: (<em>x</em>, <em>y</em>, <em>z</em>).</p>
</td></tr>
<tr><td><code id="spa_creator_+3A_fuzz_policy">fuzz_policy</code></td>
<td>
<p>The fuzzification policy to be employed by the algorithm. See details below.</p>
</td></tr>
<tr><td><code id="spa_creator_+3A_const_policy">const_policy</code></td>
<td>
<p>The construction policy to be used by the algorithm. See details below.</p>
</td></tr>
<tr><td><code id="spa_creator_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Parameters for the chosen policies. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_creator()</code> function implements a two-stage construction method that takes as input a point dataset and produces a set of spatial plateau objects as output.
</p>
<p>The input <code>tbl</code> is a point dataset (<code>data.frame</code> or <code>tibble</code> object) where each point represents the location of a phenomenon treated by the application.
Further, each point is annotated with numerical data that describe its meaning in the application.
Therefore, <code>tbl</code> must have three columns: (<em>x</em>, <em>y</em>, <em>z</em>). The columns <em>x</em>, <em>y</em> are the coordinate pairs, and <em>z</em> is the column containing domain-specific numeric values.
</p>
<p>The parameter <code>fuzz_policy</code> refers to the method used by the <strong>fuzzification stage</strong>.
This stage aims to assign membership degrees to each point of the dataset.
It accepts two possible values: <code>"fsp"</code> (default) or <code>"fcp"</code>.
</p>
<p><code>"fsp"</code> stands for <em>fuzzy set policy</em> and requires two parameters that should be informed in <code>...</code>:
</p>

<ul>
<li> <p><code>classes</code>: A character vector containing the name of classes.
</p>
</li>
<li> <p><code>mfs</code>: A vector of membership functions. Each membership function <em>i</em> represents the class <em>i</em>, where <em>i</em> in <code>length(classes)</code>. See the provided examples for more information on how to build membership functions.
</p>
</li></ul>

<p><code>"fcp"</code> stands for <em>fuzzy clustering policy</em> and requires the <code>e1071</code> package. Its possible parameters informed in <code>...</code> are:
</p>

<ul>
<li> <p><code>k</code>: A numeric value that refers to the number of groups to be created.
</p>
</li>
<li> <p><code>method</code>: A fuzzy clustering method of the package <code>e1071</code>, which can be either <code>"cmeans"</code> (default) or <code>"cshell"</code>.
</p>
</li>
<li> <p><code>use_coords</code>: A Boolean value to indicate whether the columns (<em>x</em>, <em>y</em>) should be used in the clustering algorithm (default is <code>FALSE</code>).
</p>
</li>
<li> <p><code>iter</code>: A numeric indicating the number of maximum iterations of the clustering algorithm (default is 100).
</p>
</li></ul>

<p>An optional and common parameter for both fuzzification stages is <code>"digits"</code>.
This is an integer value that indicates the number of decimal digits of the membership degrees calculated by the fuzzification stage.
That is, it is used to <strong>round</strong> membership degrees to the specified number of decimal places.
Be careful with this optional parameter! If you specify a low value for <code>"digits"</code>, some membership degrees could be rounded to 0 and thus, some components would not be created.
</p>
<p>The parameter <code>const_policy</code> refers to the method used by the <strong>construction stage</strong>.
This stage aims to create polygons from the labeled point dataset and use them to build spatial plateau objects.
It accepts three possible values: <code>"voronoi"</code> (default), &quot;<code style="white-space: pre;">&#8288;delaunay"&#8288;</code>, or <code>"convex_hull"</code>.
</p>
<p><code>"voronoi"</code> stands for <em>Voronoi diagram policy</em> and has two optional parameter that can be provided in <code>...</code>:
</p>

<ul>
<li> <p><code>base_poly</code>: An <code>sfg</code> object that will be used to clip the generated polygons. If this parameter is not provided, the Voronoi is created by using a bounding box (standard behavior of the package <code>sf</code>).
</p>
</li>
<li> <p><code>d_tolerance</code>: It refers to the parameter <code>dTolerance</code> employed by the function <code>st_voronoi()</code> of the package <code>sf</code>.
</p>
</li></ul>

<p><code>"delaunay"</code> stands for <em>Delaunay triangulation policy</em>, which accepts the following parameters in <code>...</code>:
</p>

<ul>
<li> <p><code>base_poly</code>: An <code>sfg</code> object that will be used to clip the generated triangles.
</p>
</li>
<li> <p><code>tnorm</code>: A t-norm used to calculate the membership degree of the triangle. It should be the name of a vectorized function.
Possible values are <code>"min"</code> (default) and <code>"prod"</code>.
Note that it is possible to use your own t-norms. A t-norm should has the following signature: <code>FUN(x)</code> where <em>x</em> is a numeric vector. Such a function should return a single numeric value.
</p>
</li>
<li> <p><code>d_tolerance</code>: It refers to the parameter <code>dTolerance</code> employed by the function <code>st_triangulate()</code> of the package <code>sf</code>.
</p>
</li></ul>

<p><code>"convex_hull"</code> stands for <em>Convex hull policy</em>, which accepts the following parameters in <code>...</code>:
</p>

<ul>
<li> <p><code>degrees</code>: A numeric vector containing the membership degrees that will be used to create the components. The default vector is defined by <code>seq(0.05, 1, by = 0.05)</code>.
</p>
</li>
<li> <p><code>d</code>: A numeric value representing the tolerance distance to compute the membership degree between the elements of <code>m</code> and the membership degrees of the points. The default is <code>0.05</code>.
</p>
</li>
<li> <p><code>base_poly</code>: An <code>sfg</code> object that will be used to clip the generated polygons.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble in the format <code style="white-space: pre;">&#8288;(class, pgeometry)&#8288;</code>, where <code>class</code> is a character column and <code>pgeometry</code> is a list of <code>pgeometry</code> objects.
This means that a spatial plateau object is created for representing a specific class of the point dataset.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of the two-stage construction method is introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8858878/">Carniel, A. C.; Schneider, M. A Systematic Approach to Creating Fuzzy Region Objects from Real Spatial Data Sets. In Proceedings of the 2019 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2019), pp. 1-6, 2019.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(sf)
library(ggplot2)
 
# Defining two different types of membership functions
trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

trim_mf &lt;- function(a, b, c) {
  function(x) {
    pmax(pmin((x - a)/(b - a), (c - x)/(c - b), na.rm = TRUE), 0)
  }
}

set.seed(7)
tbl = tibble(x = runif(10, min = 0, max = 30), 
             y = runif(10, min = 0, max = 50), 
             z = runif(10, min = 0, max = 100))
classes &lt;- c("cold", "hot")
cold_mf &lt;- trap_mf(0, 10, 20, 35)
hot_mf &lt;- trim_mf(35, 50, 100)

# Using the standard fuzzification policy based on fuzzy sets
res &lt;- spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf))
## Not run: 
res  
plot(res$pgeometry[[1]]) + ggtitle("Cold")
plot(res$pgeometry[[2]]) + ggtitle("Hot")

# Getting the convex hull on the points to clip plateau region objects during their constructions
pts &lt;- st_as_sf(tbl, coords = c(1, 2))
ch &lt;- st_convex_hull(do.call(c, st_geometry(pts)))
res &lt;- spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf), base_poly = ch)
plot(res$pgeometry[[1]]) + ggtitle("Cold (with clipped boundaries)")
plot(res$pgeometry[[2]]) + ggtitle("Hot (with clipped boundaries)")
 
# Using the fuzzification policy based on fuzzy clustering
spa_creator(tbl, fuzz_policy = "fcp", k = 4)

spa_creator(tbl, fuzz_policy = "fcp", k = 4, digits = 2)

# Varying the construction policy
spa_creator(tbl, fuzz_policy = "fcp", k = 3, const_policy = "delaunay")

spa_creator(tbl, fuzz_policy = "fcp", const_policy = "delaunay", k = 3, tnorm = "prod")

spa_creator(tbl, fuzz_policy = "fcp", k = 2, digits = 2, 
            degrees = seq(0.1, 1, by = 0.1), d = 0.05, const_policy = "convex_hull")

spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf), const_policy = "delaunay")
            
spa_creator(tbl, classes = classes, mfs = c(cold_mf, hot_mf), 
            digits = 2, const_policy = "convex_hull")

## End(Not run)
</code></pre>

<hr>
<h2 id='spa_eval'>Evaluate the membership degree of a point in a <code>pgeometry</code> object</h2><span id='topic+spa_eval'></span>

<h3>Description</h3>

<p><code>spa_eval()</code> evaluates the membership degree of a given point in a spatial plateau object of any type.
It returns a value in [0, 1] that indicates to which extent the point belongs to the <code>pgeometry</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_eval(pgo, point)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_eval_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
<tr><td><code id="spa_eval_+3A_point">point</code></td>
<td>
<p>An <code>sfg</code> object of the type <code>POINT</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_eval()</code> returns the membership degree of a simple point object (i.e., <code>sfg</code> object) in a given spatial plateau object (i.e., <code>pgeometry</code> object).
This evaluation depends on the following basic cases:
</p>

<ul>
<li><p> if the simple point object belongs to the interior or boundary of <em>one</em> component of the spatial plateau object, it returns the membership degree of that component.
</p>
</li>
<li><p> if the simple point object intersects more components (e.g., boundaries of region components, or different line components), it returns the maximum membership degree of all intersected components.
</p>
</li>
<li><p> if the simple point object is disjoint to the support of the spatial plateau object, it returns 0.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric value between 0 and 1 that indicates the membership degree of a point (i.e., <code>sfg</code> object) in a spatial plateau object (i.e., <code>pgeometry</code> object).
</p>


<h3>References</h3>

<p>Formal definitions of this function are described in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/9882658">Carniel, A. C.; Galdino, F.; Schneider, M. Evaluating Region Inference Methods by Using Fuzzy Spatial Inference Models. In Proceedings of the 2022 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2022), pp. 1-8, 2022.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Point components
pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((1 2), (2 1), (3 2))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0.5), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3.5))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (4 2))", 0.4)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)
lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
lcp5 &lt;- create_component("LINESTRING(-1 1, 2 2)", 0.9)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)

# Creating spatial plateau objects
ppoint &lt;- create_pgeometry(list(pcp1, pcp2, pcp3, pcp4, pcp5), "PLATEAUPOINT")
pline &lt;- create_pgeometry(list(lcp1, lcp2, lcp3), "PLATEAULINE")
pregion &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")
pcomp &lt;- create_pgeometry(list(pcp6, pcp7, lcp4, lcp5), "PLATEAUCOMPOSITION")
pcol &lt;- create_pgeometry(list(ppoint, pline, pregion, pcomp), "PLATEAUCOLLECTION")

point &lt;- st_point(c(0, 0))

spa_eval(ppoint, point)
spa_eval(pline, point)
spa_eval(pregion, point)
spa_eval(pcomp, point)
spa_eval(pcol, point)
</code></pre>

<hr>
<h2 id='spa_exact_equal'>Check two spatial plateau objects for exact equality</h2><span id='topic+spa_exact_equal'></span>

<h3>Description</h3>

<p><code>spa_exact_equal()</code> checks whether two spatial plateau objects are exactly equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_exact_equal(pgo1, pgo2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_exact_equal_+3A_pgo1">pgo1</code></td>
<td>
<p>A <code>pgeometry</code> object that is either a plateau point, plateau line, or plateau region object.</p>
</td></tr>
<tr><td><code id="spa_exact_equal_+3A_pgo2">pgo2</code></td>
<td>
<p>A <code>pgeometry</code> object that is either a plateau point, plateau line, or plateau region object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spa_exact_equal()</code> is a Boolean function that checks <em>fuzzy equality</em> in the spatial plateau context. Two <code>pgeometry</code> objects are exactly equal if their components are equal.
Two components are equal if they have the same membership degree and they are (spatially) equal (i.e., their <code>sfg</code> objects have the same geometric format - this means that the order of the points can be different).
</p>


<h3>Value</h3>

<p>A Boolean value that indicates if two <code>pgeometry</code> objects are exactly equal.
</p>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcp1 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp2 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp3 &lt;- create_component("MULTIPOINT((10 10), (9 8), (7 7))", 1)
pcp4 &lt;- create_component("MULTIPOINT((0 0), (2 3))", 0.7)

ppoint1 &lt;- create_pgeometry(list(pcp1, pcp2), "PLATEAUPOINT")
ppoint2 &lt;- create_pgeometry(list(pcp3, pcp4), "PLATEAUPOINT")

spa_exact_equal(ppoint1, ppoint2)

spa_exact_equal(ppoint1, ppoint1)
</code></pre>

<hr>
<h2 id='spa_exact_inside'>Check two spatial plateau objects for exact containment</h2><span id='topic+spa_exact_inside'></span>

<h3>Description</h3>

<p><code>spa_exact_inside()</code> checks whether a <code>pgeometry</code> object is completely inside of another <code>pgeometry</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_exact_inside(pgo1, pgo2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_exact_inside_+3A_pgo1">pgo1</code></td>
<td>
<p>A <code>pgeometry</code> object that is either a plateau point, plateau line, or plateau region object.</p>
</td></tr>
<tr><td><code id="spa_exact_inside_+3A_pgo2">pgo2</code></td>
<td>
<p>A <code>pgeometry</code> object that is either a plateau point, plateau line, or plateau region object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spa_exact_inside()</code> is a Boolean function that checks <em>fuzzy containment</em> in the spatial plateau context.
This Boolean function checks whether the components of <code>pgo1</code> are contained in the components of <code>pgo2</code>
by considering their membership degrees and geographic positions. That is, it follows the classical definition of fuzzy containment of the fuzzy set theory.
</p>
<p>In other words, this function checks if the (standard) intersection of <code>pgo1</code> and <code>pgo2</code> is exactly equal to <code>pgo1</code>. The other of operands affects the result.
</p>


<h3>Value</h3>

<p>A Boolean value that indicates if a <code>pgeometry</code> is completely and certainly inside <code>pgo2</code>.
</p>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcp1 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp2 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp3 &lt;- create_component("POINT(2 2)", 0.2)
pcp4 &lt;- create_component("MULTIPOINT((1 1), (3 3))", 0.7)

ppoint1 &lt;- create_pgeometry(list(pcp1, pcp2), "PLATEAUPOINT")
ppoint2 &lt;- create_pgeometry(list(pcp3, pcp4), "PLATEAUPOINT")

# is ppoint2 completely and certainly inside ppoint1?
spa_exact_inside(ppoint2, ppoint1)

# The order of operands after the result
# ppoint1 is not inside ppoint2 since it has different points
spa_exact_inside(ppoint1, ppoint2)
</code></pre>

<hr>
<h2 id='spa_flatten'>Flatten a plateau collection object</h2><span id='topic+spa_flatten'></span>

<h3>Description</h3>

<p><code>spa_flatten()</code> gathers all the objects of a plateau collection object and
reorganizes them into a single flattened spatial plateau object containing a quadruple
(<code>PLATEAUPOINT</code>, <code>PLATEAULINE</code>, <code>PLATEAUREGION</code>, <code>PLATEAUCOMPOSITION</code>) that preserves the identity of sub-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_flatten(pcol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_flatten_+3A_pcol">pcol</code></td>
<td>
<p>A <code>pcollection</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_flatten()</code> function yields a single flattened spatial plateau object, aggregating all spatial plateau objects by their types.
In the case of a two-level hierarchy, i.e., a plateau collection inside another one,
the function is applied recursively in the lower levels until the quadruple is built. Hence, it simplifies the representation of complex plateau collection objects.
The t-conorm considered in the aggregation is the <code>max</code> operator.
</p>


<h3>Value</h3>

<p>A <code>pcollection</code> object consisting of a quadruple (<code>PLATEAUPOINT</code>, <code>PLATEAULINE</code>, <code>PLATEAUREGION</code>, <code>PLATEAUCOMPOSITION</code>).
</p>


<h3>References</h3>

<p><a href="https://ieeexplore.ieee.org/document/9177620">Carniel, A. C.; Schneider, M. Spatial Data Types for Heterogeneously Structured Fuzzy Spatial Collections and Compositions. In Proceedings of the 2020 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2020), pp. 1-8, 2020.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Point components
pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((10 10), (9 8), (7 7))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (2 3))", 0.4)
# Line components
lcp1 &lt;- create_component("LINESTRING(0 0, 1 1.5)", 0.2)
lcp2 &lt;- create_component("LINESTRING(1 3, 1 2, 2 0.5)", 0.5)
lcp3 &lt;- create_component("LINESTRING(2 1.2, 3 1.6, 4 4)", 0.7)
lcp4 &lt;- create_component("LINESTRING(1 1.5, 2 1.2)", 1.0)
lcp5 &lt;- create_component("LINESTRING(-1 1, 2 2)", 0.9)
# Polygon components
rcp1 &lt;- create_component("POLYGON((0 0, 1 4, 2 2, 0 0))", 0.4)
rcp2 &lt;- create_component("POLYGON((2 0.5, 4 1, 4 0, 2 0.5))", 0.8)

# Creating plateau point objects
ppoint1 &lt;- create_pgeometry(list(pcp1, pcp2, pcp3), "PLATEAUPOINT")
ppoint2 &lt;- create_pgeometry(list(pcp4, pcp5), "PLATEAUPOINT")
ppoint3 &lt;- create_pgeometry(list(pcp4, pcp5), "PLATEAUPOINT")
ppoint4 &lt;- create_pgeometry(list(pcp6, pcp7), "PLATEAUPOINT")
# Creating plateau line objects
pline1 &lt;- create_pgeometry(list(lcp1, lcp3), "PLATEAULINE")
pline2 &lt;- create_pgeometry(list(lcp2, lcp4), "PLATEAULINE")
pline3 &lt;- create_pgeometry(list(lcp5), "PLATEAULINE")
# Creating a plateau region objects
pregion &lt;- create_pgeometry(list(rcp1, rcp2), "PLATEAUREGION")
# Creating a plateau composition object
pcomposition &lt;- create_pgeometry(list(ppoint4, pline3), "PLATEAUCOMPOSITION")
# Creating plateau collection objects
pcol1 &lt;- create_pgeometry(list(ppoint1, ppoint2, ppoint3, pline1), "PLATEAUCOLLECTION")
pcol2 &lt;- create_pgeometry(list(pline2, pregion, pcomposition, pcol1), "PLATEAUCOLLECTION")
## Not run: 
pcol2
plot(pcol2)

flatten_col &lt;- spa_flatten(pcol2)
flatten_col
plot(flatten_col)

## End(Not run)
</code></pre>

<hr>
<h2 id='spa_get_type'>Get the type of a spatial plateau object</h2><span id='topic+spa_get_type'></span>

<h3>Description</h3>

<p><code>spa_get_type()</code> returns the type of a spatial plateau object.
It can be either <code>"PLATEAUPOINT"</code>, <code>"PLATEAULINE"</code>, <code>"PLATEAUREGION"</code>, <code>"PLATEAUCOMPOSITION"</code>, or <code>"PLATEAUCOLLECTION"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_get_type(pgo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_get_type_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_get_type()</code> function yields the type of a spatial plateau object given as input.
For instance, if the <code>pgo</code> is a object of the class <code>ppoint</code> (subclass of <code>pgeometry</code>), it returns <code>"PLATEAUPOINT"</code>.
</p>


<h3>Value</h3>

<p>The type of a spatial plateau object as a character object (i.e., a string).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcomp1 &lt;- create_component("MULTIPOINT(1 2, 3 2)", 0.4)
pcomp2 &lt;- create_component("POINT(2 1)", 0.3)
ppoint &lt;- create_pgeometry(list(pcomp1, pcomp2), "PLATEAUPOINT")

spa_get_type(ppoint) 

lcomp1 &lt;- create_component("LINESTRING(1 2, 3 3, 3 4)", 1)
lcomp2 &lt;- create_component("LINESTRING(0 0, 5 5)", 0.5)
pline &lt;- create_pgeometry(list(lcomp1, lcomp2), "PLATEAULINE")

spa_get_type(pline)

pcomposition &lt;- create_pgeometry(list(ppoint, pline), "PLATEAUCOMPOSITION")

spa_get_type(pcomposition)
</code></pre>

<hr>
<h2 id='spa_is_empty'>Check if a <code>pgeometry</code> object is empty</h2><span id='topic+spa_is_empty'></span>

<h3>Description</h3>

<p><code>spa_is_empty()</code> checks whether a given <code>pgeometry</code> object is empty (i.e., if it does not contain components).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_is_empty(pgo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_is_empty_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_is_empty()</code> function checks if a pgeometry object has any component or not. If the number of components of a <code>pgeometry</code> object is equal to 0, then
it returns <code>TRUE</code>. Otherwise, it returns <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A Boolean value that indicates if a <code>pgeometry</code> is empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating an empty plateau line object 
pgo1 &lt;- create_empty_pgeometry("PLATEAULINE")

# Checking if it is empty
spa_is_empty(pgo1)

# Adding a component to it and checking if it still empty
comp &lt;- create_component("LINESTRING(1 1, 2 2, 2 3)", 0.5)
pgo1 &lt;- spa_add_component(pgo1, comp)
spa_is_empty(pgo1)  
</code></pre>

<hr>
<h2 id='spa_set_classification'>Set a new classification for fuzzy topological relationships</h2><span id='topic+spa_set_classification'></span>

<h3>Description</h3>

<p><code>spa_set_classification()</code> configures a new set of linguistic values and corresponding membership functions to be used by fuzzy topological relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_set_classification(classes, mfs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_set_classification_+3A_classes">classes</code></td>
<td>
<p>A character vector containing linguistic values that characterizes different situations of fuzzy topological relationships.</p>
</td></tr>
<tr><td><code id="spa_set_classification_+3A_mfs">mfs</code></td>
<td>
<p>A vector of membership functions with domain in [0, 1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_set_classification()</code> function replaces the default linguistic values employed by fuzzy topological relationships.
Each membership function <em>i</em> of the parameter <code>mfs</code> represents the class <em>i</em> of the parameter <code>classes</code>.
The length of these parameters must to be equal.
</p>


<h3>Value</h3>

<p>No return values, called for side effects.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of spatial plateau topological relationships and fuzzy topological relationships are respectively introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li>
<li> <p><a href="https://ieeexplore.ieee.org/document/7737976">Carniel, A. C.; Schneider, M. A Conceptual Model of Fuzzy Topological Relationships for Fuzzy Regions. In Proceedings of the 2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2016), pp. 2271-2278, 2016.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tibble)
library(sf)

set.seed(456)

# Generating some random points to create pgeometry objects by using spa_creator()
tbl = tibble(x = runif(10, min= 0, max = 30), 
             y = runif(10, min = 0, max = 30), 
             z = runif(10, min = 0, max = 50))

# Getting the convex hull on the points to clip plateau region objects during their constructions
pts &lt;- st_as_sf(tbl, coords = c(1, 2))
ch &lt;- st_convex_hull(do.call(c, st_geometry(pts)))

pregions &lt;- spa_creator(tbl, base_poly = ch, fuzz_policy = "fcp", k = 2)

plot(pregions$pgeometry[[1]])
plot(pregions$pgeometry[[2]])

# Showing results for spa_overlap() by considering default list of classes
spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")

## End(Not run)
# Changing the default classification 
trap_mf &lt;- function(a, b, c, d) {
  function(x) {
    pmax(pmin((x - a)/(b - a), 1, (d - x)/(d - c), na.rm = TRUE), 0)
  }
}

classes &lt;- c("superficially", "moderately", "completely")
superficially &lt;- trap_mf(0, 0.2, 0.4, 0.6)
moderately &lt;- trap_mf(0.4, 0.6, 0.8, 1)
completely &lt;- trap_mf(0.6, 0.8, 1, 1)

spa_set_classification(classes, c(superficially, moderately, completely))
## Not run: 
# Now the fuzzy topological relationships will use the new classification
spa_overlap(pregions$pgeometry[[1]], pregions$pgeometry[[2]], ret = "list")

## End(Not run)
</code></pre>

<hr>
<h2 id='spa_support'>Get the support of a <code>pgeometry</code> object</h2><span id='topic+spa_support'></span>

<h3>Description</h3>

<p><code>spa_support()</code> yields a crisp spatial object (as an <code>sfg</code> object) that corresponds to the support of a <code>pgeometry</code> object given as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spa_support(pgo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spa_support_+3A_pgo">pgo</code></td>
<td>
<p>A <code>pgeometry</code> object of any type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spa_support()</code> function employs the classical definition of <em>support</em> from the fuzzy set theory in the context of Spatial Plateau Algebra.
The <em>support</em> only comprises the points with membership degree greater than or equal to 1.
Hence, <code>spa_support()</code> returns the <code>sfg</code> object that represents the total extent of the <code>pgeometry</code> given as input.
If the <code>pgeometry</code> is empty, then an empty <code>sfg</code> object is returned.
</p>


<h3>Value</h3>

<p>An <code>sfg</code> object that represents the support of <code>pgeometry</code>. It can be an empty object, if <code>pgeometry</code> is empty.
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/tgis.13044">Carniel, A. C.; Ven√¢ncio, P. V. A. B; Schneider, M. fsr: An R package for fuzzy spatial data handling. Transactions in GIS, vol. 27, no. 3, pp. 900-927, 2023.</a>
</p>
<p>Underlying concepts and formal definitions of Spatial Plateau Algebra are introduced in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8491565">Carniel, A. C.; Schneider, M. Spatial Plateau Algebra: An Executable Type System for Fuzzy Spatial Data Types. In Proceedings of the 2018 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2018), pp. 1-8, 2018.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pcp1 &lt;- create_component("POINT(0 0)", 0.3)
pcp2 &lt;- create_component("MULTIPOINT((2 2), (2 4), (2 0))", 0.5)
pcp3 &lt;- create_component("MULTIPOINT((1 1), (3 1), (1 3), (3 3))", 0.9)
pcp4 &lt;- create_component("MULTIPOINT((1 2), (2 1), (3 2))", 1)
pcp5 &lt;- create_component("MULTIPOINT((0 0.5), (2 3))", 0.7)
pcp6 &lt;- create_component("MULTIPOINT((0 1), (3 3.5))", 0.85)
pcp7 &lt;- create_component("MULTIPOINT((1 0), (4 2))", 0.4)

# Creating a plateau point object
ppoint &lt;- create_pgeometry(list(pcp1, pcp2, pcp3, pcp4, pcp5), "PLATEAUPOINT")
ppoint

# Getting its support
spa_support(ppoint)

# Getting the support of an empty pgeometry
spa_support(create_empty_pgeometry("PLATEAUREGION"))
</code></pre>

<hr>
<h2 id='visitation'>Visitation: An example of FSI model</h2><span id='topic+visitation'></span>

<h3>Description</h3>

<p><code>visitation()</code> provides an example, without rules, of a fuzzy spatial inference (FSI) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visitation()
</code></pre>


<h3>Details</h3>

<p>The <code>visitation()</code> function provides a hypothetical FSI model that estimates the visiting experience based on prices and overall ratings of accommodations as well as sanitary conditions of restaurants.
The output of such a model infers a value between 0 and 100 that indicates how attractive it is to visit a specific location.
For this, the experience can be classified as <em>awful</em>, <em>average</em>, and <em>great</em>.
</p>
<p>The linguistic variables and their linguistic values of this FSI model are listed below:
</p>

<ul>
<li> <p><em>accommodation price</em> with <em>cut-rate</em>, <em>affordable</em>, and <em>expensive</em> as linguistic values.
</p>
</li>
<li> <p><em>accommodation review</em> with <em>bad</em>, <em>good</em>, and <em>excellent</em> as linguistic values.
</p>
</li>
<li> <p><em>food safety</em> with <em>low</em>, <em>medium</em>, and <em>high</em> as linguistic values, which represent levels of sanitary conditions.
</p>
</li></ul>

<p>Note that this is just a small running example, containing a small set of points to represent the locations of accommodations and restaurants.
</p>
<p>The usage of FSI models is subdivided into a <em>preparation phase</em> and an <em>evaluation phase</em>.
The preparation phase is responsible for instantiating a new FSI model with the elements of the data source component of FIFUS.
For this, the <code>fsr</code> package provides the following functions: <code>fsi_create()</code>, <code>fsi_add_fsa()</code>, and <code>fsi_add_cs()</code>.
These functions are employed by <code>visitation()</code> so that users can add their own fuzzy set rules (by using <code>fsi_add_rules()</code>) and perform the evaluation phase (by using the functions <code>fsi_eval()</code> and/or <code>fsi_qw_eval()</code>).
</p>
<p>In this sense, <code>visitation()</code> performs the following internal actions to return an FSI model:
</p>

<ol>
<li><p> specify the linguistic variables and their corresponding linguistic values, which are in turn represented by membership functions. These items are specified according to the context of the running example.
</p>
</li>
<li><p> define small point datasets that represent each linguistic variable. Such datasets are <code>tibble</code> objects.
</p>
</li>
<li><p> build spatial plateau objects by using <code>spa_creator()</code> on the datasets. As a result, we get spatial plateau objects that represent each linguistic value.
</p>
</li>
<li><p> create an FSI model with <code>fsi_create()</code> function.
</p>
</li>
<li><p> add fuzzy spatial antecedents with <code>fsi_add_fsa()</code>. Recall that the antecedents are spatial plateau objects previously built.
</p>
</li>
<li><p> define the linguistic variable and its linguistic values with membership functions for the consequent.
</p>
</li>
<li><p> add the consequent to the FSI model by using <code>fsi_add_cs()</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>An FSI model without fuzzy rules set.
</p>


<h3>References</h3>

<p>This function is based on the running example introduced in:
</p>

<ul>
<li> <p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
</li></ul>

<p>Underlying concepts and formal definitions of FIFUS are discussed in:
</p>

<ul>
<li> <p><a href="https://ieeexplore.ieee.org/document/8015707">Carniel, A. C.; Schneider, M. Fuzzy inference on fuzzy spatial objects (FIFUS) for spatial decision support systems. In Proceedings of the 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2017), pp. 1-6, 2017.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
fsi &lt;- visitation()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
