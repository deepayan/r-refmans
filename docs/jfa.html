<!DOCTYPE html><html><head><title>Help for package jfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jfa-package'><p>jfa &mdash; Statistical Methods for Auditing</p></a></li>
<li><a href='#accounts'><p>Accounts Receivable</p></a></li>
<li><a href='#allowances'><p>Legitimacy Audit</p></a></li>
<li><a href='#auditPrior'><p>Audit Sampling: Prior Distributions</p></a></li>
<li><a href='#benchmark'><p>Benchmark Analysis of Sales Versus Cost of Sales</p></a></li>
<li><a href='#BuildIt'><p>BuildIt Construction Financial Statements</p></a></li>
<li><a href='#carrier'><p>Carrier Company Financial Statements</p></a></li>
<li><a href='#compas'><p>COMPAS Recidivism Prediction</p></a></li>
<li><a href='#digit_test'><p>Data Auditing: Digit Distribution Test</p></a></li>
<li><a href='#evaluation'><p>Audit Sampling: Evaluation</p></a></li>
<li><a href='#jfa-methods'><p>Methods for jfa objects</p></a></li>
<li><a href='#model_fairness'><p>Algorithm Auditing: Fairness Metrics and Parity</p></a></li>
<li><a href='#planning'><p>Audit Sampling: Planning</p></a></li>
<li><a href='#repeated_test'><p>Data Auditing: Repeated Values Test</p></a></li>
<li><a href='#retailer'><p>Retailer Group Audit</p></a></li>
<li><a href='#sanitizer'><p>Factory Workers' use of Hand Sanitizer</p></a></li>
<li><a href='#selection'><p>Audit Sampling: Selection</p></a></li>
<li><a href='#sinoForest'><p>Sino Forest Corporation's Financial Statements.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Methods for Auditing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-07</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical methods for auditing as implemented in JASP
    for Audit (Derks et al., 2021 &lt;<a href="https://doi.org/10.21105%2Fjoss.02733">doi:10.21105/joss.02733</a>&gt;). First, the package
    makes it easy for an auditor to plan a statistical sample, select the sample
    from the population, and evaluate the misstatement in the sample compliant
    with international auditing standards. Second, the package provides
    statistical methods for auditing data, including tests of digit
    distributions and repeated values. Finally, the package includes methods for
    auditing algorithms on the aspect of fairness and bias. Next to classical
    statistical methodology, the package implements Bayesian equivalents of
    these methods whose statistical underpinnings are described in Derks et al.
    (2021) &lt;<a href="https://doi.org/10.1111%2Fijau.12240">doi:10.1111/ijau.12240</a>&gt;, Derks et al. (2021)
    &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fkzqp5">doi:10.31234/osf.io/kzqp5</a>&gt;, and Derks et al. (2022)
    &lt;<a href="https://doi.org/10.31234%2Fosf.io%2F8nf3e">doi:10.31234/osf.io/8nf3e</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bde (&ge; 1.0.1.1), extraDistr (&ge; 1.9.1), ggplot2 (&ge; 3.4.2),
methods, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.26.0), rstantools (&ge; 2.2.0), stats, truncdist (&ge; 1.0-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>benford.analysis (&ge; 0.1.5), BenfordTests (&ge; 1.2.0),
BeyondBenford (&ge; 1.4), fairness, knitr, MUS (&ge; 0.1.6),
rmarkdown, samplingbook (&ge; 1.2.4), testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://koenderks.github.io/jfa/">https://koenderks.github.io/jfa/</a>, <a href="https://github.com/koenderks/jfa">https://github.com/koenderks/jfa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/koenderks/jfa/issues">https://github.com/koenderks/jfa/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, GNU make</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 12:56:07 UTC; koenderks</td>
</tr>
<tr>
<td>Author:</td>
<td>Koen Derks <a href="https://orcid.org/0000-0002-5533-9349"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Koen Derks &lt;k.derks@nyenrode.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 13:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='jfa-package'>jfa &mdash; Statistical Methods for Auditing</h2><span id='topic+jfa'></span><span id='topic+jfa-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" alt='logo' width='120' style='float: right'  />
</p>
<p><code>jfa</code> is an R package that provides statistical methods for auditing. The package 
includes functions for planning, performing, and evaluating an audit sample 
compliant with international auditing standards, as well as functions for auditing data, such as 
testing the distribution of leading digits in the data against Benford's law. In addition to offering 
classical frequentist methods, <code>jfa</code> also provides a straightforward implementation of their 
Bayesian counterparts.
</p>
<p>The functionality of the <code>jfa</code> package and its intended workflow are implemented with 
a graphical user interface in the Audit module of <a href="https://jasp-stats.org">JASP</a>, 
a free and open-source software program for statistical analyses.
</p>
<p>For documentation on <code>jfa</code> itself, including the manual and user guide
for the package, worked examples, and other tutorial information visit the 
<a href="https://koenderks.github.io/jfa/">package website</a>.
</p>


<h3>Author(s)</h3>


<table>
<tr>
 <td style="text-align: left;">
    Koen Derks (maintainer, author)</td><td style="text-align: left;"> &lt;k.derks@nyenrode.nl&gt; </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Please use the citation provided by <span class="rlang"><b>R</b></span> when citing this package. 
A BibTex entry is available from <code>citation('jfa')</code>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> The <a href="https://koenderks.github.io/jfa/articles/">vignettes</a> for worked examples.
</p>
</li>
<li><p> The <a href="https://github.com/koenderks/jfa/issues">issue page</a> to submit a bug report or feature request.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load the jfa package
library(jfa)

#################################
### Example 1: Audit sampling ###
#################################

# Load the BuildIt population
data('BuildIt')

# Stage 1: Planning
stage1 &lt;- planning(materiality = 0.03, expected = 0.01)
summary(stage1)

# Stage 2: Selection
stage2 &lt;- selection(data = BuildIt, size = stage1,
                    units = 'values', values = 'bookValue',
                    method = 'interval', start = 1)
summary(stage2)

# Stage 3: Execution
sample &lt;- stage2[['sample']]

# Stage 4: Evaluation
stage4 &lt;- evaluation(data = sample, method = 'stringer.binomial',
                     values = 'bookValue', values.audit = 'auditValue')
summary(stage4)

#################################
### Example 2: Data auditing ####
#################################

# Load the sinoForest data set
data('sinoForest')

# Test first digits in the data against Benford's law
digit_test(sinoForest[["value"]], check = "first", reference = "benford")

######################################
### Example 3: Algorithm auditing ####
######################################

# Load the compas data set
data('compas')

# Test algorithmic fairness against Caucasian ethnicity
model_fairness(compas, "Ethnicity", "TwoYrRecidivism", "Predicted",
               privileged = "Caucasian", positive = "yes")
</code></pre>

<hr>
<h2 id='accounts'>Accounts Receivable</h2><span id='topic+accounts'></span>

<h3>Description</h3>

<p>Audit sample obtained from a population of N = 87 accounts receivable,
totaling $612,824 in book value (Higgins and Nandram, 2009; Lohr, 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(accounts)
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 3 variables.
</p>

<dl>
<dt>account</dt><dd><p>account number (between 1 - 87)</p>
</dd>
<dt>bookValue</dt><dd><p>booked value of the account</p>
</dd>
<dt>auditValue</dt><dd><p>audited (i.e., true) value of the account</p>
</dd>
</dl>



<h3>References</h3>

<p>Higgins, H. N., &amp; Nandram, B. (2009). Monetary unit sampling:
Improving estimation of the total audit error
<em>Advances in Accounting</em>, 25(2), 174-182.
<a href="https://doi.org/10.1016/j.adiac.2009.06.001">doi:10.1016/j.adiac.2009.06.001</a>
</p>
<p>Lohr, S. L. (2021). <em>Sampling: Design and Analysis</em>. CRC
press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(accounts)
</code></pre>

<hr>
<h2 id='allowances'>Legitimacy Audit</h2><span id='topic+allowances'></span>

<h3>Description</h3>

<p>Fictional population from a legitimacy audit, containing 4189 records with
identification numbers, stratum identifiers, book values, and audit values.
The audit values are added for illustrative purposes, as these would
need to be assessed by the auditor in the execution stage of the audit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(allowances)
</code></pre>


<h3>Format</h3>

<p>A data frame with 4189 rows and 5 variables.
</p>

<dl>
<dt>item</dt><dd><p>a unique record identification number.</p>
</dd>
<dt>branch</dt><dd><p>the stratum identifier / branch number.</p>
</dd>
<dt>bookValue</dt><dd><p>the item book value in US dollars.</p>
</dd>
<dt>auditValue</dt><dd><p>the item audit (i.e., true) value in US dollars.</p>
</dd>
<dt>times</dt><dd><p>a sample selection indicator (<code>0</code> = not in sample).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(allowances)
</code></pre>

<hr>
<h2 id='auditPrior'>Audit Sampling: Prior Distributions</h2><span id='topic+auditPrior'></span>

<h3>Description</h3>

<p><code>auditPrior()</code> is used to create a prior distribution for
Bayesian audit sampling. The interface allows a complete customization of the
prior distribution as well as a formal translation of pre-existing audit
information into a prior distribution. The function returns an object of
class <code>jfaPrior</code> that can be used in the <code>planning()</code> and
<code>evaluation()</code> functions via their <code>prior</code> argument. Objects with
class <code>jfaPrior</code> can be further inspected via associated
<code>summary()</code> and <code>plot()</code> methods. They can also be used to compute
a convoluted prior using the <code>+</code> (for addition) and <code>*</code> (for
weighing) operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auditPrior(
  method = c(
    "default", "param", "strict", "impartial", "hyp",
    "arm", "bram", "sample", "factor", "nonparam"
  ),
  likelihood = c(
    "poisson", "binomial", "hypergeometric",
    "normal", "uniform", "cauchy", "t", "chisq",
    "exponential"
  ),
  N.units = NULL,
  alpha = NULL,
  beta = NULL,
  materiality = NULL,
  expected = 0,
  ir = NULL,
  cr = NULL,
  ub = NULL,
  p.hmin = NULL,
  x = NULL,
  n = NULL,
  factor = NULL,
  samples = NULL,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auditPrior_+3A_method">method</code></td>
<td>
<p>a character specifying the method by which the prior
distribution is constructed. Possible options are <code>default</code>,
<code>strict</code>, <code>impartial</code>, <code>param</code>, <code>arm</code>, <code>bram</code>,
<code>hyp</code>, <code>sample</code>, and <code>factor</code>. See the details section for
more information.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_likelihood">likelihood</code></td>
<td>
<p>a character specifying the likelihood for updating the
prior distribution. Possible options are <code>poisson</code> (default) for a
conjugate gamma prior distribution, <code>binomial</code> for a conjugate beta
prior distribution, or <code>hypergeometric</code> for a conjugate beta-binomial
prior distribution. See the details section for more information.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_n.units">N.units</code></td>
<td>
<p>a numeric value larger than 0 specifying the total number
of units in the population. Required for the <code>hypergeometric</code>
likelihood.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value specifying the <code class="reqn">\alpha</code> parameter of
the prior distribution. Required for method <code>param</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_beta">beta</code></td>
<td>
<p>a numeric value specifying the <code class="reqn">\beta</code> parameter of
the prior distribution. Required for method <code>param</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_materiality">materiality</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
performance materiality (i.e., the maximum tolerable misstatement in the
population) as a fraction. Required for methods <code>impartial</code>,
<code>arm</code>, and <code>hyp</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_expected">expected</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the expected
(tolerable) misstatements in the sample relative to the total sample size.
Required for methods <code>impartial</code>, <code>arm</code>, <code>bram</code>, and
<code>hyp</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_ir">ir</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the inherent
risk (i.e., the probability of material misstatement occurring due to
inherent factors) in the audit risk model. Required for method <code>arm</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_cr">cr</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the internal
control risk (i.e., the probability of material misstatement occurring due
to internal control systems) in the audit risk model. Required for method
<code>arm</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_ub">ub</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
<code>conf.level</code>-% upper bound for the prior distribution as a
fraction. Required for method <code>bram</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_p.hmin">p.hmin</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the prior
probability of the hypothesis of tolerable misstatement (H1: <code class="reqn">\theta &lt;</code>
materiality). Required for method <code>hyp</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_x">x</code></td>
<td>
<p>a numeric value larger than, or equal to, 0 specifying the
sum of proportional misstatements (taints) in a prior sample. Required for
methods <code>sample</code> and <code>factor</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_n">n</code></td>
<td>
<p>a numeric value larger than 0 specifying the number of
units in a prior sample. Required for methods <code>sample</code> and
<code>factor</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_factor">factor</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the weight of
a prior sample specified via <code>x</code> and <code>n</code>. Required for method
<code>factor</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_samples">samples</code></td>
<td>
<p>a numeric vector containing samples of the prior
distribution. Required for method <code>nonparam</code>.</p>
</td></tr>
<tr><td><code id="auditPrior_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the confidence
level (1 - audit risk).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To perform Bayesian audit sampling you must assign a prior
distribution to the parameter in the model, i.e., the population
misstatement <code class="reqn">\theta</code>. The prior distribution can incorporate
pre-existing audit information about <code class="reqn">\theta</code> into the analysis, which
consequently allows for a more efficient or more accurate estimates. The
default priors used by <code>jfa</code> are indifferent towards the possible
values of <code class="reqn">\theta</code>, while still being proper. Note that the default
prior distributions are a conservative choice of prior since they, in most
cases, assume all possible misstatement to be equally likely before seeing
a data sample. It is recommended to construct an informed prior
distribution based on pre-existing audit information when possible.
</p>
<p>This section elaborates on the available input options for the
<code>method</code> argument.
</p>

<ul>
<li><p><code>default</code>:   This method produces a <em>gamma(1, 1)</em>,
<em>beta(1, 1)</em>, <em>beta-binomial(N, 1, 1)</em>, <em>normal(0.5, 1000)</em>
, <em>cauchy(0, 1000)</em>, <em>student-t(1)</em>, or <em>chi-squared(1)</em>
prior distribution. These prior distributions are mostly indifferent about
the possible values of the misstatement.
</p>
</li>
<li><p><code>param</code>:     This method produces a custom
<code>gamma(alpha, beta)</code>, <code>beta(alpha, beta)</code>,
<code>beta-binomial(N, alpha, beta)</code> prior distribution,
<em>normal(alpha, beta)</em>, <em>cauchy(alpha, beta)</em>,
<em>student-t(alpha)</em>, or <em>chi-squared(alpha)</em>. The alpha and
beta parameters must be set using <code>alpha</code> and <code>beta</code>.
</p>
</li>
<li><p><code>strict</code>:    This method produces an improper <em>gamma(1, 0)</em>,
<em>beta(1, 0)</em>, or <em>beta-binomial(N, 1, 0)</em> prior distribution.
These prior distributions match sample sizes and upper limits from
classical methods and can be used to emulate classical results.
</p>
</li>
<li><p><code>impartial</code>: This method produces an impartial prior
distribution. These prior distributions assume that tolerable misstatement
(<code class="reqn">\theta &lt;</code> materiality) and intolerable misstatement (<code class="reqn">\theta &gt;</code>
materiality) are equally likely.
</p>
</li>
<li><p><code>hyp</code>:       This method translates an assessment of the prior
probability for tolerable misstatement (<code class="reqn">\theta &lt;</code> materiality) to a
prior distribution.
</p>
</li>
<li><p><code>arm</code>:       This method translates an assessment of inherent
risk and internal control risk to a prior distribution.
</p>
</li>
<li><p><code>bram</code>:      This method translates an assessment of the
expected most likely error and <em>x</em>-% upper bound to a prior
distribution.
</p>
</li>
<li><p><code>sample</code>:    This method translates the outcome of an earlier
sample to a prior distribution.
</p>
</li>
<li><p><code>factor</code>:    This method translates and weighs the outcome of an
earlier sample to a prior distribution.
</p>
</li>
<li><p><code>nonparam</code>:  This method takes a vector of samples from the prior
distribution (via <code>samples</code>) and constructs a bounded density
(between 0 and 1) on the basis of these samples to act as the prior.
</p>
</li></ul>

<p>This section elaborates on the available input options for the
<code>likelihood</code> argument and the corresponding conjugate prior
distributions used by <code>jfa</code>.
</p>

<ul>
<li><p><code>poisson</code>:        The Poisson distribution is an approximation of
the binomial distribution. The Poisson distribution is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(\theta, n) = \frac{\lambda^\theta e^{-\lambda}}{\theta!}</code>
</p>
<p>. The
conjugate <em>gamma(<code class="reqn">\alpha, \beta</code>)</em> prior has probability density
function:
</p>
<p style="text-align: center;"><code class="reqn">p(\theta; \alpha, \beta) = \frac{\beta^\alpha \theta^{\alpha - 1}
   e^{-\beta \theta}}{\Gamma(\alpha)}</code>
</p>
<p>.
</p>
</li>
<li><p><code>binomial</code>:       The binomial distribution is an approximation
of the hypergeometric distribution. The binomial distribution is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(\theta, n, x) = {n \choose x} \theta^x (1 - \theta)^{n - x}</code>
</p>
<p>. The
conjugate <em>beta(<code class="reqn">\alpha, \beta</code>)</em> prior has probability density
function: </p>
<p style="text-align: center;"><code class="reqn">p(\theta; \alpha, \beta) = \frac{1}{B(\alpha, \beta)}
 \theta^{\alpha - 1} (1 - \theta)^{\beta - 1}</code>
</p>
<p>.
</p>
</li>
<li><p><code>hypergeometric</code>: The hypergeometric distribution is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(x, n, K, N) = \frac{{K \choose x} {N - K \choose n - x}}
 {{N \choose n}}</code>
</p>
<p>. The conjugate <em>beta-binomial(<code class="reqn">\alpha, \beta</code>)</em>
prior (Dyer and Pierce, 1993) has probability mass function:
</p>
<p style="text-align: center;"><code class="reqn">f(x, n, \alpha, \beta) = {n \choose x}
 \frac{B(x + \alpha, n - x + \beta)}{B(\alpha, \beta)}</code>
</p>
<p>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>jfaPrior</code> containing:
</p>
<table>
<tr><td><code>prior</code></td>
<td>
<p>a string describing the functional form of the prior
distribution.</p>
</td></tr>
<tr><td><code>description</code></td>
<td>
<p>a list containing a description of the prior distribution,
including the parameters of the prior distribution and the implicit sample
on which the prior distribution is based.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>a list containing statistics of the prior distribution,
including the mean, mode, median, and upper bound of the prior
distribution.</p>
</td></tr>
<tr><td><code>specifics</code></td>
<td>
<p>a list containing specifics of the prior distribution that
vary depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code>hypotheses</code></td>
<td>
<p>if <code>materiality</code> is specified, a list containing
information about the hypotheses, including prior probabilities and odds
for the hypothesis of tolerable misstatement (H1) and the hypothesis of
intolerable misstatement (H0).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character indicating the method by which the prior
distribution is constructed.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>a character indicating the likelihood of the data.</p>
</td></tr>
<tr><td><code>materiality</code></td>
<td>
<p>if <code>materiality</code> is specified, a numeric value
between 0 and 1 giving the materiality used to construct the prior
distribution.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>a numeric value larger than, or equal to, 0 giving the input
for the number of expected misstatements.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 giving the confidence
level.</p>
</td></tr>
<tr><td><code>N.units</code></td>
<td>
<p>if <code>N.units</code> is specified, the number of units in the
population.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Derks, K., de Swart, J., van Batenburg, P., Wagenmakers, E.-J.,
&amp; Wetzels, R. (2021). Priors in a Bayesian audit: How integration of
existing information into the prior distribution can improve audit
transparency and efficiency. <em>International Journal of Auditing</em>,
25(3), 621-636. <a href="https://doi.org/10.1111/ijau.12240">doi:10.1111/ijau.12240</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., Wille, J., &amp;
Wetzels, R. (2021). JASP for audit: Bayesian tools for the auditing
practice. <em>Journal of Open Source Software</em>, <em>6</em>(68), 2733.
<a href="https://doi.org/10.21105/joss.02733">doi:10.21105/joss.02733</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., &amp; Wetzels, R.
(2022). An impartial Bayesian hypothesis test for audit sampling.
<em>PsyArXiv</em>. <a href="https://doi.org/10.31234/osf.io/8nf3e">doi:10.31234/osf.io/8nf3e</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+planning">planning</a></code>
<code><a href="#topic+selection">selection</a></code>
<code><a href="#topic+evaluation">evaluation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default beta prior
auditPrior(likelihood = "binomial")

# Impartial prior
auditPrior(method = "impartial", materiality = 0.05)

# Non-conjugate prior
auditPrior(method = "param", likelihood = "normal", alpha = 0, beta = 0.1)
</code></pre>

<hr>
<h2 id='benchmark'>Benchmark Analysis of Sales Versus Cost of Sales</h2><span id='topic+benchmark'></span>

<h3>Description</h3>

<p>Fictional data from a benchmark analysis comparing industry sales versus
the industry cost of sales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(benchmark)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 2 variables.
</p>

<dl>
<dt>sales</dt><dd><p>book value in US dollars ($100,187,432&ndash;$398,280,933).</p>
</dd>
<dt>costofsales</dt><dd><p>true value in US dollars ($71,193,639&ndash;$309,475,784).</p>
</dd>
</dl>



<h3>References</h3>

<p>Derks, K., de Swart, J., van Batenburg, P., Wagenmakers, E.-J.,
&amp; Wetzels, R. (2021). Priors in a Bayesian audit: How integration of
existing information into the prior distribution can improve audit
transparency and efficiency. <em>International Journal of Auditing</em>,
25(3), 621-636. <a href="https://doi.org/10.1111/ijau.12240">doi:10.1111/ijau.12240</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(benchmark)
</code></pre>

<hr>
<h2 id='BuildIt'>BuildIt Construction Financial Statements</h2><span id='topic+BuildIt'></span>

<h3>Description</h3>

<p>Fictional data from a construction company in the United States, containing
3500 observations identification numbers, book values, and audit values. The
audit values are added for illustrative purposes, as these would need to be
assessed by the auditor in the execution stage of the audit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BuildIt)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3500 rows and 3 variables.
</p>

<dl>
<dt>ID</dt><dd><p>unique record identification number.</p>
</dd>
<dt>bookValue</dt><dd><p>book value in US dollars ($14.47&ndash;$2,224.40).</p>
</dd>
<dt>auditValue</dt><dd><p>true value in US dollars ($14.47&ndash;$2,224.40).</p>
</dd>
</dl>



<h3>References</h3>

<p>Derks, K., de Swart, J., Wagenmakers, E.-J., Wille, J., &amp;
Wetzels, R. (2021). JASP for audit: Bayesian tools for the auditing practice.
<em>Journal of Open Source Software</em>, <em>6</em>(68), 2733.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BuildIt)
</code></pre>

<hr>
<h2 id='carrier'>Carrier Company Financial Statements</h2><span id='topic+carrier'></span>

<h3>Description</h3>

<p>Fictional data from a carrier company in Europe, containing 202 ledger items
across 10 company entities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carrier)
</code></pre>


<h3>Format</h3>

<p>A data frame with 202 rows and 12 variables.
</p>

<dl>
<dt>description</dt><dd><p>description of the ledger item.</p>
</dd>
<dt>entity1</dt><dd><p>recorded values for entity 1, in US dollars.</p>
</dd>
<dt>entity2</dt><dd><p>recorded values for entity 2, in US dollars.</p>
</dd>
<dt>entity3</dt><dd><p>recorded values for entity 3, in US dollars.</p>
</dd>
<dt>entity4</dt><dd><p>recorded values for entity 4, in US dollars.</p>
</dd>
<dt>entity5</dt><dd><p>recorded values for entity 5, in US dollars.</p>
</dd>
<dt>entity6</dt><dd><p>recorded values for entity 6, in US dollars.</p>
</dd>
<dt>entity7</dt><dd><p>recorded values for entity 7, in US dollars.</p>
</dd>
<dt>entity8</dt><dd><p>recorded values for entity 8, in US dollars.</p>
</dd>
<dt>entity9</dt><dd><p>recorded values for entity 9, in US dollars.</p>
</dd>
<dt>entity10</dt><dd><p>recorded values for entity 10, in US dollars.</p>
</dd>
<dt>total</dt><dd><p>total value, in US dollars.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://towardsdatascience.com/data-driven-audit-1-automated-sampling-using-python-52e83347add5">https://towardsdatascience.com/data-driven-audit-1-automated-sampling-using-python-52e83347add5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carrier)
</code></pre>

<hr>
<h2 id='compas'>COMPAS Recidivism Prediction</h2><span id='topic+compas'></span>

<h3>Description</h3>

<p>This data was used to predict recidivism (whether a criminal will reoffend or
not) in the USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(compas)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 2 variables.
</p>

<dl>
<dt>TwoYrRecidivism</dt><dd><p>yes/no for recidivism or no recidivism.</p>
</dd>
<dt>AgeAboveFoutryFive</dt><dd><p>yes/no for age above 45 years or not</p>
</dd>
<dt>AgeBelowTwentyFive</dt><dd><p>yes/no for age below 25 years or not</p>
</dd>
<dt>Gender</dt><dd><p>female/male for gender</p>
</dd>
<dt>Misdemeanor</dt><dd><p>yes/no for having recorded misdemeanor(s) or not</p>
</dd>
<dt>Ethnicity</dt><dd><p>Caucasian, African American, Asian, Hispanic, Native American or Other</p>
</dd>
<dt>Predicted</dt><dd><p>yes/no, predicted values for recidivism</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="https://www.kaggle.com/danofer/compass">https://www.kaggle.com/danofer/compass</a>
<a href="https://cran.r-project.org/package=fairness">https://cran.r-project.org/package=fairness</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(compas)
</code></pre>

<hr>
<h2 id='digit_test'>Data Auditing: Digit Distribution Test</h2><span id='topic+digit_test'></span>

<h3>Description</h3>

<p>This function extracts and performs a test of the distribution
of (leading) digits in a vector against a reference distribution. By default,
the distribution of leading digits is checked against Benford's law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>digit_test(
  x,
  check = c("first", "last", "firsttwo", "lasttwo"),
  reference = "benford",
  conf.level = 0.95,
  prior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="digit_test_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="digit_test_+3A_check">check</code></td>
<td>
<p>location of the digits to analyze. Can be <code>first</code>,
<code>last</code>, <code>firsttwo</code>, or <code>lasttwo</code>.</p>
</td></tr>
<tr><td><code id="digit_test_+3A_reference">reference</code></td>
<td>
<p>which character string given the reference distribution for
the digits, or a vector of probabilities for each digit. Can be
<code>benford</code> for Benford's law, <code>uniform</code> for the uniform
distribution. An error is given if any entry of <code>reference</code> is
negative. Probabilities that do not sum to one are normalized.</p>
</td></tr>
<tr><td><code id="digit_test_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
confidence level (i.e., 1 - audit risk / detection risk).</p>
</td></tr>
<tr><td><code id="digit_test_+3A_prior">prior</code></td>
<td>
<p>a logical specifying whether to use a prior distribution,
or a numeric value equal to or larger than 1 specifying the prior
concentration parameter, or a numeric vector containing the prior
parameters for the Dirichlet distribution on the digit categories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Benford's law is defined as <code class="reqn">p(d) = log10(1/d)</code>. The uniform
distribution is defined as <code class="reqn">p(d) = 1/d</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>jfaDistr</code> containing:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>the specified data.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 giving the confidence
level.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>the observed counts.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>the expected counts under the null hypothesis.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value the chi-squared test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the approximate chi-squared
distribution of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>check</code></td>
<td>
<p>checked digits.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>vector of digits.</p>
</td></tr>
<tr><td><code>reference</code></td>
<td>
<p>reference distribution</p>
</td></tr>
<tr><td><code>match</code></td>
<td>
<p>a list containing the row numbers corresponding to the
observations matching each digit.</p>
</td></tr>
<tr><td><code>deviation</code></td>
<td>
<p>a vector indicating which digits deviate from their
expected relative frequency under the reference distribution.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>a logical indicating whether a prior distribution was used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Benford, F. (1938). The law of anomalous numbers.
<em>In Proceedings of the American Philosophical Society</em>, 551-572.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repeated_test">repeated_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rnorm(100)

# First digit analysis against Benford's law
digit_test(x, check = "first", reference = "benford")

# Bayesian first digit analysis against Benford's law
digit_test(x, check = "first", reference = "benford", prior = TRUE)

# Last digit analysis against the uniform distribution
digit_test(x, check = "last", reference = "uniform")

# Bayesian last digit analysis against the uniform distribution
digit_test(x, check = "last", reference = "uniform", prior = TRUE)

# First digit analysis against a custom distribution
digit_test(x, check = "last", reference = 1:9)

# Bayesian first digit analysis against a custom distribution
digit_test(x, check = "last", reference = 1:9, prior = TRUE)
</code></pre>

<hr>
<h2 id='evaluation'>Audit Sampling: Evaluation</h2><span id='topic+evaluation'></span>

<h3>Description</h3>

<p><code>evaluation()</code> is used to perform statistical inference
about the misstatement in a population after auditing a statistical sample.
It allows specification of statistical requirements for the sample with
respect to the performance materiality or the precision. The function returns
an object of class <code>jfaEvaluation</code> that can be used with associated
<code>summary()</code> and <code>plot()</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation(
  materiality = NULL,
  method = c(
    "poisson", "binomial", "hypergeometric",
    "inflated.poisson", "hurdle.beta",
    "stringer.poisson", "stringer.binomial", "stringer.hypergeometric",
    "stringer.meikle", "stringer.lta", "stringer.pvz", "stringer",
    "rohrbach", "moment", "coxsnell", "mpu", "pps",
    "direct", "difference", "quotient", "regression"
  ),
  alternative = c("less", "two.sided", "greater"),
  conf.level = 0.95,
  data = NULL,
  values = NULL,
  values.audit = NULL,
  strata = NULL,
  times = NULL,
  x = NULL,
  n = NULL,
  N.units = NULL,
  N.items = NULL,
  pooling = c("none", "complete", "partial"),
  prior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluation_+3A_materiality">materiality</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
performance materiality (i.e., the maximum tolerable misstatement in the
population) as a fraction of the total number of units in the population.
Can be <code>NULL</code>. Not used for methods <code>direct</code>, <code>difference</code>,
<code>quotient</code>, and <code>regression</code>.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_method">method</code></td>
<td>
<p>a character specifying the statistical method. Possible
options are <code>poisson</code> (default), <code>binomial</code>,
<code>hypergeometric</code>, <code>stringer.poisson</code>, <code>stringer.binomial</code>,
<code>stringer.hypergeometric</code>, <code>stringer.meikle</code>,
<code>stringer.lta</code>, <code>stringer.pvz</code>, <code>rohrbach</code>, <code>moment</code>,
<code>mpu</code>, <code>pps</code>, <code>direct</code>, <code>difference</code>, <code>quotient</code>,
or <code>regression</code>. See the details section for more information.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_alternative">alternative</code></td>
<td>
<p>a character indicating the alternative hypothesis and
the type of confidence / credible interval returned by the function.
Possible options are  <code>less</code> (default), <code>two.sided</code>, or
<code>greater</code>.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
confidence level (i.e., 1 - audit risk / detection risk).</p>
</td></tr>
<tr><td><code id="evaluation_+3A_data">data</code></td>
<td>
<p>a data frame containing a data sample.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_values">values</code></td>
<td>
<p>a character specifying name of a numeric column in
<code>data</code> containing the book values of the items.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_values.audit">values.audit</code></td>
<td>
<p>a character specifying name of a numeric column in
<code>data</code> containing the audit (i.e., true) values of the items.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_strata">strata</code></td>
<td>
<p>a character specifying name of a factor column in
<code>data</code> indicating to which stratum the item belongs.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_times">times</code></td>
<td>
<p>a character specifying name of an integer column in
<code>data</code> containing the number of times an item should be counted due
to (not) being selected (multiple times) for the sample. Items for which
this value is 0 will not be included in the evaluation.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_x">x</code></td>
<td>
<p>a numeric value or vector of values equal to or larger
than 0 specifying the sum of (proportional) misstatements in the sample or,
if this is a vector, the sum of taints in each stratum. If this argument is
specified, the input for the <code>data</code>, <code>values</code> and
<code>values.audit</code> arguments is discarded and it is assumed that the data
come from summary statistics specified by <code>x</code> and <code>n</code>.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_n">n</code></td>
<td>
<p>an integer or vector of integers larger than 0
specifying the sum of (proportional) misstatements in the sample or, if
this is a vector, the sum of taints in each stratum. If this argument is
specified, the input for the <code>data</code>, <code>values</code> and
<code>values.audit</code> arguments is discarded and it is assumed that the data
come from summary statistics specified by <code>x</code> and <code>n</code>.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_n.units">N.units</code></td>
<td>
<p>a numeric value or vector of values than 0 specifying
the total number of units in the population or, if this is a vector, the
total number of units in each stratum of the population.
This argument is strictly required for the <code>hypergeometric</code>,
<code>direct</code>, <code>difference</code>, <code>quotient</code>, and <code>regression</code>
methods, but is also used in stratification to weigh the estimates of each
individual stratum to arrive at the population estimate. If <code>NULL</code>,
each stratum is assumed to be equally represented in the population.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_n.items">N.items</code></td>
<td>
<p>an integer larger than 0 specifying the number of items
in the population. Only used for methods <code>direct</code>, <code>difference</code>,
<code>quotient</code>, and <code>regression</code>.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_pooling">pooling</code></td>
<td>
<p>a character specifying the type of model to use when
analyzing stratified samples. Possible options are <code>none</code> (default)
for no pooling (i.e., no information is shared between strata),
<code>complete</code> for complete pooling (i.e., all information is shared
between strata) or <code>partial</code> for partial pooling (i.e., some
information is shared between strata). The latter two options fit a
Bayesian model to the data using a MCMC sampling procedure whose options
can be set globally using <code>options("mc.iterations")</code> (otherwise:
2000), <code>options("mc.warmup")</code> (otherwise: 1000),
<code>options("mc.chains")</code> (otherwise: 4) and <code>options("mc.cores")</code>
(otherwise: 1).</p>
</td></tr>
<tr><td><code id="evaluation_+3A_prior">prior</code></td>
<td>
<p>a logical specifying whether to use a prior
distribution, or an object of class <code>jfaPrior</code> or <code>jfaPosterior</code>.
If this argument is specified as <code>FALSE</code> (default), the function
performs classical evaluation. If this argument is specified as <code>TRUE</code>
or as a prior from <code>auditPrior</code>, this function performs Bayesian
evaluation using the specified prior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section lists the available options for the <code>method</code>
argument.
</p>

<ul>
<li><p><code>poisson</code>:                 Evaluates the sample with the Poisson
distribution. If combined with <code>prior = TRUE</code>, performs Bayesian
evaluation using a <em>gamma</em> prior.
</p>
</li>
<li><p><code>binomial</code>:                Evaluates the sample with the binomial
distribution. If combined with <code>prior = TRUE</code>, performs Bayesian
evaluation using a <em>beta</em> prior.
</p>
</li>
<li><p><code>hypergeometric</code>:          Evaluates the sample with the
hypergeometric distribution. If combined with <code>prior = TRUE</code>,
performs Bayesian evaluation using a <em>beta-binomial</em> prior.
</p>
</li>
<li><p><code>inflated.poisson</code>:        Inflated Poisson model incorporating
the explicit probability of misstatement being zero. If
<code>prior = TRUE</code>, performs Bayesian evaluation using a <em>beta</em>
prior.
</p>
</li>
<li><p><code>hurdle.beta</code>:             Hurdle beta model incorporating the
explicit probability of a taint being zero, one, or in between. If
<code>prior = TRUE</code>, this setup performs Bayesian evaluation using a
<em>beta</em> prior.
</p>
</li>
<li><p><code>stringer.poisson</code>:        Evaluates the sample with the Stringer
bound using the Poisson distribution.
</p>
</li>
<li><p><code>stringer.binomial</code>:       Evaluates the sample with the Stringer
bound using the binomial distribution (Stringer, 1963).
</p>
</li>
<li><p><code>stringer.hypergeometric</code>: Evaluates the sample with the Stringer
bound using the hypergeometric distribution.
</p>
</li>
<li><p><code>stringer.meikle</code>:         Evaluates the sample using the
Stringer bound with Meikle's correction for understatements
(Meikle, 1972).
</p>
</li>
<li><p><code>stringer.lta</code>:            Evaluates the sample using the
Stringer bound with LTA correction for understatements (Leslie,
Teitlebaum, and Anderson, 1979).
</p>
</li>
<li><p><code>stringer.pvz</code>:            Evaluates the sample using the
Stringer bound with Pap and van Zuijlen's correction for understatements
(Pap and van Zuijlen, 1996).
</p>
</li>
<li><p><code>rohrbach</code>:                Evaluates the sample using Rohrbach's
augmented variance bound (Rohrbach, 1993).
</p>
</li>
<li><p><code>moment</code>:                  Evaluates the sample using the
modified moment bound (Dworin and Grimlund, 1984).
</p>
</li>
<li><p><code>coxsnell</code>:                Evaluates the sample using the Cox and
Snell bound (Cox and Snell, 1979).
</p>
</li>
<li><p><code>mpu</code>:                     Evaluates the sample with the
mean-per-unit estimator using the Normal distribution.
</p>
</li>
<li><p><code>pps</code>:                     Evaluates the sample with the
proportional-to-size estimator using the Student-t distribution.
</p>
</li>
<li><p><code>direct</code>:                  Evaluates the sample using the direct
estimator (Touw and Hoogduin, 2011).
</p>
</li>
<li><p><code>difference</code>:              Evaluates the sample using the
difference estimator (Touw and Hoogduin, 2011).
</p>
</li>
<li><p><code>quotient</code>:                Evaluates the sample using the
quotient estimator (Touw and Hoogduin, 2011).
</p>
</li>
<li><p><code>regression</code>:              Evaluates the sample using the
regression estimator (Touw and Hoogduin, 2011).
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>jfaEvaluation</code> containing:
</p>
<table>
<tr><td><code>conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 giving the confidence
level.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>a numeric value between 0 and 1 giving the most likely
misstatement in the population as a fraction.</p>
</td></tr>
<tr><td><code>ub</code></td>
<td>
<p>a numeric value between 0 and 1 giving the upper bound for the
misstatement in the population.</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>a numeric value between 0 and 1 giving the lower bound for the
misstatement in the population.</p>
</td></tr>
<tr><td><code>precision</code></td>
<td>
<p>a numeric value between 0 and 1 giving the difference
between the most likely misstatement and the bound relative to
<code>alternative</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>for classical tests, a numeric value giving the p-value.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>an integer larger than, or equal to, 0 giving the number of
misstatements in the sample.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>a value larger than, or equal to, 0, giving the sum of proportional
misstatements in the sample.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>an integer larger than 0 giving the sample size.</p>
</td></tr>
<tr><td><code>materiality</code></td>
<td>
<p>if <code>materiality</code> is specified, a numeric value
between 0 and 1 giving the performance materiality as a fraction.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character indicating the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character the method used.</p>
</td></tr>
<tr><td><code>N.units</code></td>
<td>
<p>if <code>N.units</code> is specified, in integer larger than 0
indicating the number of units in the population</p>
</td></tr>
<tr><td><code>N.items</code></td>
<td>
<p>if <code>N.items</code> is specified, in integer larger than 0
indicating the number of items in the population.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>if <code>method = 'hypergeometric'</code>, an integer indicating the
assumed total errors in the population.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>an object of class <code>jfaPrior</code> that contains the prior
distribution.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>an object of class <code>jfaPosterior</code> that contains the
posterior distribution.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a data frame containing the relevant columns from the
<code>data</code>.</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>a data frame containing the relevant statistical results for
the strata.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Cox, D. and Snell, E. (1979). On sampling and the estimation of
rare errors. <em>Biometrika</em>, 66(1), 125-132.
<a href="https://doi.org/10.1093/biomet/66.1.125">doi:10.1093/biomet/66.1.125</a>.
</p>
<p>Derks, K., de Swart, J., van Batenburg, P., Wagenmakers, E.-J.,
&amp; Wetzels, R. (2021). Priors in a Bayesian audit: How integration of
existing information into the prior distribution can improve audit
transparency and efficiency. <em>International Journal of Auditing</em>,
25(3), 621-636. <a href="https://doi.org/10.1111/ijau.12240">doi:10.1111/ijau.12240</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., Wille, J., &amp;
Wetzels, R. (2021). JASP for audit: Bayesian tools for the auditing
practice. <em>Journal of Open Source Software</em>, <em>6</em>(68), 2733.
<a href="https://doi.org/10.21105/joss.02733">doi:10.21105/joss.02733</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., &amp; Wetzels, R.
(2021). The Bayesian approach to audit evidence: Quantifying statistical
evidence using the Bayes factor. <em>PsyArXiv</em>.
<a href="https://doi.org/10.31234/osf.io/kzqp5">doi:10.31234/osf.io/kzqp5</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., &amp; Wetzels, R.
(2022). An impartial Bayesian hypothesis test for audit sampling.
<em>PsyArXiv</em>. <a href="https://doi.org/10.31234/osf.io/8nf3e">doi:10.31234/osf.io/8nf3e</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., &amp; Wetzels, R.
(2022). Bayesian generalized linear modeling for audit sampling: How to
incorporate audit information into the statistical model. <em>PsyArXiv</em>.
<a href="https://doi.org/10.31234/osf.io/byj2a">doi:10.31234/osf.io/byj2a</a>
</p>
<p>Dworin, L. D. and Grimlund, R. A. (1984). Dollar-unit sampling
for accounts receivable and inventory. <em>The Accounting Review</em>, 59(2),
218-241. <a href="https://www.jstor.org/stable/247296">https://www.jstor.org/stable/247296</a>
</p>
<p>Leslie, D. A., Teitlebaum, A. D., &amp; Anderson, R. J. (1979).
<em>Dollar-unit Sampling: A Practical Guide for Auditors</em>. Copp Clark
Pitman; Belmont, CA. ISBN: 9780773042780.
</p>
<p>Meikle, G. R. (1972). <em>Statistical Sampling in an Audit
Context</em>. Canadian Institute of Chartered Accountants.
</p>
<p>Pap, G., and van Zuijlen, M. C. (1996). On the asymptotic
behavior of the Stringer bound. <em>Statistica Neerlandica</em>, 50(3),
367-389. <a href="https://doi.org/10.1111/j.1467-9574.1996.tb01503.x">doi:10.1111/j.1467-9574.1996.tb01503.x</a>.
</p>
<p>Rohrbach, K. J. (1993). Variance augmentation to achieve nominal
coverage probability in sampling from audit populations. <em>Auditing</em>,
12(2), 79.
</p>
<p>Stringer, K. W. (1963). Practical aspects of statistical sampling
in auditing. <em>In Proceedings of the Business and Economic Statistics
Section</em> (pp. 405-411). American Statistical Association.
</p>
<p>Touw, P., and Hoogduin, L. (2011). <em>Statistiek voor Audit en
Controlling</em>. Boom uitgevers Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auditPrior">auditPrior</a></code>
<code><a href="#topic+planning">planning</a></code>
<code><a href="#topic+selection">selection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using summary statistics
evaluation(materiality = 0.05, x = 0, n = 100) # Non-stratified
evaluation(materiality = 0.05, x = c(2, 1, 0), n = c(50, 70, 40)) # Stratified

# Using data
data("BuildIt")
BuildIt$inSample &lt;- c(rep(1, 100), rep(0, 3400))
levs &lt;- c("low", "medium", "high")
BuildIt$stratum &lt;- factor(c(levs[3], levs[2], rep(levs, times = 1166)))
sample &lt;- subset(BuildIt, BuildIt$inSample == 1)

# Non-stratified evaluation
evaluation(
  materiality = 0.05, data = sample,
  values = "bookValue", values.audit = "auditValue"
)
# Stratified evaluation
evaluation(
  materiality = 0.05, data = sample, values = "bookValue",
  values.audit = "auditValue", strata = "stratum"
)
</code></pre>

<hr>
<h2 id='jfa-methods'>Methods for jfa objects</h2><span id='topic+jfa-methods'></span><span id='topic+print.jfaPrior'></span><span id='topic+print.summary.jfaPrior'></span><span id='topic+summary.jfaPrior'></span><span id='topic+predict.jfaPrior'></span><span id='topic+print.jfaPredict'></span><span id='topic+plot.jfaPrior'></span><span id='topic+plot.jfaPredict'></span><span id='topic+print.jfaPosterior'></span><span id='topic+print.summary.jfaPosterior'></span><span id='topic+summary.jfaPosterior'></span><span id='topic+predict.jfaPosterior'></span><span id='topic+plot.jfaPosterior'></span><span id='topic+print.jfaPlanning'></span><span id='topic+print.summary.jfaPlanning'></span><span id='topic+summary.jfaPlanning'></span><span id='topic+plot.jfaPlanning'></span><span id='topic+print.jfaSelection'></span><span id='topic+print.summary.jfaSelection'></span><span id='topic+summary.jfaSelection'></span><span id='topic+print.jfaEvaluation'></span><span id='topic+print.summary.jfaEvaluation'></span><span id='topic+summary.jfaEvaluation'></span><span id='topic+plot.jfaEvaluation'></span><span id='topic+print.jfaDistr'></span><span id='topic+print.summary.jfaDistr'></span><span id='topic+summary.jfaDistr'></span><span id='topic+plot.jfaDistr'></span><span id='topic+print.jfaRv'></span><span id='topic+plot.jfaRv'></span><span id='topic+print.jfaFairness'></span><span id='topic+print.summary.jfaFairness'></span><span id='topic+summary.jfaFairness'></span><span id='topic+plot.jfaFairness'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the <code><a href="#topic+auditPrior">auditPrior</a></code>, <code><a href="#topic+planning">planning</a></code>, <code><a href="#topic+selection">selection</a></code>, and <code><a href="#topic+evaluation">evaluation</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jfaPrior'
print(x, ...)

## S3 method for class 'summary.jfaPrior'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaPrior'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaPrior'
predict(object, n, cumulative = FALSE, ...)

## S3 method for class 'jfaPredict'
print(x, ...)

## S3 method for class 'jfaPrior'
plot(x, ...)

## S3 method for class 'jfaPredict'
plot(x, ...)

## S3 method for class 'jfaPosterior'
print(x, ...)

## S3 method for class 'summary.jfaPosterior'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaPosterior'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaPosterior'
predict(object, n, cumulative = FALSE, ...)

## S3 method for class 'jfaPosterior'
plot(x, ...)

## S3 method for class 'jfaPlanning'
print(x, ...)

## S3 method for class 'summary.jfaPlanning'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaPlanning'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaPlanning'
plot(x, ...)

## S3 method for class 'jfaSelection'
print(x, ...)

## S3 method for class 'summary.jfaSelection'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaSelection'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaEvaluation'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'summary.jfaEvaluation'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaEvaluation'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaEvaluation'
plot(x, type = c("estimates", "posterior"), ...)

## S3 method for class 'jfaDistr'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'summary.jfaDistr'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaDistr'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaDistr'
plot(x, type = c("estimates", "robustness", "sequential"), ...)

## S3 method for class 'jfaRv'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaRv'
plot(x, ...)

## S3 method for class 'jfaFairness'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'summary.jfaFairness'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'jfaFairness'
summary(object, digits = getOption("digits"), ...)

## S3 method for class 'jfaFairness'
plot(x, type = c("estimates", "posterior", "robustness", "sequential"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jfa-methods_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored.</p>
</td></tr>
<tr><td><code id="jfa-methods_+3A_digits">digits</code></td>
<td>
<p>an integer specifying the number of digits to which output should be rounded. Used in <code>summary</code>.</p>
</td></tr>
<tr><td><code id="jfa-methods_+3A_object">object</code>, <code id="jfa-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>jfaPrior</code>, <code>jfaPosterior</code>, <code>jfaPlanning</code>, <code>jfaSelection</code>, <code>jfaEvaluation</code>, <code>jfaDistr</code>, <code>jfaRv</code>, or <code>jfaFairness</code>.</p>
</td></tr>
<tr><td><code id="jfa-methods_+3A_n">n</code></td>
<td>
<p>used in <code>predict</code>. Specifies the sample size for which predictions should be made.</p>
</td></tr>
<tr><td><code id="jfa-methods_+3A_cumulative">cumulative</code></td>
<td>
<p>used in <code>predict</code>. Specifies whether cumulative probabilities should be shown.</p>
</td></tr>
<tr><td><code id="jfa-methods_+3A_type">type</code></td>
<td>
<p>used in <code>plot</code>. Specifies the type of plot to produce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> methods return a <code>data.frame</code> which contains the input and output.
</p>
<p>The <code>print</code> methods simply print and return nothing.
</p>

<hr>
<h2 id='model_fairness'>Algorithm Auditing: Fairness Metrics and Parity</h2><span id='topic+model_fairness'></span>

<h3>Description</h3>

<p>This function aims to assess fairness in algorithmic
decision-making systems by computing and testing the equality of one of
several model-agnostic fairness metrics between protected classes. The
metrics are computed based on a set of true labels and the predictions of an
algorithm. The ratio of these metrics between any unprivileged protected
class and the privileged protected class is called parity. This measure can
quantify potential fairness or discrimination in the algorithms predictions.
Available parity metrics include predictive rate parity, proportional parity,
accuracy parity, false negative rate parity, false positive rate parity, true
positive rate parity, negative predicted value parity, specificity parity,
and demographic parity. The function returns an object of class
<code>jfaFairness</code> that can be used with associated <code>summary()</code> and
<code>plot()</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_fairness(
  data,
  protected,
  target,
  predictions,
  privileged = NULL,
  positive = NULL,
  metric = c(
    "prp", "pp", "ap", "fnrp", "fprp",
    "tprp", "npvp", "sp", "dp"
  ),
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  prior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_fairness_+3A_data">data</code></td>
<td>
<p>a data frame containing the input data.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_protected">protected</code></td>
<td>
<p>a character specifying the column name in <code>data</code>
containing the protected classes (i.e., the sensitive attribute).</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_target">target</code></td>
<td>
<p>a character specifying the column name in <code>data</code>
containing the true labels of the target (i.e., to be predicted) variable.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_predictions">predictions</code></td>
<td>
<p>a character specifying the column name in <code>data</code>
containing the predicted labels of the target variable.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_privileged">privileged</code></td>
<td>
<p>a character specifying the factor level of the column
<code>protected</code> to be used as the privileged group. If <code>NULL</code> (the
default), the first factor level of the <code>protected</code> column is used.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_positive">positive</code></td>
<td>
<p>a character specifying the factor level positive class of
the column <code>target</code> to be used as the positive class. If <code>NULL</code>
(the default), the first factor level of the <code>target</code> column is used.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_metric">metric</code></td>
<td>
<p>a character indicating the fairness metrics to compute.
See the Details section below for more information.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_alternative">alternative</code></td>
<td>
<p>a character indicating the alternative hypothesis and
the type of confidence / credible interval used in the individual
comparisons to the privileged group. Possible options are  <code>two.sided</code>
(default), <code>less</code>, or <code>greater</code>. The alternative hypothesis
relating to the overall equality is always two sided.</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
confidence level (i.e., 1 - audit risk / detection risk).</p>
</td></tr>
<tr><td><code id="model_fairness_+3A_prior">prior</code></td>
<td>
<p>a logical specifying whether to use a prior distribution,
or a numeric value equal to or larger than 1 specifying the prior
concentration parameter. If this argument is specified as <code>FALSE</code>
(default), classical estimation is performed and if it is <code>TRUE</code>,
Bayesian estimation using a default prior with concentration parameter 1 is
performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following model-agnostic fairness metrics are computed based on
the confusion matrix for each protected class, using the true positives
(TP), false positives (FP), true negative (TN) and false negatives (FN).
See Pessach &amp; Shmueli (2022) for a more detailed explanation of the
individual metrics. The equality of metrics across groups is done according
to the methodology described in Fisher (1970) and Jamil et al. (2017).
</p>

<ul>
<li><p>Predictive rate parity (<code>prp</code>): calculated as TP / (TP +
FP), its ratio quantifies whether the predictive rate is equal across
protected classes.
</p>
</li>
<li><p>Proportional parity (<code>pp</code>): calculated as (TP + FP) / (TP +
FP + TN + FN), its ratio quantifies whether the positive prediction
rate is equal across protected classes.
</p>
</li>
<li><p>Accuracy parity (<code>ap</code>): calculated as (TP + TN) / (TP + FP +
TN + FN), quantifies whether the accuracy is the same across groups.
</p>
</li>
<li><p>False negative rate parity (<code>fnrp</code>): calculated as FN / (FP
+ FN), quantifies whether the false negative rate is the same across
groups.
</p>
</li>
<li><p>False positive rate parity (<code>fprp</code>): calculated as FP / (TN
+ FP), quantifies whether the false positive rate is the same across
groups.
</p>
</li>
<li><p>True positive rate parity (<code>tprp</code>): calculated as TP / (TP +
FN), quantifies whether the true positive rate is the same across
groups.
</p>
</li>
<li><p>Negative predicted value parity (<code>npvp</code>): calculated as TN /
(TN + FN), quantifies whether the negative predicted value is equal
across groups.
</p>
</li>
<li><p>Specificity parity (<code>sp</code>): calculated as TN / (TN + FP),
quantifies whether the true positive rate is the same across groups.
</p>
</li>
<li><p>Demographic parity (<code>dp</code>): calculated as TP + FP, quantifies
whether the positive predictions are equal across groups.
</p>
</li></ul>

<p>Note that, in an audit context, not all fairness measures are equally
appropriate in all situations. The fairness tree below aids in choosing
which fairness measure is appropriate for the situation at hand (Büyük,
2023).
</p>
<p><img src="../help/figures/fairness-tree.png" width="100%" alt="fairness-tree" />

</p>


<h3>Value</h3>

<p>An object of class <code>jfaFairness</code> containing:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>the specified data.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 giving the confidence
level.</p>
</td></tr>
<tr><td><code>privileged</code></td>
<td>
<p>The privileged group for computing the fairness metrics.</p>
</td></tr>
<tr><td><code>unprivileged</code></td>
<td>
<p>The unprivileged group(s).</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>The target variable used in computing the fairness metrics.</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>The predictions used to compute the fairness metrics.</p>
</td></tr>
<tr><td><code>protected</code></td>
<td>
<p>The variable indicating the protected classes.</p>
</td></tr>
<tr><td><code>positive</code></td>
<td>
<p>The positive class used in computing the fairness metrics.</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>The negative class used in computing the fairness metrics.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>The type of confidence interval.</p>
</td></tr>
<tr><td><code>confusion.matrix</code></td>
<td>
<p>A list of confusion matrices for each group.</p>
</td></tr>
<tr><td><code>performance</code></td>
<td>
<p>A data frame containing performance metrics for each
group, including accuracy, precision, recall, and F1 score.</p>
</td></tr>
<tr><td><code>metric</code></td>
<td>
<p>A data frame containing, for each group, the estimates of the
fairness metric along with the associated confidence / credible interval.</p>
</td></tr>
<tr><td><code>parity</code></td>
<td>
<p>A data frame containing, for each unprivileged group, the
parity and associated confidence / credible interval when compared to the
privileged group.</p>
</td></tr>
<tr><td><code>odds.ratio</code></td>
<td>
<p>A data frame containing, for each unprivileged group, the
odds ratio of the fairness metric and its associated confidence/credible
interval, along with inferential measures such as uncorrected p-values or
Bayes factors.</p>
</td></tr>
<tr><td><code>measure</code></td>
<td>
<p>The abbreviation of the selected fairness metric.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>a logical indicating whether a prior distribution was used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>The name of the input data object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Büyük, S. (2023). <em>Automatic Fairness Criteria and Fair
Model Selection for Critical ML Tasks</em>, Master Thesis, Utrecht University.
</p>
<p>Calders, T., &amp; Verwer, S. (2010). Three naive Bayes approaches
for discrimination-free classification. In <em>Data Mining and Knowledge
Discovery</em>. Springer Science and Business Media LLC.
<a href="https://doi.org/10.1007/s10618-010-0190-x">doi:10.1007/s10618-010-0190-x</a>
</p>
<p>Chouldechova, A. (2017). Fair prediction with disparate impact:
A study of bias in recidivism prediction instruments. In <em>Big Data</em>.
Mary Ann Liebert Inc. <a href="https://doi.org/10.1089/big.2016.0047">doi:10.1089/big.2016.0047</a>
</p>
<p>Feldman, M., Friedler, S. A., Moeller, J., Scheidegger, C., &amp;
Venkatasubramanian, S. (2015). Certifying and removing disparate impact. In
<em>Proceedings of the 21th ACM SIGKDD International Conference on
Knowledge Discovery and Data Mining</em>. <a href="https://doi.org/10.1145/2783258.2783311">doi:10.1145/2783258.2783311</a>
</p>
<p>Friedler, S. A., Scheidegger, C., Venkatasubramanian, S.,
Choudhary, S., Hamilton, E. P., &amp; Roth, D. (2019). A comparative study of
fairness-enhancing interventions in machine learning. In <em>Proceedings
of the Conference on Fairness, Accountability, and Transparency</em>.
<a href="https://doi.org/10.1145/3287560.3287589">doi:10.1145/3287560.3287589</a>
</p>
<p>Fisher, R. A. (1970). <em>Statistical Methods for Research
Workers</em>. Oliver &amp; Boyd.
</p>
<p>Jamil, T., Ly, A., Morey, R. D., Love, J., Marsman, M., &amp;
Wagenmakers, E. J. (2017). Default &quot;Gunel and Dickey&quot; Bayes factors for
contingency tables. <em>Behavior Research Methods</em>, 49, 638-652.
<a href="https://doi.org/10.3758/s13428-016-0739-8">doi:10.3758/s13428-016-0739-8</a>
</p>
<p>Pessach, D. &amp; Shmueli, E. (2022). A review on fairness in machine
learning. <em>ACM Computing Surveys</em>, 55(3), 1-44. <a href="https://doi.org/10.1145/3494672">doi:10.1145/3494672</a>
</p>
<p>Zafar, M. B., Valera, I., Gomez Rodriguez, M., &amp; Gummadi, K. P.
(2017). Fairness beyond disparate Ttreatment &amp; disparate impact. In
<em>Proceedings of the 26th International Conference on World Wide Web</em>.
<a href="https://doi.org/10.1145/3038912.3052660">doi:10.1145/3038912.3052660</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Frequentist test of specificy parity
model_fairness(
  data = compas,
  protected = "Gender",
  target = "TwoYrRecidivism",
  predictions = "Predicted",
  privileged = "Male",
  positive = "yes",
  metric = "sp"
)
</code></pre>

<hr>
<h2 id='planning'>Audit Sampling: Planning</h2><span id='topic+planning'></span>

<h3>Description</h3>

<p><code>planning()</code> is used to calculate a minimum sample size for
audit samples. It allows specification of statistical requirements for the
sample with respect to the performance materiality or the precision. The
function returns an object of class <code>jfaPlanning</code> that can be used with
associated <code>summary()</code> and <code>plot()</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planning(
  materiality = NULL,
  min.precision = NULL,
  expected = 0,
  likelihood = c("poisson", "binomial", "hypergeometric"),
  conf.level = 0.95,
  N.units = NULL,
  by = 1,
  max = 5000,
  prior = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planning_+3A_materiality">materiality</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
performance materiality (i.e., the maximum tolerable misstatement in the
population) as a fraction. Can be <code>NULL</code>, but <code>min.precision</code>
should be specified in that case.</p>
</td></tr>
<tr><td><code id="planning_+3A_min.precision">min.precision</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the minimum
precision (i.e., the estimated upper bound minus the estimated most likely
error) as a fraction. Can be <code>NULL</code>, but <code>materiality</code> should be
specified in that case.</p>
</td></tr>
<tr><td><code id="planning_+3A_expected">expected</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the expected
(tolerable) misstatements in the sample relative to the total sample size,
or a number (&gt;= 1) specifying the expected (tolerable) number of
misstatements in the sample. It is advised to set this value conservatively
to minimize the probability of the observed misstatements in the sample
exceeding the expected misstatements, which would imply that insufficient
work has been done in the end and that additional samples are required.
This argument also facilitates sequential sampling plans since it can also
be a vector (e.g., <code>c(1, 0)</code>) of tolerable misstatements in each stage
of the audit sample. Hence, <code>c(1, 0)</code> gives the sample size for a
sequential sampling plan in which the auditor can stop after seeing 0
misstatements in the first sample, but can extend the sample if more than
0 misstatements are found.</p>
</td></tr>
<tr><td><code id="planning_+3A_likelihood">likelihood</code></td>
<td>
<p>a character specifying the likelihood of the data.
Possible options are <code>poisson</code> (default) for the Poisson likelihood,
<code>binomial</code> for the binomial likelihood, or <code>hypergeometric</code> for
the hypergeometric likelihood. See the details section for more information
about the possible likelihoods.</p>
</td></tr>
<tr><td><code id="planning_+3A_conf.level">conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the
confidence level (i.e., 1 - audit risk / detection risk).</p>
</td></tr>
<tr><td><code id="planning_+3A_n.units">N.units</code></td>
<td>
<p>a numeric value larger than 0 specifying the total
number of units in the population. Required for the <code>hypergeometric</code>
likelihood.</p>
</td></tr>
<tr><td><code id="planning_+3A_by">by</code></td>
<td>
<p>an integer larger than 0 specifying the increment
between acceptable sample sizes (e.g., <code>increment = 5</code> considers only
sample sizes of 5, 10, 15, ...).</p>
</td></tr>
<tr><td><code id="planning_+3A_max">max</code></td>
<td>
<p>an integer larger than 0 specifying the sample size at
which the algorithm terminates (e.g., <code>max = 100</code> will terminate the
algorithm at <em>n</em> = 100).</p>
</td></tr>
<tr><td><code id="planning_+3A_prior">prior</code></td>
<td>
<p>a logical specifying whether to use a prior distribution,
or an object of class <code>jfaPrior</code> or <code>jfaPosterior</code>. If this
argument is specified as <code>FALSE</code> (default), the function performs
classical planning. If this argument is specified as <code>TRUE</code> or as a
prior from <code>auditPrior</code>, this function performs Bayesian planning
using a prior that is conjugate to the specified <code>likelihood</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section elaborates on the available input options for the
<code>likelihood</code> argument and the corresponding conjugate prior
distributions used by <code>jfa</code>.
</p>

<ul>
<li><p><code>poisson</code>:        The Poisson distribution is an approximation of
the binomial distribution. The Poisson distribution is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(\theta, n) = \frac{\lambda^\theta e^{-\lambda}}{\theta!}</code>
</p>
<p>. The
conjugate <em>gamma(<code class="reqn">\alpha, \beta</code>)</em> prior has probability density
function:
</p>
<p style="text-align: center;"><code class="reqn">p(\theta; \alpha, \beta) = \frac{\beta^\alpha \theta^{\alpha - 1}
   e^{-\beta \theta}}{\Gamma(\alpha)}</code>
</p>
<p>.
</p>
</li>
<li><p><code>binomial</code>:       The binomial distribution is an approximation
of the hypergeometric distribution. The binomial distribution is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(\theta, n, x) = {n \choose x} \theta^x (1 - \theta)^{n - x}</code>
</p>
<p>. The
conjugate <em>beta(<code class="reqn">\alpha, \beta</code>)</em> prior has probability density
function: </p>
<p style="text-align: center;"><code class="reqn">p(\theta; \alpha, \beta) = \frac{1}{B(\alpha, \beta)}
 \theta^{\alpha - 1} (1 - \theta)^{\beta - 1}</code>
</p>
<p>.
</p>
</li>
<li><p><code>hypergeometric</code>: The hypergeometric distribution is defined as:
</p>
<p style="text-align: center;"><code class="reqn">f(x, n, K, N) = \frac{{K \choose x} {N - K \choose n - x}}
 {{N \choose n}}</code>
</p>
<p>. The conjugate <em>beta-binomial(<code class="reqn">\alpha, \beta</code>)</em>
prior (Dyer and Pierce, 1993) has probability mass function:
</p>
<p style="text-align: center;"><code class="reqn">f(x, n, \alpha, \beta) = {n \choose x}
 \frac{B(x + \alpha, n - x + \beta)}{B(\alpha, \beta)}</code>
</p>
<p>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>jfaPlanning</code> containing:
</p>
<table>
<tr><td><code>conf.level</code></td>
<td>
<p>a numeric value between 0 and 1 giving the confidence
level.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a numeric value larger than, or equal to, 0 giving (the proportional
sum of) the tolerable errors in the sample.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>an integer larger than 0 giving the minimum sample size.</p>
</td></tr>
<tr><td><code>n_staged</code></td>
<td>
<p>in the case of a multi-stage sampling plan, an integer
larger than 0 giving the minimum sample size per stage.</p>
</td></tr>
<tr><td><code>ub</code></td>
<td>
<p>a numeric value between 0 and 1 giving the expected upper bound.</p>
</td></tr>
<tr><td><code>precision</code></td>
<td>
<p>a numeric value between 0 and 1 giving the expected
precision.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>a numeric value giving the expected one-sided p-value.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>if <code>likelihood = 'hypergeometric'</code>, an integer larger than 0
giving the assumed population errors.</p>
</td></tr>
<tr><td><code>N.units</code></td>
<td>
<p>an integer larger than 0 giving the number of units in the
population (only returned if <code>N.units</code> is specified).</p>
</td></tr>
<tr><td><code>materiality</code></td>
<td>
<p>a numeric value between 0 and 1 giving the performance
materiality if specified.</p>
</td></tr>
<tr><td><code>min.precision</code></td>
<td>
<p>a numeric value between 0 and 1 giving the minimum
precision if specified.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>a numeric value larger than, or equal to, 0 giving the
expected misstatement input.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>a character indicating the likelihood.</p>
</td></tr>
<tr><td><code>errorType</code></td>
<td>
<p>a character indicating the expected misstatements input.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>an integer giving the number of iterations of the
algorithm.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>if a prior distribution is specified, an object of class
<code>jfaPrior</code> that contains information about the prior distribution.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>if a prior distribution is specified, an object of class
<code>jfaPosterior</code> that contains information about the expected posterior
distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Derks, K., de Swart, J., van Batenburg, P., Wagenmakers, E.-J.,
&amp; Wetzels, R. (2021). Priors in a Bayesian audit: How integration of
existing information into the prior distribution can improve audit
transparency and efficiency. <em>International Journal of Auditing</em>,
25(3), 621-636. <a href="https://doi.org/10.1111/ijau.12240">doi:10.1111/ijau.12240</a>
</p>
<p>Derks, K., de Swart, J., Wagenmakers, E.-J., Wille, J., &amp;
Wetzels, R. (2021). JASP for audit: Bayesian tools for the auditing
practice. <em>Journal of Open Source Software</em>, <em>6</em>(68), 2733.
<a href="https://doi.org/10.21105/joss.02733">doi:10.21105/joss.02733</a>
</p>
<p>Dyer, D. and Pierce, R.L. (1993). On the choice of the prior
distribution in hypergeometric sampling. <em>Communications in Statistics -
Theory and Methods</em>, 22(8), 2125-2146. <a href="https://doi.org/10.1080/03610929308831139">doi:10.1080/03610929308831139</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auditPrior">auditPrior</a></code>
<code><a href="#topic+selection">selection</a></code>
<code><a href="#topic+evaluation">evaluation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Classical planning
planning(materiality = 0.03, expected = 0)

# Classical two-stage planning
planning(materiality = 0.03, expected = c(1, 0))

# Bayesian planning using a default prior
planning(materiality = 0.03, prior = TRUE)

# Bayesian planning using a custom prior
prior &lt;- auditPrior(method = "impartial", materiality = 0.05)
planning(materiality = 0.05, prior = prior)
</code></pre>

<hr>
<h2 id='repeated_test'>Data Auditing: Repeated Values Test</h2><span id='topic+repeated_test'></span>

<h3>Description</h3>

<p>This function analyzes the frequency with which values get
repeated within a set of numbers. Unlike Benford's law, and its
generalizations, this approach examines the entire number at once, not only
the first or last digit(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeated_test(
  x,
  check = c("last", "lasttwo", "all"),
  method = c("af", "entropy"),
  samples = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeated_test_+3A_x">x</code></td>
<td>
<p>a numeric vector of values from which the digits should be
analyzed.</p>
</td></tr>
<tr><td><code id="repeated_test_+3A_check">check</code></td>
<td>
<p>which digits to shuffle during the procedure. Can be
<code>last</code> or <code>lasttwo</code>.</p>
</td></tr>
<tr><td><code id="repeated_test_+3A_method">method</code></td>
<td>
<p>which statistics is used. Defaults to <code>af</code> for average
frequency, but can also be <code>entropy</code> for entropy.</p>
</td></tr>
<tr><td><code id="repeated_test_+3A_samples">samples</code></td>
<td>
<p>how many samples to use in the bootstraping procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To determine whether the data show an excessive amount of bunching,
the null hypothesis that <code>x</code> does not contain an unexpected amount of
repeated values is tested against the alternative hypothesis that <code>x</code>
has more repeated values than expected. The statistic can either be the
average frequency (<code class="reqn">AF = sum(f_i^2)/sum(f_i))</code> of the data or the
entropy (<code class="reqn">E = - sum(p_i * log(p_i))</code>, with <code class="reqn">p_i=f_i/n</code>) of the
data. Average frequency and entropy are highly correlated, but the average
frequency is often more interpretable. For example, an average frequency of
2.5 means that, on average, your observations contain a value that appears
2.5 times in the data set.To quantify what is expected, this test requires
the assumption that the integer portions of the numbers are not associated
with their decimal portions.
</p>


<h3>Value</h3>

<p>An object of class <code>jfaRv</code> containing:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>input data.</p>
</td></tr>
<tr><td><code>frequencies</code></td>
<td>
<p>frequencies of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>vector of simulated samples.</p>
</td></tr>
<tr><td><code>integers</code></td>
<td>
<p>counts for extracted integers.</p>
</td></tr>
<tr><td><code>decimals</code></td>
<td>
<p>counts for extracted decimals.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations in <code>x</code>.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value the average frequency or entropy statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>cor.test</code></td>
<td>
<p>correlation test for the integer portions of the number
versus the decimals portions of the number.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>method used.</p>
</td></tr>
<tr><td><code>check</code></td>
<td>
<p>checked digits.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Simohnsohn, U. (2019, May 25). Number-Bunching: A New Tool for
Forensic Data Analysis. Retrieved from <a href="https://datacolada.org/77">https://datacolada.org/77</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+digit_test">digit_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rnorm(50)

# Repeated values analysis shuffling last digit
repeated_test(x, check = "last", method = "af", samples = 2000)
</code></pre>

<hr>
<h2 id='retailer'>Retailer Group Audit</h2><span id='topic+retailer'></span>

<h3>Description</h3>

<p>Sample outcomes summarized per branch from an audit of a retail company
consisting of 20 branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(retailer)
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 5 variables.
</p>

<dl>
<dt>stratum</dt><dd><p>branch/stratum number.</p>
</dd>
<dt>items</dt><dd><p>total number of items in each branch.</p>
</dd>
<dt>samples</dt><dd><p>number of items in sample per branch.</p>
</dd>
<dt>errors</dt><dd><p>number of errors in sample per branch.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Derks, K., de Swart, J., &amp; Wetzels, R. (2022). Een Bayesiaanse blik
op gestratificeerde steekproeven heeft voordelen voor de auditor.
<em>Maandblad voor Accountancy en Bedrijfseconomie</em>, 96(1/2), 37-46.
<a href="https://doi.org/10.5117/mab.96.78836">doi:10.5117/mab.96.78836</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(retailer)
</code></pre>

<hr>
<h2 id='sanitizer'>Factory Workers' use of Hand Sanitizer</h2><span id='topic+sanitizer'></span>

<h3>Description</h3>

<p>Data from a study on factory workers' use of hand sanitizer. Sanitizer use
was measured to a 100th of a gram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sanitizer)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1600 rows and 1 variable.
</p>


<h3>Source</h3>

<p><a href="http://datacolada.org/appendix/74/">http://datacolada.org/appendix/74/</a>
</p>


<h3>References</h3>

<p>[Retracted] Li, M., Sun, Y., &amp; Chen, H. (2019). The decoy effect
as a nudge: Boosting hand hygiene with a worse option. Psychological Science,
30, 139–149.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sanitizer)
</code></pre>

<hr>
<h2 id='selection'>Audit Sampling: Selection</h2><span id='topic+selection'></span>

<h3>Description</h3>

<p><code>selection()</code> is used to perform statistical selection of
audit samples. It offers flexible implementations of the most common audit
sampling algorithms for attributes sampling and monetary unit sampling. The
function returns an object of class <code>jfaSelection</code> that can be used with
the associated <code>summary()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection(
  data,
  size,
  units = c("items", "values"),
  method = c("interval", "cell", "random", "sieve"),
  values = NULL,
  order = NULL,
  decreasing = FALSE,
  randomize = FALSE,
  replace = FALSE,
  start = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection_+3A_data">data</code></td>
<td>
<p>a data frame containing the population data.</p>
</td></tr>
<tr><td><code id="selection_+3A_size">size</code></td>
<td>
<p>an integer larger than 0 specifying the number of units to
select. Can also be an object of class <code>jfaPlanning</code>.</p>
</td></tr>
<tr><td><code id="selection_+3A_units">units</code></td>
<td>
<p>a character specifying the type of sampling units. Possible
options are <code>items</code> (default) for selection on the level of items
(rows) or <code>values</code> for selection on the level of monetary units.</p>
</td></tr>
<tr><td><code id="selection_+3A_method">method</code></td>
<td>
<p>a character specifying the sampling algorithm. Possible
options are <code>interval</code> (default) for fixed interval sampling,
<code>cell</code> for cell sampling, <code>random</code> for random sampling, or
<code>sieve</code> for modified sieve sampling.</p>
</td></tr>
<tr><td><code id="selection_+3A_values">values</code></td>
<td>
<p>a character specifying the name of a column in <code>data</code>
containing the book values of the items.</p>
</td></tr>
<tr><td><code id="selection_+3A_order">order</code></td>
<td>
<p>a character specifying the name of a column in <code>data</code>
containing the ranks of the items. The items in the <code>data</code> are ordered
according to these values in the order indicated by <code>decreasing</code>.</p>
</td></tr>
<tr><td><code id="selection_+3A_decreasing">decreasing</code></td>
<td>
<p>a logical specifying whether to order the items from
smallest to largest. Only used if <code>order</code> is specified.</p>
</td></tr>
<tr><td><code id="selection_+3A_randomize">randomize</code></td>
<td>
<p>a logical specifying if items should be randomly shuffled
prior to selection. Note that <code>randomize = TRUE</code> overrules
<code>order</code>.</p>
</td></tr>
<tr><td><code id="selection_+3A_replace">replace</code></td>
<td>
<p>a logical specifying if sampling units should be selected
with replacement. Only used for method <code>random</code>.</p>
</td></tr>
<tr><td><code id="selection_+3A_start">start</code></td>
<td>
<p>an integer larger than 0 specifying index of the unit that
should be selected. Only used for method <code>interval</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section elaborates on the possible options for the <code>units</code>
argument:
</p>

<ul>
<li><p><code>items</code>: In attributes sampling each item in the population is a
sampling unit. An item with a book value of $5000 is therefore equally
likely to be selected as an item with a book value of $500.
</p>
</li>
<li><p><code>values</code>: In monetary unit sampling each monetary unit in the
population is a sampling unit. An item with a book value of $5000 is
therefore ten times more likely to be selected as an item with a book
value of $500.
</p>
</li></ul>

<p>This section elaborates on the possible options for the
<code>method</code> argument:
</p>

<ul>
<li><p><code>interval</code>: In fixed interval sampling the sampling units are
divided into a number of equally large intervals. In each interval, a
single sampling unit is selected according to a fixed starting point
(specified by <code>start</code>).
</p>
</li>
<li><p><code>cell</code>:     In cell sampling the sampling units in the population
are divided into a number (equal to the sample size) of equally large
intervals. In each interval, a single sampling unit is selected randomly.
</p>
</li>
<li><p><code>random</code>:   In random sampling all sampling units are drawn with
equal probability.
</p>
</li>
<li><p><code>sieve</code>:    In modified sieve sampling items are selected with
the largest sieve ratio (Hoogduin, Hall, &amp; Tsay, 2010).
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>jfaSelection</code> containing:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a data frame containing the population data.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>a data frame containing the selected data sample.</p>
</td></tr>
<tr><td><code>n.req</code></td>
<td>
<p>an integer giving the requested sample size.</p>
</td></tr>
<tr><td><code>n.units</code></td>
<td>
<p>an integer giving the number of obtained sampling units.</p>
</td></tr>
<tr><td><code>n.items</code></td>
<td>
<p>an integer giving the number of obtained sample items.</p>
</td></tr>
<tr><td><code>N.units</code></td>
<td>
<p>an integer giving the number of sampling units in the
population data.</p>
</td></tr>
<tr><td><code>N.items</code></td>
<td>
<p>an integer giving the number of items in the population data.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>if <code>method = "interval"</code>, a numeric value giving the
size of the selection interval.</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>a character indicating the type of sampling units.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character indicating the sampling algorithm.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>if <code>values</code> is specified, a character indicating the book
value column.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>if <code>method = "interval"</code>, an integer giving the index of
the selected unit in each interval.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character indicating the name of the population data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Koen Derks, <a href="mailto:k.derks@nyenrode.nl">k.derks@nyenrode.nl</a>
</p>


<h3>References</h3>

<p>Derks, K., de Swart, J., Wagenmakers, E.-J., Wille, J., &amp;
Wetzels, R. (2021). JASP for audit: Bayesian tools for the auditing
practice. <em>Journal of Open Source Software</em>, <em>6</em>(68), 2733.
<a href="https://doi.org/10.21105/joss.02733">doi:10.21105/joss.02733</a>
</p>
<p>Hoogduin, L. A., Hall, T. W., &amp; Tsay, J. J. (2010). Modified
sieve sampling: A method for single-and multi-stage
probability-proportional-to-size sampling. <em>Auditing: A Journal of
Practice &amp; Theory</em>, 29(1), 125-148.
<a href="https://doi.org/10.2308/aud.2010.29.1.125">doi:10.2308/aud.2010.29.1.125</a>
</p>
<p>Leslie, D. A., Teitlebaum, A. D., &amp; Anderson, R. J. (1979).
<em>Dollar-unit Sampling: A Practical Guide for Auditors</em>. Copp Clark
Pitman; Belmont, CA. ISBN: 9780773042780.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auditPrior">auditPrior</a></code>
<code><a href="#topic+planning">planning</a></code>
<code><a href="#topic+evaluation">evaluation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("BuildIt")

# Select 100 items using random sampling
set.seed(1)
selection(data = BuildIt, size = 100, method = "random")

# Select 150 monetary units using fixed interval sampling
selection(
  data = BuildIt, size = 150, units = "values",
  method = "interval", values = "bookValue"
)
</code></pre>

<hr>
<h2 id='sinoForest'>Sino Forest Corporation's Financial Statements.</h2><span id='topic+sinoForest'></span>

<h3>Description</h3>

<p>Financial statement numbers of Sino Forest Corporation's 2010 Report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sinoForest)
</code></pre>


<h3>Format</h3>

<p>A data frame with 772 rows and 1 variable.
</p>


<h3>Source</h3>

<p><a href="https://cran.r-project.org/package=benford.analysis">https://cran.r-project.org/package=benford.analysis</a>
</p>


<h3>References</h3>

<p>Nigrini, M. J. (2012). Benford's Law: Application for Forensic
Accounting, Auditing and Fraud Detection. Wiley and Sons: New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sinoForest)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
