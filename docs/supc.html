<!DOCTYPE html><html><head><title>Help for package supc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {supc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#D31'><p>The Artificial Data of Consisting of as Many as 31 Randomly Placed Gaussian Clusters</p></a></li>
<li><a href='#dist.mode'><p>Configure which package is used to compute the distance matrix</p></a></li>
<li><a href='#dist.parallelization'><p>Configure how many cores will be used to calculate the distance matrix</p></a></li>
<li><a href='#freq.poly'><p>Plot the frequency polygon of pairwise distance</p></a></li>
<li><a href='#freq.poly.supc'><p>Plot the frequency polygon of pairwise distance</p></a></li>
<li><a href='#golub'><p>Gene expression dataset from Golub et al. (1999)</p></a></li>
<li><a href='#plot.supc'><p>Draw plots of the clustering result</p></a></li>
<li><a href='#shape'><p>The Artificial Data of Five Different Clusters</p></a></li>
<li><a href='#supc.random'><p>Randomized Self-Updating Process Clustering</p></a></li>
<li><a href='#supc1'><p>Self-Updating Process Clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Self-Updating Process Clustering Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wush Wu &lt;wush978@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the self-updating process clustering algorithms proposed
    in Shiu and Chen (2016) &lt;<a href="https://doi.org/10.1080%2F00949655.2015.1049605">doi:10.1080/00949655.2015.1049605</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wush978/supc">https://github.com/wush978/supc</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>amap, knitr, rmarkdown, fields, dbscan</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp(&ge; 0.12), BH(&ge; 1.62)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-10 14:53:08 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Wush Wu [aut, cre],
  Shang-Ying Shiu [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-11 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='D31'>The Artificial Data of Consisting of as Many as 31 Randomly Placed Gaussian Clusters</h2><span id='topic+D31'></span>

<h3>Description</h3>

<p>This artificial data was generated to show the strength of SUPC.
Clustering <code>D31</code> dataset is difficult for the partition type of clustering algorithms that require an initial set.
However, SUP correctly identifies the 31 major clusters.
</p>


<h3>References</h3>

<p>Veenman, C. J., M. J. T. Reinders, and E. Backer. 2002. A Maximum Variance Cluster Algorithm. IEEE Trans. Pattern Analysis and Machine Intelligence 24 (9): 1273–80.
</p>

<hr>
<h2 id='dist.mode'>Configure which package is used to compute the distance matrix</h2><span id='topic+dist.mode'></span>

<h3>Description</h3>

<p>Configure which package is used to compute the distance matrix or register one.
Note that the speed depends on the data and the hardware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.mode(mode = c("stats", "amap"), FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.mode_+3A_mode">mode</code></td>
<td>
<p>string. The available modes are <code>"stats"</code> and <code>"amap"</code> by default.</p>
</td></tr>
<tr><td><code id="dist.mode_+3A_fun">FUN</code></td>
<td>
<p>a function which has one argument <code>x</code> or <code>NULL</code>. 
The function should compute the pairwise distance of <code>x</code> and return a <code>dist</code> object.
The user can skip this argument if the <code>mode</code> is registered. For example, <code>"stats"</code>
and <code>"amap"</code> are registered by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The function is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use stats::dist to compute the pairwise distance
dist.mode("stats")
# use amap::Dist to compute the pairwise distance
dist.mode("amap")
</code></pre>

<hr>
<h2 id='dist.parallelization'>Configure how many cores will be used to calculate the distance matrix</h2><span id='topic+dist.parallelization'></span>

<h3>Description</h3>

<p>Only affect <code><a href="amap.html#topic+Dist">Dist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.parallelization(i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.parallelization_+3A_i">i</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The function is called for side effects.
</p>

<hr>
<h2 id='freq.poly'>Plot the frequency polygon of pairwise distance</h2><span id='topic+freq.poly'></span><span id='topic+freq.poly.default'></span><span id='topic+freq.poly.dist'></span>

<h3>Description</h3>

<p>Plot the frequency polygon of the pairwise distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq.poly(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq.poly_+3A_x">x</code></td>
<td>
<p>either dist object or matrix.</p>
</td></tr>
<tr><td><code id="freq.poly_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"histogram"</code> which is a list with components:
</p>
<table>
<tr><td><code>breaks</code></td>
<td>
<p>the <code class="reqn">n+1</code> cell boundaries (= <code>breaks</code> if that
was a vector). These are the nominal breaks, not with the boundary fuzz.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p><code class="reqn">n</code> integers; for each cell, the number of
<code>x[]</code> inside.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>values <code class="reqn">\hat f(x_i)</code>, as estimated
density values. If <code>all(diff(breaks) == 1)</code>, they are the
relative frequencies <code>counts/n</code> and in general satisfy
<code class="reqn">\sum_i \hat f(x_i) (b_{i+1}-b_i) = 1</code>, where <code class="reqn">b_i</code> = <code>breaks[i]</code>.</p>
</td></tr>
<tr><td><code>mids</code></td>
<td>
<p>the <code class="reqn">n</code> cell midpoints.</p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p>a character string with the actual <code>x</code> argument name.</p>
</td></tr>
<tr><td><code>equidist</code></td>
<td>
<p>logical, indicating if the distances between
<code>breaks</code> are all the same.</p>
</td></tr>
</table>

<hr>
<h2 id='freq.poly.supc'>Plot the frequency polygon of pairwise distance</h2><span id='topic+freq.poly.supc'></span><span id='topic+freq.poly.subclist'></span>

<h3>Description</h3>

<p>Plot the frequency polygon of the pairwise distance. The red dashed line is the used parameter <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'supc'
freq.poly(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq.poly.supc_+3A_x">x</code></td>
<td>
<p>either dist object or matrix.</p>
</td></tr>
<tr><td><code id="freq.poly.supc_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The function is called for side effects.
</p>

<hr>
<h2 id='golub'>Gene expression dataset from Golub et al. (1999)</h2><span id='topic+golub'></span><span id='topic+golub.supc'></span>

<h3>Description</h3>

<p>Gene expression data (3051 genes and 38 tumor mRNA samples) from the leukemia microarray study of Golub et al. (1999). 
Each row (gene) is scaled to mean 0 and standard deviation 1.
</p>


<h3>Value</h3>

<table>
<tr><td><code>golub</code></td>
<td>
<p>The matrix of scaled gene expression data.</p>
</td></tr>
<tr><td><code>golub.supc</code></td>
<td>
<p>The result of <code>golub.supc &lt;- supc1(golub, r = c(4, 4.3, 4.6, 4.7, 4.8), t = "dynamic")</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Golub, T. R., D. K. Slonim, P. Tamayo P., C. Huard C, M. Gaasenbeek M., J.P. J. P. Mesirov, H. H. Coller, et al. 1999. Molecular Classification of Cancer: Class Discovery and Class Prediction by Gene Expression Monitoring. Science 286 (5439): 531–37.
</p>

<hr>
<h2 id='plot.supc'>Draw plots of the clustering result</h2><span id='topic+plot.supc'></span>

<h3>Description</h3>

<p>General function to draw plots for analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'supc'
plot(x, type = "heatmap", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.supc_+3A_x">x</code></td>
<td>
<p><code>supc</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.supc_+3A_type">type</code></td>
<td>
<p>character value. </p>

<ul>
<li><p><code>"heatmap"</code>draw a heatmap to show the result of clustering. The clusters whose size is greater than parameter <code>major.size</code> are treated as major clusters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.supc_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The function is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(golub, package = "supc")
golub.supc &lt;- supc1(golub, rp = 0.0005, t = "dynamic", implementation = "R")
table(golub.supc$size)
plot(golub.supc, type = "heatmap", major.size = 10)


</code></pre>

<hr>
<h2 id='shape'>The Artificial Data of Five Different Clusters</h2><span id='topic+shape'></span>

<h3>Description</h3>

<p>This artificial data was generated to have five clusters: one big circle, two small circles, and two ellipses.
It was to test if the clustering algorithm could identify and distinguish between the five different clusters or not.
The dataset is generated from the following script:
</p>
<pre>
makecircle &lt;- function(N, seed) {
 n &lt;- 0
 x &lt;- NULL
 set.seed(seed)
 while(n &lt; N) {
   tmp &lt;- runif(2, min = -1, max = 1)
   if (t(tmp) %*% tmp &lt; 1) {
     n &lt;- n + 1
     x &lt;- rbind(x, tmp)
   }
 }
 return (x)
}

makedata &lt;- function(n, seed) {
 f &lt;- c(10, 3, 3, 1, 1)
 center &lt;- matrix(
   c(-.3, -.3, -.55, .8, .55, .8, .9, 0, .9, -.6),
   nrow = 5, ncol = 2, byrow = TRUE
 )
 s &lt;- matrix(
   c(.7, .7, .45, .2, .45, .2, .1, .1, .1, .1),
   nrow = 5, ncol = 2, byrow = TRUE
 )
 x &lt;- NULL
 for (i in 1:5) {
   tmp &lt;- makecircle(n * f[i], seed + i)
   tmp[,1] &lt;- tmp[,1] * s[i,1] + center[i,1]
   tmp[,2] &lt;- tmp[,2] * s[i,2] + center[i,2]
   x &lt;- rbind(x, tmp)
 }
 line &lt;- cbind(runif(floor(n / 3), min = -.1, max = .1), rep(.8, floor(n / 3)))
 noise &lt;- matrix(runif(8 * n, min = -1, max = 1), nrow = 4 * n, ncol = 2)
 return(rbind(x, line, noise))
}

shape &lt;- makedata(50, 1000)

</pre>


<h3>References</h3>

<p>Guha, S., R. Rastogi, and K. Shim. 2001. Cure: An Efficient Clustering Algorithm for Large Databases. Information Systems 26 (1): 35–38.
</p>

<hr>
<h2 id='supc.random'>Randomized Self-Updating Process Clustering</h2><span id='topic+supc.random'></span>

<h3>Description</h3>

<p>The Randomized Self-Updating Process Clustering (randomized SUP) is a modification of the original SUP algorithm. 
The randomized SUP randomly generates the partition of the instances during each iterations. 
At each iteration, the self updating process is conducted independently in each partition in order to reduce the computation and the memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supc.random(
  x,
  r = NULL,
  rp = NULL,
  t = c("static", "dynamic"),
  k = NULL,
  groups = NULL,
  tolerance = 1e-04,
  cluster.tolerance = 10 * tolerance,
  drop = TRUE,
  implementation = c("cpp", "R"),
  sort = TRUE,
  verbose = (nrow(x) &gt; 10000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supc.random_+3A_x">x</code></td>
<td>
<p>data matrix. Each row is an instance of the data.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_r">r</code></td>
<td>
<p>numeric vector or <code>NULL</code>. The parameter <code class="reqn">r</code> of the self-updating process.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_rp">rp</code></td>
<td>
<p>numeric vector or <code>NULL</code>. If <code>r</code> is <code>NULL</code>, then <code>rp</code> will be used. 
The corresponding <code>r</code> is the <code>rp</code>-percentile of the pairwise distances of the data. 
If both <code>r</code> and <code>rp</code> are <code>NULL</code>, then the default value is <code>rp = c(0.0005, 0.001, 0.01, 0.1, 0.3)</code>.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_t">t</code></td>
<td>
<p>either numeric vector, list of function, or one of <code>"static" or "dynamic"</code>. The parameter <code class="reqn">T(t)</code> of the self-updating process.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_k">k</code></td>
<td>
<p>integer value. The number of the partitions.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_groups">groups</code></td>
<td>
<p>list. The first element is the partition of the first iteration, and the second element is the partition
of the second iteration, etc. If the number of the iteration exceeds <code>length(groups)</code>, then new partition will be 
generated.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric value. The threshold of convergence.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_cluster.tolerance">cluster.tolerance</code></td>
<td>
<p>numeric value. After iterations, if the distance of two points are smaller than <code>cluster.tolerance</code>,
then they are identified as in the same cluster.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_drop">drop</code></td>
<td>
<p>logical value. Whether to delete the list structure if its length is 1.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_implementation">implementation</code></td>
<td>
<p>eithor <code>"R"</code> or <code>"cpp"</code>. Choose the engine to calculate result.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_sort">sort</code></td>
<td>
<p>logical value. Whether to sort the cluster id by size.</p>
</td></tr>
<tr><td><code id="supc.random_+3A_verbose">verbose</code></td>
<td>
<p>logical value. Whether to show the iteration history.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please check the vignettes via <code>vignette("supc", package = "supc")</code> for details.
</p>


<h3>Value</h3>

<p><code>supc1</code> returns a list of objects of <a href="base.html#topic+class">class</a> &quot;supc&quot;.
</p>
<p>Each &quot;supc&quot; object contains the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The input matrix.</p>
</td></tr>
<tr><td><code>d0</code></td>
<td>
<p>The pairwise distance matrix of <code>x</code>.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The value of <code class="reqn">r</code> of the clustering.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The function <code class="reqn">T(t)</code> of the clustering.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>The cluster id of each instance.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>The center of each cluster.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The size of each cluster.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>The number of iterations before convergence.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>The partition of each iteration.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>The position of data after iterations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shiu, Shang-Ying, and Ting-Li Chen. 2016. &quot;On the Strengths of the Self-Updating Process Clustering Algorithm.&quot; Journal of Statistical Computation and Simulation 86 (5): 1010–1031. doi: <a href="https://doi.org/10.1080/00949655.2015.1049605">10.1080/00949655.2015.1049605</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The shape data has a structure of five clusters and a number of noise data points.

makecircle=function(N, seed){
 n=0
 x=matrix(NA, nrow=N, ncol=2)
 while (n&lt;N){
   tmp=runif(2, min=0, max=1)*2-1
   if (sum(tmp^2)&lt;1) {
      n=n+1
      x[n,]=tmp
   }
 }
 return(x)
}

makedata &lt;- function(ns, seed) {
 size=c(10,3,3,1,1)
 mu=rbind(c(-0.3, -0.3), c(-0.55, 0.8), c(0.55, 0.8), c(0.9, 0), c(0.9, -0.6))
 sd=rbind(c(0.7, 0.7), c(0.45, 0.2), c(0.45, 0.2), c(0.1, 0.1), c(0.1, 0.1))
 x=NULL

 for (i in 1:5){
    tmp=makecircle(ns*size[i], seed+i)
    tmp[,1]=tmp[,1]*sd[i,1]+mu[i,1]
    tmp[,2]=tmp[,2]*sd[i,2]+mu[i,2]
    x=rbind(x, tmp)
 }
 
 tmp=runif(floor(ns/3), min=0, max=1)/5-0.1
 tmp=cbind(tmp, 0.8*rep(1, floor(ns/3)))
 x=rbind(x, tmp)
 x=rbind(x, matrix(1, nrow=2*ns, ncol=2)*2-1)
 return(x)
}

shape1 &lt;- makedata(250, 100)
dim(shape1)
plot(shape1)

X.supc=supc.random(shape1, r=0.5, t="dynamic", k = 500, implementation = "R")
plot(shape1, col=X.supc$cluster)


</code></pre>

<hr>
<h2 id='supc1'>Self-Updating Process Clustering</h2><span id='topic+supc1'></span>

<h3>Description</h3>

<p>The SUP is a distance-based method for clustering. 
The idea of this algorithm is similar to gravitational attraction: every sample gravitates towards one another. 
The algorithm mimics the process of gravitational attraction iteratively that eventually merges the samples into clusters on the sample space. 
During the iterations, all samples continue moving until the system becomes stable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supc1(
  x,
  r = NULL,
  rp = NULL,
  t = c("static", "dynamic"),
  tolerance = 1e-04,
  cluster.tolerance = 10 * tolerance,
  drop = TRUE,
  implementation = c("cpp", "R", "cpp2"),
  sort = TRUE,
  verbose = (nrow(x) &gt; 10000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supc1_+3A_x">x</code></td>
<td>
<p>data matrix. Each row is an instance of the data.</p>
</td></tr>
<tr><td><code id="supc1_+3A_r">r</code></td>
<td>
<p>numeric vector or <code>NULL</code>. The parameter <code class="reqn">r</code> of the self-updating process.</p>
</td></tr>
<tr><td><code id="supc1_+3A_rp">rp</code></td>
<td>
<p>numeric vector or <code>NULL</code>. If <code>r</code> is <code>NULL</code>, then <code>rp</code> will be used. 
The corresponding <code>r</code> is the <code>rp</code>-percentile of the pairwise distances of the data. 
If both <code>r</code> and <code>rp</code> are <code>NULL</code>, then the default value is <code>rp = c(0.0005, 0.001, 0.01, 0.1, 0.3)</code>.</p>
</td></tr>
<tr><td><code id="supc1_+3A_t">t</code></td>
<td>
<p>either numeric vector, list of function, or one of <code>"static" or "dynamic"</code>. The parameter <code class="reqn">T(t)</code> of the self-updating process.</p>
</td></tr>
<tr><td><code id="supc1_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric value. The threshold of convergence.</p>
</td></tr>
<tr><td><code id="supc1_+3A_cluster.tolerance">cluster.tolerance</code></td>
<td>
<p>numeric value. After iterations, if the distance of two points are smaller than <code>cluster.tolerance</code>,
then they are identified as in the same cluster.</p>
</td></tr>
<tr><td><code id="supc1_+3A_drop">drop</code></td>
<td>
<p>logical value. Whether to delete the list structure if its length is 1.</p>
</td></tr>
<tr><td><code id="supc1_+3A_implementation">implementation</code></td>
<td>
<p>eithor <code>"R"</code>, <code>"cpp"</code> or <code>"cpp2"</code>. Choose the engine to calculate result.
The <code>"cpp2"</code> parallelly computes the distance in C++ with OpenMP, which is not supported under OS X, and uses the early-stop to speed up calculation.</p>
</td></tr>
<tr><td><code id="supc1_+3A_sort">sort</code></td>
<td>
<p>logical value. Whether to sort the cluster id by size.</p>
</td></tr>
<tr><td><code id="supc1_+3A_verbose">verbose</code></td>
<td>
<p>logical value. Whether to show the iteration history.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please check the vignettes via <code>vignette("supc", package = "supc")</code> for details.
</p>


<h3>Value</h3>

<p><code>supc1</code> returns a list of objects of <a href="base.html#topic+class">class</a> &quot;supc&quot;.
</p>
<p>Each &quot;supc&quot; object contains the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The input matrix.</p>
</td></tr>
<tr><td><code>d0</code></td>
<td>
<p>The pairwise distance matrix of <code>x</code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The value of <code class="reqn">r</code> of the clustering.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The function <code class="reqn">T(t)</code> of the clustering.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>The cluster id of each instance.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>The center of each cluster.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The size of each cluster.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>The number of iterations before convergence.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>The position of data after iterations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shiu, Shang-Ying, and Ting-Li Chen. 2016. &quot;On the Strengths of the Self-Updating Process Clustering Algorithm.&quot; Journal of Statistical Computation and Simulation 86 (5): 1010–1031. doi: <a href="https://doi.org/10.1080/00949655.2015.1049605">10.1080/00949655.2015.1049605</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
X &lt;- local({
 mu &lt;- list(
   x = c(0, 2, 1, 6, 8, 7, 3, 5, 4),
   y = c(0, 0, 1, 0, 0, 1, 3, 3, 4)
 )
 X &lt;- lapply(1:5, function(i) {
   cbind(rnorm(9, mu$x, 1/5), rnorm(9, mu$y, 1/5))
 })
 X &lt;- do.call(rbind, X)
 n &lt;- nrow(X)
 X &lt;- rbind(X, matrix(0, 20, 2))
 k &lt;- 1
 while(k &lt;= 20) {
   tmp &lt;- c(13*runif(1)-2.5, 8*runif(1)-2.5)
   y1 &lt;- mu$x - tmp[1]
   y2 &lt;- mu$y - tmp[2]
   y &lt;- sqrt(y1^2+y2^2)
   if (min(y)&gt; 2){
     X[k+n,] &lt;- tmp
     k &lt;- k+1
   }
 }
 X
})
X.supcs &lt;- supc1(X, r = c(0.9, 1.7, 2.5), t = "dynamic", implementation = "R")
X.supcs$cluster
plot(X.supcs[[1]], type = "heatmap", major.size = 2)
plot(X.supcs[[2]], type = "heatmap", col = cm.colors(24), major.size = 5)

X.supcs &lt;- supc1(X, r = c(1.7, 2.5), t = list(
 function(t) {1.7 / 20 + exp(t) * (1.7 / 50)},
 function(t) {exp(t)}
), implementation = "R")
plot(X.supcs[[1]], type = "heatmap", major.size = 2)
plot(X.supcs[[2]], type = "heatmap", col = cm.colors(24), major.size = 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
