<!DOCTYPE html><html><head><title>Help for package linelistBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {linelistBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backnow_cm'><p>Get Bayesian Back-calculation Estimates and Model Diagnostics</p></a></li>
<li><a href='#convert_to_linelist'><p>Convert Case Counts to a Line List</p></a></li>
<li><a href='#create_caseCounts'><p>Create a Case Counts Data Frame</p></a></li>
<li><a href='#create_linelist'><p>Create a Line List from Report and Onset Dates</p></a></li>
<li><a href='#dnb'><p>Calculate Log-Probability Density for Negative Binomial Distribution</p></a></li>
<li><a href='#dummy'><p>Generate Dummy Variables Matrix for Weeks and Weekends</p></a></li>
<li><a href='#findmiss'><p>Locate Missing Values in a Numeric Vector</p></a></li>
<li><a href='#get_mu_vec'><p>Calculate Exponential of Linear Combinations</p></a></li>
<li><a href='#getr'><p>Calculate Time-Varying Reproduction Number R(t)</p></a></li>
<li><a href='#lambda'><p>Calculate Lambda Values for Poisson Distribution Mean</p></a></li>
<li><a href='#logLikNB'><p>Compute Log-Likelihood for a Right-Truncated Negative Binomial Model</p></a></li>
<li><a href='#plot.backnow'><p>Plot Estimates or Reproduction Numbers</p></a></li>
<li><a href='#plot.caseCounts'><p>Plot Case Counts Over Time</p></a></li>
<li><a href='#pnb'><p>Compute Cumulative Distribution Function for Negative Binomial Distribution</p></a></li>
<li><a href='#prop'><p>Calculate Proportions of Event Counts Within a Specified Time Range</p></a></li>
<li><a href='#rnb'><p>Generate Random Samples from a Negative Binomial Distribution</p></a></li>
<li><a href='#run_backnow'><p>Run Back Calculation and Estimate Reproduction Numbers</p></a></li>
<li><a href='#sample_cases'><p>Sample datasets</p></a></li>
<li><a href='#si'><p>Calculate Serial Interval Distribution for COVID-19</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of Epidemic Data Using Line List and Case
Count Approaches</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-30</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chad Milando &lt;cmilando@bu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for performing Bayesian inference on epidemiological 
  data to estimate the time-varying reproductive number and other related metrics.
  These methods were published in Li and White (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1009210">doi:10.1371/journal.pcbi.1009210</a>&gt;.
  This package supports analyses based on aggregated case count data and individual line list 
  data, facilitating enhanced surveillance and intervention planning for infectious 
  diseases like COVID-19. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.11), magrittr, lubridate, coda, dplyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-02 20:34:54 UTC; cwm</td>
</tr>
<tr>
<td>Author:</td>
<td>Chad Milando [aut, cre],
  Tenglong Li [ctb],
  Laura White [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-03 13:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='backnow_cm'>Get Bayesian Back-calculation Estimates and Model Diagnostics</h2><span id='topic+backnow_cm'></span>

<h3>Description</h3>

<p>This function performs Bayesian back-calculation, imputation of missing delays, and nowcasting based on the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backnow_cm(
  outcome,
  days,
  week,
  weekend,
  iter,
  sigma,
  maxdelay,
  si,
  size,
  workerID,
  printProgress,
  cd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backnow_cm_+3A_outcome">outcome</code></td>
<td>
<p>Vector of outcomes; difference between report and onset times</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_days">days</code></td>
<td>
<p>Vector of days when the report is given, aligned from the minimum report day</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_week">week</code></td>
<td>
<p>Vector indicating the week of the report, assumes no change within the week</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_weekend">weekend</code></td>
<td>
<p>Binary vector indicating if the outcome was reported during a weekend</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for the Bayesian back-calculation algorithm</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation for the normal distribution</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_maxdelay">maxdelay</code></td>
<td>
<p>The maximum delay parameter for the negative binomial distribution</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_si">si</code></td>
<td>
<p>Serial interval vector</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_size">size</code></td>
<td>
<p>The size parameter for the negative binomial distribution</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_workerid">workerID</code></td>
<td>
<p>Identifier for the parallel worker</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_printprogress">printProgress</code></td>
<td>
<p>Flag to print the progress information</p>
</td></tr>
<tr><td><code id="backnow_cm_+3A_cd">cd</code></td>
<td>
<p>second size parameter, unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output A list object that contains the back-calculated estimates and model diagnostics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
sip &lt;- si(14, 4.29, 1.18)
results &lt;- run_backnow(
 line_list, 
  MAX_ITER = as.integer(2000), 
  norm_sigma = 0.5, 
  sip = sip,
  NB_maxdelay = as.integer(20), 
  NB_size = as.integer(6), 
  workerID = 1, 
  printProgress = 1, 
 preCalcTime = TRUE)

</code></pre>

<hr>
<h2 id='convert_to_linelist'>Convert Case Counts to a Line List</h2><span id='topic+convert_to_linelist'></span>

<h3>Description</h3>

<p>This function takes a data frame of case counts and expands it into a line list format,
which is often used for epidemiological analysis. The function validates input data,
manages missingness, and assumes additional generation times based on the specified
reporting function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_linelist(
  caseCounts,
  reportF = NULL,
  reportF_args = NULL,
  reportF_missP = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_linelist_+3A_casecounts">caseCounts</code></td>
<td>
<p>A data frame with columns 'date', 'cases', and 'location'.
The data frame must meet several criteria:
- It should only contain data for one location.
- Dates must be in Date format.
- Case numbers must be non-negative integers.
- No missing values are allowed in the necessary columns.</p>
</td></tr>
<tr><td><code id="convert_to_linelist_+3A_reportf">reportF</code></td>
<td>
<p>A function used to simulate the delay from case reporting to case onset.
Defaults to a negative binomial distribution function ('rnbinom') if NULL.</p>
</td></tr>
<tr><td><code id="convert_to_linelist_+3A_reportf_args">reportF_args</code></td>
<td>
<p>A list of additional arguments to pass to 'reportF'.
Defaults to 'list(size = 3, mu = 9)' when 'reportF' is NULL.</p>
</td></tr>
<tr><td><code id="convert_to_linelist_+3A_reportf_missp">reportF_missP</code></td>
<td>
<p>A numeric probability between 0 and 1 (exclusive) indicating the
proportion of missing onset dates. It throws an error if it is out
of bounds or not numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function stops and sends error messages for various data integrity issues,
such as incorrect data types, negative cases, or missing required columns.
It also assumes that the input data is for only one location and handles
NA generation according to 'reportF_missP'.
</p>


<h3>Value</h3>

<p>A data frame in line list format, where each row corresponds to a case report.
The data frame includes columns for the report date, the delay from report to onset,
the onset date, weekend indicator, report interval in days from the first report,
and week interval.
The returned data frame has additional attributes set, including 'min_day' and the
class 'lineList'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_dates")
data("sample_location")
data("sample_cases")
case_Counts &lt;- create_caseCounts(sample_dates, sample_location, sample_cases)
line_list &lt;- convert_to_linelist(case_Counts)
</code></pre>

<hr>
<h2 id='create_caseCounts'>Create a Case Counts Data Frame</h2><span id='topic+create_caseCounts'></span>

<h3>Description</h3>

<p>This function constructs a data frame from vectors representing dates, locations,
and case numbers, ensuring that all input vectors meet specific data integrity
requirements. It checks for the correct data types, non-negative case numbers,
and uniformity in vector lengths. The function also ensures no missing values are
present and that all data pertain to a single location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_caseCounts(date_vec, location_vec, cases_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_caseCounts_+3A_date_vec">date_vec</code></td>
<td>
<p>A vector of dates corresponding to case reports; must be of type Date.</p>
</td></tr>
<tr><td><code id="create_caseCounts_+3A_location_vec">location_vec</code></td>
<td>
<p>A character vector representing the location of the case reports;
all entries must refer to the same location.</p>
</td></tr>
<tr><td><code id="create_caseCounts_+3A_cases_vec">cases_vec</code></td>
<td>
<p>A numeric vector representing the number of cases reported on each date;
values must be non-negative integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs several checks to ensure the integrity of the input:
- It verifies that all vectors have the same length.
- It confirms that there are no negative numbers in 'cases_vec'.
- It checks for and disallows any missing values in the data frame.
It throws errors if any of these conditions are not met, indicating that
the input vectors are not appropriately formatted or contain invalid data.
</p>


<h3>Value</h3>

<p>A data frame named 'caseCounts' with columns 'date', 'cases', and 'location'.
Each row corresponds to a unique report of cases on a given date at a specified location.
The data frame is assigned a class attribute of 'caseCounts'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_dates")
data("sample_location")
data("sample_cases")
case_Counts = create_caseCounts(sample_dates, sample_location, sample_cases)
</code></pre>

<hr>
<h2 id='create_linelist'>Create a Line List from Report and Onset Dates</h2><span id='topic+create_linelist'></span>

<h3>Description</h3>

<p>This function constructs a line list data frame using vectors of report and onset dates.
It performs several checks and transformations to ensure the data is consistent and
appropriate for epidemiological analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_linelist(report_dates, onset_dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_linelist_+3A_report_dates">report_dates</code></td>
<td>
<p>A vector of dates representing when cases were reported; must be of type Date.</p>
</td></tr>
<tr><td><code id="create_linelist_+3A_onset_dates">onset_dates</code></td>
<td>
<p>A vector of dates representing when symptoms onset occurred; must be of type Date.
This vector can contain NA values, but not exclusively or none at all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ensures the following:
- The length of 'report_dates' and 'onset_dates' must be equal.
- There should be no NA values in 'report_dates'.
- 'onset_dates' must contain some but not all NA values.
- Each non-NA onset date must be earlier than or equal to its corresponding report date.
If any of these conditions are violated, the function will stop with an error message.
Additionally, the function calculates the delay in days between onset and report dates,
identifies weekends, and calculates reporting and week intervals based on the earliest date.
</p>


<h3>Value</h3>

<p>A data frame with the following columns: report_dates, delay_int, onset_dates,
is_weekend, report_int, and week_int. This data frame is ordered by report_dates and
assigned a class attribute of 'lineList'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
</code></pre>

<hr>
<h2 id='dnb'>Calculate Log-Probability Density for Negative Binomial Distribution</h2><span id='topic+dnb'></span>

<h3>Description</h3>

<p>This function computes the log-probability density function of the negative
binomial distribution, given the number of successes, the dispersion parameter,
and the mean of the distribution. This is useful for probabilistic models
where negative binomial assumptions are applicable, such as certain types of
count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnb(x, r, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnb_+3A_x">x</code></td>
<td>
<p>A numeric value representing the number of successes, which should be
a non-negative integer.</p>
</td></tr>
<tr><td><code id="dnb_+3A_r">r</code></td>
<td>
<p>A numeric value representing the dispersion parameter of the negative
binomial distribution. A higher value indicates a distribution more tightly
concentrated around the mean.</p>
</td></tr>
<tr><td><code id="dnb_+3A_m">m</code></td>
<td>
<p>A numeric value representing the mean of the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the log-probability density function value
of observing 'x' successes given the mean 'm' and dispersion 'r'.
This return value is given on the log scale to facilitate calculations
that involve very small probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dnb(5, 2, 10);
</code></pre>

<hr>
<h2 id='dummy'>Generate Dummy Variables Matrix for Weeks and Weekends</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>This function creates a matrix of dummy variables based on reported weeks and weekend indicators.
Each column in the resulting matrix corresponds to a specific week, except for the last column,
which indicates whether the date falls on a weekend. This matrix is typically used in regression
models where week-specific effects are to be adjusted along with the effect of weekends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy(week, weekend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_+3A_week">week</code></td>
<td>
<p>An integer vector representing the week number of each observation.
Each element denotes the week during which a specific event occurred.</p>
</td></tr>
<tr><td><code id="dummy_+3A_weekend">weekend</code></td>
<td>
<p>A binary integer vector (elements being 0 or 1) indicating whether
each observation corresponds to a weekend. Here, '1' indicates a weekend and '0' a weekday.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix where each row corresponds to an observation and each column
to a week, with an additional final column for weekend indicators. The elements
of the matrix are dummy variables (0 or 1); each row contains exactly one '1' in
one of the first several columns corresponding to the week of the observation,
and a '1' or '0' in the last column indicating weekend status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>week &lt;- c(1, 1, 1, 2, 2, 3, 3, 3, 3, 3)
weekend &lt;- c(0, 1, 0, 0, 1, 0, 0, 1, 1, 0)
dummy_vars &lt;- dummy(week, weekend)
</code></pre>

<hr>
<h2 id='findmiss'>Locate Missing Values in a Numeric Vector</h2><span id='topic+findmiss'></span>

<h3>Description</h3>

<p>This function identifies the indices of missing values (NA) in a given numeric vector.
It is useful for data cleaning and preprocessing steps where identification of missing
data points is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findmiss(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findmiss_+3A_x">x</code></td>
<td>
<p>A numeric vector potentially containing NA values.
The values can range from -infinity to infinity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector containing the indices where NA values are found in 'x'.
These indices can be used directly to reference or manipulate elements in other vectors
of the same length or for subsetting the original vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- c(1, 2, NA, 4, NA, 6)
findmiss(vec)
</code></pre>

<hr>
<h2 id='get_mu_vec'>Calculate Exponential of Linear Combinations</h2><span id='topic+get_mu_vec'></span>

<h3>Description</h3>

<p>Computes the exponential of linear combinations of beta coefficients and a matrix
of predictors, typically used in Poisson or logistic regression models for estimating
rates or probabilities. This function specifically handles the exponential transformation,
which is commonly used to ensure that rates or probabilities are non-negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mu_vec(x12, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mu_vec_+3A_x12">x12</code></td>
<td>
<p>NumericMatrix representing a matrix of predictors, where each row corresponds
to an observation and columns correspond to different predictor variables (e.g., weeks and weekends).</p>
</td></tr>
<tr><td><code id="get_mu_vec_+3A_beta">beta</code></td>
<td>
<p>NumericVector of coefficients corresponding to the predictors in 'x12'.
This should include coefficients for both weekly effects and potentially an additional
coefficient for weekends.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function multiplies the matrix 'x12' by the vector 'beta' to get the linear predictors,
then applies the exponential function to convert these linear predictors to a scale
suitable for models where the response variable is a count or probability.
This is a critical step in generalized linear models where the link function is
the natural logarithm.
</p>


<h3>Value</h3>

<p>NumericVector where each element is the exponential of the linear combination
of the predictors and coefficients for a given observation. This vector represents
the model-estimated mean values for each observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assuming x12 is a matrix with 10 observations and 3 predictors
# and beta is a vector of 3 coefficients
x12 &lt;- matrix(rnorm(30), ncol=3)
beta &lt;- c(0.1, -0.2, 0.05)
get_mu_vec(x12, beta)
</code></pre>

<hr>
<h2 id='getr'>Calculate Time-Varying Reproduction Number R(t)</h2><span id='topic+getr'></span>

<h3>Description</h3>

<p>This function estimates the time-varying reproduction number, R(t), based on the epidemic curve and
serial interval distribution. R(t) is calculated for each day using a moving window approach,
which involves taking a segment of the epidemic curve and applying a transformation based on the
serial interval to estimate how many subsequent cases are generated by cases within the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getr(curve, si, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getr_+3A_curve">curve</code></td>
<td>
<p>NumericVector representing the estimated epidemic curve with daily counts.
This curve can include both back-calculated and nowcasted counts of infections.</p>
</td></tr>
<tr><td><code id="getr_+3A_si">si</code></td>
<td>
<p>NumericVector representing the serial interval distribution, expressed as a vector
where each element corresponds to the probability of a delay of that many days between
successive cases.</p>
</td></tr>
<tr><td><code id="getr_+3A_size">size</code></td>
<td>
<p>Integer specifying the size of the moving window used to calculate the mean reproduction number.
This window size determines how many days are included in the calculation of R(t) at each step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NumericVector containing the estimated mean reproduction numbers (R(t)) for each day.
The length of this vector will be the length of 'curve' minus 'size' minus one,
reflecting the fact that the last few days do not have enough data to fill the window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assume curve is a numeric vector of daily case counts and si is the serial interval distribution
curve &lt;- rnorm(100, mean=10, sd=3)  # example epidemic curve
si &lt;- rep(0.1, 10)  # example serial interval distribution
size &lt;- 6  # example size of the moving window
getr(curve, si, size)
</code></pre>

<hr>
<h2 id='lambda'>Calculate Lambda Values for Poisson Distribution Mean</h2><span id='topic+lambda'></span>

<h3>Description</h3>

<p>This function computes the convolution of the epidemic curve with the serial interval distribution
to estimate the mean of the Poisson distribution for each day. This mean is crucial
in models where the number of new cases follows a Poisson process. The calculation is effectively
a weighted sum of past case counts, where weights are given by the serial interval distribution,
representing the expected number of new cases caused by an individual case on each subsequent day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(curve, si)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_curve">curve</code></td>
<td>
<p>NumericVector representing the daily counts of new cases, estimated from the epidemic data.
This vector should include both historically observed data and nowcasted estimates.</p>
</td></tr>
<tr><td><code id="lambda_+3A_si">si</code></td>
<td>
<p>NumericVector representing the serial interval distribution, a probability distribution
describing the time delay between successive cases in an infectious disease transmission chain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function applies the serial interval to the epidemic curve via convolution, 
essentially calculating the expected number of secondary cases generated by each primary case
over the serial interval. The length of the resulting vector is one less than that of 'curve'
because the last day's value cannot be calculated without full serial interval data.
</p>


<h3>Value</h3>

<p>NumericVector containing the estimated mean values for the Poisson distribution
at each day, excluding the last day as the serial interval cannot be fully applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
si &lt;- c(0.5, 0.3, 0.2)  # Declining probability over three days
lambda_values &lt;- lambda(curve, si)
</code></pre>

<hr>
<h2 id='logLikNB'>Compute Log-Likelihood for a Right-Truncated Negative Binomial Model</h2><span id='topic+logLikNB'></span>

<h3>Description</h3>

<p>This function calculates the log-likelihood of observing the given data under a 
right-truncated negative binomial distribution. It is used to assess the fit of 
a model involving delay times in reporting cases, where each case has a 
delay modeled by a negative binomial distribution that is truncated at a specified maximum delay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikNB(delay_vec, x12, disp, betaplus, maxdelay)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikNB_+3A_delay_vec">delay_vec</code></td>
<td>
<p>NumericVector representing the observed delay times for each case.</p>
</td></tr>
<tr><td><code id="logLikNB_+3A_x12">x12</code></td>
<td>
<p>NumericMatrix of covariates used to model the mean of the negative binomial distribution.
Each row corresponds to a case and columns correspond to covariates including time since onset and others.</p>
</td></tr>
<tr><td><code id="logLikNB_+3A_disp">disp</code></td>
<td>
<p>NumericVector indicating the dispersion parameter for each case. This can affect the distribution 
of counts and is used to model heterogeneity in reporting delays.</p>
</td></tr>
<tr><td><code id="logLikNB_+3A_betaplus">betaplus</code></td>
<td>
<p>NumericVector containing current estimates of the model parameters, which may include 
coefficients for covariates and additional parameters.</p>
</td></tr>
<tr><td><code id="logLikNB_+3A_maxdelay">maxdelay</code></td>
<td>
<p>Integer specifying the maximum reporting delay, truncating the distribution at this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the log-likelihood by calculating the likelihood of each observed 
delay under the specified model parameters, considering the truncation at 'maxdelay'. 
The parameters 'disp' and 'betaplus' allow for flexibility in modeling different types of 
heterogeneity and covariate effects.
</p>


<h3>Value</h3>

<p>Double representing the log-likelihood of the data given the model parameters. This value 
measures how well the model with the current parameter estimates fits the observed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage with arbitrary data:
delay_vec &lt;- rnorm(100, mean=10, sd=3)  # Simulated delay times
x12 &lt;- matrix(rnorm(300), ncol=3)       # Simulated covariates
disp &lt;- rep(1, 100)                     # Dispersion parameter, constant for simplicity
betaplus &lt;- runif(4)                    # Simulated parameter estimates
maxdelay &lt;- 15                          # Maximum delay for truncation
loglik_value &lt;- logLikNB(delay_vec, x12, disp, betaplus, maxdelay)
</code></pre>

<hr>
<h2 id='plot.backnow'>Plot Estimates or Reproduction Numbers</h2><span id='topic+plot.backnow'></span>

<h3>Description</h3>

<p>This function plots estimates of case numbers or reproduction numbers ('r(t)') based on the
provided object. It can handle two types of plots: 'est' for estimated case numbers over time,
and 'rt' for estimated reproduction numbers over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'backnow'
plot(x, plottype, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.backnow_+3A_x">x</code></td>
<td>
<p>An object containing the necessary data for plotting. This object should have
specific structure depending on the 'plottype':
- For &lsquo;plottype = &rsquo;est'', 'x' should contain 'report_date', 'report_cases',
'est_back_date', and 'est_back', where 'est_back' is expected to be a matrix
with three rows representing the lower bound, estimate, and upper bound.
- For &lsquo;plottype = &rsquo;rt'', 'x' should contain 'est_rt_date' and 'est_rt',
with 'est_rt' formatted similarly to 'est_back'.</p>
</td></tr>
<tr><td><code id="plot.backnow_+3A_plottype">plottype</code></td>
<td>
<p>A character string specifying the type of plot to generate. Valid options
are 'est' for case estimates and 'rt' for reproduction numbers.</p>
</td></tr>
<tr><td><code id="plot.backnow_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the 'plottype':
- 'est': Plots the reported cases over time with a polygon representing the
uncertainty interval and a line showing the central estimate.
- 'rt': Plots the reproduction number over time with a similar style.
</p>


<h3>Value</h3>

<p>a plot object for an object of class 'backnow'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
sip &lt;- si(14, 4.29, 1.18)
results &lt;- run_backnow(
  line_list, 
  MAX_ITER = as.integer(2000), 
  norm_sigma = 0.5, 
  sip = sip,
  NB_maxdelay = as.integer(20), 
  NB_size = as.integer(6), 
  workerID = 1, 
  printProgress = 1, 
  preCalcTime = TRUE)
plot(results, 'est')
plot(results, 'rt')

</code></pre>

<hr>
<h2 id='plot.caseCounts'>Plot Case Counts Over Time</h2><span id='topic+plot.caseCounts'></span>

<h3>Description</h3>

<p>This function plots the number of cases over time from a data frame object. If the data frame
contains multiple locations, a specific location must be specified. The plot displays the total
number of cases against dates and annotates one of the earliest points with the location name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caseCounts'
plot(x, loc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.caseCounts_+3A_x">x</code></td>
<td>
<p>A data frame containing the case counts with at least two columns: 'date' and 'cases'.
The data frame may optionally include a 'location' column, which is required if multiple
locations are present.</p>
</td></tr>
<tr><td><code id="plot.caseCounts_+3A_loc">loc</code></td>
<td>
<p>An optional string specifying the location to filter the case counts by. If 'loc' is
provided and 'location' column exists in 'x', the plot will only show data for the
specified location. If multiple locations are present and 'loc' is not specified,
the function will stop with an error.</p>
</td></tr>
<tr><td><code id="plot.caseCounts_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the 'plot' function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the 'location' column is present in 'x' and contains multiple unique values,
the &lsquo;loc' parameter must be specified to indicate which location&rsquo;s data to plot.
The function adds a text annotation to the plot, labeling one of the earliest points
with the specified location's name.
</p>


<h3>Value</h3>

<p>a plot object for an object of class 'caseCounts'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_dates")
data("sample_location")
data("sample_cases")
case_Counts = create_caseCounts(sample_dates, sample_location, sample_cases)
plot(case_Counts)
</code></pre>

<hr>
<h2 id='pnb'>Compute Cumulative Distribution Function for Negative Binomial Distribution</h2><span id='topic+pnb'></span>

<h3>Description</h3>

<p>This function calculates the cumulative distribution function (CDF) of the negative binomial distribution
given a number of successes, a dispersion parameter, and the mean. The negative binomial distribution 
is commonly used to model count data with overdispersion relative to a Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnb(x, r, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnb_+3A_x">x</code></td>
<td>
<p>Non-negative integer specifying the number of successes for which the CDF is computed.
This value must be non-negative as it represents the number of successes in the distribution.</p>
</td></tr>
<tr><td><code id="pnb_+3A_r">r</code></td>
<td>
<p>Dispersion parameter of the distribution, a positive real number.
Higher values of 'r' indicate a higher probability of counts clustering around the mean, reducing overdispersion.</p>
</td></tr>
<tr><td><code id="pnb_+3A_m">m</code></td>
<td>
<p>Mean of the distribution, a positive real number indicating the expected number of successes.
The mean must be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative binomial distribution can be parameterized by a dispersion parameter 'r' and a mean 'm',
which together determine the shape of the distribution. This function is essential for modeling and
probability calculations in various fields such as epidemiology and ecology where the negative binomial
distribution is used to model count data.
</p>


<h3>Value</h3>

<p>y The probability of observing up to 'x' successes in a negative binomial distribution
parameterized by 'r' (dispersion) and 'm' (mean). This function returns the CDF value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pnb(10, 5, 10)
</code></pre>

<hr>
<h2 id='prop'>Calculate Proportions of Event Counts Within a Specified Time Range</h2><span id='topic+prop'></span>

<h3>Description</h3>

<p>This function calculates the proportion of event counts that occur within each
unit of time from a specified starting point (onset time) up to a maximum delay.
The proportions are computed relative to the total number of events occurring within
the specified time range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop(x, onset, maxdelay, cd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_+3A_x">x</code></td>
<td>
<p>NumericVector representing the count of events at each time point.</p>
</td></tr>
<tr><td><code id="prop_+3A_onset">onset</code></td>
<td>
<p>NumericVector representing the onset times for each event count.
Each element in the vector indicates the time at which an event was initiated.</p>
</td></tr>
<tr><td><code id="prop_+3A_maxdelay">maxdelay</code></td>
<td>
<p>The maximum time delay (inclusive) for which the proportions are calculated.
This parameter defines the upper bound of the time interval over which the proportions
of event counts are evaluated.</p>
</td></tr>
<tr><td><code id="prop_+3A_cd">cd</code></td>
<td>
<p>The onset time (exclusive) from which to start calculating proportions.
Events that start at times less than or equal to this value are excluded from the calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NumericVector containing the proportions of the total events falling within each unit
of time from the specified 'cd' up to 'maxdelay'. The proportions are cumulative,
with each element representing the proportion of events that have occurred by that time point,
starting from 'cd'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
onset &lt;- c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
maxdelay &lt;- 5
cd &lt;- 1
prop(x, onset, maxdelay, cd)
</code></pre>

<hr>
<h2 id='rnb'>Generate Random Samples from a Negative Binomial Distribution</h2><span id='topic+rnb'></span>

<h3>Description</h3>

<p>This function generates random samples from a negative binomial distribution with the specified dispersion parameter (<code>r</code>) and success probability (<code>p</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnb(r, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnb_+3A_r">r</code></td>
<td>
<p>The number of failures before achieving a specified number of successes in a negative binomial experiment. It also serves as the dispersion parameter which controls the variance of the distribution.</p>
</td></tr>
<tr><td><code id="rnb_+3A_p">p</code></td>
<td>
<p>The probability of success on each independent Bernoulli trial within the negative binomial experiment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random value sampled from the negative binomial distribution with parameters <code>r</code> and <code>p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- 2
p &lt;- 0.3
rnb(r, p)
</code></pre>

<hr>
<h2 id='run_backnow'>Run Back Calculation and Estimate Reproduction Numbers</h2><span id='topic+run_backnow'></span>

<h3>Description</h3>

<p>This function performs a back-calculation based on provided epidemic case count data,
estimating the time distribution of infections and reproduction numbers (r(t)).
It utilizes extensive input checks and parameter validation to ensure robust model execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_backnow(
  input,
  MAX_ITER,
  norm_sigma,
  sip,
  NB_maxdelay,
  NB_size,
  n_trunc = NB_size,
  workerID = NULL,
  printProgress = 0,
  preCalcTime = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_backnow_+3A_input">input</code></td>
<td>
<p>A data frame or list that includes epidemic data with either class 'caseCounts'
or 'lineList'. The input type determines initial processing steps.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_max_iter">MAX_ITER</code></td>
<td>
<p>Integer, maximum number of iterations for the back-calculation model.
Requires at least 2000 iterations; high numbers can significantly increase runtime.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_norm_sigma">norm_sigma</code></td>
<td>
<p>Numeric, the standard deviation for the normal distribution in the Bayesian framework.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_sip">sip</code></td>
<td>
<p>Vector of numeric values specifying the serial interval probabilities.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_nb_maxdelay">NB_maxdelay</code></td>
<td>
<p>Integer, the maximum delay for the right-truncated negative binomial distribution used in modeling.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_nb_size">NB_size</code></td>
<td>
<p>Integer, the size parameter for the negative binomial distribution.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_n_trunc">n_trunc</code></td>
<td>
<p>Integer, the truncation number for the final result matrices (defaults to 'NB_size').</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_workerid">workerID</code></td>
<td>
<p>Optional integer to specify a worker ID for parallel processing frameworks; defaults to 0.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_printprogress">printProgress</code></td>
<td>
<p>Binary integer (0 or 1), specifying whether to print progress to console; affects performance.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_precalctime">preCalcTime</code></td>
<td>
<p>Boolean, if TRUE, the function calculates a preliminary runtime estimate before full execution.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to underlying functions when converting input to the required format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ensures input data is of the correct class and processes it accordingly.
It handles different input classes by either converting 'caseCounts' to 'lineList' or
directly using &lsquo;lineList'. The function stops with an error if the input doesn&rsquo;t meet expected standards.
It performs simulations to estimate both the back-calculation of initial infections and reproduction numbers
over time, while checking and adjusting for potential NA values and ensuring that all conditions for the
model parameters are met. Output includes estimates of initial infections and reproduction numbers along
with diagnostic statistics.
</p>


<h3>Value</h3>

<p>an object of class 'backnow' with the following structure
</p>
<p>- est_back: back-calculated case counts
</p>
<p>- est_back_date: dates for back-calculated case counts 
</p>
<p>- est_rt: back-calculated R(r)
</p>
<p>- est_rt_date: dates for back-calculated R(t)
</p>
<p>- geweke_back: Geweke diagnostics for the estimated back-calculation of cases
</p>
<p>- geweke_rt; Geweke diagnostics for R(t)
</p>
<p>- report_date: a vector of dates, matches reported_cases
</p>
<p>- report_cases: a vector of reported cases
</p>
<p>- MAX_ITER: the input for 'MAX_ITER'
</p>
<p>- norm_sigma: the input for 'norm_sigma'
</p>
<p>- NB_maxdelay: the input for 'NB_maxdelay'
</p>
<p>- si: the input for serial interval 'si'
</p>
<p>- NB_size: the input for 'NB_size'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
sip &lt;- si(14, 4.29, 1.18)
results &lt;- run_backnow(
  line_list, 
  MAX_ITER = as.integer(2000), 
  norm_sigma = 0.5, 
  sip = sip,
  NB_maxdelay = as.integer(20), 
  NB_size = as.integer(6), 
  workerID = 1, 
  printProgress = 1, 
  preCalcTime = TRUE)

</code></pre>

<hr>
<h2 id='sample_cases'>Sample datasets</h2><span id='topic+sample_cases'></span><span id='topic+sample_dates'></span><span id='topic+sample_location'></span><span id='topic+sample_onset_dates'></span><span id='topic+sample_report_dates'></span><span id='topic+out_list_demo'></span>

<h3>Description</h3>

<p>These data sets provide tests for use in converting between case counts
and line list data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_cases

sample_dates

sample_location

sample_onset_dates

sample_report_dates

out_list_demo
</code></pre>


<h3>Format</h3>

<p>Either vectors or a list object (out_list_demo)
</p>


<h3>Details</h3>

<p>'sample_cases' provides a vector of daily case counts.
'sample_dates' are the dates of the sample case counts.
'sample_location' are the locations of the sample case counts.
'sample_onset_dates' are the same information as in sample_cases, but 
with one entry per case indicating the date of symptom onset.
'sample_report_dates' are the same information as in sample_cases, but 
with one entry per case indicating the date of symptom reporting.
'out_list_demo' is a precomputed output from run_backnow, useful for
plotting in the vignettes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_cases
sample_dates
sample_location
sample_onset_dates
sample_report_dates
</code></pre>

<hr>
<h2 id='si'>Calculate Serial Interval Distribution for COVID-19</h2><span id='topic+si'></span>

<h3>Description</h3>

<p>This function computes the probability distribution function (PDF) of the serial interval for COVID-19
using a gamma distribution with specified shape and rate parameters. The serial interval is defined
as the time between successive cases in a chain of transmission. This implementation generates a discrete
PDF over a given number of days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>si(ndays, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="si_+3A_ndays">ndays</code></td>
<td>
<p>Integer, the number of days over which to calculate the serial interval distribution.</p>
</td></tr>
<tr><td><code id="si_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, the shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="si_+3A_beta">beta</code></td>
<td>
<p>Numeric, the rate parameter of the gamma distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'pgamma' function to calculate cumulative probabilities for each day up to 'ndays'
and then differences these to get daily probabilities. The resulting probabilities are normalized to sum to 1,
ensuring that they represent a valid probability distribution.
</p>


<h3>Value</h3>

<p>Numeric vector representing the serial interval probabilities for each of the first 'ndays' days.
The probabilities are normalized so that their sum is 1.
</p>


<h3>References</h3>

<p>Nishiura, H., Linton, N. M., &amp; Akhmetzhanov, A. R. (2020). Serial interval of novel coronavirus (COVID-19) infections.
International Journal of Infectious Diseases, 93, 284-286.
[Link to the article](https://www.sciencedirect.com/science/article/pii/S1201971220306111)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sip &lt;- si(14, 4.29, 1.18)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
