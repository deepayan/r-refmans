<!DOCTYPE html><html><head><title>Help for package PANPRSnext</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PANPRSnext}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#funcIndex'><p>Inputs for the functional annotations of SNPs.</p></a></li>
<li><a href='#gsfPEN_cpp'><p>Main CPP function</p></a></li>
<li><a href='#gsfPEN_R'><p>Run the gsfPEN algorithm for multiple traits, with functional annotations.</p></a></li>
<li><a href='#gsfPEN_sparse_cpp'><p>Main CPP function</p></a></li>
<li><a href='#gsPEN_cpp'><p>Main CPP function</p></a></li>
<li><a href='#gsPEN_R'><p>Run the gsPEN algorithm for multiple traits, without functional annotations.</p></a></li>
<li><a href='#gsPEN_sparse_cpp'><p>Main CPP function</p></a></li>
<li><a href='#Nvec'><p>A vector of sample sizes for the q traits of the <code>summaryZ</code>.</p></a></li>
<li><a href='#plinkLD'><p>The LD info from output of the software (plink)</p></a></li>
<li><a href='#summaryZ'><p>The Z statistics from the univariate analysis of the association between 3614 SNPs and three traits respectively.</p></a></li>
<li><a href='#test_gsfPEN'><p>Run gsfPEN on a small sample of the provided data set (Only 100 samples)</p></a></li>
<li><a href='#test_gsPEN'><p>Run gsPEN on a small sample of the provided data set (Only 100 samples)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Building PRS Models Based on Summary Statistics of GWAs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Shrinkage estimator for polygenic risk prediction (PRS) models based on summary statistics of genome-wide association (GWA) studies. Based upon the methods and original 'PANPRS' package as found in: Chen, Chatterjee, Landi, and Shi (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2020.1764849">doi:10.1080/01621459.2020.1764849</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), gtools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 21:24:51 UTC; Katherine</td>
</tr>
<tr>
<td>Author:</td>
<td>Katherine Luo [aut, cre],
  Garcia Espin Osvaldo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Katherine Luo &lt;hluo224@uwo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 20:20:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='funcIndex'>Inputs for the functional annotations of SNPs.</h2><span id='topic+funcIndex'></span>

<h3>Description</h3>

<p>A 3614 x 3 matrix with (0,1) entry with 3614 SNPs and 
3 functional annotations. For the element at i-th row, j-th column, the entry 0 means SNP i without j-th functional annotation; entry 1 means otherwise.
follows: 
</p>

<ul>
<li><p> f1: The binary index for functional annotation 1.
</p>
</li>
<li><p> f2: The binary index for functional annotation 2.
</p>
</li>
<li><p> f3: The binary index for functional annotation 3.
</p>
</li></ul>


<h3>Usage</h3>

<pre><code class='language-R'>data(summaryZ)</code></pre>


<h3>Format</h3>

<p>A matrix with 3614 rows for the 3614 SNPs and 3 columns for functional annotations.</p>

<hr>
<h2 id='gsfPEN_cpp'>Main CPP function</h2><span id='topic+gsfPEN_cpp'></span>

<h3>Description</h3>

<p>Main CPP function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsfPEN_cpp(
  summary_betas,
  ld_J,
  index_matrix,
  index_J,
  ld_vec,
  SD_vec,
  tuning_matrix,
  lambda0_vec,
  z_matrix,
  lambda_vec_func,
  func_lambda,
  Ifunc_SNP,
  dims,
  params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsfPEN_cpp_+3A_summary_betas">summary_betas</code></td>
<td>
<p>matrix of summary statistics</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_ld_j">ld_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_index_matrix">index_matrix</code></td>
<td>
<p>matrix of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_index_j">index_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_ld_vec">ld_vec</code></td>
<td>
<p>vector of LD values</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_sd_vec">SD_vec</code></td>
<td>
<p>matrix of SD values</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_tuning_matrix">tuning_matrix</code></td>
<td>
<p>matrix of tuning parameters</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_lambda0_vec">lambda0_vec</code></td>
<td>
<p>vector of lambda0 values</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_z_matrix">z_matrix</code></td>
<td>
<p>matrix of z values</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_lambda_vec_func">lambda_vec_func</code></td>
<td>
<p>vector of lambda values</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_func_lambda">func_lambda</code></td>
<td>
<p>matrix of lambda values</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_ifunc_snp">Ifunc_SNP</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_dims">dims</code></td>
<td>
<p>vector of dimensions</p>
</td></tr>
<tr><td><code id="gsfPEN_cpp_+3A_params">params</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
</table>

<hr>
<h2 id='gsfPEN_R'>Run the gsfPEN algorithm for multiple traits, with functional annotations.</h2><span id='topic+gsfPEN_R'></span>

<h3>Description</h3>

<p>Run the gsfPEN algorithm for multiple traits, with functional annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsfPEN_R(
  summary_z,
  n_vec,
  plinkLD,
  func_index,
  n_iter = 1000,
  upper_val = NULL,
  breaking = 1,
  z_scale = 1,
  tuning_matrix = NULL,
  p_threshold = NULL,
  p_threshold_params = c(0.5, 10^-4, 4),
  tau_factor = c(1/25, 1, 3),
  sub_tuning = 4,
  lim_lambda = c(0.5, 0.9),
  len_lambda = 4,
  lambda_vec = NULL,
  lambda_vec_limit_len = c(1.5, 3),
  df_max = NULL,
  sparse_beta = FALSE,
  debug_output = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsfPEN_R_+3A_summary_z">summary_z</code></td>
<td>
<p>A matrix of summary statistics for each SNP and trait.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_n_vec">n_vec</code></td>
<td>
<p>A vector of sample sizes for each of the Q traits corresponding to the Q columns of summary_z.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_plinkld">plinkLD</code></td>
<td>
<p>A matrix of LD values for each pair of SNPs.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_func_index">func_index</code></td>
<td>
<p>A matrix of functional annotations for each SNP and trait. For the element at i-th row, j-th column, the entry 0 means SNP i without j-th functional annotation; entry 1 means otherwise.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_n_iter">n_iter</code></td>
<td>
<p>The number of iterations to run the algorithm.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_upper_val">upper_val</code></td>
<td>
<p>The upper bound for the tuning parameter.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_breaking">breaking</code></td>
<td>
<p>The number of iterations to run before checking for convergence.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_z_scale">z_scale</code></td>
<td>
<p>The scaling factor for the summary statistics.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_tuning_matrix">tuning_matrix</code></td>
<td>
<p>A matrix of tuning parameters.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_p_threshold">p_threshold</code></td>
<td>
<p>A vector of p-values to use for the tuning parameters.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_p_threshold_params">p_threshold_params</code></td>
<td>
<p>A vector of parameters to use for the p-value tuning parameters.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_tau_factor">tau_factor</code></td>
<td>
<p>A vector of factors to multiply the median value by to get the tuning parameters.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_sub_tuning">sub_tuning</code></td>
<td>
<p>The number of tuning parameters to use for the second iteration.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_lim_lambda">lim_lambda</code></td>
<td>
<p>The range of tuning parameters to use for the first iteration.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_len_lambda">len_lambda</code></td>
<td>
<p>The number of tuning parameters to use for the second iteration.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_lambda_vec">lambda_vec</code></td>
<td>
<p>A vector of tuning parameters to use for the first iteration.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_lambda_vec_limit_len">lambda_vec_limit_len</code></td>
<td>
<p>The number of tuning parameters to use for the first iteration.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_df_max">df_max</code></td>
<td>
<p>The maximum degrees of freedom for the model.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_sparse_beta">sparse_beta</code></td>
<td>
<p>Whether to use the sparse version of the algorithm.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_debug_output">debug_output</code></td>
<td>
<p>Whether to output the tuning combinations that did not converge.</p>
</td></tr>
<tr><td><code id="gsfPEN_R_+3A_verbose">verbose</code></td>
<td>
<p>Whether to output information through the evaluation of the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the following elements:
beta_matrix: A matrix of the estimated coefficients for each SNP and trait.
num_iter_vec: A vector of the number of iterations for each tuning combination.
all_tuning_matrix: A matrix of the tuning parameters used for each tuning combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the library and data
library(PANPRSnext)
data("summaryZ")
data("Nvec")
data("plinkLD")
data("funcIndex")

# Take random subset of the data
subset &lt;- sample(nrow(summaryZ), 100)
subset_summary_z &lt;- summaryZ[subset, ]
subset_func_index &lt;- funcIndex[subset, ]

# Run gsfPEN
output &lt;- gsfPEN_R(
  summary_z = subset_summary_z,
  n_vec = Nvec,
  plinkLD = plinkLD,
  func_index = subset_func_index
)
</code></pre>

<hr>
<h2 id='gsfPEN_sparse_cpp'>Main CPP function</h2><span id='topic+gsfPEN_sparse_cpp'></span>

<h3>Description</h3>

<p>Main CPP function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsfPEN_sparse_cpp(
  summary_betas,
  ld_J,
  index_matrix,
  index_J,
  ld_vec,
  SD_vec,
  tuning_matrix,
  lambda0_vec,
  z_matrix,
  lambda_vec_func,
  func_lambda,
  Ifunc_SNP,
  dims,
  params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_summary_betas">summary_betas</code></td>
<td>
<p>matrix of summary statistics</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_ld_j">ld_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_index_matrix">index_matrix</code></td>
<td>
<p>matrix of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_index_j">index_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_ld_vec">ld_vec</code></td>
<td>
<p>vector of LD values</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_sd_vec">SD_vec</code></td>
<td>
<p>matrix of SD values</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_tuning_matrix">tuning_matrix</code></td>
<td>
<p>matrix of tuning parameters</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_lambda0_vec">lambda0_vec</code></td>
<td>
<p>vector of lambda0 values</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_z_matrix">z_matrix</code></td>
<td>
<p>matrix of z values</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_lambda_vec_func">lambda_vec_func</code></td>
<td>
<p>vector of lambda values</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_func_lambda">func_lambda</code></td>
<td>
<p>matrix of lambda values</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_ifunc_snp">Ifunc_SNP</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_dims">dims</code></td>
<td>
<p>vector of dimensions</p>
</td></tr>
<tr><td><code id="gsfPEN_sparse_cpp_+3A_params">params</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
</table>

<hr>
<h2 id='gsPEN_cpp'>Main CPP function</h2><span id='topic+gsPEN_cpp'></span>

<h3>Description</h3>

<p>Main CPP function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsPEN_cpp(
  summary_betas,
  ld_J,
  index_matrix,
  index_J,
  ld_vec,
  SD_vec,
  tuning_matrix,
  dims,
  params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsPEN_cpp_+3A_summary_betas">summary_betas</code></td>
<td>
<p>matrix of summary statistics</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_ld_j">ld_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_index_matrix">index_matrix</code></td>
<td>
<p>matrix of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_index_j">index_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_ld_vec">ld_vec</code></td>
<td>
<p>vector of LD values</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_sd_vec">SD_vec</code></td>
<td>
<p>matrix of SD values</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_tuning_matrix">tuning_matrix</code></td>
<td>
<p>matrix of tuning parameters</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_dims">dims</code></td>
<td>
<p>vector of dimensions</p>
</td></tr>
<tr><td><code id="gsPEN_cpp_+3A_params">params</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
</table>

<hr>
<h2 id='gsPEN_R'>Run the gsPEN algorithm for multiple traits, without functional annotations.</h2><span id='topic+gsPEN_R'></span>

<h3>Description</h3>

<p>Run the gsPEN algorithm for multiple traits, without functional annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsPEN_R(
  summary_z,
  n_vec,
  plinkLD,
  n_iter = 100,
  upper_val = NULL,
  breaking = 1,
  z_scale = 1,
  tuning_matrix = NULL,
  tau_factor = c(1/25, 1, 10),
  len_lim_lambda = 10,
  sub_tuning = 50,
  lim_lambda = c(0.5, 0.9),
  len_lambda = 200,
  df_max = NULL,
  sparse_beta = FALSE,
  debug_output = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsPEN_R_+3A_summary_z">summary_z</code></td>
<td>
<p>A matrix of summary statistics for each SNP and trait.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_n_vec">n_vec</code></td>
<td>
<p>A vector of sample sizes for each of the Q traits corresponding to the Q columns of summary_z.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_plinkld">plinkLD</code></td>
<td>
<p>A matrix of LD values for each pair of SNPs.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_n_iter">n_iter</code></td>
<td>
<p>The number of iterations to run the algorithm.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_upper_val">upper_val</code></td>
<td>
<p>The upper bound for the tuning parameter.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_breaking">breaking</code></td>
<td>
<p>The number of iterations to run before checking for convergence.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_z_scale">z_scale</code></td>
<td>
<p>The scaling factor for the summary statistics.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_tuning_matrix">tuning_matrix</code></td>
<td>
<p>A matrix of tuning parameters.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_tau_factor">tau_factor</code></td>
<td>
<p>A vector of factors to multiply the median value by to get the tuning parameters.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_len_lim_lambda">len_lim_lambda</code></td>
<td>
<p>The number of tuning parameters to use for the first iteration.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_sub_tuning">sub_tuning</code></td>
<td>
<p>The number of tuning parameters to use for the second iteration.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_lim_lambda">lim_lambda</code></td>
<td>
<p>The range of tuning parameters to use for the first iteration.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_len_lambda">len_lambda</code></td>
<td>
<p>The number of tuning parameters to use for the second iteration.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_df_max">df_max</code></td>
<td>
<p>The maximum degrees of freedom for the model.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_sparse_beta">sparse_beta</code></td>
<td>
<p>Whether to use the sparse version of the algorithm.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_debug_output">debug_output</code></td>
<td>
<p>Whether to output the tuning combinations that did not converge.</p>
</td></tr>
<tr><td><code id="gsPEN_R_+3A_verbose">verbose</code></td>
<td>
<p>Whether to output information through the evaluation of the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the following elements:
beta_matrix: A matrix of the estimated coefficients for each SNP and trait.
num_iter_vec: A vector of the number of iterations for each tuning combination.
all_tuning_matrix: A matrix of the tuning parameters used for each tuning combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the library and data
library(PANPRSnext)
data("summaryZ")
data("Nvec")
data("plinkLD")

# Take random subset of the data
subset &lt;- sample(nrow(summaryZ), 100)
subset_summary_z &lt;- summaryZ[subset, ]

# Run gsPEN
output &lt;- gsPEN_R(
  summary_z = subset_summary_z,
  n_vec = Nvec,
  plinkLD = plinkLD
)
</code></pre>

<hr>
<h2 id='gsPEN_sparse_cpp'>Main CPP function</h2><span id='topic+gsPEN_sparse_cpp'></span>

<h3>Description</h3>

<p>Main CPP function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsPEN_sparse_cpp(
  summary_betas,
  ld_J,
  index_matrix,
  index_J,
  ld_vec,
  SD_vec,
  tuning_matrix,
  dims,
  params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsPEN_sparse_cpp_+3A_summary_betas">summary_betas</code></td>
<td>
<p>matrix of summary statistics</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_ld_j">ld_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_index_matrix">index_matrix</code></td>
<td>
<p>matrix of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_index_j">index_J</code></td>
<td>
<p>vector of indices of SNPs in LD with the current SNP</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_ld_vec">ld_vec</code></td>
<td>
<p>vector of LD values</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_sd_vec">SD_vec</code></td>
<td>
<p>matrix of SD values</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_tuning_matrix">tuning_matrix</code></td>
<td>
<p>matrix of tuning parameters</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_dims">dims</code></td>
<td>
<p>vector of dimensions</p>
</td></tr>
<tr><td><code id="gsPEN_sparse_cpp_+3A_params">params</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
</table>

<hr>
<h2 id='Nvec'>A vector of sample sizes for the q traits of the <code>summaryZ</code>.</h2><span id='topic+Nvec'></span>

<h3>Description</h3>

<p>A vector of q sample sizes for the q set of Z statistics corresponding to the q columns of <code>summaryZ</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Nvec)</code></pre>


<h3>Format</h3>

<p>A vector with q elements, where q is the number of columns of <code>summaryZ</code>.</p>

<hr>
<h2 id='plinkLD'>The LD info from output of the software (plink)</h2><span id='topic+plinkLD'></span>

<h3>Description</h3>

<p> The LD information is crucial for the analysis by SummaryLasso. 
The reference alleles used to obtained for the Z statsitics or the 
regression coefficients have to be the sames as those used for the LD calculation. 
This file can be obtained directly from the output of the LD calculation by the 
software (plink); for example the output can be like plink.ld.
On the other hand, the user can calcuate the LD based on their prefered tools.
The variables are as
follows: 
</p>

<ul>
<li><p> CHR_A: The chromosome of SNP_A 
</p>
</li>
<li><p> BP_A: The positions of SNP_A  
</p>
</li>
<li><p> SNP_A: The names of SNP_A 
</p>
</li>
<li><p> CHR_B: The chromosome of SNP_B 
</p>
</li>
<li><p> BP_B: The positions of SNP_B 
</p>
</li>
<li><p> SNP_B: The names of SNP_B    
</p>
</li>
<li><p> R: The correlation between SNP_A and SNP_B
</p>
</li></ul>


<h3>Usage</h3>

<pre><code class='language-R'>data(plinkLD)</code></pre>


<h3>Format</h3>

<p>A data frame with 205959 rows and 7 columns</p>


<h3>References</h3>


<ul>
<li><p> Purcell S, et al. (2007) 
PLINK: a toolset for whole-genome association and population-based 
linkage analysis. <em>American Journal of Human Genetics</em>, <strong>81</strong>.
</p>
</li></ul>


<hr>
<h2 id='summaryZ'>The Z statistics from the univariate analysis of the association between 3614 SNPs and three traits respectively.</h2><span id='topic+summaryZ'></span>

<h3>Description</h3>

<p>These Z statsitics are obtained from simulated datasets.  The variables are as
follows: 
</p>

<ul>
<li><p> Z1: The Z statistics from trait 1; the primary trait.
</p>
</li>
<li><p> Z2: The Z statistics from trait 2; the secondary trait.
</p>
</li>
<li><p> Z2: The Z statistics from trait 3; the secondary trait.
</p>
</li></ul>


<h3>Usage</h3>

<pre><code class='language-R'>data(summaryZ)</code></pre>


<h3>Format</h3>

<p>A matrix with 3614 rows for the 3614 SNPs and 3 columns for 3 traits.</p>

<hr>
<h2 id='test_gsfPEN'>Run gsfPEN on a small sample of the provided data set (Only 100 samples)</h2><span id='topic+test_gsfPEN'></span>

<h3>Description</h3>

<p>Run gsfPEN on a small sample of the provided data set (Only 100 samples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_gsfPEN(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_gsfPEN_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to gsfPEN_R</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of gsfPEN_R
</p>

<hr>
<h2 id='test_gsPEN'>Run gsPEN on a small sample of the provided data set (Only 100 samples)</h2><span id='topic+test_gsPEN'></span>

<h3>Description</h3>

<p>Run gsPEN on a small sample of the provided data set (Only 100 samples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_gsPEN(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_gsPEN_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to gsPEN_R</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of gsPEN_R
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
