<!DOCTYPE html><html><head><title>Help for package eivtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eivtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#deconv_npmle'><p>Nonparametric MLE deconvolution under heteroskedastic normal error</p></a></li>
<li><a href='#eivreg'><p>Errors-in-variables (EIV) linear regression</p></a></li>
<li><a href='#get_bugs_wishart_scalemat'><p>Compute a BUGS-compliant scale matrix for a Wishart prior</p>
distribution for precision matrix that is consistent with target
variances.</a></li>
<li><a href='#lr_ancova'><p>Latent Regression for Group Effects with Latent Heteroskedastic</p>
Error Variance</a></li>
<li><a href='#model.matrix.eivlm'><p><code>model.matrix</code> method for objects of class <code>eivlm</code>.</p></a></li>
<li><a href='#print.eivlm'><p><code>print</code> method for objects of class <code>eivlm</code>.</p></a></li>
<li><a href='#print.summary.eivlm'><p><code>print</code> method for objects of class <code>summary.eivlm</code>.</p></a></li>
<li><a href='#summary.eivlm'><p><code>summary</code> method for objects of class <code>eivlm</code>.</p></a></li>
<li><a href='#testscores'><p>Example longitudinal test score data</p></a></li>
<li><a href='#vcov.eivlm'><p><code>vcov</code> method for objects of class <code>eivlm</code>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Measurement Error Modeling Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-09-16</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), stats, grDevices, graphics, utils, R2jags</td>
</tr>
<tr>
<td>Author:</td>
<td>J.R. Lockwood</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>J.R. Lockwood &lt;jrlockwood@ets.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This includes functions for analysis with error-prone covariates, including deconvolution, latent regression and errors-in-variables regression.  It implements methods by Rabe-Hesketh et al. (2003) &lt;<a href="https://doi.org/10.1191%2F1471082x03st056oa">doi:10.1191/1471082x03st056oa</a>&gt;, Lockwood and McCaffrey (2014) &lt;<a href="https://doi.org/10.3102%2F1076998613509405">doi:10.3102/1076998613509405</a>&gt;, and Lockwood and McCaffrey (2017) &lt;<a href="https://doi.org/10.1007%2Fs11336-017-9556-y">doi:10.1007/s11336-017-9556-y</a>&gt;, among others.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-17 14:52:19 UTC; jlock</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-18 22:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='deconv_npmle'>Nonparametric MLE deconvolution under heteroskedastic normal error</h2><span id='topic+deconv_npmle'></span>

<h3>Description</h3>

<p>Implements a version of the Rabe-Hesketh et al. (2003)
algorithm for computing the nonparametric MLE of a univariate latent
variable distribution from observed error-prone measures.  Allows for
normal heteroskedastic measurement error with variance that depends on
the latent variable, such as with estimates of latent ability from
item response theory models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv_npmle(W, csem,
gridspec = list(fixed=FALSE, xmin=-5, xmax=5, numpoints=2000),
lambda = 0.0005, lltol = 1e-7, psmall = 0.00005,
discrete = FALSE, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconv_npmle_+3A_w">W</code></td>
<td>

<p>Vector of observed measures, where <code>W[i]</code> is assumed to
be an error-prone measure of a latent variable <code>X[i]</code>
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_csem">csem</code></td>
<td>

<p>A function of a single variable <code>x</code> that returns the
conditional standard deviation of <code>W</code> given <code>X=x</code>.
It needs to be able to accept a vector input and return a
vector of the same length as the input.
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_gridspec">gridspec</code></td>
<td>

<p>A named list specifying the grid over which the NPMLE will be
computed.  It must have a logical component <code>fixed</code> indicating
if the NPMLE grid is fixed (TRUE), or if the final grid is chosen by
optimization over a candidate grid (FALSE).  The default is
FALSE. The remaining components of <code>gridspec</code> specify the grid
in one of two mutually exclusive ways.  In the first way,
<code>gridspec</code> must contain elements <code>xmin</code> providing the
minimum grid value, <code>xmax</code> providing the maximum grid value,
and <code>numpoints</code> providing the desired number of points.  In
this case, the grid will be <code>numpoints</code> equally-spaced values
ranging from <code>xmin</code> to <code>xmax</code>.  In the second way,
<code>gridspec</code> must contain an element <code>grid</code>, a numeric
vector providing the actual desired grid.  It must be an arbitrary
sequence of increasing numeric values with no missing values.
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_lambda">lambda</code></td>
<td>

<p>Step size, on probability scale, in Rabe-Hesketh et al. (2003)
algorithm.  See reference for details.
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_lltol">lltol</code></td>
<td>

<p>Algorithm stops when the improvement to the log likelihood does not
exceed <code>lltol.</code>
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_psmall">psmall</code></td>
<td>

<p>If a mass point in the estimated latent distribution evolves to have
probability less than <code>psmall,</code> it gets dropped.
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_discrete">discrete</code></td>
<td>

<p>Not currently implemented.
</p>
</td></tr>
<tr><td><code id="deconv_npmle_+3A_quietly">quietly</code></td>
<td>

<p>If <code>FALSE</code> (the default), prints iteration-by-iteration
progress.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumed model is <code>W = X + U</code> where the conditional
distribution of <code>U</code> given <code>X = x</code> is assumed to be normal
with mean zero and standard deviation <code>csem(x)</code>.  The function
uses <code>W</code> to estimate a discrete latent distribution for <code>X</code>
that maximizes the likelihood of the observed data.  The function
optimizes the mass points (among a grid of candidate values) and the
associated probabilities.
</p>
<p>In the special case of homoskedastic error, the function <code>csem</code>
must be defined such that when passed a vector of length <code>n</code>, it
returns a vector of length <code>n</code> where each element is a common
constant.
</p>
<p>The default values of <code>xmin</code> and <code>xmin</code> in <code>gridspec</code>
are generally appropriate only for a latent variable on a standardized
scale with mean zero and variance one, and should be set to
appropriate values given the scale of <code>W</code>.
</p>


<h3>Value</h3>

<p>A list with elements
</p>

<ul>
<li><p>gridspec: Information about the initial grid
</p>
</li>
<li><p>.history: Iteration-by-iteration evolution of the estimated
distribution, if <code>gridspec$fixed</code> is FALSE.  Otherwise it is
an empty list
</p>
</li>
<li><p>px: A dataframe providing the final NPMLE distribution.  There
are as many rows as there are mass points in the estimated
distribution; fields described below
</p>
</li>
<li><p>reliability: An estimate of the reliability of <code>W</code>, equal
to the estimated variance of <code>X</code> divided by the sample variance
of <code>W</code>
</p>
</li>
<li><p>simex_varfuncs: A dataframe with as many rows as there are
unique values of <code>W</code>, providing estimated plug-in variance
functions to use for SIMEX data generation with latent
heteroskedastic error as described in Lockwood and McCaffrey
(forthcoming); see references.  Fields described below </p>
</li></ul>

<p>The fields of <code>px</code> are:
</p>

<ul>
<li><p>x: Location of mass point
</p>
</li>
<li><p>csem: Value of function <code>csem</code> at mass point
</p>
</li>
<li><p>p: probability at mass point
</p>
</li>
<li><p>ll: log likelihood at solution
</p>
</li>
<li><p>ex: Estimate of mean of latent distribution
</p>
</li>
<li><p>varx: Estimate of variance of latent distribution
</p>
</li></ul>

<p>The fields of <code>simex_varfuncs</code> are:
</p>

<ul>
<li><p>W: Unique observed values <code>w</code> of <code>W</code>
</p>
</li>
<li><p>gW: The square of <code>csem</code> evaluated at <code>W = w</code>
</p>
</li>
<li><p>gEXW: The square of <code>csem</code> evaluated at <code>E[X | W=w]</code>, the
conditional mean of <code>X</code> given <code>W=w</code>
</p>
</li>
<li><p>EgXW: The conditional mean of the square of <code>csem</code> of
<code>X</code> given <code>W=w</code>, equal to <code>E[g(X) | W=w]</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>J.R. Lockwood <a href="mailto:jrlockwood@ets.org">jrlockwood@ets.org</a>
</p>


<h3>References</h3>

<p>Lockwood J.R. and McCaffrey D.F. (2014). &ldquo;Correcting for test
score measurement error in ANCOVA models for estimating treatment
effects,&rdquo; <em>Journal of Educational and Behavioral Statistics</em>
39(1):22-52.
</p>
<p>Lockwood J.R. and McCaffrey D.F. (2017).
&ldquo;Simulation-extrapolation with latent heteroskedastic
variance,&rdquo; <em>Psychometrika</em> 82(3):717-736.
</p>
<p>Rabe-Hesketh S., Pickles A. and Skrondal A. (2003). &ldquo;Correcting
for covariate measurement error in logistic regression using
nonparametric maximum likelihood estimation,&rdquo; <em>Statistical
Modelling</em> 3:215-232.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testscores">testscores</a></code>,<code><a href="#topic+eivreg">eivreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testscores)

## get the unique values of the lag 1 math score and CSEM
## values and approximate the CSEM function using approxfun()
tmp &lt;- unique(testscores[,c("math_lag1","math_lag1_csem")])
print(tmp &lt;- tmp[order(tmp$math_lag1),])

.csem &lt;- approxfun(tmp$math_lag1, tmp$math_lag1_csem, rule=2:2)
plot(tmp$math_lag1, tmp$math_lag1_csem)
lines(tmp$math_lag1, .csem(tmp$math_lag1), col="blue")

## get NPMLE distribution of latent lag 1 math achievement
m &lt;- deconv_npmle(W        = testscores$math_lag1,
                  csem     = .csem,
                  gridspec = list(fixed = FALSE,
                                  xmin = min(testscores$math_lag1),
                                  xmax = max(testscores$math_lag1),
                                  numpoints = 10000),
                  quietly  = TRUE)

print(m$px)

## estimated mean is approximately the mean of W, but
## the estimated variance is less than the variance of W,
## as it should be
print(c(empirical = mean(testscores$math_lag1),
        estimated = m$px$ex[1]))

print(c(empirical = var(testscores$math_lag1),
        estimated = m$px$varx[1]))

## estimated reliability of W:
print(m$reliability)

## if implementing SIMEX, simex_varfuncs provides plug-in
## options to use for the heteroskedastic error variance
## of each observed W
print(m$simex_varfuncs)

## simple "value-added" estimates of school effects on math,
## adjusting for measurement error in the lag 1 math score.
testscores$schoolid &lt;- factor(testscores$schoolid)

meiv &lt;- eivreg(math ~ math_lag1 + sped + frl + schoolid,
         data = testscores,
         reliability = c(math_lag1 = m$reliability),
         contrasts = list(schoolid = "contr.sum"))

print(summary(meiv))

## alternative deconvolution with fixed grid
m &lt;- deconv_npmle(W        = testscores$math_lag1,
                  csem     = .csem,
                  gridspec = list(fixed = TRUE,
                                  xmin = min(testscores$math_lag1),
                                  xmax = max(testscores$math_lag1),
                                  numpoints = 40),
                  quietly  = TRUE)

print(m$px)

</code></pre>

<hr>
<h2 id='eivreg'>Errors-in-variables (EIV) linear regression</h2><span id='topic+eivreg'></span>

<h3>Description</h3>

<p>Fits errors-in-variables (EIV) linear regression given
specified reliabilities, or a specified variance/covariance matrix for
the measurement errors. For either case, it computes robust standard
error estimates that allow for weighting and/or clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eivreg(formula, data, subset, weights, na.action, method = "qr",
model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = FALSE,
contrasts = NULL, reliability = NULL, Sigma_error = NULL,
cluster_varname = NULL, df_adj = FALSE, stderr = TRUE, offset,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eivreg_+3A_formula">formula</code>, <code id="eivreg_+3A_data">data</code>, <code id="eivreg_+3A_subset">subset</code>, <code id="eivreg_+3A_weights">weights</code>, <code id="eivreg_+3A_na.action">na.action</code>, <code id="eivreg_+3A_method">method</code>, <code id="eivreg_+3A_model">model</code>, <code id="eivreg_+3A_x">x</code>, <code id="eivreg_+3A_y">y</code>, <code id="eivreg_+3A_qr">qr</code></td>
<td>

<p>See documentation for <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="eivreg_+3A_singular.ok">singular.ok</code>, <code id="eivreg_+3A_contrasts">contrasts</code>, <code id="eivreg_+3A_offset">offset</code>, <code id="eivreg_+3A_...">...</code></td>
<td>

<p>See documentation for <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="eivreg_+3A_reliability">reliability</code></td>
<td>

<p>Named numeric vector giving the reliability for each error-prone
covariate.  If left <code>NULL</code>, <code>Sigma_error</code> must be specified.
</p>
</td></tr>
<tr><td><code id="eivreg_+3A_sigma_error">Sigma_error</code></td>
<td>

<p>Named numeric matrix giving the variance/covariance matrix of the
measurement errors for the error-prone covariate(s).  If left
<code>NULL</code>, <code>reliability</code> must be specified.
</p>
</td></tr>
<tr><td><code id="eivreg_+3A_cluster_varname">cluster_varname</code></td>
<td>

<p>A character variable providing the name of a variable in <code>data</code>
that will be used as a clustering variable for robust standard error
computation.
</p>
</td></tr>
<tr><td><code id="eivreg_+3A_df_adj">df_adj</code></td>
<td>

<p>Logical (default FALSE); if TRUE, the estimated variance/covariance
matrix of the regression parameters is multiplied by <code>N/(N-p)</code>,
where <code>N</code> is the number of observations used in the
model fit and <code>p</code> is the number of regression parameters
(including an intercept, if any).
</p>
</td></tr>
<tr><td><code id="eivreg_+3A_stderr">stderr</code></td>
<td>

<p>Logical (default TRUE); if FALSE, does not compute estimated
variance/covariance matrix of the regression parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Theory</em>
</p>
<p>The EIV estimator applies when one wishes to estimate the parameters
of a linear regression of <code class="reqn">Y</code> on <code class="reqn">(X,Z)</code>, but
covariates <code class="reqn">(W,Z)</code> are instead observed, where <code class="reqn">W = X +
  U</code> for mean zero measurement error <code class="reqn">U</code>. Additional
assumptions are required about <code class="reqn">U</code> for consistent estimation;
see references for details.
</p>
<p>The standard EIV estimator of the regression coefficients is <code class="reqn">(Q'Q
  - S)^{-1}Q'Y</code>, where <code class="reqn">Q</code> is the design
matrix formed from <code class="reqn">(W,Z)</code> and <code class="reqn">S</code> is a matrix that
adjusts <code class="reqn">Q'Q</code> to account for elements that are distorted due
to measurement error.  The value of <code class="reqn">S</code> depends on whether
<code>reliability</code> or <code>Sigma_error</code> is specified.  When
<code>Sigma_error</code> is specified, <code class="reqn">S</code> is known.  When
<code>reliability</code> is specified, <code class="reqn">S</code> must be estimated using
the marginal variances of the observed error-prone covariates.
</p>
<p>The estimated regression coefficients are solutions to a system of
estimating equations, and both the system of equations and the
solutions depend on whether <code>reliability</code> or <code>Sigma_error</code>
is specified.  For each of these two cases, standard errors for the
estimated regression coefficients are computed using standard results
from M-estimation; see references.  For either case, adjustments for
clustering are provided if specified.
</p>
<p><em>Syntax Details</em>
</p>
<p>Exactly one of <code>reliability</code> or <code>Sigma_error</code> must be
specified in the call.  <code>Sigma_error</code> need not be diagonal in the
case of correlated measurement error across multiple error-prone
covariates.
</p>
<p>Error-prone variables must be included as linear main effects only; the
current version of the code does not allow interactions among
error-prone covariates, interactions of error-prone covariates with
error-free covariates, or nonlinear functions of error-prone
covariates.  The error-prone covariates cannot be specified with any
construction involving <code>I()</code>.
</p>
<p>The current version does not allow <code>singular.ok=TRUE</code>.
</p>
<p>It is strongly encouraged to use the <code>data</code> argument to pass a dataframe
containing all variables to be used in the regression, rather than
using a matrix on the right hand side of the regression formula.  In
addition, if <code>cluster_varname</code> is specified, everything including
the clustering variable must be passed as <code>data</code>.
</p>
<p>If <code>weights</code> is specified, a weighted version of the EIV
estimator is computed using operations analogous to weighted least
squares in linear regression, and a standard error for this weighted
estimator is computed.  Weights must be positive and will be
normalized inside the function to sum to the number of observations
used to fit the model.  Cases with missing weights will get dropped
just like cases with missing covariates.
</p>
<p>Different software packages that compute robust standard errors make
different choices about degrees-of-freedom adjustments intended to
improve small-sample coverage properties.  The <code>df_adj</code> argument
will inflate the estimated variance/covariance matrix of the estimated
regression coefficients by <code>N/(N-p)</code>; see Wooldridge (2002, p. 57).  In
addition, if <code>cluster_varname</code> is specified, the estimated
variance/covariance matrix will be inflated by <code>M/(M-1)</code> where
<code>M</code> is the number of unique clusters present in the estimation sample.
</p>


<h3>Value</h3>

<p>An list object of class <code>eivlm</code> with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated regression coefficients from EIV
model.
</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from fitted EIV model.
</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Column rank of regression design matrix.
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values from EIV model.
</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of observations used in fitted model.
</p>
</td></tr>
<tr><td><code>Sigma_error</code></td>
<td>
<p>The measurement error covariance matrix, if
supplied.
</p>
</td></tr>
<tr><td><code>reliability</code></td>
<td>
<p>The vector of reliabilities, if supplied.
</p>
</td></tr>
<tr><td><code>relnames</code></td>
<td>
<p>The names of the error-prone covariates.
</p>
</td></tr>
<tr><td><code>XpX_adj</code></td>
<td>
<p>The cross-product matrix of the regression, adjusted
for measurement error.
</p>
</td></tr>
<tr><td><code>varYXZ</code></td>
<td>
<p>The maximum likelihood estimate of the covariance matrix
of the outcome <code class="reqn">Y</code>, the latent covariates X and the observed,
error-free covariates <code class="reqn">Z</code>.  </p>
</td></tr>
<tr><td><code>latent_resvar</code></td>
<td>
<p>A degrees-of-freedom adjusted estimate of the
residual variance of the latent regression.  NOTE: this not an
estimate of the residual variance of the regression on the observed
covariates <code class="reqn">(W,Z)</code>, but rather an estimate of the
residual variance of the regression on <code class="reqn">(X,Z)</code>.  </p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>The estimated variance/covariance matrix of the regression
coefficients.
</p>
</td></tr>
<tr><td><code>cluster_varname</code>, <code>cluster_values</code>, <code>cluster_num</code></td>
<td>
<p>If
<code>cluster_varname</code> is specified, it is returned in the object,
along with <code>cluster_values</code> providing the actual values of the
clustering variable for the cases used in the fitted model, and
<code>cluster_num</code>, the number of unique such clusters.
</p>
</td></tr>
<tr><td><code>OTHER</code></td>
<td>
<p> The object also includes components <code>assign</code>,
<code>df.residual</code>, <code>xlevels</code>, <code>call</code>, <code>terms</code>,
<code>model</code> and other optional components such as <code>weights</code>,
depending on the call; see <code><a href="stats.html#topic+lm">lm</a></code>. In addition, the object
includes components <code>unadj_coefficients</code>,
<code>unadj_fitted.values</code>, <code>unadj_residuals</code>,
<code>unadj_effects</code>, and <code>unadj_qr</code> that are computed from the
unadjusted regression model that ignores measurement error; see
<code><a href="stats.html#topic+lm">lm</a></code>.  </p>
</td></tr> </table>


<h3>Author(s)</h3>

<p>J.R. Lockwood <a href="mailto:jrlockwood@ets.org">jrlockwood@ets.org</a> modified the <code><a href="stats.html#topic+lm">lm</a></code>
function to adapt it for EIV regression.
</p>


<h3>References</h3>

<p>Carroll R.J, Ruppert D., Stefanski L.A. and Crainiceanu C.M.
(2006). <em>Measurement Error in Nonlinear Models: A Modern
Perspective</em> (2nd edition).  London: Chapman &amp; Hall.
</p>
<p>Fuller W. (2006). <em>Measurement Error Models</em> (2nd edition). New York: John
Wiley &amp; Sons.
</p>
<p>Stefanksi L.A. and Boos D.B. (2002). &ldquo;The calculus of
M-estimation,&rdquo; <em>The American Statistician</em> 56(1):29-38.
</p>
<p>Wooldridge J. (2002). <em>Econometric Analysis of Cross Section and
Panel Data</em>. Cambridge, MA: MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+summary.eivlm">summary.eivlm</a></code>, <code><a href="#topic+deconv_npmle">deconv_npmle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1001)
## simulate data with covariates x1, x2 and z.
.n    &lt;- 1000
.d    &lt;- data.frame(x1 = rnorm(.n))
.d$x2 &lt;- sqrt(0.5)*.d$x1 + rnorm(.n, sd=sqrt(0.5))
.d$z  &lt;- as.numeric(.d$x1 + .d$x2 &gt; 0)

## generate outcome
## true regression parameters are c(2,1,1,-1)
.d$y  &lt;- 2.0 + 1.0*.d$x1 + 1.0*.d$x2 - 1.0*.d$z + rnorm(.n)

## generate error-prone covariates w1 and w2
Sigma_error &lt;- diag(c(0.20, 0.30))
dimnames(Sigma_error) &lt;- list(c("w1","w2"), c("w1","w2"))
.d$w1 &lt;- .d$x1 + rnorm(.n, sd = sqrt(Sigma_error["w1","w1"]))
.d$w2 &lt;- .d$x2 + rnorm(.n, sd = sqrt(Sigma_error["w2","w2"]))

## fit EIV regression specifying known measurement error covariance matrix
.mod1 &lt;- eivreg(y ~ w1 + w2 + z, data = .d, Sigma_error = Sigma_error)
print(class(.mod1))
.tmp &lt;- summary(.mod1)
print(class(.tmp))
print(.tmp)

## fit EIV regression specifying known reliabilities.  Note that
## point estimator is slightly different from .mod1 because
## the correction matrix S must be estimated when the reliability
## is known.
.lambda &lt;- c(1,1) / (c(1,1) + diag(Sigma_error))
.mod2 &lt;- eivreg(y ~ w1 + w2 + z, data = .d, reliability = .lambda)
print(summary(.mod2))
</code></pre>

<hr>
<h2 id='get_bugs_wishart_scalemat'>Compute a BUGS-compliant scale matrix for a Wishart prior
distribution for precision matrix that is consistent with target
variances.</h2><span id='topic+get_bugs_wishart_scalemat'></span>

<h3>Description</h3>

<p>Computes a scale matrix in the BUGS parameterization that
corresponds to a minimally-informative Wishart prior distribution for
a precision matrix, with the property that the medians of the
diagonals of the implied prior distribution for the corresponding
covariance matrix are approximately equal to specified target
variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bugs_wishart_scalemat(target, nsim=25000, reltol = 0.05, quietly=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_bugs_wishart_scalemat_+3A_target">target</code></td>
<td>

<p>A <code>p</code>-dimensional vector of target variances.  These are the
variances that you would like your BUGS Wishart prior distribution to
support.
</p>
</td></tr>
<tr><td><code id="get_bugs_wishart_scalemat_+3A_nsim">nsim</code></td>
<td>

<p>Number of Monte-Carlo simulations used to set target scale matrix.
Default is 25,000.
</p>
</td></tr>
<tr><td><code id="get_bugs_wishart_scalemat_+3A_reltol">reltol</code></td>
<td>

<p>Relative tolerance determining when the algorithm stops trying to
find a better scale matrix.  Default is 0.05.
</p>
</td></tr>
<tr><td><code id="get_bugs_wishart_scalemat_+3A_quietly">quietly</code></td>
<td>

<p>If <code>quietly</code> is <code>FALSE</code>, prints iterative and final
diagnostic information.  Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using WinBUGS/OpenBUGS/JAGS, it is often necessary to provide a
Wishart prior distribution for the precision matrix of a
<code>p</code>-dimensional random vector.  It is common to use a Wishart
distribution with <code>p+1</code> degrees of freedom in this case.  The
question is what scale matrix to use.  The BUGS languages parameterize the
Wishart distribution such that if a precision matrix <code>M</code> is given
the prior distribution <code>M ~ dwish(S,p+1)</code> for a <code>pxp</code> scale
matrix <code>S</code> and <code>p+1</code> degrees of freedom, the expected value
of <code>M</code> is <code>p+1</code> times the inverse of <code>S</code>.
</p>
<p>The current function determines a diagonal scale matrix <code>S</code> such
that the implied prior distribution for the inverse of <code>M</code>, the
variance/covariance matrix of the random vector, under the
distribution <code>M ~ dwish(S,p+1)</code> in the BUGS parameterization, has
medians of the diagonal elements approximately equal to some target
variances specified by <code>target</code>.  It iteratively tries values of
<code>S</code> via Monte Carlo simulation to select a value of <code>S</code> with
the desired property.
</p>
<p>The value of <code>reltol</code> determines how close the match must be.
Larger values of <code>nsim</code> and smaller values of <code>reltol</code> will
lead to smaller Monte Carlo error in the estimate scale matrix.
</p>


<h3>Value</h3>

<p>A list with elements
</p>

<ul>
<li><p>bugs.df: Degrees of freedom to use for Wishart prior
distribution in BUGS, equal to <code>p+1</code> where <code>p</code> is the
dimension of <code>target</code>.
</p>
</li>
<li><p>bugs.scalemat: Scale matrix to use for Wishart prior
distribution in BUGS.
</p>
</li>
<li><p>varsum: Summary of prior distribution of implied variances;
medians should approximately equal <code>target</code>.
</p>
</li>
<li><p>corsum: Summary of prior distribution of implied
correlations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>J.R. Lockwood <a href="mailto:jrlockwood@ets.org">jrlockwood@ets.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- get_bugs_wishart_scalemat(target = c(10,4,4,8), nsim = 30000,
reltol = 0.02, quietly=FALSE)
print(tmp)

## if you now model precison matrix M ~ dwish(tmp$bugs.scalemat,
## tmp$bugs.df) in a BUGS language, this will imply a prior distribution
## for the inverse of M that has medians of the diagonal elements
## approximately equal to 'target'

</code></pre>

<hr>
<h2 id='lr_ancova'>Latent Regression for Group Effects with Latent Heteroskedastic
Error Variance
</h2><span id='topic+lr_ancova'></span>

<h3>Description</h3>

<p>Uses the <code><a href="R2jags.html#topic+jags">jags</a></code> function in R2jags to fit a
latent-variable GLM with error-prone covariates that may have
heteroskedastic normal measurement error with variance that is a
function of the latent variable, such as commonly occurs with test
scores computed using item-response-theory (IRT) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr_ancova(outcome_model, Y, W, Z, G, varfuncs, plotfile=NULL,
seed=12345, modelfileonly=FALSE, scalemat=NULL, blockprior=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr_ancova_+3A_outcome_model">outcome_model</code></td>
<td>
<p>A character string indicating the outcome model.
Valid values are currently 'normal', 'normalME', 'poisson',
'bernoulli_probit', and 'bernoulli_logit'.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_y">Y</code></td>
<td>
<p>A numeric vector of outcome values. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_w">W</code></td>
<td>
<p>A numeric matrix of error-prone covariates.  Missing values
are allowed, though no column of <code>W</code> may be entirely missing.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_z">Z</code></td>
<td>
<p>A numeric matrix of error-free covariates.  Missing values
are not allowed.  First column must be a vector of 1s to serve as a
model intercept because effects of groups in <code>G</code> are
parameterized with a sum-to-zero constraint.  See Details for
additional information.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_g">G</code></td>
<td>
<p>A numeric or factor vector indicating group memberships of
units.  Missing values not allowed.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_varfuncs">varfuncs</code></td>
<td>
<p>A list with as many components as there are
error-prone covariates, equal to the number of columns of <code>W</code>.
For each <code>i</code> from <code>1</code> to <code>ncol(W)</code>,
<code>varfuncs[[i]]</code> is itself a list summarizing the known
information about the measurement error in the variable
<code>W[,i]</code>.  See Details.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_plotfile">plotfile</code></td>
<td>
<p>Character string providing full path to a PDF file
that will store some diagnostic plots regarding the variance
functions.  Default is NULL and will be assigned to a file in a
temporary directory and the name of file will be returned.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_seed">seed</code></td>
<td>
<p>An integer that will be passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>
so that Monte Carlo results can be reproduced.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_modelfileonly">modelfileonly</code></td>
<td>
<p>If TRUE, function will return a link to a file
that contains the JAGS model code, but will not actually fit the
model.  Default is FALSE.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_scalemat">scalemat</code></td>
<td>
<p>When there are multiple error-prone covariates, the
specification of the Bayesian model as implemented in JAGS requires
a scale matrix for a Wishart prior distribution for a precision
matrix.  The default is NULL, in which case the function will set a
value of <code>scalemat</code>; see Details.  If the user wishes to pass a
<code>scalemat</code> it must be a positive-definite symmetric matrix of
dimension <code>ncol(W)</code>.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_blockprior">blockprior</code></td>
<td>
<p>If TRUE (the default), specifies JAGS code to
encourage updating regression model parameters as a block to improve
MCMC mixing.</p>
</td></tr>
<tr><td><code id="lr_ancova_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="R2jags.html#topic+jags">jags</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Theory</em>
</p>
<p>The outcome <code class="reqn">Y</code> is assumed to depend on <code class="reqn">(X,Z,G)</code>
where <code class="reqn">X</code> is a vector of latent variables, <code class="reqn">Z</code> is a
vector of observed, error-free variables, and <code class="reqn">G</code> is a grouping
variable.  For example, one may be interested in the effects of some
intervention where <code class="reqn">G</code> indicates groupings of units that
received different treatments, and the variables <code class="reqn">(X,Z)</code>
are potential confounders.  This function addresses the case where
<code class="reqn">X</code> is unobserved, and error-prone proxies <code class="reqn">W</code> are
instead observed.  It is assumed that <code class="reqn">W = X + U</code> for
mean-zero, normally-distributed measurement error <code class="reqn">U</code>, and that
<code class="reqn">Var(U)</code> may be a function <code class="reqn">g(X)</code> of <code class="reqn">X</code>.  Such
error structures commonly arise with the use of test scores computed
using item-response-theory (IRT) models. Details on these issues and
other model assumptions are provided in the references.  The model is
a generalization of errors-in-variables linear regression.
</p>
<p>The model assumes that the outcome <code class="reqn">Y</code> depends on
<code class="reqn">(X,Z,G)</code> through a linear function of these predictors,
and parameters for this linear function are estimated. The conditional
distribution of <code class="reqn">Y</code> given these predictors that is assumed by
the model depends on <code>outcome_model</code>.  If <code>outcome_model</code> is
<code>normal</code>, the conditional distribution of <code class="reqn">Y</code> is assumed
to be normal, and the model also estimates a residual variance for
<code class="reqn">Y</code> given the covariates. If <code>outcome_model</code> is
<code>normalME</code>, it is assumed that there is a latent variable (call
it <code>Yl</code>) that follows the same conditional distribution as when
<code>outcome_model</code> is <code>normal</code>, and then <code class="reqn">Y</code> measures
<code>Yl</code> with normal measurement error and the known information
about this error is passed as the last component of <code>varfuncs</code>.
In this way, the <code>lr_ancova</code> can support models with
heteroskedastic measurement error in both the predictors and the
outcome.  If <code>outcome_model</code> is <code>poisson</code>, <code class="reqn">Y</code> must
consists of non-negative integers and a log link is assumed.  If
<code>outcome_model</code> is <code>bernoulli_logit</code>, <code class="reqn">Y</code> must take
on values of 0 and 1, and a logit link is assumed.  Finally, if
<code>outcome_model</code> is <code>bernoulli_probit</code>, <code class="reqn">Y</code> must take
on values of 0 and 1, and a probit link is assumed.
</p>
<p>The model assumes that the conditional distribution of <code class="reqn">X</code>
given <code class="reqn">(Z,G)</code> is normal with a mean vector that depends on
<code class="reqn">(Z,G)</code> and a covariance matrix that is assumed not to
depend on <code class="reqn">(Z,G)</code>.  Both the regression parameters and the
residual covariance matrix of this conditional distribution are
estimated.
</p>
<p>All parameters of the model involving <code class="reqn">(Y,X,Z,G)</code> are
estimated using the observed data <code class="reqn">(Y,W,Z,G)</code> using
assumptions and information about the distribution of the measurement
errors <code class="reqn">U</code>.  The structure assumed here is that measurement
errors are independent across units and across dimensions of
<code class="reqn">X</code>, and that the conditional distribution of <code class="reqn">U</code> given
<code class="reqn">(Y,X,Z,G)</code> is a normal distribution with mean zero and variance
<code class="reqn">g(X)</code>.  The function <code class="reqn">g</code> must be specified and can
be constant.  Additional discussions of this class of error functions
are provided in the references, and details about how information
about <code class="reqn">g</code> is conveyed to this function are provided below.
</p>
<p><em>Syntax Details</em>
</p>
<p>Note that this function requires the R2jags package, which in turn
requires JAGS to be installed on your system.
</p>
<p>The function will check that the only column of <code>Z</code> that is in
the span of the columns of the design matrix implied by the grouping
variable <code>G</code> is the first column, corresponding to an intercept.
The effects of <code>G</code> are parameterized with a sum-to-zero
constraint, so that the effect of each group is expressed relative to
the average of all group effects.
</p>
<p>The <code>varfuncs</code> argument requires the most thinking.  This
argument is a list with as many elements as there are error-prone
covariates, or one plus the number of error-prone covariates if
<code>outcome_model</code> is <code>normalME</code>.  In this latter case, the
final element must be the error variance function for <code class="reqn">Y</code>.
</p>
<p>Each element of the list <code>varfuncs</code> is itself a list providing
the measurement error information about one of the error-prone
covariates (or the outcome, if <code>outcome_model</code> is
<code>normalME</code>).  For each <code>i</code>, <code>varfuncs[[i]]</code> must be a
list following a particular structure.  First,
<code>varfuncs[[i]]$type</code> must be a character string taking one of
three possible values: <code>constant</code>, <code>piecewise_linear</code> or
<code>log_polynomial</code>.  The case <code>constant</code> corresponds to the
case of homoskedastic measurement error where <code class="reqn">g(X)</code> is
constant, and the variance of this measurement error must be provided
in <code>varfuncs[[i]]$vtab</code>.  The other two cases correspond to the
case where the conditional measurement error variance <code class="reqn">g(X)</code>
is a nontrivial function of <code class="reqn">X</code>.  In both of these cases,
<code>varfuncs[[i]]$vtab</code> must be a matrix or data frame with exactly
two columns and <code>K</code> rows, where the first column provides values
<code>x[1],...,x[K]</code> of <code class="reqn">X</code> and the second column provides
values <code>g(x[1]),...,g(x[K])</code>.  That is, the function <code class="reqn">g(X)</code>
is conveyed via a lookup table.  The value of <code>K</code> is selected by
the user. Larger values of <code>K</code> will make the approximation to
<code class="reqn">g(X)</code> more accurate but will cause the model estimation to
proceed more slowly.  How the values in the lookup table are used to
approximate <code class="reqn">g(X)</code> more generally depends whether
<code>varfuncs[[i]]$type</code> is <code>piecewise_linear</code> or
<code>log_polynomial</code>.  In the case of <code>piecewise_linear</code>, the
values in the lookup table are linearly interpolated.  In the case of
<code>log_polynomial</code>, a polynomial of degree
<code>varfuncs[[i]]$degree</code> is fitted to the logs of the values of
<code>g(x[1]),...,g(x[K])</code>, and the fitted model is used to build a
smooth approximation to the function <code class="reqn">g(X)</code>.  The default
value of <code>varfuncs[[i]]$degree</code> if it is not specified is 6.  For
either the piecewise linear or log polynomial approximations, the
function <code>g(X)</code>g(X) is set to <code>g(x[1])</code> for values of
<code>x</code> smaller than <code>x[1]</code>, and is set of <code>g(x[K])</code> for
values of <code>x</code> larger than <code>x[K]</code>.  Diagnostic plots of the
approximate variance functions saved in PDF file whose location is
returned by <code>lr_ancova</code>.  The Examples section provides examples
that will be helpful in specifying <code>varfuncs</code>.
</p>
<p>When there are two or more error-prone covariates, the model estimates
a residual variance/covariance matrix of <code class="reqn">X</code> given
<code class="reqn">(Z,G)</code>.  Because the model is fit in a Bayesian framework,
a prior distribution is required for this matrix.  We are using JAGS
and specify a prior distribution for the inverse of the residual
variance/covariance matrix using a Wishart distribution.  The degrees
of freedom parameter of this distribution is set to one plus
<code>ncol(W)</code> to be minimally informative.  The scale matrix of this
distribution can be set by passing an appropriate matrix via the
<code>scalemat</code> argument.  If <code>scalemat</code> is NULL, the function
specifies a diagonal scale matrix that attempts to make the prior
medians of the unknown residual variances approximately equal to the
residual variances obtained by regressing components of <code class="reqn">W</code> on
<code class="reqn">(Z,G)</code>.  See <code><a href="#topic+get_bugs_wishart_scalemat">get_bugs_wishart_scalemat</a></code>.
Such variances will be somewhat inflated due to measurement error in
<code class="reqn">W</code> but the prior variance of the Wishart distribution is
sufficiently large that this lack of alignment should be minimally
consequential in most applications.  The value of <code>scalemat</code> used
in the estimation is returned by the function, and users can start
with the default and then pass alternative values via the
<code>scalemat</code> argument for sensitivity analyses if desired.  </p>


<h3>Value</h3>

<p>A object of class <code>rjags</code>, with additional information
specific to this context.  The additional information is stored as a
list called <code>lr_ancova_extras</code> with the following components:
</p>
<table>
<tr><td><code>model.location</code></td>
<td>
<p>Path to file containing JAGS model code.</p>
</td></tr>
<tr><td><code>plot.location</code></td>
<td>
<p>Path to file containing diagnostic plots
regarding the variance functions.</p>
</td></tr>
<tr><td><code>group.map</code></td>
<td>
<p>A dataframe mapping the original group labels in
<code>G</code> to integer labels ranging from <code>1</code> to the number of
unique elements of <code>G</code>.  These are useful for mapping the group
effects reported by JAGS back to the group labels.</p>
</td></tr>
<tr><td><code>scalemat</code></td>
<td>
<p>The value of <code>scalemat</code> used in the estimation.</p>
</td></tr>
</table>
<p>The parameters used in the JAGS model, and thus named in the model
object, use naming conventions described here.  The parameters in the
linear function of <code class="reqn">(X,Z,G)</code> that is related to
<code class="reqn">Y</code> are partitioned into <code>betaYXZ</code> and <code>betaYG</code>.  In
applications involving analysis of causal effects of groupings, the
parameters <code>betaYG</code> will generally be of most interest.  When
<code>outcome_model</code> is <code>normal</code>, the residual standard deviation
of <code class="reqn">Y</code> given <code class="reqn">(X,Z,G)</code> is also estimated and is
called <code>sdYgivenXZG</code>.  Similarly, when <code>outcome_model</code> is
<code>normalME</code>, a residual standard deviation of the latent variable
corresponding to <code class="reqn">Y</code> given <code class="reqn">(X,Z,G)</code> is also
estimated and is also called <code>sdYgivenXZG</code>.  Note in this case
that the residual standard deviation of <code class="reqn">Y</code> given its
corresponding latent variable is assumed to be known and specified via
<code>varfuncs</code>.
</p>
<p>The regression parameters for the conditional distribution of
<code class="reqn">X</code> given <code class="reqn">(Z,G)</code> are partitioned as <code>betaXZ</code>
and <code>betaXG</code>.  The residual variance/covariance matrix for
<code class="reqn">X</code> given <code class="reqn">(Z,G)</code> is named
<code>varXgivenXG</code>. Additional details on these parameters can be
found by looking at the JAGS model file whose location is returned as
noted above.
</p>


<h3>Author(s)</h3>

<p>J.R. Lockwood <a href="mailto:jrlockwood@ets.org">jrlockwood@ets.org</a>
</p>


<h3>References</h3>

<p>Battauz, M. and Bellio, R. (2011). &ldquo;Structural modeling of
measurement error in generalized linear models with Rasch measures
as covariates,&rdquo; <em>Psychometrika</em> 76(1):40-56.
</p>
<p>Lockwood J.R. and McCaffrey D.F. (2014). &ldquo;Correcting for test
score measurement error in ANCOVA models for estimating treatment
effects,&rdquo; <em>Journal of Educational and Behavioral Statistics</em>
39(1):22-52.
</p>
<p>Lockwood J.R. and McCaffrey D.F. (2017).
&ldquo;Simulation-extrapolation with latent heteroskedastic
variance,&rdquo; <em>Psychometrika</em> 82(3):717-736.
</p>
<p>Plummer, M. (2003). &ldquo;JAGS: A program for analysis of Bayesian
graphical models using Gibbs sampling.&rdquo; Proceedings of the 3rd
International Workshop on Distributed Statistical Computing (DSC
2003), Vienna, Austria.
</p>
<p>Rabe-Hesketh S., Pickles A. and Skrondal A. (2003). &ldquo;Correcting
for covariate measurement error in logistic regression using
nonparametric maximum likelihood estimation,&rdquo; <em>Statistical
Modelling</em> 3:215-232.
</p>


<h3>See Also</h3>

<p><code><a href="R2jags.html#topic+jags">jags</a></code>, <code><a href="#topic+get_bugs_wishart_scalemat">get_bugs_wishart_scalemat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(3001)
cat("NOTE: this example uses MCMC and takes a little while to run\n")

## example of estimating school "value-added" effects on math test scores,
## adjusting for lag 1 math and ELA scores and accounting for the
## heteroskedastic measurement errors in those scores.
data(testscores)
print(length(unique(testscores$schoolid)))

## to help interpretation of model coefficients and school effects, standardize
## current and lag 1 test scores to have mean zero and variance 1.  Also adjust
## the conditional standard errors of measurement for the lag 1 scores.
testscores$math &lt;- as.vector(scale(testscores$math))

testscores$math_lag1_csem &lt;- testscores$math_lag1_csem / sd(testscores$math_lag1)
testscores$math_lag1      &lt;- as.vector(scale(testscores$math_lag1))

testscores$lang_lag1_csem &lt;- testscores$lang_lag1_csem / sd(testscores$lang_lag1)
testscores$lang_lag1      &lt;- as.vector(scale(testscores$lang_lag1))

## create pieces needed to call lr_ancova.  Note that first column of Z
## must be an intercept.
outcome_model &lt;- "normal"
Y             &lt;- testscores$math
W             &lt;- testscores[,c("math_lag1","lang_lag1")]
Z             &lt;- cbind(1, testscores[,c("sped","frl")])
G             &lt;- testscores$schoolid

## create varfuncs.  Need to be careful to pass conditional measurement error
## variances, which require squaring the CSEMs
varfuncs   &lt;- list()

tmp        &lt;- unique(testscores[,c("math_lag1","math_lag1_csem")])
names(tmp) &lt;- c("x","gx")
tmp        &lt;- tmp[order(tmp$x),]
tmp$gx     &lt;- tmp$gx^2
varfuncs[[1]] &lt;- list(type="log_polynomial", vtab=tmp)

tmp        &lt;- unique(testscores[,c("lang_lag1","lang_lag1_csem")])
names(tmp) &lt;- c("x","gx")
tmp        &lt;- tmp[order(tmp$x),]
tmp$gx     &lt;- tmp$gx^2
varfuncs[[2]] &lt;- list(type="log_polynomial", vtab=tmp)

## fit the model.  NOTE: in practice, larger values of n.iter and n.burnin
## would typically be used; they are kept small here so that the example
## runs relatively quickly.
m1 &lt;- lr_ancova(outcome_model, Y, W, Z, G, varfuncs, n.iter=300, n.burnin=100)

## you can check the approximation to the variance functions by looking at the
## PDF file:
print(m1$lr_ancova_extras$plot.location)

## and also can look at the JAGS model file:
print(m1$lr_ancova_extras$model.location)

## the model object is of class "rjags" and so inherits the appropriate methods,
## including print:
print(m1)
## betaXG, betaXZ, and varXgivenZG are for the conditional distribution of X
## given (Z,G).  betaYG, betaYXZ and sdYgivenXZG are for the conditional
## distribution of Y given (X,Z,G).
##
## the first two elements of betaYXZ are the coefficients for the two columns of
## X, whereas the following three elements are the coefficients for the three
## columns of Z.
##
## the school effects are in betaYG.  extract their posterior means and
## posterior standard deviations:
e &lt;- m1$BUGSoutput$summary
e &lt;- as.data.frame(e[grep("betaYG",rownames(e)),c("mean","sd")])
## check the sum-to-zero constraints:
print(sum(e$mean))
## put the actual school IDs onto "e"
e$schoolid &lt;- m1$lr_ancova_extras$group.map$G
print(e)

## compare the school effect estimates to those from a simpler model that does
## not adjust for the lag 1 ELA score, and does not account for the measurement
## error in the lag 1 math score.  Use sum-to-zero contrasts and recover the
## estimate for the last school as negative the sum of the other estimates.
testscores$schid &lt;- factor(testscores$schoolid)
m0 &lt;- lm(math ~ math_lag1 + sped + frl + schid,
         data=testscores, contrasts=list(schid = "contr.sum"))
s  &lt;- coef(m0)[grep("schid", names(coef(m0)))]
e$est_m0 &lt;- c(s, -sum(s))

## Such estimates should have some amount of omitted variable bias, which
## should manifest as the differences between the "m0" and "m1" estimates
## being positively correlated with average prior achievement.
print(cor(tapply(testscores$math_lag1, testscores$schoolid, mean), e$est_m0 - e$mean))
print(cor(tapply(testscores$lang_lag1, testscores$schoolid, mean), e$est_m0 - e$mean))

</code></pre>

<hr>
<h2 id='model.matrix.eivlm'><code>model.matrix</code> method for objects of class <code>eivlm</code>.</h2><span id='topic+model.matrix.eivlm'></span>

<h3>Description</h3>

<p>Extract model matrix from <code>eivlm</code> object. Analogous to <code>model.matrix</code> method for <code><a href="stats.html#topic+lm">lm</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eivlm'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.eivlm_+3A_object">object</code></td>
<td>

<p>A model object of class <code>eivlm</code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.eivlm_+3A_...">...</code></td>
<td>

<p>See help for <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Design matrix used in EIV regression.
</p>

<hr>
<h2 id='print.eivlm'><code>print</code> method for objects of class <code>eivlm</code>.</h2><span id='topic+print.eivlm'></span>

<h3>Description</h3>

<p>Analogous to <code>print</code> method for <code><a href="stats.html#topic+lm">lm</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eivlm'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.eivlm_+3A_x">x</code></td>
<td>

<p>A model object of class <code>eivlm</code>.
</p>
</td></tr>
<tr><td><code id="print.eivlm_+3A_digits">digits</code>, <code id="print.eivlm_+3A_...">...</code></td>
<td>

<p>See help for <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.eivlm'><code>print</code> method for objects of class <code>summary.eivlm</code>.</h2><span id='topic+print.summary.eivlm'></span>

<h3>Description</h3>

<p> Similar to <code>print</code> method for summaries of
<code><a href="stats.html#topic+lm">lm</a></code> objects, but provides additional information specific
to the EIV regression.  The <code>summary</code> method for objects of class
<code>eivlm</code> returns an object of class <code>summary.eivlm</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.eivlm'
print(x,
digits = max(3L, getOption("digits") - 3L),
symbolic.cor = x$symbolic.cor,
signif.stars = getOption("show.signif.stars"),
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.eivlm_+3A_x">x</code></td>
<td>

<p>A model object of class <code>summary.eivlm</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.eivlm_+3A_digits">digits</code>, <code id="print.summary.eivlm_+3A_symbolic.cor">symbolic.cor</code>, <code id="print.summary.eivlm_+3A_signif.stars">signif.stars</code>, <code id="print.summary.eivlm_+3A_...">...</code></td>
<td>

<p>See help for <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See help for <code><a href="#topic+summary.eivlm">summary.eivlm</a></code> for description of quantities
relevant to summarizing <code>eivlm</code> objects.
</p>

<hr>
<h2 id='summary.eivlm'><code>summary</code> method for objects of class <code>eivlm</code>.</h2><span id='topic+summary.eivlm'></span>

<h3>Description</h3>

<p>Computes summary quantities for a model of class <code>eivlm</code>.  The
computations include some quantities for the standard regression model
(uncorrected for covariate measurement error), as well as quantities
relevant to the EIV model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eivlm'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.eivlm_+3A_object">object</code></td>
<td>

<p>A model object of class <code>eivlm</code>.
</p>
</td></tr>
<tr><td><code id="summary.eivlm_+3A_correlation">correlation</code>, <code id="summary.eivlm_+3A_symbolic.cor">symbolic.cor</code>, <code id="summary.eivlm_+3A_...">...</code></td>
<td>

<p>See help for <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list object of class <code>summary.eivlm</code> with components:
</p>
<table>
<tr><td><code>residuals</code>, <code>fitted.values</code>, <code>N</code>, <code>latent_resvar</code>, <code>vcov</code>, <code>relnames</code>, <code>coefficients</code></td>
<td>
<p>See <code><a href="#topic+eivreg">eivreg</a></code>.
</p>
</td></tr>
<tr><td><code>call</code>, <code>terms</code>, <code>aliased</code>, <code>df</code>, <code>coefficients</code></td>
<td>
<p>See <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>.</p>
</td></tr>
<tr><td><code>reliability</code></td>
<td>
<p>If <code>reliability</code> is specified in model fit.
</p>
</td></tr>
<tr><td><code>Sigma_error</code></td>
<td>
<p>If <code>Sigma_error</code> is specified in model fit.
</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p>If <code>symbolic.cor</code> is specified in call to
function.
</p>
</td></tr>
<tr><td><code>latent_R2</code></td>
<td>
<p>Maximum likelihood estimate of R-squared for
regression of Y on (X,Z).  NOTE: This is not the R-squared of the
fitted regression of Y on (W,Z).
</p>
</td></tr>
<tr><td><code>latent_R2_dfadj</code></td>
<td>
<p>Estimate of R-squared for regression of Y on
(X,Z) adjusted by number of estimated regression parameters.
</p>
</td></tr>
<tr><td><code>OTHER</code></td>
<td>
<p>The object also includes components
<code>unadj_residuals</code>, <code>unadj_coefficients</code>,
<code>unadj_sigma</code>, <code>unadj_r.squared</code>,
<code>unadj_adj.r.squared</code>, <code>unadj_fstatistic</code> and
<code>unadj_cov.unscaled</code> that are computed from the &quot;unadjusted&quot;
regression model that ignores measurement error; see
<code><a href="stats.html#topic+summary.lm">summary.lm</a></code>.  Also, additional components will be
included if either <code>weights</code> or <code>cluster_varname</code> is
specified in the call to <code>eivlm</code>; see that help file for
details.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lockwood <a href="mailto:jrlockwood@ets.org">jrlockwood@ets.org</a>
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+eivreg">eivreg</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>Function <code><a href="stats.html#topic+coef">coef</a></code> will extract the matrix of coefficients
with standard errors, t-statistics and p-values.
</p>

<hr>
<h2 id='testscores'>Example longitudinal test score data</h2><span id='topic+testscores'></span>

<h3>Description</h3>

<p>Cohort of grade 6 students with mathematics test scores from a target
school year, as well as mathematics and language test scores from the prior school
year (grade 5). Measurement error in test scores quantified by conditional standard
error of measurement (CSEM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testscores)</code></pre>


<h3>Format</h3>

<p>A data frame with 4853 observations and 10 fields:
</p>

<dl>
<dt><code>stuid</code></dt><dd><p>Unique identifier for each student (one record per
student)</p>
</dd>
<dt><code>schoolid</code></dt><dd><p>Unique identifier for each student's grade 
6 school</p>
</dd>
<dt><code>math</code></dt><dd><p>Grade 6 mathematics test score</p>
</dd>
<dt><code>math_csem</code></dt><dd><p>CSEM for grade 6 mathematics test score</p>
</dd>
<dt><code>math_lag1</code></dt><dd><p>Grade 5 mathematics test score</p>
</dd>
<dt><code>math_lag1_csem</code></dt><dd><p>CSEM for grade 5 mathematics test score</p>
</dd>
<dt><code>lang_lag1</code></dt><dd><p>Grade 5 language test score</p>
</dd>
<dt><code>lang_lag1_csem</code></dt><dd><p>CSEM for grade 5 language test score</p>
</dd>
<dt><code>sped</code></dt><dd><p>1 = student designated as special education;
0 otherwise</p>
</dd>
<dt><code>frl</code></dt><dd><p>1 = student participates in Free and Reduced Price
lunch program;
0 otherwise</p>
</dd>
</dl>



<h3>Source</h3>

<p>Anonymous
</p>

<hr>
<h2 id='vcov.eivlm'><code>vcov</code> method for objects of class <code>eivlm</code>.</h2><span id='topic+vcov.eivlm'></span>

<h3>Description</h3>

<p>Extract variance/covariance matrix of estimated parameters from
<code>eivlm</code> model object. Analogous to <code>vcov</code> method for other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eivlm'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.eivlm_+3A_object">object</code></td>
<td>

<p>A model object of class <code>eivlm</code>.
</p>
</td></tr>
<tr><td><code id="vcov.eivlm_+3A_...">...</code></td>
<td>

<p>Not currently implemented.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated variance/covariance matrix of estimated regression
coefficients.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
