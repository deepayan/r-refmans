<!DOCTYPE html><html><head><title>Help for package manifold</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {manifold}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#axisAngleRep'><p>Returns the angle representation of SO(3) matrices</p>
c.f. <a href="https://en.wikipedia.org/wiki/Axis-angle_representation">https://en.wikipedia.org/wiki/Axis-angle_representation</a></a></li>
<li><a href='#basisTan.Euclidean'><p>Obtain an orthonormal basis on the tangent space</p></a></li>
<li><a href='#coordToTanV'><p>Transform the coordinates for the tangent space into a tangent vector</p></a></li>
<li><a href='#createM'><p>Create an object to symbolize the manifold.</p></a></li>
<li><a href='#dimensions'><p>Dimensions in this package</p></a></li>
<li><a href='#distance.Euclidean'><p>Geodesic distance</p></a></li>
<li><a href='#ExpM'><p>Matrix exponential</p></a></li>
<li><a href='#frechetMean'><p>Calculate the Fréchet mean</p></a></li>
<li><a href='#frechetMedian'><p>Calculate the Fréchet median</p></a></li>
<li><a href='#geodesicCurve'><p>Obtain the geodesic curve</p></a></li>
<li><a href='#GetSettingName'><p>Helper function for simulations</p></a></li>
<li><a href='#is.finiteDim'><p>Tell whether a manifold is a finite-dimensional one</p></a></li>
<li><a href='#listAvailMfd'><p>List all available manifold names</p></a></li>
<li><a href='#LogM'><p>Matrix logarithm</p></a></li>
<li><a href='#LogMSPD'><p>Matrix logarithm of a symmetric positive definite</p></a></li>
<li><a href='#MakeSym'><p>Make a symmetric matrix by specifying a near-symmetric matrix M, or the lower triangular elements lowerTri with diagonal.</p></a></li>
<li><a href='#manifold'><p>manifold: Operations for Riemannian manifolds</p></a></li>
<li><a href='#metric.Euclidean'><p>Returns the Riemannian metric</p></a></li>
<li><a href='#norm.Euclidean'><p>Norm on the tangent space induced by the Riemannian metric</p></a></li>
<li><a href='#Normalize'><p>Normalize a vector</p></a></li>
<li><a href='#origin.Euclidean'><p>Returns the origin of the manifold</p></a></li>
<li><a href='#project.Euclidean'><p>Project data points in the ambient space onto the manifold</p></a></li>
<li><a href='#projectTangent.Euclidean'><p>Project data points in the ambient space onto the tangent space</p></a></li>
<li><a href='#rieExp.Euclidean'><p>Riemannian exponential map</p></a></li>
<li><a href='#rieLog.Euclidean'><p>Riemannian logarithm map</p></a></li>
<li><a href='#rmfd'><p>Generate random variables on the manifold</p></a></li>
<li><a href='#runifSphere'><p>Generate uniform random variables on the unit sphere</p></a></li>
<li><a href='#tanVToCoord'><p>Transform tangent vectors to their coordinates on the tangent space</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Operations for Riemannian Manifolds</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements operations for Riemannian manifolds, e.g., geodesic distance, Riemannian metric, exponential and logarithm maps, etc. Also incorporates random object generator on the manifolds. See Dai, Lin, and Müller (2021) &lt;<a href="https://doi.org/10.1111%2Fbiom.13385">doi:10.1111/biom.13385</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Matrix</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-03 22:54:44 UTC; xdai</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiongtao Dai [aut, cre, cph],
  Zhenhua Lin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiongtao Dai &lt;xdai@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-04 10:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='axisAngleRep'>Returns the angle representation of SO(3) matrices
c.f. <a href="https://en.wikipedia.org/wiki/Axis-angle_representation">https://en.wikipedia.org/wiki/Axis-angle_representation</a></h2><span id='topic+axisAngleRep'></span>

<h3>Description</h3>

<p>Returns the angle representation of SO(3) matrices
c.f. <a href="https://en.wikipedia.org/wiki/Axis-angle_representation">https://en.wikipedia.org/wiki/Axis-angle_representation</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axisAngleRep(mfd, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axisAngleRep_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="axisAngleRep_+3A_x">X</code></td>
<td>
<p>A matrix holding a vectorized SO(3) matrix in each column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 4 rows and the same number of columns as X. The first row contains the angles in rads (theta), and the last three rows correspond to the the axes with respect to which the rotations are performed.
</p>

<hr>
<h2 id='basisTan.Euclidean'>Obtain an orthonormal basis on the tangent space</h2><span id='topic+basisTan.Euclidean'></span><span id='topic+basisTan'></span><span id='topic+basisTan.SO'></span><span id='topic+basisTan.SPD'></span><span id='topic+basisTan.Sphere'></span><span id='topic+basisTan.FlatTorus'></span>

<h3>Description</h3>

<p>Parametrize the tangent space at location p, so that the parameterized version contains an open neighborhood around the origin. (The dimension of v is potentially reduced).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
basisTan(mfd, p)

basisTan(mfd, p)

## S3 method for class 'SO'
basisTan(mfd, p)

## S3 method for class 'SPD'
basisTan(mfd, p)

## S3 method for class 'Sphere'
basisTan(mfd, p)

## S3 method for class 'FlatTorus'
basisTan(mfd, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basisTan.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="basisTan.Euclidean_+3A_p">p</code></td>
<td>
<p>A vector for a base point on the manifold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An orthonormal basis matrix D, whose columns contain the basis vectors, so that 'D^T v' give the coordinates 'v0' for a tangent vector 'v', and 'D
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>basisTan(Euclidean)</code>: An identity matrix
</p>
</li>
<li> <p><code>basisTan(SO)</code>: An identity matrix
</p>
</li>
<li> <p><code>basisTan(SPD)</code>: The basis is obtained from enumerating the (non-strict) lower-triangle of a square matrix. If i != j, the (i, j)th entry is mapped into a matrix with 1/sqrt(2) in the (i,j) and (j,i) entries and 0 in other entries; if (i == j), it is mapped to a matrix with 1 in the ith diagonal element and 0 otherwise. The mapped matrix is then vectorized to obtain the basis vector.
</p>
</li>
<li> <p><code>basisTan(Sphere)</code>: The basis at the north pole is [0, ..., 1, ..., 0] where the 1 is at the j = 2, ..., dAmbth location. The basis at a point p is obtained through rotating the basis from the north pole to p along the shortest geodesic.
</p>
</li>
<li> <p><code>basisTan(FlatTorus)</code>: An identity matrix
</p>
</li></ul>

<hr>
<h2 id='coordToTanV'>Transform the coordinates for the tangent space into a tangent vector</h2><span id='topic+coordToTanV'></span><span id='topic+coordToTanV.default'></span>

<h3>Description</h3>

<p>Transform the coordinates w.r.t. a basis returned by [basisTan()] to tangent vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordToTanV(mfd, p, V0, ...)

## Default S3 method:
coordToTanV(mfd, p, V0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordToTanV_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="coordToTanV_+3A_p">p</code></td>
<td>
<p>A vector for the base point</p>
</td></tr>
<tr><td><code id="coordToTanV_+3A_v0">V0</code></td>
<td>
<p>A matrix or a vector containing the coordinates</p>
</td></tr>
<tr><td><code id="coordToTanV_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which each column correspond to a different tangent vector
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>coordToTanV(default)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='createM'>Create an object to symbolize the manifold.</h2><span id='topic+createM'></span>

<h3>Description</h3>

<p>Create an object to symbolize the manifold. Supports the Euclidean, the unit sphere, special orthogonal group, and symmetric positive definite (SPD) matrices with either the affine invariant or the log-Euclidean metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createM(mfdName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createM_+3A_mfdname">mfdName</code></td>
<td>
<p>One of 'Euclidean', 'Sphere', 'SO', 'AffInv', or 'LogEu'. The name is case sensitive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overall, most of the arguments in the manifold functions respect recycling rules. If the input arguments are matrices with n rows corresponding to n points, then the manifold function will be applied to each of the n pairs; the returned value will be a matrix. If one input corresponds to n points and the other just one point, then the one point will be recycled. If each component corresponds to one point, the returned value will correspond to just one point.
</p>


<h3>Value</h3>

<p>A structure 1 with class being 'mfdName'
</p>

<hr>
<h2 id='dimensions'>Dimensions in this package</h2><span id='topic+dimensions'></span><span id='topic+calcGeomPar'></span><span id='topic+calcIntDim'></span><span id='topic+calcAmbDim'></span><span id='topic+calcTanDim'></span>

<h3>Description</h3>

<p>'calcGeomPar' calculates geometric parameter.
'calcIntDim' calculates the intrinsic dimensions.
'calcAmbDim' calculates the ambient dimensions.
'calcTanDim' calculates the number of tuples used to represent a tangent vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGeomPar(mfd, dimAmbient, dimIntrinsic, dimTangent)

calcIntDim(mfd, geomPar, dimAmbient, dimTangent)

calcAmbDim(mfd, geomPar, dimIntrinsic, dimTangent)

calcTanDim(mfd, geomPar, dimAmbient, dimIntrinsic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimensions_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="dimensions_+3A_dimambient">dimAmbient</code></td>
<td>
<p>Dimension of the ambient space.</p>
</td></tr>
<tr><td><code id="dimensions_+3A_dimintrinsic">dimIntrinsic</code></td>
<td>
<p>Intrinsic dimension of the manifold.</p>
</td></tr>
<tr><td><code id="dimensions_+3A_dimtangent">dimTangent</code></td>
<td>
<p>The length of a tangent vector</p>
</td></tr>
<tr><td><code id="dimensions_+3A_geompar">geomPar</code></td>
<td>
<p>The geometric parameter (e.g., SO(*))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value for the geometric parameter
</p>
<p>A scalar value for the intrinsic dimension
</p>
<p>A scalar value for the ambient dimension
</p>
<p>A scalar value for the number of components in the (implementation of the) tangent vector
</p>

<hr>
<h2 id='distance.Euclidean'>Geodesic distance</h2><span id='topic+distance.Euclidean'></span><span id='topic+distance'></span><span id='topic+distance.L2'></span><span id='topic+distance.HS'></span><span id='topic+distance.Dens'></span><span id='topic+distance.SO'></span><span id='topic+distance.LogEu'></span><span id='topic+distance.AffInv'></span><span id='topic+distance.Sphere'></span>

<h3>Description</h3>

<p>Geodesic distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
distance(mfd, X, Y, ...)

distance(mfd, X, Y, ...)

## S3 method for class 'L2'
distance(mfd, X, Y, ...)

## S3 method for class 'HS'
distance(mfd, X, Y, ...)

## S3 method for class 'Dens'
distance(mfd, X, Y, ...)

## S3 method for class 'SO'
distance(mfd, X, Y, ...)

## S3 method for class 'LogEu'
distance(mfd, X, Y, assumeLogRep = FALSE, ...)

## S3 method for class 'AffInv'
distance(mfd, X, Y, ...)

## S3 method for class 'Sphere'
distance(mfd, X, Y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="distance.Euclidean_+3A_x">X</code>, <code id="distance.Euclidean_+3A_y">Y</code></td>
<td>
<p>Matrices with n columns. The distance between each pair of columns is calculated. If either X or Y is a vector then it is recycled.</p>
</td></tr>
<tr><td><code id="distance.Euclidean_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
<tr><td><code id="distance.Euclidean_+3A_assumelogrep">assumeLogRep</code></td>
<td>
<p>Whether to assume the input are already the representations under the logarithm map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with n entries containing the distances between pairs of points
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>distance(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>distance(L2)</code>: Method
</p>
</li>
<li> <p><code>distance(HS)</code>: Method
</p>
</li>
<li> <p><code>distance(Dens)</code>: Method
</p>
</li>
<li> <p><code>distance(SO)</code>: Method
</p>
</li>
<li> <p><code>distance(LogEu)</code>: Method
</p>
</li>
<li> <p><code>distance(AffInv)</code>: Method
</p>
</li>
<li> <p><code>distance(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='ExpM'>Matrix exponential</h2><span id='topic+ExpM'></span>

<h3>Description</h3>

<p><code>ExpM(X)</code> computes the matrix exponential using Armardillo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpM(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpM_+3A_x">X</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix having the same size as the input
</p>

<hr>
<h2 id='frechetMean'>Calculate the Fréchet mean</h2><span id='topic+frechetMean'></span><span id='topic+frechetMean.default'></span>

<h3>Description</h3>

<p>Calculate the Fréchet mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechetMean(mfd, X, ...)

## Default S3 method:
frechetMean(
  mfd,
  X,
  mu0,
  weight = NULL,
  tol = 1e-09,
  maxit = 1000,
  lam = 0.99,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frechetMean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="frechetMean_+3A_x">X</code></td>
<td>
<p>A matrix with each column being a point on the manifold.</p>
</td></tr>
<tr><td><code id="frechetMean_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
<tr><td><code id="frechetMean_+3A_mu0">mu0</code></td>
<td>
<p>A matrix of starting points. Each column corresponds to a starting point. If there are multiple columns, then a multistart algorithm is used.</p>
</td></tr>
<tr><td><code id="frechetMean_+3A_weight">weight</code></td>
<td>
<p>A vector of weights for the observations</p>
</td></tr>
<tr><td><code id="frechetMean_+3A_tol">tol</code></td>
<td>
<p>The threshold for determining convergence</p>
</td></tr>
<tr><td><code id="frechetMean_+3A_maxit">maxit</code></td>
<td>
<p>Maximum iteration</p>
</td></tr>
<tr><td><code id="frechetMean_+3A_lam">lam</code></td>
<td>
<p>The step length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 1 column containing the Fréchet mean
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>frechetMean(default)</code>: Default method
</p>
</li></ul>

<hr>
<h2 id='frechetMedian'>Calculate the Fréchet median</h2><span id='topic+frechetMedian'></span><span id='topic+frechetMedian.default'></span>

<h3>Description</h3>

<p>Calculate the Fréchet median
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechetMedian(mfd, X, ...)

## Default S3 method:
frechetMedian(
  mfd,
  X,
  mu0,
  weight = NULL,
  tol = 1e-09,
  maxit = 1000,
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frechetMedian_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_x">X</code></td>
<td>
<p>A matrix with each column being a point on the manifold.</p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_mu0">mu0</code></td>
<td>
<p>A matrix of starting points. Each column corresponds to a starting point. If there are multiple columns, then a multistart algorithm is used.</p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_weight">weight</code></td>
<td>
<p>A vector of weights for the observations</p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_tol">tol</code></td>
<td>
<p>The threshold for determining convergence</p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_maxit">maxit</code></td>
<td>
<p>Maximum iteration</p>
</td></tr>
<tr><td><code id="frechetMedian_+3A_alpha">alpha</code></td>
<td>
<p>The step size parameter. See Fletcher et al. (2008) CVPR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 1 column containing the Fréchet median
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>frechetMedian(default)</code>: Default method
</p>
</li></ul>

<hr>
<h2 id='geodesicCurve'>Obtain the geodesic curve</h2><span id='topic+geodesicCurve'></span><span id='topic+geodesicCurve.HS'></span><span id='topic+geodesicCurve.Sphere'></span>

<h3>Description</h3>

<p>Obtain the geodesic curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesicCurve(mfd, p, h, t)

## S3 method for class 'HS'
geodesicCurve(mfd, p, h, t)

## S3 method for class 'Sphere'
geodesicCurve(mfd, p, h, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodesicCurve_+3A_mfd">mfd</code></td>
<td>
<p>A class instance that represents the Riemannian manifold</p>
</td></tr>
<tr><td><code id="geodesicCurve_+3A_p">p</code></td>
<td>
<p>The starting point of the geodesic curve</p>
</td></tr>
<tr><td><code id="geodesicCurve_+3A_h">h</code></td>
<td>
<p>A matrix with each column representing a tangent vector. If there is only one tangent vector is supplied, then it is replicated to match the length of <em>t</em></p>
</td></tr>
<tr><td><code id="geodesicCurve_+3A_t">t</code></td>
<td>
<p>A vector, the time points where the curve is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The curve is <code class="reqn">\gamma(t)=\mathrm{Exp}_p(th)</code>
</p>


<h3>Value</h3>

<p>A matrix of points lying on a geodesic. Different columns correspond to different time points
</p>
<p>A matrix with each column representing a point on the manifold
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>geodesicCurve(HS)</code>: Method
</p>
</li>
<li> <p><code>geodesicCurve(Sphere)</code>: Geodesic curve stating at a point
</p>
</li></ul>

<hr>
<h2 id='GetSettingName'>Helper function for simulations</h2><span id='topic+GetSettingName'></span>

<h3>Description</h3>

<p>Get the name of the settings from a named list good for saving into a data frame or use as file name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSettingName(settings, digits = 3, display = c("short", "pretty", "tiny"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetSettingName_+3A_settings">settings</code></td>
<td>
<p>A named list. The names corresponding to the setting parameter names, and the values are the parameter values</p>
</td></tr>
<tr><td><code id="GetSettingName_+3A_digits">digits</code></td>
<td>
<p>How many digits to use to format the numerical values</p>
</td></tr>
<tr><td><code id="GetSettingName_+3A_display">display</code></td>
<td>
<p>Which version of the setting name to produce</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of setting names
</p>

<hr>
<h2 id='is.finiteDim'>Tell whether a manifold is a finite-dimensional one</h2><span id='topic+is.finiteDim'></span>

<h3>Description</h3>

<p>Tell whether a manifold is a finite-dimensional one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.finiteDim(mfd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.finiteDim_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar indicating whether the manifold is finite-dimensional
</p>

<hr>
<h2 id='listAvailMfd'>List all available manifold names</h2><span id='topic+listAvailMfd'></span>

<h3>Description</h3>

<p>List all available manifold names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listAvailMfd()
</code></pre>


<h3>Value</h3>

<p>A character vector of the names of available manifolds
</p>

<hr>
<h2 id='LogM'>Matrix logarithm</h2><span id='topic+LogM'></span>

<h3>Description</h3>

<p><code>LogM(X)</code> computes the matrix logarithm of a general matrix using Armardillo. The returned value is a complex matrix but converted into a real one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogM(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogM_+3A_x">X</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix having the same size as the input
</p>

<hr>
<h2 id='LogMSPD'>Matrix logarithm of a symmetric positive definite</h2><span id='topic+LogMSPD'></span>

<h3>Description</h3>

<p><code>LogMSPD(X)</code> computes the matrix logarithm of an SPD matrix using Armardillo. The returned value is a real matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogMSPD(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogMSPD_+3A_x">X</code></td>
<td>
<p>An SPD matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix
</p>

<hr>
<h2 id='MakeSym'>Make a symmetric matrix by specifying a near-symmetric matrix M, or the lower triangular elements lowerTri with diagonal.</h2><span id='topic+MakeSym'></span>

<h3>Description</h3>

<p>Make a symmetric matrix by specifying a near-symmetric matrix M, or the lower triangular elements lowerTri with diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeSym(M, lowerTri, doubleDiag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeSym_+3A_m">M</code></td>
<td>
<p>A near-symmetric matrix</p>
</td></tr>
<tr><td><code id="MakeSym_+3A_lowertri">lowerTri</code></td>
<td>
<p>A vector containing the lower triangular elements of the matrix. This is an alternative way to specify the matrix.</p>
</td></tr>
<tr><td><code id="MakeSym_+3A_doublediag">doubleDiag</code></td>
<td>
<p>Only meaningful for lowerTri is not missing. Whether the diagonal elements should be multiplied by sqrt(2) for doubling the squared norm of the lower triangle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix
</p>

<hr>
<h2 id='manifold'>manifold: Operations for Riemannian manifolds</h2><span id='topic+manifold'></span>

<h3>Description</h3>

<p>Implements operations for Riemannian manifolds, e.g., geodesic distance, Riemannian metric, exponential and logarithm maps, etc. Also incorporates random object generator on the manifolds
</p>


<h3>Details</h3>

<p>References: 
Dai X, Lin Z, Müller HG. Modeling sparse longitudinal data on Riemannian manifolds. Biometrics. 2021;77(4):1328–41. 
Dai X, Lopez-Pintado S. Tukey’s depth for object data. Journal of the American Statistical Association. 2021;In press. 
</p>
<p>Maintainer:  Xiongtao Dai <a href="mailto:xdai@berkeley.edu">xdai@berkeley.edu</a>
</p>


<h3>Author(s)</h3>

<p>Xiongtao Dai <a href="mailto:xdai@berkeley.edu">xdai@berkeley.edu</a>
Zhenhua Lin
</p>

<hr>
<h2 id='metric.Euclidean'>Returns the Riemannian metric</h2><span id='topic+metric.Euclidean'></span><span id='topic+metric'></span><span id='topic+metric.default'></span><span id='topic+metric.HS'></span><span id='topic+metric.Dens'></span><span id='topic+metric.SO'></span><span id='topic+metric.LogEu'></span><span id='topic+metric.AffInv'></span><span id='topic+metric.Sphere'></span>

<h3>Description</h3>

<p>Returns the Riemannian metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
metric(mfd, p, U, V)

metric(mfd, p, U, V)

## Default S3 method:
metric(mfd, p = NULL, U, V)

## S3 method for class 'HS'
metric(mfd, p, U, V)

## S3 method for class 'Dens'
metric(mfd, p, U, V)

## S3 method for class 'SO'
metric(mfd, p, U, V)

## S3 method for class 'LogEu'
metric(mfd, p, U, V)

## S3 method for class 'AffInv'
metric(mfd, p, U, V)

## S3 method for class 'Sphere'
metric(mfd, p, U, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="metric.Euclidean_+3A_p">p</code></td>
<td>
<p>A vector containing the (single) base point on the manifold.</p>
</td></tr>
<tr><td><code id="metric.Euclidean_+3A_u">U</code>, <code id="metric.Euclidean_+3A_v">V</code></td>
<td>
<p>Matrices with n columns each containing a tangent vector. The metric of each pair of n columns is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with n entries containing the metric values
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>metric(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>metric(default)</code>: Method
</p>
</li>
<li> <p><code>metric(HS)</code>: Method
</p>
</li>
<li> <p><code>metric(Dens)</code>: Method
</p>
</li>
<li> <p><code>metric(SO)</code>: Method
</p>
</li>
<li> <p><code>metric(LogEu)</code>: Method
</p>
</li>
<li> <p><code>metric(AffInv)</code>: Method
</p>
</li>
<li> <p><code>metric(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='norm.Euclidean'>Norm on the tangent space induced by the Riemannian metric</h2><span id='topic+norm.Euclidean'></span><span id='topic+norm'></span><span id='topic+norm.default'></span><span id='topic+norm.L2'></span><span id='topic+norm.HS'></span><span id='topic+norm.Dens'></span><span id='topic+norm.SO'></span><span id='topic+norm.LogEu'></span><span id='topic+norm.AffInv'></span><span id='topic+norm.Sphere'></span>

<h3>Description</h3>

<p>Norm on the tangent space induced by the Riemannian metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
norm(mfd, p, U)

norm(mfd, p, U)

## Default S3 method:
norm(mfd, p = NULL, U)

## S3 method for class 'L2'
norm(mfd, p, U)

## S3 method for class 'HS'
norm(mfd, p, U)

## S3 method for class 'Dens'
norm(mfd, p, U)

## S3 method for class 'SO'
norm(mfd, p, U)

## S3 method for class 'LogEu'
norm(mfd, p, U)

## S3 method for class 'AffInv'
norm(mfd, p, U)

## S3 method for class 'Sphere'
norm(mfd, p, U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="norm.Euclidean_+3A_p">p</code>, <code id="norm.Euclidean_+3A_u">U</code></td>
<td>
<p>Matrices with n columns. p stands for the base point(s) and U the tangent vector(s). The norm of each column in U is calculated w.r.t. the corresponding column in p.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with n entries containing the norms of the tangent vectors
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>norm(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>norm(default)</code>: Method
</p>
</li>
<li> <p><code>norm(L2)</code>: Method
</p>
</li>
<li> <p><code>norm(HS)</code>: Method
</p>
</li>
<li> <p><code>norm(Dens)</code>: Method
</p>
</li>
<li> <p><code>norm(SO)</code>: Method
</p>
</li>
<li> <p><code>norm(LogEu)</code>: Method
</p>
</li>
<li> <p><code>norm(AffInv)</code>: Method
</p>
</li>
<li> <p><code>norm(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='Normalize'>Normalize a vector</h2><span id='topic+Normalize'></span>

<h3>Description</h3>

<p>Normalize a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalize(v, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalize_+3A_v">v</code></td>
<td>
<p>A vector to be normalized to have a unit norm</p>
</td></tr>
<tr><td><code id="Normalize_+3A_tol">tol</code></td>
<td>
<p>The tolerance value for deciding the v is actually 0, cannot be normalized, and thus return just the 0 vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same length as 'v' but having unit Euclidean norm
</p>

<hr>
<h2 id='origin.Euclidean'>Returns the origin of the manifold</h2><span id='topic+origin.Euclidean'></span><span id='topic+origin'></span><span id='topic+origin.L2'></span><span id='topic+origin.HS'></span><span id='topic+origin.Dens'></span><span id='topic+origin.SO'></span><span id='topic+origin.SPD'></span><span id='topic+origin.Sphere'></span>

<h3>Description</h3>

<p>Each manifold defined in this package has been designated a more or less reasonable choice of origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
origin(mfd, dimIntrinsic, ...)

origin(mfd, dimIntrinsic, ...)

## S3 method for class 'L2'
origin(mfd, dimIntrinsic, ...)

## S3 method for class 'HS'
origin(mfd, dimIntrinsic, ...)

## S3 method for class 'Dens'
origin(mfd, dimIntrinsic, ...)

## S3 method for class 'SO'
origin(mfd, dimIntrinsic, ...)

## S3 method for class 'SPD'
origin(mfd, dimIntrinsic, ...)

## S3 method for class 'Sphere'
origin(mfd, dimIntrinsic, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="origin.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="origin.Euclidean_+3A_dimintrinsic">dimIntrinsic</code></td>
<td>
<p>An integer for the intrinsic dimension</p>
</td></tr>
<tr><td><code id="origin.Euclidean_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 1 column, a designation of the origin on the manifold
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>origin(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>origin(L2)</code>: Method
</p>
</li>
<li> <p><code>origin(HS)</code>: Method
</p>
</li>
<li> <p><code>origin(Dens)</code>: The uniform density
</p>
</li>
<li> <p><code>origin(SO)</code>: The origin has 1 in the first ambient coordinate and 0 otherwise.
</p>
</li>
<li> <p><code>origin(SPD)</code>: The origin is the identity matrix but vectorized.
</p>
</li>
<li> <p><code>origin(Sphere)</code>: The origin has 1 in the first ambient coordinate and 0 otherwise.
</p>
</li></ul>

<hr>
<h2 id='project.Euclidean'>Project data points in the ambient space onto the manifold</h2><span id='topic+project.Euclidean'></span><span id='topic+project'></span><span id='topic+project.L2'></span><span id='topic+project.HS'></span><span id='topic+project.Dens'></span><span id='topic+project.SO'></span><span id='topic+project.AffInv'></span><span id='topic+project.LogEu'></span><span id='topic+project.SPD'></span><span id='topic+project.Sphere'></span>

<h3>Description</h3>

<p>Project data points in the ambient space onto the manifold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
project(mfd, p)

project(mfd, p)

## S3 method for class 'L2'
project(mfd, p)

## S3 method for class 'HS'
project(mfd, p)

## S3 method for class 'Dens'
project(mfd, p)

## S3 method for class 'SO'
project(mfd, p)

## S3 method for class 'AffInv'
project(mfd, p)

## S3 method for class 'LogEu'
project(mfd, p)

## S3 method for class 'SPD'
project(mfd, p)

## S3 method for class 'Sphere'
project(mfd, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="project.Euclidean_+3A_p">p</code></td>
<td>
<p>A matrix of points to be projected to the manifold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which columns correspond to points on the manifold
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>project(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>project(L2)</code>: Method
</p>
</li>
<li> <p><code>project(HS)</code>: Method
</p>
</li>
<li> <p><code>project(Dens)</code>: Method
</p>
</li>
<li> <p><code>project(SO)</code>: Method
</p>
</li>
<li> <p><code>project(AffInv)</code>: Method
</p>
</li>
<li> <p><code>project(LogEu)</code>: Method
</p>
</li>
<li> <p><code>project(SPD)</code>: Method
</p>
</li>
<li> <p><code>project(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='projectTangent.Euclidean'>Project data points in the ambient space onto the tangent space</h2><span id='topic+projectTangent.Euclidean'></span><span id='topic+projectTangent'></span><span id='topic+projectTangent.L2'></span><span id='topic+projectTangent.HS'></span><span id='topic+projectTangent.Dens'></span><span id='topic+projectTangent.SO'></span><span id='topic+projectTangent.SPD'></span><span id='topic+projectTangent.Sphere'></span>

<h3>Description</h3>

<p>Project data points in the ambient space onto the tangent space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
projectTangent(mfd, p, X, projMatOnly = FALSE, ...)

projectTangent(mfd, p, X, projMatOnly, ...)

## S3 method for class 'L2'
projectTangent(mfd, p, X, projMatOnly = FALSE, ...)

## S3 method for class 'HS'
projectTangent(mfd, p, X, projMatOnly = FALSE, ...)

## S3 method for class 'Dens'
projectTangent(mfd, p, X, projMatOnly, ...)

## S3 method for class 'SO'
projectTangent(mfd, p, X, projMatOnly = FALSE, ...)

## S3 method for class 'SPD'
projectTangent(mfd, p, X, projMatOnly = FALSE, ...)

## S3 method for class 'Sphere'
projectTangent(mfd, p, X, projMatOnly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectTangent.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="projectTangent.Euclidean_+3A_p">p</code></td>
<td>
<p>A vector containing the base point on the manifold. Data X will be projected onto the tangent space of p.</p>
</td></tr>
<tr><td><code id="projectTangent.Euclidean_+3A_x">X</code></td>
<td>
<p>A vector or a matrix containing the data points in terms of the coordinates in the ambient space.</p>
</td></tr>
<tr><td><code id="projectTangent.Euclidean_+3A_projmatonly">projMatOnly</code></td>
<td>
<p>Whether to only return the projection matrix (FALSE) or the projected data points (TRUE, the default)</p>
</td></tr>
<tr><td><code id="projectTangent.Euclidean_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which columns correspond to points on the tangent spaces
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>projectTangent(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>projectTangent(L2)</code>: Method
</p>
</li>
<li> <p><code>projectTangent(HS)</code>: Method
</p>
</li>
<li> <p><code>projectTangent(Dens)</code>: Method
</p>
</li>
<li> <p><code>projectTangent(SO)</code>: Method
</p>
</li>
<li> <p><code>projectTangent(SPD)</code>: Method
</p>
</li>
<li> <p><code>projectTangent(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='rieExp.Euclidean'>Riemannian exponential map</h2><span id='topic+rieExp.Euclidean'></span><span id='topic+rieExp'></span><span id='topic+rieExp.L2'></span><span id='topic+rieExp.HS'></span><span id='topic+rieExp.Dens'></span><span id='topic+rieExp.SO'></span><span id='topic+rieExp.LogEu'></span><span id='topic+rieExp.AffInv'></span><span id='topic+rieExp.Sphere'></span>

<h3>Description</h3>

<p>Riemannian exponential map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
rieExp(mfd, p, V, ...)

rieExp(mfd, p, V, ...)

## S3 method for class 'L2'
rieExp(mfd, p, V, ...)

## S3 method for class 'HS'
rieExp(mfd, p, V, ...)

## S3 method for class 'Dens'
rieExp(mfd, p, V, ...)

## S3 method for class 'SO'
rieExp(mfd, p, V, tol = 1e-10, ...)

## S3 method for class 'LogEu'
rieExp(mfd, p, V, ...)

## S3 method for class 'AffInv'
rieExp(mfd, p, V, ...)

## S3 method for class 'Sphere'
rieExp(mfd, p, V, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rieExp.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="rieExp.Euclidean_+3A_p">p</code>, <code id="rieExp.Euclidean_+3A_v">V</code></td>
<td>
<p>Matrices with n columns. The exponential map of each column in V is calculated w.r.t. the corresponding column in p.</p>
</td></tr>
<tr><td><code id="rieExp.Euclidean_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
<tr><td><code id="rieExp.Euclidean_+3A_tol">tol</code></td>
<td>
<p>Tolerance for 'rieExp.SO'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which columns correspond to points on the manifold
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>rieExp(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>rieExp(L2)</code>: Method
</p>
</li>
<li> <p><code>rieExp(HS)</code>: Method
</p>
</li>
<li> <p><code>rieExp(Dens)</code>: Method
</p>
</li>
<li> <p><code>rieExp(SO)</code>: Method
</p>
</li>
<li> <p><code>rieExp(LogEu)</code>: Method
</p>
</li>
<li> <p><code>rieExp(AffInv)</code>: Method
</p>
</li>
<li> <p><code>rieExp(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='rieLog.Euclidean'>Riemannian logarithm map</h2><span id='topic+rieLog.Euclidean'></span><span id='topic+rieLog'></span><span id='topic+rieLog.L2'></span><span id='topic+rieLog.HS'></span><span id='topic+rieLog.Dens'></span><span id='topic+rieLog.SO'></span><span id='topic+rieLog.LogEu'></span><span id='topic+rieLog.AffInv'></span><span id='topic+rieLog.Sphere'></span>

<h3>Description</h3>

<p>Riemannian logarithm map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Euclidean'
rieLog(mfd, p, X, ...)

rieLog(mfd, p, X, ...)

## S3 method for class 'L2'
rieLog(mfd, p, X, ...)

## S3 method for class 'HS'
rieLog(mfd, p, X, tol = 1e-07, ...)

## S3 method for class 'Dens'
rieLog(mfd, p, X, ...)

## S3 method for class 'SO'
rieLog(mfd, p, X, tol = 1e-10, ...)

## S3 method for class 'LogEu'
rieLog(mfd, p, X, ...)

## S3 method for class 'AffInv'
rieLog(mfd, p, X, ...)

## S3 method for class 'Sphere'
rieLog(mfd, p, X, tol = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rieLog.Euclidean_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="rieLog.Euclidean_+3A_p">p</code>, <code id="rieLog.Euclidean_+3A_x">X</code></td>
<td>
<p>Matrices with n columns. The logarithm map of each column in X is calculated w.r.t. the corresponding column in p.</p>
</td></tr>
<tr><td><code id="rieLog.Euclidean_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
<tr><td><code id="rieLog.Euclidean_+3A_tol">tol</code></td>
<td>
<p>Tolerance for 'rieLog.SO'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which columns correspond to points on the tangent spaces
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>rieLog(Euclidean)</code>: Method
</p>
</li>
<li> <p><code>rieLog(L2)</code>: Method
</p>
</li>
<li> <p><code>rieLog(HS)</code>: Method
</p>
</li>
<li> <p><code>rieLog(Dens)</code>: Method
</p>
</li>
<li> <p><code>rieLog(SO)</code>: Method
</p>
</li>
<li> <p><code>rieLog(LogEu)</code>: Method
</p>
</li>
<li> <p><code>rieLog(AffInv)</code>: Method
</p>
</li>
<li> <p><code>rieLog(Sphere)</code>: Method
</p>
</li></ul>

<hr>
<h2 id='rmfd'>Generate random variables on the manifold</h2><span id='topic+rmfd'></span><span id='topic+rmfd.default'></span>

<h3>Description</h3>

<p>By default, random variables are generated by mapping isotropic Gaussian distributions on the tangent space back to the manifold using the exponential map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmfd(mfd, n, dimIntrinsic, ...)

## Default S3 method:
rmfd(
  mfd,
  n,
  dimIntrinsic,
  p,
  dist = c("norm", "unif", "exp"),
  totalVar = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmfd_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="rmfd_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="rmfd_+3A_dimintrinsic">dimIntrinsic</code></td>
<td>
<p>The intrinsic dimension of the target manifold</p>
</td></tr>
<tr><td><code id="rmfd_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
<tr><td><code id="rmfd_+3A_p">p</code></td>
<td>
<p>Optionally, specify the base point of the tangent space, on which random tangent vectors will be generated. Default to the origin of 'mfd'.</p>
</td></tr>
<tr><td><code id="rmfd_+3A_dist">dist</code></td>
<td>
<p>Either a string or a function, describing the distributions. If it is character, then independent univariate r.v. following that distribution with total variance 1 is generated on the tangent space. If it is a function, it should specify the generation of the samples on the tangent space _coordinates_ (with dimension dimIntrinsic), and it must return a matrix for which the columns are the coordinates. Then it will be mapped to the tangent space at the origin and then to the manifold.</p>
</td></tr>
<tr><td><code id="rmfd_+3A_totalvar">totalVar</code></td>
<td>
<p>Total variance (sum of diagonal of the covariance matrix) of the tangent random vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with n columns, each containing a random sample on the manifold
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>rmfd(default)</code>: Default method
</p>
</li></ul>

<hr>
<h2 id='runifSphere'>Generate uniform random variables on the unit sphere</h2><span id='topic+runifSphere'></span>

<h3>Description</h3>

<p>Generate uniform random variables on the unit sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifSphere(n, dimAmbient)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifSphere_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="runifSphere_+3A_dimambient">dimAmbient</code></td>
<td>
<p>The dimension of the ambient space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'dimAmbient' by 'n' matrix. Each column is a random observation
</p>

<hr>
<h2 id='tanVToCoord'>Transform tangent vectors to their coordinates on the tangent space</h2><span id='topic+tanVToCoord'></span><span id='topic+tanVToCoord.default'></span>

<h3>Description</h3>

<p>Transform the tangent vectors to coordinates w.r.t. the basis returned by [basisTan()]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tanVToCoord(mfd, p, V, ...)

## Default S3 method:
tanVToCoord(mfd, p, V, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tanVToCoord_+3A_mfd">mfd</code></td>
<td>
<p>A manifold object created by <code><a href="#topic+createM">createM</a></code></p>
</td></tr>
<tr><td><code id="tanVToCoord_+3A_p">p</code></td>
<td>
<p>A vector for the base point</p>
</td></tr>
<tr><td><code id="tanVToCoord_+3A_v">V</code></td>
<td>
<p>A matrix or a vector containing the tangent vectors</p>
</td></tr>
<tr><td><code id="tanVToCoord_+3A_...">...</code></td>
<td>
<p>Passed into specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which each column correspond to a coordinate
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tanVToCoord(default)</code>: Method
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
