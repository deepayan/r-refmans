<!DOCTYPE html><html><head><title>Help for package geostatsp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geostatsp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conditionalGmrf'>
<p>Conditional distribution of GMRF</p></a></li>
<li><a href='#excProb'>
<p>Exceedance probabilities</p></a></li>
<li><a href='#gambiaUTM'>
<p>Gambia data</p></a></li>
<li><a href='#glgm-methods'>
<p>Generalized Linear Geostatistical Models</p></a></li>
<li><a href='#inla.models'>
<p>Valid models in INLA</p></a></li>
<li><a href='#krigeLgm'>
<p>Spatial prediction, or Kriging</p></a></li>
<li><a href='#lgm-methods'>
<p>Linear Geostatistical Models</p></a></li>
<li><a href='#likfitLgm'><p>Likelihood Based Parameter Estimation for Gaussian Random Fields</p></a></li>
<li><a href='#loaloa'>
<p>Loaloa prevalence data from 197 village surveys</p></a></li>
<li><a href='#matern'><p>Evaluate the Matern correlation function</p></a></li>
<li><a href='#maternGmrfPrec'><p>Precision matrix for a Matern spatial correlation</p></a></li>
<li><a href='#murder'>
<p>Murder locations</p></a></li>
<li><a href='#pcPriorRange'>
<p>PC prior for range parameter</p></a></li>
<li><a href='#postExp'><p>Exponentiate posterior quantiles</p></a></li>
<li><a href='#profLlgm'>
<p>Joint confidence regions</p></a></li>
<li><a href='#RFsimulate'><p>Simulation of Random Fields</p></a></li>
<li><a href='#rongelapUTM'>
<p>Rongelap data</p></a></li>
<li><a href='#simLgcp'><p>Simulate a log-Gaussian Cox process</p></a></li>
<li><a href='#spatialRoc'>
<p>Sensitivity and specificity</p></a></li>
<li><a href='#squareRaster-methods'><p>Create a raster with square cells</p></a></li>
<li><a href='#stackRasterList'>
<p>Converts a list of rasters, possibly with different projections and resolutions, to a single raster stack.</p></a></li>
<li><a href='#swissRain'>
<p>Swiss rainfall data</p></a></li>
<li><a href='#swissRainR'>
<p>Raster of Swiss rain data</p></a></li>
<li><a href='#variog'><p>Compute Empirical Variograms and Permutation Envelopes</p></a></li>
<li><a href='#wheat'>
<p>Mercer and Hall wheat yield data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geostatistical Modelling with Likelihood and Bayes</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, terra, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, numDeriv, methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RandomFields, parallel, mapmisc, ellipse, pracma, knitr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>INLA, diseasemapping, geoR, mvtnorm</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Matrix (&ge; 1.6-2)</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Geostatistical modelling facilities using 'SpatRaster' and 'SpatVector'
    objects are provided. Non-Gaussian models are fit using 'INLA', and Gaussian
    geostatistical models use Maximum Likelihood Estimation.  For details see Brown (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v063.i12">doi:10.18637/jss.v063.i12</a>&gt;. The 'RandomFields' package is available at <a href="https://www.wim.uni-mannheim.de/schlather/publications/software">https://www.wim.uni-mannheim.de/schlather/publications/software</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 15:28:43 UTC; patrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Brown [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Brown &lt;patrick.brown@utoronto.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 22:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='conditionalGmrf'>
Conditional distribution of GMRF
</h2><span id='topic+conditionalGmrf'></span>

<h3>Description</h3>

<p>Distribution of Gaussian Markov Random Field conditional on data observed with noise on the same grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditionalGmrf(param, Yvec, Xmat, NN, 
	template = NULL, mc.cores = 1, 
	cellsPerLoop = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditionalGmrf_+3A_param">param</code></td>
<td>

<p>vector of named parameters
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_yvec">Yvec</code></td>
<td>

<p>vector of observed data, or matrix with each column being a realisation.
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_xmat">Xmat</code></td>
<td>

<p>Matrix of covariates.
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_nn">NN</code></td>
<td>

<p>nearest neighbour matrix
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_template">template</code></td>
<td>

<p>Raster on which the GMRF is defined
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_mc.cores">mc.cores</code></td>
<td>

<p>passed to <code><a href="parallel.html#topic+parallel-package">mclapply</a></code>
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_cellsperloop">cellsPerLoop</code></td>
<td>

<p>number of cells to compute simultaneously.  Larger values consume more memory but 
result in faster computation.
</p>
</td></tr>
<tr><td><code id="conditionalGmrf_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code><a href="#topic+maternGmrfPrec">maternGmrfPrec</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster image with layers containing conditional mean and standard deviation.
</p>


<h3>Author(s)</h3>

<p>Patrick Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maternGmrfPrec">maternGmrfPrec</a></code>, <code><a href="#topic+lgm">lgm</a></code>
</p>

<hr>
<h2 id='excProb'>
Exceedance probabilities
</h2><span id='topic+excProb'></span>

<h3>Description</h3>

<p>Calculate exceedance probabilities pr(X &gt; threshold) from a fitted geostatistical model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>excProb(x, threshold=0, random=FALSE, template=NULL, templateIdCol=NULL,
nuggetInPrediction=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excProb_+3A_x">x</code></td>
<td>
<p>Output from either the <code>lgm</code> or <code>glgm</code> functions, or
a list of two-column matrices with columns named <code>x</code> and <code>y</code> containing the 
posterior distributions of random effects, as produced by <code>inla</code>.
</p>
</td></tr>
<tr><td><code id="excProb_+3A_threshold">threshold</code></td>
<td>
<p> the value which the exceedance probability is calculated with respect to.
</p>
</td></tr>
<tr><td><code id="excProb_+3A_random">random</code></td>
<td>
<p>Calculate exceedances for the random effects, rather than the
predicted observations (including fixed effects). </p>
</td></tr>
<tr><td><code id="excProb_+3A_template">template</code></td>
<td>
<p>A <code>SpatRaster</code> or <code>SpatVector</code>
object which the results will be contained in.
</p>
</td></tr>
<tr><td><code id="excProb_+3A_templateidcol">templateIdCol</code></td>
<td>
<p>The data column in <code>template</code> corresponding to names of <code>marginals</code>
</p>
</td></tr>
<tr><td><code id="excProb_+3A_nuggetinprediction">nuggetInPrediction</code></td>
<td>
<p>If <code>TRUE</code>, calculate exceedance probabilities of new observations by adding the 
nugget effect. Otherwise calculate probabilities for the latent process.  Ignored if <code>x</code> is output from <code>glgm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is the output from <code><a href="#topic+lgm">lgm</a></code>, pr(Y&gt;threshold) is calculated using
the Gaussian distribution using the Kriging mean and conditional variance.  When
<code>x</code> is from the <code>glgm</code> function, 
the marginal posteriors are numerically integrated to obtain pr(X &gt; threshold).
</p>


<h3>Value</h3>

<p>Either a vector of exceedance probabilities or an object of the same class as <code>template</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data('swissRain')
	swissRain = unwrap(swissRain)
	swissAltitude = unwrap(swissAltitude)
	swissBorder = unwrap(swissBorder)
	swissFit =  lgm("rain", swissRain, grid=30, 
		boxcox=0.5,fixBoxcox=TRUE,	covariates=swissAltitude)
	swissExc = excProb(swissFit, 20)
	mycol = c("green","yellow","orange","red")
	mybreaks = c(0, 0.2, 0.8, 0.9, 1)
	plot(swissBorder)
	plot(swissExc, breaks=mybreaks, col=mycol,add=TRUE,legend=FALSE)
	plot(swissBorder, add=TRUE)
	legend("topleft",legend=mybreaks, col=c(NA,mycol))



if(requireNamespace("INLA", quietly=TRUE) ) {
  INLA::inla.setOption(num.threads=2)
  # not all versions of INLA support blas.num.threads
  try(INLA::inla.setOption(blas.num.threads=2), silent=TRUE)

	swissRain$sqrtrain = sqrt(swissRain$rain)
	swissFit2 =  glgm(formula="sqrtrain",data=swissRain, grid=40, 
	covariates=swissAltitude,family="gaussian")
	swissExc = excProb(swissFit2, threshold=sqrt(30))
	swissExc = excProb(swissFit2$inla$marginals.random$space, 0,
		template=swissFit2$raster)
	
}



</code></pre>

<hr>
<h2 id='gambiaUTM'>
Gambia data
</h2><span id='topic+gambiaUTM'></span>

<h3>Description</h3>

<p>This data-set was used by Diggle, Moyeed, Rowlingson, and Thomson (2002) to demonstrate 
how the model-based geostatistics framework of Diggle et al. (1998) could be adapted to 
assess the source(s) of extrabinomial variation in the data and, in particular, whether this 
variation was spatially structured. The malaria prevalence data set consists of measurements 
of the presence of malarial parasites in blood samples obtained from children in 65 villages 
in the Gambia. Other child- and village-level indicators include age, bed net use, whether the
bed net is treated, whether or not the village belonged to the primary health care structure,
and a measure of 'greenness' using a vegetation index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gambiaUTM)</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> , with column <code>pos</code> being the binary response for a malaria 
diagnosis, as well as other child-level indicators such as <code>netuse</code> and <code>treated</code> 
being measures of bed net use and whether the nets were treated. The column <code>green</code> is 
a village-level measure of greenness. A UTM coordinate reference system is used, where 
coordinates are in metres.
</p>


<h3>Source</h3>

<p><a href="http://www.leg.ufpr.br/doku.php/pessoais:paulojus:mbgbook:datasets">http://www.leg.ufpr.br/doku.php/pessoais:paulojus:mbgbook:datasets</a>.  For further details 
on the malaria data, see Thomson et al. (1999).
</p>


<h3>References</h3>

<p>Diggle, P. J., Moyeed, R. A., Rowlingson, R. and Thomson, M. (2002). Childhood Malaria in 
the Gambia: A case-study in model-based geostatistics. Journal of the Royal Statistical 
Society. Series C (Applied Statistics), 51(4): 493-506.
</p>
<p>Diggle, P. J., Tawn, J. A. and Moyeed, R. A. (1998). Model-based
geostatistics (with Discussion). Applied Statistics,
47, 299&ndash;350.
</p>
<p>Thomson, M. C., Connor, S. J., D'Alessandro, U., Rowlingson, B., Diggle, P., Creswell, 
M. and Greenwood, B. (2004). Predicting malaria infection in Gambian children from 
satellite data and bed net use surveys: the importance of spatial correlation in the 
interpretation of results. American Journal of Tropical Medicine and Hygiene, 61: 2-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("gambiaUTM")
gambiaUTM = unwrap(gambiaUTM)

plot(gambiaUTM, main="gambia data")

if(require('mapmisc', quietly=TRUE)) {
  gambiaTiles = openmap(gambiaUTM, zoom=6, buffer=50*1000)
  oldpar=map.new(gambiaTiles)
  plot(gambiaTiles, add=TRUE)
  plot(gambiaUTM, add=TRUE)
  scaleBar(gambiaUTM, 'topright')

  par(oldpar)
}

</code></pre>

<hr>
<h2 id='glgm-methods'>
Generalized Linear Geostatistical Models
</h2><span id='topic+glgm'></span><span id='topic+glgm-methods'></span><span id='topic+glgm+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+glgm+2Cformula+2CSpatRaster+2CANY+2CANY-method'></span><span id='topic+glgm+2Cformula+2CSpatVector+2CANY+2CANY-method'></span><span id='topic+glgm+2Cformula+2Cdata.frame+2CSpatRaster+2Cdata.frame-method'></span><span id='topic+lgcp'></span>

<h3>Description</h3>

<p>Fits a generalized linear geostatistical model or a log-Gaussian Cox process
using <code>inla</code> </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,ANY,ANY,ANY'
glgm(formula, data,  grid, covariates, buffer=0, shape=1, prior, ...) 
## S4 method for signature 'formula,SpatRaster,ANY,ANY'
glgm(formula, data,  grid, covariates, buffer=0, shape=1, prior, ...) 
## S4 method for signature 'formula,SpatVector,ANY,ANY'
glgm(formula, data,  grid, covariates, buffer=0, shape=1, prior, ...) 
## S4 method for signature 'formula,data.frame,SpatRaster,data.frame'
glgm(formula, data,  grid, covariates, buffer=0, shape=1, prior, ...) 
lgcp(formula=NULL, data,  grid, covariates=NULL, border, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glgm-methods_+3A_data">data</code></td>
<td>

<p>An object of class <code> SpatVector</code> containing the data.
</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_grid">grid</code></td>
<td>
<p>Either an integer giving the number of cells in the x direction, or a raster object which 
will be used for the spatial random effect.  If the cells in the raster are not square, the resolution in the y direction 
will be adjusted to make it so.</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_covariates">covariates</code></td>
<td>
<p>Either a single raster, a list of rasters or a raster stack containing covariate values used when 
making spatial predictions.  Names of the raster layers or list elements correspond to names in the formula.  If
a covariate is missing from the data object it will be extracted from the rasters.  Defaults to <code>NULL</code> for an 
intercept-only model.
</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_formula">formula</code></td>
<td>
<p>Model formula, defaults to a linear combination of each of the layers in the <code>covariates</code> object.   
The spatial random effect should not be supplied but the default 
can be overridden with a 
<code> f(space,..)</code> term. For <code>glgm</code> the response variable defaults to the first variable in the <code>data</code> object, and
<code>formula</code> can be an integer or character string specifying the response variable.  For <code>lgcp</code>, the formula
should be one-sided.
</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_prior">prior</code></td>
<td>
<p>list with elements named <code>range</code>, <code>sd</code>, <code>sdObs</code>.  See Details.</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for the Matern correlation function, must be 1 or 2.</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_buffer">buffer</code></td>
<td>
<p>Extra space padded around the data bounding box to reduce edge effects.</p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_border">border</code></td>
<td>
<p>boundary of the region on which an LGCP is defined, passed to <code><a href="terra.html#topic+mask">mask</a></code></p>
</td></tr>
<tr><td><code id="glgm-methods_+3A_...">...</code></td>
<td>
<p>Additional options passed to  
<code><a href="INLA.html#topic+inla">inla</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Bayesian inference for generalized linear geostatistical models with INLA.  The Markov random field
approximation on a regular lattice is used for the spatial random effect.  The range parameter is the distance at which 
the correlation is 0.13, or
</p>
<p style="text-align: center;"><code class="reqn">cov[U(s+h), U(s)] = (2^{1-\nu}/Gamma(\nu))  d^\nu besselK(d, \nu) </code>
</p>
 
<p style="text-align: center;"><code class="reqn">d= |h| \sqrt{8 \nu}/range</code>
</p>

<p>where <code class="reqn">\nu</code> is the shape parameter. The range parameter produced by <code>glgm</code> multiplies the range parameter from <code>INLA</code> by the cell size.
</p>
<p>Elements of <code>prior</code> can be named <code>range</code>, <code>sd</code>, or <code>sdObs</code>.  Elements can consist of: 
</p>

<ul>
<li><p> a single value giving the prior median for penalized complexity priors (exponential on the sd or 1/range).
</p>
</li>
<li><p> a vector <code>c(u=a, alpha=b)</code> giving an quantile and probability for pc priors.  For standard deviations alpha is an upper quantile, for the range parameter b = pr(1/range &gt; 1/a).
</p>
</li>
<li><p> a vector <code>c(lower=a, upper=b)</code> giving a 0.025 and 0.975 quantiles for the sd or range.
</p>
</li>
<li><p> a list of the form <code>list(prior='loggamma', param=c(1,2))</code> passed directly to inla.
</p>
</li>
<li><p> a two-column matrix of prior densities for the sd or range.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with two components named  <code>inla</code>, <code>raster</code>, and <code>parameters</code>.  <code>inla</code> contains the results of the call to the
<code>inla</code> function.  <code>raster</code> is a raster stack with the following layers:
</p>
<table>
<tr><td><code>random.</code></td>
<td>
<p>mean, sd, X0.0??quant: Posterior mean, standard deviation, and quantiles of the random effect</p>
</td></tr>
<tr><td><code>predict.</code></td>
<td>
<p>mean, sd, X0.0??quant: same for linear predictors, on the link scale</p>
</td></tr>
<tr><td><code>predict.exp</code></td>
<td>
<p>posterior mean of the exponential of the linear predictor</p>
</td></tr>
<tr><td><code>predict.invlogit</code></td>
<td>
<p>Only supplied if a binomial response variable was used.</p>
</td></tr>
</table>
<p><code>parameters</code> contains a list with elements:
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>a table with parameter estimates and posterior quantiles</p>
</td></tr>
<tr><td><code>range</code>, <code>sd</code></td>
<td>
<p>prior and posterior distributions of range and standard deviations</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="INLA.html#topic+inla">inla</a></code>, 
<a href="https://www.r-inla.org">https://www.r-inla.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# geostatistical model for the swiss rainfall data

if(requireNamespace("INLA", quietly=TRUE) ) {
  INLA::inla.setOption(num.threads=2)
  # not all versions of INLA support blas.num.threads
  try(INLA::inla.setOption(blas.num.threads=2), silent=TRUE)
} 

require("geostatsp")
data("swissRain")
swissRain = unwrap(swissRain)
swissAltitude = unwrap(swissAltitude)
swissBorder = unwrap(swissBorder)

swissRain$lograin = log(swissRain$rain)
swissFit =  glgm(formula="lograin", data=swissRain, 
	grid=30, 
	covariates=swissAltitude, family="gaussian", 
	buffer=2000,
	prior = list(sd=1, range=100*1000, sdObs = 2),
	control.inla = list(strategy='gaussian')
	)

if(!is.null(swissFit$parameters) ) {
	
	swissExc = excProb(swissFit, threshold=log(25))

	swissExcRE = excProb(swissFit$inla$marginals.random$space, 
		log(1.5),template=swissFit$raster)

	swissFit$parameters$summary

	matplot(
		swissFit$parameters$range$postK[,'x'],
		swissFit$parameters$range$postK[,c('y','prior')],
		type="l", lty=1, xlim = c(0, 1000),
		xlab = 'km', ylab='dens')
	legend('topright', lty=1, col=1:2, legend=c('post','prior'))

	plot(swissFit$raster[["predict.exp"]]) 

	mycol = c("green","yellow","orange","red")
	mybreaks = c(0, 0.2, 0.8, 0.95, 1)
	plot(swissBorder)
	plot(swissExc, breaks=mybreaks, col=mycol,add=TRUE,legend=FALSE)
	plot(swissBorder, add=TRUE)
	legend("topleft",legend=mybreaks, fill=c(NA,mycol))


	plot(swissBorder)
	plot(swissExcRE, breaks=mybreaks, col=mycol,add=TRUE,legend=FALSE)
	plot(swissBorder, add=TRUE)
	legend("topleft",legend=mybreaks, fill=c(NA,mycol))
}

		


# a log-Gaussian Cox process example

myPoints = vect(cbind(rbeta(100,2,2), rbeta(100,3,4)))


mycov = rast(matrix(rbinom(100, 1, 0.5), 10, 10), extent=ext(0, 1, 0, 1))
names(mycov)="x1"


if(requireNamespace("INLA", quietly=TRUE) ) {
  INLA::inla.setOption(num.threads=2)
  # not all versions of INLA support blas.num.threads
  try(INLA::inla.setOption(blas.num.threads=2), silent=TRUE)
}

res = lgcp(
	formula=~factor(x1),
	data=myPoints, 
	grid=squareRaster(ext(0,1,0,1), 20), covariates=mycov,
	prior=list(sd=c(0.9, 1.1), range=c(0.4, 0.41),
	control.inla = list(strategy='gaussian'), verbose=TRUE)
)
if(length(res$parameters)) {  
	plot(res$raster[["predict.exp"]])
	plot(myPoints,add=TRUE,col="#0000FF30",cex=0.5)
}

</code></pre>

<hr>
<h2 id='inla.models'>
Valid models in INLA
</h2><span id='topic+inla.models'></span>

<h3>Description</h3>

<p>calls the function of the same name in INLA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inla.models()
</code></pre>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='krigeLgm'>
Spatial prediction, or Kriging
</h2><span id='topic+krigeLgm'></span>

<h3>Description</h3>

<p>Perform spatial prediction, producing a raster of predictions and conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigeLgm(formula, data, grid,  covariates = NULL,
	param,  
    expPred = FALSE, nuggetInPrediction = TRUE,
    mc.cores=getOption("mc.cores", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigeLgm_+3A_formula">formula</code></td>
<td>
<p>Either a model formula, or a data frame of linear covariates.</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_data">data</code></td>
<td>

<p>A <code>SpatVector</code>  containing  the data to be interpolated
</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_grid">grid</code></td>
<td>
<p>Either a <code><a href="terra.html#topic+SpatRaster">SpatRaster</a></code> , or a single integer giving the
number of cells in the X direction which predictions will be made on.  If the later
the predictions will be a raster of square cells covering the bounding box of <code>data</code>.</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_covariates">covariates</code></td>
<td>

<p>The spatial covariates used in prediction, either a <code><a href="terra.html#topic+SpatRaster">SpatRaster</a></code> stack or list of rasters.
</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_param">param</code></td>
<td>
<p>A vector of named model parameters, as produced by <code><a href="#topic+likfitLgm">likfitLgm</a></code>
</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_exppred">expPred</code></td>
<td>

<p>Should the predictions be exponentiated, defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_nuggetinprediction">nuggetInPrediction</code></td>
<td>
<p>If <code>TRUE</code>, predict new observations by adding the 
nugget effect.  The prediction variances will be adjusted accordingly, and the predictions 
on the natural scale for logged or Box Cox transformed data will be affected. 
Otherwise predict fitted values. 
</p>
</td></tr>
<tr><td><code id="krigeLgm_+3A_mc.cores">mc.cores</code></td>
<td>
<p>passed to <code><a href="parallel.html#topic+parallel-package">mclapply</a></code> if greater than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the model parameters and observed data, conditional means and variances of the spatial random field
are computed.
</p>


<h3>Value</h3>

<p>A raster  is 
returned with the following layers:
</p>
<table>
<tr><td><code>fixed</code></td>
<td>
<p>Estimated means from the fixed effects portion of the model</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>Predicted random effect</p>
</td></tr>
<tr><td><code>krige.var</code></td>
<td>
<p>Conditional variance of predicted random effect (on the transformed scale if applicable)</p>
</td></tr>
<tr><td><code>predict</code></td>
<td>
<p>Prediction of the response, sum of fixed and random effects.  If exp.pred is TRUE, gives predictions
on the exponentiated scale, and half of krige.var is added prior to exponentiating</p>
</td></tr>
<tr><td><code>predict.log</code></td>
<td>
<p>If exp.pred=TRUE, the prediction of the logged process.</p>
</td></tr>
<tr><td><code>predict.boxcox</code></td>
<td>
<p>If a box cox transformation was used, the prediction of the process on the transformed scale.</p>
</td></tr>
</table>
<p>If the prediction locations are different for fixed and random effects (typically coarser for the random 
effects), a list with two raster stacks is returned.
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>A raster stack as above, though the random effect prediction is resampled to the 
same locations as the fixed effects.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>the predictions and conditional variance of the random effects, on the same
raster as <code>newdata</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lgm">lgm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('swissRain')
swissAltitude = unwrap(swissAltitude)
swissRain = unwrap(swissRain)
swissRain$lograin = log(swissRain$rain)
swissRain[[names(swissAltitude)]] = extract(swissAltitude, swissRain, ID=FALSE)

swissFit = likfitLgm(data=swissRain, 
			formula=lograin~ CHE_alt,
			param=c(range=46500, nugget=0.05,shape=1,  
					anisoAngleDegrees=35, anisoRatio=12),
			paramToEstimate = c("range","nugget", 
				"anisoAngleDegrees", "anisoRatio")
)
myTrend = swissFit$model$formula
myParams = swissFit$param


swissBorder = unwrap(swissBorder)

swissKrige = krigeLgm(
	data=swissRain, 
	formula = myTrend,
	covariates = swissAltitude,  
	param=myParams,
	grid = squareRaster(swissBorder, 40), expPred=TRUE)

plot(swissKrige[["predict"]], main="predicted rain")
plot(swissBorder, add=TRUE)




</code></pre>

<hr>
<h2 id='lgm-methods'>
Linear Geostatistical Models
</h2><span id='topic+lgm'></span><span id='topic+lgm-methods'></span><span id='topic+lgm+2Cmissing+2CANY+2CANY+2CANY-method'></span><span id='topic+lgm+2Cnumeric+2CANY+2CANY+2CANY-method'></span><span id='topic+lgm+2Ccharacter+2CANY+2CANY+2CANY-method'></span><span id='topic+lgm+2Cformula+2CSpatVector+2Cnumeric+2CANY-method'></span><span id='topic+lgm+2Cformula+2CSpatVector+2CSpatRaster+2Cmissing-method'></span><span id='topic+lgm+2Cformula+2CSpatVector+2CSpatRaster+2Clist-method'></span><span id='topic+lgm+2Cformula+2CSpatVector+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+lgm+2Cformula+2CSpatVector+2CSpatRaster+2Cdata.frame-method'></span><span id='topic+lgm+2Cformula+2CSpatRaster+2CANY+2CANY-method'></span><span id='topic+lgm+2Cformula+2Cdata.frame+2CSpatRaster+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Calculate MLE's of model parameters and perform spatial prediction. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,ANY,ANY,ANY'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'numeric,ANY,ANY,ANY'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'character,ANY,ANY,ANY'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,SpatVector,numeric,ANY'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,SpatVector,SpatRaster,missing'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,SpatVector,SpatRaster,list'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,SpatVector,SpatRaster,SpatRaster'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,SpatVector,SpatRaster,data.frame'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,SpatRaster,ANY,ANY'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
## S4 method for signature 'formula,data.frame,SpatRaster,data.frame'
lgm(
formula, data, grid, covariates, 
buffer=0, shape=1, boxcox=1, nugget = 0, 
expPred=FALSE, nuggetInPrediction=TRUE,
reml=TRUE,mc.cores=1,
aniso=FALSE,
fixShape=TRUE,
fixBoxcox=TRUE,
fixNugget = FALSE,
...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgm-methods_+3A_formula">formula</code></td>
<td>
<p>A model formula for the fixed effects, or a character string specifying the response variable.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_data">data</code></td>
<td>

<p>A <code>SpatVector</code> or <code>SpatRaster</code> layer, brick or stack containing the locations and observations, and possibly covariates.
</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_grid">grid</code></td>
<td>
<p>Either a <code><a href="terra.html#topic+SpatRaster">SpatRaster</a></code>, or a single integer giving the
number of cells in the X direction which predictions will be made on.  If the later
the predictions will be a raster of square cells covering the bounding box of <code>data</code>.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_covariates">covariates</code></td>
<td>

<p>The spatial covariates used in prediction, either a <code><a href="terra.html#topic+SpatRaster">SpatRaster</a></code> stack or list of rasters.
Covariates in <code>formula</code> but not in <code>data</code> will be extracted from <code>covariates</code>.
</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_shape">shape</code></td>
<td>
<p>Order of the Matern correlation</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_boxcox">boxcox</code></td>
<td>
<p>Box-Cox transformation parameter (or vector of parameters), set to 1 for no transformation.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_nugget">nugget</code></td>
<td>
<p>Value for the nugget effect (observation error) variance, or vector of such values.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_exppred">expPred</code></td>
<td>

<p>Should the predictions be exponentiated, defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_nuggetinprediction">nuggetInPrediction</code></td>
<td>
<p>If <code>TRUE</code>, predict new observations by adding the 
nugget effect.  The prediction variances will be adjusted accordingly, and the predictions 
on the natural scale for logged or Box Cox transformed data will be affected. 
Otherwise predict fitted values. 
</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_reml">reml</code></td>
<td>
<p>If <code>TRUE</code> (the default), use restricted maximum likelihood.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_mc.cores">mc.cores</code></td>
<td>
<p>If <code>mc.cores&gt;1</code>, this argument is passed to  <code><a href="parallel.html#topic+parallel-package">mclapply</a></code> and computations are 
done in parallel where possible. </p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_aniso">aniso</code></td>
<td>
<p>Set to <code>TRUE</code> to use geometric anisotropy.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_fixshape">fixShape</code></td>
<td>
<p>Set to <code>FALSE</code> to estimate the Matern order</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_fixboxcox">fixBoxcox</code></td>
<td>
<p>Set to <code>FALSE</code> to estimate the Box-Cox parameter.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_fixnugget">fixNugget</code></td>
<td>
<p>Set to <code>FALSE</code> to estimate the nugget effect parameter.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_buffer">buffer</code></td>
<td>
<p>Extra distance to add around <code>grid</code>.</p>
</td></tr>
<tr><td><code id="lgm-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+likfitLgm">likfitLgm</a></code>.  Starting values can be
specified with a vector <code>param</code> of named elements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>data</code> is a <code>SpatVector</code>, parameters are estimated using <code><a href="stats.html#topic+optim">optim</a></code> to maximize
the
log-likelihood function computed by  <code><a href="#topic+likfitLgm">likfitLgm</a></code> and spatial prediction accomplished with <code><a href="#topic+krigeLgm">krigeLgm</a></code>.
</p>
<p>With <code>data</code> being a <code>Raster</code> object, a Markov Random Field approximation to the Matern is used (experimental).  Parameters to 
be estimated should be provided as vectors of possible values, with optimization only considering the parameter values supplied.
</p>


<h3>Value</h3>

<p>A list is returned which includes a <code>SpatRaster</code> named <code>predict</code> having layers:
</p>
<table>
<tr><td><code>fixed</code></td>
<td>
<p>Estimated means from the fixed effects portion of the model</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>Predicted random effect</p>
</td></tr>
<tr><td><code>krigeSd</code></td>
<td>
<p>Conditional standard deviation of predicted random effect (on the transformed scale if applicable)</p>
</td></tr>
<tr><td><code>predict</code></td>
<td>
<p>Prediction of the response, sum of predicted fixed and random effects.  
For Box-Cox or log-transformed data on the natural (untransformed) scale.  
</p>
</td></tr>
<tr><td><code>predict.log</code></td>
<td>
<p>If <code>exp.pred=TRUE</code>, the prediction of the logged process.</p>
</td></tr>
<tr><td><code>predict.boxcox</code></td>
<td>
<p>If a box cox transformation was used, the prediction of the process on the transformed scale.</p>
</td></tr>
</table>
<p>In addition, the element <code>summery</code> contains a table of parameter estimates and confidence intervals.  <code>optim</code> contains the 
output from the call to the  <code><a href="stats.html#topic+optim">optim</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likfitLgm">likfitLgm</a></code>, <code><a href="#topic+krigeLgm">krigeLgm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("swissRain")
swissRain = unwrap(swissRain)
swissAltitude = unwrap(swissAltitude)
swissBorder = unwrap(swissBorder)
 
swissRes =  lgm( formula="rain", 
	data=swissRain[1:60,], grid=20,
	covariates=swissAltitude, boxcox=0.5, fixBoxcox=TRUE, 
	shape=1, fixShape=TRUE,
	aniso=FALSE, nugget=0, fixNugget=FALSE,
	nuggetInPrediction=FALSE
)

swissRes$summary

plot(swissRes$predict[["predict"]], main="predicted rain") 
plot(swissBorder, add=TRUE)

</code></pre>

<hr>
<h2 id='likfitLgm'>Likelihood Based Parameter Estimation for Gaussian Random Fields</h2><span id='topic+likfitLgm'></span><span id='topic+loglikLgm'></span>

<h3>Description</h3>

<p><em>Maximum likelihood</em> (ML) or <em>restricted maximum likelihood</em> (REML)
parameter estimation for (transformed) Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

likfitLgm(formula, data, 
		paramToEstimate = c("range","nugget"),
		reml=TRUE,
		coordinates=data,
		param=NULL,
		upper=NULL,lower=NULL, parscale=NULL,
		verbose=FALSE)

		
loglikLgm(param, 
		data, formula, coordinates=data,
		reml=TRUE, 
		minustwotimes=TRUE,
		moreParams=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likfitLgm_+3A_formula">formula</code></td>
<td>

<p>A formula for the fixed effects portion of the model, specifying a response and covariates. 
Alternately, <code>data</code> can be a vector of observations and <code>formula</code> can be 
a model matrix.
</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_data">data</code></td>
<td>

<p>An object of class <code>SpatVect</code>, a vector of observations, 
or a data frame containing observations and covariates.
</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_coordinates">coordinates</code></td>
<td>
<p>A <code>SpatVect</code> object containing the locations of each observation, 
which defaults to <code>data</code>.  Alternately, <code>coordinates</code> can be a
<code><a href="Matrix.html#topic+symmetricMatrix-class">symmetricMatrix-class</a></code> or <code>dist</code> object 
reflecting the distance matrix of these coordinates (though this is only permitted if the 
model is isotropic).</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_param">param</code></td>
<td>
<p>A vector of model parameters, with named elements being amongst 
<code>range, nugget, boxcox, shape, anisoAngleDegrees, anisoAngleRadians,
anisoRatio</code>, and possibly <code>variance</code> (see <code><a href="#topic+matern">matern</a></code>). 
When calling <code>likfitLgm</code> this vector is a 
combination of starting values for parameters to be estiamated and fixed values of parameters
which will not be estimated.  For <code>loglikLgm</code>, it is the covariance parameters 
for which the likelihood will be evaluated.
</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_reml">reml</code></td>
<td>
<p>Whether to use Restricted Likelihood rather than Likelihood, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_paramtoestimate">paramToEstimate</code></td>
<td>
<p>Vector of names of model parameters to estimate, with parameters
excluded from this list being fixed.  The variance parameter and regression coefficients
are always estimated even if not listed.</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_lower">lower</code></td>
<td>
<p>Named vector of lower bounds for model parameters passed to <code><a href="stats.html#topic+optim">optim</a></code>, defaults are 
used for parameters not specified.</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_upper">upper</code></td>
<td>
<p>Upper bounds, as above.</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_parscale">parscale</code></td>
<td>
<p>Named vector of scaling of parameters passed as <code>control=list(parscale=parscale)</code> 
to  <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_minustwotimes">minustwotimes</code></td>
<td>
<p>Return -2 times the log likelihood rather than the likelihood</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_moreparams">moreParams</code></td>
<td>
<p>Vector of additional parameters, combined with <code>param</code>.  
Used for passing fixed parameters to <code>loglikLgm</code> from within <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="likfitLgm_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> information is printed by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>likfitLgm</code> produces list with elements
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>Maximum Likelihood Estimates of model parameters</p>
</td></tr>
<tr><td><code>varBetaHat</code></td>
<td>
<p>Variance matrix of the estimated regression parameters</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>results from <code><a href="stats.html#topic+optim">optim</a></code> </p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Either formula for the fixed effects or names of the columns
of the model matrix, depending on <code>trend</code> supplied.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a table of parameter estimates, standard errors,  confidence intervals, p values, and 
a logical value indicating whether each parameter was estimated as opposed to fixed.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>residuals, being the observations minus the fixed effects, on the
transformed scale.</p>
</td></tr>
</table>
<p><code>loglikLgm</code> returns a scalar value, either the log likelihood or -2 times the
log likelihood.  Attributes of this result include the vector of
parameters (including the MLE's computed for the variance and coefficients),
and the variance matrix of the coefficient MLE's.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgm">lgm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=40
mydat = vect(
	cbind(runif(n), seq(0,1,len=n)), 
	atts=data.frame(cov1 = rnorm(n), cov2 = rpois(n, 0.5))
	)

# simulate a random field
trueParam = c(variance=2^2, range=0.35, shape=2, nugget=0.5^2)
set.seed(1)

oneSim = RFsimulate(model=trueParam,x=mydat)

values(mydat) = cbind(values(mydat) , values(oneSim))

# add fixed effects
mydat$Y = -3 + 0.5*mydat$cov1 + 0.2*mydat$cov2 + 
	mydat$sim + rnorm(length(mydat), 0, sd=sqrt(trueParam["nugget"]))

plot(mydat, "sim", col=rainbow(10), main="U")
plot(mydat, "Y", col=rainbow(10), main="Y")


myres = likfitLgm(
	formula=Y ~ cov1 + cov2, 
	data=mydat, 
	param=c(range=0.1,nugget=0.1,shape=2), 
	paramToEstimate = c("range","nugget")
	)

myres$summary[,1:4]


# plot variograms of data, true model, and estimated model
myv = variog(mydat, formula=Y ~ cov1 + cov2,option="bin", max.dist=0.5)
# myv will be NULL if geoR isn't installed
if(!is.null(myv)){
plot(myv, ylim=c(0, max(c(1.2*sum(trueParam[c("variance", "nugget")]),myv$v))),
	main="variograms")
distseq = seq(0, 0.5, len=50)
lines(distseq, 
	sum(myres$param[c("variance", "nugget")]) - matern(distseq, param=myres$param),
	col='blue', lwd=3)
lines(distseq, 
	sum(trueParam[c("variance", "nugget")]) - matern(distseq, param=trueParam),
	col='red')	

legend("bottomright", fill=c("black","red","blue"), 
	legend=c("data","true","MLE"))
}

# without a nugget
myresNoN = likfitLgm(
	formula=Y ~ cov1 + cov2, 
	data=mydat, 
	param=c(range=0.1,nugget=0,shape=1), 
	paramToEstimate = c("range")
	)

myresNoN$summary[,1:4]


# plot variograms of data, true model, and estimated model
myv = variog(mydat, formula=Y ~ cov1 + cov2,option="bin", max.dist=0.5)

if(!is.null(myv)){
plot(myv, ylim=c(0, max(c(1.2*sum(trueParam[c("variance", "nugget")]),myv$v))),
	main="variograms")
	
distseq = seq(0, 0.5, len=50)
lines(distseq, 
	sum(myres$param[c("variance", "nugget")]) - matern(distseq, param=myres$param),
	col='blue', lwd=3)
lines(distseq, 
	sum(trueParam[c("variance", "nugget")]) - matern(distseq, param=trueParam),
	col='red')	

lines(distseq, 
	sum(myresNoN$param[c("variance", "nugget")]) - 
			matern(distseq, param=myresNoN$param),
	col='green', lty=2, lwd=3)	
legend("bottomright", fill=c("black","red","blue","green"), 
	legend=c("data","true","MLE","no N"))
}


# calculate likelihood
temp=loglikLgm(param=myres$param, 
		data=mydat, 
		formula = Y ~ cov1 + cov2,
		reml=FALSE, minustwotimes=FALSE)



# an anisotropic example


trueParamAniso = param=c(variance=2^2, range=0.2, shape=2,
	 nugget=0,anisoRatio=4,anisoAngleDegrees=10, nugget=0)

mydat$U = geostatsp::RFsimulate(trueParamAniso,mydat)$sim

mydat$Y = -3 + 0.5*mydat$cov1 + 0.2*mydat$cov2 + 
	mydat$U + rnorm(length(mydat), 0, sd=sqrt(trueParamAniso["nugget"]))

oldpar = par(no.readonly = TRUE)

par(mfrow=c(1,2), mar=rep(0.1, 4))

plot(mydat, col=as.character(cut(mydat$U, breaks=50, labels=heat.colors(50))),
	pch=16, main="aniso")
 
plot(mydat, col=as.character(cut(mydat$Y, breaks=50, labels=heat.colors(50))),
	pch=16,main="iso")



myres = likfitLgm( 
	formula=Y ~ cov1 + cov2, 
	data=mydat,
	param=c(range=0.1,nugget=0,shape=2, anisoAngleDegrees=0, anisoRatio=2), 
	paramToEstimate = c("range","nugget","anisoRatio","anisoAngleDegrees") 
	)

myres$summary

par(oldpar)
par(mfrow=c(1,2))

myraster = rast(nrows=30,ncols=30,xmin=0,xmax=1,ymin=0,ymax=1)
covEst = matern(myraster, y=c(0.5, 0.5), par=myres$param)
covTrue = matern(myraster, y=c(0.5, 0.5), par=trueParamAniso)

plot(covEst, main="estimate")
plot(covTrue, main="true")

par(oldpar)

</code></pre>

<hr>
<h2 id='loaloa'>
Loaloa prevalence data from 197 village surveys
</h2><span id='topic+loaloa'></span><span id='topic+elevationLoa'></span><span id='topic+eviLoa'></span><span id='topic+ltLoa'></span><span id='topic+tempLoa'></span>

<h3>Description</h3>

<p>Location and prevalence data from villages, elevation an vegetation index for the study region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("loaloa")</code></pre>


<h3>Format</h3>

<p><code>loaloa</code> is a <code>SpatVector</code> containing the data, with columns <code>N</code> being the number 
of individuals tested and <code>y</code> being the number of positives.
<code>elevationLoa</code> is a raster of elevation data.
<code>eviLoa</code> is a raster of vegetation index for a specific date. <code>ltLoa</code> is land type.
<code>ltLoa</code> is a raster of land types. 1     2     5     6     7     8     9    10    11    12    13    14    15
<code>tempLoa</code> is a raster of average temperature in degrees C.
</p>


<h3>Source</h3>

<p><a href="http://www.leg.ufpr.br/doku.php/pessoais:paulojus:mbgbook:datasets">http://www.leg.ufpr.br/doku.php/pessoais:paulojus:mbgbook:datasets</a> for the loaloa data,
<a href="https://lpdaac.usgs.gov/data/">https://lpdaac.usgs.gov/data/</a> for EVI and land type and  
<a href="https://srtm.csi.cgiar.org">https://srtm.csi.cgiar.org</a> for the elevation data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("loaloa")
loaloa = unwrap(loaloa)
plot(loaloa, main="loaloa villages")

# elevation
elevationLoa = unwrap(elevationLoa)
plot(elevationLoa, col=terrain.colors(100), main="elevation")
points(loaloa)

# vegetation index
eviLoa = unwrap(eviLoa)
plot(eviLoa, main="evi")
points(loaloa)

tempLoa = unwrap(tempLoa)
plot(tempLoa, main="temperature")
points(loaloa)



# land type, a categorical variable
ltLoa = unwrap(ltLoa)
plot(ltLoa)
if(requireNamespace("mapmisc")){
	mapmisc::legendBreaks("bottomleft",ltLoa, bty='n')
}
points(loaloa)

</code></pre>

<hr>
<h2 id='matern'>Evaluate the Matern correlation function</h2><span id='topic+matern'></span><span id='topic+matern.default'></span><span id='topic+matern.dist'></span><span id='topic+matern.SpatRaster'></span><span id='topic+matern.SpatVector'></span><span id='topic+fillParam'></span>

<h3>Description</h3>

<p>Returns the Matern covariance for the distances supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	matern( x, param=c(range=1, variance=1, shape=1),
	type=c('variance','cholesky','precision', 'inverseCholesky'),
	y=NULL)
	## S3 method for class 'SpatVector'
matern(x,  param,
	type=c('variance','cholesky','precision', 'inverseCholesky'),
	y=NULL)
	## Default S3 method:
matern( x, param,
	type=c('variance','cholesky','precision', 'inverseCholesky'),
	y=NULL)
	## S3 method for class 'dist'
matern( x, param,
	type=c('variance','cholesky','precision', 'inverseCholesky'),
	y=NULL)
	## S3 method for class 'SpatRaster'
matern( x,  param,
	type=c('variance','cholesky','precision', 'inverseCholesky'),
	y=NULL)
	fillParam(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_+3A_x">x</code></td>
<td>
<p>A vector or matrix of distances, or <code>SpatRaster</code> or
<code>SpatVector</code> of locations, see Details below.</p>
</td></tr>
<tr><td><code id="matern_+3A_param">param</code></td>
<td>
<p>A vector of named model parameters with, at a minimum names
<code>range</code> and  <code>shape</code> (see Details), and optionally <code>variance</code> (defaults to 1) and
<code>nugget</code> (defaults to zero).  
For Geometric Anisotropy add 
<code>anisoRatio</code> and either <code>anisoAngleDegrees</code> or  
<code>anisoAngleRadians</code>
</p>
</td></tr>
<tr><td><code id="matern_+3A_type">type</code></td>
<td>
<p>specifies if the variance matrix, 
the Cholesky decomposition of the variance matrix, 
the precision matrix, or the inverse
of the Cholesky L matrix is returned.</p>
</td></tr>
<tr><td><code id="matern_+3A_y">y</code></td>
<td>
<p>Covariance is calculated for the distance between locations in 
<code>x</code> and <code>y</code>. If <code>y=NULL</code>, covariance 
of <code>x</code> with itself is produced. 
However, if <code>x</code> is a matrix or vector it is assumed to 
be a set of distances and <code>y</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

		
<p>The formula for the Matern correlation function is
</p>
<p style="text-align: center;"><code class="reqn">
	M(x) =  \frac{variance}{\Gamma(shape)} 
	2^{1-shape} 
	\left(
		\frac{ x \sqrt{8 shape} }{range}
	\right)^{shape}  
	besselK(x \sqrt{8 shape}/ range, shape) 
</code>
</p>

<p>The <code>range</code> argument is sqrt(8*shape)*phi.geoR, sqrt(8*shape)*scale.whittle.RandomFields, and
2*scale.matern.RandomFields.
</p>
<p>Geometric anisotropy is only available when 
<code>x</code> is a <code>SpatRaster</code> or <code>SpatVector</code>.  The parameter 'anisoAngle' refers to 
rotation of the coordinates anti-clockwise by the specified amount prior to 
calculating distances, which has the effect that the contours of the correlation function
are rotated clockwise by this amount. <code>anisoRatio</code> is the amount the Y coordinates are 
divided by
by post rotation prior to calculating distances.  A large value of <code>anisoRatio</code>
makes the Y coordinates smaller and increases the correlation in the
Y direction.
</p>
<p>When <code>x</code> or <code>y</code> are rasters, cells are indexed row-wise 
starting at the top left.
</p>


<h3>Value</h3>

<p>When <code>x</code> is a vector or matrix or object of class <code>dist</code>, a vector or matrix
of covariances is returned.  
With <code>x</code> being <code>SpatVector</code> ,  <code>y</code> must also be <code>SpatVector</code>  and 
a matrix of correlations between <code>x</code> and <code>y</code>
is returned.	
When <code>x</code> is a Raster, and <code>y</code> is a single location 
a Raster of covariances between each pixel centre of <code>x</code> and <code>y</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param=c(shape=2.5,range=1,variance=1)
u=seq(0,4,len=200)
uscale = sqrt(8*param['shape'])* u / param['range']

theMaterns = cbind(
	dist=u, 
	manual=	param['variance']* 2^(1- param['shape']) * 
			( 1/gamma(param['shape'])  )  * 
			uscale^param['shape'] * besselK(uscale , param['shape']),
	geostatsp=geostatsp::matern(u, param=param)
)
head(theMaterns)
matplot(theMaterns[,'dist'], 
	theMaterns[,c('manual','geostatsp')],
	col=c('red','blue'), type='l', 
	xlab='dist', ylab='var')
legend('topright', fill=c('red','blue'),
	legend=c('manual','geostatsp'))



# example with raster
myraster = rast(nrows=40,ncols=60,extent=ext(-3, 3,-2,2))
param = c(range=2, shape=2,	anisoRatio=2, 
	anisoAngleDegrees=-25,variance=20)

# plot correlation of each cell with the origin
myMatern = matern(myraster, y=c(0,0), param=param)


plot(myMatern, main="anisortopic matern")


# correlation matrix for all cells with each other
myraster = rast(nrows=4,ncols=6,extent = ext(-3, 3, -2, 2))
myMatern = matern(myraster, param=c(range=2, shape=2))
dim(myMatern)

# plot the cell ID's
values(myraster) = seq(1, ncell(myraster))
mydf = as.data.frame(myraster, xy=TRUE)
plot(mydf$x, mydf$y, type='n', main="cell ID's")
text(mydf$x, mydf$y, mydf$lyr.1)
# correlation between bottom-right cell and top right cell is
myMatern[6,24]

# example with points
mypoints = vect(
	cbind(runif(8), runif(8))
	)
# variance matrix from points
m1=matern(mypoints, param=c(range=2,shape=1.4,variance=4,nugget=1))
# cholesky of variance from distances
c2=matern(dist(crds(mypoints)), param=c(range=2,shape=1.4,variance=4,nugget=1),type='cholesky')

# check it's correct
quantile(as.vector(m1- tcrossprod(c2)))

# example with vector of distances
range=3
distVec = seq(0, 2*range, len=100)
shapeSeq = c(0.5, 1, 2,20)
theCov = NULL
for(D in shapeSeq) {
	theCov = cbind(theCov, matern(distVec, param=c(range=range, shape=D)))
}
matplot(distVec, theCov, type='l', lty=1, xlab='distance', ylab='correlation',
	main="matern correlations")
legend("right", fill=1:length(shapeSeq), legend=shapeSeq,title='shape')
# exponential

distVec2 = seq(0, max(distVec), len=20)
points(distVec2, exp(-2*(distVec2/range)),cex=1.5, pch=5)
# gaussian
points(distVec2, exp(-2*(distVec2/range)^2), col='blue',cex=1.5, pch=5)
legend("bottomleft", pch=5, col=c('black','blue'), legend=c('exp','gau'))

# comparing to geoR and RandomFields

if (requireNamespace("RandomFields", quietly = TRUE) &amp;
requireNamespace("geoR", quietly = TRUE) 
) { 

covGeoR = covRandomFields = NULL

for(D in shapeSeq) {
	covGeoR = cbind(covGeoR, 
		geoR::matern(distVec, phi=range/sqrt(8*D), kappa=D))
	covRandomFields = cbind(covRandomFields,
		RandomFields::RFcov(x=distVec, 
		model=RandomFields::RMmatern(nu=D, var=1,
				scale=range/2) ))
}



matpoints(distVec, covGeoR, cex=0.5, pch=1)
matpoints(distVec, covRandomFields, cex=0.5, pch=2)

legend("topright", lty=c(1,NA,NA), pch=c(NA, 1, 2), 
	legend=c("geostatsp","geoR","RandomFields"))
}
 
</code></pre>

<hr>
<h2 id='maternGmrfPrec'>Precision matrix for a Matern spatial correlation</h2><span id='topic+maternGmrfPrec'></span><span id='topic+maternGmrfPrec.default'></span><span id='topic+maternGmrfPrec.dgCMatrix'></span><span id='topic+NNmat'></span><span id='topic+NNmat.default'></span><span id='topic+NNmat.SpatRaster'></span>

<h3>Description</h3>

<p>Produces the precision matrix for a Gaussian random field on a regular square lattice, using a Markov random field approximation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
maternGmrfPrec(N, ...)
## S3 method for class 'dgCMatrix'
maternGmrfPrec(N, 
	param=c(variance=1, range=1, shape=1, cellSize=1),
  adjustEdges=FALSE,...) 
## Default S3 method:
maternGmrfPrec(N, Ny=N, 	
  param=c(variance=1, range=1, shape=1, cellSize=1),
  adjustEdges=FALSE, ...)
NNmat(N, Ny=N, nearest=3, adjustEdges=FALSE)
## S3 method for class 'SpatRaster'
NNmat(N, Ny=N, nearest=3, adjustEdges=FALSE)
## Default S3 method:
NNmat(N, Ny=N, nearest=3, adjustEdges=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maternGmrfPrec_+3A_n">N</code></td>
<td>
<p>Number of grid cells in the x direction, or a matrix denoting nearest neighbours.</p>
</td></tr>
<tr><td><code id="maternGmrfPrec_+3A_ny">Ny</code></td>
<td>
<p>Grid cells in the y direction, defaults to <code>N</code> for a square grid</p>
</td></tr>
<tr><td><code id="maternGmrfPrec_+3A_param">param</code></td>
<td>
<p>Vector of model parameters, with named elements: <code>scale</code>,
scale parameter for the correlation function; <code>prec</code>, precision parameter; <code>shape</code>, 
Matern differentiability parameter (0, 1, or 2); and <code>cellSize</code>, the size of the grid cells.  Optionally, 
<code>variance</code> and <code>range</code> can be given in place of <code>prec</code> and <code>scale</code>, when the former 
are present and the latter are missing the reciprocal of the former are taken.</p>
</td></tr>
<tr><td><code id="maternGmrfPrec_+3A_adjustedges">adjustEdges</code></td>
<td>
<p>If <code>TRUE</code>, adjust the precision matrix so it does not implicitly assume 
the field takes values of zero outside the specified region.  Defaults to <code>FALSE</code>.  Can be a character string specifying the parameters to use for the correction, such as <code>'optimal'</code> or <code>'optimalShape'</code>, with <code>TRUE</code> equivalent to <code>'theo'</code></p>
</td></tr>
<tr><td><code id="maternGmrfPrec_+3A_nearest">nearest</code></td>
<td>
<p>Number of nearest neighbours to compute</p>
</td></tr>
<tr><td><code id="maternGmrfPrec_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>maternGmrfPrec.dsCMatrix</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p> The numbering of cells
is consistent with the <code>terra</code> package.  Cell 1 is the top left cell, with cell 2 being the cell to the right and numbering
continuing row-wise.
</p>
<p>The 
nearest neighbour matrix <code>N</code> has: <code>N[i,j]=1</code> if <code>i=j</code>; 
takes a value 2 if <code>i</code> and <code>j</code> are first &lsquo;rook&rsquo; neighbours; 
3 if they are first &lsquo;bishop&rsquo; neighbours; 4 if they are second &lsquo;rook&rsquo; neighbours; 5 
if &lsquo;knight&rsquo; neighbours; and 6 if third &lsquo;rook&rsquo; neighbours.
</p>
<pre>
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]    0    0    0    6    0    0    0
[2,]    0    0    5    4    5    0    0
[3,]    0    5    3    2    3    5    0
[4,]    6    4    2    1    2    4    6
[5,]    0    5    3    2    3    5    0
[6,]    0    0    5    4    5    0    0
[7,]    0    0    0    6    0    0    0
</pre>


<h3>Value</h3>

<p>A sparse matrix <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix-class</a></code> object, containing a precision matrix for a 
Gaussian random field or (from the <code>NNmat</code> function)  a matrix denoting neighbours.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># produces the matrix above
	matrix(NNmat(11, 11, nearest=5)[,11*5+6],11, 11)

	params=c(range = 3,	shape=2, variance=5^2)
	
	myGrid = squareRaster(ext(0,20,0,10), 40)
		
	# precision matrix without adjusting for edge effects
	precMat =maternGmrfPrec(N=myGrid, param=params) 
	
	attributes(precMat)$info$precisionEntries
	
	midcell = cellFromRowCol(myGrid, 
		round(nrow(myGrid)/2), round(ncol(myGrid)/2)) # the middle cell
	edgeCell = cellFromRowCol(myGrid, 5,5)# cell near corner

# show precision of middle cell 
	precMid=matrix(precMat[,midcell], 
		nrow(myGrid), ncol(myGrid), byrow=TRUE)

	precMid[round(nrow(precMid)/2) + seq(-5, 5), 
		round(ncol(precMid)/2) + seq(-3, 3)]

	# and with the adjustment
	precMatCorr =maternGmrfPrec(
		N = myGrid, param=params, 
		adjustEdges=TRUE) 

	

# variance matrices
	varMat = Matrix::solve(precMat)
	varMatCorr = Matrix::solve(precMatCorr)

# compare covariance matrix to the matern
	xseq = seq(-ymax(myGrid), ymax(myGrid), len=1000)/1.5
	plot(xseq, matern(xseq, param=params),
	 type = 'l',ylab='cov', xlab='dist',
	 ylim=c(0, params["variance"]*1.1),
	 main="matern v gmrf")

	# middle cell
	varMid=matrix(varMat[,midcell], 
		nrow(myGrid), ncol(myGrid), byrow=TRUE)
	varMidCorr=matrix(varMatCorr[,midcell], 
		nrow(myGrid), ncol(myGrid), byrow=TRUE)
	xseqMid = yFromRow(myGrid) - yFromCell(myGrid, midcell)	
	points(xseqMid, varMid[,colFromCell(myGrid, midcell)], 
		col='red')
	points(xseqMid, varMidCorr[,colFromCell(myGrid, midcell)],
		 col='blue', cex=0.5)

	# edge cells
	varEdge=matrix(varMat[,edgeCell], 
	  nrow(myGrid), ncol(myGrid), byrow=TRUE)
	varEdgeCorr = matrix(varMatCorr[,edgeCell], 
	  nrow(myGrid), ncol(myGrid), byrow=TRUE)
	xseqEdge = yFromRow(myGrid) - yFromCell(myGrid, edgeCell)
	points(xseqEdge, 
		varEdge[,colFromCell(myGrid, edgeCell)], 
		pch=3,col='red')
	points(xseqEdge, 
	  varEdgeCorr[,colFromCell(myGrid, edgeCell)], 
	  pch=3, col='blue')
	
	legend("topright", lty=c(1, NA, NA, NA, NA), 
	  pch=c(NA, 1, 3, 16, 16),
		col=c('black','black','black','red','blue'),
		legend=c('matern', 'middle','edge','unadj', 'adj')
		)


	# construct matern variance matrix

	myraster = attributes(precMat)$raster
	covMatMatern = matern(myraster, param=params)
 
 	prodUncor = crossprod(covMatMatern, precMat)
 	prodCor = crossprod(covMatMatern, precMatCorr)

 	quantile(Matrix::diag(prodUncor),na.rm=TRUE)
 	quantile(Matrix::diag(prodCor),na.rm=TRUE)
 	
 	quantile(prodUncor[lower.tri(prodUncor,diag=FALSE)],na.rm=TRUE)	
 	quantile(prodCor[lower.tri(prodCor,diag=FALSE)],na.rm=TRUE)	

 	


</code></pre>

<hr>
<h2 id='murder'>
Murder locations
</h2><span id='topic+murder'></span><span id='topic+torontoPdens'></span><span id='topic+torontoIncome'></span><span id='topic+torontoNight'></span><span id='topic+torontoBorder'></span>

<h3>Description</h3>

<p>Locations of murders in Toronto 1990-2014
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("murder")</code></pre>


<h3>Format</h3>

<p><code>murder</code> is a  <code>SpatVector</code> object of murder locations.  <code>torontoPdens</code>, 
<code>torontoIncome</code>, and <code>torontoNight</code> are rasters containing
population density (per hectare), median household income, and ambient light 
respectively.  <code>torontoBorder</code> is a <code>SpatVector</code>  of the boundary of
the city of Toronto.
</p>


<h3>Source</h3>

<p>Murder data:<a href="https://mdl.library.utoronto.ca/collections/geospatial-data/toronto-homicide-data-1990-2013">https://mdl.library.utoronto.ca/collections/geospatial-data/toronto-homicide-data-1990-2013</a>, 
</p>
<p>Lights: <a href="https://ngdc.noaa.gov/eog/viirs/download_ut_mos.html">https://ngdc.noaa.gov/eog/viirs/download_ut_mos.html</a>
</p>
<p>Boundary files: <a href="https://www150.statcan.gc.ca/n1/en/catalogue/92-160-X">https://www150.statcan.gc.ca/n1/en/catalogue/92-160-X</a>
</p>
<p>Income: <a href="https://www150.statcan.gc.ca/n1/en/catalogue/97-551-X2006007">https://www150.statcan.gc.ca/n1/en/catalogue/97-551-X2006007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("murder")
murder= unwrap(murder)
torontoBorder = unwrap(torontoBorder)

plot(torontoBorder)
points(murder, col="#0000FF40", cex=0.5)

data("torontoPop")
torontoNight = unwrap(torontoNight)
torontoIncome = unwrap(torontoIncome)
torontoPdens = unwrap(torontoPdens)

# light
plot(torontoNight, main="Toronto ambient light")
plot(torontoBorder, add=TRUE)
points(murder, col="#0000FF40", cex=0.5)


# income
plot(torontoIncome, main="Toronto Income")
points(murder, col="#0000FF40", cex=0.5)
plot(torontoBorder, add=TRUE)

# population density
plot(torontoPdens, main="Toronto pop dens")
points(murder, col="#0000FF40", cex=0.5)
plot(torontoBorder, add=TRUE)

</code></pre>

<hr>
<h2 id='pcPriorRange'>
PC prior for range parameter
</h2><span id='topic+pcPriorRange'></span><span id='topic+pcPrior'></span>

<h3>Description</h3>

<p>Creates a penalized complexity prior for the range parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcPriorRange(q, p=0.5, cellSize=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcPriorRange_+3A_q">q</code></td>
<td>
<p>Lower quantile for the range parameter</p>
</td></tr>
<tr><td><code id="pcPriorRange_+3A_p">p</code></td>
<td>
<p>probability that the range is below this quantile, defaults to the median</p>
</td></tr>
<tr><td><code id="pcPriorRange_+3A_cellsize">cellSize</code></td>
<td>
<p>size of grid cells, can be a raster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>q is the quantile in spatial units, usually meters, and the scale parameter follows an exponential distribution. 	A prior PC prior distribution for the range parameter in units of grid cells, which INLA requires, is computed.  
</p>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>parameter for the exponential distribution (for scale in units of cells), in the same parametrization as dexp</p>
</td></tr>
<tr><td><code>priorScale</code></td>
<td>
<p>matrix with x and y columns with prior of scale parameter</p>
</td></tr>
<tr><td><code>priorRange</code></td>
<td>
<p>matris with x and y columns with prior of range parameter, in meters (or original spatial units)</p>
</td></tr>
<tr><td><code>inla</code></td>
<td>
<p>character string specifying this prior in inla's format</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># pr(range &lt; 100km) = 0.1, 200m grid cells 
	x = pcPriorRange(q=100*1000, p=0.1, cellSize = 200)
	rangeSeq = seq(0, 1000, len=1001)
	plot(rangeSeq, x$dprior$range(rangeSeq*1000)*1000, 
	  type='l', xlab="range, 1000's km", ylab='dens')
	cat(x$inla)
</code></pre>

<hr>
<h2 id='postExp'>Exponentiate posterior quantiles</h2><span id='topic+postExp'></span>

<h3>Description</h3>

<p>Converts a summary table for model parameters on the log scale to the natural or exponentiated scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	postExp(x, 
		exclude = grep('^(range|aniso|shape|boxcox)', rownames(x)),
		invLogit=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postExp_+3A_x">x</code></td>
<td>
<p>a matrix or data frame as returned by <code><a href="#topic+glgm">glgm</a></code> </p>
</td></tr>
<tr><td><code id="postExp_+3A_exclude">exclude</code></td>
<td>
<p>vector of parameters not transformed, defaults to the range parameter</p>
</td></tr>
<tr><td><code id="postExp_+3A_invlogit">invLogit</code></td>
<td>
<p>Converts intercept parameter to inverse-logit scale when <code>TRUE</code>.  Can also be a vector of parameters to inverse-logit transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary table for log or exponentially transformed model parameters</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("geostatsp")
data("swissRain")
swissRain = unwrap(swissRain)
swissAltitude = unwrap(swissAltitude)

swissRain$lograin = log(swissRain$rain)

if(requireNamespace('INLA', quietly=TRUE)) {
  INLA::inla.setOption(num.threads=2)
  # not all versions of INLA support blas.num.threads
  try(INLA::inla.setOption(blas.num.threads=2), silent=TRUE)
swissFit =  glgm(formula="lograin", data=swissRain, 
	grid=20, 
	covariates=swissAltitude/1000, family="gaussian", 
	prior = list(sd=1, range=100*1000, sdObs = 2),
	control.inla = list(strategy='gaussian', int.strategy='eb'),
	control.mode = list(theta=c(1.6542995, 0.7137123,2.2404179))
	)
if(length(swissFit$parameters)) {
	postExp(swissFit$parameters$summary)
}

}

</code></pre>

<hr>
<h2 id='profLlgm'>
Joint confidence regions
</h2><span id='topic+profLlgm'></span><span id='topic+informationLgm'></span>

<h3>Description</h3>

<p>Calculates profile likelihoods and approximate joint confidence regions
for covariance parameters in linear geostatistical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profLlgm(fit, mc.cores = 1, ...)
informationLgm(fit,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profLlgm_+3A_fit">fit</code></td>
<td>

<p>Output from the <code><a href="#topic+lgm">lgm</a></code> function
</p>
</td></tr>
<tr><td><code id="profLlgm_+3A_mc.cores">mc.cores</code></td>
<td>

<p>Passed to <code><a href="parallel.html#topic+parallel-package">mclapply</a></code>
</p>
</td></tr>
<tr><td><code id="profLlgm_+3A_...">...</code></td>
<td>

<p>For <code>profLlgm</code>, one or more vectors of parameter values 
at which the profile likelihood will be calculated, with names 
corresponding to elements of <code>fit$param</code>.  For <code>informationLgm</code>,
arguments passed to  <code><a href="numDeriv.html#topic+hessian">hessian</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>one or more vectors</code></td>
<td>
<p>of parameter values</p>
</td></tr>
<tr><td><code>logL</code></td>
<td>

<p>A vector, matrix, or multi-dimensional array of profile likelihood values for every 
combination of parameter values supplied.
</p>
</td></tr>
<tr><td><code>full</code></td>
<td>
<p>Data frame with profile likelihood values and estimates of 
model parameters</p>
</td></tr>
<tr><td><code>prob</code>, <code>breaks</code></td>
<td>
<p>vector of probabilities and chi-squared derived 
likelihood values associated with those probabilities</p>
</td></tr>
<tr><td><code>MLE</code>, <code>maxLogL</code></td>
<td>
<p>Maximum Likelihood Estimates of parameters and 
log likelihood evaluated at these values</p>
</td></tr>
<tr><td><code>basepars</code></td>
<td>
<p>combination of starting values for parameters re-estimated for each
profile likelihood and values of parameters which are fixed.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>vector of colours with one element fewer than the number of probabilities</p>
</td></tr>
<tr><td><code>ci</code>, <code>ciLong</code></td>
<td>
<p>when only one parameter is varying, a matrix of confidence intervals (in both wide and long format)
is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgm">lgm</a></code>, <code><a href="parallel.html#topic+parallel-package">mcmapply</a></code>, <code><a href="numDeriv.html#topic+hessian">hessian</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this example is time consuming
# the following 'if' statement ensures the CRAN
# computer doesn't run it
if(interactive() | Sys.info()['user'] =='patrick') {

library('geostatsp')
data('swissRain')
swissRain = unwrap(swissRain)
swissAltitude = unwrap(swissAltitude)

swissFit = lgm(data=swissRain, formula=rain~ CHE_alt,
		grid=10, covariates=swissAltitude,
		shape=1,  fixShape=TRUE, 
		boxcox=0.5, fixBoxcox=TRUE, 
		aniso=TRUE,reml=TRUE,
		param=c(anisoAngleDegrees=37,anisoRatio=7.5,
		range=50000))


x=profLlgm(swissFit,
		anisoAngleDegrees=seq(30, 43 , len=4)
)


plot(x[[1]],x[[2]], xlab=names(x)[1],
		ylab='log L',
		ylim=c(min(x[[2]]),x$maxLogL),
		type='n')
abline(h=x$breaks[-1],
		col=x$col,
		lwd=1.5)
axis(2,at=x$breaks,labels=x$prob,line=-1.2,
	tick=FALSE,
		las=1,padj=1.2,hadj=0)
abline(v=x$ciLong$par,
		lty=2,
		col=x$col[as.character(x$ciLong$prob)])
lines(x[[1]],x[[2]], col='black')



}

</code></pre>

<hr>
<h2 id='RFsimulate'>Simulation of Random Fields</h2><span id='topic+RFsimulate'></span><span id='topic+modelRandomFields'></span><span id='topic+RFsimulate'></span><span id='topic+RFsimulate-methods'></span><span id='topic+RFsimulate+2CANY+2CSpatRaster-method'></span><span id='topic+RFsimulate+2Cnumeric+2CSpatRaster-method'></span><span id='topic+RFsimulate+2Cnumeric+2CSpatVector-method'></span><span id='topic+RFsimulate+2CRMmodel+2CSpatVector-method'></span><span id='topic+RFsimulate+2CRMmodel+2CSpatRaster-method'></span><span id='topic+RFsimulate+2Cmatrix+2CSpatRaster-method'></span><span id='topic+RFsimulate+2Cmatrix+2CSpatVector-method'></span><span id='topic+RFsimulate+2Cdata.frame+2CANY-method'></span>

<h3>Description</h3>

<p>This function simulates conditional and unconditional Gaussian random fields, calling the function in the RandomFields package of the same name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,SpatRaster'
RFsimulate(model, x,	data=NULL,
 err.model=NULL, n = 1, ...)
## S4 method for signature 'numeric,SpatRaster'
RFsimulate(model, x,data=NULL,
 err.model=NULL, n = 1, ...)
## S4 method for signature 'numeric,SpatVector'
RFsimulate(model, x, data=NULL, 
err.model=NULL, n = 1, ...)
## S4 method for signature 'RMmodel,SpatRaster'
RFsimulate(model, x, data=NULL, 
 err.model=NULL, n = 1, ...)
## S4 method for signature 'RMmodel,SpatVector'
RFsimulate(model, x, data=NULL, 
 err.model=NULL, n = 1, ...)
## S4 method for signature 'matrix,SpatRaster'
RFsimulate(model, x, 	data=NULL, 
 err.model=NULL, n = nrow(model), ...)
## S4 method for signature 'matrix,SpatVector'
RFsimulate(model, x,	data=NULL, 
	err.model=NULL, n = nrow(model), ...)
## S4 method for signature 'data.frame,ANY'
RFsimulate(model, x,	data=NULL, 
	err.model=NULL, n = nrow(model), ...)
modelRandomFields(param, includeNugget=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RFsimulate_+3A_model">model</code></td>
<td>
<p>object of class 
<code><a href="RandomFields.html#topic+RMmodel">RMmodel</a></code>, a vector of named model
parameters, or a matrix where each column is a model parameter
</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="terra.html#topic+SpatRaster">SpatRaster</a></code> or <code><a href="terra.html#topic+SpatVector">SpatVector</a></code>.</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_data">data</code></td>
<td>
<p>For conditional simulation and random imputing only.
If <code>data</code> is missing, unconditional
simulation is performed. Object of class
<code><a href="terra.html#topic+SpatVector">SpatVector</a></code>;
coordinates and response values of
measurements in case that conditional simulation is to
be performed
</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_err.model">err.model</code></td>
<td>
<p>For conditional simulation and random imputing only.<br />
Usually <code>err.model=RMnugget(var=var)</code>, or not given at all
(error-free measurements).
</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_n">n</code></td>
<td>
<p>number of realizations to generate.
</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_...">...</code></td>
<td>
<p>for advanced use:
further options and control parameters for the simulation
that are passed to and processed by 
<code><a href="RandomFields.html#topic+RFoptions">RFoptions</a></code> 
</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_param">param</code></td>
<td>
<p>A vector of named parameters</p>
</td></tr>
<tr><td><code id="RFsimulate_+3A_includenugget">includeNugget</code></td>
<td>
<p>If <code>FALSE</code>, the <code>nugget</code> parameter is ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>model</code> is a matrix, a different set of parameters is used for each simulation.  If 
<code>data</code> has the same number of columns as <code>model</code> has rows, 
a different column <code>i</code> is used with parameters in row <code>i</code>.   
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Patrick E. Brown <a href="mailto:patrick.brown@utoronto.ca">patrick.brown@utoronto.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="RandomFields.html#topic+RFsimulate">RFsimulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library('geostatsp')

# exclude this line to use the RandomFields package
options(useRandomFields = FALSE)

model1 &lt;- c(var=5, range=1,shape=0.5)


myraster = rast(nrows=20,ncols=30,extent = ext(0,6,0,4), 
	crs="+proj=utm +zone=17 +datum=NAD27 +units=m +no_defs")

set.seed(0) 

simu &lt;- RFsimulate(model1, x=myraster, n=3)

plot(simu[['sim2']])

xPoints = suppressWarnings(as.points(myraster))
# conditional simulation
firstSample = RFsimulate(
	c(model1, nugget=1), 
	x=xPoints[seq(1,ncell(myraster), len=100), ],
	n=3
)

secondSample = RFsimulate(
	model = cbind(var=5:3, range=seq(0.05, 0.25, len=3), shape=seq(0.5, 1.5, len=3)),
  err.model = 1,
	x= myraster,
	data=firstSample,n=4
)

plot(secondSample)



</code></pre>

<hr>
<h2 id='rongelapUTM'>
Rongelap data
</h2><span id='topic+rongelapUTM'></span>

<h3>Description</h3>

<p>This data-set was used by Diggle, Tawn and Moyeed (1998) to illustrate
the model-based geostatistical methodology introduced in the paper.
discussed in the paper. The radionuclide concentration data set consists 
of measurements of <code class="reqn">\gamma</code>-ray counts at <code class="reqn">157</code> locations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rongelapUTM)</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code>, with columns <code>count</code> being the 
radiation count and <code>time</code> being the length of time
the measurement was taken for.  A UTM coordinate reference system is used, where coordinates are in metres.
</p>


<h3>Source</h3>

<p><a href="http://www.leg.ufpr.br/doku.php/pessoais:paulojus:mbgbook:datasets">http://www.leg.ufpr.br/doku.php/pessoais:paulojus:mbgbook:datasets</a>.  For further details on the radionuclide concentration data, see Diggle,Harper and Simon (1997), Diggle, Tawn and Moyeed (1998) and Christensen (2004).
</p>


<h3>References</h3>

<p>Christensen, O. F. (2004). Monte Carlo maximum likelihood in model-based geostatistics.
Journal of computational and graphical statistics <b>13</b> 702-718.
</p>
<p>Diggle, P. J., Harper, L. and Simon, S. L. (1997). Geostatistical analysis of residual contamination from nuclea
testing. In: <em>Statistics for the environment 3: pollution assesment and control</em> (eds. V. Barnet and K. F. Turkmann), Wiley, 
Chichester, 89-107.
</p>
<p>Diggle, P. J., Tawn, J. A. and Moyeed, R. A. (1998). Model-based
geostatistics (with Discussion). Applied Statistics,
47, 299&ndash;350.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rongelapUTM")
rongelapUTM = unwrap(rongelapUTM)
plot(rongelapUTM, main="Rongelap island")

if(require('mapmisc')) {
  bgMap = openmap(rongelapUTM, buffer=300, maxTiles=2)
  plot(bgMap)
  points(rongelapUTM, cex=0.4)
  scaleBar(rongelapUTM, 'left')

}



</code></pre>

<hr>
<h2 id='simLgcp'>Simulate a log-Gaussian Cox process</h2><span id='topic+simLgcp'></span><span id='topic+simPoissonPP'></span>

<h3>Description</h3>

<p>Give covariates and model parameters, simulates a log-Gaussian Cox process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	simLgcp(param, covariates=NULL, betas=NULL, 
	offset=NULL,
	  rasterTemplate=covariates[[1]], n=1, ...)
	simPoissonPP(intensity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simLgcp_+3A_param">param</code></td>
<td>
<p>A vector of named model parameters with, at a minimum names
<code>range</code> and  <code>shape</code> (see Details), and optionally <code>variance</code> (defaults to 1).  
For Geometric Anisotropy add 
<code>anisoRatio</code> and either <code>anisoAngleDegrees</code> or  
<code>anisoAngleRadians</code>
</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_covariates">covariates</code></td>
<td>
<p>Either a raster stack or list of rasters and <code>SpatVector</code>s (with the latter having only a single data column).</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_betas">betas</code></td>
<td>
<p>Coefficients for the covariates</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_offset">offset</code></td>
<td>
<p>Vector of character strings corresponding to elements of <code>covariates</code> which are offsets</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_rastertemplate">rasterTemplate</code></td>
<td>
<p>Raster on which the latent surface is simulated,
defaults to the first covariate.</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_n">n</code></td>
<td>
<p>number of realisations to simulate</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_...">...</code></td>
<td>
<p> additional arguments, see 
<code><a href="RandomFields.html#topic+RFsimulate">RFsimulate</a></code>.</p>
</td></tr>
<tr><td><code id="simLgcp_+3A_intensity">intensity</code></td>
<td>
<p>Raster of the intensity of a Poisson point process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a <code>events</code> element containing the event locations and a <code>SpatRaster</code> element 
containing a raster stack of the covariates, spatial random effect, and intensity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mymodel = c(mean=-0.5, variance=1, 
				range=2, shape=2)

myraster = rast(nrows=15,ncols=20,xmin=0,xmax=10,ymin=0,ymax=7.5)

# some covariates, deliberately with a different resolution than myraster
covA = covB = myoffset = rast(ext(myraster), 10, 10)
values(covA) = as.vector(matrix(1:10, 10, 10))
values(covB) = as.vector(matrix(1:10, 10, 10, byrow=TRUE))
values(myoffset) = round(seq(-1, 1, len=ncell(myoffset)))

myCovariate = list(a=covA, b=covB, offsetFooBar = myoffset)

myLgcp=simLgcp(param=mymodel, 
	covariates=myCovariate, 
	betas=c(a=-0.1, b=0.25), 
	offset='offsetFooBar',
	rasterTemplate=myraster)

plot(myLgcp$raster[["intensity"]], main="lgcp")
points(myLgcp$events)

myIntensity = exp(-1+0.2*myCovariate[["a"]])
myPoissonPP = simPoissonPP(myIntensity)[[1]]
plot(myIntensity, main="Poisson pp")
points(myPoissonPP)


</code></pre>

<hr>
<h2 id='spatialRoc'>
Sensitivity and specificity
</h2><span id='topic+spatialRoc'></span>

<h3>Description</h3>

<p>Calculate ROC curves using model fits to simulated spatial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialRoc(fit, rr = c(1, 1.2, 1.5, 2), truth, border=NULL, 
	random = FALSE, prob = NULL, spec = seq(0,1,by=0.01))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialRoc_+3A_fit">fit</code></td>
<td>

<p>A fitted model from the <code><a href="#topic+lgcp">lgcp</a></code> function
</p>
</td></tr>
<tr><td><code id="spatialRoc_+3A_rr">rr</code></td>
<td>

<p>Vector of relative risks exceedance probabilities will be calculated for.  Values
are on the natural scale, with <code>spatialRoc</code> taking logs when appropriate.
</p>
</td></tr>
<tr><td><code id="spatialRoc_+3A_truth">truth</code></td>
<td>

<p>True value of the spatial surface, or result from <code><a href="#topic+simLgcp">simLgcp</a></code> function.
Assumed to be on the log scale if <code>random=TRUE</code> and on the natural scale otherwise.
</p>
</td></tr>
<tr><td><code id="spatialRoc_+3A_border">border</code></td>
<td>

<p>optional, <code>SpatVector</code> specifying region that calculations will be restricted to.
</p>
</td></tr>
<tr><td><code id="spatialRoc_+3A_random">random</code></td>
<td>

<p>compute ROC's for relative intensity (<code>FALSE</code>) or random effect (<code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="spatialRoc_+3A_prob">prob</code></td>
<td>
<p>Vector of exceedance probabilities</p>
</td></tr>
<tr><td><code id="spatialRoc_+3A_spec">spec</code></td>
<td>
<p>Vector of specificities for the resulting ROC's to be computed for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitted models are used to calculate exceedance probabilities, and
a location is judged to be above an <code>rr</code> threshold if this 
exceedance probability is above a specified probability threshold. 
Each raster cell of the true surface is categorized as being either true positive, false
positive, true negative, and false negative and sensitivity and specificity computed.
ROC curves are produced by varying the probability threshold.  
</p>


<h3>Value</h3>

<p>An array, with dimension 1 being probability threshold, dimension 2 
being the relative risk threshold, dimension 3 being sensitivity and specificity.
If <code>fit</code> is a list of model fits, dimension 4 corresponds to elements of <code>fit</code>.
</p>


<h3>Author(s)</h3>

<p>Patrick Brown 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgcp">lgcp</a></code>, <code><a href="#topic+simLgcp">simLgcp</a></code>, <code><a href="#topic+excProb">excProb</a></code>
</p>

<hr>
<h2 id='squareRaster-methods'>Create a raster with square cells</h2><span id='topic+squareRaster'></span><span id='topic+squareRaster-methods'></span><span id='topic+squareRaster+2Cmatrix-method'></span><span id='topic+squareRaster+2CSpatRaster-method'></span><span id='topic+squareRaster+2CSpatVector-method'></span><span id='topic+squareRaster+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Given a raster object, an extent, or a bounding box, a raster of with square cells and having the 
extent and number of cells specified is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
squareRaster(x,cells=NULL, buffer=0)
## S4 method for signature 'SpatRaster'
squareRaster(x,cells=NULL, buffer=0)
## S4 method for signature 'SpatVector'
squareRaster(x,cells=NULL, buffer=0)
## S4 method for signature 'SpatExtent'
squareRaster(x,cells=NULL, buffer=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squareRaster-methods_+3A_x">x</code></td>
<td>

<p>A spatial object</p>
</td></tr>
<tr><td><code id="squareRaster-methods_+3A_cells">cells</code></td>
<td>
<p>The number of cells in the x direction.  If NULL the number of columns of x is used.  </p>
</td></tr>
<tr><td><code id="squareRaster-methods_+3A_buffer">buffer</code></td>
<td>
<p>Additional area to add around the resulting raster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code> with square cells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myraster = rast(matrix(0,10,10),extent=c(0,10,0,12.3))

squareRaster(myraster)

squareRaster(myraster, buffer=3, cells=20)

squareRaster(ext(myraster), cells=10)


</code></pre>

<hr>
<h2 id='stackRasterList'>
Converts a list of rasters, possibly with different projections and resolutions, to a single raster stack.
</h2><span id='topic+stackRasterList'></span><span id='topic+spdfToBrick'></span>

<h3>Description</h3>

<p>This function is intended to be used prior to passing covariates to <a href="#topic+krigeLgm">krigeLgm</a> in order
for the rasters for all covariates to have the same projection and same resolution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackRasterList(x, template = x[[1]], method = "near", mc.cores=NULL)
spdfToBrick(x, 
    template,
    logSumExpected=FALSE,
    pattern = '^expected_[[:digit:]]+$'
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackRasterList_+3A_x">x</code></td>
<td>

<p>A list of <code>SpatRaster</code> or <code>SpatVector</code>s for 
<code>stackRasterList</code> and <code>spdfToBrick</code> respectively
</p>
</td></tr>
<tr><td><code id="stackRasterList_+3A_template">template</code></td>
<td>

<p>A raster whose projection and resolution all other rasters will be aligned with.
</p>
</td></tr>
<tr><td><code id="stackRasterList_+3A_method">method</code></td>
<td>

<p>The method to use, either &quot;near&quot;, or &quot;bilinear&quot;.  Can be a vector of the same length as x to specify different methods for each raster.  If <code>method</code> has names 
which correspond to the names of <code>x</code>, the names will be used instead of the order to assign methods to rasters.
</p>
</td></tr>
<tr><td><code id="stackRasterList_+3A_mc.cores">mc.cores</code></td>
<td>
<p>If non-null, <code><a href="parallel.html#topic+parallel-package">mclapply</a></code> is used with this argument specifying the number of cores.</p>
</td></tr>
<tr><td><code id="stackRasterList_+3A_logsumexpected">logSumExpected</code></td>
<td>
<p>return the log of the sum of offsets</p>
</td></tr>
<tr><td><code id="stackRasterList_+3A_pattern">pattern</code></td>
<td>
<p>expression to identify layers to rasterize in <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster brick, with one layer for each variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myCrs = crs("+proj=utm +zone=17 +ellps=GRS80 +units=m +no_defs")
x = list(a=rast(matrix(1:9, 3, 3), extent=ext(0,1,0,1), 
       crs=myCrs),
	b=rast(matrix(1:25, 5, 5), extent=ext(-1, 2, -1, 2),
	   crs=myCrs)
	)
mystack = stackRasterList(x)
mystack



mylist = list(
	a=rast(matrix(1:36, 6, 6,byrow=TRUE), extent=ext(0,1000,0,1000), 
       crs=myCrs),
	b=rast(matrix(1:144, 12, 12), extent=ext(-200, 200, -200, 200),
	   crs=myCrs),
	c=rast(matrix(1:100, 10, 10), extent=ext(-5000,5000,-5000,5000), 
       crs=myCrs)
	)
	
	mystack = stackRasterList(mylist, mc.cores=1)
	mystack

plot(mystack[["b"]], main="stack b")
plot(mystack[['a']],add=TRUE,col=grey(seq(0,1,len=12)),alpha=0.8,legend=FALSE)

</code></pre>

<hr>
<h2 id='swissRain'>
Swiss rainfall data
</h2><span id='topic+swissRain'></span><span id='topic+swissAltitude'></span><span id='topic+swissBorder'></span><span id='topic+swissLandType'></span>

<h3>Description</h3>

<p>Data from the SIC-97 project: Spatial Interpolation Comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("swissRain")</code></pre>


<h3>Format</h3>

<p><code>swissRain</code> is a <code>SpatVector</code> 
100 daily rainfall
measurements made in Switzerland on the 8th of May 1986.
<code>swissAltitude</code> is a raster of elevation data, and <code>swissLandType</code> is a raster
of land cover types.
</p>


<h3>Source</h3>

<p><a href="https://wiki.52north.org/AI_GEOSTATS/AI_GEOSTATSData">https://wiki.52north.org/AI_GEOSTATS/AI_GEOSTATSData</a> and  <a href="https://srtm.csi.cgiar.org">https://srtm.csi.cgiar.org</a> and
<a href="https://lpdaac.usgs.gov/data/">https://lpdaac.usgs.gov/data/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("swissRain")
swissRain = unwrap(swissRain)
swissAltitude = unwrap(swissAltitude)
swissBorder = unwrap(swissBorder)
swissLandType = unwrap(swissLandType)
plot(swissAltitude, main="elevation")
points(swissRain)
plot(swissBorder, add=TRUE)


# land type, a categorical variable
commonValues  = sort(table(values(swissLandType)),decreasing=TRUE)[1:5]
commonValues=commonValues[!names(commonValues)==0]

thelevels = levels(swissLandType)[[1]]$ID
thebreaks = c(-0.5, 0.5+thelevels)
thecol = rep(NA, length(thelevels))
names(thecol) = as.character(thelevels)

thecol[names(commonValues)] = rainbow(length(commonValues))

plot(swissLandType, breaks=thebreaks, col=thecol,legend=FALSE,
	main="land type")
points(swissRain)
plot(swissBorder, add=TRUE)


legend("left",fill=thecol[names(commonValues)],
		legend=substr(levels(swissLandType)[[1]][
						match(as.integer(names(commonValues)),
								levels(swissLandType)[[1]]$ID),
						"Category"], 1,12),
						bg= 'white'
				)

</code></pre>

<hr>
<h2 id='swissRainR'>
Raster of Swiss rain data
</h2><span id='topic+swissRainR'></span><span id='topic+swissNN'></span>

<h3>Description</h3>

<p>A raster image of Swiss rain and elevation, and a nearest neighbour matrix
corresponding to this raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissRainR)</code></pre>


<h3>Format</h3>

<p><code>swissRainR</code> is a RasterBrick of Swiss elevation and 
precipitation, and <code>swissNN</code> is a matrix of nearest neighbours.
</p>


<h3>Source</h3>

<p>See examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('swissRainR')
swissRainR = unwrap(swissRainR)
plot(swissRainR[['prec7']])
plot(swissRainR[['alt']])

swissNN[1:4,1:5]

</code></pre>

<hr>
<h2 id='variog'>Compute Empirical Variograms and Permutation Envelopes</h2><span id='topic+variog'></span><span id='topic+variog.default'></span><span id='topic+variog.SpatVector'></span><span id='topic+variogMcEnv'></span><span id='topic+variogMcEnv.default'></span><span id='topic+variogMcEnv.SpatVector'></span>

<h3>Description</h3>

<p>These are wrappers for 
<code>variog</code>in the <code>geoR</code>package 
and 
<code>variog.mc.env</code> in the <code>geoR</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog(geodata, ...)
## S3 method for class 'SpatVector'
variog(geodata, formula, ...)
## Default S3 method:
variogMcEnv(geodata, ...)
## S3 method for class 'SpatVector'
variogMcEnv(geodata, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variog_+3A_geodata">geodata</code></td>
<td>

<p>An object of class <code>SpatVector</code> or of a class suitable for 
<code>variog</code> in the <code>geoR</code> package 
</p>
</td></tr>
<tr><td><code id="variog_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the response variable and fixed effects portion of the model.
The variogram is performed on the residuals.</p>
</td></tr>
<tr><td><code id="variog_+3A_...">...</code></td>
<td>

<p>additional arguments passed to 	<code>variog</code> in the <code>geoR</code> package 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As <code>variog</code> in the <code>geoR</code> package 
and 
<code>variog.mc.env</code> in the <code>geoR</code> package 
</p>


<h3>See Also</h3>

<p><code>variog</code>in the <code>geoR</code>package and 
<code>variog.mc.env</code> in the <code>geoR</code> package 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("swissRain")
swissRain = unwrap(swissRain)
swissRain$lograin = log(swissRain$rain)
swissv= variog(swissRain, formula=lograin ~ 1,option="bin")
swissEnv = variogMcEnv(swissRain, lograin ~ 1, obj.var=swissv,nsim=9) 
if(!is.null(swissv)){
	plot(swissv, env=swissEnv, main = "Swiss variogram")
}
</code></pre>

<hr>
<h2 id='wheat'>
Mercer and Hall wheat yield data
</h2><span id='topic+wheat'></span>

<h3>Description</h3>

<p>Mercer and Hall wheat yield data, based on version in Cressie (1993), p. 455.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wheat)</code></pre>


<h3>Format</h3>

<p><code>wheat</code> is a raster where the values refer to wheat yields.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data("wheat")
	wheat = unwrap(wheat)
	plot(wheat, main="Mercer and Hall Data")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
