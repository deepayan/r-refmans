<!DOCTYPE html><html lang="en"><head><title>Help for package bggum</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bggum}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bggum'><p>bggum</p></a></li>
<li><a href='#color_palettes'><p>Color palettes provided by <code>bggum</code>.</p></a></li>
<li><a href='#ggum_simulation'><p>GGUM Simulation</p></a></li>
<li><a href='#ggumMC3'><p>GGUM MC3</p></a></li>
<li><a href='#ggumMCMC'><p>GGUM MCMC Sampler</p></a></li>
<li><a href='#ggumProbability'><p>GGUM Probability Function</p></a></li>
<li><a href='#icc'><p>Item Characteristic Curve</p></a></li>
<li><a href='#irf'><p>Item Response Function</p></a></li>
<li><a href='#post_process'><p>Post-process a Posterior Sample</p></a></li>
<li><a href='#summary.ggum'><p>Summarize Posterior Draws for GGUM Parameters</p></a></li>
<li><a href='#tune_proposals'><p>Tune proposal densities</p></a></li>
<li><a href='#tune_temperatures'><p>tune_temperatures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Estimation of Generalized Graded Unfolding Model
Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a Metropolis-coupled Markov chain Monte Carlo sampler,
    post-processing and parameter estimation functions, and plotting utilities
    for the generalized graded unfolding model of Roberts, Donoghue, and
    Laughlin (2000) &lt;<a href="https://doi.org/10.1177%2F01466216000241001">doi:10.1177/01466216000241001</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/duckmayr/bggum">https://github.com/duckmayr/bggum</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/duckmayr/bggum/issues">https://github.com/duckmayr/bggum/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, Rcpp (&ge; 0.12.14)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppDist</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, testthat, covr, knitr, rmarkdown, dplyr, tidyr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'bggum-package.R' 'RcppExports.R' 'ggumProbability.R'
'tune_proposals.R' 'tune_temps.R' 'ggumMCMC.R' 'ggumMC3.R'
'ggum_simulation.R' 'color_palettes.R' 'irf.R' 'icc.R'
'summary.R' 'post_process.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-18 23:31:56 UTC; jb</td>
</tr>
<tr>
<td>Author:</td>
<td>JBrandon Duck-Mayr
    <a href="https://orcid.org/0000-0002-2231-1294"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jacob Montgomery [aut],
  Patrick Silva [ctb],
  Luwei Ying [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>JBrandon Duck-Mayr &lt;j.duckmayr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-19 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bggum'>bggum</h2><span id='topic+bggum'></span><span id='topic+bggum-package'></span>

<h3>Description</h3>

<p>bggum provides R tools for the Bayesian estimation of generalized graded
unfolding model (Roberts, Donoghue, and Laughlin 2000) parameters.
Please see the vignette (via <code>vignette("bggum")</code>) for a practical
guide to Bayesian estimation of GGUM parameters.
Duck-Mayr and Montgomery (2019) provides a more detailed theoretical
discussion of Bayesian estimation of GGUM parameters.
</p>


<h3>Author(s)</h3>

<p>JBrandon Duck-Mayr and Jacob Montgomery
</p>


<h3>References</h3>

<p>Duck-Mayr, JBrandon, and Jacob Montgomery. 2019.
&ldquo;Ends Against the Middle: Scaling Votes When Ideological Opposites
Behave the Same for Antithetical Reasons.&rdquo;
<a href="http://jbduckmayr.com/papers/ggum.pdf">http://jbduckmayr.com/papers/ggum.pdf</a>.
</p>
<p>Roberts, James S., John R. Donoghue, and James E. Laughlin. 2000.
&ldquo;A General Item Response Theory Model for Unfolding Unidimensional
Polytomous Responses.&rdquo; <em>Applied Psychological Measurement</em>
24(1): 3&ndash;32.
</p>

<hr>
<h2 id='color_palettes'>Color palettes provided by <code>bggum</code>.</h2><span id='topic+color_palettes'></span><span id='topic+okabe_ito'></span><span id='topic+tango'></span>

<h3>Description</h3>

<p>bggum provides color palettes that can be used with its plotting functions.
The <code>okabe_ito</code> palette is the eight color, colorblind-friendly palette
from Okabe and Ito (2008).
The <code>tango</code> palette is comprised of six colors from the Tango palette
(Tango Desktop Project 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>okabe_ito(n)

tango(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color_palettes_+3A_n">n</code></td>
<td>
<p>An integer vector of length one; the number of colors to return.
If <code>n</code> is greater than the number of colors in the palette, the
colors will be recycled so that the result is of length <code>n</code>.</p>
</td></tr>
</table>


<h3>Palettes provided</h3>


<dl>
<dt>okabe_ito</dt><dd><p>c(&quot;#e69f00&quot;, &quot;#56b4e9&quot;, &quot;#009e73&quot;, &quot;#f0e442&quot;,
&quot;#0072b2&quot;, &quot;#d55e00&quot;, &quot;#cc79a7&quot;, &quot;#000000&quot;)</p>
</dd>
<dt>tango</dt><dd><p>c(&quot;#cc0000&quot;, &quot;#75507b&quot;, &quot;#73d216&quot;, &quot;#f57900&quot;, &quot;#3465a4&quot;,
&quot;#555753&quot;)</p>
</dd>
</dl>



<h3>References</h3>

<p>Okabe, Masataka and Kei Ito. 2008.
&ldquo;Color Universal Design.&rdquo;
<a href="https://jfly.uni-koeln.de/color/">https://jfly.uni-koeln.de/color/</a>.
</p>
<p>Tango Desktop Project. 2013.
&ldquo;Tango Icon Theme Guidelines.&rdquo;
<a href="https://web.archive.org/web/20160202102503/http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines">https://web.archive.org/web/20160202102503/http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Palettes that are a subset of the total available colors
okabe_ito(3)
tango(3)
## Palettes that need more colors than are available -- leads to recycling
okabe_ito(10)
tango(10)

</code></pre>

<hr>
<h2 id='ggum_simulation'>GGUM Simulation</h2><span id='topic+ggum_simulation'></span>

<h3>Description</h3>

<p>Generates randomly drawn item and person parameters, and simulated responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggum_simulation(n, m, K, theta = NULL, alpha = NULL, delta = NULL,
  tau = NULL, theta_params = c(0, 1), alpha_params = c(1.5, 1.5,
  0.25, 4), delta_params = c(2, 2, -5, 5), tau_params = c(1.5, 1.5, -2,
  0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggum_simulation_+3A_n">n</code></td>
<td>
<p>An integer vector of length one giving the number of respondents</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_m">m</code></td>
<td>
<p>An integer vector of length one giving the number of items</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_k">K</code></td>
<td>
<p>An integer vector giving the number of options for each item;
if the vector is of length one, all m items will have the same number of
options.</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_theta">theta</code></td>
<td>
<p>(Optional) A numeric vector of respondents' latent traits;
if not given, the values are drawn from a normal distribution whose
mean and standard deviation are given by the <code>theta_params</code> parameter</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_alpha">alpha</code></td>
<td>
<p>(Optional) A numeric vector of items' discrimination parameters;
if not given, the values are drawn from a four parameter beta distribution
whose parameters are given by <code>alpha_params</code></p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_delta">delta</code></td>
<td>
<p>(Optional) A numeric vector of items' location parameters;
if not given, the values are drawn from a four parameter beta distribution
whose parameters are given by <code>delta_params</code></p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_tau">tau</code></td>
<td>
<p>(Optional) A list of numeric vectors giving each item's option
thresholds; if not given, the values are drawn from a four parameter beta
distribution whose parameters are given by <code>tau_params</code></p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_theta_params">theta_params</code></td>
<td>
<p>A numeric vector of length two; the mean and standard
deviation of the normal distribution theta is drawn from</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_alpha_params">alpha_params</code></td>
<td>
<p>A numeric vector of length four; the two shape
parameters and a and b values for the four parameter beta distribution
alpha is drawn from; the default is 1.5, 1.5, 0.25, and 4</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_delta_params">delta_params</code></td>
<td>
<p>A numeric vector of length four; the two shape
parameters and a and b values for the four parameter beta distribution
delta is drawn from; the default is 2, 2, -5, and 5</p>
</td></tr>
<tr><td><code id="ggum_simulation_+3A_tau_params">tau_params</code></td>
<td>
<p>A numeric vector of length four;the two shape
parameters and a and b values for the four parameter beta distribution
each tau vector is drawn from; the default is 1.5, 1.5, -2, and 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five elements; &quot;theta&quot; containing the theta draws,
&quot;alpha&quot; containing the alpha draws, &quot;delta&quot; containing the delta draws,
&quot;tau&quot; containing the tau draws, and &quot;response_matrix&quot; containing the
simulated response matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggumProbability">ggumProbability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with 10 items, each with four options, and 100 respondents
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 4)
str(sim_data)

</code></pre>

<hr>
<h2 id='ggumMC3'>GGUM MC3</h2><span id='topic+ggumMC3'></span>

<h3>Description</h3>

<p>Metropolis Coupled Markov Chain Monte Carlo (MC3) Sampling for the GGUM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggumMC3(data, sample_iterations = 10000, burn_iterations = 10000,
  sd_tune_iterations = 5000, temp_tune_iterations = 5000,
  temp_n_draws = 2500, swap_interval = 1, flip_interval = NA,
  n_temps = length(temps), temps = NULL, optimize_temps = TRUE,
  temp_multiplier = 0.1, proposal_sds = NULL, theta_init = NULL,
  alpha_init = NULL, delta_init = NULL, tau_init = NULL,
  theta_prior_params = c(0, 1), alpha_prior_params = c(1.5, 1.5, 0.25,
  4), delta_prior_params = c(2, 2, -5, 5), tau_prior_params = c(2, 2,
  -6, 6), return_sds = TRUE, return_temps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggumMC3_+3A_data">data</code></td>
<td>
<p>An integer matrix giving the individuals' responses;
note the item options should be of the form 0, 1, ...
(an example of preparing data for analysis is given in the vignette,
available via <code>vignette("bggum")</code>)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_sample_iterations">sample_iterations</code></td>
<td>
<p>An integer vector of length one giving the number
of iterations the sampler should complete (default is 10000)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_burn_iterations">burn_iterations</code></td>
<td>
<p>An integer vector of length one giving the number of
iterations to burn in (default is 10000)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_sd_tune_iterations">sd_tune_iterations</code></td>
<td>
<p>An integer vector of length one; the number of
iterations to use to tune the proposals before the burn-in period
begins (default is 5000). If 0 is given, the proposals are not tuned.</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_temp_tune_iterations">temp_tune_iterations</code></td>
<td>
<p>An integer vector of length one; if a
temperature schedule is not provided in the <code>temps</code> argument and
<code>optimize_temps</code> = TRUE, <code>temp_tune_iterations</code> gives the number
of iterations to use to tune each temperature before the burn-in period
begins (default is 5000) &ndash; see <code><a href="#topic+tune_temperatures">tune_temperatures</a></code></p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_temp_n_draws">temp_n_draws</code></td>
<td>
<p>An integer vector of length one; if a temperature
schedule is not provided in the <code>temps</code> argument and
<code>optimize_temps</code> = TRUE, <code>temp_n_draws</code> gives the number
of draws from the temperature finding algorithm to calculate each
temperature (default is 2500) &ndash; see <code><a href="#topic+tune_temperatures">tune_temperatures</a></code></p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_swap_interval">swap_interval</code></td>
<td>
<p>The period by which to attempt chain swaps;
e.g. if swap_interval = 100, a state swap will be proposed between two
adjacent chains every 100 iterations (default is 1)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_flip_interval">flip_interval</code></td>
<td>
<p>(Optional) If given, provides the number of iterations
after which the sign of the thetas and deltas should be changed.
For example, if <code>flip_interval = 1000</code>,
every 1000 iterations the theta and delta parameters will be multiplied
by -1 (a valid parameter value change as discussed in Geyer (1991)).</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_n_temps">n_temps</code></td>
<td>
<p>The number of chains; should only be given if <code>temps</code>
is not specified</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_temps">temps</code></td>
<td>
<p>(Optional) A numeric vector giving the temperatures;
if not provided and <code>optimize_temps = FALSE</code>, each temperature T_t
for t &gt; 1 is given by
1 / (1 + <code>temp_multiplier</code> * (t-1)), and T_1 = 1,
while if <code>optimize_temps = TRUE</code>, the temperature schedule is
determined according to an optimal temperature finding algorithm
&ndash; see <code><a href="#topic+tune_temperatures">tune_temperatures</a></code></p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_optimize_temps">optimize_temps</code></td>
<td>
<p>A logical vector of length one; if TRUE and a
temperature schedule is not provided in the <code>temps</code> argument,
an algorithm is run to determine the optimal temperature schedule
(default is TRUE) &ndash; see <code><a href="#topic+tune_temperatures">tune_temperatures</a></code></p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_temp_multiplier">temp_multiplier</code></td>
<td>
<p>A numeric vector of length one; if a temperature
schedule is not provided and <code>optimize_temps = FALSE</code>,
controls the differences between temperatures as described in the
description of the <code>temps</code> argument (default is 0.1)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_proposal_sds">proposal_sds</code></td>
<td>
<p>(Optional) A list of length four where is element is a
numeric vector giving standard deviations for the proposals;
the first element should be a numeric vector with a standard deviation
for the proposal for each respondent's theta parameter (the latent trait),
the second a vector with a standard deviation for each item's alpha
(discrimination) parameter, the third a vector with a standard deviation
for each item's delta (location) parameter, and the fourth a vector with
a standard deviation for each item's tau (option threshold) parameters.
If not given, the standard deviations are all set to 1.0 before any
tuning begins.</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_theta_init">theta_init</code></td>
<td>
<p>(Optional) Either a numeric vector giving an initial value
for each respondent's theta parameter, or a numeric matrix giving an
initial value for each respondent's theta parameter for each parallel chain;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_alpha_init">alpha_init</code></td>
<td>
<p>(Optional) Either a numeric vector giving an initial value
for each item's alpha parameter, or a numeric matrix giving an
initial value for each item's alpha parameter for each parallel chain;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_delta_init">delta_init</code></td>
<td>
<p>(Optional) Either a numeric vector giving an initial value
for each item's delta parameter, or a numeric matrix giving an
initial value for each item's delta parameter for each parallel chain;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_tau_init">tau_init</code></td>
<td>
<p>(Optional) Either a list giving an initial value
for each item's tau vector, or a list of lists giving an
initial value for each item's tau vector for each parallel chain;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_theta_prior_params">theta_prior_params</code></td>
<td>
<p>A numeric vector of length two;
the mean and standard deviation of theta parameters' prior distribution
(where the theta parameters have a normal prior; the default is 0 and 1)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_alpha_prior_params">alpha_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for alpha parameters' prior
distribution (where the alpha parameters have a four parameter beta prior;
the default is 1.5, 1.5, 0.25, and 4)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_delta_prior_params">delta_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for delta parameters' prior
distribution (where the delta parameters have a four parameter beta prior;
the default is 2, 2, -5, and 5)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_tau_prior_params">tau_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for tau parameters' prior
distribution (where the tau parameters have a four parameter beta prior;
the default is 2, 2, -6, and 6)</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_return_sds">return_sds</code></td>
<td>
<p>A logical vector of length one; if TRUE, the proposal
standard deviations are stored in an attribute of the returned object
named &quot;proposal_sds.&quot; The default is TRUE.</p>
</td></tr>
<tr><td><code id="ggumMC3_+3A_return_temps">return_temps</code></td>
<td>
<p>A logical vector of length one; if TRUE, the temperatures
of the parallel chains are stored in an attribute of the returned object
named &quot;temps.&quot; The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggumMC3</code> provides <code>R</code> implementation of the MC3 algorithm
from Duck-Mayr and Montgomery (2019).
Some details are provided in this help file, but please see the vignette
(via <code>vignette("bggum")</code>) for a full in-depth practical guide to
Bayesian estimation of GGUM parameters.
</p>
<p>Our sampler creates random initial values for the parameters of the model,
according to their prior distributions.
N parallel chains are run, each at a different inverse &quot;temperature&quot;;
the first &quot;cold&quot; chain has an inverse temperature of 1, and each subsequent
chain has increasingly lower values (still greater than zero,
i.e. fractional values).
At each iteration, for each chain, new parameter values are proposed
from a normal distribution with a mean of the current parameter value,
and the proposal is accepted probabilistically using a
Metropolis-Hastings acceptance ratio.
The purpose of the chains' &quot;temperatures&quot; is to increase the probability of
accepting proposals for chains other than the &quot;cold&quot; chain recorded for
inference; the acceptance probability in the Metropolis-Hastings
update steps for parameter values are raised to the power of the chain's
inverse temperature.
After every <code>swap_interval</code>th iteration of the sampler, a proposal is
made to swap states between adjacent chains as a Metropolis step.
For details, please read the vignette via <code>vignette("bggum")</code>,
or see Duck-Mayr and Montgomery (2019);
see also Gill (2008) and Geyer (1991).
</p>
<p>Before burn-in, the standard deviation of the proposal densities can be
tuned to ensure that the acceptance rate is neither too high nor too low
(we keep the acceptance rate between 0.2 and 0.25).
This is done if proposal standard deviations are not provided as an argument
and <code>sd_tune_iterations</code> is greater than 0.
</p>
<p>The temperature schedule can also be tuned using an implementation of the
temperature tuning algorithm in Atchadé, Roberts, and Rosenthal (2011).
This is done if a temperature schedule is not provided as an argument and
<code>optimize_temps = TRUE</code>.
If a temperature schedule is not provided and <code>optimize_temps = FALSE</code>,
each temperature T_t for t &gt; 1 is given by
1 / (1 + <code>temp_multiplier</code> * (t-1)), and T_1 = 1.
</p>


<h3>Value</h3>

<p>A numeric matrix giving the parameter values at each iteration
for the cold chain.
The matrix will additionally have classes &quot;ggum&quot;
(so that <code><a href="#topic+summary.ggum">summary.ggum</a></code> can be called on the result)
and &quot;mcmc&quot; with an &quot;mcpar&quot; attribute
(so that functions from the <code>coda</code> package can be used, e.g.
to assess convergence).
If <code>return_sds</code> is <code>TRUE</code>, the result also has an attribute
&quot;proposal_sds&quot;, which will be a list of length four giving the standard
deviations of the proposal densities for the theta, alpha, delta, and
tau parameters respectively.
If <code>return_temps</code> is <code>TRUE</code>, the result also has an attribute
&quot;temps&quot;, which will be a numeric vector giving the parallel chains'
inverse temperatures.
</p>


<h3>References</h3>

<p>Atchadé, Yves F., Gareth O. Roberts, and Jeffrey S. Rosenthal.
2011.  &ldquo;Towards Optimal Scaling of Metropolis-Coupled Markov Chain
Monte Carlo.&rdquo; <em>Statistics and Computing</em> 21(4): 555&ndash;68.
</p>
<p>Duck-Mayr, JBrandon, and Jacob Montgomery. 2019.
&ldquo;Ends Against the Middle: Scaling Votes When Ideological Opposites
Behave the Same for Antithetical Reasons.&rdquo;
<a href="http://jbduckmayr.com/papers/ggum.pdf">http://jbduckmayr.com/papers/ggum.pdf</a>.
</p>
<p>Geyer, Charles J. 1991. &ldquo;Markov Chain Monte Carlo Maximum
Likelihood.&rdquo; In Computing Science and Statistics. Proceedings of the 23rd
Symposium on the Interface, edited by E. M. Keramides, 156–63. Fairfax
Station, VA: Interface Foundation.
</p>
<p>Gill, Jeff. 2008. <em>Bayesian Methods: A Social and Behavioral
Sciences Approach</em>. 2d ed. Boca Raton, FL: Taylor &amp; Francis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggumProbability">ggumProbability</a></code>, <code><a href="#topic+ggumMCMC">ggumMCMC</a></code>,
<code><a href="#topic+tune_temperatures">tune_temperatures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: This is a toy example just to demonstrate the function, which uses
## a small dataset and an unreasonably low number of sampling interations.
## For a longer practical guide on Bayesian estimation of GGUM parameters,
## please see the vignette ( via vignette("bggum") ).
## We'll simulate data to use for this example:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 2)
## Now we can generate posterior draws:
## (for the purposes of example, we use 100 iterations,
## though in practice you would use much more)
draws &lt;- ggumMC3(data = sim_data$response_matrix, n_temps = 2,
                 sd_tune_iterations = 100, temp_tune_iterations = 100,
                 temp_n_draws = 50,
                 burn_iterations = 100, sample_iterations = 100)

</code></pre>

<hr>
<h2 id='ggumMCMC'>GGUM MCMC Sampler</h2><span id='topic+ggumMCMC'></span>

<h3>Description</h3>

<p>MCMC sampler for the generalized graded unfolding model (GGUM), utilizing
a Metropolis-Hastings algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggumMCMC(data, sample_iterations = 50000, burn_iterations = 50000,
  tune_iterations = 5000, flip_interval = NA, proposal_sds = NULL,
  theta_init = NULL, alpha_init = NULL, delta_init = NULL,
  tau_init = NULL, theta_prior_params = c(0, 1),
  alpha_prior_params = c(1.5, 1.5, 0.25, 4), delta_prior_params = c(2,
  2, -5, 5), tau_prior_params = c(2, 2, -6, 6), return_sds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggumMCMC_+3A_data">data</code></td>
<td>
<p>An integer matrix giving the response by each respondent to
each item; note the item options should be of the form 0, 1, ...
(an example of preparing data for analysis is given in the vignette,
available via <code>vignette("bggum")</code>)</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_sample_iterations">sample_iterations</code></td>
<td>
<p>An integer vector of length one;
the number of iterations the sampler should store (default is 50000)</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_burn_iterations">burn_iterations</code></td>
<td>
<p>An integer vector of length one; the number of
&quot;burn-in&quot; iterations to run, during which parameter draws are not
stored (default is 50000).</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_tune_iterations">tune_iterations</code></td>
<td>
<p>An integer vector of length one; the number of
iterations to use to tune the proposals before the burn-in period
begins (default is 5000). If 0 is given, the proposals are not tuned.</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_flip_interval">flip_interval</code></td>
<td>
<p>(Optional) If given, provides the number of iterations
after which the sign of the thetas and deltas should be changed.
For example, if <code>flip_interval = 1000</code>,
every 1000 iterations the theta and delta parameters will be multiplied
by -1 (a valid parameter value change as discussed in Geyer (1991)).</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_proposal_sds">proposal_sds</code></td>
<td>
<p>(Optional) A list of length four where is element is a
numeric vector giving standard deviations for the proposals;
the first element should be a numeric vector with a standard deviation
for the proposal for each respondent's theta parameter (the latent trait),
the second a vector with a standard deviation for each item's alpha
(discrimination) parameter, the third a vector with a standard deviation
for each item's delta (location) parameter, and the fourth a vector with
a standard deviation for each item's tau (option threshold) parameters.
If not given, the standard deviations are all set to 1.0 before any
tuning begins.</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_theta_init">theta_init</code></td>
<td>
<p>(Optional) A numeric vector giving an initial value
for each respondent's theta parameter;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_alpha_init">alpha_init</code></td>
<td>
<p>(Optional) A numeric vector giving an initial value
for each item's alpha parameter;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_delta_init">delta_init</code></td>
<td>
<p>(Optional) A numeric vector giving an initial value
for each item's delta parameter;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_tau_init">tau_init</code></td>
<td>
<p>(Optional) A list giving an initial value
for each item's tau vector;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_theta_prior_params">theta_prior_params</code></td>
<td>
<p>A numeric vector of length two;
the mean and standard deviation of theta parameters' prior distribution
(where the theta parameters have a normal prior; the default is 0 and 1)</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_alpha_prior_params">alpha_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for alpha parameters' prior
distribution (where the alpha parameters have a four parameter beta prior;
the default is 1.5, 1.5, 0.25, and 4)</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_delta_prior_params">delta_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for delta parameters' prior
distribution (where the delta parameters have a four parameter beta prior;
the default is 2, 2, -5, and 5)</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_tau_prior_params">tau_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for tau parameters' prior
distribution (where the tau parameters have a four parameter beta prior;
the default is 2, 2, -6, and 6)</p>
</td></tr>
<tr><td><code id="ggumMCMC_+3A_return_sds">return_sds</code></td>
<td>
<p>A logical vector of length one; if TRUE, the proposal
standard deviations are stored in an attribute of the returned object
named &quot;proposal_sds.&quot; The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggumMCMC</code> provides <code>R</code> implementation of an MCMC sampler for
the GGUM, based heavily on the algorithm given in de la Torre et al (2006);
though the package allows parameter estimation from <code>R</code>,
the functions are actually written in <code>C++</code> to allow for reasonable
execution time.
Some details are provided in this help file, but please see the vignette
(via <code>vignette("bggum")</code>) for a full in-depth practical guide to
Bayesian estimation of GGUM parameters.
</p>
<p>Our sampler creates random initial values for the parameters of the model,
according to their prior distributions.
At each iteration, new parameter values are proposed
from a normal distribution with a mean of the current parameter value,
and the proposal is accepted probabilistically using a standard
Metropolis-Hastings acceptance ratio.
During burn-in, parameter draws are not stored.
Before burn-in, the standard deviation of the proposal densities can be
tuned to ensure that the acceptance rate is neither too high nor too low
(we keep the acceptance rate between 0.2 and 0.25).
This is done if proposal standard deviations are not provided as an argument
and <code>sd_tune_iterations</code> is greater than 0.
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>sample_iterations</code> rows
and one column for every parameter of the model, so that each element
of the matrix gives the value of a parameter for a particular iteration
of the MCMC algorithm.
The matrix will additionally have classes &quot;ggum&quot;
(so that <code><a href="#topic+summary.ggum">summary.ggum</a></code> can be called on the result)
and &quot;mcmc&quot; with an &quot;mcpar&quot; attribute
(so that functions from the <code>coda</code> package can be used, e.g.
to assess convergence).
If <code>return_sds</code> is <code>TRUE</code>, the result also has an attribute
&quot;proposal_sds&quot;, which will be a list of length four giving the standard
deviations of the proposal densities for the theta, alpha, delta, and
tau parameters respectively.
</p>


<h3>References</h3>

<p>de la Torre, Jimmy, Stephen Stark, and Oleksandr S.
Chernyshenko. 2006. &ldquo;Markov Chain Monte Carlo Estimation of Item
Parameters for the Generalized Graded Unfolding Model.&rdquo; <em>Applied
Psychological Measurement</em> 30(3): 216&ndash;232.
</p>
<p>Geyer, Charles J. 1991. &ldquo;Markov Chain Monte Carlo Maximum
Likelihood.&rdquo; In Computing Science and Statistics. Proceedings of the 23rd
Symposium on the Interface, edited by E. M. Keramides, 156–63. Fairfax
Station, VA: Interface Foundation.
</p>
<p>Roberts, James S., John R. Donoghue, and James E. Laughlin. 2000.
&ldquo;A General Item Response Theory Model for Unfolding Unidimensional
Polytomous Responses.&rdquo; <em>Applied Psychological Measurement</em>
24(1): 3&ndash;32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggumProbability">ggumProbability</a></code>, <code><a href="#topic+ggumMC3">ggumMC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: This is a toy example just to demonstrate the function, which uses
## a small dataset and an unreasonably low number of sampling interations.
## For a longer practical guide on Bayesian estimation of GGUM parameters,
## please see the vignette ( via vignette("bggum") ).
## We'll simulate data to use for this example:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 2)
## Now we can generate posterior draws:
## (for the purposes of example, we use 100 iterations,
## though in practice you would use much more)
draws &lt;- ggumMCMC(data = sim_data$response_matrix,
                  tune_iterations = 100,
                  burn_iterations = 100,
                  sample_iterations = 100)

</code></pre>

<hr>
<h2 id='ggumProbability'>GGUM Probability Function</h2><span id='topic+ggumProbability'></span>

<h3>Description</h3>

<p>Calculate the probability of a response according to the GGUM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggumProbability(response, theta, alpha, delta, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggumProbability_+3A_response">response</code></td>
<td>
<p>A numeric vector or matrix giving the response(s) for which
probability should be calculated.</p>
</td></tr>
<tr><td><code id="ggumProbability_+3A_theta">theta</code></td>
<td>
<p>A numeric vector of latent trait score(s) for respondent(s)</p>
</td></tr>
<tr><td><code id="ggumProbability_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector of discrimination parameter(s)</p>
</td></tr>
<tr><td><code id="ggumProbability_+3A_delta">delta</code></td>
<td>
<p>A numeric vector of location parameter(s)</p>
</td></tr>
<tr><td><code id="ggumProbability_+3A_tau">tau</code></td>
<td>
<p>A numeric vector (if responses to one item are given) or a list
(if responses to multiple items are given); the tau parameters for each
item is a numeric vector of length K (the number of possible responses)
giving the options' threshold parameters; the first element of <code>tau</code>
should be zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The General Graded Unfolding Model (GGUM) is an item response model
designed to consider the possibility of disagreement for opposite reasons.
This function gives the probability of a respondent's response to a test
item given item and respondent parameters. The user can calculate the
probability of one particular response to an item, for any number of the
possible responses to the item, the probability of a vector of responses
(either responses by one person to multiple items, or by multiple people to
one item), or the probability of each response in a response matrix.
</p>
<p>The probability that respondent <code class="reqn">i</code> chooses option <code class="reqn">k</code> for item
<code class="reqn">j</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{\exp (\alpha_j [k (\theta_i - \delta_j) -
\sum_{m=0}^k \tau_{jm}]) + \exp (\alpha_j [(2K - k - 1)
(\theta_i - \delta_j) - \sum_{m=0}^k \tau_{jm}])}{%
\sum_{l=0}^{K-1} [\exp (\alpha_j [l (\theta_i - \delta_j) -
\sum_{m=0}^l \tau_{jm}]) + \exp (\alpha_j [(2K - l - 1)
(\theta_i - \delta_j) - \sum_{m=0}^l \tau_{jm}])]}</code>
</p>
<p>,
where <code class="reqn">\theta_i</code> is <code class="reqn">i</code>'s latent trait parameter,
<code class="reqn">\alpha_j</code> is the item's discrimination parameter,
<code class="reqn">\delta_j</code> is the item's location parameter,
<code class="reqn">\tau_{j0}, \ldots, \tau_{j(K-1)}</code> are the options' threshold
parameters, and <code class="reqn">\tau_{j0}</code> is 0,
<code class="reqn">K</code> is the number of options for item <code class="reqn">j</code>, and
the options are indexed by <code class="reqn">k = 0, \ldots, K-1</code>.
</p>


<h3>Value</h3>

<p>A matrix or vector of the same dimensions/length of <code>response</code>.
</p>


<h3>Note</h3>

<p>Please note that items' options should be zero-indexed.
</p>


<h3>References</h3>

<p>de la Torre, Jimmy, Stephen Stark, and Oleksandr S.
Chernyshenko. 2006. &ldquo;Markov Chain Monte Carlo Estimation of Item
Parameters for the Generalized Graded Unfolding Model.&rdquo; <em>Applied
Psychological Measurement</em> 30(3): 216&ndash;232.
</p>
<p>Roberts, James S., John R. Donoghue, and James E. Laughlin. 2000.
&ldquo;A General Item Response Theory Model for Unfolding Unidimensional
Polytomous Responses.&rdquo; <em>Applied Psychological Measurement</em>
24(1): 3&ndash;32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## What is the probability of a 1 response to a dichotomous item
## with discrimination parameter 2, location parameter 0, and
## option threshold vector (0, -1) for respondents at -1, 0, and 1
## on the latent scale?
ggumProbability(response = rep(1, 3), theta = c(-1, 0, 1), alpha = 2,
                delta = 0, tau = c(0, -1))
## We can also use this function for getting the probability of all
## observed responses given the data and item and person parameter estimtes.
## Here's an example of that with some simulated data:
## Simulate data with 10 items, each with four options, and 100 respondents
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 4)
head(ggumProbability(response = sim_data$response_matrix,
                     theta = sim_data$theta,
                     alpha = sim_data$alpha,
                     delta = sim_data$delta,
                     tau = sim_data$tau))

</code></pre>

<hr>
<h2 id='icc'>Item Characteristic Curve</h2><span id='topic+icc'></span>

<h3>Description</h3>

<p>Plots item characteristic curves given alpha, delta, and tau parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc(a, d, t, from = -3, to = 3, by = 0.01, layout_matrix = 1,
  main_title = "Item Characteristic Curve", sub = "",
  color = "black", plot_responses = FALSE, thetas = NULL,
  responses = NULL, response_color = "#0000005f")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icc_+3A_a">a</code></td>
<td>
<p>A numeric vector of alpha parameters</p>
</td></tr>
<tr><td><code id="icc_+3A_d">d</code></td>
<td>
<p>A numeric vector of delta parameters</p>
</td></tr>
<tr><td><code id="icc_+3A_t">t</code></td>
<td>
<p>Either a list of numeric vectors for the tau parameters for each
option, or a numeric vector if the IRF for only one item is desired &ndash;
note the first element of each vector should be zero</p>
</td></tr>
<tr><td><code id="icc_+3A_from">from</code></td>
<td>
<p>A numeric vector of length one,
the lowest theta value to estimate response probabilities for;
default is -3</p>
</td></tr>
<tr><td><code id="icc_+3A_to">to</code></td>
<td>
<p>A numeric vector of length one,
the highest theta value to estimate response probabilities for;
default is 3</p>
</td></tr>
<tr><td><code id="icc_+3A_by">by</code></td>
<td>
<p>A numeric vector of length one giving the spacing between
theta values; default is 0.01</p>
</td></tr>
<tr><td><code id="icc_+3A_layout_matrix">layout_matrix</code></td>
<td>
<p>An integer matrix dictating the layout of the plot;
the default is a one-column matrix with one element for each item</p>
</td></tr>
<tr><td><code id="icc_+3A_main_title">main_title</code></td>
<td>
<p>A character vector giving the plots' main titles;
default is &quot;Item Characteristic Curve&quot;.</p>
</td></tr>
<tr><td><code id="icc_+3A_sub">sub</code></td>
<td>
<p>An optional character vector of subtitles for the resulting plots,
to be pasted onto the main title (helpful for titling individual plots
when plotting multiple items' ICCs).</p>
</td></tr>
<tr><td><code id="icc_+3A_color">color</code></td>
<td>
<p>The color to plot the ICC line in; default is &quot;black&quot;</p>
</td></tr>
<tr><td><code id="icc_+3A_plot_responses">plot_responses</code></td>
<td>
<p>A logical vector of length one specifying whether to
draw points at the theta estimates of actual responses; default is FALSE</p>
</td></tr>
<tr><td><code id="icc_+3A_thetas">thetas</code></td>
<td>
<p>An optional vector of theta estimates for response drawing;
if <code>plot_responses = TRUE</code> and <code>thetas</code> is not provided,
an error will be thrown.</p>
</td></tr>
<tr><td><code id="icc_+3A_responses">responses</code></td>
<td>
<p>An optional matrix or vector (if the ICC for only one item
is desired) of responses; if <code>plot_responses = TRUE</code> and
<code>responses</code> is not provided, an error will be thrown.
NOTE: The lowest response for each item should be 0, not 1.</p>
</td></tr>
<tr><td><code id="icc_+3A_response_color">response_color</code></td>
<td>
<p>The color to plot the response points when
<code>plot_responses = TRUE</code>; the default is <code>"#0000005f"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## We'll simulate data to use for these examples:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 4)
## You can plot the ICC for one item:
icc(sim_data$alpha[1], sim_data$delta[1], sim_data$tau[[1]])
## Or multiple items:
icc(sim_data$alpha[1:2], sim_data$delta[1:2], sim_data$tau[1:2], sub = 1:2)
## You can also plot the actual responses over the expected response line:
icc(sim_data$alpha[1], sim_data$delta[1], sim_data$tau[[1]],
    plot_responses = TRUE, responses = sim_data$response_matrix[ , 1],
    thetas = sim_data$theta)

</code></pre>

<hr>
<h2 id='irf'>Item Response Function</h2><span id='topic+irf'></span>

<h3>Description</h3>

<p>Plots response functions given alpha, delta, and tau parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irf(a, d, t, from = -3, to = 3, by = 0.01, layout_matrix = 1,
  main_title = "Item Response Function", sub = "",
  option_names = NULL, line_types = NULL, color = "black",
  rug = FALSE, thetas = NULL, responses = NULL, sides = 1,
  rug_colors = "black")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irf_+3A_a">a</code></td>
<td>
<p>A numeric vector of alpha parameters</p>
</td></tr>
<tr><td><code id="irf_+3A_d">d</code></td>
<td>
<p>A numeric vector of delta parameters</p>
</td></tr>
<tr><td><code id="irf_+3A_t">t</code></td>
<td>
<p>Either a list of numeric vectors for the tau parameters for each
option, or a numeric vector if the IRF for only one item is desired &ndash;
note the first element of each vector should be zero</p>
</td></tr>
<tr><td><code id="irf_+3A_from">from</code></td>
<td>
<p>A numeric vector of length one,
the lowest theta value to estimate response probabilities for;
default is -3</p>
</td></tr>
<tr><td><code id="irf_+3A_to">to</code></td>
<td>
<p>A numeric vector of length one,
the highest theta value to estimate response probabilities for;
default is 3</p>
</td></tr>
<tr><td><code id="irf_+3A_by">by</code></td>
<td>
<p>A numeric vector of length one giving the spacing between
theta values; default is 0.01</p>
</td></tr>
<tr><td><code id="irf_+3A_layout_matrix">layout_matrix</code></td>
<td>
<p>An integer matrix dictating the layout of the plot;
the default is a one-column matrix with one element for each item</p>
</td></tr>
<tr><td><code id="irf_+3A_main_title">main_title</code></td>
<td>
<p>A character vector giving the plots' main titles;
default is &quot;Item Response Function&quot;.</p>
</td></tr>
<tr><td><code id="irf_+3A_sub">sub</code></td>
<td>
<p>An optional character vector of subtitles for the resulting plots,
to be pasted onto the main title (helpful for titling individual plots
when plotting multiple items' IRFs).</p>
</td></tr>
<tr><td><code id="irf_+3A_option_names">option_names</code></td>
<td>
<p>An optional character vector giving names for the items'
options; if NULL, generic names (e.g. &quot;Option 1&quot;, &quot;Option 2&quot;, etc.)
are used</p>
</td></tr>
<tr><td><code id="irf_+3A_line_types">line_types</code></td>
<td>
<p>An optional integer vector specifying lty for each option;
if not provided, the first option for each question will have lty = 1,
the second will have lty = 2, etc.</p>
</td></tr>
<tr><td><code id="irf_+3A_color">color</code></td>
<td>
<p>A specification of the colors to draw lines in. Colors can be
specified by either a character vector of colors (either names that R
recognizes or hexidecimal specifications) or a function taking a single
argument for the number of colors to return. See
<code><a href="#topic+color_palettes">color_palettes</a></code> for a list of color palettes provided
by <code>bggum</code>. The default is &quot;black&quot; (for all lines).</p>
</td></tr>
<tr><td><code id="irf_+3A_rug">rug</code></td>
<td>
<p>A logical vector of length one specifying whether to draw a
rug of theta estimates; the default is FALSE</p>
</td></tr>
<tr><td><code id="irf_+3A_thetas">thetas</code></td>
<td>
<p>An optional vector of theta estimates for rug drawing;
if <code>rug = TRUE</code> and <code>thetas</code> is not provided,
an error will be thrown.</p>
</td></tr>
<tr><td><code id="irf_+3A_responses">responses</code></td>
<td>
<p>An optional matrix or vector (if the IRF for only one item
is desired) of responses; if <code>rug = TRUE</code> and <code>responses</code> is not
provided, an error will be thrown.
NOTE: The lowest response for each item should be 0, not 1.</p>
</td></tr>
<tr><td><code id="irf_+3A_sides">sides</code></td>
<td>
<p>A vector giving the side(s) to draw the rug on if
<code>rug = TRUE</code>; if the vector is of length &gt; 1, the first option for
each item will be drawn on the side given by the first element of the
vector, the rug for the second option for each item will be drawn on the
side given by the second element of the vector, etc.</p>
</td></tr>
<tr><td><code id="irf_+3A_rug_colors">rug_colors</code></td>
<td>
<p>A vector giving the color(s) to draw the rug in if
<code>rug = TRUE</code> or a function taking a single argument for the number of
colors to return. See <code><a href="#topic+color_palettes">color_palettes</a></code> for a list of color
palettes provided by <code>bggum</code>. The default is &quot;black&quot; (for all rugs).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## We'll simulate data to use for these examples:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 4)
## You can plot the IRF for one item:
irf(sim_data$alpha[1], sim_data$delta[1], sim_data$tau[[1]],
    option_names = 0:3)
## Or multiple items:
irf(sim_data$alpha[1:2], sim_data$delta[1:2], sim_data$tau[1:2],
    option_names = 0:3, sub = 1:2)
## You can plot it in color:
irf(sim_data$alpha[1], sim_data$delta[1], sim_data$tau[[1]],
    option_names = 0:3, color = tango)
## You can also plot a rug of the repsondents' theta estimates with the IRF
irf(sim_data$alpha[1], sim_data$delta[1], sim_data$tau[[1]],
    rug = TRUE, responses = sim_data$response_matrix[ , 1],
    thetas = sim_data$theta, option_names = 0:3)

</code></pre>

<hr>
<h2 id='post_process'>Post-process a Posterior Sample</h2><span id='topic+post_process'></span>

<h3>Description</h3>

<p>Post-process the results of <code><a href="#topic+ggumMCMC">ggumMCMC</a></code> or <code><a href="#topic+ggumMC3">ggumMC3</a></code>
using an artificial identifiability constraint (AIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_process(sample, constraint, expected_sign)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post_process_+3A_sample">sample</code></td>
<td>
<p>A numeric matrix of posterior draws as returned by
<code><a href="#topic+ggumMCMC">ggumMCMC</a></code> or <code><a href="#topic+ggumMC3">ggumMC3</a></code>.</p>
</td></tr>
<tr><td><code id="post_process_+3A_constraint">constraint</code></td>
<td>
<p>An integer vector of length one giving the column number
of the parameter to constrain, or a character vector of length one giving
the column name for the constraint.</p>
</td></tr>
<tr><td><code id="post_process_+3A_expected_sign">expected_sign</code></td>
<td>
<p>A character vector of length one giving the sign for
the constraint; it should be either &quot;-&quot; if the constrained parameter is
to be negative or &quot;+&quot; if the constrained parameter is to be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since under the GGUM the probability of a response is the same for any given
choice of theta and delta parameters and the negative of that choice; i.e.
</p>
<p style="text-align: center;"><code class="reqn">Pr(z | \theta, \alpha, \delta, \tau) = Pr(z | -\theta, \alpha, -\delta, \tau),</code>
</p>

<p>if symmetric priors are used, the posterior has a reflective mode.
This function transforms a posterior sample by enforcing a constraint
that a particular parameter is of a given sign, essentially transforming
it into a sample from only one of the reflective modes if a suitable
constraint is chosen; using a sufficiently extreme parameter is suggested.
</p>
<p>Please see the vignette (via <code>vignette("bggum")</code>) for a full in-depth
practical guide to Bayesian estimation of GGUM parameters.
</p>


<h3>Value</h3>

<p>A numeric matrix, the post-processed sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggumMCMC">ggumMCMC</a></code>, <code><a href="#topic+ggumMC3">ggumMC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: This is a toy example just to demonstrate the function, which uses
## a small dataset and an unreasonably low number of sampling interations.
## For a longer practical guide on Bayesian estimation of GGUM parameters,
## please see the vignette ( via vignette("bggum") ).
## We'll simulate data to use for this example:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 2)
## Now we can generate posterior draws
## (for the purposes of example, we use 100 iterations,
## though in practice you would use much more)
draws &lt;- ggumMC3(data = sim_data$response_matrix, n_temps = 2,
                 sd_tune_iterations = 100, temp_tune_iterations = 100,
                 temp_n_draws = 50,
                 burn_iterations = 100, sample_iterations = 100)
## Then you can post-process the output
processed_draws &lt;- post_process(sample = draws,
                                constraint = which.min(sim_data$theta),
                                expected_sign = "-")

</code></pre>

<hr>
<h2 id='summary.ggum'>Summarize Posterior Draws for GGUM Parameters</h2><span id='topic+summary.ggum'></span><span id='topic+summary.list'></span>

<h3>Description</h3>

<p>Summarize the results of <code><a href="#topic+ggumMCMC">ggumMCMC</a></code> or <code><a href="#topic+ggumMC3">ggumMC3</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggum'
summary(object, ...)

## S3 method for class 'list'
summary(object, ..., combine = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ggum_+3A_object">object</code></td>
<td>
<p>A numeric matrix of posterior draws as returned by
<code><a href="#topic+ggumMCMC">ggumMCMC</a></code> or <code><a href="#topic+ggumMC3">ggumMC3</a></code>, or a list of
such matrices.</p>
</td></tr>
<tr><td><code id="summary.ggum_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods</p>
</td></tr>
<tr><td><code id="summary.ggum_+3A_combine">combine</code></td>
<td>
<p>A logical vector of length one; if <code>TRUE</code> and
<code>object</code> is a list of <code>ggum</code> result objects, the matrices are
combined and a summary of the combined sample is given; if <code>FALSE</code>
and <code>object</code> is a list of <code>ggum</code> result objects, each matrix
will be summarized individually; and if <code>object</code> is not a list, it
has no effect. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the posterior mean, median, standard deviation,
and 0.025 and 0.975 quantiles for GGUM parameters from posterior samples
drawn using <code><a href="#topic+ggumMCMC">ggumMCMC</a></code> or <code><a href="#topic+ggumMC3">ggumMC3</a></code>.
Please note that the quantiles are calculated using the type 8 algorithm
from Hyndman and Fan (1996), as suggested by Hyndman and Fan (1996), rather
than the type 7 algorithm that would be the default from R's
<code>quantile()</code>).
Before calling this function, care should be taken to ensure that
post-processing has been done if necessary to identify the correct
reflective posterior mode, as discussed in the vignette and Duck-Mayr and
Montgomery (2019).
</p>
<p>Please see the vignette (via <code>vignette("bggum")</code>) for a full in-depth
practical guide to Bayesian estimation of GGUM parameters.
</p>


<h3>Value</h3>

<p>A list with three elements: estimates (a list of length four;
a numeric vector giving the means of the theta draws, a numeric vector
giving the means of the alpha draws, a numeric vector giving the means
of the delta draws, and a list where the means of the tau draws are
collated into a tau estimate vector for each item), sds (a list of length
four giving the posterior standard deviations for the theta, alpha, delta,
and tau draws), and statistics (a matrix with five columns and one row
for each parameter giving the 0.025 quantile, the 0.5 quantile, the mean,
the 0.975 quantile, and the standard deviation of the posterior draws
for each parameter; please note the quantiles are calculated using the
type 8 algorithm from Hyndman and Fan 1996, as suggested by Hyndman and
Fan 1996, rather than the type 7 algorithm that would be the default
from R's <code>quantile()</code>).
</p>
<p>If <code>object</code> is a list and <code>combine</code> is <code>FALSE</code>,
a list of such lists will be returned.
</p>


<h3>References</h3>

<p>Duck-Mayr, JBrandon, and Jacob Montgomery. 2019.
&ldquo;Ends Against the Middle: Scaling Votes When Ideological Opposites
Behave the Same for Antithetical Reasons.&rdquo;
<a href="http://jbduckmayr.com/papers/ggum.pdf">http://jbduckmayr.com/papers/ggum.pdf</a>.
</p>
<p>Hyndman, R. J. and Fan, Y. 1996. &ldquo;Sample Quantiles in
Packages.&rdquo; <em>American Statistician</em> 50, 361&ndash;365.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggumMCMC">ggumMCMC</a></code>, <code><a href="#topic+ggumMC3">ggumMC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: This is a toy example just to demonstrate the function, which uses
## a small dataset and an unreasonably low number of sampling interations.
## For a longer practical guide on Bayesian estimation of GGUM parameters,
## please see the vignette ( via vignette("bggum") ).
## We'll simulate data to use for this example:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 2)
## Now we can generate posterior draws
## (for the purposes of example, we use 100 iterations,
## though in practice you would use much more)
draws &lt;- ggumMC3(data = sim_data$response_matrix, n_temps = 2,
                 sd_tune_iterations = 100, temp_tune_iterations = 100,
                 temp_n_draws = 50,
                 burn_iterations = 100, sample_iterations = 100)
## Then post-process the output
processed_draws &lt;- post_process(sample = draws,
                                constraint = which.min(sim_data$theta),
                                expected_sign = "-")
## And now we can obtain a summary of the posterior
posterior_summary &lt;- summary(processed_draws)
## It contains all the parameter estimates
str(posterior_summary$estimates)
## As well as the posterior standard deviations
str(posterior_summary$sds)
## And a matrix of the mean (estimates), median, standard deviations,
## and 0.025 and 0.975 quantiles
head(posterior_summary$statistics)

</code></pre>

<hr>
<h2 id='tune_proposals'>Tune proposal densities</h2><span id='topic+tune_proposals'></span>

<h3>Description</h3>

<p>Tunes the standard deviation for the parameters' proposal densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_proposals(data, tune_iterations, K = NULL, thetas = NULL,
  alphas = NULL, deltas = NULL, taus = NULL,
  theta_prior_params = c(0, 1), alpha_prior_params = c(1.5, 1.5, 0.25,
  4), delta_prior_params = c(2, 2, -5, 5), tau_prior_params = c(2, 2,
  -6, 6))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tune_proposals_+3A_data">data</code></td>
<td>
<p>An integer matrix giving the response by each
respondent to each item</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_tune_iterations">tune_iterations</code></td>
<td>
<p>An integer vector of length one;
the number of iterations to complete</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_k">K</code></td>
<td>
<p>(Optional) A numeric vector with an element for each item giving
the number of options for the item; if not provided, it is generated by
taking the number of unique options observed in the data</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_thetas">thetas</code></td>
<td>
<p>(Optional) A numeric vector giving an initial value
for each respondent's theta parameter;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_alphas">alphas</code></td>
<td>
<p>(Optional) A numeric vector giving an initial value
for each item's alpha parameter;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_deltas">deltas</code></td>
<td>
<p>(Optional) A numeric vector giving an initial value
for each item's delta parameter;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_taus">taus</code></td>
<td>
<p>(Optional) A list giving an initial value
for each item's tau vector;
if not given, the initial values are drawn from the prior distribution</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_theta_prior_params">theta_prior_params</code></td>
<td>
<p>A numeric vector of length two;
the mean and standard deviation of theta parameters' prior distribution
(where the theta parameters have a normal prior; the default is 0 and 1)</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_alpha_prior_params">alpha_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for alpha parameters' prior
distribution (where the alpha parameters have a four parameter beta prior;
the default is 1.5, 1.5, 0.25, and 4)</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_delta_prior_params">delta_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for delta parameters' prior
distribution (where the delta parameters have a four parameter beta prior;
the default is 2, 2, -5, and 5)</p>
</td></tr>
<tr><td><code id="tune_proposals_+3A_tau_prior_params">tau_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for tau parameters' prior
distribution (where the tau parameters have a four parameter beta prior;
the default is 2, 2, -6, and 6)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs the MCMC algorithm for the number of iterations
specified in <code>tune_iterations</code>, updating parameter values at each
iteration. Every 100 iterations, the function determines how many
of the previous 100 iterations resulted in an accepted proposal for
each parameter. If the number of acceptances was less than 20,
the standard deviation of the proposal for that parameter is
decreased by (20 - N) * 0.01, where N is the number of acceptances in
the previous 100 iterations. If N is greater than 25, the proposal
standard deviation is increased by (N - 25) * 0.01.
</p>
<p>Please see the vignette (via <code>vignette("bggum")</code>) for a full in-depth
practical guide to Bayesian estimation of GGUM parameters.
</p>


<h3>Value</h3>

<p>A list, where each element is a numeric vector;
the first element is a numeric vector of standard deviations for the
theta parameters' proposals, the second for the alpha parameters, the
third for the delta parameters, and the fourth for the tau parameters
</p>


<h3>Warning</h3>

<p>The parameters are updated in place;
that is, if you supply objects for the <code>theta</code>, <code>alpha</code>,
<code>delta</code>, and <code>tau</code> arguments, the objects will not hold the
same values after the function is run
(in the underlying C++ function, these objects are passed by reference).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: This is a toy example just to demonstrate the function, which uses
## a small dataset and an unreasonably low number of tuning interations.
## For a longer practical guide on Bayesian estimation of GGUM parameters,
## please see the vignette ( via vignette("bggum") ).
## We'll simulate data to use for this example
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 2)
## Now we can tune the proposal densities
## (for the purposes of example, we use 100 iterations,
## though in practice you would use much more)
proposal_sds &lt;- tune_proposals(data = sim_data$response_matrix,
                               tune_iterations = 100)

</code></pre>

<hr>
<h2 id='tune_temperatures'>tune_temperatures</h2><span id='topic+tune_temperatures'></span>

<h3>Description</h3>

<p>Find Optimal Temperatures for the GGUM MCMCMC Sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_temperatures(data, n_temps, temp_tune_iterations = 5000,
  n_draws = 2500, K = NULL, proposal_sds = NULL,
  sd_tune_iterations = 5000, theta_prior_params = c(0, 1),
  alpha_prior_params = c(1.5, 1.5, 0.25, 4), delta_prior_params = c(2,
  2, -5, 5), tau_prior_params = c(2, 2, -6, 6))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tune_temperatures_+3A_data">data</code></td>
<td>
<p>An integer matrix giving the response by each
respondent to each item</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_n_temps">n_temps</code></td>
<td>
<p>How many temperatures to make?</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_temp_tune_iterations">temp_tune_iterations</code></td>
<td>
<p>How many iterations should the temperature
tuning algorithm run for each temperature? (default is 5000)</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_n_draws">n_draws</code></td>
<td>
<p>How many draws should be used to determine each temperature?
(specifying n_draws &lt; temp_tune_iterations will result in an error;
default is 2500).</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_k">K</code></td>
<td>
<p>(Optional) A numeric vector with an element for each item giving
the number of options for the item; if not provided, it is generated by
taking the number of unique options observed in the data</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_proposal_sds">proposal_sds</code></td>
<td>
<p>(Optional) A list of length four where is element is a
numeric vector giving standard deviations for the proposals;
the first element should be a numeric vector with a standard deviation
for the proposal for each respondent's theta parameter (the latent trait),
the second a vector with a standard deviation for each item's alpha
(discrimination) parameter, the third a vector with a standard deviation
for each item's delta (location) parameter, and the fourth a vector with
a standard deviation for each item's tau (option threshold) parameters.
If not given, the standard deviations are all set to 1.0 before any
tuning begins.</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_sd_tune_iterations">sd_tune_iterations</code></td>
<td>
<p>A numeric vector of length one; if proposal
standard deviations are not given, this provides the number of
iterations to use to tune the proposals before the temperature finding
algorithm begins (default is 5000)</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_theta_prior_params">theta_prior_params</code></td>
<td>
<p>A numeric vector of length two;
the mean and standard deviation of theta parameters' prior distribution
(where the theta parameters have a normal prior; the default is 0 and 1)</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_alpha_prior_params">alpha_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for alpha parameters' prior
distribution (where the alpha parameters have a four parameter beta prior;
the default is 1.5, 1.5, 0.25, and 4)</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_delta_prior_params">delta_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for delta parameters' prior
distribution (where the delta parameters have a four parameter beta prior;
the default is 2, 2, -5, and 5)</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_tau_prior_params">tau_prior_params</code></td>
<td>
<p>A numeric vector of length four;
the two shape parameters and a and b values for tau parameters' prior
distribution (where the tau parameters have a four parameter beta prior;
the default is 2, 2, -6, and 6)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Atchadé, Roberts, and Rosenthal (2011) determine the optimal swap-acceptance
rate for Metropolis-coupled MCMC and provide an algorithm for building
optimal temperature schedules. We implement this algorithm in the context of
the GGUM to provide a temperature schedule that should result in
approximately 0.234 swap acceptance rate between adjacent chains.
</p>
<p>Please see the vignette (via <code>vignette("bggum")</code>) for a full in-depth
practical guide to Bayesian estimation of GGUM parameters.
</p>


<h3>Value</h3>

<p>A numeric vector of temperatures
</p>


<h3>References</h3>

<p>Atchadé, Yves F., Gareth O. Roberts, and Jeffrey S. Rosenthal.
2011.  &ldquo;Towards Optimal Scaling of Metropolis-Coupled Markov Chain
Monte Carlo.&rdquo; <em>Statistics and Computing</em> 21(4): 555&ndash;68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggumMCMC">ggumMCMC</a></code>, <code><a href="#topic+ggumMC3">ggumMC3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: This is a toy example just to demonstrate the function, which uses
## a small dataset and an unreasonably low number of sampling interations.
## For a longer practical guide on Bayesian estimation of GGUM parameters,
## please see the vignette ( via vignette("bggum") ).
## We'll simulate data to use for this example:
set.seed(123)
sim_data &lt;- ggum_simulation(100, 10, 2)
## Now we can tune the temperature schedule:
## (for the purposes of example, we use 100 iterations,
## though in practice you would use much more)
temps &lt;- tune_temperatures(data = sim_data$response_matrix, n_temps = 5,
                           temp_tune_iterations = 100, n_draws = 50,
                           sd_tune_iterations = 100)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
