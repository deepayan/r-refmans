<!DOCTYPE html><html lang="en"><head><title>Help for package VLMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VLMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha2int'><p>&lsquo;Single Character&rsquo; &lt;&ndash;&gt; Integer Conversion for Discrete Data</p></a></li>
<li><a href='#alphabet'><p>The Alphabet in Use</p></a></li>
<li><a href='#as.dendrogram.vlmc'><p>Dendrogram Construction from VLMCs</p></a></li>
<li><a href='#bnrf1'><p>BNRF1 Gene DNA sequences: Epstein-Barr and Herpes</p></a></li>
<li><a href='#deviance.vlmc'><p>Compute the Deviance of a Fitted VLMC Object</p></a></li>
<li><a href='#draw.vlmc'><p>Draw a &quot;VLMC&quot; Object (in ASCII) as Tree</p></a></li>
<li><a href='#id2ctxt'><p>VLMC Context ID Conversion</p></a></li>
<li><a href='#int2char'><p>Character - Integer Conversion</p></a></li>
<li><a href='#logLik'><p>Log Likelihood of and between VLMC objects</p></a></li>
<li><a href='#OZrain'><p>Daily Rainfall in Melbourne, Australia, 1981-1990</p></a></li>
<li><a href='#predict.vlmc'><p>Prediction of VLMC for (new) Series</p></a></li>
<li><a href='#prt.vvec'><p>Recursively Print the VLMC Result Vector</p></a></li>
<li><a href='#RCplot'><p>Residuals vs Context plot</p></a></li>
<li><a href='#residuals.vlmc'><p>Compute Residuals of a Fitted VLMC Object</p></a></li>
<li><a href='#simulate.vlmc'><p>Simulate a Discrete Time Series from fitted VLMC model</p></a></li>
<li><a href='#summary.vlmc'><p>Summary of Fitted Variable Length Markov Chain (VLMC)</p></a></li>
<li><a href='#vlmc'><p>Fit a Variable Length Markov Chain (VLMC)</p></a></li>
<li><a href='#vlmc.version'><p>Version of VLMC Package</p></a></li>
<li><a href='#vlmctree'><p>Compute the tree structure of a &quot;vlmc&quot; object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.4-4</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Released 1.4-3-1 on 2019-04-29</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Variable Length Markov Chains ('VLMC') Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions, Classes &amp; Methods for estimation, prediction, and
  simulation (bootstrap) of Variable Length Markov Chain ('VLMC') Models.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>astsa</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>{astsa} mentioned in docu only.</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-14 07:42:48 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 09:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha2int'>&lsquo;Single Character&rsquo; &lt;&ndash;&gt; Integer Conversion for Discrete Data</h2><span id='topic+alpha2int'></span><span id='topic+int2alpha'></span>

<h3>Description</h3>

<p>Simple conversion functions for discrete data (e.g., time series),
between <code>0:k</code> integers and <em>single</em> letter characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha2int(x, alpha)
int2alpha(i, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha2int_+3A_x">x</code></td>
<td>
<p>character vector of single letters.</p>
</td></tr>
<tr><td><code id="alpha2int_+3A_alpha">alpha</code></td>
<td>
<p>the alphabet, as one character string.</p>
</td></tr>
<tr><td><code id="alpha2int_+3A_i">i</code></td>
<td>
<p>integer vector of numbers in <code>0:k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>alpha2int(x,*)</code> returns an <code><a href="base.html#topic+integer">integer</a></code> vector of the same
length as <code>x</code>, consisting of values from <code>0:k</code> where
<code>k + 1</code> is the length of the alphabet, <code><a href="base.html#topic+nchar">nchar</a>(alpha)</code>.
</p>
<p><code>int2alpha(i,*)</code> returns a vector of <em>single letter</em>
<code><a href="base.html#topic+character">character</a></code> of the same length as <code>i</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code>, and
<code><a href="#topic+int2char">int2char</a>()</code> and its inverse, <code><a href="#topic+char2int">char2int</a>()</code>,
both working with multi-character strings instead of vectors of single
characters; further, <code><a href="#topic+alphabet">alphabet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alphabet &lt;- "abcdefghijk"
(ch &lt;- sample(letters[1:10], 30, replace = TRUE))
(ic &lt;- alpha2int(ch, alphabet))
stopifnot(int2alpha(ic, alphabet) == ch)
</code></pre>

<hr>
<h2 id='alphabet'>The Alphabet in Use</h2><span id='topic+alphabet'></span><span id='topic+alphabet.vlmc'></span>

<h3>Description</h3>

<p>Return the alphabet in use, as a vector of &ldquo;characters&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphabet(x, ...)
## S3 method for class 'vlmc'
alphabet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphabet_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object, currently only available for
<code><a href="#topic+vlmc">vlmc</a></code> ones.</p>
</td></tr>
<tr><td><code id="alphabet_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+character">character</a></code> vector, say <code>r</code>, with length equal to
the alphabet size.  Currently, typically all <code>r[i]</code> are strings
of just one character.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alpha2int">alpha2int</a></code> for conversion to and from integer
codings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bnrf1)
vb &lt;- vlmc(bnrf1EB, cutoff = 5)
alphabet(vb) # |--&gt; "a" "c" "g" "t"
</code></pre>

<hr>
<h2 id='as.dendrogram.vlmc'>Dendrogram Construction from VLMCs</h2><span id='topic+as.dendrogram.vlmc'></span>

<h3>Description</h3>

<p>This is a method for the <code>as.dendrogram</code> generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
as.dendrogram(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.dendrogram.vlmc_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+vlmc">vlmc</a></code> object.</p>
</td></tr>
<tr><td><code id="as.dendrogram.vlmc_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+dendrogram">dendrogram</a></code>, i.e. a nested list
described on that page.

</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+as.dendrogram">as.dendrogram</a></code>, <code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(presidents)
dpr &lt;- factor(cut(presidents, c(0,45,70,100)), exclude=NULL)# NA = 4th level
(vlmc.pres &lt;- vlmc(dpr))
draw(vlmc.pres)
(dv.dpr &lt;- as.dendrogram(vlmc.pres))
str(dv.dpr)
str(unclass(dv.dpr))

plot(dv.dpr, type ="tr", nodePar = list(pch=c(1,16), cex = 1.5))

## Artificial example
f1 &lt;- c(1,0,0,0) ; f2 &lt;- rep(1:0, 2)
(dt1 &lt;- c(f1,f1,f2,f1,f2,f2,f1))
(vlmc.dt1c01 &lt;- vlmc(dts = dt1, cutoff.prune = 0.1))
(dvlmc &lt;- as.dendrogram(vlmc.dt1c01))
str(dvlmc)
## not so useful:
plot(dvlmc, nodePar= list(pch=c(1,16)))
## complete disaster:
plot(dvlmc, type ="tr", nodePar= list(pch=c(1,16)))

## but this is not (yet) so much better (want the same angles to left
## and right!!
plot(dvlmc, type ="tr", nodePar = list(pch=c(1,16)), center=TRUE,
     main = format(vlmc.dt1c01$call))
mtext(paste("dt1 =", gsub(" ","",deparse(dt1,width=100))))
</code></pre>

<hr>
<h2 id='bnrf1'>BNRF1 Gene DNA sequences: Epstein-Barr and Herpes</h2><span id='topic+bnrf1EB'></span><span id='topic+bnrf1HV'></span>

<h3>Description</h3>

<p>Two gene DNA data &ldquo;discrete time series&rdquo;,
</p>

<dl>
<dt><code>bnrf1EB</code></dt><dd><p>the BNRF1 gene from the Epstein-Barr virus,</p>
</dd>
<dt><code>bnrf1HV</code></dt><dd><p>the BNRF1 gene from the herpes virus.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(bnrf1)</code></pre>


<h3>Format</h3>

<p>The EB sequence is of <code><a href="base.html#topic+length">length</a></code> 3954, whereas the HV has
3741 nucleotides.
Both are <span class="rlang"><b>R</b></span> <code><a href="base.html#topic+factor">factor</a></code>s with the four levels
<code>c("a","c","g","t")</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler (original packaging for <span class="rlang"><b>R</b></span>).</p>


<h3>Source</h3>

<p>See the references; data used to be at
<code style="white-space: pre;">&#8288;https://anson.ucdavis.edu/~shumway/tsa.html&#8288;</code>, and are now available
in CRAN package <a href="https://CRAN.R-project.org/package=astsa"><span class="pkg">astsa</span></a>, e.g., <code><a href="astsa.html#topic+bnrf1ebv">bnrf1ebv</a></code>.
</p>


<h3>References</h3>

<p>Shumway, R. and Stoffer, D. (2000)
<em>Time Series Analysis and its Applications</em>.
Springer Texts in Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bnrf1)
bnrf1EB[1:500]
table(bnrf1EB)
table(bnrf1HV)
n &lt;- length(bnrf1HV)
table(t = bnrf1HV[-1], "t-1" = bnrf1HV[-n])

plot(as.integer(bnrf1EB[1:500]), type = "b")


## Simplistic gene matching:
percent.eq &lt;- sapply(0:200,
           function(i) 100 * sum(bnrf1EB[(1+i):(n+i)] ==  bnrf1HV))/n
plot.ts(percent.eq)
</code></pre>

<hr>
<h2 id='deviance.vlmc'>Compute the Deviance of a Fitted VLMC Object</h2><span id='topic+deviance.vlmc'></span>

<h3>Description</h3>

<p>Compute the Deviance, i.e., - 2 log[likelihood(*)] of a fitted VLMC
object.  The log-likelihood is also known as &ldquo;entropy&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.vlmc_+3A_object">object</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="deviance.vlmc_+3A_...">...</code></td>
<td>
<p>possibly further arguments (none at the moment).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, the deviance, i.e., <code class="reqn">- 2 log.likelihood(*)</code>.
where the  log.likelihood is really what we currently have
as <code><a href="#topic+entropy">entropy</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+entropy">entropy</a></code>, <code><a href="#topic+vlmc">vlmc</a></code>,<code><a href="#topic+residuals.vlmc">residuals.vlmc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>example(vlmc)
deviance(vlmc.pres)

devianceR &lt;- function(object)
{
    dn &lt;- dimnames(pr &lt;- predict(object))
    -2 * sum(log(pr[cbind(2:nrow(pr), match(dn[[1]][-1], dn[[2]]))]))
}
all.equal(deviance(vlmc.pres), devianceR(vlmc.pres), tol = 1e-14)
</code></pre>

<hr>
<h2 id='draw.vlmc'>Draw a &quot;VLMC&quot; Object (in ASCII) as Tree</h2><span id='topic+draw.vlmc'></span><span id='topic+draw'></span>

<h3>Description</h3>

<p>Draws a <code>vlmc</code> object, typically the result of
<code><a href="#topic+vlmc">vlmc</a>(.)</code>, to the <span class="rlang"><b>R</b></span> console,
using one line per node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(x, ...)
## S3 method for class 'vlmc'
draw(x, kind = 3, flag = TRUE, show.hidden = 0,
     cumulative = TRUE, delta = cumulative, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.vlmc_+3A_x">x</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_kind">kind</code></td>
<td>
<p>integer code for the &ldquo;kind of drawing&rdquo;, in {0,1,2,3}.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_flag">flag</code></td>
<td>
<p>logical; ..</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_show.hidden">show.hidden</code></td>
<td>
<p>integer code; if not <code>0</code>, give some
indications about hidden (final) nodes .....</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_cumulative">cumulative</code></td>
<td>
<p>logical indicating if the cumulative counts should
be shown for nonterminal nodes; the &lsquo;delta&rsquo;s can only be computed
from the cumulative counts, i.e., <code>cumulative = FALSE</code> should
be used only by the knowing one.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_delta">delta</code></td>
<td>
<p>logical indicating if delta,
i.e. <code class="reqn">\delta</code><code class="reqn">(n, p(n))</code> should be computed and
printed for each (non-root) node <code class="reqn">n</code> with parent <code class="reqn">p(n)</code>.  Note
that this does not really make sense when <code>cumulative = FALSE</code>.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code>, some extraneous progress
information is printed to the <span class="rlang"><b>R</b></span> console.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_...">...</code></td>
<td>
<p>(potentially more arguments)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>.............
</p>
<p>.............
</p>
<p>Note that the counts internally are stored &ldquo;non-cumulatively&rdquo;,
i.e., as <em>difference</em> counts which is useful for likelihood (ratio)
computations.  In the internal C code, the <em>difference</em> counts are
originally computed by the <code>comp_difference()</code> function after tree
generation.  <code>draw(*, cumulative = TRUE)</code> internally calls the C
function <code>cumulate()</code> for the cumulative sums.
</p>


<h3>Value</h3>

<p>nothing is returned.</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  example(vlmc)
  draw(vlmc.dt1c01)
  draw(vlmc.dt1c01, flag = FALSE)
  draw(vlmc.dt1c01, kind = 1)
  draw(vlmc.dt1)
  draw(vlmc.dt1, show = 3)
  draw(vlmc.dt1, cumulative = FALSE)
</code></pre>

<hr>
<h2 id='id2ctxt'>VLMC Context ID Conversion</h2><span id='topic+id2ctxt'></span>

<h3>Description</h3>

<p>Utility for converting a <code><a href="#topic+vlmc">vlmc</a></code> state ID to the
corresponding context.  Of rare interest to the average user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id2ctxt(id, m=nchar(alpha), alpha=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id2ctxt_+3A_id">id</code></td>
<td>
<p>integer, a context ID such as optionally returned by
<code><a href="#topic+predict.vlmc">predict.vlmc</a></code>.</p>
</td></tr>
<tr><td><code id="id2ctxt_+3A_m">m</code></td>
<td>
<p>integer, the alphabet length.  Defaults to
<code><a href="base.html#topic+nchar">nchar</a>(alpha)</code>, the alphabet size if that is given.</p>
</td></tr>
<tr><td><code id="id2ctxt_+3A_alpha">alpha</code></td>
<td>
<p>alphabet string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list (if <code>alpha</code> is not specified) or character vector of the
same length as <code>id</code>, giving the 
context (as integer vector or single string) of the corresponding id
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.vlmc">predict.vlmc</a>(*, type = "ID")</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>    id2ctxt(c(2,3,5,9), alpha = "Ab")
str(id2ctxt(c(2,3,5,9), 2))
</code></pre>

<hr>
<h2 id='int2char'>Character - Integer Conversion</h2><span id='topic+int2char'></span><span id='topic+char2int'></span>

<h3>Description</h3>

<p>Simple conversion utilities for character to integer conversion and
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2char(i, alpha)
char2int(x, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int2char_+3A_i">i</code></td>
<td>
<p>integer vectors, typically in <code>0:m</code> when <code>alpha</code>
has <code class="reqn">m + 1</code> letters.</p>
</td></tr>
<tr><td><code id="int2char_+3A_alpha">alpha</code></td>
<td>
<p>character string with several letters, representing the
alphabet.</p>
</td></tr>
<tr><td><code id="int2char_+3A_x">x</code></td>
<td>
<p>character string, typically with letters from <code>alpha</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>int2char()</code> gives a string (length 1 character) with as many
characters as <code>length(i)</code>, by 0-indexing into the alphabet
<code>alpha</code>.
</p>
<p><code>char2int()</code> gives an integer vector of length <code>nchar(x)</code>
of integer codes according to <code>alpha</code> (starting at 0 !).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int2alpha">int2alpha</a>()</code> (which is used by <code>int2char</code>)
and its inverse, <code><a href="#topic+int2alpha">int2alpha</a>()</code>, both working with vectors
of <em>single</em> characters instead of multi-character strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2int("vlmc", paste(letters, collapse=""))

int2char(c(0:3, 3:1), "abcd")
int2char(c(1:0,3,3), "abc") # to eat ;-)
</code></pre>

<hr>
<h2 id='logLik'>Log Likelihood of and between VLMC objects</h2><span id='topic+logLik.vlmc'></span><span id='topic+entropy'></span><span id='topic+entropy2'></span>

<h3>Description</h3>

<p>Compute the log-likelihood or &ldquo;entropy&rdquo; of a fitted
<code><a href="#topic+vlmc">vlmc</a></code> object.  This is a method for the
generic <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(object)
## S3 method for class 'vlmc'
logLik(object, ...)
entropy2(ivlmc1, ivlmc2, alpha.len = ivlmc1[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="logLik_+3A_ivlmc1">ivlmc1</code>, <code id="logLik_+3A_ivlmc2">ivlmc2</code></td>
<td>
<p>two <code>vlmc</code> (sub) trees, see <code><a href="#topic+vlmc">vlmc</a></code>.</p>
</td></tr>
<tr><td><code id="logLik_+3A_alpha.len">alpha.len</code></td>
<td>
<p>positive integer specifying the alphabet length.</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>(potentially more arguments; required by generic)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>logLik.vlmc()</code> method computes the log likelihood for a fitted
<code><a href="#topic+vlmc">vlmc</a></code> object.  <code>entropy</code> is an alias for
<code>logLik</code> for reasons of back compatibility.
</p>
<p><code>entropy2</code> is less clear ... ... [[[ FIXME ]]] ... ...
</p>


<h3>Value</h3>

<p>a negative number, in some contexts typically further divided by
<code>log(x$alpha.len)</code>.
</p>
<p>Note that the <code>logLik</code> method is used by the default method of
the <code><a href="stats.html#topic+AIC">AIC</a></code> generic function (from R version 1.4.x), and
hence provides <code>AIC(object)</code> for vlmc objects.  Also, since vlmc
version 1.3-13, <code><a href="stats.html#topic+BIC">BIC</a>()</code> works as well.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+deviance.vlmc">deviance.vlmc</a></code>,
<code><a href="#topic+vlmc">vlmc</a></code>, <code><a href="#topic+draw.vlmc">draw.vlmc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- cumsum(rpois(999, 1.5)) %% 10
(vd &lt;- vlmc(dd))
entropy(vd)# the bare number
logLik(vd)
logLik(vdL &lt;- vlmc(dd, cutoff = 3))
entropy2(vd $vlmc.vec,
         vdL$vlmc.vec)

## AIC model selection:
f1 &lt;- c(1,0,0,0)  # as in example(vlmc)
f2 &lt;- rep(1:0,2)
(dt1 &lt;- c(f1,f1,f2,f1,f2,f2,f1))
AIC(print(vlmc(dt1)))
AIC(print(vlmc(dt1, cutoff = 2.6)))
AIC(print(vlmc(dt1, cutoff = 0.4)))# these two differ ``not really''
AIC(print(vlmc(dt1, cutoff = 0.1)))

## Show how to compute it from the fitted conditional probabilities :
logLikR &lt;- function(x) {
    dn &lt;- dimnames(pr &lt;- predict(x))
    sum(log(pr[cbind(2:nrow(pr), match(dn[[1]][-1], dn[[2]]))]))
}

all.equal(  logLikR(vd),
          c(logLik (vd)), tol=1e-10) # TRUE, they do the same

## Compare different ones:  [cheap example]:
example(draw)
for(n in ls())
  if(is.vlmc(get(n))) {
       vv &lt;- get(n)
       cat(n,":",formatC(logLik(vv) / log(vv$alpha.len),
                         format= "f", wid=10),"\n")
  }
</code></pre>

<hr>
<h2 id='OZrain'>Daily Rainfall in Melbourne, Australia, 1981-1990</h2><span id='topic+OZrain'></span>

<h3>Description</h3>

<p>Amount of daily rainfall in Melbourne, Australia,
1981-1990, measured in millimeters.  The amounts are integers with
many zeros and three days of more than 500mm rain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OZrain)</code></pre>


<h3>Format</h3>

<p>A time-series of length 3653 with the amount of daily rainfall in mm.
Because of the two leap years 1984 and '88, we have constructed it
with <code><a href="stats.html#topic+ts">ts</a>(*, start=1981, frequency=365.25,
    end = 1981+ (3653 - 1)/365.25)</code>.
</p>


<h3>Note</h3>

<p>There must be one extra observation since for the ten years with two
leap years, there are only 3652 days.
In 61 out of 100 days, there's no rain.
</p>


<h3>Source</h3>

<p>&lsquo;<span class="file">rainfall.dat</span>&rsquo; in Rob J. Hyndman's <em>Time Series Data Library</em>,

currently available at <a href="https://pkg.yangzhuoranyang.com/tsdl/">https://pkg.yangzhuoranyang.com/tsdl/</a>
</p>
<p>originally, Australian Bureau of Meteorology, <a href="https://www.abs.gov.au">https://www.abs.gov.au</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OZrain)
(n &lt;- length(OZrain)) ## should be 1 more than
ISOdate(1990,12,31) - ISOdate(1981, 1,1)## but it's 2 ..

has.rain &lt;- OZrain &gt; 0

summary(OZrain[has.rain])# Median = 18,  Q3 = 50
table(rain01 &lt;- as.integer(has.rain))
table(rain4c &lt;- cut(OZrain, c(-.1, 0.5, 18.5, 50.1, 1000)))



AIC(v1  &lt;- vlmc(rain01))# cutoff = 1.92
AIC(v00 &lt;- vlmc(rain01, cut = 1.4))
AIC(v0  &lt;- vlmc(rain01, cut = 1.5))



hist(OZrain)
hist(OZrain, breaks = c(0,1,5,10,50,1000), xlim = c(0,100))

plot(OZrain, main = "Rainfall 1981-1990 in Melbourne")
plot(OZrain, log="y", main = "Non-0 Rainfall [LOG scale]")

lOZ &lt;- lowess(log10(OZrain[has.rain]), f= .05)
lines(time(OZrain)[has.rain], 10^lOZ$y, col = 2, lwd = 2)
</code></pre>

<hr>
<h2 id='predict.vlmc'>Prediction of VLMC for (new) Series</h2><span id='topic+print.predict.vlmc'></span><span id='topic+predict.vlmc'></span><span id='topic+fitted.vlmc'></span>

<h3>Description</h3>

<p>Compute predictions on a fitted VLMC object
for each (but the first) element of another discrete time series.
Computes by default a matrix of prediction probabilities.  The argument
<code>type</code> allows other predictions such as the most probable
<code>"class"</code> or <code>"response"</code>, the context length (tree
<code>"depth"</code>), or an <code>"ID"</code> of the corresponding context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
predict(object, newdata,
         type = c("probs", "class","response", "id.node", "depth", "ALL"),
         se.fit = FALSE,
         allow.subset = TRUE, check.alphabet=TRUE,
         ...)
## S3 method for class 'vlmc'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.vlmc_+3A_object">object</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_newdata">newdata</code></td>
<td>
<p>a discrete &ldquo;time series&rdquo;, a numeric, character or
factor, as the <code>dts</code> argument of <code><a href="#topic+vlmc">vlmc</a>(.)</code>.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_type">type</code></td>
<td>
<p>character indicating the type of prediction required,
options given in the <em>Usage</em> secion above, see also the
<em>Value</em> section below.  The default <code>"probs"</code>
returns a matrix of prediction probabilties, whereas <code>"class"</code>
or <code>"response"</code> give the corresponding most
probable class.  The value of this argument can be abbreviated.
</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_se.fit">se.fit</code></td>
<td>
<p>a switch indicating if standard errors are required.
<br /> &mdash; NOT YET supported &mdash; .</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_allow.subset">allow.subset</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>newdata</code> may not
have all different &ldquo;alphabet letters&rdquo; used in <code>x</code>.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_check.alphabet">check.alphabet</code></td>
<td>
<p>logical; if <code>TRUE</code>, consistency of
<code>newdata</code>'s alphabet with those of <code>x</code> is checked.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_...">...</code></td>
<td>
<p>(potentially further arguments) required by generic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the <code>type</code> argument,
</p>
<table role = "presentation">
<tr><td><code>"probs"</code></td>
<td>
<p>an <code class="reqn">n \times m</code> matrix <code>pm</code> of (prediction)
probabilities, i.e., all the rows of <code>pm</code> sum to 1.
</p>
<p><code>pm[i,k]</code> is
<code class="reqn">\hat P[Y_i = k | Y_{i-1},\dots]</code> (and
is therefore <code><a href="base.html#topic+NA">NA</a></code> for <code>i=1</code>).
The <code><a href="base.html#topic+dimnames">dimnames</a></code> of <code>pm</code> are the values of
<code>newdata[]</code> and the alphabet letters <code>k</code>.</p>
</td></tr>
<tr><td><code>"class"</code>, <code>"response"</code></td>
<td>
<p>the corresponding most probable value of Y[];
as <code>factor</code> for <code>"class"</code> and as integer in
<code>0:(m-1)</code> for <code>type = "response"</code>. If there is more than
one most probable value, the first one is chosen.</p>
</td></tr>
<tr><td><code>"id.node"</code></td>
<td>
<p>an (integer) &ldquo;ID&rdquo; of the current context (= node
of the tree represented VLMC).</p>
</td></tr>
<tr><td><code>"depth"</code></td>
<td>
<p>the context length, i.e., the depth of the
Markov chain, at the current observation (of <code>newdata</code>).</p>
</td></tr>
<tr><td><code>"ALL"</code></td>
<td>
<p>an object of class <code>"predict.vlmc"</code>, a list with the
following components,
</p>

<dl>
<dt>ID</dt><dd><p>integer vector as for <code>type = "id.node"</code>,</p>
</dd>
<dt>probs</dt><dd><p>prediction probability matrix, as above,</p>
</dd>
<dt>flags</dt><dd><p>integer vector, non-zero for particular states only,
rather for debugging.</p>
</dd>
<dt>ctxt</dt><dd><p>character, <code>ctxt[i]</code> a string giving the
context (backwards) for <code>newdata[i]</code>, using alphabet
letters.</p>
</dd>
<dt>fitted</dt><dd><p>character with fitted values, i.e., the alphabet letter
with the highest probability, using <code><a href="base.html#topic+max.col">max.col</a></code> where
ties are broken at random.</p>
</dd>
<dt>alpha, alpha.len</dt><dd><p>the alphabet (single string) and its
length.</p>
</dd>
</dl>

<p>which has its own print method (<code>print.predict.vlmc</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>predict</code> method and its possible arguments may still be
developed, and we are considering to return the marginal
probabilities instead of <code>NA</code> for the first value(s).
</p>
<p>The <code><a href="base.html#topic+print">print</a></code> method <code>print.predict.vlmc</code> uses
<code><a href="MASS.html#topic+fractions">fractions</a></code> from package <span class="pkg">MASS</span> to display
the probabilities <code class="reqn">Pr[X = j]</code>, for
<code class="reqn">j \in \{0,1,\dots\}</code>, as these are rational
numbers, shown as fractions of integers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code> and <code><a href="#topic+residuals.vlmc">residuals.vlmc</a></code>.  For
simulation, <code><a href="#topic+simulate.vlmc">simulate.vlmc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- c(1,0,0,0)
f2 &lt;- rep(1:0,2)
(dt2 &lt;- rep(c(f1,f1,f2,f1,f2,f2,f1),2))

(vlmc.dt2c15  &lt;- vlmc(dt2, cutoff = 1.5))
draw(vlmc.dt2c15)

## Fitted Values:
all.equal(predict(vlmc.dt2c15, dt2), predict(vlmc.dt2c15))
(pa2c15 &lt;- predict(vlmc.dt2c15, type = "ALL"))

## Depth = context length  ([1] : NA) :
stopifnot(nchar(pa2c15 $ ctxt)[-1] ==
          predict(vlmc.dt2c15, type = "depth")[-1])

same &lt;- (ff1 &lt;- pa2c15 $ fitted) ==
        (ff2 &lt;- int2alpha(predict(vlmc.dt2c15, type ="response"), alpha="01"))
which(!same) #-&gt; some are different, since max.col() breaks ties at random!

ndt2 &lt;- c(rep(0,6),f1,f1,f2)
predict(vlmc.dt2c15, ndt2, "ALL")

(newdt2 &lt;- sample(dt2, 17))
pm &lt;- predict(vlmc.dt2c15, newdt2, allow.subset = TRUE)
summary(apply(pm, 1, sum))# all 1

predict(vlmc.dt2c15, newdt2, type = "ALL")

data(bnrf1)
(vbnrf &lt;- vlmc(bnrf1EB))
(pA &lt;- predict(vbnrf, bnrf1EB[1:24], type = "ALL"))
 pc &lt;- predict(vbnrf, bnrf1EB[1:24], type = "class")
 pr &lt;- predict(vbnrf, bnrf1EB[1:24], type = "resp")
stopifnot(as.integer  (pc[-1])   == 1 + pr[-1],
          as.character(pc[-1]) == strsplit(vbnrf$alpha,NULL)[[1]][1 + pr[-1]])

##-- Example of a "perfect" fit -- just for illustration:
##			    the default, thresh = 2 doesn't fit perfectly(i=38)
(vlmc.dt2c0th1 &lt;- vlmc(dt2, cutoff = 0, thresh = 1))

## "Fitted" = "Data" (but the first which can't be predicted):
stopifnot(dt2[-1] == predict(vlmc.dt2c0th1,type = "response")[-1])
</code></pre>

<hr>
<h2 id='prt.vvec'>Recursively Print the VLMC Result Vector</h2><span id='topic+prt.vvec'></span>

<h3>Description</h3>

<p>This is an auxiliary function which recursively displays (prints) the
integer result vector of a <code><a href="#topic+vlmc">vlmc</a></code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prt.vvec(v, nalph, pad=" ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prt.vvec_+3A_v">v</code></td>
<td>
<p>typically <code>x $ vlmc.vec[ -1]</code> where <code>x</code> is the
result of <code><a href="#topic+vlmc">vlmc</a>(*)</code>.</p>
</td></tr>
<tr><td><code id="prt.vvec_+3A_nalph">nalph</code></td>
<td>
<p>alphabet size; typically <code>x $ vlmc.vec[1]</code>.</p>
</td></tr>
<tr><td><code id="prt.vvec_+3A_pad">pad</code></td>
<td>
<p>character, to be used for padding <code>paste(*, collapse=pad)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.vlmc">summary.vlmc</a></code> which uses <code>prt.vvec</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  example(vlmc)
  str(vv &lt;- vlmc.dt1$vlmc)
  prt.vvec(vv[-1], n = 2)
  prt.vvec(vv[-1], n = 2, pad = " | ")
</code></pre>

<hr>
<h2 id='RCplot'>Residuals vs Context plot</h2><span id='topic+RCplot'></span>

<h3>Description</h3>

<p>Plots the residuals of a fitted VLMC model against the contexts, i.e.,
produces a boxplot of residuals for all contexts used in the model fit.
</p>
<p>This has proven to be useful function, and the many optional arguments
allow quite a bit of customization.  However, the current
implementation is somewhat experimental and the defaults have been
chosen from only a few examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCplot(x, r2 = residuals(x, "deviance")^2,
       alphabet = x$alpha, lab.horiz = k &lt;= 20,
       do.call = TRUE,
       cex.axis = if (k &lt;= 20) 1 else if (k &lt;= 40) 0.8 else 0.6,
       y.fact = if (.Device == "postscript") 1.2 else 0.75,
       col = "gray70", xlab = "Context", main = NULL,
       med.pars = list(col = "red", pch = 12, cex = 1.25 * cex.axis),
       ylim = range(0, r2, finite = TRUE),
       ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCplot_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>vlmc</code>.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_r2">r2</code></td>
<td>
<p>numeric vector, by default of squared deviance residuals of
<code>x</code>, but conceptually any (typically non-negative) vector of
the appropriate length.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_alphabet">alphabet</code></td>
<td>
<p>the alphabet to use for labeling the contexts,
via <code><a href="#topic+id2ctxt">id2ctxt</a></code>.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_lab.horiz">lab.horiz</code></td>
<td>
<p>logical indicating if the context labels should be
written <b>horiz</b>ontally or vertically.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_do.call">do.call</code></td>
<td>
<p>logical indicating if the <code><a href="#topic+vlmc">vlmc</a></code> call
should be put as subtitle.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the character expansion for axis labeling, see also
<code><a href="graphics.html#topic+par">par</a></code>.  The default is only approximately good.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_y.fact">y.fact</code></td>
<td>
<p>numeric factor for expanding the space to use for the
context labels (when <code>lab.horiz</code> is false).</p>
</td></tr>
<tr><td><code id="RCplot_+3A_col">col</code></td>
<td>
<p>color used for filling the boxes.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_xlab">xlab</code></td>
<td>
<p>x axis label (with default).</p>
</td></tr>
<tr><td><code id="RCplot_+3A_main">main</code></td>
<td>
<p>main title to be used, <code>NULL</code> entailing a sensible default.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_med.pars">med.pars</code></td>
<td>
<p>graphical parameters to be used for coding of medians
that are almost 0.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_ylim">ylim</code></td>
<td>
<p>y range limits for plotting.</p>
</td></tr>
<tr><td><code id="RCplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>Invisibly</em>, a list with components
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>the number of contexts (and hence box plots) used.</p>
</td></tr>
<tr><td><code>fID</code></td>
<td>
<p>a factor (as used in the interncal call to
<code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>).</p>
</td></tr>
<tr><td><code>rp</code></td>
<td>
<p>a list as resulting from the above call to <code>plot.factor()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Mächler M. and Bühlmann P. (2004)
Variable Length Markov Chains: Methodology, Computing, and Software.
<em>J. Computational and Graphical Statistics</em> <b>2</b>, 435&ndash;455.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.vlmc">summary.vlmc</a></code> for other properties of a VLMC model.</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(vlmc)
RCplot(vlmc.pres)
RCplot(vlmc.dt1c01)## &lt;&lt; almost perfect fit (0 resid.)
</code></pre>

<hr>
<h2 id='residuals.vlmc'>Compute Residuals of a Fitted VLMC Object</h2><span id='topic+residuals.vlmc'></span>

<h3>Description</h3>

<p>Compute residuals of a fitted <code><a href="#topic+vlmc">vlmc</a></code> object.
</p>
<p>This is yet a matter of research and may change in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
residuals(object,
        type = c("classwise",
                 "deviance", "pearson", "working", "response", "partial"),
        y = object$y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.vlmc_+3A_object">object</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="residuals.vlmc_+3A_type">type</code></td>
<td>
<p>The type of residuals to compute, defaults to
<code>"classwise"</code> which returns an <code class="reqn">n \times m</code> matrix,
see below.  The other types only make sense when the discrete
values of <code>y</code> are ordered which always includes the binary case
(<code class="reqn">m=2</code>).
<br />
The <code>"deviance"</code> residuals <code class="reqn">r</code> are defined similarly as for logistic
regression, see below.
<br />
&quot;pearson&quot;, &quot;working&quot; and &quot;response&quot; are currently
identical and give the difference of the underlying integer code (of
the discrete data).

<b>Note</b> that <code>"partial"</code> residuals are not yet defined!
</p>
</td></tr>
<tr><td><code id="residuals.vlmc_+3A_y">y</code></td>
<td>
<p>discrete time series with respect to which the residuals are
to be computed.</p>
</td></tr>
<tr><td><code id="residuals.vlmc_+3A_...">...</code></td>
<td>
<p>possibly further arguments (none at the moment).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type = "classwise"</code> (the default), a numeric matrix of dimension
<code class="reqn">n \times m</code> of values <code class="reqn">I_{i,j} - p_{i,j}</code> where the indicator <code class="reqn">I_{i,j}</code> is 1 iff
<code>y[i] == a[j]</code> and <code>a</code> is the alphabet (or levels) of
<code>y</code>, and <code class="reqn">p_{i,j}</code> are the elements of the estimated (1-step
ahead) predicted probabilities, <code>p &lt;- predict(object)</code>.
Hence, for each <code class="reqn">i</code>, the only positive residual stands for the
observed class.
</p>
<p>For all other <code>type</code>s, the result is
a numeric vector of the length of the original time-series (with first
element <code>NA</code>).<br />
For <code>type = "deviance"</code>,
<code class="reqn">r_i = \pm\sqrt{-2\log(P_i)}</code>
where <code class="reqn">P_i</code> is the predicted probability for the i-th
observation which is the same as <code class="reqn">p_{i,y_i}</code> above (now
assuming <code class="reqn">y_i \in \{1,2,\dots,m</code>).
The sum of the squared deviance residuals <em>is</em> the deviance of
the fitted model.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code>,<code><a href="#topic+deviance.vlmc">deviance.vlmc</a></code>, and
<code><a href="#topic+RCplot">RCplot</a></code> for a novel residual plot.</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(vlmc)
rp &lt;- residuals(vlmc.pres)
stopifnot(all(abs(apply(rp[-1,],1,sum)) &lt; 1e-15))
matplot(seq(presidents), rp, ylab = "residuals", type="l")
## ``Tukey-Anscombe'' (the following is first stab at plot method):
matplot(fitted(vlmc.pres), rp, ylab = "residuals", xaxt = "n",
        type="b", pch=vlmc.pres$alpha)
axis(1, at = 0:(vlmc.pres$alpha.len-1),
     labels = strsplit(vlmc.pres$alpha,"")[[1]])


summary(rd &lt;- residuals(vlmc.pres, type = "dev"))
rd[1:7]
## sum of squared dev.residuals === deviance :
all.equal(sum(rd[-1] ^ 2),
          deviance(vlmc.pres))

</code></pre>

<hr>
<h2 id='simulate.vlmc'>Simulate a Discrete Time Series from fitted VLMC model</h2><span id='topic+simulate.vlmc'></span>

<h3>Description</h3>

<p>Simulate from fitted VLMC model &ndash; basis of the VLMC bootstrap</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
simulate(object, nsim = 1, seed = NULL, n,
         n.start = 64 * object$size[["context"]],
         integer.return = FALSE, keep.RSeed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.vlmc_+3A_object">object</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_nsim">nsim</code>, <code id="simulate.vlmc_+3A_n">n</code></td>
<td>
<p>non-negative integer, giving the length of the result.
Note that <code>n</code> is deprecated and just there for back compatibility.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_seed">seed</code></td>
<td>
<p>random seed initializer; see <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_n.start">n.start</code></td>
<td>
<p>the number of initial values to be
discarded (because of initial effects).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_integer.return">integer.return</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result will be an
<code><a href="base.html#topic+integer">integer</a></code> vector with values in <code>0:(k-1)</code>;
otherwise the resulting vector consists of letters from the alphabet
<code>x$alpha</code>.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_keep.rseed">keep.RSeed</code></td>
<td>
<p>logical indicating if the seed should be stored with
the result (as &lsquo;required&rsquo; by the generic
<code><a href="stats.html#topic+simulate">simulate</a></code>).  Only set this <code>FALSE</code> with good
reasons (back compatibility).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_...">...</code></td>
<td>
<p>(potentially further arguments for other <code>simulate</code>
methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> is used and updated as with other random
number generation routines such as <code><a href="stats.html#topic+rbinom">rbinom</a></code>.
</p>
<p>Note that if you want to simulate from a given start sequence
<code>x0</code>, you'd use <code><a href="#topic+predict.vlmc">predict.vlmc</a>(x, x0, type= "response")</code>
&mdash; actually not quite yet.
</p>


<h3>Value</h3>

<p>A <code>"simulate.vlmc"</code> object, basically a vector of length
<code>nsim</code>.  Either <code><a href="base.html#topic+integer">integer</a></code> or <code><a href="base.html#topic+character">character</a></code>,
depending on the <code>integer.return</code> argument, see above.  Further,
if <code>keep.RSeed</code> was true (as by default), a <code>"seed"</code> attribute
with the random seed at the start of the simulation, for reproducibility.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code> and <code><a href="#topic+predict.vlmc">predict.vlmc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(vlmc)

simulate(vlmc.dt1, 100)
simulate(vlmc.dt1c01, 100, int = TRUE)
# n.start = 0: 1st few observations will resemble the data
simulate(vlmc.dt1c01, 20, n.start=0, int = TRUE)


</code></pre>

<hr>
<h2 id='summary.vlmc'>Summary of Fitted Variable Length Markov Chain (VLMC)</h2><span id='topic+summary.vlmc'></span><span id='topic+print.summary.vlmc'></span>

<h3>Description</h3>

<p>Compute (and print) a summary of a <code>vlmc</code> object which is
typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
summary(object, ...)
## S3 method for class 'summary.vlmc'
print(x, digits = getOption("digits"),
         vvec.printing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.vlmc_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>vlmc</code>.</p>
</td></tr>
<tr><td><code id="summary.vlmc_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>summary.vlmc</code>.</p>
</td></tr>
<tr><td><code id="summary.vlmc_+3A_digits">digits</code></td>
<td>
<p>integer giving the number of significant digits for
printing numbers.</p>
</td></tr>
<tr><td><code id="summary.vlmc_+3A_vvec.printing">vvec.printing</code></td>
<td>
<p>logical indicating if the <code>vvec</code> component
should be printed recursively via <code><a href="#topic+prt.vvec">prt.vvec</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.vlmc_+3A_...">...</code></td>
<td>
<p>potentially further arguments [Generic].</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.vlmc()</code> returns an object of class <code>"summary.vlmc"</code>
for which there's a print method. It is basically a list containing
all of <code>object</code>, plus additionally
</p>
<table role = "presentation">
<tr><td><code>confusion.table</code></td>
<td>
<p>the symmetric contingency table of data vs fitted.</p>
</td></tr>
<tr><td><code>depth.stats</code></td>
<td>
<p>statistics of Markov chain depth along the data;
currently just <code>summary(predict(object, type="depth"))</code>.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>the <code class="reqn">R^2</code> statistic, i.e. the percentage (in [0,1]) of
correctly predicted data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code>, <code><a href="#topic+draw.vlmc">draw.vlmc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bnrf1)
vb &lt;- vlmc(bnrf1EB)
svb &lt;- summary(vb)
svb

</code></pre>

<hr>
<h2 id='vlmc'>Fit a Variable Length Markov Chain (VLMC)</h2><span id='topic+vlmc'></span><span id='topic+print.vlmc'></span><span id='topic+is.vlmc'></span>

<h3>Description</h3>

<p>Fit a Variable Length Markov Chain (VLMC) to a discrete time series,
in basically two steps:<br />
First a large Markov Chain is generated containing (all if
<code>threshold.gen = 1</code>) the context states of the time series.  In
the second step, many states of the MC are collapsed by <em>pruning</em>
the corresponding context tree.
</p>
<p>Currently, the &ldquo;alphabet&rdquo; may contain can at most 26 different
&ldquo;character&rdquo;s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlmc(dts,
     cutoff.prune = qchisq(alpha.c, df=max(.1,alpha.len-1),lower.tail=FALSE)/2,
     alpha.c = 0.05,
     threshold.gen = 2,
     code1char = TRUE, y = TRUE, debug = FALSE, quiet = FALSE,
     dump = 0, ctl.dump = c(width.ct = 1+log10(n), nmax.set = -1) )

is.vlmc(x)
## S3 method for class 'vlmc'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vlmc_+3A_dts">dts</code></td>
<td>
<p>a discrete &ldquo;time series&rdquo;; can be a numeric, character or factor.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_cutoff.prune">cutoff.prune</code></td>
<td>
<p>non-negative number; the cutoff used for pruning;
defaults to half the <code class="reqn">\alpha</code>-quantile of a chisq distribution,
where <code class="reqn">\alpha =</code> <code>alpha.c</code>, the following argument:</p>
</td></tr>
<tr><td><code id="vlmc_+3A_alpha.c">alpha.c</code></td>
<td>
<p>number in (0,1) used to specify <code>cutoff.prune</code> in
the more intuitive <code class="reqn">\chi^2</code> quantile scale; defaulting to 5%.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_threshold.gen">threshold.gen</code></td>
<td>
<p>integer <code>&gt;= 1</code> (usually left at 2).  When
<em>generating</em> the initial large tree, only generate nodes with
<code>count &gt;= threshold.gen</code>.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_code1char">code1char</code></td>
<td>
<p>logical; if true (default), the data <code>dts</code> will
be ..........FIXME...........</p>
</td></tr>
<tr><td><code id="vlmc_+3A_y">y</code></td>
<td>
<p>logical; if true (default), the data <code>dts</code> will be
returned.  This allows to ensure that residuals
(<code><a href="#topic+residuals.vlmc">residuals.vlmc</a></code>) and &ldquo;k-step ahead&rdquo; predictions can
be computed from the result.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_debug">debug</code></td>
<td>
<p>logical; should debugging info be printed to stderr.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_quiet">quiet</code></td>
<td>
<p>logical; if true, don't print some warnings.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_dump">dump</code></td>
<td>
<p>integer in <code>0:2</code>.  If positive, the pruned tree is
dumped to stderr; if 2, the initial <b>un</b>pruned tree is dumped as well.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_ctl.dump">ctl.dump</code></td>
<td>
<p>integer of length 2, say <code>ctl[1:2]</code> controlling
the above dump when <code>dump &gt; 0</code>.  <code>ctl[1]</code> is the width
(number of characters) for the &ldquo;counts&rdquo;, <code>ctl[2]</code> the maximal
number of set elements that are printed per node; when the latter is
not positive (by default), currently <code>max(6, 15 - log10(n))</code> is used.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_x">x</code></td>
<td>
<p>a fitted <code>"vlmc"</code> object.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_digits">digits</code></td>
<td>
<p>integer giving the number of significant digits for
printing numbers.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_...">...</code></td>
<td>
<p>potentially further arguments [Generic].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"vlmc"</code> object, basically a list with components
</p>
<table role = "presentation">
<tr><td><code>nobs</code></td>
<td>
<p>length of data series when fit.  (was named <code>"n"</code> in
earlier versions.)</p>
</td></tr>
<tr><td><code>threshold.gen</code>, <code>cutoff.prune</code></td>
<td>
<p>the arguments (or their defaults).</p>
</td></tr>
<tr><td><code>alpha.len</code></td>
<td>
<p>the alphabet size.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the alphabet used, as one string.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a named integer vector of length (&gt;=) 4, giving
characteristic sizes of the fitted VLMC.  Its named components are
</p>

<dl>
<dt>&quot;ord.MC&quot;</dt><dd><p>the (maximal) order of the Markov chain,</p>
</dd>
<dt>&quot;context&quot;</dt><dd><p>the &ldquo;context tree size&rdquo;, i.e., the number of
leaves plus number of &ldquo;hidden nodes&rdquo;,</p>
</dd>

<dt>&quot;nr.leaves&quot;</dt><dd><p>is the number of leaves, and</p>
</dd>
<dt>&quot;total&quot;</dt><dd><p>the number of integers needed to encode the VLMC
tree, i.e., <code>length(vlmc.vec)</code> (see below).</p>
</dd>
</dl>

</td></tr>
<tr><td><code>vlmc.vec</code></td>
<td>
<p>integer vector, containing (an encoding of) the fitted
VLMC tree.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if <code>y = TRUE</code>, the data <code>dts</code>, as
<code><a href="base.html#topic+character">character</a></code>, using the letters from <code>alpha</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+call">call</a></code> <code>vlmc(..)</code> used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Set <code>cutoff = 0, thresh = 1</code> for getting a &ldquo;perfect fit&rdquo;,
i.e. a VLMC which perfectly re-predicts the data (apart from the first
observation).  Note that even with <code>cutoff = 0</code> some pruning may
happen, for all (terminal) nodes with <code class="reqn">\delta</code>=0.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Buhlmann P. and Wyner A. (1998)
Variable Length Markov Chains.
<em>Annals of Statistics</em> <b>27</b>, 480&ndash;513.
</p>
<p>Mächler M. and Bühlmann P. (2004)
Variable Length Markov Chains: Methodology, Computing, and Software.
<em>J. Computational and Graphical Statistics</em> <b>2</b>, 435&ndash;455.
</p>
<p>Mächler M. (2004)
VLMC &mdash; Implementation and <span class="rlang"><b>R</b></span> interface; working paper.

</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw.vlmc">draw.vlmc</a></code>,
<code><a href="#topic+entropy">entropy</a></code>, <code><a href="#topic+simulate.vlmc">simulate.vlmc</a></code> for &ldquo;VLMC bootstrapping&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- c(1,0,0,0)
f2 &lt;- rep(1:0,2)
(dt1 &lt;- c(f1,f1,f2,f1,f2,f2,f1))

(vlmc.dt1  &lt;- vlmc(dt1))
 vlmc(dt1, dump = 1,
      ctl.dump = c(wid = 3, nmax = 20), debug = TRUE)
(vlmc.dt1c01 &lt;- vlmc(dts = dt1, cutoff.prune = .1, dump=1))

data(presidents)
dpres &lt;- cut(presidents, c(0,45,70, 100)) # three values + NA
table(dpres &lt;- factor(dpres, exclude = NULL)) # NA as 4th level
levels(dpres)#-&gt; make the alphabet -&gt; warning
vlmc.pres &lt;- vlmc(dpres, debug = TRUE)
vlmc.pres

## alphabet &amp; and its length:
vlmc.pres$alpha
stopifnot(
  length(print(strsplit(vlmc.pres$alpha,NULL)[[1]])) == vlmc.pres$ alpha.len
)

## You now can use larger alphabets (up to 95) letters:
set.seed(7); it &lt;- sample(40, 20000, replace=TRUE)
v40 &lt;- vlmc(it)
v40
## even larger alphabets now give an error:
il &lt;- sample(100, 10000, replace=TRUE)
ee &lt;- tryCatch(vlmc(il), error= function(e)e)
stopifnot(is(ee, "error"))
</code></pre>

<hr>
<h2 id='vlmc.version'>Version of VLMC Package</h2><span id='topic+vlmc.version'></span>

<h3>Description</h3>

<p>Character string, giving the version number (and date)
of the VLMC package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vlmc.version
## Not run: 
[1] "VLMC 1.3-14;  after $Date: 2014/06/03 08:05:21 $ UTC"

## End(Not run)
</code></pre>

<hr>
<h2 id='vlmctree'>Compute the tree structure of a &quot;vlmc&quot; object</h2><span id='topic+vlmctree'></span><span id='topic+.vvec2tree'></span><span id='topic+str.vtree'></span>

<h3>Description</h3>

<p>Compute the tree representation of a <code>"<a href="#topic+vlmc">vlmc</a>"</code> object as <span class="rlang"><b>R</b></span>
<code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlmctree(x)

## S3 method for class 'vtree'
str(object, ...)
.vvec2tree(vv, k, chk.lev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vlmctree_+3A_x">x</code>, <code id="vlmctree_+3A_object">object</code></td>
<td>
<p>typically the result of <code><a href="#topic+vlmc">vlmc</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="vlmctree_+3A_vv">vv</code></td>
<td>
<p>integer vector encoding the fitted vlmc, typically
<code>x$vlmc.vec[-1]</code>.</p>
</td></tr>
<tr><td><code id="vlmctree_+3A_k">k</code></td>
<td>
<p>integer, the alphabet size.</p>
</td></tr>
<tr><td><code id="vlmctree_+3A_chk.lev">chk.lev</code></td>
<td>
<p>integer internally used for consistency checking.</p>
</td></tr>
<tr><td><code id="vlmctree_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.vvec2tree</code> is the internal (recursive) function building up the
tree.
</p>
<p><code>str.vtree</code> is a method for the generic <code><a href="utils.html#topic+str">str</a></code>
function and typically for the output of <code>vlmctree()</code>. For each
node, it gives the &ldquo;parenting level&rdquo; in braces and the counts.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+class">class</a></code> <code>"vtree"</code>
representing the tree structure recursively.
</p>
<p>Each &ldquo;node&rdquo; of the tree is itself a list with
components
</p>
<table role = "presentation">
<tr><td><code>level</code></td>
<td>
<p>length-2 integer giving the level in {0,1,...},
counted from the root (which is <code>0</code>) and the parenting level,
i.e the longest branch.</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>integer vector of length <code>k</code> where <code>k</code> is the
number of &ldquo;letters&rdquo; in the alphabet.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>equals to <code>sum(* $ count)</code>.</p>
</td></tr>
<tr><td><code>child</code></td>
<td>
<p>a list (of length <code>k</code>) of child nodes or
<code><a href="base.html#topic+NULL">NULL</a></code> (i.e. not there).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(presidents)
dpres &lt;- cut(presidents, c(0,45,70, 100)) # three values + NA
table(dpres &lt;- factor(dpres, exclude = NULL)) # NA as 4th level

(vlmc.prc1 &lt;- vlmc(dpres, cut = 1, debug = TRUE))
str(vv.prc1 &lt;- vlmctree(vlmc.prc1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
