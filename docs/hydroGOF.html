<!DOCTYPE html><html><head><title>Help for package hydroGOF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hydroGOF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#br2'>
<p>br2</p></a></li>
<li><a href='#cp'>
<p>Coefficient of persistence</p></a></li>
<li><a href='#d'>
<p>Index of Agreement</p></a></li>
<li><a href='#dr'>
<p>Refined Index of Agreement</p></a></li>
<li><a href='#EgaEnEstellaQts'>
<p>Ega in &quot;Estella&quot; (Q071), ts with daily streamflows.</p></a></li>
<li><a href='#ggof'>
<p>Graphical Goodness of Fit</p></a></li>
<li><a href='#gof'>
<p>Numerical Goodness-of-fit measures</p></a></li>
<li><a href='#hydroGOF-internal'><p>Internal hydroGOF objects</p></a></li>
<li><a href='#hydroGOF-package'>
<p>Goodness-of-fit (GoF) functions for numerical and graphical comparison of simulated and observed time series, mainly focused on hydrological modelling.</p></a></li>
<li><a href='#KGE'>
<p>Kling-Gupta Efficiency</p></a></li>
<li><a href='#KGElf'>
<p>Kling-Gupta Efficiency for low values</p></a></li>
<li><a href='#KGEnp'>
<p>Non-parametric version of the Kling-Gupta Efficiency</p></a></li>
<li><a href='#mae'>
<p>Mean Absolute Error</p></a></li>
<li><a href='#md'>
<p>Modified index of agreement</p></a></li>
<li><a href='#me'>
<p>Mean Error</p></a></li>
<li><a href='#mNSE'>
<p>Modified Nash-Sutcliffe efficiency</p></a></li>
<li><a href='#mse'>
<p>Mean Squared Error</p></a></li>
<li><a href='#nrmse'>
<p>Normalized Root Mean Square Error</p></a></li>
<li><a href='#NSE'>
<p>Nash-Sutcliffe Efficiency</p></a></li>
<li><a href='#pbias'>
<p>Percent Bias</p></a></li>
<li><a href='#pbiasfdc'>
<p>Percent Bias in the Slope of the Midsegment of the Flow Duration Curve</p></a></li>
<li><a href='#pfactor'>
<p>P-factor</p></a></li>
<li><a href='#plot2'>
<p>Plotting 2 Time Series</p></a></li>
<li><a href='#plotbands'>
<p>Plot a ts with observed values and two confidence bounds</p></a></li>
<li><a href='#plotbandsonly'>
<p>Adds uncertainty bounds to an existing plot.</p></a></li>
<li><a href='#R2'>
<p>Coefficient of determination</p></a></li>
<li><a href='#rd'>
<p>Relative Index of Agreement</p></a></li>
<li><a href='#rfactor'>
<p>R-factor</p></a></li>
<li><a href='#rmse'>
<p>Root Mean Square Error</p></a></li>
<li><a href='#rNSE'>
<p>Relative Nash-Sutcliffe efficiency</p></a></li>
<li><a href='#rPearson'>
<p>Pearson correlation coefficient</p></a></li>
<li><a href='#rSD'>
<p>Ratio of Standard Deviations</p></a></li>
<li><a href='#rSpearman'>
<p>Spearman's rank correlation coefficient</p></a></li>
<li><a href='#rsr'>
<p>Ratio of RMSE to the standard deviation of the observations</p></a></li>
<li><a href='#sKGE'>
<p>Split Kling-Gupta Efficiency</p></a></li>
<li><a href='#ssq'>
<p>Sum of the Squared Residuals</p></a></li>
<li><a href='#ubRMSE'>
<p>Unbiased Root Mean Square Error</p></a></li>
<li><a href='#valindex'>
<p>Valid Indexes</p></a></li>
<li><a href='#ve'>
<p>Volumetric Efficiency</p></a></li>
<li><a href='#wNSE'>
<p>Weighted Nash-Sutcliffe efficiency</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Goodness-of-Fit Functions for Comparison of Simulated and
Observed Hydrological Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mauricio Zambrano-Bigiarini &lt;mzb.devel@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>S3 functions implementing both statistical and graphical goodness-of-fit measures between observed and simulated values, mainly oriented to be used during the calibration, validation, and application of hydrological models. Missing values in observed and/or simulated values can be removed before computations. Comments / questions / collaboration of any kind are very welcomed.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), zoo (&ge; 1.7-2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>hydroTSM (&ge; 0.5-0), xts (&ge; 0.8-2), methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hzambran/hydroGOF">https://github.com/hzambran/hydroGOF</a></td>
</tr>
<tr>
<td>MailingList:</td>
<td>https://stat.ethz.ch/mailman/listinfo/r-sig-ecology</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hzambran/hydroGOF/issues">https://github.com/hzambran/hydroGOF/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 21:18:40 UTC; hzambran</td>
</tr>
<tr>
<td>Author:</td>
<td>Mauricio Zambrano-Bigiarini
    <a href="https://orcid.org/0000-0002-9536-643X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 22:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='br2'>
br2
</h2><span id='topic+br2'></span><span id='topic+br2.default'></span><span id='topic+br2.matrix'></span><span id='topic+br2.data.frame'></span><span id='topic+br2.zoo'></span>

<h3>Description</h3>

<p>Coefficient of determination (r2) multiplied by the slope of the regression line between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br2(sim, obs, ...)

## Default S3 method:
br2(sim, obs, na.rm=TRUE, use.abs=FALSE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
br2(sim, obs, na.rm=TRUE, use.abs=FALSE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
br2(sim, obs, na.rm=TRUE, use.abs=FALSE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
br2(sim, obs, na.rm=TRUE, use.abs=FALSE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="br2_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="br2_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="br2_+3A_na.rm">na.rm</code></td>
<td>

<p>logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="br2_+3A_use.abs">use.abs</code></td>
<td>

<p>logical value indicating whether the condition to select the formula used to compute <code>br2</code> should be 'b&lt;=1' or 'abs(b) &lt;=1'. <br />
Krausse et al. (2005) uses 'b&lt;=1' as condition, but strictly speaking this condition should be 'abs(b)&lt;=1'. However, if your model simulations are somewhat &quot;close&quot; to the observations, this condition should not have much impact on the computation of 'br2'. <br />
This argument was introduced in hydroGOF 0.4-0, following a comment by E. White. Its default value is <code>FALSE</code> to ensure compatibility with previous versions of hydroGOF.
</p>
</td></tr>
<tr><td><code id="br2_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="br2_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="br2_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="br2_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> br2 = |b| R2 , b &lt;= 1  ; br2 = \frac{R2}{|b|}, b &gt; 1  </code>
</p>
 
<p>A model that systematically over or under-predicts all the time will still result in &quot;good&quot; <code>R2</code> (close to 1), even if all predictions were wrong (Krause et al., 2005).
The <code>br2</code> coefficient allows accounting for the discrepancy in the magnitude of two signals (depicted by 'b') as well as their dynamics (depicted by <code>R2</code>)
</p>


<h3>Value</h3>

<p>br2 between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the <code>br2</code> between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>
<p>The slope <code>b</code> is computed as the coefficient of the linear regression between <code>sim</code> and <code>obs</code>, forcing the intercept be equal to zero.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Krause, P., Boyle, D. P., and Base, F.: Comparison of different efficiency criteria for hydrological model assessment, Adv. Geosci., 5, 89-97, 2005</cite>
</p>
<p><cite>Krstic, G., Krstic, N.S., Zambrano-Bigiarini, M. (2016). The br2-weighting Method for Estimating the Effects of Air Pollution on Population Health. Journal of Modern Applied Statistical Methods, 15(2), 42. doi:10.22237/jmasm/1478004000</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R2">R2</a></code>, <code><a href="#topic+rPearson">rPearson</a></code>, <code><a href="#topic+rSpearman">rSpearman</a></code>, <code><a href="stats.html#topic+cor">cor</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: 
# Looking at the difference between r2 and br2 for a case with systematic 
# over-prediction of observed values
obs &lt;- 1:10
sim1 &lt;- 2*obs + 5
sim2 &lt;- 2*obs + 25

# The coefficient of determination is equal to 1 even if there is no one single 
# simulated value equal to its corresponding observed counterpart
r2 &lt;- (cor(sim1, obs, method="pearson"))^2 # r2=1

# 'br2' effectively penalises the systematic over-estimation
br2(sim1, obs) # br2 = 0.3684211
br2(sim2, obs) # br2 = 0.1794872

ggof(sim1, obs)
ggof(sim2, obs)

# Computing 'br2' without forcing the intercept be equal to zero
br2.2 &lt;- r2/2 # br2 = 0.5

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'br2' for the "best" (unattainable) case
br2(sim=sim, obs=obs)

##################
# Example 3: br2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

br2(sim=sim, obs=obs)

##################
# Example 4: br2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

br2(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
br2(sim=lsim, obs=lobs)

##################
# Example 5: br2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

br2(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
br2(sim=lsim, obs=lobs)

##################
# Example 6: br2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
br2(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
br2(sim=lsim, obs=lobs)

##################
# Example 7: br2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
br2(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
br2(sim=lsim, obs=lobs)

##################
# Example 8: br2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

br2(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
br2(sim=sim1, obs=obs1)

</code></pre>

<hr>
<h2 id='cp'>
Coefficient of persistence
</h2><span id='topic+cp'></span><span id='topic+cp.default'></span><span id='topic+cp.matrix'></span><span id='topic+cp.data.frame'></span><span id='topic+cp.zoo'></span>

<h3>Description</h3>

<p>Coefficient of persistence between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp(sim, obs, ...)

## Default S3 method:
cp(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
cp(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
cp(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
cp(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="cp_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="cp_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="cp_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="cp_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="cp_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="cp_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> cp = 1 -\frac { \sum_{i=2}^N { \left( S_i - O_i \right)^2 } } { \sum_{i=1}^{N-1} { \left( O_{i+1} - O_i \right)^2 } }  </code>
</p>

<p>Coefficient of persistence (Kitadinis and Bras, 1980; Corradini et al., 1986) is used to compare the model  performance against a simple model using the observed value of the previous day as the prediction for the current day. <br />
</p>
<p>The coefficient of persistence compare the predictions of the model with the predictions obtained by assuming that the process is a Wiener process (variance increasing linearly with time), in which case, the best estimate for the future is given by the latest measurement (Kitadinis and Bras, 1980). <br />
</p>
<p>Persistence model efficiency is a normalized model evaluation statistic that quantifies the relative magnitude of the residual variance (noise) to the variance of the errors obtained by the use of a simple persistence model (Moriasi et al., 2007). 
</p>
<p>CP ranges from 0 to 1, with CP = 1 being the optimal value and it should be larger than 0.0 to indicate a minimally acceptable model performance.
</p>


<h3>Value</h3>

<p>Coefficient of persistence between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the coefficient of persistence between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Kitanidis, P.K., and Bras, R.L. 1980. Real-time forecasting with a conceptual hydrologic model. 2. Applications and results. Water Resources Research, Vol. 16, No. 6, pp. 1034:1044</cite> <br />
</p>
<p><cite>Moriasi, D. N. et al. (2007). Model Evaluation Guidelines for Systematic Quantification of Accuracy in Watershed Simulations. Transactions of the ASABE, 50:(3), 885-900</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
cp(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
cp(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'cp' for the "best" (unattainable) case
cp(sim=sim, obs=obs)

##################
# Example 3: cp for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

cp(sim=sim, obs=obs)

##################
# Example 4: cp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

cp(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
cp(sim=lsim, obs=lobs)

##################
# Example 5: cp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

cp(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
cp(sim=lsim, obs=lobs)

##################
# Example 6: cp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
cp(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
cp(sim=lsim, obs=lobs)

##################
# Example 7: cp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
cp(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
cp(sim=lsim, obs=lobs)

##################
# Example 8: cp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

cp(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
cp(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='d'>
Index of Agreement
</h2><span id='topic+d'></span><span id='topic+d.default'></span><span id='topic+d.matrix'></span><span id='topic+d.data.frame'></span><span id='topic+d.zoo'></span>

<h3>Description</h3>

<p>Index of Agreement between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d(sim, obs, ...)

## Default S3 method:
d(sim, obs, na.rm=TRUE, fun=NULL, ...,
           epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
           epsilon.value=NA)

## S3 method for class 'data.frame'
d(sim, obs, na.rm=TRUE, fun=NULL, ...,
           epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
           epsilon.value=NA)

## S3 method for class 'matrix'
d(sim, obs, na.rm=TRUE, fun=NULL, ...,
           epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
           epsilon.value=NA)

## S3 method for class 'zoo'
d(sim, obs, na.rm=TRUE, fun=NULL, ...,
           epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
           epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="d_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="d_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="d_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="d_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="d_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>FUN</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="d_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">d = 1 - \frac{\sum_{i=1}^N {(O_i - S_i)^2} } { \sum_{i=1}^N { ( \left| S_i -  \bar{O} \right| + \left| O_i -  \bar{O}  \right| } )^2 } </code>
</p>
 
<p>The Index of Agreement (d) developed by Willmott (1981) as a standardized measure of the degree of model prediction error. 
</p>
<p>It is is dimensionless and varies between 0 and 1. A value of 1 indicates a perfect match, and 0 indicates no agreement at all (Willmott, 1981).
</p>
<p>The index of agreement can detect additive and proportional differences in the observed and simulated means and variances; however, it is overly sensitive to extreme values due to the squared differences (Legates and McCabe, 1999).
</p>


<h3>Value</h3>

<p>Index of agreement between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes or data.frames, the returned value is a vector, with the index of agreement between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Willmott, C. J. 1981. On the validation of models. Physical Geography, 2, 184&ndash;194</cite> <br />
</p>
<p><cite>Willmott, C. J. (1984). On the evaluation of model performance in physical geography. Spatial Statistics and Models, G. L. Gaile and C. J. Willmott, eds., 443-460</cite> <br />
</p>
<p><cite>Willmott, C. J., S. G. Ackleson, R. E. Davis, J. J. Feddema, K. M. Klink, D. R. Legates, J. O'Donnell, and C. M. Rowe (1985), Statistics for the Evaluation and Comparison of Models, J. Geophys. Res., 90(C5), 8995-9005</cite> <br />
</p>
<p><cite>Legates, D. R. and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resources Research, 35(1), 233-241. doi:10.1029/1998WR900018</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+md">md</a></code>, <code><a href="#topic+rd">rd</a></code>, <code><a href="#topic+dr">dr</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
d(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
d(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'd' for the "best" (unattainable) case
d(sim=sim, obs=obs)

##################
# Example 3: d for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

d(sim=sim, obs=obs)

##################
# Example 4: d for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

d(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
d(sim=lsim, obs=lobs)

##################
# Example 5: d for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

d(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
d(sim=lsim, obs=lobs)

##################
# Example 6: d for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
d(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
d(sim=lsim, obs=lobs)

##################
# Example 7: d for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
d(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
d(sim=lsim, obs=lobs)

##################
# Example 8: d for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

d(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
d(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='dr'>
Refined Index of Agreement
</h2><span id='topic+dr'></span><span id='topic+dr.default'></span><span id='topic+dr.matrix'></span><span id='topic+dr.data.frame'></span><span id='topic+dr.zoo'></span>

<h3>Description</h3>

<p>Refined Index of Agreement (dr) between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr(sim, obs, ...)

## Default S3 method:
dr(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
dr(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
dr(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
dr(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dr_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="dr_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="dr_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="dr_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="dr_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="dr_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>FUN</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="dr_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">c = 2</code>
</p>

<p style="text-align: center;"><code class="reqn">A = \sum_{i=1}^N {\left| S_i - O_i \right|} </code>
</p>

<p style="text-align: center;"><code class="reqn">B = c \sum_{i=1}^N {\left| O_i - \bar{O} \right|} </code>
</p>

<p style="text-align: center;"><code class="reqn">dr = 1 - \frac{A} { B } ; A \leq B</code>
</p>
 
<p style="text-align: center;"><code class="reqn">dr = 1 - \frac{B} { A } ; A &gt; B</code>
</p>
 
<p>The Refined Index of Agreement (dr, Willmott et al., 2012) is a reformulation of the orginal Willmott's index of agreement developed in the 1980s (Willmott, 1981; Willmott, 1984; Willmott et al., 1985)
</p>
<p>The Refined Index of Agreement (dr) is dimensionless, and it varies between -1 to 1 (in contrast to the original d, which varies in [0, 1]).
</p>
<p>The Refined Index of Agreement (dr) is monotonically related with the modified Nash-Sutcliffe (E1) desribed in Legates and McCabe (1999).
</p>
<p>In general, dr is more rationally related to model accuracy than are other existing indices (Willmott et al., 2012; Willmott et al., 2015). It also is quite flexible, making it applicable to a wide range of model-performance problems (Willmott et al., 2012)
</p>


<h3>Value</h3>

<p>Refined Index of Agreement (dr) between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes or data.frames, the returned value is a vector, with the Refined Index of Agreement (dr) between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Willmott, C.J., Robeson, S.M. and Matsuura, K. (2012). A refined index of model performance. International Journal of climatology, 32(13), pp.2088-2094. doi:10.1002/joc.2419.</cite> <br />
</p>
<p><cite>Willmott, C.J., Robeson, S.M., Matsuura, K. and Ficklin, D.L. (2015). Assessment of three dimensionless measures of model performance. Environmental Modelling &amp; Software, 73, pp.167-174. doi:10.1016/j.envsoft.2015.08.012</cite> <br />
</p>
<p><cite>Willmott, C. J. (1981). On the validation of models. Physical Geography, 2, 184&ndash;194</cite>  <br />
</p>
<p><cite>Willmott, C. J. (1984). On the evaluation of model performance in physical geography. Spatial Statistics and Models, G. L. Gaile and C. J. Willmott, eds., 443-460</cite> <br />
</p>
<p><cite>Willmott, C. J., S. G. Ackleson, R. E. Davis, J. J. Feddema, K. M. Klink, D. R. Legates, J. O'Donnell, and C. M. Rowe (1985), Statistics for the Evaluation and Comparison of Models, J. Geophys. Res., 90(C5), 8995-9005</cite> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+d">d</a></code>, <code><a href="#topic+md">md</a></code>, <code><a href="#topic+rd">rd</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
dr(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
dr(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'dr' for the "best" (unattainable) case
dr(sim=sim, obs=obs)

##################
# Example 3: dr for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

dr(sim=sim, obs=obs)

##################
# Example 4: dr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

dr(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
dr(sim=lsim, obs=lobs)

##################
# Example 5: dr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

dr(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
dr(sim=lsim, obs=lobs)

##################
# Example 6: dr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
dr(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
dr(sim=lsim, obs=lobs)

##################
# Example 7: dr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
dr(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
dr(sim=lsim, obs=lobs)

##################
# Example 8: dr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

dr(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
dr(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='EgaEnEstellaQts'>
Ega in &quot;Estella&quot; (Q071), ts with daily streamflows.
</h2><span id='topic+EgaEnEstellaQts'></span>

<h3>Description</h3>

<p>Time series with daily streamflows of the Ega River (subcatchment of the Ebro River basin, Spain) measured at the gauging station &quot;Estella&quot; (Q071), for the period 01/Jan/1961 to 31/Dec/1970
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EgaEnEstellaQts)
</code></pre>


<h3>Format</h3>

<p>zoo object.
</p>


<h3>Source</h3>

<p>Downloaded from: <a href="https://www.chebro.es">https://www.chebro.es</a>. Last accessed [March 2010]. <br />
These data are intended to be used for research purposes only, being distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.
</p>

<hr>
<h2 id='ggof'>
Graphical Goodness of Fit
</h2><span id='topic+ggof'></span>

<h3>Description</h3>

<p>Graphical comparison between two vectors (numeric, ts or zoo), with several numerical goodness of fit printed as a legend. <br />
Missing values in observed and/or simulated values can removed before the computations. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggof(sim, obs, na.rm = TRUE, dates, date.fmt = "%Y-%m-%d", 
     pt.style = "ts", ftype = "o",  FUN, 
     stype="default", season.names=c("Winter", "Spring", "Summer", "Autumn"),
     gof.leg = TRUE,  digits=2, 
     gofs=c("ME", "MAE", "RMSE", "NRMSE", "PBIAS", "RSR", "rSD", "NSE", "mNSE", 
             "rNSE", "d", "md", "rd", "r", "R2", "bR2", "KGE", "VE"),
     legend, leg.cex=1,
     tick.tstep = "auto", lab.tstep = "auto", lab.fmt=NULL,
     cal.ini=NA, val.ini=NA,
     main, xlab = "Time", ylab=c("Q, [m3/s]"),  
     col = c("blue", "black"), 
     cex = c(0.5, 0.5), cex.axis=1.2, cex.lab=1.2,
     lwd = c(1, 1), lty = c(1, 3), pch = c(1, 9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggof_+3A_sim">sim</code></td>
<td>

<p>numeric or zoo object with with simulated values
</p>
</td></tr>
<tr><td><code id="ggof_+3A_obs">obs</code></td>
<td>

<p>numeric or zoo object with observed values
</p>
</td></tr>
<tr><td><code id="ggof_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_dates">dates</code></td>
<td>

<p>character, factor, Date or POSIXct object indicating how to obtain the dates for the corresponding values in the <code>sim</code> and <code>obs</code> time series <br />
If <code>dates</code> is a character or factor, it is converted into Date/POSIXct class, using the date format specified by <code>date.fmt</code>
</p>
</td></tr>
<tr><td><code id="ggof_+3A_date.fmt">date.fmt</code></td>
<td>

<p>OPTIONAL. character indicating the format in which the dates are stored in <code>dates</code>, <code>cal.ini</code> and <code>val.ini</code>. See <code>format</code> in <code><a href="base.html#topic+as.Date">as.Date</a></code>. Default value is <kbd>%Y-%m-%d</kbd> <br />
ONLY required when <code>class(dates)=="character"</code> or <code>class(dates)=="factor"</code> or when <code>cal.ini</code> and/or <code>val.ini</code> is provided.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_pt.style">pt.style</code></td>
<td>

<p>Character indicating if the 2 ts have to be plotted as lines or bars. When <code>ftype</code> is NOT <kbd>o</kbd>, it only applies to the annual values. Valid values are: <br />
-) <kbd>ts</kbd> : (default) each ts is plotted as a lines along the 'x' axis <br />
-) <kbd>bar</kbd>: both series are plotted as barplots. 
</p>
</td></tr>
<tr><td><code id="ggof_+3A_ftype">ftype</code></td>
<td>

<p>Character indicating how many plots are desired by the user. Valid values are: <br />
-) <kbd>o</kbd>       : only the original <code>sim</code> and <code>obs</code> time series are plotted <br />
-) <kbd>dm</kbd>      : it assumes that <code>sim</code> and <code>obs</code> are daily time series and Daily and Monthly values are plotted  <br />
-) <kbd>ma</kbd>      : it assumes that <code>sim</code> and <code>obs</code> are daily or monthly time series and Monthly and Annual values are plotted <br />
-) <kbd>dma</kbd>     : it assumes that <code>sim</code> and <code>obs</code> are daily time series and Daily, Monthly and Annual values are plotted <br />
-) <kbd>seasonal</kbd>: seasonal values are plotted. See <code>stype</code> and <code>season.names</code>
</p>
</td></tr>
<tr><td><code id="ggof_+3A_fun">FUN</code></td>
<td>

<p>OPTIONAL, ONLY required when <code>ftype</code> is in <code>c('dm', 'ma', 'dma', 'seasonal')</code>. Function that have to be applied for transforming teh original ts into monthly, annual or seasonal time step (e.g., for precipitation FUN MUST be <code>sum</code>, for temperature and flow time series, FUN MUST be <code>mean</code>)
</p>
</td></tr>
<tr><td><code id="ggof_+3A_stype">stype</code></td>
<td>

<p>OPTIONAL, only used when <code>ftype=seasonal</code>. <br />
character, indicating whath weather seasons will be used for computing the output. Possible values are: <br />
-) <kbd>default</kbd>          =&gt;  &quot;winter&quot;= DJF  = Dec, Jan, Feb;      &quot;spring&quot;= MAM = Mar, Apr, May;  &quot;summer&quot;= JJA  = Jun, Jul, Aug;       &quot;autumn&quot;= SON = Sep, Oct, Nov  <br />
-) <kbd>FrenchPolynesia</kbd>  =&gt;  &quot;winter&quot;= DJFM = Dec, Jan, Feb, Mar; &quot;spring&quot;= AM  = Apr, May;       &quot;summer&quot;= JJAS = Jun, Jul, Aug, Sep;  &quot;autumn&quot;= ON  = Oct, Nov 
</p>
</td></tr>
<tr><td><code id="ggof_+3A_season.names">season.names</code></td>
<td>

<p>OPTIONAL, only used when <code>ftype=seasonal</code>. <br />
character of length 4 indicating the names of each one of the weather seasons defined by <code>stype</code>.These names are only used for plotting purposes
</p>
</td></tr>
<tr><td><code id="ggof_+3A_gof.leg">gof.leg</code></td>
<td>

<p>logical, indicating if several numerical goodness of fit have to be computed between <code>sim</code> and <code>obs</code>, and plotted as a legend on the graph. If <code>leg.gof=TRUE</code>, then <code>x</code> is considered as observed and <code>y</code> as simulated values (for some gof functions this is important).
</p>
</td></tr>
<tr><td><code id="ggof_+3A_digits">digits</code></td>
<td>

<p>OPTIONAL, only used when <code>leg.gof=TRUE</code>. Numeric, representing the decimal places used for rounding the goodness-of-fit indexes.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_gofs">gofs</code></td>
<td>

<p>character, with one or more strings indicating the goodness-of-fit measures to be shown in the legend of the plot when  <code>gof.leg=TRUE</code>. <br />
Possible values when <code>ftype!='seasonal'</code> are in <code>c("ME", "MAE", "MSE", "RMSE", "NRMSE", "PBIAS", "RSR", "rSD", "NSE", "mNSE", "rNSE", "d", "md", "rd", "cp", "r", "R2", "bR2", "KGE", "VE")</code> <br />
Possible values when <code>ftype='seasonal'</code> are in c(&quot;ME&quot;, &quot;RMSE&quot;, &quot;PBIAS&quot;, &quot;RSR&quot;, &quot;NSE&quot;, &quot;d&quot;, &quot;R2&quot;, &quot;KGE&quot;, &quot;VE&quot;)
</p>
</td></tr>
<tr><td><code id="ggof_+3A_legend">legend</code></td>
<td>

<p>character of length 2 to appear in the legend.  
</p>
</td></tr>
<tr><td><code id="ggof_+3A_leg.cex">leg.cex</code></td>
<td>

<p>OPTIONAL. ONLY used when <code>leg.gof=TRUE</code>. Character expansion factor for drawing the legend, *relative*  to current 'par(&quot;cex&quot;)'. Used for text, and provides the default for 'pt.cex' and 'title.cex'. Default value = 1
</p>
</td></tr>
<tr><td><code id="ggof_+3A_tick.tstep">tick.tstep</code></td>
<td>

<p>character, indicating the time step that have to be used for putting the ticks on the time axis. Valid values are: <kbd>auto</kbd>, <kbd>years</kbd>, <kbd>months</kbd>,<kbd>weeks</kbd>, <kbd>days</kbd>, <kbd>hours</kbd>, <kbd>minutes</kbd>, <kbd>seconds</kbd>.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_lab.tstep">lab.tstep</code></td>
<td>

<p>character, indicating the time step that have to be used for putting the labels on the time axis. Valid values are: <kbd>auto</kbd>, <kbd>years</kbd>, <kbd>months</kbd>,<kbd>weeks</kbd>, <kbd>days</kbd>, <kbd>hours</kbd>, <kbd>minutes</kbd>, <kbd>seconds</kbd>.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_lab.fmt">lab.fmt</code></td>
<td>

<p>Character indicating the format to be used for the label of the axis. See <code>lab.fmt</code> in <code><a href="hydroTSM.html#topic+drawTimeAxis">drawTimeAxis</a></code>.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_cal.ini">cal.ini</code></td>
<td>

<p>OPTIONAL. Character, indicating the date in which the calibration period started. <br />
When <code>cal.ini</code> is provided, all the values in <code>obs</code> and <code>sim</code> with dates previous to <code>cal.ini</code> are SKIPPED from the computation of the goodness-of-fit measures (when <code>gof.leg=TRUE</code>), but their values are still plotted, in order to examine if the warming up period was too short, acceptable or too long for the chosen calibration period.
In addition, a vertical red line in drawn at this date. 
</p>
</td></tr>
<tr><td><code id="ggof_+3A_val.ini">val.ini</code></td>
<td>

<p>OPTIONAL. Character, the date in which the validation period started. <br />
ONLY used for drawing a vertical red line at this date. 
</p>
</td></tr>
<tr><td><code id="ggof_+3A_main">main</code></td>
<td>

<p>character representing the main title of the plot.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_xlab">xlab</code></td>
<td>

<p>label for the 'x' axis.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_ylab">ylab</code></td>
<td>

<p>label for the 'y' axis.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_col">col</code></td>
<td>

<p>character, representing the colors of <code>sim</code> and <code>obs</code>
</p>
</td></tr>
<tr><td><code id="ggof_+3A_cex">cex</code></td>
<td>

<p>numeric, representing the values controlling the size of text and symbols of 'x' and 'y' with respect to the default
</p>
</td></tr>
<tr><td><code id="ggof_+3A_cex.axis">cex.axis</code></td>
<td>

<p>numeric, representing the magnification to be used for the axis annotation relative to 'cex'. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_cex.lab">cex.lab</code></td>
<td>

<p>numeric, representing the magnification to be used for x and y labels relative to the current setting of 'cex'. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="ggof_+3A_lwd">lwd</code></td>
<td>

<p>vector with the line width of <code>sim</code> and <code>obs</code>
</p>
</td></tr>
<tr><td><code id="ggof_+3A_lty">lty</code></td>
<td>

<p>numeric with the line type of <code>sim</code> and <code>obs</code>
</p>
</td></tr>
<tr><td><code id="ggof_+3A_pch">pch</code></td>
<td>

<p>numeric with the type of symbol for <code>x</code> and <code>y</code>. (e.g., 1: white circle; 9: white rhombus with a cross inside)
</p>
</td></tr>
<tr><td><code id="ggof_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots observed and simulated values in the same graph.
</p>
<p>If <code>gof.leg=TRUE</code>, it computes the numerical values of: <br />
'me', 'mae', 'rmse', 'nrmse', 'PBIAS',  'RSR, 'rSD', 'NSE', 'mNSE', 'rNSE', 'd', 'md, 'rd', 'cp', 'r', 'r.Spearman', 'R2', 'bR2', 'KGE', 'VE'
</p>


<h3>Value</h3>

<table>
<tr><td><code>me</code></td>
<td>
<p>Mean Error</p>
</td></tr>
<tr><td><code>mae</code></td>
<td>
<p>Mean Absolute Error</p>
</td></tr>

<tr><td><code>rmse</code></td>
<td>
<p>Root Mean Square Error</p>
</td></tr>
<tr><td><code>nrmse</code></td>
<td>
<p>Normalized Root Mean Square Error</p>
</td></tr>
<tr><td><code>PBIAS</code></td>
<td>
<p>Percent Bias</p>
</td></tr>
<tr><td><code>pbiasfdc</code></td>
<td>
<p>PBIAS in the slope of the midsegment of the Flow Duration Curve</p>
</td></tr>
<tr><td><code>RSR</code></td>
<td>
<p>Ratio of RMSE to the Standard Deviation of the Observations, RSR = rms / sd(obs). ( 0 &lt;= RSR &lt;= +Inf )</p>
</td></tr>
<tr><td><code>rSD</code></td>
<td>
<p>Ratio of Standard Deviations, rSD = sd(sim) / sd(obs)</p>
</td></tr>
<tr><td><code>NSE</code></td>
<td>
<p>Nash-Sutcliffe Efficiency ( -Inf &lt;= NSE &lt;= 1 )</p>
</td></tr>
<tr><td><code>mNSE</code></td>
<td>
<p>Modified Nash-Sutcliffe Efficiency</p>
</td></tr>
<tr><td><code>rNSE</code></td>
<td>
<p>Relative Nash-Sutcliffe Efficiency</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Index of Agreement ( 0 &lt;= d &lt;= 1 )</p>
</td></tr>
<tr><td><code>md</code></td>
<td>
<p>Modified Index of Agreement</p>
</td></tr>
<tr><td><code>rd</code></td>
<td>
<p>Relative Index of Agreement</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>Persistence Index ( 0 &lt;= PI &lt;= 1 ) </p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Pearson product-moment correlation coefficient ( -1 &lt;= r &lt;= 1 )</p>
</td></tr>
<tr><td><code>r.Spearman</code></td>
<td>
<p>Spearman Correlation coefficient ( -1 &lt;= r.Spearman &lt;= 1 ) </p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>Coefficient of Determination ( 0 &lt;= R2 &lt;= 1 ). <br />
Gives the proportion of the variance of one variable that is predictable from the other variable</p>
</td></tr>
<tr><td><code>bR2</code></td>
<td>
<p>R2 multiplied by the coefficient of the regression line between <code>sim</code> and <code>obs</code> <br /> ( 0 &lt;= bR2 &lt;= 1 )</p>
</td></tr>
<tr><td><code>KGE</code></td>
<td>
<p>Kling-Gupta efficiency between <code>sim</code> and <code>obs</code> <br /> ( 0 &lt;= KGE &lt;= 1 )</p>
</td></tr>
<tr><td><code>VE</code></td>
<td>
<p>Volumetric efficiency between <code>sim</code> and <code>obs</code> <br /> ( -Inf &lt;= VE &lt;= 1)</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233-241</cite> <br />
</p>
<p><cite>Krause P., Boyle D.P., and Base F., Comparison of different efficiency criteria for hydrological model assessment, Advances in Geosciences 5 (2005), pp. 89-97</cite> <br />
</p>
<p><cite>Moriasi, D.N., Arnold, J.G., Van Liew, M.W., Bingner, R.L., Harmel, R.D., Veith, T.L. 2007. Model evaluation guidelines for systematic quantification of accuracy in watershed simulations <br /> Transactions of the ASABE. 50(3):885-900</cite> <br />
</p>
<p><cite>Boyle, D. P., H. V. Gupta, and S. Sorooshian (2000), Toward Improved Calibration of Hydrologic Models: Combining the Strengths of Manual and Automatic Methods, Water Resour. Res., 36(12), 3663-3674</cite> <br />
</p>
<p><cite>Kitanidis, P. K., and R. L. Bras (1980), Real-Time Forecasting With a Conceptual Hydrologic Model 2. Applications and Results, Water Resour. Res., 16(6), 1034-1044</cite> <br />
</p>
<p><cite>J.E. Nash and J.V. Sutcliffe, River flow forecasting through conceptual models. Part 1: a discussion of principles, J. Hydrol. 10 (1970), pp. 282-290</cite> <br />
</p>
<p><cite>Yapo P. O., Gupta H. V., Sorooshian S., 1996. Automatic calibration of conceptual rainfall-runoff models: sensitivity to calibration data. Journal of Hydrology. v181 i1-4. 23-48. doi:10.1016/0022-1694(95)02918-4</cite> <br />
</p>
<p><cite>Yilmaz, K. K., H. V. Gupta, and T. Wagener  (2008), A process-based diagnostic approach to model evaluation: Application to the NWS distributed hydrologic model, Water Resour. Res., 44, W09417, doi:10.1029/2007WR006716</cite> <br />
</p>
<p><cite>Hoshin V. Gupta, Harald Kling, Koray K. Yilmaz, Guillermo F. Martinez. Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of Hydrology, Volume 377, Issues 1-2, 20 October 2009, Pages 80-91. DOI: 10.1016/j.jhydrol.2009.08.003. ISSN 0022-1694</cite> <br />
</p>
<p><cite>Criss, R. E. and Winston, W. E. (2008), Do Nash values have value? Discussion and alternate proposals. Hydrological Processes, 22: 2723-2725. doi: 10.1002/hyp.7072</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+plot2">plot2</a></code>, 
<code><a href="#topic+ggof">ggof</a></code>, <code><a href="#topic+me">me</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, 
<code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+rsr">rsr</a></code>, <code><a href="#topic+rSD">rSD</a></code>, <code><a href="#topic+NSE">NSE</a></code>, <code><a href="#topic+mNSE">mNSE</a></code>, 
<code><a href="#topic+rNSE">rNSE</a></code>, <code><a href="#topic+wNSE">wNSE</a></code>, <code><a href="#topic+d">d</a></code>, <code><a href="#topic+dr">dr</a></code>, <code><a href="#topic+md">md</a></code>, <code><a href="#topic+rd">rd</a></code>, 
<code><a href="#topic+cp">cp</a></code>, <code><a href="#topic+rPearson">rPearson</a></code>, <code><a href="#topic+R2">R2</a></code>, <code><a href="#topic+br2">br2</a></code>, <code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+KGElf">KGElf</a></code>,
<code><a href="#topic+KGEnp">KGEnp</a></code>, <code><a href="#topic+sKGE">sKGE</a></code>, <code><a href="#topic+VE">VE</a></code>, <code><a href="#topic+rSpearman">rSpearman</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- 1:10
sim &lt;- 2:11

## Not run: 
ggof(sim, obs)

## End(Not run)

##################
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Getting the numeric goodness of fit for the "best" (unattainable) case
gof(sim=sim, obs=obs)

# Randomly changing the first 2000 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Getting the new numeric goodness-of-fit measures
gof(sim=sim, obs=obs)

# Getting the graphical representation of 'obs' and 'sim' along with the numeric 
# goodness-of-fit measures for the daily and monthly time series 
## Not run: 
ggof(sim=sim, obs=obs, ftype="dm", FUN=mean)

## End(Not run)

# Getting the graphical representation of 'obs' and 'sim' along with some numeric 
# goodness-of-fit measures for the seasonal time series 
## Not run: 
ggof(sim=sim, obs=obs, ftype="seasonal", FUN=mean)

## End(Not run)

# Computing the daily residuals 
# even if this is a dummy example, it is enough for illustrating the capability
r &lt;- sim-obs

# Summarizing and plotting the residuals
## Not run: 
library(hydroTSM)

# summary
smry(r) 

# daily, monthly and annual plots, boxplots and histograms
hydroplot(r, FUN=mean)

# seasonal plots and boxplots
hydroplot(r, FUN=mean, pfreq="seasonal")

## End(Not run)

</code></pre>

<hr>
<h2 id='gof'>
Numerical Goodness-of-fit measures
</h2><span id='topic+gof'></span><span id='topic+gof.default'></span><span id='topic+gof.matrix'></span><span id='topic+gof.data.frame'></span><span id='topic+gof.zoo'></span>

<h3>Description</h3>

<p>Numerical goodness-of-fit measures between <code>sim</code> and <code>obs</code>, with treatment of missing values. Several performance indices for comparing two vectors, matrices or data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(sim, obs, ...)

## Default S3 method:
gof(sim, obs, na.rm=TRUE, do.spearman=FALSE, do.pbfdc=FALSE,
        j=1, norm="sd", s=c(1,1,1), method=c("2009", "2012"), lQ.thr=0.7,
        hQ.thr=0.2, start.month=1, digits=2, fun=NULL, ...,
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
        epsilon.value=NA)
## S3 method for class 'matrix'
gof(sim, obs, na.rm=TRUE, do.spearman=FALSE, do.pbfdc=FALSE,
        j=1, norm="sd", s=c(1,1,1), method=c("2009", "2012"), lQ.thr=0.7,
        hQ.thr=0.2, start.month=1, digits=2, fun=NULL, ...,
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"),
        epsilon.value=NA)
## S3 method for class 'data.frame'
gof(sim, obs, na.rm=TRUE, do.spearman=FALSE, do.pbfdc=FALSE,
        j=1, norm="sd", s=c(1,1,1), method=c("2009", "2012"), lQ.thr=0.7,
        hQ.thr=0.2, start.month=1, digits=2, fun=NULL, ...,
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"),
        epsilon.value=NA)
## S3 method for class 'zoo'
gof(sim, obs, na.rm=TRUE, do.spearman=FALSE, do.pbfdc=FALSE,
        j=1, norm="sd", s=c(1,1,1), method=c("2009", "2012"), lQ.thr=0.7,
        hQ.thr=0.2, start.month=1, digits=2, fun=NULL, ...,
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"),
        epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="gof_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="gof_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="gof_+3A_do.spearman">do.spearman</code></td>
<td>

<p>logical. Indicates if the Spearman correlation has to be computed. The default is FALSE.
</p>
</td></tr>
<tr><td><code id="gof_+3A_do.pbfdc">do.pbfdc</code></td>
<td>

<p>logical. Indicates if the Percent Bias in the Slope of the midsegment of the Flow Duration Curve (<code><a href="#topic+pbiasfdc">pbiasfdc</a></code>) has to be computed. The default is FALSE.
</p>
</td></tr>
<tr><td><code id="gof_+3A_j">j</code></td>
<td>

<p>argument passed to the <code><a href="#topic+mNSE">mNSE</a></code> function
</p>
</td></tr>
<tr><td><code id="gof_+3A_norm">norm</code></td>
<td>

<p>argument passed to the <code><a href="#topic+nrmse">nrmse</a></code> function
</p>
</td></tr>
<tr><td><code id="gof_+3A_s">s</code></td>
<td>

<p>argument passed to the <code><a href="#topic+KGE">KGE</a></code> function
</p>
</td></tr>
<tr><td><code id="gof_+3A_method">method</code></td>
<td>

<p>argument passed to the <code><a href="#topic+KGE">KGE</a></code> function
</p>
</td></tr>
<tr><td><code id="gof_+3A_lq.thr">lQ.thr</code></td>
<td>

<p>argument passed to the (optional) <code><a href="#topic+pbiasfdc">pbiasfdc</a></code> function
</p>
</td></tr>
<tr><td><code id="gof_+3A_hq.thr">hQ.thr</code></td>
<td>

<p>argument passed to the (optional) <code><a href="#topic+pbiasfdc">pbiasfdc</a></code> function
</p>
</td></tr>
<tr><td><code id="gof_+3A_start.month">start.month</code></td>
<td>

<p>[OPTIONAL]. Only used for the computation of the split KGE (<code>sKGE</code>) when the (hydrological) year of interest is different from the calendar year.
</p>
<p>numeric in [1:12] indicating the starting month of the (hydrological) year. Numeric values in [1, 12] represent months in [January, December]. By default <code>start.month=1</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_digits">digits</code></td>
<td>

<p>decimal places used for rounding the goodness-of-fit indexes.
</p>
</td></tr>
<tr><td><code id="gof_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the all the goodness-of-fit functions.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="gof_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>FUN</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the <code>gof</code> function is a matrix with one column only, and the following rows: <br />
</p>
<table>
<tr><td><code>ME</code></td>
<td>
<p>Mean Error</p>
</td></tr>
<tr><td><code>MAE</code></td>
<td>
<p>Mean Absolute Error</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>Mean Squared Error</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root Mean Square Error</p>
</td></tr>
<tr><td><code>ubRMSE</code></td>
<td>
<p>Unbiased Root Mean Square Error</p>
</td></tr>
<tr><td><code>NRMSE</code></td>
<td>
<p>Normalized Root Mean Square Error  ( -100% &lt;= nrms &lt;= 100% )</p>
</td></tr>
<tr><td><code>PBIAS</code></td>
<td>
<p>Percent Bias</p>
</td></tr>
<tr><td><code>RSR</code></td>
<td>
<p>Ratio of RMSE to the Standard Deviation of the Observations, RSR = rms / sd(obs). ( 0 &lt;= RSR &lt;= +Inf )</p>
</td></tr>
<tr><td><code>rSD</code></td>
<td>
<p>Ratio of Standard Deviations, rSD = sd(sim) / sd(obs)</p>
</td></tr>
<tr><td><code>NSE</code></td>
<td>
<p>Nash-Sutcliffe Efficiency ( -Inf &lt;= NSE &lt;= 1 )</p>
</td></tr>
<tr><td><code>mNSE</code></td>
<td>
<p>Modified Nash-Sutcliffe Efficiency</p>
</td></tr>
<tr><td><code>rNSE</code></td>
<td>
<p>Relative Nash-Sutcliffe Efficiency</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Index of Agreement ( 0 &lt;= d &lt;= 1 )</p>
</td></tr>
<tr><td><code>dr</code></td>
<td>
<p>Refined Index of Agreement ( -1 &lt;= dr &lt;= 1 )</p>
</td></tr>
<tr><td><code>md</code></td>
<td>
<p>Modified Index of Agreement ( 0 &lt;= md &lt;= 1 )</p>
</td></tr>
<tr><td><code>rd</code></td>
<td>
<p>Relative Index of Agreement ( 0 &lt;= rd &lt;= 1 )</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>Persistence Index ( 0 &lt;= PI &lt;= 1 ) </p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Pearson Correlation coefficient ( -1 &lt;= r &lt;= 1 )</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>Coefficient of Determination ( 0 &lt;= R2 &lt;= 1 )</p>
</td></tr>
<tr><td><code>bR2</code></td>
<td>
<p>R2 multiplied by the coefficient of the regression line between <code>sim</code> and <code>obs</code> <br /> ( 0 &lt;= bR2 &lt;= 1 )</p>
</td></tr>
<tr><td><code>KGE</code></td>
<td>
<p>Kling-Gupta efficiency between <code>sim</code> and <code>obs</code> <br /> ( -Inf &lt;= KGE &lt;= 1 )</p>
</td></tr>
<tr><td><code>KGElf</code></td>
<td>
<p>Kling-Gupta Efficiency for low values between <code>sim</code> and <code>obs</code> <br /> ( -Inf &lt;= KGElf &lt;= 1 )</p>
</td></tr>
<tr><td><code>KGEnp</code></td>
<td>
<p>Non-parametric version of the Kling-Gupta Efficiency between <code>sim</code> and <code>obs</code> <br /> ( -Inf &lt;= KGEnp &lt;= 1 )</p>
</td></tr>
<tr><td><code>sKGE</code></td>
<td>
<p>Split Kling-Gupta Efficiency between <code>sim</code> and <code>obs</code> <br /> ( -Inf &lt;= sKGE &lt;= 1 ). Only computed when both <code>sim</code> and <code>obs</code> are zoo objects</p>
</td></tr>
<tr><td><code>VE</code></td>
<td>
<p>Volumetric efficiency between <code>sim</code> and <code>obs</code> <br /> ( -Inf &lt;= VE &lt;= 1)</p>
</td></tr>
<tr><td><code>r.Spearman</code></td>
<td>
<p>Spearman Correlation coefficient ( -1 &lt;= r.Spearman &lt;= 1 ). Only computed when <code>do.spearman=TRUE</code></p>
</td></tr>
<tr><td><code>pbiasfdc</code></td>
<td>
<p>PBIAS in the slope of the midsegment of the Flow Duration Curve</p>
</td></tr>

</table>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension. <br />
</p>
<p>Missing values in <code>obs</code> and/or <code>sim</code> can be removed before the computations, depending on the value of <code>na.rm</code>. <br />
</p>
<p>Although <code>r</code> and <code>r2</code> have been widely used for model evaluation, these statistics are over-sensitive to outliers and insensitive to additive and proportional differences between model predictions and measured data (Legates and McCabe, 1999)
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233-241</cite> <br />
</p>
<p><cite>Krause P., Boyle D.P., and Base F., Comparison of different efficiency criteria for hydrological model assessment, Advances in Geosciences 5 (2005), pp. 89-97</cite> <br />
</p>
<p><cite>Moriasi, D.N., Arnold, J.G., Van Liew, M.W., Bingner, R.L., Harmel, R.D., Veith, T.L. 2007. Model evaluation guidelines for systematic quantification of accuracy in watershed simulations <br /> Transactions of the ASABE. 50(3):885-900</cite> <br />
</p>
<p><cite>Boyle, D. P., H. V. Gupta, and S. Sorooshian (2000), Toward Improved Calibration of Hydrologic Models: Combining the Strengths of Manual and Automatic Methods, Water Resour. Res., 36(12), 3663-3674</cite> <br />
</p>
<p><cite>Kitanidis, P. K., and R. L. Bras (1980), Real-Time Forecasting With a Conceptual Hydrologic Model 2. Applications and Results, Water Resour. Res., 16(6), 1034-1044</cite> <br />
</p>
<p><cite>Nash, J.E. and Sutcliffe, J.V. (1970). River flow forecasting through conceptual models. Part 1: a discussion of principles, J. Hydrol. 10, pp. 282-290</cite> <br />
</p>
<p><cite>Yapo P. O., Gupta H. V., Sorooshian S., 1996. Automatic calibration of conceptual rainfall-runoff models: sensitivity to calibration data. Journal of Hydrology. v181 i1-4. 23-48</cite> <br />
</p>
<p><cite>Yilmaz, K. K., H. V. Gupta, and T. Wagener  (2008), A process-based diagnostic approach to model evaluation: Application to the NWS distributed hydrologic model, Water Resour. Res., 44, W09417, doi:10.1029/2007WR006716</cite> <br />
</p>
<p><cite>Hoshin V. Gupta, Harald Kling, Koray K. Yilmaz, Guillermo F. Martinez. Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of Hydrology, Volume 377, Issues 1-2, 20 October 2009, Pages 80-91. DOI: 10.1016/j.jhydrol.2009.08.003. ISSN 0022-1694</cite> <br />
</p>
<p><cite>Criss, R. E. and Winston, W. E. (2008), Do Nash values have value? Discussion and alternate proposals. Hydrological Processes, 22: 2723-2725. doi: 10.1002/hyp.7072</cite>
</p>


<h3>See Also</h3>


<p><code><a href="#topic+ggof">ggof</a></code>, <code><a href="#topic+me">me</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, 
<code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+rsr">rsr</a></code>, <code><a href="#topic+rSD">rSD</a></code>, <code><a href="#topic+NSE">NSE</a></code>, <code><a href="#topic+mNSE">mNSE</a></code>, 
<code><a href="#topic+rNSE">rNSE</a></code>, <code><a href="#topic+wNSE">wNSE</a></code>, <code><a href="#topic+d">d</a></code>, <code><a href="#topic+dr">dr</a></code>, <code><a href="#topic+md">md</a></code>, <code><a href="#topic+rd">rd</a></code>, 
<code><a href="#topic+cp">cp</a></code>, <code><a href="#topic+rPearson">rPearson</a></code>, <code><a href="#topic+R2">R2</a></code>, <code><a href="#topic+br2">br2</a></code>, <code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+KGElf">KGElf</a></code>,
<code><a href="#topic+KGEnp">KGEnp</a></code>, <code><a href="#topic+sKGE">sKGE</a></code>, <code><a href="#topic+VE">VE</a></code>, <code><a href="#topic+rSpearman">rSpearman</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
gof(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
gof(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'gof' for the "best" (unattainable) case
gof(sim=sim, obs=obs)

##################
# Example 3: gof for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

gof(sim=sim, obs=obs)

##################
# Example 4: gof for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

gof(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
gof(sim=lsim, obs=lobs)

##################
# Example 5: gof for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

gof(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
gof(sim=lsim, obs=lobs)

##################
# Example 6: gof for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
gof(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
gof(sim=lsim, obs=lobs)

##################
# Example 7: gof for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
gof(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
gof(sim=lsim, obs=lobs)

##################
# Example 8: gof for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

gof(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
gof(sim=sim1, obs=obs1)

# Storing a matrix object with all the GoFs:
g &lt;-  gof(sim, obs)

# Getting only the RMSE
g[4,1]
g["RMSE",]

## Not run: 
# Writing all the GoFs into a TXT file
write.table(g, "GoFs.txt", col.names=FALSE, quote=FALSE)

# Getting the graphical representation of 'obs' and 'sim' along with the 
# numeric goodness of fit 
ggof(sim=sim, obs=obs)

## End(Not run)

</code></pre>

<hr>
<h2 id='hydroGOF-internal'>Internal hydroGOF objects</h2><span id='topic+.intersect'></span><span id='topic+preproc'></span>

<h3>Description</h3>

<p>Internal hydroGOF objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='hydroGOF-package'>
Goodness-of-fit (GoF) functions for numerical and graphical comparison of simulated and observed time series, mainly focused on hydrological modelling.
</h2><span id='topic+hydroGOF-package'></span><span id='topic+hydroGOF'></span>

<h3>Description</h3>

<p>S3 functions implementing both statistical and graphical goodness-of-fit measures between observed and simulated values, to be used during the calibration, validation, and application of hydrological models. <br />
</p>
<p>Missing values in observed and/or simulated values can be removed before computations. <br />
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hydroGOF</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.5-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL &gt;= 2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> Sun Jan 21 17:34:26 -03 2024 ; MZB </td>
</tr>
<tr>
 <td style="text-align: left;">
BuiltUnder: </td><td style="text-align: left;"> R version 4.3.2 (2023-10-31) ;x86_64-pc-linux-gnu (64-bit) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
 
<p>Quantitative statistics included in this package are: 
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+me">me</a></code>         Mean Error </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mae">mae</a></code>        Mean Absolute Error </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code><a href="#topic+mse">mse</a></code>        Mean Squared Error </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rmse">rmse</a></code>       Root Mean Square Error </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ubRMSE">ubRMSE</a></code>     Unbiased Root Mean Square Error </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nrmse">nrmse</a></code>      Normalized Root Mean Square Error </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pbias">pbias</a></code>      Percent Bias </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rsr">rsr</a></code>        Ratio of RMSE to the Standard Deviation of the Observations </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rSD">rSD</a></code>        Ratio of Standard Deviations </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+NSE">NSE</a></code>        Nash-Sutcliffe Efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mNSE">mNSE</a></code>       Modified Nash-Sutcliffe Efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rNSE">rNSE</a></code>       Relative Nash-Sutcliffe Efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+wNSE">wNSE</a></code>       Weighted Nash-Sutcliffe Efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+d">d</a></code>          Index of Agreement </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dr">dr</a></code>         Refined Index of Agreement </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+md">md</a></code>         Modified Index of Agreement  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rd">rd</a></code>         Relative Index of Agreement </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cp">cp</a></code>         Persistence Index </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rPearson">rPearson</a></code>   Pearson correlation coefficient  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+R2">R2</a></code>         Coefficient of determination </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+br2">br2</a></code>        R2 multiplied by the coefficient of the regression line between <code>sim</code> and <code>obs</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+KGE">KGE</a></code>        Kling-Gupta efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+KGElf">KGElf</a></code>      Kling-Gupta Efficiency for low values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+KGEnp">KGEnp</a></code>      Non-parametric version of the Kling-Gupta Efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sKGE">sKGE</a></code>       Split Kling-Gupta Efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+VE">VE</a></code>         Volumetric efficiency  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rSpearman">rSpearman</a></code>  Spearman's rank correlation coefficient  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>   PBIAS in the slope of the midsegment of the flow duration curve </td>
</tr>
<tr>
 <td style="text-align: left;">
----------------------------------------------------------------------------------------------------------</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>
<p>Maintainer: Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Box, G. E. (1966). Use and abuse of regression. Technometrics, 8(4), 625-629. doi:10.1080/00401706.1966.10490407</cite>. <br />
</p>
<p><cite>Bennett, N.D.; Croke, B.F.; Guariso, G.; Guillaume, J.H.; Hamilton, S.H.; Jakeman, A.J.; Marsili-Libelli, S.; Newham, L.T.; Norton, J.P.; Perrin, C.; Pierce, S.A. (2013). Characterising performance of environmental models. Environmental Modelling and Software, 40, 1-20. doi:10.1016/j.envsoft.2012.09.011</cite> <br />
</p>
<p><cite>Boyle, D. P., H. V. Gupta, and S. Sorooshian (2000), Toward Improved Calibration of Hydrologic Models: Combining the Strengths of Manual and Automatic Methods, Water Resources Research, 36(12), 3663-3674. doi:10.1029/2000WR900207</cite> <br />
</p>
<p><cite>Criss, R. E. and Winston, W. E. (2008), Do Nash values have value? Discussion and alternate proposals. Hydrological Processes, 22: 2723-2725. doi:10.1002/hyp.7072</cite>
</p>
<p><cite>Entekhabi, D., Reichle, R. H., Koster, R. D., Crow, W. T. (2010). Performance metrics for soil moisture retrievals and application requirements. Journal of Hydrometeorology, 11(3), 832-840. doi: 10.1175/2010JHM1223.1</cite> <br />
</p>
<p><cite>Fenicia, F., D. P. Solomatine, H. H. G. Savenije, and P. Matgen. (2007) Soft combination of local models in a multi-objective framework. Hydrological and Earth Systems Science, Vol. 4, pp. 91-123. doi:10.5194/hessd-4-91-2007</cite> <br />
</p>
<p><cite>Garcia, F.; Folton, N.; Oudin, L. (2017). Which objective function to calibrate rainfall-runoff models for low-flow index simulations?. Hydrological sciences journal, 62(7), 1149-1166. doi:10.1080/02626667.2017.1308511</cite> <br />
</p>
<p><cite>Gupta, Hoshin V., Harald Kling, Koray K. Yilmaz, Guillermo F. Martinez. Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. (2009). Journal of Hydrology, Volume 377, Issues 1-2, 20, Pages 80-91. doi:10.1016/j.jhydrol.2009.08.003</cite> <br />
</p>
<p><cite>Harmel, R.D.; Smith, P.K.; Migliaccio, K.W.; Chaubey, I.; Douglas-Mankin, K.R.; Benham, B.; Shukla, S.; Munoz-Carpena, R.; Robson, B.J., 2014. Evaluating, interpreting, and communicating performance of hydrologic/water quality models considering intended use: A review and recommendations. Environmental modelling and software, 57, 40-51. doi:10.1016/j.envsoft.2014.02.013</cite> <br />
</p>
<p><cite>Krstic, G., Krstic, N.S., Zambrano-Bigiarini, M. (2016). The br2-weighting Method for Estimating the Effects of Air Pollution on Population Health. Journal of Modern Applied Statistical Methods, 15(2), 42. doi:10.22237/jmasm/1478004000</cite> <br />
</p>
<p><cite>Kitanidis, P. K., and R. L. Bras (1980), Real-Time Forecasting With a Conceptual Hydrologic Model 2. Applications and Results, Water Resour. Res., 16(6), 1034-1044</cite> <br />
</p>
<p><cite>Kling, H., M. Fuchs, and M. Paulin (2012), Runoff conditions in the upper Danube basin under an ensemble of climate change scenarios. Journal of Hydrology, Volumes 424-425, 6 March 2012, Pages 264-277, doi:10.1016/j.jhydrol.2012.01.011</cite> <br />
</p>
<p><cite>Knoben, W. J.; Freer, J. E.; Woods, R. A. (2019). Inherent benchmark or not? Comparing Nash-Sutcliffe and Kling-Gupta efficiency scores. Hydrology and Earth System Sciences, 23(10), 4323-4331. doi:10.5194/hess-23-4323-2019</cite> <br />
</p>
<p><cite>Krause, P., Boyle, D. P., and Base, F.: Comparison of different efficiency criteria for hydrological model assessment, Adv. Geosci., 5, 89-97, 2005. doi:10.5194/adgeo-5-89-2005</cite> <br />
</p>
<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233-241. doi:10.1029/1998WR900018</cite> <br />
</p>
<p><cite>Mizukami, N.; Rakovec, O.; Newman, A. J.; Clark, M. P.; Wood, A. W.; Gupta, H. V.; Kumar, R. (2019). On the choice of calibration metrics for &quot;high-flow&quot; estimation using hydrologic models. doi:10.5194/hess-23-2601-2019</cite> <br />
</p>
<p><cite>Moriasi, D.N.; Arnold, J.G.; Van Liew, M.W.; Bingner, R.L.; Harmel, R.D.; Veith, T.L. (2007). Model evaluation guidelines for systematic quantification of accuracy in watershed simulations <br /> Transactions of the ASABE. 50(3):885-900</cite> <br />
</p>
<p><cite>Nash, J.E. and J.V. Sutcliffe, River flow forecasting through conceptual models. Part 1: a discussion of principles, J. Hydrol. 10 (1970), pp. 282-290. doi:10.1016/0022-1694(70)90255-6</cite> <br />
</p>
<p><cite>Pearson, K. (1920). Notes on the history of correlation. Biometrika, 13(1), 25-45. doi:10.2307/2331722</cite>. <br />
</p>
<p><cite>Pfannerstill, M.; Guse, B.; Fohrer, N. (2014). Smart low flow signature metrics for an improved overall performance evaluation of hydrological models. Journal of Hydrology, 510, 447-458. doi:10.1016/j.jhydrol.2013.12.044</cite> <br />
</p>
<p><cite>Pool, S., Vis, M. and Seibert, J. (2018). Evaluating model performance: towards a non-parametric variant of the Kling-Gupta efficiency. Hydrological Sciences Journal, 63(13-14), pp.1941-1953. doi:/10.1080/02626667.2018.1552002</cite> <br />
</p>
<p><cite>Pushpalatha, R., Perrin, C., Le Moine, N. and Andreassian, V. (2012). A review of efficiency criteria suitable for evaluating low-flow simulations. Journal of Hydrology, 420, 171-182. doi:10.1016/j.jhydrol.2011.11.055</cite> <br />
</p>
<p><cite>Santos, L.; Thirel, G.; Perrin, C. (2018). Pitfalls in using log-transformed flows within the KGElf criterion. doi:10.5194/hess-22-4583-2018</cite> <br />
</p>
<p><cite>Spearman, C. (1961). The Proof and Measurement of Association Between Two Things. In J. J. Jenkins and D. G. Paterson (Eds.), Studies in individual differences: The search for intelligence (pp. 45-58). Appleton-Century-Crofts. doi:10.1037/11491-005</cite> <br />
</p>
<p><cite>Willmott, C.J., Robeson, S.M. and Matsuura, K. (2012). A refined index of model performance. International Journal of climatology, 32(13), pp.2088-2094. doi:10.1002/joc.2419</cite> <br />
</p>
<p><cite>Willmott, C.J., Robeson, S.M., Matsuura, K. and Ficklin, D.L. (2015). Assessment of three dimensionless measures of model performance. Environmental Modelling and Software, 73, pp.167-174. doi:10.1016/j.envsoft.2015.08.012</cite> <br />
</p>
<p><cite>Willmott, C. J. (1981). On the validation of models. Physical Geography, 2, 184-194</cite> <br />
</p>
<p><cite>Willmott, C. J. (1984). On the evaluation of model performance in physical geography. Spatial Statistics and Models, G. L. Gaile and C. J. Willmott, eds., 443-460</cite> <br />
</p>
<p><cite>Willmott, C. J., S. G. Ackleson, R. E. Davis, J. J. Feddema, K. M. Klink, D. R. Legates, J. O'Donnell, and C. M. Rowe (1985), Statistics for the Evaluation and Comparison of Models, J. Geophys. Res., 90(C5), 8995-9005</cite> <br />
</p>
<p><cite>Yapo, P. O.; Gupta, H. V.; Sorooshian S. (1996). Automatic calibration of conceptual rainfall-runoff models: sensitivity to calibration data. Journal of Hydrology. v181 i1-4. 23-48. doi:10.1016/0022-1694(95)02918-4</cite> <br />
</p>
<p><cite>Yilmaz, K. K., H. V. Gupta, and T. Wagener (2008), A process-based diagnostic approach to model evaluation: Application to the NWS distributed hydrologic model, Water Resources Research, 44, W09417, doi:10.1029/2007WR006716</cite> <br />
</p>


<h3>See Also</h3>

<p><a href="https://CRAN.R-project.org/package=hydroPSO">https://CRAN.R-project.org/package=hydroPSO</a> <br />
<a href="https://CRAN.R-project.org/package=hydroTSM">https://CRAN.R-project.org/package=hydroTSM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- 1:100
sim &lt;- obs

# Numerical goodness of fit
gof(sim,obs)

# Reverting the order of simulated values
sim &lt;- 100:1
gof(sim,obs)

## Not run: 
ggof(sim, obs)

## End(Not run)

##################
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
require(zoo)
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to observations
sim &lt;- obs 

# Getting the numeric goodness-of-fit measures for the "best" (unattainable) case
gof(sim=sim, obs=obs)

# Randomly changing the first 2000 elements of 'sim', by using a normal 
# distribution  with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Getting the new numeric goodness of fit
gof(sim=sim, obs=obs)

# Graphical representation of 'obs' vs 'sim', along with the numeric 
# goodness-of-fit measures
## Not run: 
ggof(sim=sim, obs=obs)

## End(Not run)
</code></pre>

<hr>
<h2 id='KGE'>
Kling-Gupta Efficiency
</h2><span id='topic+KGE'></span><span id='topic+KGE.default'></span><span id='topic+KGE.matrix'></span><span id='topic+KGE.data.frame'></span><span id='topic+KGE.zoo'></span>

<h3>Description</h3>

<p>Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>
<p>This goodness-of-fit measure was developed by Gupta et al. (2009) to provide a diagnostically interesting decomposition of the Nash-Sutcliffe efficiency (and hence MSE), which facilitates the analysis of the relative importance of its different components (correlation, bias and variability) in the context of hydrological modelling. 
Kling et al. (2012), proposed a revised version of this index, to ensure that the bias and variability ratios are not cross-correlated.
</p>
<p>Kling-Gupta efficiencies range from -Inf to 1. Essentially, the closer to 1, the more similar <code>sim</code> and <code>obs</code> are. 
</p>
<p>Knoben et al. (2019) showed that KGE values greater than -0.41 indicate that a model improves upon the mean flow benchmark, even if the model's KGE value is negative.
</p>
<p>In the computation of this index, there are three main components involved: 
</p>
<p>1) <kbd>r</kbd>    : the Pearson product-moment correlation coefficient. Ideal value is r=1.
</p>
<p>2) <kbd>Beta</kbd> : the ratio between the mean of the simulated values and the mean of the observed ones. Ideal value is Beta=1.
</p>
<p>3) <kbd>vr</kbd>   : variability ratio, which could be computed using the standard deviation (<kbd>Alpha</kbd>) or the coefficient of variation (<kbd>Gamma</kbd>) of <code>sim</code> and <code>obs</code>, depending on the value of <code>method</code>:
</p>
<p>3.1) <kbd>Alpha</kbd>: the ratio between the standard deviation of the simulated values and the standard deviation of the observed ones. Its ideal value is <kbd>Alpha=1</kbd>.
</p>
<p>3.2) <kbd>Gamma</kbd>: the ratio between the coefficient of variation (<kbd>CV</kbd>) of the simulated values to the coefficient of variation of the observed ones. Its ideal value is <kbd>Gamma=1</kbd>.
</p>
<p>For a full discussion pf the Kling-Gupta index, and its advantages over the Nash-Sutcliffe efficiency (<code><a href="#topic+NSE">NSE</a></code>) see Gupta et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KGE(sim, obs, ...)

## Default S3 method:
KGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012", "2021"), 
             out.type=c("single", "full"), fun=NULL, ...,
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
KGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012", "2021"), 
             out.type=c("single", "full"), fun=NULL, ...,
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
KGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012", "2021"), 
             out.type=c("single", "full"), fun=NULL, ...,
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
             
## S3 method for class 'zoo'
KGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012", "2021"), 
             out.type=c("single", "full"), fun=NULL, ...,
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KGE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="KGE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="KGE_+3A_s">s</code></td>
<td>

<p>numeric of length 3, representing the scaling factors to be used for re-scaling the criteria space before computing the Euclidean distance from the ideal point c(1,1,1), i.e., <code>s</code> elements are used for adjusting the emphasis on different components.
The first elements is used for rescaling the Pearson product-moment correlation coefficient (<code>r</code>), the second element is used for rescaling <code>Alpha</code> and the third element is used for re-scaling <code>Beta</code>
</p>
</td></tr>
<tr><td><code id="KGE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="KGE_+3A_method">method</code></td>
<td>

<p>character, indicating the formula used to compute the variability ratio in the Kling-Gupta efficiency. Valid values are:
</p>
<p>-) <kbd>2009</kbd>: the variability is defined as &lsquo;Alpha&rsquo;, the ratio of the standard deviation of <code>sim</code> values to the standard deviation of <code>obs</code>. This is the default option. See Gupta et al. (2009).
</p>
<p>-) <kbd>2012</kbd>: the variability is defined as &lsquo;Gamma&rsquo;, the ratio of the coefficient of variation of <code>sim</code> values to the coefficient of variation of <code>obs</code>. See Kling et al. (2012). 
</p>
<p>-) <kbd>2021</kbd>: the bias is defined as &lsquo;Beta&rsquo;, the ratio of <code>mean(sim)</code> minus <code>mean(obs)</code> to the standard deviation of <code>obs</code>.  The variability is defined as &lsquo;Alpha&rsquo;, the ratio of the standard deviation of <code>sim</code> values to the standard deviation of <code>obs</code>. See Tang et al. (2021). 
</p>
</td></tr>
<tr><td><code id="KGE_+3A_out.type">out.type</code></td>
<td>

<p>character, indicating the whether the output of the function has to include each one of the three terms used in the computation of the Kling-Gupta efficiency or not. Valid values are:
</p>
<p>-) <kbd>single</kbd>: the output is a numeric with the Kling-Gupta efficiency only.
</p>
<p>-) <kbd>full</kbd>: the output is a list of two elements: the first one with the Kling-Gupta efficiency, and the second is a numeric with 3 elements: the Pearson product-moment correlation coefficient (&lsquo;r&rsquo;), the ratio between the mean of the simulated values to the mean of observations (&lsquo;Beta&rsquo;), and the variability measure (&lsquo;Gamma&rsquo; or &lsquo;Alpha&rsquo;, depending on the value of <code>method</code>).
</p>
</td></tr>
<tr><td><code id="KGE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Kling-Gupta efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="KGE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="KGE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="KGE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">KGE = 1 - ED</code>
</p>

<p style="text-align: center;"><code class="reqn"> ED =  \sqrt{ (s[1]*(r-1))^2 +(s[2]*(vr-1))^2 + (s[3]*(\beta-1))^2 } </code>
</p>

<p style="text-align: center;"><code class="reqn">r=Pearson product-moment correlation coefficient</code>
</p>

<p style="text-align: center;"><code class="reqn">vr=  \left\{
  \begin{array}{cc}
    \alpha &amp; , \: method=2009 \\
    \gamma &amp; , \: method=2012
  \end{array}
\right.</code>
</p>

<p style="text-align: center;"><code class="reqn">\beta=\mu_s/\mu_o</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha=\sigma_s/\sigma_o</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma=\frac{CV_s}{CV_o} = \frac{\sigma_s/\mu_s}{\sigma_o/\mu_o}</code>
</p>



<h3>Value</h3>

<p>If <code>out.type=single</code>: numeric with the Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>. If <code>sim</code> and <code>obs</code> are matrices, the output value is a vector, with the Kling-Gupta efficiency between each column of <code>sim</code> and <code>obs</code>
</p>
<p>If <code>out.type=full</code>: a list of two elements:
</p>
<table>
<tr><td><code>KGE.value</code></td>
<td>

<p>numeric with the Kling-Gupta efficiency. If <code>sim</code> and <code>obs</code> are matrices, the output value is a vector, with the Kling-Gupta efficiency between each column of <code>sim</code> and <code>obs</code>
</p>
</td></tr>
<tr><td><code>KGE.elements</code></td>
<td>

<p>numeric with 3 elements: the Pearson product-moment correlation coefficient (&lsquo;r&rsquo;), the ratio between the mean of the simulated values to the mean of observations (&lsquo;Beta&rsquo;), and the variability measure (&lsquo;Gamma&rsquo; or &lsquo;Alpha&rsquo;, depending on the value of <code>method</code>). If <code>sim</code> and <code>obs</code> are matrices, the output value is a matrix, with the previous three elements computed for each column of <code>sim</code> and <code>obs</code><br />  
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano-Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Gupta, H. V.; Kling, H.; Yilmaz, K. K.; Martinez, G. F. (2009). Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of hydrology, 377(1-2), 80-91. doi:10.1016/j.jhydrol.2009.08.003. ISSN 0022-1694</cite> <br />
</p>
<p><cite>Kling, H.; Fuchs, M.; Paulin, M. (2012). Runoff conditions in the upper Danube basin under an ensemble of climate change scenarios. Journal of Hydrology, 424, 264-277, doi:10.1016/j.jhydrol.2012.01.011</cite> <br />
</p>
<p><cite>Santos, L.; Thirel, G.; Perrin, C. (2018). Pitfalls in using log-transformed flows within the KGE criterion. doi:10.5194/hess-22-4583-2018</cite> <br />
</p>
<p><cite>Knoben, W. J.; Freer, J. E.; Woods, R. A. (2019). Inherent benchmark or not? Comparing Nash-Sutcliffe and Kling-Gupta efficiency scores. Hydrology and Earth System Sciences, 23(10), 4323-4331. doi:10.5194/hess-23-4323-2019</cite> <br />
</p>
<p><cite>Mizukami, N.; Rakovec, O.; Newman, A. J.; Clark, M. P.; Wood, A. W.; Gupta, H. V.; Kumar, R. (2019). On the choice of calibration metrics for &quot;high-flow&quot; estimation using hydrologic models. doi:10.5194/hess-23-2601-2019</cite> <br />
</p>
<p><cite>Tang, G., Clark, M. P., &amp; Papalexiou, S. M. (2021). SC-earth: a station-based serially complete earth dataset from 1950 to 2019. Journal of Climate, 34(16), 6493-6511. doi:10.1175/JCLI-D-21-0067.1</cite> <br />
</p>
<p><cite>Cinkus, G., Mazzilli, N., Jourde, H., Wunsch, A., Liesch, T., Ravbar, N., Chen, Z., and Goldscheider, N. (2023). When best is the enemy of good - critical evaluation of performance criteria in hydrological models. Hydrology and Earth System Sciences 27, 2397-2411, doi:10.5194/hess-27-2397-2023</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KGElf">KGElf</a></code>, <code><a href="#topic+sKGE">sKGE</a></code>, <code><a href="#topic+KGEnp">KGEnp</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
KGE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
KGE(sim, obs)

##################
# Example2: Looking at the difference between 'method=2009' and 'method=2012'
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Simulated daily time series, initially equal to twice the observed values
sim &lt;- 2*obs 

# KGE 2009
KGE(sim=sim, obs=obs, method="2009", out.type="full")

# KGE 2012
KGE(sim=sim, obs=obs, method="2012", out.type="full")

##################
# Example3: KGE for simulated values equal to observations plus random noise 
#           on the first half of the observed values
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim &lt;- obs 
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)

# Computing the new 'KGE'
KGE(sim=sim, obs=obs)

# Randomly changing the first 2000 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Computing the new 'KGE'
KGE(sim=sim, obs=obs)

##################
# Example 4: KGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

KGE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
KGE(sim=lsim, obs=lobs)

##################
# Example 5: KGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

KGE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGE(sim=lsim, obs=lobs)

##################
# Example 6: KGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
KGE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGE(sim=lsim, obs=lobs)

##################
# Example 7: KGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
KGE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGE(sim=lsim, obs=lobs)

##################
# Example 8: KGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

KGE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
KGE(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='KGElf'>
Kling-Gupta Efficiency for low values
</h2><span id='topic+KGElf'></span><span id='topic+KGElf.default'></span><span id='topic+KGElf.matrix'></span><span id='topic+KGElf.data.frame'></span><span id='topic+KGElf.zoo'></span>

<h3>Description</h3>

<p>Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>, with focus on low (streamflow) values and treatment of missing values. <br />
</p>
<p>This goodness-of-fit measure was developed by Garcia et al. (2017), as a modification to the original Kling-Gupta efficiency (KGE) proposed by Gupta et al. (2009). See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KGElf(sim, obs, ...)

## Default S3 method:
KGElf(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"), 
               epsilon.type=c("Pushpalatha2012", "otherFactor", "otherValue", "none"), 
               epsilon.value=NA, ...)

## S3 method for class 'data.frame'
KGElf(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"), 
               epsilon.type=c("Pushpalatha2012", "otherFactor", "otherValue", "none"), 
               epsilon.value=NA, ...)

## S3 method for class 'matrix'
KGElf(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"), 
               epsilon.type=c("Pushpalatha2012", "otherFactor", "otherValue", "none"), 
               epsilon.value=NA, ...)
             
## S3 method for class 'zoo'
KGElf(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"), 
               epsilon.type=c("Pushpalatha2012", "otherFactor", "otherValue", "none"), 
               epsilon.value=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KGElf_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_s">s</code></td>
<td>

<p>numeric of length 3, representing the scaling factors to be used for re-scaling the criteria space before computing the Euclidean distance from the ideal point c(1,1,1), i.e., <code>s</code> elements are used for adjusting the emphasis on different components.
The first elements is used for rescaling the Pearson product-moment correlation coefficient (<code>r</code>), the second element is used for rescaling <code>Alpha</code> and the third element is used for re-scaling <code>Beta</code>
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_method">method</code></td>
<td>

<p>character, indicating the formula used to compute the variability ratio in the Kling-Gupta efficiency. Valid values are:
</p>
<p>-) <kbd>2009</kbd>: the variability is defined as &lsquo;Alpha&rsquo;, the ratio of the standard deviation of <code>sim</code> values to the standard deviation of <code>obs</code>. This is the default option. See Gupta et al. (2009).
</p>
<p>-) <kbd>2012</kbd>: the variability is defined as &lsquo;Gamma&rsquo;, the ratio of the coefficient of variation of <code>sim</code> values to the coefficient of variation of <code>obs</code>. See Kling et al. (2012). 
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). This is the default option.
</p>
<p>2) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
<p>3) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value.
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="KGElf_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Garcia et al. (2017) tested different objective functions and found that the mean value of the KGE applied to the streamflows (i.e., KGE(Q)) and the KGE applied to the inverse of the streamflows (i.e., KGE(1/Q) is able to provide a an aceptable representation of low-flow indices important for water management. They also found that KGE applied to a transformation of streamflow values (e.g., log)  is inadequate to capture low-flow indices important for water management. <br />
</p>
<p>The robustness of their findings depends more on the climate variability rather than the objective function, and they are insensitive to the hydrological model used in the evaluation.
</p>
<p style="text-align: center;"><code class="reqn">KGE_{lf} =  \frac{KGE(Q) + KGE(1/Q)}{2} </code>
</p>

<p>Traditional Kling-Gupta efficiencies (Gupta et al., 2009; Kling et al., 2012) range from -Inf to 1 and, therefore, KGElf should also range from -Inf to 1. Essentially, the closer to 1, the more similar <code>sim</code> and <code>obs</code> are. <br />
</p>
<p>Knoben et al. (2019) showed that traditional Kling-Gupta (Gupta et al., 2009; Kling et al., 2012) values greater than -0.41 indicate that a model improves upon the mean flow benchmark, even if the model's KGE value is negative.
</p>


<h3>Value</h3>

<p>numeric with the Kling-Gupta efficiency for low flows between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrices, the output value is a vector, with the Kling-Gupta efficiency between each column of <code>sim</code> and <code>obs</code>
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano-Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Garcia, F.; Folton, N.; Oudin, L. (2017). Which objective function to calibrate rainfall-runoff models for low-flow index simulations?. Hydrological sciences journal, 62(7), 1149-1166. doi:10.1080/02626667.2017.1308511</cite> <br />
</p>
<p><cite>Pushpalatha, R., Perrin, C., Le Moine, N. and Andreassian, V. (2012). A review of efficiency criteria suitable for evaluating low-flow simulations. Journal of Hydrology, 420, 171-182. doi:10.1016/j.jhydrol.2011.11.055</cite> <br />
</p>
<p><cite>Pfannerstill, M.; Guse, B.; Fohrer, N. (2014). Smart low flow signature metrics for an improved overall performance evaluation of hydrological models. Journal of Hydrology, 510, 447-458. doi:10.1016/j.jhydrol.2013.12.044</cite> <br />
</p>
<p><cite>Gupta, H. V.; Kling, H.; Yilmaz, K. K.; Martinez, G. F. (2009). Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of hydrology, 377(1-2), 80-91. doi:10.1016/j.jhydrol.2009.08.003. ISSN 0022-1694</cite> <br />
</p>
<p><cite>Kling, H.; Fuchs, M.; Paulin, M. (2012). Runoff conditions in the upper Danube basin under an ensemble of climate change scenarios. Journal of Hydrology, 424, 264-277, doi:10.1016/j.jhydrol.2012.01.011</cite> <br />
</p>
<p><cite>Santos, L.; Thirel, G.; Perrin, C. (2018). Pitfalls in using log-transformed flows within the KGE criterion. doi:10.5194/hess-22-4583-2018</cite> <br />
</p>
<p><cite>Knoben, W. J.; Freer, J. E.; Woods, R. A. (2019). Inherent benchmark or not? Comparing Nash-Sutcliffe and Kling-Gupta efficiency scores. Hydrology and Earth System Sciences, 23(10), 4323-4331. doi:10.5194/hess-23-4323-2019</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+KGEnp">KGEnp</a></code>, <code><a href="#topic+sKGE">sKGE</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
KGElf(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
KGElf(sim, obs)

##################
# Example2: Looking at the difference between 'method=2009' and 'method=2012'
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Simulated daily time series, initially equal to twice the observed values
sim &lt;- 2*obs 

# KGE 2009
KGE(sim=sim, obs=obs, method="2009", out.type="full")

# KGE 2012
KGE(sim=sim, obs=obs, method="2012", out.type="full")

# KGElf (Garcia et al., 2017):
KGElf(sim=sim, obs=obs, method="2012")

##################
# Example3: KGElf for simulated values equal to observations plus random noise 
#           on the first half of the observed values. 
#           This random noise has more relative importance for ow flows than 
#           for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim &lt;- obs 
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

# Computing 'KGElf'
KGElf(sim=sim, obs=obs)

##################
# Example 4: KGElf for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

KGElf(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
KGElf(sim=lsim, obs=lobs)

##################
# Example 5: KGElf for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

KGElf(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGElf(sim=lsim, obs=lobs)

##################
# Example 6: KGElf for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
KGElf(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGElf(sim=lsim, obs=lobs)

##################
# Example 7: KGElf for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
KGElf(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGElf(sim=lsim, obs=lobs)

##################
# Example 8: KGElf for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

KGElf(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
KGElf(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='KGEnp'>
Non-parametric version of the Kling-Gupta Efficiency
</h2><span id='topic+KGEnp'></span><span id='topic+KGEnp.default'></span><span id='topic+KGEnp.matrix'></span><span id='topic+KGEnp.data.frame'></span><span id='topic+KGEnp.zoo'></span>

<h3>Description</h3>

<p>Non-parametric Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
</p>
<p>This goodness-of-fit measure was developed by Pool et al. (2018), as a non-parametric alternative to the original Kling-Gupta efficiency (KGE) proposed by Gupta et al. (2009). See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KGEnp(sim, obs, ...)

## Default S3 method:
KGEnp(sim, obs, na.rm=TRUE, out.type=c("single", "full"), fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'data.frame'
KGEnp(sim, obs, na.rm=TRUE, out.type=c("single", "full"), fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'matrix'
KGEnp(sim, obs, na.rm=TRUE, out.type=c("single", "full"), fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)
             
## S3 method for class 'zoo'
KGEnp(sim, obs, na.rm=TRUE, out.type=c("single", "full"), fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KGEnp_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_out.type">out.type</code></td>
<td>

<p>character, indicating the whether the output of the function has to include each one of the three terms used in the computation of the Kling-Gupta efficiency or not. Valid values are:
</p>
<p>-) <kbd>single</kbd>: the output is a numeric with the Kling-Gupta efficiency only.
</p>
<p>-) <kbd>full</kbd>: the output is a list of two elements: the first one with the Kling-Gupta efficiency, and the second is a numeric with 3 elements: the Spearman rank correlation coefficient (&lsquo;rSpearman&rsquo;), the ratio between the mean of the simulated values to the mean of observations (&lsquo;Beta&rsquo;), and the variability measure (&lsquo;Alpha&rsquo;).
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="KGEnp_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This non-paramettric verison of the Kling-Gupta efficiency keeps the bias term Alpha (mean(sim) / mean(obs)), but for correlation uses the Spearman rank coefficient instead of the Pearson product-moment coefficient; and for variability it uses the normalized flow-duration curve instead of the standard deviation (or coefficient of variation).
</p>
<p>The proposed non-parametric based multi-objective function can be seen as a useful alternative to existing performance measures when aiming at acceptable simulations of multiple hydrograph aspects (Pool et al., 2018).
</p>
<p style="text-align: center;"><code class="reqn">KGE_{np} = 1 - ED</code>
</p>

<p style="text-align: center;"><code class="reqn"> ED =  \sqrt{ ((\rho-1)^2 + (\alpha-1)^2 + (\beta-1)^2 } </code>
</p>

<p style="text-align: center;"><code class="reqn">\rho = \textrm{Spearman rank correlation coefficient}</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha = 1 - 0.5*sum( sim(I(k)) / (n*\mu_s) - obs(J(k)) / (n*\mu_o) )</code>
</p>

<p style="text-align: center;"><code class="reqn">\beta = \mu_s/\mu_o</code>
</p>

<p>Traditional Kling-Gupta efficiencies (Gupta et al., 2009; Kling et al., 2012) range from -Inf to 1, and therefore KGEnp should do so. Essentially, the closer to 1, the more similar <code>sim</code> and <code>obs</code> are. <br />
</p>
<p>Knoben et al. (2019) showed that traditional Kling-Gupta (Gupta et al., 2009; Kling et al., 2012) values greater than -0.41 indicate that a model improves upon the mean flow benchmark, even if the model's KGE value is negative.
</p>


<h3>Value</h3>

<p>numeric with the non-parametric Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>. <br />
If <code>sim</code> and <code>obs</code> are matrices, the output value is a vector, with the non-parametric Kling-Gupta efficiency between each column of <code>sim</code> and <code>obs</code>
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano-Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Pool, S., Vis, M. and Seibert, J. (2018). Evaluating model performance: towards a non-parametric variant of the Kling-Gupta efficiency. Hydrological Sciences Journal, 63(13-14), pp.1941-1953. doi:/10.1080/02626667.2018.1552002.</cite> <br />
</p>
<p><cite>Garcia, F.; Folton, N.; Oudin, L. (2017). Which objective function to calibrate rainfall-runoff models for low-flow index simulations?. Hydrological sciences journal, 62(7), 1149-1166. doi:10.1080/02626667.2017.1308511</cite> <br />
</p>
<p><cite>Gupta, H. V.; Kling, H.; Yilmaz, K. K.; Martinez, G. F. (2009). Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of hydrology, 377(1-2), 80-91. doi:10.1016/j.jhydrol.2009.08.003. ISSN 0022-1694</cite> <br />
</p>
<p><cite>Kling, H.; Fuchs, M.; Paulin, M. (2012). Runoff conditions in the upper Danube basin under an ensemble of climate change scenarios. Journal of Hydrology, 424, 264-277, doi:10.1016/j.jhydrol.2012.01.011</cite> <br />
</p>
<p><cite>Santos, L.; Thirel, G.; Perrin, C. (2018). Pitfalls in using log-transformed flows within the KGE criterion. doi:10.5194/hess-22-4583-2018</cite> <br />
</p>
<p><cite>Knoben, W. J.; Freer, J. E.; Woods, R. A. (2019). Inherent benchmark or not? Comparing Nash-Sutcliffe and Kling-Gupta efficiency scores. Hydrology and Earth System Sciences, 23(10), 4323-4331. doi:10.5194/hess-23-4323-2019</cite> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+KGElf">KGElf</a></code>, <code><a href="#topic+sKGE">sKGE</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
KGEnp(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
KGEnp(sim, obs)

##################
# Example2: Looking at the difference between 'method=2009' and 'method=2012'
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Simulated daily time series, initially equal to twice the observed values
sim &lt;- 2*obs 

# KGE 2009
KGE(sim=sim, obs=obs, method="2009", out.type="full")

# KGE 2012
KGE(sim=sim, obs=obs, method="2012", out.type="full")

# KGEnp (Pool et al., 2018):
KGEnp(sim=sim, obs=obs)

##################
# Example3: KGEnp for simulated values equal to observations plus random noise 
#           on the first half of the observed values
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim &lt;- obs 
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)

# Computing the new 'KGEnp'
KGEnp(sim=sim, obs=obs)

# Randomly changing the first 2000 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Computing the new 'KGEnp'
KGEnp(sim=sim, obs=obs)

##################
# Example 4: KGEnp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

KGEnp(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
KGEnp(sim=lsim, obs=lobs)

##################
# Example 5: KGEnp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

KGEnp(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGEnp(sim=lsim, obs=lobs)

##################
# Example 6: KGEnp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
KGEnp(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGEnp(sim=lsim, obs=lobs)

##################
# Example 7: KGEnp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
KGEnp(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
KGEnp(sim=lsim, obs=lobs)

##################
# Example 8: KGEnp for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

KGEnp(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
KGEnp(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='mae'>
Mean Absolute Error
</h2><span id='topic+mae'></span><span id='topic+mae.default'></span><span id='topic+mae.matrix'></span><span id='topic+mae.data.frame'></span><span id='topic+mae.zoo'></span>

<h3>Description</h3>

<p>Mean absolute error between <code>sim</code> and <code>obs</code>, in the same units of them, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mae(sim, obs, ...)

## Default S3 method:
mae(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
mae(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
mae(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
mae(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mae_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="mae_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="mae_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="mae_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="mae_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="mae_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="mae_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> mae = \frac{1}{N} \sum_{i=1}^N { \left|S_i - O_i) \right| } </code>
</p>
 


<h3>Value</h3>

<p>Mean absolute error between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the mean absolute error between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> have to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Mean_absolute_error">https://en.wikipedia.org/wiki/Mean_absolute_error</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
mae(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
mae(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'mae' for the "best" (unattainable) case
mae(sim=sim, obs=obs)

##################
# Example 3: mae for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

mae(sim=sim, obs=obs)

##################
# Example 4: mae for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

mae(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
mae(sim=lsim, obs=lobs)

##################
# Example 5: mae for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

mae(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mae(sim=lsim, obs=lobs)

##################
# Example 6: mae for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
mae(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mae(sim=lsim, obs=lobs)

##################
# Example 7: mae for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
mae(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mae(sim=lsim, obs=lobs)

##################
# Example 8: mae for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

mae(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
mae(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='md'>
Modified index of agreement
</h2><span id='topic+md'></span><span id='topic+md.default'></span><span id='topic+md.matrix'></span><span id='topic+md.data.frame'></span><span id='topic+md.zoo'></span>

<h3>Description</h3>

<p>This function computes the modified Index of Agreement between <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
If 'x' is a matrix or a data frame, a vector of the modified index of agreement among the columns is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md(sim, obs, ...)

## Default S3 method:
md(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
md(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
md(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
md(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="md_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="md_+3A_j">j</code></td>
<td>

<p>numeric, with the exponent to be used in the computation of the modified index of agreement. The default value is j=1.
</p>
</td></tr>
<tr><td><code id="md_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="md_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the modified index of agreement.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="md_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="md_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="md_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>numeric value to be added to both <code>sim</code> and <code>obs</code> when <code>epsilon.type="otherValue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">md = 1 - \frac{ \sum_{i=1}^N {\left| O_i - S_i \right| ^j} } { \sum_{i=1}^N { \left| S_i -  \bar{O} \right| + \left| O_i -  \bar{O}  \right|^j } } </code>
</p>
 
<p>The Index of Agreement (d) developed by Willmott (1981) as a standardized measure of the degree of model prediction error and varies between 0 and 1. <br />
A value of 1 indicates a perfect match, and 0 indicates no agreement at all (Willmott, 1981).
</p>
<p>The index of agreement can detect additive and proportional differences in the observed and simulated means and variances; however, it is overly sensitive to extreme values due to the squared differences (Legates and McCabe, 1999).
</p>


<h3>Value</h3>

<p>Modified index of agreement between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the modified index of agreement between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Krause, P., Boyle, D. P., and Base, F.: Comparison of different efficiency criteria for hydrological model assessment, Adv. Geosci., 5, 89-97, 2005</cite> <br />
</p>
<p><cite>Willmott, C. J. 1981. On the validation of models. Physical Geography, 2, 184&ndash;194</cite> <br />
</p>
<p><cite>Willmott, C. J. (1984). On the evaluation of model performance in physical geography. Spatial Statistics and Models, G. L. Gaile and C. J. Willmott, eds., 443-460</cite> <br />
</p>
<p><cite>Willmott, C. J., S. G. Ackleson, R. E. Davis, J. J. Feddema, K. M. Klink, D. R. Legates, J. O'Donnell, and C. M. Rowe (1985), Statistics for the Evaluation and Comparison of Models, J. Geophys. Res., 90(C5), 8995-9005</cite> <br />
</p>
<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233&ndash;241</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+d">d</a></code>, <code><a href="#topic+dr">dr</a></code>, <code><a href="#topic+rd">rd</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- 1:10
sim &lt;- 1:10
md(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
md(sim, obs)

##################
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the modified index of agreement for the "best" (unattainable) case
md(sim=sim, obs=obs)

# Randomly changing the first 2000 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Computing the new 'd1'
md(sim=sim, obs=obs)
</code></pre>

<hr>
<h2 id='me'>
Mean Error
</h2><span id='topic+me'></span><span id='topic+me.default'></span><span id='topic+me.matrix'></span><span id='topic+me.data.frame'></span><span id='topic+me.zoo'></span>

<h3>Description</h3>

<p>Mean error between <code>sim</code> and <code>obs</code>, in the same units of them, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me(sim, obs, ...)

## Default S3 method:
me(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
me(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
me(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
me(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="me_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="me_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="me_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="me_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="me_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="me_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="me_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> me = \frac{1}{N} \sum_{i=1}^N { \left(S_i - O_i) \right) } </code>
</p>
 


<h3>Value</h3>

<p>Mean error between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the mean error between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Hill, T., Lewicki, P., &amp; Lewicki, P. (2006). Statistics: methods and applications: a comprehensive reference for science, industry, and data mining. StatSoft, Inc.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
me(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
me(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'me' for the "best" (unattainable) case
me(sim=sim, obs=obs)

##################
# Example 3: me for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

me(sim=sim, obs=obs)

##################
# Example 4: me for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

me(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
me(sim=lsim, obs=lobs)

##################
# Example 5: me for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

me(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
me(sim=lsim, obs=lobs)

##################
# Example 6: me for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
me(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
me(sim=lsim, obs=lobs)

##################
# Example 7: me for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
me(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
me(sim=lsim, obs=lobs)

##################
# Example 8: me for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

me(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
me(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='mNSE'>
Modified Nash-Sutcliffe efficiency
</h2><span id='topic+mNSeff'></span><span id='topic+mNSE'></span><span id='topic+mNSE.default'></span><span id='topic+mNSE.matrix'></span><span id='topic+mNSE.data.frame'></span><span id='topic+mNSE.zoo'></span>

<h3>Description</h3>

<p>Modified Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mNSE(sim, obs, ...)

## Default S3 method:
mNSE(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'data.frame'
mNSE(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'matrix'
mNSE(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'zoo'
mNSE(sim, obs, j=1, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mNSE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_j">j</code></td>
<td>

<p>numeric, with the exponent to be used in the computation of the modified Nash-Sutcliffe efficiency. The default value is <code>j=1</code>.
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>FUN</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="mNSE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> mNSE = 1 -\frac { \sum_{i=1}^N { \left| S_i - O_i \right|^j } } { \sum_{i=1}^N { \left| O_i - \bar{O} \right|^j } }  </code>
</p>

<p>When <code>j=1</code>, the modified NSeff is not inflated by the squared values of the differences, because the squares are replaced by absolute values.
</p>


<h3>Value</h3>

<p>Modified Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the modified Nash-Sutcliffe efficiency between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Krause, P., Boyle, D. P., and Base, F.: Comparison of different efficiency criteria for hydrological model assessment, Adv. Geosci., 5, 89-97, 2005</cite> <br />
</p>
<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233-241</cite> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NSE">NSE</a></code>, <code><a href="#topic+rNSE">rNSE</a></code>, <code><a href="#topic+wNSE">wNSE</a></code>, <code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
mNSE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
mNSE(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'mNSE' for the "best" (unattainable) case
mNSE(sim=sim, obs=obs)

##################
# Example 3: mNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

mNSE(sim=sim, obs=obs)

##################
# Example 4: mNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

mNSE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
mNSE(sim=lsim, obs=lobs)

##################
# Example 5: mNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

mNSE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mNSE(sim=lsim, obs=lobs)

##################
# Example 6: mNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
mNSE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mNSE(sim=lsim, obs=lobs)

##################
# Example 7: mNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
mNSE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mNSE(sim=lsim, obs=lobs)

##################
# Example 8: mNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

mNSE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
mNSE(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='mse'>
Mean Squared Error
</h2><span id='topic+mse'></span><span id='topic+mse.default'></span><span id='topic+mse.matrix'></span><span id='topic+mse.data.frame'></span><span id='topic+mse.zoo'></span>

<h3>Description</h3>

<p>Mean squared error between <code>sim</code> and <code>obs</code>, in the squared units of <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(sim, obs, ...)

## Default S3 method:
mse(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
mse(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
mse(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
mse(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="mse_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="mse_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="mse_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="mse_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="mse_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="mse_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> mse = \frac{1}{N} \sum_{i=1}^N { \left( S_i - O_i \right)^2 } </code>
</p>
 


<h3>Value</h3>

<p>Mean squared error between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the mean squared error between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Yapo P. O., Gupta H. V., Sorooshian S., 1996. Automatic calibration of conceptual rainfall-runoff models: sensitivity to calibration data. Journal of Hydrology. v181 i1-4. 23-48</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
mse(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
mse(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'mse' for the "best" (unattainable) case
mse(sim=sim, obs=obs)

##################
# Example 3: mse for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

mse(sim=sim, obs=obs)

##################
# Example 4: mse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

mse(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
mse(sim=lsim, obs=lobs)

##################
# Example 5: mse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

mse(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mse(sim=lsim, obs=lobs)

##################
# Example 6: mse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
mse(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mse(sim=lsim, obs=lobs)

##################
# Example 7: mse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
mse(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
mse(sim=lsim, obs=lobs)

##################
# Example 8: mse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

mse(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
mse(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='nrmse'>
Normalized Root Mean Square Error
</h2><span id='topic+nrmse'></span><span id='topic+nrmse.default'></span><span id='topic+nrmse.matrix'></span><span id='topic+nrmse.data.frame'></span><span id='topic+nrmse.zoo'></span>

<h3>Description</h3>

<p>Normalized root mean square error (NRMSE) between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrmse(sim, obs, ...)

## Default S3 method:
nrmse(sim, obs, na.rm=TRUE, norm="sd", fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'data.frame'
nrmse(sim, obs, na.rm=TRUE, norm="sd", fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'matrix'
nrmse(sim, obs, na.rm=TRUE, norm="sd", fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'zoo'
nrmse(sim, obs, na.rm=TRUE, norm="sd", fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrmse_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_norm">norm</code></td>
<td>

<p>character, indicating the value to be used for normalising the root mean square error (RMSE). Valid values are: <br />
-) <kbd>sd</kbd>    : standard deviation of observations (default). <br />
-) <kbd>maxmin</kbd>: difference between the maximum and minimum observed values
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="nrmse_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> nrmse = 100 \frac {\sqrt{ \frac{1}{N} \sum_{i=1}^N { \left( S_i - O_i \right)^2 } } } {nval} </code>
</p>

<p style="text-align: center;"><code class="reqn">nval=  \left\{
  \begin{array}{cl}
    sd(O_i)           &amp; , \: \textrm{norm="sd"} \\
    O_{max} - O_{min} &amp; , \: \textrm{norm="maxmin"}    
  \end{array}
  \right.</code>
</p>
 


<h3>Value</h3>

<p>Normalized root mean square error (nrmse) between <code>sim</code> and <code>obs</code>. The result is given in percentage (%) <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the normalized root mean square error between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> have to have the same length/dimension <br />
</p>
<p>Missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
nrmse(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
nrmse(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'nrmse' for the "best" (unattainable) case
nrmse(sim=sim, obs=obs)

##################
# Example 3: nrmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

nrmse(sim=sim, obs=obs)

##################
# Example 4: nrmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

nrmse(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
nrmse(sim=lsim, obs=lobs)

##################
# Example 5: nrmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

nrmse(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
nrmse(sim=lsim, obs=lobs)

##################
# Example 6: nrmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
nrmse(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
nrmse(sim=lsim, obs=lobs)

##################
# Example 7: nrmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
nrmse(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
nrmse(sim=lsim, obs=lobs)

##################
# Example 8: nrmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

nrmse(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
nrmse(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='NSE'>
Nash-Sutcliffe Efficiency
</h2><span id='topic+NSeff'></span><span id='topic+NSE'></span><span id='topic+NSE.default'></span><span id='topic+NSE.matrix'></span><span id='topic+NSE.data.frame'></span><span id='topic+NSE.zoo'></span>

<h3>Description</h3>

<p>Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSE(sim, obs, ...)

## Default S3 method:
NSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
NSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
NSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
NSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="NSE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="NSE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="NSE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="NSE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="NSE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="NSE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> NSE = 1 -\frac { \sum_{i=1}^N { \left( S_i - O_i \right)^2 } } { \sum_{i=1}^N { \left( O_i - \bar{O} \right)^2 } }  </code>
</p>

<p>The Nash-Sutcliffe efficiency (NSE) is a normalized statistic that determines the relative magnitude of the residual variance (&quot;noise&quot;) compared to the measured data variance (&quot;information&quot;) (Nash and Sutcliffe, 1970). <br />
</p>
<p>NSE indicates how well the plot of observed versus simulated data fits the 1:1 line.<br />
</p>
<p>Nash-Sutcliffe efficiencies range from -Inf to 1. Essentially, the closer to 1, the more accurate the model is. <br />
-) NSE = 1, corresponds to a perfect match of modelled to the observed data. <br />
-) NSE = 0, indicates that the model predictions are as accurate as the mean of the observed data, <br />
-) -Inf &lt; NSE &lt; 0, indicates that the observed mean is better predictor than the model.
</p>


<h3>Value</h3>

<p>Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the Nash-Sutcliffe efficiency between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe_model_efficiency_coefficient">https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe_model_efficiency_coefficient</a> <br />
</p>
<p><cite>Nash, J.E. and J.V. Sutcliffe, River flow forecasting through conceptual models. Part 1: a discussion of principles, J. Hydrol. 10 (1970), pp. 282-290. doi:10.1016/0022-1694(70)90255-6</cite> <br />
</p>
<p><cite>Criss, R. E. and Winston, W. E. (2008), Do Nash values have value? Discussion and alternate proposals. Hydrological Processes, 22: 2723-2725. doi:10.1002/hyp.7072</cite>
</p>
<p><cite>Knoben, W. J.; Freer, J. E.; Woods, R. A. (2019). Inherent benchmark or not? Comparing Nash-Sutcliffe and Kling-Gupta efficiency scores. Hydrology and Earth System Sciences, 23(10), 4323-4331. doi:10.5194/hess-23-4323-2019</cite> <br />
</p>
<p><cite>Pushpalatha, R., Perrin, C., Le Moine, N. and Andreassian, V. (2012). A review of efficiency criteria suitable for evaluating low-flow simulations. Journal of Hydrology, 420, 171-182. doi:10.1016/j.jhydrol.2011.11.055</cite>  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mNSE">mNSE</a></code>, <code><a href="#topic+rNSE">rNSE</a></code>, <code><a href="#topic+wNSE">wNSE</a></code>, <code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
NSE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
NSE(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'NSE' for the "best" (unattainable) case
NSE(sim=sim, obs=obs)

##################
# Example 3: NSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

NSE(sim=sim, obs=obs)

##################
# Example 4: NSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

NSE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
NSE(sim=lsim, obs=lobs)

##################
# Example 5: NSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

NSE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
NSE(sim=lsim, obs=lobs)

##################
# Example 6: NSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
NSE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
NSE(sim=lsim, obs=lobs)

##################
# Example 7: NSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
NSE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
NSE(sim=lsim, obs=lobs)

##################
# Example 8: NSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

NSE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
NSE(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='pbias'>
Percent Bias
</h2><span id='topic+pbias'></span><span id='topic+pbias.default'></span><span id='topic+pbias.matrix'></span><span id='topic+pbias.data.frame'></span><span id='topic+pbias.zoo'></span>

<h3>Description</h3>

<p>Percent Bias between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbias(sim, obs, ...)

## Default S3 method:
pbias(sim, obs, na.rm=TRUE, dec=1, fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'data.frame'
pbias(sim, obs, na.rm=TRUE, dec=1, fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'matrix'
pbias(sim, obs, na.rm=TRUE, dec=1, fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)

## S3 method for class 'zoo'
pbias(sim, obs, na.rm=TRUE, dec=1, fun=NULL, ..., 
               epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
               epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbias_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="pbias_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="pbias_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="pbias_+3A_dec">dec</code></td>
<td>

<p>numeric, specifying the number of decimal places used to rounf the output object. Default value is 1.
</p>
</td></tr>
<tr><td><code id="pbias_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="pbias_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="pbias_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="pbias_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PBIAS = 100 \frac{  \sum_{i=1}^N { \left( S_i - O_i \right) } } { \sum_{i=1}^N O_i} </code>
</p>
 
<p>Percent bias (PBIAS) measures the average tendency of the simulated values to be larger or smaller than their observed ones. <br />
</p>
<p>The optimal value of PBIAS is 0.0, with low-magnitude values indicating accurate model simulation. Positive values indicate overestimation bias, whereas negative values indicate model underestimation bias
</p>


<h3>Value</h3>

<p>Percent bias between <code>sim</code> and <code>obs</code>. The result is given in percentage (%) <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the percent bias between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Yapo, P. O.; Gupta, H. V.; Sorooshian S. (1996). Automatic calibration of conceptual rainfall-runoff models: sensitivity to calibration data. Journal of Hydrology. v181 i1-4. 23&ndash;48. doi:10.1016/0022-1694(95)02918-4</cite> <br />
</p>
<p><cite>Sorooshian, S., Q. Duan, and V. K. Gupta. 1993. Calibration of rainfall-runoff models: Application of global optimization to the Sacramento Soil Moisture Accounting Model, Water Resources Research, 29 (4), 1185-1194, doi:10.1029/92WR02617</cite>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
pbias(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
pbias(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'pbias' for the "best" (unattainable) case
pbias(sim=sim, obs=obs)

##################
# Example 3: pbias for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

pbias(sim=sim, obs=obs)

##################
# Example 4: pbias for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

pbias(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
pbias(sim=lsim, obs=lobs)

##################
# Example 5: pbias for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

pbias(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
pbias(sim=lsim, obs=lobs)

##################
# Example 6: pbias for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
pbias(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
pbias(sim=lsim, obs=lobs)

##################
# Example 7: pbias for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
pbias(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
pbias(sim=lsim, obs=lobs)

##################
# Example 8: pbias for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

pbias(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
pbias(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='pbiasfdc'>
Percent Bias in the Slope of the Midsegment of the Flow Duration Curve
</h2><span id='topic+pbiasfdc'></span><span id='topic+pbiasfdc.default'></span><span id='topic+pbiasfdc.matrix'></span><span id='topic+pbiasfdc.data.frame'></span><span id='topic+pbiasfdc.zoo'></span>

<h3>Description</h3>

<p>Percent Bias in the slope of the midsegment of the flow duration curve (FDC) [%]. It is related to the vertical soil moisture redistribution. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbiasfdc(sim, obs, ...)

## Default S3 method:
pbiasfdc(sim, obs, lQ.thr=0.7, hQ.thr=0.2, na.rm=TRUE, 
       plot=TRUE, verbose=FALSE, fun=NULL, ..., 
       epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
       epsilon.value=NA)

## S3 method for class 'data.frame'
pbiasfdc(sim, obs, lQ.thr=0.7, hQ.thr=0.2, na.rm=TRUE, 
        plot=TRUE, verbose=FALSE, fun=NULL, ..., 
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
        epsilon.value=NA)

## S3 method for class 'matrix'
pbiasfdc(sim, obs, lQ.thr=0.7, hQ.thr=0.2, na.rm=TRUE, 
        plot=TRUE, verbose=FALSE, fun=NULL, ..., 
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
        epsilon.value=NA)
       
## S3 method for class 'zoo'
pbiasfdc(sim, obs, lQ.thr=0.7, hQ.thr=0.2, na.rm=TRUE, 
        plot=TRUE, verbose=FALSE, fun=NULL, ..., 
        epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
        epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbiasfdc_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_lq.thr">lQ.thr</code></td>
<td>

<p>numeric, used to classify low flows. All the streamflows with a probability of exceedence larger or equal to <code>lQ.thr</code> are classified as low flows
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_hq.thr">hQ.thr</code></td>
<td>

<p>numeric, used to classify high flows. All the streamflows with a probability of exceedence larger or equal to <code>hQ.thr</code> are classified as high flows
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' values should be stripped before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_plot">plot</code></td>
<td>

<p>a logical value indicating if the flow duration curves corresponding to <code>obs</code> and <code>sim</code> have to be  plotted or not.
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_verbose">verbose</code></td>
<td>

<p>logical; if TRUE, progress messages are printed 
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="pbiasfdc_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Percent Bias in the slope of the midsegment of the flow duration curve, between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the Percent Bias in the slope of the midsegment of the flow duration curve, between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p>The result is given in percentage (%). <br />
</p>
<p>It requires the <span class="pkg">hydroTSM</span> package.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Yilmaz, K. K., H. V. Gupta, and T. Wagener  (2008), A process-based diagnostic approach to model evaluation: Application to the NWS distributed hydrologic model, Water Resour. Res., 44, W09417, doi:10.1029/2007WR006716</cite>
</p>
<p><cite>Yilmaz, K. K., H. V. Gupta, and T. Wagener  (2008), A process-based diagnostic approach to model evaluation: Application to the NWS distributed hydrologic model, Water Resour. Res., 44, W09417, doi:10.1029/2007WR006716</cite>
</p>


<h3>See Also</h3>

<p><a href="hydroTSM.html#topic+fdc">fdc</a>, <code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
pbiasfdc(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
pbiasfdc(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'pbiasfdc' for the "best" (unattainable) case
pbiasfdc(sim=sim, obs=obs)

##################
# Example 3: pbiasfdc for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

pbiasfdc(sim=sim, obs=obs)

##################
# Example 4: pbiasfdc for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

pbiasfdc(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
pbiasfdc(sim=lsim, obs=lobs)

##################
# Example 5: pbiasfdc for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

pbiasfdc(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
pbiasfdc(sim=lsim, obs=lobs)

##################
# Example 6: pbiasfdc for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
pbiasfdc(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
pbiasfdc(sim=lsim, obs=lobs)

##################
# Example 7: pbiasfdc for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
pbiasfdc(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
pbiasfdc(sim=lsim, obs=lobs)

##################
# Example 8: pbiasfdc for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

pbiasfdc(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
pbiasfdc(sim=sim1, obs=obs1)

## End(Not run)
</code></pre>

<hr>
<h2 id='pfactor'>
P-factor
</h2><span id='topic+pfactor'></span><span id='topic+pfactor.default'></span><span id='topic+pfactor.matrix'></span><span id='topic+pfactor.data.frame'></span>

<h3>Description</h3>

<p><var>P-factor</var> is the percent of observations that are within the given uncertainty bounds. <br />
</p>
<p>Ideally, i.e., with a combination of model structure and parameter values that perfectly represents the catchment under study, and in absence of measurement errors and other additional sources of uncertainty, all the simulated values should be in a perfect match with the observations, leading to a <var>P-factor</var> equal to 1, and an <var>R-factor</var> equal to zero. However, in real-world applications we aim at encompassing as much observations as possible within the given uncertainty bounds (<var>P-factor</var> close to 1) while keeping the width of the uncertainty bounds as small as possible (<var>R-factor</var> close to 0), in order to avoid obtaining a good bracketing of observations at expense of uncertainty bounds too wide to be informative for the decision-making process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfactor(x, ...)

## Default S3 method:
pfactor(x, lband, uband, na.rm=TRUE, ...)

## S3 method for class 'data.frame'
pfactor(x, lband, uband, na.rm=TRUE, ...)

## S3 method for class 'matrix'
pfactor(x, lband, uband, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfactor_+3A_x">x</code></td>
<td>

<p>ts or zoo object with the observed values.
</p>
</td></tr>
<tr><td><code id="pfactor_+3A_lband">lband</code></td>
<td>

<p>numeric, ts or zoo object with the values of the lower uncertainty bound
</p>
</td></tr>
<tr><td><code id="pfactor_+3A_uband">uband</code></td>
<td>

<p>numeric, ts or zoo object with the values of the upper uncertainty bound
</p>
</td></tr>
<tr><td><code id="pfactor_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' values should be stripped before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="pfactor_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Percent of the <code>x</code> observations that are within the given uncertainty bounds given by <code>lband</code> and <code>uband</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the <var>P-factor</var> between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p>So far, the argument <code>na.rm</code> is not being taken into account.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Abbaspour, K. C., M. Faramarzi, S. S. Ghasemi, and H. Yang (2009), Assessing the impact of climate change on water resources in Iran, Water Resour. Res., 45(10), W10,434, doi:10.1029/2008WR007615</cite> <br />
</p>
<p><cite>Abbaspour, K. C., J. Yang, I. Maximov, R. Siber, K. Bogner, J. Mieleitner, J. Zobrist, and R. Srinivasan (2007), Modelling hydrology and water quality in the pre-alpine/alpine Thur watershed using SWAT, Journal of Hydrology, 333(2-4), 413-430, doi:10.1016/j.jhydrol.2006.09.014</cite> <br />
</p>
<p><cite>Schuol, J., K. Abbaspour, R. Srinivasan, and H. Yang (2008b), Estimation of freshwater availability in the West African sub-continent using the SWAT hydrologic model, Journal of Hydrology, 352(1-2), 30, doi:10.1016/j.jhydrol.2007.12.025</cite> <br />
</p>
<p><cite>Abbaspour, C., Karim (2007), User manual for SWAT-CUP, SWAT calibration and uncertainty analysis programs, 93pp, Eawag: Swiss Fed. Inst. of Aquat. Sci. and Technol. Dubendorf, Switzerland</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfactor">rfactor</a></code>, <code><a href="#topic+plotbands">plotbands</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
lband &lt;- x - 0.1
uband &lt;- x + 0.1
pfactor(x, lband, uband)

lband &lt;- x - rnorm(10)
uband &lt;- x + rnorm(10)
pfactor(x, lband, uband)

#############
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Selecting only the daily values belonging to the year 1961
obs &lt;- window(obs, end=as.Date("1961-12-31"))

# Generating the lower and upper uncertainty bounds, centred at the observations
lband &lt;- obs - 5
uband &lt;- obs + 5

pfactor(obs, lband, uband)

# Randomly generating the lower and upper uncertainty bounds
uband &lt;- obs + rnorm(length(obs))
lband &lt;- obs - rnorm(length(obs))

pfactor(obs, lband, uband)
</code></pre>

<hr>
<h2 id='plot2'>
Plotting 2 Time Series
</h2><span id='topic+plot2'></span>

<h3>Description</h3>

<p>Plotting of 2 time series, in two different vertical windows or overlapped in the same window. <br />
It requires the <span class="pkg">hydroTSM</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2(x, y, plot.type = "multiple", 
      tick.tstep = "auto", lab.tstep = "auto", lab.fmt=NULL,
      main, xlab = "Time", ylab,
      cal.ini=NA, val.ini=NA, date.fmt="%Y-%m-%d",
      gof.leg = FALSE, gof.digits=2, 
      gofs=c("ME", "MAE", "RMSE", "NRMSE", "PBIAS", "RSR", "rSD", "NSE", "mNSE", 
             "rNSE", "d", "md", "rd", "r", "R2", "bR2", "KGE", "VE"),
      legend, leg.cex = 1,
      col = c("black", "blue"),
      cex = c(0.5, 0.5), cex.axis=1.2, cex.lab=1.2, 
      lwd= c(1,1), lty=c(1,3), pch = c(1, 9), 
      pt.style = "ts", add = FALSE, 
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2_+3A_x">x</code></td>
<td>

<p>time series that will be plotted. class(x) must be ts or zoo. If <code>leg.gof=TRUE</code>, then <code>x</code> is considered as <b>simulated</b> (for some goodness-of-fit functions this is important)
</p>
</td></tr>
<tr><td><code id="plot2_+3A_y">y</code></td>
<td>

<p>time series that will be plotted. class(x) must be ts or zoo. If <code>leg.gof=TRUE</code>, then <code>y</code> is considered as <b>observed</b> values (for some goodness-of-fit functions this is important)
</p>
</td></tr>
<tr><td><code id="plot2_+3A_plot.type">plot.type</code></td>
<td>

<p>character, indicating if the 2 ts have to be plotted in the same window or in two different vertical ones. Valid values are: <br />
-) <kbd>single</kbd>  : (default) superimposes the 2 ts on a single plot <br />
-) <kbd>multiple</kbd>: plots the 2 series on 2 multiple vertical plots 
</p>
</td></tr>
<tr><td><code id="plot2_+3A_tick.tstep">tick.tstep</code></td>
<td>

<p>character, indicating the time step that have to be used for putting the ticks on the time axis. Valid values are: <kbd>auto</kbd>, <kbd>years</kbd>, <kbd>months</kbd>,<kbd>weeks</kbd>, <kbd>days</kbd>, <kbd>hours</kbd>, <kbd>minutes</kbd>, <kbd>seconds</kbd>.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_lab.tstep">lab.tstep</code></td>
<td>

<p>character, indicating the time step that have to be used for putting the labels on the time axis. Valid values are: <kbd>auto</kbd>, <kbd>years</kbd>, <kbd>months</kbd>,<kbd>weeks</kbd>, <kbd>days</kbd>, <kbd>hours</kbd>, <kbd>minutes</kbd>, <kbd>seconds</kbd>.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_lab.fmt">lab.fmt</code></td>
<td>

<p>Character indicating the format to be used for the label of the axis. See <code>lab.fmt</code> in <code><a href="hydroTSM.html#topic+drawTimeAxis">drawTimeAxis</a></code>.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_main">main</code></td>
<td>

<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>
</p>
</td></tr>
<tr><td><code id="plot2_+3A_xlab">xlab</code></td>
<td>

<p>label for the 'x' axis
</p>
</td></tr>
<tr><td><code id="plot2_+3A_ylab">ylab</code></td>
<td>

<p>label for the 'y' axis 
</p>
</td></tr>
<tr><td><code id="plot2_+3A_cal.ini">cal.ini</code></td>
<td>

<p>OPTIONAL. Character, indicating the date in which the calibration period started. <br />
When <code>cal.ini</code> is provided, all the values in <code>obs</code> and <code>sim</code> with dates previous to <code>cal.ini</code> are SKIPPED from the computation of the goodness-of-fit measures (when <code>gof.leg=TRUE</code>), but their values are still plotted, in order to examine if the warming up period was too short, acceptable or too long for the chosen calibration period.
In addition, a vertical red line in drawn at this date. 
</p>
</td></tr>
<tr><td><code id="plot2_+3A_val.ini">val.ini</code></td>
<td>

<p>OPTIONAL. Character with the date in which the validation period started. <br />
ONLY used for drawing a vertical red line at this date. 
</p>
</td></tr>
<tr><td><code id="plot2_+3A_date.fmt">date.fmt</code></td>
<td>

<p>OPTIONAL. Character indicating the format in which the dates entered are stored in <code>cal.ini</code> and <code>val.ini</code>. Default value is <kbd>%Y-%m-%d</kbd>. ONLY required when <code>cal.ini</code> or <code>val.ini</code> is provided.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_gof.leg">gof.leg</code></td>
<td>

<p>logical, indicating if several numerical goodness-of-fit values have to be computed between <code>sim</code> and <code>obs</code>, and plotted as a legend on the graph. If <code>gof.leg=TRUE</code> (default value), then <code>x</code> is considered as observed and <code>y</code> as simulated values (for some gof functions this is important). This legend is ONLY plotted when <code>plot.type="single"</code>
</p>
</td></tr>
<tr><td><code id="plot2_+3A_gof.digits">gof.digits</code></td>
<td>

<p>OPTIONAL, only used when <code>gof.leg=TRUE</code>. Decimal places used for rounding the goodness-of-fit indexes.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_gofs">gofs</code></td>
<td>

<p>character, with one or more strings indicating the goodness-of-fit measures to be shown in the legend of the plot when  <code>gof.leg=TRUE</code>. <br />
Possible values are in <code>c("ME", "MAE", "MSE", "RMSE", "NRMSE", "PBIAS", "RSR", "rSD", "NSE", "mNSE", "rNSE", "d", "md", "rd", "cp", "r", "R2", "bR2", "KGE", "VE")</code>.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_legend">legend</code></td>
<td>

<p>vector of length 2 to appear in the legend.  
</p>
</td></tr>
<tr><td><code id="plot2_+3A_leg.cex">leg.cex</code></td>
<td>

<p>numeric, indicating the character expansion factor *relative* to current 'par(&quot;cex&quot;)'. Used for text, and provides the default for 'pt.cex' and 'title.cex'. Default value = 1 <br />
So far, it controls the expansion factor of the 'GoF' legend and the legend referring to <code>x</code> and <code>y</code>
</p>
</td></tr>
<tr><td><code id="plot2_+3A_col">col</code></td>
<td>

<p>character, with the colors of <code>x</code> and <code>y</code>
</p>
</td></tr>
<tr><td><code id="plot2_+3A_cex">cex</code></td>
<td>

<p>numeric, with the values controlling the size of text and symbols of <code>x</code> and <code>y</code> with respect to the default
</p>
</td></tr>
<tr><td><code id="plot2_+3A_cex.axis">cex.axis</code></td>
<td>

<p>numeric, with the magnification of axis annotation relative to 'cex'. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_cex.lab">cex.lab</code></td>
<td>

<p>numeric, with the magnification to be used for x and y labels relative to the current setting of 'cex'. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot2_+3A_lwd">lwd</code></td>
<td>

<p>vector with the line width of <code>x</code> and <code>y</code>
</p>
</td></tr>
<tr><td><code id="plot2_+3A_lty">lty</code></td>
<td>

<p>vector with the line type of <code>x</code> and <code>y</code>
</p>
</td></tr>
<tr><td><code id="plot2_+3A_pch">pch</code></td>
<td>

<p>vector with the type of symbol for <code>x</code> and <code>y</code>. (e.g.: 1: white circle; 9: white rhombus with a cross inside)
</p>
</td></tr>
<tr><td><code id="plot2_+3A_pt.style">pt.style</code></td>
<td>

<p>Character, indicating if the 2 ts have to be plotted as lines or bars. Valid values are: <br />
-) <kbd>ts</kbd> : (default) each ts is plotted as a lines along the <code>x</code> axis <br />
-) <kbd>bar</kbd>: the 2 series are plotted as a barplot. 
</p>
</td></tr>
<tr><td><code id="plot2_+3A_add">add</code></td>
<td>

<p>logical indicating if other plots will be added in further calls to this function. <br />
-) <kbd>FALSE</kbd> =&gt; the plot and the legend are plotted on the same graph <br />
-) <kbd>TRUE</kbd>  =&gt; the legend is plotted in a new graph, usually when called from another function (e.g.: <code><a href="#topic+ggof">ggof</a></code>)
</p>
</td></tr>
<tr><td><code id="plot2_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code><a href="zoo.html#topic+plot.zoo">plot.zoo</a></code> function for plotting <code>x</code>, or from other methods
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It requires the package <span class="pkg">hydroTSM</span>.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggof">ggof</a></code>, <code><a href="hydroTSM.html#topic+plot_pq">plot_pq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- 2:11
obs &lt;- 1:10
## Not run: 
plot2(sim, obs)

## End(Not run)

##################
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Randomly changing the first 2000 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Plotting 'sim' and 'obs' in 2 separate panels
plot2(x=obs, y=sim)

# Plotting 'sim' and 'obs' in the same window
plot2(x=obs, y=sim, plot.type="single")
</code></pre>

<hr>
<h2 id='plotbands'>
Plot a ts with observed values and two confidence bounds 
</h2><span id='topic+plotbands'></span>

<h3>Description</h3>

<p>It plots a ts with observed values and two confidence bounds. Optionally can also add a simulated time series, in order to be compared with 'x'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbands(x, lband, uband, sim, 
          dates, date.fmt="%Y-%m-%d",
          gof.leg= TRUE, gof.digits=2, 
          legend=c("Obs", "Sim", "95PPU"), leg.cex=1,
          bands.col="lightblue", border= NA,
          tick.tstep= "auto", lab.tstep= "auto", lab.fmt=NULL,
          cal.ini=NA, val.ini=NA, 
          main="Confidence Bounds for 'x'", 
          xlab="Time", ylab="Q, [m3/s]", ylim,
          col=c("black", "blue"), type= c("lines", "lines"),
          cex= c(0.5, 0.5), cex.axis=1.2, cex.lab=1.2,          
          lwd=c(0.6, 1), lty=c(3, 4), pch=c(1,9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbands_+3A_x">x</code></td>
<td>

<p>zoo or xts object with the observed values.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_lband">lband</code></td>
<td>

<p>zoo or xts object with the values of the lower band.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_uband">uband</code></td>
<td>

<p>zoo or xts object with the values of the upper band.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_sim">sim</code></td>
<td>

<p>OPTIONAL. zoo or xts object with the simulated values.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_dates">dates</code></td>
<td>

<p>OPTIONAL. Date, factor, or character object indicating the dates that will be assigned to <code>x</code>, <code>lband</code>, <code>uband</code>, and <code>sim</code> (when provided). <br />
If <code>dates</code> is a factor or character vector, its values are converted to dates using the date format specified by <code>date.fmt</code>. <br />
When <code>x</code>, <code>lband</code>, <code>uband</code>, and <code>sim</code> are already of zoo class, <b>the values provided by <code>dates</code> over-write the original dates of the objects</b>.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_date.fmt">date.fmt</code></td>
<td>

<p>OPTIONAL. Character indicating the format in which the dates entered are stored in <code>cal.ini</code> and <code>val.ini</code>. See <code>format</code> in <code><a href="base.html#topic+as.Date">as.Date</a></code>.<br />
Default value is <kbd>%Y-%m-%d</kbd> <br />
ONLY required when <code>cal.ini</code>, <code>val.ini</code> or <code>dates</code> is provided.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_gof.leg">gof.leg</code></td>
<td>

<p>logical indicating if the p-factor and r-factor have to be computed and plotted as legends on the graph.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_gof.digits">gof.digits</code></td>
<td>

<p>OPTIONAL, numeric. Only used when <code>gof.leg=TRUE</code>. Decimal places used for rounding the goodness-of-fit indexes
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_legend">legend</code></td>
<td>

<p>OPTIONAL. logical or character vector of length 3 with the strings that will be used for the legend of the plot. <br />
-) When <code>legend</code> is a character vector, the first element is used for labelling the observed series, the second for labelling the simulated series and the third one for the predictive uncertainty bounds. Default value is <code>c("obs", "sim", "95PPU")</code> <br />
-) When <code>legend=FALSE</code>, the legend is not drawn.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_leg.cex">leg.cex</code></td>
<td>

<p>OPTIONAL. numeric. Used for the GoF legend. Character expansion factor *relative* to current 'par(&quot;cex&quot;)'. Used for text, and provides the default for 'pt.cex' and 'title.cex'. Default value is 1.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_bands.col">bands.col</code></td>
<td>

<p>See <code><a href="graphics.html#topic+polygon">polygon</a></code>. Color to be used for filling the area between the lower and upper uncertainty bound.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_border">border</code></td>
<td>

<p>See <code><a href="graphics.html#topic+polygon">polygon</a></code>. The color to draw the border.  The default, 'NULL', means to  use 'par(&quot;fg&quot;)'.  Use 'border = NA' to omit borders.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_tick.tstep">tick.tstep</code></td>
<td>

<p>character, indicating the time step that have to be used for putting the ticks on the time axis. Valid values are: <kbd>auto</kbd>, <kbd>years</kbd>, <kbd>months</kbd>,<kbd>weeks</kbd>, <kbd>days</kbd>, <kbd>hours</kbd>, <kbd>minutes</kbd>, <kbd>seconds</kbd>.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_lab.tstep">lab.tstep</code></td>
<td>

<p>character, indicating the time step that have to be used for putting the labels on the time axis. Valid values are: <kbd>auto</kbd>, <kbd>years</kbd>, <kbd>months</kbd>,<kbd>weeks</kbd>, <kbd>days</kbd>, <kbd>hours</kbd>, <kbd>minutes</kbd>, <kbd>seconds</kbd>.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_lab.fmt">lab.fmt</code></td>
<td>

<p>Character indicating the format to be used for the label of the axis. See <code>lab.fmt</code> in <code><a href="hydroTSM.html#topic+drawTimeAxis">drawTimeAxis</a></code>.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_cal.ini">cal.ini</code></td>
<td>

<p>OPTIONAL. Character with the date in which the calibration period started. <br />
ONLY used for drawing a vertical red line at this date. 
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_val.ini">val.ini</code></td>
<td>

<p>OPTIONAL. Character with the date in which the validation period started. <br />
ONLY used for drawing a vertical red line at this date. 
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_main">main</code></td>
<td>

<p>an overall title for the plot: see 'title' 
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis: see 'title'
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis: see 'title'
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_ylim">ylim</code></td>
<td>

<p>the y limits of the plot. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_col">col</code></td>
<td>

<p>colors to be used for plotting the <code>x</code> and <code>sim</code> ts.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_type">type</code></td>
<td>

<p>character.  Indicates if the observed and simulated series have to be plotted as lines or points. Possible values are: <br />
-) <kbd>lines</kbd> : the observed/simulated series are plotted as lines <br />
-) <kbd>points</kbd>: the observed/simulated series are plotted as points
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_cex">cex</code></td>
<td>

<p>See code <a href="graphics.html#topic+plot.default">plot.default</a>. A numerical vector giving the amount by which plotting characters and symbols should be scaled relative to the default.  <br />
This works as a multiple of 'par(&quot;cex&quot;)'. 'NULL' and 'NA' are equivalent to '1.0'.  Note that this does not affect annotation.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_cex.axis">cex.axis</code></td>
<td>

<p>magnification of axis annotation relative to 'cex'.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_cex.lab">cex.lab</code></td>
<td>

<p>Magnification to be used for x and y labels relative to the current setting of 'cex'. See '?par'.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_lwd">lwd</code></td>
<td>

<p>See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>. The line width, see 'par'.
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_lty">lty</code></td>
<td>

<p>See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>. The line type, see 'par'. 
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_pch">pch</code></td>
<td>

<p>numeric, with the type of symbol for <code>x</code> and <code>y</code>. (e.g.: 1: white circle; 9: white rhombus with a cross inside)
</p>
</td></tr>
<tr><td><code id="plotbands_+3A_...">...</code></td>
<td>

<p>further arguments passed to the <code><a href="graphics.html#topic+points">points</a></code> function for plotting <code>x</code>, or from other methods
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It requires the <span class="pkg">hydroTSM</span> package
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfactor">pfactor</a></code>, <code><a href="#topic+rfactor">rfactor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Selecting only the daily values belonging to the year 1961
obs &lt;- window(obs, end=as.Date("1961-12-31"))

# Generating the lower and upper uncertainty bounds
lband &lt;- obs - 5
uband &lt;- obs + 5

## Not run: 
plotbands(obs, lband, uband)

## End(Not run)

# Randomly generating a simulated time series
sim &lt;- obs + rnorm(length(obs), mean=3)

## Not run: 
plotbands(obs, lband, uband, sim)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotbandsonly'>
Adds uncertainty bounds to an existing plot.
</h2><span id='topic+plotbandsonly'></span>

<h3>Description</h3>

<p>Adds a polygon representing uncertainty bounds to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbandsonly(lband, uband, dates, date.fmt="%Y-%m-%d",
          bands.col="lightblue", border= NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbandsonly_+3A_lband">lband</code></td>
<td>

<p>zoo or xts object with the values of the lower band.
</p>
</td></tr>
<tr><td><code id="plotbandsonly_+3A_uband">uband</code></td>
<td>

<p>zoo or xts object with the values of the upper band.
</p>
</td></tr>
<tr><td><code id="plotbandsonly_+3A_dates">dates</code></td>
<td>

<p>OPTIONAL. Date, factor, or character object indicating the dates that will be assigned to <code>lband</code> and <code>uband</code>. <br />
If <code>dates</code> is a factor or character vector, its values are converted to dates using the date format specified by <code>date.fmt</code>. <br />
When <code>lband</code> and <code>uband</code> are already of zoo class, <b>the values provided by <code>dates</code> over-write the original dates of the objects</b>.
</p>
</td></tr>
<tr><td><code id="plotbandsonly_+3A_date.fmt">date.fmt</code></td>
<td>

<p>OPTIONAL. Character indicating the format of <code>dates</code>. See <code>format</code> in <code><a href="base.html#topic+as.Date">as.Date</a></code>.
</p>
</td></tr>
<tr><td><code id="plotbandsonly_+3A_bands.col">bands.col</code></td>
<td>

<p>See <code><a href="graphics.html#topic+polygon">polygon</a></code>. Color to be used for filling the area between the lower and upper uncertainty bound.
</p>
</td></tr>
<tr><td><code id="plotbandsonly_+3A_border">border</code></td>
<td>

<p>See <code><a href="graphics.html#topic+polygon">polygon</a></code>. The color to draw the border.  The default, 'NULL', means to  use 'par(&quot;fg&quot;)'.  Use 'border = NA' to omit borders.
</p>
</td></tr>
<tr><td><code id="plotbandsonly_+3A_...">...</code></td>
<td>

<p>further arguments passed to the <code><a href="graphics.html#topic+polygon">polygon</a></code> function for plotting the bands, or from other methods
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It requires the <span class="pkg">hydroTSM</span> package
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfactor">pfactor</a></code>, <code><a href="#topic+rfactor">rfactor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Selecting only the daily values belonging to the year 1961
obs &lt;- window(obs, end=as.Date("1961-12-31"))

# Generating the lower and upper uncertainty bounds
lband &lt;- obs - 5
uband &lt;- obs + 5

## Not run: 
plot(obs, type="n")
plotbandsonly(lband, uband)
points(obs, col="blue", cex=0.6, type="o")

## End(Not run)

</code></pre>

<hr>
<h2 id='R2'>
Coefficient of determination
</h2><span id='topic+R2'></span><span id='topic+R2.default'></span><span id='topic+R2.matrix'></span><span id='topic+R2.data.frame'></span><span id='topic+R2.zoo'></span>

<h3>Description</h3>

<p>coefficient of determination between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2(sim, obs, ...)

## Default S3 method:
R2(sim, obs, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
R2(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
R2(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
R2(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
           epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="R2_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="R2_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="R2_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="R2_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="R2_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="R2_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>numeric value to be added to both <code>sim</code> and <code>obs</code> when <code>epsilon.type="otherValue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient of determination (R2) is the proportion of the variation in the dependent variable that is predictable from the independent variable(s).
</p>
<p>It is a statistic used in the context of statistical models whose main purpose is either the prediction of future outcomes or the testing of hypotheses, on the basis of other related information. It provides a measure of how well observed outcomes are replicated by the model, based on the proportion of total variation of outcomes explained by the model.
</p>
<p>The coefficient of determination is a statistical measure of how well the regression predictions approximate the real data points. An R2 of 1 indicates that the regression predictions perfectly fit the data.
</p>
<p>Values of R2 outside the range 0 to 1 occur when the model fits the data worse than the worst possible least-squares predictor (equivalent to a horizontal hyperplane at a height equal to the mean of the observed data). This occurs when a wrong model was chosen, or nonsensical constraints were applied by mistake.
</p>


<h3>Value</h3>

<p>Coefficient of determination between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the coefficient of determination between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Coefficient_of_determination">https://en.wikipedia.org/wiki/Coefficient_of_determination</a>
</p>
<p><cite>Box, G. E. (1966). Use and abuse of regression. Technometrics, 8(4), 625-629. doi:10.1080/00401706.1966.10490407</cite>
</p>
<p><cite>Hahn, G. J. (1973). The coefficient of determination exposed. Chemtech, 3(10), 609-612. Aailable online at: <a href="https://www2.hawaii.edu/~cbaajwe/Ph.D.Seminar/Hahn1973.pdf">https://www2.hawaii.edu/~cbaajwe/Ph.D.Seminar/Hahn1973.pdf</a>.</cite>
</p>
<p><cite>Barrett, J. P. (1974). The coefficient of determination-some limitations. The American Statistician, 28(1), 19-20. doi:10.1080/00031305.1974.10479056</cite>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
R2(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
R2(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'R2' for the "best" (unattainable) case
R2(sim=sim, obs=obs)

##################
# Example 3: R2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

R2(sim=sim, obs=obs)

##################
# Example 4: R2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

R2(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
R2(sim=lsim, obs=lobs)

##################
# Example 5: R2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

R2(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
R2(sim=lsim, obs=lobs)

##################
# Example 6: R2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
R2(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
R2(sim=lsim, obs=lobs)

##################
# Example 7: R2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
R2(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
R2(sim=lsim, obs=lobs)

##################
# Example 8: R2 for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

R2(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
R2(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='rd'>
Relative Index of Agreement
</h2><span id='topic+rd'></span><span id='topic+rd.default'></span><span id='topic+rd.matrix'></span><span id='topic+rd.data.frame'></span><span id='topic+rd.zoo'></span>

<h3>Description</h3>

<p>This function computes the Relative Index of Agreement (d) between <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
If <code>x</code> is a matrix or a data frame, a vector of the relative index of agreement among the columns is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rd(sim, obs, ...)

## Default S3 method:
rd(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
rd(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
rd(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
rd(sim, obs, na.rm=TRUE, fun=NULL, ...,
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rd_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rd_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rd_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rd_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rd_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rd_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>FUN</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>FUN</code>.
</p>
</td></tr>
<tr><td><code id="rd_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">rd = 1 - \frac{ \sum_{i=1}^N { \left( \frac{O_i - S_i}{O_i} \right) ^2} } { \sum_{i=1}^N {  \left( \frac{ \left| S_i -  \bar{O} \right| + \left| O_i -  \bar{O}  \right|}{\bar{O}} \right)^2 } } </code>
</p>
 


<p>It varies between 0 and 1. A value of 1 indicates a perfect match, and 0 indicates no agreement at all.
</p>


<h3>Value</h3>

<p>Relative index of agreement between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the relative index of agreement between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation. <br />
</p>
<p>If some of the observed values are equal to zero (at least one of them), this index can not be computed.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Krause, P., Boyle, D. P., and Base, F.: Comparison of different efficiency criteria for hydrological model assessment, Adv. Geosci., 5, 89-97, 2005</cite> <br />
</p>
<p><cite>Willmott, C. J. (1981). On the validation of models. Physical Geography, 2, 184&ndash;194</cite> <br />
</p>
<p><cite>Willmott, C. J. (1984). On the evaluation of model performance in physical geography. Spatial Statistics and Models, G. L. Gaile and C. J. Willmott, eds., 443-460</cite> <br />
</p>
<p><cite>Willmott, C. J., S. G. Ackleson, R. E. Davis, J. J. Feddema, K. M. Klink, D. R. Legates, J. O'Donnell, and C. M. Rowe (1985), Statistics for the Evaluation and Comparison of Models, J. Geophys. Res., 90(C5), 8995-9005</cite> <br />
</p>
<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233&ndash;241</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+d">d</a></code>, <code><a href="#topic+md">md</a></code>, <code><a href="#topic+dr">dr</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rd(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rd(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rd' for the "best" (unattainable) case
rd(sim=sim, obs=obs)

##################
# Example 3: rd for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rd(sim=sim, obs=obs)

##################
# Example 4: rd for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rd(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rd(sim=lsim, obs=lobs)

##################
# Example 5: rd for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rd(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rd(sim=lsim, obs=lobs)

##################
# Example 6: rd for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rd(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rd(sim=lsim, obs=lobs)

##################
# Example 7: rd for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rd(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rd(sim=lsim, obs=lobs)

##################
# Example 8: rd for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rd(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rd(sim=sim1, obs=obs1)

</code></pre>

<hr>
<h2 id='rfactor'>
R-factor
</h2><span id='topic+rfactor'></span><span id='topic+rfactor.default'></span><span id='topic+rfactor.matrix'></span><span id='topic+rfactor.data.frame'></span>

<h3>Description</h3>

<p><var>R-factor</var> represents the average width of the given uncertainty bounds divided by the standard deviation of the observations. <br />
</p>
<p>Ideally, i.e., with a combination of model structure and parameter values that perfectly represents the catchment under study, and in absence of measurement errors and other additional sources of uncertainty, all the simulated values should be in a perfect match with the observations, leading to a <var>P-factor</var> equal to 1, and an <var>R-factor</var> equal to zero. However, in real-world applications we aim at encompassing as much observations as possible within the given uncertainty bounds (<var>P-factor</var> close to 1) while keeping the width of the uncertainty bounds as small as possible (<var>R-factor</var> close to 0), in order to avoid obtaining a good bracketing of observations at expense of uncertainty bounds too wide to be informative for the decision-making process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfactor(x, ...)

## Default S3 method:
rfactor(x, lband, uband, na.rm=TRUE, ...)

## S3 method for class 'data.frame'
rfactor(x, lband, uband, na.rm=TRUE, ...)

## S3 method for class 'matrix'
rfactor(x, lband, uband, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfactor_+3A_x">x</code></td>
<td>

<p>ts or zoo object with the observed values.
</p>
</td></tr>
<tr><td><code id="rfactor_+3A_lband">lband</code></td>
<td>

<p>numeric, ts or zoo object with the values of the lower uncertainty bound
</p>
</td></tr>
<tr><td><code id="rfactor_+3A_uband">uband</code></td>
<td>

<p>numeric, ts or zoo object with the values of the upper uncertainty bound
</p>
</td></tr>
<tr><td><code id="rfactor_+3A_na.rm">na.rm</code></td>
<td>

<p>logical value indicating whether 'NA' values should be stripped before the computation proceeds.
</p>
</td></tr>
<tr><td><code id="rfactor_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Average width of the given uncertainty bounds, given by <code>lband</code> and <code>uband</code>, divided by the standard deviation of the observations <code>x</code> <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the R-factor between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p>So far, the argument <code>na.rm</code> is not being taken into account.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Abbaspour, K. C., M. Faramarzi, S. S. Ghasemi, and H. Yang (2009), Assessing the impact of climate change on water resources in Iran, Water Resour. Res., 45(10), W10,434, doi:10.1029/2008WR007615</cite> <br />
</p>
<p><cite>Abbaspour, K. C., J. Yang, I. Maximov, R. Siber, K. Bogner, J. Mieleitner, J. Zobrist, and R. Srinivasan (2007), Modelling hydrology and water quality in the pre-alpine/alpine Thur watershed using SWAT, Journal of Hydrology, 333(2-4), 413-430, doi:10.1016/j.jhydrol.2006.09.014</cite> <br />
</p>
<p><cite>Schuol, J., K. Abbaspour, R. Srinivasan, and H. Yang (2008b), Estimation of freshwater availability in the West African sub-continent using the SWAT hydrologic model, Journal of Hydrology, 352(1-2), 30, doi:10.1016/j.jhydrol.2007.12.025</cite> <br />
</p>
<p><cite>Abbaspour, C., Karim (2007), User manual for SWAT-CUP, SWAT calibration and uncertainty analysis programs, 93pp, Eawag: Swiss Fed. Inst. of Aquat. Sci. and Technol. Dubendorf, Switzerland.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfactor">pfactor</a></code>, <code><a href="#topic+plotbands">plotbands</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
lband &lt;- x - 0.1
uband &lt;- x + 0.1
rfactor(x, lband, uband)

lband &lt;- x - rnorm(10)
uband &lt;- x + rnorm(10)
rfactor(x, lband, uband)

#############
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Selecting only the daily values belonging to the year 1961
obs &lt;- window(obs, end=as.Date("1961-12-31"))

# Generating the lower and upper uncertainty bounds, centred at the observations
lband &lt;- obs - 5
uband &lt;- obs + 5

rfactor(obs, lband, uband)

# Randomly generating the lower and upper uncertainty bounds
uband &lt;- obs + rnorm(length(obs))
lband &lt;- obs - rnorm(length(obs))

rfactor(obs, lband, uband)

</code></pre>

<hr>
<h2 id='rmse'>
Root Mean Square Error
</h2><span id='topic+rmse'></span><span id='topic+rmse.default'></span><span id='topic+rmse.matrix'></span><span id='topic+rmse.data.frame'></span><span id='topic+rmse.zoo'></span>

<h3>Description</h3>

<p>Root Mean Square Error (RMSE) between <code>sim</code> and <code>obs</code>, in the same units of <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
RMSE gives the standard deviation of the model prediction error. A smaller value indicates better model performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(sim, obs, ...)

## Default S3 method:
rmse(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'data.frame'
rmse(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'matrix'
rmse(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'zoo'
rmse(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rmse_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rmse_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rmse_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Root Mean Square Error.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rmse_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rmse_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="rmse_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> rmse = \sqrt{ \frac{1}{N} \sum_{i=1}^N { \left( S_i - O_i \right)^2 } } </code>
</p>
 


<h3>Value</h3>

<p>Root mean square error (rmse) between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the RMSE between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Root_mean_square_deviation">https://en.wikipedia.org/wiki/Root_mean_square_deviation</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rmse(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rmse(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rmse' for the "best" (unattainable) case
rmse(sim=sim, obs=obs)

##################
# Example 3: rmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rmse(sim=sim, obs=obs)

##################
# Example 4: rmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rmse(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rmse(sim=lsim, obs=lobs)

##################
# Example 5: rmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rmse(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rmse(sim=lsim, obs=lobs)

##################
# Example 6: rmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rmse(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rmse(sim=lsim, obs=lobs)

##################
# Example 7: rmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rmse(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rmse(sim=lsim, obs=lobs)

##################
# Example 8: rmse for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rmse(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rmse(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='rNSE'>
Relative Nash-Sutcliffe efficiency
</h2><span id='topic+rNSeff'></span><span id='topic+rNSE'></span><span id='topic+rNSE.default'></span><span id='topic+rNSE.matrix'></span><span id='topic+rNSE.data.frame'></span><span id='topic+rNSE.zoo'></span>

<h3>Description</h3>

<p>Relative Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rNSE(sim, obs, ...)

## Default S3 method:
rNSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'data.frame'
rNSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'matrix'
rNSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'zoo'
rNSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rNSE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rNSE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rNSE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rNSE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the relative Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rNSE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rNSE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any nummeric value.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="rNSE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> rNSE = 1 -\frac { \sum_{i=1}^N { ( \frac{ S_i - O_i }{O_i} )^2 } } { \sum_{i=1}^N { ( \frac{ O_i - \bar{O} }{\bar{O}} )^2 } }  </code>
</p>



<h3>Value</h3>

<p>Relative Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the relative Nash-Sutcliffe efficiency between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>
<p>If some of the observed values are equal to zero (at least one of them), this index can not be computed.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Krause, P., Boyle, D. P., and Base, F.: Comparison of different efficiency criteria for hydrological model assessment, Adv. Geosci., 5, 89-97, 2005</cite> <br />
</p>
<p><cite>Legates, D. R., and G. J. McCabe Jr. (1999), Evaluating the Use of &quot;Goodness-of-Fit&quot; Measures in Hydrologic and Hydroclimatic Model Validation, Water Resour. Res., 35(1), 233-241</cite>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NSE">NSE</a></code>, <code><a href="#topic+mNSE">mNSE</a></code>, <code><a href="#topic+wNSE">wNSE</a></code>, <code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rNSE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rNSE(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rNSE' for the "best" (unattainable) case
rNSE(sim=sim, obs=obs)

##################
# Example 3: rNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rNSE(sim=sim, obs=obs)

##################
# Example 4: rNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rNSE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rNSE(sim=lsim, obs=lobs)

##################
# Example 5: rNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rNSE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rNSE(sim=lsim, obs=lobs)

##################
# Example 6: rNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rNSE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rNSE(sim=lsim, obs=lobs)

##################
# Example 7: rNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rNSE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rNSE(sim=lsim, obs=lobs)

##################
# Example 8: rNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rNSE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rNSE(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='rPearson'>
Pearson correlation coefficient
</h2><span id='topic+rPearson'></span><span id='topic+rPearson.default'></span><span id='topic+rPearson.matrix'></span><span id='topic+rPearson.data.frame'></span><span id='topic+rPearson.zoo'></span>

<h3>Description</h3>

<p>Pearson correlation coefficient between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rPearson(sim, obs, ...)

## Default S3 method:
rPearson(sim, obs, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
rPearson(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
rPearson(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
rPearson(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rPearson_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rPearson_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rPearson_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rPearson_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rPearson_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rPearson_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="rPearson_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>numeric value to be added to both <code>sim</code> and <code>obs</code> when <code>epsilon.type="otherValue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a wrapper to the <code><a href="stats.html#topic+cor">cor</a></code> function.
</p>
<p>The Pearson correlation coefficient (PCC) is a correlation coefficient that measures linear correlation between two sets of data. <br />
</p>
<p>It is the ratio between the covariance of two variables and the product of their standard deviations; thus, it is essentially a normalized measurement of the covariance, such that the result always has a value between -1 and 1. 
As with covariance itself, the measure can only reflect a linear correlation of variables, and ignores many other types of relationships or correlations. <br />
</p>
<p>The correlation coefficient ranges from -1 to 1. An absolute value of exactly 1 implies that a linear equation describes the relationship between <code>sim</code> and <code>obs</code> perfectly, with all data points lying on a line. 
The correlation sign is determined by the regression slope: a value of +1 implies that all data points lie on a line for which <code>sim</code>  increases as <code>obs</code>  increases, and vice versa for -1.
A value of 0 implies that there is no linear dependency between the variables.
</p>


<h3>Value</h3>

<p>Pearson correlation coefficient between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the Pearson correlation coefficient between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">https://en.wikipedia.org/wiki/Pearson_correlation_coefficient</a>
</p>
<p><cite>Pearson, K. (1920). Notes on the history of correlation. Biometrika, 13(1), 25-45. doi:10.2307/2331722</cite>
</p>
<p><cite>Schober, P., Boer, C., Schwarte, L. A. (2018). Correlation coefficients: appropriate use and interpretation. Anesthesia and Analgesia, 126(5), 1763-1768. doi:10.1213/ANE.0000000000002864</cite>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rPearson(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rPearson(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rPearson' for the "best" (unattainable) case
rPearson(sim=sim, obs=obs)

##################
# Example 3: rPearson for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rPearson(sim=sim, obs=obs)

##################
# Example 4: rPearson for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rPearson(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rPearson(sim=lsim, obs=lobs)

##################
# Example 5: rPearson for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rPearson(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rPearson(sim=lsim, obs=lobs)

##################
# Example 6: rPearson for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rPearson(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rPearson(sim=lsim, obs=lobs)

##################
# Example 7: rPearson for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rPearson(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rPearson(sim=lsim, obs=lobs)

##################
# Example 8: rPearson for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rPearson(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rPearson(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='rSD'>
Ratio of Standard Deviations
</h2><span id='topic+rSD'></span><span id='topic+rSD.default'></span><span id='topic+rSD.matrix'></span><span id='topic+rSD.data.frame'></span><span id='topic+rSD.zoo'></span>

<h3>Description</h3>

<p>Ratio of standard deviations between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSD(sim, obs, ...)

## Default S3 method:
rSD(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
rSD(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
rSD(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
rSD(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSD_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rSD_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rSD_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rSD_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rSD_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rSD_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="rSD_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> r_{SD} = \frac {sd_{sim}} {sd_{obs}}  </code>
</p>


<h3>Value</h3>

<p>Ratio of standard deviations between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the ratio of standard deviations between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="#topic+rsr">rsr</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rSD(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rSD(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rSD' for the "best" (unattainable) case
rSD(sim=sim, obs=obs)

##################
# Example 3: rSD for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rSD(sim=sim, obs=obs)

##################
# Example 4: rSD for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rSD(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rSD(sim=lsim, obs=lobs)

##################
# Example 5: rSD for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rSD(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rSD(sim=lsim, obs=lobs)

##################
# Example 6: rSD for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rSD(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rSD(sim=lsim, obs=lobs)

##################
# Example 7: rSD for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rSD(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rSD(sim=lsim, obs=lobs)

##################
# Example 8: rSD for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rSD(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rSD(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='rSpearman'>
Spearman's rank correlation coefficient
</h2><span id='topic+rSpearman'></span><span id='topic+rSpearman.default'></span><span id='topic+rSpearman.matrix'></span><span id='topic+rSpearman.data.frame'></span><span id='topic+rSpearman.zoo'></span>

<h3>Description</h3>

<p>Spearman's rank correlation coefficient between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSpearman(sim, obs, ...)

## Default S3 method:
rSpearman(sim, obs, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
rSpearman(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
rSpearman(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
rSpearman(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSpearman_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rSpearman_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rSpearman_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rSpearman_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rSpearman_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rSpearman_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="rSpearman_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>numeric value to be added to both <code>sim</code> and <code>obs</code> when <code>epsilon.type="otherValue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a wrapper to the <code><a href="stats.html#topic+cor">cor</a></code> function.
</p>
<p>The Spearman's rank correlation coefficient is a nonparametric measure of rank correlation (statistical dependence between the rankings of two variables). <br />
</p>
<p>It assesses how well the relationship between two variables can be described using a monotonic function. <br />
</p>
<p>The Spearman correlation between two variables is equal to the Pearson correlation between the rank values of those two variables.
However, while Pearson's correlation assesses linear relationships, Spearman's correlation assesses monotonic relationships (whether linear or not). <br />
</p>
<p>If there are no repeated data values, a perfect Spearman correlation of +1 or -1 occurs when each of the variables is a perfect monotone function of the other.
</p>


<h3>Value</h3>

<p>Spearman's rank correlation coefficient between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the Spearman's rank correlation coefficient between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient">https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient</a>
</p>
<p><cite>Spearman, C. (1961). The Proof and Measurement of Association Between Two Things. In J. J. Jenkins and D. G. Paterson (Eds.), Studies in individual differences: The search for intelligence (pp. 45-58). Appleton-Century-Crofts. doi:10.1037/11491-005</cite>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rSpearman(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rSpearman(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rSpearman' for the "best" (unattainable) case
rSpearman(sim=sim, obs=obs)

##################
# Example 3: rSpearman for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rSpearman(sim=sim, obs=obs)

##################
# Example 4: rSpearman for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rSpearman(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rSpearman(sim=lsim, obs=lobs)

##################
# Example 5: rSpearman for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rSpearman(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rSpearman(sim=lsim, obs=lobs)

##################
# Example 6: rSpearman for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rSpearman(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rSpearman(sim=lsim, obs=lobs)

##################
# Example 7: rSpearman for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rSpearman(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rSpearman(sim=lsim, obs=lobs)

##################
# Example 8: rSpearman for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rSpearman(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rSpearman(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='rsr'>
Ratio of RMSE to the standard deviation of the observations
</h2><span id='topic+rsr'></span><span id='topic+rsr.default'></span><span id='topic+rsr.matrix'></span><span id='topic+rsr.data.frame'></span><span id='topic+rsr.zoo'></span>

<h3>Description</h3>

<p>Ratio of the RMSE between simulated and observed values to the standard deviation of the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsr(sim, obs, ...)

## Default S3 method:
rsr(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
rsr(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
rsr(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
rsr(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsr_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="rsr_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="rsr_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="rsr_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="rsr_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="rsr_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="rsr_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ratio of RMSE to the standard deviation of the observations. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the RSR between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Moriasi, D.N., Arnold, J.G., Van Liew, M.W., Bingner, R.L., Harmel, R.D., Veith, T.L. 2007. Model evaluation guidelines for systematic quantification of accuracy in watershed simulations. Transactions of the ASABE. 50(3):885-900</cite>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="#topic+rSD">rSD</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
rsr(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
rsr(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rsr' for the "best" (unattainable) case
rsr(sim=sim, obs=obs)

##################
# Example 3: rsr for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

rsr(sim=sim, obs=obs)

##################
# Example 4: rsr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

rsr(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
rsr(sim=lsim, obs=lobs)

##################
# Example 5: rsr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

rsr(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rsr(sim=lsim, obs=lobs)

##################
# Example 6: rsr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
rsr(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rsr(sim=lsim, obs=lobs)

##################
# Example 7: rsr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
rsr(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
rsr(sim=lsim, obs=lobs)

##################
# Example 8: rsr for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

rsr(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
rsr(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='sKGE'>
Split Kling-Gupta Efficiency
</h2><span id='topic+sKGE'></span><span id='topic+sKGE.default'></span><span id='topic+sKGE.matrix'></span><span id='topic+sKGE.data.frame'></span><span id='topic+sKGE.zoo'></span>

<h3>Description</h3>

<p>Split Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>.
</p>
<p>This goodness-of-fit measure was developed by Fowler et al. (2018), as a modification to the original Kling-Gupta efficiency (KGE) proposed by Gupta et al. (2009). See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sKGE(sim, obs, ...)

## Default S3 method:
sKGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"),
              start.month=1, out.PerYear=FALSE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'data.frame'
sKGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"),
              start.month=1, out.PerYear=FALSE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'matrix'
sKGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"),
              start.month=1, out.PerYear=FALSE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)
             
## S3 method for class 'zoo'
sKGE(sim, obs, s=c(1,1,1), na.rm=TRUE, method=c("2009", "2012"),
              start.month=1, out.PerYear=FALSE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sKGE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_s">s</code></td>
<td>

<p>numeric of length 3, representing the scaling factors to be used for re-scaling the criteria space before computing the Euclidean distance from the ideal point c(1,1,1), i.e., <code>s</code> elements are used for adjusting the emphasis on different components.
The first elements is used for rescaling the Pearson product-moment correlation coefficient (<code>r</code>), the second element is used for rescaling <code>Alpha</code> and the third element is used for re-scaling <code>Beta</code>
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_method">method</code></td>
<td>

<p>character, indicating the formula used to compute the variability ratio in the Kling-Gupta efficiency. Valid values are:
</p>
<p>-) <kbd>2009</kbd>: the variability is defined as &lsquo;Alpha&rsquo;, the ratio of the standard deviation of <code>sim</code> values to the standard deviation of <code>obs</code>. This is the default option. See Gupta et al. (2009).
</p>
<p>-) <kbd>2012</kbd>: the variability is defined as &lsquo;Gamma&rsquo;, the ratio of the coefficient of variation of <code>sim</code> values to the coefficient of variation of <code>obs</code>. See Kling et al. (2012). 
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_start.month">start.month</code></td>
<td>

<p>[OPTIONAL]. Only used when the (hydrological) year of interest is different from the calendar year.
</p>
<p>numeric in [1:12] indicating the starting month of the (hydrological) year. Numeric values in [1, 12] represent months in [January, December]. By default <code>start.month=1</code>.
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_out.peryear">out.PerYear</code></td>
<td>

<p>logical, indicating the whether the output of the function has to include the Kling-Gupta efficiencies obtained for the individual years in <code>sim</code> and <code>obs</code> or not.
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="sKGE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Garcia et al. (2017) tested different objective functions and found that the mean value of the KGE applied to the streamflows (i.e., KGE(Q)) and the KGE applied to the inverse of the streamflows (i.e., KGE(1/Q) is able to provide a an aceptable representation of low-flow indices important for water management. They also found that KGE applied to a transformation of streamflow values (e.g., log)  is inadequate to capture low-flow indices important for water management. <br />
</p>
<p>The robustness of their findings depends more on the climate variability rather than the objective function, and they are insensitive to the hydrological model used in the evaluation.<br />
</p>
<p>Traditional Kling-Gupta efficiencies (Gupta et al., 2009; Kling et al., 2012) range from -Inf to 1 and, therefore, KGElf should also range from -Inf to 1. Essentially, the closer to 1, the more similar <code>sim</code> and <code>obs</code> are. <br />
</p>
<p>Knoben et al. (2019) showed that traditional Kling-Gupta (Gupta et al., 2009; Kling et al., 2012) values greater than -0.41 indicate that a model improves upon the mean flow benchmark, even if the model's KGE value is negative.
</p>


<h3>Value</h3>

<p>If <code>out.PerYear=FALSE</code>: numeric with the Split Kling-Gupta efficiency between <code>sim</code> and <code>obs</code>. If <code>sim</code> and <code>obs</code> are matrices, the output value is a vector, with the Split Kling-Gupta efficiency between each column of <code>sim</code> and <code>obs</code>
</p>
<p>If <code>out.PerYear=FALSE</code>: a list of two elements:
</p>
<table>
<tr><td><code>sKGE.value</code></td>
<td>

<p>numeric with the Split Kling-Gupta efficiency. If <code>sim</code> and <code>obs</code> are matrices, the output value is a vector, with the Split Kling-Gupta efficiency between each column of <code>sim</code> and <code>obs</code>
</p>
</td></tr>
<tr><td><code>KGE.PerYear</code></td>
<td>

<p>numeric with the Kling-Gupta efficincies obtained for the individual years in <code>sim</code> and <code>obs</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano-Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Fowler, K.; Coxon, G.; Freer, J.; Peel, M.; Wagener, T.; Western, A.; Woods, R.; Zhang, L. (2018). Simulating runoff under changing climatic conditions: A framework for model improvement. Water Resources Research, 54(12), 812-9832. doi:10.1029/2018WR023989.</cite>
</p>
<p><cite>Gupta, H. V.; Kling, H.; Yilmaz, K. K.; Martinez, G. F. (2009). Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of hydrology, 377(1-2), 80-91. doi:10.1016/j.jhydrol.2009.08.003.</cite>
</p>
<p><cite>Kling, H.; Fuchs, M.; Paulin, M. (2012). Runoff conditions in the upper Danube basin under an ensemble of climate change scenarios. Journal of Hydrology, 424, 264-277, doi:10.1016/j.jhydrol.2012.01.011.</cite>
</p>
<p><cite>Pushpalatha, R., Perrin, C., Le Moine, N. and Andreassian, V. (2012). A review of efficiency criteria suitable for evaluating low-flow simulations. Journal of Hydrology, 420, 171-182. doi:10.1016/j.jhydrol.2011.11.055.</cite>
</p>
<p><cite>Pfannerstill, M.; Guse, B.; Fohrer, N. (2014). Smart low flow signature metrics for an improved overall performance evaluation of hydrological models. Journal of Hydrology, 510, 447-458. doi:10.1016/j.jhydrol.2013.12.044.</cite> 
</p>
<p><cite>Santos, L.; Thirel, G.; Perrin, C. (2018). Pitfalls in using log-transformed flows within the sKGE criterion. doi:10.5194/hess-22-4583-2018</cite>
</p>
<p><cite>Knoben, W. J.; Freer, J. E.; Woods, R. A. (2019). Inherent benchmark or not? Comparing Nash-Sutcliffe and Kling-Gupta efficiency scores. Hydrology and Earth System Sciences, 23(10), 4323-4331. doi:10.5194/hess-23-4323-2019.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+KGElf">KGElf</a></code>, <code><a href="#topic+KGEnp">KGEnp</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: Looking at the difference between 'method=2009' and 'method=2012'
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Simulated daily time series, initially equal to twice the observed values
sim &lt;- 2*obs 

# KGE 2009
KGE(sim=sim, obs=obs, method="2009", out.type="full")

# KGE 2012
KGE(sim=sim, obs=obs, method="2012", out.type="full")

# sKGE (Garcia et al., 2017):
sKGE(sim=sim, obs=obs, method="2012")

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'sKGE' for the "best" (unattainable) case
sKGE(sim=sim, obs=obs)

##################
# Example 3: sKGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

sKGE(sim=sim, obs=obs)

##################
# Example 4: sKGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

sKGE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
sKGE(sim=lsim, obs=lobs)

##################
# Example 5: sKGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

sKGE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
sKGE(sim=lsim, obs=lobs)

##################
# Example 6: sKGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
sKGE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
sKGE(sim=lsim, obs=lobs)

##################
# Example 7: sKGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
sKGE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
sKGE(sim=lsim, obs=lobs)

##################
# Example 8: sKGE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

sKGE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
sKGE(sim=sim1, obs=obs1)

</code></pre>

<hr>
<h2 id='ssq'>
Sum of the Squared Residuals
</h2><span id='topic+ssq'></span><span id='topic+ssq.default'></span><span id='topic+ssq.matrix'></span><span id='topic+ssq.data.frame'></span><span id='topic+ssq.zoo'></span>

<h3>Description</h3>

<p>Sum of the Squared Residuals between <code>sim</code> and <code>obs</code>, with treatment of missing values. Its units are the squared measurement units of <code>sim</code> and <code>obs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssq(sim, obs, ...)

## Default S3 method:
ssq(sim, obs, na.rm = TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
ssq(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
ssq(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
## S3 method for class 'zoo'
ssq(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssq_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="ssq_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="ssq_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="ssq_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="ssq_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="ssq_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="ssq_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> ssr = \sum_{i=1}^N { (S_i - O_i )^2 } </code>
</p>
 


<h3>Value</h3>

<p>Sum of the squared residuals between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the SSR between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+ubRMSE">ubRMSE</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- 1:10
sim &lt;- 1:10
ssq(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
ssq(sim, obs)

##################
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'rNSeff' for the "best" (unattainable) case
ssq(sim=sim, obs=obs)

# Randomly changing the first 2000 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:2000] &lt;- obs[1:2000] + rnorm(2000, mean=10)

# Computing the new 'rNSeff'
ssq(sim=sim, obs=obs)
</code></pre>

<hr>
<h2 id='ubRMSE'>
Unbiased Root Mean Square Error
</h2><span id='topic+ubRMSE'></span><span id='topic+ubRMSE.default'></span><span id='topic+ubRMSE.matrix'></span><span id='topic+ubRMSE.data.frame'></span><span id='topic+ubRMSE.zoo'></span>

<h3>Description</h3>

<p>unbiased Root Mean Square Error (ubRMSE) between <code>sim</code> and <code>obs</code>, in the same units of <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
</p>
<p>ubRMSE was introduced by Entekhabi et al. (2010) to improve the evaluation of the temporal dynamic of volumentric soil moisture, by removing from the traditional RMSE the mean bias error caused by the mistmatch  between the spatial representativeness of in situ soil moisture and the corresponding gridded values. <br /> 
</p>
<p>A smaller value indicates better model performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ubRMSE(sim, obs, ...)

## Default S3 method:
ubRMSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'data.frame'
ubRMSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'matrix'
ubRMSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)

## S3 method for class 'zoo'
ubRMSE(sim, obs, na.rm=TRUE, fun=NULL, ...,
              epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
              epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ubRMSE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="ubRMSE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="ubRMSE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="ubRMSE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the Root Mean Square Error.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="ubRMSE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="ubRMSE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="ubRMSE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>numeric value to be added to both <code>sim</code> and <code>obs</code> when <code>epsilon.type="otherValue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The traditional root mean square error (RMSE) is severely compromised if there are biases in either the mean
or the amplitude of fluctuations of the simulated values. If it can be estimated reliably, the
mean-bias (BIAS) can easily be removed from RMSE, leading to the unbiased RMSE:
</p>
<p style="text-align: center;"><code class="reqn"> ubRMSE = \sqrt{ RMSE^2 - BIAS^2 } </code>
</p>
 


<h3>Value</h3>

<p>Unbiased Root mean square error (ubRMSE) between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes or data.frames, the returned value is a vector, with the ubRMSE between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Entekhabi, D., Reichle, R. H., Koster, R. D., &amp; Crow, W. T. (2010). Performance metrics for soil moisture retrievals and application requirements. Journal of Hydrometeorology, 11(3), 832-840. doi: 10.1175/2010JHM1223.1</cite> <br />
</p>
<p><cite>Ling, X., Huang, Y., Guo, W., Wang, Y., Chen, C., Qiu, B., Ge, J., Qin, K., Xue, Y., Peng, J. (2021). Comprehensive evaluation of satellite-based and reanalysis soil moisture products using in situ observations over China. Hydrology and Earth System Sciences, 25(7), 4209-4229. doi:10.5194/hess-25-4209-2021</cite> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbias">pbias</a></code>, <code><a href="#topic+pbiasfdc">pbiasfdc</a></code>, <code><a href="#topic+mae">mae</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+rmse">rmse</a></code>, <code><a href="#topic+nrmse">nrmse</a></code>, <code><a href="#topic+ssq">ssq</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
ubRMSE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
ubRMSE(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'ubRMSE' for the "best" (unattainable) case
ubRMSE(sim=sim, obs=obs)

##################
# Example 3: ubRMSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

ubRMSE(sim=sim, obs=obs)

##################
# Example 4: ubRMSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

ubRMSE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
ubRMSE(sim=lsim, obs=lobs)

##################
# Example 5: ubRMSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

ubRMSE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
ubRMSE(sim=lsim, obs=lobs)

##################
# Example 6: ubRMSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
ubRMSE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
ubRMSE(sim=lsim, obs=lobs)

##################
# Example 7: ubRMSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
ubRMSE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
ubRMSE(sim=lsim, obs=lobs)

##################
# Example 8: ubRMSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

ubRMSE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
ubRMSE(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='valindex'>
Valid Indexes
</h2><span id='topic+valindex'></span><span id='topic+valindex.default'></span><span id='topic+valindex.matrix'></span>

<h3>Description</h3>

<p>Identify the indexes that are simultaneously valid (not missing) in <code>sim</code> and <code>obs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valindex(sim, obs, ...)

## Default S3 method:
valindex(sim, obs, ...)

## S3 method for class 'matrix'
valindex(sim, obs, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valindex_+3A_sim">sim</code></td>
<td>

<p>zoo, xts, numeric, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="valindex_+3A_obs">obs</code></td>
<td>

<p>zoo, xts, numeric, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="valindex_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the indexes that are simultaneously valid (not missing) in <code>obs</code> and <code>sim</code>.
</p>


<h3>Note</h3>

<p>This function is used in the functions of this package for removing missing values from the observed and simulated time series.
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mauricio.zambrano@ing.unitn.it&gt;
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+is.na">is.na</a></code>, <code><a href="base.html#topic+which">which</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- 1:5
obs &lt;- c(1, NA, 3, NA, 5)
valindex(sim, obs)

</code></pre>

<hr>
<h2 id='ve'>
Volumetric Efficiency
</h2><span id='topic+VE'></span><span id='topic+VE.default'></span><span id='topic+VE.matrix'></span><span id='topic+VE.data.frame'></span><span id='topic+VE.zoo'></span>

<h3>Description</h3>

<p>Volumetric efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VE(sim, obs, ...)

## Default S3 method:
VE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'data.frame'
VE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'matrix'
VE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)

## S3 method for class 'zoo'
VE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
            epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
            epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ve_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="ve_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="ve_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="ve_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing this goodness-of-fit index.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="ve_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="ve_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the the mean observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="ve_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> VE = 1 -\frac { \sum_{i=1}^N { \left| S_i - O_i \right| } } { \sum_{i=1}^N { \left( O_i \right) } }  </code>
</p>

<p>Volumetric efficiency was proposed in order to circumvent some problems associated to the Nash-Sutcliffe efficiency. It ranges from 0 to 1 and represents the fraction of water delivered at the proper time; its compliment represents the fractional volumetric mistmach (Criss and Winston, 2008).
</p>


<h3>Value</h3>

<p>Volumetric efficiency between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the Volumetric efficiency between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> have to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation
</p>


<h3>Author(s)</h3>

<p>Mauricio Zambrano Bigiarini &lt;mzb.devel@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Criss, R. E. and Winston, W. E. (2008), Do Nash values have value? Discussion and alternate proposals. Hydrological Processes, 22: 2723-2725. doi: 10.1002/hyp.7072</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>, <code><a href="#topic+NSE">NSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
VE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
VE(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'VE' for the "best" (unattainable) case
VE(sim=sim, obs=obs)

##################
# Example 3: VE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

VE(sim=sim, obs=obs)

##################
# Example 4: VE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

VE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
VE(sim=lsim, obs=lobs)

##################
# Example 5: VE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

VE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
VE(sim=lsim, obs=lobs)

##################
# Example 6: VE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
VE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
VE(sim=lsim, obs=lobs)

##################
# Example 7: VE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
VE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
VE(sim=lsim, obs=lobs)

##################
# Example 8: VE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

VE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
VE(sim=sim1, obs=obs1)
</code></pre>

<hr>
<h2 id='wNSE'>
Weighted Nash-Sutcliffe efficiency
</h2><span id='topic+wNSE'></span><span id='topic+wNSE.default'></span><span id='topic+wNSE.matrix'></span><span id='topic+wNSE.data.frame'></span><span id='topic+wNSE.zoo'></span>

<h3>Description</h3>

<p>Weighted Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>, with treatment of missing values. <br />
</p>
<p>This goodness-of-fit measure was proposed by Hundecha and Bardossy (2004) to put special focus on high values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wNSE(sim, obs, ...)

## Default S3 method:
wNSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'data.frame'
wNSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'matrix'
wNSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)

## S3 method for class 'zoo'
wNSE(sim, obs, na.rm=TRUE, fun=NULL, ..., 
             epsilon.type=c("none", "Pushpalatha2012", "otherFactor", "otherValue"), 
             epsilon.value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wNSE_+3A_sim">sim</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with simulated values
</p>
</td></tr>
<tr><td><code id="wNSE_+3A_obs">obs</code></td>
<td>

<p>numeric, zoo, matrix or data.frame with observed values
</p>
</td></tr>
<tr><td><code id="wNSE_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical value indicating whether 'NA' should be stripped before the computation proceeds. <br />
When an 'NA' value is found at the i-th position in <code>obs</code> <b>OR</b> <code>sim</code>, the i-th value of <code>obs</code> <b>AND</b> <code>sim</code> are removed before the computation.
</p>
</td></tr>
<tr><td><code id="wNSE_+3A_fun">fun</code></td>
<td>

<p>function to be applied to <code>sim</code> and <code>obs</code> in order to obtain transformed values thereof before computing the weighted Nash-Sutcliffe efficiency.
</p>
<p>The first argument MUST BE a numeric vector with any name (e.g., <code>x</code>), and additional arguments are passed using <code>...</code>.
</p>
</td></tr>
<tr><td><code id="wNSE_+3A_...">...</code></td>
<td>

<p>arguments passed to <code>fun</code>, in addition to the mandatory first numeric vector.
</p>
</td></tr>
<tr><td><code id="wNSE_+3A_epsilon.type">epsilon.type</code></td>
<td>

<p>argument used to define a numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>FUN</code>. 
</p>
<p>It is was  designed to allow the use of logarithm and other similar functions that do not work with zero values.
</p>
<p>Valid values of <code>epsilon.type</code> are:
</p>
<p>1) <kbd>"none"</kbd>: <code>sim</code> and <code>obs</code> are used by <code>fun</code> without the addition of any numeric value. This is the default option.
</p>
<p>2) <kbd>"Pushpalatha2012"</kbd>: one hundredth (1/100) of the mean observed values is added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>, as described in Pushpalatha et al. (2012). 
</p>
<p>3) <kbd>"otherFactor"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
<p>4) <kbd>"otherValue"</kbd>: the numeric value defined in the <code>epsilon.value</code> argument is directly added to both <code>sim</code> and <code>obs</code>, before applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="wNSE_+3A_epsilon.value">epsilon.value</code></td>
<td>

<p>-) when <code>epsilon.type="otherValue"</code> it represents the numeric value to be added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>. <br />
-) when <code>epsilon.type="otherFactor"</code> it represents the numeric factor used to multiply the mean of the observed values, instead of the one hundredth (1/100) described in Pushpalatha et al. (2012). The resulting value is then added to both <code>sim</code> and <code>obs</code> before applying <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> wNSE = 1 -\frac { \sum_{i=1}^N  O_i * ( S_i - O_i )^2 } { \sum_{i=1}^N  O_i * (  O_i - \bar{O}  )^2 } </code>
</p>
 


<h3>Value</h3>

<p>Weighted Nash-Sutcliffe efficiency between <code>sim</code> and <code>obs</code>. <br />
</p>
<p>If <code>sim</code> and <code>obs</code> are matrixes, the returned value is a vector, with the relative Nash-Sutcliffe efficiency between each column of <code>sim</code> and <code>obs</code>.
</p>


<h3>Note</h3>

<p><code>obs</code> and <code>sim</code> has to have the same length/dimension <br />
</p>
<p>The missing values in <code>obs</code> and <code>sim</code> are removed before the computation proceeds, and only those positions with non-missing values in <code>obs</code> and <code>sim</code> are considered in the computation <br />
</p>
<p>If some of the observed values are equal to zero (at least one of them), this index can not be computed.
</p>


<h3>Author(s)</h3>

<p>sluedtke (github user)
</p>


<h3>References</h3>

<p><cite>Nash, J.E. and J.V. Sutcliffe, River flow forecasting through conceptual models. Part 1: A discussion of principles, J. Hydrol. 10 (1970), pp. 282-290. doi:10.1016/0022-1694(70)90255-6</cite> <br />
</p>
<p><cite>Hundecha, Y., Bardossy, A. (2004). Modeling of the effect of land use changes on the runoff generation of a river basin through parameter regionalization of a watershed model. Journal of hydrology, 292(1-4), 281-295. doi:10.1016/j.jhydrol.2004.01.002</cite> <br />
</p>
<p><cite>Hundecha, Y., Ouarda, T. B., Bardossy, A. (2008). Regional estimation of parameters of a rainfall-runoff model at ungauged watersheds using the 'spatial' structures of the parameters within a canonical physiographic-climatic space. Water Resources Research, 44(1). doi:10.1029/2006WR005439</cite> <br />
</p>
<p><cite>Hundecha, Y. and Merz, B. (2012), Exploring the Relationship between Changes in Climate and Floods Using a Model-Based Analysis, Water Resour. Res., 48(4), 1-21, doi:10.1029/2011WR010527</cite>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NSE">NSE</a></code>, <code><a href="#topic+rNSE">rNSE</a></code>, <code><a href="#topic+mNSE">mNSE</a></code>, <code><a href="#topic+KGE">KGE</a></code>, <code><a href="#topic+gof">gof</a></code>, <code><a href="#topic+ggof">ggof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################
# Example 1: basic ideal case
obs &lt;- 1:10
sim &lt;- 1:10
wNSE(sim, obs)

obs &lt;- 1:10
sim &lt;- 2:11
wNSE(sim, obs)

##################
# Example 2: 
# Loading daily streamflows of the Ega River (Spain), from 1961 to 1970
data(EgaEnEstellaQts)
obs &lt;- EgaEnEstellaQts

# Generating a simulated daily time series, initially equal to the observed series
sim &lt;- obs 

# Computing the 'wNSE' for the "best" (unattainable) case
wNSE(sim=sim, obs=obs)

##################
# Example 3: wNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values. 
#            This random noise has more relative importance for ow flows than 
#            for medium and high flows.
  
# Randomly changing the first 1826 elements of 'sim', by using a normal distribution 
# with mean 10 and standard deviation equal to 1 (default of 'rnorm').
sim[1:1826] &lt;- obs[1:1826] + rnorm(1826, mean=10)
ggof(sim, obs)

wNSE(sim=sim, obs=obs)

##################
# Example 4: wNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' during computations.

wNSE(sim=sim, obs=obs, fun=log)

# Verifying the previous value:
lsim &lt;- log(sim)
lobs &lt;- log(obs)
wNSE(sim=lsim, obs=lobs)

##################
# Example 5: wNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding the Pushpalatha2012 constant
#            during computations

wNSE(sim=sim, obs=obs, fun=log, epsilon.type="Pushpalatha2012")

# Verifying the previous value, with the epsilon value following Pushpalatha2012
eps  &lt;- mean(obs, na.rm=TRUE)/100
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
wNSE(sim=lsim, obs=lobs)

##################
# Example 6: wNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and adding a user-defined constant
#            during computations

eps &lt;- 0.01
wNSE(sim=sim, obs=obs, fun=log, epsilon.type="otherValue", epsilon.value=eps)

# Verifying the previous value:
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
wNSE(sim=lsim, obs=lobs)

##################
# Example 7: wNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying (natural) 
#            logarithm to 'sim' and 'obs' and using a user-defined factor
#            to multiply the mean of the observed values to obtain the constant
#            to be added to 'sim' and 'obs' during computations

fact &lt;- 1/50
wNSE(sim=sim, obs=obs, fun=log, epsilon.type="otherFactor", epsilon.value=fact)

# Verifying the previous value:
eps  &lt;- fact*mean(obs, na.rm=TRUE)
lsim &lt;- log(sim+eps)
lobs &lt;- log(obs+eps)
wNSE(sim=lsim, obs=lobs)

##################
# Example 8: wNSE for simulated values equal to observations plus random noise 
#            on the first half of the observed values and applying a 
#            user-defined function to 'sim' and 'obs' during computations

fun1 &lt;- function(x) {sqrt(x+1)}

wNSE(sim=sim, obs=obs, fun=fun1)

# Verifying the previous value, with the epsilon value following Pushpalatha2012
sim1 &lt;- sqrt(sim+1)
obs1 &lt;- sqrt(obs+1)
wNSE(sim=sim1, obs=obs1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
