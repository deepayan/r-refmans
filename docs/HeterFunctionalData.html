<!DOCTYPE html><html lang="en"><head><title>Help for package HeterFunctionalData</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HeterFunctionalData}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CF'><p>Classical F test for mixed effects model</p></a></li>
<li><a href='#cov_squared_jackknife'><p>Jackknife estimate of the squared covariance between two time points</p></a></li>
<li><a href='#dataformat_wide_to_long'><p>Convert data from wide format to long format</p></a></li>
<li><a href='#eu'><p>A function to calaculate cell residues.</p></a></li>
<li><a href='#fun.sigijj12'><p>Unbiased estimate of  $sigma_ijj1^2$</p></a></li>
<li><a href='#Heter.test'><p>Heteroscedastic test for functional data</p></a></li>
<li><a href='#NorRanGen'><p>Generate a vector of random effects with specific correlation structure and given variance</p></a></li>
<li><a href='#sigma4'><p>Unbiased estimate of squared variance $sigma^4$ based on U-statistic of an i.i.d. sample</p></a></li>
<li><a href='#sigma4bootstrap'><p>Bootstrap estimate of $sigma^4$ using an i.i.d. sample</p></a></li>
<li><a href='#sigma4jackknife'><p>Jackknife estimate of $sigma^4$ using an i.i.d. sample</p></a></li>
<li><a href='#taufun'><p>An intermediate function to calculate the partial sums</p></a></li>
<li><a href='#tcontrast'><p>Test of no contrast effect of the treatments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Test of No Main and/or Interaction Effects in Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Haiyan Wang, Mickael Akritas, James Higgins, Dale Blasi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haiyan Wang &lt;hwang@ksu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Distribution free heteroscedastic tests for functional data. 
    The following tests are included in this package: test of no main treatment or contrast
    effect and no simple treatment effect given in 
    Wang, Higgins, and Blasi (2010) &lt;<a href="https://doi.org/10.1016%2Fj.spl.2009.11.016">doi:10.1016/j.spl.2009.11.016</a>&gt;,
    no main time effect, and no interaction effect based on 
    original observations given in Wang and Akritas (2010a) 
    &lt;<a href="https://doi.org/10.1080%2F10485250903171621">doi:10.1080/10485250903171621</a>&gt;
    and tests based on ranks given in Wang and Akritas (2010b)
    &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2010.03.012">doi:10.1016/j.jmva.2010.03.012</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-12 15:19:44 UTC; hwang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-20 09:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CF'>Classical F test for mixed effects model</h2><span id='topic+CF'></span>

<h3>Description</h3>

<p>#' This function conducts the test of main effect of treatment, interaction effect of treatment and time,  main effect of time,
and simple effect of treament based on mixed effects models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CF(data, a, b, mn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CF_+3A_data">data</code></td>
<td>
<p>The data in long format (see the example in function  dataformat_wide_to_long( )).</p>
</td></tr>
<tr><td><code id="CF_+3A_a">a</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="CF_+3A_b">b</code></td>
<td>
<p>The number of time points or repeated measurements per subject.</p>
</td></tr>
<tr><td><code id="CF_+3A_mn">mn</code></td>
<td>
<p>The vector of sample sizes in treatments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of p-values from mixed effect model for the test of no main
treatment effect (palpha), test of no main time effect (pbeta),
test of no interaction effect between treatment and time (pgamma),
and test of no simple effect of treatment (pphi).
</p>

<hr>
<h2 id='cov_squared_jackknife'>Jackknife estimate of the squared covariance between two time points</h2><span id='topic+cov_squared_jackknife'></span>

<h3>Description</h3>

<p>This function provides the Jackknife estimate of the squared
covariance using i.i.d. obervations from one variable given in vector <code>x</code>
and i.i.d. observations from a second variable given in vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_squared_jackknife(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_squared_jackknife_+3A_x">x</code></td>
<td>
<p>a vector of i.i.d. observations</p>
</td></tr>
<tr><td><code id="cov_squared_jackknife_+3A_y">y</code></td>
<td>
<p>a second vector of i.i.d. observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jackknife estimate of the squared covariance
</p>

<hr>
<h2 id='dataformat_wide_to_long'>Convert data from wide format to long format</h2><span id='topic+dataformat_wide_to_long'></span>

<h3>Description</h3>

<p>The function dataformat_wide_to_long() takes data in wide format (see the example) and convert to long format so that it will be ready for function Heter.test().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataformat_wide_to_long(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataformat_wide_to_long_+3A_data">data</code></td>
<td>
<p>The data stored in wide format. The first column is the index for subject (named as sub).
The second column is index for treatment (named as trt). The remaining columns are named time1, time2, etc. See the example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data in long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of data in wide format
# sub trt      time1          time2         time3           time4         time5
 # 1   1  2.4644642  1.7233498 -1.1374695 -0.5242729 -2.379145
 # 2   1  2.5746848  1.0181738 -0.8325308 -2.4873067 -3.463602
 # 3   1  2.5813995 -0.7528324 -3.1457645 -3.3135573 -4.364621
 # 4   1  0.8232141  0.2394987 -2.2073150 -3.3583005 -6.073399
 # 5   1  0.8274860  0.8323298 -2.1028060 -2.6015848 -3.291307
 # 1   2 -2.2217084  0.6779049  3.6310542  3.2052691  4.310316
 # 2   2 -3.3954705 -0.7827040  3.1364749  3.7184895  5.118996
 #
 # Data stored in long format
 # x_{ijk}, k=1, ..., n_i are the kth observation from the ith subject at time j.
 # 1 1 1 x111
 # 1 1 2 x112
 # 1 2 1 x121
 # 1 2 2 x122
 # 1 2 3 x123

 #  The following example generate a data set that contains data from
 # 3 treatments, with 3 subjects in treatment 1, 3 subjects in treatment 2,
 # and 4 subjects in treatment 3. Each subject contains m=50
 # repeated observations from Poisson distribution. For the 1st treatment,
 # the mean vector of the repeated observations from the same subject is
 # equal to mu1 plus a random effect vector generated by NorRanGen( ).
 # The m is the number of repeated measurements per subject.
 f1&lt;-function(m, mu1, raneff) {
     currentmu=mu1+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
 f2&lt;-function(m, mu2, raneff) {
     currentmu=mu2+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
 f3&lt;- function(m, mu3, raneff){
     currentmu=mu3+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}

 # The a is the number of treatments. The mn stores the number of subjects in treatments.
 a=3;  mn=c(3, 3, 4); mu1=3; mu2=3; mu3=3; m=50
 raneff=NorRanGen(m) # generate random effects with AR(1) structure.

 # Generate data and store in wide format.
datawide=numeric()
now=0
for (i in 1:a){
   fi=function(x1, x2) f1(m,x1, x2)*(i==1)+f2(m,x1, x2)*(i==2)+f3(m, x1, x2)*(i==3)
   mu=mu1*(i==1)+mu2*(i==2)+mu3*(i==3)
   for (k in 1:mn[i]){
          now=now+1
          datawide&lt;-rbind(datawide, c(k, i, fi(mu, raneff) )   	)
          colnames(datawide)=c("sub", "trt", paste("time", seq(m), sep=""))
          #this is a typical way to store data in practice
    }
 } #end of j

 dat=dataformat_wide_to_long(datawide)
</code></pre>

<hr>
<h2 id='eu'>A function to calaculate cell residues.</h2><span id='topic+eu'></span>

<h3>Description</h3>

<p>This function calcualtes the residual $x_ijk-barx_ij.$ for the kth replication from the ith group at jth time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eu(x, coln, Rij, Rik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eu_+3A_x">x</code></td>
<td>
<p>the data matrix in long format, whose first column gives the index i, 2nd columns given the index j, 3rd column gives the index k,
and the last column gives the observation $x_ijk$.
For given i and j,  $x_ijk, k=1, ..., n_ij$ are assumed to be i.i.d. from the same distribution.</p>
</td></tr>
<tr><td><code id="eu_+3A_coln">coln</code></td>
<td>
<p>takes value 4 or 5. If coln=4, the calculation uses original data;  if coln=5, the calculation uses rank. The  default value for coln is 5.</p>
</td></tr>
<tr><td><code id="eu_+3A_rij">Rij</code></td>
<td>
<p>is the mean of all observations in ith treatment at jth measurement calculated in other functions</p>
</td></tr>
<tr><td><code id="eu_+3A_rik">Rik</code></td>
<td>
<p>is the mean for the kth subject in ith treatment calculated in other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The residual to be used in Heter.test()
</p>

<hr>
<h2 id='fun.sigijj12'>Unbiased estimate of  $sigma_ijj1^2$</h2><span id='topic+fun.sigijj12'></span>

<h3>Description</h3>

<p>This function calculatess an unbiased estimate of  $sigma_ijj1^2$ using the u-statisitic of vectors
$x=(x_1, x_2, ..., x_ni)$ and  $y=(y_1, y_2, ..., y_ni)$,
where $X_j$ and $Y_j$ are correlated, but $X_j$ and $Y_j1$ are independent if $j ne j1$.
Note: $sum_k1 ne k2 ne k3 ne k4 (x_k1-x_k2))(y_k1-y_k2)) (x_k3-x_k4)) (y_k3-y_k4))$ is an
unbiased est. of  $4*ni*(ni-1)*(ni-2)*(ni-3) [E(X_ijk-mu_ij u_ij1k) ]^2$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.sigijj12(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fun.sigijj12_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="fun.sigijj12_+3A_y">y</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two variables sigmaijj12 and ssijj1 in it.
The sigmaijj12 variable gives an unbiased estimate of $sigma_ijj1^2$.
The ssijj1 variable gives an unbiased estimate of $sigma_ijj sigma_ij_1j_1$.
</p>

<hr>
<h2 id='Heter.test'>Heteroscedastic test for functional data</h2><span id='topic+Heter.test'></span>

<h3>Description</h3>

<p>This function conducts the test of main effect of treatment, interaction effect of treatment and time,  main effect of time,
and simple effect of treament based on original observations (see  Wang and Akritas 2010a) or ranks (see Wang and Akritas 2010b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Heter.test(
  data,
  a,
  b,
  mn,
  h = 0.45,
  method = "rank",
  Ca = cbind(as.vector(rep(1, a - 1)), -diag(a - 1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Heter.test_+3A_data">data</code></td>
<td>
<p>The data in long format (see the example in function  dataformat_wide_to_long( )).</p>
</td></tr>
<tr><td><code id="Heter.test_+3A_a">a</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="Heter.test_+3A_b">b</code></td>
<td>
<p>The number of time points or repeated measurements per subject.</p>
</td></tr>
<tr><td><code id="Heter.test_+3A_mn">mn</code></td>
<td>
<p>The vector of sample sizes in treatments.</p>
</td></tr>
<tr><td><code id="Heter.test_+3A_h">h</code></td>
<td>
<p>The h value used in the estimators in Proposition 3.3 of Wang and Akritas (2010a) and Theorem 3.2 of Wang, Higgins, and Blasi (2010).
The value of h should be in (0, 0.5) for the test of no main treatment effect
or contract effect of treatments. For other tests, h should be in (0, 1).
Recommend to use the default value h=0.45 as given in the function.
Note: If multiple values are provided to h as a vector, then the calculation
will be carried out for each h value, which results in multiple p-values
in the returned result for palpha, pbeta, pgamma, pphi.</p>
</td></tr>
<tr><td><code id="Heter.test_+3A_method">method</code></td>
<td>
<p>Specifying method='rank' to use rank test. For all other values, the test based on original data will be used.</p>
</td></tr>
<tr><td><code id="Heter.test_+3A_ca">Ca</code></td>
<td>
<p>Contrast matrix for the contrast effect of the treatments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of p-values for the test of no main
treatment effect (palpha), test of no main time effect (pbeta),
test of no interaction effect between treatment and time (pgamma),
and test of no simple effect of treatment (pphi). For each h value,
the p-values are in the same column.
</p>


<h3>References</h3>

<p>Haiyan Wang and Michael Akritas (2010a). Inference from heteroscedastic functional data, Journal of Nonparametric Statistics. 22:2, 149-168.
DOI: 10.1080/10485250903171621
</p>
<p>Haiyan Wang and Michael Akritas (2010b). Rank test for heteroscedastic functional data. Journal of Multivariate Analysis. 101: 1791-1805.
https://doi.org/10.1016/j.jmva.2010.03.012
</p>
<p>Haiyan Wang, James Higgins, and Dale Blasi (2010).  Distribution-Free
Tests For No Effect Of Treatment In Heteroscedastic Functional Data
Under Both Weak And Long Range Dependence. Statistics and Probability
Letters. 80: 390-402. Doi:10.1016/j.spl.2009.11.016
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data set that contains data from 3 treatments,
# with 3 subjects in treatment 1, 3 subjects in treatment 2,
# and 4 subjects in treatment 3. Each subject contains m=50
# repeated observations from Poisson distribution. For the 1st treatment,
# the mean vector of the repeated observations from the same subject is
# equal to mu1 plus a random effect vector generated by NorRanGen( ).
# The m is the number of repeated measurements per subject.
 f1&lt;-function(m, mu1, raneff) {
     currentmu=mu1+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
 f2&lt;-function(m, mu2, raneff) {
     currentmu=mu2+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
f3&lt;- function(m, mu3, raneff){
     currentmu=mu3+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
# The a is the number of treatments. The mn stores the number of subjects in treatments.
a=3;  mn=c(3, 3, 4); mu1=3; mu2=3; mu3=3; m=50
# Generate the time effects via random effects with AR(1) structure.
raneff=NorRanGen(m)
# Generate data and store in wide format.
datawide=numeric()
now=0
for (i in 1:a){
   fi=function(x1, x2) f1(m,x1, x2)*(i==1)+f2(m,x1, x2)*(i==2)+f3(m, x1, x2)*(i==3)
   mu=mu1*(i==1)+mu2*(i==2)+mu3*(i==3)
   for (k in 1:mn[i]){
       now=now+1
       datawide&lt;-rbind(datawide, c(k, i, fi(mu, raneff) )   	)
       colnames(datawide)=c("sub", "trt", paste("time", seq(m), sep=""))
       #this is a typical way to store data in practice
   }
} #end of j

# Note:There are different time effects since values in raneff vector are different
dat=dataformat_wide_to_long(datawide)   #dat is in long format
# Define the h value used in Proposition 3.3 of Wang and Akritas (2010a)
h=c(0.45, 0.49)
  #Note: The resulting palpha, pbeta, pgamma, pphi each contains
  #      two p-values, one corresponds to each h value
  #      (see Proposition 3.3 of Wang and Akritas (2010a))
# test based on original data.
(org= Heter.test(dat, a, m, mn, h, method='original') )
#test based on ranks
(rankt= Heter.test(dat, a, m, mn, h, method='rank') )


</code></pre>

<hr>
<h2 id='NorRanGen'>Generate a vector of random effects with specific correlation structure and given variance</h2><span id='topic+NorRanGen'></span>

<h3>Description</h3>

<p>Generate a vector of random effects that follow AR(1)
correlation structure with rho=exp(-1/m) and variances sigmaj being
given or andomly generated from uniform distribution on (1.2, 1.4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NorRanGen(m, sigmaj = stats::runif(m, 1.2, 1.4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NorRanGen_+3A_m">m</code></td>
<td>
<p>the length of the vector of the random effects</p>
</td></tr>
<tr><td><code id="NorRanGen_+3A_sigmaj">sigmaj</code></td>
<td>
<p>standard deviations for the random effect vector. Default is a vector from U(1.2, 1.4).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the random effect vector of length m
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   m=50;  raneff=NorRanGen(m)
# Note: If X ~ N(0, I), then tran X ~ N(0, A) with
# A being the cov matrix of AR(1), which contains the standard deviations sigma and the
# correlation coeff rho=exp(-1/m).
# i.e. corr= (1  rho  rho^2 ... rho^(m-1)
#             rho 1   rho   ... rho^(m-2)
#                 ...................
#             rho^(m-1) rho^(m-2) ... rho )
#
# To see the correlation values, run the following example
# j1=seq(25); cv=numeric()
# for (j in 1:25){
#  lag=abs(j1-j)/25; cv=rbind(cv, exp(-lag))
#}
# row.names(cv)=j1;  colnames(cv)=j1;  cv[1,]
</code></pre>

<hr>
<h2 id='sigma4'>Unbiased estimate of squared variance $sigma^4$ based on U-statistic of an i.i.d. sample</h2><span id='topic+sigma4'></span>

<h3>Description</h3>

<p>This function takes a random sample and produces an unbiased estimate of the squared variance based on
the U-statistic $sum_k1 ne k2 ne k3 ne k4 (x_k1-x_k2))^2 (x_k3-x_k4))^2$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma4(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma4_+3A_x">x</code></td>
<td>
<p>is a vector of i.i.d. observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>unbiased estimate of squared variance $sigma^4$, where $sigma^2$ is the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x=stats::rnorm(10)
  sigma4(x)
</code></pre>

<hr>
<h2 id='sigma4bootstrap'>Bootstrap estimate of $sigma^4$ using an i.i.d. sample</h2><span id='topic+sigma4bootstrap'></span>

<h3>Description</h3>

<p>This function takes a random sample and approximates an unbiased estimate of the squared variance based on
Bootstrap estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma4bootstrap(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma4bootstrap_+3A_x">x</code></td>
<td>
<p>is a vector of i.i.d. observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bootstrap estimate of $ sigma^4$, where $sigma^2$ is the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x=stats::rnorm(10)
  sigma4bootstrap(x)
</code></pre>

<hr>
<h2 id='sigma4jackknife'>Jackknife estimate of $sigma^4$ using an i.i.d. sample</h2><span id='topic+sigma4jackknife'></span>

<h3>Description</h3>

<p>This function takes a random sample and approximates an unbiased estimate of the squared variance based on
Jackknife estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma4jackknife(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma4jackknife_+3A_x">x</code></td>
<td>
<p>is a vector of i.i.d. observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jackknife estimate of $sigma^4$, where $sigma^2$ is the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x=stats::rnorm(10)
  sigma4jackknife(x)
</code></pre>

<hr>
<h2 id='taufun'>An intermediate function to calculate the partial sums</h2><span id='topic+taufun'></span>

<h3>Description</h3>

<p>This function is internally used to calculate the partial sums which will
then be used in calculating the asymptotic variances of the test statistics in Heter.test()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taufun(u, ranks, d1, d2, d3, a, b, mn, mcon, coln)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taufun_+3A_u">u</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="taufun_+3A_ranks">ranks</code></td>
<td>
<p>a vector corresponds to either the fourth column of data or rank of the observations.</p>
</td></tr>
<tr><td><code id="taufun_+3A_d1">d1</code></td>
<td>
<p>a vector corresponds to the first column of data in the long format.</p>
</td></tr>
<tr><td><code id="taufun_+3A_d2">d2</code></td>
<td>
<p>a vector corresponds to the second column of data in the long format.</p>
</td></tr>
<tr><td><code id="taufun_+3A_d3">d3</code></td>
<td>
<p>a vector corresponds to the third column of data in the long format.</p>
</td></tr>
<tr><td><code id="taufun_+3A_a">a</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="taufun_+3A_b">b</code></td>
<td>
<p>The number of time points or repeated measurements per subject.</p>
</td></tr>
<tr><td><code id="taufun_+3A_mn">mn</code></td>
<td>
<p>The vector of sample sizes in treatments.</p>
</td></tr>
<tr><td><code id="taufun_+3A_mcon">mcon</code></td>
<td>
<p>a vector corresponds to $b^h$ in Theorem 3.2 of Wand and Akritas (2010a)</p>
</td></tr>
<tr><td><code id="taufun_+3A_coln">coln</code></td>
<td>
<p>takes value 4 or 5. Value 4 is for the tests based on original data
and value 5 is for the tests based on ranks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Asymptotic variances to be used in Heter.test().
</p>

<hr>
<h2 id='tcontrast'>Test of no contrast effect of the treatments</h2><span id='topic+tcontrast'></span>

<h3>Description</h3>

<p>This function conducts the test of no contract effect of treatments
based on Theorem 3.2 of Wang, Higgins, and Blasi (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcontrast(
  data,
  a,
  b,
  mn,
  h = 0.45,
  method = "rank",
  Ca = cbind(as.vector(rep(1, a - 1)), -diag(a - 1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcontrast_+3A_data">data</code></td>
<td>
<p>The data in long format (see the example in function  dataformat_wide_to_long( )).</p>
</td></tr>
<tr><td><code id="tcontrast_+3A_a">a</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="tcontrast_+3A_b">b</code></td>
<td>
<p>The number of time points or repeated measurements per subject.</p>
</td></tr>
<tr><td><code id="tcontrast_+3A_mn">mn</code></td>
<td>
<p>The vector of sample sizes in treatments.</p>
</td></tr>
<tr><td><code id="tcontrast_+3A_h">h</code></td>
<td>
<p>The h value used in the estimators in Theorem 3.2 of Wang, Higgins, and Blasi (2010).
The value of h should be in (0, 0.5).
Recommend to use the default value h=0.45 as given in the function.
Note: If multiple values are provided to h as a vector, then the calculation
will be carried out for each h value, which results in multiple p-values
in the returned result.</p>
</td></tr>
<tr><td><code id="tcontrast_+3A_method">method</code></td>
<td>
<p>Specifying method='rank' to use rank test. For all other values, the test based on original data will be used.</p>
</td></tr>
<tr><td><code id="tcontrast_+3A_ca">Ca</code></td>
<td>
<p>Contrast matrix for the contrast effect of the treatments.
The default contrast corresponds to the main treatment effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that contains the test statistics and pvalues for each h value.
</p>


<h3>References</h3>

<p>Haiyan Wang and Michael Akritas (2010a). Inference from heteroscedastic functional data, Journal of Nonparametric Statistics. 22:2, 149-168.
DOI: 10.1080/10485250903171621
</p>
<p>Haiyan Wang and Michael Akritas (2010b). Rank test for heteroscedastic functional data. Journal of Multivariate Analysis. 101: 1791-1805.
https://doi.org/10.1016/j.jmva.2010.03.012
</p>
<p>Haiyan Wang, James Higgins, and Dale Blasi (2010).  Distribution-Free
Tests For No Effect Of Treatment In Heteroscedastic Functional Data
Under Both Weak And Long Range Dependence. Statistics and Probability
Letters. 80: 390-402. Doi:10.1016/j.spl.2009.11.016
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data set that contains data from 3 treatments,
# with 3 subjects in treatment 1, 3 subjects in treatment 2,
# and 4 subjects in treatment 3. Each subject contains m=50
# repeated observations from Poisson distribution. For the 1st treatment,
# the mean vector of the repeated observations from the same subject is
# equal to mu1 plus a random effect vector generated by NorRanGen( ).
# The m is the number of repeated measurements per subject.
 f1&lt;-function(m, mu1, raneff) {
     currentmu=mu1+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
 f2&lt;-function(m, mu2, raneff) {
     currentmu=mu2+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
 f3&lt;- function(m, mu3, raneff){
     currentmu=mu3+raneff;
     currentmu[abs(currentmu)&lt;1e-2]=1e-2;
     rpois(m, abs(currentmu))}
# The a is the number of treatments. The mn stores the number of subjects in treatments.
a=3;  mn=c(3, 3, 4); mu1=3; mu2=3; mu3=2; m=50
# Note treatment 3 has mean mu3=2, which is different from the mean of
#  the other two treatments.
# Generate the time effects via random effects with AR(1) structure.
raneff=NorRanGen(m)
# Generate data and store in wide format.
datawide=numeric()
now=0
for (i in 1:a){
   fi=function(x1, x2) f1(m,x1, x2)*(i==1)+f2(m,x1, x2)*(i==2)+f3(m, x1, x2)*(i==3)
   mu=mu1*(i==1)+mu2*(i==2)+mu3*(i==3)
   for (k in 1:mn[i]){
       now=now+1
       datawide&lt;-rbind(datawide, c(k, i, fi(mu, raneff) )   	)
       colnames(datawide)=c("sub", "trt", paste("time", seq(m), sep=""))
       #this is a typical way to store data in practice
   }
} #end of j

# Note:There are different time effects since values in raneff vector are different
dat=dataformat_wide_to_long(datawide)   #dat is in long format
  #Note: For each h value below, the test statistic and p-value are calculated.
  #      (see Theorem 3.2 of Wang, Higgins, and Blasi (2010))

tcontrast(dat, a, m, mn, h=c(0.45, 0.49), method='original')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
