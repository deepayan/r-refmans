<!DOCTYPE html><html><head><title>Help for package changepoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {changepoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BINSEG'>
<p>Binary Segmentation - Only intended for developer use.</p></a></li>
<li><a href='#changepoint-package'>
<p>Methods for Changepoint Detection</p></a></li>
<li><a href='#class_input'>
<p>Input all required arguments into cpt classes - Only intended for developer use.</p></a></li>
<li><a href='#coef-methods'><p> ~~ Methods for Function coef  ~~</p></a></li>
<li><a href='#cpt-class'><p>Class &quot;cpt&quot;</p></a></li>
<li><a href='#cpt.mean'>
<p>Identifying Changes in Mean</p></a></li>
<li><a href='#cpt.meanvar'>
<p>Identifying Changes in Mean and Variance</p></a></li>
<li><a href='#cpt.range-class'><p>Class &quot;cpt.range&quot;</p></a></li>
<li><a href='#cpt.reg-class'><p>Class &quot;cpt.reg&quot;</p></a></li>
<li><a href='#cpt.var'>
<p>Identifying Changes in Variance</p></a></li>
<li><a href='#cpts'>
<p>Generic Function - cpts</p></a></li>
<li><a href='#cpts-methods'><p> ~~ Methods for Function cpts  ~~</p></a></li>
<li><a href='#cpts.full'>
<p>Generic Function - cpts.full</p></a></li>
<li><a href='#cpts.full-methods'><p> ~~ Methods for Function cpts.full  ~~</p></a></li>
<li><a href='#cpts.full&lt;-'>
<p>Generic Function - cpts.full&lt;-</p></a></li>
<li><a href='#cpts.full&lt;&ndash;methods'><p> ~~ Methods for Function cpts.full&lt;-  ~~</p></a></li>
<li><a href='#cpts.ts'>
<p>Generic Function - cpts.ts</p></a></li>
<li><a href='#cpts.ts-methods'><p> ~~ Methods for Function cpts.ts  ~~</p></a></li>
<li><a href='#cpts&lt;-'>
<p>Generic Function - cpts&lt;-</p></a></li>
<li><a href='#cpts&lt;&ndash;methods'><p> ~~ Methods for Function cpts&lt;-  ~~</p></a></li>
<li><a href='#cpttype'>
<p>Generic Function - cpttype</p></a></li>
<li><a href='#cpttype-methods'><p> ~~ Methods for Function cpttype  ~~</p></a></li>
<li><a href='#cpttype&lt;-'>
<p>Generic Function - cpttype</p></a></li>
<li><a href='#cpttype&lt;&ndash;methods'><p> ~~ Methods for Function cpttype&lt;-  ~~</p></a></li>
<li><a href='#data.set'>
<p>Generic Function - data.set</p></a></li>
<li><a href='#data.set-methods'><p> ~~ Methods for Function data.set  ~~</p></a></li>
<li><a href='#data.set.ts'>
<p>Generic Function - data.set.ts</p></a></li>
<li><a href='#data.set.ts-methods'><p> ~~ Methods for Function data.set.ts  ~~</p></a></li>
<li><a href='#data.set&lt;-'>
<p>Generic Function - data.set&lt;-</p></a></li>
<li><a href='#data.set&lt;&ndash;methods'><p> ~~ Methods for Function data.set&lt;-  ~~</p></a></li>
<li><a href='#decision'>
<p>Decision Function - Only intended for developer use.</p></a></li>
<li><a href='#distribution'>
<p>Generic Function - distribution</p></a></li>
<li><a href='#distribution-methods'><p> ~~ Methods for Function distribution  ~~</p></a></li>
<li><a href='#distribution&lt;-'>
<p>Generic Function - distribution&lt;-</p></a></li>
<li><a href='#distribution&lt;&ndash;methods'><p> ~~ Methods for Function distribution&lt;-  ~~</p></a></li>
<li><a href='#ftse100'>
<p>FTSE 100 Daily Returns: 2nd April 1984 &ndash; 13th September 2012</p></a></li>
<li><a href='#HC1'>
<p>G+C Content in Human Chromosome 1</p></a></li>
<li><a href='#Lai2005fig3'>
<p>Normalized glioblastoma profile for chromosome 13</p></a></li>
<li><a href='#Lai2005fig4'>
<p>Normalized glioblastoma profile for an excerpt of chromosome 7, the EGFR locus.</p></a></li>
<li><a href='#likelihood'>
<p>Generic Function - likelihood</p></a></li>
<li><a href='#likelihood-methods'><p> ~~ Methods for Function likelihood  ~~</p></a></li>
<li><a href='#logLik-methods'><p> ~~ Methods for Function logLik  ~~</p></a></li>
<li><a href='#method'>
<p>Generic Function - method</p></a></li>
<li><a href='#method-methods'><p> ~~ Methods for Function method  ~~</p></a></li>
<li><a href='#method&lt;-'>
<p>Generic Function - method&lt;-</p></a></li>
<li><a href='#method&lt;&ndash;methods'><p> ~~ Methods for Function method&lt;-  ~~</p></a></li>
<li><a href='#minseglen'>
<p>Generic Function - minseglen</p></a></li>
<li><a href='#minseglen-methods'><p> ~~ Methods for Function minseglen  ~~</p></a></li>
<li><a href='#minseglen&lt;-'>
<p>Generic Function - minseglen&lt;-</p></a></li>
<li><a href='#minseglen&lt;&ndash;methods'><p> ~~ Methods for Function minseglen&lt;-  ~~</p></a></li>
<li><a href='#ncpts'>
<p>Generic Function - ncpts</p></a></li>
<li><a href='#ncpts-methods'><p> ~~ Methods for Function ncpts  ~~</p></a></li>
<li><a href='#ncpts.max'>
<p>Generic Function - ncpts.max</p></a></li>
<li><a href='#ncpts.max-methods'><p> ~~ Methods for Function ncpts.max  ~~</p></a></li>
<li><a href='#ncpts.max&lt;-'>
<p>Generic Function - ncpts.max&lt;-</p></a></li>
<li><a href='#ncpts.max&lt;&ndash;methods'><p> ~~ Methods for Function ncpts.max&lt;-  ~~</p></a></li>
<li><a href='#nseg'>
<p>Generic Function - nseg</p></a></li>
<li><a href='#nseg-methods'><p> ~~ Methods for Function nseg  ~~</p></a></li>
<li><a href='#param'>
<p>Generic Function - param</p></a></li>
<li><a href='#param-methods'><p> ~~ Methods for Function param  ~~</p></a></li>
<li><a href='#param.est'>
<p>Generic Function - param.est</p></a></li>
<li><a href='#param.est-methods'><p> ~~ Methods for Function param.est  ~~</p></a></li>
<li><a href='#param.est&lt;-'>
<p>Generic Function - param.est&lt;-</p></a></li>
<li><a href='#param.est&lt;&ndash;methods'><p> ~~ Methods for Function param.est&lt;-  ~~</p></a></li>
<li><a href='#PELT'>
<p>PELT (Pruned Exact Linear Time) - Only intended for developer use.</p></a></li>
<li><a href='#pen.type'>
<p>Generic Function - pen.type</p></a></li>
<li><a href='#pen.type-methods'><p> ~~ Methods for Function pen.type  ~~</p></a></li>
<li><a href='#pen.type&lt;-'>
<p>Generic Function - pen.type&lt;-</p></a></li>
<li><a href='#pen.type&lt;&ndash;methods'><p> ~~ Methods for Function pen.type&lt;-  ~~</p></a></li>
<li><a href='#pen.value'>
<p>Generic Function - pen.value</p></a></li>
<li><a href='#pen.value-methods'><p> ~~ Methods for Function pen.value  ~~</p></a></li>
<li><a href='#pen.value.full'>
<p>Generic Function - pen.value.full</p></a></li>
<li><a href='#pen.value.full-methods'><p> ~~ Methods for Function pen.value.full  ~~</p></a></li>
<li><a href='#pen.value.full&lt;-'>
<p>Generic Function - pen.value.full&lt;-</p></a></li>
<li><a href='#pen.value.full&lt;&ndash;methods'><p> ~~ Methods for Function pen.value.full&lt;-  ~~</p></a></li>
<li><a href='#pen.value&lt;-'>
<p>Generic Function - pen.value</p></a></li>
<li><a href='#pen.value&lt;&ndash;methods'><p> ~~ Methods for Function pen.value&lt;-  ~~</p></a></li>
<li><a href='#penalty_decision'>
<p>Penalty Decision Function - Only intended for developer use.</p></a></li>
<li><a href='#plot-methods'><p> ~~ Methods for Function plot in Package &lsquo;graphics&rsquo; ~~</p></a></li>
<li><a href='#seg.len'>
<p>Generic Function - seg.len</p></a></li>
<li><a href='#seg.len-methods'><p> ~~ Methods for Function seg.len  ~~</p></a></li>
<li><a href='#show-methods'><p> ~~ Methods for Function print in Package &lsquo;base&rsquo; ~~</p></a></li>
<li><a href='#summary-methods'><p> ~~ Methods for Function summary in Package &lsquo;base&rsquo; ~~</p></a></li>
<li><a href='#test.stat'>
<p>Generic Function - test.stat</p></a></li>
<li><a href='#test.stat-methods'><p> ~~ Methods for Function test.stat  ~~</p></a></li>
<li><a href='#test.stat&lt;-'>
<p>Generic Function - test.stat&lt;-</p></a></li>
<li><a href='#test.stat&lt;&ndash;methods'><p> ~~ Methods for Function test.stat&lt;-  ~~</p></a></li>
<li><a href='#wave.c44137'>
<p>Wave data from buoy c44137</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Changepoint Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rkillick/changepoint/issues">https://github.com/rkillick/changepoint/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rkillick/changepoint/">https://github.com/rkillick/changepoint/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various mainstream and specialised changepoint methods for finding single and multiple changepoints within data.  Many popular non-parametric and frequentist methods are included.  The cpt.mean(), cpt.var(), cpt.meanvar() functions should be your first point of call.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1), methods, stats, zoo(&ge; 0.9-1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, vdiffr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-03 18:30:45 UTC; killick</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-03 22:30:06 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Rebecca Killick [aut, cre],
  Kaylea Haynes [aut],
  Idris Eckley [ths],
  Paul Fearnhead [ctb, ths],
  Robin Long [ctb],
  Jamie Lee [ctr]</td>
</tr>
</table>
<hr>
<h2 id='BINSEG'>
Binary Segmentation - Only intended for developer use.
</h2><span id='topic+BINSEG'></span>

<h3>Description</h3>

<p>Implements the Binary Segmentation method for identifying changepoints in a given set of summary statistics for a specified cost function and penalty.
</p>
<p>This function is called by <code>cpt.mean</code>, <code>cpt.var</code> and <code>cpt.meanvar</code> when <code>method="BinSeg"</code>.  This is not intended for use by regular users of the package.  It is exported for developers to call directly for speed increases or to fit alternative cost functions.
</p>
<p>WARNING: No checks on arguments are performed!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BINSEG(sumstat, pen = 0, cost_func = "norm.mean", shape = 1, minseglen = 2,  Q=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BINSEG_+3A_sumstat">sumstat</code></td>
<td>

<p>A matrix containing the summary statistics of data within which you wish to find a changepoint.  Currently assumes 3 columns and uses the number of rows as the length of the data +1 (initial value of 0).
</p>
</td></tr>
<tr><td><code id="BINSEG_+3A_pen">pen</code></td>
<td>

<p>Default choice is 0, this should be evaluated elsewhere and a numerical value entered.  This should be positive - this isn't checked but results are meaningless if it isn't.
</p>
</td></tr>
<tr><td><code id="BINSEG_+3A_cost_func">cost_func</code></td>
<td>

<p>The friendly name of the cost function to be called in C.  If using your own cost function, this must be the name of the C function to use.
</p>
</td></tr>
<tr><td><code id="BINSEG_+3A_shape">shape</code></td>
<td>

<p>Only required for cost_func=&quot;Gamma&quot;,default is 1.  Must be a positive value, this isn't checked.
</p>
</td></tr>
<tr><td><code id="BINSEG_+3A_minseglen">minseglen</code></td>
<td>

<p>Positive integer giving the minimum segment length (no. of observations between changes), default is 2.  No checks are performed on the input value so it could be larger than feasible to have changes in the data.
</p>
</td></tr>
<tr><td><code id="BINSEG_+3A_q">Q</code></td>
<td>

<p>The maximum number of changepoints to search for (positive integer). No checks are performed and so a number larger than allowed can be input.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used as a wrapper function to implement the Binary Segmentation algorithm in C.  It simply creates the necessary worker vectors, ensures all inputs are the correct type, and passes everything to the C function.
</p>
<p>This function is exported for developer use only.  It does not perform any checks on inputs (other than type coersion) and is simply a wrapper function for the C code.
</p>


<h3>Value</h3>

<p>A list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>2xQ Matrix containing the changepoint positions on the first row and the test statistic on the second row in the order identified.</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>Ordered list of optimal number of changepoints ending with n.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal number changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>Binary Segmentation: Scott, A. J. and Knott, M. (1974) A Cluster Analysis Method for Grouping Means in the Analysis of Variance, <em>Biometrics</em> <b>30(3)</b>, 507&ndash;512
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>,<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This function should only be used by developers, see its use in cpt.mean, cpt.var and cpt.meanvar.
</code></pre>

<hr>
<h2 id='changepoint-package'>
Methods for Changepoint Detection
</h2><span id='topic+changepoint-package'></span><span id='topic+changepoint'></span>

<h3>Description</h3>

<p>Implements various mainstream and specialised changepoint methods for finding single and multiple changepoints within data.  Many popular non-parametric and frequentist methods are included.  Users should start by looking at the documentation for cpt.mean(), cpt.var() and cpt.meanvar().
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> changepoint</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2.4 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-10-31</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;, Kaylea Haynes &lt;k.haynes1@lancs.ac.uk&gt; with contributions from Idris A. Eckley &lt;i.eckley@lancs.ac.uk&gt;, Paul Fearnhead &lt;p.fearnhead@lancs.ac.uk&gt;.
</p>
<p>Maintainer: Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;
</p>


<h3>References</h3>

<p>Chen, J. and Gupta, A. K. (2000) <em>Parametric statistical change point analysis</em>, Birkhauser
</p>
<p>PELT Algorithm: Killick R, Fearnhead P, Eckley IA (2012) Optimal detection of changepoints with a linear computational cost, <em>JASA</em> <b>107(500)</b>, 1590&ndash;1598
</p>
<p>Binary Segmentation: Scott, A. J. and Knott, M. (1974) A Cluster Analysis Method for Grouping Means in the Analysis of Variance, <em>Biometrics</em> <b>30(3)</b>, 507&ndash;512
</p>
<p>Segment Neighbourhoods: Auger, I. E. And Lawrence, C. E. (1989) Algorithms for the Optimal Identification of Segment Neighborhoods, <em>Bulletin of Mathematical Biology</em> <b>51(1)</b>, 39&ndash;54
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># change in variance
set.seed(1)
x=c(rnorm(100,0,1),rnorm(100,0,10))
ansvar=cpt.var(x)
plot(ansvar)
print(ansvar) # identifies 1 changepoint at 100

# change in mean
y=c(rnorm(100,0,1),rnorm(100,5,1))
ansmean=cpt.mean(y)
plot(ansmean,cpt.col='blue')
print(ansmean)

# change in mean and variance
z=c(rnorm(100,0,1),rnorm(100,2,10))
ansmeanvar=cpt.meanvar(z)
plot(ansmeanvar,cpt.width=3)
print(ansmeanvar)
</code></pre>

<hr>
<h2 id='class_input'>
Input all required arguments into cpt classes - Only intended for developer use.
</h2><span id='topic+class_input'></span>

<h3>Description</h3>

<p>This function helps to input all the necessary information into the correct format for <code>cpt</code> and <code>cpt.range</code> classes.
</p>
<p>This function is called by <code>cpt.mean</code>, <code>cpt.var</code> and <code>cpt.meanvar</code> when <code>class=TRUE</code>.  This is not intended for use by regular users of the package.  It is exported for developers to call directly for speed and convenience.
</p>
<p>WARNING: No checks on arguments are performed!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_input(data, cpttype, method, test.stat, penalty, pen.value, minseglen, 
param.estimates, out=list(), Q=NA, shape=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="class_input_+3A_data">data</code></td>
<td>

<p>Data used in changepoint analysis, see <code><a href="#topic+cpt.mean">cpt.mean</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_cpttype">cpttype</code></td>
<td>

<p>Type of changepoint analysis performed as a text string, e.g. &quot;Mean&quot;, &quot;Mean and Variance&quot;.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_method">method</code></td>
<td>

<p>Method used as a text string, see <code><a href="#topic+cpt.mean">cpt.mean</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_test.stat">test.stat</code></td>
<td>

<p>The assumed test statistic / distribution of the data as a text string.  , see <code><a href="#topic+cpt.mean">cpt.mean</a></code>, <code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code> or <code><a href="#topic+cpt.var">cpt.var</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_penalty">penalty</code></td>
<td>

<p>Penalty used as a text string, see <code><a href="#topic+cpt.mean">cpt.mean</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_pen.value">pen.value</code></td>
<td>

<p>Numerical penalty value used in the analysis (positive).
</p>
</td></tr>
<tr><td><code id="class_input_+3A_minseglen">minseglen</code></td>
<td>

<p>Minimum segment length used in the analysis (positive integer).
</p>
</td></tr>
<tr><td><code id="class_input_+3A_param.estimates">param.estimates</code></td>
<td>

<p>Logical.  If TRUE then parameter estimates are calculated. If FALSE no parameter estimates are calculated and the slot is blank in the returned object.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_out">out</code></td>
<td>

<p>List of output from <code><a href="#topic+BINSEG">BINSEG</a></code>, <code><a href="#topic+PELT">PELT</a></code> or other <code>method</code> used.  Function assumes that <code>method</code> and format of <code>out</code> match.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_q">Q</code></td>
<td>

<p>The value of <code>Q</code> used in the <code>BinSeg</code> or <code>SegNeigh</code> methods.
</p>
</td></tr>
<tr><td><code id="class_input_+3A_shape">shape</code></td>
<td>

<p>Value of the assumed known shape parameter required when test.stat=&quot;Gamma&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes all the input required for the <code>cpt</code> or <code>cpt.range</code> classes and enters it into the object.
</p>
<p>This function is exported for developer use only.  It does not perform any checks on inputs and is simply a convenience function for converting the output of the worker functions into a nice format for the <code>cpt</code> and <code>cpt.range</code> classes.
</p>


<h3>Value</h3>

<p>An object of class <code>cpt</code> or <code>cpt.range</code> as appropriate filled with the given attributes.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This function should only be used by developers, see its use in cpt.mean, cpt.var and cpt.meanvar.
</code></pre>

<hr>
<h2 id='coef-methods'> ~~ Methods for Function coef  ~~</h2><span id='topic+coef-methods'></span><span id='topic+coef+2Ccpt-method'></span><span id='topic+coef+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>coef</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves parameter estimates (i.e. param.est slot) from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves parameter estimates (i.e. param.est slot) from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='cpt-class'>Class &quot;cpt&quot;</h2><span id='topic+cpt-class'></span><span id='topic+cpt-method+2Ccpts'></span><span id='topic+cpt-method+2Ccpttype'></span><span id='topic+cpt-method+2Cdata.set'></span><span id='topic+cpt-method+2Cdata.set.ts'></span><span id='topic+cpt-method+2Ctest.stat'></span><span id='topic+cpt-method+2Cncpts.max'></span><span id='topic+cpt-method+2Cmethod'></span><span id='topic+cpt-method+2Cminseglen'></span><span id='topic+cpt-method+2Cparam.est'></span><span id='topic+cpt-method+2Cpen.type'></span><span id='topic+cpt-method+2Cpen.value'></span><span id='topic+cpt-method+2Ccpts+3C-'></span><span id='topic+cpt-method+2Ccpttype+3C-'></span><span id='topic+cpt-method+2Cdata.set+3C-'></span><span id='topic+cpt-method+2Ctest.stat+3C-'></span><span id='topic+cpt-method+2Cncpts.max+3C-'></span><span id='topic+cpt-method+2Cmethod+3C-'></span><span id='topic+cpt-method+2Cminseglen+3C-'></span><span id='topic+cpt-method+2Cparam.est+3C-'></span><span id='topic+cpt-method+2Cpen.type+3C-'></span><span id='topic+cpt-method+2Cpen.value+3C-'></span><span id='topic+cpt-method+2Cprint'></span><span id='topic+cpt-method+2Csummary'></span><span id='topic+cpt-method+2Cplot'></span><span id='topic+cpt-method+2Cparam'></span><span id='topic+cpt-method+2ClogLik'></span>

<h3>Description</h3>

<p>A class for changepoint objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("cpt", ...)</code>.
</p>

<dl>
<dt><code>new("cpt", ...)</code>:</dt><dd><p>creates a new object with class cpt </p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>data.set</code>:</dt><dd><p>Object of class <code>"ts"</code>, a coerced time series of the original data. </p>
</dd>
<dt><code>cpttype</code>:</dt><dd><p>Object of class <code>"character"</code>, the type of changepoint that was identified. </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>, the method that was used to search for changepoints. </p>
</dd>
<dt><code>test.stat</code>:</dt><dd><p>Object of class <code>"character"</code>, the test statistic for the analysis of the data. </p>
</dd>
<dt><code>pen.type</code>:</dt><dd><p>Object of class <code>"character"</code>, the penalty type specified in the analysis.</p>
</dd>
<dt><code>pen.value</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the value of the penalty used in the analysis.</p>
</dd>
<dt><code>minseglen</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the minimum segment length (no. of observations between changepoints) used in the analysis.</p>
</dd>
<dt><code>cpts</code>:</dt><dd><p>Object of class <code>"numeric"</code>, vector of changepoints identified. </p>
</dd>
<dt><code>ncpts.max</code>:</dt><dd><p>Object of class <code>"numeric"</code>, maximum number of changepoint that can be identified. </p>
</dd>
<dt><code>param.est</code>:</dt><dd><p>Object of class <code>"list"</code>, list where each element is a vector of parameter estimates, if requested. </p>
</dd>
<dt><code>date</code>:</dt><dd><p>Object of class <code>"character"</code>, date and time the changepoint analysis was run. </p>
</dd>
<dt><code>version</code>:</dt><dd><p>Object of class <code>"character"</code>, version number of the package used when the analysis was run.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>cpts</dt><dd><p><code>signature(object = "cpt")</code>: retrieves cpts slot </p>
</dd>
<dt>cpttype</dt><dd><p><code>signature(object = "cpt")</code>: retrieves cpttype slot </p>
</dd>
<dt>data.set</dt><dd><p><code>signature(object = "cpt")</code>: retrieves vector version of data.set slot </p>
</dd>
<dt>data.set.ts</dt><dd><p><code>signature(object = "cpt")</code>: retrieves time series version of data.set slot </p>
</dd>
<dt>test.stat</dt><dd><p><code>signature(object = "cpt")</code>: retrieves test.stat slot </p>
</dd>
<dt>ncpts.max</dt><dd><p><code>signature(object = "cpt")</code>: retrieves ncpts.max slot </p>
</dd>
<dt>method</dt><dd><p><code>signature(object = "cpt")</code>: retrieves method slot </p>
</dd>
<dt>minseglen</dt><dd><p><code>signature(object = "cpt")</code>: retrieves minseglen slot </p>
</dd>
<dt>param.est</dt><dd><p><code>signature(object = "cpt")</code>: retrieves param.est slot </p>
</dd>
<dt>pen.type</dt><dd><p><code>signature(object = "cpt")</code>: retrieves pen.type slot </p>
</dd>
<dt>pen.value</dt><dd><p><code>signature(object = "cpt")</code>: retrieves pen.value slot </p>
</dd>
<dt>cpts&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces cpts slot </p>
</dd>
<dt>cpttype&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces cpttype slot </p>
</dd>
<dt>data.set&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces data.set slot </p>
</dd>
<dt>test.stat&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces test.stat slot </p>
</dd>
<dt>ncpts.max&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces ncpts.max slot </p>
</dd>
<dt>method&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces method slot </p>
</dd>
<dt>minseglen&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces minseglen slot </p>
</dd>
<dt>param.est&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces param.est slot </p>
</dd>
<dt>pen.type&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces pen.type slot </p>
</dd>
<dt>pen.value&lt;-</dt><dd><p><code>signature(object = "cpt")</code>: replaces pen.value slot </p>
</dd>
<dt>print</dt><dd><p><code>signature(object = "cpt")</code>: prints details of the cpt object including summary</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "cpt")</code>: prints a summary of the cpt object </p>
</dd>
<dt>plot</dt><dd><p><code>signature(object = "cpt")</code>: plots the cpt object with changepoints highlighted</p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "cpt")</code>: calculates the parameter estimates for the cpt object</p>
</dd>
<dt>logLik</dt><dd><p><code>signature(object = "cpt")</code>: returns the overall log-likelihood of the cpt object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.set-methods">data.set-methods</a></code>,<code><a href="#topic+cpts-methods">cpts-methods</a></code>,<code><a href="#topic+cpt.reg-class">cpt.reg</a></code>,<code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("cpt") # shows the structure of the cpt class

x=new("cpt") # creates a new object with the cpt class defaults
cpts(x) # retrieves the cpts slot from x
cpts(x)&lt;-c(10,50,100) # replaces the cpts slot from x with c(10,50,100)

# Example of a change in variance at 100 in simulated normal data
set.seed(1)
x=c(rnorm(100,0,1),rnorm(100,0,10))
ans=cpt.var(x) 
print(ans) # prints details of the analysis including a summary
summary(ans)
plot(ans) # plots the data with change (vertical line) at 100
logLik(ans) # raw likelihood of the data with changepoints, second value is likelihood + penalty
</code></pre>

<hr>
<h2 id='cpt.mean'>
Identifying Changes in Mean
</h2><span id='topic+cpt.mean'></span>

<h3>Description</h3>

<p>Calculates the optimal positioning and (potentially) number of changepoints for data using the user specified method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt.mean(data,penalty="MBIC",pen.value=0,method="AMOC",Q=5,test.stat="Normal",class=TRUE,
param.estimates=TRUE,minseglen=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpt.mean_+3A_data">data</code></td>
<td>

<p>A vector, ts object or matrix containing the data within which you wish to find a changepoint.  If data is a matrix, each row is considered a separate dataset.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_penalty">penalty</code></td>
<td>

<p>Choice of &quot;None&quot;, &quot;SIC&quot;, &quot;BIC&quot;, &quot;MBIC&quot;, AIC&quot;, &quot;Hannan-Quinn&quot;, &quot;Asymptotic&quot;, &quot;Manual&quot; and &quot;CROPS&quot; penalties.  If Manual is specified, the manual penalty is contained in the pen.value parameter. If Asymptotic is specified, the theoretical type I error is contained in the pen.value parameter.  If CROPS is specified, the penalty range is contained in the pen.value parameter; note this is a vector of length 2 which contains the minimum and maximum penalty value.  Note CROPS can only be used if the method is &quot;PELT&quot;. The predefined penalties listed DO count the changepoint as a parameter, postfix a 0 e.g.&quot;SIC0&quot; to NOT count the changepoint as a parameter.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_pen.value">pen.value</code></td>
<td>

<p>The theoretical type I error e.g.0.05 when using the Asymptotic penalty.  A vector of length 2 (min,max) if using the CROPS penalty.  The value of the penalty when using the Manual penalty option - this can be a numeric value or text giving the formula to use.  Available variables are, n=length of original data, null=null likelihood, alt=alternative likelihood, tau=proposed changepoint, diffparam=difference in number of alternatve and null parameters.  
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_method">method</code></td>
<td>

<p>Choice of &quot;AMOC&quot;, &quot;PELT&quot;, &quot;SegNeigh&quot; or &quot;BinSeg&quot;.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_q">Q</code></td>
<td>

<p>The maximum number of changepoints to search for using the &quot;BinSeg&quot; method.  The maximum number of segments (number of changepoints + 1) to search for using the &quot;SegNeigh&quot; method.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_test.stat">test.stat</code></td>
<td>

<p>The assumed test statistic / distribution of the data.  Currently only &quot;Normal&quot; and &quot;CUSUM&quot; supported.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_class">class</code></td>
<td>

<p>Logical.  If TRUE then an object of class <code>cpt</code> is returned.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_param.estimates">param.estimates</code></td>
<td>

<p>Logical.  If TRUE and class=TRUE then parameter estimates are returned. If FALSE or class=FALSE no parameter estimates are returned.
</p>
</td></tr>
<tr><td><code id="cpt.mean_+3A_minseglen">minseglen</code></td>
<td>

<p>Positive integer giving the minimum segment length (no. of observations between changes), default is the minimum allowed by theory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to find changes in mean for data using the test statistic specfified in the test.stat parameter.  The changes are found using the method supplied which can be single changepoint (AMOC) or multiple changepoints using exact (PELT or SegNeigh) or approximate (BinSeg) methods.  A changepoint is denoted as the last observation of the segment / regime.
</p>


<h3>Value</h3>

<p>If <code>class=TRUE</code> then an object of S4 class &quot;cpt&quot; is returned.  The slot <code>cpts</code> contains the changepoints that are returned.  For <code>class=FALSE</code> the structure is as follows.
</p>
<p>If data is a vector (single dataset) then a vector/list is returned depending on the value of method.  If data is a matrix (multiple datasets) then a list is returned where each element in the list is either a vector or list depending on the value of method.
</p>
<p>If method is AMOC then a vector (one dataset) or matrix (multiple datasets) is returned, the columns are:
</p>
<table>
<tr><td><code>cpt</code></td>
<td>
<p>The most probable location of a changepoint if a change was identified or NA if no changepoint.</p>
</td></tr>
<tr><td><code>p value</code></td>
<td>
<p>The p-value of the identified changepoint.</p>
</td></tr>
</table>
<p>If method is PELT then a vector is returned containing the changepoint locations for the penalty supplied.  This always ends with n.
If the penalty is CROPS then a list is returned with elements:
</p>
<table>
<tr><td><code>cpt.out</code></td>
<td>
<p>A data frame containing the value of the penalty value where the number of segmentations changes, the number of segmentations and the value of the cost at that penalty value.</p>
</td></tr>
<tr><td><code>changepoints</code></td>
<td>
<p>The optimal changepoint for the different penalty values starting with the lowest penalty value</p>
</td></tr>
</table>
<p>If method is SegNeigh then a list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>Matrix containing the changepoint positions for 1,...,Q changepoints.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>Value of the -2*log(likelihood ratio) + penalty for the optimal number of changepoints selected.</p>
</td></tr>
</table>
<p>If method is BinSeg then a list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>2xQ Matrix containing the changepoint positions on the first row and the test statistic on the second row.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>Change in Normal mean: Hinkley, D. V. (1970) Inference About the Change-Point in a Sequence of Random Variables, <em>Biometrika</em> <b>57</b>, 1&ndash;17
</p>
<p>CUSUM Test: M. Csorgo, L. Horvath (1997) Limit Theorems in Change-Point Analysis, <em>Wiley</em>
</p>
<p>PELT Algorithm: Killick R, Fearnhead P, Eckley IA (2012) Optimal detection of changepoints with a linear computational cost, <em>JASA</em> <b>107(500)</b>, 1590&ndash;1598
</p>
<p>CROPS: Haynes K, Eckley IA, Fearnhead P (2014) Efficient penalty search for multiple changepoint problems (in submission), arXiv:1412.3617
</p>
<p>Binary Segmentation: Scott, A. J. and Knott, M. (1974) A Cluster Analysis Method for Grouping Means in the Analysis of Variance, <em>Biometrics</em> <b>30(3)</b>, 507&ndash;512
</p>
<p>Segment Neighbourhoods: Auger, I. E. And Lawrence, C. E. (1989) Algorithms for the Optimal Identification of Segment Neighborhoods, <em>Bulletin of Mathematical Biology</em> <b>51(1)</b>, 39&ndash;54
</p>
<p>MBIC: Zhang, N. R. and Siegmund, D. O. (2007) A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data. <em>Biometrics</em> <b>63</b>, 22-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>,<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a change in mean at 100 in simulated normal data
set.seed(1)
x=c(rnorm(100,0,1),rnorm(100,10,1))
cpt.mean(x,penalty="SIC",method="AMOC",class=FALSE) # returns 100 to show that the null hypothesis
#was rejected and the change in mean is at 100 and the confidence level is 1.
ans=cpt.mean(x,penalty="Asymptotic",pen.value=0.01,method="AMOC") 
cpts(ans)# returns 100 to show that the null hypothesis was rejected, the change in mean is at 100
#and we are 99% confident of this result
cpt.mean(x,penalty="Manual",pen.value=0.8,method="AMOC",test.stat="CUSUM") 
# returns 101 as the changepoint location 


# Example of multiple changes in mean at 50,100,150 in simulated normal data
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,5,1),rnorm(50,10,1),rnorm(50,3,1))
cpt.mean(x,penalty="Manual",pen.value="2*log(n)",method="BinSeg",Q=5,class=FALSE) 
# returns optimal number of changepoints is 3, locations are 50,100,150.

# Example of using the CROPS penalty in data set above
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,5,1),rnorm(50,10,1),rnorm(50,3,1))
out=cpt.mean(x, pen.value = c(4,1500),penalty = "CROPS",method = "PELT") 
cpts.full(out)  # returns 7 segmentations for penalty values between 4 and 1500.  
# We find segmentations with 7, 5, 4, 3, 2, 1 and 0 changepoints. 
# Note that the empty final row indicates no changepoints.
pen.value.full(out) # gives associated penalty transition points
# CROPS does not give an optimal set of changepoints thus we may wish to explore further
plot(out,diagnostic=TRUE) 
# looks like the segmentation with 3 changepoints, 50,100,150 is the most appropriate
plot(out,ncpts=3) 


# Example multiple datasets where the first row has multiple changes in mean and the second row has
#no change in mean
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,5,1),rnorm(50,10,1),rnorm(50,3,1))
y=rnorm(200,0,1)
z=rbind(x,y)
cpt.mean(z,penalty="Asymptotic",pen.value=0.01,method="SegNeigh",Q=5,class=FALSE) # returns list
#that has two elements, the first has 3 changes in mean and variance at 50,100,150 and the second
#has no changes in variance
ans=cpt.mean(z,penalty="Asymptotic",pen.value=0.01,method="PELT") 
cpts(ans[[1]]) # same results as for the SegNeigh method.
cpts(ans[[2]]) # same results as for the SegNeigh method.
</code></pre>

<hr>
<h2 id='cpt.meanvar'>
Identifying Changes in Mean and Variance
</h2><span id='topic+cpt.meanvar'></span>

<h3>Description</h3>

<p>Calculates the optimal positioning and (potentially) number of changepoints for data using the user specified method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt.meanvar(data,penalty="MBIC",pen.value=0,method="AMOC",Q=5,test.stat="Normal",
class=TRUE,param.estimates=TRUE,shape=1,minseglen=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpt.meanvar_+3A_data">data</code></td>
<td>

<p>A vector, ts object or matrix containing the data within which you wish to find a changepoint.  If data is a matrix, each row is considered a separate dataset.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_penalty">penalty</code></td>
<td>

<p>Choice of &quot;None&quot;, &quot;SIC&quot;, &quot;BIC&quot;, &quot;MBIC&quot;, AIC&quot;, &quot;Hannan-Quinn&quot;, &quot;Asymptotic&quot;, &quot;Manual&quot; and &quot;CROPS&quot; penalties.  If Manual is specified, the manual penalty is contained in the pen.value parameter. If Asymptotic is specified, the theoretical type I error is contained in the pen.value parameter.  If CROPS is specified, the penalty range is contained in the pen.value parameter; note this is a vector of length 2 which contains the minimum and maximum penalty value.  Note CROPS can only be used if the method is &quot;PELT&quot;. The predefined penalties listed DO count the changepoint as a parameter, postfix a 0 e.g.&quot;SIC0&quot; to NOT count the changepoint as a parameter.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_pen.value">pen.value</code></td>
<td>

<p>The theoretical type I error e.g.0.05 when using the Asymptotic penalty.  A vector of length 2 (min,max) if using the CROPS penalty.  The value of the penalty when using the Manual penalty option - this can be a numeric value or text giving the formula to use.  Available variables are, n=length of original data, null=null likelihood, alt=alternative likelihood, tau=proposed changepoint, diffparam=difference in number of alternatve and null parameters.  
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_method">method</code></td>
<td>

<p>Choice of &quot;AMOC&quot;, &quot;PELT&quot;, &quot;SegNeigh&quot; or &quot;BinSeg&quot;.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_q">Q</code></td>
<td>

<p>The maximum number of changepoints to search for using the &quot;BinSeg&quot; method.  The maximum number of segments (number of changepoints + 1) to search for using the &quot;SegNeigh&quot; method.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_test.stat">test.stat</code></td>
<td>

<p>The assumed test statistic / distribution of the data.  Currently only &quot;Normal&quot;, &quot;Gamma&quot;, &quot;Exponential&quot; and &quot;Poisson&quot; are supported.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_class">class</code></td>
<td>

<p>Logical.  If TRUE then an object of class <code>cpt</code> is returned.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_param.estimates">param.estimates</code></td>
<td>

<p>Logical.  If TRUE and class=TRUE then parameter estimates are returned. If FALSE or class=FALSE no parameter estimates are returned.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_shape">shape</code></td>
<td>

<p>Value of the assumed known shape parameter required when test.stat=&quot;Gamma&quot;.
</p>
</td></tr>
<tr><td><code id="cpt.meanvar_+3A_minseglen">minseglen</code></td>
<td>

<p>Positive integer giving the minimum segment length (no. of observations between changes), default is the minimum allowed by theory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to find changes in mean and variance for data using the test statistic specified in the test.stat parameter.  The changes are found using the method supplied which can be single changepoint (AMOC) or multiple changepoints using exact (PELT or SegNeigh) or approximate (BinSeg) methods.  A changepoint is denoted as the last observation of the segment / regime.
</p>


<h3>Value</h3>

<p>If <code>class=TRUE</code> then an object of S4 class &quot;cpt&quot; is returned.  The slot <code>cpts</code> contains the changepoints that are returned.  For <code>class=FALSE</code> the structure is as follows.
</p>
<p>If data is a vector (single dataset) then a vector/list is returned depending on the value of method.  If data is a matrix (multiple datasets) then a list is returned where each element in the list is either a vector or list depending on the value of method.
</p>
<p>If method is AMOC then a vector (one dataset) or matrix (multiple datasets) is returned, the columns are:
</p>
<table>
<tr><td><code>cpt</code></td>
<td>
<p>The most probable location of a changepoint if a change was identified or NA if no changepoint.</p>
</td></tr>
<tr><td><code>p value</code></td>
<td>
<p>The p-value of the identified changepoint.</p>
</td></tr>
</table>
<p>If method is PELT then a vector is returned containing the changepoint locations for the penalty supplied.  This always ends with n.
If the penalty is CROPS then a list is returned with elements:
</p>
<table>
<tr><td><code>cpt.out</code></td>
<td>
<p>A data frame containing the value of the penalty value where the number of segmentations changes, the number of segmentations and the value of the cost at that penalty value.</p>
</td></tr>
<tr><td><code>changepoints</code></td>
<td>
<p>The optimal changepoints for the different penalty values starting with the lowest penalty value</p>
</td></tr>
</table>
<p>If method is SegNeigh then a list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>Matrix containing the changepoint positions for 1,...,Q changepoints.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>Value of the -2*log(likelihood ratio) + penalty for the optimal number of changepoints selected.</p>
</td></tr>
</table>
<p>If method is BinSeg then a list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>2xQ Matrix containing the changepoint positions on the first row and the test statistic on the second row.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>Change in Normal mean and variance: Chen, J. and Gupta, A. K. (2000) <em>Parametric statistical change point analysis</em>, Birkhauser
</p>
<p>Change in Gamma shape parameter: Chen, J. and Gupta, A. K. (2000) <em>Parametric statistical change point analysis</em>, Birkhauser
</p>
<p>Change in Exponential model: Chen, J. and Gupta, A. K. (2000) <em>Parametric statistical change point analysis</em>, Birkhauser
</p>
<p>Change in Poisson model: Chen, J. and Gupta, A. K. (2000) <em>Parametric statistical change point analysis</em>, Birkhauser
</p>
<p>PELT Algorithm: Killick R, Fearnhead P, Eckley IA (2012) Optimal detection of changepoints with a linear computational cost, <em>JASA</em> <b>107(500)</b>, 1590&ndash;1598
</p>
<p>CROPS: Haynes K, Eckley IA, Fearnhead P (2014) Efficient penalty search for multiple changepoint problems (in submission), arXiv:1412.3617
</p>
<p>Binary Segmentation: Scott, A. J. and Knott, M. (1974) A Cluster Analysis Method for Grouping Means in the Analysis of Variance, <em>Biometrics</em> <b>30(3)</b>, 507&ndash;512
</p>
<p>Segment Neighbourhoods: Auger, I. E. And Lawrence, C. E. (1989) Algorithms for the Optimal Identification of Segment Neighborhoods, <em>Bulletin of Mathematical Biology</em> <b>51(1)</b>, 39&ndash;54
</p>
<p>MBIC: Zhang, N. R. and Siegmund, D. O. (2007) A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data. <em>Biometrics</em> <b>63</b>, 22-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a change in scale parameter (mean and variance) at 100 in simulated gamma data
set.seed(1)
x=c(rgamma(100,shape=1,rate=1),rgamma(100,shape=1,rate=5))
cpt.meanvar(x,penalty="SIC",method="AMOC",test.stat="Gamma",class=FALSE,shape=1) # returns 97 to
#show that the null hypothesis was rejected and the change in scale parameter is at 97
ans=cpt.meanvar(x,penalty="AIC",method="AMOC",test.stat="Gamma",shape=1)
cpts(ans) 
# returns 97 to show that the null hypothesis was rejected, the change in scale parameter is at 97


# Example of multiple changes in mean and variance at 50,100,150 in simulated normal data
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,5,3),rnorm(50,10,1),rnorm(50,3,10))
cpt.meanvar(x,penalty="Manual",pen.value="4*log(n)",method="BinSeg",Q=5,class=FALSE) 
# returns optimal number of changepoints is 4, locations are 50,100,150,152.

# Example of using the CROPS penalty in the above example
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,5,3),rnorm(50,10,1),rnorm(50,3,10))
out=cpt.meanvar(x,pen.value=c(2*log(length(x)),100*log(length(x))),penalty="CROPS",method="PELT")
cpts.full(out)
# returns 6 segmentations for penalty values between 2log(n) and 100log(n).
# We find segmentations with 9, 7, 4, 3, 1 and 0 changepoints. 
# Note that the empty final row indicates no changepoints.
pen.value.full(out) # gives associated penalty transition points
# CROPS does not give an optimal set of changepoints thus we may wish to explore further
plot(out,diagnostic=TRUE) 
# looks like the segmentation with 4 changepoints, 50,100,150,200 is the most appropriate
plot(out,ncpts=3) 


# Example multiple datasets where the first row has multiple changes in mean and variance and the
#second row has no change in mean or variance
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,5,3),rnorm(50,10,1),rnorm(50,3,10))
y=rnorm(200,0,1)
z=rbind(x,y)
cpt.meanvar(z,penalty="Asymptotic",pen.value=0.01,method="SegNeigh",Q=5,class=FALSE) # returns list
#that has two elements, the first has 3 changes in mean and variance at 50,100,150 and the second
#has no changes in mean or variance
ans=cpt.meanvar(z,penalty="Asymptotic",pen.value=0.01,method="PELT") 
cpts(ans[[1]]) # same results as for the SegNeigh method.
cpts(ans[[2]]) # same results as for the SegNeigh method.
</code></pre>

<hr>
<h2 id='cpt.range-class'>Class &quot;cpt.range&quot;</h2><span id='topic+cpt.range-class'></span>

<h3>Description</h3>

<p>A class for changepoint objects that return more than 1 segmentation. Inherits from cpt class.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("cpt.range", ...)</code>.
</p>

<dl>
<dt><code>new("cpt.range", ...)</code>:</dt><dd><p>creates a new object with class cpt.range </p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>cpts.full</code>:</dt><dd><p>Object of class <code>"matrix"</code>, each row of the matrix is a different segmentation of the data (different set of changepoints).</p>
</dd>
<dt><code>pen.value.full</code>:</dt><dd><p>Object of class <code>"vector"</code>, each element is the penalty used to create the set of changepoints in the corresponding row of <code>cpts.full</code>.</p>
</dd>
</dl>
<p>The remaining slots are inherited from the <code>cpt</code> class.
</p>
<dl>
<dt><code>data.set</code>:</dt><dd><p>Object of class <code>"ts"</code>, a coerced time series of the original data. Inherited from cpt class. </p>
</dd>
<dt><code>cpttype</code>:</dt><dd><p>Object of class <code>"character"</code>, the type of changepoint that was identified. Inherited from cpt class. </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>, the method that was used to search for changepoints. Inherited from cpt class. </p>
</dd>
<dt><code>test.stat</code>:</dt><dd><p>Object of class <code>"character"</code>, the test statistic for the analysis of the data. Inherited from cpt class. </p>
</dd>
<dt><code>pen.type</code>:</dt><dd><p>Object of class <code>"character"</code>, the penalty type specified in the analysis. Inherited from cpt class.</p>
</dd>
<dt><code>pen.value</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the value of the penalty used in the analysis. Inherited from cpt class.</p>
</dd>
<dt><code>minseglen</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the minimum segment length (no. of observations between changepoints) used in the analysis. Inherited from cpt class.</p>
</dd>
<dt><code>cpts</code>:</dt><dd><p>Object of class <code>"numeric"</code>, vector of optimal changepoints identified. Inherited from cpt class. </p>
</dd>
<dt><code>ncpts.max</code>:</dt><dd><p>Object of class <code>"numeric"</code>, maximum number of changepoint that can be identified. Inherited from cpt class. </p>
</dd>
<dt><code>param.est</code>:</dt><dd><p>Object of class <code>"list"</code>, list where each element is a vector of parameter estimates, if requested. Inherited from cpt class. </p>
</dd>
<dt><code>date</code>:</dt><dd><p>Object of class <code>"character"</code>, date and time the changepoint analysis was run. Inherited from cpt class. </p>
</dd>
<dt><code>version</code>:</dt><dd><p>Object of class <code>"character"</code>, version number of the package used when the analysis was run. Inherited from cpt class.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>cpts.full</dt><dd><p><code>signature(object = "cpt.range")</code>: retrieves cpts.full slot </p>
</dd>
<dt>pen.value.full</dt><dd><p><code>signature(object = "cpt.range")</code>: retrieves pen.value.full slot </p>
</dd>
<dt>cpts.full&lt;-</dt><dd><p><code>signature(object = "cpt.range")</code>: replaces cpts.full slot </p>
</dd>
<dt>param</dt><dd><p><code>signature(object="cpt.range",ncpts=NA)</code>: creates parameter estimates for the segmentation with <code>ncpts</code> number of changepoints.  If ncpts=NA then the optimal set of changepoints according to the set penalty is used.</p>
</dd>
<dt>pen.value.full&lt;-</dt><dd><p><code>signature(object = "cpt.range")</code>: replaces pen.value.full slot </p>
</dd>
<dt>plot</dt><dd><p><code>signature(object="cpt.range",ncpts=NA,diagnostic=FALSE)</code>: by default plots the optimal segmentation as for <code>class="cpt"</code>.  If ncpts is specified then plots the segmentation for <code>ncpts</code> number of changepoints.  If <code>diagnostic=TRUE</code> then produces a diagnostic plot to aide selection of the number of changes.</p>
</dd>
<dt>print</dt><dd><p><code>signature(object = "cpt.range")</code>: prints details of the cpt.range object including summary</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "cpt.range")</code>: prints a summary of the cpt.range object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpts.full-methods">cpts.full-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>,<code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("cpt.range") # shows the structure of the cpt.range class

x=new("cpt.range") # creates a new object with the cpt.range class defaults
cpts(x) # retrieves the cpts slot from x
cpts(x)&lt;-c(10,50,100) # replaces the cpts slot from x with c(10,50,100)

# Example of multiple changes in variance at 50,100,150 in simulated normal data
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,0,10),rnorm(50,0,5),rnorm(50,0,1))
out=cpt.var(x,pen.value=c(log(length(x)),10*log(length(x))),penalty="CROPS",method="PELT")
print(out) # prints details of the analysis including a summary
summary(out)
plot(out,diagnostic=TRUE) # a diagnostic plot to identify number of changepoints
# looks like the segmentation with 3 changepoints, 50,99,150 is the most appropriate
plot(out,ncpts=3) # plots the segmentation for 3 changes
logLik(out,ncpts=3) 
# raw likelihood of the data with changepoints, second value is likelihood + penalty
</code></pre>

<hr>
<h2 id='cpt.reg-class'>Class &quot;cpt.reg&quot;</h2><span id='topic+cpt.reg-class'></span><span id='topic+cpt.reg-method+2Ccpts'></span><span id='topic+cpt.reg-method+2Ccpttype'></span><span id='topic+cpt.reg-method+2Cdata.set'></span><span id='topic+cpt.reg-method+2Ctest.stat'></span><span id='topic+cpt.reg-method+2Cmethod'></span><span id='topic+cpt.reg-method+2Cncpts.max'></span><span id='topic+cpt.reg-method+2Cparam.est'></span><span id='topic+cpt.reg-method+2Cpen.type'></span><span id='topic+cpt.reg-method+2Cpen.value'></span><span id='topic+cpt.reg-method+2Ccpts+3C-'></span><span id='topic+cpt.reg-method+2Ccpttype+3C-'></span><span id='topic+cpt.reg-method+2Cdata.set+3C-'></span><span id='topic+cpt.reg-method+2Ctest.stat+3C-'></span><span id='topic+cpt.reg-method+2Cmethod+3C-'></span><span id='topic+cpt.reg-method+2Cncpts.max+3C-'></span><span id='topic+cpt.reg-method+2Cparam.est+3C-'></span><span id='topic+cpt.reg-method+2Cpen.type+3C-'></span><span id='topic+cpt.reg-method+2Cpen.value+3C-'></span><span id='topic+cpt.reg-method+2Cprint'></span><span id='topic+cpt.reg-method+2Csummary'></span><span id='topic+cpt.reg-method+2Cparam'></span>

<h3>Description</h3>

<p>A class for changepoint objects, specifically change in regression.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("cpt", ...)</code>.
</p>

<dl>
<dt><code>new("cpt", ...)</code>:</dt><dd><p>creates a new object with class cpt </p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>data.set</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the original vector of data </p>
</dd>
<dt><code>cpttype</code>:</dt><dd><p>Object of class <code>"character"</code>, the type of changepoint that was identified </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>, the method that was used to search for changepoints, default change in regression </p>
</dd>
<dt><code>test.stat</code>:</dt><dd><p>Object of class <code>"character"</code>, the test statistic used to analyse the data </p>
</dd>
<dt><code>pen.type</code>:</dt><dd><p>Object of class <code>"character"</code>, the penalty type specified in the analysis</p>
</dd>
<dt><code>pen.value</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the value of the penalty used in the analysis</p>
</dd>
<dt><code>minseglen</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the minimum segment length (no. of observations between changepoints) used in the analysis.</p>
</dd>
<dt><code>cpts</code>:</dt><dd><p>Object of class <code>"numeric"</code>, vector of changepoints identified </p>
</dd>
<dt><code>ncpts.max</code>:</dt><dd><p>Object of class <code>"numeric"</code>, maximum number of changepoint that can be identified </p>
</dd>
<dt><code>param.est</code>:</dt><dd><p>Object of class <code>"list"</code>, list where each element is a vector of parameter estimates, if requested </p>
</dd>
<dt><code>date</code>:</dt><dd><p>Object of class <code>"character"</code>, date and time the changepoint analysis was run </p>
</dd>
<dt><code>version</code>:</dt><dd><p>Object of class <code>"character"</code>, version number of the package used when the analysis was run.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>cpts</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves cpts slot </p>
</dd>
<dt>cpttype</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves cpttype slot </p>
</dd>
<dt>data.set</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves data.set slot </p>
</dd>
<dt>test.stat</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves test.stat slot </p>
</dd>
<dt>ncpts.max</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves ncpts.max slot </p>
</dd>
<dt>method</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves method slot </p>
</dd>
<dt>minseglen</dt><dd><p><code>signature(object = "cpt")</code>: retrieves minseglen slot </p>
</dd>
<dt>param.est</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves param.est slot </p>
</dd>
<dt>pen.type</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves pen.type slot </p>
</dd>
<dt>pen.value</dt><dd><p><code>signature(object = "cpt.reg")</code>: retrieves pen.value slot </p>
</dd>
<dt>cpts&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces cpts slot </p>
</dd>
<dt>cpttype&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces cpttype slot </p>
</dd>
<dt>data.set&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces data.set slot </p>
</dd>
<dt>test.stat&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces test.stat slot </p>
</dd>
<dt>ncpts.max&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces ncpts.max slot </p>
</dd>
<dt>method&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces method slot </p>
</dd>
<dt>param.est&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces param.est slot </p>
</dd>
<dt>pen.type&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces pen.type slot </p>
</dd>
<dt>pen.value&lt;-</dt><dd><p><code>signature(object = "cpt.reg")</code>: replaces pen.value slot </p>
</dd>
<dt>print</dt><dd><p><code>signature(object = "cpt.reg")</code>: prints details of the cpt object including summary</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "cpt.reg")</code>: prints a summary of the cpt object </p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "cpt.reg")</code>: calculates the parameter estimates for the cpt object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpts-methods">cpts-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("cpt.reg")

x=new("cpt.reg") # creates a new object with the cpt.reg class defaults
data.set(x)  # retrieves the data.set slot from x
data.set(x)&lt;-matrix(1:10,nrow=5,ncol=2) # replaces the data.set slot from x with a matrix

</code></pre>

<hr>
<h2 id='cpt.var'>
Identifying Changes in Variance
</h2><span id='topic+cpt.var'></span>

<h3>Description</h3>

<p>Calculates the optimal positioning and (potentially) number of changepoints for data using the user specified method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpt.var(data,penalty="MBIC",pen.value=0,know.mean=FALSE,mu=NA,method="AMOC",Q=5,
test.stat="Normal",class=TRUE,param.estimates=TRUE,minseglen=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpt.var_+3A_data">data</code></td>
<td>

<p>A vector, ts object or matrix containing the data within which you wish to find a changepoint.  If data is a matrix, each row is considered a separate dataset.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_penalty">penalty</code></td>
<td>

<p>Choice of &quot;None&quot;, &quot;SIC&quot;, &quot;BIC&quot;, &quot;MBIC&quot;, AIC&quot;, &quot;Hannan-Quinn&quot;, &quot;Asymptotic&quot;, &quot;Manual&quot; and &quot;CROPS&quot; penalties.  If Manual is specified, the manual penalty is contained in the pen.value parameter. If Asymptotic is specified, the theoretical type I error is contained in the pen.value parameter.  If CROPS is specified, the penalty range is contained in the pen.value parameter; note this is a vector of length 2 which contains the minimum and maximum penalty value.  Note CROPS can only be used if the method is &quot;PELT&quot;. The predefined penalties listed DO count the changepoint as a parameter, postfix a 0 e.g.&quot;SIC0&quot; to NOT count the changepoint as a parameter.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_pen.value">pen.value</code></td>
<td>

<p>The theoretical type I error e.g.0.05 when using the Asymptotic penalty.  A vector of length 2 (min,max) if using the CROPS penalty.  The value of the penalty when using the Manual penalty option - this can be a numeric value or text giving the formula to use.  Available variables are, n=length of original data, null=null likelihood, alt=alternative likelihood, tau=proposed changepoint, diffparam=difference in number of alternatve and null parameters.  
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_know.mean">know.mean</code></td>
<td>

<p>Only required for test.stat=&quot;Normal&quot;.  Logical, if TRUE then the mean is assumed known and mu is taken as its value.  If FALSE, and mu=NA (default value) then the mean is estimated via maximum likelihood.  If FALSE and the value of mu is supplied, mu is not estimated but is counted as an estimated parameter for decisions.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_mu">mu</code></td>
<td>

<p>Only required for test.stat=&quot;Normal&quot;.  Numerical value of the true mean of the data.  Either single value or vector of length nrow(data).  If data is a matrix and mu is a single value, the same mean is used for each row.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_method">method</code></td>
<td>

<p>Choice of &quot;AMOC&quot;, &quot;PELT&quot;, &quot;SegNeigh&quot; or &quot;BinSeg&quot;.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_q">Q</code></td>
<td>

<p>The maximum number of changepoints to search for using the &quot;BinSeg&quot; method.  The maximum number of segments (number of changepoints + 1) to search for using the &quot;SegNeigh&quot; method.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_test.stat">test.stat</code></td>
<td>

<p>The assumed test statistic / distribution of the data.  Currently only &quot;Normal&quot; and &quot;CSS&quot; supported.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_class">class</code></td>
<td>

<p>Logical.  If TRUE then an object of class <code>cpt</code> is returned.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_param.estimates">param.estimates</code></td>
<td>

<p>Logical.  If TRUE and class=TRUE then parameter estimates are returned. If FALSE or class=FALSE no parameter estimates are returned.
</p>
</td></tr>
<tr><td><code id="cpt.var_+3A_minseglen">minseglen</code></td>
<td>

<p>Positive integer giving the minimum segment length (no. of observations between changes), default is the minimum allowed by theory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to find changes in variance for data using the test statistic specified in the test.stat parameter.  The changes are found using the method supplied which can be single changepoint (AMOC) or multiple changepoints using exact (PELT or SegNeigh) or approximate (BinSeg) methods.  A changepoint is denoted as the last observation of the segment / regime.
Note that for the test.stat=&quot;CSS&quot; option the preset penalties are log(.) to allow comparison with test.stat=&quot;Normal&quot;.  
</p>


<h3>Value</h3>

<p>If <code>class=TRUE</code> then an object of S4 class &quot;cpt&quot; is returned.  The slot <code>cpts</code> contains the changepoints that are returned.  For <code>class=FALSE</code> the structure is as follows.
</p>
<p>If data is a vector (single dataset) then a vector/list is returned depending on the value of method.  If data is a matrix (multiple datasets) then a list is returned where each element in the list is either a vector or list depending on the value of method.
</p>
<p>If method is AMOC then a vector (one dataset) or matrix (multiple datasets) is returned, the columns are:
</p>
<table>
<tr><td><code>cpt</code></td>
<td>
<p>The most probable location of a changepoint if a change was identified or NA if no changepoint.</p>
</td></tr>
<tr><td><code>p value</code></td>
<td>
<p>The p-value of the identified changepoint.</p>
</td></tr>
</table>
<p>If method is PELT then a vector is returned containing the changepoint locations for the penalty supplied.  This always ends with n.
If the penalty is CROPS then a list is returned with elements:
</p>
<table>
<tr><td><code>cpt.out</code></td>
<td>
<p>A data frame containing the value of the penalty value where the number of segmentations changes, the number of segmentations and the value of the cost at that penalty value.</p>
</td></tr>
<tr><td><code>segmentations</code></td>
<td>
<p>The optimal segmentations for the different penalty values starting with the lowest penalty value</p>
</td></tr>
</table>
<p>If method is SegNeigh then a list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>Matrix containing the changepoint positions for 1,...,Q changepoints.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>Value of the -2*log(likelihood ratio) + penalty for the optimal number of changepoints selected.</p>
</td></tr>
</table>
<p>If method is BinSeg then a list is returned with elements:
</p>
<table>
<tr><td><code>cps</code></td>
<td>
<p>2xQ Matrix containing the changepoint positions on the first row and the test statistic on the second row.</p>
</td></tr>
<tr><td><code>op.cpts</code></td>
<td>
<p>The optimal changepoint locations for the penalty supplied.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>Penalty used to find the optimal number of changepoints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>Normal: Chen, J. and Gupta, A. K. (2000) <em>Parametric statistical change point analysis</em>, Birkhauser
</p>
<p>CSS: C. Inclan, G. C. Tiao (1994) Use of Cumulative Sums of Squares for Retrospective Detection of Changes of Variance, <em>Journal of the American Statistical Association</em> <b>89(427)</b>, 913&ndash;923
</p>
<p>PELT Algorithm: Killick R, Fearnhead P, Eckley IA (2012) Optimal detection of changepoints with a linear computational cost, <em>JASA</em> <b>107(500)</b>, 1590&ndash;1598
</p>
<p>CROPS: Haynes K, Eckley IA, Fearnhead P (2014) Efficient penalty search for multiple changepoint problems (in submission), arXiv:1412.3617
</p>
<p>Binary Segmentation: Scott, A. J. and Knott, M. (1974) A Cluster Analysis Method for Grouping Means in the Analysis of Variance, <em>Biometrics</em> <b>30(3)</b>, 507&ndash;512
</p>
<p>Segment Neighbourhoods: Auger, I. E. And Lawrence, C. E. (1989) Algorithms for the Optimal Identification of Segment Neighborhoods, <em>Bulletin of Mathematical Biology</em> <b>51(1)</b>, 39&ndash;54
</p>
<p>MBIC: Zhang, N. R. and Siegmund, D. O. (2007) A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data. <em>Biometrics</em> <b>63</b>, 22-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>,<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a change in variance at 100 in simulated normal data
set.seed(1)
x=c(rnorm(100,0,1),rnorm(100,0,10))
cpt.var(x,penalty="SIC",method="AMOC",class=FALSE) # returns 100 to show that the null hypothesis
#was rejected and the change in variance is at 100
ans=cpt.var(x,penalty="Asymptotic",pen.value=0.01,method="AMOC") 
cpts(ans)# returns 100 to show that the null hypothesis was rejected, the change in variance is at
#100 and we are 99% confident of this result

# Example of multiple changes in variance at 50,100,150 in simulated data
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,0,10),rnorm(50,0,5),rnorm(50,0,1))
cpt.var(x,penalty="Manual",pen.value="log(2*log(n))",method="BinSeg",test.stat="CSS",Q=5,
class=FALSE) # returns optimal number of changepoints is 4, locations are 50,53,99,150.

# Example of using CROPS in the above example
set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,0,10),rnorm(50,0,5),rnorm(50,0,1))
out=cpt.var(x,pen.value=c(log(length(x)),100*log(length(x))),penalty="CROPS",method="PELT")
cpts.full(out) # returns 7 segmentations for penalty values between log(n) and 100log(n).
# We find segmentations with 7, 5, 4,3,2,1 and 0 changepoints.
# Note that the empty final row indicates no changepoints.
pen.value.full(out) # gives associated penalty transition points
# CROPS does not give an optimal set of changepoints thus we may wish to explore further
plot(out,diagnostic=TRUE) 
# looks like the segmentation with 3 changepoints, 50,100,150 is the most appropriate
plot(out,ncpts=3) 

# Example multiple datasets where the first row has multiple changes in variance and the second row
#has no change in variance
set.seed(10)
x=c(rnorm(50,0,1),rnorm(50,0,10),rnorm(50,0,5),rnorm(50,0,1))
y=rnorm(200,0,1)
z=rbind(x,y)
cpt.var(z,penalty="Asymptotic",pen.value=0.01,method="SegNeigh",Q=5,class=FALSE) # returns list that
#has two elements, the first has 3 changes in variance at 50,100,149 and the second has no changes
#in variance
ans=cpt.var(z,penalty="Asymptotic",pen.value=0.01,method="PELT") 
cpts(ans[[1]]) # same results as for the SegNeigh method.
cpts(ans[[2]]) # same results as for the SegNeigh method.
</code></pre>

<hr>
<h2 id='cpts'>
Generic Function - cpts
</h2><span id='topic+cpts'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="cpts_+3A_...">...</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used and whether ... is needed/warranted (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpts-methods">cpts-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
cpts(x) # retrieves the cpts slot from x
</code></pre>

<hr>
<h2 id='cpts-methods'> ~~ Methods for Function cpts  ~~</h2><span id='topic+cpts-methods'></span><span id='topic+cpts+2Ccpt-method'></span><span id='topic+cpts+2Ccpt.reg-method'></span><span id='topic+cpts+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpts</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves cpts slot from an object of class cpt, from version 1.0 this no longer prints the length of the dataset.
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves cpts slot from an object of class cpt.reg, from version 1.0 this no longer prints the length of the dataset.
</p>
</dd>
<dt><code>signature(object = "cpt.range",ncpts=NA)</code></dt><dd>
<p>Retrieves the row in the cpts.full slot from an object of class cpt.range that has length ncpts, from version 1.0 this no longer prints the length of the dataset.
</p>
</dd>
</dl>

<hr>
<h2 id='cpts.full'>
Generic Function - cpts.full
</h2><span id='topic+cpts.full'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts.full(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts.full_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpts.full-methods">cpts.full-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt.range") # new cpt.range object
cpts.full(x) # retrieves the cpts.full slot from x
</code></pre>

<hr>
<h2 id='cpts.full-methods'> ~~ Methods for Function cpts.full  ~~</h2><span id='topic+cpts.full-methods'></span><span id='topic+cpts.full+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpts.full</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt.range")</code></dt><dd>
<p>Retrieves cpts.full slot from an object of class cpt.range.
</p>
</dd>
</dl>

<hr>
<h2 id='cpts.full+26lt+3B-'>
Generic Function - cpts.full&lt;-
</h2><span id='topic+cpts.full+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts.full(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts.full+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="cpts.full+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpts.full+3C--methods">cpts.full&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt.range") # new cpt.range object
cpts.full(x)&lt;-matrix(c(10,20,10,NA),nrow=2,byrow=TRUE) 
# replaces the vector of changepoint in object x with the given matrix
</code></pre>

<hr>
<h2 id='cpts.full+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function cpts.full&lt;-  ~~</h2><span id='topic+cpts.full+3C--methods'></span><span id='topic+cpts.full+3C-+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpts.full&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt.range")</code></dt><dd>
<p>Assigns the value following &lt;- to the cpts.full slot in x.  This is required to be a matrix.
</p>
</dd>
</dl>

<hr>
<h2 id='cpts.ts'>
Generic Function - cpts.ts
</h2><span id='topic+cpts.ts'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts.ts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts.ts_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpts.ts-methods">cpts.ts-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
cpts.ts(x) # retrieves the cpts slot from x but unlike cpts, displays the "date" index rather than
#the position within the vector
</code></pre>

<hr>
<h2 id='cpts.ts-methods'> ~~ Methods for Function cpts.ts  ~~</h2><span id='topic+cpts.ts-methods'></span><span id='topic+cpts.ts+2Ccpt-method'></span><span id='topic+cpts.ts+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpts.ts</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves cpts slot from an object of class cpt, from version 1.0 this no longer prints the length of the dataset.  Contrary to the <code>cpts</code> function, cpts.ts displays the changepoints using the &quot;date&quot; index according to the start and frequency of the time series data.set(object)
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves cpts slot from an object of class cpt.reg, from version 1.0 this no longer prints the length of the dataset.  Contrary to the <code>cpts</code> function, cpts.ts displays the changepoints using the &quot;date&quot; index according to the start and frequency of the time series data.set(object)
</p>
</dd>
</dl>

<hr>
<h2 id='cpts+26lt+3B-'>
Generic Function - cpts&lt;-
</h2><span id='topic+cpts+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="cpts+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpts+3C--methods">cpts&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
cpts(x)&lt;-10 # replaces the vector of changepoint in object x with 10
</code></pre>

<hr>
<h2 id='cpts+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function cpts&lt;-  ~~</h2><span id='topic+cpts+3C--methods'></span><span id='topic+cpts+3C-+2Ccpt-method'></span><span id='topic+cpts+3C-+2Ccpt.reg-method'></span><span id='topic+cpts+3C-+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpts&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the cpts slot in x, from version 1.0 this no longer requires the last entry to be the length of the dataset.
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the cpts slot in x, from version 1.0 this no longer requires the last entry to be the length of the dataset.
</p>
</dd>
<dt><code>signature(x = "cpt.range")</code></dt><dd>
<p>Assigns the value following &lt;- to the cpts slot in x, from version 1.0 this no longer requires the last entry to be the length of the dataset.
</p>
</dd>
</dl>

<hr>
<h2 id='cpttype'>
Generic Function - cpttype
</h2><span id='topic+cpttype'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpttype(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpttype_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpttype-methods">cpttype-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
cpttype(x) # retrieves the cpttype slot from x
</code></pre>

<hr>
<h2 id='cpttype-methods'> ~~ Methods for Function cpttype  ~~</h2><span id='topic+cpttype-methods'></span><span id='topic+cpttype+2Ccpt-method'></span><span id='topic+cpttype+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpttype</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves cpttype slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves cpttype slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='cpttype+26lt+3B-'>
Generic Function - cpttype
</h2><span id='topic+cpttype+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpttype(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpttype+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="cpttype+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpttype+3C--methods">cpttype&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
cpttype(x)&lt;-"mean" # replaces the existing cpttype in object x with "mean"
</code></pre>

<hr>
<h2 id='cpttype+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function cpttype&lt;-  ~~</h2><span id='topic+cpttype+3C--methods'></span><span id='topic+cpttype+3C-+2Ccpt-method'></span><span id='topic+cpttype+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>cpttype&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the cpttype slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the cpttype slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='data.set'>
Generic Function - data.set
</h2><span id='topic+data.set'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.set(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.set_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.set-methods">data.set-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
data.set(x) # retrieves the data.set slot from x
</code></pre>

<hr>
<h2 id='data.set-methods'> ~~ Methods for Function data.set  ~~</h2><span id='topic+data.set-methods'></span><span id='topic+data.set+2Ccpt-method'></span><span id='topic+data.set+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>data.set</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves the data.set slot from objects with class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves the data.set slot from objects with class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='data.set.ts'>
Generic Function - data.set.ts
</h2><span id='topic+data.set.ts'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.set.ts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.set.ts_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.set.ts-methods">data.set.ts-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
data.set.ts(x) # retrieves the data.set slot from x.  This is a ts object.
</code></pre>

<hr>
<h2 id='data.set.ts-methods'> ~~ Methods for Function data.set.ts  ~~</h2><span id='topic+data.set.ts-methods'></span><span id='topic+data.set.ts+2Ccpt-method'></span><span id='topic+data.set.ts+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>data.set.ts</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves the data.set slot from objects with class cpt.  This returns a ts class object.
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves the data.set slot from objects with class cpt.reg. This returns a ts class object.
</p>
</dd>
</dl>

<hr>
<h2 id='data.set+26lt+3B-'>
Generic Function - data.set&lt;-
</h2><span id='topic+data.set+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.set(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.set+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="data.set+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.set+3C--methods">data.set&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
data.set(x)&lt;-c(1,2,3,4,5) # replaces the existing data.set slot in x with c(1,2,3,4,5)
</code></pre>

<hr>
<h2 id='data.set+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function data.set&lt;-  ~~</h2><span id='topic+data.set+3C--methods'></span><span id='topic+data.set+3C-+2Ccpt-method'></span><span id='topic+data.set+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>data.set&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the data.set slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the data.set slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='decision'>
Decision Function - Only intended for developer use.
</h2><span id='topic+decision'></span>

<h3>Description</h3>

<p>Uses the function parameters to decide if a proposed changepoint is a true changepoint or due to random variability.  Test is conducted using the user specified penalty.
</p>
<p>This function is called by <code>cpt.mean</code>, <code>cpt.var</code> and <code>cpt.meanvar</code> when <code>method="AMOC"</code>.  This is not intended for use by regular users of the package.  It is exported for developers to call directly for speed increases or to fit alternative cost functions.
</p>
<p>WARNING: No checks on arguments are performed!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision(tau,null,alt=NA,penalty="MBIC",n=0,diffparam=1,pen.value=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_+3A_tau">tau</code></td>
<td>

<p>A numeric value or vector specifying the proposed changepoint location(s).
</p>
</td></tr>
<tr><td><code id="decision_+3A_null">null</code></td>
<td>

<p>The value of the null test statistic.  If tau is a vector, so is null.  If the test statistic is already known (i.e. doesn't have null and alternative components), replace the null argument with the test statistic.
</p>
</td></tr>
<tr><td><code id="decision_+3A_alt">alt</code></td>
<td>

<p>The value of the alternative test statistic (at tau).  If tau is a vector, so is alt.  If the test statistic is already known, then it is used in replacement of the null argument and the alternative should not be specified (default NA to account for this)
</p>
</td></tr>
<tr><td><code id="decision_+3A_penalty">penalty</code></td>
<td>

<p>Choice of &quot;None&quot;, &quot;SIC&quot;, &quot;BIC&quot;, &quot;MBIC&quot;, AIC&quot;, &quot;Hannan-Quinn&quot;, &quot;Asymptotic&quot; and &quot;Manual&quot; penalties.  If Manual is specified, the manual penalty is contained in the pen.value parameter. If Asymptotic is specified, the theoretical type I error is contained in the pen.value parameter. The predefined penalties listed DO count the changepoint as a parameter, postfix a 0 e.g.&quot;SIC0&quot; to NOT count the changepoint as a parameter.
</p>
</td></tr>
<tr><td><code id="decision_+3A_n">n</code></td>
<td>

<p>The length of the original data, required to give sensible &quot;no changepoint&quot; output.
</p>
</td></tr>
<tr><td><code id="decision_+3A_diffparam">diffparam</code></td>
<td>

<p>The difference in the number of parameters in the null and alternative hypotheses, required for the SIC, BIC, AIC, Hanna-Quinn and possibly Manual penalties.
</p>
</td></tr>
<tr><td><code id="decision_+3A_pen.value">pen.value</code></td>
<td>

<p>The theoretical type I error e.g.0.05 when using the Asymptotic penalty.  The value of the penalty when using the Manual penalty option - this can be a numeric value or text giving the formula to use.  Available variables are, n=length of original data, null=null likelihood, alt=alternative likelihood, tau=proposed changepoint, diffparam=difference in number of alternatve and null parameters.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to test whether tau is a true changepoint or not.  This test uses the null-alternative as the test statistic and performs the test where the null hypothesis is no change point and the alternative hypothesis is a single changepoint at tau.  The test is (null-alt)&gt;=penalty, if TRUE then the changepoint is deemed a true changepoint, if FALSE then n (length of data) is returned.
</p>
<p>If the test statistic is already known then it replaces the null value and the alternative is not required (default NA).  In this case the test is null&gt;=penalty, if TRUE then the changepoint is deemed a true changepoint, if FALSE then n (length of data) is returned.
</p>
<p>This function is exported for developer use only.  It does not perform any checks on inputs and is included for convenience and speed for those who are developing their own cost functions.
</p>


<h3>Value</h3>

<p>A list is returned with two elements, cpt and pen.
</p>
<table>
<tr><td><code>cpt</code></td>
<td>
<p> If tau is a single value then a single value is returned: Either the value of the true changepoint location or n (length of data) if no changepoint is found.
</p>
<p>If tau is a vector of length m then a vector of length m is returned:Each element is either the value of the true changepoint location or n (length of data) if no changepoint is found.  The first element is for the first value of tau and the final element is for the final value of tau.
</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>The numeric value of the penalty used for the test(s).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>SIC/BIC: Schwarz, G. (1978) Estimating the Dimension of a Model, <em>The Annals of Statistics</em> <b>6(2)</b>, 461&ndash;464
</p>
<p>MBIC: Zhang, N. R. and Siegmund, D. O. (2007) A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data. <em>Biometrics</em> <b>63</b>, 22-32.
</p>
<p>AIC: Akaike, H. (1974) A new look at the statistical model identification, <em>Automatic Control, IEEE Transactions on</em> <b>19(6)</b>, 716&ndash;723
</p>
<p>Hannan-Quinn: Hannan, E. J. and B. G. Quinn (1979) The Determination of the Order of an Autoregression, <em>Journal of the Royal Statistical Society, B</em> <b>41</b>, 190&ndash;195
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of finding a change
out=c(100,765.1905,435.6529) # tau, null, alt
decision(out[1],out[2],out[3],penalty="SIC",n=200,diffparam=1) # returns 100 as a true changepoint

# Example of no change found
out=c(53,-22.47768,-24.39894) # tau, null, alt
decision(out[1],out[2],out[3],penalty="Manual",n=200,diffparam=1,pen.value="2*log(n)")
</code></pre>

<hr>
<h2 id='distribution'>
Generic Function - distribution
</h2><span id='topic+distribution'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distribution-methods">distribution-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
distribution(x) # retrieves the distribution slot from x
</code></pre>

<hr>
<h2 id='distribution-methods'> ~~ Methods for Function distribution  ~~</h2><span id='topic+distribution-methods'></span><span id='topic+distribution+2Ccpt-method'></span><span id='topic+distribution+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>distribution</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves distribution slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves distribution slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='distribution+26lt+3B-'>
Generic Function - distribution&lt;-
</h2><span id='topic+distribution+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="distribution+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distribution+3C--methods">distribution&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
distribution(x)&lt;-"normal" # replaces the current distribution slot of x with "normal"
</code></pre>

<hr>
<h2 id='distribution+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function distribution&lt;-  ~~</h2><span id='topic+distribution+3C--methods'></span><span id='topic+distribution+3C-+2Ccpt-method'></span><span id='topic+distribution+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>distribution&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the distribution slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the distribution slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='ftse100'>
FTSE 100 Daily Returns: 2nd April 1984 &ndash; 13th September 2012
</h2><span id='topic+ftse100'></span>

<h3>Description</h3>

<p>This dataset gives the daily returns (c_t+1/c_t -1) of the UK FTSE 100 index from 2nd April 1984 until the 13th September 2012.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftse100
</code></pre>


<h3>Format</h3>

<p>A matrix of dimension 7187 x 2 where the first column is the Date and the second column is the Daily Return.
</p>


<h3>Source</h3>

<p>Yahoo! Finance</p>

<hr>
<h2 id='HC1'>
G+C Content in Human Chromosome 1
</h2><span id='topic+HC1'></span>

<h3>Description</h3>

<p>This dataset gives the G+C content in 3kb windows along the Human Chromosome from 10Mb to 33Mb (no missing data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HC1
</code></pre>


<h3>Format</h3>

<p>A vector of length 23553.
</p>


<h3>Source</h3>

<p>http://www.ncbi.nlm.nih.gov/mapview/map_search.cgi?taxid=9606&amp;build=previous</p>

<hr>
<h2 id='Lai2005fig3'>
Normalized glioblastoma profile for chromosome 13
</h2><span id='topic+Lai2005fig3'></span>

<h3>Description</h3>

<p>This dataset is taken from Lai W, Johnson MJ, Kucherlapati R, Park PJ, Bioinformatics , 2005.  The paper states that the original source of the data is from Bredel et al. (2005).  The data is Chromosome 13 in GBM31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lai2005fig3
</code></pre>


<h3>Format</h3>

<p>A matrix of dimensions 797 x 5.  The columns are Spot, CH, POS.start, POS.end, GBM31.
</p>


<h3>Source</h3>

<p>http://compbio.med.harvard.edu/Supplements/Bioinformatics05b/Profiles/Chrom_13_GBM31.xls</p>

<hr>
<h2 id='Lai2005fig4'>
Normalized glioblastoma profile for an excerpt of chromosome 7, the EGFR locus.
</h2><span id='topic+Lai2005fig4'></span>

<h3>Description</h3>

<p>This dataset is taken from Lai W, Johnson MJ, Kucherlapati R, Park PJ, Bioinformatics , 2005.  The paper states that the original source of the data is from Bredel et al. (2005).  The data is an excerpt of chromosome 7 in GBM29 from 40 to 65 Mb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lai2005fig4
</code></pre>


<h3>Format</h3>

<p>A matrix of dimensions 193 x 5.  The columns are Spot, CH, POS.start, POS.end, GBM31.
</p>


<h3>Source</h3>

<p>http://compbio.med.harvard.edu/Supplements/Bioinformatics05b/Profiles/Chrom_7_from40_to65Mb_GBM29.xls</p>

<hr>
<h2 id='likelihood'>
Generic Function - likelihood
</h2><span id='topic+likelihood'></span>

<h3>Description</h3>

<p>Generic function to calculate the likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used to calculate the likelihood (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function to calculate the likelihood.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likelihood-methods">likelihood-methods</a></code>, <code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,0,10),rnorm(50,0,5),rnorm(50,0,1))
out=cpt.var(x,penalty="Manual",pen.value="2*log(n)",method="BinSeg",Q=5)
likelihood(out) # returns the raw scaled negative likelihood (925.8085) and the scaled negative
#likelihood + penalty (957.5984)
</code></pre>

<hr>
<h2 id='likelihood-methods'> ~~ Methods for Function likelihood  ~~</h2><span id='topic+likelihood-methods'></span><span id='topic+likelihood+2Ccpt-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>likelihood</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Returns the likelihood of the data with the fitted changepoints, two values are returned, the raw scaled negative likelihood and the scaled negative likelihood + penalty.  Only valid for cpttype=&quot;mean&quot;,&quot;variance&quot; or &quot;mean and variance&quot;.
</p>
</dd>
</dl>

<hr>
<h2 id='logLik-methods'> ~~ Methods for Function logLik  ~~</h2><span id='topic+logLik-methods'></span><span id='topic+logLik+2Ccpt-method'></span><span id='topic+logLik+2Ccpt.reg-method'></span><span id='topic+logLik+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>logLik</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Returns the -2*log-likelihood of the data with the fitted changepoints, two values are returned, the raw twice negative log-likelihood and twice negative log-likelihood + penalty.  Only valid for cpttype=&quot;mean&quot;,&quot;variance&quot; or &quot;mean and variance&quot;.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x=c(rnorm(50,0,1),rnorm(50,0,10),rnorm(50,0,5),rnorm(50,0,1))
out=cpt.var(x,penalty="Manual",pen.value="2*log(n)",method="BinSeg",Q=5)
logLik(out) # returns the raw scaled negative likelihood (925.8085) and the scaled negative
#likelihood + penalty (957.5984)
</code></pre>

<hr>
<h2 id='method'>
Generic Function - method
</h2><span id='topic+method'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+method-methods">method-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
method(x) # retrieves the method slot from x
</code></pre>

<hr>
<h2 id='method-methods'> ~~ Methods for Function method  ~~</h2><span id='topic+method-methods'></span><span id='topic+method+2Ccpt-method'></span><span id='topic+method+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>method</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves method slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves method slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='method+26lt+3B-'>
Generic Function - method&lt;-
</h2><span id='topic+method+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="method+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+method+3C--methods">method&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
method(x)&lt;-"mean" # replaces the existing method slot in x with "mean"
</code></pre>

<hr>
<h2 id='method+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function method&lt;-  ~~</h2><span id='topic+method+3C--methods'></span><span id='topic+method+3C-+2Ccpt-method'></span><span id='topic+method+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>method&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the method slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the method slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='minseglen'>
Generic Function - minseglen
</h2><span id='topic+minseglen'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minseglen(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minseglen_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minseglen-methods">minseglen-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
minseglen(x) # retrieves the minseglen slot from x
</code></pre>

<hr>
<h2 id='minseglen-methods'> ~~ Methods for Function minseglen  ~~</h2><span id='topic+minseglen-methods'></span><span id='topic+minseglen+2Ccpt-method'></span><span id='topic+minseglen+2Ccpt.reg-method'></span><span id='topic+minseglen+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>minseglen</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves minseglen slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.range")</code></dt><dd>
<p>Retrieves minseglen slot from an object of class cpt.range
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves minseglen slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='minseglen+26lt+3B-'>
Generic Function - minseglen&lt;-
</h2><span id='topic+minseglen+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minseglen(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minseglen+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="minseglen+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minseglen+3C--methods">minseglen&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
minseglen(x)&lt;-5 # replaces the existing minseglen slot in x with 5
</code></pre>

<hr>
<h2 id='minseglen+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function minseglen&lt;-  ~~</h2><span id='topic+minseglen+3C--methods'></span><span id='topic+minseglen+3C-+2Ccpt-method'></span><span id='topic+minseglen+3C-+2Ccpt.reg-method'></span><span id='topic+minseglen+3C-+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>minseglen&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the minseglen slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the minseglen slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.range")</code></dt><dd>
<p>Assigns the value following &lt;- to the minseglen slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='ncpts'>
Generic Function - ncpts
</h2><span id='topic+ncpts'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncpts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncpts_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncpts-methods">ncpts-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
ncpts(x) # returns the number of changepoints (i.e. length of the cpts slot in x minus 1)
</code></pre>

<hr>
<h2 id='ncpts-methods'> ~~ Methods for Function ncpts  ~~</h2><span id='topic+ncpts-methods'></span><span id='topic+ncpts+2Ccpt-method'></span><span id='topic+ncpts+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>ncpts</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Returns the number of changepoints (i.e. length of the cpts slot minus 1) from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Returns the number of changepoints (i.e. length of the cpts slot minus 1) from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='ncpts.max'>
Generic Function - ncpts.max
</h2><span id='topic+ncpts.max'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncpts.max(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncpts.max_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncpts.max-methods">ncpts.max-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
ncpts.max(x) # retrieves the ncpts.max slot from x
</code></pre>

<hr>
<h2 id='ncpts.max-methods'> ~~ Methods for Function ncpts.max  ~~</h2><span id='topic+ncpts.max-methods'></span><span id='topic+ncpts.max+2Ccpt-method'></span><span id='topic+ncpts.max+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>ncpts.max</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves ncpts.max slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves ncpts.max slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='ncpts.max+26lt+3B-'>
Generic Function - ncpts.max&lt;-
</h2><span id='topic+ncpts.max+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncpts.max(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncpts.max+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="ncpts.max+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function.
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncpts.max+3C--methods">ncpts.max&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
ncpts.max(x)&lt;-10 # replaces the vector of changepoint in object x with 10
</code></pre>

<hr>
<h2 id='ncpts.max+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function ncpts.max&lt;-  ~~</h2><span id='topic+ncpts.max+3C--methods'></span><span id='topic+ncpts.max+3C-+2Ccpt-method'></span><span id='topic+ncpts.max+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>ncpts.max&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the ncpts.max slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the ncpts.max slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='nseg'>
Generic Function - nseg
</h2><span id='topic+nseg'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nseg(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nseg_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nseg-methods">nseg-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
nseg(x) # returns the number of segments (i.e. length of the cpts slot)
</code></pre>

<hr>
<h2 id='nseg-methods'> ~~ Methods for Function nseg  ~~</h2><span id='topic+nseg-methods'></span><span id='topic+nseg+2Ccpt-method'></span><span id='topic+nseg+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>nseg</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Returns the number of segments (i.e. length of the cpts slot) from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Returns the number of segments (i.e. length of the cpts slot) from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='param'>
Generic Function - param
</h2><span id='topic+param'></span>

<h3>Description</h3>

<p>Generic function that returns parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used to find the parameter estimates (and if one exists)
</p>
</td></tr>
<tr><td><code id="param_+3A_...">...</code></td>
<td>

<p>Other variables that may be required depending on the class of <code>object</code>, see individual methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function that returns parameter estimates
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param-methods">param-methods</a></code>,<code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x=c(rnorm(100,0,1),rnorm(100,0,10))
ans=cpt.var(x,penalty="Asymptotic",pen.value=0.01,method="AMOC",param.estimates=FALSE)
# if estimates were not requested in the analysis then they can be created at a later stage if
#required
ans=param(ans) # fills the param.est slot with the parameter estimes.
param.est(ans) # variance is 0.8067621
</code></pre>

<hr>
<h2 id='param-methods'> ~~ Methods for Function param  ~~</h2><span id='topic+param-methods'></span><span id='topic+param+2Ccpt-method'></span><span id='topic+param+2Ccpt.range-method'></span><span id='topic+param+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>param</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Replaces the <code>param.value</code> slot in object with the parameter estimates that are appropriate for the changepoint type (<code>cpttype</code> slot).  If the Gamma test statistic is used then the shape parameter is required as a variable.
</p>
</dd>
<dt><code>signature(object = "cpt.range")</code></dt><dd>
<p>Returns a new (blank) cpt.range object where the <code>param.value</code> slot contains the parameter estimates for a segmentation with the <code>ncpts</code> specified number of changepoints.  This is also tailored to the changepoint type (<code>cpttype</code> slot) of the original object.  If the Gamma test statistic is used then the shape parameter is required as a variable.  An example of use is given in the <a href="#topic+cpt.mean">cpt.mean</a> help file.
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Replaces the <code>param.value</code> slot in object with the parameter estimates that are appropriate for the changepoint test statistic (<code>test.stat</code> slot).
</p>
</dd>
</dl>

<hr>
<h2 id='param.est'>
Generic Function - param.est
</h2><span id='topic+param.est'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.est(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.est_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param.est-methods">param.est-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
param.est(x) # retrieves the param.est slot from x
</code></pre>

<hr>
<h2 id='param.est-methods'> ~~ Methods for Function param.est  ~~</h2><span id='topic+param.est-methods'></span><span id='topic+param.est+2Ccpt-method'></span><span id='topic+param.est+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>param.est</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves param.est slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves param.est slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='param.est+26lt+3B-'>
Generic Function - param.est&lt;-
</h2><span id='topic+param.est+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.est(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.est+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="param.est+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param.est+3C--methods">param.est&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
param.est(x)&lt;-list(mean=0) # replaces the current param.est list in x with list(mean=0)
</code></pre>

<hr>
<h2 id='param.est+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function param.est&lt;-  ~~</h2><span id='topic+param.est+3C--methods'></span><span id='topic+param.est+3C-+2Ccpt-method'></span><span id='topic+param.est+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>param.est&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the param.est slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the param.est slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='PELT'>
PELT (Pruned Exact Linear Time) - Only intended for developer use.
</h2><span id='topic+PELT'></span>

<h3>Description</h3>

<p>Implements the PELT method for identifying changepoints in a given set of summary statistics for a specified cost function and penalty.
</p>
<p>This function is called by <code>cpt.mean</code>, <code>cpt.var</code> and <code>cpt.meanvar</code> when <code>method="PELT"</code>.  This is not intended for use by regular users of the package.  It is exported for developers to call directly for speed increases or to fit alternative cost functions.
</p>
<p>WARNING: No checks on arguments are performed!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PELT(sumstat, pen = 0, cost_func = "norm.mean", shape = 1, minseglen = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PELT_+3A_sumstat">sumstat</code></td>
<td>

<p>A matrix containing the summary statistics of data within which you wish to find a changepoint.  Currently assumes 3 columns and uses the number of rows as the length of the data +1 (initial value of 0).
</p>
</td></tr>
<tr><td><code id="PELT_+3A_pen">pen</code></td>
<td>

<p>Default choice is 0, this should be evaluated elsewhere and a numerical value entered.  This should be positive - this isn't checked but results are meaningless if it isn't.
</p>
</td></tr>
<tr><td><code id="PELT_+3A_cost_func">cost_func</code></td>
<td>

<p>The friendly name of the cost function to be called in C.  If using your own cost function, this must be the name of the C function to use.
</p>
</td></tr>
<tr><td><code id="PELT_+3A_shape">shape</code></td>
<td>

<p>Only required for cost_func=&quot;Gamma&quot;,default is 1.  Must be a positive value, this isn't checked.
</p>
</td></tr>
<tr><td><code id="PELT_+3A_minseglen">minseglen</code></td>
<td>

<p>Positive integer giving the minimum segment length (no. of observations between changes), default is 1.  No checks are performed on the input value so it could be larger than feasible to have changes in the data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used as a wrapper function to implement the PELT algorithm in C.  It simply creates the necessary worker vectors, ensures all inputs are the correct type, and passes everything to the C function.
</p>
<p>This function is exported for developer use only.  It does not perform any checks on inputs (other than type coersion) and is simply a wrapper function for the C code.
</p>


<h3>Value</h3>

<p>A list is returned with elements:
</p>
<table>
<tr><td><code>lastchangecpts</code></td>
<td>
<p>Vector of length n containing the last changepoint prior to each timepoint.</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>Ordered list of optimal number of changepoints ending with n.</p>
</td></tr>
<tr><td><code>lastchangelike</code></td>
<td>
<p>Vector of lenght n containing the likelihood of the optimal segmentation up to each timepoint.</p>
</td></tr>
<tr><td><code>ncpts</code></td>
<td>
<p>Number of changes identified.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>PELT Algorithm: Killick R, Fearnhead P, Eckley IA (2012) Optimal detection of changepoints with a linear computational cost, <em>JASA</em> <b>107(500)</b>, 1590&ndash;1598
</p>
<p>CROPS: Haynes K, Eckley IA, Fearnhead P (2014) Efficient penalty search for multiple changepoint problems (in submission), arXiv:1412.3617
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>,<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="#topic+cpt-class">cpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This function should only be used by developers, see its use in cpt.mean, cpt.var and cpt.meanvar.
</code></pre>

<hr>
<h2 id='pen.type'>
Generic Function - pen.type
</h2><span id='topic+pen.type'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.type(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.type_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pen.type-methods">pen.type-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
pen.type(x) # retrieves the pen.type slot from x
</code></pre>

<hr>
<h2 id='pen.type-methods'> ~~ Methods for Function pen.type  ~~</h2><span id='topic+pen.type-methods'></span><span id='topic+pen.type+2Ccpt-method'></span><span id='topic+pen.type+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>pen.type</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves pen.type slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves pen.type slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='pen.type+26lt+3B-'>
Generic Function - pen.type&lt;-
</h2><span id='topic+pen.type+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.type(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.type+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="pen.type+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pen.type+3C--methods">pen.type&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
pen.type(x)&lt;-"SIC" # replaces the existing pen.type slot in x with "SIC"
</code></pre>

<hr>
<h2 id='pen.type+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function pen.type&lt;-  ~~</h2><span id='topic+pen.type+3C--methods'></span><span id='topic+pen.type+3C-+2Ccpt-method'></span><span id='topic+pen.type+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>pen.type&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the pen.type slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the pen.type slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='pen.value'>
Generic Function - pen.value
</h2><span id='topic+pen.value'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.value(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.value_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pen.value-methods">pen.value-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
pen.value(x) # retrieves the pen.value slot from x
</code></pre>

<hr>
<h2 id='pen.value-methods'> ~~ Methods for Function pen.value  ~~</h2><span id='topic+pen.value-methods'></span><span id='topic+pen.value+2Ccpt-method'></span><span id='topic+pen.value+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>pen.value</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves pen.value slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves pen.value slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='pen.value.full'>
Generic Function - pen.value.full
</h2><span id='topic+pen.value.full'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.value.full(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.value.full_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pen.value.full-methods">pen.value.full-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt.range") # new cpt.range object
pen.value.full(x) # retrieves the pen.value.full slot from x
</code></pre>

<hr>
<h2 id='pen.value.full-methods'> ~~ Methods for Function pen.value.full  ~~</h2><span id='topic+pen.value.full-methods'></span><span id='topic+pen.value.full+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>pen.value.full</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt.range")</code></dt><dd>
<p>Retrieves pen.value.full slot from an object of class cpt.range.
</p>
</dd>
</dl>

<hr>
<h2 id='pen.value.full+26lt+3B-'>
Generic Function - pen.value.full&lt;-
</h2><span id='topic+pen.value.full+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.value.full(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.value.full+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="pen.value.full+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pen.value.full+3C--methods">pen.value.full&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt.range") # new cpt.range object
pen.value.full(x)&lt;-5 # replaces the existing pen.value.full slot in x with 5
</code></pre>

<hr>
<h2 id='pen.value.full+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function pen.value.full&lt;-  ~~</h2><span id='topic+pen.value.full+3C--methods'></span><span id='topic+pen.value.full+3C-+2Ccpt.range-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>pen.value.full&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt.range")</code></dt><dd>
<p>Assigns the value following &lt;- to the pen.value.full slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='pen.value+26lt+3B-'>
Generic Function - pen.value
</h2><span id='topic+pen.value+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen.value(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen.value+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="pen.value+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pen.value+3C--methods">pen.value&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
pen.value(x)&lt;-5 # replaces the existing pen.value slot in x with 5
</code></pre>

<hr>
<h2 id='pen.value+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function pen.value&lt;-  ~~</h2><span id='topic+pen.value+3C--methods'></span><span id='topic+pen.value+3C-+2Ccpt-method'></span><span id='topic+pen.value+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>pen.value&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the pen.value slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the pen.value slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='penalty_decision'>
Penalty Decision Function - Only intended for developer use.
</h2><span id='topic+penalty_decision'></span>

<h3>Description</h3>

<p>Evaluates the arguments to give a numeric value for the penalty.
</p>
<p>This function is called by <code>cpt.mean</code>, <code>cpt.var</code> and <code>cpt.meanvar</code>.  This is not intended for use by regular users of the package.  It is exported for developers to call directly for speed increases or to fit alternative cost functions.
</p>
<p>WARNING: No checks on arguments are performed!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty_decision(penalty, pen.value, n, diffparam, asymcheck, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_decision_+3A_penalty">penalty</code></td>
<td>

<p>Choice of &quot;None&quot;, &quot;SIC&quot;, &quot;BIC&quot;, &quot;MBIC&quot;, AIC&quot;, &quot;Hannan-Quinn&quot;, &quot;Asymptotic&quot; and &quot;Manual&quot; penalties.  If Manual is specified, the manual penalty is contained in the pen.value parameter. If Asymptotic is specified, the theoretical type I error is contained in the pen.value parameter. The predefined penalties listed DO count the changepoint as a parameter, postfix a 0 e.g.&quot;SIC0&quot; to NOT count the changepoint as a parameter.
</p>
</td></tr>
<tr><td><code id="penalty_decision_+3A_pen.value">pen.value</code></td>
<td>

<p>The theoretical type I error e.g.0.05 when using the Asymptotic penalty.  The value of the penalty when using the Manual penalty option - this can be a numeric value or text giving the formula to use.  Available variables are, n=length of original data, null=null likelihood, alt=alternative likelihood, tau=proposed changepoint, diffparam=difference in number of alternatve and null parameters.  
</p>
</td></tr>
<tr><td><code id="penalty_decision_+3A_n">n</code></td>
<td>

<p>The length of the original data, required to give sensible &quot;no changepoint&quot; output.
</p>
</td></tr>
<tr><td><code id="penalty_decision_+3A_diffparam">diffparam</code></td>
<td>

<p>The difference in the number of parameters (degrees of freedom) when a change is added, required for the SIC, BIC, AIC, Hanna-Quinn and possibly Manual penalties.  Do NOT include the changepoint when calculating this number as this is automatically added.
</p>
</td></tr>
<tr><td><code id="penalty_decision_+3A_asymcheck">asymcheck</code></td>
<td>

<p>A text string which translates to the asymptotic formula for a specific cost function.  Currently implemented values are: <code>mean.norm</code>, <code>var.norm</code>, <code>meanvar.norm</code>, <code>reg.norm</code>, <code>var.css</code>, <code>mean.cusum</code>, <code>meanvar.gamma</code>, <code>meanvar.exp</code>, <code>meanvar.poisson</code>.
</p>
</td></tr>
<tr><td><code id="penalty_decision_+3A_method">method</code></td>
<td>

<p>Method used as a text string, see <code><a href="#topic+cpt.mean">cpt.mean</a></code> for further details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the text string input and converts it to a numerical value for the specific length of data specified by n.
</p>
<p>This function is exported for developer use only.  It does not perform any checks on inputs and is included for convenience and speed for those who are developing their own cost functions.
</p>


<h3>Value</h3>

<p>The numeric value of the penalty.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>SIC/BIC: Schwarz, G. (1978) Estimating the Dimension of a Model, <em>The Annals of Statistics</em> <b>6(2)</b>, 461&ndash;464
</p>
<p>MBIC: Zhang, N. R. and Siegmund, D. O. (2007) A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data. <em>Biometrics</em> <b>63</b>, 22-32.
</p>
<p>AIC: Akaike, H. (1974) A new look at the statistical model identification, <em>Automatic Control, IEEE Transactions on</em> <b>19(6)</b>, 716&ndash;723
</p>
<p>Hannan-Quinn: Hannan, E. J. and B. G. Quinn (1979) The Determination of the Order of an Autoregression, <em>Journal of the Royal Statistical Society, B</em> <b>41</b>, 190&ndash;195
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpt.mean">cpt.mean</a></code>,<code><a href="#topic+cpt.var">cpt.var</a></code>,<code><a href="#topic+cpt.meanvar">cpt.meanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of finding a change
out=c(100,765.1905,435.6529) # tau, null, alt
decision(out[1],out[2],out[3],penalty="SIC",n=200,diffparam=1) # returns 100 as a true changepoint

# Example of no change found
out=c(53,-22.47768,-24.39894) # tau, null, alt
decision(out[1],out[2],out[3],penalty="Manual",n=200,diffparam=1,pen.value="2*log(n)")
</code></pre>

<hr>
<h2 id='plot-methods'> ~~ Methods for Function plot in Package &lsquo;graphics&rsquo; ~~</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY-method'></span><span id='topic+plot+2Ccpt-method'></span><span id='topic+plot+2Ccpt.range-method'></span><span id='topic+plot+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>plot</code> in Package &lsquo;graphics&rsquo; ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
<p>Generic plot function, see graphics package description using ?plot
</p>
</dd>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Plots the data and identifies the changepoints using vertical lines (change in variance), horizontal lines (change in mean).  Optional arguments to control the lines: <code>cpt.col</code> equivilent to <code>col</code> to change the colour of the changepoint line; <code>cpt.width</code> equivilent to <code>lwd</code> to change the width of the changepoint line; <code>cpt.style</code> equivilent to <code>lty</code> to change the style of the line.
</p>
</dd>
<dt><code>signature(x = "cpt.range")</code></dt><dd>
<p>As for the <code>cpt</code> objects except for two optional arguments, <code>ncpts</code> and <code>diagnostic</code>.  The <code>ncpts</code> option allows you to specify a plot of the segmentation with <code>ncpts</code> changepoints in, i.e. the optimal may be specified as 10 changes but you want to plot the segmentation with 5 changes (provided a segmentation with 5 changes is listed in <code>cpts.full(x)</code>.  The <code>diagnostic</code> option when set to <code>TRUE</code> plots the number of changepoints in each segmentation against the change in test statistic when adding that change.  This can aide the decision on the number of changepoints as when a true changepoint is added the cost increases/decreases rapidly, but when a changepoint due to noise is added the change is small.  This is akin to a scree plot in principal component analysis.  The idea is that someone may choose to create a plot using <code>diagnostic=TRUE</code>, identify the appropriate number of changes and then replot using <code>ncpts</code> to visualize that segmentation.
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Plotting is only valid for one regressor.  Plots the regressor against the response and identifies the changepoints using horizontal lines.  Optional arguments to control the lines: <code>cpt.col</code> equivilent to <code>col</code> to change the colour of the changepoint line; <code>cpt.width</code> equivilent to <code>lwd</code> to change the width of the changepoint line; <code>cpt.style</code> equivilent to <code>lty</code> to change the style of the line.
</p>
</dd>
</dl>

<hr>
<h2 id='seg.len'>
Generic Function - seg.len
</h2><span id='topic+seg.len'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg.len(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg.len_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.len-methods">seg.len-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
seg.len(x) # returns the length of each segment in the data (i.e. no. of obs between changepoints)
</code></pre>

<hr>
<h2 id='seg.len-methods'> ~~ Methods for Function seg.len  ~~</h2><span id='topic+seg.len-methods'></span><span id='topic+seg.len+2Ccpt-method'></span><span id='topic+seg.len+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>seg.len</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Returns the length of segments from an object of class cpt, i.e. the number of observations between changepoints
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Returns the length of segments from an object of class cpt.reg, i.e. the number of observations between changepoints
</p>
</dd>
</dl>

<hr>
<h2 id='show-methods'> ~~ Methods for Function print in Package &lsquo;base&rsquo; ~~</h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Ccpt-method'></span><span id='topic+show+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>show</code> in Package &lsquo;base&rsquo; ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
<p>Generic print function, see base package description using ?print
</p>
</dd>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Prints out information contained within the object x including a summary
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Prints out information contained within the object x including a summary
</p>
</dd>
</dl>

<hr>
<h2 id='summary-methods'> ~~ Methods for Function summary in Package &lsquo;base&rsquo; ~~</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2Ccpt-method'></span><span id='topic+summary+2Ccpt.range-method'></span><span id='topic+summary+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>summary</code> in Package &lsquo;base&rsquo; ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>Generic summary function, see base package description using ?summary
</p>
</dd>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Prints out a summary of the object to the terminal.
</p>
</dd>
<dt><code>signature(object = "cpt.range")</code></dt><dd>
<p>Prints out a summary of the object to the terminal.
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Prints out a summary of the object to the terminal.
</p>
</dd>
</dl>

<hr>
<h2 id='test.stat'>
Generic Function - test.stat
</h2><span id='topic+test.stat'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.stat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.stat_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.stat-methods">test.stat-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
test.stat(x) # retrieves the test.stat slot from x
</code></pre>

<hr>
<h2 id='test.stat-methods'> ~~ Methods for Function test.stat  ~~</h2><span id='topic+test.stat-methods'></span><span id='topic+test.stat+2Ccpt-method'></span><span id='topic+test.stat+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>test.stat</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "cpt")</code></dt><dd>
<p>Retrieves test.stat slot from an object of class cpt
</p>
</dd>
<dt><code>signature(object = "cpt.reg")</code></dt><dd>
<p>Retrieves test.stat slot from an object of class cpt.reg
</p>
</dd>
</dl>

<hr>
<h2 id='test.stat+26lt+3B-'>
Generic Function - test.stat&lt;-
</h2><span id='topic+test.stat+3C-'></span>

<h3>Description</h3>

<p>Generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.stat(object)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.stat+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Depending on the class of <code>object</code> depends on the method used (and if one exists)
</p>
</td></tr>
<tr><td><code id="test.stat+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic Function
</p>


<h3>Value</h3>

<p>Depends on the class of <code>object</code>, see individual methods
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.stat+3C--methods">test.stat&lt;&ndash;methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=new("cpt") # new cpt object
test.stat(x)&lt;-"normal" # replaces the current test.stat slot of x with "normal"
</code></pre>

<hr>
<h2 id='test.stat+26lt+3B+26ndash+3Bmethods'> ~~ Methods for Function test.stat&lt;-  ~~</h2><span id='topic+test.stat+3C--methods'></span><span id='topic+test.stat+3C-+2Ccpt-method'></span><span id='topic+test.stat+3C-+2Ccpt.reg-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>test.stat&lt;-</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cpt")</code></dt><dd>
<p>Assigns the value following &lt;- to the test.stat slot in x
</p>
</dd>
<dt><code>signature(x = "cpt.reg")</code></dt><dd>
<p>Assigns the value following &lt;- to the test.stat slot in x
</p>
</dd>
</dl>

<hr>
<h2 id='wave.c44137'>
Wave data from buoy c44137
</h2><span id='topic+wave.c44137'></span>

<h3>Description</h3>

<p>This dataset gives the significant wave heights from buoy c44137 obtained from the Fisheries and Oceans Canada, East Scotian Slop.  The data are taken at hourly intervals from January 2005 until September 2012.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave.c44137
</code></pre>


<h3>Format</h3>

<p>A vector of length 63651.
</p>


<h3>Source</h3>

<p>http://www.meds-sdmm.dfo-mpo.gc.ca/isdm-gdsi/waves-vagues/search-recherche/list-liste/data-donnees-eng.asp?medsid=C44137</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
