<!DOCTYPE html><html><head><title>Help for package polymapR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polymapR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_dup_markers'><p>Add back duplicate markers after mapping</p></a></li>
<li><a href='#ALL_dosages'><p>A dosage matrix for a random pairing tetraploid with five linkage groups.</p></a></li>
<li><a href='#all_linkages_list_P1'><p>A (nested) list of linkage data frames classified per linkage group and homologue</p></a></li>
<li><a href='#assign_linkage_group'><p>Assign non-SN markers to a linkage group and homologue(s).</p></a></li>
<li><a href='#assign_SN_SN'><p>Assign (leftover) 1.0 markers</p></a></li>
<li><a href='#bridgeHomologues'><p>Use bridge markers to cluster homologues into linkage groups</p></a></li>
<li><a href='#calcSegtypeInfo'><p>Build a list of segregation types</p></a></li>
<li><a href='#check_map'><p>Check the quality of a linkage map using heatplots</p></a></li>
<li><a href='#check_marker_assignment'><p>Check for consistent marker assignment between both parents</p></a></li>
<li><a href='#check_maxP'><p>check your dataset's maxP distribution</p></a></li>
<li><a href='#checkF1'><p>Identify the best-fitting F1 segregation types</p></a></li>
<li><a href='#chk1'><p>Example output of the checkF1 function</p></a></li>
<li><a href='#cluster_per_LG'><p>Cluster 1.0 markers into correct homologues per linkage group</p></a></li>
<li><a href='#cluster_SN_markers'><p>Cluster 1.0 markers</p></a></li>
<li><a href='#compare_maps'><p>Compare linkage maps, showing links between connecting markers common to neighbouring maps</p></a></li>
<li><a href='#consensus_LG_assignment'><p>Consensus LG assignment</p></a></li>
<li><a href='#consensus_LG_names'><p>Find consensus linkage group names</p></a></li>
<li><a href='#convert_marker_dosages'><p>Convert marker dosages to the basic types.</p></a></li>
<li><a href='#convert_polyRAD'><p>Convert (probabilistic) genotype calling results from polyRAD to input compatible with polymapR</p></a></li>
<li><a href='#convert_updog'><p>Convert (probabilistic) genotype calling results from updog to input compatible with polymapR.</p></a></li>
<li><a href='#correctDosages'><p>Check if dosage scores may have to be shifted</p></a></li>
<li><a href='#create_phased_maplist'><p>Create a phased homologue map list using the original dosages</p></a></li>
<li><a href='#createTetraOriginInput'><p>Create input files for TetraOrigin using an integrated linkage map list and marker dosage matrix</p></a></li>
<li><a href='#define_LG_structure'><p>Generate linkage group and homologue structure of SxN markers</p></a></li>
<li><a href='#exampleRAD_mapping'><p>Example output dataset of polyRAD::PipelineMapping2Parents function</p></a></li>
<li><a href='#finish_linkage_analysis'><p>Linkage analysis between all markertypes within a linkage group.</p></a></li>
<li><a href='#get_markertype_combinations'><p>Visualize and get all markertype combinations for which there are functions in polymapR</p></a></li>
<li><a href='#gp_df'><p>An example of a genotype probability data frame</p></a></li>
<li><a href='#gp_overview'><p>gp_overview</p></a></li>
<li><a href='#gp_vignette_data'><p>A list of objects needed to build the probabilistic genotype vignette</p></a></li>
<li><a href='#homologue_lg_assignment'><p>Assign markers to linkage groups and homologues.</p></a></li>
<li><a href='#integrated.maplist'><p>A nested list with integrated maps</p></a></li>
<li><a href='#LGHomDf_P1_1'><p>A <code>data.frame</code> specifying the assigned homologue and linkage group number per SxN marker</p></a></li>
<li><a href='#linkage'><p>Calculate recombination frequency, LOD and phase</p></a></li>
<li><a href='#linkage.gp'><p>Calculate recombination frequency, LOD and phase using genotype probabilities</p></a></li>
<li><a href='#map1'><p>A sample map</p></a></li>
<li><a href='#map2'><p>A sample map</p></a></li>
<li><a href='#map3'><p>A sample map</p></a></li>
<li><a href='#maplist_P1'><p>A list of maps of one parent</p></a></li>
<li><a href='#marker_binning'><p>Perform binning of markers.</p></a></li>
<li><a href='#marker_data_summary'><p>Summarize marker data</p></a></li>
<li><a href='#MDSMap_from_list'><p>Wrapper function for MDSMap to generate linkage maps from list of pairwise linkage estimates</p></a></li>
<li><a href='#merge_homologues'><p>Merge homologues</p></a></li>
<li><a href='#mout'><p>Example output dataset of updog::multidog function</p></a></li>
<li><a href='#overviewSNlinks'><p>Plotting 1.0 links between homologues</p></a></li>
<li><a href='#P1_homologues'><p>A list of cluster stacks at different LOD scores</p></a></li>
<li><a href='#P1_SxS_Assigned'><p>A <code>data.frame</code> with marker assignments</p></a></li>
<li><a href='#p4_functions'><p>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a preferential pairing tetraploid</p></a></li>
<li><a href='#parental_quantities'><p>Calculate frequency of each markertype.</p></a></li>
<li><a href='#PCA_progeny'><p>Perform a PCA on progeny</p></a></li>
<li><a href='#phase_SN_diploid'><p>Phase 1.0 markers at the diploid level</p></a></li>
<li><a href='#phased.maplist'><p>A list of phased maps</p></a></li>
<li><a href='#plot_hom_vs_LG'><p>Plot homologue position versus integrated positions</p></a></li>
<li><a href='#plot_map'><p>Plot linkage maps</p></a></li>
<li><a href='#plot_phased_maplist'><p>Visualise the phased homologue maplist</p></a></li>
<li><a href='#polymapR-package'><p>polymapR: Linkage Analysis in Outcrossing Polyploids</p></a></li>
<li><a href='#r_LOD_plot'><p>Plot r versus LOD</p></a></li>
<li><a href='#r2_functions'><p>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing diploid cross.</p></a></li>
<li><a href='#r3_functions'><p>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing triploid from a 4x2 or 2x4 cross.</p></a></li>
<li><a href='#r4_functions'><p>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing tetraploid</p></a></li>
<li><a href='#r6_functions'><p>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing hexaploid</p></a></li>
<li><a href='#screen_for_duplicate_individuals'><p>Screen for duplicate individuals</p></a></li>
<li><a href='#screen_for_duplicate_individuals.gp'><p>Screen for duplicate individuals using weighted genotype probabilities</p></a></li>
<li><a href='#screen_for_duplicate_markers'><p>Screen for and remove duplicated markers</p></a></li>
<li><a href='#screen_for_NA_values'><p>Screen marker data for NA values</p></a></li>
<li><a href='#SN_SN_P1'><p>A linkage <code>data.frame</code>.</p></a></li>
<li><a href='#SNSN_LOD_deviations'><p>Identify deviations in LOD scores between pairs of simplex x nulliplex markers</p></a></li>
<li><a href='#test_prefpairing'><p>Check for and estimate preferential pairing</p></a></li>
<li><a href='#write_nested_list'><p>Write out a nested list</p></a></li>
<li><a href='#write_pwd_list'><p>Write pwd files from a nested list</p></a></li>
<li><a href='#write.mct'><p>Write MapChart file</p></a></li>
<li><a href='#write.pwd'><p>Write a JoinMap compatible .pwd file from linkage data.frame.</p></a></li>
<li><a href='#write.TSNPM'><p>Write TetraploidSNPMap input file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linkage Analysis in Outcrossing Polyploids</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Creation of linkage maps in polyploid species from marker dosage
    scores of an F1 cross from two heterozygous parents. Currently works for outcrossing diploid, autotriploid, autotetraploid and autohexaploid species, 
    as well as segmental allotetraploids. Methods are described in a manuscript of Bourke et al. (2018) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty371">doi:10.1093/bioinformatics/bty371</a>&gt;. Since version 1.1.0,
    both discrete and probabilistic genotypes are acceptable input; for more details on the latter see Liao et al. (2021) &lt;<a href="https://doi.org/10.1007%2Fs00122-021-03834-x">doi:10.1007/s00122-021-03834-x</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, graphics, grDevices, igraph, knitr,
MDSMap, stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, hexbin, Hmisc, RColorBrewer, reshape2, rmarkdown,
polyRAD, updog, mappoly</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 14:45:16 UTC; bourk001</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Bourke [aut, cre],
  Geert van Geest [aut],
  Roeland Voorrips [ctb],
  Yanlin Liao [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Bourke &lt;pbourkey@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 21:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_dup_markers'>Add back duplicate markers after mapping</h2><span id='topic+add_dup_markers'></span>

<h3>Description</h3>

<p>Often there will be duplicate markers that can be put aside to speed up mapping. These may be added back to the maps afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dup_markers(maplist, bin_list, marker_assignments = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dup_markers_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. Output of MDSMap_from_list.</p>
</td></tr>
<tr><td><code id="add_dup_markers_+3A_bin_list">bin_list</code></td>
<td>
<p>A list of marker bins containing marker duplicates. One of the list outputs of <code><a href="#topic+screen_for_duplicate_markers">screen_for_duplicate_markers</a></code></p>
</td></tr>
<tr><td><code id="add_dup_markers_+3A_marker_assignments">marker_assignments</code></td>
<td>
<p>Optional argument to include the marker_assignments (output of <code><a href="#topic+check_marker_assignment">check_marker_assignment</a></code>). If included, marker assignment information will also be copied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>

<dl>
<dt>maplist</dt><dd><p>List of maps, now with duplicate markers added</p>
</dd>
<dt>marker_assignments</dt><dd><p>If required, marker assignment list with duplicate markers added</p>
</dd>
</dl>


<hr>
<h2 id='ALL_dosages'>A dosage matrix for a random pairing tetraploid with five linkage groups.</h2><span id='topic+ALL_dosages'></span><span id='topic+segregating_data'></span><span id='topic+screened_data'></span><span id='topic+screened_data2'></span><span id='topic+screened_data3'></span><span id='topic+TRI_dosages'></span>

<h3>Description</h3>

<p>A dosage matrix for a random pairing tetraploid with five linkage groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALL_dosages

segregating_data

screened_data

screened_data2

screened_data3

TRI_dosages
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 2873 rows and 209 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1417 rows and 209 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1417 rows and 207 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1417 rows and 200 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 250 rows and 202 columns.
</p>

<hr>
<h2 id='all_linkages_list_P1'>A (nested) list of linkage data frames classified per linkage group and homologue</h2><span id='topic+all_linkages_list_P1'></span><span id='topic+all_linkages_list_P1_split'></span><span id='topic+all_linkages_list_P1_subset'></span>

<h3>Description</h3>

<p>A (nested) list of linkage data frames classified per linkage group and homologue
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_linkages_list_P1

all_linkages_list_P1_split

all_linkages_list_P1_subset
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>
<p>An object of class <code>list</code> of length 5.
</p>
<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='assign_linkage_group'>Assign non-SN markers to a linkage group and homologue(s).</h2><span id='topic+assign_linkage_group'></span>

<h3>Description</h3>

<p><code>assign_linkage_group</code> quantifies per marker number of linkages to a linkage group and evaluates to which linkage group (and homologue(s)) the marker belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_linkage_group(
  linkage_df,
  LG_hom_stack,
  SN_colname = "marker_a",
  unassigned_marker_name = "marker_b",
  phase_considered = "coupling",
  LG_number,
  LOD_threshold = 3,
  ploidy,
  assign_homologue = T,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_linkage_group_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage <code>data.frame</code> as output of <code><a href="#topic+linkage">linkage</a></code>.</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A <code>data.frame</code> with markernames (<code>"SxN_Marker"</code>), linkage group (<code>"LG"</code>) and homologue (<code>"homologue"</code>)</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_sn_colname">SN_colname</code></td>
<td>
<p>The name of the column in linkage_df harbouring the 1.0 markers</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_unassigned_marker_name">unassigned_marker_name</code></td>
<td>
<p>The name of the column in linkage_df harbouring the marker that are to be assigned.</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_phase_considered">phase_considered</code></td>
<td>
<p>The phase that is used to assign the markers (deprecated)</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_lg_number">LG_number</code></td>
<td>
<p>The number of chromosomes (linkage groups) in the species.</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>The LOD score at which a linkage to a linkage group is significant.</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the plant species.</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_assign_homologue">assign_homologue</code></td>
<td>
<p>Logical. Should markers be assigned to homologues? If <code>FALSE</code> markers will be assigned to all homologues</p>
</td></tr>
<tr><td><code id="assign_linkage_group_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a data.frame with at least the following columns:
</p>
<table>
<tr><td><code>Assigned_LG</code></td>
<td>
<p>The assigned linkage group</p>
</td></tr>
<tr><td><code>Assigned_hom1</code></td>
<td>
<p>The homologue with most linkages</p>
</td></tr>
</table>
<p>The columns LG1 - LGn and Hom1 - Homn give the number of hits per marker for that linkage group/homologue. Assigned_hom2 .. gives the nth homologue with most linkages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_DN_P1", "LGHomDf_P1_1")
assigned_df&lt;-assign_linkage_group(linkage_df = SN_DN_P1,
                     LG_hom_stack = LGHomDf_P1_1,
                     LG_number = 5, ploidy = 4)
</code></pre>

<hr>
<h2 id='assign_SN_SN'>Assign (leftover) 1.0 markers</h2><span id='topic+assign_SN_SN'></span>

<h3>Description</h3>

<p>Some 1.0 markers might have had ambiguous linkages, or linkages with low LOD scores leaving them unlinked to a linkage group.
<code>assign_SN_SN</code> finds 1.0 markers unlinked to a linkage group and tries to assign them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_SN_SN(
  linkage_df,
  LG_hom_stack,
  LOD_threshold,
  ploidy,
  LG_number,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_SN_SN_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A <code>data.frame</code> as output of <code><a href="#topic+linkage">linkage</a></code> with arguments markertype1=c(1,0) and markertype2=NULL.</p>
</td></tr>
<tr><td><code id="assign_SN_SN_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A <code>data.frame</code> with markernames (<code>"SxN_Marker"</code>), linkage group (<code>"LG"</code>) and homologue (<code>"homologue"</code>)</p>
</td></tr>
<tr><td><code id="assign_SN_SN_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>A LOD score at which linkages between markers are significant.</p>
</td></tr>
<tr><td><code id="assign_SN_SN_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. The ploidy level of the plant species.</p>
</td></tr>
<tr><td><code id="assign_SN_SN_+3A_lg_number">LG_number</code></td>
<td>
<p>Integer. Number of chromosomes (linkage groups)</p>
</td></tr>
<tr><td><code id="assign_SN_SN_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with the following columns:
</p>
<table>
<tr><td><code>SxN_Marker</code></td>
<td>
<p>The markername</p>
</td></tr>
<tr><td><code>Assigned_hom1</code></td>
<td>
<p>The assigned homologue</p>
</td></tr>
<tr><td><code>Assigned_LG</code></td>
<td>
<p>The assigned linkage group</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P1", "LGHomDf_P1_1")
SN_assigned&lt;-assign_SN_SN(linkage_df = SN_SN_P1,
             LG_hom_stack = LGHomDf_P1_1,
             LOD_threshold= 4,
             ploidy=4,
             LG_number=5)
</code></pre>

<hr>
<h2 id='bridgeHomologues'>Use bridge markers to cluster homologues into linkage groups</h2><span id='topic+bridgeHomologues'></span><span id='topic+assembleDuplexLinks'></span>

<h3>Description</h3>

<p>Clustering at high LOD scores results in marker clusters representing homologues.
<code>bridgeHomologues</code> clusters these (pseudo)homologues to linkage groups using linkage information between 1.0 and
bridge markers within a parent (e.g. 2.0 for a tetraploid).
If parent-specific bridge markers (e.g. 2.0) cannot be used, biparental markers can also be used (e.g. 1.1, 1.2, 2.1, 2.2 and 1.3 markers).
The linkage information between 1.0 and biparental markers can be combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bridgeHomologues(
  cluster_stack,
  cluster_stack2 = NULL,
  linkage_df,
  linkage_df2 = NULL,
  LOD_threshold = 5,
  automatic_clustering = TRUE,
  LG_number,
  parentname = "",
  min_links = 1,
  min_bridges = 1,
  only_coupling = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridgeHomologues_+3A_cluster_stack">cluster_stack</code></td>
<td>
<p>A <code>data.frame</code> with a column <code>"marker"</code> specifying markernames,
and a column <code>"cluster"</code> specifying marker cluster</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_cluster_stack2">cluster_stack2</code></td>
<td>
<p>Optional. A <code>cluster_stack</code> for the other parent.
Use this argument if cross-parent markers are used (e.g. when using 1.1 markers).</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage <code>data.frame</code> as output of <code><a href="#topic+linkage">linkage</a></code> between bridge (e.g. 1.0 and 2.0) markers.</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_linkage_df2">linkage_df2</code></td>
<td>
<p>Optional. A <code>linkage_df</code> specifying linkages between 1.0 and cross-parent markers in the other parent.
Use this argument if cross-parent markers are used (e.g. when using 1.1, 2.1, 1.2 and/or 2.2 markers).
The use of multiple types of cross-parent markers is allowed.</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>Integer. The LOD threshold specifying at which LOD score a link between 1.0 and bridging-type marker (e.g. 2.0) is used for clustering homologues.</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_automatic_clustering">automatic_clustering</code></td>
<td>
<p>Logical. Should clustering be executed without user input?</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_lg_number">LG_number</code></td>
<td>
<p>Integer. Expected number of chromosomes (linkage groups)</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_parentname">parentname</code></td>
<td>
<p>Name of the parent. Used in the main title of the plot.</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_min_links">min_links</code></td>
<td>
<p>The minimum number of links between a bridge marker and a cluster for that bridge to be considered. In the case
of a 2x0 marker for example, this argument means that the 2x0 marker must have at least <code>min_links</code> linkages of at least a LOD of <code>LOD_threshold</code> with
markers from each of the clusters involved, to be considered a single bridging link. Make this number higher if there are a lot of spurious links.</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_min_bridges">min_bridges</code></td>
<td>
<p>The minimum number of bridge markers needed to assign two homologues together as coming from the same chromosomal linkage group.
See argument <code>min_links</code> for further details.</p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_only_coupling">only_coupling</code></td>
<td>
<p>Logical, should only coupling linkages be used in the process? By default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="bridgeHomologues_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with markers classified by homologue and linkage group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("P1_homologues", "P2_homologues", "SN_DN_P1", "SN_SS_P1", "SN_SS_P2")
ChHomDf&lt;-bridgeHomologues(cluster_stack = P1_homologues[["5"]],
                 linkage_df=SN_DN_P1,
                 LOD_threshold=4,
                 automatic_clustering=TRUE,
                 LG_number=5,
                 parentname="P1")

ChHomDf&lt;-bridgeHomologues(cluster_stack = P1_homologues[["5"]],
                           cluster_stack2 = P2_homologues[["5"]],
                 linkage_df=SN_SS_P1,
                 linkage_df2=SN_SS_P2,
                 LOD_threshold=4,
                 automatic_clustering=TRUE,
                 LG_number=5,
                 parentname="P1")
</code></pre>

<hr>
<h2 id='calcSegtypeInfo'>Build a list of segregation types</h2><span id='topic+calcSegtypeInfo'></span>

<h3>Description</h3>

<p>For each possible segregation type in an F1 progeny with given
parental ploidy (and ploidy2, if parent2 has a different ploidy than parent1)
information is given on the segregation ratios, parental dosages and whether
the segregation is expected under polysomic, disomic and/or mixed inheritance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSegtypeInfo(ploidy, ploidy2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSegtypeInfo_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of parent 1 (must be even, 2 (diploid) or larger).</p>
</td></tr>
<tr><td><code id="calcSegtypeInfo_+3A_ploidy2">ploidy2</code></td>
<td>
<p>The ploidy of parent 2. If omitted (default=NULL) it is
assumed to be equal to ploidy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the segregation types consist of a short sequence of
digits (and sometimes letters), an underscore and a final number. This is
interpreted as follows, for example segtype 121_0: 121 means that there
are three consecutive dosages in the F1 population with frequency ratios 1:2:1,
and the 0 after the underscore means that the lowest of these dosages is
nulliplex. So 121_0 means a segregation of 1 nulliplex : 2 simplex : 1 duplex.
A monomorphic F1 (one single dosage) is indicated as e.g. 1_4 (only one
dosage, the 4 after the underscore means that this is monomorphic quadruplex).
If UPPERCASE letters occur in the first part of the name these are interpreted
as additional digits with values of A=10 to Z=35, e.g. 18I81_0 means a
segregation of 1:8:18:8:1 (using the I as 18), with the lowest dosage being
nulliplex.<br />
With higher ploidy levels higher numbers (above 35) may be required.
In that case each unique ratio number above 35 is assigned a lowercase letter.
E.g. one segregation type in octaploids is 9bcb9_2: a 9:48:82:48:9
segregation where the lowest dosage is duplex.<br />
Segregation types with more than 5 dosage classes are considered &quot;complex&quot;
and get codes like c7e_1 (again in octoploids): this means a complex type
(the first c) with 7 dosage classes; the e means that this is the fifth
type with 7 classes. Again the _1 means that the lowest dosage is simplex.
It is always possible (and for all segtype names with lowercase letters it is
necessary) to look up the actual segregation ratios in the intratio item
of the segtype. For octoploid segtype c7e_1 this shows 0:1:18:69:104:69:18:1:0
(the two 0's mean that nulli- and octoplexes do not occur).
</p>


<h3>Value</h3>

<p>A list with for each different segregation type (segtype) one item.
The names of the items are the names of the segtypes.
Each item is itself a list with components:
</p>

<dl>
<dt>freq</dt><dd><p>A vector of the ploidy+1 fractions of the dosages in the F1</p>
</dd>
<dt>intratios</dt><dd><p>An integer vector with the ratios as the simplest integers</p>
</dd>
<dt>expgeno</dt><dd><p>A vector with the dosages present in this segtype</p>
</dd>
<dt>allfrq</dt><dd><p>The allele frequency of the dosage allele in the F1</p>
</dd>
<dt>polysomic</dt><dd><p>Boolean: does this segtype occur with polysomic inheritance?</p>
</dd>
<dt>disomic</dt><dd><p>Boolean: does this segtype occur with disomic inheritance?</p>
</dd>
<dt>mixed</dt><dd><p>Boolean: does this segtype occur with mixed inheritance (i.e. with
polysomic inheritance in one parent and disomic inheritance in the other)?</p>
</dd>
<dt>pardosage</dt><dd><p>Integer matrix with 2 columns and as many rows as there
are parental dosage combinations for this segtype;
each row has one possible combination of dosages for
parent 1 (1st column) and parent 2 (2nd column)</p>
</dd>
<dt>parmode</dt><dd><p>Logical matrix with 3 columns and the same number of rows as
pardosage. The 3 columns are named polysomic, disomic and mixed and
tell if this parental dosage combination will generate this
segtype under polysomic, disomic and mixed inheritance</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>si4 &lt;- calcSegtypeInfo(ploidy=4) # two 4x parents: a 4x F1 progeny
print(si4[["11_0"]])

si3 &lt;- calcSegtypeInfo(ploidy=4, ploidy2=2) # a 4x and a diplo parent: a 3x progeny
print(si3[["11_0"]])
</code></pre>

<hr>
<h2 id='check_map'>Check the quality of a linkage map using heatplots</h2><span id='topic+check_map'></span>

<h3>Description</h3>

<p>Perform a series of checks on a linkage map and visualise the results using heatplots. Also shows the discrepency between
the pairwise and multi-point r estimates, plotted against the LOD of the pairwise estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_map(
  linkage_list,
  maplist,
  mapfn = "haldane",
  lod.thresh = 5,
  tidyplot = TRUE,
  detail = 1,
  plottype = c("", "pdf", "png")[1],
  prefix = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_map_+3A_linkage_list">linkage_list</code></td>
<td>
<p>A named <code>list</code> with r and LOD of markers within linkage groups.</p>
</td></tr>
<tr><td><code id="check_map_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. In the first column marker names and in the second their position.</p>
</td></tr>
<tr><td><code id="check_map_+3A_mapfn">mapfn</code></td>
<td>
<p>The map function used in generating the maps, either one of &quot;haldane&quot; or &quot;kosambi&quot;. By default &quot;haldane&quot; is assumed.</p>
</td></tr>
<tr><td><code id="check_map_+3A_lod.thresh">lod.thresh</code></td>
<td>
<p>Numeric. Threshold for the LOD values to be displayed in heatmap, by default 5 (set at 0 to display all values)</p>
</td></tr>
<tr><td><code id="check_map_+3A_tidyplot">tidyplot</code></td>
<td>
<p>If <code>TRUE</code>, an attempt is made to reduce the plot density, using the <code>hexbin</code> package. 
This can have a considerable performance impact for high-density maps</p>
</td></tr>
<tr><td><code id="check_map_+3A_detail">detail</code></td>
<td>
<p>Level of detail for heatmaps, by default 1 cM. Values less than 0.5 cM can have serious performance implications.</p>
</td></tr>
<tr><td><code id="check_map_+3A_plottype">plottype</code></td>
<td>
<p>Option to specify graphical device for plotting, (either png or pdf), or by default &quot;&quot;, in which case plots are directly plotted within R</p>
</td></tr>
<tr><td><code id="check_map_+3A_prefix">prefix</code></td>
<td>
<p>Optional prefix appended to plot names if outputting plots.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("maplist_P1","all_linkages_list_P1")
check_map(linkage_list = all_linkages_list_P1, maplist = maplist_P1)

## End(Not run)
</code></pre>

<hr>
<h2 id='check_marker_assignment'>Check for consistent marker assignment between both parents</h2><span id='topic+check_marker_assignment'></span>

<h3>Description</h3>

<p>Function to ensure there is consistent marker assignment to chromosomal linkage groups
for biparental markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_marker_assignment(
  marker_assignment.P1,
  marker_assignment.P2,
  log = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_marker_assignment_+3A_marker_assignment.p1">marker_assignment.P1</code></td>
<td>
<p>A marker assignment matrix for parent 1 with markernames as rownames and at least containing the column <code>"Assigned_LG"</code>; the output of <code><a href="#topic+homologue_lg_assignment">homologue_lg_assignment</a></code>.</p>
</td></tr>
<tr><td><code id="check_marker_assignment_+3A_marker_assignment.p2">marker_assignment.P2</code></td>
<td>
<p>A marker assignment matrix for parent 2 with markernames as rownames and at least containing the column <code>"Assigned_LG"</code>; the output of <code><a href="#topic+homologue_lg_assignment">homologue_lg_assignment</a></code>.</p>
</td></tr>
<tr><td><code id="check_marker_assignment_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL (by default) log is send to stdout.</p>
</td></tr>
<tr><td><code id="check_marker_assignment_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent to stdout or log?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of matrices with corrected marker assignments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("marker_assignments_P1"); data("marker_assignments_P2")
check_marker_assignment(marker_assignments_P1,marker_assignments_P2)
</code></pre>

<hr>
<h2 id='check_maxP'>check your dataset's maxP distribution</h2><span id='topic+check_maxP'></span>

<h3>Description</h3>

<p>Function to assess the distribution of maximum genotype probabilities (<code>maxP</code>), if these are available. The function
plots a violin graph showing the distribution of the samples' <code>maxP</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_maxP(probgeno_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_maxP_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function
<code>saveMarkerModels</code> of R package <code>fitPoly</code>, or alternatively, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code>
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any value, is simply a visualisation tool to help assess data quality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("gp_df")
check_maxP(gp_df)
</code></pre>

<hr>
<h2 id='checkF1'>Identify the best-fitting F1 segregation types</h2><span id='topic+checkF1'></span>

<h3>Description</h3>

<p>For a given set of F1 and parental samples, this function
finds the best-fitting segregation type using either discrete or probabilistic input data. 
It can also perform a dosage shift prior to selecting the segregation type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkF1(
  input_type = "discrete",
  dosage_matrix,
  probgeno_df,
  parent1,
  parent2,
  F1,
  ancestors = character(0),
  polysomic,
  disomic,
  mixed,
  ploidy,
  ploidy2,
  outfile = "",
  critweight = c(1, 0.4, 0.4),
  Pvalue_threshold = 1e-04,
  fracInvalid_threshold = 0.05,
  fracNA_threshold = 0.25,
  shiftmarkers,
  parentsScoredWithF1 = TRUE,
  shiftParents = parentsScoredWithF1,
  showAll = FALSE,
  append_shf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkF1_+3A_input_type">input_type</code></td>
<td>
<p>Can be either one of 'discrete' or 'probabilistic'. For the former (default), a <code>dosage_matrix</code> must be supplied,
while for the latter a <code>probgeno_df</code> must be supplied.</p>
</td></tr>
<tr><td><code id="checkF1_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="checkF1_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function
<code>saveMarkerModels</code> of R package <code>fitPoly</code>, or alternatively, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code>
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="checkF1_+3A_parent1">parent1</code></td>
<td>
<p>character vector with the sample names of parent 1</p>
</td></tr>
<tr><td><code id="checkF1_+3A_parent2">parent2</code></td>
<td>
<p>character vector with the sample names of parent 2</p>
</td></tr>
<tr><td><code id="checkF1_+3A_f1">F1</code></td>
<td>
<p>character vector with the sample names of the F1 individuals</p>
</td></tr>
<tr><td><code id="checkF1_+3A_ancestors">ancestors</code></td>
<td>
<p>character vector with the sample names of any other
ancestors or other samples of interest. The dosages of these samples will
be shown in the output (shifted if shiftParents <code>TRUE</code>) but they are not used
in the selection of the segregation type.</p>
</td></tr>
<tr><td><code id="checkF1_+3A_polysomic">polysomic</code></td>
<td>
<p>if <code>TRUE</code> at least all polysomic segtypes are considered;
if <code>FALSE</code> these are not specifically selected (but if e.g. disomic is <code>TRUE</code>,
any polysomic segtypes that are also disomic will still be considered)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_disomic">disomic</code></td>
<td>
<p>if <code>TRUE</code> at least all disomic segtypes are considered (see
<code>polysomic</code>)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_mixed">mixed</code></td>
<td>
<p>if <code>TRUE</code> at least all mixed segtypes are considered (see
<code>polysomic</code>). A mixed segtype occurs when inheritance in one parent is
polysomic (random chromosome pairing) and in the other parent disomic (fully
preferential chromosome pairing)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of parent 1 (must be even, 2 (diploid) or larger).</p>
</td></tr>
<tr><td><code id="checkF1_+3A_ploidy2">ploidy2</code></td>
<td>
<p>The ploidy of parent 2. If omitted it is
assumed to be equal to ploidy.</p>
</td></tr>
<tr><td><code id="checkF1_+3A_outfile">outfile</code></td>
<td>
<p>the tab-separated text file to write the output to; if NA a temporary file
checkF1.tmp is created in the current working directory and deleted at end</p>
</td></tr>
<tr><td><code id="checkF1_+3A_critweight">critweight</code></td>
<td>
<p>NA or a numeric vector containing the weights of three quality
criteria; do not need to sum to 1. If NA, the output will not contain a
column qall_weights. Else the weights specify how qall_weights will be
calculated from quality parameters q1, q2 and q3.</p>
</td></tr>
<tr><td><code id="checkF1_+3A_pvalue_threshold">Pvalue_threshold</code></td>
<td>
<p>a minimum threshold value for the Pvalue of the
bestParentfit segtype (with a smaller Pvalue the q1 quality parameter will
be set to 0)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_fracinvalid_threshold">fracInvalid_threshold</code></td>
<td>
<p>a maximum threshold for the fracInvalid of the
bestParentfit segtype (with a larger fraction of invalid dosages in the F1
the q1 quality parameter will be set to 0)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_fracna_threshold">fracNA_threshold</code></td>
<td>
<p>a maximum threshold for the fraction of unscored F1
samples (with a larger fraction of unscored samples in the F1
the q3 quality parameter will be set to 0)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_shiftmarkers">shiftmarkers</code></td>
<td>
<p>if specified, shiftmarkers must be a data frame with
columns MarkerName and shift; for the markernames that match exactly
(upper/lowercase etc) those in the input (either <code>dosage_matrix</code> or <code>probgeno_df</code>), the dosages are increased by the
amount specified in column shift,
e.g. if shift is -1, dosages 2..ploidy are converted to 1..(ploidy-1)
and dosage 0 is a combination of old dosages 0 and 1, for all samples.
The segregation check is then performed with the shifted dosages.
A shift=NA is allowed, these markers will not be shifted.
The sets of markers in the input (either <code>dosage_matrix</code> or <code>probgeno_df</code>) and shiftmarkers
may be different, but markers may occur only once in shiftmarkers.
A column shift is added at the end of the returned data frame.<br />
If parameter shiftParents is <code>TRUE</code>, the parental and ancestor scores are
shifted as the F1 scores, if <code>FALSE</code> they are not shifted.</p>
</td></tr>
<tr><td><code id="checkF1_+3A_parentsscoredwithf1">parentsScoredWithF1</code></td>
<td>
<p><code>TRUE</code> if parents are scored in the same experiment
and the same <code>fitPoly</code> run as the F1, else <code>FALSE</code>.
If <code>TRUE</code>, their fraction missing scores
and conflicts tell something about the quality of the scoring. If <code>FALSE</code>
(e.g. when the F1 is triploid and the parents are diploid and tetraploid) the
quality of the F1 scores can be independent of that of the parents.<br />
If not specified, <code>TRUE</code> is assumed if ploidy2 == ploidy and <code>FALSE</code> if
ploidy2 != ploidy</p>
</td></tr>
<tr><td><code id="checkF1_+3A_shiftparents">shiftParents</code></td>
<td>
<p>only used if parameter shiftmarkers is specified. If <code>TRUE</code>,
apply the shifts also to the parental and ancestor scores.
By default <code>TRUE</code> if <code>parentsScoredWithF1</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="checkF1_+3A_showall">showAll</code></td>
<td>
<p>(default <code>FALSE</code>) if <code>TRUE</code>, for each segtype 3 columns
are added to the returned data frame with the frqInvalid, Pvalue and
matchParents values for these segtype (see the description of the return value)</p>
</td></tr>
<tr><td><code id="checkF1_+3A_append_shf">append_shf</code></td>
<td>
<p>if <code>TRUE</code> and parameter shiftmarkers is specified, _shf is
appended to all marker names where shift is not 0. This is not required for
any of the functions in this package but may prevent duplicated marker names
when using other software.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each marker is tested how well the different segregation types
fit with the observed parental and F1 dosages. The results are summarized
by columns bestParentfit (which is the best fitting segregation type,
taking into account the F1 and parental dosages) and columns qall_mult
and/or qall_weights (how good is the fit of the bestParentfit segtype: 0=bad,
1=good).<br />
Column bestfit in the results gives the segtype best fitting the F1
segregation without taking account of the parents. This bestfit segtype is
used by function correctDosages, which tests for possible &quot;shifts&quot; in
the marker models.<br />
In case the parents are not scored together with the F1 (e.g. if the F1 is
triploid and the parents are diploid and tetraploid) <code>dosage_matrix</code>
should be edited to contain the parental as well as the F1 scores.
In case the diploid and tetraploid parent are scored in the same run of
function <code>saveMarkerModels</code> (from package <code>fitPoly</code>)
the diploid is initially scored as nulliplex-duplex-quadruplex (dosage 0, 2
or 4); that must be converted to the true diploid dosage scores (0, 1 or 2).
Similar corrections are needed with other combinations, such as a diploid
parent scored together with a hexaploid population etc.
</p>


<h3>Value</h3>

<p>A list containing two elements, <code>checked_F1</code> and <code>meta</code>. <code>meta</code> is itself
a list that stores the parameter settings used in running <code>checkF1</code> which can 
be useful for later reference. The first element (<code>checked_F1</code>) contains the actual results: a data
frame with one row per marker, with the following columns:
</p>

<ul>
<li><p> m: the sequential number of the marker (as assigned by <code>fitPoly</code>)
</p>
</li>
<li><p> MarkerName: the name of the marker, with _shf appended if the marker
is shifted and append_shf is <code>TRUE</code>
</p>
</li>
<li><p> parent1: consensus dosage score of the samples of parent 1
</p>
</li>
<li><p> parent2: consensus dosage score of the samples of parent 2
</p>
</li>
<li><p> F1_0 ...	F1_&lt;ploidy&gt;: the number of F1 samples with dosage scores
0 ... &lt;ploidy&gt;
</p>
</li>
<li><p> F1_NA: the number of F1 samples with a missing dosage score
</p>
</li>
<li><p> sample names of parents and ancestors: the dosage scores for those
samples
</p>
</li>
<li><p> bestfit: the best fitting segtype, considering only the F1 samples
</p>
</li>
<li><p> frqInvalid_bestfit: for the bestfit segtype, the frequency of F1 samples
with a dosage score that is invalid (that should not occur). The frequency is
calculated as the number of invalid samples divided by the number of non-NA
samples
</p>
</li>
<li><p> Pvalue_bestfit: the chisquare test P-value for the observed
distribution of dosage scores vs the expected fractions. For segtypes
where only one dosage is expected (1_0, 1_1 etc) the binomial probability of
the number of invalid scores is given, assuming an error
rate of seg_invalidrate (hard-coded as 0.03)
</p>
</li>
<li><p> matchParent_bestfit: indication how the bestfit segtype matches the
consensus dosages of parent 1 and 2: &quot;Unknown&quot;=both parental
dosages unknown; &quot;No&quot;=one or both parental dosages known
and conflicting with the segtype; &quot;OneOK&quot;= only one parental
dosage known, not conflicting with the segtype; &quot;Yes&quot;=both
parental dosages known and combination matching with
the segtype. This score is initially assigned based on
only high-confidence parental consensus scores; if
low-confidence dosages are confirmed by the F1, the
matchParent for (only) the selected segtype is
updated, as are the parental consensus scores.
</p>
</li>
<li><p> bestParentfit: the best fitting segtype that does not conflict with
the parental consensus scores
</p>
</li>
<li><p> frqInvalid_bestParentfit, Pvalue_bestParentfit,
matchParent_bestParentfit: same as the corresponding columns for bestfit.
Note that matchParent_bestParentfit cannot be &quot;No&quot;.
</p>
</li>
<li><p> q1_segtypefit: a value from 0 (bad) to 1 (good), a measure of the fit of
the bestParentfit segtype based on Pvalue, invalidP and whether bestfit is
equal to bestParentfit
</p>
</li>
<li><p> q2_parents: a value from 0 (bad) to 1 (good), based either on the
quality of the parental scores (the number of missing scores and of
conflicting scores, if parentsScoredWithF1 is TRUE) or on matchParents
(No=0, Unknown=0.65, OneOK=0.9, Yes=1, if parentsScoredWithF1 is FALSE)
</p>
</li>
<li><p> q3_fracscored: a value from 0 (bad) to 1 (good), based on the fraction
of F1 samples that have a non-missing dosage score
</p>
</li>
<li><p> qall_mult: a value from 0 (bad) to 1 (good), a summary quality score
equal to the product q1*q2*q3. Equal to 0 if any of these is 0, hence
sensitive to thresholds; a natural selection criterion would be to accept
all markers with qall_mult &gt; 0
</p>
</li>
<li><p> qall_weights: a value from 0 (bad) to 1 (good), a weighted average of
q1, q2 and q3, with weights as specified in parameter critweight. This column is
present only if critweight is specified. In this case there is no &quot;natural&quot;
threshold; a threshold for selection of markers must be obtained by inspecting
XY-plots of markers over a range of qall_weights values
</p>
</li>
<li><p> shift: if shiftmarkers is specified a column shift is added with
for all markers the applied shift (for the unshifted markers the shift value
is 0)
</p>
</li></ul>

<p>qall_mult and/or qall_weights can be used to compare the quality
of the SNPs within one analysis and one F1 population but not between analyses
or between different F1 populations.<br />
If parameter showAll is <code>TRUE</code> there are 3 additional columns for each
segtype with names frqInvalid_&lt;segtype&gt;, Pvalue_&lt;segtype&gt; and
matchParent_&lt;segtype&gt;; see the corresponding columns for bestfit for an
explanation. These extra columns are inserted directly before the bestfit
column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("ALL_dosages")
chk1&lt;-checkF1(input_type="discrete",dosage_matrix=ALL_dosages,parent1="P1",parent2="P2",
F1=setdiff(colnames(ALL_dosages),c("P1","P2")),polysomic=T,disomic=F,mixed=F,
ploidy=4)
data("gp_df")
chk1&lt;-checkF1(input_type="probabilistic",probgeno_df=gp_df,parent1="P1",parent2="P2",
F1=setdiff(levels(gp_df$SampleName),c("P1","P2")),polysomic=T,disomic=F,mixed=F,
ploidy=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='chk1'>Example output of the checkF1 function</h2><span id='topic+chk1'></span>

<h3>Description</h3>

<p>Example output of the checkF1 function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chk1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='cluster_per_LG'>Cluster 1.0 markers into correct homologues per linkage group</h2><span id='topic+cluster_per_LG'></span>

<h3>Description</h3>

<p>Clustering at one LOD score for all markers does usually not result in correct classification of homologues. Usually there are more clusters of (pseudo)homologues than expected. This function lets you inspect every linkage group separately and allows for clustering at a different LOD threshold per LG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_per_LG(
  LG,
  linkage_df,
  LG_hom_stack,
  LOD_sequence,
  modify_LG_hom_stack = FALSE,
  nclust_out = NULL,
  network.layout = c("circular", "stacked", "n"),
  device = NULL,
  label.offset = 1,
  cex.lab = 0.7,
  log = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_per_LG_+3A_lg">LG</code></td>
<td>
<p>Integer. Linkage group to investigate.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A data.frame as output of <code><a href="#topic+linkage">linkage</a></code> with arguments <code>markertype1 = c(1,0)</code> and <code>markertype2=NULL</code>.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A <code>data.frame</code> with columns <code>"SxN_Marker"</code> providing 1.0 markernames and <code>"LG"</code>
and <code>"homologue"</code> providing linkage group and homologue respectively.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_lod_sequence">LOD_sequence</code></td>
<td>
<p>A numeric or vector of numerics giving LOD threshold(s) at which clustering should be performed.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_modify_lg_hom_stack">modify_LG_hom_stack</code></td>
<td>
<p>Logical. Should <code>LG_hom_stack</code> be modified and returned?</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_nclust_out">nclust_out</code></td>
<td>
<p>Number of clusters in the output. If there are more clusters than this number only the nclust_out largest clusters are returned.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_network.layout">network.layout</code></td>
<td>
<p>Network layout: <code>"circular"</code> or <code>"stacked"</code>. If <code>"n"</code> no network is plotted.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_device">device</code></td>
<td>
<p>Function of the graphics device to plot to (e.g. <code><a href="grDevices.html#topic+pdf">pdf</a></code>, <code><a href="grDevices.html#topic+png">png</a></code>, <code><a href="grDevices.html#topic+jpeg">jpeg</a></code>). The active device is used when <code>NULL</code></p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_label.offset">label.offset</code></td>
<td>
<p>Offset of labels. Only used if <code>network.layout="circular"</code>.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_cex.lab">cex.lab</code></td>
<td>
<p>label character expansion. Only for <code>network.layout="circular"</code>.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
<tr><td><code id="cluster_per_LG_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>device</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified LG_hom_stack <code>data.frame</code> if <code>modify_LG_hom_stack = TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P2", "LGHomDf_P2_1")
#take only markers in coupling:
SN_SN_P2_coupl &lt;- SN_SN_P2[SN_SN_P2$phase=="coupling",]
cluster_per_LG(LG = 2,
               linkage_df=SN_SN_P2_coupl,
               LG_hom_stack=LGHomDf_P2_1,
               LOD_sequence=seq(4,10,2),
               modify_LG_hom_stack=FALSE,
               nclust_out=4,
               network.layout="circular",
               device=NULL,
               label.offset=1.2,
               cex.lab=0.75)
</code></pre>

<hr>
<h2 id='cluster_SN_markers'>Cluster 1.0 markers</h2><span id='topic+cluster_SN_markers'></span>

<h3>Description</h3>

<p><code>cluster_SN_markers</code> clusters simplex nulliplex at different LOD scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_SN_markers(
  linkage_df,
  LOD_sequence = 7,
  independence_LOD = FALSE,
  LG_number,
  ploidy,
  parentname = "",
  plot_network = FALSE,
  min_clust_size = 1,
  plot_clust_size = TRUE,
  max_vertex_size = 5,
  min_vertex_size = 2,
  phase_considered = "All",
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_SN_markers_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage data.frame as output of <code><a href="#topic+linkage">linkage</a></code> calculating linkage between 1.0 markers.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_lod_sequence">LOD_sequence</code></td>
<td>
<p>A numeric vector. Specifying a sequence of LOD thresholds at which clustering is performed.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_independence_lod">independence_LOD</code></td>
<td>
<p>Logical. Should the LOD of independence be used for clustering? (by default, <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_lg_number">LG_number</code></td>
<td>
<p>Expected number of chromosomes (linkage groups)</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of the parent for which clustering is to be performed</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_parentname">parentname</code></td>
<td>
<p>Name of parent</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_plot_network">plot_network</code></td>
<td>
<p>Logical. Should a network be plotted. Recommended FALSE with large number of marker combinations.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_min_clust_size">min_clust_size</code></td>
<td>
<p>Integer. The minimum cluster size to be returned. By default, a minimum cluster size of 1 is used, meaning all
markers are returned. Setting this to a higher number can be useful for cleaning out mini-clusters that don't show strong linkage
to the rest of the marker set.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_plot_clust_size">plot_clust_size</code></td>
<td>
<p>Logical. Should exact cluster size be plotted as vertex labels?</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_max_vertex_size">max_vertex_size</code></td>
<td>
<p>Integer. The maximum vertex size. Only used if <code>plot_clust_size=FALSE</code>.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_min_vertex_size">min_vertex_size</code></td>
<td>
<p>Integer. The minimum vertex size. Only used if <code>plot_clust_size=FALSE</code>.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_phase_considered">phase_considered</code></td>
<td>
<p>Character string. By default all phases are used, but &quot;coupling&quot; or &quot;repulsion&quot; are also allowed.</p>
</td></tr>
<tr><td><code id="cluster_SN_markers_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout (console).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (named) list of cluster stacks, each of which is a data.frame with columns &quot;marker&quot; and &quot;cluster&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P1")
cluster_list&lt;-cluster_SN_markers(SN_SN_P1,LOD_sequence=c(4:10),parentname="P1",ploidy=4,LG_number=5)
</code></pre>

<hr>
<h2 id='compare_maps'>Compare linkage maps, showing links between connecting markers common to neighbouring maps</h2><span id='topic+compare_maps'></span>

<h3>Description</h3>

<p>This function allows the visualisation of connections between different maps, showing them side by side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_maps(
  maplist,
  chm.wd = 0.2,
  bg.col = "white",
  links.col = "grey42",
  thin.links = NULL,
  type = "karyotype",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_maps_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. This is probably most conveniently built on-the-fly in the function call itself.
If names are assigned to different maps (list items) these will appear above
the maps. In cases of multiple comparisons, for example comparing 1 map of interest to 3 others, the map of interest can
be supplied multiple times in the list, interspersed between the other maps. See the example below for details.</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_chm.wd">chm.wd</code></td>
<td>
<p>The width in inches that linkage groups should be drawn. By default 0.2 inches is used.</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_bg.col">bg.col</code></td>
<td>
<p>The background colour of the maps, by default white. It can be useful to use a different background colour for the maps.
In this case, supply <code>bg.col</code> as a vector of colour identifiers, with the same length as <code>maplist</code> and corresponding to its elements in 
the same order. See the example below for details.</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_links.col">links.col</code></td>
<td>
<p>The colour with which links between maps are drawn, by default grey.</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_thin.links">thin.links</code></td>
<td>
<p>Option to thin the plotting of links between maps, which might be useful if there are very many shared markers in a 
small genetic region. By default <code>NULL</code>, otherwise supply a value (in cM) for the minimum genetic distance between linking-lines 
(e.g. 0.5).</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_type">type</code></td>
<td>
<p>Plot type, by default &quot;karyotype&quot;. If &quot;scatter&quot; is requested a scatter plot is drawn, but only if the comparison is between 2 maps.</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_...">...</code></td>
<td>
<p>option to supply arguments to the <code>plot</code> function (e.g. <code>main =</code> to add a title to the plot)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("map1","map2","map3")
compare_maps(maplist=list("1a"=map1,"c08"=map2,"1b"=map3),bg.col=c("thistle","white","skyblue"))
</code></pre>

<hr>
<h2 id='consensus_LG_assignment'>Consensus LG assignment</h2><span id='topic+consensus_LG_assignment'></span>

<h3>Description</h3>

<p>Assign markers to an LG based on consensus between two parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_LG_assignment(
  P1_assigned,
  P2_assigned,
  LG_number,
  ploidy,
  consensus_file = NULL,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_LG_assignment_+3A_p1_assigned">P1_assigned</code></td>
<td>
<p>A marker assignment file of the first parent. Should contain the number of linkages per LG per marker.</p>
</td></tr>
<tr><td><code id="consensus_LG_assignment_+3A_p2_assigned">P2_assigned</code></td>
<td>
<p>A marker assignment file of the second parent. Should be the same markertype as first parent and contain the number of linkages per LG per marker.</p>
</td></tr>
<tr><td><code id="consensus_LG_assignment_+3A_lg_number">LG_number</code></td>
<td>
<p>Number of linkage groups (chromosomes).</p>
</td></tr>
<tr><td><code id="consensus_LG_assignment_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of plant species.</p>
</td></tr>
<tr><td><code id="consensus_LG_assignment_+3A_consensus_file">consensus_file</code></td>
<td>
<p>Filename of consensus output. No output is written if NULL.</p>
</td></tr>
<tr><td><code id="consensus_LG_assignment_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>
<table>
<tr><td><code>P1_assigned</code></td>
<td>

<p>A (modified) marker assignment matrix of the first parent.
</p>
</td></tr>
<tr><td><code>P2_assigned</code></td>
<td>

<p>A (modified) marker assignment matrix of the second parent.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("P1_SxS_Assigned", "P2_SxS_Assigned_2")
SxS_Assigned_list &lt;- consensus_LG_assignment(P1_SxS_Assigned,P2_SxS_Assigned_2,5,4)
</code></pre>

<hr>
<h2 id='consensus_LG_names'>Find consensus linkage group names</h2><span id='topic+consensus_LG_names'></span>

<h3>Description</h3>

<p>Chromosomes that should have same number, might have gotten different numbers between parents during clustering.
<code>consensus_LG_names</code> uses markers present in both parents (usually 1.1 markers) to modify the linkage group numbers in one parent with the other as template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_LG_names(
  modify_LG,
  template_SxS,
  modify_SxS,
  merge_LGs = TRUE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_LG_names_+3A_modify_lg">modify_LG</code></td>
<td>
<p>A <code>data.frame</code> with markernames, linkage group (<code>"LG"</code>) and homologue (<code>"homologue"</code>), in which the linkage group numbers will be modified</p>
</td></tr>
<tr><td><code id="consensus_LG_names_+3A_template_sxs">template_SxS</code></td>
<td>
<p>A file with assigned markers of which (at least) part is present in both parents of the template parent.</p>
</td></tr>
<tr><td><code id="consensus_LG_names_+3A_modify_sxs">modify_SxS</code></td>
<td>
<p>A file with assigned markers of which (at least) part is present in both parents of the parent of which linkage group number are modified.</p>
</td></tr>
<tr><td><code id="consensus_LG_names_+3A_merge_lgs">merge_LGs</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. If <code>FALSE</code>, any discrepency in the number of linkage groups will not be merged, but removed instead.
This can be needed if the number of chromosomes identified is not equal between parents, and the user wishes to proceed with a core set.</p>
</td></tr>
<tr><td><code id="consensus_LG_names_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified modified_LG according to the template_SxS linkage group numbering
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LGHomDf_P2_2", "P1_SxS_Assigned", "P2_SxS_Assigned")
consensus_LGHomDf&lt;-consensus_LG_names(LGHomDf_P2_2, P1_SxS_Assigned, P2_SxS_Assigned)
</code></pre>

<hr>
<h2 id='convert_marker_dosages'>Convert marker dosages to the basic types.</h2><span id='topic+convert_marker_dosages'></span>

<h3>Description</h3>

<p>Convert marker dosages to the basic types which hold the same information and for which linkage calculations can be performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_marker_dosages(
  dosage_matrix,
  ploidy,
  ploidy2 = NULL,
  parent1 = "P1",
  parent2 = "P2",
  marker_conversion_info = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_marker_dosages_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="convert_marker_dosages_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level of the plant species. If parents have different ploidy level, ploidy of parent1.</p>
</td></tr>
<tr><td><code id="convert_marker_dosages_+3A_ploidy2">ploidy2</code></td>
<td>
<p>ploidy level of the second parent. NULL if both parents have the same ploidy level.</p>
</td></tr>
<tr><td><code id="convert_marker_dosages_+3A_parent1">parent1</code></td>
<td>
<p>Character string specifying the first (usually maternal) parentname.</p>
</td></tr>
<tr><td><code id="convert_marker_dosages_+3A_parent2">parent2</code></td>
<td>
<p>Character string specifying the second (usually paternal) parentname.</p>
</td></tr>
<tr><td><code id="convert_marker_dosages_+3A_marker_conversion_info">marker_conversion_info</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. Should marker conversion information be returned? This output can be useful for later map phasing step,
if original marker coding is desired (which is most likely the case).</p>
</td></tr>
<tr><td><code id="convert_marker_dosages_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified dosage matrix. If <code>marker_conversion_info = TRUE</code>, this function returns a list, with both the converted dosage_matrix, and 
information on the marker conversions performed per marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ALL_dosages")
conv&lt;-convert_marker_dosages(dosage_matrix=ALL_dosages, ploidy = 4)
</code></pre>

<hr>
<h2 id='convert_polyRAD'>Convert (probabilistic) genotype calling results from polyRAD to input compatible with polymapR</h2><span id='topic+convert_polyRAD'></span>

<h3>Description</h3>

<p>Convert (probabilistic) genotype calling results from polyRAD to input compatible with polymapR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_polyRAD(RADdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_polyRAD_+3A_raddata">RADdata</code></td>
<td>
<p>An RADdata (S3 class) object; output of the function <a href="polyRAD.html#topic+PipelineMapping2Parents">PipelineMapping2Parents</a> having followed
the prior steps needed in the polyRAD pipeline. See the polyRAD vignette for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame which include columns: 
MarkerName, SampleName,P0 ~ Pploidy (e.g. P0 ~ P4 for tetraploid, which represents
the probability assigning to this dosage), maxgeno (the most likely dosage),
and maxP (the maximum probability)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleRAD_mapping")
convert_polyRAD(RADdata = exampleRAD_mapping)
</code></pre>

<hr>
<h2 id='convert_updog'>Convert (probabilistic) genotype calling results from updog to input compatible with polymapR.</h2><span id='topic+convert_updog'></span>

<h3>Description</h3>

<p>Convert (probabilistic) genotype calling results from updog to input compatible with polymapR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_updog(mout, output_type = "discrete", min_prob = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_updog_+3A_mout">mout</code></td>
<td>
<p>An object of class multidog; output of the function <a href="updog.html#topic+multidog">multidog</a>.</p>
</td></tr>
<tr><td><code id="convert_updog_+3A_output_type">output_type</code></td>
<td>
<p>Output genotypes can be either &quot;discrete&quot; or &quot;probabilistic&quot;, defaults to discrete.</p>
</td></tr>
<tr><td><code id="convert_updog_+3A_min_prob">min_prob</code></td>
<td>
<p>If genotypes are being discretised, sets the minimum posterior probability in order to 
call a genotype with confidence. If maxpostprob &lt; min_prob, that genotype is made missing. A default of 0.7 is 
suggested with no particular motivation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If output_type is discrete, the function returns a dosage matrix with rownames given by marker names.
Columns are organised as parent 1 genotype, parent 2 genotype and then F1 individuals.
If output_type is probabilistic, then the output is a data frame which include columns: 
MarkerName, SampleName,P0 ~ Pploidy (e.g. P0 ~ P4 for tetraploid, which represents
the probability assigning to this dosage), maxgeno (the most likely dosage),
and maxP (the maximum probability)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mout")
convert_updog(mout)
</code></pre>

<hr>
<h2 id='correctDosages'>Check if dosage scores may have to be shifted</h2><span id='topic+correctDosages'></span>

<h3>Description</h3>

<p>fitPoly sometimes uses a &quot;shifted&quot; model to assign dosage
scores (e.g. all samples are assigned a dosage one higher than the true
dosage). This happens mostly when there are only few dosages present
among the samples. This function checks if a shift of +/-1 is possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctDosages(chk, dosage_matrix, parent1, parent2, ploidy,
polysomic=TRUE, disomic=FALSE, mixed=FALSE,
absent.threshold=0.04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctDosages_+3A_chk">chk</code></td>
<td>
<p>data frame returned by function checkF1 when called without
shiftmarkers</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_parent1">parent1</code></td>
<td>
<p>character vector with names of the samples of parent 1</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_parent2">parent2</code></td>
<td>
<p>character vector with names of the samples of parent 2</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy of parents and F1 (correctDosages must not be used for
F1 populations where the parents have a different ploidy, or where the
parental genotypes are not scored together with the F1);
same as used in the call to checkF1 that generated data.frame chk</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_polysomic">polysomic</code></td>
<td>
<p>if TRUE at least all polysomic segtypes are considered;
if FALSE these are not specifically selected (but if e.g. disomic is TRUE,
any polysomic segtypes that are also disomic will still be considered);
same as used in the call to checkF1 that generated data.frame chk</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_disomic">disomic</code></td>
<td>
<p>if TRUE at least all disomic segtypes are considered (see
param polysomic); same as used in the call to checkF1 that generated
data.frame chk</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_mixed">mixed</code></td>
<td>
<p>if TRUE at least all mixed segtypes are considered (see
param polysomic). A mixed segtype occurs when inheritance in one parent is
polysomic (random chromosome pairing) and in the other parent disomic (fully
preferential chromosome pairing); same as used in the call to checkF1 that
generated data.frame chk</p>
</td></tr>
<tr><td><code id="correctDosages_+3A_absent.threshold">absent.threshold</code></td>
<td>
<p>the threshold for the fraction of ALL samples
that has the dosage that is assumed to be absent due to mis-fitting of
fitPoly; should be at least the assumed error rate of the fitPoly scoring
assuming the fitted model is correct</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A shift of -1 (or +1) is proposed when (1) the fraction of all
samples with dosage 0 (or ploidy) is below absent.threshold, (2) the
bestfit (not bestParentfit!) segtype in chk has one empty dosage on the
low (or high) side and more than one empty dosage at the high (or low) side,
and (3) the shifted consensus parental dosages do not conflict with the
shifted segregation type.<br />
The returned data.frame (or a subset, e.g. based on the values in the
fracNotOk and parNA columns) can serve as parameter shiftmarkers in a
new call to checkF1.<br />
Based on the quality scores assigned by checkF1 to
the original and shifted versions of each marker the user can decide if
either or both should be kept. A data.frame combining selected rows
of the original and shifted versions of the checkF1 output (which may
contain both a shifted and an unshifted version of some markers) can then be
used as input to compareProbes or writeDosagefile.
</p>


<h3>Value</h3>

<p>a data frame with columns
</p>

<ul>
<li><p>markername
</p>
</li>
<li><p>segtype: the bestfit (not bestParentfit!) segtype from chk
</p>
</li>
<li><p>parent1, parent2: the consensus parental dosages; possibly
low-confidence, so may be different from those reported in chk
</p>
</li>
<li><p>shift: -1, 0 or 1: the amount by which this marker should be shifted
</p>
</li></ul>

<p>The next fields are only calculated if shift is not 0:
</p>

<ul>
<li><p>fracNotOk: the fraction of ALL samples that are in the dosage
(0 or ploidy) that should be empty if the marker is indeed shifted.
</p>
</li>
<li><p>parNA: the number of parental dosages that is missing (0, 1 or 2)
</p>
</li></ul>


<hr>
<h2 id='create_phased_maplist'>Create a phased homologue map list using the original dosages</h2><span id='topic+create_phased_maplist'></span>

<h3>Description</h3>

<p><code>create_phased_maplist</code> is a function for creating a phased maplist, using
integrated map positions and original marker dosages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_phased_maplist(
  input_type = "discrete",
  maplist,
  dosage_matrix.conv,
  dosage_matrix.orig = NULL,
  probgeno_df,
  chk,
  remove_markers = NULL,
  original_coding = FALSE,
  N_linkages = 2,
  lower_bound = 0.05,
  ploidy,
  ploidy2 = NULL,
  marker_assignment.1,
  marker_assignment.2,
  parent1 = "P1",
  parent2 = "P2",
  marker_conversion_info = NULL,
  log = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_phased_maplist_+3A_input_type">input_type</code></td>
<td>
<p>Can be either one of 'discrete' or 'probabilistic'. For the former (default), at least <code>dosage_matrix.conv</code> must be supplied,
while for the latter <code>chk</code> must be supplied.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. In the first column marker names and in the second their position.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_dosage_matrix.conv">dosage_matrix.conv</code></td>
<td>
<p>Matrix of marker dosage scores with markers in rows and individuals in columns. Note that dosages must be
in converted form, i.e. after having run the <code><a href="#topic+convert_marker_dosages">convert_marker_dosages</a></code> function. Errors may result otherwise.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_dosage_matrix.orig">dosage_matrix.orig</code></td>
<td>
<p>Optional, by default <code>NULL</code>.The unconverted dosages (i.e. raw dosage data before using
the <code><a href="#topic+convert_marker_dosages">convert_marker_dosages</a></code> function). Required if <code>original_coding</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>Probabilistic genotypes, for description see e.g. <code><a href="#topic+gp_overview">gp_overview</a></code>. Required if probabilistic genotypes are used.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_chk">chk</code></td>
<td>
<p>Output list as returned by function <code><a href="#topic+checkF1">checkF1</a></code>. Required if probabilistic genotypes are used.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_remove_markers">remove_markers</code></td>
<td>
<p>Optional vector of marker names to remove from the maps. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_original_coding">original_coding</code></td>
<td>
<p>Logical. Should the phased map use the original marker coding or not? By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_n_linkages">N_linkages</code></td>
<td>
<p>Number of significant linkages (as defined in <code><a href="#topic+homologue_lg_assignment">homologue_lg_assignment</a></code>) required for high-confidence linkage group assignment.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Numeric. Lower bound for the rate at which homologue linkages (fraction of total for that marker) are recognised.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. Ploidy of the organism.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Optional integer, by default <code>NULL</code>. Ploidy of parent 2, if different from parent 1.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_marker_assignment.1">marker_assignment.1</code></td>
<td>
<p>A marker assignment matrix for parent 1 with markernames as rownames and at least containing the column <code>"Assigned_LG"</code>.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_marker_assignment.2">marker_assignment.2</code></td>
<td>
<p>A marker assignment matrix for parent 2 with markernames as rownames and at least containing the column <code>"Assigned_LG"</code>.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_parent1">parent1</code></td>
<td>
<p>character vector with names of the samples of parent 1</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_parent2">parent2</code></td>
<td>
<p>character vector with names of the samples of parent 2</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_marker_conversion_info">marker_conversion_info</code></td>
<td>
<p>One of the list elements (named 'marker_conversion_info') generated by the function <code><a href="#topic+convert_marker_dosages">convert_marker_dosages</a></code> when the argument <code>marker_conversion_info</code>
was set to <code>TRUE</code> (not the default, so a user will typically have to re-run this step first).
Required if <code>original_coding</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
<tr><td><code id="create_phased_maplist_+3A_verbose">verbose</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. Should details of the phasing process be given?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("integrated.maplist", "screened_data3", "marker_assignments_P1","marker_assignments_P2")
create_phased_maplist(maplist = integrated.maplist,
                     dosage_matrix.conv = screened_data3,
                     marker_assignment.1=marker_assignments_P1,
                     marker_assignment.2=marker_assignments_P2,
                     ploidy = 4)
## End(Not run)
</code></pre>

<hr>
<h2 id='createTetraOriginInput'>Create input files for TetraOrigin using an integrated linkage map list and marker dosage matrix</h2><span id='topic+createTetraOriginInput'></span>

<h3>Description</h3>

<p><code>createTetraOriginInput</code> is a function for creating an input file for TetraOrigin, combining
map positions with marker dosages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTetraOriginInput(
  maplist,
  dosage_matrix,
  bin_size = NULL,
  bounds = NULL,
  remove_markers = NULL,
  outdir = "TetraOrigin",
  output_stem = "TetraOrigin_input",
  plot_maps = TRUE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTetraOriginInput_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. In the first column marker names and in the second their position.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns. Either provide the unconverted dosages (i.e.
before using the <code><a href="#topic+convert_marker_dosages">convert_marker_dosages</a></code> function), or converted dosages (i.e. screened data), in matrix form.
The analysis and results are unaffected by this choice, but it may be simpler to understand the results if converted dosages
are used. Conversely, it may be advantageous to use the original unconverted dosages if particular marker alleles are being
tracked for (e.g.) the development of selectable markers afterwards.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_bin_size">bin_size</code></td>
<td>
<p>Numeric. Size (in cM) of the bins to include. If <code>NULL</code> (by default) then all markers are used (no binning).</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_bounds">bounds</code></td>
<td>
<p>Numeric vector. If <code>NULL</code> (by default) then all positions are included, however if specified then output
is limited to a specific region, which is useful for later fine-mapping work.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_remove_markers">remove_markers</code></td>
<td>
<p>Optional vector of marker names to remove from the maps. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_outdir">outdir</code></td>
<td>
<p>Output directory to which input files for TetraOrigin are written.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_output_stem">output_stem</code></td>
<td>
<p>Character prefix to add to the .csv output filename.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_plot_maps">plot_maps</code></td>
<td>
<p>Logical. Plot the marker positions of the selected markers using <code><a href="#topic+plot_map">plot_map</a></code>.</p>
</td></tr>
<tr><td><code id="createTetraOriginInput_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("integrated.maplist","ALL_dosages")
createTetraOriginInput(maplist=integrated.maplist,dosage_matrix=ALL_dosages,bin_size=10)
## End(Not run)
</code></pre>

<hr>
<h2 id='define_LG_structure'>Generate linkage group and homologue structure of SxN markers</h2><span id='topic+define_LG_structure'></span>

<h3>Description</h3>

<p>Function which organises the output of <code>cluster_SN_markers</code> into a data frame of numbered linkage groups and homologues.
Only use this function if it is clear from the graphical output of <code>cluster_SN_markers</code> that there are LOD scores present which define both chromosomes (lower LOD)
and homologues (higher LOD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_LG_structure(cluster_list, LOD_chm, LOD_hom, LG_number, log = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_LG_structure_+3A_cluster_list">cluster_list</code></td>
<td>
<p>A list of cluster_stacks, the output of <code>cluster_SN_markers</code>.</p>
</td></tr>
<tr><td><code id="define_LG_structure_+3A_lod_chm">LOD_chm</code></td>
<td>
<p>Integer. The LOD threshold specifying at which LOD score the markers divide into chromosomal groups</p>
</td></tr>
<tr><td><code id="define_LG_structure_+3A_lod_hom">LOD_hom</code></td>
<td>
<p>Integer. The LOD threshold specifying at which LOD score the markers divide into homologue groups</p>
</td></tr>
<tr><td><code id="define_LG_structure_+3A_lg_number">LG_number</code></td>
<td>
<p>Integer. Expected number of chromosomes (linkage groups). Note that if this number of clusters are not
present at LOD_chm, the function will abort.</p>
</td></tr>
<tr><td><code id="define_LG_structure_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with markers classified by homologue and linkage group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("P1_homologues")
ChHomDf&lt;-define_LG_structure(cluster_list=P1_homologues,LOD_chm=3.5,LOD_hom=5,LG_number=5)
</code></pre>

<hr>
<h2 id='exampleRAD_mapping'>Example output dataset of polyRAD::PipelineMapping2Parents function</h2><span id='topic+exampleRAD_mapping'></span>

<h3>Description</h3>

<p>Example output dataset of polyRAD::PipelineMapping2Parents function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleRAD_mapping
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RADdata</code> of length 23.
</p>

<hr>
<h2 id='finish_linkage_analysis'>Linkage analysis between all markertypes within a linkage group.</h2><span id='topic+finish_linkage_analysis'></span>

<h3>Description</h3>

<p><code>finish_linkage_analysis</code> is a wrapper for <code><a href="#topic+linkage">linkage</a></code>, or in the case of probabilistic genotypes, <code><a href="#topic+linkage.gp">linkage.gp</a></code>.
The function performs linkage calculations between all markertypes within a linkage group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finish_linkage_analysis(
  input_type = "discrete",
  marker_assignment,
  dosage_matrix,
  probgeno_df,
  chk,
  marker_combinations = NULL,
  parent1 = "P1",
  parent2 = "P2",
  which_parent = 1,
  ploidy,
  ploidy2 = NULL,
  convert_palindrome_markers = TRUE,
  pairing = "random",
  prefPars = c(0, 0),
  LG_number,
  verbose = TRUE,
  log = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finish_linkage_analysis_+3A_input_type">input_type</code></td>
<td>
<p>Can be either one of 'discrete' or 'probabilistic'. For the former (default), <code>dosage_matrix</code> must be supplied,
while for the latter <code>probgeno_df</code> and <code>chk</code> must be supplied.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_marker_assignment">marker_assignment</code></td>
<td>
<p>A marker assignment matrix with markernames as rownames and at least containing the column <code>"Assigned_LG"</code>.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>A named integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function
<code>saveMarkerModels</code> of R package <code>fitPoly</code>, or alternatively, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_chk">chk</code></td>
<td>
<p>Output list as returned by function <code><a href="#topic+checkF1">checkF1</a></code>. This argument is only needed if probabilistic genotypes are used.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_marker_combinations">marker_combinations</code></td>
<td>
<p>A matrix with four columns specifying marker combinations to calculate linkage.
If <code>NULL</code> all combinations are used for which there are rf functions.
Dosages of markers should be in the same order as specified in the names of rf functions.
E.g. if using 1.0_2.0 and 1.0_3.0 types use: <code>matrix(c(1,0,2,0,1,0,3,0), byrow = TRUE, ncol = 4)</code></p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_parent1">parent1</code></td>
<td>
<p>Character string specifying the identifier of parent 1, by default &quot;P1&quot;</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_parent2">parent2</code></td>
<td>
<p>Character string specifying the identifier of parent 2, by default &quot;P2&quot;</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_which_parent">which_parent</code></td>
<td>
<p>Integer, either 1 or 2, with default 1, where 1 or 2 refers to parent1 or parent2 respectively.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer ploidy level of parent1, and also by default parent2. Argument <code>ploidy2</code> can be used if parental ploidies differ.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Integer, by default <code>NULL</code>. If parental ploidies differ, use this to specify the ploidy of parent2.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_convert_palindrome_markers">convert_palindrome_markers</code></td>
<td>
<p>Logical. Should markers that behave the same for both parents be converted to a workable format for that parent? E.g.: should 3.1 markers be converted to 1.3?</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_pairing">pairing</code></td>
<td>
<p>Type of pairing at meiosis, with options <code>"random"</code> or <code>"preferential"</code>. By default, random pairing is assumned.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_prefpars">prefPars</code></td>
<td>
<p>The estimates for preferential pairing parameters for parent 1 and 2, in range 0 &lt;= p &lt; 2/3. By default this is c(0,0) (so, no preferential pairing).
See the function <code><a href="#topic+test_prefpairing">test_prefpairing</a></code> and the vignette for more details.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_lg_number">LG_number</code></td>
<td>
<p>Number of linkage groups (chromosomes).</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent to stdout or log?</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
<tr><td><code id="finish_linkage_analysis_+3A_...">...</code></td>
<td>
<p>(Other) arguments passed to <code><a href="#topic+linkage">linkage</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with marker assignments. Number of linkages of 1.0 markers are artificial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("screened_data3", "marker_assignments_P1")
linkages_list_P1&lt;-finish_linkage_analysis(marker_assignment=marker_assignments_P1,
                                          dosage_matrix=screened_data3,
                                          parent1="P1",
                                          parent2="P2",
                                          which_parent=1,
                                          convert_palindrome_markers=FALSE,
                                          ploidy=4,
                                          pairing="random",
                                          LG_number=5)
                                          
## End(Not run)
</code></pre>

<hr>
<h2 id='get_markertype_combinations'>Visualize and get all markertype combinations for which there are functions in polymapR</h2><span id='topic+get_markertype_combinations'></span>

<h3>Description</h3>

<p>Visualize and get all markertype combinations for which there are functions in polymapR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_markertype_combinations(ploidy, pairing, nonavailable_combinations = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_markertype_combinations_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level</p>
</td></tr>
<tr><td><code id="get_markertype_combinations_+3A_pairing">pairing</code></td>
<td>
<p>Type of pairing. Either &quot;random&quot; or &quot;preferential&quot;.</p>
</td></tr>
<tr><td><code id="get_markertype_combinations_+3A_nonavailable_combinations">nonavailable_combinations</code></td>
<td>
<p>Logical. Should nonavailable combinations be plotted with grey lines?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns. Each row represents a function with the first and second markertype.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_markertype_combinations(ploidy = 4, pairing = "random")
</code></pre>

<hr>
<h2 id='gp_df'>An example of a genotype probability data frame</h2><span id='topic+gp_df'></span>

<h3>Description</h3>

<p>An example of a genotype probability data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_df
</code></pre>


<h3>Format</h3>

<p>Data frame
</p>

<hr>
<h2 id='gp_overview'>gp_overview</h2><span id='topic+gp_overview'></span>

<h3>Description</h3>

<p>Function to generate an overview of genotype probabilities across a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_overview(probgeno_df, cutoff = 0.7, alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_overview_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function
<code>saveMarkerModels</code> of R package <code>fitPoly</code>, or equivalently, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code>
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gp_overview_+3A_cutoff">cutoff</code></td>
<td>
<p>a filtering threshold, by default 0.7, to identify individuals with more than <code>alpha</code> 
non-missing (maximum) genotype probabilities falling below this cut-off. In other words, by using this
default settings (<code>cutoff</code> = 0.7 and <code>alpha</code> = 0.1), you require that 90
in one of the possible genotype dosage classes. This can help identify problematic individuals with many examples of 
diffuse genotype calls. Lowering the threshold allows more diffuse calls to be accepted.</p>
</td></tr>
<tr><td><code id="gp_overview_+3A_alpha">alpha</code></td>
<td>
<p>Option to specify the quantile of an individuals' scores that will be used to test against <code>cutoff</code>, by default 0.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>

<dl>
<dt>probgeno_df</dt><dd>
<p>Input data, filtered based on chosen <code>cutoff</code>
</p>
</dd>
<dt>population_overview</dt><dd>
<p>data.frame containing summary statistics of each individual's genotyping scores
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("gp_df")
gp_overview(gp_df)

## End(Not run)
</code></pre>

<hr>
<h2 id='gp_vignette_data'>A list of objects needed to build the probabilistic genotype vignette</h2><span id='topic+gp_vignette_data'></span>

<h3>Description</h3>

<p>A list of objects needed to build the probabilistic genotype vignette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_vignette_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 15.
</p>

<hr>
<h2 id='homologue_lg_assignment'>Assign markers to linkage groups and homologues.</h2><span id='topic+homologue_lg_assignment'></span>

<h3>Description</h3>

<p>This is a wrapper combining <code><a href="#topic+linkage">linkage</a></code> (or <code><a href="#topic+linkage.gp">linkage.gp</a></code>) and <code><a href="#topic+assign_linkage_group">assign_linkage_group</a></code>. 
It is used to assign all marker types to linkage groups by using linkage information with 1.0 markers. It allows for input of marker assignments for which this analysis has already been performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homologue_lg_assignment(
  input_type = "discrete",
  dosage_matrix,
  probgeno_df,
  chk,
  assigned_list,
  assigned_markertypes,
  SN_functions = NULL,
  LG_hom_stack,
  parent1 = "P1",
  parent2 = "P2",
  which_parent = 1,
  ploidy,
  ploidy2 = NULL,
  convert_palindrome_markers = TRUE,
  pairing = "random",
  LG_number,
  LOD_threshold = 3,
  write_intermediate_files = TRUE,
  log = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homologue_lg_assignment_+3A_input_type">input_type</code></td>
<td>
<p>Can be either one of 'discrete' or 'probabilistic'. For the former (default), <code>dosage_matrix</code> must be supplied,
while for the latter <code>probgeno_df</code> and <code>chk</code> must be supplied.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function
<code>saveMarkerModels</code> of R package <code>fitPoly</code>, or alternatively, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_chk">chk</code></td>
<td>
<p>Output list as returned by function <code><a href="#topic+checkF1">checkF1</a></code>. This argument is only needed if probabilistic genotypes are used.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_assigned_list">assigned_list</code></td>
<td>
<p>List of <code>data.frames</code> with marker assignments for which the assignment analysis is already performed.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_assigned_markertypes">assigned_markertypes</code></td>
<td>
<p>List of integer vectors of length 2. Specifying the markertypes in the same order as assigned_list.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_sn_functions">SN_functions</code></td>
<td>
<p>A vector of function names to be used. If NULL all remaining linkage functions with SN markers are used.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A <code>data.frame</code> with markernames (<code>"SxN_Marker"</code>), linkage group (<code>"LG"</code>) and homologue (<code>"homologue"</code>)</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_parent1">parent1</code></td>
<td>
<p>A character string specifying name of parent1.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_parent2">parent2</code></td>
<td>
<p>A character string specifying the name of parent2.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_which_parent">which_parent</code></td>
<td>
<p>Integer, either 1 or 2, with default 1, where 1 or 2 refers to parent1 or parent2 respectively.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of parent 1. If parent 2 has the same ploidy level, then also the ploidy level of parent 2.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Integer, by default <code>NULL</code>. If parental ploidies differ, use this to specify the ploidy of parent 2. Note that in cross-ploidy situations, ploidy2 must be smaller than ploidy.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_convert_palindrome_markers">convert_palindrome_markers</code></td>
<td>
<p>Logical. Should markers that behave the same for both parents be converted to a workable format for that parent? E.g.: should 3.1 markers be converted to 1.3?</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_pairing">pairing</code></td>
<td>
<p>Type of pairing. Either <code>"random"</code> or <code>"preferential"</code>. By default random pairing is assumed.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_lg_number">LG_number</code></td>
<td>
<p>Expected number of chromosomes (linkage groups).</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>LOD threshold at which a linkage is considered significant.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_write_intermediate_files">write_intermediate_files</code></td>
<td>
<p>Logical. Write intermediate linkage files to working directory?</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
<tr><td><code id="homologue_lg_assignment_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+linkage">linkage</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> specifying marker assignments to linkage group and homologue.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("screened_data3", "P1_SxS_Assigned", "P1_DxN_Assigned", "LGHomDf_P1_1")
Assigned_markers&lt;-homologue_lg_assignment(dosage_matrix = screened_data3,
                                          assigned_list = list(P1_SxS_Assigned, P1_DxN_Assigned),
                                          assigned_markertypes = list(c(1,1), c(2,0)),
                                          LG_hom_stack = LGHomDf_P1_1,ploidy=4,LG_number = 5,
                                          write_intermediate_files=FALSE)
                         
## End(Not run)
</code></pre>

<hr>
<h2 id='integrated.maplist'>A nested list with integrated maps</h2><span id='topic+integrated.maplist'></span>

<h3>Description</h3>

<p>A nested list with integrated maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrated.maplist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='LGHomDf_P1_1'>A <code>data.frame</code> specifying the assigned homologue and linkage group number per SxN marker</h2><span id='topic+LGHomDf_P1_1'></span><span id='topic+LGHomDf_P2_1'></span><span id='topic+LGHomDf_P2_2'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> specifying the assigned homologue and linkage group number per SxN marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LGHomDf_P1_1

LGHomDf_P2_1

LGHomDf_P2_2
</code></pre>


<h3>Format</h3>


<ul>
<li><p> SxN_Marker. Markername of simplex nulliplex marker
</p>
</li>
<li><p> homologue. Assigned homologue number
</p>
</li>
<li><p> LG Assigned. linkage group number
</p>
</li></ul>

<p>An object of class <code>data.frame</code> with 195 rows and 3 columns.
</p>
<p>An object of class <code>data.frame</code> with 195 rows and 3 columns.
</p>

<hr>
<h2 id='linkage'>Calculate recombination frequency, LOD and phase</h2><span id='topic+linkage'></span>

<h3>Description</h3>

<p><code>linkage</code> is used to calculate recombination frequency, LOD and phase within one type of marker or between two types of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkage(
  dosage_matrix,
  markertype1 = c(1, 0),
  markertype2 = NULL,
  parent1 = "P1",
  parent2 = "P2",
  which_parent = 1,
  ploidy,
  ploidy2 = NULL,
  G2_test = FALSE,
  convert_palindrome_markers = TRUE,
  LOD_threshold = 0,
  pairing = "random",
  prefPars = c(0, 0),
  combinations_per_iter = NULL,
  iter_RAM = 500,
  ncores = 1,
  verbose = TRUE,
  full_output = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkage_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="linkage_+3A_markertype1">markertype1</code></td>
<td>
<p>A vector of length 2 specifying the first markertype to compare. The first element specifies the dosage in <code>which_parent</code> (see below), the second in the other parent.</p>
</td></tr>
<tr><td><code id="linkage_+3A_markertype2">markertype2</code></td>
<td>
<p>A vector of length 2 specifying the first markertype to compare. This argument is optional. If not specified, the function will calculate
linkage within the markertype as specified by <code>markertype1</code>.
The first element specifies the dosage in <code>which_parent</code> (see below), the second in the other parent.</p>
</td></tr>
<tr><td><code id="linkage_+3A_parent1">parent1</code></td>
<td>
<p>Character string specifying the name of parent1 as provided in the column-names of dosage_matrix. By default, &quot;P1&quot;.</p>
</td></tr>
<tr><td><code id="linkage_+3A_parent2">parent2</code></td>
<td>
<p>Character string specifying the other parent as provided in the column-names of dosage_matrix. By default, &quot;P2&quot;.</p>
</td></tr>
<tr><td><code id="linkage_+3A_which_parent">which_parent</code></td>
<td>
<p>Integer, either 1 or 2, with default 1, where 1 or 2 refers to parent1 or parent2 respectively. For example, if you wish to estimate linkage between markers with alleles that 
are polymorphic (i.e. segregating) and originates from parent1, then which_parent = 1. A bi-parental marker is a marker such as a 1x1 marker, so having
a segregating allele in both parents. For linkage estimation between pairs of bi-parental markers, the result does not depend on this argument. For linkage estimation between e.g. a
1x0 and 1x1 marker, then which_parent should be 1. Similarly, to calculate linkage between 0x1 and 1x1 markers, which_parent should be 2.</p>
</td></tr>
<tr><td><code id="linkage_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. The ploidy of the parent 1. If parent2 has the same ploidy level, then also the ploidy level of parent 2.</p>
</td></tr>
<tr><td><code id="linkage_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Integer, by default <code>NULL</code>. If parental ploidies differ, use this to specify the ploidy of parent2.</p>
</td></tr>
<tr><td><code id="linkage_+3A_g2_test">G2_test</code></td>
<td>
<p>Apply a G2 test (LOD of independence) in addition to the LOD of linkage.</p>
</td></tr>
<tr><td><code id="linkage_+3A_convert_palindrome_markers">convert_palindrome_markers</code></td>
<td>
<p>Logical. Should markers that behave the same for both parents be converted to a workable format for that parent? E.g.: should 3.1 markers be converted to 1.3? If unsure, set to TRUE.</p>
</td></tr>
<tr><td><code id="linkage_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>Minimum LOD score of linkages to report. Recommended to use for large number (&gt; millions) of marker comparisons in order to reduce memory usage.</p>
</td></tr>
<tr><td><code id="linkage_+3A_pairing">pairing</code></td>
<td>
<p>Type of chromosomal pairing behaviour during meiosis, either <code>"random"</code> or <code>"preferential"</code>. By default, random pairing is assumed (i.e. polysomic inheritance) is assumed. Note that this default does not affect
linkage estimation in a diploid, where pairing is arguably not random.</p>
</td></tr>
<tr><td><code id="linkage_+3A_prefpars">prefPars</code></td>
<td>
<p>The estimates for preferential pairing parameters for the target and other parent, respectively, in range 0 &lt;= p &lt; 2/3. By default this is c(0,0) (so, no preferential pairing).
See the function <code><a href="#topic+test_prefpairing">test_prefpairing</a></code> and the vignette for more details.</p>
</td></tr>
<tr><td><code id="linkage_+3A_combinations_per_iter">combinations_per_iter</code></td>
<td>
<p>Optional integer. Number of marker combinations per iteration.</p>
</td></tr>
<tr><td><code id="linkage_+3A_iter_ram">iter_RAM</code></td>
<td>
<p>A (very) conservative estimate of working memory in megabytes used per core. It only takes the size frequency matrices into account. Actual usage is more, especially with large number of linkages that are reported. Reduce memory usage by using a higher LOD_threshold.</p>
</td></tr>
<tr><td><code id="linkage_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Works both for Windows and UNIX (using <code>doParallel</code>). Use <code>parallel::detectCores()</code> to find out how many cores you have available.</p>
</td></tr>
<tr><td><code id="linkage_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent to stdout?</p>
</td></tr>
<tr><td><code id="linkage_+3A_full_output">full_output</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, the complete output over all phases and showing marker combination counts is returned.</p>
</td></tr>
<tr><td><code id="linkage_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with columns:
</p>

<dl>
<dt>marker_a</dt><dd>
<p>first marker of comparison. If markertype2 is specified, it has the type of markertype1.
</p>
</dd>
<dt>marker_b</dt><dd>
<p>second marker of comparison. It has the type of markertype2 if specified.
</p>
</dd>
<dt>r</dt><dd>
<p>(estimated) recombinations frequency
</p>
</dd>
<dt>LOD</dt><dd>
<p>(estimated) LOD score
</p>
</dd>
<dt>phase</dt><dd>
<p>phase between markers
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("screened_data3")
SN_SN_P1 &lt;- linkage(dosage_matrix = screened_data3,
                   markertype1 = c(1,0),
                   which_parent = 1,
                   ploidy = 4,
                   pairing = "random",
                   ncores = 1
                   )
</code></pre>

<hr>
<h2 id='linkage.gp'>Calculate recombination frequency, LOD and phase using genotype probabilities</h2><span id='topic+linkage.gp'></span>

<h3>Description</h3>

<p><code>linkage.gp</code> is used to calculate recombination frequency, LOD and phase within one type of marker or between two types of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkage.gp(
  probgeno_df,
  chk,
  pardose = NULL,
  markertype1 = c(1, 0),
  markertype2 = NULL,
  target_parent = match.arg(c("P1", "P2")),
  G2_test = FALSE,
  LOD_threshold = 0,
  prefPars = c(0, 0),
  combinations_per_iter = NULL,
  iter_RAM = 500,
  ncores = 2,
  verbose = TRUE,
  check_qall_mult = FALSE,
  method = "approx",
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkage.gp_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function <code>saveMarkerModels</code> of R package <code>fitPoly</code>, or alternatively, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="linkage.gp_+3A_chk">chk</code></td>
<td>
<p>Output list as returned by function <code><a href="#topic+checkF1">checkF1</a></code></p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_pardose">pardose</code></td>
<td>
<p>Option to include the most likely (discrete) parental dosage scores, used mainly for internal calls of this function. By default <code>NULL</code></p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_markertype1">markertype1</code></td>
<td>
<p>A vector of length 2 specifying the first markertype to compare. The first element specifies the dosage in <code>target_parent</code> (and the second in the other parent).</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_markertype2">markertype2</code></td>
<td>
<p>A vector of length 2 specifying the first markertype to compare. This argument is optional. If not specified, the function will calculate
linkage within the markertype as specified by <code>markertype1</code>.
The first element specifies the dosage in <code>target_parent</code> (and the second in the other parent).</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_target_parent">target_parent</code></td>
<td>
<p>Which parent is being targeted (only acceptable options are &quot;P1&quot; or &quot;P2&quot;), ie. which parent is of specific interest? 
If this is the maternal parent, please specify as &quot;P1&quot;. If the paternal parent, please use &quot;P2&quot;. The actual identifiers of the two parents are
entered using the arguments <code>parent1_replicates</code> and <code>parent2_replicates</code>.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_g2_test">G2_test</code></td>
<td>
<p>Apply a G2 test (LOD of independence) in addition to the LOD of linkage.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>Minimum LOD score of linkages to report. Recommended to use for large number (&gt; millions) of marker comparisons in order to reduce memory usage.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_prefpars">prefPars</code></td>
<td>
<p>The estimates for preferential pairing parameters for parent 1 and 2, in range 0 &lt;= p &lt; 2/3. By default this is c(0,0) (so, no preferential pairing).
See the function <code><a href="#topic+test_prefpairing">test_prefpairing</a></code> and the vignette for more details.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_combinations_per_iter">combinations_per_iter</code></td>
<td>
<p>Optional integer. Number of marker combinations per iteration.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_iter_ram">iter_RAM</code></td>
<td>
<p>A (very) conservative estimate of working memory in megabytes used per core. It only takes the size frequency matrices into account. Actual usage is more, especially with large number of linkages that are reported. Reduce memory usage by using a higher LOD_threshold.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Works both for Windows and UNIX (using <code>doParallel</code>). Use <code>parallel::detectCores()</code> to find out how many cores you have available.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent to stdout?</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_check_qall_mult">check_qall_mult</code></td>
<td>
<p>Check the <code>qall_mult</code> column of <code>chk</code>, and filter out markers with <code>qall_mult = 0</code>. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_method">method</code></td>
<td>
<p>Either <code>"approx"</code> or <code>"mappoly"</code>. If <code>"approx"</code> (the default method), then an approximated estimator is used which introduces
a small amount of bias in the estimator of recombination frequency. If method <code>"mappoly"</code> is specified, the full likelihood is used in the
estimation, leading to an unbiased estimator (this has been implemented in the mappoly package of Marcelo Mollinari). The <code>mappoly</code> method has
higher computational demands which may introduce problems for larger datasets, but will lead to higher accuracy overall.</p>
</td></tr>
<tr><td><code id="linkage.gp_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with columns:
</p>

<dl>
<dt>marker_a:</dt><dd>
<p>first marker of comparison. If markertype2 is specified, it has the type of markertype1.
</p>
</dd>
<dt>marker_b:</dt><dd>
<p>second marker of comparison. It has the type of markertype2 if specified.
</p>
</dd>
<dt>r:</dt><dd>
<p>recombination frequency
</p>
</dd>
<dt>LOD:</dt><dd>
<p>LOD score associated with r
</p>
</dd>
<dt>phase:</dt><dd>
<p>phase between markers
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("gp_df","chk1")
SN_SN_P1.gp &lt;- linkage.gp(probgeno_df = gp_df,
                          chk = chk1,
                          markertype1 = c(1,0),
                          target_parent = "P1")
</code></pre>

<hr>
<h2 id='map1'>A sample map</h2><span id='topic+map1'></span>

<h3>Description</h3>

<p>A sample map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 2 columns.
</p>

<hr>
<h2 id='map2'>A sample map</h2><span id='topic+map2'></span>

<h3>Description</h3>

<p>A sample map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 2 columns.
</p>

<hr>
<h2 id='map3'>A sample map</h2><span id='topic+map3'></span>

<h3>Description</h3>

<p>A sample map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 60 rows and 2 columns.
</p>

<hr>
<h2 id='maplist_P1'>A list of maps of one parent</h2><span id='topic+maplist_P1'></span><span id='topic+maplist_P1_subset'></span><span id='topic+maplist_P2_subset'></span>

<h3>Description</h3>

<p>A list of maps of one parent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maplist_P1

maplist_P1_subset

maplist_P2_subset
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>
<p>An object of class <code>list</code> of length 5.
</p>
<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='marker_binning'>Perform binning of markers.</h2><span id='topic+marker_binning'></span>

<h3>Description</h3>

<p><code>marker_binning</code> allows for binning of very closely linked markers and choses one representative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker_binning(
  dosage_matrix,
  linkage_df,
  r_thresh = NA,
  lod_thresh = NA,
  target_parent = "P1",
  other_parent = "P2",
  max_marker_nr = NULL,
  max_iter = 10,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_binning_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>A dosage <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_r_thresh">r_thresh</code></td>
<td>
<p>Numeric. Threshold at which markers are binned. Is calculated if NA.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_lod_thresh">lod_thresh</code></td>
<td>
<p>Numeric. Threshold at which markers are binned. Is calculated if NA.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_target_parent">target_parent</code></td>
<td>
<p>A character string specifying the name of the target parent.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_other_parent">other_parent</code></td>
<td>
<p>A character string specifying the name of the other parent.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_max_marker_nr">max_marker_nr</code></td>
<td>
<p>The maximum number of markers per homologue. If specified, LOD threshold is optimized based on this number.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to find optimum LOD threshold. Only used if <code>max_marker_nr</code> is specified.</p>
</td></tr>
<tr><td><code id="marker_binning_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>binned_df</code></td>
<td>

<p>A linkage data.frame with binned markers removed.
</p>
</td></tr>
<tr><td><code>removed</code></td>
<td>

<p>A data.frame containing binned markers and their representatives.
</p>
</td></tr>
<tr><td><code>left</code></td>
<td>

<p>Integer. Number markers left.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("screened_data3", "all_linkages_list_P1_split")
binned_markers&lt;-marker_binning(screened_data3, all_linkages_list_P1_split[["LG2"]][["homologue3"]])
</code></pre>

<hr>
<h2 id='marker_data_summary'>Summarize marker data</h2><span id='topic+marker_data_summary'></span>

<h3>Description</h3>

<p>Gives a frequency table of different markertypes, relative frequency per markertype of incompatible offspring and the names of incompatible progeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker_data_summary(
  dosage_matrix,
  ploidy,
  ploidy2 = NULL,
  pairing = c("random", "preferential"),
  parent1 = "P1",
  parent2 = "P2",
  progeny_incompat_cutoff = 0.1,
  verbose = TRUE,
  shortform = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_data_summary_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. Ploidy of parent 1, and .</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Ploidy of parent 2, by default <code>NULL</code>, as it is assumed ploidy2 equals ploidy.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_pairing">pairing</code></td>
<td>
<p>Type of pairing. &quot;random&quot; or &quot;preferential&quot;.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_parent1">parent1</code></td>
<td>
<p>Column name of first parent. Usually maternal parent.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_parent2">parent2</code></td>
<td>
<p>Column name of second parent. Usually paternal parent.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_progeny_incompat_cutoff">progeny_incompat_cutoff</code></td>
<td>
<p>The relative number of incompatible dosages per genotype that results in reporting
this genotype as incompatible. Incompatible dosages are greater than maximum number of alleles than can be inherited or
smaller than the minimum number of alleles that can be inherited.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_verbose">verbose</code></td>
<td>
<p>Logical, by default <code>TRUE</code> - should intermediate messages be written to stout?</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_shortform">shortform</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. Returns only a shortened output with parental dosage summary, used internally by some functions.</p>
</td></tr>
<tr><td><code id="marker_data_summary_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>
<table>
<tr><td><code>parental_info</code></td>
<td>

<p>frequency table of different markertypes. Names start with parentnames, and behind that the dosage score.
</p>
</td></tr>
<tr><td><code>offspring_incompatible</code></td>
<td>

<p>Rate of incompatible (&quot;impossible&quot;) marker scores (given as percentages of the total number of observed marker scores per marker class)
</p>
</td></tr>
<tr><td><code>progeny_incompatible</code></td>
<td>

<p>progeny names having incompatible dosage scores higher than threshold at progeny_incompat_cutoff.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("ALL_dosages")
summary_list&lt;-marker_data_summary(dosage_matrix = ALL_dosages, ploidy = 4)
</code></pre>

<hr>
<h2 id='MDSMap_from_list'>Wrapper function for MDSMap to generate linkage maps from list of pairwise linkage estimates</h2><span id='topic+MDSMap_from_list'></span>

<h3>Description</h3>

<p>Create multidimensional scaling maps from a list of linkages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDSMap_from_list(
  linkage_list,
  write_to_file = FALSE,
  mapdir = "mapping_files_MDSMap",
  plot_prefix = "",
  log = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDSMap_from_list_+3A_linkage_list">linkage_list</code></td>
<td>
<p>A named <code>list</code> with r and LOD of markers within linkage groups.</p>
</td></tr>
<tr><td><code id="MDSMap_from_list_+3A_write_to_file">write_to_file</code></td>
<td>
<p>Should output be written to a file? By default <code>FALSE</code>, if <code>TRUE</code> then output,
including plots from <code>MDSMap</code> are saved in the same directory as the one used for input files. These
plots are currently saved as pdf images. If a different plot format is required (e.g. for publications),
then run the <code>MDSMap</code> function <code><a href="MDSMap.html#topic+estimate.map">estimate.map</a></code> (or similar) directly and save the output
with a different plotting function as wrapper around the map function call.</p>
</td></tr>
<tr><td><code id="MDSMap_from_list_+3A_mapdir">mapdir</code></td>
<td>
<p>Directory to which map input files are initially written. Also used for output if <code>write_to_file=TRUE</code></p>
</td></tr>
<tr><td><code id="MDSMap_from_list_+3A_plot_prefix">plot_prefix</code></td>
<td>
<p>prefix for the filenames of output plots.</p>
</td></tr>
<tr><td><code id="MDSMap_from_list_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written.
If NULL log is send to stdout.</p>
</td></tr>
<tr><td><code id="MDSMap_from_list_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="MDSMap.html#topic+estimate.map">estimate.map</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("all_linkages_list_P1")
maplist_P1 &lt;- MDSMap_from_list(all_linkages_list_P1[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='merge_homologues'>Merge homologues</h2><span id='topic+merge_homologues'></span>

<h3>Description</h3>

<p>Based on additional information, homologue fragments, separated during clustered should be merged again.
<code>merge_homologues</code> allows to merge homologues per linkage group based on user input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_homologues(LG_hom_stack, ploidy, LG, mergeList = NULL, log = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_homologues_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A <code>data.frame</code> with markernames, linkage group (<code>"LG"</code>) and homologue (<code>"homologue"</code>)</p>
</td></tr>
<tr><td><code id="merge_homologues_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy level of the plant species.</p>
</td></tr>
<tr><td><code id="merge_homologues_+3A_lg">LG</code></td>
<td>
<p>The linkage group where the to be merged homologue fragments are in.</p>
</td></tr>
<tr><td><code id="merge_homologues_+3A_mergelist">mergeList</code></td>
<td>
<p>A list of vectors of length 2, specifying the numbers of the homologue fragments to be merged. User input is asked if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="merge_homologues_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified LG_hom_stack
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LGHomDf_P2_1")
merged&lt;-merge_homologues(LGHomDf_P2_1,ploidy=4,LG=2,mergeList=list(c(1,5)))
</code></pre>

<hr>
<h2 id='mout'>Example output dataset of updog::multidog function</h2><span id='topic+mout'></span>

<h3>Description</h3>

<p>Example output dataset of updog::multidog function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mout
</code></pre>


<h3>Format</h3>

<p>An object of class <code>multidog</code> of length 2.
</p>

<hr>
<h2 id='overviewSNlinks'>Plotting 1.0 links between homologues</h2><span id='topic+overviewSNlinks'></span>

<h3>Description</h3>

<p><code>overviewSNlinks</code> is written to enable merging of homologue fractions.
Fractions of homologues will have more markers in coupling than in repulsion, whereas separate homologues will only have markers in repulsion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overviewSNlinks(
  linkage_df,
  LG_hom_stack,
  LG,
  LOD_threshold,
  ymax = NULL,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overviewSNlinks_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A data.frame as output of <code><a href="#topic+linkage">linkage</a></code> with arguments markertype1=c(1,0) and markertype2=NULL.</p>
</td></tr>
<tr><td><code id="overviewSNlinks_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A data.frame with a column &quot;SxN_Marker&quot; specifying markernames,
a column &quot;homologue&quot; specifying homologue cluster and &quot;LG&quot; specifying linkage group.</p>
</td></tr>
<tr><td><code id="overviewSNlinks_+3A_lg">LG</code></td>
<td>
<p>Integer. Linkage group number of interest.</p>
</td></tr>
<tr><td><code id="overviewSNlinks_+3A_lod_threshold">LOD_threshold</code></td>
<td>
<p>Numeric. LOD threshold of linkages which are plotted.</p>
</td></tr>
<tr><td><code id="overviewSNlinks_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y-limit of the plots.</p>
</td></tr>
<tr><td><code id="overviewSNlinks_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P1", "LGHomDf_P1_1")
overviewSNlinks(linkage_df=SN_SN_P1,
               LG_hom_stack=LGHomDf_P1_1,
               LG=5,
               LOD_threshold=3)
</code></pre>

<hr>
<h2 id='P1_homologues'>A list of cluster stacks at different LOD scores</h2><span id='topic+P1_homologues'></span><span id='topic+P2_homologues'></span><span id='topic+P2_homologues_triploid'></span>

<h3>Description</h3>

<p>A list of cluster stacks at different LOD scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P1_homologues

P2_homologues

P2_homologues_triploid
</code></pre>


<h3>Format</h3>

<p>A list with with LOD thresholds as names. The list contains dataframes with the following format:
</p>

<ul>
<li><p> marker. markername
</p>
</li>
<li><p> pseudohomologue. name of (pseudo)homologue
</p>
</li></ul>

<p>An object of class <code>list</code> of length 10.
</p>
<p>An object of class <code>list</code> of length 15.
</p>

<hr>
<h2 id='P1_SxS_Assigned'>A <code>data.frame</code> with marker assignments</h2><span id='topic+P1_SxS_Assigned'></span><span id='topic+P2_SxS_Assigned'></span><span id='topic+P2_SxS_Assigned_2'></span><span id='topic+P1_DxN_Assigned'></span><span id='topic+P2_DxN_Assigned'></span><span id='topic+marker_assignments_P1'></span><span id='topic+marker_assignments_P2'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> with marker assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P1_SxS_Assigned

P2_SxS_Assigned

P2_SxS_Assigned_2

P1_DxN_Assigned

P2_DxN_Assigned

marker_assignments_P1

marker_assignments_P2
</code></pre>


<h3>Format</h3>

<p>A data.frame with at least the following columns:
</p>

<ul>
<li><p> Assigned_LG. The assigned linkage group
</p>
</li>
<li><p> Assigend_hom1. The homologue with most linkages
</p>
</li></ul>

<p>The columns LG1 - LGn and Hom1 - Homn give the number of hits per marker for that linkage group/homologue. Assigned_hom2 .. gives the nth homologue with most linkages.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 301 rows and 14 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 301 rows and 14 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 111 rows and 14 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 101 rows and 14 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1094 rows and 16 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1127 rows and 16 columns.
</p>

<hr>
<h2 id='p4_functions'>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a preferential pairing tetraploid</h2><span id='topic+p4_functions'></span>

<h3>Description</h3>

<p>This group of functions is called by <code><a href="#topic+linkage">linkage</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="p4_functions_+3A_x">x</code></td>
<td>
<p>A frequency table of the different classes of dosages in the progeny. The column names start with <code>"n_"</code>. Followed by the dosage of the first marker and then of the second.</p>
</td></tr>
<tr><td><code id="p4_functions_+3A_p1">p1</code></td>
<td>
<p>Preferential pairing parameter for parent 1, numeric value in range 0 &lt;= p1 &lt; 2/3</p>
</td></tr>
<tr><td><code id="p4_functions_+3A_p2">p2</code></td>
<td>
<p>Preferential pairing parameter for parent 2, numeric value in range 0 &lt;= p2 &lt; 2/3</p>
</td></tr>
<tr><td><code id="p4_functions_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>r_mat</code></td>
<td>
<p>A matrix with recombination frequencies for the different phases</p>
</td></tr>
<tr><td><code>LOD_mat</code></td>
<td>
<p>A matrix with LOD scores for the different phases</p>
</td></tr>
<tr><td><code>logL_mat</code></td>
<td>
<p>A matrix with log likelihood ratios for the different phases</p>
</td></tr>
<tr><td><code>phasing_strategy</code></td>
<td>
<p>A character string specifying the phasing strategy. <code>"MLL"</code> for maximum likelihood en <code>"MINR"</code> for minimum recombination frequency.</p>
</td></tr>
<tr><td><code>possible_phases</code></td>
<td>
<p>The phases between markers that are possible. Same order and length as column names of output matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='parental_quantities'>Calculate frequency of each markertype.</h2><span id='topic+parental_quantities'></span>

<h3>Description</h3>

<p>Plots and returns frequency information for each markertype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parental_quantities(
  dosage_matrix,
  parent1 = "P1",
  parent2 = "P2",
  log = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parental_quantities_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="parental_quantities_+3A_parent1">parent1</code></td>
<td>
<p>Character string specifying the first (usually maternal) parentname.</p>
</td></tr>
<tr><td><code id="parental_quantities_+3A_parent2">parent2</code></td>
<td>
<p>Character string specifying the second (usually paternal) parentname.</p>
</td></tr>
<tr><td><code id="parental_quantities_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
<tr><td><code id="parental_quantities_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing the frequency of each markertype in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ALL_dosages","screened_data")
parental_quantities(dosage_matrix=ALL_dosages)
parental_quantities(dosage_matrix=screened_data)
</code></pre>

<hr>
<h2 id='PCA_progeny'>Perform a PCA on progeny</h2><span id='topic+PCA_progeny'></span>

<h3>Description</h3>

<p>Principal component analysis in order to identify individuals that deviate from the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA_progeny(dosage_matrix, highlight = NULL, colors = NULL, log = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA_progeny_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="PCA_progeny_+3A_highlight">highlight</code></td>
<td>
<p>A list of character vectors specifying individual names that should be highlighted</p>
</td></tr>
<tr><td><code id="PCA_progeny_+3A_colors">colors</code></td>
<td>
<p>Highlight colors. Vector of the same length as <code>highlight</code>.</p>
</td></tr>
<tr><td><code id="PCA_progeny_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are imputed by taking the mean of marker dosages per marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ALL_dosages")
PCA_progeny(dosage_matrix=ALL_dosages, highlight=list(c("P1", "P2")), colors="red")
</code></pre>

<hr>
<h2 id='phase_SN_diploid'>Phase 1.0 markers at the diploid level</h2><span id='topic+phase_SN_diploid'></span>

<h3>Description</h3>

<p><code>phase_SN_diploid</code> phases simplex x nulliplex markers for a diploid parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase_SN_diploid(
  linkage_df,
  cluster_list,
  LOD_chm = 3.5,
  LG_number,
  independence_LOD = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase_SN_diploid_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage data.frame as output of <code><a href="#topic+linkage">linkage</a></code> calculating linkage between 1.0 markers.</p>
</td></tr>
<tr><td><code id="phase_SN_diploid_+3A_cluster_list">cluster_list</code></td>
<td>
<p>A list of cluster_stacks, the output of <code>cluster_SN_markers</code>.</p>
</td></tr>
<tr><td><code id="phase_SN_diploid_+3A_lod_chm">LOD_chm</code></td>
<td>
<p>Integer. The LOD threshold specifying at which LOD score the markers divide into chromosomal groups</p>
</td></tr>
<tr><td><code id="phase_SN_diploid_+3A_lg_number">LG_number</code></td>
<td>
<p>Expected number of chromosomes (linkage groups)</p>
</td></tr>
<tr><td><code id="phase_SN_diploid_+3A_independence_lod">independence_LOD</code></td>
<td>
<p>Logical. Should the LOD of independence be used for clustering? (by default, <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="phase_SN_diploid_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout (console).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with markers classified by homologue and linkage group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P2_triploid","P2_homologues_triploid")
cluster_list2&lt;-phase_SN_diploid(SN_SN_P2_triploid,P2_homologues_triploid,LOD_chm=5,LG_number = 3)
</code></pre>

<hr>
<h2 id='phased.maplist'>A list of phased maps</h2><span id='topic+phased.maplist'></span>

<h3>Description</h3>

<p>A list of phased maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phased.maplist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='plot_hom_vs_LG'>Plot homologue position versus integrated positions</h2><span id='topic+plot_hom_vs_LG'></span>

<h3>Description</h3>

<p>Plot homologue position versus integrated positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hom_vs_LG(map_df, maplist_homologue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hom_vs_LG_+3A_map_df">map_df</code></td>
<td>
<p>A dataframe of a map that defines a linkage group.</p>
</td></tr>
<tr><td><code id="plot_hom_vs_LG_+3A_maplist_homologue">maplist_homologue</code></td>
<td>
<p>A list of maps were each item represents a homoloogue.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("integrated.maplist", "maplist_P1_subset")
colnames(integrated.maplist[["LG2"]]) &lt;- c("marker", "position", "QTL_LOD")
plot_hom_vs_LG(map_df = integrated.maplist[["LG2"]],
               maplist_homologue = maplist_P1_subset[["LG2"]])
</code></pre>

<hr>
<h2 id='plot_map'>Plot linkage maps</h2><span id='topic+plot_map'></span>

<h3>Description</h3>

<p>Makes a simple plot of a list of generated linkage maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_map(
  maplist,
  highlight = NULL,
  bg_col = "grey",
  highlight_col = "yellow",
  colname_in_mark = NULL,
  colname_beside_mark = NULL,
  palette_in_mark = colorRampPalette(c("white", "purple")),
  palette_beside_mark = colorRampPalette(c("white", "green")),
  color_by_type = FALSE,
  dosage_matrix = NULL,
  parent1 = "P1",
  parent2 = "P2",
  legend = FALSE,
  ...,
  legend.args = list(x = 1, y = 120)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_map_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. In the first column marker names and in the second their position.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_highlight">highlight</code></td>
<td>
<p>A list of the same length of maplist with vectors of length 2 that specifies the
limits in cM from and to which the plotted chromosomes should be highlighted.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_bg_col">bg_col</code></td>
<td>
<p>The background colour of the map.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_highlight_col">highlight_col</code></td>
<td>
<p>The color of the highlight. Only used if <code>highlight</code> is specified.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_colname_in_mark">colname_in_mark</code></td>
<td>
<p>Optional. The column name of the value to be plotted as marker color.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_colname_beside_mark">colname_beside_mark</code></td>
<td>
<p>Optional. The column name of the value to be plotted beside the markers.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_palette_in_mark">palette_in_mark</code>, <code id="plot_map_+3A_palette_beside_mark">palette_beside_mark</code></td>
<td>
<p>Color palette used to plot values. Only used if colnames of the values are specified.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_color_by_type">color_by_type</code></td>
<td>
<p>Logical. Should the markers be coloured by type? If TRUE, dosage_matrix should be specified.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>Optional (by default <code>NULL</code>). Dosage matrix of marker genotypes, input of <code><a href="#topic+linkage">linkage</a></code></p>
</td></tr>
<tr><td><code id="plot_map_+3A_parent1">parent1</code></td>
<td>
<p>Character string specifying the first (usually maternal) parentname.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_parent2">parent2</code></td>
<td>
<p>Character string specifying the second (usually paternal) parentname.</p>
</td></tr>
<tr><td><code id="plot_map_+3A_legend">legend</code></td>
<td>
<p>Logical. Should a legend be drawn?</p>
</td></tr>
<tr><td><code id="plot_map_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot_map_+3A_legend.args">legend.args</code></td>
<td>
<p>Optional extra arguments to pass to <code><a href="graphics.html#topic+legend">legend</a></code>, by default a list with x = 1 and y = 120 (position of the legend). 
Additional arguments should be passed using name = value, i.e. as a named list. Note that arguments <code>lty</code> (= 1) and <code>lwd</code> (= 2) have
already been used internally (as well as <code>legend</code> and <code>col</code>), so cannot be re-specified without causing an error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("maplist_P1")
plot_map(maplist = maplist_P1, colname_in_mark = "nnfit", bg_col = "white",
         palette_in_mark = colorRampPalette(c("blue", "purple", "red")),
         highlight = list(c(20, 60),
         c(60,80),
         c(20,30),
         c(40,70),
         c(60,80)))
</code></pre>

<hr>
<h2 id='plot_phased_maplist'>Visualise the phased homologue maplist</h2><span id='topic+plot_phased_maplist'></span>

<h3>Description</h3>

<p><code>plot_phased_maplist</code> is a function for visualising a phased maplist, the output of
<code><a href="#topic+create_phased_maplist">create_phased_maplist</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_phased_maplist(
  phased.maplist,
  ploidy,
  ploidy2 = NULL,
  cols = c("black", "darkred", "navyblue"),
  width = 0.2,
  mapTitles = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_phased_maplist_+3A_phased.maplist">phased.maplist</code></td>
<td>
<p>A list of phased linkage maps, the output of <code><a href="#topic+create_phased_maplist">create_phased_maplist</a></code></p>
</td></tr>
<tr><td><code id="plot_phased_maplist_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. Ploidy of the organism.</p>
</td></tr>
<tr><td><code id="plot_phased_maplist_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Optional integer, by default <code>NULL</code>. Ploidy of parent 2, if different from parent 1.</p>
</td></tr>
<tr><td><code id="plot_phased_maplist_+3A_cols">cols</code></td>
<td>
<p>Vector of colours for the integrated, parent1 and parent2 maps, respectively.</p>
</td></tr>
<tr><td><code id="plot_phased_maplist_+3A_width">width</code></td>
<td>
<p>Width of the linkage maps, by default 0.2</p>
</td></tr>
<tr><td><code id="plot_phased_maplist_+3A_maptitles">mapTitles</code></td>
<td>
<p>Optional vector of titles for maps, by default names of maplist, or titles LG1, LG2 etc. are used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("phased.maplist")
plot_phased_maplist(phased.maplist, ploidy = 4)
</code></pre>

<hr>
<h2 id='polymapR-package'>polymapR: Linkage Analysis in Outcrossing Polyploids</h2><span id='topic+polymapR'></span><span id='topic+polymapR-package'></span>

<h3>Description</h3>

<p>Creation of linkage maps in polyploid species from marker dosage scores of an F1 cross from two heterozygous parents. Currently works for outcrossing diploid, autotriploid, autotetraploid and autohexaploid species, as well as segmental allotetraploids. Methods are described in a manuscript of Bourke et al. (2018) <a href="https://doi.org/10.1093/bioinformatics/bty371">doi:10.1093/bioinformatics/bty371</a>. Since version 1.1.0, both discrete and probabilistic genotypes are acceptable input; for more details on the latter see Liao et al. (2021) <a href="https://doi.org/10.1007/s00122-021-03834-x">doi:10.1007/s00122-021-03834-x</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Peter Bourke <a href="mailto:pbourkey@gmail.com">pbourkey@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Geert van Geest
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Roeland Voorrips [contributor]
</p>
</li>
<li><p> Yanlin Liao [contributor]
</p>
</li></ul>


<hr>
<h2 id='r_LOD_plot'>Plot r versus LOD</h2><span id='topic+r_LOD_plot'></span>

<h3>Description</h3>

<p><code>r_LOD_plot</code> plots r versus LOD, colour separated for different phases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_LOD_plot(
  linkage_df,
  plot_main = "",
  chm = NA,
  r_max = 0.5,
  tidyplot = TRUE,
  nbins = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_LOD_plot_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage data.frame as output of <code><a href="#topic+linkage">linkage</a></code>.</p>
</td></tr>
<tr><td><code id="r_LOD_plot_+3A_plot_main">plot_main</code></td>
<td>
<p>A character string specifying the main title</p>
</td></tr>
<tr><td><code id="r_LOD_plot_+3A_chm">chm</code></td>
<td>
<p>Integer specifying chromosome</p>
</td></tr>
<tr><td><code id="r_LOD_plot_+3A_r_max">r_max</code></td>
<td>
<p>Maximum r value to plot</p>
</td></tr>
<tr><td><code id="r_LOD_plot_+3A_tidyplot">tidyplot</code></td>
<td>
<p>If <code>TRUE</code> (by default), an attempt is made to reduce the plot density using hexagonal binning from the <code>ggplot2</code> package. 
This is recommended for large datasets, where the number of pairwise estimates becomes high.</p>
</td></tr>
<tr><td><code id="r_LOD_plot_+3A_nbins">nbins</code></td>
<td>
<p>The number of bins in each direction, passed to ggplot2::geom_hex. Only used if <code>tidyplot = TRUE</code>. Increasing this number
can lead to slower but more accurate plotting.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P1")
r_LOD_plot(SN_SN_P1)
</code></pre>

<hr>
<h2 id='r2_functions'>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing diploid cross.</h2><span id='topic+r2_functions'></span><span id='topic+r2_1.0_1.0'></span><span id='topic+r2_1.0_1.1'></span><span id='topic+r2_1.1_1.1'></span>

<h3>Description</h3>

<p>This group of functions is called by <code><a href="#topic+linkage">linkage</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2_1.0_1.0(x, ncores = 1)

r2_1.0_1.1(x, ncores = 1)

r2_1.1_1.1(x, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2_functions_+3A_x">x</code></td>
<td>
<p>A frequency table of the different classes of dosages in the progeny. The column names start with <code>"n_"</code>. Followed by the dosage of the first marker and then of the second.</p>
</td></tr>
<tr><td><code id="r2_functions_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>r_mat</code></td>
<td>
<p>A matrix with recombination frequencies for the different phases</p>
</td></tr>
<tr><td><code>LOD_mat</code></td>
<td>
<p>A matrix with LOD scores for the different phases</p>
</td></tr>
<tr><td><code>logL_mat</code></td>
<td>
<p>A matrix with log likelihood ratios for the different phases</p>
</td></tr>
<tr><td><code>phasing_strategy</code></td>
<td>
<p>A character string specifying the phasing strategy. <code>"MLL"</code> for maximum likelihood en <code>"MINR"</code> for minimum recombination frequency.</p>
</td></tr>
<tr><td><code>possible_phases</code></td>
<td>
<p>The phases between markers that are possible. Same order and length as column names of output matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='r3_functions'>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing triploid from a 4x2 or 2x4 cross.</h2><span id='topic+r3_functions'></span><span id='topic+r3_2_1.0_1.0'></span><span id='topic+r3_2_1.0_1.1'></span><span id='topic+r3_2_1.0_1.2'></span><span id='topic+r3_2_1.2_1.2'></span>

<h3>Description</h3>

<p>This group of functions is called by <code><a href="#topic+linkage">linkage</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r3_2_1.0_1.0(x, ncores = 1)

r3_2_1.0_1.1(x, ncores = 1)

r3_2_1.0_1.2(x, ncores = 1)

r3_2_1.2_1.2(x, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r3_functions_+3A_x">x</code></td>
<td>
<p>A frequency table of the different classes of dosages in the progeny. The column names start with <code>"n_"</code>. Followed by the dosage of the first marker and then of the second.</p>
</td></tr>
<tr><td><code id="r3_functions_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>r_mat</code></td>
<td>
<p>A matrix with recombination frequencies for the different phases</p>
</td></tr>
<tr><td><code>LOD_mat</code></td>
<td>
<p>A matrix with LOD scores for the different phases</p>
</td></tr>
<tr><td><code>logL_mat</code></td>
<td>
<p>A matrix with log likelihood ratios for the different phases</p>
</td></tr>
<tr><td><code>phasing_strategy</code></td>
<td>
<p>A character string specifying the phasing strategy. <code>"MLL"</code> for maximum likelihood en <code>"MINR"</code> for minimum recombination frequency.</p>
</td></tr>
<tr><td><code>possible_phases</code></td>
<td>
<p>The phases between markers that are possible. Same order and length as column names of output matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='r4_functions'>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing tetraploid</h2><span id='topic+r4_functions'></span>

<h3>Description</h3>

<p>This group of functions is called by <code><a href="#topic+linkage">linkage</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="r4_functions_+3A_x">x</code></td>
<td>
<p>A frequency table of the different classes of dosages in the progeny. The column names start with <code>"n_"</code>. Followed by the dosage of the first marker and then of the second.</p>
</td></tr>
<tr><td><code id="r4_functions_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing (deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>r_mat</code></td>
<td>
<p>A matrix with recombination frequencies for the different phases</p>
</td></tr>
<tr><td><code>LOD_mat</code></td>
<td>
<p>A matrix with LOD scores for the different phases</p>
</td></tr>
<tr><td><code>logL_mat</code></td>
<td>
<p>A matrix with log likelihood ratios for the different phases</p>
</td></tr>
<tr><td><code>phasing_strategy</code></td>
<td>
<p>A character string specifying the phasing strategy. <code>"MLL"</code> for maximum likelihood en <code>"MINR"</code> for minimum recombination frequency.</p>
</td></tr>
<tr><td><code>possible_phases</code></td>
<td>
<p>The phases between markers that are possible. Same order and length as column names of output matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='r6_functions'>Calculate recombination frequency, LOD and log-likelihood from frequency tables in a random pairing hexaploid</h2><span id='topic+r6_functions'></span>

<h3>Description</h3>

<p>This group of functions is called by <code><a href="#topic+linkage">linkage</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="r6_functions_+3A_x">x</code></td>
<td>
<p>A frequency table of the different classes of dosages in the progeny. The column names start with <code>"n_"</code>. Followed by the dosage of the first marker and then of the second.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>r_mat</code></td>
<td>
<p>A matrix with recombination frequencies for the different phases</p>
</td></tr>
<tr><td><code>LOD_mat</code></td>
<td>
<p>A matrix with LOD scores for the different phases</p>
</td></tr>
<tr><td><code>logL_mat</code></td>
<td>
<p>A matrix with log likelihood ratios for the different phases</p>
</td></tr>
<tr><td><code>phasing_strategy</code></td>
<td>
<p>A character string specifying the phasing strategy. <code>"MLL"</code> for maximum likelihood en <code>"MINR"</code> for minimum recombination frequency.</p>
</td></tr>
<tr><td><code>possible_phases</code></td>
<td>
<p>The phases between markers that are possible. Same order and length as column names of output matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='screen_for_duplicate_individuals'>Screen for duplicate individuals</h2><span id='topic+screen_for_duplicate_individuals'></span>

<h3>Description</h3>

<p><code>screen_for_duplicate_individuals</code> identifies and merges duplicate individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_for_duplicate_individuals(
  dosage_matrix,
  cutoff = NULL,
  plot_cor = TRUE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_for_duplicate_individuals_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals_+3A_cutoff">cutoff</code></td>
<td>
<p>Correlation coefficient cut off. At this correlation coefficient, individuals are merged. If NULL user input will be asked after plotting.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals_+3A_plot_cor">plot_cor</code></td>
<td>
<p>Logical. Should correlation coefficients be plotted? Can be memory/CPU intensive with high number of individuals.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix similar to dosage_matrix, with merged duplicate individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#user input:
data("segregating_data")
screen_for_duplicate_individuals(dosage_matrix=segregating_data,cutoff=0.9,plot_cor=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='screen_for_duplicate_individuals.gp'>Screen for duplicate individuals using weighted genotype probabilities</h2><span id='topic+screen_for_duplicate_individuals.gp'></span>

<h3>Description</h3>

<p><code>screen_for_duplicate_individuals.gp</code> identifies and merges duplicate individuals based on probabilistic genotypes.
See <code><a href="#topic+screen_for_duplicate_individuals">screen_for_duplicate_individuals</a></code> for the original function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_for_duplicate_individuals.gp(
  probgeno_df,
  ploidy,
  parent1 = "P1",
  parent2 = "P2",
  F1,
  cutoff = 0.95,
  plot_cor = TRUE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_probgeno_df">probgeno_df</code></td>
<td>
<p>A data frame as read from the scores file produced by function
<code>saveMarkerModels</code> of R package <code>fitPoly</code>, or alternatively, a data frame containing the following columns:
</p>

<dl>
<dt>SampleName</dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName</dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0</dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1...</dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max dosage, e.g. P4 for tetraploid population)
</p>
</dd>
<dt>maxP</dt><dd>
<p>Maximum genotype probability identified for a particular individual and marker combination
</p>
</dd>
<dt>maxgeno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination
</p>
</dd>
<dt>geno</dt><dd>
<p>Most probable dosage for a particular individual and marker combination, if <code>maxP</code> exceeds a user-defined threshold (e.g. 0.9), otherwise <code>NA</code>
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of parent 1</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_parent1">parent1</code></td>
<td>
<p>character vector with the sample names of parent 1</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_parent2">parent2</code></td>
<td>
<p>character vector with the sample names of parent 2</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_f1">F1</code></td>
<td>
<p>character vector with the sample names of the F1 individuals</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_cutoff">cutoff</code></td>
<td>
<p>Correlation coefficient cut off to declare duplicates. At this correlation coefficient, individuals are merged. If <code>NULL</code> user input will be asked after plotting.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_plot_cor">plot_cor</code></td>
<td>
<p>Logical. Should correlation coefficients be plotted? Can be memory/CPU intensive with high number of individuals.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_individuals.gp_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame similar to input <code>probgeno_df</code>, but with duplicate individuals merged.
</p>

<hr>
<h2 id='screen_for_duplicate_markers'>Screen for and remove duplicated markers</h2><span id='topic+screen_for_duplicate_markers'></span>

<h3>Description</h3>

<p><code>screen_for_duplicate_markers</code> identifies and merges duplicate markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_for_duplicate_markers(
  dosage_matrix,
  merge_NA = TRUE,
  plot_cluster_size = TRUE,
  ploidy,
  ploidy2 = NULL,
  LG_number,
  estimate_bin_size = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_for_duplicate_markers_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_merge_na">merge_NA</code></td>
<td>
<p>Logical. Should missing values be imputed if non-NA in duplicated marker? By default, <code>TRUE</code>.
If <code>FALSE</code> the dosage scores of representing marker are represented in the filtered_dosage_matrix.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_plot_cluster_size">plot_cluster_size</code></td>
<td>
<p>Logical. Should an informative plot about duplicate cluster size be given? By default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level of parent 1. Only needed if <code>estimate_bin_size</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Integer, by default <code>NULL</code>. If parental ploidies differ, use this to specify the ploidy of parent 2. 
Only needed if <code>estimate_bin_size</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_lg_number">LG_number</code></td>
<td>
<p>Expected number of chromosomes (linkage groups). Only needed if <code>estimate_bin_size</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_estimate_bin_size">estimate_bin_size</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, a very rudimentary calculation is made to estimate
the average size of a marker bin, assuming a uniform distribution of cross-over events and on average one cross-over per bivalent.</p>
</td></tr>
<tr><td><code id="screen_for_duplicate_markers_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>bin_list</dt><dd><p>list of binned markers. The list names are the representing markers.
This information can later be used to enrich the map with binned markers.</p>
</dd>
<dt>filtered_dosage_matrix</dt><dd><p>dosage_matrix with merged duplicated markers.
The markers will be given the name of the marker with least missing values.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("screened_data3")
dupmscreened &lt;- screen_for_duplicate_markers(screened_data3)
</code></pre>

<hr>
<h2 id='screen_for_NA_values'>Screen marker data for NA values</h2><span id='topic+screen_for_NA_values'></span>

<h3>Description</h3>

<p><code>screen_for_NA_values</code> identifies and can remove rows or columns of a marker dataset based on the relative frequency of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_for_NA_values(
  dosage_matrix,
  margin = 1,
  cutoff = NULL,
  parentnames = c("P1", "P2"),
  plot_breakdown = FALSE,
  log = NULL,
  print.removed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_for_NA_values_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="screen_for_NA_values_+3A_margin">margin</code></td>
<td>
<p>An integer at which margin the missing value frequency will be calculated. A value of 1 means rows (markers), 2 means columns (individuals)</p>
</td></tr>
<tr><td><code id="screen_for_NA_values_+3A_cutoff">cutoff</code></td>
<td>
<p>Missing value frequency cut off. At this frequency, rows or columns are removed from the dataset. If NULL user input will be asked after plotting the missing value frequency histogram.</p>
</td></tr>
<tr><td><code id="screen_for_NA_values_+3A_parentnames">parentnames</code></td>
<td>
<p>A character vector of length 2, specifying the parent names.</p>
</td></tr>
<tr><td><code id="screen_for_NA_values_+3A_plot_breakdown">plot_breakdown</code></td>
<td>
<p>Logical. Should the percentage of markers removed as breakdown per markertype be plotted? Can only be used if margin = 1.</p>
</td></tr>
<tr><td><code id="screen_for_NA_values_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
<tr><td><code id="screen_for_NA_values_+3A_print.removed">print.removed</code></td>
<td>
<p>Logical. Should removed instances be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix similar to dosage_matrix, with rows or columns removed that had a higher missing value frequency than specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("segregating_data","screened_data")
screened_markers&lt;-screen_for_NA_values(dosage_matrix=segregating_data, margin=1, cutoff=0.1)
screened_indiv&lt;-screen_for_NA_values(dosage_matrix=screened_data, margin=2, cutoff=0.1)
</code></pre>

<hr>
<h2 id='SN_SN_P1'>A linkage <code>data.frame</code>.</h2><span id='topic+SN_SN_P1'></span><span id='topic+SN_SN_P2'></span><span id='topic+SN_SS_P1'></span><span id='topic+SN_SS_P2'></span><span id='topic+SN_DN_P1'></span><span id='topic+SN_DN_P2'></span><span id='topic+SN_SN_P2_triploid'></span>

<h3>Description</h3>

<p>A linkage <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SN_SN_P1

SN_SN_P2

SN_SS_P1

SN_SS_P2

SN_DN_P1

SN_DN_P2

SN_SN_P2_triploid
</code></pre>


<h3>Format</h3>


<ul>
<li><p> marker_a. First marker in comparison
</p>
</li>
<li><p> marker_b. Second marker in comparison
</p>
</li>
<li><p> r. recombination frequency
</p>
</li>
<li><p> LOD. LOD score
</p>
</li>
<li><p> phase. The phase between markers
</p>
</li></ul>

<p>An object of class <code>linkage_df</code> (inherits from <code>data.frame</code>) with 19306 rows and 5 columns.
</p>
<p>An object of class <code>linkage_df</code> (inherits from <code>data.frame</code>) with 53152 rows and 5 columns.
</p>
<p>An object of class <code>linkage_df</code> (inherits from <code>data.frame</code>) with 59494 rows and 5 columns.
</p>
<p>An object of class <code>linkage_df</code> (inherits from <code>data.frame</code>) with 19536 rows and 5 columns.
</p>
<p>An object of class <code>linkage_df</code> (inherits from <code>data.frame</code>) with 19897 rows and 5 columns.
</p>
<p>An object of class <code>data.frame</code> with 6655 rows and 5 columns.
</p>

<hr>
<h2 id='SNSN_LOD_deviations'>Identify deviations in LOD scores between pairs of simplex x nulliplex markers</h2><span id='topic+SNSN_LOD_deviations'></span>

<h3>Description</h3>

<p><code>SNSN_LOD_deviations</code> checks whether the LOD scores obtained in the case of pairs of simplex x nulliple
markers are compatible with expectation. This can help identify problematic linkage estimates which can adversely affect
marker clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNSN_LOD_deviations(
  linkage_df,
  ploidy,
  N,
  plot_expected = TRUE,
  alpha = c(0.05, 0.2),
  phase = c("coupling", "repulsion")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNSN_LOD_deviations_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage data.frame as output of <code><a href="#topic+linkage">linkage</a></code>.</p>
</td></tr>
<tr><td><code id="SNSN_LOD_deviations_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. The ploidy level of the species.</p>
</td></tr>
<tr><td><code id="SNSN_LOD_deviations_+3A_n">N</code></td>
<td>
<p>Numeric. The number of F1 individuals in the mapping population.</p>
</td></tr>
<tr><td><code id="SNSN_LOD_deviations_+3A_plot_expected">plot_expected</code></td>
<td>
<p>Logical. Plot the observed and expected relationship between r and LOD.</p>
</td></tr>
<tr><td><code id="SNSN_LOD_deviations_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Vector of upper and lower tolerances around expected line.</p>
</td></tr>
<tr><td><code id="SNSN_LOD_deviations_+3A_phase">phase</code></td>
<td>
<p>Character string. Specify which phase to examine for deviations (usually this is &quot;coupling&quot; phase).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of deviations in LOD scores outside the range defined by tolerances input <code>alpha</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SN_SN_P1")
SNSN_LOD_deviations(SN_SN_P1,ploidy = 4, N = 198)
</code></pre>

<hr>
<h2 id='test_prefpairing'>Check for and estimate preferential pairing</h2><span id='topic+test_prefpairing'></span>

<h3>Description</h3>

<p>Identify closely-mapped repulsion-phase simplex x nulliplex markers and test these
for preferential pairing, including estimating a preferential pairing parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_prefpairing(
  dosage_matrix,
  maplist,
  LG_hom_stack,
  target_parent = "P1",
  other_parent = "P2",
  ploidy,
  min_cM = 0.5,
  adj.method = "fdr",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_prefpairing_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_maplist">maplist</code></td>
<td>
<p>A list of integrated chromosomal maps, as generated by e.g. <code><a href="#topic+MDSMap_from_list">MDSMap_from_list</a></code>. In the first column marker names and in the second their position.</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_lg_hom_stack">LG_hom_stack</code></td>
<td>
<p>A <code>data.frame</code> with markernames (<code>"SxN_Marker"</code>), linkage group (<code>"LG"</code>) and homologue (<code>"homologue"</code>),
the output of <code><a href="#topic+define_LG_structure">define_LG_structure</a></code> or <code><a href="#topic+bridgeHomologues">bridgeHomologues</a></code> usually.</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_target_parent">target_parent</code></td>
<td>
<p>Character string specifying the parent to be tested for preferential pairing as provided in the columnnames of dosage_matrix, by default &quot;P1&quot;.</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_other_parent">other_parent</code></td>
<td>
<p>The other parent, by default &quot;P2&quot;</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy level of the species, by default 4 (tetraploid) is assumed.</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_min_cm">min_cM</code></td>
<td>
<p>The smallest distance to be considered a true distance on the linkage map, by default distances less than 0.5 cM are considered essentially zero.</p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_adj.method">adj.method</code></td>
<td>
<p>Method to correct p values of Binomial test for multiple testing, by default the FDR correction is used, other options are available, inherited from <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
<tr><td><code id="test_prefpairing_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent to stdout? If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("ALL_dosages","integrated.maplist","LGHomDf_P1_1")
P1pp &lt;- test_prefpairing(ALL_dosages,integrated.maplist,LGHomDf_P1_1,ploidy=4)
</code></pre>

<hr>
<h2 id='write_nested_list'>Write out a nested list</h2><span id='topic+write_nested_list'></span>

<h3>Description</h3>

<p>Write a nested list into a directory structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_nested_list(
  nested_list,
  directory,
  save_as_object = FALSE,
  object_prefix = directory,
  extension = if (save_as_object) ".Rdata" else ".txt",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_nested_list_+3A_nested_list">nested_list</code></td>
<td>
<p>A nested list.</p>
</td></tr>
<tr><td><code id="write_nested_list_+3A_directory">directory</code></td>
<td>
<p>Character string. Directory name to which to write the structure.</p>
</td></tr>
<tr><td><code id="write_nested_list_+3A_save_as_object">save_as_object</code></td>
<td>
<p>Logical. Save as R object?</p>
</td></tr>
<tr><td><code id="write_nested_list_+3A_object_prefix">object_prefix</code></td>
<td>
<p>Character. Prefix of R object. Only used if <code>save_as_object = TRUE</code>.</p>
</td></tr>
<tr><td><code id="write_nested_list_+3A_extension">extension</code></td>
<td>
<p>Character. File extension. Default is &quot;.txt&quot;.</p>
</td></tr>
<tr><td><code id="write_nested_list_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="utils.html#topic+write.table">write.table</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("all_linkages_list_P1_subset")
write_nested_list(nested_list = all_linkages_list_P1_subset,
                  directory = "all_linkages_P1",
                  sep="\t")
## End(Not run)
</code></pre>

<hr>
<h2 id='write_pwd_list'>Write pwd files from a nested list</h2><span id='topic+write_pwd_list'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="#topic+write.pwd">write.pwd</a></code>, which allows to write multiple pwd files with a directory structure according to the nested linkage list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_pwd_list(
  linkages_list,
  target_parent,
  binned = FALSE,
  dir = getwd(),
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_pwd_list_+3A_linkages_list">linkages_list</code></td>
<td>
<p>A nested <code>list</code> with linkage group on the first level and homologue on the second.</p>
</td></tr>
<tr><td><code id="write_pwd_list_+3A_target_parent">target_parent</code></td>
<td>
<p>A  character string specifying the name of the target parent.</p>
</td></tr>
<tr><td><code id="write_pwd_list_+3A_binned">binned</code></td>
<td>
<p>Logical. Are the markers binned? This information is used in the pwd header.</p>
</td></tr>
<tr><td><code id="write_pwd_list_+3A_dir">dir</code></td>
<td>
<p>A character string specifying the directory in which the files are written. Defaults to working directory.</p>
</td></tr>
<tr><td><code id="write_pwd_list_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("all_linkages_list_P1_split")
write_pwd_list(all_linkages_list_P1_split, target_parent="P1", binned=FALSE)
## End(Not run)
</code></pre>

<hr>
<h2 id='write.mct'>Write MapChart file</h2><span id='topic+write.mct'></span>

<h3>Description</h3>

<p>Write a .mct file of a maplist for external plotting with MapChart software (Voorrips ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.mct(
  maplist,
  mapdir = "mapping_files_MDSMap",
  file_info = paste("; MapChart file created on", Sys.Date()),
  filename = "MapFile",
  precision = 2,
  showMarkerNames = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mct_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. In the first column marker names and in the second their position. All map data are
compiled into a single MapChart file.</p>
</td></tr>
<tr><td><code id="write.mct_+3A_mapdir">mapdir</code></td>
<td>
<p>Directory to which .mct files are written, by default the same directory
as for <code><a href="#topic+MDSMap_from_list">MDSMap_from_list</a></code></p>
</td></tr>
<tr><td><code id="write.mct_+3A_file_info">file_info</code></td>
<td>
<p>A character string added to the first lines of the .mct file, by default a datestamp is recorded.</p>
</td></tr>
<tr><td><code id="write.mct_+3A_filename">filename</code></td>
<td>
<p>Character string of filename to write the .mct file to, by default &quot;MapFile&quot;</p>
</td></tr>
<tr><td><code id="write.mct_+3A_precision">precision</code></td>
<td>
<p>To how many decimal places should marker positions be specified (default = 2)?</p>
</td></tr>
<tr><td><code id="write.mct_+3A_showmarkernames">showMarkerNames</code></td>
<td>
<p>Logical, by default <code>FALSE</code>, if <code>TRUE</code>, the marker names will be diplayed in the
MapChart output as well.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("integrated.maplist")
write.mct(integrated.maplist)
## End(Not run)
</code></pre>

<hr>
<h2 id='write.pwd'>Write a JoinMap compatible .pwd file from linkage data.frame.</h2><span id='topic+write.pwd'></span>

<h3>Description</h3>

<p>Output of this function allows to use JoinMap to perform the marker ordering step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pwd(linkage_df, pwd_file, file_info, log = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pwd_+3A_linkage_df">linkage_df</code></td>
<td>
<p>A linkage <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="write.pwd_+3A_pwd_file">pwd_file</code></td>
<td>
<p>A character string specifying a file open for writing.</p>
</td></tr>
<tr><td><code id="write.pwd_+3A_file_info">file_info</code></td>
<td>
<p>A character string added to the first lines of the .pwd file.</p>
</td></tr>
<tr><td><code id="write.pwd_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("all_linkages_list_P1_split")
write.pwd(all_linkages_list_P1_split[["LG3"]][["homologue1"]],
           "LG3_homologue1_P1.pwd",
           "Please feed me to JoinMap")
## End(Not run)
</code></pre>

<hr>
<h2 id='write.TSNPM'>Write TetraploidSNPMap input file</h2><span id='topic+write.TSNPM'></span>

<h3>Description</h3>

<p>Output the phased linkage map files into format readable by TetraploidSNPMap (Hackett et al. 2017) to perform QTL analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.TSNPM(
  phased.maplist,
  outputdir = "TetraploidSNPMap_QTLfiles",
  filename = "TSNPM",
  ploidy,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.TSNPM_+3A_phased.maplist">phased.maplist</code></td>
<td>
<p>Phased maps in list format, the output of <code><a href="#topic+create_phased_maplist">create_phased_maplist</a></code></p>
</td></tr>
<tr><td><code id="write.TSNPM_+3A_outputdir">outputdir</code></td>
<td>
<p>Directory to which TetraploidSNPMap files are written, by default written to &quot;TetraploidSNPMap_QTLfiles&quot; folder</p>
</td></tr>
<tr><td><code id="write.TSNPM_+3A_filename">filename</code></td>
<td>
<p>Character string of filename stem to write the output files to, by default &quot;TSNPM&quot; with linkage groups names appended</p>
</td></tr>
<tr><td><code id="write.TSNPM_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species, currently only 4 is supported by TetraploidSNPMap</p>
</td></tr>
<tr><td><code id="write.TSNPM_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be sent to stdout?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("phased.maplist")
write.TSNPM(phased.maplist,ploidy=4)
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
