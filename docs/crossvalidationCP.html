<!DOCTYPE html><html><head><title>Help for package crossvalidationCP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crossvalidationCP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crossvalidationCP-package'><p>Cross-validation for change-point regression</p></a></li>
<li><a href='#convertSingleParam'><p>Provides estimators that allows list of parameters</p></a></li>
<li><a href='#COPPS'><p>Cross-validation with Order-Preserved Sample-Splitting</p></a></li>
<li><a href='#criteria'><p>Pre-implemented cross-validation criteria</p></a></li>
<li><a href='#crossvalidationCP'><p>Cross-validation in change-point regression</p></a></li>
<li><a href='#estimators'><p>Pre-implemented estimators</p></a></li>
<li><a href='#VfoldCV'><p>V-fold cross-validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cross-Validation for Change-Point Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>changepoint (&ge; 2.0), fpopw(&ge; 1.1), wbs (&ge; 1.4), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the cross-validation methodology from Pein and Shah (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2112.03220">doi:10.48550/arXiv.2112.03220</a>&gt;. Can be customised by providing different cross-validation criteria, estimators for the change-point locations and local parameters, and freely chosen folds. Pre-implemented estimators and criteria are available. It also includes our own implementation of the COPPS procedure &lt;<a href="https://doi.org/10.1214%2F19-AOS1814">doi:10.1214/19-AOS1814</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-22 16:07:52 UTC; pein</td>
</tr>
<tr>
<td>Author:</td>
<td>Pein Florian [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pein Florian &lt;f.pein@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-22 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='crossvalidationCP-package'>Cross-validation for change-point regression</h2><span id='topic+crossvalidationCP-package'></span>

<h3>Description</h3>

<p>Implements the cross-validation methodology from <cite>Pein and Shah (2021)</cite>. The approach can be customised by providing cross-validation criteria, estimators for the change-point locations and local parameters, and freely chosen folds. Pre-implemented estimators and criteria are available. It also includes our own implementation of the <abbr><span class="acronym">COPPS</span></abbr> procedure <cite>Zou et al. (2020)</cite>. By default, 5-fold cross-validation with ordered folds, absolute error loss, and least squares estimation for estimating the change-point locations is used.
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+crossvalidationCP">crossvalidationCP</a></code>. It selects among a list of parameters the one with the smallest cross-validation criterion for a given method. The user can freely choose the folds, the local estimator and the criterion. Several pre-implemented <a href="#topic+estimators">estimators</a> and <a href="#topic+criteria">criteria</a> are available. Estimators have to allow a list of parameters at the same time. One can use <code><a href="#topic+convertSingleParam">convertSingleParam</a></code> to convert a function allowing only a single parameter to a function that allows a list of parameters.
</p>
<p>A ssimpler, but more limited access is given by the functions <code><a href="#topic+VfoldCV">VfoldCV</a></code>, <code><a href="#topic+COPPS">COPPS</a></code>, <code><a href="#topic+CV1">CV1</a></code> and <code><a href="#topic+CVmod">CVmod</a></code>. <code><a href="#topic+VfoldCV">VfoldCV</a></code> performs V-fold cross-validation, where the tuning parameter is directly the number of change-points. <code><a href="#topic+COPPS">COPPS</a></code> implements the <abbr><span class="acronym">COPPS</span></abbr> procedure <cite>Zou et al. (2020)</cite>, i.e. 2-fold cross-validation with Order-Preserved Sample-Splitting and the tuning parameter being again the number of change-points. <code><a href="#topic+CV1">CV1</a></code> and <code><a href="#topic+CVmod">CVmod</a></code> do the same, but with <a href="#topic+criterionL1loss">absolute error loss</a> and the <a href="#topic+criterionMod">modified quadratic error loss</a>, see (15) and (16) in <cite>Pein and Shah (2021)</cite>, instead of <a href="#topic+criterionL2loss">quadratic error loss</a>.
</p>
<p>Note that <code><a href="#topic+COPPS">COPPS</a></code> can be problematic when larger changes occur at odd locations. For a detailed discussion, why standard quadratic error loss can lead to misestimation, see Section 2 in <cite>Pein and Shah (2021)</cite>. By default, we recommend to use <a href="#topic+criterionL1loss">absolute error loss</a> and 5-fold cross-validation as offered by <code><a href="#topic+VfoldCV">VfoldCV</a></code>.
</p>
<p>So far only univariate data is supported, but support for multivariate data is planned.</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>
<p>Zou, C., Wang, G., and Li, R. (2020) Consistent selection of the number of change-points via sample-splitting. <em>The Annals of Statistics</em>, <b>48</b>(1), 413&ndash;439.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossvalidationCP">crossvalidationCP</a></code>, <a href="#topic+estimators">estimators</a>, <a href="#topic+criteria">criteria</a>, <code><a href="#topic+convertSingleParam">convertSingleParam</a></code>, <code><a href="#topic+VfoldCV">VfoldCV</a></code>, <code><a href="#topic+COPPS">COPPS</a></code>, <code><a href="#topic+CV1">CV1</a></code>, <code><a href="#topic+CVmod">CVmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call with default parameters:
# 5-fold cross-validation with absolute error loss, least squares estimation,
# and possible parameters being 0 to 5 change-points
Y &lt;- rnorm(100)
(ret &lt;- crossvalidationCP(Y = Y))
# a simpler, but more limited access to it is offered by VfoldCV()
identical(VfoldCV(Y = Y), ret)

# more interesting data and more detailed output
set.seed(1L)
Y &lt;- c(rnorm(50), rnorm(50, 5), rnorm(50), rnorm(50, 5))
VfoldCV(Y = Y, output = "detailed")
# finds the correct change-points at 50, 100, 150
# (plus the start and end points 0 and 200)

# reducing the maximal number of change-points to 2
VfoldCV(Y = Y, Kmax = 2)

# crossvalidationCP is more flexible and allows a list of parameters
# here only 1 or 2 change-points are allowed
crossvalidationCP(Y = Y, param = as.list(1:2))

# reducing the number of folds to 3
ret &lt;- VfoldCV(Y = Y, V = 3L, output = "detailed")
# the same but with explicitly specified folds
identical(crossvalidationCP(Y = Y, folds = list(seq(1, 200, 3), seq(2, 200, 3), seq(3, 200, 3)),
                            output = "detailed"), ret)
                            
# 2-fold cross-validation with Order-Preserved Sample-Splitting
ret &lt;- crossvalidationCP(Y = Y, folds = "COPPS", output = "detailed")

# a simpler access to it is offered by CV1()
identical(CV1(Y = Y, output = "detailed"), ret)

# different criterion: quadratic error loss
ret &lt;- crossvalidationCP(Y = Y, folds = "COPPS", output = "detailed", criterion = criterionL2loss)

# same as COPPS procedure; as offered by COPPS()
identical(COPPS(Y = Y, output = "detailed"), ret)

# COPPS potentially fails to provide a good selection when large changes occur at odd locations
# Example 1 in (Pein and Shah, 2021), see Section 2.2 in this paper for more details
set.seed(1)
exampleY &lt;- rnorm(102, c(rep(10, 46), rep(0, 5), rep(30, 51)))
# misses one change-point
crossvalidationCP(Y = exampleY, folds = "COPPS", criterion = criterionL2loss) 

# correct number of change-points when modified criterion (or absolute error loss) is used
(ret &lt;- crossvalidationCP(Y = exampleY, folds = "COPPS", criterion = criterionMod)) 

# a simpler access to it is offered by CVmod() 
identical(CVmod(Y = exampleY), ret)

# manually given criterion; identical to criterionL1loss()
testCriterion &lt;- function(testset, estset, value = NULL, ...) {
  if (!is.null(value)) {
    return(sum(abs(testset - value)))
  }
  
  sum(abs(testset - mean(estset)))
}
identical(crossvalidationCP(Y = Y, criterion = testCriterion, output = "detailed"),
          crossvalidationCP(Y = Y, output = "detailed"))

# PELT as a local estimator instead of least squares estimation
# param must contain parameters that are acceptable for the given estimator
crossvalidationCP(Y = Y, estimator = pelt, output = "detailed",
                  param = list("SIC", "MBIC", 3 * log(length(Y))))

# argument minseglen of pelt specified in ...
crossvalidationCP(Y = Y, estimator = pelt, output = "detailed",
                  param = list("SIC", "MBIC", 3 * log(length(Y))), minseglen = 60)
</code></pre>

<hr>
<h2 id='convertSingleParam'>Provides estimators that allows list of parameters</h2><span id='topic+convertSingleParam'></span>

<h3>Description</h3>

<p>Converts estimators allowing single parameters to estimators allowing a list of parameters. The resulting function can be passed to the argument <code>estimator</code> in the cross-validation functions, see <cite>See Also</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertSingleParam(estimator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertSingleParam_+3A_estimator">estimator</code></td>
<td>
<p>the function to be converted, i.e. a function providing a local estimate. The function must have the arguments <code>Y</code>, <code>param</code> and <code>...</code>, where <code>Y</code> will be the observations, and <code>param</code> a single parameter of arbitrary type. Hence <code><a href="base.html#topic+list">lists</a></code> can be used when multiple parameter of different types are needed. It has to return either a vector with the estimated change-points or a list containing the named entries <code>cps</code> and <code>value</code>. In this case <code>cps</code> has to be a numeric vector with the estimated change-points as before and <code>value</code> has to be a list of length one entry longer than <code>cps</code> giving the locally estimated values. An example is given below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that can be passed to the argument <code>estimator</code> in the cross-validation functions, see the functions listed in <cite>See Also</cite>
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossvalidationCP">crossvalidationCP</a></code>, <code><a href="#topic+VfoldCV">VfoldCV</a></code>, <code><a href="#topic+COPPS">COPPS</a></code>, <code><a href="#topic+CV1">CV1</a></code>, <code><a href="#topic+CVmod">CVmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># wrapper around pelt to demonstrate an estimator that allows a single parameter only
singleParamEstimator &lt;- function(Y, param, minseglen = 1, ...) {
  if (is.numeric(param)) {
    ret &lt;- changepoint::cpt.mean(data = Y, penalty = "Manual", pen.value = param, method = "PELT",
                                 minseglen = minseglen)
  } else {
    ret &lt;- changepoint::cpt.mean(data = Y, penalty = param, method = "PELT", minseglen = minseglen)
  }
  
  list(cps = ret@cpts[-length(ret@cpts)], value = as.list(ret@param.est$mean))
}
# conversion to an estimator that is suitable for crossvalidationCP() etc.
estimatorMultiParam &lt;- convertSingleParam(singleParamEstimator)
crossvalidationCP(rnorm(100), estimator = estimatorMultiParam, param = list("SIC", "MBIC"))
</code></pre>

<hr>
<h2 id='COPPS'>Cross-validation with Order-Preserved Sample-Splitting</h2><span id='topic+COPPS'></span><span id='topic+CV1'></span><span id='topic+CVmod'></span>

<h3>Description</h3>

<p>Tuning parameters are selected by a generalised <abbr><span class="acronym">COPPS</span></abbr> procedure. All functions use Order-Preserved Sample-Splitting, meaning that the folds will be the odd and even indexed observations. The three functions differ in which cross-validation criterion they are using. <code>COPPS</code> is the original <abbr><span class="acronym">COPPS</span></abbr> procedure <cite>Zou et al. (2020)</cite>, i.e. uses <a href="#topic+criterionL2loss">quadratic error loss</a>. <code>CV1</code> and <code>CVmod</code> use <a href="#topic+criterionL1loss">absolute error loss</a> and the <a href="#topic+criterionMod">modified quadratic error loss</a>, respectively.</p>


<h3>Usage</h3>

<pre><code class='language-R'>COPPS(Y, param = 5L, estimator = leastSquares,
      output = c("param", "fit", "detailed"), ...)
CV1(Y, param = 5L, estimator = leastSquares,
    output = c("param", "fit", "detailed"), ...)
CVmod(Y, param = 5L, estimator = leastSquares,
      output = c("param", "fit", "detailed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COPPS_+3A_y">Y</code></td>
<td>
<p>the observations, can be any data type that supports the function <code><a href="base.html#topic+length">length</a></code> and the operator <code><a href="Matrix.html#topic++5B">[]</a></code> and can be passed to <code>estimator</code> and the <code><a href="#topic+criteria">cross-validation criterion</a></code>, e.g. a numeric vector or a list. Support for <code><a href="base.html#topic+matrix">matrices</a></code>, i.e. for multivariate data, is planned but not implemented so far</p>
</td></tr>
<tr><td><code id="COPPS_+3A_param">param</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> giving the possible tuning parameters. Alternatively, a single integer which will be interpreted as the maximal number of change-points and converted to <code>as.list(0:param)</code></p>
</td></tr>
<tr><td><code id="COPPS_+3A_estimator">estimator</code></td>
<td>
<p>a function providing a local estimate. For pre-implemented estimators see <a href="#topic+estimators">estimators</a>. The function must have the arguments <code>Y</code>, <code>param</code> and <code>...</code>, where <code>Y</code> will be a subset of the observations, and <code>param</code> and <code>...</code> will be the corresponding arguments of the called function. Note that <code>...</code> will be passed to <code>estimator</code> and the <code><a href="#topic+criterion">cross-validation criterion</a></code>. The return value must be either a list of length <code>length(param)</code> with each entry containing the estimated change-point locations for the given entry in <code>param</code> or a list containing the named entries <code>cps</code> and <code>value</code>. In this case <code>cps</code> has to be a list of the estimated change-points as before and <code>value</code> has to be a list of the locally estimated values for each entry in <code>param</code>, i.e. each list entry has to be a list itself of length one entry longer than the corresponding entry in <code>cps</code>. The function <code><a href="#topic+convertSingleParam">convertSingleParam</a></code> offers the conversion of an estimator allowing a single parameter into an estimator allowing multiple parameters</p>
</td></tr>
<tr><td><code id="COPPS_+3A_output">output</code></td>
<td>
<p>a string specifying the output, either <code>"param"</code>, <code>"fit"</code> or <code>"detailed"</code>. For details what they mean see <cite>Value</cite></p>
</td></tr>
<tr><td><code id="COPPS_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed to <code>estimator</code> and the <code><a href="#topic+criterion">cross-validation criterion</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>output == "param"</code>, the selected tuning parameter, i.e. an entry from <code>param</code>. If <code>output == "fit"</code>, a list with the entries <code>param</code>, giving the selected tuning parameter, and <code>fit</code>. The named entry <code>fit</code> is a list giving the returned fit obtained by applying <code>estimator</code> to the whole data <code>Y</code> with the selected tuning parameter. The returned value is transformed to a list with an entry <code>cps</code> giving the estimated change-points and, if provided by <code>estimator</code>, an entry <code>value</code> giving the estimated local values. If <code>output == "detailed"</code>, the same as for <code>output == "fit"</code>, but additionally the entries <code>CP</code>, <code>CVodd</code>,  and <code>CVeven</code> giving the calculated cross-validation criteria for all <code>parameter</code> entries. <code>CVodd</code> and <code>CVeven</code> are the criteria when the odd / even observations are in the test set, respectively. <code>CP</code> is the sum of those two.
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>
<p>Zou, C., Wang, G., and Li, R. (2020) Consistent selection of the number of change-points via sample-splitting. <em>The Annals of Statistics</em>, <b>48</b>(1), 413&ndash;439.
</p>


<h3>See Also</h3>

<p><a href="#topic+estimators">estimators</a>, <a href="#topic+criteria">criteria</a>, <code><a href="#topic+convertSingleParam">convertSingleParam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call with default parameters:
# 2-folds cross-validation with ordereded folds, absolute error loss,
# least squares estimation, and possible parameters being 0 to 5 change-points
CV1(Y = rnorm(100))
# the same, but with modified error loss
CVmod(Y = rnorm(100))
# the same, but with quadratic error loss, indentical to COPPS procedure
COPPS(Y = rnorm(100))

# more interesting data and more detailed output
set.seed(1L)
Y &lt;- c(rnorm(50), rnorm(50, 5), rnorm(50), rnorm(50, 5))
CV1(Y = Y, output = "detailed")
# finds the correct change-points at 50, 100, 150
# (plus the start and end points 0 and 200)

# list of parameters, only allowing 1 or 2 change-points
CVmod(Y = Y, param = as.list(1:2))

# COPPS potentially fails to provide a good selection when large changes occur at odd locations
# Example 1 in (Pein and Shah, 2021), see Section 2.2 in this paper for more details
set.seed(1)
exampleY &lt;- rnorm(102, c(rep(10, 46), rep(0, 5), rep(30, 51)))
# misses one change-point
COPPS(Y = exampleY) 

# correct number of change-points when modified criterion (or absolute error loss) is used
CVmod(Y = exampleY)

# PELT as a local estimator instead of least squares estimation
# param must contain parameters that are acceptable for the given estimator
CV1(Y = Y, estimator = pelt, output = "detailed", param = list("SIC", "MBIC", 3 * log(length(Y))))

# argument minseglen of pelt specified in ...
CVmod(Y = Y, estimator = pelt, output = "detailed", param = list("SIC", "MBIC", 3 * log(length(Y))),
                  minseglen = 30)
</code></pre>

<hr>
<h2 id='criteria'>Pre-implemented cross-validation criteria</h2><span id='topic+criteria'></span><span id='topic+criterion'></span><span id='topic+criterionL2loss'></span><span id='topic+criterionL1loss'></span><span id='topic+criterionMod'></span>

<h3>Description</h3>

<p><code>criterionL1loss</code>, <code>criterionMod</code> and <code>criterionL2loss</code> compute the cross-validation criterion with L1-loss, the modified criterion and the criterion with L2-loss for univariate data, see (15), (16), and (6) in <cite>Pein and Shah (2021)</cite>, respectively. If <code>value</code> is given (i.e. <code>value =! NULL</code>), then <code>value</code> replaces the empirical means. All criteria can be passed to the argument <code>criterion</code> in the cross-validation functions, see the functions listed in <cite>See Also</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterionL1loss(testset, estset, value = NULL, ...)
criterionMod(testset, estset, value = NULL, ...)
criterionL2loss(testset, estset, value = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criteria_+3A_testset">testset</code></td>
<td>
<p>a numeric vector giving the observations in the test set / fold. For <code>criterionMod</code>, if <code>length(testset) == 1L</code>, <code>NaN</code> will be returned, see <cite>Details</cite></p>
</td></tr>
<tr><td><code id="criteria_+3A_estset">estset</code></td>
<td>
<p>a numeric vector giving the observations in the estimation set</p>
</td></tr>
<tr><td><code id="criteria_+3A_value">value</code></td>
<td>
<p>a single numeric giving the local value on the segment or <code>NULL</code>. If <code>NULL</code> the value will be <code>mean(estset)</code></p>
</td></tr>
<tr><td><code id="criteria_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>criterionMod</code> requires that the minimal segment length is at least <code>2</code>. So far the only pre-implemented estimators that allows for such an option are <code><a href="#topic+pelt">pelt</a></code> and <code><a href="#topic+binseg">binseg</a></code>, where one can specify <code>minseglen</code> in <code>...</code>.
</p>


<h3>Value</h3>

<p>a single numeric</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossvalidationCP">crossvalidationCP</a></code>, <code><a href="#topic+VfoldCV">VfoldCV</a></code>, <code><a href="#topic+COPPS">COPPS</a></code>, <code><a href="#topic+CV1">CV1</a></code>, <code><a href="#topic+CVmod">CVmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all functions can be called directly, e.g.
Y &lt;- rnorm(100)
criterionL1loss(testset = Y[seq(1, 100, 2)], estset = Y[seq(2, 100, 2)])

# but their main purpose is to serve as the criterion in the cross-validation functions, e.g.
crossvalidationCP(rnorm(100), criterion = criterionL1loss)
</code></pre>

<hr>
<h2 id='crossvalidationCP'>Cross-validation in change-point regression</h2><span id='topic+crossvalidationCP'></span>

<h3>Description</h3>

<p>Generic function for cross-validation to select tuning parameters in change-point regression. It selects among a list of parameters the one with the smallest cross-validation criterion for a given method. The cross-validation criterion, the estimator, and the the folds can be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossvalidationCP(Y, param = 5L, folds = 5L, estimator = leastSquares,
                  criterion = criterionL1loss,
                  output = c("param", "fit", "detailed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossvalidationCP_+3A_y">Y</code></td>
<td>
<p>the observations, can be any data type that supports the function <code><a href="base.html#topic+length">length</a></code> and the operator <code><a href="Matrix.html#topic++5B">[]</a></code> and can be passed to <code>estimator</code> and <code>criterion</code>, e.g. a numeric vector or a list. Support for <code><a href="base.html#topic+matrix">matrices</a></code>, i.e. for multivariate data, is planned but not implemented so far</p>
</td></tr>
<tr><td><code id="crossvalidationCP_+3A_param">param</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> giving the possible tuning parameters. Alternatively, a single integer which will be interpreted as the maximal number of change-points and converted to <code>as.list(0:param)</code>. All values have to be acceptable values for the specified <code>estimator</code></p>
</td></tr>
<tr><td><code id="crossvalidationCP_+3A_folds">folds</code></td>
<td>
<p>either a <code><a href="base.html#topic+list">list</a></code>, a single integer or the string <code>"COPPS"</code> specifying the folds. If a <code><a href="base.html#topic+list">list</a></code>, each entry should be an integer vector with values between <code>1</code> and <code>length(Y)</code> giving the indices of the observations in the fold. A single integer specifies the number of folds and ordered folds are automatically created, i.e. fold <code>i</code> will be <code>seq(i, length(Y), folds)</code>. <code>"COPPS"</code> means that a generalised <abbr><span class="acronym">COPPS</span></abbr> procedure <cite>Zou et al. (2020)</cite> will be used, i.e. 2-fold cross-validation with Order-Preserved Sample-Splitting, meaning that the folds will be the odd and even indexed observations. Note that observations will be given in reverse order to the cross-validation criterion when the odd-indexed observations are in the test set. This allows criteria such as the <a href="#topic+criterionMod">modified criterion</a>, where for the odd-indexed the first and for the even-indexed the last observation is removed</p>
</td></tr>
<tr><td><code id="crossvalidationCP_+3A_estimator">estimator</code></td>
<td>
<p>a function providing a local estimate. For pre-implemented estimators see <a href="#topic+estimators">estimators</a>. The function must have the arguments <code>Y</code>, <code>param</code> and <code>...</code>, where <code>Y</code> will be a subset of the observations, and <code>param</code> and <code>...</code> will be the corresponding arguments of the called function. Note that <code>...</code> will be passed to <code>estimator</code> and <code>criterion</code>. The return value must be either a list of length <code>length(param)</code> with each entry containing the estimated change-point locations for the given entry in <code>param</code> or a list containing the named entries <code>cps</code> and <code>value</code>. In this case <code>cps</code> has to be a list of the estimated change-points as before and <code>value</code> has to be a list of the locally estimated values for each entry in <code>param</code>, i.e. each list entry has to be a list itself of length one entry longer than the corresponding entry in <code>cps</code>. The function <code><a href="#topic+convertSingleParam">convertSingleParam</a></code> offers the conversion of an estimator allowing a single parameter into an estimator allowing multiple parameters</p>
</td></tr>
<tr><td><code id="crossvalidationCP_+3A_criterion">criterion</code></td>
<td>
<p>a function providing the cross-validation criterion. For pre-implemented criteria see <a href="#topic+criteria">criteria</a>. The function must have the arguments <code>testset</code>, <code>estset</code> and <code>value</code>. <code>testset</code> and <code>estset</code> are the observations of one segment that are in the test and estimation set, respectively. <code>value</code> is the local parameter on the segment if provided by <code>estimator</code>, otherwise <code>NULL</code>. Additionally, <code>...</code> is possible and potentially necessary to absorb arguments, since the argument <code>...</code> of <code>crossvalidationCP</code> will be passed to <code>estimator</code> and <code>criterion</code>. It must return a single numeric. All return values will be summed accordingly and <code><a href="base.html#topic+which.min">which.min</a></code> will be called on the vector to determine the parameter with the smallest criterion, hence some <code>NaN</code> values etc. are allowed</p>
</td></tr>
<tr><td><code id="crossvalidationCP_+3A_output">output</code></td>
<td>
<p>a string specifying the output, either <code>"param"</code>, <code>"fit"</code> or <code>"detailed"</code>. For details what they mean see <cite>Value</cite></p>
</td></tr>
<tr><td><code id="crossvalidationCP_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed to <code>estimator</code> and <code>criterion</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>output == "param"</code>, the selected tuning parameter, i.e. an entry from <code>param</code>. If <code>output == "fit"</code>, a list with the entries <code>param</code>, giving the selected tuning parameter, and <code>fit</code>. The named entry <code>fit</code> is a list giving the returned fit obtained by applying <code>estimator</code> to the whole data <code>Y</code> with the selected tuning parameter. The retured value is transformed to a list with an entry <code>cps</code> giving the estimated change-points and, if provided by <code>estimator</code>, an entry <code>value</code> giving the estimated local values. If <code>output == "detailed"</code>, the same as for <code>output == "fit"</code>, but additionally an entry <code>CP</code> giving all calculated cross-validation criteria. Those values are summed over all folds
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>
<p>Zou, C., Wang, G., and Li, R. (2020) Consistent selection of the number of change-points via sample-splitting. <em>The Annals of Statistics</em>, <b>48</b>(1), 413&ndash;439.
</p>


<h3>See Also</h3>

<p><a href="#topic+estimators">estimators</a>, <a href="#topic+criteria">criteria</a>, <code><a href="#topic+convertSingleParam">convertSingleParam</a></code>, <code><a href="#topic+VfoldCV">VfoldCV</a></code>, <code><a href="#topic+COPPS">COPPS</a></code>, <code><a href="#topic+CV1">CV1</a></code>, <code><a href="#topic+CVmod">CVmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call with default parameters:
# 5-fold cross-validation with absolute error loss, least squares estimation,
# and possible parameters being 0 to 5 change-points
# a simpler access to it is offered by VfoldCV()
crossvalidationCP(Y = rnorm(100))

# more interesting data and more detailed output
set.seed(1L)
Y &lt;- c(rnorm(50), rnorm(50, 5), rnorm(50), rnorm(50, 5))
crossvalidationCP(Y = Y, output = "detailed")
# finds the correct change-points at 50, 100, 150
# (plus the start and end points 0 and 200)

# list of parameters, only allowing 1 or 2 change-points
crossvalidationCP(Y = Y, param = as.list(1:2))

# reducing the number of folds to 3
ret &lt;- crossvalidationCP(Y = Y, folds = 3L, output = "detailed")
# the same but with explicitly specified folds
identical(crossvalidationCP(Y = Y, folds = list(seq(1, 200, 3), seq(2, 200, 3), seq(3, 200, 3)),
                            output = "detailed"), ret)
                            
# 2-fold cross-validation with Order-Preserved Sample-Splitting
ret &lt;- crossvalidationCP(Y = Y, folds = "COPPS", output = "detailed")

# a simpler access to it is offered by CV1()
identical(CV1(Y = Y, output = "detailed"), ret)

# different criterion: quadratic error loss
ret &lt;- crossvalidationCP(Y = Y, folds = "COPPS", output = "detailed", criterion = criterionL2loss)

# same as COPPS procedure; as offered by COPPS()
identical(COPPS(Y = Y, output = "detailed"), ret)

# COPPS potentially fails to provide a good selection when large changes occur at odd locations
# Example 1 in (Pein and Shah, 2021), see Section 2.2 in this paper for more details
set.seed(1)
exampleY &lt;- rnorm(102, c(rep(10, 46), rep(0, 5), rep(30, 51)))
# misses one change-point
crossvalidationCP(Y = exampleY, folds = "COPPS", criterion = criterionL2loss) 

# correct number of change-points when modified criterion (or absolute error loss) is used
(ret &lt;- crossvalidationCP(Y = exampleY, folds = "COPPS", criterion = criterionMod)) 

# a simpler access to it is offered by CVmod() 
identical(CVmod(Y = exampleY), ret)

# manually given criterion; identical to criterionL1loss()
testCriterion &lt;- function(testset, estset, value = NULL, ...) {
  if (!is.null(value)) {
    return(sum(abs(testset - value)))
  }
  
  sum(abs(testset - mean(estset)))
}
identical(crossvalidationCP(Y = Y, criterion = testCriterion, output = "detailed"),
          crossvalidationCP(Y = Y, output = "detailed"))
          
# PELT as a local estimator instead of least squares estimation
# param must contain parameters that are acceptable for the given estimator
crossvalidationCP(Y = Y, estimator = pelt, output = "detailed",
                  param = list("SIC", "MBIC", 3 * log(length(Y))))

# argument minseglen of pelt specified in ...
crossvalidationCP(Y = Y, estimator = pelt, output = "detailed",
                  param = list("SIC", "MBIC", 3 * log(length(Y))), minseglen = 60)
</code></pre>

<hr>
<h2 id='estimators'>Pre-implemented estimators</h2><span id='topic+estimators'></span><span id='topic+leastSquares'></span><span id='topic+optimalPartitioning'></span><span id='topic+pelt'></span><span id='topic+binseg'></span><span id='topic+wbs'></span>

<h3>Description</h3>

<p>Pre-implemented change-point estimators that can be passed to the argument <code>estimator</code> in the cross-validation functions, see the functions listed in <cite>See Also</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leastSquares(Y, param, ...)
pelt(Y, param, ...)
binseg(Y, param, ...)
wbs(Y, param, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimators_+3A_y">Y</code></td>
<td>
<p>a numeric vector giving the observations</p>
</td></tr>
<tr><td><code id="estimators_+3A_param">param</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> giving the possible tuning parameters. See <cite>Details</cite> to see which tuning parameters are allowed for which function</p>
</td></tr>
<tr><td><code id="estimators_+3A_...">...</code></td>
<td>
<p>additional arguments, see <cite>Details</cite> to see which arguments are allowed for which function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>leastSquares</code> implements least squares estimation by using the segment neighbourhoods algorithm with functional pruning from <cite>Rigaill (20015)</cite>, see also <cite>Auger and Lawrence (1989)</cite> for the original segment neighbourhoods algorithm. It calls <code><a href="fpopw.html#topic+Fpsn">Fpsn</a></code>. Each list entry in <code>param</code> has to be a single integer giving the number of change-points.
</p>
<p><code>optimalPartitioning</code> is outdated. It will give the same results as <code>leastSquares</code>, but is slower. It is part of the package for backwards compatibility only.
</p>
<p><code>pelt</code> implements <abbr><span class="acronym">PELT</span></abbr> <cite>(Killick et al., 2012)</cite>, i.e. penalised maximum likelihood estimation computed by a pruned dynamic program. For each list entry in <code>param</code> it calls <code><a href="changepoint.html#topic+cpt.mean">cpt.mean</a></code> with <code>method = "PELT"</code> and <code>penalty = param[[i]]</code> or when <code>param[[i]]</code> is a numeric with <code>penalty = "Manual"</code> and <code>pen.value = param[[i]]</code>. Hence, each entry in <code>param</code> must be a single numeric or an argument that can be passed to <code>penalty</code>. Additionally <code>minseglen</code> can be specified in <code>...</code>, by default <code>minseglen = 1</code>.
</p>
<p><code>binseg</code> implements binary segmentation <cite>(Vostrikova, 1981)</cite>. The call is the same as for <code>pelt</code>, but with <code>method = "BinSeg"</code>. Additionally, the maximal number of change-points <code>Q</code> can be specified in <code>...</code>, by default <code>Q = 5</code>. Alternatively, each list entry of <code>param</code> can be a list itself containing the named entries <code>penalty</code> and <code>Q</code>. Note that this estimator differs from binary segmentation in <cite>Zou et al. (2020)</cite>, it requires a penalty instead of a given number of change-points. Warnings that <code>Q</code> is chosen too small are suppressed when <code>Q</code> is given in <code>param</code>, but not when it is a global parameter specified in <code>...</code> or <code>Q = 5</code> by default.
</p>
<p><code>wbs</code> implements wild binary segmentation <cite>(Fryzlewicz, 2014)</cite>. It calls <code><a href="wbs.html#topic+changepoints">changepoints</a></code> with <code>th.const = param</code>, hence <code>param</code> has to be a list of positive scalars. Additionally, <code>...</code> will be passed.
</p>


<h3>Value</h3>

<p>For <code>leastSquares</code> and <code>wbs</code> a list of length <code>length(param)</code> with each entry containing the estimated change-point locations for the given entry in <code>param</code>. For the other functions a list containing the named entries <code>cps</code> and <code>value</code>, with <code>cps</code> a list of the estimated change-points as before and <code>value</code> a list of the locally estimated values for each entry in <code>param</code>, i.e. each list entry is a list itself of length one entry longer than the corresponding entry in <code>cps</code>.
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>
<p>Rigaill, G. (2015) A pruned dynamic programming algorithm to recover the best segmentations with 1 to Kmax change-points. <em>Journal de la Societe Francaise de Statistique</em> <b>156</b>(4), 180&ndash;205.
</p>
<p>Auger, I. E., Lawrence, C. E. (1989) Algorithms for the Optimal Identification of Segment Neighborhoods. <em>Bulletin of Mathematical Biology</em>, <b>51</b>(1), 39&ndash;54.
</p>
<p>Killick, R., Fearnhead, P., Eckley, I. A. (2012) Optimal detection of changepoints with a linear computational cost. <em>Journal of the American Statistical Association</em>, <b>107</b>(500), 1590&ndash;1598.
</p>
<p>Vostrikova, L. Y. (1981). Detecting 'disorder' in multidimensional random processes. <em>Soviet Mathematics Doklady</em>,
<b>24</b>, 55&ndash;59.
</p>
<p>Fryzlewicz, P. (2014) Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, <b>42</b>(6), 2243&ndash;2281.
</p>
<p>Zou, C., Wang, G., and Li, R. (2020). Consistent selection of the number of change-points via sample-splitting. <em>The Annals of Statistics</em>, <b>48</b>(1), 413&ndash;439.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossvalidationCP">crossvalidationCP</a></code>, <code><a href="#topic+VfoldCV">VfoldCV</a></code>, <code><a href="#topic+COPPS">COPPS</a></code>, <code><a href="#topic+CV1">CV1</a></code>, <code><a href="#topic+CVmod">CVmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all functions can be called directly, e.g.
leastSquares(Y = rnorm(100), param = 2)

# but their main purpose is to serve as a local estimator in the cross-validation functions, e.g.
crossvalidationCP(rnorm(100), estimator = leastSquares)

# param must contain values that are suitable for the given estimator
crossvalidationCP(rnorm(100), estimator = pelt, param = list("SIC", "MBIC"))
</code></pre>

<hr>
<h2 id='VfoldCV'>V-fold cross-validation</h2><span id='topic+VfoldCV'></span>

<h3>Description</h3>

<p>Selects the number of change-points by minimizing a V-fold cross-validation criterion. The criterion, the estimator, and the number of folds can be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VfoldCV(Y, V = 5L, Kmax = 8L, adaptiveKmax = TRUE, tolKmax = 3L, estimator = leastSquares,
        criterion = criterionL1loss, output = c("param", "fit", "detailed"), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VfoldCV_+3A_y">Y</code></td>
<td>
<p>the observations, can be any data type that supports the function <code><a href="base.html#topic+length">length</a></code> and the operator <code><a href="Matrix.html#topic++5B">[]</a></code> and can be passed to <code>estimator</code> and <code>criterion</code>, e.g. a numeric vector or a list. Support for <code><a href="base.html#topic+matrix">matrices</a></code>, i.e. for multivariate data, is planned but not implemented so far</p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_v">V</code></td>
<td>
<p>a single integer giving the number of folds. Ordered folds will automatically be created, i.e. fold <code>i</code> will be <code>seq(i, length(Y), folds)</code></p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_kmax">Kmax</code></td>
<td>
<p>a single integer giving maximal number of change-points</p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_adaptivekmax">adaptiveKmax</code></td>
<td>
<p>a single logical indicating whether <code>Kmax</code> should be chosen adaptively. If true <code>Kmax</code> will be double if the estimated number of change-points is not at least <code>Kmax - tolKmax</code></p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_tolkmax">tolKmax</code></td>
<td>
<p>a single integer specifiying how much the estimated number of change-points have to be smaller than <code>Kmax</code></p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_estimator">estimator</code></td>
<td>
<p>a function providing a local estimate. For pre-implemented estimators see <a href="#topic+estimators">estimators</a>. The function must have the arguments <code>Y</code>, <code>param</code> and <code>...</code>, where <code>Y</code> will be a subset of the observations, <code>param</code> will be <code>list(0:Kmax)</code>, and <code>...</code> will be the argument <code>...</code> of <code>VfoldCV</code>. Note that <code>...</code> will be passed to <code>estimator</code> and <code>criterion</code>. The return value must be either a list of length <code>length(param)</code> with each entry containing the estimated change-point locations for the given entry in <code>param</code> or a list containing the named entries <code>cps</code> and <code>value</code>. In this case <code>cps</code> has to be a list of the estimated change-points as before and <code>value</code> has to be a list of the locally estimated values for each entry in <code>param</code>, i.e. each list entry has to be a list itself of length one entry longer than the corresponding entry in <code>cps</code>. The function <code><a href="#topic+convertSingleParam">convertSingleParam</a></code> offers the conversion of an estimator allowing a single parameter into an estimator allowing multiple parameters. From the currently pre-implemented estimators only <code><a href="#topic+leastSquares">leastSquares</a></code> accepts <code>param == list(0:Kmax)</code>. Estimators that allow <code>param</code> to differ from <code>list(0:Kmax)</code> can be used in <code><a href="#topic+crossvalidationCP">crossvalidationCP</a></code></p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_criterion">criterion</code></td>
<td>
<p>a function providing the cross-validation criterion. For pre-implemented criteria see <a href="#topic+criteria">criteria</a>. The function must have the arguments <code>testset</code>, <code>estset</code> and <code>value</code>. <code>testset</code> and <code>estset</code> are the observations of one segment that are in the test and estimation set, respectively. <code>value</code> is the local parameter on the segment if provided by <code>estimator</code>, otherwise <code>NULL</code>. Additionally, <code>...</code> is possible and potentially necessary to absorb arguments, since the argument <code>...</code> of <code>VfoldCV</code> will be passed to <code>estimator</code> and <code>criterion</code>. It must return a single numeric. All return values will be summed accordingly and <code><a href="base.html#topic+which.min">which.min</a></code> will be called on the vector to determine the parameter with the smallest criterion. Hence some <code>NaN</code> values etc. are allowed</p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_output">output</code></td>
<td>
<p>a string specifying the output, either <code>"param"</code>, <code>"fit"</code> or <code>"detailed"</code>. For details what they mean see <cite>Value</cite></p>
</td></tr>
<tr><td><code id="VfoldCV_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed to <code>estimator</code> and <code>criterion</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>output == "param"</code>, the selected number of change-points, i.e. an integer between <code>0</code> and <code>Kmax</code>. If <code>output == "fit"</code>, a list with the entries <code>param</code>, giving the selected number of change-points, and <code>fit</code>. The named entry <code>fit</code> is a list giving the returned fit obtained by applying <code>estimator</code> to the whole data <code>Y</code> with the selected tuning parameter. The returned value is transformed to a list with an entry <code>cps</code> giving the estimated change-points and, if provided by <code>estimator</code>, an entry <code>value</code> giving the estimated local values. If <code>output == "detailed"</code>, the same as for <code>output == "fit"</code>, but additionally an entry <code>CP</code> giving all calculated cross-validation criteria. Those values are summed over all folds
</p>


<h3>References</h3>

<p>Pein, F., and Shah, R. D. (2021) Cross-validation for change-point regression: pitfalls and solutions. <em>arXiv:2112.03220</em>.
</p>


<h3>See Also</h3>

<p><a href="#topic+estimators">estimators</a>, <a href="#topic+criteria">criteria</a>, <code><a href="#topic+convertSingleParam">convertSingleParam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call with default parameters:
# 5-fold cross-validation with absolute error loss, least squares estimation,
# and 0 to 5 change-points
VfoldCV(Y = rnorm(100))

# more interesting data and more detailed output
set.seed(1L)
Y &lt;- c(rnorm(50), rnorm(50, 5), rnorm(50), rnorm(50, 5))
VfoldCV(Y = Y, output = "detailed")
# finds the correct change-points at 50, 100, 150
# (plus the start and end points 0 and 200)

# reducing the number of folds to 3
VfoldCV(Y = Y, V = 3L, output = "detailed")

# reducing the maximal number of change-points to 2
VfoldCV(Y = Y, Kmax = 2)

# different criterion: modified error loss
VfoldCV(Y = Y, output = "detailed", criterion = criterionMod)

# manually given criterion; identical to criterionL1loss()
testCriterion &lt;- function(testset, estset, value = NULL, ...) {
  if (!is.null(value)) {
    return(sum(abs(testset - value)))
  }
  
  sum(abs(testset - mean(estset)))
}
identical(VfoldCV(Y = Y, criterion = testCriterion, output = "detailed"),
          VfoldCV(Y = Y, output = "detailed"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
