<!DOCTYPE html><html><head><title>Help for package alkahest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {alkahest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alkahest-package'><p>alkahest: Pre-Processing XY Data from Experimental Methods</p></a></li>
<li><a href='#baseline_linear'><p>Linear Baseline Estimation</p></a></li>
<li><a href='#baseline_peakfilling'><p>4S Peak Filling</p></a></li>
<li><a href='#baseline_polynomial'><p>Polynomial Baseline Estimation</p></a></li>
<li><a href='#baseline_rollingball'><p>Rolling Ball Baseline Estimation</p></a></li>
<li><a href='#baseline_rubberband'><p>Rubberband Baseline Estimation</p></a></li>
<li><a href='#baseline_snip'><p>SNIP Baseline Estimation</p></a></li>
<li><a href='#BEGe'><p>Gamma-Ray Spectrometry</p></a></li>
<li><a href='#integrate_rectangle'><p>Rectangle Rule</p></a></li>
<li><a href='#integrate_trapezoid'><p>Trapezoidal Rule</p></a></li>
<li><a href='#ka2_strip_penalized'><p>Strip XRD ka2</p></a></li>
<li><a href='#LaBr'><p>Gamma-Ray Spectrometry</p></a></li>
<li><a href='#peaks_find'><p>Find Peaks</p></a></li>
<li><a href='#peaks_fwhm'><p>Half-Width at Half-Maximum</p></a></li>
<li><a href='#replace_negative'><p>Replace Negative Values</p></a></li>
<li><a href='#replace_threshold'><p>Replace Values Below a Given Threshold</p></a></li>
<li><a href='#resample_bin'><p>Bin</p></a></li>
<li><a href='#resample_down'><p>Downsample</p></a></li>
<li><a href='#resample_interpolate'><p>Linearly Interpolate</p></a></li>
<li><a href='#rescale_area'><p>Normalize intensities by AUC</p></a></li>
<li><a href='#rescale_range'><p>Rescales intensities to have specified minimum and maximum</p></a></li>
<li><a href='#rescale_total'><p>Rescale intensities to sum to a specified value</p></a></li>
<li><a href='#rescale_transform'><p>Transform Intensities</p></a></li>
<li><a href='#signal_bind'><p>Bind</p></a></li>
<li><a href='#signal_correct'><p>Baseline Correction</p></a></li>
<li><a href='#signal_drift'><p>Drift Intensities</p></a></li>
<li><a href='#signal_mean'><p>Mean Intensities</p></a></li>
<li><a href='#signal_shift'><p>Shift the X Scale</p></a></li>
<li><a href='#smooth_likelihood'><p>Penalized Likelihood Smoothing</p></a></li>
<li><a href='#smooth_loess'><p>Loess Smoothing</p></a></li>
<li><a href='#smooth_rectangular'><p>Rectangular Smoothing</p></a></li>
<li><a href='#smooth_savitzky'><p>Savitzky-Golay Filter</p></a></li>
<li><a href='#smooth_triangular'><p>Triangular Smoothing</p></a></li>
<li><a href='#smooth_whittaker'><p>Whittaker Smoothing</p></a></li>
<li><a href='#subset'><p>Subset</p></a></li>
<li><a href='#window_sliding'><p>Sliding Windows</p></a></li>
<li><a href='#window_tumbling'><p>Tumbling Windows</p></a></li>
<li><a href='#XRD'><p>Powder X-ray Diffraction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Pre-Processing XY Data from Experimental Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Frerebeau &lt;nicolas.frerebeau@u-bordeaux-montaigne.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A lightweight, dependency-free toolbox for pre-processing XY
    data from experimental methods (i.e. any signal that can be measured
    along a continuous variable). This package provides methods for
    baseline estimation and correction, smoothing, normalization,
    integration and peaks detection. Baseline correction methods includes
    polynomial fitting as described in Lieber and Mahadevan-Jansen (2003)
    &lt;<a href="https://doi.org/10.1366%2F000370203322554518">doi:10.1366/000370203322554518</a>&gt;, Rolling Ball algorithm after Kneen
    and Annegarn (1996) &lt;<a href="https://doi.org/10.1016%2F0168-583X%2895%2900908-6">doi:10.1016/0168-583X(95)00908-6</a>&gt;, SNIP algorithm
    after Ryan et al. (1988) &lt;<a href="https://doi.org/10.1016%2F0168-583X%2888%2990063-8">doi:10.1016/0168-583X(88)90063-8</a>&gt;, 4S Peak
    Filling after Liland (2015) &lt;<a href="https://doi.org/10.1016%2Fj.mex.2015.02.009">doi:10.1016/j.mex.2015.02.009</a>&gt; and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://packages.tesselle.org/alkahest/">https://packages.tesselle.org/alkahest/</a>,
<a href="https://github.com/tesselle/alkahest">https://github.com/tesselle/alkahest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tesselle/alkahest/issues">https://github.com/tesselle/alkahest/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, Matrix, rmarkdown, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AllGenerics.R' 'alkahest-internal.R' 'alkahest-package.R'
'baseline.R' 'data.R' 'integrate.R' 'peaks.R' 'replace.R'
'resample.R' 'rescale.R' 'signal.R' 'smooth.R' 'windows.R'
'xrd.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-13 07:35:59 UTC; nicolas</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Frerebeau <a href="https://orcid.org/0000-0001-5759-4944"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (Université Bordeaux Montaigne),
  Brice Lebrun <a href="https://orcid.org/0000-0001-7503-8685"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-13 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alkahest-package'>alkahest: Pre-Processing XY Data from Experimental Methods</h2><span id='topic+alkahest-package'></span><span id='topic+_PACKAGE'></span><span id='topic+alkahest'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A lightweight, dependency-free toolbox for pre-processing XY data from experimental methods (i.e. any signal that can be measured along a continuous variable). This package provides methods for baseline estimation and correction, smoothing, normalization, integration and peaks detection. Baseline correction methods includes polynomial fitting as described in Lieber and Mahadevan-Jansen (2003) <a href="https://doi.org/10.1366/000370203322554518">doi:10.1366/000370203322554518</a>, Rolling Ball algorithm after Kneen and Annegarn (1996) <a href="https://doi.org/10.1016/0168-583X%2895%2900908-6">doi:10.1016/0168-583X(95)00908-6</a>, SNIP algorithm after Ryan et al. (1988) <a href="https://doi.org/10.1016/0168-583X%2888%2990063-8">doi:10.1016/0168-583X(88)90063-8</a>, 4S Peak Filling after Liland (2015) <a href="https://doi.org/10.1016/j.mex.2015.02.009">doi:10.1016/j.mex.2015.02.009</a> and more.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
<strong>Package:</strong> </td><td style="text-align: left;"> alkahest </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Type:</strong> </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Version:</strong> </td><td style="text-align: left;"> 1.1.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>License:</strong> </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Zenodo:</strong> </td><td style="text-align: left;"> <a href="https://doi.org/10.5281/zenodo.7081524">doi:10.5281/zenodo.7081524</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p><strong>Full list of authors and contributors</strong> (alphabetic order)
</p>

<table>
<tr>
 <td style="text-align: left;">
Nicolas Frerebeau </td><td style="text-align: left;"> <em>Université Bordeaux Montaigne, France</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
Brice Lebrun </td><td style="text-align: left;"> <em>Université Bordeaux Montaigne, France</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><strong>Package maintainer</strong>
</p>
<p>Nicolas Frerebeau<br />
<a href="mailto:nicolas.frerebeau@u-bordeaux-montaigne.fr">nicolas.frerebeau@u-bordeaux-montaigne.fr</a>
</p>
<p>Archéosciences Bordeaux (UMR 6034)<br />
Maison de l'Archéologie<br />
Université Bordeaux Montaigne<br />
33607 Pessac cedex<br />
France
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://packages.tesselle.org/alkahest/">https://packages.tesselle.org/alkahest/</a>
</p>
</li>
<li> <p><a href="https://github.com/tesselle/alkahest">https://github.com/tesselle/alkahest</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tesselle/alkahest/issues">https://github.com/tesselle/alkahest/issues</a>
</p>
</li></ul>


<hr>
<h2 id='baseline_linear'>Linear Baseline Estimation</h2><span id='topic+baseline_linear'></span><span id='topic+baseline_linear-method'></span><span id='topic+baseline_linear+2Cnumeric+2Cnumeric-method'></span><span id='topic+baseline_linear+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Linear Baseline Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_linear(x, y, ...)

## S4 method for signature 'numeric,numeric'
baseline_linear(x, y, points = range(x))

## S4 method for signature 'ANY,missing'
baseline_linear(x, points = range(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_linear_+3A_x">x</code>, <code id="baseline_linear_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_linear_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="baseline_linear_+3A_points">points</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the data points to be used in
the fitting process (in <code>x</code> unit).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_correct">signal_correct()</a></code>
</p>
<p>Other baseline estimation methods: 
<code><a href="#topic+baseline_peakfilling">baseline_peakfilling</a>()</code>,
<code><a href="#topic+baseline_polynomial">baseline_polynomial</a>()</code>,
<code><a href="#topic+baseline_rollingball">baseline_rollingball</a>()</code>,
<code><a href="#topic+baseline_rubberband">baseline_rubberband</a>()</code>,
<code><a href="#topic+baseline_snip">baseline_snip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Linear baseline
baseline &lt;- baseline_linear(XRD, points = c(25, 34))

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(baseline, type = "l", col = "red")

## Correct baseline
XRD$count &lt;- XRD$count - baseline$y

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
</code></pre>

<hr>
<h2 id='baseline_peakfilling'>4S Peak Filling</h2><span id='topic+baseline_peakfilling'></span><span id='topic+baseline_peakfilling-method'></span><span id='topic+baseline_peakfilling+2Cnumeric+2Cnumeric-method'></span><span id='topic+baseline_peakfilling+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Baseline estimation by iterative mean suppression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_peakfilling(x, y, ...)

## S4 method for signature 'numeric,numeric'
baseline_peakfilling(x, y, n, m, by = 10, lambda = 1600, d = 2, sparse = FALSE)

## S4 method for signature 'ANY,missing'
baseline_peakfilling(x, n, m, by = 10, lambda = 1600, d = 2, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_peakfilling_+3A_x">x</code>, <code id="baseline_peakfilling_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_n">n</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> value giving the number of iterations.</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the half window size.</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_by">by</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector givging the umber of buckets to
divide <code>x</code> into.</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_lambda">lambda</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the smoothing parameter. The larger
<code>lambda</code> is, the smoother the curve (see <code><a href="#topic+smooth_whittaker">smooth_whittaker()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_d">d</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the order of the penalty (see
<code><a href="#topic+smooth_whittaker">smooth_whittaker()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_peakfilling_+3A_sparse">sparse</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should sparse matrices be used for
computation (see <code><a href="#topic+smooth_whittaker">smooth_whittaker()</a></code>)? If <code>TRUE</code>, <span class="pkg">Matrix</span> is required.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Liland, K. H. (2015). 4S Peak Filling - baseline estimation by iterative
mean suppression. <em>MethodsX</em>, 2, 135-140. <a href="https://doi.org/10.1016/j.mex.2015.02.009">doi:10.1016/j.mex.2015.02.009</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_correct">signal_correct()</a></code>, <code><a href="#topic+smooth_whittaker">smooth_whittaker()</a></code>
</p>
<p>Other baseline estimation methods: 
<code><a href="#topic+baseline_linear">baseline_linear</a>()</code>,
<code><a href="#topic+baseline_polynomial">baseline_polynomial</a>()</code>,
<code><a href="#topic+baseline_rollingball">baseline_rollingball</a>()</code>,
<code><a href="#topic+baseline_rubberband">baseline_rubberband</a>()</code>,
<code><a href="#topic+baseline_snip">baseline_snip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## 4S Peak Filling baseline
baseline &lt;- baseline_peakfilling(XRD, n = 10, m = 5, by = 10, sparse = TRUE)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(baseline, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='baseline_polynomial'>Polynomial Baseline Estimation</h2><span id='topic+baseline_polynomial'></span><span id='topic+baseline_polynomial-method'></span><span id='topic+baseline_polynomial+2Cnumeric+2Cnumeric-method'></span><span id='topic+baseline_polynomial+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Polynomial Baseline Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_polynomial(x, y, ...)

## S4 method for signature 'numeric,numeric'
baseline_polynomial(x, y, d = 3, tolerance = 0.001, stop = 100)

## S4 method for signature 'ANY,missing'
baseline_polynomial(x, d = 3, tolerance = 0.001, stop = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_polynomial_+3A_x">x</code>, <code id="baseline_polynomial_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_polynomial_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="baseline_polynomial_+3A_d">d</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the degree of the polynomial. Must be less
than the number of unique points.</p>
</td></tr>
<tr><td><code id="baseline_polynomial_+3A_tolerance">tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scalar giving the tolerance of difference
between iterations.</p>
</td></tr>
<tr><td><code id="baseline_polynomial_+3A_stop">stop</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the stopping rule (i.e. maximum number of
iterations).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Lieber, C. A. and Mahadevan-Jansen, A. (2003). Automated Method for
Subtraction of Fluorescence from Biological Raman Spectra. <em>Applied
Spectroscopy</em>, 57(11): 1363-67. <a href="https://doi.org/10.1366/000370203322554518">doi:10.1366/000370203322554518</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_correct">signal_correct()</a></code>
</p>
<p>Other baseline estimation methods: 
<code><a href="#topic+baseline_linear">baseline_linear</a>()</code>,
<code><a href="#topic+baseline_peakfilling">baseline_peakfilling</a>()</code>,
<code><a href="#topic+baseline_rollingball">baseline_rollingball</a>()</code>,
<code><a href="#topic+baseline_rubberband">baseline_rubberband</a>()</code>,
<code><a href="#topic+baseline_snip">baseline_snip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Subset from 20 to 70 degrees
XRD &lt;- signal_select(XRD, from = 20, to = 70)

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Polynomial baseline
baseline &lt;- baseline_polynomial(XRD, d = 4, tolerance = 0.02, stop = 1000)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(baseline, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='baseline_rollingball'>Rolling Ball Baseline Estimation</h2><span id='topic+baseline_rollingball'></span><span id='topic+baseline_rollingball-method'></span><span id='topic+baseline_rollingball+2Cnumeric+2Cnumeric-method'></span><span id='topic+baseline_rollingball+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Rolling Ball Baseline Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_rollingball(x, y, ...)

## S4 method for signature 'numeric,numeric'
baseline_rollingball(x, y, m, s)

## S4 method for signature 'ANY,missing'
baseline_rollingball(x, m, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_rollingball_+3A_x">x</code>, <code id="baseline_rollingball_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_rollingball_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="baseline_rollingball_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size (i.e. the number of
adjacent points to be used; see <code><a href="#topic+window_sliding">window_sliding()</a></code>) for
minimization/maximization.</p>
</td></tr>
<tr><td><code id="baseline_rollingball_+3A_s">s</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size (i.e. the number of
adjacent points to be used; see <code><a href="#topic+window_sliding">window_sliding()</a></code>) for smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>There will be <code class="reqn">(m - 1) / 2</code> points both at the beginning and at the end
of the data series for which a complete <code class="reqn">m</code>-width window cannot be
obtained. To prevent data loss, progressively wider/narrower windows are
used at both ends of the data series.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Kneen, M. A. and Annegarn, H. J. (1996). Algorithm for Fitting XRF, SEM and
PIXE X-Ray Spectra Backgrounds. <em>Nuclear Instruments and Methods in Physics
Research Section B: Beam Interactions with Materials and Atoms</em>,
109/110: 209-213. <a href="https://doi.org/10.1016/0168-583X%2895%2900908-6">doi:10.1016/0168-583X(95)00908-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_correct">signal_correct()</a></code>
</p>
<p>Other baseline estimation methods: 
<code><a href="#topic+baseline_linear">baseline_linear</a>()</code>,
<code><a href="#topic+baseline_peakfilling">baseline_peakfilling</a>()</code>,
<code><a href="#topic+baseline_polynomial">baseline_polynomial</a>()</code>,
<code><a href="#topic+baseline_rubberband">baseline_rubberband</a>()</code>,
<code><a href="#topic+baseline_snip">baseline_snip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Subset from 20 to 70 degrees
XRD &lt;- signal_select(XRD, from = 20, to = 70)

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Rolling Ball baseline
baseline &lt;- baseline_rollingball(XRD, m = 201, s = 151)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(baseline, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='baseline_rubberband'>Rubberband Baseline Estimation</h2><span id='topic+baseline_rubberband'></span><span id='topic+baseline_rubberband-method'></span><span id='topic+baseline_rubberband+2Cnumeric+2Cnumeric-method'></span><span id='topic+baseline_rubberband+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Rubberband Baseline Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_rubberband(x, y, ...)

## S4 method for signature 'numeric,numeric'
baseline_rubberband(x, y, noise = 0, spline = TRUE, ...)

## S4 method for signature 'ANY,missing'
baseline_rubberband(x, noise = 0, spline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_rubberband_+3A_x">x</code>, <code id="baseline_rubberband_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_rubberband_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>.</p>
</td></tr>
<tr><td><code id="baseline_rubberband_+3A_noise">noise</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the noise level.
Only used if <code>method</code> is &quot;<code>rubberband</code>&quot;.</p>
</td></tr>
<tr><td><code id="baseline_rubberband_+3A_spline">spline</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should spline interpolation through the
support points be used instead of linear interpolation?
Only used if <code>method</code> is &quot;<code>rubberband</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convex envelope of the spectrum is determined and the
baseline is estimated as the part of the convex envelope lying below the
spectrum. Note that the rubber band does not enter the concave regions
(if any) of the spectrum.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p><code>baseline_rubberband()</code> is slightly modified from C. Beleites'
<code><a href="hyperSpec.html#topic+spc-rubberband">hyperSpec::spc.rubberband()</a></code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_correct">signal_correct()</a></code>
</p>
<p>Other baseline estimation methods: 
<code><a href="#topic+baseline_linear">baseline_linear</a>()</code>,
<code><a href="#topic+baseline_peakfilling">baseline_peakfilling</a>()</code>,
<code><a href="#topic+baseline_polynomial">baseline_polynomial</a>()</code>,
<code><a href="#topic+baseline_rollingball">baseline_rollingball</a>()</code>,
<code><a href="#topic+baseline_snip">baseline_snip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Rubberband baseline
baseline &lt;- baseline_rubberband(BEGe)

plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")
lines(baseline, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='baseline_snip'>SNIP Baseline Estimation</h2><span id='topic+baseline_snip'></span><span id='topic+baseline_snip-method'></span><span id='topic+baseline_snip+2Cnumeric+2Cnumeric-method'></span><span id='topic+baseline_snip+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Sensitive Nonlinear Iterative Peak clipping algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_snip(x, y, ...)

## S4 method for signature 'numeric,numeric'
baseline_snip(x, y, LLS = FALSE, decreasing = FALSE, n = 100)

## S4 method for signature 'ANY,missing'
baseline_snip(x, LLS = FALSE, decreasing = FALSE, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_snip_+3A_x">x</code>, <code id="baseline_snip_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="baseline_snip_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="baseline_snip_+3A_lls">LLS</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the LLS operator be applied on <code>x</code>
before employing SNIP algorithm? Only used if <code>method</code> is &quot;<code>SNIP</code>&quot;.</p>
</td></tr>
<tr><td><code id="baseline_snip_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a decreasing clipping window
be used?</p>
</td></tr>
<tr><td><code id="baseline_snip_+3A_n">n</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> value giving the number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Morháč, M., Kliman, J., Matoušek, V., Veselský, M. &amp; Turzo, I. (1997).
Background elimination methods for multidimensional gamma-ray spectra.
<em>Nuclear Instruments and Methods in Physics Research Section A:
Accelerators, Spectrometers, Detectors and Associated Equipment</em>, 401(1),
p. 113-132. <a href="https://doi.org/10.1016/S0168-9002%2897%2901023-1">doi:10.1016/S0168-9002(97)01023-1</a>
</p>
<p>Morháč, M. &amp; Matoušek, V. (2008). Peak Clipping Algorithms for Background
Estimation in Spectroscopic Data. <em>Applied Spectroscopy</em>, 62(1), p. 91-106.
<a href="https://doi.org/10.1366/000370208783412762">doi:10.1366/000370208783412762</a>
</p>
<p>Ryan, C. G., Clayton, E., Griffin, W. L., Sie, S. H. &amp; Cousens, D. R.
(1988). SNIP, a statistics-sensitive background treatment for the
quantitative analysis of PIXE spectra in geoscience applications.
<em>Nuclear Instruments and Methods in Physics Research Section B:
Beam Interactions with Materials and Atoms</em>, 34(3), p. 396-402.
<a href="https://doi.org/10.1016/0168-583X%2888%2990063-8">doi:10.1016/0168-583X(88)90063-8</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_correct">signal_correct()</a></code>
</p>
<p>Other baseline estimation methods: 
<code><a href="#topic+baseline_linear">baseline_linear</a>()</code>,
<code><a href="#topic+baseline_peakfilling">baseline_peakfilling</a>()</code>,
<code><a href="#topic+baseline_polynomial">baseline_polynomial</a>()</code>,
<code><a href="#topic+baseline_rollingball">baseline_rollingball</a>()</code>,
<code><a href="#topic+baseline_rubberband">baseline_rubberband</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## SNIP baseline
baseline &lt;- baseline_snip(BEGe, LLS = FALSE, decreasing = FALSE, n = 100)

plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")
lines(baseline, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='BEGe'>Gamma-Ray Spectrometry</h2><span id='topic+BEGe'></span>

<h3>Description</h3>

<p>Gamma-Ray Spectrometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BEGe
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 8192 rows (channels) and 2 variables.
</p>

<dl>
<dt>energy</dt><dd><p>(keV)</p>
</dd>
<dt>count</dt><dd></dd>
</dl>



<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+LaBr">LaBr</a></code>,
<code><a href="#topic+XRD">XRD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("BEGe")
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")
</code></pre>

<hr>
<h2 id='integrate_rectangle'>Rectangle Rule</h2><span id='topic+integrate_rectangle'></span><span id='topic+integrate_rectangle-method'></span><span id='topic+integrate_rectangle+2Cnumeric+2Cnumeric-method'></span><span id='topic+integrate_rectangle+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Approximates the definite integral by using the rectangle rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_rectangle(x, y, ...)

## S4 method for signature 'numeric,numeric'
integrate_rectangle(x, y, right = FALSE)

## S4 method for signature 'ANY,missing'
integrate_rectangle(x, right = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_rectangle_+3A_x">x</code>, <code id="integrate_rectangle_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="integrate_rectangle_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="integrate_rectangle_+3A_right">right</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the right rule be used instead of
the left rule?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other integration methods: 
<code><a href="#topic+integrate_trapezoid">integrate_trapezoid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate the area under the sine curve from 0 to pi
# integrate(f = function(x) x^3, lower = 0, upper = 2)
x &lt;- seq(0, 2, len = 101)
y &lt;- x^3

plot(x, y, type = "l")

integrate_rectangle(x, y, right = FALSE) # 3.9204
integrate_rectangle(x, y, right = TRUE) # 4.0804
integrate_trapezoid(x, y) # 4.0004
</code></pre>

<hr>
<h2 id='integrate_trapezoid'>Trapezoidal Rule</h2><span id='topic+integrate_trapezoid'></span><span id='topic+integrate_trapezoid-method'></span><span id='topic+integrate_trapezoid+2Cnumeric+2Cnumeric-method'></span><span id='topic+integrate_trapezoid+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Approximates the definite integral by using the trapezoidal rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_trapezoid(x, y, ...)

## S4 method for signature 'numeric,numeric'
integrate_trapezoid(x, y)

## S4 method for signature 'ANY,missing'
integrate_trapezoid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_trapezoid_+3A_x">x</code>, <code id="integrate_trapezoid_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="integrate_trapezoid_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other integration methods: 
<code><a href="#topic+integrate_rectangle">integrate_rectangle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate the area under the sine curve from 0 to pi
# integrate(f = function(x) x^3, lower = 0, upper = 2)
x &lt;- seq(0, 2, len = 101)
y &lt;- x^3

plot(x, y, type = "l")

integrate_rectangle(x, y, right = FALSE) # 3.9204
integrate_rectangle(x, y, right = TRUE) # 4.0804
integrate_trapezoid(x, y) # 4.0004
</code></pre>

<hr>
<h2 id='ka2_strip_penalized'>Strip XRD ka2</h2><span id='topic+ka2_strip_penalized'></span><span id='topic+ka2_strip_penalized-method'></span><span id='topic+ka2_strip_penalized+2Cnumeric+2Cnumeric-method'></span><span id='topic+ka2_strip_penalized+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Strip XRD ka2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ka2_strip_penalized(x, y, ...)

## S4 method for signature 'numeric,numeric'
ka2_strip_penalized(
  x,
  y,
  lambda,
  wave = c(1.5406, 1.54443),
  tau = 0.5,
  nseg = 1,
  progress = interactive()
)

## S4 method for signature 'ANY,missing'
ka2_strip_penalized(
  x,
  lambda,
  wave = c(1.5406, 1.54443),
  tau = 0.5,
  nseg = 1,
  progress = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ka2_strip_penalized_+3A_x">x</code>, <code id="ka2_strip_penalized_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="ka2_strip_penalized_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="ka2_strip_penalized_+3A_lambda">lambda</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the smoothing parameter. The larger
<code>lambda</code> is, the smoother the curve.</p>
</td></tr>
<tr><td><code id="ka2_strip_penalized_+3A_wave">wave</code></td>
<td>
<p>A length-two <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the characteristic
wavelengths of the anode material (defaults to copper).</p>
</td></tr>
<tr><td><code id="ka2_strip_penalized_+3A_tau">tau</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the ratio between
<code class="reqn">\alpha</code>1 and <code class="reqn">\alpha</code>2 line intensities (defaults to 1/2).</p>
</td></tr>
<tr><td><code id="ka2_strip_penalized_+3A_nseg">nseg</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the number of equally
sized segments for B-spline basis matrix computation.</p>
</td></tr>
<tr><td><code id="ka2_strip_penalized_+3A_progress">progress</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a progress bar be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p><span class="pkg">Matrix</span> is required.
</p>


<h3>Author(s)</h3>

<p>J. J. de Rooi <em>et al.</em> (original R code).
</p>


<h3>References</h3>

<p>de Rooi, J. J., van der Pers, N. M., Hendrikx, R. W. A., Delhez, R.,
Böttger A. J. and Eilers, P. H. C. (2014). Smoothing of X-ray diffraction
data and Ka2 elimination using penalized likelihood and the composite link
model. <em>Journal of Applied Crystallography</em>, 47: 852-860.
<a href="https://doi.org/10.1107/S1600576714005809">doi:10.1107/S1600576714005809</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## X-ray diffraction
data("XRD")

## Subset from 20 to 40 degrees
XRD &lt;- signal_select(XRD, from = 20, to = 40)

## Plot diffractogram
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Penalized likelihood smoothing
lambda &lt;- seq(from = 1, to = 8, length.out = 40)
lambda &lt;- 10^lambda

likelihood &lt;- smooth_likelihood(XRD, lambda = lambda, d = 3)
lines(likelihood, col = "red")

## Strip ka2
ka2 &lt;- ka2_strip_penalized(XRD, lambda = lambda, tau = 0.5, nseg = 1)
lines(ka2, col = "blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='LaBr'>Gamma-Ray Spectrometry</h2><span id='topic+LaBr'></span>

<h3>Description</h3>

<p>Gamma-Ray Spectrometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LaBr
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 1024 rows (channels) and 2 variables.
</p>

<dl>
<dt>energy</dt><dd><p>(keV)</p>
</dd>
<dt>count</dt><dd></dd>
</dl>



<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+BEGe">BEGe</a></code>,
<code><a href="#topic+XRD">XRD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LaBr")
plot(LaBr, type = "l", xlab = "Energy (keV)", ylab = "Count")
</code></pre>

<hr>
<h2 id='peaks_find'>Find Peaks</h2><span id='topic+peaks_find'></span><span id='topic+peaks_find-method'></span><span id='topic+peaks_find+2Cnumeric+2Cnumeric-method'></span><span id='topic+peaks_find+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Finds local maxima in sequential data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks_find(x, y, ...)

## S4 method for signature 'numeric,numeric'
peaks_find(x, y, method = "MAD", SNR = 2, m = NULL, ...)

## S4 method for signature 'ANY,missing'
peaks_find(x, method = "MAD", SNR = 2, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_find_+3A_x">x</code>, <code id="peaks_find_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="peaks_find_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to internal methods.</p>
</td></tr>
<tr><td><code id="peaks_find_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the method to be used for
background noise estimation (see below).</p>
</td></tr>
<tr><td><code id="peaks_find_+3A_snr">SNR</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the signal-to-noise-ratio for peak detection
(see below).</p>
</td></tr>
<tr><td><code id="peaks_find_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size (i.e. the number of
adjacent points to be used).
If <code>NULL</code>, 5% of the data points is used as the half window size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A local maximum has to be the highest one in the given window and has to be
higher than <code class="reqn">SNR \times noise</code> to be recognized as peak.
</p>
<p>The following methods are available for noise estimation:
</p>

<dl>
<dt><code>MAD</code></dt><dd><p>Median Absolute Deviation.</p>
</dd>
</dl>

<p>Note that to improve peak detection, it may be helpful to smooth the data
and remove the baseline beforehand.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>There will be <code class="reqn">(m - 1) / 2</code> points both at the beginning and at the end
of the data series for which a complete <code class="reqn">m</code>-width window cannot be
obtained. To prevent data loss, progressively wider/narrower windows are
used at both ends of the data series.
</p>
<p>Adapted from Stasia Grinberg's
<a href="https://github.com/stas-g/findPeaks"><code>findPeaks</code></a> function.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other peaks detection methods: 
<code><a href="#topic+peaks_fwhm">peaks_fwhm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## 4S Peak Filling baseline
baseline &lt;- baseline_peakfilling(XRD, n = 10, m = 5, by = 10, sparse = TRUE)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(baseline, type = "l", col = "red")

## Correct baseline
XRD &lt;- signal_drift(XRD, lag = baseline, subtract = TRUE)

## Find peaks
peaks &lt;- peaks_find(XRD, SNR = 3, m = 11)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(peaks, type = "p", pch = 16, col = "red")
abline(h = attr(peaks, "noise"), lty = 2) # noise threshold

## Half-Width at Half-Maximum
x &lt;- seq(-4, 4, length = 1000)
y &lt;- dnorm(x)

peaks_fwhm(x, y, center = 0) # Expected: 2 * sqrt(2 * log(2))
</code></pre>

<hr>
<h2 id='peaks_fwhm'>Half-Width at Half-Maximum</h2><span id='topic+peaks_fwhm'></span><span id='topic+peaks_fwhm-method'></span><span id='topic+peaks_fwhm+2Cnumeric+2Cnumeric-method'></span><span id='topic+peaks_fwhm+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Estimates the Half-Width at Half-Maximum (FWHM) for a given peak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks_fwhm(x, y, ...)

## S4 method for signature 'numeric,numeric'
peaks_fwhm(x, y, center)

## S4 method for signature 'ANY,missing'
peaks_fwhm(x, center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_fwhm_+3A_x">x</code>, <code id="peaks_fwhm_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="peaks_fwhm_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="peaks_fwhm_+3A_center">center</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value giving the peak position in <code>x</code> units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It tries to get the smallest possible estimate.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other peaks detection methods: 
<code><a href="#topic+peaks_find">peaks_find</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## 4S Peak Filling baseline
baseline &lt;- baseline_peakfilling(XRD, n = 10, m = 5, by = 10, sparse = TRUE)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(baseline, type = "l", col = "red")

## Correct baseline
XRD &lt;- signal_drift(XRD, lag = baseline, subtract = TRUE)

## Find peaks
peaks &lt;- peaks_find(XRD, SNR = 3, m = 11)

plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
lines(peaks, type = "p", pch = 16, col = "red")
abline(h = attr(peaks, "noise"), lty = 2) # noise threshold

## Half-Width at Half-Maximum
x &lt;- seq(-4, 4, length = 1000)
y &lt;- dnorm(x)

peaks_fwhm(x, y, center = 0) # Expected: 2 * sqrt(2 * log(2))
</code></pre>

<hr>
<h2 id='replace_negative'>Replace Negative Values</h2><span id='topic+replace_negative'></span><span id='topic+replace_negative-method'></span><span id='topic+replace_negative+2Cnumeric+2Cnumeric-method'></span><span id='topic+replace_negative+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Replace Negative Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_negative(x, y, ...)

## S4 method for signature 'numeric,numeric'
replace_negative(x, y, value = 0)

## S4 method for signature 'ANY,missing'
replace_negative(x, value = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_negative_+3A_x">x</code>, <code id="replace_negative_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="replace_negative_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to <code>threshold</code>.</p>
</td></tr>
<tr><td><code id="replace_negative_+3A_value">value</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value to replace negative values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other replacement methods: 
<code><a href="#topic+replace_threshold">replace_threshold</a>()</code>
</p>

<hr>
<h2 id='replace_threshold'>Replace Values Below a Given Threshold</h2><span id='topic+replace_threshold'></span><span id='topic+replace_threshold-method'></span><span id='topic+replace_threshold+2Cnumeric+2Cnumeric+2Cfunction-method'></span><span id='topic+replace_threshold+2CANY+2Cmissing+2Cfunction-method'></span><span id='topic+replace_threshold+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+replace_threshold+2CANY+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Replace Values Below a Given Threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_threshold(x, y, threshold, ...)

## S4 method for signature 'numeric,numeric,'function''
replace_threshold(x, y, threshold, value = 0, ...)

## S4 method for signature 'ANY,missing,'function''
replace_threshold(x, threshold, value = 0, ...)

## S4 method for signature 'numeric,numeric,numeric'
replace_threshold(x, y, threshold, value = 0, ...)

## S4 method for signature 'ANY,missing,numeric'
replace_threshold(x, threshold, value = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_threshold_+3A_x">x</code>, <code id="replace_threshold_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="replace_threshold_+3A_threshold">threshold</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value or a <code><a href="base.html#topic+function">function</a></code> that takes a <code>numeric</code>
vector as argument and returns a single <code>numeric</code> value.</p>
</td></tr>
<tr><td><code id="replace_threshold_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to <code>threshold</code>.</p>
</td></tr>
<tr><td><code id="replace_threshold_+3A_value">value</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value to replace values below <code>threshold</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other replacement methods: 
<code><a href="#topic+replace_negative">replace_negative</a>()</code>
</p>

<hr>
<h2 id='resample_bin'>Bin</h2><span id='topic+resample_bin'></span><span id='topic+resample_bin-method'></span><span id='topic+resample_bin+2Cnumeric+2Cnumeric-method'></span><span id='topic+resample_bin+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Averages <code>x</code> values and applies a function to the corresponding <code>y</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_bin(x, y, ...)

## S4 method for signature 'numeric,numeric'
resample_bin(x, y, by, f = mean, ...)

## S4 method for signature 'ANY,missing'
resample_bin(x, y, by, f = sum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_bin_+3A_x">x</code>, <code id="resample_bin_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_bin_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="resample_bin_+3A_by">by</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the binning ratio (i.e. the number of
points to be grouped together; see <code><a href="#topic+window_tumbling">window_tumbling()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_bin_+3A_f">f</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> that takes a <code>numeric</code> vector of intensities as
argument and returns a single <code>numeric</code> vector. Used to estimate the local
representative value in each bin (defaults to <code><a href="base.html#topic+sum">sum()</a></code>; see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other resampling methods: 
<code><a href="#topic+resample_down">resample_down</a>()</code>,
<code><a href="#topic+resample_interpolate">resample_interpolate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Bin by 3
XRD_bin_mean &lt;- resample_bin(XRD, by = 3, f = mean)
XRD_bin_min &lt;- resample_bin(XRD, by = 3, f = min)

plot(XRD, type = "l", xlim = c(25, 35),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_bin_mean, type = "l", col = "red")
lines(XRD_bin_min, type = "l", col = "green")

## Downsample by 10
XRD_down &lt;- resample_down(XRD, by = 10)

plot(XRD, type = "l", xlim = c(20, 40),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_down, type = "l", col = "red")

## Linearly interpolate
XRD_approx &lt;- resample_interpolate(XRD, from = 20, to = 40, by = 0.02)

plot(XRD, type = "l", xlim = c(20, 40),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_approx, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='resample_down'>Downsample</h2><span id='topic+resample_down'></span><span id='topic+resample_down-method'></span><span id='topic+resample_down+2Cnumeric+2Cnumeric-method'></span><span id='topic+resample_down+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Downsample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_down(x, y, ...)

## S4 method for signature 'numeric,numeric'
resample_down(x, y, by)

## S4 method for signature 'ANY,missing'
resample_down(x, y, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_down_+3A_x">x</code>, <code id="resample_down_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_down_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="resample_down_+3A_by">by</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the downsampling factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other resampling methods: 
<code><a href="#topic+resample_bin">resample_bin</a>()</code>,
<code><a href="#topic+resample_interpolate">resample_interpolate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Bin by 3
XRD_bin_mean &lt;- resample_bin(XRD, by = 3, f = mean)
XRD_bin_min &lt;- resample_bin(XRD, by = 3, f = min)

plot(XRD, type = "l", xlim = c(25, 35),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_bin_mean, type = "l", col = "red")
lines(XRD_bin_min, type = "l", col = "green")

## Downsample by 10
XRD_down &lt;- resample_down(XRD, by = 10)

plot(XRD, type = "l", xlim = c(20, 40),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_down, type = "l", col = "red")

## Linearly interpolate
XRD_approx &lt;- resample_interpolate(XRD, from = 20, to = 40, by = 0.02)

plot(XRD, type = "l", xlim = c(20, 40),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_approx, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='resample_interpolate'>Linearly Interpolate</h2><span id='topic+resample_interpolate'></span><span id='topic+resample_interpolate-method'></span><span id='topic+resample_interpolate+2Cnumeric+2Cnumeric-method'></span><span id='topic+resample_interpolate+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Linearly Interpolate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_interpolate(x, y, ...)

## S4 method for signature 'numeric,numeric'
resample_interpolate(x, y, from, to, by, ...)

## S4 method for signature 'ANY,missing'
resample_interpolate(x, y, from, to, by, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_interpolate_+3A_x">x</code>, <code id="resample_interpolate_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_interpolate_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code><a href="stats.html#topic+approxfun">stats::approx()</a></code>.</p>
</td></tr>
<tr><td><code id="resample_interpolate_+3A_from">from</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the starting value of the
sequence where interpolation is to take place.</p>
</td></tr>
<tr><td><code id="resample_interpolate_+3A_to">to</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the end value of the
sequence where interpolation is to take place.</p>
</td></tr>
<tr><td><code id="resample_interpolate_+3A_by">by</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the increment of the
sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other resampling methods: 
<code><a href="#topic+resample_bin">resample_bin</a>()</code>,
<code><a href="#topic+resample_down">resample_down</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Bin by 3
XRD_bin_mean &lt;- resample_bin(XRD, by = 3, f = mean)
XRD_bin_min &lt;- resample_bin(XRD, by = 3, f = min)

plot(XRD, type = "l", xlim = c(25, 35),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_bin_mean, type = "l", col = "red")
lines(XRD_bin_min, type = "l", col = "green")

## Downsample by 10
XRD_down &lt;- resample_down(XRD, by = 10)

plot(XRD, type = "l", xlim = c(20, 40),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_down, type = "l", col = "red")

## Linearly interpolate
XRD_approx &lt;- resample_interpolate(XRD, from = 20, to = 40, by = 0.02)

plot(XRD, type = "l", xlim = c(20, 40),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD_approx, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='rescale_area'>Normalize intensities by AUC</h2><span id='topic+rescale_area'></span><span id='topic+rescale_area-method'></span><span id='topic+rescale_area+2Cnumeric+2Cnumeric-method'></span><span id='topic+rescale_area+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Rescales intensities so that the area under the curve (AUC) is equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_area(x, y, ...)

## S4 method for signature 'numeric,numeric'
rescale_area(x, y, method = c("rectangle", "trapezoid"), ...)

## S4 method for signature 'ANY,missing'
rescale_area(x, method = c("rectangle", "trapezoid"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_area_+3A_x">x</code>, <code id="rescale_area_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="rescale_area_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="rescale_area_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the method for integration.
It must be one of &quot;<code>rectangle</code>&quot; or &quot;<code>trapezoid</code>&quot;.
Any unambiguous substring can be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other normalization methods: 
<code><a href="#topic+rescale_range">rescale_range</a>()</code>,
<code><a href="#topic+rescale_total">rescale_total</a>()</code>,
<code><a href="#topic+rescale_transform">rescale_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Normalize by area under the curve
BEGe_area &lt;- rescale_area(BEGe)
plot(BEGe_area, type = "l", xlab = "Energy (keV)", ylab = "Count")
integrate_rectangle(BEGe)
integrate_rectangle(BEGe_area)

## Rescale so that intensities sum to 1
BEGe_total &lt;- rescale_total(BEGe, total = 1)
plot(BEGe_total, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Rescale intensities to 0-1
BEGe_range &lt;- rescale_range(BEGe, min = 0, max = 1)
plot(BEGe_range, type = "l", xlab = "Energy (keV)", ylab = "Count")
</code></pre>

<hr>
<h2 id='rescale_range'>Rescales intensities to have specified minimum and maximum</h2><span id='topic+rescale_range'></span><span id='topic+rescale_range-method'></span><span id='topic+rescale_min'></span><span id='topic+rescale_min-method'></span><span id='topic+rescale_max'></span><span id='topic+rescale_max-method'></span><span id='topic+rescale_range+2Cnumeric+2Cnumeric-method'></span><span id='topic+rescale_range+2CANY+2Cmissing-method'></span><span id='topic+rescale_min+2Cnumeric+2Cnumeric-method'></span><span id='topic+rescale_min+2CANY+2Cmissing-method'></span><span id='topic+rescale_max+2Cnumeric+2Cnumeric-method'></span><span id='topic+rescale_max+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Rescales intensities to have specified minimum and maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_range(x, y, ...)

rescale_min(x, y, ...)

rescale_max(x, y, ...)

## S4 method for signature 'numeric,numeric'
rescale_range(x, y, min = 0, max = 1)

## S4 method for signature 'ANY,missing'
rescale_range(x, min = 0, max = 1)

## S4 method for signature 'numeric,numeric'
rescale_min(x, y, min = 0)

## S4 method for signature 'ANY,missing'
rescale_min(x, min = 0)

## S4 method for signature 'numeric,numeric'
rescale_max(x, y, max = 1)

## S4 method for signature 'ANY,missing'
rescale_max(x, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_range_+3A_x">x</code>, <code id="rescale_range_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="rescale_range_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="rescale_range_+3A_min">min</code></td>
<td>
<p>A legnth-one <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the output minimum.</p>
</td></tr>
<tr><td><code id="rescale_range_+3A_max">max</code></td>
<td>
<p>A legnth-one <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the output maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other normalization methods: 
<code><a href="#topic+rescale_area">rescale_area</a>()</code>,
<code><a href="#topic+rescale_total">rescale_total</a>()</code>,
<code><a href="#topic+rescale_transform">rescale_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Normalize by area under the curve
BEGe_area &lt;- rescale_area(BEGe)
plot(BEGe_area, type = "l", xlab = "Energy (keV)", ylab = "Count")
integrate_rectangle(BEGe)
integrate_rectangle(BEGe_area)

## Rescale so that intensities sum to 1
BEGe_total &lt;- rescale_total(BEGe, total = 1)
plot(BEGe_total, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Rescale intensities to 0-1
BEGe_range &lt;- rescale_range(BEGe, min = 0, max = 1)
plot(BEGe_range, type = "l", xlab = "Energy (keV)", ylab = "Count")
</code></pre>

<hr>
<h2 id='rescale_total'>Rescale intensities to sum to a specified value</h2><span id='topic+rescale_total'></span><span id='topic+rescale_total-method'></span><span id='topic+rescale_total+2Cnumeric+2Cnumeric-method'></span><span id='topic+rescale_total+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Rescales intensities to sum to a specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_total(x, y, ...)

## S4 method for signature 'numeric,numeric'
rescale_total(x, y, total = 1)

## S4 method for signature 'ANY,missing'
rescale_total(x, total = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_total_+3A_x">x</code>, <code id="rescale_total_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="rescale_total_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="rescale_total_+3A_total">total</code></td>
<td>
<p>A legnth-one <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the output total.
Defaults to 1, i.e. normalizes by total intensity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other normalization methods: 
<code><a href="#topic+rescale_area">rescale_area</a>()</code>,
<code><a href="#topic+rescale_range">rescale_range</a>()</code>,
<code><a href="#topic+rescale_transform">rescale_transform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Normalize by area under the curve
BEGe_area &lt;- rescale_area(BEGe)
plot(BEGe_area, type = "l", xlab = "Energy (keV)", ylab = "Count")
integrate_rectangle(BEGe)
integrate_rectangle(BEGe_area)

## Rescale so that intensities sum to 1
BEGe_total &lt;- rescale_total(BEGe, total = 1)
plot(BEGe_total, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Rescale intensities to 0-1
BEGe_range &lt;- rescale_range(BEGe, min = 0, max = 1)
plot(BEGe_range, type = "l", xlab = "Energy (keV)", ylab = "Count")
</code></pre>

<hr>
<h2 id='rescale_transform'>Transform Intensities</h2><span id='topic+rescale_transform'></span><span id='topic+rescale_transform-method'></span><span id='topic+rescale_transform+2Cnumeric+2Cnumeric-method'></span><span id='topic+rescale_transform+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Transform Intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_transform(x, y, ...)

## S4 method for signature 'numeric,numeric'
rescale_transform(x, y, f, ...)

## S4 method for signature 'ANY,missing'
rescale_transform(x, f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_transform_+3A_x">x</code>, <code id="rescale_transform_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="rescale_transform_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="rescale_transform_+3A_f">f</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> that takes a <code>numeric</code> vector of intensities as
argument and returns a <code>numeric</code> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation of intensities can be used to improve the identification of
peaks with a low signal-to-noise ratio.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other normalization methods: 
<code><a href="#topic+rescale_area">rescale_area</a>()</code>,
<code><a href="#topic+rescale_range">rescale_range</a>()</code>,
<code><a href="#topic+rescale_total">rescale_total</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Transform intensities
BEGe_trans &lt;- rescale_transform(BEGe, f = sqrt)
plot(BEGe_trans, type = "l", xlab = "Energy (keV)", ylab = "sqrt(Count)")
</code></pre>

<hr>
<h2 id='signal_bind'>Bind</h2><span id='topic+signal_bind'></span><span id='topic+signal_bind-method'></span><span id='topic+signal_bind+2CANY-method'></span>

<h3>Description</h3>

<p>Combines XY objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_bind(...)

## S4 method for signature 'ANY'
signal_bind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_bind_+3A_...">...</code></td>
<td>
<p>Any object that can be interpreted in a suitable way
(see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+matrix">matrix</a></code> of intensities.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other signal processing methods: 
<code><a href="#topic+signal_correct">signal_correct</a>()</code>,
<code><a href="#topic+signal_drift">signal_drift</a>()</code>,
<code><a href="#topic+signal_mean">signal_mean</a>()</code>,
<code><a href="#topic+signal_shift">signal_shift</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

XRD1 &lt;- signal_drift(XRD, lag = 1500)

## Bind
XRD_bind &lt;- signal_bind(XRD, XRD1)
XRD_bind[, 1:10]

## Mean
XRD_mean &lt;- signal_mean(XRD, XRD1)

plot(NULL, type = "l", xlim = c(10, 70) , ylim = c(3000, 36000),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD, type = "l")
lines(XRD1, type = "l")
lines(XRD_mean, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='signal_correct'>Baseline Correction</h2><span id='topic+signal_correct'></span><span id='topic+signal_correct-method'></span><span id='topic+signal_correct+2Cnumeric+2Cnumeric-method'></span><span id='topic+signal_correct+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Baseline Correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_correct(x, y, ...)

## S4 method for signature 'numeric,numeric'
signal_correct(x, y, method = c("linear", "rubberband", "SNIP", "4S"), ...)

## S4 method for signature 'ANY,missing'
signal_correct(x, method = c("linear", "rubberband", "SNIP", "4S"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_correct_+3A_x">x</code>, <code id="signal_correct_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="signal_correct_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code style="white-space: pre;">&#8288;baseline_*()&#8288;</code> (see details).</p>
</td></tr>
<tr><td><code id="signal_correct_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the method for baseline
estimation. It must be one of &quot;<code>linear</code>&quot;, &quot;<code>rubberband</code>&quot;, &quot;<code>SNIP</code>&quot; or &quot;<code style="white-space: pre;">&#8288;4S&#8288;</code>&quot;
(see details). Any unambiguous substring can be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available methods for baseline estimation:
</p>

<dl>
<dt><code>linear</code></dt><dd><p>Linear baseline estimation (see <code><a href="#topic+baseline_linear">baseline_linear()</a></code>).</p>
</dd>
<dt><code>rubberband</code></dt><dd><p>Rubberband baseline estimation (see
<code><a href="#topic+baseline_rubberband">baseline_rubberband()</a></code>).</p>
</dd>
<dt><code>SNIP</code></dt><dd><p>Sensitive Nonlinear Iterative Peak clipping algorithm
(see <code><a href="#topic+baseline_snip">baseline_snip()</a></code>).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;4S&#8288;</code></dt><dd><p>4S Peak Filling (see <code><a href="#topic+baseline_peakfilling">baseline_peakfilling()</a></code>).</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other signal processing methods: 
<code><a href="#topic+signal_bind">signal_bind</a>()</code>,
<code><a href="#topic+signal_drift">signal_drift</a>()</code>,
<code><a href="#topic+signal_mean">signal_mean</a>()</code>,
<code><a href="#topic+signal_shift">signal_shift</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Drift
baseline &lt;- baseline_snip(BEGe)
BEGe_drif &lt;- signal_drift(BEGe, lag = baseline, subtract = TRUE)

plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")
lines(BEGe_drif, type = "l", col = "red")

## Correct
BEGe_corr &lt;- signal_correct(BEGe, method = "SNIP")

plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")
lines(BEGe_corr, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='signal_drift'>Drift Intensities</h2><span id='topic+signal_drift'></span><span id='topic+signal_drift-method'></span><span id='topic+signal_drift+2Cnumeric+2Cnumeric+2Cnumeric-method'></span><span id='topic+signal_drift+2CANY+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Drift Intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_drift(x, y, lag, ...)

## S4 method for signature 'numeric,numeric,numeric'
signal_drift(x, y, lag)

## S4 method for signature 'ANY,missing,ANY'
signal_drift(x, lag, subtract = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_drift_+3A_x">x</code>, <code id="signal_drift_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="signal_drift_+3A_lag">lag</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the offset or any object that can
be interpreted in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>)</p>
</td></tr>
<tr><td><code id="signal_drift_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="signal_drift_+3A_subtract">subtract</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should <code>lag</code> be subtracted to <code>y</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other signal processing methods: 
<code><a href="#topic+signal_bind">signal_bind</a>()</code>,
<code><a href="#topic+signal_correct">signal_correct</a>()</code>,
<code><a href="#topic+signal_mean">signal_mean</a>()</code>,
<code><a href="#topic+signal_shift">signal_shift</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Subset from 2.75 to 200 keV
BEGe &lt;- signal_select(BEGe, from = 3, to = 200)

## Drift
BEGe_plus &lt;- signal_drift(BEGe, lag = 250)
BEGe_minus &lt;- signal_drift(BEGe, lag = 250, subtract = TRUE)

plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")
lines(BEGe_plus, type = "l", col = "red")
lines(BEGe_minus, type = "l", col = "green")
</code></pre>

<hr>
<h2 id='signal_mean'>Mean Intensities</h2><span id='topic+signal_mean'></span><span id='topic+signal_mean-method'></span><span id='topic+signal_mean+2CANY-method'></span>

<h3>Description</h3>

<p>Mean Intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_mean(...)

## S4 method for signature 'ANY'
signal_mean(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_mean_+3A_...">...</code></td>
<td>
<p>Any object that can be interpreted in a suitable way
(see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other signal processing methods: 
<code><a href="#topic+signal_bind">signal_bind</a>()</code>,
<code><a href="#topic+signal_correct">signal_correct</a>()</code>,
<code><a href="#topic+signal_drift">signal_drift</a>()</code>,
<code><a href="#topic+signal_shift">signal_shift</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

XRD1 &lt;- signal_drift(XRD, lag = 1500)

## Bind
XRD_bind &lt;- signal_bind(XRD, XRD1)
XRD_bind[, 1:10]

## Mean
XRD_mean &lt;- signal_mean(XRD, XRD1)

plot(NULL, type = "l", xlim = c(10, 70) , ylim = c(3000, 36000),
     xlab = expression(2*theta), ylab = "Count")
lines(XRD, type = "l")
lines(XRD1, type = "l")
lines(XRD_mean, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='signal_shift'>Shift the X Scale</h2><span id='topic+signal_shift'></span><span id='topic+signal_shift-method'></span><span id='topic+signal_shift+2Cnumeric+2Cnumeric-method'></span><span id='topic+signal_shift+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Shifts the <code>x</code> scale by a given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_shift(x, y, lag, ...)

## S4 method for signature 'numeric,numeric'
signal_shift(x, y, lag)

## S4 method for signature 'ANY,missing'
signal_shift(x, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_shift_+3A_x">x</code>, <code id="signal_shift_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="signal_shift_+3A_lag">lag</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the offset.</p>
</td></tr>
<tr><td><code id="signal_shift_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other signal processing methods: 
<code><a href="#topic+signal_bind">signal_bind</a>()</code>,
<code><a href="#topic+signal_correct">signal_correct</a>()</code>,
<code><a href="#topic+signal_drift">signal_drift</a>()</code>,
<code><a href="#topic+signal_mean">signal_mean</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## X-ray diffraction
data("XRD")

## Plot spectrum
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Shift by one degree
XRD_offset &lt;- signal_shift(XRD, lag = 1)
lines(XRD_offset, type = "l", col = "red")
</code></pre>

<hr>
<h2 id='smooth_likelihood'>Penalized Likelihood Smoothing</h2><span id='topic+smooth_likelihood'></span><span id='topic+smooth_likelihood-method'></span><span id='topic+smooth_likelihood+2Cnumeric+2Cnumeric-method'></span><span id='topic+smooth_likelihood+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Penalized Likelihood Smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_likelihood(x, y, ...)

## S4 method for signature 'numeric,numeric'
smooth_likelihood(x, y, lambda, d = 2, SE = FALSE, progress = interactive())

## S4 method for signature 'ANY,missing'
smooth_likelihood(x, lambda, d = 2, SE = FALSE, progress = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_likelihood_+3A_x">x</code>, <code id="smooth_likelihood_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_likelihood_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="smooth_likelihood_+3A_lambda">lambda</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the smoothing parameter. The larger
<code>lambda</code> is, the smoother the curve.</p>
</td></tr>
<tr><td><code id="smooth_likelihood_+3A_d">d</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the order of the penalty.</p>
</td></tr>
<tr><td><code id="smooth_likelihood_+3A_se">SE</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should standard errors be returned?</p>
</td></tr>
<tr><td><code id="smooth_likelihood_+3A_progress">progress</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a progress bar be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p><span class="pkg">Matrix</span> is required.
</p>


<h3>Author(s)</h3>

<p>J. J. de Rooi <em>et al.</em> (original R code).
</p>


<h3>References</h3>

<p>de Rooi, J. J., van der Pers, N. M., Hendrikx, R. W. A., Delhez, R.,
Böttger A. J. and Eilers, P. H. C. (2014). Smoothing of X-ray diffraction
data and Ka2 elimination using penalized likelihood and the composite link
model. <em>Journal of Applied Crystallography</em>, 47: 852-860.
<a href="https://doi.org/10.1107/S1600576714005809">doi:10.1107/S1600576714005809</a>
</p>


<h3>See Also</h3>

<p>Other smoothing methods: 
<code><a href="#topic+smooth_loess">smooth_loess</a>()</code>,
<code><a href="#topic+smooth_rectangular">smooth_rectangular</a>()</code>,
<code><a href="#topic+smooth_savitzky">smooth_savitzky</a>()</code>,
<code><a href="#topic+smooth_triangular">smooth_triangular</a>()</code>,
<code><a href="#topic+smooth_whittaker">smooth_whittaker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## X-ray diffraction
data("XRD")

## Subset from 20 to 40 degrees
XRD &lt;- signal_select(XRD, from = 20, to = 40)

## Plot diffractogram
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")

## Penalized likelihood smoothing
lambda &lt;- seq(from = 1, to = 8, length.out = 40)
lambda &lt;- 10^lambda

likelihood &lt;- smooth_likelihood(XRD, lambda = lambda, d = 3)
lines(likelihood, col = "red")

## Strip ka2
ka2 &lt;- ka2_strip_penalized(XRD, lambda = lambda, tau = 0.5, nseg = 1)
lines(ka2, col = "blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='smooth_loess'>Loess Smoothing</h2><span id='topic+smooth_loess'></span><span id='topic+smooth_loess-method'></span><span id='topic+smooth_loess+2Cnumeric+2Cnumeric-method'></span><span id='topic+smooth_loess+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Smoothes intensities by loess fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_loess(x, y, ...)

## S4 method for signature 'numeric,numeric'
smooth_loess(x, y, span = 0.75, ...)

## S4 method for signature 'ANY,missing'
smooth_loess(x, span = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_loess_+3A_x">x</code>, <code id="smooth_loess_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_loess_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to <code><a href="stats.html#topic+loess">stats::loess()</a></code>.</p>
</td></tr>
<tr><td><code id="smooth_loess_+3A_span">span</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the degree of smoothing (see
<code><a href="stats.html#topic+loess">stats::loess()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other smoothing methods: 
<code><a href="#topic+smooth_likelihood">smooth_likelihood</a>()</code>,
<code><a href="#topic+smooth_rectangular">smooth_rectangular</a>()</code>,
<code><a href="#topic+smooth_savitzky">smooth_savitzky</a>()</code>,
<code><a href="#topic+smooth_triangular">smooth_triangular</a>()</code>,
<code><a href="#topic+smooth_whittaker">smooth_whittaker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with some noise
x &lt;- seq(-4, 4, length = 100)
y &lt;- dnorm(x) + rnorm(100, mean = 0, sd = 0.01)

## Plot spectrum
plot(x, y, type = "l", xlab = "", ylab = "")

## Rectangular smoothing
unweighted &lt;- smooth_rectangular(x, y, m = 3)
plot(unweighted, type = "l", xlab = "", ylab = "")

## Triangular smoothing
weighted &lt;- smooth_triangular(x, y, m = 5)
plot(weighted, type = "l", xlab = "", ylab = "")

## Loess smoothing
loess &lt;- smooth_loess(x, y, span = 0.75)
plot(loess, type = "l", xlab = "", ylab = "")

## Savitzky–Golay filter
savitzky &lt;- smooth_savitzky(x, y, m = 21, p = 2)
plot(savitzky, type = "l", xlab = "", ylab = "")

## Whittaker smoothing
whittaker &lt;- smooth_whittaker(x, y, lambda = 1600, d = 2)
plot(whittaker, type = "l", xlab = "", ylab = "")
</code></pre>

<hr>
<h2 id='smooth_rectangular'>Rectangular Smoothing</h2><span id='topic+smooth_rectangular'></span><span id='topic+smooth_rectangular-method'></span><span id='topic+smooth_rectangular+2Cnumeric+2Cnumeric-method'></span><span id='topic+smooth_rectangular+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Unweighted sliding-average or rectangular Smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_rectangular(x, y, ...)

## S4 method for signature 'numeric,numeric'
smooth_rectangular(x, y, m = 3)

## S4 method for signature 'ANY,missing'
smooth_rectangular(x, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_rectangular_+3A_x">x</code>, <code id="smooth_rectangular_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_rectangular_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="smooth_rectangular_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size (i.e. the number of
adjacent points to be used; see <code><a href="#topic+window_sliding">window_sliding()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It replaces each point in the signal with the average of <code class="reqn">m</code> adjacent
points.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>There will be <code class="reqn">(m - 1) / 2</code> points both at the beginning and at the end
of the data series for which a complete <code class="reqn">m</code>-width window cannot be
obtained. To prevent data loss, progressively wider/narrower windows are
used at both ends of the data series.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other smoothing methods: 
<code><a href="#topic+smooth_likelihood">smooth_likelihood</a>()</code>,
<code><a href="#topic+smooth_loess">smooth_loess</a>()</code>,
<code><a href="#topic+smooth_savitzky">smooth_savitzky</a>()</code>,
<code><a href="#topic+smooth_triangular">smooth_triangular</a>()</code>,
<code><a href="#topic+smooth_whittaker">smooth_whittaker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with some noise
x &lt;- seq(-4, 4, length = 100)
y &lt;- dnorm(x) + rnorm(100, mean = 0, sd = 0.01)

## Plot spectrum
plot(x, y, type = "l", xlab = "", ylab = "")

## Rectangular smoothing
unweighted &lt;- smooth_rectangular(x, y, m = 3)
plot(unweighted, type = "l", xlab = "", ylab = "")

## Triangular smoothing
weighted &lt;- smooth_triangular(x, y, m = 5)
plot(weighted, type = "l", xlab = "", ylab = "")

## Loess smoothing
loess &lt;- smooth_loess(x, y, span = 0.75)
plot(loess, type = "l", xlab = "", ylab = "")

## Savitzky–Golay filter
savitzky &lt;- smooth_savitzky(x, y, m = 21, p = 2)
plot(savitzky, type = "l", xlab = "", ylab = "")

## Whittaker smoothing
whittaker &lt;- smooth_whittaker(x, y, lambda = 1600, d = 2)
plot(whittaker, type = "l", xlab = "", ylab = "")
</code></pre>

<hr>
<h2 id='smooth_savitzky'>Savitzky-Golay Filter</h2><span id='topic+smooth_savitzky'></span><span id='topic+smooth_savitzky-method'></span><span id='topic+smooth_savitzky+2Cnumeric+2Cnumeric-method'></span><span id='topic+smooth_savitzky+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Savitzky-Golay Filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_savitzky(x, y, ...)

## S4 method for signature 'numeric,numeric'
smooth_savitzky(x, y, m = 3, p = 2)

## S4 method for signature 'ANY,missing'
smooth_savitzky(x, m, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_savitzky_+3A_x">x</code>, <code id="smooth_savitzky_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_savitzky_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="smooth_savitzky_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size (i.e. the number of
adjacent points to be used).</p>
</td></tr>
<tr><td><code id="smooth_savitzky_+3A_p">p</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the degree of the polynomial to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is based on the least-squares fitting of polynomials to
segments of <code class="reqn">m</code> adjacent points.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>There will be <code class="reqn">(m - 1) / 2</code> points both at the beginning and at the end
of the data series for which a complete <code class="reqn">m</code>-width window cannot be
obtained. To prevent data loss, the original <code class="reqn">(m - 1) / 2</code> points at
both ends of the data series are preserved.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Gorry, P. A. (1990). General Least-Squares Smoothing and Differentiation by
the Convolution (Savitzky-Golay) Method. <em>Analytical Chemistry</em>, 62(6),
p. 570-573. <a href="https://doi.org/10.1021/ac00205a007">doi:10.1021/ac00205a007</a>.
</p>
<p>Savitzky, A. &amp; Golay, M. J. E. (1964). Smoothing and Differentiation of
Data by Simplified Least Squares Procedures. <em>Analytical Chemistry</em>,
36(8), p. 1627-1639. <a href="https://doi.org/10.1021/ac60214a047">doi:10.1021/ac60214a047</a>.
</p>


<h3>See Also</h3>

<p>Other smoothing methods: 
<code><a href="#topic+smooth_likelihood">smooth_likelihood</a>()</code>,
<code><a href="#topic+smooth_loess">smooth_loess</a>()</code>,
<code><a href="#topic+smooth_rectangular">smooth_rectangular</a>()</code>,
<code><a href="#topic+smooth_triangular">smooth_triangular</a>()</code>,
<code><a href="#topic+smooth_whittaker">smooth_whittaker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with some noise
x &lt;- seq(-4, 4, length = 100)
y &lt;- dnorm(x) + rnorm(100, mean = 0, sd = 0.01)

## Plot spectrum
plot(x, y, type = "l", xlab = "", ylab = "")

## Rectangular smoothing
unweighted &lt;- smooth_rectangular(x, y, m = 3)
plot(unweighted, type = "l", xlab = "", ylab = "")

## Triangular smoothing
weighted &lt;- smooth_triangular(x, y, m = 5)
plot(weighted, type = "l", xlab = "", ylab = "")

## Loess smoothing
loess &lt;- smooth_loess(x, y, span = 0.75)
plot(loess, type = "l", xlab = "", ylab = "")

## Savitzky–Golay filter
savitzky &lt;- smooth_savitzky(x, y, m = 21, p = 2)
plot(savitzky, type = "l", xlab = "", ylab = "")

## Whittaker smoothing
whittaker &lt;- smooth_whittaker(x, y, lambda = 1600, d = 2)
plot(whittaker, type = "l", xlab = "", ylab = "")
</code></pre>

<hr>
<h2 id='smooth_triangular'>Triangular Smoothing</h2><span id='topic+smooth_triangular'></span><span id='topic+smooth_triangular-method'></span><span id='topic+smooth_triangular+2Cnumeric+2Cnumeric-method'></span><span id='topic+smooth_triangular+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Weighted sliding-average or triangular smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_triangular(x, y, ...)

## S4 method for signature 'numeric,numeric'
smooth_triangular(x, y, m = 3)

## S4 method for signature 'ANY,missing'
smooth_triangular(x, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_triangular_+3A_x">x</code>, <code id="smooth_triangular_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_triangular_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="smooth_triangular_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size (i.e. the number of
adjacent points to be used; see <code><a href="#topic+window_sliding">window_sliding()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It replaces each point in the signal with the weighted mean of <code class="reqn">m</code>
adjacent points.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>There will be <code class="reqn">(m - 1) / 2</code> points both at the beginning and at the end
of the data series for which a complete <code class="reqn">m</code>-width window cannot be
obtained. To prevent data loss, progressively wider/narrower windows are
used at both ends of the data series.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other smoothing methods: 
<code><a href="#topic+smooth_likelihood">smooth_likelihood</a>()</code>,
<code><a href="#topic+smooth_loess">smooth_loess</a>()</code>,
<code><a href="#topic+smooth_rectangular">smooth_rectangular</a>()</code>,
<code><a href="#topic+smooth_savitzky">smooth_savitzky</a>()</code>,
<code><a href="#topic+smooth_whittaker">smooth_whittaker</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with some noise
x &lt;- seq(-4, 4, length = 100)
y &lt;- dnorm(x) + rnorm(100, mean = 0, sd = 0.01)

## Plot spectrum
plot(x, y, type = "l", xlab = "", ylab = "")

## Rectangular smoothing
unweighted &lt;- smooth_rectangular(x, y, m = 3)
plot(unweighted, type = "l", xlab = "", ylab = "")

## Triangular smoothing
weighted &lt;- smooth_triangular(x, y, m = 5)
plot(weighted, type = "l", xlab = "", ylab = "")

## Loess smoothing
loess &lt;- smooth_loess(x, y, span = 0.75)
plot(loess, type = "l", xlab = "", ylab = "")

## Savitzky–Golay filter
savitzky &lt;- smooth_savitzky(x, y, m = 21, p = 2)
plot(savitzky, type = "l", xlab = "", ylab = "")

## Whittaker smoothing
whittaker &lt;- smooth_whittaker(x, y, lambda = 1600, d = 2)
plot(whittaker, type = "l", xlab = "", ylab = "")
</code></pre>

<hr>
<h2 id='smooth_whittaker'>Whittaker Smoothing</h2><span id='topic+smooth_whittaker'></span><span id='topic+smooth_whittaker-method'></span><span id='topic+smooth_whittaker+2Cnumeric+2Cnumeric-method'></span><span id='topic+smooth_whittaker+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Whittaker Smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_whittaker(x, y, ...)

## S4 method for signature 'numeric,numeric'
smooth_whittaker(x, y, lambda = 1600, d = 2, sparse = FALSE)

## S4 method for signature 'ANY,missing'
smooth_whittaker(x, lambda = 1600, d = 2, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_whittaker_+3A_x">x</code>, <code id="smooth_whittaker_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="smooth_whittaker_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="smooth_whittaker_+3A_lambda">lambda</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the smoothing parameter. The larger
<code>lambda</code> is, the smoother the curve.</p>
</td></tr>
<tr><td><code id="smooth_whittaker_+3A_d">d</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the order of the penalty.</p>
</td></tr>
<tr><td><code id="smooth_whittaker_+3A_sparse">sparse</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should sparse matrices be used for
computation? If <code>TRUE</code>, <span class="pkg">Matrix</span> is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Eilers, P. H. C. (2003). A Perfect Smoother. <em>Analytical Chemistry</em>,
75(14): 3631-36. <a href="https://doi.org/10.1021/ac034173t">doi:10.1021/ac034173t</a>.
</p>


<h3>See Also</h3>

<p>Other smoothing methods: 
<code><a href="#topic+smooth_likelihood">smooth_likelihood</a>()</code>,
<code><a href="#topic+smooth_loess">smooth_loess</a>()</code>,
<code><a href="#topic+smooth_rectangular">smooth_rectangular</a>()</code>,
<code><a href="#topic+smooth_savitzky">smooth_savitzky</a>()</code>,
<code><a href="#topic+smooth_triangular">smooth_triangular</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with some noise
x &lt;- seq(-4, 4, length = 100)
y &lt;- dnorm(x) + rnorm(100, mean = 0, sd = 0.01)

## Plot spectrum
plot(x, y, type = "l", xlab = "", ylab = "")

## Rectangular smoothing
unweighted &lt;- smooth_rectangular(x, y, m = 3)
plot(unweighted, type = "l", xlab = "", ylab = "")

## Triangular smoothing
weighted &lt;- smooth_triangular(x, y, m = 5)
plot(weighted, type = "l", xlab = "", ylab = "")

## Loess smoothing
loess &lt;- smooth_loess(x, y, span = 0.75)
plot(loess, type = "l", xlab = "", ylab = "")

## Savitzky–Golay filter
savitzky &lt;- smooth_savitzky(x, y, m = 21, p = 2)
plot(savitzky, type = "l", xlab = "", ylab = "")

## Whittaker smoothing
whittaker &lt;- smooth_whittaker(x, y, lambda = 1600, d = 2)
plot(whittaker, type = "l", xlab = "", ylab = "")
</code></pre>

<hr>
<h2 id='subset'>Subset</h2><span id='topic+subset'></span><span id='topic+signal_select'></span><span id='topic+signal_select-method'></span><span id='topic+signal_slice'></span><span id='topic+signal_slice-method'></span><span id='topic+signal_select+2Cnumeric+2Cnumeric-method'></span><span id='topic+signal_select+2CANY+2Cmissing-method'></span><span id='topic+signal_slice+2Cnumeric+2Cnumeric-method'></span><span id='topic+signal_slice+2CANY+2Cmissing-method'></span>

<h3>Description</h3>


<ul>
<li> <p><code>signal_select()</code> allows to subset by values of <code>x</code>.
</p>
</li>
<li> <p><code>signal_slice()</code> allows to subset by position along <code>x</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>signal_select(x, y, ...)

signal_slice(x, y, ...)

## S4 method for signature 'numeric,numeric'
signal_select(x, y, from, to)

## S4 method for signature 'ANY,missing'
signal_select(x, from, to)

## S4 method for signature 'numeric,numeric'
signal_slice(x, y, subset)

## S4 method for signature 'ANY,missing'
signal_slice(x, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code>, <code id="subset_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="subset_+3A_from">from</code>, <code id="subset_+3A_to">to</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value giving the first and last value (in <code>x</code>
unit) to be selected.</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving either positive values to keep,
or negative values to drop. The values provided must be either all
positive or all negative (coerced to integer as by <code><a href="base.html#topic+as.integer">as.integer()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> with two components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other signal processing methods: 
<code><a href="#topic+signal_bind">signal_bind</a>()</code>,
<code><a href="#topic+signal_correct">signal_correct</a>()</code>,
<code><a href="#topic+signal_drift">signal_drift</a>()</code>,
<code><a href="#topic+signal_mean">signal_mean</a>()</code>,
<code><a href="#topic+signal_shift">signal_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gamma-ray spectrometry
data("BEGe")

## Plot spectrum
plot(BEGe, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Subset from 2.75 keV to 200 keV
BEGe_1 &lt;- signal_select(BEGe, from = 3, to = 200)

## Plot spectrum
plot(BEGe_1, type = "l", xlab = "Energy (keV)", ylab = "Count")

## Subset from the 20th to the 1250th value
BEGe_2 &lt;- signal_slice(BEGe, subset = 20:1250)

## Plot spectrum
plot(BEGe_2, type = "l", xlab = "Energy (keV)", ylab = "Count")
</code></pre>

<hr>
<h2 id='window_sliding'>Sliding Windows</h2><span id='topic+window_sliding'></span><span id='topic+window_sliding-method'></span><span id='topic+window_sliding+2Cinteger+2Cinteger-method'></span><span id='topic+window_sliding+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>There will be <code class="reqn">(m - 1) / 2</code> points both at the beginning and at the end
of the data series for which a complete <code class="reqn">m</code>-width window cannot be
obtained. To prevent data loss, progressively wider/narrower windows are
evaluated at both ends of the data series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_sliding(n, m, ...)

## S4 method for signature 'integer,integer'
window_sliding(n, m, i = NULL)

## S4 method for signature 'numeric,numeric'
window_sliding(n, m, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_sliding_+3A_n">n</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the length of the data series (will be coerced
with <code><a href="base.html#topic+as.integer">as.integer()</a></code> and hence truncated toward zero).</p>
</td></tr>
<tr><td><code id="window_sliding_+3A_m">m</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the window size, i.e. the number of
adjacent points to be used (will be coerced with <code><a href="base.html#topic+as.integer">as.integer()</a></code> and hence
truncated toward zero).</p>
</td></tr>
<tr><td><code id="window_sliding_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="window_sliding_+3A_i">i</code></td>
<td>
<p>A vector <code><a href="base.html#topic+integer">integer</a></code> specifying the indices of the data points for
which windows should be returned. If <code>NULL</code> (the default), windows are
evaluated for each data point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a length-<code class="reqn">n</code> <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+integer">integer</a></code> vectors (indices of the
data points in each window).
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other moving windows: 
<code><a href="#topic+window_tumbling">window_tumbling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Length of the data series
n &lt;- 10

## Progressive sliding windows
sliding &lt;- window_sliding(n = n, m = 5)

plot(NULL, xlim = c(1, n), ylim = c(1, 10.5), xlab = "Index", ylab = "Window")
for (i in seq_along(sliding)) {
  w &lt;- sliding[[i]]
  text(x = w, y = rep(i, length(w)), labels = w, pos = 3)
  lines(w, rep(i, length(w)), type = "l", lwd = 2)
}

## Tumbling windows
## (compare with drop = TRUE)
tumbling &lt;- window_tumbling(n = n, m = 3, drop = FALSE)

plot(NULL, xlim = c(1, n), ylim = c(1, 5.5), xlab = "Index", ylab = "Window")
for (i in seq_along(tumbling)) {
  w &lt;- tumbling[[i]]
  text(x = w, y = rep(i, length(w)), labels = w, pos = 3)
  lines(w, rep(i, length(w)), type = "l", lwd = 2)
}

</code></pre>

<hr>
<h2 id='window_tumbling'>Tumbling Windows</h2><span id='topic+window_tumbling'></span><span id='topic+window_tumbling-method'></span><span id='topic+window_tumbling+2Cinteger+2Cinteger-method'></span><span id='topic+window_tumbling+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Tumbling Windows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_tumbling(n, m, ...)

## S4 method for signature 'integer,integer'
window_tumbling(n, m, drop = FALSE)

## S4 method for signature 'numeric,numeric'
window_tumbling(n, m, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_tumbling_+3A_n">n</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the length of the data series (will be coerced
with <code><a href="base.html#topic+as.integer">as.integer()</a></code> and hence truncated toward zero).</p>
</td></tr>
<tr><td><code id="window_tumbling_+3A_m">m</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the window size, i.e. the number of
adjacent points to be used (will be coerced with <code><a href="base.html#topic+as.integer">as.integer()</a></code> and hence
truncated toward zero).</p>
</td></tr>
<tr><td><code id="window_tumbling_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="window_tumbling_+3A_drop">drop</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: if <code>m</code> is not a multiple of <code>n</code>, should the
last data points be removed so that all windows have the same length?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+integer">integer</a></code> vectors (indices of the data points in
each window).
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other moving windows: 
<code><a href="#topic+window_sliding">window_sliding</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Length of the data series
n &lt;- 10

## Progressive sliding windows
sliding &lt;- window_sliding(n = n, m = 5)

plot(NULL, xlim = c(1, n), ylim = c(1, 10.5), xlab = "Index", ylab = "Window")
for (i in seq_along(sliding)) {
  w &lt;- sliding[[i]]
  text(x = w, y = rep(i, length(w)), labels = w, pos = 3)
  lines(w, rep(i, length(w)), type = "l", lwd = 2)
}

## Tumbling windows
## (compare with drop = TRUE)
tumbling &lt;- window_tumbling(n = n, m = 3, drop = FALSE)

plot(NULL, xlim = c(1, n), ylim = c(1, 5.5), xlab = "Index", ylab = "Window")
for (i in seq_along(tumbling)) {
  w &lt;- tumbling[[i]]
  text(x = w, y = rep(i, length(w)), labels = w, pos = 3)
  lines(w, rep(i, length(w)), type = "l", lwd = 2)
}

</code></pre>

<hr>
<h2 id='XRD'>Powder X-ray Diffraction</h2><span id='topic+XRD'></span>

<h3>Description</h3>

<p>Powder X-ray Diffraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XRD
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 2989 rows and 2 variables.
</p>

<dl>
<dt>theta</dt><dd></dd>
<dt>count</dt><dd></dd>
</dl>



<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+BEGe">BEGe</a></code>,
<code><a href="#topic+LaBr">LaBr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("XRD")
plot(XRD, type = "l", xlab = expression(2*theta), ylab = "Count")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
