<!DOCTYPE html><html><head><title>Help for package ggsector</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggsector}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#draw_key_sector'><p>draw_key_sector</p></a></li>
<li><a href='#GeomSectorPanel'><p>ggplot sector</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sector_df'><p>sector coordinates</p></a></li>
<li><a href='#sectorGrob'><p>Draw sector with grid</p></a></li>
<li><a href='#SectorPlot'><p>Draw sector for seurat object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Draw Sectors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Some useful functions that can use 'grid' and 'ggplot2' to plot sectors and interact with 'Seurat' to plot gene expression percentages. Also, there are some examples of how to draw sectors in 'ComplexHeatmap'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ComplexHeatmap, knitr, rmarkdown, reshape2, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2, grid</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, Matrix, prettydoc, rlang, Seurat, stats,
tibble, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yanpd01/ggsector">https://github.com/yanpd01/ggsector</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-05 13:01:14 UTC; yan</td>
</tr>
<tr>
<td>Author:</td>
<td>Pengdong Yan <a href="https://orcid.org/0000-0002-2425-7930"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pengdong Yan &lt;yanpd01@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='draw_key_sector'>draw_key_sector</h2><span id='topic+draw_key_sector'></span>

<h3>Description</h3>

<p>draw_key_sector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_key_sector(data, params, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_key_sector_+3A_data">data</code></td>
<td>
<p>A single row data frame containing the scaled aesthetics to
display in this key</p>
</td></tr>
<tr><td><code id="draw_key_sector_+3A_params">params</code></td>
<td>
<p>A list of additional parameters supplied to the geom.</p>
</td></tr>
<tr><td><code id="draw_key_sector_+3A_size">size</code></td>
<td>
<p>Width and height of key in mm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot legend
</p>

<hr>
<h2 id='GeomSectorPanel'>ggplot sector</h2><span id='topic+GeomSectorPanel'></span><span id='topic+GeomSectorIndividual'></span><span id='topic+geom_sector'></span>

<h3>Description</h3>

<p>Draw sector with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_sector(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  individual = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeomSectorPanel_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_individual">individual</code></td>
<td>
<p>Logical, default is FALSE.
When &quot;individual=FALSE&quot;, draw very quickly with a vector form,
when &quot;individual=TRUE&quot;, draw individually at a slower speed.
Anyway, for better presentation, please add coord_fixed().</p>
</td></tr>
<tr><td><code id="GeomSectorPanel_+3A_verbose">verbose</code></td>
<td>
<p>Logical, default is TRUE. Whether to display reminder information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When &quot;individual=FALSE&quot;, draw very quickly with a vector form,
when &quot;individual=TRUE&quot;, draw individually at a slower speed.
</p>
<p>The required parameters in mapping are &quot;x&quot;, &quot;y&quot;, &quot;theta&quot;, and
the additional modifiable parameters are &quot;r&quot;, &quot;start&quot;, &quot;r_start&quot;, &quot;type&quot;, &quot;colour&quot;, &quot;fill&quot;, &quot;ratio&quot;, &quot;size&quot; for line size, &quot;linetype&quot;.
</p>
<p>When there is coord_fixed(), r = 0.5 means that the sector-shaped
background circle just fills the entire cell
</p>
<p>The <code>ratio</code> parameter is still an experimental parameter,
if it is not necessary, please do not set it yourself.
The <code>ratio</code> parameter only works when <code>individual = FALSE</code>.
When <code>ratio</code> is null, it will be auto calculated.
</p>
<p>For better display effect, please always  add <code>coord_fixed()</code>.
</p>
<p>For details, please check the <code><a href="#topic+grid.sector">grid.sector()</a></code>.
</p>
<p>For more details, please type <code>vignette("ggsector")</code>.
</p>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## prepare data
library(ggsector)
library(reshape2)
df &lt;- cor(mtcars)[1:3, 1:5] %&gt;%
    abs() %&gt;%
    melt(varnames = c("x", "y"))

###
## Note, for better display effect, please always add coord_fixed()
## Note, for better display effect, please always add coord_fixed()
## Note, for better display effect, please always add coord_fixed()

## theta
ggplot(df) +
    ## type = "percent", theta = 0-100
    geom_sector(
        aes(y, x, theta = value * 100),
        type = "percent",
        color = "blue",
        individual = TRUE
    ) +
    ## type = "degree", theta = 0-360
    geom_sector(
        aes(y, x, theta = value * 360),
        type = "degree",
        color = "red",
        alpha = 0.5,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

## r
ggplot(df) +
    geom_sector(
        aes(y, x, theta = value * 100),
        r = rep(c(0.15, 0.3, 0.45), 5),
        fill = 2,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

## start
ggplot(df) +
    geom_sector(
        aes(y, x, theta = value * 100),
        start = rep(c(60, 40, 20), 5),
        fill = 2,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

## r_start
ggplot(df) +
    geom_sector(
        aes(y, x, theta = value * 100),
        r_start = rep(c(0.15, 0.25, 0.35), 5),
        fill = 2,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())


####################  individual ###################
##########  individual with coord_fixed() ##########

## `individual = TRUE` + coord_fixed()
# x = x, y = y
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(x, y),
        theta = 75,
        fill = 2,
        r = 0.5,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

# x = y, y =x
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(y, x),
        theta = 75,
        fill = 2,
        r = 0.5,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

## `individual = FALSE` + coord_fixed()
# x = x, y = y
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(x, y),
        theta = 75,
        fill = 2,
        r = 0.5,
        individual = FALSE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

# x = y, y =x
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(y, x),
        theta = 75,
        fill = 2,
        r = 0.5,
        individual = TRUE
    ) +
    coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())

##########  individual without coord_fixed() ##########
## If you are in a special situation and cannot use coord_fixed(),
## then it is recommended that you use `individual = TRUE` and
## the `r` parameter to fine-tune.
## Also, to reduce the radius, you need to try it manually.

## `individual = TRUE` without coord_fixed()
# x = x, y = y
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(x, y),
        theta = 75,
        fill = 2,
        r = 0.35, ## To reduce the radius, you need to try it manually
        individual = TRUE
    ) +
    theme_bw() +
    theme(axis.title = element_blank())

# x = y, y =x
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(y, x),
        theta = 75,
        fill = 2,
        r = 0.25, ## To reduce the radius, you need to try it manually
        individual = TRUE
    ) +
    theme_bw() +
    theme(axis.title = element_blank())

## `individual = FALSE`
## If you really want to use `individual = FALSE` without coord_fixed(),
## you might try the experimental parameter `ratio'
## You need to manually adjust the `ratio` value
## to prevent sector deformation.
# x = x, y = y
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(x, y),
        theta = 75,
        fill = 2,
        r = 0.5,
        ## You need to manually adjust the `ratio` value
        ## to prevent sector deformation.
        ratio = 1.6,
        individual = FALSE
    ) +
    theme_bw() +
    theme(axis.title = element_blank())

# x = y, y =x
ggplot(rbind(
    cbind(df, t1 = 1),
    cbind(df[1:9, ], t1 = 2)
)) +
    facet_wrap(~t1, ncol = 2) +
    geom_sector(
        aes(y, x),
        theta = 75,
        fill = 2,
        r = 0.5,
        ## You need to manually adjust the `ratio` value
        ## to prevent sector deformation.
        ratio = 1.6,
        individual = FALSE
    ) +
    # coord_fixed() +
    theme_bw() +
    theme(axis.title = element_blank())


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic++25+7C+7C+25'></span><span id='topic+html_pretty'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>prettydoc</dt><dd><p><code><a href="prettydoc.html#topic+html_pretty">html_pretty</a></code></p>
</dd>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+op-null-default">%||%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sector_df'>sector coordinates</h2><span id='topic+sector_df'></span><span id='topic+sector_df_multiple'></span>

<h3>Description</h3>

<p>According to the input center position, radius and angle,
get the polygon coordinates of a sector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sector_df(
  x = 0.5,
  y = 0.5,
  theta = 25,
  r = 0.5,
  start = 0,
  r_start = 0,
  type = "percent",
  ratio = 1
)

sector_df_multiple(
  x = 0.5,
  y = 0.5,
  theta = 25,
  r = 0.5,
  start = 0,
  r_start = 0,
  type = "percent",
  ratio = 1,
  group
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sector_df_+3A_x">x</code></td>
<td>
<p>Numeric, the x-axis coordinate of the sector center.</p>
</td></tr>
<tr><td><code id="sector_df_+3A_y">y</code></td>
<td>
<p>Numeric, the y-axis coordinate of the sector center.</p>
</td></tr>
<tr><td><code id="sector_df_+3A_theta">theta</code></td>
<td>
<p>Numeric, the angle of the sector,
if 'type = &quot;percent&quot;', the input is a percentage(0-100),
if 'type = &quot;degree&quot;', the input is an angle(0-360).</p>
</td></tr>
<tr><td><code id="sector_df_+3A_r">r</code></td>
<td>
<p>Numeric, radius of the outer circle of the sector(0-0.5).</p>
</td></tr>
<tr><td><code id="sector_df_+3A_start">start</code></td>
<td>
<p>Numeric, starting angle of sector.</p>
</td></tr>
<tr><td><code id="sector_df_+3A_r_start">r_start</code></td>
<td>
<p>Numeric, radius of the inner circle of the sector(0-r).</p>
</td></tr>
<tr><td><code id="sector_df_+3A_type">type</code></td>
<td>
<p>&quot;percent&quot;, &quot;degree&quot; or an integer (preferably greater than 50),
represents the number of scattered points on the circle where the sector is drawn.
When <code>type = "percent"</code>, the circumference of the circle where the sector is
located is composed of 100 scattered points;
when <code>type = "degree"</code>, the circumference of the circle where the sector is
located is composed of 360 scattered points;
when <code>type = 150</code>, the circumference of the circle where the sector is
located is composed of 150 scattered points.</p>
</td></tr>
<tr><td><code id="sector_df_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio, expressed as <code>y / x</code>.</p>
</td></tr>
<tr><td><code id="sector_df_+3A_group">group</code></td>
<td>
<p>A numeric vector used to separate locations in x and y into multiple sectors.
If missing, it will be automatically added as a number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+sector_df">sector_df()</a></code> Only one value can be passed in for each parameter,
and a sector coordinate is returned.
</p>
<p><code><a href="#topic+sector_df_multiple">sector_df_multiple()</a></code> Each parameter can pass in multiple values,
and return multiple sector coordinates
</p>
<p>The value of the 'type' parameter is &quot;percent&quot;, &quot;degree&quot; or an integer (preferably greater than 50),
represents the number of scattered points on the circle where the sector is drawn.
When type = &quot;percent&quot;, the circumference of the circle where the sector is
located is composed of 100 scattered points;
when type = &quot;degree&quot;, the circumference of the circle where the sector is
located is composed of 360 scattered points
</p>
<p>For more details, please type <code>vignette("ggsector")</code>.
</p>


<h3>Value</h3>

<p>coordinates of sector.
</p>
<p>coordinates of sectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## coordinates of single sector
# type of percent, start = 0, r_start = 0
tmp_df &lt;- sector_df(x = 0.5, y = 0.5, theta = 25, r = 0.4, start = 0, r_start = 0)
tmp_df
grid.newpage()
grid.polygon(
    tmp_df$x, tmp_df$y,
    vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc"))
)
# type of percent, start = 50, r_start = 0.2
tmp_df &lt;- sector_df(x = 0.5, y = 0.5, theta = 25, r = 0.4, start = 50, r_start = 0.2)
tmp_df
grid.newpage()
grid.polygon(
    tmp_df$x, tmp_df$y,
    vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc"))
)

# type of degree, start = 90, r_start = 0
tmp_df &lt;- sector_df(
    x = 0.5, y = 0.5, theta = 180, r = 0.4,
    start = 90, r_start = 0, type = "degree"
)
tmp_df
grid.newpage()
grid.polygon(
    tmp_df$x, tmp_df$y,
    vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc"))
)
# type of degree, start = 180, r_start = 0.2
tmp_df &lt;- sector_df(
    x = 0.5, y = 0.5, theta = 180, r = 0.4,
    start = 270, r_start = 0.2, type = "degree"
)
tmp_df
grid.newpage()
grid.polygon(
    tmp_df$x, tmp_df$y,
    vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc"))
)

## Coordinates of Multiple Sectors
tmp_df &lt;- sector_df_multiple(
    x = c(0.2, 0.5, 0.8),
    theta = c(25, 50, 75),
    r = 0.15,
    start = c(75, 50, 100),
    r_start = c(0, 0.05, 0.1),
    type = "percent"
)
tmp_df
grid.newpage()
grid.polygon(
    tmp_df$x,
    tmp_df$y,
    id = tmp_df$group,
    vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc")),
    gp = gpar(
        fill = 3:1, col = 1:3
    )
)

# type = 10, 100, 1000
tmp_df &lt;- sector_df_multiple(
    x = c(0.25, 0.5, 0.75),
    theta = c(7.5, 75, 750),
    r = 0.125,
    r_start = c(0.05),
    type = c(c(10, "percent", 1000))
)
tmp_df
grid.newpage()
grid.polygon(
    tmp_df$x,
    tmp_df$y,
    id = tmp_df$group,
    vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc")),
    gp = gpar(
        fill = 3:1, col = 1:3
    )
)
</code></pre>

<hr>
<h2 id='sectorGrob'>Draw sector with grid</h2><span id='topic+sectorGrob'></span><span id='topic+grid.sector'></span>

<h3>Description</h3>

<p><code><a href="#topic+sectorGrob">sectorGrob()</a></code> return a polygon grob. <code><a href="#topic+grid.sector">grid.sector()</a></code> draw sector.
For more details, please type <code>vignette("ggsector")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sectorGrob(
  x = 0.5,
  y = 0.5,
  theta = 25,
  r = 0.5,
  start = 0,
  r_start = 0,
  type = "percent",
  ratio = 1,
  group,
  default.units = "npc",
  vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc")),
  gp = gpar(col = "black", fill = "transparent")
)

grid.sector(
  x = 0.5,
  y = 0.5,
  theta = 25,
  r = 0.5,
  start = 0,
  r_start = 0,
  type = "percent",
  ratio = 1,
  group,
  default.units = "npc",
  vp = viewport(height = unit(1, "snpc"), width = unit(1, "snpc")),
  gp = gpar(col = "black", fill = "transparent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sectorGrob_+3A_x">x</code></td>
<td>
<p>Numeric, the x-axis coordinate of the sector center.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_y">y</code></td>
<td>
<p>Numeric, the y-axis coordinate of the sector center.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_theta">theta</code></td>
<td>
<p>Numeric, the angle of the sector,
if 'type = &quot;percent&quot;', the input is a percentage(0-100),
if 'type = &quot;degree&quot;', the input is an angle(0-360).</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_r">r</code></td>
<td>
<p>Numeric, radius of the outer circle of the sector(0-0.5).</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_start">start</code></td>
<td>
<p>Numeric, starting angle of sector.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_r_start">r_start</code></td>
<td>
<p>Numeric, radius of the inner circle of the sector(0-r).</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_type">type</code></td>
<td>
<p>&quot;percent&quot;, &quot;degree&quot; or an integer (preferably greater than 50),
represents the number of scattered points on the circle where the sector is drawn.
When <code>type = "percent"</code>, the circumference of the circle where the sector is
located is composed of 100 scattered points;
when <code>type = "degree"</code>, the circumference of the circle where the sector is
located is composed of 360 scattered points;
when <code>type = 150</code>, the circumference of the circle where the sector is
located is composed of 150 scattered points.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio, expressed as <code>y / x</code>.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_group">group</code></td>
<td>
<p>A numeric vector used to separate locations in x and y into multiple sectors.
If missing, it will be automatically added as a number.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="sectorGrob_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>polygon grob
</p>
<p>draw sector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Draw basic grid

# sectorGrob with units of "cm" and type of "degree"
grid.newpage()
gp &lt;- sectorGrob(
    x = unit(c(3, 9, 15), "cm"),
    y = unit(c(5, 9, 15), "cm"),
    theta = c(90, 180, 270),
    r = 1,
    start = c(180, 180, 270),
    r_start = c(0.6, 0.3, 0),
    type = "degree",
    group = factor(1:3, levels = c(2, 3, 1)),
    gp = gpar(fill = c("green", "red", "blue"))
)
grid.draw(gp)

# grid.sector with units of "npc" and type of "percent"
grid.newpage()
grid.sector(
    x = c(0.1, 0.5, 0.9),
    y = c(0.9, 0.6, 0.1),
    theta = c(25, 50, 90),
    r = .1,
    start = c(25, 50, 100),
    r_start = c(0.06, 0.03, 0),
    type = "percent",
    group = factor(1:3, levels = c(2, 3, 1)),
    gp = gpar(col = c("green", "red", "blue"), fill = 2:4),
    default.units = "npc"
)


## Draw sector with ComplexHeatmap

# prepare data
library(magrittr)
library(ComplexHeatmap)
t0 &lt;- cor(mtcars) %&gt;%
    set_colnames(paste("y_", colnames(.))) %&gt;%
    set_rownames(paste("x_", rownames(.)))
mat &lt;- abs(t0)
mat[1:5, 1:5]

# Realized by modifying the [grid::viewport()],
# the sector can be set with a fixed width and height
set.seed(1)
Heatmap(
    mat,
    name = "vp",
    rect_gp = gpar(type = "none"),
    cell_fun = function(j, i, x, y, width, height, fill) {
        grid.rect(
            x = x, y = y, width = width, height = height,
            gp = gpar(col = "grey", fill = NA)
        )
        grid.sector(
            theta = mat[i, j] * 100,
            r = 0.5,
            start = mat[i, j] * 100 * runif(1),
            r_start = mat[i, j] * 0.49 * runif(1),
            vp = viewport(x, y, width, height),
            gp = gpar(fill = fill, col = "transparent")
        )
    },
    width = unit(.7, "snpc"),
    height = unit(.7, "snpc")
)

# Realized in the form of coordinates + radius.
# The default viewport locks the horizontal and vertical axes
# so that the sector does not deform, which needs to be removed here.
# The radius 'r' is half the min(length, width).
set.seed(2)
Heatmap(
    mat,
    name = "xy + r",
    rect_gp = gpar(type = "none"),
    cell_fun = function(j, i, x, y, width, height, fill) {
        grid.rect(
            x = x, y = y, width = width, height = height,
            gp = gpar(col = "grey", fill = NA)
        )
        r &lt;- as.numeric(min(width, height)) / 2
        grid.sector(
            x,
            y,
            theta = mat[i, j] * 100,
            r = r,
            start = mat[i, j] * 100 * runif(1),
            r_start = mat[i, j] * r * 0.9 * runif(1),
            vp = NULL,
            gp = gpar(fill = fill, col = "transparent")
        )
    },
    width = unit(.7, "snpc"),
    height = unit(.7, "snpc")
)

# layer full
# The input matrix needs to be extracted with pindex(mat, i, j)
set.seed(3)
Heatmap(
    mat,
    name = "layer",
    rect_gp = gpar(type = "none"),
    layer_fun = function(j, i, x, y, width, height, fill) {
        grid.rect(
            x = x, y = y, width = width, height = height,
            gp = gpar(col = "grey", fill = NA)
        )
        r &lt;- as.numeric(min(width, height)) / 2
        grid.sector(
            x,
            y,
            theta = pindex(mat, i, j) * 100,
            r = r,
            start = pindex(mat, i, j) * 100 * runif(nrow(mat) * ncol(mat)),
            r_start = pindex(mat, i, j) * r * 0.9 * runif(nrow(mat) * ncol(mat)),
            vp = NULL,
            gp = gpar(fill = fill, col = "transparent")
        )
    },
    width = unit(.7, "snpc"),
    height = unit(.7, "snpc")
)


</code></pre>

<hr>
<h2 id='SectorPlot'>Draw sector for seurat object</h2><span id='topic+SectorPlot'></span>

<h3>Description</h3>

<p>A better alternative to <code><a href="Seurat.html#topic+DotPlot">Seurat::DotPlot()</a></code>.
For more details, please type <code>vignette("ggsector")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SectorPlot(
  object,
  features,
  features.level,
  assay,
  slot = c("data", "scale.data", "counts"),
  group.by,
  group.level,
  split.by,
  split.level,
  col_low = "blue",
  col_mid = "white",
  col_high = "red",
  col_midpoint,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SectorPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_features">features</code></td>
<td>
<p>Input vector of genes list.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_features.level">features.level</code></td>
<td>
<p>Levels of genes list.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_assay">assay</code></td>
<td>
<p>Specific assay to get data from or set data for; defaults to the default assay.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_slot">slot</code></td>
<td>
<p>Specific assay data to get or set.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_group.by">group.by</code></td>
<td>
<p>Column of metadata to group the cells by, default is Idents().</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_group.level">group.level</code></td>
<td>
<p>Levels of group.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_split.by">split.by</code></td>
<td>
<p>Column of metadata to split the cells by, default is NULL.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_split.level">split.level</code></td>
<td>
<p>Levels of split vars.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_col_low">col_low</code></td>
<td>
<p>Colours for low ends of the gradient.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_col_mid">col_mid</code></td>
<td>
<p>Colour for mid point.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_col_high">col_high</code></td>
<td>
<p>Colours for high ends of the gradient.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_col_midpoint">col_midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.</p>
</td></tr>
<tr><td><code id="SectorPlot_+3A_...">...</code></td>
<td>
<p>Other arguments for <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>.
Defaults to quantile(exp, 0.5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Download pbmc data from
# https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz
library(Seurat)
path &lt;- paste0(tempdir(), "/pbmc3k.tar.gz")
file &lt;- paste0(tempdir(), "/filtered_gene_bc_matrices/hg19")
download.file(
    "https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz",
    path
)
untar(path, exdir = tempdir())
pbmc.data &lt;- Read10X(data.dir = file)
pbmc &lt;- CreateSeuratObject(
    counts = pbmc.data,
    project = "pbmc3k",
    min.cells = 3,
    min.features = 200
)
pbmc &lt;- NormalizeData(pbmc)
pbmc &lt;- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
pbmc &lt;- ScaleData(pbmc, features = rownames(pbmc))
pbmc &lt;- RunPCA(pbmc)
pbmc &lt;- RunUMAP(pbmc, dim = 1:10)
pbmc &lt;- FindNeighbors(pbmc, dims = 1:10)
pbmc &lt;- FindClusters(pbmc, resolution = 1)
pbmc &lt;- FindClusters(pbmc, resolution = 0.5)
markers &lt;- tibble::tribble(
    ~type, ~marker,
    "Naive CD4+ T", "IL7R,CCR7",
    "CD14+ Mono", "CD14,LYZ",
    "Memory CD4+", "IL7R,S100A4",
    "B", "MS4A1",
    "CD8+ T", "CD8A",
    "FCGR3A+ Mono", "FCGR3A,MS4A7",
    "NK", "GNLY,NKG7",
    "DC", "FCER1A,CST3",
    "Platelet", "PPBP",
) %&gt;%
    tidyr::separate_rows(marker, sep = ", *") %&gt;%
    dplyr::distinct()

# Dotplot
DotPlot(pbmc, features = unique(markers$marker)) + coord_flip()

# contrast with DotPlot
SectorPlot(pbmc, markers$marker, features.level = unique(rev(markers$marker)))

SectorPlot(pbmc, markers$marker, group.by = "RNA_snn_res.1")

# split plot
# Assume a variable 'day', expressed as the number of days of cell development.
set.seed(1)
pbmc[["day"]] &lt;- sample(1:3, ncol(pbmc), TRUE)
SectorPlot(pbmc, markers$marker, group.by = "RNA_snn_res.0.5", split.by = "day")
SectorPlot(
    pbmc, markers$marker,
    group.by = "day", split.by = "RNA_snn_res.0.5", nrow = 1
)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
