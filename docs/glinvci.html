<!DOCTYPE html><html lang="en"><head><title>Help for package glinvci</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glinvci}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#glinvci'><p>glinvci: Confidence intervals and hypothesis testing for GLInv model</p></a></li>
<li><a href='#clone_model'><p>Clone a GLInv model</p></a></li>
<li><a href='#fit.glinv'><p>Fitting a GLInv model via numerical optimisation</p></a></li>
<li><a href='#get_restricted_ou'><p>Convenience function for constructing restricted/reparameterised OU parameterisation function.</p></a></li>
<li><a href='#glinv'><p>Construct an GLInv model with respect to user-specified parametrisation</p></a></li>
<li><a href='#glinv_gauss'><p>Construct an object representing a GLInv model with respect to the underlying Gaussian process parameters.</p></a></li>
<li><a href='#grad'><p>Compute the log-likelihood gradients of GLInv models</p></a></li>
<li><a href='#has_tipvals'><p>Check if a <code>glinv_gauss</code> model contains trait values at their tips.</p></a></li>
<li><a href='#hess'><p>Compute the log-likelihood Hessian of GLInv models</p></a></li>
<li><a href='#lik'><p>Compute the likelihood of a GLInv model</p></a></li>
<li><a href='#marginal_ci'><p>Getting marginal confidence interval for GLInv model</p></a></li>
<li><a href='#nparams_ou'><p>Get the number of parameters of the unrestricted OU model</p></a></li>
<li><a href='#ou_haltlost'><p>Handling missing data and lost traits in Ornstein-Uhlenbeck processes</p></a></li>
<li><a href='#oupar'><p>Parameterisation functions of Ornstein-Uhlenbeck model</p></a></li>
<li><a href='#parameter_restriction'><p>Restrict the parameters space of OU and Brownian motion models.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rglinv'><p>Simulate random trait values from models.</p></a></li>
<li><a href='#set_tips'><p>Set trait values at the tip for a <code>glinv_gauss</code> model.</p></a></li>
<li><a href='#varest'><p>Estimate the variance-covariance matrix of the maximum likelihood estimator.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phylogenetic Comparative Methods with Uncertainty Estimates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Woodrow Kiang &lt;hello@hckiang.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for analytically computing the asymptotic confidence intervals and maximum-likelihood estimates of a class of continuous-time Gaussian branching processes defined by Mitov V, Bartoszek K, Asimomitis G, Stadler T (2019) &lt;<a href="https://doi.org/10.1016%2Fj.tpb.2019.11.005">doi:10.1016/j.tpb.2019.11.005</a>&gt;. The class of model includes the widely used Ornstein-Uhlenbeck and Brownian motion branching processes. The framework is designed to be flexible enough so that the users can easily specify their own sub-models, or re-parameterizations, and obtain the maximum-likelihood estimates and confidence intervals of their own custom models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://git.sr.ht/~hckiang/glinvci">https://git.sr.ht/~hckiang/glinvci</a>,
<a href="https://github.com/hckiang/glinvci">https://github.com/hckiang/glinvci</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>optimx, lbfgsb3c, BB, ape, numDeriv, plyr, rlang, generics,
utils, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-16 22:11:39 UTC; hckiang</td>
</tr>
<tr>
<td>Author:</td>
<td>Woodrow Kiang [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-18 10:32:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='glinvci'>glinvci: Confidence intervals and hypothesis testing for GLInv model</h2><span id='topic+glinvci'></span><span id='topic+glinvci-package'></span>

<h3>Description</h3>

<p>The glinvci package provides a framework for computing the maximum-likelihood estimates
and asymptotic confidence intervals of a class of continuous-time Gaussian branching processes,
including the Ornstein-Uhlenbeck branching process, which is commonly used in phylogenetic
comparative methods. The framework is designed to be flexible enough that the user can
easily specify their own parameterisation and obtain the maximum-likelihood estimates and
confidence intervals of their own parameters.
</p>


<h3>Author(s)</h3>

<p>Hao Chi Kiang, <a href="mailto:hello@hckiang.com">hello@hckiang.com</a>
</p>

<hr>
<h2 id='clone_model'>Clone a GLInv model</h2><span id='topic+clone_model'></span><span id='topic+clone_model.glinv_gauss'></span><span id='topic+clone_model.glinv'></span>

<h3>Description</h3>

<p>The <code>clone_model</code> function is a S3 generic method for either the <code><a href="#topic+glinv">glinv</a></code>
or <code><a href="#topic+glinv_gauss">glinv_gauss</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone_model(mod, ...)

## S3 method for class 'glinv_gauss'
clone_model(mod, ...)

## S3 method for class 'glinv'
clone_model(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clone_model_+3A_mod">mod</code></td>
<td>
<p>An object of either <code><a href="#topic+glinv">glinv</a></code> or <code><a href="#topic+glinv_gauss">glinv_gauss</a></code> class.</p>
</td></tr>
<tr><td><code id="clone_model_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the S3 methods. Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>glinv</code> or <code>glinv_gauss</code> object is mutable, the assignment <code>model2 = model1</code>
will not make a copy your model. The correct way to copy a model is to use the <code>clone_model</code>
function.
</p>


<h3>Value</h3>

<p>A new model that is a clone of <code>mod</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repar = get_restricted_ou(H=NULL, theta=c(0,0), Sig='diag', lossmiss=NULL)
mod1 = glinv(tree    = ape::rtree(10),
             x0      = c(0,0),
             X       = NULL,
             repar   = repar)
mod2 = mod1
mod3 = clone_model(mod1)
traits = matrix(rnorm(20), 2, 10)
set_tips(mod1, traits)
print(has_tipvals(mod1))  # TRUE
print(has_tipvals(mod2))  # TRUE
print(has_tipvals(mod3))  # FALSE
</code></pre>

<hr>
<h2 id='fit.glinv'>Fitting a GLInv model via numerical optimisation</h2><span id='topic+fit.glinv'></span>

<h3>Description</h3>

<p><code>fit.glinv</code> finds the maximum likelihood estimate of a <code>glinv</code> model by solving a numerical
optimisation problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glinv'
fit(
  object,
  parinit = NULL,
  method = "L-BFGS-B",
  lower = -Inf,
  upper = Inf,
  use_optim = FALSE,
  project = NULL,
  projectArgs = NULL,
  num_threads = 2L,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.glinv_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+glinv">glinv</a></code>.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_parinit">parinit</code></td>
<td>
<p>A vector, parameter for initialisation of the optimisation routine.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_method">method</code></td>
<td>
<p>One of <code>L-BFGS-B</code>, <code>CG</code>, <code>BB</code>, or any other methods which is accepted by optim.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_lower">lower</code></td>
<td>
<p>A vector of lower bounds on the parameters.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_upper">upper</code></td>
<td>
<p>A vector of upper bounds on the parameters.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_use_optim">use_optim</code></td>
<td>
<p>If true, use optim's version of <code>L-BFGS-B</code> and <code>CG</code>.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_project">project</code></td>
<td>
<p>Passed to <code>BBoptim</code>.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_projectargs">projectArgs</code></td>
<td>
<p>Passed to <code>BBoptim</code>.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use when computing the gradient</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_control">control</code></td>
<td>
<p>Options to be passed into each the underlying optimisation routine's <code>control</code>
argument.</p>
</td></tr>
<tr><td><code id="fit.glinv_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is <code>L-BFGS-B</code>, then <code><a href="lbfgsb3c.html#topic+lbfgsb3c">lbfgsb3c</a></code> is used for optimisation;
if it is <code>CG</code> then <code><a href="optimx.html#topic+Rcgmin">Rcgmin</a></code> from the <code>optimx</code> package is used; if it
is <code>BB</code> then <code><a href="BB.html#topic+BBoptim">BBoptim</a></code> is used, otherwise the method argument is passed to
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>
<p>By default, <code>L-BFGS-B</code> declares convergence when the change of function value is small, <code>CG</code>
tests stops when change of gradient squared-Euclidean-norm is small, <code>BB</code> stops when either the
change of function values, or the infinity norm of a project gradient, is small. These can be changed
through the <code>control</code> argument and the user should refer to the optimisation packages' respective
documentation for details.
</p>
<p>The user can opt for using <code><a href="stats.html#topic+optim">optim</a></code>'s version of <code>CG</code> and <code>L-BFGS-B</code>. The
implementation in <code><a href="stats.html#topic+optim">optim</a></code> of the methods does not incorporate improvements of the
methods in the recent decades, but they have stood the test of time.
</p>
<p>If <code>parinit</code> were not supplied and the distance between <code>lower</code> and <code>upper</code> is infinite,
the initialisation point of the optimisation is drawn from a uniform distribution ranging [-1,1]
distribution. If initalisation were not supplied, but the distance between <code>lower</code> and <code>upper</code>
is finite, then the initialisation is drawn from a uniform distribution ranging
[<code>lower</code>, <code>upper</code>].
</p>


<h3>Value</h3>

<p><code>fit.glinv</code> returns a list containing at least the following elements:
</p>
<table role = "presentation">
<tr><td><code>mlepar</code></td>
<td>
<p>The maximum likelihood estimate.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log-likelihood at the maximum likelihood estimate.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>The gradient of log-likelihood at the maximum likelihood estimate.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Zero if the optimisation routine has converged successfully.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A message from the optimisation routine.</p>
</td></tr>
</table>

<hr>
<h2 id='get_restricted_ou'>Convenience function for constructing restricted/reparameterised OU parameterisation function.</h2><span id='topic+get_restricted_ou'></span>

<h3>Description</h3>

<p><code>get_restricted_ou</code> is a convenience function for constructing restricted/reparameterised
OU parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_restricted_ou(H = NULL, theta = NULL, Sig = NULL, lossmiss = "halt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_restricted_ou_+3A_h">H</code></td>
<td>
<p>One of <code>NULL</code>, 'symmetric', 'logspd', 'spd', 'diag', 'logdiag', 'zero', or a
numerical vector specifying fixed parameters.</p>
</td></tr>
<tr><td><code id="get_restricted_ou_+3A_theta">theta</code></td>
<td>
<p>One of <code>NULL</code>, 'zero', or a numerical vector specifying fixed parameters.</p>
</td></tr>
<tr><td><code id="get_restricted_ou_+3A_sig">Sig</code></td>
<td>
<p>One of <code>NULL</code>, 'diag', or a numerical vector specifying fixed parameters.</p>
</td></tr>
<tr><td><code id="get_restricted_ou_+3A_lossmiss">lossmiss</code></td>
<td>
<p>One of <code>NULL</code>, 'zap', 'halt'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_restricted_ou</code> is intended to provide a more convenient way to construct the
restrictions functions, restricted Jacobian and Hessian, than the more flexible methods
described in <code><a href="#topic+parameter_restriction">parameter_restriction</a></code>.
</p>
<p>If either one of <code>H</code>, <code>theta</code> is 'zero' but not both, the function stops with error.
This is because former is statistically not sensible, and the latter can be done by directly
passing a vector of zero to the <code>theta</code> argument.
</p>
<p>If lossmiss is <code>NULL</code>, the returned functions does not have capability to handle missing or
lost values.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>A reparameterisation function conforming to the format required by the <code>parfns</code>
argument of <code>glinv</code>.</p>
</td></tr>
<tr><td><code>jac</code></td>
<td>
<p>A Jacobian function of the above reparameterisation function conforming to the format
required by the <code>parjacs</code> argument of <code>glinv</code>.</p>
</td></tr>
<tr><td><code>hess</code></td>
<td>
<p>A Hessian function of the above reparameterisation function conforming to the format
required by the <code>parhess</code> argument of <code>glinv</code>.</p>
</td></tr>
<tr><td><code>nparams</code></td>
<td>
<p>A function which accepts one integer argument, the total number of dimensions
of the multivariate traits, and returns the number of parameters of the restricted
model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>### --- STEP 1: Make an example tree
set.seed(0x5EEDL, kind='Super-Duper')
ntips = 200
k     = 2                 # No. of trait dimensions
tr    = ape::rtree(ntips) 
x0    = rnorm(k)

### --- STEP 2: Make a model which has unrestricted H, fixed theta and diagonal Sigma_x'.
repar = get_restricted_ou(H=NULL, theta=c(3,1), Sig='diag', lossmiss=NULL)
mod   = glinv(tr, x0, X=NULL,
              pardims =repar$nparams(k),
              parfns  =repar$par,
              parjacs =repar$jac,
              parhess =repar$hess)
# Actually, to save typing, the following short-cut call is the same as the above:
# mod = glinv(tr, x0, X=NULL, repar=repar)

### --- STEP 3: Set up parameters; H, theta, and sig_x needs to be concatenated
H     = matrix(c(1,0,0,-1), k)
theta = c(3,1)
sig   = matrix(c(0.25,0,0,0.25), k)
sig_x = t(chol(sig))
par_truth = c(H=H, sig_x=c(0.5,0.5))

### --- STEP 4: Get a simulated data set to toy with
X = rglinv(mod, par=par_truth)
set_tips(mod, X)

### --- STEP 5: Make an unrestricted model object to compare with the one
### whose parameters are restricted.
mod_unrestricted = glinv(tr, x0, X,
                         pardims=nparams_ou(k),
                         parfns=oupar,
                         parjacs=oujac,
                         parhess=ouhess)


### --- STEP 6: Confirm this is indeed the same as typing everything manually
## Does the restricted model gives the same likelihood as the unrestricted? (Yes, it does.)
LIK   = lik(mod)(par_truth)
LIK_unrestricted = lik(mod_unrestricted)(c(H,theta,sig_x[lower.tri(sig_x, diag=TRUE)]))
print(LIK == LIK_unrestricted)
# [1] TRUE
## We can as well type everything manually as follows. This mod_manual should be
## the same as the mod object; just a different way of calling the glinv function.
mod_manual = glinv(tr, x0, X,
                   pardims  = nparams_ou_fixedtheta_diagSig(k),
                   parfns   = ou_fixedtheta_diagSig(oupar,   theta=c(3,1)),
                   parjacs  = dou_fixedtheta_diagSig(oujac,  theta=c(3,1)),
                   parhess  = hou_fixedtheta_diagSig(ouhess, theta=c(3,1)))
LIK_manual = lik(mod_manual)(par_truth)
print(LIK == LIK_manual) #It's really the same
# [1] TRUE

</code></pre>

<hr>
<h2 id='glinv'>Construct an GLInv model with respect to user-specified parametrisation</h2><span id='topic+glinv'></span><span id='topic+print.glinv'></span><span id='topic+lik.glinv'></span><span id='topic+grad.glinv'></span><span id='topic+hess.glinv'></span><span id='topic+plot.glinv'></span>

<h3>Description</h3>

<p>The <code>glinv</code> function construct an object of class <code>glinv</code>, which represents a GLInv model with respect
to a user-specified parametrisation.
</p>
<p>The <code>lik.glinv</code> function returns a function which accepts a parameter vector, which is of length <code>mod$nparams</code>,
and returns the log-likelihood.
</p>
<p>The <code>grad.glinv</code> function returns a function which accepts a parameter vector, which is of length <code>mod$nparams</code>,
and returns the gradient of log-likelihood with respect to this parametrisation.
</p>
<p>The <code>hess.glinv</code> function returns a function which accepts a parameter vector, which is of length <code>mod$nparams</code>,
and returns the Hessian matrix of log-likelihood with respect to this parametrisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glinv(
  tree,
  x0,
  X,
  parfns = NULL,
  pardims = NULL,
  regimes = NULL,
  parjacs = NULL,
  parhess = NULL,
  repar = NULL
)

## S3 method for class 'glinv'
print(x, ...)

## S3 method for class 'glinv'
lik(mod, ...)

## S3 method for class 'glinv'
grad(
  mod,
  num_threads = 2L,
  numDerivArgs = list(method = "Richardson", method.args = list(d = 0.5, r = 3)),
  ...
)

## S3 method for class 'glinv'
hess(
  mod,
  num_threads = 2L,
  numDerivArgs = list(method = "Richardson", method.args = list(d = 0.5, r = 3)),
  store_gaussian_hessian = FALSE,
  ...
)

## S3 method for class 'glinv'
plot(x, internal_nodes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glinv_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_x0">x0</code></td>
<td>
<p>A vector representing the root's trait vector. Must not contain <code>NA</code> and <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_x">X</code></td>
<td>
<p>Optional. A matrix of trait values, in which <code>X[p,n]</code> stores the p-th dimension
of the multivariate trait of the n-th tip of the phylogeny. <code>NA</code> and <code>NaN</code>
has special meanings (See Details).</p>
</td></tr>
<tr><td><code id="glinv_+3A_parfns">parfns</code></td>
<td>
<p>A list of functions that maps from the user-parametrisation to the underlying Gaussian parameters.
Each of them returns a vector of concatenated <code class="reqn">(\Phi, w, V')</code>, where <code class="reqn">V'</code> is the lower triangular
part of <code class="reqn">V</code>, and accepts four arguments: a vector of parameters whose length is specified
by the <code>pardims</code> argument to the <code>glinv_gauss</code> function, the branch length leading to the currently processing node, 
a vector of factors with three levels indicating which dimensions are missing or lost in the mother of
the current node, and a vector of factors with the same three levels indicating missingness of the current
node.</p>
</td></tr>
<tr><td><code id="glinv_+3A_pardims">pardims</code></td>
<td>
<p>A vector of integers, which has the same amount elements as the length of parfns.
<code>pardims[i]</code> indicates the length of the parameter vector that <code>parfns[i]</code> accepts.</p>
</td></tr>
<tr><td><code id="glinv_+3A_regimes">regimes</code></td>
<td>
<p>A list of length-two integer vectors. Each of these length-two vectors specifies an evolutionary regime
and consists of a named element <code>start</code>, which specifies the node ID at which an evolutionary regime 
starts, and another named element <code>fn</code>, which is an index of <code>parfns</code>, indicating which parametrisation
function this evolutionary regime should use.</p>
</td></tr>
<tr><td><code id="glinv_+3A_parjacs">parjacs</code></td>
<td>
<p>A list of functions, which has the same amount elements as that of <code>parfns</code>.
<code>parjacs[i]</code> accepts the same arguments as <code>parfns[i]</code> and returns the Jacobian of <code>parfns[i]</code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_parhess">parhess</code></td>
<td>
<p>A list of functions, which has the same amount elements as that of <code>parfn[i]</code>.
<code>parhess[i]</code> accepts the same arguments as <code>parfns[i]</code> and returns a list of three 3D arrays,
named <code>Phi</code>, <code>w</code>, <code>V</code> respectively inside the list. <code>((parhess[[i]])(...))$Phi[m,i,j]</code> contains
the cross second-order partial derivative of <code class="reqn">\Phi_m</code> (here we treat the matrix <code class="reqn">\Phi</code> as a
column-major-flattened vector) with respect to the <code class="reqn">i</code>-th and<code class="reqn">j</code>-th user parameters;
while <code>((parhess[[i]])(...))$w[m,i,j]</code> and <code>((parhess[[i]])(...))$V[m,i,j]</code>
analogously contains second-order derivative of <code class="reqn">w_m</code> and <code class="reqn">V'_m</code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_repar">repar</code></td>
<td>
<p>Optional. One or a list of object returned by <code>get_restricted_ou</code>. This is a convenient
short-cut alternative to supplying <code>pardims</code>, <code>parfns</code>, <code>parjacs</code>, and
<code>parhess</code> one-by-one.</p>
</td></tr>
<tr><td><code id="glinv_+3A_x">x</code></td>
<td>
<p>An object of class <code>glinv</code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="glinv_+3A_mod">mod</code></td>
<td>
<p>An object of class <code>glinv</code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="glinv_+3A_numderivargs">numDerivArgs</code></td>
<td>
<p>Arguments to pass to <code>numDeriv::<a href="numDeriv.html#topic+jacobian">jacobian</a></code>. Only used the user did not specify the
<code>parjacs</code> arguments when creating <code>mod</code>.</p>
</td></tr>
<tr><td><code id="glinv_+3A_store_gaussian_hessian">store_gaussian_hessian</code></td>
<td>
<p>If <code>TRUE</code> and <code>method</code> is not <code>mc</code>, the returned list will contain
a (usually huge) Hessian matrix <code>gaussian_hessian</code> with respect to the Gaussian
parameters <code class="reqn">\Phi, w, V'</code>. This option significantly increases the amount of memory
the function uses, in order to store the matrix.</p>
</td></tr>
<tr><td><code id="glinv_+3A_internal_nodes">internal_nodes</code></td>
<td>
<p>Boolean, whether to plot the internal nodes's numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>glinv</code> assumes one or more evolutionary regimes exists in the phylogeny. The <code>regimes</code> parameters defines
how many regimes there are, where do the regimes start, and what parameterisation function it has. If <code>regimes</code> were
NULL then a single regime starting from the root node is assumed. Multiple regimes could share the same parametrisation
function (and thus the same parameters) by specifying the same index; therefore the number of regimes may differs from 
the number of parametrisation functions. One and only one regime must start from the root of the phylogeny.
</p>
<p>If <code>X</code> contains <code>NA</code> in the <code class="reqn">p</code>-th dimension of the <code class="reqn">i</code>-th tip (whose node ID is also <code class="reqn">i</code>) then <code class="reqn">X_pi</code> is
tagged <code>MISSING</code>. No other tags of any other nodes are changed. The <code class="reqn">p</code>-th dimension of any node <code class="reqn">j</code>, regardless of
whether or not it is an internal node or a tips, is tagged <code>LOST</code> if and only if the <code class="reqn">p</code>-th dimension of all tips inside
the clade started at <code class="reqn">j</code> are <code>NaN</code>. Any entry that is neither <code>LOST</code> nor <code>MISSING</code> are tagged <code>OK</code>. These
tags are then passed into the user-defined functions <code>parfns</code> etc. as arguments; therefore the user is free to specify how
these tags are handled. <code>x0</code> cannot contain missing values, and the vectors of missingness tags passed to <code>parfns</code>, for
any nodes, are always of the same length as <code>x0</code>.
</p>
<p>Before this package calls the functions in <code>parhess</code>, it adds, into the function's environment, a variable named <code>INFO__</code> 
which contains some extra information.
</p>
<p>Passing a single function to <code>parfns</code> is equivalent to passing a singleton list; and the same is true for <code>parjacs</code>,
<code>parhess</code>, and <code>pardims</code>.
</p>


<h3>Value</h3>

<p>The <code>glinv</code> function returns a model object of S3 class <code>glinv</code>. Elements are:
</p>
<table role = "presentation">
<tr><td><code>rawmod</code></td>
<td>
<p>An object of class <code>glinv_gauss</code>.</p>
</td></tr>
<tr><td><code>regimes</code></td>
<td>
<p>Identical to the <code>regimes</code> argument.</p>
</td></tr>
<tr><td><code>regtags</code></td>
<td>
<p>An integer vector of the same length as the number of nodes. The <code class="reqn">i</code>-th element is
the regime ID (corresponding to the index in the <code>regimes</code> argument to the <code>glinv_gauss</code> function) of
node <code class="reqn">i</code>. <code>NA</code> at the root.</p>
</td></tr>
<tr><td><code>misstags</code></td>
<td>
<p>A factor matrix with three ordered levels, <code>LOST</code>, <code>OK</code>, and <code>MISSING</code>. Each column
corresponds to a node and row to a trait dimension.</p>
</td></tr>
<tr><td><code>nparams</code></td>
<td>
<p>The sum of the <code>pardims</code> argument, an integer.</p>
</td></tr>
<tr><td><code>pardims</code></td>
<td>
<p>Identical to the <code>pardims</code> arguemnt.</p>
</td></tr>
<tr><td><code>parfntags</code></td>
<td>
<p>An integer vector of the same length as the number of nodes. The <code class="reqn">i</code>-th element is
the index of <code>parfns</code> that corresponds to node <code class="reqn">i</code>. <code>NA</code> at the root.</p>
</td></tr>
<tr><td><code>parfns</code></td>
<td>
<p>Identical to the <code>parfns</code> argument.</p>
</td></tr>
<tr><td><code>parjacs</code></td>
<td>
<p>Identical to the <code>parjacs</code> argument.</p>
</td></tr>
<tr><td><code>parhess</code></td>
<td>
<p>Identical to the <code>parhess</code> argument.</p>
</td></tr>
<tr><td><code>parsegments</code></td>
<td>
<p>A <code class="reqn">K</code>-by-2 matrix of integer indicies, where <code class="reqn">K</code> is the length of <code>parfns</code>.
If <code>v</code> is a vector that <code><a href="#topic+lik.glinv">lik.glinv</a></code> accepts, then
<code>v[parsegments[k,1]:parsegments[k,2]]</code> is the parameter vector should <code>parfns[[k]]</code>
accept.</p>
</td></tr>
<tr><td><code>gausssegments</code></td>
<td>
<p>A <code class="reqn">N</code>-by-2 matrix of integer indicies, where <code class="reqn">N</code> is the number of nodes.
If <code>w</code> is a vector that <code><a href="#topic+lik.glinv_gauss">lik.glinv_gauss</a></code> accepts, then
<code>w[gausssegments[i,1]:gausssegments[i,2]]</code> is the concatenated <code class="reqn">(\Phi, w, V')</code>
corresponding to node <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code>gaussparams_fn</code></td>
<td>
<p>A function that accepts a parameter vector of length <code>nparams</code> and returns a
parameter vector of length <code>rawmod$nparams</code>. When called, this function
traverses the tree, calls the functions in parfns on each node, and assemble 
the results into a format that <code><a href="#topic+lik.glinv_gauss">lik.glinv_gauss</a></code> accepts.</p>
</td></tr>
<tr><td><code>gaussparams_jac</code></td>
<td>
<p>A function that accepts a parameter vector of length <code>nparams</code> and returns a
<code class="reqn">p</code>-by-<code class="reqn">q</code> Jacobian matrix, where <code class="reqn">p</code> is <code>rawmod$nparams</code> and <code class="reqn">q</code>
is <code>nparams</code> in this object. When called, this function traverses
the tree, calls the functions in <code>parjacs</code> on each node, and row-concatenates the
result in an order consistent with what <code><a href="#topic+lik.glinv_gauss">lik.glinv_gauss</a></code> accepts.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The original data (trait) matrix in a &quot;normalized&quot; format.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mitov V, Bartoszek K, Asimomitis G, Stadler T (2019). “Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts.” Theor. Popul. Biol.. https://doi.org/10.1016/j.tpb.2019.11.005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(glinvci)
### --- STEP 1: Make an example tree
set.seed(0x5EEDL, kind='Super-Duper')
ntips = 200
k     = 2                 # No. of trait dimensions
tr    = ape::rtree(ntips) 
x0    = rnorm(k)

### --- STEP 2: Make a model object. We use OU as an example.
###             Assume H is a positively definite diagonal matrix and in
###             log scale.
mod = glinv(tr, x0, X=NULL,
            parfns  = list(ou_logdiagH(ou_haltlost(oupar))),
            pardims = list(nparams_ou_diagH(k)),
            parjacs = list(dou_logdiagH(dou_haltlost(oujac))),
            parhess = list(hou_logdiagH(hou_haltlost(ouhess))))

### --- STEP 3: Set up parameters; H, theta, and sig_x needs to be concatenated
H     = matrix(c(2,0,0,1/2), k) #Diagonals, 
theta = c(0,0)
sig   = matrix(c(0.5,0.1,0.1,0.2), k)
sig_x = t(chol(sig))
## glinvci ALWAYS assumes diagonals of sig_x is in log scale.
diag(sig_x) = log(diag(sig_x))
par_truth = c(logdiagH=log(diag(H)),theta=theta,sig_x=sig_x[lower.tri(sig_x,diag=TRUE)])
## Now par_truth the vector of parameters in the right format that the model
## can consume. Notice about we use log(diag(H)) because we specified ou
## logdiagH earlier.

### --- STEP 4: Simulate a data set from the model and the true parameters,
### then set this data into the model.
X = rglinv(mod, par=par_truth)
set_tips(mod, X)

### --- STEP 5: Try computing the likelihood, gradient and Hessian justifying
### for illustration purpose.
print(par_truth)
print(lik(mod)(par_truth))
print(grad(mod)(par_truth))
print(hess(mod)(par_truth))

### --- STEP 6: Fit a model; here we use the truth as initialisation
### only for illustration purpose to reduce load on CRAN's server. In reality
### you usually want to initialise with either some best guess or random
### values.
fitted = fit(mod, parinit = par_truth)
print(fitted)

### --- STEP 7: Estimate the variance-covariance matrix of the MLE
v_estimate = varest(mod, fitted)

### --- STEP 8: Get marginal confidence intervals; and compare with the truth.
print(marginal_ci(v_estimate, lvl=0.95)) 
print(par_truth)

</code></pre>

<hr>
<h2 id='glinv_gauss'>Construct an object representing a GLInv model with respect to the underlying Gaussian process parameters.</h2><span id='topic+glinv_gauss'></span><span id='topic+lik.glinv_gauss'></span><span id='topic+grad.glinv_gauss'></span><span id='topic+hess.glinv_gauss'></span><span id='topic+print.glinv_gauss'></span>

<h3>Description</h3>

<p>The <code>glinv_gauss</code> function constructs an object of class <code>glinv_gauss</code>, which represents a lower-level 
GLInv model with respect to the underlying Gaussian process space. The likelihood Hessian of, for example, Brownian motion
and Ornstein-Uhlenbeck models can be computed by applying the calculus chain rule to the output of Jacobians and Hessians
from this class.
</p>
<p>The <code>lik.glinv_gauss</code> function computes the likelihood of a full <code>glinv_gauss</code> model.
</p>
<p>The <code>grad.glinv_gauss</code> function computes the log-likelihood gradients of a <code>glinv_gauss</code> models.
If <code>par</code> is NULL, it returns a function that, when called, returns the same thing as if <code>grad.glinv_gauss</code>
were called with <code>par</code> argument.
</p>
<p>The <code>hess.glinv_gauss</code> function computes the log-likelihood Hessian of a <code>glinv_gauss</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glinv_gauss(tree, x0, dimtab = NULL, X = NULL)

## S3 method for class 'glinv_gauss'
lik(mod, par = NULL, ...)

## S3 method for class 'glinv_gauss'
grad(mod, par = NULL, lik = FALSE, num_threads = 2L, ...)

## S3 method for class 'glinv_gauss'
hess(
  mod,
  par = NULL,
  lik = FALSE,
  grad = FALSE,
  directions = NULL,
  num_threads = 2L,
  ...
)

## S3 method for class 'glinv_gauss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glinv_gauss_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code>ape::phylo</code>.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_x0">x0</code></td>
<td>
<p>A vector representing the root's trait vector.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_dimtab">dimtab</code></td>
<td>
<p>An integer, a vector of integers, or NULL, specifying the number of dimensions of each nodes of the tree.
If it is a vector, <code>dimtab[n]</code> is the trait vector dimension of node <code>n</code>. If it is only a single
integer than all nodes are assumed to have the same amount of dimensions. If it is NULL then all
nodes are asummed to have the same amount of dimensions as <code>x0</code>.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_x">X</code></td>
<td>
<p>Trait values, either a matrix in which <code>X[p,n]</code> stores the <code class="reqn">p</code>-th dimension
of the multivariate trait of the <code class="reqn">n</code>-th tip of the phylogeny, or a list in which
<code>X[[n]]</code> is a numeric vector representing the multivariate trait of the <code class="reqn">n</code>-th tip.
The latter form is required if not all the tips has the same number of dimensions.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_mod">mod</code></td>
<td>
<p>A model object of class <code>glinv_gauss</code>.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_par">par</code></td>
<td>
<p>A vector, containing the parameters at which the likelihood should be computed.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_lik">lik</code></td>
<td>
<p>If <code>TRUE</code>, <code>grad.glinv_gauss</code> and <code>hess.glinv_gauss</code> returns also the log-likelihood.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_grad">grad</code></td>
<td>
<p>If <code>TRUE</code>, <code>hess.glinv_gauss</code> returns also the gradient.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_directions">directions</code></td>
<td>
<p>Either <code>NULL</code> or a matrix with <code>mod$nparams</code> many rows and arbitrarily many columns.
If <code>NULL</code>, 'hess.glinv_gauss' returns the Hessian matrix itself, which is typically
a huge matrix; otherwise, the funciton returns a square matrix <code class="reqn">M</code> such that <code class="reqn">M_ij</code>
contains <code class="reqn">d_i^T H d_j</code>, where <code class="reqn">d_i</code> is the <code class="reqn">i</code>-th column of <code>directions</code> and
<code class="reqn">H</code> is the huge Hessian matrix, without storing <code class="reqn">H</code> itself in memory.</p>
</td></tr>
<tr><td><code id="glinv_gauss_+3A_x">x</code></td>
<td>
<p>An object of class <code>glinv_gauss</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>glinv_gauss</code> class does not include any information for dealing with evolutionary regimes, lost traits, and
missing data, nor does it facilitate reparametrisation. These are all functionality of the <code>glinv</code> class instead.
The member variables of the objects of the <code>glinv_gauss</code> class only are for the users' convenience to <em>read</em>
the information about the model, and the user <em>should not</em> modify its member variables directly.
</p>
<p>For each non-root node <code class="reqn">i</code> in the phylogeny, the multivariate trait vector <code class="reqn">x_i</code> follows
a Gaussian distribution with mean <code class="reqn">\Phi_i x_j + w_i</code> and variance <code class="reqn">V_i</code> when conditioned on
the mother's trait vector <code class="reqn">x_j</code>. The &lsquo;parameters&rsquo; of this model is, therefore, the joint of all
<code class="reqn">(\Phi_i, w_i V'_i)</code> for all nodes <code class="reqn">i</code>. The root does not have any associated parameters.
</p>
<p>The parameter vector <code>par</code> should be the concatenation of all <code class="reqn">(\Phi_i, w_i, V'_i)</code> in accending
order sorted by <code class="reqn">i</code>, the node number (which is the same node numbers as in <code>tree$edge</code>). The matrix
<code class="reqn">\Phi_i</code> is flattened in column-major order and <code class="reqn">V'_i</code> is the lower-triangular part of V_i,
column-major-flattened. Since the root does not have parameters, its entry is simply skipped.
For example, if a binary tree has 10 non-root nodes in total and each of them are 3 dimensional, then
each <code class="reqn">(\Phi_i, w_i, V'_i)</code> should have <code class="reqn">9+3+6=18</code> elements; thus after concatenation <code>par</code> should
be a 180 elements.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>glinv_gauss</code> with the following components
</p>

<dl>
<dt>ctree</dt><dd><p>A pointer to an internal C structure.</p>
</dd>
<dt>apetree</dt><dd><p>Same as the <code>tree</code> argument but with some pre-processing in its edge table</p>
</dd>
<dt>origtree</dt><dd><p>The <code>tree</code> argument.</p>
</dd>
<dt>x0</dt><dd><p>The trait vector at the root of the tree.</p>
</dd>
<dt>dimtab</dt><dd><p>Identical to the <code>dimtab</code> argument.</p>
</dd>
<dt>gaussdim</dt><dd><p>The number of dimension of the parameter space of this model.</p>
</dd>
</dl>



<h3>References</h3>

<p>Mitov V, Bartoszek K, Asimomitis G, Stadler T (2019). “Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts.” Theor. Popul. Biol.. https://doi.org/10.1016/j.tpb.2019.11.005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr = ape::rtree(3)
model = glinv_gauss(tr, x0=c(0,0), X=matrix(rnorm(6),2,3))
par = unlist(
 list(
   list('Phi' = c(1,0,0,1), # Parameters for node #1, a tip
        'w'   = c(-1,1),
        'V'   = c(1,0,1)),  # Lower triangular part of a 2D identity matrix
   list('Phi' = c(2,0,0,2), # For node #2, a tip
        'w'   = c(-2,2),
        'V'   = c(2,0,2)),
   list('Phi' = c(3,0,0,3), # For node #3, a tip
        'w'   = c(-3,3),
        'V'   = c(3,0,3)),
   list('Phi' = c(4,0,0,4), # For node #5. Node #4 skipped as it is the root
        'w'   = c(-4,4),
        'V'   = c(4,0,4))
   ))
print(par)
lik(model, par)
grad(model, par)
hess(model, par)
</code></pre>

<hr>
<h2 id='grad'>Compute the log-likelihood gradients of GLInv models</h2><span id='topic+grad'></span>

<h3>Description</h3>

<p>For the <code><a href="#topic+glinv">glinv</a></code> class, which is a high-level user interface, please see <code><a href="#topic+grad.glinv">grad.glinv</a></code>; and
for <code><a href="#topic+glinv_gauss">glinv_gauss</a></code>, which is a lower-level facility, please see <code><a href="#topic+grad.glinv_gauss">grad.glinv_gauss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_+3A_mod">mod</code></td>
<td>
<p>An object of either <code><a href="#topic+glinv">glinv</a></code> or <code><a href="#topic+glinv_gauss">glinv_gauss</a></code> class.</p>
</td></tr>
<tr><td><code id="grad_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the S3 methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector containing the gradient of <code>mod</code>.
</p>

<hr>
<h2 id='has_tipvals'>Check if a <code>glinv_gauss</code> model contains trait values at their tips.</h2><span id='topic+has_tipvals'></span><span id='topic+has_tipvals.glinv_gauss'></span><span id='topic+has_tipvals.glinv'></span>

<h3>Description</h3>

<p>Returns true if and only if the <code>glinv_gauss</code> model were initialised with <code>X=NULL</code>
and the user had never called <code>set_tips</code> on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_tipvals(mod)

## S3 method for class 'glinv_gauss'
has_tipvals(mod)

## S3 method for class 'glinv'
has_tipvals(mod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_tipvals_+3A_mod">mod</code></td>
<td>
<p>A <code>glinv_gauss</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean. True if <code>mod</code> contains tip trait values and false otherwise.
</p>

<hr>
<h2 id='hess'>Compute the log-likelihood Hessian of GLInv models</h2><span id='topic+hess'></span>

<h3>Description</h3>

<p>For the <code><a href="#topic+glinv">glinv</a></code> class, which is a high-level user interface, please see <code><a href="#topic+hess.glinv">hess.glinv</a></code>; and
for <code><a href="#topic+glinv_gauss">glinv_gauss</a></code>, which is a lower-level facility, please see <code><a href="#topic+hess.glinv_gauss">hess.glinv_gauss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hess(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hess_+3A_mod">mod</code></td>
<td>
<p>An object of either <code><a href="#topic+glinv">glinv</a></code> or <code><a href="#topic+glinv_gauss">glinv_gauss</a></code> class.</p>
</td></tr>
<tr><td><code id="hess_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the S3 methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical square matrix containing the Hessian of <code>mod</code>.
</p>

<hr>
<h2 id='lik'>Compute the likelihood of a GLInv model</h2><span id='topic+lik'></span>

<h3>Description</h3>

<p>This is a S3 generic method. For the <code><a href="#topic+glinv">glinv</a></code> class, which is a high-level user interface, please 
see <code><a href="#topic+lik.glinv">lik.glinv</a></code>; and for <code><a href="#topic+glinv_gauss">glinv_gauss</a></code>, which is a lower-level facility, please see
<code><a href="#topic+lik.glinv_gauss">lik.glinv_gauss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lik(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lik_+3A_mod">mod</code></td>
<td>
<p>An object of either <code><a href="#topic+glinv">glinv</a></code> or <code><a href="#topic+glinv_gauss">glinv_gauss</a></code> class.</p>
</td></tr>
<tr><td><code id="lik_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the S3 methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical scalar containing the likelihood of <code>mod</code>.
</p>

<hr>
<h2 id='marginal_ci'>Getting marginal confidence interval for GLInv model</h2><span id='topic+marginal_ci'></span>

<h3>Description</h3>

<p><code>marginal_ci</code> computes the marginal confidence interval for each parameters
using the variance-covariance matrix output by 'varest.glinv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_ci(varest_result, lvl = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal_ci_+3A_varest_result">varest_result</code></td>
<td>
<p>The output from 'varest.glinv'.</p>
</td></tr>
<tr><td><code id="marginal_ci_+3A_lvl">lvl</code></td>
<td>
<p>Confidence level. Default to 95 percent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code class="reqn">p</code>-by-2 matrix where <code class="reqn">p</code> is the number of parameters.
The first column is the lower limits and second column is the upper limits.
</p>

<hr>
<h2 id='nparams_ou'>Get the number of parameters of the unrestricted OU model</h2><span id='topic+nparams_ou'></span>

<h3>Description</h3>

<p><code>nparams_ou</code> returns the number of parameters of the unrestricted OU model. For the restricted
models, including Brownian motion, see <code><a href="#topic+parameter_restriction">parameter_restriction</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nparams_ou(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nparams_ou_+3A_k">k</code></td>
<td>
<p>An Integer. The total number of dimensions of the multivariate traits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical scalar, which is the number of parameters of the the unrestricted OU model.
</p>

<hr>
<h2 id='ou_haltlost'>Handling missing data and lost traits in Ornstein-Uhlenbeck processes</h2><span id='topic+ou_haltlost'></span><span id='topic+dou_haltlost'></span><span id='topic+hou_haltlost'></span><span id='topic+ou_zaplost'></span><span id='topic+dou_zaplost'></span><span id='topic+hou_zaplost'></span>

<h3>Description</h3>

<p><code>ou_haltlost</code> and <code>ou_zaplost</code> handles lost traits and missing data.
Each of them wraps the function <code><a href="#topic+oupar">oupar</a></code> and returns
a new function that accepts the same arguments and output the same form of result,
but takes into account lost traits and missing data. <code>dou_haltlost</code> and
<code>dou_zaplost</code> wraps the Jacobian function <code><a href="#topic+oujac">oujac</a></code>, and
<code>hou_haltlost</code> and <code>hou_zaplost</code> wraps the Hessian function
<code><a href="#topic+ouhess">ouhess</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ou_haltlost(parfn)

dou_haltlost(jacfn)

hou_haltlost(hessfn)

ou_zaplost(parfn)

dou_zaplost(jacfn)

hou_zaplost(hessfn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ou_haltlost_+3A_parfn">parfn</code></td>
<td>
<p>A function that maps from the user-parametrisation to the underlying Gaussian parameters.
Each of them returns a vector of concatenated <code class="reqn">(\Phi, w, V')</code>, where <code class="reqn">V'</code> is the lower triangular
part of <code class="reqn">V</code>, and accepts four arguments: a vector of parameters whose length is specified
by the <code>pardims</code> argument to the <code>glinv_gauss</code> function, the branch length leading to the currently processing node, 
a vector of factors with three levels indicating which dimensions are missing or lost in the mother of
the current node, and a vector of factors with the same three levels indicating missingness of the current
node.</p>
</td></tr>
<tr><td><code id="ou_haltlost_+3A_jacfn">jacfn</code></td>
<td>
<p>A function that accepts the same arguments as <code>parfn</code> and returns the Jacobian
of <code>parfn</code>.</p>
</td></tr>
<tr><td><code id="ou_haltlost_+3A_hessfn">hessfn</code></td>
<td>
<p>A function that accepts the same arguments as <code>parfns</code> and returns a list of three 3D arrays,
named <code>Phi</code>, <code>w</code>, <code>V</code> respectively inside the list. <code>((hessfn)(...))$Phi[m,i,j]</code>
contains the cross second-order partial derivative of <code class="reqn">\Phi_m</code> (here we treat the matrix
<code class="reqn">\Phi</code> as a column-major-flattened vector) with respect to the <code class="reqn">i</code>-th and<code class="reqn">j</code>-th parameters
in the joint <code class="reqn">(H,\theta,\Sigma_x)</code> vector, and
<code>((hessfn)(...))$w[m,i,j]</code> and <code>((hessfn)(...))$V[m,i,j]</code>
analogously contains second-order derivative of <code class="reqn">w_m</code> and <code class="reqn">V'_m</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>What is missing traits and lost traits</h4>

<p>A &lsquo;missing&rsquo; trait refers to a trait value whose data is missing due to data
collection problems. Fundamentally, they evolves in the same manner as other
traits. An <code>NA</code> entry in the data is deemed &lsquo;missing&rsquo;. On the other hand,
a lost trait is a trait dimension which had ceased to exists during the
evolutionary process. An <code>NaN</code> entry in the data indicates a &lsquo;lost&rsquo; trait.
</p>



<h4>Each nodes has their own missing-ness tags</h4>

<p>Each trait dimension of each nodes, either internal or tip, are tagged with
one of the three labels: <code>MISSING</code>, <code>LOST</code>, and <code>OK</code>.
If the data contains an <code>NA</code> in the <code class="reqn">p</code>-th dimension of the <code class="reqn">i</code>-th tip
then <code class="reqn">X_pi</code> is tagged <code>MISSING</code>. No other tags of any other nodes and dimensions
are changed in the case of missing-ness. On the other hands, the <code class="reqn">p</code>-th dimension of
any node <code class="reqn">j</code>, regardless of whether or not it is an internal node or a tips, is
tagged <code>LOST</code> if and only if the <code class="reqn">p</code>-th dimension of all tips inside
the clade started at <code class="reqn">j</code> are <code>NaN</code>. Any entry that is neither tagged
<code>LOST</code> nor <code>MISSING</code> are tagged <code>OK</code>.
</p>
<p>This corresponds to the biological intuition that, if a value is missing only due
to data collection problems, the missingness should not influence the random walk
process way up the phylogenetic tree; and this is obviously not true if the trait
had ceased to exists instead.
</p>



<h4>Handling of missing data and lost traits</h4>

<p><code>ou_haltlost</code> and <code>ou_zaplost</code> handles missing data in the same way: they
simply marginalises the unobserved dimensions in the joint Gaussian distributions of
tip data.
</p>
<p>For lost traits, <code>ou_haltlost</code> assumes the followings:
</p>

<ol>
<li><p> In the entire branch leading to the earliest node <code class="reqn">j</code> whose <code class="reqn">p</code>-th dimension
is tagged <code>LOST</code>, the lost trait dimension does not evolve at all.
</p>
</li>
<li><p> In the entire same branch, the magnitude of the <code class="reqn">p</code>-th dimension at <code class="reqn">j</code>'s
mother node has no influence on other dimensions, in any instantaneous moments during
the evolution in the branch, neither through the linear combination with the drift
matrix nor the Wiener process covariance; in other words, the SDE governing the 
non-lost dimensions' random walk is invariant of <code class="reqn">j</code>'s mother nodes' <code class="reqn">p</code>-th dimension.
</p>
</li></ol>

<p>Therefore, <code>ou_haltlost</code> first set the <code class="reqn">p</code>-th row and column of both of <code class="reqn">H_j</code>
and the <code class="reqn">p</code>-th row of <code class="reqn">Sigma_x</code> to zero and marginalise out the degenerate Gaussian
dimension.
</p>
<p>On the other hands, <code>ou_zaplost</code> does not assume the lost trait to stop evolving
immediately at moment when the branch leading to <code class="reqn">j</code> starts, but, instead, simply
marginalise out the lost, non-degenerate Gaussian dimensions. This method is the same as
the one that is used in the <code>PCMBase</code> package.
</p>



<h4>Usage in combination with parameter restrictions</h4>

<p>Without paramter restriction, the following is an example usage in a call to the
<code><a href="#topic+glinv">glinv</a></code> function. It constructs a <code><a href="#topic+glinv">glinv</a></code> model object
which is capable of handling missing data and lost traits.
</p>
<pre>
        mod.full = glinv(tree, x0, my_data,
                         parfns  = haltlost(oupar),
                         pardims = nparams_ou(k),
                         parjacs = dhaltlost(oujac),
                         parhess = hhaltlost(ouhess))
</pre>
<p>Note that we have the same naming convention that functions wrappers whose
nams have prefix <code>d</code> wraps the Jacobians, while prefix <code>d</code> wraps
the Hessians.
</p>
<p>If parameter restriction is needed, then <code>*ou_*lost</code> should called
<em>before any reparameterisation/restriction functions</em> because it
expects the passed-in function <code>parfn</code> to accept the full <code class="reqn">H</code>
matrix, rather than only the diagonal or lower-triangular part of it.
Example:
</p>
<pre>
        f = haltlost(oupar)
        g = dhaltlost(oujac)
        h = hhaltlost(oujac)
        mod.full = glinv(tree, x0, my_data,
                         parfns  = ou_spdH(f),
                         pardims = nparams_ou_spdH(k),
                         parjacs = dou_spdH(g),
                         parhess = ou_spdH(h,g))
</pre>



<h3>Value</h3>

<p><code>ou_haltlost</code> and <code>ou_zaplost</code> returns a wrapped versions of 'parfn', which accepts the same arguments
and outputs in the same format. <code>dou_haltlost</code> and <code>dou_zaplost</code>, analogously, wraps <code>jacfn</code>.
<code>hou_zaplost</code> and <code>hou_zaplost</code> wraps <code>hessfn</code>.
</p>

<hr>
<h2 id='oupar'>Parameterisation functions of Ornstein-Uhlenbeck model</h2><span id='topic+oupar'></span><span id='topic+oujac'></span><span id='topic+ouhess'></span>

<h3>Description</h3>

<p><code>oupar</code> is a function that maps from the Ornstein-Uhlenbeck model
parameters to the Gaussian parametersation.
</p>
<p><code>oujac</code> accepts the same arguments as <code>oupar</code> and returns the
Jacobian matrix of <code>oupar</code>.
</p>
<p><code>ouhess</code> accepts the same arguments as <code>oupar</code>
and returns all the second derivatives <code>oupar</code>. The returned
values are consistent with the format required by <code><a href="#topic+glinv">glinv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oupar(par, t, ...)

oujac(par, t, ...)

ouhess(par, t, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oupar_+3A_par">par</code></td>
<td>
<p>A numeric vector containing the joint vector of the
Ornstein-Uhlenbeck drift matrix, long-term mean,
and volitality matrix, which is a lower-triangular
Cholesky factor.</p>
</td></tr>
<tr><td><code id="oupar_+3A_t">t</code></td>
<td>
<p>Branch length of the currently processing node.</p>
</td></tr>
<tr><td><code id="oupar_+3A_...">...</code></td>
<td>
<p>Unused in these functions. Their existence is needed because
<code><a href="#topic+lik.glinv">lik.glinv</a></code> etc. always pass us four arguments.
See <code><a href="#topic+lik.glinv">lik.glinv</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By multivariate Ornstein-Uhlenbeck process, we mean
</p>
<p style="text-align: center;"><code class="reqn">dx(t) = -H(x(t) - \theta)dt + \Sigma_x dW(t)</code>
</p>

<p>where <code class="reqn">H</code> is a <code class="reqn">k</code>-by-<code class="reqn">k</code> matrix with real entries,
<code class="reqn">\theta</code> is any real <code class="reqn">k</code>-vector, <code class="reqn">\Sigma_x</code> is a
lower-triangular matrix, <code class="reqn">W(t)</code> is the Brownian motion process.
The parameters of this model is <code class="reqn">(H,\theta,\Sigma_x)</code>,
therefore <code class="reqn">k^2+k+k(k+1)/2</code> dimensional.
</p>
<p>This package uses parameterisation <code class="reqn">(H,\theta,\Sigma_x')</code>, where
<code class="reqn">H</code> and <code class="reqn">\theta</code> is the same as above defined, and <code class="reqn">\Sigma_x'</code>
is the lower-triangular part of <code class="reqn">\Sigma_x</code>, except that, only on diagonal
entries, <code class="reqn">\Sigma_x'=log(\Sigma_x)</code>. The use of logarithm is for
eliminating multiple local maxima in the log-likelihood.
</p>
<p>The <code>par</code> arguemnt is the concatenation of column-major-flattened
<code class="reqn">H</code>, <code class="reqn">\theta</code>, and the column-major-flattened lower-triangular part
of <code class="reqn">\Sigma_x'</code>.
</p>


<h3>Value</h3>

<p><code>oupar</code> returns the a vector of concatenated <code class="reqn">(\Phi, w, V')</code>,
where <code class="reqn">V'</code> is the lower triangular part of <code class="reqn">V</code>. <code>oujac</code>
returns the Jacobian matrix of <code>oupar</code>. <code>ouhess</code> returns
a list of three 3D arrays, named <code>Phi</code>, <code>w</code>, <code>V</code> respectively inside the list, in which
<code>ouhess(...)$Phi[m,i,j]</code> contains
the cross second-order partial derivative of <code class="reqn">\Phi_m</code> (here we treat the matrix <code class="reqn">\Phi</code> as a
column-major-flattened vector) with respect to the <code class="reqn">i</code>-th and<code class="reqn">j</code>-th user parameters;
and <code>ouhess(...)$w[m,i,j]</code> and <code>((parhess[[i]])(...))$V[m,i,j]</code>
analogously contains second-order derivative of <code class="reqn">w_m</code> and <code class="reqn">V'_m</code>.
</p>

<hr>
<h2 id='parameter_restriction'>Restrict the parameters space of OU and Brownian motion models.</h2><span id='topic+parameter_restriction'></span><span id='topic+avail_restrictions'></span><span id='topic+brn'></span><span id='topic+brn_diagSig'></span><span id='topic+brn_fixedSig'></span><span id='topic+dbrn'></span><span id='topic+dbrn_diagSig'></span><span id='topic+dbrn_fixedSig'></span><span id='topic+dou_diagH'></span><span id='topic+dou_diagH_diagSig'></span><span id='topic+dou_diagH_fixedSig'></span><span id='topic+dou_diagH_fixedtheta'></span><span id='topic+dou_diagH_fixedtheta_diagSig'></span><span id='topic+dou_diagH_fixedtheta_fixedSig'></span><span id='topic+dou_diagSig'></span><span id='topic+dou_fixedH'></span><span id='topic+dou_fixedH_diagSig'></span><span id='topic+dou_fixedH_fixedSig'></span><span id='topic+dou_fixedH_fixedtheta'></span><span id='topic+dou_fixedH_fixedtheta_diagSig'></span><span id='topic+dou_fixedSig'></span><span id='topic+dou_fixedtheta'></span><span id='topic+dou_fixedtheta_diagSig'></span><span id='topic+dou_fixedtheta_fixedSig'></span><span id='topic+dou_logdiagH'></span><span id='topic+dou_logdiagH_diagSig'></span><span id='topic+dou_logdiagH_fixedSig'></span><span id='topic+dou_logdiagH_fixedtheta'></span><span id='topic+dou_logdiagH_fixedtheta_diagSig'></span><span id='topic+dou_logdiagH_fixedtheta_fixedSig'></span><span id='topic+dou_logspdH'></span><span id='topic+dou_logspdH_diagSig'></span><span id='topic+dou_logspdH_fixedSig'></span><span id='topic+dou_logspdH_fixedtheta'></span><span id='topic+dou_logspdH_fixedtheta_diagSig'></span><span id='topic+dou_logspdH_fixedtheta_fixedSig'></span><span id='topic+dou_spdH'></span><span id='topic+dou_spdH_diagSig'></span><span id='topic+dou_spdH_fixedSig'></span><span id='topic+dou_spdH_fixedtheta'></span><span id='topic+dou_spdH_fixedtheta_diagSig'></span><span id='topic+dou_spdH_fixedtheta_fixedSig'></span><span id='topic+dou_symH'></span><span id='topic+dou_symH_diagSig'></span><span id='topic+dou_symH_fixedSig'></span><span id='topic+dou_symH_fixedtheta'></span><span id='topic+dou_symH_fixedtheta_diagSig'></span><span id='topic+dou_symH_fixedtheta_fixedSig'></span><span id='topic+hbrn'></span><span id='topic+hbrn_diagSig'></span><span id='topic+hbrn_fixedSig'></span><span id='topic+hou_diagH'></span><span id='topic+hou_diagH_diagSig'></span><span id='topic+hou_diagH_fixedSig'></span><span id='topic+hou_diagH_fixedtheta'></span><span id='topic+hou_diagH_fixedtheta_diagSig'></span><span id='topic+hou_diagH_fixedtheta_fixedSig'></span><span id='topic+hou_diagSig'></span><span id='topic+hou_fixedH'></span><span id='topic+hou_fixedH_diagSig'></span><span id='topic+hou_fixedH_fixedSig'></span><span id='topic+hou_fixedH_fixedtheta'></span><span id='topic+hou_fixedH_fixedtheta_diagSig'></span><span id='topic+hou_fixedSig'></span><span id='topic+hou_fixedtheta'></span><span id='topic+hou_fixedtheta_diagSig'></span><span id='topic+hou_fixedtheta_fixedSig'></span><span id='topic+hou_logdiagH'></span><span id='topic+hou_logdiagH_diagSig'></span><span id='topic+hou_logdiagH_fixedSig'></span><span id='topic+hou_logdiagH_fixedtheta'></span><span id='topic+hou_logdiagH_fixedtheta_diagSig'></span><span id='topic+hou_logdiagH_fixedtheta_fixedSig'></span><span id='topic+hou_logspdH'></span><span id='topic+hou_logspdH_diagSig'></span><span id='topic+hou_logspdH_fixedSig'></span><span id='topic+hou_logspdH_fixedtheta'></span><span id='topic+hou_logspdH_fixedtheta_diagSig'></span><span id='topic+hou_logspdH_fixedtheta_fixedSig'></span><span id='topic+hou_spdH'></span><span id='topic+hou_spdH_diagSig'></span><span id='topic+hou_spdH_fixedSig'></span><span id='topic+hou_spdH_fixedtheta'></span><span id='topic+hou_spdH_fixedtheta_diagSig'></span><span id='topic+hou_spdH_fixedtheta_fixedSig'></span><span id='topic+hou_symH'></span><span id='topic+hou_symH_diagSig'></span><span id='topic+hou_symH_fixedSig'></span><span id='topic+hou_symH_fixedtheta'></span><span id='topic+hou_symH_fixedtheta_diagSig'></span><span id='topic+hou_symH_fixedtheta_fixedSig'></span><span id='topic+nparams_brn'></span><span id='topic+nparams_brn_diagSig'></span><span id='topic+nparams_brn_fixedSig'></span><span id='topic+nparams_ou_diagH'></span><span id='topic+nparams_ou_diagH_diagSig'></span><span id='topic+nparams_ou_diagH_fixedSig'></span><span id='topic+nparams_ou_diagH_fixedtheta'></span><span id='topic+nparams_ou_diagH_fixedtheta_diagSig'></span><span id='topic+nparams_ou_diagH_fixedtheta_fixedSig'></span><span id='topic+nparams_ou_diagSig'></span><span id='topic+nparams_ou_fixedH'></span><span id='topic+nparams_ou_fixedH_diagSig'></span><span id='topic+nparams_ou_fixedH_fixedSig'></span><span id='topic+nparams_ou_fixedH_fixedtheta'></span><span id='topic+nparams_ou_fixedH_fixedtheta_diagSig'></span><span id='topic+nparams_ou_fixedSig'></span><span id='topic+nparams_ou_fixedtheta'></span><span id='topic+nparams_ou_fixedtheta_diagSig'></span><span id='topic+nparams_ou_fixedtheta_fixedSig'></span><span id='topic+nparams_ou_logdiagH'></span><span id='topic+nparams_ou_logdiagH_diagSig'></span><span id='topic+nparams_ou_logdiagH_fixedSig'></span><span id='topic+nparams_ou_logdiagH_fixedtheta'></span><span id='topic+nparams_ou_logdiagH_fixedtheta_diagSig'></span><span id='topic+nparams_ou_logdiagH_fixedtheta_fixedSig'></span><span id='topic+nparams_ou_logspdH'></span><span id='topic+nparams_ou_logspdH_diagSig'></span><span id='topic+nparams_ou_logspdH_fixedSig'></span><span id='topic+nparams_ou_logspdH_fixedtheta'></span><span id='topic+nparams_ou_logspdH_fixedtheta_diagSig'></span><span id='topic+nparams_ou_logspdH_fixedtheta_fixedSig'></span><span id='topic+nparams_ou_spdH'></span><span id='topic+nparams_ou_spdH_diagSig'></span><span id='topic+nparams_ou_spdH_fixedSig'></span><span id='topic+nparams_ou_spdH_fixedtheta'></span><span id='topic+nparams_ou_spdH_fixedtheta_diagSig'></span><span id='topic+nparams_ou_spdH_fixedtheta_fixedSig'></span><span id='topic+nparams_ou_symH'></span><span id='topic+nparams_ou_symH_diagSig'></span><span id='topic+nparams_ou_symH_fixedSig'></span><span id='topic+nparams_ou_symH_fixedtheta'></span><span id='topic+nparams_ou_symH_fixedtheta_diagSig'></span><span id='topic+nparams_ou_symH_fixedtheta_fixedSig'></span><span id='topic+ou_diagH'></span><span id='topic+ou_diagH_diagSig'></span><span id='topic+ou_diagH_fixedSig'></span><span id='topic+ou_diagH_fixedtheta'></span><span id='topic+ou_diagH_fixedtheta_diagSig'></span><span id='topic+ou_diagH_fixedtheta_fixedSig'></span><span id='topic+ou_diagSig'></span><span id='topic+ou_fixedH'></span><span id='topic+ou_fixedH_diagSig'></span><span id='topic+ou_fixedH_fixedSig'></span><span id='topic+ou_fixedH_fixedtheta'></span><span id='topic+ou_fixedH_fixedtheta_diagSig'></span><span id='topic+ou_fixedSig'></span><span id='topic+ou_fixedtheta'></span><span id='topic+ou_fixedtheta_diagSig'></span><span id='topic+ou_fixedtheta_fixedSig'></span><span id='topic+ou_logdiagH'></span><span id='topic+ou_logdiagH_diagSig'></span><span id='topic+ou_logdiagH_fixedSig'></span><span id='topic+ou_logdiagH_fixedtheta'></span><span id='topic+ou_logdiagH_fixedtheta_diagSig'></span><span id='topic+ou_logdiagH_fixedtheta_fixedSig'></span><span id='topic+ou_logspdH'></span><span id='topic+ou_logspdH_diagSig'></span><span id='topic+ou_logspdH_fixedSig'></span><span id='topic+ou_logspdH_fixedtheta'></span><span id='topic+ou_logspdH_fixedtheta_diagSig'></span><span id='topic+ou_logspdH_fixedtheta_fixedSig'></span><span id='topic+ou_spdH'></span><span id='topic+ou_spdH_diagSig'></span><span id='topic+ou_spdH_fixedSig'></span><span id='topic+ou_spdH_fixedtheta'></span><span id='topic+ou_spdH_fixedtheta_diagSig'></span><span id='topic+ou_spdH_fixedtheta_fixedSig'></span><span id='topic+ou_symH'></span><span id='topic+ou_symH_diagSig'></span><span id='topic+ou_symH_fixedSig'></span><span id='topic+ou_symH_fixedtheta'></span><span id='topic+ou_symH_fixedtheta_diagSig'></span><span id='topic+ou_symH_fixedtheta_fixedSig'></span>

<h3>Description</h3>

<p><code>ou_diagH</code>, <code>ou_diagH_fixedtheta_diagSig</code>, etc., restricts the OU model's
parameters. For example, <code>ou_diagH</code> restricts the drift <code class="reqn">H</code> to diagonal matrix,
and <code>ou_diagH_fixedtheta_diagSig</code> further restricts theta to be a constant and
<code class="reqn">\Sigma_x'</code> to be diagonal. A Brownian motion model can be made by these restriction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avail_restrictions

brn_diagSig(parfn)

ou_logdiagH(parfn)

dou_logdiagH(jacfn)

hou_logdiagH(hessfn)

ou_logdiagH_diagSig(parfn)

ou_logspdH_fixedtheta(parfn, theta)

ou_spdH_fixedSig(parfn, Sig)

ou_fixedH_diagSig(parfn, H)

dou_logdiagH_diagSig(jacfn)

dou_logspdH_fixedtheta(jacfn, theta)

dou_spdH_fixedSig(jacfn, Sig)

dou_fixedH_diagSig(jacfn, H)

hou_logdiagH_diagSig(hessfn)

hou_logspdH_fixedtheta(hessfn, jacfn, theta)

hou_spdH_fixedSig(hessfn, jacfn, Sig)

hou_spdH_fixedtheta_fixedSig(hessfn, jacfn, theta, Sig)

hou_fixedH_diagSig(hessfn, H)

nparams_ou_logdiagH(k)

nparams_brn(k)

nparams_ou_spdH_fixedSig(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_restriction_+3A_parfn">parfn</code></td>
<td>
<p>A function that maps from the user-parametrisation to the underlying Gaussian parameters.
Each of them returns a vector of concatenated <code class="reqn">(\Phi, w, V')</code>, where <code class="reqn">V'</code> is the lower triangular
part of <code class="reqn">V</code>, and accepts four arguments: a vector of parameters whose length is specified
by the <code>pardims</code> argument to the <code>glinv_gauss</code> function, the branch length leading to the currently processing node, 
a vector of factors with three levels indicating which dimensions are missing or lost in the mother of
the current node, and a vector of factors with the same three levels indicating missingness of the current
node.</p>
</td></tr>
<tr><td><code id="parameter_restriction_+3A_jacfn">jacfn</code></td>
<td>
<p>A function that accepts the same arguments as <code>parfn</code> and returns the Jacobian
of <code>parfn</code>.</p>
</td></tr>
<tr><td><code id="parameter_restriction_+3A_hessfn">hessfn</code></td>
<td>
<p>A function that accepts the same arguments as <code>parfns</code> and returns a list of three 3D arrays,
named <code>Phi</code>, <code>w</code>, <code>V</code> respectively inside the list. <code>((hessfn)(...))$Phi[m,i,j]</code>
contains the cross second-order partial derivative of <code class="reqn">\Phi_m</code> (here we treat the matrix
<code class="reqn">\Phi</code> as a column-major-flattened vector) with respect to the <code class="reqn">i</code>-th and<code class="reqn">j</code>-th parameters
in the joint <code class="reqn">(H,\theta,\Sigma_x')</code> vector, and
<code>((hessfn)(...))$w[m,i,j]</code> and <code>((hessfn)(...))$V[m,i,j]</code>
analogously contains second-order derivative with respect to <code class="reqn">w_m</code> and <code class="reqn">V'_m</code>.</p>
</td></tr>
<tr><td><code id="parameter_restriction_+3A_h">H</code></td>
<td>
<p>A numerical vector containing the (flattened) fixed parameter <code class="reqn">H</code>.</p>
</td></tr>
<tr><td><code id="parameter_restriction_+3A_theta">theta</code></td>
<td>
<p>A numerical vector containing the (flattened) fixed parameter <code class="reqn">theta</code>.</p>
</td></tr>
<tr><td><code id="parameter_restriction_+3A_sig">Sig</code></td>
<td>
<p>A numerical vector containing the (flattened) fixed parameter <code class="reqn">\Sigma_x'</code>.</p>
</td></tr>
<tr><td><code id="parameter_restriction_+3A_k">k</code></td>
<td>
<p>An integer. The total number of dimensions of the multivariate traits.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Details</h3>



<h4>How reparametrisation and restriction works</h4>

<p>In the simplest form, without any restriction or reparametrisation, the user typically
needs to pass <code>oupar</code>, <code>oujac</code>, <code>ouhess</code>, all of which are simply
functions which maps from the OU parameters <code class="reqn">(H,\theta,\Sigma_x')</code> to the Gaussian
paramters <code class="reqn">(\Phi_i,w_i,V'_i)</code> for each node. For example:
</p>
<pre>
        mod.full = glinv(tree, x0, my_data,
                         parfns  = oupar,
                         pardims = nparams_ou(k),
                         parjacs = oujac,
                         parhess = ouhess)
</pre>
<p>If one would like to restrict <code class="reqn">H</code> to only positively definite diagonal matrices,
then the call should become
</p>
<pre>
        mod.pddiag = glinv(tree, x0, my_data,
                           parfns  = ou_logdiagH(oupar),
                           pardims = nparams_ou_logdiagH(k),
                           parjacs = dou_logdiagH(oujac),
                           parhess = hou_logdiagH(ouhess))
</pre>
<p>Note that there is a naming convention that <code>ou_*</code> should be applied to 'oupar',
<code>dou_*</code> to 'oujac', and <code>hou_*</code> to 'ouhess'. <code>d</code> stands for &lsquo;derivative&rsquo;
and <code>h</code> stands for &lsquo;Hessian&rsquo;.
</p>
<p>In the above call, ou_logdiagH(oupar) accepts the <code>oupar</code> function as argument
and returns a new function. This new function behaves the same way as oupar itself,
except that it expects its first argument (which is the model parameters) to be of
lower dimension, only consisting of <code class="reqn">(h,\theta,\Sigma_x')</code> where <code class="reqn">h</code> is the
diagonal vector of <code class="reqn">H</code>. The following example should be illustrative:
</p>
<pre>
        f = ou_logdiagH(oupar)
        par.full = list(H     = matrix(c(3,0,0,2),2,2), # diagonal matrix
                        theta = c(4,5),
                        sig_x = c(1,0.1,1))
        par.restricted = list(H     = log(diag(par.full$H)),
                              theta = par.full$theta,
                              sig_x = par.full$sig_x)
        print(all.equal(f(unlist(par.restricted),1,NULL,NULL),
                        oupar(unlist(par.full),1,NULL,NULL)))
        # [1] TRUE
</pre>



<h4>Pre-defined restrictions</h4>

<p>The following table summarises all the pre-defined <code>ou_*</code> functions. See <code><a href="#topic+oupar">oupar</a></code>
for precise meaning of the <code class="reqn">(H,\theta,\Sigma_x')</code> mentioned below.
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>R function</strong>   </td><td style="text-align: left;"> <strong>Parameter Format after Restriction</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>brn*</code>           </td><td style="text-align: left;"> <code class="reqn">\Sigma_x'</code>. The Brownian motion. <code class="reqn">H</code> and <code class="reqn">\theta</code> are zero, thus missing.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_diagH_*</code>      </td><td style="text-align: left;"> <code class="reqn">(h,\theta,\Sigma_x')</code>, with <code class="reqn">h=diag(H)</code>, and H is a diagonal matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_logdiagH_*</code>   </td><td style="text-align: left;"> <code class="reqn">(log(h),\theta,\Sigma_x')</code>, with <code class="reqn">h=diag(H)</code>, and H is a diagonal matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_symH_*</code>       </td><td style="text-align: left;"> <code class="reqn">(L,\theta,\Sigma_x')</code>, with <code class="reqn">L</code> being lower-triangular part of the symmetric matrix <code class="reqn">H</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_spdH_*</code>       </td><td style="text-align: left;"> <code class="reqn">(L,\theta,\Sigma_x')</code>, with <code class="reqn">L</code> being Cholesky factor of the S.P.D. matrix <code class="reqn">H</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_logspdH_*</code>    </td><td style="text-align: left;"> <code class="reqn">(L',\theta,\Sigma_x')</code> where <code class="reqn">L'</code> equals <code class="reqn">L</code>, except that on the diagonals <code class="reqn">L'_i</code> = <code class="reqn">log L_i</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_fixedH_*</code>     </td><td style="text-align: left;"> <code class="reqn">(\theta,\Sigma_x')</code>. <code class="reqn">H</code> is constant, hence missing</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_fixedtheta_*</code> </td><td style="text-align: left;"> <code class="reqn">(H,\Sigma_x')</code>. <code class="reqn">\theta</code> is constant, hence missing</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_fixedSig_*</code>   </td><td style="text-align: left;"> <code class="reqn">(H,\theta)</code>. <code class="reqn">\Sigma_x</code> is constant, hence missing</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>*_diagSig_*</code>    </td><td style="text-align: left;"> <code class="reqn">(H,\theta,s)</code> where <code class="reqn">s=diag(\Sigma_x'</code>, with <code class="reqn">\Sigma_x'</code> being a diagonal matrix.
</td>
</tr>

</table>

<p>By Cholesky factor, we mean the only the non-zero part of the lower-triangular Cholesky factor. Restricting <code class="reqn">\Sigma_x'</code> to a diagonal matrix
means that <code class="reqn">\Sigma_x</code> is also diagonal; and the variance of the Brownian motion is <code class="reqn">log(diag(\Sigma_x'))</code>. In other words, the diagonal
restriction is placed on <code class="reqn">\Sigma_x'</code>, not <code class="reqn">\Sigma_x</code>.
</p>



<h4>Finding a list of these restriction functions</h4>

<p>One can use <code>print(avail_restrictions)</code> to see a list of all of these restriction function names.
</p>



<h4>Calling these restriction functions</h4>

<p>All <code>*ou_*</code> or <code>*brn*</code> functions accepts the same arguemnts as <code>ou_logdiagH</code>,
<code>dou_logdiagH</code>, <code>hou_logdiagH</code>, <code>nparams_ou_logdiagH</code> as shown in the Usage
and Arguments section, except that:
</p>

<ol>
<li><p> If the reparametrisation contains any Cholesky decomposition (in other words, the function name
contains <code>spd</code> or <code>logspd</code>) then in the Hessian-level reparameterisation function
(named <code>hou_*</code>) an extra argument <code>jacfn</code> is required.
</p>
</li>
<li><p> If the reparametrisation contains any fixed parameters, extra arguments <code>H</code>, <code>theta</code>,
or <code>Sig</code> are required, depending what is fixed.
</p>
</li></ol>

<p>For example, in the Usage section, <code>ou_logspdH_fixedtheta</code> takes an extra argument <code>theta</code> because
of (2), and <code>hou_spdH_fixedSig</code> takes extra argument two extra arguments because of both (1) and (2) are
true.
</p>


<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+fit'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+fit">fit</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rglinv'>Simulate random trait values from models.</h2><span id='topic+rglinv'></span><span id='topic+rglinv.glinv'></span><span id='topic+rglinv.glinv_gauss'></span>

<h3>Description</h3>

<p>Simulate random trait values from the Gaussian branching process specified by <code>mod</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglinv(mod, par, Nsamp, simplify)

## S3 method for class 'glinv'
rglinv(mod, par, Nsamp = 1, simplify = TRUE)

## S3 method for class 'glinv_gauss'
rglinv(mod, par, Nsamp = 1, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rglinv_+3A_mod">mod</code></td>
<td>
<p>Either a <code>glinv_gauss</code> or <code>glinv</code> object.</p>
</td></tr>
<tr><td><code id="rglinv_+3A_par">par</code></td>
<td>
<p>Parameters underlying the simulation, in the same format as <code>lik.glinv_gauss</code> or <code>lik.glinv</code>.</p>
</td></tr>
<tr><td><code id="rglinv_+3A_nsamp">Nsamp</code></td>
<td>
<p>Number of sample point to simulate.</p>
</td></tr>
<tr><td><code id="rglinv_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE, <code>rglinv.glinv</code> returns an Nsamp-element list with each element being a tip-trait matrix;
otherwise, <code>rglinv.glinv</code> returns an Nsamp-element list with each element being an <code class="reqn">n</code>-element list
of <code class="reqn">k</code>-element trait vectors, where <code class="reqn">n</code> is the number of tips and <code class="reqn">k</code> is the dimension of
each trait vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing Nsamp elements, each of which represents a sample point from the model <code>mod</code>. The
format of each elements depends on the <code>simplify</code> argument.
</p>

<hr>
<h2 id='set_tips'>Set trait values at the tip for a <code>glinv_gauss</code> model.</h2><span id='topic+set_tips'></span><span id='topic+set_tips.glinv_gauss'></span><span id='topic+set_tips.glinv'></span>

<h3>Description</h3>

<p>If a <code>glinv_gauss</code> or <code>glinv</code> object were initalised with <code>X=NULL</code>, methods like
<code>lik</code> will not work because it lacks actual data. In this case, the user
should set the trait values using this method. If trait values were already set before,
they will be replaced with the new trait values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_tips(mod, X)

## S3 method for class 'glinv_gauss'
set_tips(mod, X)

## S3 method for class 'glinv'
set_tips(mod, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_tips_+3A_mod">mod</code></td>
<td>
<p>A <code>glinv_gauss</code> or <code>glinv</code> object.</p>
</td></tr>
<tr><td><code id="set_tips_+3A_x">X</code></td>
<td>
<p>A matrix of trait values, in which <code>X[p,n]</code> stores the p-th dimension
of the multivariate trait of the n-th tip of the phylogeny.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> can contain any <code>NA</code> nor <code>NaN</code> if <code>set_tips</code> is called on a
<code>glinv</code> model but this is will result in error if the method were called on a
<code>glinv_gauss</code> model.
</p>
<p>This method alters an underlying C structure, therefore has a mutable-object
semantic. (See example).
</p>


<h3>Value</h3>

<p>A model whose tip trait values are set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr = ape::rtree(10)
model  = glinv_gauss(tr, x0=c(0,0))  # The `X` argument is implicitly NULL
model2 = model                       # This is not copied!
traits = matrix(rnorm(20), 2, 10)
set_tips(model, traits)
</code></pre>

<hr>
<h2 id='varest'>Estimate the variance-covariance matrix of the maximum likelihood estimator.</h2><span id='topic+varest'></span><span id='topic+varest.glinv'></span>

<h3>Description</h3>

<p><code>varest</code> estimates the uncertainty of an already-computed maximum likelihood estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varest(mod, ...)

## S3 method for class 'glinv'
varest(
  mod,
  fitted,
  method = "analytical",
  numDerivArgs = list(method = "Richardson", method.args = list(d = 0.5, r = 3)),
  num_threads = 2L,
  store_gaussian_hessian = FALSE,
  control.mc = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varest_+3A_mod">mod</code></td>
<td>
<p>An object of class <code>glinv</code></p>
</td></tr>
<tr><td><code id="varest_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="varest_+3A_fitted">fitted</code></td>
<td>
<p>Either an object returned by <code>fit.glinv</code> or a vector of length <code>mod$nparams</code>
that contains the maximum likelihood estimate.</p>
</td></tr>
<tr><td><code id="varest_+3A_method">method</code></td>
<td>
<p>Either &lsquo;analytical&rsquo;, &lsquo;linear&rsquo; or &lsquo;mc&rsquo;. It specifies how the covariance matrix
is computed.</p>
</td></tr>
<tr><td><code id="varest_+3A_numderivargs">numDerivArgs</code></td>
<td>
<p>Arguments to pass to <code>numDeriv::<a href="numDeriv.html#topic+jacobian">jacobian</a></code>. Only used if the
user did not supply <code>parjacs</code> when constructing <code>mod</code>.</p>
</td></tr>
<tr><td><code id="varest_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="varest_+3A_store_gaussian_hessian">store_gaussian_hessian</code></td>
<td>
<p>If <code>TRUE</code> and <code>method</code> is not <code>mc</code>, the returned list will contain
a (usually huge) Hessian matrix <code>gaussian_hessian</code> with respect to the Gaussian
parameters <code class="reqn">\Phi, w, V'</code>. This option significantly increases the amount of memory
the function uses, in order to store the matrix.</p>
</td></tr>
<tr><td><code id="varest_+3A_control.mc">control.mc</code></td>
<td>
<p>A list of additional arguments to pass to the <code>mc</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is <code>analytical</code> then the covariance matrix is estimated by inverting the
negative analytically-computed Hessian at the maximum likelihood estimate; if it is 
<code>mc</code> then the estimation is done by using Spall's Monte Carlo simultaneous perturbation method;
if it is <code>linear</code> then it is done by the &quot;delta method&quot;, which approximates the user
parameterisation with its first-order Taylor expansion.
</p>
<p>The <code>analytical</code> method requires that <code>parhess</code> was specified when 'mod' was created.
The <code>linear</code> method does not use the curvature of the reparameterisation and its result is
sometimes unreliable; but it does not require the use of <code>parhess</code>. The <code>mc</code> method also
does not need <code>parjacs</code>, but the it introduces an additional source complexity and random noise
into the estimation; and a large number of sample may be needed.
</p>
<p>The <code>control.mc</code> can have the following elements:
</p>

<dl>
<dt>Nsamp</dt><dd><p>Integer. Number of Monte Carlo iteration to run. Default is 10000.</p>
</dd>
<dt>c</dt><dd><p>Numeric. Size of perturbation to the parameters. Default is 0.005.</p>
</dd>
<dt>quiet</dt><dd><p>Boolean. Whether to print progress and other information or not. Default is <code>TRUE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>vcov</code></td>
<td>
<p>The estimated variance-covariance matrix of the maximum likelihood estimator.</p>
</td></tr>
<tr><td><code>mlepar</code></td>
<td>
<p>The maximum likelihood estimator passed in by the user.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the log-likelihood at the maximum likelihood estimate. Only exists when <code>method</code> is not <code>mc</code></p>
</td></tr>
<tr><td><code>gaussian_hessian</code></td>
<td>
<p>Optional, only exists when 'store_gaussian_hessian' is TRUE.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Spall JC. Monte Carlo computation of the Fisher information matrix in nonstandard settings. Journal of Computational and Graphical Statistics. 2005 Dec 1;14(4):889-909.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
