<!DOCTYPE html><html><head><title>Help for package shipunov</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shipunov}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%-%'><p>Minus names</p></a></li>
<li><a href='#Adj.Rand'><p>Adjusted Rand index</p></a></li>
<li><a href='#Aggregate1'><p>Aggregates by one vector and uses it for row names</p></a></li>
<li><a href='#Alldups'><p>Finds all duplicates</p></a></li>
<li><a href='#atmospheres'><p>atmospheres</p></a></li>
<li><a href='#Bclabels'><p>Plot bootstrap values</p></a></li>
<li><a href='#Bclust'><p>Bootstrapped hclust</p></a></li>
<li><a href='#BestOverlap'><p>Calculates the best overlap</p></a></li>
<li><a href='#Biarrows'><p>Adds correlation arrows to the scatterplot</p></a></li>
<li><a href='#Biokey'><p>Convert diagnostic keys and classification lists</p></a></li>
<li><a href='#BootA'><p>Bootstrap clustering</p></a></li>
<li><a href='#BootKNN'><p>Bootstrap with kNN</p></a></li>
<li><a href='#BootRF'><p>Bootstrap with 'randomForest()'</p></a></li>
<li><a href='#Boxplots'><p>Grouped boxplots</p></a></li>
<li><a href='#Cdate'><p>System date, time plus easy save history</p></a></li>
<li><a href='#chaetocnema'><p>Chaetocnema flea beetles</p></a></li>
<li><a href='#Cladd'><p>Adds confidence bands to the simple linear model plots</p></a></li>
<li><a href='#Class.sample'><p>Samples along the class labels</p></a></li>
<li><a href='#classifs'><p>Classification lists</p></a></li>
<li><a href='#Classproj'><p>Class projection</p></a></li>
<li><a href='#Clustergram'><p>Clustergram: visualize the cluster structure</p></a></li>
<li><a href='#Coeff.det'><p>Average coefficients of determination for each variable</p></a></li>
<li><a href='#Coml'><p>Compare checklists</p></a></li>
<li><a href='#Cor'><p>Correlation matrix with p-values</p></a></li>
<li><a href='#Cor.vec'><p>Calculates correlation and converts results into the named long vector</p></a></li>
<li><a href='#CVs'><p>Coefficients of variation</p></a></li>
<li><a href='#Ditto'><p>Removes duplicated data values downstream</p></a></li>
<li><a href='#DNN'><p>Distance matrix based kNN classification</p></a></li>
<li><a href='#dolbli'><p>dolbli</p></a></li>
<li><a href='#Dotcharts'><p>Improved dotcharts</p></a></li>
<li><a href='#drosera'><p>drosera</p></a></li>
<li><a href='#Ell'><p>Plot ellipse</p></a></li>
<li><a href='#Ellipses'><p>Confidence ellipses</p></a></li>
<li><a href='#eq'><p>eq</p></a></li>
<li><a href='#Ex.boxplot'><p>Boxplot explanation</p></a></li>
<li><a href='#Ex.col'><p>Examples of colors</p></a></li>
<li><a href='#Ex.font'><p>Examples of fonts</p></a></li>
<li><a href='#Ex.lty'><p>Examples of line types</p></a></li>
<li><a href='#Ex.margins'><p>Example of plot margins</p></a></li>
<li><a href='#Ex.pch'><p>Point examples</p></a></li>
<li><a href='#Ex.plots'><p>Examples of plot types</p></a></li>
<li><a href='#Fence'><p>Colorize tips of 'hclust' plot</p></a></li>
<li><a href='#Files'><p>Textual file system browser</p></a></li>
<li><a href='#Fill'><p>Fill data values downstream, like in spreadsheets</p></a></li>
<li><a href='#Gap.code'><p>Gap coding</p></a></li>
<li><a href='#Gen.cl.data'><p>Generates datasets for clustering</p></a></li>
<li><a href='#Gini'><p>Compute the simple Gini coefficient</p></a></li>
<li><a href='#Gower.dist'><p>Gower distance</p></a></li>
<li><a href='#Gradd'><p>Classification grid and decision boundaries</p></a></li>
<li><a href='#Gridmoon'><p>Draw with 'R'</p></a></li>
<li><a href='#haltica'><p>Haltica flea beetles</p></a></li>
<li><a href='#Hcl2mat'><p>Clustering to matrix</p></a></li>
<li><a href='#Hclust.match'><p>Counts matches between two hierarchical clusterings</p></a></li>
<li><a href='#Hcoords'><p>Calculates coordinates of nodes from 'hclust' plot</p></a></li>
<li><a href='#Histr'><p>Histogram with overlaid curve</p></a></li>
<li><a href='#hrahn'><p>Angiosperm families: morphological characters</p></a></li>
<li><a href='#Hulls'><p>Convex hulls for multiple groups</p></a></li>
<li><a href='#hwc'><p>hwc</p></a></li>
<li><a href='#Infill'><p>Rarefaction curves</p></a></li>
<li><a href='#Jclust'><p>Simple bootstrap and jackknife clustering</p></a></li>
<li><a href='#K'><p>Coefficient of divergence</p></a></li>
<li><a href='#keys'><p>Diagnostic keys</p></a></li>
<li><a href='#Life'><p>Game of Life</p></a></li>
<li><a href='#Linechart'><p>Dotchart-like plot sfor every scaled variable grouped by factor</p></a></li>
<li><a href='#Ls'><p>Ls</p></a></li>
<li><a href='#Mag'><p>Interpreter for effect sizes</p></a></li>
<li><a href='#MDSv'><p>MDS: dimension importance (&quot;explained variance&quot; surrogate)</p></a></li>
<li><a href='#Miney'><p>Miney game</p></a></li>
<li><a href='#Misclass'><p>Misclassification (confusion) table</p></a></li>
<li><a href='#Missing.map'><p>Textual plot of missing data</p></a></li>
<li><a href='#moldino'><p>moldino</p></a></li>
<li><a href='#MrBayes'><p>Calls MrBayes</p></a></li>
<li><a href='#MRH'><p>Matrix Representation of Hierarchical Clustering</p></a></li>
<li><a href='#NC.dist'><p>Normalized Compression Distance</p></a></li>
<li><a href='#Normality'><p>Check normality</p></a></li>
<li><a href='#Overlap'><p>Calculates overlap between polygons</p></a></li>
<li><a href='#pairwise.Eff'><p>Pairwise table of effects with magnitudes</p></a></li>
<li><a href='#pairwise.Rro.test'><p>Robust rank order test post hoc derivative</p></a></li>
<li><a href='#pairwise.Table2.test'><p>Pairwise Chi-squared or Fisher test for 2-dimensional tables</p></a></li>
<li><a href='#Phyllotaxis'><p>Plant phyllotaxis</p></a></li>
<li><a href='#Pinhull'><p>Point in hull</p></a></li>
<li><a href='#plantago'><p>plantago</p></a></li>
<li><a href='#Pleiad'><p>Correlation circles (correlation pleiads)</p></a></li>
<li><a href='#Plot.phylocl'><p>Plot phylogenetic tree with clades collapsed</p></a></li>
<li><a href='#PlotBest.dist'><p>Dotchart which reflects the &quot;best&quot; base distance method</p></a></li>
<li><a href='#PlotBest.hclust'><p>Plots dotchart with best clustering method</p></a></li>
<li><a href='#PlotBest.mdist'><p>Dotchart which reflects the &quot;best&quot; of non-base distances</p></a></li>
<li><a href='#Ploth'><p>Changes the appearance of cluster dendrogram</p></a></li>
<li><a href='#Points'><p>Number of cases in each location reflected in the point size</p></a></li>
<li><a href='#Polyarea'><p>Area of the polygon</p></a></li>
<li><a href='#Polycenter'><p>Center of the polygon</p></a></li>
<li><a href='#Pull'><p>Select rows from data frame</p></a></li>
<li><a href='#R.logo'><p>Imitation (!) of the modern 'R' logo</p></a></li>
<li><a href='#Read.fasta'><p>Read 'FASTA' files</p></a></li>
<li><a href='#Read.tri.nts'><p>Read 'NTSYSpc' files</p></a></li>
<li><a href='#Recode'><p>Basic multiple recoding</p></a></li>
<li><a href='#Root1'><p>Roots phylogenetic trees even if outgroup is not monophyletic</p></a></li>
<li><a href='#Rostova.tbl'><p>Calculates multiple correlation matrices (via 'factor1') and stacks them together</p></a></li>
<li><a href='#Rpart2newick'><p>Converts 'rpart' object into Newick tree</p></a></li>
<li><a href='#Rresults'><p>Rresults shell script</p></a></li>
<li><a href='#Rro.test'><p>Robust rank order test</p></a></li>
<li><a href='#S.value'><p>S-value</p></a></li>
<li><a href='#salix_leaves'><p>salix_leaves</p></a></li>
<li><a href='#Saynodynamite'><p>Say &ldquo;no&rdquo; to dynamite plots!</p></a></li>
<li><a href='#SM.dist'><p>Simple Match distance</p></a></li>
<li><a href='#Squares'><p>Areas of polygons</p></a></li>
<li><a href='#Str'><p>'str()' enchanced for data frames</p></a></li>
<li><a href='#Table2df'><p>Convert table to data frame saving structure</p></a></li>
<li><a href='#Tcoords'><p>Calculates coordinates of tips from 'hclust' plot</p></a></li>
<li><a href='#Tctext'><p>Easy way to add text labels to 'hclust' plot</p></a></li>
<li><a href='#Tobin'><p>Binarize (make dummy variables)</p></a></li>
<li><a href='#Toclip'><p>Insert content to Linux X11 clipboard</p></a></li>
<li><a href='#Topm'><p>Stacks correlation matrix</p></a></li>
<li><a href='#Ttcols'><p>Text-to-columns</p></a></li>
<li><a href='#Updist'><p>Educated distances for semi-supervised clustering</p></a></li>
<li><a href='#Vicinities'><p>Arrange observations by the distance from center</p></a></li>
<li><a href='#VTcoeffs'><p>Effect sizes of association between categorical variables</p></a></li>
<li><a href='#Write.fasta'><p>Write 'FASTA' files</p></a></li>
<li><a href='#Xpager'><p>Separate terminal pager for Linux</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions from Alexey Shipunov</td>
</tr>
<tr>
<td>Version:</td>
<td>1.17.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexey Shipunov [aut, cre], Paul Murrell [ctb], Marcello D'Orazio [ctb], Stephen Turner [ctb], Eugeny Altshuler [ctb], Roland Rau [ctb], Marcus W Beck [ctb], Sebastian Gibb [ctb], Weiliang Qiu [ctb], Emmanuel Paradis [ctb], Roger Koenker [ctb], R Core Team [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>ORPHANED</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for data manipulation, plotting and statistical computing,
 to use separately or with the book "Visual Statistics. Use R!":
 Shipunov (2020) <a href="http://ashipunov.info/shipunov/software/r/r-en.htm">http://ashipunov.info/shipunov/software/r/r-en.htm</a>.
 Dr Alexey Shipunov died in December 2022.
 Most useful functions:
 Bclust(), Jclust() and BootA() which bootstrap hierarchical clustering;
 Recode() which does multiple recoding in a fast, simple and flexible way;
 Misclass() which outputs confusion matrix even if classes are not concerted;
 Overlap() which measures group separation on any projection;
 Biarrows() which converts any scatterplot into biplot;
 and Pleiad() which is fast and flexible correlogram.</td>
</tr>
<tr>
<td>Imports:</td>
<td>PBSmapping, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>apcluster, ape, class, cluster, dbscan, e1071, effsize, grid,
ips, kernlab, MASS, mclust, meanShiftR, nnet, phangorn,
randomForest, rpart, smirnov, StatMatch, tapkee, tree, vegan</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-05 13:41:26 UTC; ripley</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-05 14:42:56</td>
</tr>
<tr>
<td>X-CRAN-Original-Maintainer:</td>
<td>Alexey Shipunov &lt;dactylorhiza@gmail.com&gt;</td>
</tr>
<tr>
<td>X-CRAN-Comment:</td>
<td>Orphaned on 2023-02-05 after Dr Shipunov's death.</td>
</tr>
</table>
<hr>
<h2 id='+25-+25'>Minus names</h2><span id='topic++25-+25'></span>

<h3>Description</h3>

<p>Subtract names from names</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %-% y</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25-+2B25_+3A_x">x</code></td>
<td>
<p>Character vector (likely named) to subtract from</p>
</td></tr>
<tr><td><code id="+2B25-+2B25_+3A_y">y</code></td>
<td>
<p>Subtracting character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of 'x', the function uses 'names(x)'. If 'x' has no names, they will be assigned from values.
</p>


<h3>Value</h3>

<p>Character vector</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(iris[, iris %-% "Species"])
str(iris[, !names(iris) %in% "Species"]) # this is how to make it without %-%
c("apples", "bananas") %-% "apples" # simple character string also works
</code></pre>

<hr>
<h2 id='Adj.Rand'>Adjusted Rand index</h2><span id='topic+Adj.Rand'></span>

<h3>Description</h3>

<p>Adjusted Rand index to compare different clusterings</p>


<h3>Usage</h3>

<pre><code class='language-R'>Adj.Rand(cl1, cl2, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Adj.Rand_+3A_cl1">cl1</code></td>
<td>
<p>First classification (character vector of group names)</p>
</td></tr>
<tr><td><code id="Adj.Rand_+3A_cl2">cl2</code></td>
<td>
<p>Second classification</p>
</td></tr>
<tr><td><code id="Adj.Rand_+3A_...">...</code></td>
<td>
<p>Further arguments to table()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use 'useNA=&quot;ifany&quot;' or similar option to take NAs as a separate class
(for more explanations, see help for table() command).
</p>
<p>Note that in rare cases, Adjusted Rand Index might become negative, this
might be some evidence that differences between two partitions are &quot;worse
than random&quot;, i.e., there is a pattern in differences.
</p>


<h3>Value</h3>

<p>Similarity: numerical vector of length 1</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Hubert L. and Arabie P. 1985. Comparing partitions. Journal of Classification. 2. 193&ndash;218.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Misclass">Misclass</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.dist &lt;- dist(iris[, 1:4], method="manhattan")
iris.hclust &lt;- hclust(iris.dist)
iris.3 &lt;- cutree(iris.hclust, 3)
Adj.Rand(iris.3, iris[, 5])
</code></pre>

<hr>
<h2 id='Aggregate1'>Aggregates by one vector and uses it for row names</h2><span id='topic+Aggregate1'></span>

<h3>Description</h3>

<p>Aggregates by one vector and uses it for row names</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aggregate1(df, by, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aggregate1_+3A_df">df</code></td>
<td>
<p>Data frame to aggregate</p>
</td></tr>
<tr><td><code id="Aggregate1_+3A_by">by</code></td>
<td>
<p>Atomic object to use for aggregating</p>
</td></tr>
<tr><td><code id="Aggregate1_+3A_...">...</code></td>
<td>
<p>Further arguments for 'aggregate()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Aggregate1()' is an 'aggregate()' helper: aggregates only by one atomic variable and uses it for row names.
</p>


<h3>Value</h3>

<p>Same as of 'aggregate()'</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aggregate">aggregate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>trees3 &lt;- sample(letters[1:3], nrow(trees), replace=TRUE)
Aggregate1(trees, trees3, median, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='Alldups'>Finds all duplicates</h2><span id='topic+Alldups'></span>

<h3>Description</h3>

<p>Finds duplicates from both ends, optionally returns indexes of duplicate groups</p>


<h3>Usage</h3>

<pre><code class='language-R'>Alldups(v, groups=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Alldups_+3A_v">v</code></td>
<td>
<p>Vector, matrix or data frame</p>
</td></tr>
<tr><td><code id="Alldups_+3A_groups">groups</code></td>
<td>
<p>If TRUE, returns group indexes (non-duplicated are 0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is extension of duplicated() which _does not_ skip the first
duplicate in each group. 'NA' consider for duplicates but do not count as
duplicate group.
</p>
<p>If the first argument is a matrix or data frame and 'groups=TRUE',
Aldups() starts from converting them into character vector with
paste0(..., collapse=&quot;&quot;).
</p>
<p>If 'groups=TRUE', Alldups() uses as.numeric(as.character(v)) twice to
index duplicated groups with natural numbers (and non-duplicated with 0).
</p>


<h3>Value</h3>

<p>Logical vector of length equal to 'v', or numerical vector if 'groups=TRUE'</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c("one", "two", "", NA, "two", "three", "three", "three", NA, "", "four")
Alldups(aa)
data.frame(v=aa, dups=Alldups(aa), groups=Alldups(aa, groups=TRUE))

## clustering based on duplicates from rounding
(iris.dgr &lt;- Alldups(round(iris[, 1:4]/10), groups=TRUE))
Misclass(iris.dgr, iris$Species, best=TRUE)
</code></pre>

<hr>
<h2 id='atmospheres'>atmospheres</h2><span id='topic+atmospheres'></span>

<h3>Description</h3>

<p>Atmospheres of Solar System.
</p>
<p>Mercury might be easily taken out because it does not have atmosphere in strict sense.
</p>
<p>All data in percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atmospheres</code></pre>


<h3>Source</h3>

<p>Data from the NASA Web site, once was available as 'planetatmoscomp.pdf' document.
</p>

<hr>
<h2 id='Bclabels'>Plot bootstrap values</h2><span id='topic+Bclabels'></span>

<h3>Description</h3>

<p>Print (bootstrap) values on 'hclust' plot</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Bclabels(hcl, values, coords=NULL, horiz=FALSE, method="text",
 threshold=NULL, top=NULL, percent=FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bclabels_+3A_hcl">hcl</code></td>
<td>
<p><code>hclust</code> object</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_values">values</code></td>
<td>
<p><code>numeric</code>, (bootstrap) values to use</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_coords">coords</code></td>
<td>
<p>If NULL (default), coordinates will be calculated with Hcoords(hcl)</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_horiz">horiz</code></td>
<td>
<p>Plot values for a horizontal tree?</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_method">method</code></td>
<td>
<p>If &quot;text&quot; (default), plot text values, if &quot;points&quot;, plot points</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_threshold">threshold</code></td>
<td>
<p>If set, do not plot text or points for values &lt; threshold; respects percents if set</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_top">top</code></td>
<td>
<p>If set as 'n', plot values only for 'n' highest clusters</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_percent">percent</code></td>
<td>
<p>Plot values as percents?</p>
</td></tr>
<tr><td><code id="Bclabels_+3A_...">...</code></td>
<td>
<p>If &quot;text&quot; (default), additional arguments to text(), if &quot;points&quot;, to points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low-level plot function plots text or points in accordance with
bootstrap values to the corresponding node of the plotted 'hclust'
object.
</p>


<h3>Value</h3>

<p>List with components: 'coords' for coordinates, 'labels' for (selected)
values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bclust">Bclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 'atmospheres' data
(bb &lt;- Bclust(t(atmospheres))) # specify 'mc.cores=4' or similar to speed up the process

## standard use
plot(bb$hclust)
Bclabels(bb$hclust, bb$values, col="blue", pos=3, offset=0.1, threshold=0.9)

## 'points' method
plot(bb$hclust)
Bclabels(bb$hclust, bb$values, method="points", threshold=0.9, pch=19, cex=2)

## 'points' which grow with support
plot(bb$hclust)
Bclabels(bb$hclust, bb$values, method="points", pch=19, cex=bb$values*3)

## pre-defined coordinates
coords1 &lt;- Hcoords(bb$hclust)
plot(bb$hclust)
Bclabels(bb$hclust, bb$values, coords=coords1, method="points", pch=19,
 cex=bb$values*3)

## use with horizontal Ploth()
oldpar &lt;- par(mar=c(2,1,0,4))
Ploth(bb$hclust, horiz=TRUE)
Bclabels(bb$hclust, bb$values, col="blue", pos=3, offset=0.1, horiz=TRUE)
par(oldpar)

## 'moldino' data
m.bb &lt;- Bclust(t(moldino)) # specify 'mc.cores=4' or similar to speed up the process
plot(m.bb$hclust)
Bclabels(m.bb$hclust, m.bb$values, col="red", pos=3, offset=0.1, threshold=0.5)

## 'iris' data, with hyper-binding to make number of variables reliable
iris.bb &lt;- Bclust(iris[, rep(1:4, 6)], iter=100) # remove iter=100 for better bootstrap
plot(iris.bb$hclust, labels=FALSE, main="", xlab="", sub="Bootstrap, 100 replicates")
## use 'percent' and 'top'
Bclabels(iris.bb$hclust, iris.bb$values, top=5, percent=TRUE, pos=3, offset=0.1)
Fence(iris.bb$hclust, iris$Species)
legend("topright", legend=levels(iris$Species), col=1:3, lwd=2.5, bty="n")

</code></pre>

<hr>
<h2 id='Bclust'>Bootstrapped hclust</h2><span id='topic+Bclust'></span><span id='topic+plot.Bclust'></span>

<h3>Description</h3>

<p>Bootstraps (or jacknifes) hierarchical clustering</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Bclust(data, method.d="euclidean", method.c="ward.D", FUN=function(.x)
 hclust(dist(.x, method=method.d), method=method.c),iter=1000,
 mc.cores=1, monitor=TRUE, bootstrap=TRUE, relative=FALSE, hclist=NULL)

## S3 method for class 'Bclust'
plot(x, main="", xlab=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bclust_+3A_data">data</code></td>
<td>
<p>Data suitable for the chosen distance method</p>
</td></tr>
<tr><td><code id="Bclust_+3A_method.d">method.d</code></td>
<td>
<p>Method for dist()</p>
</td></tr>
<tr><td><code id="Bclust_+3A_method.c">method.c</code></td>
<td>
<p>Method for hclust()</p>
</td></tr>
<tr><td><code id="Bclust_+3A_fun">FUN</code></td>
<td>
<p>Function to make 'hclust' objects</p>
</td></tr>
<tr><td><code id="Bclust_+3A_iter">iter</code></td>
<td>
<p>Number of replicates</p>
</td></tr>
<tr><td><code id="Bclust_+3A_mc.cores">mc.cores</code></td>
<td>
<p><code>integer</code>, number of processes to run in parallel</p>
</td></tr>
<tr><td><code id="Bclust_+3A_monitor">monitor</code></td>
<td>
<p>If TRUE (default), prints a dot for each replicate</p>
</td></tr>
<tr><td><code id="Bclust_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If FALSE (not default), performs jacknife (and makes
'iter=ncol(data)')</p>
</td></tr>
<tr><td><code id="Bclust_+3A_relative">relative</code></td>
<td>
<p>If TRUE (not default), use the relative matching of
branches (see in Details)</p>
</td></tr>
<tr><td><code id="Bclust_+3A_hclist">hclist</code></td>
<td>
<p>Allows to supply the list of 'hclust' objects</p>
</td></tr>
<tr><td><code id="Bclust_+3A_x">x</code></td>
<td>
<p>Object of the class 'Bclust'</p>
</td></tr>
<tr><td><code id="Bclust_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="Bclust_+3A_xlab">xlab</code></td>
<td>
<p>Horizontal axis label</p>
</td></tr>
<tr><td><code id="Bclust_+3A_...">...</code></td>
<td>
<p>Additional arguments to the plot.hclust()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides bootstrapping for hierarchical clustering
(<code><a href="stats.html#topic+hclust">hclust</a></code> objects). Internally, it uses Hcl2mat() which
converts 'hclust' objects into binary matrix of cluster memberships.
</p>
<p>The default clustering method is the variance-minimizing &quot;ward.D&quot;
(which works better with Euclidean distances); to make it coherent with
hclust() default, specify 'method.c=&quot;complete&quot;'. Also, it sometimes
makes sense to transform non-Euclidean distances into Euclidean with
'dist(_non_euclidean_dist_)'.
</p>
<p>Bclust() and companion functions were based on functions from the
'bootstrap' package of Sebastian Gibb.
</p>
<p>Option 'hclist' presents the special case when list of 'hclust' objects
is pre-build. In that case, other arguments (except 'mc.cores' and
'monitor') will be ignored, and the first component of 'hclist', that
is 'hclist[[1]]', will be used as &quot;original&quot; clustering to compare with
all other objects in the 'hclist'. Number of replicates is the length
of 'hclist' minus one.
</p>
<p>Option 'relative' changes the mechanism of how branches of reference
clustering (&quot;original&quot;) and bootstrapped clustering (&quot;current&quot;)
compared. If 'relative=FALSE' (default), only absolute matches (present
or absent) are count, and vector of matches is binary (either 0 or 1).
If 'relative=TRUE', branches of &quot;original&quot; which have no matches in
&quot;current&quot;, are checked additionally for the similarity with all
branches of &quot;current&quot;, and the minimal (asymmetric) binary
dissimilarity value is used as a match. Therefore, the matching vector
in this case is numeric instead of binary. This will typically result
in the reliable raising of bootstrap values. The underlying methodology
is similar to what is defined in  Lemoine et al. (2018) as a &quot;transfer
bootstrap&quot;. As the asymmetric binary is the _proportion_ of items in
which only one is &quot;1&quot; amongst those which have one or two &quot;1&quot;, it is
possible to rephrase Lemoine et al. (2018), and say that this distance
is equal to the _proportion_ of items that must be _removed_ to make
both branches identical. Please note that with 'relative=TRUE', the
whole algorithm is several times slower then default.
</p>
<p>Please note that Bclust() frequently underestimates the cluster
stability when number of characters is relatively small. One of
possible remedies is to use hyper-binding (like &quot;cbind(data, data,
data)&quot;) to reach the reliable number of characters.
</p>
<p>plot.Bclust() designed for quick plotting and plots labels (bootstrap
support values) with the following defaults: 'percent=TRUE, pos=3,
offset=0.1'. To change how labels are plotted, use separate Bclabels()
command.
</p>


<h3>Value</h3>

<p>Returns object of class 'Bclust' which is a list with components:
'values' for bootstrapped frequencies of each node, 'hcl' for original
'hclust' object, 'consensus' which is a sum of all Hcl2mat() matrices,
'meth' (bootstrap or jacknife), and 'iter', for number of iterations.
</p>


<h3>References</h3>

<p>Felsenstein J. 1985. Confidence limits on phylogenies: an approach
using the bootstrap. Evolution. 39 (4): 783&ndash;791.
</p>
<p>Efron B., Halloran E., Holmes S. 1996. Bootstrap confidence levels for
phylogenetic trees. Proceedings of the National Academy of Sciences. 93
(23): 13429&ndash;13429.
</p>
<p>Lemoine F. et al. 2018. Renewing Felsenstein's phylogenetic bootstrap
in the era of big data. Nature, 556(7702): 452&ndash;456
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jclust">Jclust</a></code>, <code><a href="#topic+BootA">BootA</a></code>, <code><a href="#topic+Hcl2mat">Hcl2mat</a></code>,
<code><a href="#topic+Bclabels">Bclabels</a></code>, <code><a href="#topic+Hcoords">Hcoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- t(atmospheres)

## standard use
(bb &lt;- Bclust(data)) # specify 'mc.cores=4' or similar to speed up the process
plot(bb)

## more advanced plotting with Bclabels()
plot(bb$hclust)
Bclabels(bb$hclust, bb$values, threshold=0.5, col="grey", pos=1)

## how to use the consensus data
plot(hclust(dist(bb$consensus)), main="Net consensus tree") # net consensus
## majority rule is 'consensus &gt;= 0.5', strict is like 'round(consensus) == 1'

## how to make user-defined function
bb1 &lt;- Bclust(t(atmospheres), FUN=function(.x) hclust(Gower.dist(.x)))
plot(bb1)

## how to jacknife
bb2 &lt;- Bclust(data, bootstrap=FALSE, monitor=FALSE)
plot(bb2)

## how to make (and use) the pre-build list of clusterings
hclist &lt;- vector("list", length=0)
hclist[[1]] &lt;- hclust(dist(data)) # "orig" is the first
for (n in 2:101) hclist[[n]] &lt;- hclust(dist(data[, sample.int(ncol(data), replace=TRUE)]))
(bb3 &lt;- Bclust(hclist=hclist))
plot(bb3)

## how to use the relative matching
bb4 &lt;- Bclust(data, relative=TRUE)
plot(bb4)

## how to hyper-bind
bb5 &lt;- Bclust(cbind(data, data, data)) # now data has 24 characters
plot(bb5)

## how to use hclust() defaults
bb6 &lt;- Bclust(data, method.c="complete")
plot(bb6)

</code></pre>

<hr>
<h2 id='BestOverlap'>Calculates the best overlap</h2><span id='topic+BestOverlap'></span>

<h3>Description</h3>

<p>Uses multiple datasets, measures overlaps between class-related convex
hulls and reports the best dataset, the best overlap table and summary
with confidence intervals. Can be used to assess bootstrap or jackknife
results, to compare different dimension reduction and/or clustering
methods, and to average results of stochastic methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BestOverlap(xylabels, ci="95%", round=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BestOverlap_+3A_xylabels">xylabels</code></td>
<td>
<p>List of data frames, each with at least 3 columns named
exactly as: &quot;x&quot; for x coordinates, &quot;y&quot; for y coordinates and &quot;labels&quot;
for class labels</p>
</td></tr>
<tr><td><code id="BestOverlap_+3A_ci">ci</code></td>
<td>
<p>Confidence interval (character string with percent sign)</p>
</td></tr>
<tr><td><code id="BestOverlap_+3A_round">round</code></td>
<td>
<p>How to round numbers in summary table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'BestOverlap()' requires object, typically created after bootstrapping or
similar procedure (see below for examples). This 'xylabels' object must
contain at least three columns named exactly as c(&quot;x&quot;, &quot;y&quot;, &quot;labels&quot;), in
any order.
</p>
<p>Please note that label types must be the same between data frames inside
'xylabels' list. For consistency, first data frame is used as a label
standard. If any next data frame contain label types different from
standard, it will be ignored.
</p>


<h3>Value</h3>

<p>List with three components: 'best' data frame, 'best.overlap' table and
'summary' data frame.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
## Bootstrap PCA
B &lt;- 100
xylabels &lt;- vector("list", length=0)
for (n in 1:B) {
ROWS &lt;- sample(nrow(iris), replace=TRUE)
tmp &lt;- prcomp(iris[ROWS, -5])$x[, 1:2]
xylabels[[n]] &lt;- data.frame(x=tmp[, 1], y=tmp[, 2], labels=iris[ROWS, 5])
}
BestOverlap(xylabels)

## Jacknife PCA
B &lt;- nrow(iris)
xylabels &lt;- vector("list", length=0)
for (n in 1:B) {
ROWS &lt;- (1:B)[-n]
tmp &lt;- prcomp(iris[ROWS, -5])$x[, 1:2]
xylabels[[n]] &lt;- data.frame(x=tmp[, 1], y=tmp[, 2], labels=iris[ROWS, 5])
}
BestOverlap(xylabels)

## Stochastic method: Stochastic Proximity Embedding
library(tapkee)
B &lt;- 100
xylabels &lt;- vector("list", length=0)
for (n in 1:B) {
tmp &lt;- Tapkee(iris[, -5], method="spe")
xylabels[[n]] &lt;- data.frame(x=tmp[, 1], y=tmp[, 2], labels=iris[, 5])
}
BestOverlap(xylabels)

## Diverse dimension reduction methods
library(tapkee)
B &lt;- c("lle", "npe", "ltsa", "lltsa", "hlle", "la", "lpp", "dm", "isomap", "l-isomap")
xylabels &lt;- vector("list", length=0)
for (n in B) {
tmp &lt;- Tapkee(iris[, -5], method=n, add="-k 50")
xylabels[[n]] &lt;- data.frame(x=tmp[, 1], y=tmp[, 2], labels=iris[, 5])
}
BestOverlap(xylabels)

## One dimension reduction but many clusterings
B &lt;- 100
xylabels &lt;- vector("list", length=0)
tmp1 &lt;- prcomp(iris[, -5])$x[, 1:2]
for (n in 1:B) {
tmp2 &lt;- kmeans(iris[, -5], centers=3)$cluster
xylabels[[n]] &lt;- data.frame(x=tmp1[, 1], y=tmp1[, 2], labels=letters[tmp2])
}
BestOverlap(xylabels)



</code></pre>

<hr>
<h2 id='Biarrows'>Adds correlation arrows to the scatterplot</h2><span id='topic+Biarrows'></span>

<h3>Description</h3>

<p>Plots 'orig' variables as arrows on the 'deriv' variables 2D scatterplot</p>


<h3>Usage</h3>

<pre><code class='language-R'>Biarrows(deriv, orig, coeffs=NULL, shrink=0.45, closer=0.9,
 pt.col="forestgreen", pt.cex=1, pt.pch=NA, tx=colnames(orig),
 tx.col="forestgreen", tx.cex=0.8, tx.font=1, tx.pos=NULL, tx.off=0.5, xpd=TRUE,
 ar.col="forestgreen", ar.len=0.05, shift="auto", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Biarrows_+3A_deriv">deriv</code></td>
<td>
<p>Data derived from, e.g., dimension reducion of 'orig'</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_orig">orig</code></td>
<td>
<p>Original data</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_coeffs">coeffs</code></td>
<td>
<p>(Optional) two-column matrix with proposed coordinates of arrow tips, row names must represent 'orig' variables</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_shrink">shrink</code></td>
<td>
<p>How to shrink arrows in relation to 'deriv' ranges, default is 45% (0.45)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_closer">closer</code></td>
<td>
<p>How closer to the center (in relation to the text label) is the arrow tip, default is 0.9</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_pt.col">pt.col</code></td>
<td>
<p>Color of points, default is &quot;forestgreen&quot;</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_pt.cex">pt.cex</code></td>
<td>
<p>Size of points, default is 1</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_pt.pch">pt.pch</code></td>
<td>
<p>Type of points, default is NA (no points)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_tx">tx</code></td>
<td>
<p>Text labels, default are 'colnames(orig)'</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_tx.col">tx.col</code></td>
<td>
<p>Color of text labels, default is &quot;forestgreen&quot;</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_tx.cex">tx.cex</code></td>
<td>
<p>Size of text, default is 0.8</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_tx.font">tx.font</code></td>
<td>
<p>Font of text, default is 1 (plain)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_tx.pos">tx.pos</code></td>
<td>
<p>Position of text, default is NULL (in the center)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_tx.off">tx.off</code></td>
<td>
<p>Offest for text labels, default 0.5 (works only if 'tx.pos' is not NULL)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_xpd">xpd</code></td>
<td>
<p>Allow text to go outside of plotting region?</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_ar.col">ar.col</code></td>
<td>
<p>Color of arrows, default is &quot;forestgreen&quot;</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_ar.len">ar.len</code></td>
<td>
<p>Length of the edges of the arrow head (in inches)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_shift">shift</code></td>
<td>
<p>Shift from the center which is c(0, 0); default is &quot;auto&quot; which is colMeans(deriv)</p>
</td></tr>
<tr><td><code id="Biarrows_+3A_...">...</code></td>
<td>
<p>Further arguments to arrows()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Biarrows() calculates correlations between two sets of variables which
generally belong to the same data: more then one 'orig' variables and
exactly two 'deriv' variables. These correlations might be understood as
importances of the 'orig' variables. Then Biarrows() scales correlations
to the 'deriv' ranges and adds text labels and arrows (possibly also
points) to the scatterplot of derived variables. These arrows represent
the original variables in relation with derived variables. Resulted plot
may be seen as a biplot which simultaneously shows two sets of variables.
In fact, it is possible to show three and more sets of variables (see
examples).
</p>
<p>This approach might work for data derived from (almost) any kind of
dimensional reduction. Biarrows() is also much more flexible than
standard biplot(). Please note, however, that Biarrows() is only
visualization, and numerical conclustions might not be justified.
</p>
<p>If 'deriv' data contains more then 2 variables, the rest will be
discarded. Both 'deriv' and 'orig' should be either data frames or matrices
with column names and compatible dimensions, possibly with NAs.
</p>
<p>Biarrows(dr, coeffs=...) allows to use pre-calculated coefficients. In
that case, 'data' is ignored (except for column names, but they might be
supplied separately as 'tx' value), and 'coeffs' will be scaled. See
examples to understand better how it works.
</p>
<p>To suppress arrows or text, use zero color. Points are suppressed by
default.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+biplot">biplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.cmd &lt;- cmdscale(dist(iris[, -5]))
plot(iris.cmd, xlab="Dim 1", ylab="Dim 2")
Biarrows(iris.cmd, iris[, -5])
title(main="MDS biplot with Biarrows()")

## ===

library(MASS)
iris.mds &lt;- isoMDS(dist(unique(iris[, -5])))
plot(iris.mds$points, xlab="Dim 1", ylab="Dim 2")
Biarrows(iris.mds$points, unique(iris[, -5]))
title(main="Non-metric MDS biplot with Biarrows()")

## ===

library(MASS)
iris.smm &lt;- sammon(dist(unique(iris[, -5])))
plot(iris.smm$points, xlab="Dim 1", ylab="Dim 2")
Biarrows(iris.smm$points, unique(iris[, -5]))
title(main="Sammon mapping biplot with Biarrows()")

## ===

iris.p &lt;- prcomp(iris[, -5], scale=TRUE)
biplot(iris.p, xpd=TRUE, main="Original PCA biplot")
plot(iris.p$x)
Biarrows(iris.p$x, iris[, -5])
title(main="PCA biplot with Biarrows()")

## ===

plot(iris.p$x, xlab="PCA1", ylab="PCA2")
## how to use 'coeffs'
## they also useful as surrogates of variable importances
(coeffs &lt;- cor(iris[, -5], iris.p$x, method="spearman"))
Biarrows(iris.p$x, tx=rownames(coeffs), coeffs=coeffs)

## ===

plot(iris[, c(1, 3)])
Biarrows(iris[, c(1, 3)], iris.p$x)
title(main="\"Reversed biplot\"")

## ===

plot(iris[, c(1, 3)])
Biarrows(iris[, c(1, 3)], iris[, c(2, 4)])
title(main="Iris flowers: lengths vs. widths")

## ===

plot(iris.p$x)
Biarrows(iris.p$x[, 1:2], iris.p$x[, 1:2])
title(main="\"Self-biplot\" on PCA")

## ===

library(MASS)
iris.ldap &lt;- predict(lda(Species ~ ., data=iris), iris[, -5])
plot(iris.ldap$x)
Biarrows(iris.ldap$x, iris[, -5])
Biarrows(iris.ldap$x, iris.p$x[, 1:2], shift=c(9, 2.5),
 shrink=0.95, lty=2, ar.col="darkgrey", tx.col="darkgrey")
title(main="Triplot: LDA, original variables and PCA axes")

## ===

iris.cl &lt;- Classproj(iris[, -5], iris$Species)
plot(iris.cl$proj, col=iris$Species)
Biarrows(iris.cl$proj, iris[, -5])
title(main="Classproj biplot")

</code></pre>

<hr>
<h2 id='Biokey'>Convert diagnostic keys and classification lists</h2><span id='topic+Biokey'></span><span id='topic+Numranks'></span>

<h3>Description</h3>

<p>Convert the oldest biological data structures: diagnostic keys (&quot;keys&quot;) and classification lists (&quot;classifs&quot;)</p>


<h3>Usage</h3>

<pre><code class='language-R'>Biokey(data, from="", to="", recalculate=TRUE, internal=FALSE, force=FALSE)
Numranks(nums=NULL, ranks=NULL, add=NULL, empty="Species")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Biokey_+3A_data">data</code></td>
<td>
<p>Diagnostic keys (&quot;keys&quot;), classification lists (&quot;classifs&quot;) and tables, or Newick phylogeny trees</p>
</td></tr>
<tr><td><code id="Biokey_+3A_from">from</code></td>
<td>
<p>Data type to convert from</p>
</td></tr>
<tr><td><code id="Biokey_+3A_to">to</code></td>
<td>
<p>Data type to convert to</p>
</td></tr>
<tr><td><code id="Biokey_+3A_recalculate">recalculate</code></td>
<td>
<p>Recalculate the numeric ids?</p>
</td></tr>
<tr><td><code id="Biokey_+3A_internal">internal</code></td>
<td>
<p>(For debugging) Output internal 4-column 'key' objects instead?</p>
</td></tr>
<tr><td><code id="Biokey_+3A_force">force</code></td>
<td>
<p>(For debugging) Ignore list of allowable conversion pairs?</p>
</td></tr>
<tr><td><code id="Biokey_+3A_nums">nums</code></td>
<td>
<p>Numbers to convert into ranks</p>
</td></tr>
<tr><td><code id="Biokey_+3A_ranks">ranks</code></td>
<td>
<p>Ranks to convert into numbers</p>
</td></tr>
<tr><td><code id="Biokey_+3A_add">add</code></td>
<td>
<p>Rank-number conversion rule to add (overrides embedded rules)</p>
</td></tr>
<tr><td><code id="Biokey_+3A_empty">empty</code></td>
<td>
<p>What rank to use for empty number?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Biokey() is a way to convert classification lists (&quot;classifs&quot;) or
diagnostic keys into each other. In addition, it handles species
classification tables (&quot;table&quot;) and Newick trees (&quot;newick&quot;).
</p>
<p>To know which conversions are allowed, simply type Biokey() without
arguments (this will also induce the harmless error message).
</p>
<p>Numranks() converts biological rank names into numbers and numbers into
rank names (Shipunov, 2017). To see the embedded conversion table, type
Numranks() without arguments.
</p>
<p>To know more about keys and classifs, read help for &quot;classifs&quot; and &quot;keys&quot;.
</p>
<p>Bracket keys (see help for &quot;keys&quot;) could have more than two conditions,
other keys not, so problems might arise during conversion (see examples).
</p>
<p>Backreferenced keys (see help for &quot;keys&quot;) is just a variety of bracket keys
so the only possible way to make them is from bracket keys.
</p>
<p>Branched key (see help for &quot;keys&quot;) is an indented key with omitted
&quot;indent&quot; column, therefore it does not require the separate conversion
way. See examples about how to convert indent column into actual indents.
</p>
<p>Classification &quot;table&quot; is the data frame where each column represent some
particular rank (see examples to understand better). Similarly to &quot;classif&quot;, 
&quot;table&quot; should use numerical ranks. In this case, numerical ranks should be
column names (see examples).
</p>
<p>When Biokey() converts &quot;classif&quot; to &quot;newick&quot;, it keeps higher group names
as node labels. It does not do that in all other cases.
</p>
<p>It is an open question if phylogeny tree (Newick) should be converted
into &quot;classif&quot; (see help for &quot;classifs&quot;) with all intermediate ranks
propagated (thus frequently become monotypic, i.e. with just one
subgroup), or with only main ranks (whole numbers) propagated, or
terminals (by default, they always have  &quot;species&quot; rank = 1) could follow
much bigger ranks (i.e., &quot;species&quot; = 1 might follow &quot;family&quot; = 3, not
&quot;genus&quot; = 2). At the moment, the last variant is implemented.
</p>
<p>Comparably, &quot;newick&quot; to &quot;classif&quot; conversion does _not_ remove names of
monotypic intermediate taxa, this might result in &quot;crowding&quot; of node
labels (see the example). Also, this conversion automatically propagates
intermediate ranks to make all ranks concerted, this might result in
empty labels.
</p>


<h3>Value</h3>

<p>Typically, the data frame or just a character string (in case of Newick output).
Output may contain column names but this is only to facilitate understanding of
the format and could be stripped without consequences. If 'internal=TRUE',
outputs a standardized 4-column data frame in a form of branched key
(columns 'id', 'description', 'terminal'), plus 'goto' column which might be just NAs.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Shipunov A. 2017. &quot;Numerical ranks&quot; to improve biological nomenclature of
higher groups. See &quot;https://arxiv.org/abs/1708.07260&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classifs">classifs</a></code>, <code><a href="#topic+keys">keys</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Biokey() # makes (harmless) error message but also shows which conversions are available
Numranks() # shows the conversion table

## ===

Numranks(nums=1:7)
Numranks(ranks="kingdom") # "kingdom", "order", "family" and "tribe" translate into Latin

## ===

## three branched keys
i1 &lt;- c("1 A ", "2 B Name1", "2 BB Name2", "1 AA ", "3 C Name3", "3 CC Name4")
i2 &lt;- c("1 A Name1", "2 B Name2", "2 BB ", "3 C Name3", "3 CC Name4")
i3 &lt;- c("1 A Name1", "2 B Name2", "2 BB ", "3 C Name3",
 "3 CC Name4", "2 BBB ", "4 D Name5", "4 DD Name6", "4 DDD Name7")
k1 &lt;- read.table(textConnection(i1), sep=" ", as.is=TRUE)
k2 &lt;- read.table(textConnection(i2), sep=" ", as.is=TRUE)
k3 &lt;- read.table(textConnection(i3), sep=" ", as.is=TRUE)

## convert them into phylogeny trees and plot
t1 &lt;- Biokey(k1, from="branched", to="newick")
t2 &lt;- Biokey(k2, from="branched", to="newick")
t3 &lt;- Biokey(k3, from="branched", to="newick")
library(ape) # load 'ape' to plot Newick trees below
plot(read.tree(text=t1))
plot(read.tree(text=t2))
plot(read.tree(text=t3))

## ===

## Bracket keys
bracket1 &lt;- keys[[1]]
bracket1
Biokey(bracket1, from="bracket", to="backreferenced")
(ii &lt;- Biokey(bracket1, from="bracket", to="indented"))
## Remove third condition to avoid warnings:
Biokey(bracket1[bracket1[, 3] != "Horse", ], from="bracket", to="serial")
(nn &lt;- Biokey(bracket1, from="bracket", to="newick"))
plot.phylo(read.tree(text=nn)) # plot newick as phylogeny trees

## Now convert indent column into actual indents:
for (i in 1:length(ii[, 1])) ii[i, 1] &lt;- paste(rep(" ", ii[i, 1]), collapse="")
## and make also dot leaders
ifelse(!is.na(ii[, 3]), "...", "")
ii

## Branched keys
branched1 &lt;- keys[[3]]
head(branched1)
Biokey(branched1, from="branched", to="bracket")[1:7, ]
Biokey(branched1, from="branched", to="indented")[1:7, ]
Biokey(branched1, from="branched", to="serial")[1:7, ]
(nn &lt;- Biokey(branched1, from="branched", to="newick"))
plot.phylo(read.tree(text=nn))

## Indented keys (same as branched but with indent as first column)
indented0 &lt;- c("0 1 Blue ", "1 2 Gas Sky", "1 2 Liquid ",
 "0 1 Yellow ", "2 3 Star Sun", "2 3 Buttecup Flower")
(indented1 &lt;- read.table(textConnection(indented0), sep=" ", as.is=TRUE))
Biokey(indented1, from="indented", to="bracket")
Biokey(indented1, from="indented", to="serial")
(nn &lt;- Biokey(indented1, from="indented", to="newick"))
plot.phylo(read.tree(text=nn))

## Serial keys
serial1 &lt;- keys[[4]]
head(serial1)
Biokey(serial1, from="serial", to="bracket")[1:7, ]
Biokey(serial1, from="serial", to="indented")[1:7, ]
(nn &lt;- Biokey(serial1, from="serial", to="newick"))
plot.phylo(read.tree(text=nn))

## Classifs
classif2 &lt;- classifs[[2]]
classif2[, 1] &lt;- Numranks(ranks=classif2[, 1], add=c(Series=1.1))
head(classif2)
Biokey(classif2, from="classif", to="table")[1:7, ]
(nn &lt;- Biokey(classif2, from="classif", to="newick"))
tt &lt;- read.tree(text=nn)
plot.phylo(tt, node.depth=2)
nodelabels(tt$node.label, frame="none", bg="transparent", adj=-0.05)

## Classification tables
table0 &lt;- c("FAMILY SUBFAMILY TRIBE GENUS", "Hominidae Homininae Hominini Homo",
 "Hominidae Homininae Hominini Pan", "Hominidae Homininae Gorillini Gorilla",
 "Hominidae Ponginae Ponginini Pongo")
(table1 &lt;- read.table(textConnection(table0), sep=" ", as.is=TRUE, h=TRUE))
names(table1) &lt;- Numranks(ranks=names(table1))
table1
Biokey(table1, from="table", to="classif")

## Newick phylogeny trees
newick1 &lt;- "((Coronopus,Plantago),(Bougueria,(Psyllium_s.str.,Albicans)),Littorella);"
plot.phylo(read.tree(text=newick1))
Biokey(newick1, from="newick", to="classif")

</code></pre>

<hr>
<h2 id='BootA'>Bootstrap clustering</h2><span id='topic+BootA'></span>

<h3>Description</h3>

<p>How to bootstrap clustering with 'ape'</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootA(dat, FUN=function(.x) ape::nj(dist(.x)), iter=1000, mc.cores=1, tresh=50,
 cons=TRUE, prop=0.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootA_+3A_dat">dat</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="BootA_+3A_fun">FUN</code></td>
<td>
<p>how to bootstrap (see examples)</p>
</td></tr>
<tr><td><code id="BootA_+3A_iter">iter</code></td>
<td>
<p>number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="BootA_+3A_mc.cores">mc.cores</code></td>
<td>
<p>how many cores to employ (system-dependent)</p>
</td></tr>
<tr><td><code id="BootA_+3A_tresh">tresh</code></td>
<td>
<p>Threshold for printing bootstrap values</p>
</td></tr>
<tr><td><code id="BootA_+3A_cons">cons</code></td>
<td>
<p>Calculate consensus tree?</p>
</td></tr>
<tr><td><code id="BootA_+3A_prop">prop</code></td>
<td>
<p>0.5 is majority-rule consensus (default), 1 is strict consensus</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is how to bootstrap clustering with 'ape::boot.phylo()'.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bclust">Bclust</a></code>, <code><a href="#topic+BootA">BootA</a></code>, ape::<code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- iris[, -5]
row.names(dat) &lt;- abbreviate(make.names(iris[, 5], unique=TRUE))
iris.BA1 &lt;- BootA(dat, iter=100)
plot(iris.BA1$boot.tree, show.node.label=TRUE)
plot(iris.BA1$cons.tree)
iris.BA2 &lt;- BootA(dat, FUN=function(.x) ape::as.phylo(hclust(dist(.x))), iter=100)
## Not run: 
## change (or remove) 'mc.cores=...' in accordance with your system features
iris.BA3 &lt;- BootA(dat, FUN=function(.x) phangorn::NJ(dist(.x)), iter=100,
 mc.cores=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='BootKNN'>Bootstrap with kNN</h2><span id='topic+BootKNN'></span>

<h3>Description</h3>

<p>How to bootstrap with kNN (and DNN)</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootKNN(data, classes, sub="none", nsam=4, nboot=1000, misclass=TRUE, method="knn", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootKNN_+3A_data">data</code></td>
<td>
<p>Data frame to classify</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_classes">classes</code></td>
<td>
<p>Character vector of class names</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_sub">sub</code></td>
<td>
<p>Subsample to use (see example)</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_nsam">nsam</code></td>
<td>
<p>Number of training items from each level of grouping factor, default 4</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_nboot">nboot</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_misclass">misclass</code></td>
<td>
<p>Calculate misclassification table?</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_method">method</code></td>
<td>
<p>Either &quot;knn&quot; (class::knn()) or &quot;dnn&quot; (shipunov::Dnn())</p>
</td></tr>
<tr><td><code id="BootKNN_+3A_...">...</code></td>
<td>
<p>Further arguments to method functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples equal numbers ('nsam') of training items from
<em>each level</em> of grouping factor.
</p>
<p>It also allows to use <em>sub</em>set of data which will be used for
sub-sampling of training data.
</p>


<h3>Value</h3>

<p>Returns all predictions as character matrix, each boot is a column</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code>class::<a href="class.html#topic+knn">knn</a></code>, <code><a href="#topic+Dnn">Dnn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.sub &lt;- 1:nrow(iris) %in% seq(1, nrow(iris), 5)
iris.bootknn &lt;- BootKNN(iris[, -5], iris[, 5], sub=iris.sub)
## calculate and plot stability
st &lt;- apply(iris.bootknn, 1, function(.x) var(as.numeric(as.factor(.x))))
plot(prcomp(iris[, -5])$x, col=iris$Species, pch=ifelse(st == 0, 19, 1))
## boot Dnn
BootKNN(iris[, -5], iris[, 5], nboot=50, method="dnn",
 k=1, FUN=function(.x) Gower.dist(.x))
</code></pre>

<hr>
<h2 id='BootRF'>Bootstrap with 'randomForest()'</h2><span id='topic+BootRF'></span>

<h3>Description</h3>

<p>How to bootstrap with 'randomForest()'</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootRF(data, classes, sub="none", nsam=4, nboot=1000, misclass=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootRF_+3A_data">data</code></td>
<td>
<p>Data frame to classify</p>
</td></tr>
<tr><td><code id="BootRF_+3A_classes">classes</code></td>
<td>
<p>Character vector of class names</p>
</td></tr>
<tr><td><code id="BootRF_+3A_sub">sub</code></td>
<td>
<p>Subsample to use (see example)</p>
</td></tr>
<tr><td><code id="BootRF_+3A_nsam">nsam</code></td>
<td>
<p>Number of training items from each level of grouping factor, default 4</p>
</td></tr>
<tr><td><code id="BootRF_+3A_nboot">nboot</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="BootRF_+3A_misclass">misclass</code></td>
<td>
<p>Calculate misclassification table?</p>
</td></tr>
<tr><td><code id="BootRF_+3A_...">...</code></td>
<td>
<p>Further options to randomForest()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that as randomForest::randomForest() is based on sampling, BootRF()
is the kind of second-level bootstrap.
</p>
<p>BootRF() is very simple and does not interact with Random Forest
algorithms. It is stratified, i.e. samples equal numbers ('nsam') of
training items from the <em>each level</em> of grouping factor.
</p>
<p>Also, it allows to use the <em>sub</em>set of data which will be in turn
used for sub-sampling of training data.
</p>


<h3>Value</h3>

<p>Returns all predictions as character matrix, each boot is a column</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code>randomForest::<a href="randomForest.html#topic+randomForest">randomForest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.sub &lt;- 1:nrow(iris) %in% seq(1, nrow(iris), 5)

## could be slow
iris.bootrf &lt;- BootRF(iris[, -5], iris[, 5], sub=iris.sub)
iris.bootrf &lt;- BootRF(iris[, -5], iris[, 5]) # naturally, lower
## calculate and plot stability
st &lt;- apply(iris.bootrf, 1, function(.x) var(as.numeric(as.factor(.x))))
plot(prcomp(iris[, -5])$x, col=iris$Species, pch=ifelse(st == 0, 19, 1))

</code></pre>

<hr>
<h2 id='Boxplots'>Grouped boxplots</h2><span id='topic+Boxplots'></span>

<h3>Description</h3>

<p>Boxplots for every scaled variable grouped by factor</p>


<h3>Usage</h3>

<pre><code class='language-R'>Boxplots(vars, groups, boxcols=Pastels, legpos="topleft", srt=45, adj=1,
 slty=3, yticks=FALSE, ymarks=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Boxplots_+3A_vars">vars</code></td>
<td>
<p>data frame consists of variables to plot</p>
</td></tr>
<tr><td><code id="Boxplots_+3A_groups">groups</code></td>
<td>
<p>grouping factor</p>
</td></tr>
<tr><td><code id="Boxplots_+3A_boxcols">boxcols</code></td>
<td>
<p>colors of character boxes, default is 'Pastels', i.e. c(&quot;white&quot;, &quot;lightblue&quot;, &quot;mistyrose&quot;, &quot;lightcyan&quot;, &quot;lavender&quot;, &quot;cornsilk&quot;)</p>
</td></tr>
<tr><td><code id="Boxplots_+3A_legpos">legpos</code></td>
<td>
<p>where to place automatic legend, default is 'topleft', for no legend use 'legpos=NA'</p>
</td></tr>
<tr><td><code id="Boxplots_+3A_slty">slty</code></td>
<td>
<p>line type to delimit groups of boxes</p>
</td></tr>
<tr><td><code id="Boxplots_+3A_srt">srt</code>, <code id="Boxplots_+3A_adj">adj</code>, <code id="Boxplots_+3A_yticks">yticks</code>, <code id="Boxplots_+3A_ymarks">ymarks</code></td>
<td>
<p>regular 'plot()' arguments</p>
</td></tr>
<tr><td><code id="Boxplots_+3A_...">...</code></td>
<td>
<p>additional arguments to 'boxplot()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many ways to represent groups in data. One is trellis plots. 'Boxplots()' make grouped plots which fit the plot box linearly and therefore easy to compare. So the main idea for grouped plots is to make comparison easier.
</p>
<p>Please note that because characters within group are likely of different nature, they are scaled. Consequently, tick marks are removed as they have no sense.
</p>
<p>Alternatives: trellis designs.
</p>


<h3>Value</h3>

<p>For the efficiency reasons, the function does not return anything.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="#topic+Linechart">Linechart</a></code>, <code><a href="#topic+Dotchart3">Dotchart3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Trees &lt;- trees
Trees[, 4] &lt;- sample(letters[1:3], nrow(Trees), replace=TRUE)
Boxplots(Trees[, 1:3], factor(Trees[, 4]), srt=0, adj=c(.5, 1)) # horizontal labels

sp &lt;- Recode(eq_s$N.POP, eq_l$N.POP, eq_l$SPECIES)
eq &lt;- cbind(sp=as.factor(sp), eq_s[, -1])
eq3 &lt;- eq[eq$sp %in% levels(eq$sp)[1:3], ]
Boxplots(eq3[, 2:9], eq3[, 1], boxcols=grey(1:3/3), slty=0) # no border lines
</code></pre>

<hr>
<h2 id='Cdate'>System date, time plus easy save history</h2><span id='topic+Cdate'></span><span id='topic+Ctime'></span><span id='topic+Save.history'></span>

<h3>Description</h3>

<p>System date in 'yyyymmdd' format, system time in 'yyyymmdd_hhmmss' format plus easy save history</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cdate()
Ctime()
Save.history()
</code></pre>


<h3>Details</h3>

<p>System date / time in compact formats. These formats are by experience, the most appropriate formats both for file systems and for spreadsheets.
</p>
<p>There is also easy 'savehistory' (does not work under macOS R GUI &ndash; but works under macOS 'Terminal.app' R).
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+savehistory">savehistory</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Cdate()
Ctime()
## Not run: 
## does not work under macOS GUI
Save.history()

## End(Not run)
</code></pre>

<hr>
<h2 id='chaetocnema'>Chaetocnema flea beetles</h2><span id='topic+chaetocnema'></span>

<h3>Description</h3>

<p>Lubischew data (1962, pp. 465&ndash;468, tables 4&ndash;6): 74 Chaetocnema flea beetles specimens which belong to three cryptic species.
</p>
<p>Sources of specimens:
</p>
<p>Chaetocnema concinna Marsh:
</p>
<p>1-6 Environs of Uljianovsk;
7 Khvalynsk, the Volga;
8-9 Perm;
10-14 Environs of Leningrad;
15-17 The Ukraine;
18 Ashkhabad, Turkmenistan;
19-21 France.
</p>
<p>Ch. heikertintgeri Lubis.:
</p>
<p>1-8 Environs of Uljianovsk;
9 Khvalynsk;
10-14 Perm;
15-17 Environs of Leningrad;
18-20 The Ukraine;
21 Ustj-Zilma;
22 Gagra, Abkhazia;
23-27 Ussuri district;
28-29 Yakutsk district;
30 Khabarovsk;
31 Germany.
</p>
<p>Ch. heptapotamnica Lubis.:
</p>
<p>1-18 Environs of Lake Issyk-Kul, Kirghizia;
19 Alma-ata, Kazachstan;
20-22 Environs of Frunze, Kirghizia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chaetocnema</code></pre>


<h3>Format</h3>

<p>These data frame contains the following columns:
</p>

<dl>
<dt><code>Species</code></dt><dd><p>Species epithet</p>
</dd>
<dt><code>No</code></dt><dd><p>Number of sample (see below)</p>
</dd>
<dt><code>x10</code></dt><dd><p>Width of the first joint of the first tarsus (the sum of measurements for both tarsi), in microns</p>
</dd>
<dt><code>x12</code></dt><dd><p>The same for the second joint</p>
</dd>
<dt><code>x14</code></dt><dd><p>The maximal width of the aedeagus in the fore-part, in microns</p>
</dd>
<dt><code>x18</code></dt><dd><p>The front angle of the aedeagus, 1 unit = 7.5 degrees</p>
</dd>
<dt><code>x40</code></dt><dd><p>The maximal width of the head between the external edges of the eyes, in 0.01 mm</p>
</dd>
<dt><code>x48</code></dt><dd><p>The aedeagus width from the side, in microns</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lubischew A.A. 1962. On the use of discriminant functions in taxonomy. Biometrics. 18:455&ndash;477.
</p>

<hr>
<h2 id='Cladd'>Adds confidence bands to the simple linear model plots</h2><span id='topic+Cladd'></span>

<h3>Description</h3>

<p>Adds confidence bands to the simple linear model plots</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cladd(model, data, level=.95, lty=2, ab.lty=0, col="black", ab.col="black")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cladd_+3A_model">model</code></td>
<td>
<p>Simple linear model name</p>
</td></tr>
<tr><td><code id="Cladd_+3A_data">data</code></td>
<td>
<p>Original data</p>
</td></tr>
<tr><td><code id="Cladd_+3A_level">level</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="Cladd_+3A_lty">lty</code></td>
<td>
<p>Confidence bands line type</p>
</td></tr>
<tr><td><code id="Cladd_+3A_ab.lty">ab.lty</code></td>
<td>
<p>Regression line type</p>
</td></tr>
<tr><td><code id="Cladd_+3A_col">col</code></td>
<td>
<p>Confidence bands line color</p>
</td></tr>
<tr><td><code id="Cladd_+3A_ab.col">ab.col</code></td>
<td>
<p>Regression line color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Cladd()' adds confidence bands to the simple linear model plots.
Works only for simple lm(y ~ x) objects!
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hg.lm &lt;- lm(Height ~ Girth, data=trees)
plot(Height ~ Girth, data=trees)
Cladd(hg.lm, data=trees, ab.lty=1)
</code></pre>

<hr>
<h2 id='Class.sample'>Samples along the class labels</h2><span id='topic+Class.sample'></span>

<h3>Description</h3>

<p>Stratified sampling: sample separately within each class</p>


<h3>Usage</h3>

<pre><code class='language-R'>Class.sample(lbls, nsam=NULL, prop=NULL, uniform=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Class.sample_+3A_lbls">lbls</code></td>
<td>
<p>Vector of labels convertable into factor</p>
</td></tr>
<tr><td><code id="Class.sample_+3A_nsam">nsam</code></td>
<td>
<p>Number of samples to take from each class</p>
</td></tr>
<tr><td><code id="Class.sample_+3A_prop">prop</code></td>
<td>
<p>Proportion of samples to take from each class</p>
</td></tr>
<tr><td><code id="Class.sample_+3A_uniform">uniform</code></td>
<td>
<p>Uniform instead of random?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Class.sample()' splits labels into groups in accordance with classes,
and samples each of them separately. If 'prop' is specified, then number
of samples in each class calculated separately from this value. Of both
'nsam' and 'prop' specified, preference is given to 'prop'.
</p>
<p>Uniform method samples each n-th member of the class to reach the desired
sample size.
</p>
<p>If sample size is bigger then class size, the whole class will be sampled.
</p>
<p>Class.sample() uses the ave() internally, and can be easily extended, for
example, to make k-fold sampling, like:
</p>
<p>ave(seq_along(lbls), lbls,
FUN=function(.x) cut(sample(length(.x)), breaks=k, labels=FALSE))
</p>


<h3>Value</h3>

<p>Logical vector of length equal to 'vector'</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(sam &lt;- Class.sample(iris$Species, nsam=5))
iris.trn &lt;- iris[sam, ]
iris.tst &lt;- iris[!sam, ]

(sample1 &lt;- Class.sample(iris$Species, nsam=10))
table(iris$Species, sample1)
(sample2 &lt;- Class.sample(iris$Species, prop=0.2))
table(iris$Species, sample2)
(sample3 &lt;- Class.sample(iris$Species, nsam=10, uniform=TRUE))
table(iris$Species, sample3)
(sample4 &lt;- Class.sample(iris$Species, prop=0.2, uniform=TRUE))
table(iris$Species, sample4)
</code></pre>

<hr>
<h2 id='classifs'>Classification lists</h2><span id='topic+classifs'></span>

<h3>Description</h3>

<p>Classification lists ('classifs') are probably one of the most ancient
attempts to represent biological diversity, the ordered heterogeneity of
living things. In biological systematics, they dated from 1753 when
Linnaeus published his &quot;Species Plantarum&quot;:
</p>

<p><img src="../help/figures/linnaeus1753classif.png" width="50%" alt="Figure: linnaeus1753classif.png" />

</p>
<p>(here on the first page of this book four ranks and five names are
represented: class (&quot;Monandria&quot;), order (&quot;Monogynia&quot;), genus (&quot;Canna&quot;)
and species (&quot;Canna indica&quot; and &quot;Canna angustilolia&quot;))
</p>
<p>In essence, classifs require only two columns: rank and name (in that
order) so they are easy to standardize as two-column data frames.
However, we need to know how to order the ranks. One way is to convert
ranks into numbers (Shipunov, 2017). Numranks() implements this
functionality.
</p>
<p>It is possible to extend classifs with more columns: synonyms, name
comments and taxonomic comments. Synonyms (the third column) are
especially useful; each synonym will be then one row where second
position is a valid name and third position is (one of) synonyms.
</p>
<p>Please note that while 'classifs' as data frames are human-readable, they
are not typographic. To make them better suited for publication, one
might convert them into LaTeX where many packages could be used to
typeset classifications (for example, my 'classif2' package).
</p>
<p>Note also that in classif, species names must be given in full (in
biology, species name consists of two words, (a) genus name and (b)
species epithet). One of examples below shows how to replace
abbreviations with full genus names. </p>


<h3>Usage</h3>

<pre><code class='language-R'>classifs
</code></pre>


<h3>Format</h3>

<p>The list with two data frames representing 'classifs', classification
lists. First is the classif with textual ranks, second with numerical
ranks. Both based on some classifications of Plantago (ribworts,
plantains), first (Shipunov, 2000) include species only from European
Russia, the other is from the oldest Plantago monograph (Barneoud, 1845).
</p>


<h3>Source</h3>

<p>Linnaeus C. 1753. Species Plantarum. Holmieae.
</p>
<p>Barneoud F.M. 1845. Monographie generale de la familie des
Plantaginaceae. Paris.
</p>
<p>Shipunov A. 2019. classif2 &ndash; Biological classification tables. Version
2.2. See &quot;https://ctan.org/pkg/classif2&quot;.
</p>
<p>Shipunov A. 2000. The genera Plantago L. and Psyllium Mill.
(Plantaginaceae Juss.) in the flora of East Europe. T. Novosti
Systematiki Vysshikh Rastenij. 32: 139&ndash;152. [In Russian]
</p>
<p>Shipunov A. 2017. &quot;Numerical ranks&quot; to improve biological nomenclature of
higher groups. 2017. See &quot;https://arxiv.org/abs/1708.07260&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Biokey">Biokey</a></code>, <code><a href="#topic+Numranks">Numranks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## European Russian species classif
plevru &lt;- classifs$plevru
## convert rank names into numbers
plevru[, 1] &lt;- Numranks(ranks=plevru[, 1], add=c(Series=1.1))

## now convert into Newick tree and plot it
plevru.n &lt;- Biokey(plevru, from="classif", to="newick")
library(ape) # to plot, load the 'ape' package
plot(read.tree(text=plevru.n))

## convert classif to taxonomic table
plevru.t &lt;- Biokey(plevru, from="classif", to="table")
colnames(plevru.t) &lt;- Numranks(nums=as.numeric(colnames(plevru.t)))
plevru.t

## two Newick trees
aa &lt;- "(A,(B,C),(D,E));"
bb &lt;- "((A,(B,C)),(D,E));"
## convert them to classif
aa.c &lt;- Biokey(aa, from="newick", to="classif")
bb.c &lt;- Biokey(bb, from="newick", to="classif")
## ... and back to Newick
aa.n &lt;- Biokey(aa.c, from="classif", to="newick")
bb.n &lt;- Biokey(bb.c, from="classif", to="newick")

## how to convert abbreviated species names
spp &lt;- c ("Plantago afra", "P. arborescens", "P. arenaria")
stt &lt;- do.call(rbind, strsplit(spp, " "))
stt[, 1] &lt;- Fill(stt[, 1], "P.")
(res &lt;- apply(stt, 1, paste, collapse=" "))
</code></pre>

<hr>
<h2 id='Classproj'>Class projection</h2><span id='topic+Classproj'></span>

<h3>Description</h3>

<p>Class projection which preserves distances between class centers</p>


<h3>Usage</h3>

<pre><code class='language-R'>Classproj(data, classes, method="DMS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Classproj_+3A_data">data</code></td>
<td>
<p>Data: must be numeric and convertible into matrix</p>
</td></tr>
<tr><td><code id="Classproj_+3A_classes">classes</code></td>
<td>
<p>Class labels (correspond to data rows), NAs are allowed (sic!)</p>
</td></tr>
<tr><td><code id="Classproj_+3A_method">method</code></td>
<td>
<p>Either &quot;DMS&quot; for Dhillon et al., 2002 or &quot;QJ&quot; for Qiu and Joe, 2006</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Classproj' is the leveraged (supervised) or educated (semi-supervised)
manifold learning (dimension reduction). See examples for the variety of
its uses.
</p>
<p>It uses classes to determine centers and then tries to preserve distances
between centers; two methods are possible: &quot;DMS&quot; which is slightly
faster, and &quot;QJ&quot; which frequently finds a better projection.
</p>
<p>The code is based on the functions from 'clusterGeneration' package from
Weiliang Qiu.
</p>


<h3>Value</h3>

<p>Returns list with 'proj' coordinates of projected data points and
'centers' coordinates of class centers.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Dhillon I.S., Modha D.S., Spangler W.S. 2002. Class visualization of
high-dimensional data with applications. Computational Statistics and
Data Analysis. 41: 59&ndash;90.
</p>
<p>Qiu W.-L., Joe H. 2006. Separation index and partial membership for
clustering. Computational Statistics and Data Analysis. 50: 585&ndash;603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Leveraged approach (all classes are known)
iris.dms &lt;- Classproj(iris[, -5], iris$Species, method="DMS")
plot(iris.dms$proj, col=iris$Species)
text(iris.dms$centers, levels(iris$Species), col=1:3)

iris.qj &lt;- Classproj(iris[, -5], iris$Species, method="QJ")
plot(iris.qj$proj, col=iris$Species)
text(iris.qj$centers, levels(iris$Species), col=1:3)

## Educated approach (classes are known only for 10 data points per class)
sam &lt;- Class.sample(iris$Species, 10)
newclasses &lt;- iris$Species
newclasses[!sam] &lt;- NA

iris.dms &lt;- Classproj(iris[, -5], newclasses)
plot(iris.dms$proj, col=iris$Species, pch=ifelse(sam, 19, 1))
text(iris.dms$centers, levels(iris$Species), col=1:3)

iris.qj &lt;- Classproj(iris[, -5], newclasses, method="QJ")
plot(iris.qj$proj, col=iris$Species, pch=ifelse(sam, 19, 1))
text(iris.qj$centers, levels(iris$Species), col=1:3)

## Automated approach (classes calculated automatically)
## Good to visualize _any_ clustering or learning
iris.km &lt;- kmeans(iris[, -5], 3)

iris.dms &lt;- Classproj(iris[, -5], iris.km$cluster)
plot(iris.dms$proj, col=iris.km$cluster)
text(iris.dms$centers, labels=1:3, col=1:3, cex=2)

iris.qj &lt;- Classproj(iris[, -5], iris.km$cluster, method="QJ")
plot(iris.qj$proj, col=iris.km$cluster)
text(iris.qj$centers, labels=1:3, col=1:3, cex=2)
</code></pre>

<hr>
<h2 id='Clustergram'>Clustergram: visualize the cluster structure</h2><span id='topic+Clustergram'></span>

<h3>Description</h3>

<p>Plot which shows cluster memberships and distances when clusters numbers increases</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  Clustergram(data, maxcl=ncol(data)*2, nboot=FALSE, method="kmeans",
  m.dist="euclidean", m.hclust="complete", plot=TRUE, broom=4e-3,
  col="gray", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clustergram_+3A_data">data</code></td>
<td>
<p>Data, typically data frame</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_maxcl">maxcl</code></td>
<td>
<p>Maximal number of clusters, default is number of columns times 2; minimal number of clusters is 2</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_nboot">nboot</code></td>
<td>
<p>Either 'FALSE' (no bootstrap, default) or number of bootstrap runs</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_method">method</code></td>
<td>
<p>Either 'kmeans' or 'hclust'</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_m.dist">m.dist</code></td>
<td>
<p>If method='hclust', method to calculate distances, see ?dist</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_m.hclust">m.hclust</code></td>
<td>
<p>If method='hclust', method to clusterize, see ?hclust</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_plot">plot</code></td>
<td>
<p>Plot?</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_broom">broom</code></td>
<td>
<p>Extent to which spread lines, default is 4e-3</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_col">col</code></td>
<td>
<p>Color of lines</p>
</td></tr>
<tr><td><code id="Clustergram_+3A_...">...</code></td>
<td>
<p>Further arguments to plot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clustergram shows how cluster members are assigned to clusters as the
number of clusters increases. This graph is useful in exploratory
analysis for non-hierarchical clustering algorithms like k-means and for
hierarchical cluster algorithms when the number of observations is large
enough to make dendrograms impractical (from Schonlau, 2004; see also
www.schonlau.net).
</p>
<p>One application is to use clustergram to determine the optimal number of
clusters. Basic idea is that you look for the point (number of clusters)
where more clusters do not significanly change the picture (i.e., do not
add more information) The best number of clusters is _near_ that point
(see examples).
</p>
<p>See also Martin Fleischmann (martinfleischmann.net) for practical
explanation and scikit-learn 'clustergram' Python package.
</p>
<p>Clustergram() code based on simplified and optimized Tal Galili's github
'clustergram' code.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Schonlau M. 2004. Visualizing non-hierarchical and hierarchical cluster
analyses with clustergrams. Computational Statistics 19, 95-111.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(250)
aa &lt;- matrix(rnorm(20000), nrow=100)
## maximal number of clusters is less than default
## line color is like in scikit-learn
## larger "broom" so lines are a bit broader
Clustergram(aa, maxcl=5, col="#3B6E8C", broom=2e-2, main="Artificial data, homogeneous")
aa[1:60, ] &lt;- aa[1:60, ] + 0.7
aa[1:20, ] &lt;- aa[1:20, ] + 0.4
Clustergram(aa, maxcl=5, col="#F29528", broom=2e-2,
 main="Artificial data, heterogeneous, 3 clusters")

## Clustergram() invisibly outputs matrix of clusters
ii &lt;- Clustergram(iris[, -5], main=expression(bolditalic("Iris")*bold(" data")))
head(ii)
## Hierarchical clustering instead of kmeans
Clustergram(iris[, -5], method="hclust", m.hclust="average", main="Iris, UPGMA")
## Bootstrap. Resulted PDF could be opening slowly, use raster images in that case
Clustergram(iris[, -5], nboot=100, col=adjustcolor("darkgray", alpha.f=0.3),
 main="Iris, kmeans, nboot 100")

</code></pre>

<hr>
<h2 id='Coeff.det'>Average coefficients of determination for each variable</h2><span id='topic+Coeff.det'></span>

<h3>Description</h3>

<p>Average coefficients of determination for each variable</p>


<h3>Usage</h3>

<pre><code class='language-R'>Coeff.det(X, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coeff.det_+3A_x">X</code></td>
<td>
<p>Data frame or matrix with values</p>
</td></tr>
<tr><td><code id="Coeff.det_+3A_...">...</code></td>
<td>
<p>Arguments to 'cor()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Average coefficients of determination for each variable.
</p>
<p>Allows to compare various correlation structures (Rostova, 1999; Rostova,
2002).
</p>


<h3>Value</h3>

<p>Numerical vector of coefficients of determination</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Rostova N.S. 1999. The variability of correlations systems between the
morphological characters. Part 1. Natural populations of Leucanthemum
vulgare (Asteraceae). Botanicheskij Zhurnal. 84(11): 50&ndash;66.
</p>
<p>Rostova N.S. 2002. Correlations: Structure and Variability. Saint
Petersburg, St. Petersburg University Publisher.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Coeff.det(trees, use="pairwise") </code></pre>

<hr>
<h2 id='Coml'>Compare checklists</h2><span id='topic+Coml'></span><span id='topic+summary.Coml'></span>

<h3>Description</h3>

<p>Compare species checklists</p>


<h3>Usage</h3>

<pre><code class='language-R'>Coml(df1, df2)
## S3 method for class 'Coml'
summary(object, ..., n=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coml_+3A_df1">df1</code></td>
<td>
<p>First data frame with species presence/absence data, species as row names</p>
</td></tr>
<tr><td><code id="Coml_+3A_df2">df2</code></td>
<td>
<p>Second data frame</p>
</td></tr>
<tr><td><code id="Coml_+3A_object">object</code></td>
<td>
<p>Object of the class 'Coml'</p>
</td></tr>
<tr><td><code id="Coml_+3A_n">n</code></td>
<td>
<p>Number of indicator species</p>
</td></tr>
<tr><td><code id="Coml_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compare two (groups of) checklists (Abramova et al., 2003).
</p>
<p>Calculates difference (in %) between checklists with <em>common base</em>, i.e., species occurrence/abundance columns of data frame with species names as row names.
</p>
<p>Finds names of &quot;indicators&quot; most characteristic to each group
</p>


<h3>Value</h3>

<p>Object of the class 'Coml', or nothing</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Abramova L. A., Rimskaya-Korsakova N. N., Shipunov A. B. 2003. The comparative study of the flora of Kiv Gulf, Chupa Gulf and Keret' Archipelago islands (Kandalaksha Bay of White Sea). Proceedings of the Pertsov White Sea Biological Station. Vol. 9. Moscow. P. 22&ndash;33. in Russian (English abstract)</p>


<h3>Examples</h3>

<pre><code class='language-R'>y.Coml &lt;- Coml(dolbli[1:45], dolbli[46:79])
summary(y.Coml, n=5)
</code></pre>

<hr>
<h2 id='Cor'>Correlation matrix with p-values</h2><span id='topic+Cor'></span><span id='topic+Cor2'></span>

<h3>Description</h3>

<p>Correlation matrix with p-values</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cor(X, stars=TRUE, dec=4, p.level=0.05, ...)
Cor2(X, dec=4, p.level=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cor_+3A_x">X</code></td>
<td>
<p>Matrix or data frame with values</p>
</td></tr>
<tr><td><code id="Cor_+3A_stars">stars</code></td>
<td>
<p>Replaces p-values with stars if it not greater than 'p.level'</p>
</td></tr>
<tr><td><code id="Cor_+3A_dec">dec</code></td>
<td>
<p>Decimal point</p>
</td></tr>
<tr><td><code id="Cor_+3A_p.level">p.level</code></td>
<td>
<p>P-level</p>
</td></tr>
<tr><td><code id="Cor_+3A_...">...</code></td>
<td>
<p>Arguments to 'cor.test()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Cor()' calculates correlation matrix with p-values.
</p>
<p>'Cor2()' is another (faster) variant of correlation matrix with p-values based on F-statistic.
Shows significances in the upper triagle. Uses Pearson correlation only but much faster than 'Cor()'.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>Cor(longley, dec=2)
Cor2(longley, dec=2)
</code></pre>

<hr>
<h2 id='Cor.vec'>Calculates correlation and converts results into the named long vector</h2><span id='topic+Cor.vec'></span>

<h3>Description</h3>

<p>Calculates correlation and converts results into the named long vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Cor.vec(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cor.vec_+3A_x">X</code></td>
<td>
<p>Data frame or matrix with values</p>
</td></tr>
<tr><td><code id="Cor.vec_+3A_...">...</code></td>
<td>
<p>Arguments to 'cor()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates correlation and converts results into the named long vector
(Rostova, 1999; Rostova, 2002).
</p>


<h3>Value</h3>

<p>Named numerical vector of correlations.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Rostova N.S. 1999. The variability of correlations systems between the
morphological characters. Part 1. Natural populations of Leucanthemum
vulgare (Asteraceae). Botanicheskij Zhurnal. 84(11): 50&ndash;66.
</p>
<p>Rostova N.S. 2002. Correlations: Structure and Variability. Saint
Petersburg, St. Petersburg University Publisher.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rostova.tbl">Rostova.tbl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
Cor.vec(trees, method="spearman")

</code></pre>

<hr>
<h2 id='CVs'>Coefficients of variation</h2><span id='topic+CVs'></span>

<h3>Description</h3>

<p>Coefficients of variation</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVs(sample, na.rm=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVs_+3A_sample">sample</code></td>
<td>
<p>Numerical vector</p>
</td></tr>
<tr><td><code id="CVs_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NAs?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coefficients of variation: different variants of the standardized range
</p>


<h3>Value</h3>

<p>Named numerical vector</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(trees, CVs)
</code></pre>

<hr>
<h2 id='Ditto'>Removes duplicated data values downstream</h2><span id='topic+Ditto'></span>

<h3>Description</h3>

<p>Replaces duplicated values with &quot;ditto&quot; string</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ditto(x, ditto="")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ditto_+3A_x">x</code></td>
<td>
<p>Vector, possibly with missing values</p>
</td></tr>
<tr><td><code id="Ditto_+3A_ditto">ditto</code></td>
<td>
<p>String to replace with, typically empty string &quot;&quot; (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the first argument is not a character vector, Ditto() converts it to
the character.
</p>


<h3>Value</h3>

<p>Vector with replaced values</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fill">Fill</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ditto(c("a", "a", "", "b", "b"))
Ditto(c("a", "a", "", "b", NA, "b"))
Ditto(c("a", "a", "", "b", NA, "b"), ditto=NA)
Ditto(c("a", "a", "", "b", NA, "b"), ditto="--")
</code></pre>

<hr>
<h2 id='DNN'>Distance matrix based kNN classification</h2><span id='topic+DNN'></span><span id='topic+Dnn'></span>

<h3>Description</h3>

<p><code>DNN</code> uses pre-cooked distance matrix to replace missing values in class labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNN(dst, cl, k, d, details=FALSE, self=FALSE)
Dnn(trn, tst, classes, FUN=function(.x) dist(.x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNN_+3A_dst">dst</code></td>
<td>
<p>Distance matrix (object of class 'dist').</p>
</td></tr>
<tr><td><code id="DNN_+3A_cl">cl</code></td>
<td>
<p>Factor of class labels, should contain NAs to designate testing sub-group.</p>
</td></tr>
<tr><td><code id="DNN_+3A_k">k</code></td>
<td>
<p>How many neighbors to select, odd numbers preferable. If specified, do not use &quot;d&quot;.</p>
</td></tr>
<tr><td><code id="DNN_+3A_d">d</code></td>
<td>
<p>Distance to consider for neighborhood, in fractions of maximal distance. If specified, do not use &quot;k&quot;.</p>
</td></tr>
<tr><td><code id="DNN_+3A_details">details</code></td>
<td>
<p>If TRUE, function will return voting matrix. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DNN_+3A_self">self</code></td>
<td>
<p>Allow self-training? Default is FALSE.</p>
</td></tr>
<tr><td><code id="DNN_+3A_trn">trn</code></td>
<td>
<p>Data to train from, classes variable out.</p>
</td></tr>
<tr><td><code id="DNN_+3A_tst">tst</code></td>
<td>
<p>Data with unknown classes.</p>
</td></tr>
<tr><td><code id="DNN_+3A_classes">classes</code></td>
<td>
<p>Classes variable for training data.</p>
</td></tr>
<tr><td><code id="DNN_+3A_fun">FUN</code></td>
<td>
<p>Function to calculate distances, by default, just dist() (i.e., Euclidean distances).</p>
</td></tr>
<tr><td><code id="DNN_+3A_...">...</code></td>
<td>
<p>Additional arguments from Dnn() to DNN(), note that either 'k' or 'd' must be specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If classic kNN is a lazy classifier, DNN is super-lazy because it does
not even calculate the distance matrix itself. Instead, you supply it
with distance matrix (object of class 'dist') pre-computed with _any_
possible tool. This lifts many restrictions. For example, arbitrary
distance could be used (like Gower distance which allows any type of
variable). This is also much faster than typical kNN.
</p>
<p>In addition to neighbor-based kNN classification, DNN implements
_neighborhood_ classification when all neighbors within selected
distance used for voting.
</p>
<p>As usual in kNN, ties are broken at random. DNN also controls
situations when no neighbors are within the given distance (and returns
NA), and also when all neighbors are relevant (also returns NA).
</p>
<p>By default, DNN() returns missing part of class labels, completely or
partially filled with new (predicted) class labels. If 'cl' has no NAs
and self=FALSE (default), DNN() returns it back with warning. It allows
for combined and stepwise extensions (see examples). If 'details=TRUE',
DNN() will return matrix where each column represents the table used
for voting. If self=TRUE, DNN() could be used to calculate the class
proximity surrogate.
</p>
<p>Dnn() is based on DNN() but has more class::knn()-like interface (see examples).
</p>


<h3>Value</h3>

<p>Character vector with predicted class labels; or matrix if 'details=TRUE'.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p>class::<code><a href="class.html#topic+knn">knn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.d &lt;- dist(iris[, -5])

cl1 &lt;- iris$Species
sam &lt;- c(rep(0, 4), 1) &gt; 0
cl1[!sam] &lt;- NA
table(cl1, useNA="ifany")

## based on neighbor number
iris.pred &lt;- DNN(dst=iris.d, cl=cl1, k=5)
Misclass(iris$Species[is.na(cl1)], iris.pred)

## based on neighborhood size
iris.pred &lt;- DNN(dst=iris.d, cl=cl1, d=0.05)
table(iris.pred, useNA="ifany")
Misclass(iris$Species[is.na(cl1)], iris.pred)

## protection against "all points relevant"
DNN(dst=iris.d, cl=cl1, d=1)[1:5]
## and all are ties:
DNN(dst=iris.d, cl=cl1, d=1, details=TRUE)[, 1:5]

## any distance works
iris.d2 &lt;- Gower.dist(iris[, -5])
iris.pred &lt;- DNN(dst=iris.d2, cl=cl1, k=5)
Misclass(iris$Species[is.na(cl1)], iris.pred)

## combined
cl2 &lt;- cl1
iris.pred &lt;- DNN(dst=iris.d, cl=cl2, d=0.05)
cl2[is.na(cl2)] &lt;- iris.pred
table(cl2, useNA="ifany")
iris.pred2 &lt;- DNN(dst=iris.d, cl=cl2, k=5)
cl2[is.na(cl2)] &lt;- iris.pred2
table(cl2, useNA="ifany")
Misclass(iris$Species, cl2)

## self-training and class proximity surrogate
cl3 &lt;- iris$Species
t(DNN(dst=iris.d, cl=cl3, k=5, details=TRUE, self=TRUE))/5

## Dnn() with more class::knn()-like interface
iris.trn &lt;- iris[sam, ]
iris.tst &lt;- iris[!sam, ]
Dnn(iris.trn[, -5], iris.tst[, -5], iris.trn[, 5], k=7)

## stepwise DNN, note the warning when no NAs left
cl4 &lt;- cl1
for (d in (5:14)/100) {
iris.pred &lt;- DNN(dst=iris.d, cl=cl4, d=d)
cl4[is.na(cl4)] &lt;- iris.pred
}
table(cl4, useNA="ifany")
Misclass(iris$Species, cl4)
## rushing to d=14% gives much worse results
iris.pred &lt;- DNN(dst=iris.d, cl=cl1, d=0.14)
table(iris.pred, useNA="ifany")
Misclass(iris$Species[is.na(cl1)], iris.pred)
</code></pre>

<hr>
<h2 id='dolbli'>dolbli</h2><span id='topic+dolbli'></span>

<h3>Description</h3>

<p>Plants of two Arctic lakes.
</p>
<p>Observations on the coastal flora of Arctic lakes. Flora was sampled on the 20 m coastline. 1999&ndash;2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dolbli</code></pre>


<h3>Format</h3>


<dl>
<dt><code>columns</code></dt><dd><p>Lake names with plot numbers, data is abundance of plant species, in 1543 scale
(0 &ndash; absent; 1 &ndash; one individual plant; 2 &ndash; no more than 12 individual plants (rametes);
3 &ndash; number of individuals is more than 12 but no more than 5% of total number of plants on a plot;
4 &ndash; number of individuals is more than 5% but no more than 25% of total number of plants on a plot;
5 &ndash; number of individuals is more than 25% but no more than 50% of total number of plants on a plot;
6 &ndash; number of individuals is more than 50% but no more than 75% of total number of plants on a plot;
7 &ndash; number of individuals is more than 75% of total number of plants on a plot.)</p>
</dd>
<dt><code>rows</code></dt><dd><p>Names of plant species, trees start with 0</p>
</dd>
</dl>



<h3>Source</h3>

<p>Shipunov, A. The creation of databases about flora of isles and lakes of North
Karelia. Abstract. P. 97&ndash;98. Study of the flora of East Europe: Achievements and prospects.
23&ndash;28 May 2005, St.-Petersburg.
</p>
<p>Shipunov A., Motyleva M. The comparative study of the flora of lakes in Tchupa gulf environs.
III scientific session of Marine Biological Station of Saint-Petersburg State University.
Abstracts. P. 27&ndash;29. Saint-Petersburg, 2002. [In Russian].
</p>

<hr>
<h2 id='Dotcharts'>Improved dotcharts</h2><span id='topic+Dotchart'></span><span id='topic+Dotchart1'></span><span id='topic+Dotchart3'></span>

<h3>Description</h3>

<p>Dotcharts, improved and extended</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Dotchart1(x, labels=NULL, groups=NULL, gdata=NULL, offset=1/8,
 ann=par("ann"), xaxt=par("xaxt"),  frame.plot=TRUE, log="",
 cex=par("cex"), pt.cex=cex, pch=21, gpch=21, bg=par("bg"),
 color=par("fg"),  gcolor=par("fg"), lcolor="gray", xlim=
 range(x[is.finite(x)]), main=NULL, xlab=NULL, ylab=NULL, ...)

Dotchart(x, ...)

Dotchart3(values, left, right, pch=21, bg="white", pt.cex=1.2,
 lty=1, lwd=2, gridcol="grey", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dotcharts_+3A_x">x</code></td>
<td>
<p>Either a vector or matrix of numeric values. Inputs are coerced by 'as.numeric()', with a message.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_labels">labels</code></td>
<td>
<p>A vector of labels for each point.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_groups">groups</code></td>
<td>
<p>An optional factor indicating how the elements of 'x' are grouped.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_gdata">gdata</code></td>
<td>
<p>Data values for the groups. This is typically a summary such as the median or mean of each group.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_offset">offset</code></td>
<td>
<p>Offset in inches of 'ylab' and 'labels'.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_ann">ann</code></td>
<td>
<p>Logical value indicating whether title and x and y axis labels should appear on the plot.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_xaxt">xaxt</code></td>
<td>
<p>String indicating the x-axis style; use 'n' to suppress and see also par(&quot;xaxt&quot;).</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_frame.plot">frame.plot</code></td>
<td>
<p>Logical indicating whether a box should be drawn around the plot.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_log">log</code></td>
<td>
<p>Character string indicating if one or the other axis should be logarithmic, see ?plot.default.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_cex">cex</code></td>
<td>
<p>The character size to be used.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_pt.cex">pt.cex</code></td>
<td>
<p>The 'cex' to be applied to plotting symbols.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_pch">pch</code></td>
<td>
<p>The plotting character or symbol to be used.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_gpch">gpch</code></td>
<td>
<p>The plotting character or symbol to be used for group values.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_bg">bg</code></td>
<td>
<p>The background color of plotting characters.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_color">color</code></td>
<td>
<p>The color(s) to be used for points and labels.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_gcolor">gcolor</code></td>
<td>
<p>The single color to be used for group labels and values.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_lcolor">lcolor</code></td>
<td>
<p>The color(s) to be used for the horizontal lines.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_xlim">xlim</code></td>
<td>
<p>Horizontal range for the plot.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_main">main</code></td>
<td>
<p>Overall title for the plot, see 'title'.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_xlab">xlab</code>, <code id="Dotcharts_+3A_ylab">ylab</code></td>
<td>
<p>Axis annotations as in 'title'.</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_values">values</code></td>
<td>
<p>Centers for 'Dotchart3()'</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_left">left</code></td>
<td>
<p>Left margins for 'Dotchart3()'</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_right">right</code></td>
<td>
<p>Right margins for 'Dotchart3()'</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_lty">lty</code></td>
<td>
<p>Line type for 'Dotchart3()'</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_lwd">lwd</code></td>
<td>
<p>Line width for 'Dotchart3()'</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_gridcol">gridcol</code></td>
<td>
<p>Grid color for 'Dotchart3()'</p>
</td></tr>
<tr><td><code id="Dotcharts_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For better explanations of options, see 'help(dotchart)'.
</p>
<p>Dotchart1() is a dotchart() corrected for use with 1-dimensional tables.
If the argument is a 1-dimensional table, Dotchart() converts it into
numeric vector first and instead of warning, outputs the message. This is
helpful to the beginners with R, and especially on macOS GUI where
warnings are in red. It also allows dotcharts to show 'ylab' (this was
not available in R &lt; 4.0.3 but corrected later).
</p>
<p>Dotchart() is a prettified dotchart with the following defaults:
'lcolor=&quot;black&quot;, bg=&quot;white&quot;, pt.cex=1.2'.
</p>
<p>Dotchart3() is the dotchart extension which shows values together with
ranges. Somewhat similar to Linechart() but more general (and does not
work with grouped data).
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+dotchart">dotchart</a></code>, <code><a href="#topic+Linechart">Linechart</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compare:
aa &lt;- table(c(1, 1, 1, 2, 2, 3))
dotchart(aa, ylab="Ylab") # produces warning; does not show 'ylab' if R version &lt; 4.0.3
Dotchart1(aa, ylab="Ylab") # outputs message instead of warning; always shows 'ylab'
Dotchart(aa, ylab="Ylab") # in addition to Dotchart1(), dots and grid are more visible

iris1 &lt;- aggregate(iris[, 1], iris[5], function(.x) fivenum(.x)[c(3, 1, 5)])
iris1x &lt;- iris1$x
row.names(iris1x) &lt;- iris1$Species
Dotchart3(iris1x[, 1], iris1x[, 2], iris1x[, 3])

</code></pre>

<hr>
<h2 id='drosera'>drosera</h2><span id='topic+drosera'></span>

<h3>Description</h3>

<p>Observations on the round-leaf sundew, Drosera rotundifolia, White Sea coast, August 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drosera
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>POP</code></dt><dd><p>Code of the population</p>
</dd>
<dt><code>YOUNG.L</code></dt><dd><p>Number of young, not opened leaves</p>
</dd>
<dt><code>MATURE.L</code></dt><dd><p>Number of mature, catching leaves</p>
</dd>
<dt><code>OLD.L</code></dt><dd><p>Number of old, degrading leaves</p>
</dd>
<dt><code>INSECTS</code></dt><dd><p>Total number of insects per plant</p>
</dd>
<dt><code>INFL.L</code></dt><dd><p>Inflorescence length (0 if absent), mm</p>
</dd>
<dt><code>STALK.L</code></dt><dd><p>Length of stalk (without flowers), mm</p>
</dd>
<dt><code>N.FLOW</code></dt><dd><p>Number of flowers</p>
</dd>
<dt><code>LEAF.L</code></dt><dd><p>Length of maximal leaf, mm</p>
</dd>
<dt><code>LEAF.W</code></dt><dd><p>Width of maximal leaf, mm</p>
</dd>
<dt><code>PET.L</code></dt><dd><p>Length of maximal leaf petiole, mm</p>
</dd>
</dl>


<hr>
<h2 id='Ell'>Plot ellipse</h2><span id='topic+Ell'></span>

<h3>Description</h3>

<p>Plot ellipse</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ell(x, y, width, height=width, theta=2*pi, npoints=100, plot=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ell_+3A_x">x</code></td>
<td>
<p>x coordinate of center</p>
</td></tr>
<tr><td><code id="Ell_+3A_y">y</code></td>
<td>
<p>y coordinate of center</p>
</td></tr>
<tr><td><code id="Ell_+3A_width">width</code></td>
<td>
<p>length of major axis</p>
</td></tr>
<tr><td><code id="Ell_+3A_height">height</code></td>
<td>
<p>length of minor axis</p>
</td></tr>
<tr><td><code id="Ell_+3A_theta">theta</code></td>
<td>
<p>rotation</p>
</td></tr>
<tr><td><code id="Ell_+3A_npoints">npoints</code></td>
<td>
<p>number of points to send to polygon</p>
</td></tr>
<tr><td><code id="Ell_+3A_plot">plot</code></td>
<td>
<p>if TRUE, add to current device, if FALSE, returns list of components</p>
</td></tr>
<tr><td><code id="Ell_+3A_...">...</code></td>
<td>
<p>arguments to 'polygon()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots ellipse based on 'polygon()'.</p>


<h3>Value</h3>

<p>If plot=FALSE, returns list of components.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(1:8, type="n")
Ell(4, 5, 6)
</code></pre>

<hr>
<h2 id='Ellipses'>Confidence ellipses</h2><span id='topic+Ellipses'></span>

<h3>Description</h3>

<p>Calculates and plots group confidence ellipses</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ellipses(pts, groups, match.color=TRUE, usecolors=NULL,
 centers=FALSE, c.pch=0, c.cex=3,
 level=0.95, df=1000, prec=51,
 coords=NULL, plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ellipses_+3A_pts">pts</code></td>
<td>
<p>Data points to plot</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_groups">groups</code></td>
<td>
<p>Grouping variable</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_match.color">match.color</code></td>
<td>
<p>Match colors</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_usecolors">usecolors</code></td>
<td>
<p>Use colors (palette)</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_centers">centers</code></td>
<td>
<p>Show centers?</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_c.pch">c.pch</code></td>
<td>
<p>Color of center points</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_c.cex">c.cex</code></td>
<td>
<p>Scale of center points</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_level">level</code></td>
<td>
<p>Confidence level for F-distribution</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_df">df</code></td>
<td>
<p>Used in calculation of P-content according to F(2, df) distribution</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_prec">prec</code></td>
<td>
<p>Precision of ellipse plotting (default is 51 points)</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_coords">coords</code></td>
<td>
<p>Pre-calculated ellipses coordinates: list of two-column matrices named as groups (by default, not required)</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_plot">plot</code></td>
<td>
<p>Plot?</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_...">...</code></td>
<td>
<p>Arguments to lines()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that (at least at the moment), ellipses are plotted with line(),
therefore shading is not straightforward (but possible, see examples).
</p>
<p>Also, with a help from Pinhull() (see its help), it is possible to reveal
&quot;outliers&quot;, points outside of each ellipse borders.
</p>
<p>See also package 'cluster' for ellipsoidhulls() function that allows to
draw ellipse-like hulls.
</p>


<h3>Value</h3>

<p>Invisibly returns the list in the form similar to Hulls(), to use as a
list of polygons or with Overlap().
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Overlap">Overlap</a></code>, <code><a href="#topic+Pinhull">Pinhull</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
plot(iris.p, type="n", xlab="PC1", ylab="PC2")
text(iris.p, labels=abbreviate(iris[, 5], 1, method="both.sides"))
iris.e &lt;- Ellipses(iris.p[, 1:2], iris[, 5], centers=TRUE)

## calculate overlap between ellipses
Overlap(iris.e)

## how to plot filled ellipses
plot(iris.p, type="n", xlab="PC1", ylab="PC2")
text(iris.p, labels=abbreviate(iris[, 5], 1, method="both.sides"))
for (i in seq_along(iris.e))
 polygon(iris.e[[i]], border=NA, col=adjustcolor(i, alpha.f=0.2))

## how to reveal (and label) "outliers", points outside of _all_ ellipses
iris.pie &lt;- Pinhull(iris.p, iris.e)
outs &lt;- which(apply(iris.pie, 1, sum) == 0)
points(iris.p[outs, ], cex=2, pch=4)

## embedded convex hulls
plot(iris.p, col=iris$Species)
for (i in seq_along(iris.e)) lines(iris.e[[i]], col=i, lty=2)
mi &lt;- cbind(seq_len(nrow(iris)), as.numeric(iris$Species)) # indexing matrix
## remove "outliers" in broad sense, points which are outside of its "own" ellipse:
emb &lt;- rowSums(iris.pie) == 1 &amp; iris.pie[mi]
Hulls(iris.p[emb, ], iris$Species[emb])

## LDA ellipes
library(MASS)
ch.lda &lt;- lda(Species ~ ., data=chaetocnema[, -2])
ch.lda.pred &lt;- predict(ch.lda, chaetocnema[, -(1:2)])
## ellipses here are by default bigger then plot so use workaround:
ee &lt;- Ellipses(ch.lda.pred$x, chaetocnema$Species, plot=FALSE)
xx &lt;- range(c(do.call(rbind, ee)[, 1], ch.lda.pred$x[, 1]))
yy &lt;- range(c(do.call(rbind, ee)[, 2], ch.lda.pred$x[, 2]))
plot(ch.lda.pred$x, col=chaetocnema$Species, xlim=xx, ylim=yy)
Ellipses(ch.lda.pred$x, chaetocnema$Species, coords=ee)

## search for the maximal level which gives zero overlap
plot(x5 ~ x17, data=haltica, pch=as.numeric(haltica$Species))
for (i in (99:59)/100) {
cat(i, "\n")
ee &lt;- Ellipses(haltica[, c("x17", "x5")], haltica$Species, level=i, plot=FALSE)
print(mean(Overlap(ee), na.rm=TRUE))
cat("\n")
}
Ellipses(haltica[, c("x17", "x5")], haltica$Species, level=.62)
</code></pre>

<hr>
<h2 id='eq'>eq</h2><span id='topic+eq'></span><span id='topic+eq_l'></span><span id='topic+eq_s'></span>

<h3>Description</h3>

<p>Horsetails (<em>Equisetum</em>) are the old, pre-dinosaur plant lineage.
Only several dozen species survived, but despite a long evolution the
borders between these species are still unclear for researchers.
</p>
<p>In 2005&ndash;2006, morphometric analysis was performed of more than 1,000 horsetail
plants belong to most widespread Eurasian species growing in Middle Russia.
For the analysis, we used 8 morphological characters and also tried to identify species.
</p>
<p>'eq_l' contains population locations and species determinations.
</p>
<p>'eq_s' and 'eq' are actual morphometric data, but 'eq' contains only 2 species out of 8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq
eq_l
eq_s
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>DL.R</code></dt><dd><p>plant height, mm</p>
</dd>
<dt><code>DIA.ST</code></dt><dd><p>maximal diameter of stem, mm</p>
</dd>
<dt><code>N.REB</code></dt><dd><p>number of ridges on a stem</p>
</dd>
<dt><code>N.ZUB</code></dt><dd><p>number of teeth (reduced leaves)</p>
</dd>
<dt><code>DL.OSN.Z</code></dt><dd><p>length of tooth base</p>
</dd>
<dt><code>DL.TR.V</code></dt><dd><p>length of sheath</p>
</dd>
<dt><code>DL.BAZ</code></dt><dd><p>length of basal segment of branch</p>
</dd>
<dt><code>DL.PER</code></dt><dd><p>length of first (after the basal) segment of branch</p>
</dd>
<dt><code>SPECIES</code></dt><dd><p>preliminary species determination</p>
</dd>
<dt><code>N.POP</code></dt><dd><p>population number</p>
</dd>
<dt><code>WHERE</code></dt><dd><p>population location (region)</p>
</dd>
</dl>

<hr>
<h2 id='Ex.boxplot'>Boxplot explanation</h2><span id='topic+Ex.boxplot'></span>

<h3>Description</h3>

<p>Boxplot explanation</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.boxplot(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ex.boxplot_+3A_...">...</code></td>
<td>
<p>Arguments to 'boxplot()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scheme which explains typical boxplot.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.boxplot()
</code></pre>

<hr>
<h2 id='Ex.col'>Examples of colors</h2><span id='topic+Ex.col'></span><span id='topic+Ex.cols'></span>

<h3>Description</h3>

<p>Examples of colors (current colors or all named colors)</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.col(all=FALSE)
Ex.cols(all=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ex.col_+3A_all">all</code></td>
<td>
<p>Show all named colors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'all=FALSE' (default), plots current colors along with their names and
numeric codes; &quot;white&quot; is added as the first color (with numeric code 0).
This plot does not usually look nice if the current palette contains more
than 40&ndash;45 colors.
</p>
<p>If 'all=TRUE', plots all named colors plus (for completedness)
&quot;transparent&quot;, which also can be used as color specification in R. Large
device is required to see all (almost 500) named colors.
</p>
<p>For the palettes, run 'example(rainbow)' and other palette-related
commands.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+palette">palette</a></code>, <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="grDevices.html#topic+colors">colors</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.cols()
Ex.cols(all=TRUE)
</code></pre>

<hr>
<h2 id='Ex.font'>Examples of fonts</h2><span id='topic+Ex.font'></span><span id='topic+Ex.fonts'></span>

<h3>Description</h3>

<p>Examples of standard fonts</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.font()</code></pre>


<h3>Details</h3>

<p>Examples of standard fonts</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.fonts()
</code></pre>

<hr>
<h2 id='Ex.lty'>Examples of line types</h2><span id='topic+Ex.lty'></span><span id='topic+Ex.lines'></span>

<h3>Description</h3>

<p>Line type examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.lty(custom="431313")
Ex.lines(custom="431313")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ex.lty_+3A_custom">custom</code></td>
<td>
<p>character string to specify custom line type (see '?lines').</p>
</td></tr></table>


<h3>Details</h3>

<p>Line type examples. To see other possible custom line types, try custom=&quot;F8&quot; or similar.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.lines(custom="F8")
</code></pre>

<hr>
<h2 id='Ex.margins'>Example of plot margins</h2><span id='topic+Ex.margins'></span>

<h3>Description</h3>

<p>Example of plot margins</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.margins()</code></pre>


<h3>Details</h3>

<p>Example of plot margins. Modified from Paul Murrell (2006).</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Murrell P. 2006. R Graphics.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.margins()
</code></pre>

<hr>
<h2 id='Ex.pch'>Point examples</h2><span id='topic+Ex.pch'></span><span id='topic+Ex.points'></span>

<h3>Description</h3>

<p>Point ('pch') examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.pch(extras=c("*", ".", "+", "a"), cex=2, col="black", bg="gray",
 coltext="black", cextext=1.2, main="")
Ex.points(extras=c("*", ".", "+", "a"), cex=2, col="black", bg="gray",
 coltext="black", cextext=1.2, main="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ex.pch_+3A_extras">extras</code></td>
<td>
<p>which extra symbols to show</p>
</td></tr>
<tr><td><code id="Ex.pch_+3A_cex">cex</code></td>
<td>
<p>point scale, default 2</p>
</td></tr>
<tr><td><code id="Ex.pch_+3A_col">col</code></td>
<td>
<p>point color, default black</p>
</td></tr>
<tr><td><code id="Ex.pch_+3A_bg">bg</code></td>
<td>
<p>point background (for symbols with a 'bg'-colored interior), default gray</p>
</td></tr>
<tr><td><code id="Ex.pch_+3A_coltext">coltext</code></td>
<td>
<p>text color, default black</p>
</td></tr>
<tr><td><code id="Ex.pch_+3A_cextext">cextext</code></td>
<td>
<p>text scale, default 1.2</p>
</td></tr>
<tr><td><code id="Ex.pch_+3A_main">main</code></td>
<td>
<p>plot title, no title by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point ('pch') examples, modified from 'example(points)'.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+points">points</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.points()
</code></pre>

<hr>
<h2 id='Ex.plots'>Examples of plot types</h2><span id='topic+Ex.plots'></span><span id='topic+Ex.types'></span>

<h3>Description</h3>

<p>Examples of plot types</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ex.plots()
Ex.types()</code></pre>


<h3>Details</h3>

<p>Examples of nine standard plot types.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Ex.types()
</code></pre>

<hr>
<h2 id='Fence'>Colorize tips of 'hclust' plot</h2><span id='topic+Fence'></span>

<h3>Description</h3>

<p>Uses segments() and Tcoords() to colorize 'hclust' plot</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Fence(hcl, fct, ex=0.05, lwd=2.5, horiz=FALSE, hang=0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fence_+3A_hcl">hcl</code></td>
<td>
<p><code>hclust</code> object</p>
</td></tr>
<tr><td><code id="Fence_+3A_fct">fct</code></td>
<td>
<p>Variable to colorize labels, will be converted into factor</p>
</td></tr>
<tr><td><code id="Fence_+3A_ex">ex</code></td>
<td>
<p>The fraction of the plot height by which segments go up and
down from the tips; by default, it is half of the 'hang'</p>
</td></tr>
<tr><td><code id="Fence_+3A_lwd">lwd</code></td>
<td>
<p>Line width of segments</p>
</td></tr>
<tr><td><code id="Fence_+3A_horiz">horiz</code></td>
<td>
<p>Plot on a horizontal tree?</p>
</td></tr>
<tr><td><code id="Fence_+3A_hang">hang</code></td>
<td>
<p>The fraction of the plot height by which labels should hang
below the rest of the plot; by default, it is equal to the default
'hang' from <code>hclust</code> which is 0.1</p>
</td></tr>
<tr><td><code id="Fence_+3A_...">...</code></td>
<td>
<p>Further arguments to segments()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Tcoords">Tcoords</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.h &lt;- hclust(dist(iris[, -5]))
plot(iris.h, labels=FALSE)
Fence(iris.h, iris$Species)
legend("topright", legend=levels(iris$Species), col=1:3, lwd=2.5, bty="n")

</code></pre>

<hr>
<h2 id='Files'>Textual file system browser</h2><span id='topic+Files'></span>

<h3>Description</h3>

<p>Textual file system browser</p>


<h3>Usage</h3>

<pre><code class='language-R'>Files(root=getwd(), multiple=FALSE, hidden=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Files_+3A_root">root</code></td>
<td>
<p>Root directory to explore, default is the working directory</p>
</td></tr>
<tr><td><code id="Files_+3A_multiple">multiple</code></td>
<td>
<p>Allows multiple files to be selected</p>
</td></tr>
<tr><td><code id="Files_+3A_hidden">hidden</code></td>
<td>
<p>Show hidden files?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interactive text-based file chooser dialog, modified from code published
by &quot;mathematical.coffee&quot; on Stack Overflow as &quot;R command-line file
dialog&quot;.
</p>
<p>If 'multiple=TRUE', one can select files one by one (they will
&quot;disappear&quot; from the displayed list), and typing &quot;0&quot; will output this
list. If &quot;multiple=FALSE&quot;, typing &quot;0&quot; will output the name of the current
directory.
</p>
<p>Files() uses normalizePath() so symbolic links will be resolved. Also,
Files() is not very useful when number of files in the directory is
large.
</p>
<p>Alternatives for Linux: 'tcltk::tk_choose.files()' and
'tcltk::tk_choose.dir()'
</p>


<h3>Value</h3>

<p>Returns character vector of selected files, or directory name (useful for
'setwd()'), or new user-defined file name with full path.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+setwd">setwd</a></code>, <code><a href="base.html#topic+getwd">getwd</a></code>, <code><a href="base.html#topic+dir">dir</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## interactive commands
setwd &lt;- Files() # then select directory to work in
Files("~", hidden=TRUE) # explore home directory with hidden files (Linux, macOS)

## End(Not run)
</code></pre>

<hr>
<h2 id='Fill'>Fill data values downstream, like in spreadsheets</h2><span id='topic+Fill'></span>

<h3>Description</h3>

<p>Replaces &quot;ditto&quot; values with preceding values</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fill(x, ditto="")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fill_+3A_x">x</code></td>
<td>
<p>Vector, possibly with missing values</p>
</td></tr>
<tr><td><code id="Fill_+3A_ditto">ditto</code></td>
<td>
<p>What to fill, typically empty string &quot;&quot; (default) or NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with replaced values</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ditto">Ditto</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c("a", "a", "", "b", "", "c", "d", "")
Fill(aa)
bb &lt;- c("a", "a", NA, "b", NA, "c", "d", NA)
Fill(bb, ditto=NA)
dd &lt;- c("", "a", "a", "", "", "b", NA, "", "c", "d", "")
Fill(dd)
</code></pre>

<hr>
<h2 id='Gap.code'>Gap coding</h2><span id='topic+Gap.code'></span>

<h3>Description</h3>

<p>Gap coding of DNA nucleotide alignments</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gap.code(seqs)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gap.code_+3A_seqs">seqs</code></td>
<td>
<p>Character vector of aligned (and preferably flank trimmed) DNA sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FastGap-like gap code nucleotide alignments ('ATGCN-' are allowed).
</p>
<p>Encodes gap presence as 'A' and absence as 'C'.
</p>
<p>Likely too straightforward, and only weakly optimized (really slow).
</p>


<h3>Value</h3>

<p>Outputs character matrix where each column is a gapcoded position.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Borchsenius F. 2009. FastGap 1.2. Department of Biosciences, Aarhus
University, Denmark. See &quot;http://www.aubot.dk/FastGap_home.htm&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>write(file=file.path(tempdir(), "tmp.fasta"),  c(
 "&gt;1\nGAAC------ATGC",
 "&gt;2\nGAAC------TTGC",
 "&gt;3\nGAAC---CCTTTGC",
 "&gt;4\nGAA---------GC"))
write(file=file.path(tempdir(), "tmp_expected.fasta"), c(
 "&gt;1\nGAAC------ATGCCA-",
 "&gt;2\nGAAC------TTGCCA-",
 "&gt;3\nGAAC---CCTTTGCCCA",
 "&gt;4\nGAA---------GCA--"))
tmp &lt;- Read.fasta(file=file.path(tempdir(), "tmp.fasta"))
expected &lt;- Read.fasta(file=file.path(tempdir(), "tmp_expected.fasta"))
seqs &lt;- tmp$sequence
gc &lt;- Gap.code(seqs)
tmp$sequence &lt;- apply(cbind(seqs, gc), 1, paste, collapse="")
identical(tmp, expected) # TRUE, isn't it?
</code></pre>

<hr>
<h2 id='Gen.cl.data'>Generates datasets for clustering</h2><span id='topic+Gen.cl.data'></span>

<h3>Description</h3>

<p>Imitation of the Python <code>sklearn.datasets</code> functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gen.cl.data(type=c("blobs", "moons", "circles"), N=100, noise=NULL,
 shuffle=TRUE, bdim=2, bcenters=3, bnoise=1, bbox=c(-10, 10), cfactor=0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gen.cl.data_+3A_type">type</code></td>
<td>
<p>'blobs' are Gaussian blobs; 'moons' are two interleaving half-circles; 'circles' are two embedded circles</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_n">N</code></td>
<td>
<p>Number of data points</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to randomize the output</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_noise">noise</code></td>
<td>
<p>Standard deviation of Gaussian noise applied to point positions</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_bdim">bdim</code></td>
<td>
<p>Dimensionality of 'blobs' dataset</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_bcenters">bcenters</code></td>
<td>
<p>Number of 'blobs' centers</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_bnoise">bnoise</code></td>
<td>
<p>Standard deviation of 'blobs' Gaussian noise: vector of length one or length equal to the number of centers</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_bbox">bbox</code></td>
<td>
<p>The bounding box within which blobs centers will be created</p>
</td></tr>
<tr><td><code id="Gen.cl.data_+3A_cfactor">cfactor</code></td>
<td>
<p>Scale factor between 'circles' (should be &gt; 0 and &lt; 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorihms were taken partly from Python 'scikit-learn' and from Github 'elbamos/clusteringdatasets'.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>scikit.palette &lt;- c("#377EB8", "#FF7F00", "#4DAF4A", "#F781BF", "#A65628", "#984EA3",
"#999999", "#E41A1C", "#DEDE00", "#000000")
palette(scikit.palette)
n.samples &lt;- 500

## data
set.seed(21)
no.structure &lt;- list(samples=cbind(runif(n.samples), runif(n.samples)),
 labels=rep(1, n.samples))
noisy.circles &lt;- Gen.cl.data(type="circles", N=n.samples, cfactor=0.5, noise=0.05)
noisy.moons &lt;- Gen.cl.data(type="moons", N=n.samples, noise=0.05)
blobs &lt;- Gen.cl.data(type="blobs", N=n.samples, noise=1)
## anisotropically distributed data
aniso &lt;- Gen.cl.data(type="blobs", N=n.samples)
aniso$samples &lt;- aniso$samples %*% rbind(c(0.6, -0.6), c(-0.4, 0.8))
## blobs with varied variances
varied &lt;- Gen.cl.data(type="blobs", N=n.samples, bnoise=c(1, 2.5, 0.5))
set.seed(NULL)

## single example
plot(aniso$samples, col=aniso$labels, pch=19)

## all data objects example
## old.X11.options &lt;- X11.options(width=6, height=6) # to make square cells
oldpar &lt;- par(mfrow=c(2, 3), mar=c(1, 1, 3, 1))
for (n in c("noisy.circles", "noisy.moons", "no.structure",
 "blobs", "aniso", "varied")) {
 plot(get(n)$samples, col=get(n)$labels, pch=19, main=n, xlab="", ylab="",
 xaxt="n", yaxt="n")
}
par(oldpar)
## X11.options &lt;- old.X11.options


## comparison of clustering techniques example
## old.X11.options &lt;- X11.options(width=10, height=6)  # to make square cells
oldpar &lt;- par(mfrow=c(6, 10), mar=rep(0, 4), xaxt="n", yaxt="n")
COUNT &lt;- 1
for (n in c("noisy.circles", "noisy.moons", "no.structure", "blobs", "aniso", "varied")) {
 K &lt;- 3
 if (n %in% c("noisy.circles", "noisy.moons")) K &lt;- 2
 TITLE &lt;- function(x) if (COUNT==1) { legend("topleft", legend=x, cex=1.25, bty="n") }
##
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="ward.D2"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("Ward")
##
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="average"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("UPGMA")
##
 newlabels &lt;- kmeans(round(get(n)$samples, 5), centers=K)$cluster
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("K-means")
##
 newlabels &lt;- cutree(as.hclust(cluster::diana(dist(get(n)$samples))), k=K) # slow
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("DIANA")
##
 nn &lt;- cluster::fanny(get(n)$samples, k=K) # a bit slow
 dunn &lt;- apply(nn$membership, 1, function(.x) (sum(.x^2) - 1/K) / (1 - 1/K))
 fuzzy &lt;- dunn &lt; 0.05
 plot(get(n)$samples[!fuzzy, ], col=nn$clustering[!fuzzy], pch=19)
 points(get(n)$samples[fuzzy, ], col="black", pch=1)
 TITLE("FANNY")
##
 newlabels &lt;- kernlab::specc(get(n)$samples, centers=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("spectral")
##
 nn &lt;- apcluster::apclusterK(apcluster::negDistMat(), get(n)$samples, K=K) # very slow
 newlabes &lt;- apply(sapply(nn@clusters,
  function(.y) 1:nrow(get(n)$samples) %in% .y), 1, which)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("AP") # affinity propagation
##
 ## eps values taken out of scikit and 'dbscan::kNNdistplot() "knee"', 'minPts' default
 EPS &lt;- c(noisy.circles=0.3, noisy.moons=0.3, no.structure=0.3, blobs=1,
  aniso=0.5, varied=1)
 nn &lt;- dbscan::dbscan(get(n)$samples, eps=EPS[n])
 outliers &lt;- nn$cluster == 0
 plot(get(n)$samples[!outliers, ], col=nn$cluster[!outliers], pch=19)
 points(get(n)$samples[outliers, ], col="black", pch=1)
 TITLE("DBSCAN")
##
 newlabels &lt;- meanShiftR::meanShift(get(n)$samples, nNeighbors=10)$assignment
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("mean-shift")
##
 library(mclust)
 newlabels &lt;- Mclust(get(n)$samples)$classification
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("Gaussian")
 COUNT &lt;- COUNT + 1
}
par(oldpar)
## X11.options &lt;- old.X11.options



## comparison of linkages example
## old.X11.options &lt;- X11.options(width=8, height=6) # to make square cells
oldpar &lt;- par(mfrow=c(6, 8), mar=rep(0, 4), xaxt="n", yaxt="n")
COUNT &lt;- 1
for (n in c("noisy.circles", "noisy.moons", "no.structure", "blobs", "aniso", "varied")) {
 K &lt;- 3 ; if (n %in% c("noisy.circles", "noisy.moons")) K &lt;- 2
 TITLE &lt;- function(x) if (COUNT==1) { legend("topleft", legend=x, cex=1.25, bty="n") }
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="ward.D2"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("Ward orig")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="ward.D"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("Ward")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="average"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("UPGMA")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="single"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("single")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="complete"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("complete")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="mcquitty"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("WPGMA")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="median"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("WPGMC")
 newlabels &lt;- cutree(hclust(dist(get(n)$samples), method="centroid"), k=K)
 plot(get(n)$samples, col=newlabels, pch=19)
 TITLE("UPGMC")
 COUNT &lt;- COUNT + 1
}
par(oldpar)
## X11.options &lt;- old.X11.options

palette("default")
</code></pre>

<hr>
<h2 id='Gini'>Compute the simple Gini coefficient</h2><span id='topic+Gini'></span>

<h3>Description</h3>

<p>Computes the simple Gini coefficient of unequality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Gini(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gini_+3A_x">x</code></td>
<td>
<p>a numeric vector with non-negative elements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gini coefficient is a common measure of inequality. Here it presents only
for the convenience to have this calculation &quot;outside&quot; of social science
R packages (where it commonly presents). Please read elsewhere of its
meaning and uses.
</p>
<p>Code is based on the 'reldist' package from Mark S. Handcock but
simplified to revome the using of weights (as a sideway result, it should
be slightly faster).
</p>


<h3>Value</h3>

<p>The Gini coefficient (number between 0 and 1).
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p><em>Relative Distribution Methods in the Social Sciences</em>, by Mark S.
Handcock and Martina Morris, Springer-Verlag, Inc., New York, 1999. ISBN
0387987789.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
salary &lt;- c(21, 19, 27, 11, 102, 25, 21)
Gini(salary)

new.1000 &lt;- sample((median(salary) - IQR(salary)) :
(median(salary) + IQR(salary)), 1000, replace=TRUE)
salary2 &lt;- c(salary, new.1000)
Gini(salary2)

salary3 &lt;- salary[-which.max(salary)]
salary3
Gini(salary3)

salary4 &lt;- c(salary3, 1010)
salary4
Gini(salary4)

</code></pre>

<hr>
<h2 id='Gower.dist'>Gower distance</h2><span id='topic+Gower.dist'></span>

<h3>Description</h3>

<p>Calculates Gower distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gower.dist(data.x, data.y=data.x, rngs=NULL,
 KR.corr=TRUE, na.rm=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gower.dist_+3A_data.x">data.x</code></td>
<td>
<p>A matrix or a data frame containing variables that should
be used in the computation of the distance.</p>
</td></tr>
<tr><td><code id="Gower.dist_+3A_data.y">data.y</code></td>
<td>
<p>A numeric matrix or data frame with the same variables, of
the same type, as those in 'data.x'</p>
</td></tr>
<tr><td><code id="Gower.dist_+3A_rngs">rngs</code></td>
<td>
<p>A vector with the ranges to scale the variables. Its length
must be equal to number of variables in 'data.x'</p>
</td></tr>
<tr><td><code id="Gower.dist_+3A_kr.corr">KR.corr</code></td>
<td>
<p>When TRUE (default) the extension of the Gower's
dissimilarity measure proposed by Kaufman and Rousseeuw (1990) is used.
Otherwise, the original Gower's (1971) formula is considered.</p>
</td></tr>
<tr><td><code id="Gower.dist_+3A_na.rm">na.rm</code></td>
<td>
<p>Replace missing values with maximal distance?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gower.dist() code based on analogous function from 'StatMatch' package;
please see this package for the original code and full documentation.
</p>
<p>This function computes the Gower's distance (dissimilarity) among units
in a dataset or among observations in two distinct datasets. Columns of
mode numeric will be considered as interval scaled variables; columns of
mode character or class factor will be considered as categorical nominal
variables; columns of class ordered will be considered as categorical
ordinal variables and, columns of mode logical will be considered as
binary asymmetric variables. Missing values (NA) are allowed. If only
data.x is supplied, the dissimilarities between _rows_ of data.x will be
computed.
</p>
<p>For 'rngs', in correspondence of non-numeric variables, just put 1 or NA.
When rngs=NULL (default), the range of a numeric variable is estimated by
jointly considering the values for the variable in 'data.x' and those in
'data.y'.
</p>
<p>When 'na.rm=TRUE', all missing values (NAs and NaNs) in the result will
be replaced with maximal distance. This is discussable but helps, e.g.,
to bootstrap hierarchical clustering in case if data is rich of NAs.
</p>


<h3>Value</h3>

<p>A distance object with distances among rows of 'data.x' and those of
'data.y'.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Gower J.C. 1971. A general coefficient of similarity and some of its
properties. Biometrics. 27: 623&ndash;637.
</p>
<p>Kaufman L., Rousseeuw P.J. 1990. Finding Groups in Data: An Introduction
to Cluster Analysis. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, cluster::<code><a href="cluster.html#topic+daisy">daisy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 &lt;- as.logical(rbinom(10, 1, 0.5))
x2 &lt;- sample(letters, 10, replace=TRUE)
x3 &lt;- rnorm(10)
x4 &lt;- ordered(cut(x3, -4:4, include.lowest=TRUE))
xx &lt;- data.frame(x1, x2, x3, x4, stringsAsFactors=FALSE)

## matrix of distances among first obs. in xx and the remaining ones
Gower.dist(data.x=xx[1:6, ], data.y=xx[7:10, ])

## matrix of distances among observations in xx
row.names(xx) &lt;- LETTERS[1:nrow(xx)]
dx &lt;- Gower.dist(xx)
plot(hclust(dx))

</code></pre>

<hr>
<h2 id='Gradd'>Classification grid and decision boundaries</h2><span id='topic+Gradd'></span>

<h3>Description</h3>

<p>Adds to the 2D ordination either colored points to make classification grid, or lines to show decision boundaries</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gradd(model2var, data2var, spacing=75, what="points",
 trnsp=0.2, pch=16, cex=0.8, lwd=2, lty=2, lcol="grey", palette=NULL,
 type="ids", User.Predict=function(model2var, X) {}, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gradd_+3A_model2var">model2var</code></td>
<td>
<p>Model based on 'data2var' (see below).</p>
</td></tr>
<tr><td><code id="Gradd_+3A_data2var">data2var</code></td>
<td>
<p>Data with _exactly_ 2 variables, e.g., result of PCA.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_spacing">spacing</code></td>
<td>
<p>Density of points to predict.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_what">what</code></td>
<td>
<p>What to draw: either &quot;points&quot; for classification grid, or &quot;lines&quot; for decision boundaries</p>
</td></tr>
<tr><td><code id="Gradd_+3A_trnsp">trnsp</code></td>
<td>
<p>Transparency of points.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_pch">pch</code></td>
<td>
<p>Type of points.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_cex">cex</code></td>
<td>
<p>Scale of points.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_lwd">lwd</code></td>
<td>
<p>Width of lines.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_lty">lty</code></td>
<td>
<p>Type of lines.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_lcol">lcol</code></td>
<td>
<p>Color of lines.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_palette">palette</code></td>
<td>
<p>Palette to use.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_type">type</code></td>
<td>
<p>Type of the model: &quot;ids&quot;, &quot;lda&quot;, &quot;tree&quot;, or &quot;user&quot; (see examples).</p>
</td></tr>
<tr><td><code id="Gradd_+3A_user.predict">User.Predict</code></td>
<td>
<p>Function to define in case of 'type=&quot;user&quot;'.</p>
</td></tr>
<tr><td><code id="Gradd_+3A_...">...</code></td>
<td>
<p>Additional arguments to points() or contour().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gradd() takes model and its 2D data, makes new data with the same range
but made of dense equidistantly spaced (grid-like) points, then predicts
class labels from this new data, probably also calculates decision
boundaries, and finally plots either points colored by predition, or
lines along boundaries.
</p>
<p>Before you run Gradd(), make the model. This model should have 'predict'
method, and use ids (to make colors) and exactly 2 variables with names
same as 'data2var' column names, e.g:
</p>
<p>model2var &lt;- somemodel(ids ~ ., data=cbind(ids, data2var))
</p>
<p>If the model type is &quot;user&quot;, the Gradd() uses predefined
'User.Predict(model2var, X)' function which must return factor ids from
testing X data (see examples).
</p>
<p>To plot both lines and grid, use Gradd() twice.
</p>
<p>Gradd() is mainly a teching demo. It is useful if the goal is to
illustrate the general properties of the supervised method and/or
underlying data. It uses the entire 2D dataset to learn new data but
learning from training subset is also possible, see the Naive Bayes
example below.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SVM:
library(e1071)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.svm.pca &lt;- svm(Species ~ ., data=cbind(iris[5], iris.p))
plot(iris.p, type="n", main="SVM")
Gradd(iris.svm.pca, iris.p) # type="ids" (default)
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## LDA:
library(MASS)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.lda.pca &lt;- lda(Species ~ . , data=cbind(iris[5], iris.p))
plot(iris.p, type="n", main="LDA")
Gradd(iris.lda.pca, iris.p, type="lda")
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## tree::tree() (note how to draw decision boundaries):
library(tree)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.tree.pca &lt;- tree(Species ~ . , data=cbind(iris[5], iris.p))
plot(iris.p, type="n", main="tree")
Gradd(iris.tree.pca, iris.p, type="tree", what="lines")
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## randomForest:
library(randomForest)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.rf.pca &lt;- randomForest(Species ~ ., data=cbind(iris[5], iris.p))
plot(iris.p, type="n", main="randomForest")
Gradd(iris.rf.pca, iris.p) # type="ids" (default)
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## naiveBayes (note how to use training subsample):
library(e1071)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
sel &lt;- 1:nrow(iris) 
plot(iris.p, col=iris$Species, pch=ifelse(sel, 19, 1), main="naiveBayes")
iris.nb2 &lt;- naiveBayes(Species ~ ., data=cbind(iris[5], iris.p)[sel, ])
Gradd(iris.nb2, iris.p[sel, ], what="lines")

## rpart (note how to use MDS for the base plot):
iris.dist &lt;- dist(iris[, -5], method="manhattan")
iris.dist[iris.dist == 0] &lt;- abs(jitter(0))
library(MASS)
iris.m &lt;- isoMDS(iris.dist)$points
colnames(iris.m) &lt;- c("Dim1", "Dim2")
library(rpart)
iris.rpart.mds &lt;- rpart(Species ~ . , data=cbind(iris[5], iris.m))
plot(iris.m, type="n", main="rpart + MDS")
Gradd(iris.rpart.mds, iris.m, type="tree")
text(iris.m, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## QDA:
library(MASS)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.qda.pca &lt;- qda(Species ~ . , data=cbind(iris[5], iris.p))
plot(iris.p, type="n", main="QDA")
Gradd(iris.qda.pca, iris.p, type="lda")
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## nnet:
library(nnet)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.nnet.pca &lt;- nnet(Species ~ . , data=cbind(iris[5], iris.p), size=4)
plot(iris.p, type="n", main="nnet")
Gradd(iris.nnet.pca, iris.p, type="tree")
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))

## kNN (note how to employ User.Predict()):
library(class)
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
plot(iris.p, type="n", main="kNN")
Gradd(cbind(iris[5], iris.p), iris.p, type="user",
 User.Predict=function(model2var, X) knn(model2var[, 2:3], X, model2var[, 1], k=5))
text(iris.p, col=as.numeric(iris[, 5]), labels=abbreviate(iris[, 5], 1,
 method="both.sides"))
</code></pre>

<hr>
<h2 id='Gridmoon'>Draw with 'R'</h2><span id='topic+Gridmoon'></span>

<h3>Description</h3>

<p>Sraw with 'R'</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gridmoon(Skyres=50, Nightsky=TRUE, Daysky="deepskyblue", Moon=TRUE,
 Moonsize=0.05, Stars=TRUE, Hillcol="black", Text=c("Once upon a time..."),
 Textsize=22, Textpos=c(.15, .51), Textcol="white")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gridmoon_+3A_skyres">Skyres</code></td>
<td>
<p>Sky resoluiton</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_nightsky">Nightsky</code></td>
<td>
<p>If TRUE, ther eis a night</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_daysky">Daysky</code></td>
<td>
<p>Color of day sky</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_moon">Moon</code></td>
<td>
<p>If TRUE, there is a moon</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_moonsize">Moonsize</code></td>
<td>
<p>Moon size</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_stars">Stars</code></td>
<td>
<p>If TRUE, there are stars</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_hillcol">Hillcol</code></td>
<td>
<p>Hill color</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_text">Text</code></td>
<td>
<p>Text to print</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_textsize">Textsize</code></td>
<td>
<p>Text size</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_textpos">Textpos</code></td>
<td>
<p>Text position</p>
</td></tr>
<tr><td><code id="Gridmoon_+3A_textcol">Textcol</code></td>
<td>
<p>Text color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Gridmoon()' is an example how to paint (draw) with 'R'. Just for fun. From Murrell (2006) &quot;R Graphics&quot;, with modifications.
</p>
<p>Author's comments:
</p>
<p>An example of a one-off image drawn using the grid system.
</p>
<p>The code is somewhat modular and general, with functions for producing different shapes, but the sizes and locations used in this particular image assume a 2:1 aspect ratio.
</p>
<p>The gradient-fill background (dark at the top to lighter at the bottom) is achieved by filling multiple overlapping polygons with slowly changing shades of grey.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Murrell P. 2006. R Graphics.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples best viewed with 2:1 aspect ratio, use something like
## dev.new(width=10, height=5)
Gridmoon(Skyres=75)
Gridmoon(Nightsky=FALSE, Moon=FALSE, Stars=FALSE, Hillcol="forestgreen",
 Text="Use R!", Textcol="yellow", Textpos=c(.25, .85), Textsize=96)
</code></pre>

<hr>
<h2 id='haltica'>Haltica flea beetles</h2><span id='topic+haltica'></span>

<h3>Description</h3>

<p>Lubischew data (1962, pp. 460&ndash;461, table 2): 39 Haltica flea beetles specimens which belong to two cryptic species.
</p>
<p>Sources of specimens:
</p>
<p>Haltica oleracea:
</p>
<p>1, 2, 3, 4, 6: Western Europe (Germany, France, Italy);
5: Leningrad;
7, 8: Perm;
11, 12: Kiev;
15, 16: Middle Volga (Kuibyshev);
17: Orel district, Middle Russia;
9, 10: Northern Caucasus;
13, 14, 18, 19: Transcaucasia (Delizhan, Akstafa).
</p>
<p>H. carduorum:
</p>
<p>6: Northern Russia (Elabuga);
1, 5, 9, 10, 11, 12, 14, 16, 20: Middle Russia (Penza, Orel, Voronezh districts);
3, 4, 17; Northern Caucasus;
2, 15, 18, 19: Black Sea Coast of the Caucasus;
13: Transcaucasia (Armenia);
7, 8: Middle Asia (Schachriziabs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haltica</code></pre>


<h3>Format</h3>

<p>These data frame contains the following columns:
</p>

<dl>
<dt><code>Species</code></dt><dd><p>Species epithet</p>
</dd>
<dt><code>No</code></dt><dd><p>Number of sample (see below)</p>
</dd>
<dt><code>x5</code></dt><dd><p>The distance of the transverse groove from the posterior border of the prothorax, in microns</p>
</dd>
<dt><code>x14</code></dt><dd><p>The length of the elytram, in 0.01 mm</p>
</dd>
<dt><code>x17</code></dt><dd><p>The length of the second antennal joint, in microns</p>
</dd>
<dt><code>x18</code></dt><dd><p>The length of the third antennal joint, in microns</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lubischew A.A. 1962. On the use of discriminant functions in taxonomy. Biometrics. 18:455&ndash;477.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(prcomp(haltica[, -(1:2)])$x[, 1:2], col=haltica$Species)

haltica.qj &lt;- Classproj(haltica[, -(1:2)], haltica$Species, method="QJ")
plot(haltica.qj$proj, col=haltica$Species)
text(haltica.qj$centers, levels(haltica$Species), col=1:2)
</code></pre>

<hr>
<h2 id='Hcl2mat'>Clustering to matrix</h2><span id='topic+Hcl2mat'></span>

<h3>Description</h3>

<p>Converts clustering to matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Hcl2mat(hcl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hcl2mat_+3A_hcl">hcl</code></td>
<td>
<p><code>hclust</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts 'hclust' object into binary matrix
in accordance with clusterings.
</p>
<p>It has many uses: clustering bootstrap, clustering compare, and
matrix representation of hierarchical clustering.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bclust">Bclust</a></code>, <code><a href="#topic+MRH">MRH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(Hcl2mat(hclust(dist(iris[, -5]))))

</code></pre>

<hr>
<h2 id='Hclust.match'>Counts matches between two hierarchical clusterings</h2><span id='topic+Hclust.match'></span>

<h3>Description</h3>

<p>Counts matches between two hierarchical clusterings</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hclust.match(hc1, hc2, scale=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hclust.match_+3A_hc1">hc1</code></td>
<td>
<p>First hclust object</p>
</td></tr>
<tr><td><code id="Hclust.match_+3A_hc2">hc2</code></td>
<td>
<p>Second hclust object</p>
</td></tr>
<tr><td><code id="Hclust.match_+3A_scale">scale</code></td>
<td>
<p>Scale by the sum size of trees?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Hclust.match()' counts matches between two hierarchical clusterings (based on 'cutree()').
</p>
<p>Result is a sort of consensus distances. Useful, for example, for clustering heatmaps.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa.d1 &lt;- hclust(dist(t(atmospheres)))
aa.d2 &lt;- hclust(as.dist(1 - abs(cor(atmospheres, method="spearman"))),
 method="ward.D")
aa12.match &lt;- Hclust.match(aa.d1, aa.d2)
heatmap(aa12.match, scale="none")
</code></pre>

<hr>
<h2 id='Hcoords'>Calculates coordinates of nodes from 'hclust' plot</h2><span id='topic+Hcoords'></span>

<h3>Description</h3>

<p>Takes the 'hclust' plot and calculates coordinates of ann internal nodes</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Hcoords(hcl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hcoords_+3A_hcl">hcl</code></td>
<td>
<p><code>hclust</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates coordinates for each 'hclust' node. Inspired
by pvclust::hc2axes().
</p>
<p>Hcoords() is useful in connection with Bclust() family (namely,
Bclabels()) and also separately. Since Hcoords() allows to label
separate nodes, it can be used to label selected clusters (see
examples).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bclust">Bclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(Hcoords(hclust(dist(iris[, -5]))))

## simple example: number all nodes
hcl &lt;- hclust(UScitiesD, "ward.D2")
plot(hcl)
hcoo &lt;- Hcoords(hcl)
text(hcoo, labels=1:nrow(hcoo), pos=1)

## complex example:
## find MCCN (Most Close Common Node)
## and label it
plot(hcl)
mat &lt;- Hcl2mat(hcl)
nodes &lt;- 1:nrow(mat) # nodes are rows
colnames(mat) &lt;- hcl$labels
## take two tips and select those rows (nodes) where both present
sel1 &lt;- rowSums(mat[, colnames(mat) %in% c("Denver", "Chicago")]) &gt; 1
## MCCN is the node with both our tips but with the minimum of other tips
MCCN1 &lt;- nodes[sel1][which.min(rowSums(mat[sel1, ]))]
text(hcoo[MCCN1, , drop=FALSE], labels="Eastern + Central", pos=1)
sel2 &lt;- rowSums(mat[, colnames(mat) %in% c("Miami", "Chicago")]) &gt; 1
MCCN2 &lt;- nodes[sel2][which.min(rowSums(mat[sel2, ]))]
text(hcoo[MCCN2, , drop=FALSE], labels="Eastern", pos=1)

</code></pre>

<hr>
<h2 id='Histr'>Histogram with overlaid curve</h2><span id='topic+Histr'></span>

<h3>Description</h3>

<p>Histogram with overlaid normal curve or density, optionally with rug</p>


<h3>Usage</h3>

<pre><code class='language-R'>Histr(x, overlay="normal", rug=FALSE, col="gray80", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Histr_+3A_x">x</code></td>
<td>
<p>numerical vector</p>
</td></tr>
<tr><td><code id="Histr_+3A_overlay">overlay</code></td>
<td>
<p>type of curve to overlay, accepted values are &quot;normal&quot; and &quot;density&quot;</p>
</td></tr>
<tr><td><code id="Histr_+3A_rug">rug</code></td>
<td>
<p>if TRUE, will add rug plot</p>
</td></tr>
<tr><td><code id="Histr_+3A_col">col</code></td>
<td>
<p>curve color</p>
</td></tr>
<tr><td><code id="Histr_+3A_...">...</code></td>
<td>
<p>arguments to 'hist()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Histr() plots histogram with overlaid normal curve or density, optionally with rug.
Based on analogous function from Stephen Turner's 'Tmisc' package.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+rnorm">rnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000, mean=5, sd=2)
Histr(x)
Histr(x, overlay="density")
Histr(x^2, overlay="density", rug=TRUE, breaks=50, col="lightblue2")
</code></pre>

<hr>
<h2 id='hrahn'>Angiosperm families: morphological characters</h2><span id='topic+hrahn'></span>

<h3>Description</h3>

<p>This data originated from the Hansen and Rahn (1969) &quot;punched cards&quot;
publication, and subsequent additions and corrections (Hansen and Rahn,
1972; Hansen and Rahn, 1979). Idea was to use paper cards with holes to
assist identification of flowering plants (angiosperm) families. These
cards were digitized (Duncan and Meacham, 1986) and then used in several
multi-entry identification systems (for example, Duncan and Meacham,
1986; Ray, 1995; Families..., 2008).
</p>
<p>But what was a sizeable task in 1980&ndash;1990s, now is only few hours of R
programming. It is therefore quite easy to make such system with R,
please see the example. The core function is only a few lines of code,
everything else is the interface &quot;bells and whistles&quot;. This example
system is also applicable to any data with similar structure.
</p>
<p>The 'hrahn' data can also be used for the purposes other than
identification, for example, to assist in the morphological analysis of
angiosperm families.
</p>
<p>Comparing with original printed sources, the version used here misses
supporting illustrations and some comments to characters. Comparing with
digital sources, it was slightly modified, mostly to correct the
imperfect digitization, and add some comments from the printed version
(they are in lowercase).
</p>
<p>One of comments is large but important so it is placed below as &quot;Note I&quot;.
</p>
<p>===
</p>
<p>Note I. [concerning naming of perianth]
</p>
<p>A. Perianth segments in 1 cycle or 2 cycles uniform in colour, size and
shape.
</p>
<p>B. coloured and petal-like ... all _petals_
</p>
<p>BB. green (colourless if the plant is without chlorophyll) or dry and
hyaline, glumaceous or scarious ... all _sepals_
</p>
<p>AA. Perianth segments in 2 cycles different in colour, size or shape.
</p>
<p>C. outer cycle ... _sepals_
</p>
<p>CC. inner cycle ... _petals_
</p>
<p>AAA. Perianth segments spirally arranged with a gradual transition in
colour, size and shape from inner to outer segments: in these cases we
have guarded against misinterpretations by stating _all_ segments as
_sepals_ _and_ as _petals_. If there is a tendency to differentiation
into sepals and petals, then the numbers judged by us to be interpretable
as sepals are stated as such and in the same way for the petals.
</p>
<p>===
</p>
<p>The data is based on the family concepts and characters used in Melchior
(1964), Hutchinson (1967) and Cronquist (1981). Therefore, family
concepts might be different from those which are in use now. In the data,
families in are given in accordance with classifications above so
outputted list of families is not sorted alphabetically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
hrahn

</code></pre>


<h3>Format</h3>

<p>This is a list which contains two components:
</p>

<dl>
<dt><code>data</code></dt><dd><p>Binary matrix, row names are families, columns with
'chars'</p>
</dd>
<dt><code>chars</code></dt><dd><p>Character vector with descriptions of characters,
posititons correspond with columns of 'data'</p>
</dd>
</dl>


<h3>Source</h3>

<p>Cronquist A. 1981. An integrated system of classification of flowering
plants. Columbia University Press, New York.
</p>
<p>Duncan T., Meacham C.A. 1986. Multiple-entry keys for the identification
of angiosperm families using a microcomputer. Taxon. 35: 492&ndash;494.
</p>
<p>Families of Angiosperms: Punched Cards by Hansen and Rahn. 2008. eFloras.
URL: http://www.efloras.org/flora_page.aspx?flora_id=900. Missouri
Botanical Garden, St. Louis, MO and Harvard University Herbaria, Cambridge,
MA.
</p>
<p>Hansen B., Rahn K. 1969. Determination of angiosperm families by means of
a punched-card system. Dansk Botanisk Arkiv. 26: 1&ndash;46 + 172 punched
cards.
</p>
<p>Hansen B., Rahn K. 1972. Determination of angiosperm families by means of
a punched-card system. Additions and corrections. I. Botanisk tidsskrift.
67: 152&ndash;163.
</p>
<p>Hansen B., Rahn K. 1979. Determination of angiosperm families by means of
a punched-card system. Additions and corrections. II. Botanisk
tidsskrift. 74: 177&ndash;178.
</p>
<p>Hutchinson J. 1967. Key to the families of flowering plants of the world.
Clarendon Press, Oxford.
</p>
<p>Melchior H. 1964. A. Engler's Syllabus der Pflanzenfamilien 12. II Band.
Angiospermen. Gerbrueder Borntbaeger, Berlin, Nikolassee.
</p>
<p>Ray Ph. 1995. Flowering plant family identification. URL:
http://www.colby.edu/info.tech/BI211/info.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- hrahn$data
chars &lt;- hrahn$chars

showcharlist &lt;- function(selchar) {
 tmp &lt;- tempfile()
 selected &lt;- ifelse(seq_along(chars) %in% selchar, "[X]", "[ ]")
 useful &lt;- makeuseful(selchar)
 selected[useful] &lt;- "[O]"
 write.table(data.frame(selected, seq_along(chars), chars),
  file=tmp, quote=FALSE, col.names=FALSE, row.names=FALSE)
 file.show(tmp)
}

makeuseful &lt;- function(selchar) { # numbers of potentially useful characters
 selrows &lt;- rowSums(data[, selchar, drop=FALSE]) == length(selchar)
 sums &lt;- colSums(data[selrows, , drop=FALSE])
 seq_len(ncol(data))[sums &gt; 0 &amp; sums &lt; sum(selrows)]
}

makefam &lt;- function(selchar) { # the core function
 selrows &lt;- rowSums(data[, selchar, drop=FALSE]) == length(selchar)
 row.names(data)[selrows]
}

displayfam &lt;- function(selfam, howmany=12) { # display first "howmany" families
 if (is.null(selfam) || length(selfam) == 0) return("None")
 lfam &lt;- length(selfam)
 if (lfam &gt; howmany) {
 dfam &lt;- selfam[seq_len(howmany)]
 res &lt;- paste(c(dfam, paste0("and ", lfam-12, " more")), collapse=", ")
 } else {
 res &lt;- paste(selfam, collapse=", ")
 }
 res
}

updatechar &lt;- function(old, new) { # add or remove characters
 positive &lt;- new[new &gt; 0 &amp; new &lt;= length(chars)]
 old &lt;- union(na.omit(old), positive)
 negative &lt;- abs(new[new &lt; 0])
 setdiff(old, negative)
}

displaydn &lt;- function(num, sym="-") { # display numbers with dashes
 if (!is.numeric(num)) stop("Argument must be numeric")
 if (length(num) == 1) return(as.character(num))
 num &lt;- sort(unique(num))
 if (length(num) == 2) return(paste(num, collapse=", "))
 num[abs(num - c(num[length(num)], num[-length(num)])) == 1 &amp;
  abs(num - c(num[-1], num[1])) == 1] &lt;- "-"
 gsub(", (-, )+", sym, paste(num, collapse=", "))
## slightly longer (but concatenates with +1 number):
## cc &lt;- paste0(num, c(ifelse(diff(num) == 1, "-", ""), ""), collapse=", ")
## gsub("-, ", "-", gsub("-, (-*[0-9]+-, )+", "-", cc))
}

displaychar &lt;- function(selchar) {
 if (is.null(selchar) || length(selchar) == 0) return("None")
 displaydn(selchar)
}

run &lt;- function(howmany=12, selfam=NULL, selchar=NULL) { # interface, recursive function
if (!interactive()) return(cat("Please run in interactive mode\n"))
cat("Results:", displayfam(selfam, howmany=howmany), "\n")
cat("Selected characters:", displaychar(selchar), "\n")
cat("Potentially useful characters:", displaychar(makeuseful(selchar)), "\n")
cat("===\n")
cat("Type (character) numbers, separate with comma, negative numbers remove from selection\n")
cat("Type 'c' to see the list of characters, [X] selected, [O] potentially useful\n")
cat("Type any other single letter to exit\n")
cat("===\n")
x &lt;- readline(prompt="Your choice: ")
while (TRUE) {
 if (x == "c") showcharlist(selchar)
 if (x %in% c(letters[-3], LETTERS)) break
 new &lt;- suppressWarnings(as.integer(strsplit(x, split=",")[[1]]))
 selchar &lt;- updatechar(selchar, new)
 selfam &lt;- makefam(selchar)
 run(howmany=howmany, selfam=selfam, selchar=selchar)
 break
 }
}

run()

</code></pre>

<hr>
<h2 id='Hulls'>Convex hulls for multiple groups</h2><span id='topic+Hulls'></span>

<h3>Description</h3>

<p>Calculates and plots groups hulls and related information</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hulls(pts, groups, match.colors=TRUE, usecolors=NULL,
 plot=TRUE, centers=FALSE, c.pch=0, c.cex=3,
 outliers=TRUE, coef=1.5, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hulls_+3A_pts">pts</code></td>
<td>
<p>Data points to plot, 2-dimensional</p>
</td></tr>
<tr><td><code id="Hulls_+3A_groups">groups</code></td>
<td>
<p>Grouping variable, any type</p>
</td></tr>
<tr><td><code id="Hulls_+3A_match.colors">match.colors</code></td>
<td>
<p>Match colors with groups</p>
</td></tr>
<tr><td><code id="Hulls_+3A_usecolors">usecolors</code></td>
<td>
<p>Which group colors to use (does not rotate)</p>
</td></tr>
<tr><td><code id="Hulls_+3A_plot">plot</code></td>
<td>
<p>Plot?</p>
</td></tr>
<tr><td><code id="Hulls_+3A_centers">centers</code></td>
<td>
<p>Show centers?</p>
</td></tr>
<tr><td><code id="Hulls_+3A_c.pch">c.pch</code></td>
<td>
<p>Type of center points</p>
</td></tr>
<tr><td><code id="Hulls_+3A_c.cex">c.cex</code></td>
<td>
<p>Scale of center points</p>
</td></tr>
<tr><td><code id="Hulls_+3A_outliers">outliers</code></td>
<td>
<p>Include outliers?</p>
</td></tr>
<tr><td><code id="Hulls_+3A_coef">coef</code></td>
<td>
<p>Determines how to detect outliers, see 'coef' from 'boxplot.stats()' </p>
</td></tr>
<tr><td><code id="Hulls_+3A_...">...</code></td>
<td>
<p>Arguments to 'lines()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'centers=TRUE', Hulls() calculates centroids of polygons corresponding
with convex hulls.
</p>
<p>If 'outliers=FALSE', Hulls() uses boxplot.stats() to detect outliers
(points which are most distant from centers). This option could be used
for cluster sharpening. It also automatically switches to 'centers=TRUE'
so if you want to plot smoothed hulls but do not want to plot their
centers, use something like 'c.pch=NA' or 'c.cex=0' (see examples).
</p>
<p>Please also check Ellipses() function which uses confidence ellipses
based on F-distribution.
</p>
<p>Note that (at least at the moment), polygons are plotted with line()
function, therefore shading is not straightforward (but possible, see
examples).
</p>


<h3>Value</h3>

<p>Invisibly outputs list of hulls (polygons) with coordinates, and possibly
also with 'centers' and 'outliers' attributes. Indices of margin points
returned as row names of each polygon.
</p>
<p>See also package 'cluster' for ellipsoidhulls() function that allows to
draw ellipse-like hulls.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ellipses">Ellipses</a></code>, <code><a href="#topic+Overlap">Overlap</a></code>, <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
plot(iris.p, type="n", xlab="PC1", ylab="PC2")
pal &lt;- rainbow(3)
text(iris.p, labels=abbreviate(iris[, 5], 1, method="both.sides"),
 col=pal[as.numeric(iris[, 5])])
Hulls(iris.p, iris[, 5], centers=TRUE, usecolors=pal)

## smoothed hulls
plot(iris.p, col=iris$Species, xlab="PC1", ylab="PC2")
ppts &lt;- Hulls(iris.p, iris[, 5], centers=TRUE, outliers=FALSE, c.pch=NA)
## reveal outliers:
(out &lt;- attr(ppts, "outliers"))
points(iris.p[out, ], pch=4, cex=1.4)

## this might complement Overlap()
cnts &lt;- attr(ppts, "centers")
dist(cnts)
## how to use centers for clustering groups
plot(hclust(dist(cnts)))

## this is how to plot shaded hulls
plot(iris.p, pch=as.numeric(iris$Species))
for (i in seq_along(ppts))
 polygon(ppts[[i]], border=NA, col=adjustcolor(i, alpha.f=0.2))
</code></pre>

<hr>
<h2 id='hwc'>hwc</h2><span id='topic+hwc'></span><span id='topic+hwc2'></span><span id='topic+hwc3'></span>

<h3>Description</h3>

<p>Artificial data for teaching purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwc
hwc2
hwc3
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>COLOR</code></dt><dd><p>hair color</p>
</dd>
<dt><code>WEIGHT</code></dt><dd><p>weight, kg</p>
</dd>
<dt><code>HEIGHT</code></dt><dd><p>height, cm</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## 'hwc' was made like (commands repeated until sd was around 3):
sd(VES.BR &lt;- round(rnorm(30, mean=mean(70:90), sd=3)))
sd(VES.BL &lt;- round(rnorm(30, mean=mean(69:79), sd=3)))
sd(VES.SH &lt;- round(rnorm(30, mean=mean(70:80), sd=3)))
sd(ROST.BR &lt;- round(rnorm(30, mean=mean(160:180), sd=3)))
sd(ROST.BL &lt;- round(rnorm(30, mean=mean(155:160), sd=3)))
sd(ROST.SH &lt;- round(rnorm(30, mean=mean(160:170), sd=3)))
data.frame(COLOR=rep(c("black", "blond", "brown"), each=30),
 WEIGHT=c(VES.BR, VES.BL, VES.SH), HEIGHT=c(ROST.BR, ROST.BL, ROST.SH))

## 'hwc2' is similar but 'sd' was not controlled so it is usually not homogeneous

## 'hwc3' was made like:
set.seed(1683)
VES.BR &lt;- sample(70:90, 30, replace=TRUE)
VES.BL &lt;- sample(69:79, 30, replace=TRUE)
VES.SH &lt;- sample(70:80, 30, replace=TRUE)
ROST.BR &lt;- sample(160:180, 30, replace=TRUE)
ROST.BL &lt;- sample(155:160, 30, replace=TRUE)
ROST.SH &lt;- sample(160:170, 30, replace=TRUE)
data.frame(COLOR=rep(c("black", "blond", "brown"), each=30), 
 WEIGHT=c(VES.BR, VES.BL, VES.SH), HEIGHT=c(ROST.BR, ROST.BL, ROST.SH))
</code></pre>

<hr>
<h2 id='Infill'>Rarefaction curves</h2><span id='topic+Infill'></span><span id='topic+plot.Infill'></span><span id='topic+summary.Infill'></span>

<h3>Description</h3>

<p>Rarefaction curves</p>


<h3>Usage</h3>

<pre><code class='language-R'>Infill(x, n=10)
## S3 method for class 'Infill'
plot(x, ...)
## S3 method for class 'Infill'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Infill_+3A_x">x</code></td>
<td>
<p>Data frame where columns are species</p>
</td></tr>
<tr><td><code id="Infill_+3A_object">object</code></td>
<td>
<p>Object of the class &quot;Infill&quot;</p>
</td></tr>
<tr><td><code id="Infill_+3A_n">n</code></td>
<td>
<p>Number of permutations</p>
</td></tr>
<tr><td><code id="Infill_+3A_...">...</code></td>
<td>
<p>Arguments to 'plot()' or 'summary()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Infill()' returns matrix to draw accumulation curves (each column is one curve).
</p>
<p>'Infill' uses checklists of biological organisms to build rarefaction curves. You can estimate how many taxa will appear in the next sample to plan your investigations (e.g. revealing flora or fauna of the certain area).
</p>
<p>If cells contain taxa abundance it will be automatically replaced with 1 or 0. Permutation is a random shuffle of the samples to get more valid estimation of the taxa accumulation process. It does not matter which sample appeared first. The resulting plot gives information on the process of taxa revealing during the investigation. High number of permutations gives more precise results, but the calculations are more slow. Empirically, 100 permutations are enough. The plot indicates full taxa number which has been accumulated in this and all the previous samples.
</p>


<h3>Value</h3>

<p>Object of the class &quot;Infill&quot;, or nothing</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov, Eugeny Altshuler</p>


<h3>References</h3>

<p>Diaz-Frances E., Soberon J. 2005. Statistical estimation and model selection of species accumulation curves. Conservation Biology. Vol. 19, N 2. P. 569-573.
</p>
<p>Gotelli N.J., Colwell R.C. 2001. Quantifying biodiversity: procedures and pitfalls in the measurement and comparison of species richness. Ecology Letters. Vol. 4. P. 379-391.
</p>
<p>Soberon J.M., Llorente J.B. 1993. The use of species accumulation functions for the prediction of species richness. Conservation Biology. Vol. 7. N 3. P. 480-488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- t(dolbli)
data &lt;- x[1:45, ] # one of two lakes selected
data.I &lt;- Infill(data)
summary(data.I)
plot(data.I)
</code></pre>

<hr>
<h2 id='Jclust'>Simple bootstrap and jackknife clustering</h2><span id='topic+Jclust'></span><span id='topic+plot.Jclust'></span><span id='topic+print.Jclust'></span>

<h3>Description</h3>

<p>Simple bootstrap and jackknife clustering</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Jclust(data, n.cl, iter=1000, method.d="euclidean", method.c="ward.D",
 bootstrap=TRUE, monitor=TRUE)

## S3 method for class 'Jclust'
print(x, ...)

## S3 method for class 'Jclust'
plot(x, main="", xlab=NULL, rect.lty=3, rect.col=1,
 rect.xpd=TRUE, top=FALSE, lab.pos=3, lab.offset=0.5, lab.col=par("col"),
 lab.font=par("font"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jclust_+3A_data">data</code></td>
<td>
<p>Data</p>
</td></tr>
<tr><td><code id="Jclust_+3A_n.cl">n.cl</code></td>
<td>
<p>Number of desired clusters</p>
</td></tr>
<tr><td><code id="Jclust_+3A_iter">iter</code></td>
<td>
<p>Number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="Jclust_+3A_method.d">method.d</code></td>
<td>
<p>Distance method</p>
</td></tr>
<tr><td><code id="Jclust_+3A_method.c">method.c</code></td>
<td>
<p>Hierarchical clustering method</p>
</td></tr>
<tr><td><code id="Jclust_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Bootstrap or jackknife?</p>
</td></tr>
<tr><td><code id="Jclust_+3A_monitor">monitor</code></td>
<td>
<p>If TRUE (default), prints a dot for each replicate</p>
</td></tr>
<tr><td><code id="Jclust_+3A_x">x</code></td>
<td>
<p>Object of the class 'Jclust'</p>
</td></tr>
<tr><td><code id="Jclust_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="Jclust_+3A_xlab">xlab</code></td>
<td>
<p>Horizontal axis label</p>
</td></tr>
<tr><td><code id="Jclust_+3A_rect.lty">rect.lty</code></td>
<td>
<p>Line type for the rectangles</p>
</td></tr>
<tr><td><code id="Jclust_+3A_rect.col">rect.col</code></td>
<td>
<p>Color of rectangles</p>
</td></tr>
<tr><td><code id="Jclust_+3A_rect.xpd">rect.xpd</code></td>
<td>
<p>Plot rectangle sides if they go outside the plotting
region?</p>
</td></tr>
<tr><td><code id="Jclust_+3A_top">top</code></td>
<td>
<p>Plot values on top?</p>
</td></tr>
<tr><td><code id="Jclust_+3A_lab.pos">lab.pos</code></td>
<td>
<p>Position specifier for the values text labels</p>
</td></tr>
<tr><td><code id="Jclust_+3A_lab.offset">lab.offset</code></td>
<td>
<p>Distance of the text labels in fractions of a character width</p>
</td></tr>
<tr><td><code id="Jclust_+3A_lab.col">lab.col</code></td>
<td>
<p>Color of the text labels</p>
</td></tr>
<tr><td><code id="Jclust_+3A_lab.font">lab.font</code></td>
<td>
<p>Font of the text labels</p>
</td></tr>
<tr><td><code id="Jclust_+3A_...">...</code></td>
<td>
<p>Additional arguments to the print() or plot.hclust()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple method to bootstrap and jackknife cluster memberships, and plot
consensus membership tree. Requires the desired number of clusters.
</p>
<p>The default clustering method is the variance-minimizing &quot;ward.D&quot; (which
works better with Euclidean distances); to make it coherent with hclust()
default, specify 'method.c=&quot;complete&quot;'.
</p>
<p>Note that Jclust() is fast indirect bootstrap, it boostrap the consensus
(not the original) tree and narrows results with the desired number of
clusters. Please consider also Bclust() which is the direct method, and
phylogeny-based BootA().
</p>


<h3>Value</h3>

<p>Returns 'Jclust' object which is a list with components &quot;meth&quot; (bootstrap
or jacknife), &quot;mat&quot; (matrix of results, consensus matrix), &quot;hclust&quot;
(consensus tree as 'hclust' object), &quot;gr&quot; (groups), &quot;supp&quot; (support
values), &quot;iter&quot; (number of iterations) and &quot;n.cl&quot; (number of cluters
used.)
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bclust">Bclust</a></code>,
</p>
<p><code><a href="#topic+BootA">BootA</a></code>,
</p>
<p><code><a href="#topic+Fence">Fence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 'moldino' data, 1000 iterations
(mo.j &lt;- Jclust(t(moldino), n.cl=3, iter=1000))
plot(mo.j)

## adjust locations of value labels
data.jb &lt;- Jclust(t(atmospheres), method.c="complete", n.cl=3)
plot(data.jb, top=TRUE, lab.pos=1, lab.offset=1, lab.col=2, lab.font=2)

## plot together with Fence()
iris.jb &lt;- Jclust(iris[, -5], n.cl=3)
plot(iris.jb, labels=FALSE)
Fence(iris.jb$hclust, iris$Species)
legend("topright", legend=levels(iris$Species), col=1:3, lwd=2.5, bty="n")


## This is how one can bootstrap _all_ reliable cluster numbers:
for (i in 2:(nrow(t(moldino)) - 1)) print(Jclust(t(moldino), i, iter=1000, boot=TRUE))

</code></pre>

<hr>
<h2 id='K'>Coefficient of divergence</h2><span id='topic+K'></span><span id='topic+print.K'></span><span id='topic+summary.K'></span>

<h3>Description</h3>

<p>Lubischew's coefficient of divergence (SSMD^2)</p>


<h3>Usage</h3>

<pre><code class='language-R'>K(x, y=NULL, data=NULL, mad=FALSE, na.rm=TRUE)
## S3 method for class 'K'
print(x, ...)
## S3 method for class 'K'
summary(object, ..., num=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K_+3A_x">x</code></td>
<td>
<p>Numeric vector, or formula, or object of the class 'K'</p>
</td></tr>
<tr><td><code id="K_+3A_y">y</code></td>
<td>
<p>Second numeric vector, or nothing</p>
</td></tr>
<tr><td><code id="K_+3A_data">data</code></td>
<td>
<p>Data with two columns (in case of formula)</p>
</td></tr>
<tr><td><code id="K_+3A_mad">mad</code></td>
<td>
<p>Non-parametric variant of K (not Lubischew's)</p>
</td></tr>
<tr><td><code id="K_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NAs?</p>
</td></tr>
<tr><td><code id="K_+3A_object">object</code></td>
<td>
<p>Object of the class 'K'</p>
</td></tr>
<tr><td><code id="K_+3A_num">num</code></td>
<td>
<p>Digits to round</p>
</td></tr>
<tr><td><code id="K_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the effect size measures, Lubischew's K, coefficient of divergence (Lubischew, 1959).
Interestingly, the recently invented &quot;striclty standardized mean difference&quot;
SSMD (see, for example, &quot;https://en.wikipedia.org/wiki/Strictly_standardized_mean_difference&quot;)
is just a square root of K.
</p>


<h3>Value</h3>

<p>K() returns value of K, or nothing. summary.K() returns also magnitude and P, &quot;probability of misclassification&quot;.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Lubischew A. A. 1959. How to apply biometry to systematics. Leningrad University Herald. N 9. P. 128&ndash;136. [In Russian, English abstract].</p>


<h3>Examples</h3>

<pre><code class='language-R'>K(1:3, 2:100)
sapply(eq[, -1], function(.x) K(.x ~ eq[, 1]))
summary(K(x17 ~ Species, data=haltica), num=5)
</code></pre>

<hr>
<h2 id='keys'>Diagnostic keys</h2><span id='topic+keys'></span>

<h3>Description</h3>

<p>Diagnostic keys are data structures which help to identify biological
samples, i.e. give them (scientific) names. They are old but still very
popular because they are simple and efficient, sometimes even for not
very experienced user.
</p>
<p>The second goal of these keys is the compact representation of biological
diversity. Diagnostic keys are not very far from classification lists
(see 'classifs'), phylogeny trees (like 'phylo' objects in 'ape'
package), from core R 'dendrogram' and 'hclust' objects, and especially
from recursive partitioning objects (e.g., from 'tree' or 'rpart'
packages).
</p>
<p>In biology, diagnostic keys exist in many flavors which are possible to
reduce into two main types:
</p>
<p>I. Branched keys, where alternatives are separated.
</p>
<p>You compare your sample with the first description. Then, if the sample
agrees with first description, you go to second description (these keys
are usually fully dichotomous), then to the third, until you reach the
temninal (name of the organism). If not, you find the alternative
description of the _same level_ (same depth). The main difficulty here is
how to find it.
</p>
<p>To help user find descriptions of the same depths, branched keys are
usually presented as _indented_ where each line starts with an indent.
Bigger indent means bigger depth.
</p>
<p>Branched or indented keys could be traced at least to 1668, to one of
John Wilkins books:
</p>

<p><img src="../help/figures/wilkins1668indented.png" width="40%" alt="Figure: wilkins1668indented.png" />

</p>
<p>(and maybe to much earlier scholastic works.)
</p>
<p>Indented keys are widely used, especially in English-language
publications.
</p>
<p>Another modification could be traced to 1892 when A.
Semenow-Tjan-Shanskij published his serial key:
</p>

<p><img src="../help/figures/semenow1892serial.png" width="50%" alt="Figure: semenow1892serial.png" />

</p>
<p>Serial keys are similar to all branched keys but numbering style is
different. All steps are numbered sequentially but each has a
back-reference to the alternative so user is not required to find the
description of the same depth, they are already here. Serial keys are
strictly dichotomous. They are probably the most space-saving keys, and
still in use, especially in entomology.
</p>
<p>II. Bracket keys, where alternatives are together, and user required to
use 'goto' references to take the next step.
</p>
<p>They can be traced to the famous &quot;Flora Francoise&quot; (1778) where J.-B.
Lamarck likely used them the first time:
</p>

<p><img src="../help/figures/lamarck1778bracket.png" width="50%" alt="Figure: lamarck1788bracket.png" />

</p>
<p>You compare your sample with first description, and if it agrees, go to
where 'goto' reference says. If not, go to second (alternative)
description, and then again use its 'goto'. On the last steps, 'goto' is
just the terminal, the name you want. Sometimes, bracket keys have more
than one alternative (e.g., not fully dichotomous).
</p>
<p>Bracket keys pose another difficulty: it is not easy to go back (up) if
you by mistake went into the wrong direction. Williamson (1922) proposed
backreferenced keys where each step supplied with back-reference:
</p>

<p><img src="../help/figures/williamson1922backreferenced.png" width="50%" alt="Figure: williamson1922backreferenced.png" />

</p>
<p>Sometimes, back-references exist only in case where the referenced step
is not immediately before the current.
</p>
<p>Bracket keys (backreferenced or not) are probably most popular in
biology, and most international as well.
</p>
<p>Here bracket, branched and serial keys are standardized as rectangular
tables (data frames). Each feature (id, backreference, description,
terminal, 'goto') is just one column. In bracket keys, terminal and
'goto' are combined. For example, if you need a bracket key without
backreferences, use three columns: id, description and terminal+'goto'.
Order of columns is important, column name is not. Please see examples to
understand better.
</p>
<p>Note that while this format is human-readable, it is not typographic. To
make keys more typographic, user might want to convert them into LaTeX
where several packages allow for typesetting diagnostic keys (for
example, my 'biokey' package.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys
</code></pre>


<h3>Format</h3>

<p>The list which contains four data frames representing three different
flavors of biological diagnostic keys: two simple bracket keys, one
branched (indented variant) and one serial key. Last two keys are
real-world keys, first to determine Plantago (ribworts, plantains) from
European Russia (Shipunov, 2000), second &ndash; from North America (Shipunov,
2019).
</p>


<h3>Source</h3>

<p>Lamarck J.-B., de. 1778. Flore Francoise. Paris.
</p>
<p>Semenow-Tjan-Shanskij A.P. 1892. Note sur la subdivision du genre Lethrus
Scop. et description de deux nouvelles. Trudy Russkago Entomologicheskago
Obschestva. 26: 232&ndash;244.
</p>
<p>Shipunov A. 2000. The genera Plantago L. and Psyllium Mill.
(Plantaginaceae Juss.) in the flora of East Europe. Novosti Systematiki
Vysshikh Rastenij. 32: 139&ndash;152. [In Russian]
</p>
<p>Shipunov A. 2019. Plantago. In: Freeman, C. and Rabeler R. (eds.) Flora
of North America. 2019. 17: 280&ndash;293. Oxford University Press, New York
and Oxford.
</p>
<p>Shipunov A. 2019. biokey &ndash; Flexible identification key tables in LaTeX.
Version 3.1. See &quot;https://ctan.org/pkg/biokey&quot;.
</p>
<p>Sviridov A.V. 1994. Types of the biodiagnostic keys and their uses.
Moscow. [In Russian]
</p>
<p>Wilkins J. 1663. An essay towards the real character and philosophical
language. London.
</p>
<p>Williamson E. 1922. Keys in systematic work. Science. 55: 703. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Biokey">Biokey</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(keys)

head(bracket1)
head(bracket2)
head(branched)
head(serial)

## convert keys with Biokey()
sii &lt;- Biokey(serial, from="serial", to="indented")
sbb &lt;- Biokey(serial, from="serial", to="bracket")
bbr &lt;- Biokey(branched, from="branched", to="bracket")

## convert keys and visualize them as trees
library(ape) # load 'ape' library to plot Newick trees
plot(read.tree(text=Biokey(bracket1, from="bracket", to="newick")))
plot(read.tree(text=Biokey(bracket2, from="bracket", to="newick")))
plot(read.tree(text=Biokey(branched, from="branched", to="newick")))
plot(read.tree(text=Biokey(serial, from="serial", to="newick")))

detach(keys)

## to make a new bracket key (without backreferences)
## supply three columns: id, description and 'goto'+terminal
bracket3 &lt;- read.table(as.is=TRUE, text="
1 Small Ant
1 Big 2
2 Blue Sky
2 Green Grass
")
bracket3
Biokey(bracket3, from="bracket", to="newick")
cophenetic(ape::read.tree(text=Biokey(bracket3, from="bracket", to="newick")))
</code></pre>

<hr>
<h2 id='Life'>Game of Life</h2><span id='topic+Life'></span>

<h3>Description</h3>

<p>Conway's Game of Life</p>


<h3>Usage</h3>

<pre><code class='language-R'>Life(n.rows=40, n.cols=40, n.cycles=100, sleep.time=0.12,
 cols=c("#f0f0f0", "#2f81c1"), random=TRUE, rnd.threshold=0.3)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Life_+3A_n.rows">n.rows</code></td>
<td>
<p>Number of rows</p>
</td></tr>
<tr><td><code id="Life_+3A_n.cols">n.cols</code></td>
<td>
<p>Number of columns</p>
</td></tr>
<tr><td><code id="Life_+3A_n.cycles">n.cycles</code></td>
<td>
<p>Number of cycles</p>
</td></tr>
<tr><td><code id="Life_+3A_sleep.time">sleep.time</code></td>
<td>
<p>Time for pause after each cycle</p>
</td></tr>
<tr><td><code id="Life_+3A_cols">cols</code></td>
<td>
<p>Main colors</p>
</td></tr>
<tr><td><code id="Life_+3A_random">random</code></td>
<td>
<p>If FALSE, runs in the interactive mode</p>
</td></tr>
<tr><td><code id="Life_+3A_rnd.threshold">rnd.threshold</code></td>
<td>
<p>0 empty board; 1 all squares are filled</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the interactive mode (random=FALSE), left click to define or remove
cells, then click on red square in the bottom left corner to start
cycles. Click positions are rounded so they are not always precise.
</p>
<p>To stop cycles, use Ctrl-C (Linux, macOS) or Esc (Windows) in the main R
window.
</p>
<p>The code was inspired by the Github gist (which is not available anymore)
attributed to Vadim Vinichenko. Note that margins influence the behavior
of cells, i.e., the field is not infinite as in the &quot;classic&quot; Game of
Life.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Gardner M. 1970. The fantastic combinations of John Conway's new
solitaire game &quot;life&quot;. Scientific American. 223: 120&ndash;123.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Life(n.cols=10, n.rows=10, n.cycles=10, sleep.time=0.3)

</code></pre>

<hr>
<h2 id='Linechart'>Dotchart-like plot sfor every scaled variable grouped by factor</h2><span id='topic+Linechart'></span>

<h3>Description</h3>

<p>Dotchart-like plot for every scaled variable grouped by factor</p>


<h3>Usage</h3>

<pre><code class='language-R'>Linechart(vars, groups, xticks=TRUE, xmarks=TRUE, mad=FALSE, pch=19,
 se.lwd=1, se.col=1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Linechart_+3A_vars">vars</code></td>
<td>
<p>Variables to draw (data frame)</p>
</td></tr>
<tr><td><code id="Linechart_+3A_groups">groups</code></td>
<td>
<p>Grouing factor</p>
</td></tr>
<tr><td><code id="Linechart_+3A_xticks">xticks</code></td>
<td>
<p>Show xticks?</p>
</td></tr>
<tr><td><code id="Linechart_+3A_xmarks">xmarks</code></td>
<td>
<p>Show xmarks?</p>
</td></tr>
<tr><td><code id="Linechart_+3A_mad">mad</code></td>
<td>
<p>Show MAD instead of IQR?</p>
</td></tr>
<tr><td><code id="Linechart_+3A_pch">pch</code></td>
<td>
<p>Points type</p>
</td></tr>
<tr><td><code id="Linechart_+3A_se.lwd">se.lwd</code></td>
<td>
<p>Lines width</p>
</td></tr>
<tr><td><code id="Linechart_+3A_se.col">se.col</code></td>
<td>
<p>Lines color</p>
</td></tr>
<tr><td><code id="Linechart_+3A_...">...</code></td>
<td>
<p>arguments to 'plot()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linechart() is dotchart-based plot which shows medians and IQRs (or MADs)
for every scaled variable grouped by 'groups' factor.
</p>
<p>Alternatives: trellis designs.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Boxplots">Boxplots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
Trees &lt;- trees
Trees[, 4] &lt;- sample(letters[1:3], nrow(Trees), replace=TRUE)
Linechart(Trees[, 1:3], factor(Trees[, 4]))

Linechart(iris[, 1:4], iris[, 5])

</code></pre>

<hr>
<h2 id='Ls'>Ls</h2><span id='topic+Ls'></span>

<h3>Description</h3>

<p>Advanced object browser</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ls (pos = 1, pattern, mode = "any", type = "any", exclude = "function", sort = "name")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ls_+3A_mode">mode</code></td>
<td>
<p>which object mode to include, &quot;any&quot; to include all</p>
</td></tr>
<tr><td><code id="Ls_+3A_type">type</code></td>
<td>
<p>which object type to include (&quot;type&quot; is typically, but not always an object's class attribute), &quot;any&quot; to include all</p>
</td></tr>
<tr><td><code id="Ls_+3A_exclude">exclude</code></td>
<td>
<p>exclude functions (default), &quot;none&quot; to include all</p>
</td></tr>
<tr><td><code id="Ls_+3A_sort">sort</code></td>
<td>
<p>sort by name (default), &quot;size&quot; to sort by size</p>
</td></tr>
<tr><td><code id="Ls_+3A_pos">pos</code></td>
<td>
<p>specify environment, passed to ls()</p>
</td></tr>
<tr><td><code id="Ls_+3A_pattern">pattern</code></td>
<td>
<p>optional regular expression, passed to ls()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on 'ls()' but outputs data frame.</p>


<h3>Value</h3>

<p>Data frame with object features columns.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ls">ls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trees)
Ls()
</code></pre>

<hr>
<h2 id='Mag'>Interpreter for effect sizes</h2><span id='topic+Mag'></span>

<h3>Description</h3>

<p>Interprets R^2-related effect sizes</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mag(x, squared=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mag_+3A_x">x</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="Mag_+3A_squared">squared</code></td>
<td>
<p>Is value squared?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interpreter for R^2-related effect sizes (see example).</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- apply(cor(trees), 1:2, function(.x) Mag(.x, squared=FALSE))
aa[upper.tri(aa, diag=TRUE)] &lt;- "-"
noquote(aa)
</code></pre>

<hr>
<h2 id='MDSv'>MDS: dimension importance (&quot;explained variance&quot; surrogate)</h2><span id='topic+MDSv'></span>

<h3>Description</h3>

<p>Calculates R-squared coefficients of the linear relationships between
each of derived variables and original data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDSv(scores)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDSv_+3A_scores">scores</code></td>
<td>
<p>Data frame or matrix with values (e.g., result of isoMDS())</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MDSv() converts each of the derived variables and original data into
distance matrices, and then uses lm() to calculate adjusted R-squared
coefficients. These coefficients may be used to understand the
&quot;importance&quot; of each new dimension. They work for any dimension
reduction techique including multidimensional scaling.
</p>


<h3>Value</h3>

<p>Numeric vector, one values per column of scores</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.dist &lt;- dist(unique(iris[, -5]), method="manhattan")

iris.cmd &lt;- cmdscale(iris.dist)
MDSv(iris.cmd)

iris.p &lt;- prcomp(iris[, -5])
MDSv(iris.p$x)
100*summary(iris.p)$importance[2, ] # compare with MDSv() results

</code></pre>

<hr>
<h2 id='Miney'>Miney game</h2><span id='topic+Miney'></span>

<h3>Description</h3>

<p>Minesweeper game</p>


<h3>Usage</h3>

<pre><code class='language-R'>Miney(n, ucol="#b8ff73", gcol="#f0f0f0", bcol="red", space=0.05, pbombs=0.15)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Miney_+3A_n">n</code></td>
<td>
<p>Size of the field to play, i.e. n=9 (default) is 9 x 9 field.</p>
</td></tr>
<tr><td><code id="Miney_+3A_ucol">ucol</code></td>
<td>
<p>Color of unknown cells, default is &quot;law green&quot;</p>
</td></tr>
<tr><td><code id="Miney_+3A_gcol">gcol</code></td>
<td>
<p>Color of good cells, default is gray</p>
</td></tr>
<tr><td><code id="Miney_+3A_bcol">bcol</code></td>
<td>
<p>Color of bad cells</p>
</td></tr>
<tr><td><code id="Miney_+3A_space">space</code></td>
<td>
<p>Space between cells</p>
</td></tr>
<tr><td><code id="Miney_+3A_pbombs">pbombs</code></td>
<td>
<p>Proportion of cells with bombs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Heavily modified from 'Miney::miney()' of Roland Rau. See also the fun::mine_sweeper() function.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## interactive command:
Miney(3)

## End(Not run)
</code></pre>

<hr>
<h2 id='Misclass'>Misclassification (confusion) table</h2><span id='topic+Misclass'></span>

<h3>Description</h3>

<p>Misclassification (confusion) table</p>


<h3>Usage</h3>

<pre><code class='language-R'>Misclass(pred, obs, best=FALSE, ignore=NULL, quiet=FALSE, force=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Misclass_+3A_pred">pred</code></td>
<td>
<p>Predicted class labels</p>
</td></tr>
<tr><td><code id="Misclass_+3A_obs">obs</code></td>
<td>
<p>Observed class labels</p>
</td></tr>
<tr><td><code id="Misclass_+3A_best">best</code></td>
<td>
<p>Perform a search for the classification table with minimal misclassification error?</p>
</td></tr>
<tr><td><code id="Misclass_+3A_ignore">ignore</code></td>
<td>
<p>Vector of class labels to ignore (convert into NAs)</p>
</td></tr>
<tr><td><code id="Misclass_+3A_quiet">quiet</code></td>
<td>
<p>Output summary?</p>
</td></tr>
<tr><td><code id="Misclass_+3A_force">force</code></td>
<td>
<p>Override the restriction of class number in 'best=TRUE' and speed up code?</p>
</td></tr>
<tr><td><code id="Misclass_+3A_...">...</code></td>
<td>
<p>Arguments to 'table'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Misclass()' produces misclassification (confusion) 2D table based on two
classifications.
</p>
<p>The simple variant ('best=FALSE') assumes that class labels are concerted
(same number of corresponding classes).
</p>
<p>Advanced variant ('best=TRUE') can search for the best classification
table (with minimal misclassification rate), this is especially useful in
case of unsupervised classifications which typically return numeric
labels. It therefore assumes that the table is a result of some
non-random process. However, internally it generates all permutations of
factor levels and could be very slow if there are 8 and more class
labels. Therefore, more than 8 classes are not allowed. It is possible
nevertheless to override this restriction with 'force=TRUE'; this option
also uses the experimental code which replaces internal table() with
tabulate() and is much faster with many labels.
</p>
<p>Variant with 'best=TRUE' might also add empty rows (filled with zeros) to
the table in case if numbers of classes are not equal.
</p>
<p>Additional arguments could be passed for table(), for example,
'useNA=&quot;ifany&quot;'. If supplied data contains NAs, there will be also note
in the end. Note that tabulate()-based code (activated with force=&quot;TRUE&quot;)
does not take table()-specific arguments, so if this is a case, warning
will be issued.
</p>
<p>It is possible to ignore (convert into NAs) some class labels with
'ignore=...', this is useful for methods like DBSCAN which output special
label for outliers. In that case, note about missing data is also issued.
</p>
<p>Alternatives: confusion matrix from caret::confusionMatrix() which is
more feature rich but much less flexible. See in examples how to
implement some statistics used there.
</p>
<p>Note that partial &quot;Misclassification errors&quot; are reverse sensitivities,
and &quot;Mean misclassification error&quot; is a reverse accuracy.
</p>
<p>If you want to plot misclassification table, Cohen-Friendly association
plot, assocplot() is probably the best. On this plot, note rectangles
which are big, tall and black (check help(assocplot) to know more).
Diagonal which is black and other cells red indicate low
misclassification rates.
</p>


<h3>Value</h3>

<p>Invisibly returns the table of class comparison</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Adj.Rand">Adj.Rand</a></code>, <code>link{assocplot}</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.dist &lt;- dist(iris[, -5], method="manhattan")
iris.hclust &lt;- hclust(iris.dist)
iris.3 &lt;- cutree(iris.hclust, 3)
Misclass(iris.3, iris[, 5])

set.seed(1)
iris.k &lt;- kmeans(iris[, -5], centers=3)
Misclass(iris.k$cluster, iris[, 5])
Misclass(iris.k$cluster, iris[, 5], best=TRUE)

res &lt;- Misclass(iris.k$cluster, iris[, 5], best=TRUE, quiet=TRUE)
## how to calculate statistics from caret::confusionMatrix()
binom.test(sum(diag(res)), sum(res))$conf.int
mcnemar.test(res) # to avoid NA's, add small number to 'res'
## how to plot misclassification table
assocplot(res)
## how to use Misclass() for Recode()
nn &lt;- Recode(iris.k$cluster, from=dimnames(res)$pred, to=dimnames(res)$obs)
head(nn)

library(dbscan)
iris.db &lt;- dbscan(iris[, -5], eps=0.3)
Misclass(iris.db$cluster, iris$Species, ignore=0, best=TRUE)

set.seed(NULL)
</code></pre>

<hr>
<h2 id='Missing.map'>Textual plot of missing data</h2><span id='topic+Missing.map'></span>

<h3>Description</h3>

<p>Textual plot of missing data</p>


<h3>Usage</h3>

<pre><code class='language-R'>Missing.map(df)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Missing.map_+3A_df">df</code></td>
<td>
<p>Data frame with any data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Missing.map()' makes textual plot of missing data, inspired by 'DescTools::PlotMiss()'.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>Missing.map(salix_leaves)
</code></pre>

<hr>
<h2 id='moldino'>moldino</h2><span id='topic+moldino'></span><span id='topic+moldino_l'></span>

<h3>Description</h3>

<p>Observations on island floras.
Islands are located in the freshwater Moldino lake, Middle Russia.
Data collected in 2013.
</p>
<p>'moldino_l' contains squares and GPS locations.
</p>
<p>'moldino' contains the actual abundance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moldino</code></pre>


<h3>Format</h3>


<dl>
<dt><code>columns</code></dt><dd><p>Island names, data is abundance of plant species, in 1543 scale
(0 &ndash; absent; 1 &ndash; one individual plant; 2 &ndash; no more than 12 individual plants (rametes);
3 &ndash; number of individuals is more than 12 but no more than 5% of total number of plants on a plot;
4 &ndash; number of individuals is more than 5% but no more than 25% of total number of plants on a plot;
5 &ndash; number of individuals is more than 25% but no more than 50% of total number of plants on a plot;
6 &ndash; number of individuals is more than 50% but no more than 75% of total number of plants on a plot;
7 &ndash; number of individuals is more than 75% of total number of plants on a plot.)</p>
</dd>
<dt><code>rows</code></dt><dd><p>Names of plant species</p>
</dd>
<dt><code>NAME</code></dt><dd><p>Island name</p>
</dd>
<dt><code>SQUARE</code></dt><dd><p>Island square, m2</p>
</dd>
<dt><code>LAT</code></dt><dd><p>Latitude</p>
</dd>
<dt><code>LON</code></dt><dd><p>Longitude</p>
</dd>
</dl>



<h3>Source</h3>

<p>Abramova L., Volkova P., Eliseeva E., Troshina A., Shipunov A.
2005&ndash;inward. The checklist of flora from environs of village Polukarpovo
(Tver region). See<br />
&quot;http://ashipunov.info/shipunov/moldino/nauka/molflora.pdf&quot;.
</p>
<p>Shipunov A., Abramova L. 2014. Islands in lakes and the sea: how do they
differ? European Journal of Environmental Sciences. 4: 112&ndash;115.
</p>

<hr>
<h2 id='MrBayes'>Calls MrBayes</h2><span id='topic+MrBayes'></span>

<h3>Description</h3>

<p>A slight improvement of 'ips::mrbayes()'</p>


<h3>Usage</h3>

<pre><code class='language-R'>MrBayes(x, file="", nst=6, rates="invgamma", ngammacat=4, nruns=2, ngen=1e+06,
 printfreq=100, samplefreq=10, nchains=4, savebrlens="yes", temp=0.2, burnin=10,
 contype="allcompat", run=FALSE, simple=TRUE, exec="mb-mpi", method="dna")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MrBayes_+3A_x">x</code></td>
<td>
<p>The object to process (must be 'DNAbin' class)</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_file">file</code></td>
<td>
<p>A character string, giving the name of the MrBayes input file</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_nst">nst</code></td>
<td>
<p>An integer giving the number of rates in the model of sequence evolution</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_rates">rates</code></td>
<td>
<p>A character string; allowed are &quot;equal&quot;, &quot;gamma&quot;, &quot;propinv&quot;, &quot;invgamma&quot;, and &quot;adgamma&quot;; the default is &quot;equal&quot;</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_ngammacat">ngammacat</code></td>
<td>
<p>An integer; the number rate categories for the discretized Gamma distribution; the default is '4'</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_nruns">nruns</code></td>
<td>
<p>An integer; the number of runs</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_ngen">ngen</code></td>
<td>
<p>An integer; the number of states of the MCMC</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_printfreq">printfreq</code></td>
<td>
<p>An integer; the interval between states of the MCMC to be printed on the screen</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_samplefreq">samplefreq</code></td>
<td>
<p>An integer; the interval between states of the MCMC to be sampled</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_nchains">nchains</code></td>
<td>
<p>An integer; number of Metropolis coupled MCMCs in each run</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_savebrlens">savebrlens</code></td>
<td>
<p>Logical; shall branch lengths be saved</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_temp">temp</code></td>
<td>
<p>Heating parameter</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_burnin">burnin</code></td>
<td>
<p>An integer; the number of samples from the MCMC to be discarded prior to further analysis</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_contype">contype</code></td>
<td>
<p>A character string; the type of consensus tree calculated from the posterior distribution of trees</p>
</td></tr></table>
<p>either &quot;halfcompat&quot; (majority-rule consensus tree) or &quot;allcombat&quot; (strict consensus tree)
</p>
<table>
<tr><td><code id="MrBayes_+3A_run">run</code></td>
<td>
<p>Logical; 'run = FALSE' will only print the NEXUS file, 'run = TRUE' will also start the MCMC runs, if the 'path' argument is correctly specified</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_simple">simple</code></td>
<td>
<p>New option: if TRUE (default), then outputs tree in the format readable by functions from 'ape' package</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_exec">exec</code></td>
<td>
<p>New option: name of UNIX executable (to allow multi-threaded version)</p>
</td></tr>
<tr><td><code id="MrBayes_+3A_method">method</code></td>
<td>
<p>New option: either &quot;dna&quot;, or &quot;mixed&quot; to handle mixed or purely morphologic data (see below)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MrBayes() is an improvement of ips::mrbayes() and ips::mrbayes.mixed(). Please see its documentation for clarity and other options.
</p>
<p>Comparing with 'ips' sources, MrBayes() has some code alterations and three more options. It also both views and saves output (works only on UNIX).
</p>
<p>If 'method=&quot;mixed&quot;', the function requires character matrix as input where missing data are labeled with &quot;N&quot;,
morphological columns encoded as 0/1 and placed after nucleotide columns (which might be absent).
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p>ips::<code><a href="ips.html#topic+mrbayes">mrbayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ips)
data(ips.cox1)
x &lt;- ips.cox1[, 100:140]

## Not run: 
## requires MrBayes program installation
MrBayes(x, file="cox1", ngen=100, run=TRUE)

str(plantago)
plantago[is.na(plantago)] &lt;- "N"
row.names(plantago) &lt;- gsub(" ", "_", row.names(plantago))
## requires MrBayes program installation
tr &lt;- MrBayes(plantago, file="plantago", method="mixed", burnin=5000, run=TRUE) # makes many files
tr &lt;- tr[[1]]
tr &lt;- root(tr, outgroup="Plantago_maritima", resolve.root=TRUE)
tr$node.label &lt;- suppressWarnings(round(as.numeric(tr$node.label)*100)) # warning is OK
tr$node.label[tr$node.label == "NA"] &lt;- ""
plot(tr)
nodelabels(tr$node.label, frame="none", bg="transparent", adj=-0.1)
add.scale.bar()

## End(Not run)
</code></pre>

<hr>
<h2 id='MRH'>Matrix Representation of Hierarchical Clustering</h2><span id='topic+MRH'></span>

<h3>Description</h3>

<p>Matrix Representation of Hierarchical clustering (MRH)</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRH(hcl, dim=NULL, method="groups")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRH_+3A_hcl">hcl</code></td>
<td>
<p>'hclust' object</p>
</td></tr>
<tr><td><code id="MRH_+3A_dim">dim</code></td>
<td>
<p>Number of desired dimensions, if defaults are not suitable</p>
</td></tr>
<tr><td><code id="MRH_+3A_method">method</code></td>
<td>
<p>Either &quot;groups&quot; (default), or &quot;height&quot;, or &quot;branches&quot;, or &quot;cophenetic&quot; (see below for explanations)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls cutree(), or Hcl2mat(), or cmdscale(cophenetic()) in order to output the
Matrix Representation of Hierarchical clustering (MRH).
</p>
<p>If method=&quot;groups&quot; then clustering tree is cut by all possible numbers of clusters 'k'
(excluding 'k=1' and 'k=n' which bring no information) so 'dim' is always 'n-2'.
</p>
<p>If method=&quot;height&quot; then clustering tree is cut by equally spaced agglomeration heights
(excluding minimal and maximal heights which bring no information). Default 'dim' here is '2*n',
but higher values might work even better.
</p>
<p>If method=&quot;branches&quot; then use Hcl2mat() to transform object into the binary matrix of memberships,
always with  'n-1' dimensions (so user-specified 'dim' is not taken into account).
Each column in this matrix represents the tree branch.
</p>
<p>If method=&quot;cophenetic&quot; then multidimensional scaling scores with maximum dimensionality on cophenetic
distances are computed. Default 'dim' is 'n-1' but lesser numbers might work better.
</p>
<p>The main feature of the resulted matrices is that they provide the &quot;bridge&quot; of conversion between original data,
distance matrices and clustering (including phylogenetic trees) results. After conversion, many interesting applications
become possible. For example, if converted trees represent the _same_ objects,  it is possible to &quot;hyper-bind&quot;,
or &quot;average&quot; (Ashkenazy et al., 2018) them.
</p>
<p>To work with 'phylo' objects, convert them first to 'hclust' with as.hclust(), and before that, possibly also apply
compute.brlen(), multi2di() and collapse.singles().
</p>


<h3>Value</h3>

<p>Matrix with default number of columns equal to number of objects (n) minus 1 (method=&quot;branches&quot; or method=&quot;cophenetic&quot;)
or 'n-2' (method=&quot;groups&quot;), or '2*n' (method=&quot;height&quot;).
</p>
<p>Rows are objects, values are either cluster numbers (method=&quot;groups&quot; or method=&quot;height&quot;)
so matrix consist of whole positive numbers,  binary cluster memberships (method=&quot;branches&quot;)
or decimal MDS scores (method=&quot;cophenetic&quot;).
</p>


<h3>References</h3>

<p>Ashkenazy H., Sela I., Levy Karin E., Landan G., Pupko T. 2018. Multiple sequence alignment averaging
improves phylogeny reconstruction. Systematic Biology. 68: 117&ndash;130.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cutree">cutree</a></code>, <code>link{cmdscale}</code>, <code>link{Hcl2mat}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa.h &lt;- hclust(dist(t(atmospheres)))
plot(aa.h)

(aa.mrh1 &lt;- MRH(aa.h))
plot(hclust(dist(aa.mrh1)))

aa.mrh2 &lt;- MRH(aa.h, method="height", dim=100) # here 'dim' should better be large
str(aa.mrh2)
plot(hclust(dist(aa.mrh2)))

plot(hclust(dist(cbind(aa.mrh1, aa.mrh2)))) # hyper-bind

(aa.mrh3 &lt;- MRH(aa.h, method="branches"))
plot(hclust(dist(aa.mrh3)))

(aa.mrh4 &lt;- MRH(aa.h, method="cophenetic"))
plot(hclust(dist(aa.mrh4)))

library(ape)
tree &lt;- read.tree(text="((A:1,B:1):2,(C:3,D:4):2):3;")
(tree.mrh3 &lt;- MRH(as.hclust(compute.brlen(tree)), method="branches"))
</code></pre>

<hr>
<h2 id='NC.dist'>Normalized Compression Distance</h2><span id='topic+NC.dist'></span>

<h3>Description</h3>

<p>Calculates the normalized compression distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>NC.dist(data, method="gzip", character=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NC.dist_+3A_data">data</code></td>
<td>
<p>Matrix (or data frame) with variables that should be used in
the computation of the distance between rows.</p>
</td></tr>
<tr><td><code id="NC.dist_+3A_method">method</code></td>
<td>
<p>Taken from memCompress(): either &quot;gzip&quot;, or &quot;bzip2&quot;, or
&quot;xz&quot;; the last is very slow</p>
</td></tr>
<tr><td><code id="NC.dist_+3A_character">character</code></td>
<td>
<p>Convert to character mode (default), or use as raw?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NC.dist() computes the distance based on the sizes of the compressed
vectors. It is calculated as
</p>
<p>dissimilarity(x, y) = B(x, y) - max(B(x), B(y)) / min(B(x), B(y))
</p>
<p>where B(x) and B(y) are the bytesizes of the compressed 'x' and 'y', and
B(x, y) is the comressed bytesize of concatenated 'x' and 'y'. The
algorithm uses basic memCompress() function.
</p>
<p>If argument is the data frame, NC.dist() internally converts it into the
matrix. All columns by default will be converted into character mode (and
if 'character=FALSE', into raw). This default behavior allows NC.dist() to be
the universal distance which also does not mind NAs and zeroes.
</p>


<h3>Value</h3>

<p>Distance object with distances among rows of 'data'</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Cilibrasi, R., &amp; Vitanyi, P. M. (2005). Clustering by compression.
Information Theory, IEEE Transactions on, 51(4), 1523-1545.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+memCompress">memCompress</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## converts variables into character, universal method
iris.nc &lt;- NC.dist(iris[, -5])
iris.hnc &lt;- hclust(iris.nc, method="ward.D2")
## amazingly, it works even for vectors with length=4 (iris data rows)
plot(prcomp(iris[, -5])$x, col=cutree(iris.hnc, 3))

## using variables as raw, it is good when they are uniform
iris.nc2 &lt;- NC.dist(iris[, -5], character=FALSE)
iris.hnc2 &lt;- hclust(iris.nc2, method="ward.D2")
plot(prcomp(iris[, -5])$x, col=cutree(iris.hnc2, 3))

## bzip2 uses Burrows-Wheeler transform
NC.dist(matrix(runif(100), ncol=10), method="bzip2")

</code></pre>

<hr>
<h2 id='Normality'>Check normality</h2><span id='topic+Normality'></span>

<h3>Description</h3>

<p>Check normality through Shapiro-Wilks test</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normality(x, p=0.05)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normality_+3A_x">x</code></td>
<td>
<p>numerical vector</p>
</td></tr>
<tr><td><code id="Normality_+3A_p">p</code></td>
<td>
<p>level of significance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normality via Shapiro-Wilks test. Kolmogorov-Smirnov is apparently too weak for small samples. The word of caution: this function only <em>helps</em> to decide if the data complains with parametric methods (&quot;normal&quot;). </p>


<h3>Value</h3>

<p>Character vector of length one.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="stats.html#topic+rnorm">rnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Normality(rnorm(100))
sapply(trees, Normality)
</code></pre>

<hr>
<h2 id='Overlap'>Calculates overlap between polygons</h2><span id='topic+Overlap'></span><span id='topic+summary.Overlap'></span>

<h3>Description</h3>

<p>Calculates overlaps between polygons (typically, convex hulls or
confidence ellipses from some scatterplot). Requires 'PBSmapping'
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Overlap(ppts, symmetric=FALSE, negative=FALSE)
## S3 method for class 'Overlap'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Overlap_+3A_ppts">ppts</code></td>
<td>
<p>List with hulls information (e.g., output from Hulls())</p>
</td></tr>
<tr><td><code id="Overlap_+3A_symmetric">symmetric</code></td>
<td>
<p>Make overlaps symmetric (like in distance matrix)?</p>
</td></tr>
<tr><td><code id="Overlap_+3A_negative">negative</code></td>
<td>
<p>Calculate &quot;negative overlaps&quot; (relative distance between
non-overlapped hulls)?</p>
</td></tr>
<tr><td><code id="Overlap_+3A_object">object</code></td>
<td>
<p>Object of the class 'Overlap'</p>
</td></tr>
<tr><td><code id="Overlap_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea of Overlap() is to provide the measurement of the
separation between groups in 2D space.
</p>
<p>Overlap() employs calculations of areas of polygons and their intersects
provided by 'PBSmapping' package. Initially, it was based on the code
provided by J. Oksanen for his &quot;ordihulldist&quot; function.
</p>
<p>By default, overlaps are asymmetric, so overlap between a and b is not
necessarily equal to the overlap between b and a. If 'symmetric=TRUE',
then Overlap() will calculate symmetric overlaps, less precise but more
suitable, e.g., for interpreting overlaps as distances.
</p>
<p>When 'negative=TRUE', Overlap() calculates also negative polygon-based
distances between non-overlapping polygons. They are symmetric and might
be used as similarities too (please look on examples).
</p>
<p>summary.Overlap() provides some general numbers, including mean and total
overlaps for each hull. In these calculations, hulls without overlaps are
ignored. Note that summary.Overlap() calculates the arithmetic, not
geometric, mean (whereras symmetric Overlap() uses geometric mean). The
average of all overlaps could serve as the reliable measure of the
quality of dimension reduction.
</p>
<p>Please also check out vegan::ordiareatest() function; this studies the
one-side hypothesis that actuall hull areas are smaller than with
randomized groups (i.e., that actuall hulls are better than random).
</p>


<h3>Value</h3>

<p>Object (square matrix) of class 'Overlap', or nothing.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Serebryanaya A., Shipunov A. 2009. Morphological variation of plants on
the uprising islands of northern Russia. Annales Botanici Fennici. 2009.
46: 81-89.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Ellipses">Ellipses</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.h &lt;- Hulls(iris.p, iris$Species, plot=FALSE)

Overlap(iris.h)
Overlap(iris.h, negative=TRUE)
Overlap(iris.h, symmetric=TRUE)

(iris.o &lt;- Overlap(iris.h, symmetric=TRUE, negative=TRUE))
as.dist(1 - iris.o) # how to convert overlaps into distance-like objects

summary(Overlap(iris.h))
summary(Overlap(iris.h, negative=TRUE))
summary(Overlap(iris.h, symmetric=TRUE))
summary(iris.o)

iris.e &lt;- Ellipses(iris.p, iris$Species, plot=FALSE, centers=TRUE)
Overlap(iris.e, negative=TRUE)

</code></pre>

<hr>
<h2 id='pairwise.Eff'>Pairwise table of effects with magnitudes</h2><span id='topic+pairwise.Eff'></span>

<h3>Description</h3>

<p>Pairwise table of effects with magnitudes</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.Eff(vec, fac, eff="K", dec=2, mad=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.Eff_+3A_vec">vec</code></td>
<td>
<p>Values</p>
</td></tr>
<tr><td><code id="pairwise.Eff_+3A_fac">fac</code></td>
<td>
<p>Groups</p>
</td></tr>
<tr><td><code id="pairwise.Eff_+3A_eff">eff</code></td>
<td>
<p>Effect, either 'K' or 'cohen.d', or 'cliff.delta'</p>
</td></tr>
<tr><td><code id="pairwise.Eff_+3A_dec">dec</code></td>
<td>
<p>Decimals to round</p>
</td></tr>
<tr><td><code id="pairwise.Eff_+3A_mad">mad</code></td>
<td>
<p>Use MAD-based nonparametric modification of K?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairwise table of effect sizes.
</p>
<p>At the moment, classic Lyubischev's K (a.k.a. SSSMD),
effsize::cliff.delta() and effsize::cohen.d() are supported.
</p>


<h3>Value</h3>

<p>List with test outputs.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairwise.Eff(hwc$WEIGHT, hwc$COLOR)
pairwise.Eff(hwc$WEIGHT, hwc$COLOR, mad=TRUE)
pairwise.Eff(hwc$WEIGHT, hwc$COLOR, eff="cohen.d")
pairwise.Eff(hwc$WEIGHT, hwc$COLOR, eff="cliff.delta")
</code></pre>

<hr>
<h2 id='pairwise.Rro.test'>Robust rank order test post hoc derivative</h2><span id='topic+pairwise.Rro.test'></span>

<h3>Description</h3>

<p>Robust rank order test post hoc derivative</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.Rro.test(x, g, p.adjust.method="BH")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.Rro.test_+3A_x">x</code></td>
<td>
<p>Values</p>
</td></tr>
<tr><td><code id="pairwise.Rro.test_+3A_g">g</code></td>
<td>
<p>Groups</p>
</td></tr>
<tr><td><code id="pairwise.Rro.test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>See '?p.adjust'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'pairwise.Rro.test()' is the Robust rank order test post hoc derivative.</p>


<h3>Value</h3>

<p>List with test outputs</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rro.test">Rro.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pairwise.Rro.test(airquality$Ozone, airquality$Month)
</code></pre>

<hr>
<h2 id='pairwise.Table2.test'>Pairwise Chi-squared or Fisher test for 2-dimensional tables</h2><span id='topic+pairwise.Table2.test'></span>

<h3>Description</h3>

<p>Pairwise Chi-squared or Fisher test for 2-dimensional tables</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.Table2.test(tbl, names=rownames(tbl), p.adjust.method="BH", exact=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.Table2.test_+3A_tbl">tbl</code></td>
<td>
<p>Contingency table</p>
</td></tr>
<tr><td><code id="pairwise.Table2.test_+3A_names">names</code></td>
<td>
<p>Level names</p>
</td></tr>
<tr><td><code id="pairwise.Table2.test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>See '?p.adjust'</p>
</td></tr>
<tr><td><code id="pairwise.Table2.test_+3A_exact">exact</code></td>
<td>
<p>Run exact test?</p>
</td></tr>
<tr><td><code id="pairwise.Table2.test_+3A_...">...</code></td>
<td>
<p>Arguments to test function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairwise Chi-squared or Fisher test for 2-dimensional tables.
</p>
<p>Alternatives: NCStats::chisqPostHoc() and fifer::chisq.post.hoc(). Both
of them are not CRAN packages.
</p>


<h3>Value</h3>

<p>List with test outputs.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>titanic &lt;- margin.table(Titanic, c(1, 4))
chisq.test(titanic)
pairwise.Table2.test(titanic)
</code></pre>

<hr>
<h2 id='Phyllotaxis'>Plant phyllotaxis</h2><span id='topic+Phyllotaxis'></span><span id='topic+Fibonacci'></span>

<h3>Description</h3>

<p>Outputs the plant phyllotaxis formula or angle of divergence</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phyllotaxis(n, angle=FALSE)
Fibonacci(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Phyllotaxis_+3A_n">n</code></td>
<td>
<p>non-negative integer</p>
</td></tr>
<tr><td><code id="Phyllotaxis_+3A_angle">angle</code></td>
<td>
<p>if TRUE, output angle of divergence</p>
</td></tr>
<tr><td><code id="Phyllotaxis_+3A_x">x</code></td>
<td>
<p>non-negative integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Fibonacci(x)' calculates the n's Fibonacci's number, it is the rare case that is not exercise but really used for work.
</p>
<p>'Phyllotaxis(n)' uses 'Fibonacci(x)' to output the phyllotaxis formula (see examples) or (if 'angle=TRUE') the angle of divergence.
</p>


<h3>Value</h3>

<p>Number or character vector of length one.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(1:10, Fibonacci)
sapply(1:10, Phyllotaxis)
sapply(1:10, Phyllotaxis, angle=TRUE)
</code></pre>

<hr>
<h2 id='Pinhull'>Point in hull</h2><span id='topic+Pinhull'></span>

<h3>Description</h3>

<p>For each observation, returns if it is within a polygon</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Pinhull(pts, ppts)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pinhull_+3A_pts">pts</code></td>
<td>
<p>Data points, 2-dimensional</p>
</td></tr>
<tr><td><code id="Pinhull_+3A_ppts">ppts</code></td>
<td>
<p>List with polygon information (e.g., output from Hulls() or
Ellipses())</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each 'pts' observation, Pinhull() uses PBSmapping::findPolys() to
find if it is within (or on the border) of each polygon described in
'ppts'.
</p>
<p>The output or Pinhull is easy to use to calculate the &quot;observation
overlap&quot;, it also allows to reveal &quot;outliers&quot; (points outside all
polygons) and all polygon membership features (e.g., which points belong
to more than one polygon).
</p>


<h3>Value</h3>

<p>Logical matrix, each column is the hull (polygon) name, rows correspond
with rows of data points.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Ellipses">Ellipses</a></code>, <code><a href="#topic+Overlap">Overlap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.h &lt;- Hulls(iris.p, iris$Species, plot=FALSE)
iris.e &lt;- Ellipses(iris.p, iris$Species, plot=FALSE)

## convex hulls
iris.pih &lt;- Pinhull(iris.p, iris.h)

## confidence ellipses
iris.pie &lt;- Pinhull(iris.p, iris.e)
## membership overlap
dist(t(iris.pie), method="binary")
## how to find outliers (points outside of all ellipses)
which(apply(iris.pie, 1, sum) == 0) # outliers
## how to make membership table
iris.pie.g &lt;- cbind(iris.pie, group=Alldups(iris.pie, groups=TRUE))
key &lt;- iris.pie.g[!duplicated(iris.pie), ]
key &lt;- key[order(key[, "group"]), ]
mem &lt;- aggregate(1:nrow(iris.p), list(group=iris.pie.g[, "group"]), paste0, collapse=", ")
mem &lt;- cbind(key, mem)
mem[, mem %-% "group"] # all memberships

## distance based on membership intersection, Overlap() analog
dist(t(iris.pie), method="binary") # asymmetric binary
SM.dist(t(iris.pie)) # symmetric binary

## uniqueness of species
lapply(1:3, function(.x) sum(rowSums(iris.pie[as.numeric(iris$Species) == .x,
 ]) &gt; 1)/table(iris$Species)[.x]) ## versicolor is least unique

</code></pre>

<hr>
<h2 id='plantago'>plantago</h2><span id='topic+plantago'></span>

<h3>Description</h3>

<p>Plantago (ribworts, plantains) species from European Russia:
morphological table (Shipunov, 1998).
</p>
<p>All not applicable, unknown and &quot;both&quot; values are labeled as &quot;NA&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plantago
</code></pre>


<h3>Format</h3>

<p>This data frame has species names as row names, and contains the
following columns (all variables are binary):
</p>

<dl>
<dt><code>V01</code></dt><dd><p>0 annuals or biennials, 1 perennials</p>
</dd>
<dt><code>V02</code></dt><dd><p>0 not taller than 20 cm, 1 taller than 20 cm</p>
</dd>
<dt><code>V03</code></dt><dd><p>0 aboveground stems herbaceous, 1 aboveground stems woody</p>
</dd>
<dt><code>V04</code></dt><dd><p>0 vegetative nodes shortened, 1 vegetative nodes elongated</p>
</dd>
<dt><code>V05</code></dt><dd><p>0 vegetative shoots do not branch, 1 vegetative shoots branch</p>
</dd>
<dt><code>V06</code></dt><dd><p>0 phyllotaxis opposite, 1 phyllotaxis alternate</p>
</dd>
<dt><code>V07</code></dt><dd><p>0 well developed green leaves &lt;= 5, 1 more</p>
</dd>
<dt><code>V08</code></dt><dd><p>0 the base of main shoot covered with remains of withered leaves, 1 the base is not covered with remains of withered leaves</p>
</dd>
<dt><code>V09</code></dt><dd><p>0 rhizome &gt; 1 cm diam, 1 rhizome thinner</p>
</dd>
<dt><code>V10</code></dt><dd><p>0 slanted or horizontal rhizome, 1 vertical rhizome</p>
</dd>
<dt><code>V11</code></dt><dd><p>0 main root fast degrading, 1 main root presents on adult plants</p>
</dd>
<dt><code>V12</code></dt><dd><p>0 adventitious and lateral roots &gt;= 1 mm diam, 1 less than 1 mm diam</p>
</dd>
<dt><code>V13</code></dt><dd><p>0 heterophylly present, 1 leaves similar</p>
</dd>
<dt><code>V14</code></dt><dd><p>0 leaves thin, transparent, 1 leaves not transparent</p>
</dd>
<dt><code>V15</code></dt><dd><p>0 leaves darken when dry, 1 leaves do not darken, sometimes became yellow or brown</p>
</dd>
<dt><code>V16</code></dt><dd><p>0 leaves (almost) naked, 1 leaves pubescent</p>
</dd>
<dt><code>V17</code></dt><dd><p>0 leaves flat, 1 leaves section rounded or leaves with furrow</p>
</dd>
<dt><code>V18</code></dt><dd><p>0 leaves with large teeth or even lobes, 1 leaves margin whole or with small teeth</p>
</dd>
<dt><code>V19</code></dt><dd><p>0 leaves linear, 1 leaves more broad</p>
</dd>
<dt><code>V20</code></dt><dd><p>0 leaves lanceolate, 1 leaves more broad</p>
</dd>
<dt><code>V21</code></dt><dd><p>0 leaves obovate, 1 leaves elliptic or ovate</p>
</dd>
<dt><code>V22</code></dt><dd><p>0 leaf tip blunt, 1 leaf tip sharp</p>
</dd>
<dt><code>V23</code></dt><dd><p>0 leaf base broad, suddenly narrowing into petiole, 1 leaf base narrow, smoothly become a petiole</p>
</dd>
<dt><code>V24</code></dt><dd><p>0 leaf margin with teeth, 1 leaf margin whole</p>
</dd>
<dt><code>V25</code></dt><dd><p>0 leaf veins &gt;=7, 1 &lt; 7</p>
</dd>
<dt><code>V26</code></dt><dd><p>0 petioles present, 1 petioles absent</p>
</dd>
<dt><code>V27</code></dt><dd><p>0 petioles almost equal or a bit shorter than leaf blades, 1 petioles much shorter than blades</p>
</dd>
<dt><code>V28</code></dt><dd><p>0 petioles without wings at the lowest 1/3 of length, 1 petioles with wings at the lowest 1/3 of length</p>
</dd>
<dt><code>V29</code></dt><dd><p>0 stalks horizontal or arcuate, 1 stalks straight or curved</p>
</dd>
<dt><code>V30</code></dt><dd><p>0 stalks naked, 1 stalks pubescent</p>
</dd>
<dt><code>V31</code></dt><dd><p>0 stalks with ribs, 1 stalks without ribs</p>
</dd>
<dt><code>V32</code></dt><dd><p>0 spikes longer, equal or slightly shorter than stalks, 1 spikes much shorter than stalks</p>
</dd>
<dt><code>V33</code></dt><dd><p>0 spikes long cylindrical or tail-like, 1 spikes rounded or short cylindrical</p>
</dd>
<dt><code>V34</code></dt><dd><p>0 lower bracts are much much broader than others, 1 all bracts similar</p>
</dd>
<dt><code>V35</code></dt><dd><p>0 middle and upper bracts not longer than sepals, 1 longer than sepals</p>
</dd>
<dt><code>V36</code></dt><dd><p>0 bracts with sharp tip, 1 bracts with blunt tip</p>
</dd>
<dt><code>V37</code></dt><dd><p>0 bract width &gt;= length, 1 bract length &gt; width</p>
</dd>
<dt><code>V38</code></dt><dd><p>0 bracts pubescent, 1 bracts naked</p>
</dd>
<dt><code>V39</code></dt><dd><p>0 bracts awned, 1 bracts not awned</p>
</dd>
<dt><code>V40</code></dt><dd><p>0 flowers slanted, spike lax, 1 flowers appressed, spike dense</p>
</dd>
<dt><code>V41</code></dt><dd><p>0 outer and inner sepals significantly different, 1 all sepals more or less similar</p>
</dd>
<dt><code>V42</code></dt><dd><p>0 sepals narrow, 1 sepals broad</p>
</dd>
<dt><code>V43</code></dt><dd><p>0 sepals with sharp tip, 1 sepals with blunt tip</p>
</dd>
<dt><code>V44</code></dt><dd><p>0 sepals pubescent, 1 sepals naked</p>
</dd>
<dt><code>V45</code></dt><dd><p>0 outer sepals fused, 1 outer sepals separate</p>
</dd>
<dt><code>V46</code></dt><dd><p>0 corolla tube pubescent, 1 corolla tube naked</p>
</dd>
<dt><code>V47</code></dt><dd><p>0 corolla lobes broad, elliptic or rounded, 1 corolla lobes narrow, oblanceolate or lanceolate</p>
</dd>
<dt><code>V48</code></dt><dd><p>0 corolla lobes with sharp tip, 1 corolla lobes with blunt tip</p>
</dd>
<dt><code>V49</code></dt><dd><p>0 corolla lobes white or silver, 1 corolla lobes yellowish or brownish</p>
</dd>
<dt><code>V50</code></dt><dd><p>0 stamens not exserted, 1 stamens exserted</p>
</dd>
<dt><code>V51</code></dt><dd><p>0 filaments yellowish or brownish, 1 filaments white, pinkish or purplish</p>
</dd>
<dt><code>V52</code></dt><dd><p>0 pollen grains with thickened pore margin, 1 pollen grains without thickened pore margin</p>
</dd>
<dt><code>V53</code></dt><dd><p>0 pollen grains with &gt;= 9 pores, 1 pollen grains with &lt; 9 pores</p>
</dd>
<dt><code>V54</code></dt><dd><p>0 pyxidium ovate or broadly conical, 1 pyxidium narrowly conical or elongated</p>
</dd>
<dt><code>V55</code></dt><dd><p>0 one or two seeds are much smaller than others, 1 all seeds similar</p>
</dd>
<dt><code>V56</code></dt><dd><p>0 seeds =&lt; 2, 1 seeds &gt; 2</p>
</dd>
<dt><code>V57</code></dt><dd><p>0 seeds 3&ndash;5, 1 seeds &gt;= 6</p>
</dd>
<dt><code>V58</code></dt><dd><p>0 seeds flattened, 1 seeds rounded or angled</p>
</dd>
<dt><code>V59</code></dt><dd><p>0 plane which passes through embryo cotyledons is perpendicular to placenta, 1 plane which passes through embryo cotyledons is parallel to placenta</p>
</dd>
<dt><code>V60</code></dt><dd><p>0 polyploids, 1 diploids</p>
</dd>
<dt><code>V61</code></dt><dd><p>0 x=5, 1 x=6</p>
</dd>
</dl>


<h3>Source</h3>

<p>Shipunov A. 1998. Plantains (genera Plantago L. and Psyllium Mill.,
Plantaginaceae) of European Russia and adjacent territories. Ph. D.
Thesis. Moscow State University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(hclust(dist(plantago, method="binary")))
</code></pre>

<hr>
<h2 id='Pleiad'>Correlation circles (correlation pleiads)</h2><span id='topic+Pleiad'></span>

<h3>Description</h3>

<p>Plot correlation circles (correlation pleiads, correlograms)</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pleiad(tbl, abs=FALSE, corr=FALSE, dist=FALSE, treshold=FALSE,
 circ=list(1, 1, 1), breaks=5, auto=TRUE, gr=6, lwd=NULL, lty=NULL,
 lcol=NULL,  abbr=-1, lbltext="internal", lblcex=1, off=1.09, hofft=0.07,
 hoff=1.02, legend=TRUE,  legtext=1, legpos="topright", leghoriz=FALSE,
 show.int=FALSE, dig.lab=1, neg.col=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pleiad_+3A_tbl">tbl</code></td>
<td>
<p>Data: square, numeric, symmetric matrix with same row and column names</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_abs">abs</code></td>
<td>
<p>If TRUE, uses absolute values instead of real</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_corr">corr</code></td>
<td>
<p>If TRUE, uses absolute values instead of real and cuts from 0 to 1, this is good for correlation matrices</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_dist">dist</code></td>
<td>
<p>If TRUE, converts distance matrix to the data frame &ndash; good for &quot;dist&quot; objects</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_treshold">treshold</code></td>
<td>
<p>If this is (saying) =.5, selects for plotting (with lty=1) only those values which are &gt;.5</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_circ">circ</code></td>
<td>
<p>Line type, width and color for the cirle; if first or third =0, no cicrle</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_breaks">breaks</code></td>
<td>
<p>How to cut() values, if &quot;cramer&quot;, then =c(0, .1, .3, .5, 1)</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_auto">auto</code></td>
<td>
<p>If FALSE, specify 'lwd', 'lty' and 'lcol'</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_gr">gr</code></td>
<td>
<p>Grayscale scheme starts from 6 breaks</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_lwd">lwd</code></td>
<td>
<p>If auto=FALSE, specify here the vector concerted with breaks</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_lty">lty</code></td>
<td>
<p>If auto=FALSE, specify here the vector concerted with breaks</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_lcol">lcol</code></td>
<td>
<p>If auto=FALSE, specify here the vector concerted with breaks; if length(lcol) == 1, all lines are of particular color</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_abbr">abbr</code></td>
<td>
<p>If =-1, no abbreviation; if =0, no labels; other values run abbreviate(..., abbr)</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_lbltext">lbltext</code></td>
<td>
<p>If this is a vector starting from something else, will replace dimnames</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_lblcex">lblcex</code></td>
<td>
<p>Magnification of labels</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_off">off</code></td>
<td>
<p>Radial offset of labels, be careful!</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_hofft">hofft</code></td>
<td>
<p>Treshold determining which labels are rigtmost/leftmost, 'hofft=0' put all labels into this group</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_hoff">hoff</code></td>
<td>
<p>Horizontal offset for rightmost/leftmost labels; 'hoff=1' removes offset</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_legend">legend</code></td>
<td>
<p>If FALSE, no legend</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_legtext">legtext</code></td>
<td>
<p>If =1 then &quot;weaker ... stronger&quot;; if =2, shows cutting intervals; if =3, then 1:5; if &gt;3, issues error</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_legpos">legpos</code></td>
<td>
<p>Position of the legend, see help(legend)</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_leghoriz">leghoriz</code></td>
<td>
<p>Make the legend horizontal?</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_show.int">show.int</code></td>
<td>
<p>Show intervals in (...] form</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_dig.lab">dig.lab</code></td>
<td>
<p>dig.lab for cut(), use to change notation</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_neg.col">neg.col</code></td>
<td>
<p>If not NULL and 'abs' or 'corr' are TRUE, colorize negative correlations using specified color</p>
</td></tr>
<tr><td><code id="Pleiad_+3A_...">...</code></td>
<td>
<p>Further arguments to points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Correlation circles (correlation pleiads, correlograms) based on the
works of Petr Terentjev's (Saint-Petersburg) school.
</p>
<p>Please be sure to use 'corr=TRUE' or 'dist=TRUE' when working with
correlation matrices or 'dist' objects, respectively.
</p>
<p>It is probably a good idea to order data entries with hierarchical
clustering to optimize the resulted graph (see examples).
</p>
<p>Note that: (1) 'lty', 'lwd' and 'lcol' are not recycling; (2) plot has no
margins so consider second 'legend()' to add any text to the plot (see
examples); (3) it works best when number of items is relatively low (&lt;
30); (4) it can visualize (colorize) negative correlations (see examples)
but this works bes with default (black) color; (5) 'dist=TRUE' will
convert dissimilarities into similarities by substracting from maximum.
</p>
<p>Alternatives: those graph plotting packages which are able to plot
&quot;correlogram&quot;.
</p>


<h3>Value</h3>

<p>Data frame (invisibly) with position of points, might help in plot
enchancing.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
l.c &lt;- cor(datasets::longley, method="spearman", use="pairwise")
Pleiad(l.c, corr=TRUE, legtext=2, pch=21, cex=2, bg="white", breaks=3,
 gr=3, hoff=1, show.int=TRUE)
legend("topleft", legend="Macroeconomic correlations", text.font=2,
bty="n")

## colorize negative correlations and use hclust() to re-order
reorder &lt;- hclust(dist(t(longley)))$order
Pleiad(l.c[reorder, reorder], corr=TRUE, neg.col="red")

dr.c &lt;- cor(drosera[, -1], method="spearman", use="pairwise")
## simple example with most defaults
Pleiad(dr.c, corr=TRUE)
## complex example with user-specified colors etc.
Pleiad(dr.c, corr=TRUE, legtext=2, pch=19, cex=1.2, hoff=1.06,
 auto=FALSE, lwd=c(1, 1, 1, 2.5, 4), lty=rep(1, 5),
 lcol=colorRampPalette(c("grey", "#D8284F"))(5),
 circ=c(2, 1, 1))

## visualize distances
Pleiad(dist(t(atmospheres)), dist=TRUE, breaks=3, legtext=2, dig.lab=3)

</code></pre>

<hr>
<h2 id='Plot.phylocl'>Plot phylogenetic tree with clades collapsed</h2><span id='topic+Plot.phylocl'></span>

<h3>Description</h3>

<p>Plot phylogenetic tree with clades collapsed into triangles or rectangles</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.phylocl(tree, cl, strict=TRUE, keep.mono=FALSE, what="triangles",
 col.ed="black", col.td="black", col.etr="transparent", col.ttr="transparent",
 col.pfl="lightgrey", col.pbr="black", lty.p=1, lwd.p=1, col.ct="black",
 ct.off=0, ct.fnt=1, cex=par("cex"), longer="0%", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot.phylocl_+3A_tree">tree</code></td>
<td>
<p>phylo object</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_cl">cl</code></td>
<td>
<p>two columns classification table</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_strict">strict</code></td>
<td>
<p>default TRUE: do not join all descendants</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_keep.mono">keep.mono</code></td>
<td>
<p>default FALSE: do not keep monotypic clades</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_what">what</code></td>
<td>
<p>default &quot;triangles&quot;, also possible to use &quot;rectangles&quot;</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.ed">col.ed</code></td>
<td>
<p>default &quot;black&quot;, default edge color</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.td">col.td</code></td>
<td>
<p>default black&quot;, default tips color</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.etr">col.etr</code></td>
<td>
<p>default &quot;transparent&quot;, color to suppress original edges</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.ttr">col.ttr</code></td>
<td>
<p>default &quot;transparent&quot;, color to suppress original tips</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.pfl">col.pfl</code></td>
<td>
<p>default &quot;lightgrey&quot;, fill color for polygons</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.pbr">col.pbr</code></td>
<td>
<p>default &quot;black&quot;, border color of polygons</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_lty.p">lty.p</code></td>
<td>
<p>default 1, line type of polygon borders</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_lwd.p">lwd.p</code></td>
<td>
<p>default 1, line width</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_col.ct">col.ct</code></td>
<td>
<p>default &quot;black&quot;, color of clade labels</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_ct.off">ct.off</code></td>
<td>
<p>default 0, text offset of clade labels</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_ct.fnt">ct.fnt</code></td>
<td>
<p>default 1, text font of clade labels</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_cex">cex</code></td>
<td>
<p>default par(&quot;cex&quot;), text font size of all labels</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_longer">longer</code></td>
<td>
<p>default &quot;0%&quot;, percent to increase xlim to fit longer clade labels</p>
</td></tr>
<tr><td><code id="Plot.phylocl_+3A_...">...</code></td>
<td>
<p>options to ape::plot.phylo()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot.phylocl() plots phylogenetic tree with clades collapsed into
triangles or rectangles.
</p>
<p>Alternative is phytools::plot.backbonePhylo() which however requires more
manual work.
</p>
<p>Some tricks used (null plotting and transparent elements), the last one
is actually useful in other ways.
</p>
<p>Intersections and other deviated cases not controlled. However, they are
really easy to spot.
</p>
<p>All parameters of polygons should be either &quot;scalars&quot; or vectors of the
same length as clade list (minus monotypic clades), clades are in
alphabetical order. To help, list of clade names is invisibly returned in
the end.
</p>
<p>If keep.mono=TRUE, then monotypic clades must have names in the clade
list, otherwise this option is useless.
</p>


<h3>Value</h3>

<p>Returns list of clade names.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p>phytools::plot.backbonePhylo()</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa.d &lt;- hclust(dist(t(atmospheres)))
tree &lt;- ape::unroot(ape::as.phylo(aa.d))

cl &lt;- data.frame(
planet=c(
 "Mercury",
 "Venus",
 "Earth",
 "Mars",
 "Jupiter",
 "Saturn",
 "Uranus",
 "Neptune"),
clade=c(
 "Mercury",
 "Mars group",
 "Earth",
 "Mars group",
 "Close giants",
 "Close giants",
 "Distant giants",
 "Distant giants"),
stringsAsFactors=FALSE)

Plot.phylocl(tree, cl, longer="5%", ct.off=0.1)
</code></pre>

<hr>
<h2 id='PlotBest.dist'>Dotchart which reflects the &quot;best&quot; base distance method</h2><span id='topic+PlotBest.dist'></span>

<h3>Description</h3>

<p>Plots dotchart with shows correspondences between data and various base distances</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PlotBest.dist(data, distances=c("euclidean", "maximum", "manhattan",
"canberra", "binary", "minkowski"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotBest.dist_+3A_data">data</code></td>
<td>
<p>Data frame with values</p>
</td></tr>
<tr><td><code id="PlotBest.dist_+3A_distances">distances</code></td>
<td>
<p>Distances to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the &quot;best&quot; distance method. Please note that this is a mere
visualization, and numbers are used only to understand the relative
correspondence between raw data and distances.
</p>
<p>Uses maximal correlations between multidimensional scaling of distance
object (converted internally to Euclidean) and PCA of data. Both MDS and
PCA use two dimensions.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PlotBest.dist(iris[, -5])

PlotBest.dist(t(moldino))

</code></pre>

<hr>
<h2 id='PlotBest.hclust'>Plots dotchart with best clustering method</h2><span id='topic+PlotBest.hclust'></span>

<h3>Description</h3>

<p>Plots dotchart with best clustering method</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PlotBest.hclust(dist, clust=c("ward.D", "ward.D2", "single", "complete",
"average", "mcquitty", "median", "centroid"), plot=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotBest.hclust_+3A_dist">dist</code></td>
<td>
<p>Distance matrix</p>
</td></tr>
<tr><td><code id="PlotBest.hclust_+3A_clust">clust</code></td>
<td>
<p>Clustering method</p>
</td></tr>
<tr><td><code id="PlotBest.hclust_+3A_plot">plot</code></td>
<td>
<p>Plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the &quot;best&quot; hierarchical clustering method. Uses cophenetic
correlation.
</p>


<h3>Value</h3>

<p>Numeric vector with correlation values (equal to the number of
clusterings involved)
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PlotBest.hclust(dist(iris[, -5]))

PlotBest.hclust(dist(t(moldino)))

</code></pre>

<hr>
<h2 id='PlotBest.mdist'>Dotchart which reflects the &quot;best&quot; of non-base distances</h2><span id='topic+PlotBest.mdist'></span>

<h3>Description</h3>

<p>Plots dotchart which shows correspondences between data and various non-base distances</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PlotBest.mdist(data, distances=c("manhattan", "euclidean", "canberra",
"clark",  "bray", "kulczynski", "jaccard", "gower", "altGower",
"morisita", "horn", "binomial",  "chao", "cao", "mahalanobis",
"cor.pearson", "cor.spearman", "cor.kendall",  "gower_dist",
"simple_match_dist", "daisy.gower", "smirnov"),
binary.only=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotBest.mdist_+3A_data">data</code></td>
<td>
<p>Data frame with values</p>
</td></tr>
<tr><td><code id="PlotBest.mdist_+3A_distances">distances</code></td>
<td>
<p>Distances to use</p>
</td></tr>
<tr><td><code id="PlotBest.mdist_+3A_binary.only">binary.only</code></td>
<td>
<p>Use binary only distances?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the &quot;best&quot; distance method using many non-base distances from
several packages (namely, &quot;cluster&quot;, &quot;smirnov&quot; and &quot;vegan&quot; &ndash; but does
not include &quot;mountford&quot; and &quot;raup&quot; as they are very special). Please note
that this is a mere visualization, and numbers are used only to
understand the relative correspondence between raw data and distances.
</p>
<p>Uses maximal correlations between multidimensional scaling of distance
object (converted internally to Euclidean) and PCA of data. Both MDS and
PCA use two dimensions.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotBest.dist">PlotBest.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
PlotBest.mdist(iris[, -5])

m1 &lt;- t((moldino &gt; 0) * 1)
PlotBest.mdist(m1, binary.only=TRUE)

</code></pre>

<hr>
<h2 id='Ploth'>Changes the appearance of cluster dendrogram</h2><span id='topic+Ploth'></span>

<h3>Description</h3>

<p>Modifies several aspects of the cluster dendrogram</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  Ploth(hclust, labels=hclust[["labels"]], lab.font=1, lab.col=1, col=1,
   pch.cex=1, pch=NA, bg=0, col.edges=FALSE, hang=-1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ploth_+3A_hclust">hclust</code></td>
<td>
<p>Hclust object</p>
</td></tr>
<tr><td><code id="Ploth_+3A_labels">labels</code></td>
<td>
<p>Labels</p>
</td></tr>
<tr><td><code id="Ploth_+3A_lab.font">lab.font</code></td>
<td>
<p>Label font</p>
</td></tr>
<tr><td><code id="Ploth_+3A_lab.col">lab.col</code></td>
<td>
<p>Label colors</p>
</td></tr>
<tr><td><code id="Ploth_+3A_col">col</code></td>
<td>
<p>Colors of edges and points</p>
</td></tr>
<tr><td><code id="Ploth_+3A_pch.cex">pch.cex</code></td>
<td>
<p>Scale of points</p>
</td></tr>
<tr><td><code id="Ploth_+3A_pch">pch</code></td>
<td>
<p>Point types</p>
</td></tr>
<tr><td><code id="Ploth_+3A_bg">bg</code></td>
<td>
<p>Points backgrounds</p>
</td></tr>
<tr><td><code id="Ploth_+3A_col.edges">col.edges</code></td>
<td>
<p>Colorize edges?</p>
</td></tr>
<tr><td><code id="Ploth_+3A_hang">hang</code></td>
<td>
<p>Makes leaves hang, see plot.hclust(); -1 is default here
whereas 0.1 is default for 'hclust'</p>
</td></tr>
<tr><td><code id="Ploth_+3A_...">...</code></td>
<td>
<p>Further arguments to plot.dendrogram()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Changes the appearance of cluster dendrogram. If labels are long, you
might need to modify the plot margins.
</p>
<p>Please take into account that supplied labels are meant to be in their
_initial_ order, not in order of their appearance on the dendrogram.
</p>
<p>Ploth() does not change the text size of labels, please use Tctext()
and Tcoords() for this (and other) purposes.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tcoords">Tcoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.dist &lt;- dist(iris[, 1:4], method="manhattan")
iris.hclust &lt;- hclust(iris.dist)
Ploth(iris.hclust, col=as.numeric(iris[, 5]), pch=16, col.edges=TRUE, horiz=TRUE,
 leaflab="none")
legend("topleft", fill=1:nlevels(iris[, 5]), legend=levels(iris[, 5]))

Ploth(hclust(UScitiesD, "ward.D2"), labels=abbreviate(attr(UScitiesD, "Labels")),
 lab.col=c(1, rep(2, 9)), lab.font=c(2, rep(1, 9)), hang=0.1)

</code></pre>

<hr>
<h2 id='Points'>Number of cases in each location reflected in the point size</h2><span id='topic+Points'></span><span id='topic+PPoints'></span>

<h3>Description</h3>

<p>Number of cases in each location reflected in the point size</p>


<h3>Usage</h3>

<pre><code class='language-R'>Points(x, y, pch=1, centers=FALSE, scale=1, cex.min=1, col=1,
 na.omit=TRUE, plot=TRUE, ...)
PPoints(groups, x, y, cols=as.numeric(groups), pchs=as.numeric(groups),
 na.omit.all=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Points_+3A_x">x</code>, <code id="Points_+3A_y">y</code></td>
<td>
<p>Coordinates</p>
</td></tr>
<tr><td><code id="Points_+3A_pch">pch</code></td>
<td>
<p>Point type</p>
</td></tr>
<tr><td><code id="Points_+3A_pchs">pchs</code></td>
<td>
<p>Types of point groups</p>
</td></tr>
<tr><td><code id="Points_+3A_centers">centers</code></td>
<td>
<p>If TRUE, show centers of each location as a pixel-size dot (pch=&quot;.&quot;)</p>
</td></tr>
<tr><td><code id="Points_+3A_cex.min">cex.min</code></td>
<td>
<p>Minimal point size</p>
</td></tr>
<tr><td><code id="Points_+3A_col">col</code></td>
<td>
<p>Color of points</p>
</td></tr>
<tr><td><code id="Points_+3A_cols">cols</code></td>
<td>
<p>Color of point groups</p>
</td></tr>
<tr><td><code id="Points_+3A_na.omit">na.omit</code></td>
<td>
<p>If TRUE (default), skip data points with NAs</p>
</td></tr>
<tr><td><code id="Points_+3A_plot">plot</code></td>
<td>
<p>If FALSE, does not plot</p>
</td></tr>
<tr><td><code id="Points_+3A_na.omit.all">na.omit.all</code></td>
<td>
<p>If TRUE (default), skip data points and corresponding factor
values with NAs, then make 'na.omit' for internal Points() FALSE</p>
</td></tr>
<tr><td><code id="Points_+3A_scale">scale</code></td>
<td>
<p>Scale factor for point size</p>
</td></tr>
<tr><td><code id="Points_+3A_groups">groups</code></td>
<td>
<p>Factor defining groups</p>
</td></tr>
<tr><td><code id="Points_+3A_...">...</code></td>
<td>
<p>Points() passes other arguments to points(), PPoints() passes other arguments to Points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frequently, more then one data point is located in one coordinate place (so called
&quot;overplotting&quot;). How to show overplotting? One way is 'jitter()', these is also
(really advanced) 'sunflowerplot()'. 'Points()' does it in its own way: number of
cases in each point will be reflected in the point size. 'Points()' is a low-level
graphic function, analogous to 'points()'.
</p>
<p>'PPoints()' is the same as 'Points()' but for multiple subgroups.
</p>
<p>To prettify plot, it is recommended to change 'scale' and optionally also 'cex.min'.
</p>
<p>Alternative is the base R 'sunflowerplot()' but it is hard to read and there is no possibility
to show multiple groups in data. Another alternative might be points with transparent color.
</p>


<h3>Value</h3>

<p>Invisibly returns vector of &quot;multiplication indexes&quot;, in case of PPoints() it is group-wise
so overplotting between groups does not count. Please keep in mind that these
indexes only indicate how many times the point is overplotted, but do not show groups of duplicates.
Use Alldups() for groups.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+jitter">jitter</a></code>, <code><a href="graphics.html#topic+sunflowerplot">sunflowerplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## colors modified via palette()
plot(iris[, 1:2], type="n")
palette(rainbow(3))
PPoints(iris[, 5], iris[, 1], iris[, 2], pchs=0, scale=0.7)
palette("default")
## now with centers, colors default, pch by group, and one NA
iris[1, 1] &lt;- NA
plot(iris[, 1:2], type="n")
PPoints(iris[, 5], iris[, 1], iris[, 2], scale=0.7, centers=TRUE)
data(iris) ## to restore default embedded object
</code></pre>

<hr>
<h2 id='Polyarea'>Area of the polygon</h2><span id='topic+Polyarea'></span>

<h3>Description</h3>

<p>Calculates area of polygon</p>


<h3>Usage</h3>

<pre><code class='language-R'>Polyarea(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Polyarea_+3A_x">x</code></td>
<td>
<p>Polygon vertices: two-column numerical matrix or data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on vegan::summary.ordihulls().
</p>


<h3>Value</h3>

<p>Numerical vector of length 1.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Squares">Squares</a></code>, <code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Ellipses">Ellipses</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1:9, 8:1) # from ?polygon
y &lt;- c(1, 2*(5:3), 2, -1, 17, 9, 8, 2:9)
Polyarea(cbind(x, y)) # numerical matrix
Polyarea(data.frame(x, y)) # numerical data frame

</code></pre>

<hr>
<h2 id='Polycenter'>Center of the polygon</h2><span id='topic+Polycenter'></span>

<h3>Description</h3>

<p>Finds polygon center</p>


<h3>Usage</h3>

<pre><code class='language-R'>Polycenter(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Polycenter_+3A_x">x</code></td>
<td>
<p>Polygon vertices: two-column numerical matrix or data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on vegan::summary.ordihulls().
</p>


<h3>Value</h3>

<p>Named numerical vector of length 2 (x and y coordinates of the center).
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Squares">Squares</a></code>, <code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Ellipses">Ellipses</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1:9, 8:1) # from ?polygon
y &lt;- c(1, 2*(5:3), 2, -1, 17, 9, 8, 2:9)
Polycenter(cbind(x, y)) # numerical matrix
Polycenter(data.frame(x, y)) # numerical data frame

iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
iris.h &lt;- Hulls(iris.p, iris$Species, plot=FALSE)
sapply(iris.h, Polycenter)

</code></pre>

<hr>
<h2 id='Pull'>Select rows from data frame</h2><span id='topic+Pull'></span>

<h3>Description</h3>

<p>Selects rows from data frame basing on the evaluation of the second argument</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pull(df, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pull_+3A_df">df</code></td>
<td>
<p>Data frame to select from</p>
</td></tr>
<tr><td><code id="Pull_+3A_...">...</code></td>
<td>
<p>Arguments to with(df, ...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the first argument is not a data frame, function will stop with an error.
</p>
<p>Pull() is similar to subset() (but is much simpler and allows non-logical
values) and to dplyr::filter() function.
</p>
<p>Please avoid using Pull() in non-ineractive mode.
</p>


<h3>Value</h3>

<p>Data frame</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>`[`(trees, 3, 1) # ... so square bracket is a command
## arguments of `[` are independent; this is why square bracket does not "catch" the context:
trees[trees$Girth &lt; 11 &amp; trees$Height == 65, ] # boring and long
trees[trees$Girth &lt; 11 &amp; sample(0:1, nrow(trees), replace=TRUE), ] # yes, boring, long but flexible
trees[with(trees, Girth &lt; 11 &amp; Height == 65), ] # less boring but still long
## it would be nice to avoid typing "trees" twice:
Pull(trees, Girth &lt; 11 &amp; Height == 65) # shorter
Pull(trees, Girth &lt; 11 &amp; sample(0:1, nrow(trees), replace=TRUE)) # flexibility is still here
Pull(trees, Girth &lt; 11 &amp; sample(0:1, nrow(trees),
 replace=TRUE))$Height # if you want also select columns
Pull(trees, grep(81, Height)) # select not only by TRUE/FALSE but also by row index
</code></pre>

<hr>
<h2 id='R.logo'>Imitation (!) of the modern 'R' logo</h2><span id='topic+R.logo'></span>

<h3>Description</h3>

<p>Imitation (!) of the modern 'R' logo</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.logo(x, y, col.e="#B8BABF", col.l="#1E63B5", cex=12)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R.logo_+3A_x">x</code></td>
<td>
<p>x coordinate of the letter</p>
</td></tr>
<tr><td><code id="R.logo_+3A_y">y</code></td>
<td>
<p>y coordinate of the letter</p>
</td></tr>
<tr><td><code id="R.logo_+3A_col.e">col.e</code></td>
<td>
<p>ellipse color</p>
</td></tr>
<tr><td><code id="R.logo_+3A_col.l">col.l</code></td>
<td>
<p>letter color</p>
</td></tr>
<tr><td><code id="R.logo_+3A_cex">cex</code></td>
<td>
<p>scale, default 12</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imitation (sic!) of the modern (flat) 'R' logo. Font and proportions are not exactly the same, also there is no gradient.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ell">Ell</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(1, type="n", axes=FALSE, xlab="", ylab="")
R.logo(1.1, 0.9, cex=25)
##
plot(1:20, type="n")
for (i in 1:20) R.logo(i, i, cex=2)
</code></pre>

<hr>
<h2 id='Read.fasta'>Read 'FASTA' files</h2><span id='topic+Read.fasta'></span>

<h3>Description</h3>

<p>Simple reading of 'FASTA' files</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read.fasta(file)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read.fasta_+3A_file">file</code></td>
<td>
<p>File name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple reading of 'FASTA' files.</p>


<h3>Value</h3>

<p>Data frame with two columns: 'name' and 'sequence'.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>write(file=file.path(tempdir(), "tmp.fasta"), "&gt;some_id\nATGC")
Read.fasta(file=file.path(tempdir(), "tmp.fasta"))
</code></pre>

<hr>
<h2 id='Read.tri.nts'>Read 'NTSYSpc' files</h2><span id='topic+Read.tri.nts'></span>

<h3>Description</h3>

<p>Read a lower triangular matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read.tri.nts(file, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read.tri.nts_+3A_file">file</code></td>
<td>
<p>File to read</p>
</td></tr>
<tr><td><code id="Read.tri.nts_+3A_...">...</code></td>
<td>
<p>Arguments to 'scan()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads a lower triangular matrix which at least in my practice, typically come from 'NTSYSpc' program.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>write(file=file.path(tempdir(), "tmp.nts"), x=c(
'" Procrustes distances between all pairs:
2 12 12 0
0.000E+000 
4.058E-002 0.000E+000 
5.753E-002 6.489E-002 0.000E+000 
6.445E-002 8.124E-002 9.509E-002 0.000E+000 
2.610E-001 2.395E-001 2.317E-001 3.051E-001 0.000E+000 
2.719E-001 2.508E-001 2.461E-001 3.132E-001 4.531E-002 0.000E+000 
2.563E-001 2.357E-001 2.278E-001 3.008E-001 4.414E-002 6.510E-002 0.000E+000 
8.003E-002 6.611E-002 7.738E-002 9.885E-002 2.206E-001 2.270E-001 2.161E-001 
0.000E+000 
6.838E-002 8.893E-002 6.691E-002 1.018E-001 2.585E-001 2.704E-001 2.497E-001 
1.019E-001 0.000E+000 
6.233E-002 6.756E-002 4.079E-002 8.329E-002 2.396E-001 2.507E-001 2.338E-001 
5.519E-002 5.932E-002 0.000E+000 
2.504E-001 2.313E-001 2.230E-001 2.967E-001 8.714E-002 1.080E-001 6.522E-002 
2.205E-001 2.323E-001 2.281E-001 0.000E+000 
2.590E-001 2.688E-001 2.424E-001 2.757E-001 3.698E-001 3.926E-001 3.689E-001 
3.051E-001 2.280E-001 2.603E-001 3.312E-001 0.000E+000 '
))

## interactive
file.show(file=file.path(tempdir(), "tmp.nts"))

Read.tri.nts(file=file.path(tempdir(), "tmp.nts"), skip=2)
</code></pre>

<hr>
<h2 id='Recode'>Basic multiple recoding</h2><span id='topic+Recode'></span><span id='topic+Recode4'></span><span id='topic+RecodeR'></span><span id='topic+Recode4R'></span>

<h3>Description</h3>

<p>Basic multiple recoding (similar to the 'SQL' left join)</p>


<h3>Usage</h3>

<pre><code class='language-R'>Recode(var, from, to, char=TRUE, recycle=FALSE)
Recode4(var, from, to, missed="", ...)
RecodeR(var, from, to, char=TRUE, recycle=FALSE)
Recode4R(var, from, to, missed="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Recode_+3A_var">var</code></td>
<td>
<p>Variable to recode</p>
</td></tr>
<tr><td><code id="Recode_+3A_from">from</code></td>
<td>
<p>'from' column of the recoding &quot;table&quot;</p>
</td></tr>
<tr><td><code id="Recode_+3A_to">to</code></td>
<td>
<p>'to' column</p>
</td></tr>
<tr><td><code id="Recode_+3A_char">char</code></td>
<td>
<p>If TRUE (default), do not treat 'to' character vectors as factors</p>
</td></tr>
<tr><td><code id="Recode_+3A_recycle">recycle</code></td>
<td>
<p>If TRUE (not default), recycle 'to' along 'from'</p>
</td></tr>
<tr><td><code id="Recode_+3A_missed">missed</code></td>
<td>
<p>Replace missed (not recoded) with something, default is &quot;&quot; (empty charactrer string)</p>
</td></tr>
<tr><td><code id="Recode_+3A_...">...</code></td>
<td>
<p>Further options to Recode() and RecodeR()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic multiple recoding is similar to 'SQL' left join.
</p>
<p>Inspired from Paul Johnston (Univ. of Kansas) recode() function.
</p>
<p>Alternatives are car::recode(), lessR::Recode(), admisc::recode() and 'mgsub' package.
First three are much more complicated, last is much slower and less flexible.
</p>
<p>To understand the idea better, please look on the examples.
</p>
<p>There are four functions:
</p>
<p>1. Recode() &ndash; base function. If starting points (&quot;from&quot;) are the same,
only the <em>last</em> rule (&quot;from-to&quot; pair) has an effect.
If rules are chained, they still work independently (i.e., chaining has no effect).
</p>
<p>2. Recode4() &ndash; considers not recoded (missing). By default, this will replace non-Recode()'d 
entries with empty string (&quot;&quot;).
</p>
<p>3. RecodeR() &ndash; running recode. If starting points (&quot;from&quot;) are the same,
only the <em>first</em> rule (&quot;from-to&quot; pair) has an effect.
Chaining is possible.
</p>
<p>4. Recode4R() &ndash; running plus considers missing. By default, this will replace non-RecodeR()'ed 
entries with empty string (&quot;&quot;).
</p>


<h3>Value</h3>

<p>Recoded vector (note that mode will not necessarily be the same, e.g., when recoding numbers with characters).</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## recoding a phrase
phrase &lt;- "The quick brown fox jumps over 123 lazy dogs"
var &lt;- unlist(strsplit(phrase, split=""))
from &lt;- letters[1:20]
to &lt;- rev(from)
Recode.result &lt;- paste(Recode(var, from, to), collapse="")
Recode4.result &lt;- paste(Recode4(var, from, to, missed="-"), collapse="")
RecodeR.result &lt;- paste(RecodeR(var, from, to), collapse="")
Recode4R.result &lt;- paste(Recode4R(var, from, to, missed="-"), collapse="")
from.rule &lt;- paste(from, collapse=" ")
to.rule &lt;- paste(to, collapse=" ")
rbind(from.rule, to.rule, phrase, Recode.result, Recode4.result, RecodeR.result, Recode4R.result)

## reverse complement of DNA sequence
dna &lt;- "GAATTC" # EcoR1 palindromic sequence
paste(Recode(rev(strsplit(dna, NULL)[[1]]),
 c("A", "T", "G", "C"), c("T", "A", "C", "G")), collapse="") # = 'dna', as expected
dna &lt;- "ATTCGGC" # something random
paste(Recode(rev(strsplit(dna, NULL)[[1]]),
 c("A", "T", "G", "C"), c("T", "A", "C", "G")), collapse="")

## Recode4() when value recoded to itself
Recode4(1:5, 1:4, c(2, 1, 3, 3), NA)
Recode4(1:5, 1:4, c(2, 1, 3, 3))

## this is how "char" option works
Recode(1, 1, factor(2), char=FALSE)
Recode(1, 1, factor(2))

## this is how "recycle" option works
Recode(1:3, 1:3, 4)
Recode(1:3, 1:3, 4, recycle=TRUE)

</code></pre>

<hr>
<h2 id='Root1'>Roots phylogenetic trees even if outgroup is not monophyletic</h2><span id='topic+Root1'></span>

<h3>Description</h3>

<p><code>Root1</code> non-interactively reroots a phylogenetic tree with respect
to the specified outgroup even if it is not monophyletic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Root1(phy, outgroup, select=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Root1_+3A_phy">phy</code></td>
<td>
<p>An object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="Root1_+3A_outgroup">outgroup</code></td>
<td>
<p>A vector of mode numeric or character specifying the
new outgroup.</p>
</td></tr>
<tr><td><code id="Root1_+3A_select">select</code></td>
<td>
<p>Which element of outgroup to select if it is not monophyletic.</p>
</td></tr>
<tr><td><code id="Root1_+3A_...">...</code></td>
<td>
<p>Arguments passed to ape::root().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper of ape::root() to use in non-interactive mode.
If specified outgroup is not monophyletic, instead of error, it issues
error _message_, and chooses the 'select' element as a new outgroup.
</p>


<h3>Value</h3>

<p>An object of class <code>"phylo"</code>
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p>ape::<code><a href="ape.html#topic+root">root</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.orders, package="ape")
ape::root(bird.orders, 1:2)
## ape::root(bird.orders, 1:3) # gives error
Root1(bird.orders, 1:3) # only outputs error _message_
Root1(bird.orders, 1, resolve.root=TRUE)
</code></pre>

<hr>
<h2 id='Rostova.tbl'>Calculates multiple correlation matrices (via 'factor1') and stacks them together</h2><span id='topic+Rostova.tbl'></span>

<h3>Description</h3>

<p>Calculates multiple correlation matrices (via 'factor1') and stacks them together</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Rostova.tbl(X, GROUP, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rostova.tbl_+3A_x">X</code></td>
<td>
<p>Data frame or matrix with values</p>
</td></tr>
<tr><td><code id="Rostova.tbl_+3A_group">GROUP</code></td>
<td>
<p>Number of grouping variable</p>
</td></tr>
<tr><td><code id="Rostova.tbl_+3A_...">...</code></td>
<td>
<p>Arguments to 'Cor.vec()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates multiple correlation matrices (via GROUP) and stacks them
together.
</p>
<p>Output is suitable for PCA, distance calculations and other multivariate
methods (Rostova, 1999; Rostova, 2002).
</p>


<h3>Value</h3>

<p>Data frame with correlation structure</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Rostova N.S. 1999. The variability of correlations systems between the
morphological characters. Part 1. Natural populations of Leucanthemum
vulgare (Asteraceae). Botanicheskij Zhurnal. 84(11): 50&ndash;66.
</p>
<p>Rostova N.S. 2002. Correlations: Structure and Variability. Saint
Petersburg, St. Petersburg University Publisher.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cor.vec">Cor.vec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
Trees &lt;- trees
Trees[, 4] &lt;- sample(letters[1:3], nrow(Trees), replace=TRUE)
(rr &lt;- Rostova.tbl(Trees, 4))
plot(hclust(dist(rr)))

</code></pre>

<hr>
<h2 id='Rpart2newick'>Converts 'rpart' object into Newick tree</h2><span id='topic+Rpart2newick'></span>

<h3>Description</h3>

<p>Converts 'rpart' object into Newick tree</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rpart2newick(rpart.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rpart2newick_+3A_rpart.object">rpart.object</code></td>
<td>
<p>'rpart' object, output of rpart::rpart()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by 'shaunpwilkinson/rpart2dendro.R' gist.
</p>


<h3>Value</h3>

<p>Newick tree (text string).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rpart)
(fit &lt;- rpart(Kyphosis ~ Age + Number + Start, data=kyphosis))
plot(fit); text(fit, all=TRUE, xpd=TRUE)
library(ape)
tree1 &lt;- read.tree(text=Rpart2newick(fit))
plot(tree1)
nodelabels(tree1$node.label, frame="none", bg="transparent", adj=-0.1)

(fit2 &lt;- rpart(Species ~ ., data=iris))
plot(fit2); text(fit2, all=TRUE, xpd=TRUE)
tree2 &lt;- read.tree(text=Rpart2newick(fit2))
plot(tree2)
nodelabels(tree2$node.label, frame="none", bg="transparent", adj=-0.1)
</code></pre>

<hr>
<h2 id='Rresults'>Rresults shell script</h2><span id='topic+Rresults'></span>

<h3>Description</h3>

<p>Rresults shell script</p>


<h3>Details</h3>

<p>'Rresults' is a bash shell script which allows to gather all R input and
R textual output into one text file, and (unnamed) R graphical output
into another (PDF) file (only if the 'pdftk' utility is installed). If
graphical output has name(s), it will be saved in its own file(s).
</p>
<p>Very useful for the debugging and other non-interactive activities with R
scripts as everything is in one place.
</p>
<p>The script has one option &quot;-d&quot; which adds the timestamp to the file name
of text results. This option also switches R to add sessionInfo() to the
end of output.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## works only if the script is properly installed
cat("\"Hello, world!\"\n", "plot(1:20)\n", file="hello.r")
system("Rresults hello.r")
system("Rresults -d hello.r")
## interactive command
file.show("hello_rresults.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='Rro.test'>Robust rank order test</h2><span id='topic+Rro.test'></span>

<h3>Description</h3>

<p>Robust rank order test</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rro.test(x1, y1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rro.test_+3A_x1">x1</code></td>
<td>
<p>Fist numerical variable</p>
</td></tr>
<tr><td><code id="Rro.test_+3A_y1">y1</code></td>
<td>
<p>Second numerical variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Robust rank order test (modification of Wilcoxon test for samples with
contrasting variation), a variant of Fligner-Policello test.
</p>
<p>Alternatives: robustrank::mod.wmw.test() (probably more sophisticated);
npsm::fp.test(); NSM3::pFligPoli() (very advanced, with possibilities of
exact and Monte Carlo testing); RVAideMemoire::fp.test() (developed in
the way similar to most base R tests, probably the best alternative).
</p>


<h3>Value</h3>

<p>Returns z statistic and p-value.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data from help(wilcox.test)
x &lt;- c(0.80, 0.83, 1.89, 1.04, 1.45, 1.38, 1.91, 1.64, 0.73, 1.46)
y &lt;- c(1.15, 0.88, 0.90, 0.74, 1.21)
Rro.test(x, y)
</code></pre>

<hr>
<h2 id='S.value'>S-value</h2><span id='topic+S.value'></span>

<h3>Description</h3>

<p><code>S.value</code> returns S-values, Shannon information transforms of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.value(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S.value_+3A_x">x</code></td>
<td>
<p>Either numerical vector of p-values, or list where at least one element has the name similar to &quot;p.value&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Greenland (2019) proposes that researchers &quot;think of p-values as measuring the _compatibility_ between
hypotheses and datas.&quot; S-values should help to understand this concept better.
</p>
<p>From Wasserstein et al. (2019): S-values supplement a focal p-value p with its Shannon information transform
(s-value or surprisal) s = -log2(p). This measures the amount of information supplied by the test against the tested
hypothesis (or model): rounded off, the s-value shows the number of heads in a row one would need to see when tossing
a coin to get the same amount of information against the tosses being &ldquo;fair&rdquo; (independent with &ldquo;heads&rdquo; probability
of 1/2) instead of being loaded for heads. For example, if p = 0.03, this represents -log2(0.03) = 5 bits of information
against the hypothesis (like getting 5 heads in a trial of &ldquo;fairness&rdquo; with 5 coin tosses); and if p = 0.25, this
represents only -log2(0.25) = 2 bits of information against the hypothesis (like getting 2 heads in a trial of
&ldquo;fairness&rdquo; with only 2 coin tosses).
</p>
<p>For the convenience, S.value() works directly with output of many statistical tests (see examples). If the output is a list
which has more than one component with name similar to &quot;pvalue&quot;, only first will be used.
</p>


<h3>Value</h3>

<p>Numerical vector.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>References</h3>

<p>Wasserstein R.L., Schirm A.L., Lazar N.A. 2019. Moving to a World Beyond &ldquo;p &lt; 0.05&rdquo;.
The American Statistician. 73(S1): 1&ndash;19.
</p>
<p>Greenland S. 2019. Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values
and Their Resolution With S-Values. The American Statistician. 73(S1): 106&ndash;114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S.value(0.05)

S.value(0.01)
S.value(0.1)
S.value(0.00000000001)

S.value(t.test(extra ~ group, data = sleep))
S.value(list(pvalues=c(0.01, 0.002)))
</code></pre>

<hr>
<h2 id='salix_leaves'>salix_leaves</h2><span id='topic+salix_leaves'></span><span id='topic+salix_plants'></span><span id='topic+salix_pop'></span>

<h3>Description</h3>

<p>Morphometry on willows (Salix).
</p>
<p>Three files (datasets):
'salix_pop' localities,
'salix_plants' measures on whole plants,
'salix_leaves' measures on leaves from from these plants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salix_leaves
</code></pre>


<h3>Format</h3>

<p>These data frames contain the following columns:
</p>

<dl>
<dt><code>POP</code></dt><dd><p>Location ID</p>
</dd>
<dt><code>WHERE</code></dt><dd><p>Geography</p>
</dd>
<dt><code>SPECIES</code></dt><dd><p>Species</p>
</dd>
<dt><code>PLN</code></dt><dd><p>Plant ID</p>
</dd>
<dt><code>HEIGHT</code></dt><dd><p>Height, m</p>
</dd>
<dt><code>SEX</code></dt><dd><p>Plant sex (willows are dioeciuos)</p>
</dd>
<dt><code>PID</code></dt><dd><p>Shoot ID</p>
</dd>
<dt><code>N.CIRCLES</code></dt><dd><p>Number of circles of the imaginary spiral between two leaves (below)</p>
</dd>
<dt><code>N.LEAVES</code></dt><dd><p>Number of leaves between the chosen one and the next in the same position</p>
</dd>
<dt><code>INTERNODE</code></dt><dd><p>Internode length, average, mm</p>
</dd>
<dt><code>DIAM</code></dt><dd><p>Stem diameter in the middle of shoot, mm</p>
</dd>
<dt><code>NL</code></dt><dd><p>Leaf ID</p>
</dd>
<dt><code>LL</code></dt><dd><p>Maximal length of the leaf, mm (along midvein from blade basement to blade top)</p>
</dd>
<dt><code>LW</code></dt><dd><p>Maximal width of the leaf, mm</p>
</dd>
<dt><code>PW</code></dt><dd><p>Position of maximal width, mm (along midvein)</p>
</dd>
<dt><code>PTL</code></dt><dd><p>Length of the petiole, mm (from the place of attachment to blade base)</p>
</dd>
<dt><code>STPL</code></dt><dd><p>Stipules present?</p>
</dd>
<dt><code>SL</code></dt><dd><p>Maximal width of maximal stipule, mm (0 if no stipule present)</p>
</dd>
<dt><code>SW</code></dt><dd><p>Maximal width of maximal stipule, mm (0 if no stipule present)</p>
</dd>
<dt><code>TL</code></dt><dd><p>Length of maximal marginal tooth, mm (0 in no teeth)</p>
</dd>
<dt><code>ADC</code></dt><dd><p>Color of the adaxial (upper) leaf surface: 1  glaucous, 2 other shades of green</p>
</dd>
<dt><code>ABC</code></dt><dd><p>Color of the abaxial (lower) leaf surface: 1  glaucous, 2 other shades of green</p>
</dd>
<dt><code>ADP</code></dt><dd><p>Pubescence of the adaxial (upper) leaf surface under magnification: 1 absent, 2 rare (epidermis surface visible), 3 dense (epidermis surface is not visible or barely visible)</p>
</dd>
<dt><code>ABP</code></dt><dd><p>Pubescence of the abaxial (lower) leaf surface under magnification: 1 absent, 2 rare (epidermis surface visible), 3 dense (epidermis surface is not visible or barely visible)</p>
</dd>
</dl>


<hr>
<h2 id='Saynodynamite'>Say &ldquo;no&rdquo; to dynamite plots!</h2><span id='topic+Saynodynamite'></span>

<h3>Description</h3>

<p>Say &ldquo;no&rdquo; to dynamite plots!</p>


<h3>Usage</h3>

<pre><code class='language-R'>Saynodynamite()</code></pre>


<h3>Details</h3>

<p>'Poster' plot to emphasize the harmfulness of so called dynamite plots.
</p>
<p>See, for example, thorough analysis at &quot;http://emdbolker.wikidot.com/blog%3Adynamite&quot;.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Saynodynamite()
</code></pre>

<hr>
<h2 id='SM.dist'>Simple Match distance</h2><span id='topic+SM.dist'></span>

<h3>Description</h3>

<p>Calculates simple match distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>SM.dist(data, zeroes=TRUE, cut=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SM.dist_+3A_data">data</code></td>
<td>
<p>Matrix (or data frame) with variables that should be used in
the computation of the distance between rows.</p>
</td></tr>
<tr><td><code id="SM.dist_+3A_zeroes">zeroes</code></td>
<td>
<p>If FALSE (not default), zeroes will be ignored, so if data
is binary, result will be close to the asymmetric binary distance
('dist(..., method=&quot;binary&quot;)').</p>
</td></tr>
<tr><td><code id="SM.dist_+3A_cut">cut</code></td>
<td>
<p>If TRUE (not default), attempt will be made to discretize all
numeric columns with number of breaks default to hist(); zeroes will be
saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument is the data frame, SM.dist() internally converts it into the
matrix. If there are character values, they will be converted column-wise
to factors and then to integers.
</p>
<p>SM.dist() ignores NAs when computing the distance values, and treates
zeroes the same way if 'zeroes=FALSE'.
</p>


<h3>Value</h3>

<p>Distance object with distances among rows of 'data'</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(mm &lt;- rbind(c(1, 0, 0), c(1, NA, 1), c(1, 1, 0)))
SM.dist(mm)
SM.dist(mm, zeroes=FALSE)
dist(mm, method="binary")

ii &lt;- cluster::pam(SM.dist(sapply(iris[, -5], round)), k=3)
Misclass(ii$clustering, iris$Species, best=TRUE)

i2 &lt;- cluster::pam(SM.dist(iris), k=3) # SM.dist() "consumes" all types of data
Misclass(i2$clustering, iris$Species, best=TRUE)

</code></pre>

<hr>
<h2 id='Squares'>Areas of polygons</h2><span id='topic+Squares'></span>

<h3>Description</h3>

<p>Calculates areas of polygons</p>


<h3>Usage</h3>

<pre><code class='language-R'>Squares(ppts, relative=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Squares_+3A_ppts">ppts</code></td>
<td>
<p>Output from Hulls() or Ellipses(), or just a list of
polygons</p>
</td></tr>
<tr><td><code id="Squares_+3A_relative">relative</code></td>
<td>
<p>Calculate relative squares?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;List of polygons&quot; must be the list which contains any number of
two-column numerical matrices of data frames, each represents the
vertices of one polygon.
</p>
<p>Might be useful to understand the variability of groups.
</p>


<h3>Value</h3>

<p>Numerical (possibly named) vector of polygon areas, one element per
polygon.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Ellipses">Ellipses</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.pca &lt;- prcomp(iris[, -5])
iris.p &lt;- iris.pca$x[, 1:2]

iris.h &lt;- Hulls(iris.p[, 1:2], as.numeric(iris[, 5]), plot=FALSE)
Squares(iris.h, relative=TRUE)

iris.e &lt;- Ellipses(iris.p, iris$Species, plot=FALSE, centers=TRUE)
Squares(iris.e)

</code></pre>

<hr>
<h2 id='Str'>'str()' enchanced for data frames</h2><span id='topic+Str'></span>

<h3>Description</h3>

<p>Enhanced 'str()': with variable numbers, row names, missing data indication and possibly more</p>


<h3>Usage</h3>

<pre><code class='language-R'>Str(df, as.factor=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Str_+3A_df">df</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="Str_+3A_as.factor">as.factor</code></td>
<td>
<p>Convert character columns to factors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Str()' is an enhanced 'str()'. 'Str()' (1) shows data frame structure
with column indexes, (2) indicates presence of NA(s) with star (*) and
(3) lists first five row names, if they are not default.
</p>
<p>If the object is a data frame with atomic columns, this function captures
output of internal 'str()', changes it and outputs the new one. If the
object is not a data frame or is a data frame with non-atomic columns,
then output is not changed.
</p>
<p>If 'as.factor=TRUE', converts all character columns to factors before
reporting the structure, thus mimicking pre-R4 behavior of many functions
related with data frames (and also invisibly outputs the new data frame).
Might be useful, for example, to understand the number of unique
character values which will be shown as &quot;factor levels&quot;, works well in
conjunction with summary(), please see examples.
</p>
<p>Alternative: DescTools::Str() which uses cycles (slower!), has less
features, but works with non-atomic columns.
</p>


<h3>Value</h3>

<p>If 'as.factor=TRUE', invisibly outputs the data frame with all character
columns converted into factors.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+str">str</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>trees1 &lt;- trees
row.names(trees1)[1] &lt;- "a"
trees1[1, 1] &lt;- NA
Str(trees)
Str(trees1)

## Not run: 
trees.crazy &lt;- trees
trees.crazy[[2]] &lt;- trees[, 2, drop=FALSE]
str(trees.crazy)
Str(trees.crazy) # columns non-atomic: output as from str()

## End(Not run)

abc &lt;- data.frame(N=1:26, LETTERS, letters, stringsAsFactors=FALSE)
abc[3, 1] &lt;- NA
Str(abc)
Str(abc, as.factor=TRUE)
summary(Str(abc, as.factor=TRUE))

</code></pre>

<hr>
<h2 id='Table2df'>Convert table to data frame saving structure</h2><span id='topic+Table2df'></span>

<h3>Description</h3>

<p>Convert table to data frame saving structure</p>


<h3>Usage</h3>

<pre><code class='language-R'>Table2df(table)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Table2df_+3A_table">table</code></td>
<td>
<p>'table' object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert contingency table into data frame and keep structure.
</p>


<h3>Value</h3>

<p>Data frame</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>Table2df(table(iris[, 5]))
</code></pre>

<hr>
<h2 id='Tcoords'>Calculates coordinates of tips from 'hclust' plot</h2><span id='topic+Tcoords'></span>

<h3>Description</h3>

<p>Takes the 'hclust' plot and calculates coordinates of all tips</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Tcoords(hcl, hang=0.1, add=0, horiz=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tcoords_+3A_hcl">hcl</code></td>
<td>
<p><code>hclust</code> object</p>
</td></tr>
<tr><td><code id="Tcoords_+3A_hang">hang</code></td>
<td>
<p>The fraction of the plot height by which labels should hang
below the rest of the plot; better to make it equal to the 'hang' from
<code>hclust</code> (default is 0.1).</p>
</td></tr>
<tr><td><code id="Tcoords_+3A_add">add</code></td>
<td>
<p>Add to 'hang' to make labels look better; the reliable value
is about 0.03</p>
</td></tr>
<tr><td><code id="Tcoords_+3A_horiz">horiz</code></td>
<td>
<p>Plot values for a horizontal tree?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates coordinates for each tip of the plotted
'hclust' object. It is useful together with plot.hclust(...,
labels=FALSE).
</p>
<p>There are numerous applications of Tcoords(). Typical situation is when
user wants to change default labels on plot.hclust() but it is possible
only after conversion into the dendrogram. However, this conversion
might alter the graphical representation, and, what is worse, is not
suitable for advanced forms of plot.hclust(), for example, in 'pvclust'
package or those from Bclust() or Jclust()-related commands.
</p>
<p>Tcoords() allows to plot labels (or points, or any low lewel
structures) separately. Therefore, it is possible to rotate them,
colorize them, abbreviate them, change their font and so on. By
default, labels will be plotted horizontally, not vertically as it is
in plot.hclust().
</p>
<p>Tcoords() treats labels in order of their appearance on the dendrogram
and not in their initial order, so do not forget to apply the 'order'
component of 'hclust' object (see below for examples).
</p>
<p>Together with Hcoords(), Tcoords() in principle allows to plot
dendrogram in the alternative way (for example, with aid of segments()
and text()). That will allow, for example, to plot 'hclust'
horizontally without conversion into dendrogram. This possibility,
however, reqiures a further research.
</p>
<p>Please also see Fence() and Tctext() which are convenient functions
based on Tcoords() for adding segments and text labels, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+Ploth">Ploth</a></code>, <code><a href="#topic+Fence">Fence</a></code>,
<code><a href="#topic+Tctext">Tctext</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hcl &lt;- hclust(UScitiesD, "ward.D2")
newlabels &lt;- abbreviate(hcl$labels, 3)
newlabels &lt;- newlabels[hcl$order] # do not forget to reorder labels!
plot(hcl, labels=FALSE)
text(Tcoords(hcl, add=0.03), newlabels, col=ifelse(grepl("W.D", newlabels), 2, 1))

## points instead of text labels
plot(hcl, labels=FALSE)
points(Tcoords(hcl), pch=19)

## how to colorize tips, useful if dendrogram is dense
iris.h &lt;- hclust(dist(iris[, -5]))
plot(iris.h, labels=FALSE)
points(Tcoords(iris.h, add=0.01), col=iris$Species[iris.h$order]) # reorder lalels!

## can be used with Ploth(), i.e., with dendrogram
Ploth(hcl, labels=NA, horiz=TRUE) # hang=-1 is default
tc &lt;- Tcoords(hcl, hang=-1, horiz=TRUE)
text(tc, newlabels, pos=4, xpd=TRUE, cex=1.1) # Ploth() cannot change text size

</code></pre>

<hr>
<h2 id='Tctext'>Easy way to add text labels to 'hclust' plot</h2><span id='topic+Tctext'></span>

<h3>Description</h3>

<p>Uses text() and Tcoords() to add text labels to 'hclust' plot</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  Tctext(hcl, labels=hcl[["labels"]], hang=0.1, add=0, horiz=FALSE, xpd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tctext_+3A_hcl">hcl</code></td>
<td>
<p><code>hclust</code> object</p>
</td></tr>
<tr><td><code id="Tctext_+3A_labels">labels</code></td>
<td>
<p>Character vector with the size of 'labels' component of
'hcl'; by default, these exact 'labels'</p>
</td></tr>
<tr><td><code id="Tctext_+3A_hang">hang</code></td>
<td>
<p>The fraction of the plot height by which labels should hang
below the rest of the plot; by default, it is equal to the default
'hang' from <code>hclust</code> which is 0.1</p>
</td></tr>
<tr><td><code id="Tctext_+3A_add">add</code></td>
<td>
<p>Add to 'hang' to make labels look better; the reliable value
is about 0.03</p>
</td></tr>
<tr><td><code id="Tctext_+3A_horiz">horiz</code></td>
<td>
<p>Plot on a horizontal tree?</p>
</td></tr>
<tr><td><code id="Tctext_+3A_xpd">xpd</code></td>
<td>
<p>Plot text if it goes outside of the plotting region?</p>
</td></tr>
<tr><td><code id="Tctext_+3A_...">...</code></td>
<td>
<p>Further arguments to text()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that labels (similarly to Ploth()) are treated in their
_initial_, pre-clustered order because Tctext() reorders everything
internally. This is not similar to Tcoords() which treats them in order
of their appearance on the dendrogram and therefore requires manual
re-ordering.
</p>
<p>Please feel free to use the simple enough code of this function to
produce other convenient 'hclust'-labeling routines, for example, one
can make 'Tcpoints' based on Tcoords() and points().
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tcoords">Tcoords</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+Ploth">Ploth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hcl &lt;- hclust(UScitiesD, "ward.D2")

## how to imitate the default plot.hclust() with Tctext()
old.par &lt;- par(mfrow=c(1, 2))
plot(hcl, labels=gsub("[A-z.]", "  ", hcl$labels))
Tctext(hcl, srt=90, add=0.04, adj=c(1, 0.5))
plot(hcl)
par(old.par)

## how to use different properties of text()
plot(hcl, labels=FALSE)
Tctext(hcl, srt=45, add=0.02, adj=c(0.8, 1), font=2:1, col=1:5, cex=0.8)

## how to use Tctext() with Ploth()
old.par &lt;- par(mar=c(3, 1, 0, 7))
Ploth(hcl, horiz=TRUE, labels=NA, col=c(1:5, 1:5), col.edges=TRUE)
Tctext(hcl, horiz=TRUE, hang=-1, col=1:5, pos=4, cex=1.1, font=3)
par(old.par)

</code></pre>

<hr>
<h2 id='Tobin'>Binarize (make dummy variables)</h2><span id='topic+Tobin'></span>

<h3>Description</h3>

<p>Converts vector into matrix with binary columns</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tobin(var, convert.names=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tobin_+3A_var">var</code></td>
<td>
<p>character or numerical variable</p>
</td></tr>
<tr><td><code id="Tobin_+3A_convert.names">convert.names</code></td>
<td>
<p>if TRUE (default), construct new variable names, otherwise, use unique variable values as variable names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Tobin()' transforms character or numeric vector into the matrix with 0/1 (absent/present) cells.
</p>
<p>Two approaches are in use: through '==' operation and through the conversion into factor.
</p>
<p>First approach also constructs new names of variables whereas the second ('convert.names=FALSE') makes variable names from names of factor levels (i.e., labels).
</p>
<p>Alternatives: &quot;*dumm*&quot; packages (there are few in CRAN).
</p>


<h3>Value</h3>

<p>Matrix with binary columns</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>(ee &lt;- sample(letters[1:5], 10, replace=TRUE))
Tobin(ee, conv=FALSE)
Tobin(ee, conv=TRUE)
</code></pre>

<hr>
<h2 id='Toclip'>Insert content to Linux X11 clipboard</h2><span id='topic+Toclip'></span>

<h3>Description</h3>

<p>Insert content to Linux X11 clipboard (uses 'xclip')</p>


<h3>Usage</h3>

<pre><code class='language-R'>Toclip(x, sep="\t", row.names=FALSE, col.names=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Toclip_+3A_x">x</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="Toclip_+3A_sep">sep</code></td>
<td>
<p>Separator, tab by default</p>
</td></tr>
<tr><td><code id="Toclip_+3A_row.names">row.names</code></td>
<td>
<p>FALSE by default</p>
</td></tr>
<tr><td><code id="Toclip_+3A_col.names">col.names</code></td>
<td>
<p>TRUE by default</p>
</td></tr>
<tr><td><code id="Toclip_+3A_...">...</code></td>
<td>
<p>Arguments to 'write.table()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linux-specific. Inserts data frame to Linux X11 clipboard (not primary or secondary).
Useful for interface with spreadsheets.
</p>
<p>Works if 'xclip' utility is already installed.
</p>
<p>Alternative with more flexibility: 'clipr' package.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
aa &lt;- data.frame(1:3) # Linux- (and X11-) specific
Toclip(aa) # then load the content into spreadsheet

## End(Not run)
</code></pre>

<hr>
<h2 id='Topm'>Stacks correlation matrix</h2><span id='topic+Topm'></span>

<h3>Description</h3>

<p>Stacks (correlation) matrix and selects values which are above the &ldquo;level&rdquo;</p>


<h3>Usage</h3>

<pre><code class='language-R'>Topm(X, level=0.45, values=0, corr=TRUE, square=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Topm_+3A_x">X</code></td>
<td>
<p>Data frame or matrix with values</p>
</td></tr>
<tr><td><code id="Topm_+3A_level">level</code></td>
<td>
<p>Threshold</p>
</td></tr>
<tr><td><code id="Topm_+3A_values">values</code></td>
<td>
<p>If &gt; 0, ignores &quot;level&quot; and outputs until reaches number, if &quot;all&quot;, outputs all values</p>
</td></tr>
<tr><td><code id="Topm_+3A_corr">corr</code></td>
<td>
<p>If FALSE, does not show magnitude</p>
</td></tr>
<tr><td><code id="Topm_+3A_square">square</code></td>
<td>
<p>If FALSE, does not use lower triangle, some rows could be redundant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Topm()' stacks (correlation) matrix and selects (and sorts) values which are above the &ldquo;level&rdquo;.
</p>
<p>Good for the analysis of correlation matrices.
</p>


<h3>Value</h3>

<p>Data frame with correlation values</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cor">Cor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Topm(cor(trees), corr=TRUE)
</code></pre>

<hr>
<h2 id='Ttcols'>Text-to-columns</h2><span id='topic+Ttcols'></span>

<h3>Description</h3>

<p>Splits character vector into columns of the matrix based on specified separator</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Ttcols(text, missed=NA, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ttcols_+3A_text">text</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="Ttcols_+3A_missed">missed</code></td>
<td>
<p>How to fill empty cells of the result, default is NA</p>
</td></tr>
<tr><td><code id="Ttcols_+3A_...">...</code></td>
<td>
<p>Arguments to split() function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Text-to-columns operation is common in spreadsheets. In R, demands for
this functionality are likely also high because there are numerous
solutions. Below are some most simple, flexible and extendable:
</p>
<p>do.call(rbind, strsplit(..., split)) &ndash; fast and easy but it recycles
short rows
</p>
<p>read.table(text=..., sep=split, fill=TRUE, colClasses=&quot;character&quot;,
header=FALSE) &ndash; does not know how many columns you want; it uses only 5
first lines and requires to specify column names otherwise
</p>
<p>strcapture() &ndash; needs both rows of equal length _and_ number of future
columns
</p>
<p>stringr::str_split_fixed() &ndash; needs number of columns to make
</p>
<p>reshape2::colsplit() &ndash; needs column names beforehand
</p>
<p>tidyr::separate() &ndash; cannot take vectors and also wants explicit column
names
</p>
<p>Ttcols() is fast, simple and flexible solution which does not have
problems from above. It handles only one vector at time but it is easy to
overcome because it is simple to extend and combine.
</p>


<h3>Value</h3>

<p>Matrix of splitted strings without separators, empty cells filled with
'missed'.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fill">Fill</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
aa &lt;- c("one,I,i", "two,II", "three", NA, "", Inf, "2 ,3, 4,_5", 15, ",a,,b")
Ttcols(aa, split=" *, *")

bb &lt;- c("one,I,i", "two,II", "three")
Ttcols(bb, split=",")

Ttcols(row.names(mtcars), split=" ", missed="")

</code></pre>

<hr>
<h2 id='Updist'>Educated distances for semi-supervised clustering</h2><span id='topic+Updist'></span>

<h3>Description</h3>

<p>Updates distance matrix to help link or unlink objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Updist(dst, link=NULL, unlink=NULL, dmax=max(dst), dmin=min(dst))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Updist_+3A_dst">dst</code></td>
<td>
<p><code>dist</code> object</p>
</td></tr>
<tr><td><code id="Updist_+3A_link">link</code></td>
<td>
<p>1-level list with the arbitrary number of components,
each component is a numeric vector of row numbers for objects which you prefer to be linked</p>
</td></tr>
<tr><td><code id="Updist_+3A_unlink">unlink</code></td>
<td>
<p>1-level list with the arbitrary number of components,
each component is a numeric vector of row numbers for objects which you prefer to be not linked</p>
</td></tr>
<tr><td><code id="Updist_+3A_dmax">dmax</code></td>
<td>
<p>Distance to set for not linked objects</p>
</td></tr>
<tr><td><code id="Updist_+3A_dmin">dmin</code></td>
<td>
<p>Distance to set for linked objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function borrows the idea of MPCKM semi-supervised k-means (Bilenko et al., 2004)
but instead of updating distances on the run, it simply updates the distances object
beforehand in accordance with 'link' and 'unlink' constraints.
</p>
<p>Amazingly, it works as expected :) Please see the examples below.
</p>


<h3>References</h3>

<p>Bilenko M., Basu S., Mooney R.J. 2004. Integrating constraints and metric learning
in semi-supervised clustering. In: Proceedings of the twenty-first international
conference on Machine learning. P. 11. ACM.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris.d &lt;- dist(iris[, -5])
iris.km &lt;- kmeans(iris.d, 3)
iris.h &lt;- cutree(hclust(iris.d, method="ward.D"), k=3)

Misclass(iris.km$cluster, iris$Species, best=TRUE)
Misclass(iris.h, iris$Species, best=TRUE)

i.vv &lt;- cbind(which(iris$Species == "versicolor"), which(iris$Species == "virginica"))
i.link &lt;- list(sample(i.vv[, 2], 25), sample(i.vv[, 1], 25))
i.unlink &lt;- list(i.vv[1, ], i.vv[2, ])

iris.upd &lt;- Updist(iris.d, link=i.link, unlink=i.unlink)

iris.ukm &lt;- kmeans(iris.upd, 3)
iris.uh &lt;- cutree(hclust(iris.upd, method="ward.D"), k=3)

Misclass(iris.ukm$cluster, iris$Species, best=TRUE)
Misclass(iris.uh, iris$Species, best=TRUE)

## ===

aad &lt;- dist(t(atmospheres))
plot(hclust(aad))

aadu &lt;- Updist(aad, unlink=list(c("Earth", "Mercury")))
plot(hclust(aadu))
</code></pre>

<hr>
<h2 id='Vicinities'>Arrange observations by the distance from center</h2><span id='topic+Vicinities'></span>

<h3>Description</h3>

<p>Uses group centers to order all observations within group</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vicinities(data, groups, num=NULL, centers=NULL, method.c="median", method.d="manhattan")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vicinities_+3A_data">data</code></td>
<td>
<p>Numeric data frame or matrix</p>
</td></tr>
<tr><td><code id="Vicinities_+3A_groups">groups</code></td>
<td>
<p>Grouping factor</p>
</td></tr>
<tr><td><code id="Vicinities_+3A_num">num</code></td>
<td>
<p>How many indices per group to return, default is all</p>
</td></tr>
<tr><td><code id="Vicinities_+3A_centers">centers</code></td>
<td>
<p>Matrix or data frame with group centers, one row per 'groups' level</p>
</td></tr>
<tr><td><code id="Vicinities_+3A_method.c">method.c</code></td>
<td>
<p>How to calculate group centers, name of function</p>
</td></tr>
<tr><td><code id="Vicinities_+3A_method.d">method.d</code></td>
<td>
<p>How to calculate distances between centers and individual observations, dist() mehtod</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes data (data frame or matrix), grouping factor and
(optionally) matrix or data frame with group centers. Then it calculates
proximities between all observations and corresponding center, group by
group. Result is a list of proximity indices (row numbers). This list
allows, for example, to find &quot;central&quot; (&quot;typical&quot;, &quot;nuclear&quot;)
observations useful, e.g., as centroids or medoids, and also &quot;peripheral&quot;
observations, &quot;outliers&quot;.
</p>
<p>Distances by default are calculated with dist(..., method=&quot;manhattan&quot;)
but it is possible to specify any other dist() method via &quot;method.d&quot;.
</p>
<p>Pre-defined centers might be taken from many sources, e.g., Hulls(),
Ellipses(), Classproj(), see examples.
</p>
<p>If &quot;centers&quot; data is not supplied, then Vicinities() will perform a naive
computation of group centers via univariate medians. It is also possible
to use (via &quot;method.c&quot;) mean or any similar function which works within
sapply() and accepts &quot;na.rm=TRUE&quot; option.
</p>
<p>If size of the group is less then &quot;num&quot;, the resulted list will contain
NAs. If this is not a desired behavior, use something like lapply(res,
head, num).
</p>


<h3>Value</h3>

<p>The list of nlevels(as.factor(groups)) size, components named from these
levels and contained &quot;num&quot; numeric indices, corresponding with the row
numbers of original data.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hulls">Hulls</a></code>, <code><a href="#topic+Ellipses">Ellipses</a></code>, <code><a href="#topic+Classproj">Classproj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use for MDS
iris.d &lt;- dist(iris[, -5])
iris.c &lt;- cmdscale(iris.d)
iris.sc &lt;- as.data.frame(iris.c)
## naive calculation
first3n &lt;- unlist(Vicinities(iris.sc, iris$Species, num=3))
last10n &lt;- unlist(lapply(Vicinities(iris.sc, iris$Species), tail, 10))
##
plot(iris.sc, col=iris$Species)
points(iris.sc[first3n, ], pch=19, col=iris$Species[first3n])
points(iris.sc[last10n, ], pch=4, cex=2, col="black")

## use pre-defined centers from Hulls()
plot(iris.sc, col=iris$Species)
iris.h &lt;- Hulls(iris.sc, groups=iris$Species, centers=TRUE)
first3h &lt;- unlist(Vicinities(iris.sc, iris$Species, centers=iris.h$centers, num=3))
points(iris.sc[first3h, ], pch=19, col=iris$Species[first3h])

## use pre-defined centers from Ellipses()
plot(iris.sc, col=iris$Species)
iris.e &lt;- Ellipses(iris.sc, groups=iris$Species, centers=TRUE)
first3e &lt;- unlist(Vicinities(iris.sc, iris$Species, centers=iris.e$centers, num=3))
points(iris.sc[first3e, ], pch=19, col=iris$Species[first3e])

## ===

## plot and use pre-defined centers from Classproj()
iris.cl &lt;- Classproj(iris[, -5], iris[, 5])
first3cc &lt;- unlist(Vicinities(iris.cl$proj, iris[, 5], centers=iris.cl$centers, num=3))
plot(iris.cl$proj, col=iris$Species)
points(iris.cl$proj[first3cc, ], pch=19, col=iris$Species[first3cc])
## now calculate centers naively from projection data
first3cn &lt;- unlist(Vicinities(iris.cl$proj, iris[, 5], num=3))
points(iris.cl$proj[first3cn, ], pch=1, cex=1.5, col=iris$Species[first3cn])

## ===

## use as medoids for PAM
library(cluster)
iris.p &lt;- pam(iris.d, k=3)
Misclass(iris.p$clustering, iris[, 5], best=TRUE) # to compare
## naive method, raw data (4 columns)
first1nr &lt;- unlist(Vicinities(iris[, -5], iris$Species, 1))
iris.pm &lt;- pam(iris.d, k=3, medoids=first1nr)
Misclass(iris.pm$clustering, iris[, 5], best=TRUE) # slightly better!
## ... or as centers for k-means, for stability
first1h &lt;- unlist(Vicinities(iris.sc, iris$Species, centers=iris.h$centers, num=1))
iris.km &lt;- kmeans(iris[, -5], centers=iris[first1h, -5])
Misclass(iris.km$cluster, iris[, 5], best=TRUE)

## ===

## PCA and different vicinities methods
iris.p &lt;- prcomp(iris[, -5])$x[, 1:2]
plot(iris.p, col=iris$Species)
first3p1 &lt;- unlist(Vicinities(iris.p, iris[, 5], num=3))
first3p2 &lt;- unlist(Vicinities(iris.p, iris[, 5], num=3,
 method.c="mean", method.d="euclidean")) # mean, Euclidean
points(iris.p[first3p1, ], pch=19, col=iris[first3p1, 5])
points(iris.p[first3p2, ], pch=1, cex=1.5, col=iris[first3p2, 5])

## ===

## use MDS vicinities to reduce dataset for hierarchical clustering with bootstrap
iris3 &lt;- iris[first3n, ]
iris3b &lt;- Bclust(iris3[, -5], method.d="euclidean", method.c="average", iter=100)
plot(iris3b$hclust, labels=iris3[, 5])
Bclabels(iris3b$hclust, iris3b$values)

iris3j &lt;- Jclust(iris3[, -5], method.d="euclidean", method.c="average",
 n.cl=3, iter=100)
plot(iris3j, labels=iris3[, 5])

## ===

## use of external function to compute naive distances
Mode &lt;- function(x, na.rm=TRUE) {
 if (length(x) &lt;= 2) return(x[1])
 if (na.rm &amp; anyNA(x)) x &lt;- x[!is.na(x)]
 ux &lt;- unique(x)
 ux[which.max(tabulate(match(x, ux)))]
}
Vicinities(iris[, -5], iris[, 5], method.c="Mode", 3)

</code></pre>

<hr>
<h2 id='VTcoeffs'>Effect sizes of association between categorical variables</h2><span id='topic+VTcoeffs'></span>

<h3>Description</h3>

<p>Effect sizes of association between categorical variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>VTcoeffs(table, correct=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VTcoeffs_+3A_table">table</code></td>
<td>
<p>Contingency table</p>
</td></tr>
<tr><td><code id="VTcoeffs_+3A_correct">correct</code></td>
<td>
<p>Perform continuity correction in underlying chi-square test?</p>
</td></tr>
<tr><td><code id="VTcoeffs_+3A_...">...</code></td>
<td>
<p>Additional arguments to underlying chisq.test()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Association between categorical variables.
</p>
<p>Calculates Cramer's V and Tschuprow's, original and corrected (Bergsma, 2013)
</p>
<p>Alternative: vcd::assocstats()
</p>
<p>Includes magnitude interpretation for original Cramer's V (for df &lt; 6).
</p>


<h3>Value</h3>

<p>Data frame with coefficients, values and tables.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- margin.table(Titanic, 1:2)
VTcoeffs(x)
VTcoeffs(x)[2, ] # most practical
</code></pre>

<hr>
<h2 id='Write.fasta'>Write 'FASTA' files</h2><span id='topic+Write.fasta'></span>

<h3>Description</h3>

<p>Simple writing of 'FASTA' files</p>


<h3>Usage</h3>

<pre><code class='language-R'>Write.fasta(df, file)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Write.fasta_+3A_df">df</code></td>
<td>
<p>Name of data frame</p>
</td></tr>
<tr><td><code id="Write.fasta_+3A_file">file</code></td>
<td>
<p>File name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple writing of 'FASTA' files. If the data frame has more then two columns,
only two first columns will be used (with warning).</p>


<h3>Value</h3>

<p>'FASTA' file on the disk.</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- data.frame(one="some_id", two="ATGC", three="something else")
Write.fasta(ff, file=file.path(tempdir(), "tmp.fasta")) # warning will be produced
file.show(file=file.path(tempdir(), "tmp.fasta")) # interactive
</code></pre>

<hr>
<h2 id='Xpager'>Separate terminal pager for Linux</h2><span id='topic+Xpager'></span>

<h3>Description</h3>

<p>Separate terminal pager for Linux X11 (uses some terminal and 'less')</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xpager(pager="xterm")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xpager_+3A_pager">pager</code></td>
<td>
<p>name of the terminal application to use, or &quot;old&quot; for the default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linux pager in the new terminal window. 'xterm' is default,
there is also setting for 'mate-terminal';
'konsole' (KDE terminal) and 'gnome-terminal' are easy to add.
</p>
<p>Run Xpager(&quot;old&quot;) to restore default behavior.
</p>
<p>BTW, for some reason, 'editor()' does not work this way.
</p>


<h3>Author(s)</h3>

<p>Alexey Shipunov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Linux- (and X11-) specific
Xpager()
?help
Xpager("old")
?help

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
