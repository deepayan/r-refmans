<!DOCTYPE html><html><head><title>Help for package RRphylo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RRphylo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RRphylo-package'><p>Phylogenetic Ridge Regression Methods for Comparative Studies</p></a></li>
<li><a href='#angle.matrix'><p>Ontogenetic shape vectors analysis</p></a></li>
<li><a href='#colorbar'><p>Draw colorbar on a plot</p></a></li>
<li><a href='#conv.map'><p>Mapping morphological convergence on 3D surfaces</p></a></li>
<li><a href='#cutPhylo'><p>Cut the phylogeny at a given age or node</p></a></li>
<li><a href='#DataApes'><p>Example dataset</p></a></li>
<li><a href='#DataCetaceans'><p>Example dataset</p></a></li>
<li><a href='#DataFelids'><p>Example dataset</p></a></li>
<li><a href='#DataOrnithodirans'><p>Example dataset</p></a></li>
<li><a href='#DataSimians'><p>Example dataset</p></a></li>
<li><a href='#DataUng'><p>Example dataset</p></a></li>
<li><a href='#distNodes'><p>Finding distance between nodes and tips</p></a></li>
<li><a href='#evo.dir'><p>Phylogenetic vector analysis of phenotypic change</p></a></li>
<li><a href='#fix.poly'><p>Resolving polytomies to non-zero length branches</p></a></li>
<li><a href='#getGenus'><p>Taxonomic inspection of the tree at the genus level</p></a></li>
<li><a href='#getMommy'><p>Upward tip or node to root path</p></a></li>
<li><a href='#getSis'><p>Get sister clade</p></a></li>
<li><a href='#lollipoPlot'><p>Lollipop charts</p></a></li>
<li><a href='#makeFossil'><p>Make fossil species on a phylogeny</p></a></li>
<li><a href='#makeL'><p>Matrix of branch lengths along root-to-tip paths</p></a></li>
<li><a href='#makeL1'><p>Matrix of branch lengths along a root-to-node path</p></a></li>
<li><a href='#move.lineage'><p>Move tips or clades</p></a></li>
<li><a href='#namesCompare'><p>Checking species names for misspelling and synonyms</p></a></li>
<li><a href='#node.paths'><p>Tracing nodes along paths</p></a></li>
<li><a href='#overfitRR'><p>Testing RRphylo methods overfit</p></a></li>
<li><a href='#PGLS_fossil'><p>Phylogenetic Generalized Least Square with phylogenies including</p>
fossils</a></li>
<li><a href='#phyloclust'><p>Test for phylogenetic clustering</p></a></li>
<li><a href='#plotConv'><p>Graphical representation of search.conv results</p></a></li>
<li><a href='#plotRates'><p>Plot RRphylo rates at a specified node</p></a></li>
<li><a href='#plotRR'><p>Plot the RRphylo output onto the phylogenetic tree</p></a></li>
<li><a href='#plotShift'><p>Graphical representation of search.shift results</p></a></li>
<li><a href='#plotTrend'><p>Graphical representation of search.trend results</p></a></li>
<li><a href='#random.evolvability.test'><p>Randomization test for phylogenetic structuring in evolvability</p></a></li>
<li><a href='#rate.map'><p>Mapping rate and direction of phenotypic change on 3D surfaces.</p></a></li>
<li><a href='#rescaleRR'><p>Rescaling phylogenetic trees</p></a></li>
<li><a href='#retrieve.angles'><p>Extracting a user-specified subset of the evo.dir results</p></a></li>
<li><a href='#RRphylo'><p>Evolutionary rates computation along phylogenies</p></a></li>
<li><a href='#RRphylo-defunct'><p>Defunct functions in Package RRphylo</p></a></li>
<li><a href='#RRphylo-deprecated'><p>Deprecated functions in Package RRphylo</p></a></li>
<li><a href='#scaleTree'><p>Phylogenetic tree calibration</p></a></li>
<li><a href='#search.conv'><p>Searching for morphological convergence among species and clades</p></a></li>
<li><a href='#search.shift'><p>Locating shifts in phenotypic evolutionary rates</p></a></li>
<li><a href='#search.trend'><p>Searching for evolutionary trends in phenotypes and rates</p></a></li>
<li><a href='#setBM'><p>Producing simulated phenotypes with trends</p></a></li>
<li><a href='#sig2BM'><p>Brownian Motion rate computation</p></a></li>
<li><a href='#sizedsubtree'><p>Find a node subtending to a clade of desired size</p></a></li>
<li><a href='#StableTraitsR'><p>Run StableTraits from within R</p></a></li>
<li><a href='#swapONE'><p>Create alternative phylogenies from a given tree</p></a></li>
<li><a href='#tips'><p>Get descending tips</p></a></li>
<li><a href='#tree.merger'><p>Fast addition of tips and clades on an existing tree</p></a></li>
<li><a href='#treeCompare'><p>Visualize the difference between phylogenetic trees</p></a></li>
<li><a href='#treedataMatch'><p>Cross-reference tree and data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phylogenetic Ridge Regression Methods for Comparative Studies</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-04</td>
</tr>
<tr>
<td>Version:</td>
<td>2.8.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco Carotenuto</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pasquale Raia &lt;pasquale.raia@unina.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for phylogenetic analysis (Castiglione et al., 2018 &lt;<a href="https://doi.org/10.1111%2F2041-210X.12954">doi:10.1111/2041-210X.12954</a>&gt;). The functions perform the estimation of phenotypic evolutionary rates, identification of phenotypic evolutionary rate shifts, quantification of direction and size of evolutionary change in multivariate traits, the computation of ontogenetic shape vectors and test for morphological convergence.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), emmeans(&ge; 1.4.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, phytools, stats4, foreach, doParallel, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>phangorn, rlist, scales, R.utils, cluster, RColorBrewer,
nlme, car, smatr, picante, vegan, ddpcr, geomorph, rmarkdown,
knitr, kableExtra, plotrix, pdftools, rgl, mvMORPH, ggplot2,
qpdf, inflection, Rvcg, Morpho, evolqg, manipulate, markdown,
Rphylopars, phylolm, webshot2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-04 09:19:48 UTC; Utente</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-04 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RRphylo-package'>Phylogenetic Ridge Regression Methods for Comparative Studies</h2><span id='topic+RRphylo-package'></span>

<h3>Description</h3>

<p><span class="pkg">RRphylo</span> provides tools for phylogenetic comparative
analysis. The main functions allow estimation of phenotypic evolutionary
rates, identification of shifts in rate of evolution, quantification of
direction and size of evolutionary change of multivariate traits, and
computation of species ontogenetic vectors. Additionally, there are
functions for simulating phenotypic data, manipulating phylogenetic trees,
and retrieving information from phylogenies. Finally, there are functions
to plot and test rate shifts at particular nodes.
</p>
<p>The complete list of functions can be displayed with
<code>library(help = RRphylo)</code>. Citations to individual functions are
available by typing <code>citation("RRphylo")</code>.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>

<hr>
<h2 id='angle.matrix'>Ontogenetic shape vectors analysis</h2><span id='topic+angle.matrix'></span>

<h3>Description</h3>

<p>This function computes and compares ontogenetic vectors among
species in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle.matrix(RR,node,Y=NULL,select.axes=c("no","yes"),
  type=c("phenotypes","rates"),cova=NULL,clus=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle.matrix_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="angle.matrix_+3A_node">node</code></td>
<td>
<p>the number identifying the most recent common ancestor to all the
species the user wants ontogenetic vectors be computed.</p>
</td></tr>
<tr><td><code id="angle.matrix_+3A_y">Y</code></td>
<td>
<p>multivariate trait values at tips.</p>
</td></tr>
<tr><td><code id="angle.matrix_+3A_select.axes">select.axes</code></td>
<td>
<p>if <code>"yes"</code>, <code>Y</code> variables are individually
regressed against developmental stages and only significant variables are
retained to compute ontogenetic vectors. All variables are retained
otherwise.</p>
</td></tr>
<tr><td><code id="angle.matrix_+3A_type">type</code></td>
<td>
<p>specifies weather to perform the analysis on phenotypic
(<code>"phenotypes"</code>) or rate (<code>"rates"</code>) vectors.</p>
</td></tr>
<tr><td><code id="angle.matrix_+3A_cova">cova</code></td>
<td>
<p>the covariate to be indicated if its effect on rate values must
be accounted for. Contrary to <code>RRphylo</code>, <code>cova</code> needs to be as
long as the number of tips in the tree. As the covariate only affects rates
computation, there is no covariate to provide when <code>type =
"phenotypes"</code>.</p>
</td></tr>
<tr><td><code id="angle.matrix_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>angle.matrix</code> set <code>clus</code> = 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>angle.matrix</code> function takes as objects a phylogenetic
tree (retrieved directly from an <code><a href="#topic+RRphylo">RRphylo</a></code> object), including
the different ontogenetic stages of each species as polytomies. Names at
tips must be written as species ID and stage number separated by the
underscore. The <code>RRphylo</code> object <code>angle.matrix</code> is fed with is
just used to extract the dichotomized version of the phylogeny. This is
necessary because node numbers change randomly at dichotomizing non-binary
trees. However, when performing <code>angle.matrix</code> with the covariate the
<code>RRphylo </code> object must be produced without accounting for the
covariate. Furthermore, as the covariate only affects the rates
computation, it makes no sense to use it when computing vectors for
phenotypic variables. Once angles and vectors are computed,
<code>angle.matrix</code> performs two tests by means of standard major axis
(SMA) regression. For each species pair, the &quot;biogenetic test&quot; verifies
whether the angle between species grows during development, meaning that
the two species becomes less similar to each other during growth. The
&quot;paedomorphosis test&quot; tells whether there is heterochronic shape change in
the data. Under paedomorphosis, the adult stages of one (paedomorphic)
species will resemble the juvenile stages of the other (peramorphic)
species. The test regresses the angles formed by the shapes at different
ontogenetic stages of a species to the shape at the youngest stage of the
other in the pair, against age. Then, it tests whether the two regression
lines (one per species) have different slopes, and whether they have
different signs. If the regression lines point to different directions, it
means that one of the two species in the pair resembles, with age, the
juveniles of the other, indicating paedomorphosis. Ontogenetic vectors of
individual species are further computed, in reference to the MRCA of the
pair, and to the first stage of each species (i.e. intraspecifically).
Importantly, the size of the ontogenetic vectors of rates tell whether the
two species differ in terms of developmental rate, which is crucial to
understand which process is behind paedomorphosis, where it applies.While
performing the analysis, the function prints messages on-screen informing
about tests results. If <code>select.axes = "yes"</code>, informs the user about
which phenotypic variables are used. Secondly, it specifies whether
ontogenetic vectors to MRCA, and intraspecific ontogenetic vectors
significantly differ in angle or size between species pairs. Then, for each
species pair, it indicates if the biogenetic law and paedomorphosis apply.
</p>


<h3>Value</h3>

<p>A list containing 4 objects:
</p>
<ol>
<li> <p><strong>$regression.matrix</strong> a 'list' including
'angles between species' and 'angles between species to MRCA' matrices for
all possible combinations of species pairs from the two sides descending
from the MRCA. For each matrix, corresponding biogenetic and paedomorphosis
tests are reported. </p>
</li>
<li> <p><strong>$angles.2.MRCA.and.vector.size</strong> a
'data.frame' including angles between the resultant vector of species and
the MRCA and the size of the resultant vector computed from species to
MRCA, per stage per species. </p>
</li>
<li> <p><strong>$ontogenetic.vectors2MRCA</strong> a
'data.frame' including angle, size, and corresponding x and y components,
of ontogenetic vectors computed between each species and the MRCA. For both
angle and size, the p-value for the difference between species pairs is
reported. </p>
</li>
<li> <p><strong>$ontogenetic.vectors.to.1st.stage</strong> a 'list'
containing: </p>
<ul>
<li><p>$matrices: for all possible combinations of
species pairs from the two sides descending form the MRCA, the upper
triangle of the matrix contains the angles between different ontogenetic
stages for the first species. The same applies to the lower triangle, but
for the second species. </p>
</li>
<li><p>$vectors: for all possible combinations of
species pairs from the two sides descending form the MRCA, angles and sizes
of ontogenetic vectors computed to the first stage of each species. For
both, the p-value for the difference between the species pair is reported.
</p>
</li></ul>
 </li></ol>



<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  data("DataApes")
  DataApes$PCstage-&gt;PCstage
  DataApes$Tstage-&gt;Tstage
  DataApes$CentroidSize-&gt;CS
  cc&lt;- 2/parallel::detectCores()

  RRphylo(tree=Tstage,y=PCstage,clus=cc)-&gt;RR
# Case 1. without accounting for the effect of a covariate

 # Case 1.1 selecting shape variables that show significant relationship with age
  # on phenotypic vectors
    angle.matrix(RR,node=72,Y=PCstage,select.axes="yes",type="phenotypes",clus=cc)
  # on rates vectors
    angle.matrix(RR,node=72,Y=PCstage,select.axes="yes",type="rates",clus=cc)

 # Case 1.2 using all shape variables
  # on phenotypic vectors
    angle.matrix(RR,node=72,Y=PCstage,select.axes="no",type="phenotypes",clus=cc)
  # on rates vectors
    angle.matrix(RR,node=72,Y=PCstage,select.axes="no",type="rates",clus=cc)


# Case 2. accounting for the effect of a covariate (on rates vectors only)

 # Case 2.1 selecting shape variables that show significant relationship with age
   angle.matrix(RR,node=72,Y=PCstage,select.axes="yes",type="rates", cova=CS,clus=cc)


 # Case 2.2 using all shape variables
   angle.matrix(RR,node=72,Y=PCstage,select.axes="no",type="rates",cova=CS,clus=cc)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='colorbar'>Draw colorbar on a plot</h2><span id='topic+colorbar'></span>

<h3>Description</h3>

<p>The function adds a color bar to  plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorbar(
  colors,
  x,
  y = NULL,
  direction = "vertical",
  height = 1,
  width = 1,
  border = "black",
  lwd = 2,
  lty = 1,
  labs = NULL,
  labs.pos = NULL,
  title = NULL,
  title.pos = NULL,
  ticks = TRUE,
  tck.pos = NULL,
  tck.length = 1,
  xpd = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorbar_+3A_colors">colors</code></td>
<td>
<p>vector of colors.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_x">x</code>, <code id="colorbar_+3A_y">y</code></td>
<td>
<p>the x and y coordinates where the bottom left corner of the bar is
positioned. Keywords as in <code><a href="graphics.html#topic+legend">legend</a></code> are allowed.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_direction">direction</code></td>
<td>
<p>either <code>"vertical"</code> or <code>"horizontal"</code>.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_height">height</code></td>
<td>
<p>a number indicating the amount by which the height of the bar
should be scaled relative to the default.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_width">width</code></td>
<td>
<p>a number indicating the amount by which the width of the bar
should be scaled relative to the default.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_border">border</code></td>
<td>
<p>color of the border around the bar. Set <code>NA</code> to suppress
border drawing.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_lwd">lwd</code></td>
<td>
<p>border line width.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_lty">lty</code></td>
<td>
<p>border line type.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_labs">labs</code></td>
<td>
<p>the vector of labels to place next to the bar.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_labs.pos">labs.pos</code></td>
<td>
<p>either <code>"left"</code>/<code>"right"</code> for
<code>direction="vertical"</code> or <code>"top"</code>/<code>"bottom"</code> for
<code>direction="horizontal"</code>. Default settings are <code>"right"</code> and
<code>"bottom"</code>.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_title">title</code></td>
<td>
<p>the title to be placed next to the bar.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_title.pos">title.pos</code></td>
<td>
<p>either on the <code>"top"</code> or at the <code>"bottom"</code> of the
bar. Default setting is <code>"top"</code>.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_ticks">ticks</code></td>
<td>
<p>logical indicating whether ticks should be drawn next to each
label.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_tck.pos">tck.pos</code></td>
<td>
<p>indicates whether ticks should be plotter <code>"in"</code>side or
<code>"out"</code>side the bar border.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_tck.length">tck.length</code></td>
<td>
<p>tick lengths</p>
</td></tr>
<tr><td><code id="colorbar_+3A_xpd">xpd</code></td>
<td>
<p>a value of the <code><a href="graphics.html#topic+par">par</a></code> <code>xpd</code>.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>text</code> (for labels
and title) and <code>segments</code>. All these arguments must be hooked to the
element they refer to by indicating: <code>labs.*</code> for labels,
<code>title.\*</code> for title, and <code>tck.\*</code> for ticks. See example for
further details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Silvia Castiglione
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rainbow(30)-&gt;cols
replicate(4,paste(sample(letters,4),collapse=""))-&gt;labs

plot(rnorm(20),rnorm(20))
colorbar(cols,"topleft")

plot(rnorm(20),rnorm(20))
colorbar(cols,"topright",
         height=1.2,width=1.2,lwd=2,
         labs=labs,labs.pos="left",labs.cex=1.3,labs.adj=1,
         title="Colorbar!",title.cex=1.4,title.font=2,title.adj=c(0,0),
         tck.pos="out",tck.lwd=2,xpd=TRUE)
</code></pre>

<hr>
<h2 id='conv.map'>Mapping morphological convergence on 3D surfaces</h2><span id='topic+conv.map'></span>

<h3>Description</h3>

<p>Given vectors of RW (or PC) scores, the function selects the
RW(PC) axes which best account for convergence and maps convergent areas on
the corresponding 3D surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.map(dataset,pcs,mshape,conv=NULL, exclude=NULL,out.rem=TRUE,
  show.consensus=FALSE, plot=TRUE,col="blue",names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.map_+3A_dataset">dataset</code></td>
<td>
<p>data frame (or matrix) with the RW (or PC) scores of the group
or species to be compared.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_pcs">pcs</code></td>
<td>
<p>RW (or PC) vectors (eigenvectors of the covariance matrix) of all
the samples.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_mshape">mshape</code></td>
<td>
<p>the Consensus configuration.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_conv">conv</code></td>
<td>
<p>a named character vector indicating convergent species as
(indicated as &quot;conv&quot; in <code>dataset</code>) and not convergent species
(indicated as &quot;noconv&quot;).</p>
</td></tr>
<tr><td><code id="conv.map_+3A_exclude">exclude</code></td>
<td>
<p>integer: the index number of the RW (or PC) to be excluded
from the comparison.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_out.rem">out.rem</code></td>
<td>
<p>logical: if <code>TRUE</code> triangles with outlying area
difference are removed.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_show.consensus">show.consensus</code></td>
<td>
<p>logical: if <code>TRUE</code>, the Consensus configuration is
included in the comparison.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_plot">plot</code></td>
<td>
<p>logical: if <code>TRUE</code>, the pairwise comparisons are be plotted.
For more than 5 pairwise comparisons, the plot is not shown.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_col">col</code></td>
<td>
<p>character: the colour for the plot.</p>
</td></tr>
<tr><td><code id="conv.map_+3A_names">names</code></td>
<td>
<p>logical: if <code>TRUE</code>, the names of the groups or species are
displayed in the 3d plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conv.map</code> automatically builds a 3D mesh on the mean shape
calculated from the Relative Warp Analysis (RWA) or Principal Component
Analysis (PCA) (<cite>Schlager 2017</cite>) by applying the function
<code><a href="Rvcg.html#topic+vcgBallPivoting">vcgBallPivoting</a></code> (<span class="pkg">Rvcg</span>). <code>conv.map</code> further
gives the opportunity to exclude some RW (or PC) axes from the analysis
because, for example, in most cases the first axes are mainly related to
high-order morphological differences driven by phylogeny and size
variations. <code>conv.map</code> finds and plots the strength of convergence on
3D surfaces. An output of <code>conv.map</code> (if the dataset contains a number
equal or lower then 5 items) is an interactive plot mapping the convergence
on the 3D models. In the upper triangle of the 3D multiple layouts the rows
representing the reference models and the columns the target models. On the
contrary, on the lower triangle the rows correspond to the target models
and the columns the reference models. In the calculation of the differences
of areas we supply the possibility to find and remove outliers from the
vectors of areas calculated on the reference and target surfaces. We
suggest considering this possibility if the mesh may contain degenerate
facets.
</p>


<h3>Value</h3>

<p>The function returns a list including:
</p>
<ul>
<li><p><strong>$angle.compare</strong> data frame including the real angles
between the given shape vectors, the angles conv computed between vectors
of the selected RWs (or PCs), the angles between vectors of the
non-selected RWs (or PCs), the difference conv, and its p values.
</p>
</li>
<li><p><strong>$selected.pcs</strong> RWs (or PCs) axes selected for convergence.
</p>
</li>
<li><p><strong>$average.dist</strong> symmetric matrix of pairwise distances between
3D surfaces. </p>
</li>
<li><p><strong>$suface1</strong> list of coloured surfaces, if two
meshes are given, it represents convergence between mesh A and B charted on
mesh A. </p>
</li>
<li><p><strong>$suface2</strong> list of coloured surfaces, if two meshes are
given, it represents convergence between mesh A and B charted on mesh B.
</p>
</li>
<li> <p><strong>$scale</strong> the value used to set the colour gradient, computed
as the maximum of all differences between each surface and the mean shape.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marina Melchionna, Antonio Profico, Silvia Castiglione, Carmela
Serio, Gabriele Sansalone, Pasquale Raia
</p>


<h3>References</h3>

<p>Schlager, S. (2017). <em>Morpho and Rvcg–Shape Analysis in R:
R-Packages for geometric morphometrics, shape analysis and surface
manipulations.</em> In: Statistical shape and deformation analysis. Academic
Press.
Melchionna, M., Profico, A., Castiglione, S., Serio, C., Mondanaro,
A., Modafferi, M., Tamagnini, D., Maiorano, L. , Raia, P., Witmer, L.M.,
Wroe, S., &amp; Sansalone, G. (2021). A method for mapping morphological
convergence on three-dimensional digital models: the case of the mammalian
sabre-tooth. Palaeontology, 64, 573–584. doi:10.1111/pala.12542
</p>


<h3>See Also</h3>

<p><a href="../doc/search.conv.html"><code>search.conv</code> vignette</a> ;
<code><a href="Morpho.html#topic+relWarps">relWarps</a></code> ; <code><a href="Morpho.html#topic+procSym">procSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  data(DataSimians)
  DataSimians$pca-&gt;pca

  ## Case 1. Convergent species only
     dato&lt;-pca$PCscores[c(1,4),]

     CM&lt;-conv.map(dataset = dato,
                 pcs = pca$PCs,
                 mshape = pca$mshape,
                 show.consensus = TRUE)

  ## Case 2. Convergent and non-convergent species
     dato&lt;-pca$PCscores[c(1,4,7),]
     conv&lt;-c("conv","conv","noconv")
     names(conv)&lt;-rownames(dato)

     CM&lt;-conv.map(dataset = dato,
                  pcs = pca$PCs,
                  mshape = pca$mshape,
                  conv = conv,
                  show.consensus = TRUE,
                  col = "orange")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='cutPhylo'>Cut the phylogeny at a given age or node</h2><span id='topic+cutPhylo'></span>

<h3>Description</h3>

<p>The function cuts all the branches of the phylogeny which are
younger than a specific age or node (i.e. the age of the node).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutPhylo(tree,age=NULL,node=NULL,keep.lineage=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutPhylo_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="cutPhylo_+3A_age">age</code></td>
<td>
<p>the age (in terms of time distance from the recent) at which the
tree must be cut</p>
</td></tr>
<tr><td><code id="cutPhylo_+3A_node">node</code></td>
<td>
<p>the node whose age must be used as cutting limit.</p>
</td></tr>
<tr><td><code id="cutPhylo_+3A_keep.lineage">keep.lineage</code></td>
<td>
<p>logical specifying whether lineages with no descendant tip must be retained (see example below). Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an entire lineage is cut (i.e. one or more nodes along a path) and <code>keep.lineages = TRUE</code>,
the leaves left are labeled as &quot;l&quot; followed by a number.
</p>


<h3>Value</h3>

<p>The function returns the cut phylogeny and plots it into the graphic
device. The time axis keeps the root age of the original tree. Note,
tip labels are ordered according to their position in the tree.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>See Also</h3>

<p><a href="../doc/Tree-Manipulation.html#cutPhylo"><code>cutPhylo</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ape)

set.seed(22)
rtree(100)-&gt;tree
3-&gt;age

cutPhylo(tree,age=age)-&gt;t1
cutPhylo(tree,age=age,keep.lineage=FALSE)-&gt;t1
cutPhylo(tree,node=151)-&gt;t2
cutPhylo(tree,node=151,keep.lineage=FALSE)-&gt;t2

## End(Not run)
</code></pre>

<hr>
<h2 id='DataApes'>Example dataset</h2><span id='topic+DataApes'></span>

<h3>Description</h3>

<p>Geometric morphometrics shape data regarding Apes' facial
skeleton and Apes phylogentic trees (<cite>Profico et al. 2017</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DataApes)
</code></pre>


<h3>Format</h3>

<p>A list containing: </p>
 <dl>
<dt><strong>$PCstage</strong></dt><dd><p>A data frame
containing 38 shape variables for Apes' facial skull at different
ontogenetic stages</p>
</dd></dl>
<p>. </p>
<dl>
<dt><strong>$PCadult</strong></dt><dd><p>A data frame containing 3
shape variables for Apes' facial skull</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><strong>$Tstage</strong></dt><dd><p>Phylogenetic tree of Apes including the different
ontogenetic stages of each species as polytomies</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><strong>$Tadult</strong></dt><dd><p>Phylogenetic tree of Apes</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><strong>$CentroidSize</strong></dt><dd><p>numeric vector of Centroid Size values of
&lsquo;PCstage&rsquo;</p>
</dd></dl>
<p>. 
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Profico, A., Piras, P., Buzi, C., Di Vincenzo, F., Lattarini, F.,
Melchionna, M., Veneziano, A., Raia, P. &amp; Manzi, G. (2017). The evolution
of cranial base and face in Cercopithecoidea and Hominoidea: Modularity and
morphological integration. <em>American journal of primatology</em>,79:
e22721.
</p>

<hr>
<h2 id='DataCetaceans'>Example dataset</h2><span id='topic+DataCetaceans'></span>

<h3>Description</h3>

<p>Cetaceans' body and brain mass, and phylogenetic tree (Serio et
al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DataCetaceans)
</code></pre>


<h3>Format</h3>

<p>A list containing: </p>
 <dl>
<dt><strong>treecet</strong></dt><dd><p>Cetaceans
phylogenetic tree</p>
</dd></dl>
<p>. </p>
<dl>
<dt><strong>masscet</strong></dt><dd><p>numeric vector of cetaceans
body masses (ln g)</p>
</dd></dl>
<p>. </p>
<dl>
<dt><strong>brainmasscet</strong></dt><dd><p>numeric vector of
cetaceans brain masses (ln g)</p>
</dd></dl>
<p>. </p>
<dl>
<dt><strong>aceMyst</strong></dt><dd><p>body mass (ln g)
for <em>Mystacodon selenensis</em>, used as node prior at the ancestor of the
Mysticeti</p>
</dd></dl>
<p>. 
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Serio, C., Castiglione, S., Tesone, G., Piccolo, M., Melchionna,
M., Mondanaro, A., Di Febbraro, M., &amp; Raia, P. (2019). Macroevolution of
Toothed Whales Exceptional Relative Brain Size. <em>Evolutionary
Biology</em>, 46: 332-342. doi:10.1007/s11692-019-09485-7
</p>

<hr>
<h2 id='DataFelids'>Example dataset</h2><span id='topic+DataFelids'></span>

<h3>Description</h3>

<p>Geometric morphometrics shape data regarding felids' mandible
and phylogentic tree (<cite>Piras et al., 2018</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DataFelids)
</code></pre>


<h3>Format</h3>

<p>A list containing: </p>
 <dl>
<dt><strong>$PCscoresfel</strong></dt><dd><p>A data
frame containing 83 shape variables for felids' mandible</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><strong>$treefel</strong></dt><dd><p>Phylogenetic tree of felids</p>
</dd></dl>
<p>. 
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Piras, P., Silvestro, D., Carotenuto, F., Castiglione, S.,
Kotsakis, A., Maiorino, L., Melchionna, M.,Mondanaro, A., Sansalone, G.,
Serio, C., Vero, V. A., &amp; Raia, P. (2018). Evolution of the sabertooth
mandible: A deadly ecomorphological specialization. <em>Palaeogeography,
Palaeoclimatology, Palaeoecology</em>, 496, 166-174.
</p>

<hr>
<h2 id='DataOrnithodirans'>Example dataset</h2><span id='topic+DataOrnithodirans'></span>

<h3>Description</h3>

<p>Ornithodirans' body mass, phylogenetic tree and locomotory type
(<cite>Castiglione et al 2018</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DataOrnithodirans)
</code></pre>


<h3>Format</h3>

<p>A list containing: </p>
 <dl>
<dt><strong>treedino</strong></dt><dd><p>Ornithodirans
phylogenetic tree</p>
</dd></dl>
<p>. </p>
<dl>
<dt><strong>massdino</strong></dt><dd><p>numeric vector of
ornithodirans body masses</p>
</dd></dl>
<p>. </p>
<dl>
<dt><strong>statedino</strong></dt><dd><p>vector of
ornithodirans locomotory type</p>
</dd></dl>
<p>. 
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Castiglione, S., Tesone, G., Piccolo, M., Melchionna, M.,
Mondanaro, A., Serio, C., Di Febbraro, M., &amp; Raia, P.(2018). A new method
for testing evolutionary rate variation and shifts in phenotypic evolution.
<em>Methods in Ecology and Evolution</em>, 9:
974-983.doi:10.1111/2041-210X.12954
</p>

<hr>
<h2 id='DataSimians'>Example dataset</h2><span id='topic+DataSimians'></span>

<h3>Description</h3>

<p>The output of Procrustes superimposition as performed by the function <code><a href="Morpho.html#topic+procSym">procSym</a></code> on 9 simians faces and the phylogenetic tree for such species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DataSimians)
</code></pre>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>

<hr>
<h2 id='DataUng'>Example dataset</h2><span id='topic+DataUng'></span>

<h3>Description</h3>

<p>Geometric morphometrics shape data regarding mandible and
phylogentic tree of 'Ungulatomorpha' (<cite>Raia et al., 2010</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DataUng)
</code></pre>


<h3>Format</h3>

<p>A list containing: </p>
 <dl>
<dt><strong>$PCscoresung</strong></dt><dd><p>A data
frame containing 205 shape variables for mandible of 'Ungulatomorpha'</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><strong>$treeung</strong></dt><dd><p>Phylogenetic tree of 'Ungulatomorpha'</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><strong>$stateung</strong></dt><dd><p>vector of 'Ungulatomorpha' feeding type</p>
</dd></dl>
<p>. 
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Raia, P., Carotenuto, F., Meloro, C., Piras, P., &amp; Pushkina, D.
(2010). The shape of contention: adaptation, history, and contingency in
ungulate mandibles. <em>Evolution</em>, 64: 1489-1503.
</p>

<hr>
<h2 id='distNodes'>Finding distance between nodes and tips</h2><span id='topic+distNodes'></span>

<h3>Description</h3>

<p>The function computes the distance between pairs of nodes, pairs
of tips, or between nodes and tips. The distance is meant as both patristic
distance and the number of nodes intervening between the pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distNodes(tree,node=NULL,clus=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distNodes_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="distNodes_+3A_node">node</code></td>
<td>
<p>either a single node/tip or a pair of nodes/tips.</p>
</td></tr>
<tr><td><code id="distNodes_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>distNodes</code> set <code>clus</code> = 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>node</code> is specified, the function returns a data frame with
distances between the focal node/tip and the other nodes/tips on the tree
(or for the selected pair only). Otherwise, the function returns a matrix
containing the number of nodes intervening between each pair of nodes and
tips.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("DataApes")
DataApes$Tstage-&gt;Tstage

cc&lt;- 2/parallel::detectCores()
distNodes(tree=Tstage,clus=cc)
distNodes(tree=Tstage,node=64,clus=cc)
distNodes(tree=Tstage,node="Tro_2",clus=cc)
distNodes(tree=Tstage,node=c(64,48),clus=cc)
distNodes(tree=Tstage,node=c(64,"Tro_2"),clus=cc)

</code></pre>

<hr>
<h2 id='evo.dir'>Phylogenetic vector analysis of phenotypic change</h2><span id='topic+evo.dir'></span>

<h3>Description</h3>

<p>This function quantifies direction, size and rate of
evolutionary change of multivariate traits along node-to-tip paths and
between species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evo.dir(RR,angle.dimension=c("rates","phenotypes"),
  y.type=c("original","RR"),y=NULL,pair.type=c("node","tips"),pair=NULL,
  node=NULL,random=c("yes","no"),nrep=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evo.dir_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_angle.dimension">angle.dimension</code></td>
<td>
<p>specifies whether vectors of <code>"rates"</code> or
<code>"phenotypes"</code> are used.</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_y.type">y.type</code></td>
<td>
<p>must be indicated when <code>angle.dimension = "phenotypes"</code>.
If <code>"original"</code>, it uses the phenotypes as provided by the user, if
<code>"RR"</code> it uses <code>RR$predicted.phenotypes</code>.</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_y">y</code></td>
<td>
<p>specifies the phenotypes to be provided if <code>y.type =
"original"</code>.</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_pair.type">pair.type</code></td>
<td>
<p>either <code>"node"</code> or <code>"tips"</code>. Angles are computed
between each possible couple of species descending from a specified node
(<code>"node"</code>), or between a given couple of species (<code>"tips"</code>).</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_pair">pair</code></td>
<td>
<p>species pair to be specified if <code>pair.type = "tips"</code>. It
needs to be written as in the example below.</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_node">node</code></td>
<td>
<p>node number to be specified if <code>pair.type = "node"</code>. Notice
the node number must refer to the dichotomic version of the original tree,
as produced by <code>RRphylo</code>.</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_random">random</code></td>
<td>
<p>whether to perform randomization test
(<code>"yes"</code>/<code>"no"</code>).</p>
</td></tr>
<tr><td><code id="evo.dir_+3A_nrep">nrep</code></td>
<td>
<p>number of replications must be indicated if <code>random =
"yes"</code>. It is set at 100 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The way <code>evo.dir</code> computes vectors depends on whether
phenotypes or rates are used as variables. <code><a href="#topic+RRphylo">RRphylo</a></code> rates
along a path are aligned along a chain of ancestor/descendant
relationships. As such, each rate vector origin coincides to the tip of its
ancestor, and the resultant of the path is given by vector addition. In
contrast, phenotypic vectors are computed with reference to a common origin
(i.e. the consensus shape in a geometric morphometrics). In this latter
case, vector subtraction (rather than addition) will define the resultant
of the evolutionary direction.  It is important to realize that resultants
could be at any angle even if the species (the terminal vectors) have
similar phenotypes, because path resultants, rather than individual
phenotypes, are being contrasted. However, the function also provides the
angle between individual phenotypes as 'angle.between.species'. To perform
randomization test (<code>random = "yes"</code>), the evolutionary directions of
the two species are collapsed together. Then, for each variable, the median
is found, and random paths of the same size as the original paths are
produced sampling at random from the 47.5th to the 52.5th percentile around
the medians. This way, a random distribution of angles is obtained under
the hypothesis that the two directions are actually parallel. The
'angle.direction' represents the angle formed by the species phenotype and
a vector of 1s (as long as the number of variables representing the
phenotype). This way, each species phenotype is contrasted to the same
vector. The 'angle.direction' values could be inspected to test whether
individual species phenotypes evolve towards similar directions.
</p>


<h3>Value</h3>

<p>Under all specs, <code>evo.dir</code> returns a 'list' object. The length
of the list is one if <code>pair.type = "tips"</code>.  If <code>pair.type =
  "node"</code>, the list is as long as the number of all possible species pairs
descending from the node. Each element of the list contains:
</p>
<p><strong>angle.path.A</strong> angle of the resultant vector of species A to
MRCA
</p>
<p><strong>vector.size.species.A</strong> size of the resultant vector of
species A to MRCA
</p>
<p><strong>angle.path.B</strong> angle of the resultant vector of species B to
MRCA
</p>
<p><strong>vector.size.species.B</strong> size of the resultant vector of
species B to MRCA
</p>
<p><strong>angle.between.species.to.mrca</strong> angle between the species
paths resultant vectors to the MRCA
</p>
<p><strong>angle.between.species</strong> angle between species vectors (as they
are, without computing the path)
</p>
<p><strong>MRCA</strong> the node identifying the most recent common ancestor of
A and B
</p>
<p><strong>angle.direction.A</strong> angle of the vector of species A (as it
is, without computing the path) to a fixed reference vector (the same for
all species)
</p>
<p><strong>vec.size.direction.A</strong> size of the vector of species A
</p>
<p><strong>angle.direction.B</strong> angle of the vector of species B (as it
is, without computing the path) to a fixed reference vector (the same for
all species)
</p>
<p><strong>vec.size.direction.B</strong> size of the vector of species B
</p>
<p>If <code>random = "yes"</code>, results also include p-values for the
angles.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data("DataApes")
  DataApes$PCstage-&gt;PCstage
  DataApes$Tstage-&gt;Tstage
  cc&lt;- 2/parallel::detectCores()

  RRphylo(tree=Tstage,y=PCstage, clus=cc)-&gt;RR

# Case 1. Without performing randomization test

 # Case 1.1 Computing angles between rate vectors
  # for each possible couple of species descending from node 72
    evo.dir(RR,angle.dimension="rates",pair.type="node",node=72 ,
    random="no")
  # for a given couple of species
    evo.dir(RR,angle.dimension="rates",pair.type="tips",
    pair= c("Sap_1","Tro_2"),random="no")

 # Case 1.2 computing angles between phenotypic vectors provided by the user
  # for each possible couple of species descending from node 72
    evo.dir(RR,angle.dimension="phenotypes",y.type="original",
    y=PCstage,pair.type="node",node=72,random="no")
  # for a given couple of species
    evo.dir(RR,angle.dimension="phenotypes",y.type="original",
    y=PCstage,pair.type="tips",pair=c("Sap_1","Tro_2"),random="no")

 # Case 1.3 computing angles between phenotypic vectors produced by "RRphylo"
  # for each possible couple of species descending from node 72
    evo.dir(RR,angle.dimension="phenotypes",y.type="RR",
    pair.type="node",node=72,random="no")
  # for a given couple of species
    evo.dir(RR,angle.dimension="phenotypes",y.type="RR",
    pair.type="tips",pair=c("Sap_1","Tro_2"),random="no")


# Case 2. Performing randomization test

 # Case 2.1 Computing angles between rate vectors
  # for each possible couple of species descending from node 72
    evo.dir(RR,angle.dimension="rates",pair.type="node",node=72 ,
    random="yes",nrep=10)

  # for a given couple of species
    evo.dir(RR,angle.dimension="rates",pair.type="tips",
    pair= c("Sap_1","Tro_2"),random="yes",nrep=10)

 # Case 2.2 computing angles between phenotypic vectors provided by the user
  # for each possible couple of species descending from node 72
    evo.dir(RR,angle.dimension="phenotypes",y.type="original",
    y=PCstage,pair.type="node",node=72,random="yes",nrep=10)

  # for a given couple of species
    evo.dir(RR,angle.dimension="phenotypes",y.type="original",
    y=PCstage,pair.type="tips",pair=c("Sap_1","Tro_2"),random="yes",nrep=10)

 # Case 2.3 computing angles between phenotypic vectors produced by "RRphylo"
  # for each possible couple of species descending from node 72
    evo.dir(RR,angle.dimension="phenotypes",y.type="RR",
    pair.type="node",node=72,random="yes",nrep=10)

  # for a given couple of species
    evo.dir(RR,angle.dimension="phenotypes",y.type="RR",
    pair.type="tips",pair=c("Sap_1","Tro_2"),random="yes",nrep=10)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='fix.poly'>Resolving polytomies to non-zero length branches</h2><span id='topic+fix.poly'></span>

<h3>Description</h3>

<p>The function either collapses clades under a polytomy or
resolves polytomous clades to non-zero length branches, dichotomous clades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.poly(tree,type=c("collapse","resolve"),node=NULL,tol=1e-10,random=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.poly_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="fix.poly_+3A_type">type</code></td>
<td>
<p>either 'collapse' to create polytomies to one or more specific
nodes or 'resolve' to resolve (fix) all the polytomies within the tree or
to one or more specific nodes.</p>
</td></tr>
<tr><td><code id="fix.poly_+3A_node">node</code></td>
<td>
<p>the node in the tree where a polytomy should be created or fixed,
either. If <code>type='resolve'</code> and <code>node=NULL</code> all the polytomies
present in the tree are resolved.</p>
</td></tr>
<tr><td><code id="fix.poly_+3A_tol">tol</code></td>
<td>
<p>the tolerance to consider a branch length significantly greater
than zero, set at 1e-10 by default. If <code>type='resolve'</code>, all the
branch lengths smaller than <code>tol</code> are treated as polytomies.</p>
</td></tr>
<tr><td><code id="fix.poly_+3A_random">random</code></td>
<td>
<p>a logical value specifying whether to resolve the polytomies
randomly (the default) or in the order they appear in the tree (if
<code>random = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under <code>type='resolve'</code> polytomous clades are resolved adding
non-zero length branches to each new node. The evolutionary time attached
to the new nodes is partitioned equally below the dichotomized clade.
</p>


<h3>Value</h3>

<p>A phylogenetic tree with randomly fixed (i.e. <code>type='resolve'</code>)
polytomies or created polytomies (i.e. <code>type='collapse'</code>).Note,
tip labels are ordered according to their position in the tree.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Piccolo, M., Mondanaro, A.,
Melchionna, M., Di Febbraro, M., Sansalone, G., Wroe, S., &amp; Raia, P.
(2020). The influence of domestication, insularity and sociality on the
tempo and mode of brain size evolution in mammals. <em>Biological Journal
of the Linnean Society</em>,132: 221-231. doi:10.1093/biolinnean/blaa186
</p>


<h3>See Also</h3>

<p><a href="../doc/Tree-Manipulation.html#fix.poly"><code>fix.poly</code>
vignette</a>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 require(ape)

 data("DataCetaceans")
 DataCetaceans$treecet-&gt;treecet

 # Resolve all the polytomies within Cetaceans phylogeny
 fix.poly(treecet,type="resolve")-&gt;treecet.fixed
 par(mfrow=c(1,2))
 plot(treecet,no.margin=TRUE,show.tip.label=FALSE)
 plot(treecet.fixed,no.margin=TRUE,show.tip.label=FALSE)

 # Resolve the polytomies pertaining the genus Kentriodon
 fix.poly(treecet,type="resolve",node=221)-&gt;treecet.fixed2
 par(mfrow=c(1,2))
 plot(treecet,no.margin=TRUE,show.tip.label=FALSE)
 plot(treecet.fixed2,no.margin=TRUE,show.tip.label=FALSE)

 # Collapse Delphinidae into a polytomous clade
 fix.poly(treecet,type="collapse",node=179)-&gt;treecet.collapsed
 par(mfrow=c(1,2))
 plot(treecet,no.margin=TRUE,show.tip.label=FALSE)
 plot(treecet.collapsed,no.margin=TRUE,show.tip.label=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getGenus'>Taxonomic inspection of the tree at the genus level</h2><span id='topic+getGenus'></span>

<h3>Description</h3>

<p>The function returns the most recent common ancestor and the
number of species belonging to each or some user-specified genera within
the phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenus(tree,genera=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenus_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous. Generic name and specific epithet must be separated by
'_'.</p>
</td></tr>
<tr><td><code id="getGenus_+3A_genera">genera</code></td>
<td>
<p>a character vector including one or more genera to focus on.
Please notice the function is case sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data-frame including the number of species and
the most recent common ancestor of each genera.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DataCetaceans$treecet-&gt;tree

getGenus(tree)
getGenus(tree,c("Mesoplodon","Balaenoptera"))
</code></pre>

<hr>
<h2 id='getMommy'>Upward tip or node to root path</h2><span id='topic+getMommy'></span>

<h3>Description</h3>

<p>This function is a wrapper around <span class="pkg">phytools</span>
<code>getDescendants</code> (<cite>Revell 2012</cite>). It returns the node path from a
given node or species to the root of the phylogeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMommy(tree,N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMommy_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="getMommy_+3A_n">N</code></td>
<td>
<p>the number of node or tip to perform the function on. The function also works with tip labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function produces a vector of node numbers as integers, collated
from a node or a tip towards the tree root.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Revell, L. J. (2012). phytools: An R package for phylogenetic
comparative biology (and other things). <em>Methods in Ecology and
Evolution</em>, 3: 217-223.doi:10.1111/j.2041-210X.2011.00169.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DataApes")
DataApes$Tstage-&gt;Tstage

getMommy(tree=Tstage,N=12)
</code></pre>

<hr>
<h2 id='getSis'>Get sister clade</h2><span id='topic+getSis'></span>

<h3>Description</h3>

<p>The function identifies and returns the sister clade of a given
node/tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSis(tree,n,printZoom=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSis_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="getSis_+3A_n">n</code></td>
<td>
<p>number of focal node or name of focal tip.</p>
</td></tr>
<tr><td><code id="getSis_+3A_printzoom">printZoom</code></td>
<td>
<p>if <code>TRUE</code> the function plots the tree section of
interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sister node number or sister tip name. In case of polytomies, the
function returns a vector.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DataOrnithodirans)
DataOrnithodirans$treedino-&gt;treedino
getSis(tree=treedino,n=677,printZoom=FALSE)
getSis(tree=treedino,n="Shenzhoupterus_chaoyangensis",printZoom=FALSE)
</code></pre>

<hr>
<h2 id='lollipoPlot'>Lollipop charts</h2><span id='topic+lollipoPlot'></span>

<h3>Description</h3>

<p>The function generates lollipop or dumbbell dots charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lollipoPlot(values, type = "v", pt.lwd = NULL, pt.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lollipoPlot_+3A_values">values</code></td>
<td>
<p>either a vector, matrix, or data.frame of data. If matrix or
data.frame including two columns, a dumbbell dots chart is plotted.</p>
</td></tr>
<tr><td><code id="lollipoPlot_+3A_type">type</code></td>
<td>
<p>plot direction, either vertical (&quot;v&quot;, the default) or horizontal
(&quot;h&quot;).</p>
</td></tr>
<tr><td><code id="lollipoPlot_+3A_pt.lwd">pt.lwd</code></td>
<td>
<p>points lwd</p>
</td></tr>
<tr><td><code id="lollipoPlot_+3A_pt.col">pt.col</code></td>
<td>
<p>points color</p>
</td></tr>
<tr><td><code id="lollipoPlot_+3A_...">...</code></td>
<td>
<p>other arguments passed to the functions <code>plot</code>,
<code>points</code>, and <code>segments</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a dumbbell dots chart is plotted, different parameters (i.e.
col/cex/pch/bg/lwd) for starting and ending points can be supplied. See
example for further details.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(emmeans)

lollipoPlot(values=feedlot[,4],pt.col="green",pt.lwd=2,lwd=0.8,col="gray20",
            ylab="swt",xlab="samples")

line.col&lt;-sample(colors()[-1],length(levels(feedlot[,1])))
line.col&lt;-rep(line.col,times=table(feedlot[,1]))

lollipoPlot(values=feedlot[order(feedlot[,1]),3],ylab="ewt",xlab="samples",
            bg=as.numeric(as.factor(feedlot[order(feedlot[,1]),2])),
            cex=1.2,pch=21,col=line.col)



lollipoPlot(values=feedlot[order(feedlot[,1]),3:4],type="h",ylab="ewt",xlab="samples",
            pt.col=c("blue","cyan"),cex=1.2,pch=c(3,4),col=line.col)

lollipoPlot(values=feedlot[order(feedlot[,1]),3:4],type="h",ylab="ewt",xlab="samples",
            bg=cbind(line.col,line.col),cex=c(1.2,1),pch=c(21,22))
</code></pre>

<hr>
<h2 id='makeFossil'>Make fossil species on a phylogeny</h2><span id='topic+makeFossil'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>'phylo'</code> and
randomly changes the lengths of the leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFossil(tree,p=0.5,ex=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFossil_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="makeFossil_+3A_p">p</code></td>
<td>
<p>the proportion of tips involved. By default it is half of the number
of tips.</p>
</td></tr>
<tr><td><code id="makeFossil_+3A_ex">ex</code></td>
<td>
<p>the multiplying parameter to change the leaf lengths. It is set at
0.5 by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function produces a phylogeny having the same backbone of the
original one.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DataApes")
DataApes$Tstage-&gt;Tstage

makeFossil(tree=Tstage)
</code></pre>

<hr>
<h2 id='makeL'>Matrix of branch lengths along root-to-tip paths</h2><span id='topic+makeL'></span>

<h3>Description</h3>

<p>This function produces a <code class="reqn">n * m</code> matrix, where n=number of
tips and m=number of branches (i.e. n + number of nodes). Each row
represents the branch lengths aligned along a root-to-tip path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeL(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeL_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code class="reqn">n * m</code> matrix of branch lengths for all
root-to-tip paths in the tree (one per species).
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DataApes")
DataApes$Tstage-&gt;Tstage

makeL(tree=Tstage)
</code></pre>

<hr>
<h2 id='makeL1'>Matrix of branch lengths along a root-to-node path</h2><span id='topic+makeL1'></span>

<h3>Description</h3>

<p>This function produces a <code class="reqn">n * n</code> matrix, where n=number of
internal branches. Each row represents the branch lengths aligned along a
root-to-node path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeL1(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeL1_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code class="reqn">n * n</code> matrix of branch lengths for all
root-to-node paths (one per each node of the tree).
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DataApes")
DataApes$Tstage-&gt;Tstage

makeL1(tree=Tstage)
</code></pre>

<hr>
<h2 id='move.lineage'>Move tips or clades</h2><span id='topic+move.lineage'></span>

<h3>Description</h3>

<p>Move a single tip or an entire clade to a different position
within the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move.lineage(tree,focal,sister,rescale=TRUE,rootage=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move.lineage_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="move.lineage_+3A_focal">focal</code></td>
<td>
<p>the lineage to be moved. It can be either a tip name/number or a
node number. If <code>tree$node.label</code> is not <code>NULL</code>, a <code>focal</code>
clade can be indicated as &quot;Clade NAMEOFTHECLADE&quot; when appropriate.
Similarly, an entire genus can be indicated as &quot;Genus NAMEOFTHEGENUS&quot; (see
examples below).</p>
</td></tr>
<tr><td><code id="move.lineage_+3A_sister">sister</code></td>
<td>
<p>the sister tip/node where the <code>focal</code> must be attached. It
can be tip name/number or node number. If <code>tree$node.label</code> is not
<code>NULL</code>, a <code>focal</code> clade can be indicated as &quot;Clade
NAMEOFTHECLADE&quot; when appropriate. Similarly, an entire genus can be
indicated as &quot;Genus NAMEOFTHEGENUS&quot; (see examples below).</p>
</td></tr>
<tr><td><code id="move.lineage_+3A_rescale">rescale</code></td>
<td>
<p>logical. If the most recent common ancestor of the
<code>focal</code> clade is older than its new ancestor (i.e. the node right
above <code>sister</code>), the user can choose whether the height of the
<code>focal</code> clade must be rescaled on the height of the new ancestor
(<code>rescale=TRUE</code>), or the topology of the tree must be modified to
accommodate the height of <code>focal</code> as it is (rescale=FALSE, in this
case <code><a href="#topic+scaleTree">scaleTree</a></code> is applied).</p>
</td></tr>
<tr><td><code id="move.lineage_+3A_rootage">rootage</code></td>
<td>
<p>the age of the tree root to be supplied if <code>focal</code> must
be attached to it. If <code>rootage=NULL</code> the total height of the tree
increases by 10%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The phylogenetic tree with required topological changes.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(phytools)
DataCetaceans$tree-&gt;tree

### Case 1. Moving a single tip
# sister to a tip
move.lineage(tree,focal="Orcinus_orca",sister="Balaenoptera_musculus")
# sister to a clade
move.lineage(tree,focal="Orcinus_orca",sister=131)
# sister to a clade by using tree$node.label
move.lineage(tree,focal="Balaenoptera_musculus",sister="Clade Delphinida")
# sister to a specific genus
move.lineage(tree,focal="Orcinus_orca",sister="Genus Balaenoptera")
# sister to the tree root with and without rootage
move.lineage(tree,focal="Balaenoptera_musculus",sister=117)
move.lineage(tree,focal="Balaenoptera_musculus",sister=117,rootage=max(diag(vcv(tree))))

### Case 2. Moving a clade
# sister to a tip
move.lineage(tree,focal="Genus Mesoplodon",sister="Balaenoptera_musculus")
move.lineage(tree,focal="Clade Delphinida",sister="Balaenoptera_musculus")
move.lineage(tree,focal=159,sister="Balaenoptera_musculus")
# sister to a clade
move.lineage(tree,focal="Genus Mesoplodon",sister=131)
move.lineage(tree,focal="Clade Delphinida",sister=131)
move.lineage(tree,focal=159,sister=131)
# sister to a clade by using tree$node.label
move.lineage(tree,focal="Genus Mesoplodon",sister="Clade Plicogulae")
move.lineage(tree,focal="Clade Delphinida",sister="Clade Plicogulae")
move.lineage(tree,focal=159,sister="Clade Plicogulae")
# sister to a specific genus
move.lineage(tree,focal="Genus Mesoplodon",sister="Genus Balaenoptera")
move.lineage(tree,focal="Clade Delphinida",sister="Genus Balaenoptera")
move.lineage(tree,focal=159,sister="Genus Balaenoptera")
# sister to the tree root with and without rootage
move.lineage(tree,focal="Genus Mesoplodon",sister=117)
move.lineage(tree,focal="Clade Delphinida",sister=117)
move.lineage(tree,focal=159,sister=117)
move.lineage(tree,focal="Genus Mesoplodon",sister=117,rootage=max(diag(vcv(tree))))
move.lineage(tree,focal="Clade Delphinida",sister=117,rootage=max(diag(vcv(tree))))
move.lineage(tree,focal=159,sister=117,rootage=max(diag(vcv(tree))))
</code></pre>

<hr>
<h2 id='namesCompare'>Checking species names for misspelling and synonyms</h2><span id='topic+namesCompare'></span>

<h3>Description</h3>

<p>The function cross-references two vectors of species names
checking for possible synonyms, misspelled names, and genus-species or
species-subspecies correspondence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namesCompare(vec1,vec2,proportion=0.15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namesCompare_+3A_vec1">vec1</code>, <code id="namesCompare_+3A_vec2">vec2</code></td>
<td>
<p>a vector of species names. Genus names only are also
allowed. Generic name and specific epithet must be separated by '_'. Note
that <code>vec2</code> is used as the reference. Incomplete or suspicious names
are better placed in <code>vec1</code> (see example below).</p>
</td></tr>
<tr><td><code id="namesCompare_+3A_proportion">proportion</code></td>
<td>
<p>the maximum proportion of different characters between any
<code>vec1-vec2</code> names pair to consider it a possible misspelling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> including:
</p>
<p><strong>$genus</strong> if <code>vec1</code> includes genera names which miss
specific epithet, this object lists all the species in <code>vec2</code>
belonging to each of the genera.
</p>
<p><strong>$subspecies</strong> if <code>vec1</code> includes subspecies (i.e. two
epithets after genus name), this object lists species in <code>vec2</code>
possibly corresponding to each of the subspecies.
</p>
<p><strong>$epithet</strong> lists species with matching epithets as possible
synonyms.
</p>
<p><strong>$misspelling</strong> lists possible misspelled names. For each
proposed mismatched names pair the proportion of characters in the
<code>vec1</code> differing from the string in <code>vec2</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Antonella Esposito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
names(DataFelids$statefel)-&gt;nams
nams[c(19,12,37,80,43)]&lt;-c("Puma_yagouaroundi","Felis_manul","Catopuma",
                           "Pseudaelurus","Panthera_zdansky")
nams&lt;-nams[-81]

namesCompare(nams,names(DataFelids$statefel))
namesCompare(names(DataFelids$statefel),nams)

## End(Not run)
</code></pre>

<hr>
<h2 id='node.paths'>Tracing nodes along paths</h2><span id='topic+node.paths'></span>

<h3>Description</h3>

<p>Given a vector of nodes, the function collates nodes along
individual lineages from the youngest (i.e. furthest from the tree root) to
the oldest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.paths(tree, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.paths_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="node.paths_+3A_vec">vec</code></td>
<td>
<p>a vector of node numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of node paths, each starting from the youngest node (i.e.
furthest from the tree root) and ending to the oldest along the path.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape)

rtree(100)-&gt;tree
sample(seq(Ntip(tree)+1,Ntip(tree)+Nnode(tree)),20)-&gt;nods
plot(tree,show.tip.label=FALSE)
nodelabels(node=nods,frame="n",col="red")
node.paths(tree=tree, vec=nods)
</code></pre>

<hr>
<h2 id='overfitRR'>Testing RRphylo methods overfit</h2><span id='topic+overfitRR'></span>

<h3>Description</h3>

<p>Testing the robustness of <code><a href="#topic+search.trend">search.trend</a></code>
(<cite>Castiglione et al. 2019a</cite>), <code><a href="#topic+search.shift">search.shift</a></code>
(<cite>Castiglione et al. 2018</cite>),  <code><a href="#topic+search.conv">search.conv</a></code>
(<cite>Castiglione et al. 2019b</cite>), and <code><a href="#topic+PGLS_fossil">PGLS_fossil</a></code> results to
sampling effects and phylogenetic uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overfitRR(RR,y,phylo.list=NULL,s=0.25,swap.args=NULL,trend.args=NULL,shift.args=NULL,
conv.args=NULL, pgls.args=NULL,aces=NULL,x1=NULL,aces.x1=NULL,cov=NULL,
rootV=NULL,nsim=100,clus=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overfitRR_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_y">y</code></td>
<td>
<p>a named vector of phenotypes.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_phylo.list">phylo.list</code></td>
<td>
<p>a list (or multiPhylo) of alternative phylogenies to be
tested.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_s">s</code></td>
<td>
<p>the percentage of tips to be cut off. It is set at 25% by default.
If <code>phylo.list</code> is provided, this argument is ignored.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_swap.args">swap.args</code></td>
<td>
<p>a list of arguments to be passed to the function
<code><a href="#topic+swapONE">swapONE</a></code>, including <code>list(si=NULL,si2=NULL,</code>
<code>node=NULL)</code>. If <code>swap.arg</code> is unspecified, the function
automatically sets both <code>si</code> and <code>si2</code> to 0.1. If
<code>phylo.list</code> is provided, swapping is not performed.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_trend.args">trend.args</code></td>
<td>
<p>a list of arguments specific to the function
<code>search.trend</code>, including <code>list(node=NULL,x1.residuals=FALSE)</code>.
If a trend for the whole tree is to be tested, type <code>trend.args =
list()</code>. No trend is tested if left unspecified.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_shift.args">shift.args</code></td>
<td>
<p>a list of arguments specific to the function
<code>search.shift</code>, including <code>list(node=NULL,</code> <code>state=NULL)</code>.
Arguments <code>node</code> and <code>state</code> can be specified at the same time.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_conv.args">conv.args</code></td>
<td>
<p>a list of arguments specific to the function
<code>search.conv</code>, including <code>list(node=NULL,</code> <code>state=NULL,
declust=FALSE)</code>. Arguments <code>node</code> and <code>state</code> can be specified at
the same time.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_pgls.args">pgls.args</code></td>
<td>
<p>a list of arguments specific to the function
<code>PGLS_fossil</code>, including <code>list(modform,</code> <code>data,
tree=FALSE,RR=TRUE,...)</code>. If <code>tree=TRUE</code>, <code>PGLS_fossil</code> is
performed by using the RRphylo output tree as <code>tree</code> argument. If
<code>RR=TRUE</code>, <code>PGLS_fossil</code> is performed by using the RRphylo output
as <code>RR</code> argument. Arguments <code>tree</code> and <code>RR</code> can be
<code>TRUE</code> at the same time. <code>...</code> are further argument passed to
<code>PGLS_fossil</code>.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_aces">aces</code></td>
<td>
<p>if used to produce the <code>RR</code> object, the vector of those
ancestral character values at nodes known in advance must be specified.
Names correspond to the nodes in the tree.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_x1">x1</code></td>
<td>
<p>the additional predictor to be specified if the RR object has been
created using an additional predictor (i.e. multiple version of
<code>RRphylo</code>). <code>'x1'</code> vector must be as long as the number of nodes
plus the number of tips of the tree, which can be obtained by running
<code>RRphylo</code> on the predictor as well, and taking the vector of ancestral
states and tip values to form the <code>x1</code>.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_aces.x1">aces.x1</code></td>
<td>
<p>a named vector of ancestral character values at nodes for
<code>x1</code>. It must be indicated if the RR object has been created using
both <code>aces</code> and <code>x1</code>. Names correspond to the nodes in the tree.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_cov">cov</code></td>
<td>
<p>if used to produce the <code>RR</code> object, the covariate must be
specified. As in <code>RRphylo</code>, the covariate vector must be as long as
the number of nodes plus the number of tips of the tree, which can be
obtained by running <code>RRphylo</code> on the covariate as well, and taking the
vector of ancestral states and tip values to form the covariate.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_rootv">rootV</code></td>
<td>
<p>if used to produce the <code>RR</code> object, the phenotypic value at
the tree root must be specified.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to be performed. It is set at 100 by
default.</p>
</td></tr>
<tr><td><code id="overfitRR_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>overfitRR</code> set <code>clus</code> = 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods using a large number of parameters risk being overfit. This
usually translates in poor fitting with data and trees other than the those
originally used. With <code>RRphylo</code> methods this risk is usually very low.
However, the user can assess how robust the results got by applying
<code>search.shift</code>, <code>search.trend</code>, <code>search.conv</code> or
<code>PGLS_fossil</code> are by running <code>overfitRR</code>. With the latter, the
original tree and data are subsampled by specifying a <code>s</code> parameter,
that is the proportion of tips to be removed from the tree. In some cases,
though, removing as many tips as imposed by <code>s</code> would delete too many
tips right in clades and/or states under testing. In these cases, the
function maintains no less than 5 species at least in each clade/state
under testing (or all species if there is less), reducing the sampling
parameter <code>s</code> if necessary. Internally, <code>overfitRR</code> further
shuffles the tree by using the function <code><a href="#topic+swapONE">swapONE</a></code>. Thereby,
both the potential for overfit and phylogenetic uncertainty are accounted
for straight away.
</p>
<p>Otherwise, a list of alternative phylogenies can be supplied to
<code>overfitRR</code>. In this case subsampling and swapping arguments are
ignored, and robustness testing is performed on the alternative topologies
as they are. If a clade has to be tested either in <code>search.shift</code>,
<code>search.trend</code>, or <code>search.conv</code>, the function scans each
alternative topology searching for the corresponding clade. If the species
within such clade on the alternative topology differ more than 10
species within the clade in the original tree, the identity of the clade is
considered disrupted and the test is not performed.
</p>


<h3>Value</h3>

<p>The function returns a 'RRphyloList' object containing:
</p>
<p><strong>$mean.sampling</strong> the mean proportion of species actually
removed from the tree over the iterations.
</p>
<p><strong>$tree.list</strong> a 'multiPhylo' list including the trees generated
within <code>overfitRR</code>
</p>
<p><strong>$RR.list</strong> a 'RRphyloList' including the results of each
<code>RRphylo</code> performed within <code>overfitRR</code>
</p>
<p><strong>$rootCI</strong> the 95% confidence interval around the root value.
</p>
<p><strong>$ace.regressions</strong> a 'RRphyloList' including the results of
linear regression between ancestral state estimates before and after the
subsampling.
</p>
<p><strong>$conv.results</strong> a list including results for
<code>search.conv</code> performed under <code>clade</code> and <code>state</code>
conditions. If a node pair is specified within <code>conv.args</code>, the
<code>$clade</code> object contains the percentage of simulations producing
significant p-values for convergence between the clades, and the proportion
of tested trees (i.e. where the clades identity was preserved; always 1 if
no <code>phylo.list</code> is supplied). If a state vector is supplied within
<code>conv.args</code>, the object <code>$state</code> contains the percentage of
simulations producing significant p-values for convergence within (single
state) or between states (multiple states).
</p>
<p><strong>$shift.results</strong> a list including results for
<code>search.shift</code> performed under <code>clade</code> and <code>sparse</code>
conditions. If one or more nodes are specified within <code>shift.args</code>,
the <code>$clade</code> object contains for each node the percentage of
simulations producing significant p-value separated by shift sign, and the
same figures by considering all the specified nodes as evolving under a
single rate (all.clades). For each node the proportion of tested trees
(i.e. where the clade identity was preserved; always 1 if no
<code>phylo.list</code> is supplied) is also indicated. If a state vector is
supplied within <code>shift.args</code>, the object <code>$sparse</code> contains the
percentage of simulations producing significant p-value separated by shift
sign ($p.states).
</p>
<p><strong>$trend.results</strong> a list including the percentage of
simulations showing significant p-values for phenotypes versus age and
absolute rates versus age regressions for the entire tree separated by
slope sign ($tree). If one or more nodes are specified within
<code>trend.args</code>, the list also includes the same results at nodes ($node)
and the results for comparison between nodes ($comparison). For each node the proportion
of tested trees (i.e. where the clade identity was preserved; always 1 if
no <code>phylo.list</code> is supplied) is also indicated.
</p>
<p><strong>$pgls.results</strong> two 'RRphyloList' objects including results of
<code>PGLS_fossil</code> performed by using the phylogeny as it is (<code>$tree</code>)
or rescaled according to the <code>RRphylo</code> rates (<code>$RR</code>).
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia
</p>


<h3>References</h3>

<p>Castiglione, S., Tesone, G., Piccolo, M., Melchionna, M.,
Mondanaro, A., Serio, C., Di Febbraro, M., &amp; Raia, P. (2018). A new method
for testing evolutionary rate variation and shifts in phenotypic evolution.
<em>Methods in Ecology and Evolution</em>, 9:
974-983.doi:10.1111/2041-210X.12954
</p>
<p>Castiglione, S., Serio, C., Mondanaro, A., Di Febbraro, M.,
Profico, A., Girardi, G., &amp; Raia, P. (2019a) Simultaneous detection of
macroevolutionary patterns in phenotypic means and rate of change with and
within phylogenetic trees including extinct species. <em>PLoS ONE</em>, 14:
e0210101. https://doi.org/10.1371/journal.pone.0210101
</p>
<p>Castiglione, S., Serio, C., Tamagnini, D., Melchionna, M.,
Mondanaro, A., Di Febbraro, M., Profico, A., Piras, P.,Barattolo, F., &amp;
Raia, P. (2019b). A new, fast method to search for morphological
convergence with shape data. <em>PLoS ONE</em>, 14, e0226949.
https://doi.org/10.1371/journal.pone.0226949
</p>


<h3>See Also</h3>

<p><a href="../doc/overfitRR.html"><code>overfitRR</code> vignette</a> ;
<a href="../doc/search.trend.html"><code>search.trend</code> vignette</a> ;
<a href="../doc/search.shift.html"><code>search.shift</code> vignette</a> ;
<a href="../doc/search.conv.html"><code>search.conv</code> vignette</a> ;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
DataOrnithodirans$statedino-&gt;statedino
cc&lt;- 2/parallel::detectCores()

# Extract Pterosaurs tree and data
library(ape)
extract.clade(treedino,746)-&gt;treeptero
massdino[match(treeptero$tip.label,names(massdino))]-&gt;massptero
massptero[match(treeptero$tip.label,names(massptero))]-&gt;massptero


RRphylo(tree=treedino,y=massdino,clus=cc)-&gt;dinoRates
RRphylo(tree=treeptero,y=log(massptero),clus=cc)-&gt;RRptero

# Case 1 search.shift under both "clade" and "sparse" condition
search.shift(RR=dinoRates, status.type= "clade")-&gt;SSnode
search.shift(RR=dinoRates, status.type= "sparse", state=statedino)-&gt;SSstate

overfitRR(RR=dinoRates,y=massdino,swap.args =list(si=0.2,si2=0.2),
          shift.args = list(node=rownames(SSnode$single.clades),state=statedino),
          nsim=10,clus=cc)-&gt;orr.ss

# Case 2 search.trend on the entire tree
search.trend(RR=RRptero, y=log(massptero),nsim=100,clus=cc,cov=NULL,node=NULL)-&gt;STtree

overfitRR(RR=RRptero,y=log(massptero),swap.args =list(si=0.2,si2=0.2),
          trend.args = list(),nsim=10,clus=cc)-&gt;orr.st1

# Case 3 search.trend at specified nodescov=NULL,
search.trend(RR=RRptero, y=log(massptero),node=143,clus=cc)-&gt;STnode

overfitRR(RR=RRptero,y=log(massptero),
          trend.args = list(node=143),nsim=10,clus=cc)-&gt;orr.st2

# Case 4 overfitRR on multiple RRphylo
data("DataCetaceans")
DataCetaceans$treecet-&gt;treecet
DataCetaceans$masscet-&gt;masscet
DataCetaceans$brainmasscet-&gt;brainmasscet
DataCetaceans$aceMyst-&gt;aceMyst

ape::drop.tip(treecet,treecet$tip.label[-match(names(brainmasscet),
                                               treecet$tip.label)])-&gt;treecet.multi
masscet[match(treecet.multi$tip.label,names(masscet))]-&gt;masscet.multi

RRphylo(tree=treecet.multi,y=masscet.multi,clus=cc)-&gt;RRmass.multi
RRmass.multi$aces[,1]-&gt;acemass.multi
c(acemass.multi,masscet.multi)-&gt;x1.mass

RRphylo(tree=treecet.multi,y=brainmasscet,x1=x1.mass,clus=cc)-&gt;RRmulti
search.trend(RR=RRmulti, y=brainmasscet,x1=x1.mass,clus=cc)-&gt;STcet
overfitRR(RR=RRmulti,y=brainmasscet,trend.args = list(),
          x1=x1.mass,nsim=10,clus=cc)-&gt;orr.st3

search.trend(RR=RRmulti, y=brainmasscet,x1=x1.mass,x1.residuals=TRUE,
             clus=cc)-&gt;STcet.resi
overfitRR(RR=RRmulti,y=brainmasscet,trend.args = list(x1.residuals=TRUE),
          x1=x1.mass,nsim=10,clus=cc)-&gt;orr.st4

# Case 5 searching convergence between clades and within a single state
data("DataFelids")
DataFelids$PCscoresfel-&gt;PCscoresfel
DataFelids$treefel-&gt;treefel
DataFelids$statefel-&gt;statefel

RRphylo(tree=treefel,y=PCscoresfel,clus=cc)-&gt;RRfel
search.conv(RR=RRfel, y=PCscoresfel, min.dim=5, min.dist="node9",clus=cc)-&gt;SC.clade
as.numeric(c(rownames(SC.clade[[1]])[1],as.numeric(as.character(SC.clade[[1]][1,1]))))-&gt;conv.nodes

overfitRR(RR=RRfel, y=PCscoresfel,conv.args =
list(node=conv.nodes,state=statefel,declust=TRUE),nsim=10,clus=cc)-&gt;orr.sc

# Case 6 overfitRR on PGLS_fossil
library(phytools)
rtree(100)-&gt;tree
fastBM(tree)-&gt;resp
fastBM(tree,nsim=3)-&gt;resp.multi
fastBM(tree)-&gt;pred1
fastBM(tree)-&gt;pred2

PGLS_fossil(modform=y1~x1+x2,data=list(y1=resp,x2=pred1,x1=pred2),tree=tree)-&gt;pgls_noRR

RRphylo(tree,resp,clus=cc)-&gt;RR
PGLS_fossil(modform=y1~x1+x2,data=list(y1=resp,x2=pred1,x1=pred2),tree=tree,RR=RR)-&gt;pgls_RR

overfitRR(RR=RR,y=resp,
          pgls.args=list(modform=y1~x1+x2,data=list(y1=resp,x2=pred1,x1=pred2),
                         tree=TRUE,RR=TRUE),nsim=10,clus=cc)-&gt;orr.pgls1

PGLS_fossil(modform=y1~x1+x2,data=list(y1=resp.multi,x2=pred1,x1=pred2),tree=tree)-&gt;pgls2_noRR

RRphylo(tree,resp.multi,clus=cc)-&gt;RR
PGLS_fossil(modform=y1~x1+x2,data=list(y1=resp.multi,x2=pred1,x1=pred2),tree=tree,RR=RR)-&gt;pgls2_RR

overfitRR(RR=RR,y=resp.multi,
          pgls.args=list(modform=y1~x1+x2,data=list(y1=resp.multi,x2=pred1,x1=pred2),
                         tree=TRUE,RR=TRUE),nsim=10,clus=cc)-&gt;orr.pgls2



## End(Not run)
</code></pre>

<hr>
<h2 id='PGLS_fossil'>Phylogenetic Generalized Least Square with phylogenies including
fossils</h2><span id='topic+PGLS_fossil'></span>

<h3>Description</h3>

<p>The function performs pgls for non-ultrametric trees using a
variety of evolutionary models or <code><a href="#topic+RRphylo">RRphylo</a></code> rates to change the
tree correlation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PGLS_fossil(modform,data=NULL,tree=NULL,RR=NULL,GItransform=FALSE,
  intercept=FALSE,model="BM",method=NULL,permutation="none",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PGLS_fossil_+3A_modform">modform</code></td>
<td>
<p>the formula for the regression model.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_data">data</code></td>
<td>
<p>a data.frame or list including response and predictor variables
as named in <code>modform</code>. If not found in <code>data</code>, the variables are
taken from current environment.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree to be indicated for any model except if
<code>RRphylo</code> is used to rescale tree branches. The tree needs not to be
ultrametric and fully dichotomous.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_rr">RR</code></td>
<td>
<p>the result of <code>RRphylo</code> performed on the response variable. If
<code>RR</code> is specified, tree branches are rescaled to the absolute
branch-wise rate values calculated by <code>RRphylo</code> to transform the
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_gitransform">GItransform</code></td>
<td>
<p>logical indicating whether the PGLS approach as in Garland
and Ives (2000) must be applied.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_intercept">intercept</code></td>
<td>
<p>under <code>GItransform = TRUE</code>, indicates whether the
intercept should be included in the model.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_model">model</code></td>
<td>
<p>an evolutionary model as indicated in
<code><a href="phylolm.html#topic+phylolm">phylolm</a></code> (for univariate response variable) or
<code><a href="mvMORPH.html#topic+mvgls">mvgls</a></code> (for multivariate response variable).</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_method">method</code></td>
<td>
<p>optional argument to be passed to <code>phylolm</code> (for
univariate response variable) or <code>mvgls</code> (for multivariate response
variable). See individual functions for further details.</p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_permutation">permutation</code></td>
<td>
<p>passed to <code><a href="mvMORPH.html#topic+manova.gls">manova.gls</a></code></p>
</td></tr>
<tr><td><code id="PGLS_fossil_+3A_...">...</code></td>
<td>
<p>further argument passed to <code>phylolm</code>, <code>mvgls</code>,
<code>manova.gls</code>, or <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is meant to work with both univariate or multivariate
data, both low- or high-dimensional. In the first case, <code>PGLS_fossil</code>
uses <code>phylolm</code>, returning an object of class &quot;phylolm&quot;. In the latter,
regression coefficients are estimated by <code>mvgls</code>, and statistical
significance is obtained by means of permutations within <code>manova.gls</code>.
In this case, <code>PGLS_fossil</code> returns a list including the output of
both analyses. In all cases, for both univariate or multivariate data, if
<code>GItransform = TRUE</code> the functions returns a standard <code>lm</code>
output. In the latter case, the output additionally includes the result of
manova applied on the multivariate linear model.
</p>


<h3>Value</h3>

<p>Fitted pgls parameters and significance. The class of the output
object depends on input data (see details).
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio, Gabriele Sansalone,
Giorgia Girardi
</p>


<h3>References</h3>

<p>Garland, Jr, T., &amp; Ives, A. R. (2000). Using the past to predict
the present: confidence intervals for regression equations in phylogenetic
comparative methods. <em>The American Naturalist</em>, 155: 346-364.
doi:10.1086/303327
</p>


<h3>See Also</h3>

<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a>;
<code><a href="mvMORPH.html#topic+mvgls">mvgls</a></code> ; <code><a href="mvMORPH.html#topic+manova.gls">manova.gls</a></code>
;<code><a href="phylolm.html#topic+phylolm">phylolm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ape)
library(phytools)
cc&lt;- 2/parallel::detectCores()

rtree(100)-&gt;tree
fastBM(tree)-&gt;resp
fastBM(tree,nsim=3)-&gt;resp.multi
fastBM(tree)-&gt;pred1
fastBM(tree)-&gt;pred2

PGLS_fossil(modform=resp~pred1+pred2,tree=tree)-&gt;pgls_noRR
PGLS_fossil(modform=resp~pred1+pred2,tree=tree,GItransform=TRUE)-&gt;GIpgls_noRR

RRphylo(tree,resp,clus=cc)-&gt;RR
PGLS_fossil(modform=resp~pred1+pred2,tree=tree,RR=RR)-&gt;pgls_RR
PGLS_fossil(modform=resp~pred1+pred2,tree=tree,RR=RR,GItransform=TRUE)-&gt;GIpgls_RR

# To derive log-likelihood and AIC for outputs of PGLS_fossil applied on univariate
# response variables the function AIC can be applied
AIC(pgls_noRR)
AIC(pgls_RR)
AIC(GIpgls_noRR)
AIC(GIpgls_RR)


PGLS_fossil(modform=resp.multi~pred1+pred2,tree=tree)-&gt;pgls2_noRR
PGLS_fossil(modform=resp.multi~pred1+pred2,tree=tree,GItransform=TRUE)-&gt;GIpgls2_noRR

# To evaluate statistical significance of multivariate models, the '$manova'
# object must be inspected
pgls2_noRR$manova
summary(GIpgls2_noRR$manova)

RRphylo(tree,resp.multi,clus=cc)-&gt;RR
PGLS_fossil(modform=resp.multi~pred1+pred2,tree=tree,RR=RR)-&gt;pgls2_RR
PGLS_fossil(modform=resp.multi~pred1+pred2,tree=tree,RR=RR,GItransform=TRUE)-&gt;GIpgls2_RR

# To evaluate statistical significance of multivariate models, the '$manova'
# object must be inspected
pgls2_noRR$manova
summary(GIpgls2_noRR$manova)
pgls2_RR$manova
summary(GIpgls2_RR$manova)

logLik(pgls2_noRR$pgls)
logLik(pgls2_RR$pgls)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyloclust'>Test for phylogenetic clustering</h2><span id='topic+phyloclust'></span>

<h3>Description</h3>

<p>The function tests the presence of phylogenetic clustering for
species within a focal state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloclust(tree,state,focal,nsim=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloclust_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous.</p>
</td></tr>
<tr><td><code id="phyloclust_+3A_state">state</code></td>
<td>
<p>the named vector of tip states.</p>
</td></tr>
<tr><td><code id="phyloclust_+3A_focal">focal</code></td>
<td>
<p>the focal state to be tested for phylogenetic clustering.</p>
</td></tr>
<tr><td><code id="phyloclust_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform the phylogenetic clustering
test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test for phylogenetic clustering, the function computes the mean
cophenetic (i.e. evolutionary time) distance between all the species under
the <code>focal</code> state. Such value is compared to a random distribution of
time distances obtained by sampling <code>nsim</code> times as many random tips
as those under the <code>focal</code> state. In the presence of significant
phylogenetic clustering, tips under the <code>focal</code> state are randomly
removed until the <code>p</code> becomes &gt;0.05 or only 3 tips are left.
</p>


<h3>Value</h3>

<p>The function returns a list including the p-value ($p) for the test
of phylogenetic clustering and a $declusterized object containing the
declusterized versions of the original tree and state vector (i.e. tips are
removed as to make p&gt;0.05) and the vector of removed species.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DataFelids")
DataFelids$treefel-&gt;treefel
DataFelids$statefel-&gt;statefel

phyloclust(tree=treefel,state=statefel,focal="saber")
</code></pre>

<hr>
<h2 id='plotConv'>Graphical representation of search.conv results</h2><span id='topic+plotConv'></span>

<h3>Description</h3>

<p>This function generates customized functions to produce plots out of
<code><a href="#topic+search.conv">search.conv</a></code> results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConv(SC,y,variable,RR=NULL,state=NULL,aceV=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotConv_+3A_sc">SC</code></td>
<td>
<p>an object produced by <code><a href="#topic+search.conv">search.conv</a></code>.</p>
</td></tr>
<tr><td><code id="plotConv_+3A_y">y</code></td>
<td>
<p>the multivariate phenotype used to perform <code>search.conv</code>.</p>
</td></tr>
<tr><td><code id="plotConv_+3A_variable">variable</code></td>
<td>
<p>the index of result to plot. If convergence between clades is
inspected, this is the position within the <code>SC$'average distance from
group centroids'</code> vector of the clade pair to be plotted. In the case of
convergence between states, this is the number of the line of
<code>SC$state.res</code> where results for the state pair are returned.</p>
</td></tr>
<tr><td><code id="plotConv_+3A_rr">RR</code></td>
<td>
<p>the object produced by <code><a href="#topic+RRphylo">RRphylo</a></code> used to perform
<code>search.conv</code>. This is not indicated if convergence between states is
tested.</p>
</td></tr>
<tr><td><code id="plotConv_+3A_state">state</code></td>
<td>
<p>the named vector of tip states used to perform <code>search.conv</code>.
This is not indicated if convergence between clades is tested.</p>
</td></tr>
<tr><td><code id="plotConv_+3A_acev">aceV</code></td>
<td>
<p>phenotypic values at internal nodes to be provided if used to
perform <code>search.conv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If convergence between clades was tested, <code>plotConv</code> returns a
list of four functions:
</p>
<p><strong><code>$plotHistTips</code></strong> shows the mean Euclidean distance
computed between phenotypic vectors of all the tips belonging to the
converging clades as compared to the distribution of distances between all
possible pair of tips across the rest of the tree. The usage is:
<code>...$plotHistTips(hist.args=NULL,line.args=NULL)</code>, where
<code>hist.args</code> is a list of further arguments passed to the function
<code>hist</code>, and <code>line.args</code> is a list of further arguments passed to
the function <code>lines</code>.
</p>
<p><strong><code>$plotHistAces</code></strong> shows the Euclidean distance computed
between phenotypic vectors of the MRCAs of the converging clades as compared
to the distribution of distances between all possible pairs of nodes across
the rest of the tree. The usage is identical to <code>$plotHistTips</code>.
</p>
<p><strong><code>$plotPChull</code></strong> generates a PC1/PC2 plot obtained by
performing a PCA of the species phenotypes. Convergent clades are indicated
by colored convex hulls. Large dots represent the mean phenotypes per clade
(i.e. their group centroids) and asterisks (customizable) represent the
ancestral phenotypes of the individual clades. The usage is:
<code>...$plotPChull(plot.args=NULL,chull.args=NULL,means.args=NULL,</code>
<code>ace.args=NULL,legend.args=list()</code>,where <code>plot.args</code> is a list of
further arguments passed to the function <code>plot</code>, <code>chull.args</code> is a
list of further arguments passed to the function <code>polygon</code>,
<code>means.args</code> and <code>ace.args</code> are lists of further argument passed
to the function <code>points</code> to customize the dots representing the
centroids and the ancestral phenotypes respectively, and <code>legend.args</code>
is a list of additional arguments passed to the function <code>legend</code> (if
<code>= NULL</code> the legend is not plotted).
</p>
<p><strong><code>$plotTraitgram</code></strong> produces a modified traitgram plot (see
package <span class="pkg">picante</span>) highlighting the branches of the clades found to
converge. The usage is:
<code>plotTraitgram(colTree=NULL,colNodes=NULL,...)</code>, where <code>colTree</code>
is the color to represent the traitgram lines not pertaining the converging
clades, <code>colNodes</code> is the color (or the vector of colors) to represent
the traitgram lines pertaining the converging clades, and <code>...</code> are
further arguments passed to the function <code>plot</code> to plot lines.
</p>
<p>If convergence between states was tested, <code>plotConv</code> returns a
list of two functions:
</p>
<p><strong><code>$plotPChull</code></strong> generates a PC1/PC2 plot obtained by
performing a PCA of the species phenotypes, with colored convex hulls
enclosing species belonging to different states. The usage is:
<code>...$plotPChull(plot.args=NULL,chull.args=NULL,points.args=NULL,</code>
<code>legend.args=list()</code>, where <code>plot.args</code> is a list of further
arguments passed to the function <code>plot</code>, <code>chull.args</code> is a list of
further arguments passed to the function <code>polygon</code>, <code>points.args</code>
is a list of further argument passed to the function <code>points</code>, and
<code>legend.args</code> is a list of additional arguments passed to the function
<code>legend</code> (if <code>= NULL</code> the legend is not plotted).
</p>
<p><strong><code>$plotPolar</code></strong> produces a polar plot of the mean angle
within/between state/s as compared to the 95
angles. The usage is:
<code>...$plotPolar(polar.args=NULL,polygon.args=NULL,line.args=NULL)</code>,
where <code>polar.args</code> is a list of further arguments passed to the
function <code><a href="plotrix.html#topic+polar.plot">polar.plot</a></code> to set the plot basics (i.e.
<code>radial.lim</code>, <code>start</code>, and so on), <code>polygon.args</code> is a list
of further arguments passed to the function <code>polar.plot</code> under the
condition <code>rp.type="p"</code> (see <code>plotrix::polar.plot</code> for details) to
set the angles distribution graphics, and <code>line.args</code> is a list of
further arguments passed to the function <code>polar.plot</code> under the
condition <code>rp.type="r"</code> to set the mean angle graphics.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Tamagnini, D., Melchionna, M.,
Mondanaro, A., Di Febbraro, M., Profico, A., Piras, P.,Barattolo, F., &amp;
Raia, P. (2019). A new, fast method to search for morphological convergence
with shape data. <em>PLoS ONE</em>, 14, e0226949.
https://doi.org/10.1371/journal.pone.0226949
</p>


<h3>See Also</h3>

<p><a href="../doc/search.conv.html"><code>search.conv</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotConv</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataFelids")
DataFelids$PCscoresfel-&gt;PCscoresfel
DataFelids$treefel-&gt;treefel
DataFelids$statefel-&gt;statefel-&gt;state2
state2[sample(which(statefel=="nostate"),20)]&lt;-"st2"
cc&lt;- 2/parallel::detectCores()

RRphylo(treefel,PCscoresfel,clus=cc)-&gt;RRfel

search.conv(RR=RRfel, y=PCscoresfel, min.dim=5, min.dist="node9",clus=cc)-&gt;sc_clade
plotConv(sc_clade,PCscoresfel,variable=2,RR=RRfel)-&gt;pc

pc$plotHistTips(hist.args = list(col="gray80",yaxt="n",cex.axis=0.8,cex.main=1.5),
                line.args = list(lwd=3,lty=4,col="purple"))
pc$plotHistAces(hist.args = list(col="gray80",cex.axis=0.8,cex.main=1.5),
                line.args = list(lwd=3,lty=4,col="gold"))
pc$plotPChull(chull.args = list(border=c("cyan","magenta"),lty=1),
              means.args = list(pch=c(23,22),cex=3,bg=c("cyan2","magenta2")),
              ace.args=list(pch=9),legend.args = NULL)
pc$plotTraitgram(colTree = "gray70",colNodes = c("cyan","magenta"))


search.conv(tree=treefel, y=PCscoresfel, state=statefel,declust=TRUE,clus=cc)-&gt;sc_state
plotConv(sc_state,PCscoresfel,variable=1,state=statefel)-&gt;pc
pc$plotPChull(chull.args = list(border=c("gray70","blue"),lty=1),
              points.args = list(pch=c(23,22),bg="gray"),
              legend.args = list(pch=c(23,22),x="top"))

pc$plotPolar(polar.args = list(clockwise=TRUE,start=0,rad.col="black",grid.col="black"),
             polygon.args = list(line.col="green",poly.col=NA,lwd=2),
             line.args = list(line.col="deeppink",lty=2,lwd=3))

    
## End(Not run)
</code></pre>

<hr>
<h2 id='plotRates'>Plot RRphylo rates at a specified node</h2><span id='topic+plotRates'></span>

<h3>Description</h3>

<p>This function generates customized functions to produce
histograms and lollipop charts of the <code><a href="#topic+RRphylo">RRphylo</a></code> rates computed
for a given clade as compared to the rates computed for the rest of the
tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRates(RR,node,export.tiff=NULL,filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRates_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="plotRates_+3A_node">node</code></td>
<td>
<p>the node subtending the clade of interest.</p>
</td></tr>
<tr><td><code id="plotRates_+3A_export.tiff">export.tiff</code></td>
<td>
<p>is deprecated.</p>
</td></tr>
<tr><td><code id="plotRates_+3A_filename">filename</code></td>
<td>
<p>is deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of functions:
</p>
<p><strong>$plotHist</strong> returns the histograms of rates (in ln absolute
values) computed for the focal clade against rates computed the rest of the
tree. The usage is:
<code>...$plotHist(hist.args=list(col1,col2),legend.args=list())</code>, where
<code>legend.args</code> is a list of additional arguments passed to the function
<code>legend</code> (if <code>= NULL</code> the legend is not plotted) and
<code>hist.args</code> is a list of further arguments passed to the function
<code>plot.histogram</code>. <code>hist.args</code> default arguments include histogram
colors for background rates (<code>col1</code>) and rates of the clade under
inspection (<code>col2</code>).
</p>
<p><strong>$plotLollipop</strong> returns the lollipop chart of the rates of
individual branches of the focal clade collated in increasing rate value,
and contrasted to the average rate computed over the rest of the tree
branches (the vertical line). The usage is:
<code>...$plotLollipop(lollipop.args=NULL,line.args=NULL)</code>, where
<code>lollipop.args</code> is a list of further arguments passed to the function
<code><a href="#topic+lollipoPlot">lollipoPlot</a></code>  and <code>line.args</code> is a list of additional
arguments passed to the function <code>line</code>. This function additionally
returns the vector of rates for the focal clade, collated in increasing
order.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia
</p>


<h3>See Also</h3>

<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotRates</code> vignette</a>
</p>
<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotRates</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("DataApes")
DataApes$PCstage-&gt;PCstage
DataApes$Tstage-&gt;Tstage
cc&lt;- 2/parallel::detectCores()

RRphylo(tree=Tstage,y=PCstage,clus=cc)-&gt;RR

plotRates(RR,node=72)-&gt;pR
pR$plotHist(hist.args=list(col1="cyan1",col2="blue"),legend.args=list(x="topright"))
pR$plotLollipop(lollipop.args=list(col="chartreuse",bg="chartreuse"),
                line.args=list(col="deeppink",lwd=2))

</code></pre>

<hr>
<h2 id='plotRR'>Plot the RRphylo output onto the phylogenetic tree</h2><span id='topic+plotRR'></span>

<h3>Description</h3>

<p>This function generates customized functions to plot the
phylogenetic tree (as returned by <code><a href="#topic+RRphylo">RRphylo</a></code>) with branches
colored according to phenotypic values or phenotypic evolutionary rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRR(RR,y,multivariate=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRR_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code>RRphylo</code>.</p>
</td></tr>
<tr><td><code id="plotRR_+3A_y">y</code></td>
<td>
<p>the vector/matrix of phenotypic values used to perform
<code>RRphylo</code>.</p>
</td></tr>
<tr><td><code id="plotRR_+3A_multivariate">multivariate</code></td>
<td>
<p>if <code>RRphylo</code> was performed on multivariate data, this
argument indicates whether individual rates for each variables (<code>=
"multiple.rates"</code>) or the norm2 vector of multivariate rates (<code>=
"rates"</code>) should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of functions:
</p>
<p><strong>$plotRRphen</strong> charts phenotypic values along the tree branches.
Phenotypes at tips are taken as they are from the <code>y</code> object.
Phenotypic values for internal branches are derived from the <code>RR$aces</code>
object. The usage is:
<code>...$plotRRphen(variable=NULL,tree.args=NULL,color.pal=NULL,colorbar.args=list())</code>,
where <code>variable</code> is the index or name of the variable to be plotted in
case of multivariate data, <code>tree.args</code> is a list of further arguments
passed to the function <code>plot.phylo</code>, <code>color.pal</code> is a function to
generate the color palette, and <code>colorbar.args</code> is a list of further
arguments passed to the function <code><a href="#topic+colorbar">colorbar</a></code> (if <code>= NULL</code>
the bar is not plotted).
</p>
<p><strong>$plotRRrates</strong> charts evolutionary rate values along the tree
branches. The usage is identical to <code>$plotRRphen</code>. In case of
multivariate data and <code>multivariate = "rates"</code>, the argument
<code>variable</code> can be left unspecified.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia
</p>


<h3>See Also</h3>

<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a>
</p>
<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotRR</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataApes")
DataApes$PCstage-&gt;PCstage
DataApes$Tstage-&gt;Tstage
cc&lt;- 2/parallel::detectCores()

RRphylo(tree=Tstage,y=PCstage,clus=cc)-&gt;RR

plotRR(RR,y=PCstage,multivariate="multiple.rates")-&gt;pRR
pRR$plotRRphen(variable=1,tree.args=list(edge.width=2),color.pal=rainbow,
               colorbar.args = list(x="bottomleft",labs.adj=0.7,xpd=TRUE))
pRR$plotRRrates(variable=2,tree.args=list(edge.width=2,direction="leftwards"),
                color.pal=rainbow,colorbar.args = list(x="topright",labs.adj=0.7,xpd=TRUE))


plotRR(RR,y=PCstage,multivariate="rates")-&gt;pRR
pRR$plotRRrates(tree.args=list(edge.width=2),
                color.pal=hcl.colors,
                colorbar.args = list(x="topleft",labs.adj=0.7,xpd=TRUE,title.pos="bottom"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotShift'>Graphical representation of search.shift results</h2><span id='topic+plotShift'></span><span id='topic+addShift'></span>

<h3>Description</h3>

<p><code>plotShift</code> generates customized functions to produce plots
out of <code><a href="#topic+search.shift">search.shift</a></code> results.
<code>addShift</code> adds circles to highlight shifting clades onto the currently
plotted tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotShift(RR,SS,state=NULL)

addShift(SS,symbols.args=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotShift_+3A_rr">RR</code></td>
<td>
<p>the object produced by <code><a href="#topic+RRphylo">RRphylo</a></code> used to perform
<code>search.shift</code>.</p>
</td></tr>
<tr><td><code id="plotShift_+3A_ss">SS</code></td>
<td>
<p>an object produced by <code>search.shift</code>.</p>
</td></tr>
<tr><td><code id="plotShift_+3A_state">state</code></td>
<td>
<p>if <code>search.shift</code> was performed under <code>status.type =
"sparse"</code>, this is the same <code>state</code> vector provided to the function.</p>
</td></tr>
<tr><td><code id="plotShift_+3A_symbols.args">symbols.args</code></td>
<td>
<p>as described for <code>$plotClades</code> below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>...$plotClades()</code> or plotting the tree and applying
<code>addShift()</code> returns the same plot. The latter function might be useful
in combination with <code><a href="#topic+plotRR">plotRR</a></code> to add the shifts information to the
branch-wise plot of evolutionary rate values.
</p>


<h3>Value</h3>

<p>The function returns a function to generate a customizable plot of
<code>search.shift</code> results.
</p>
<p>If <code>search.shift</code> was performed under <code>status.type =
 "clade"</code>, <code>plotShift</code> returns a <strong><code>$plotClades</code></strong> function
which highlights the shifting clades onto the phylogenetic tree. The usage
is: <code>...$plotClades(tree.args=NULL,symbols.args=NULL)</code>, where
<code>tree.args</code> is a list of further arguments passed to the function
<code>plot.phylo</code>, and <code>symbols.args</code> is a list of further arguments
passed to the function <code>symbols</code> (n.b. the shape of the symbol is not
customizable). The function automatically plots red circles for negative
shifts and blue circles for positive shifts, in each cases with the radium
proportional to the absolute value of rate difference. The user can choose
different color options for positive/negative shifts by setting
<code>symbols.args=list(fg=c(pos="color for positive shift",neg="color for
 negative shift"))</code>, or provide a vector of as many colors as the number of
shifting clades. The same applies to the argument &quot;bg&quot;.
</p>
<p>If <code>search.shift</code> was performed under <code>status.type =
 "sparse"</code>, <code>plotShift</code> returns a <strong><code>$plotStates</code></strong> function
which plots the states onto the phylogenetic trees. The usage is:
<code>...$plotStates(tree.args=NULL,points.args=NULL,legend.args=list())</code>,
where <code>tree.args</code> is a list of further arguments passed to the function
<code>plot.phylo</code>, <code>points.args</code> is a list of further arguments passed
to the function <code>points</code>, and <code>legend.args</code> is a list of
additional arguments passed to the function <code>legend</code> (if <code>= NULL</code>
the legend is not plotted). If as many colors/pch values as the number of
different states are provided in <code>points.args</code>, each of them is
assigned to each states taken in the same order they are returned by
<code>search.shift</code>.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione
</p>


<h3>References</h3>

<p>Castiglione, S., Tesone, G., Piccolo, M., Melchionna, M.,
Mondanaro, A., Serio, C., Di Febbraro, M., &amp; Raia, P.(2018). A new method
for testing evolutionary rate variation and shifts in phenotypic evolution.
<em>Methods in Ecology and Evolution</em>, 9:
974-983.doi:10.1111/2041-210X.12954
</p>


<h3>See Also</h3>

<p><a href="../doc/search.shift.html"><code>search.shift</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotShift</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
DataOrnithodirans$statedino-&gt;statedino
cc&lt;- 2/parallel::detectCores()

RRphylo(tree=treedino,y=massdino,clus=cc)-&gt;dinoRates

search.shift(RR=dinoRates,status.type="clade")-&gt;SSauto
plotShift(RR=dinoRates,SS=SSauto)-&gt;plotSS
plotSS$plotClades()

plot(dinoRates$tree)
addShift(SS=SSauto)

search.shift(RR=dinoRates,status.type="clade",node=c(696,746))-&gt;SSnode
plotShift(RR=dinoRates,SS=SSnode)-&gt;plotSS
plotSS$plotClades(tree.args=list(no.margin=TRUE),
                  symbols.args=list(fg=NA,bg=c(pos="cyan",neg="magenta")))


search.shift(RR=dinoRates,status.type= "sparse",state=statedino)-&gt;SSstate
plotShift(RR=dinoRates,SS=SSstate,state=statedino)-&gt;plotSS
plotSS$plotStates(tree.args=list(no.margin=TRUE),
                  points.args=list(bg=c("gold","forestgreen","royalblue","white"),
                                   col=c("black","black","black","orangered"),
                                   pch=c(21,22,24,11)),legend.args=list())
    
## End(Not run)
</code></pre>

<hr>
<h2 id='plotTrend'>Graphical representation of search.trend results</h2><span id='topic+plotTrend'></span>

<h3>Description</h3>

<p>This function generates customized functions to produce plots of
phenotype versus time and absolute evolutionary rates versus time
regressions for the entire phylogeny and individual clades. Each custom
function takes as first argument the index or name of the variable (as in
the <code>search.trend</code> output in <code>$trends.data$phenotypeVStime</code>) to be
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrend(ST)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrend_+3A_st">ST</code></td>
<td>
<p>an object produced by <code><a href="#topic+search.trend">search.trend</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of functions:
</p>
<p><strong><code>$plotSTphen</code></strong> returns the plot of rescaled phenotype versus age
regression. The 95% confidence intervals of slopes produced by regressing
phenotypes simulated under the Brownian motion are plotted as a polygon. The
usage is
<code>...$plotSTphen(variable,plot.args=NULL,polygon.args=NULL,line.args=NULL)</code>,
where <code>variable</code> is the index or name of the variable to be plotted,
<code>plot.args</code> is a list of further arguments passed to the function
<code>plot</code>, <code>polygon.args</code> is a list of further arguments passed to
the function <code>polygon</code>, and <code>line.args</code> is a list of further
arguments passed to the function <code>lines</code>. The functions automatically
plots white points for internal nodes, red points for tips, a blue
regression line, and a gray shaded polygon to represent the 95% confidence
intervals of Brownian motion slopes.
</p>
<p><strong><code>$plotSTrates</code></strong> returns the plot of log rescaled rates versus age
regression. The 95% confidence intervals of slopes produced by regressing
rates simulated under the Brownian motion are plotted as a shaded area. The
arguments are the same as described for <code>$plotSTphen</code>. In the case of
multivariate <code>y</code>, the 2-norm vector of multiple rates (see
<code><a href="#topic+RRphylo">RRphylo</a></code> for details) can be plotted by setting <code>variable
 = "rate"</code> or <code>variable = </code> the number of actual variables + 1.
</p>
<p><strong><code>$plotSTphenNode</code></strong> returns plots of rescaled phenotype versus age
regression for individual clades. The usage is
<code>...$plotSTphenNode(variable,node,plot.args=NULL,lineTree.args=NULL,</code>
<code>lineNode.args=NULL,node.palette=NULL)</code>, where <code>variable</code> is the
same as <code>plotSTphen</code> and <code>node</code> is the vector of indices or numbers
(as inputted to <code>search.trend</code>, to be indicated as character) of nodes
to be plotted. The function allows up to nine nodes at the same time.
<code>plot.args</code> is a list of further arguments passed to the function
<code>plot</code>, including <code>pch.node</code>, a custom argument to set individual
<code>pch</code> at nodes (its length can be one or as long as the number of
nodes). <code>lineTree.args</code> is a list of further arguments passed to the
function <code>lines</code> used to plot the regression line for the entire tree
<code>lineNode.args</code> is a list of further arguments passed to the function
<code>lines</code> used to plot the regression line for individual nodes.
<code>node.palette</code> is the vector of colors specific to nodes points and
lines. Its length can be one or as long as the number of nodes.
</p>
<p><strong><code>$plotSTratesNode</code></strong> returns plots of absolute rates versus age
regression for individual clades. The arguments are the same as described
for <code>$plotSTphenNode</code>. In the case of multivariate <code>y</code>, the 2-norm
vector of multiple rates (see <code><a href="#topic+RRphylo">RRphylo</a></code> for details) can be
plotted by setting <code>variable = "rate"</code> or <code>variable = </code> the number
of actual variables + 1.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Mondanaro, A., Di Febbraro, M.,
Profico, A., Girardi, G., &amp; Raia, P. (2019) Simultaneous detection of
macroevolutionary patterns in phenotypic means and rate of change with and
within phylogenetic trees including extinct species. <em>PLoS ONE</em>, 14:
e0210101. https://doi.org/10.1371/journal.pone.0210101
</p>


<h3>See Also</h3>

<p><a href="../doc/search.trend.html"><code>search.trend</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotTrend</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
cc&lt;- 2/parallel::detectCores()

# Extract Pterosaurs tree and data
library(ape)
extract.clade(treedino,746)-&gt;treeptero
massdino[match(treeptero$tip.label,names(massdino))]-&gt;massptero
massptero[match(treeptero$tip.label,names(massptero))]-&gt;massptero

RRphylo(tree=treeptero,y=log(massptero),clus=cc)-&gt;RRptero

search.trend(RR=RRptero, y=log(massptero), nsim=100, node=143, clus=cc,cov=NULL)-&gt;ST

plotTrend(ST)-&gt;plotST

plotST$plotSTphen(1) # to plot phenotypic trend through time for entire tree
plotST$plotSTphen("log(massptero)",plot.args=list(cex=1.2,col="blue")) # equivalent to above

plotST$plotSTrates(1) # to plot rates trend through time for entire tree

# to plot phenotypic trend through time for the clade
plotST$plotSTphenNode("log(massptero)",plot.args=list(xlab="Age",main="Phenotypic trend"),
                    lineTree.args=list(lty=1,col="pink"),lineNode.args=list(lwd=3),
                    node.palette=c("chartreuse"))

# to plot rates trend through time for the clade
plotST$plotSTratesNode("rate")

   
## End(Not run)
</code></pre>

<hr>
<h2 id='random.evolvability.test'>Randomization test for phylogenetic structuring in evolvability</h2><span id='topic+random.evolvability.test'></span>

<h3>Description</h3>

<p>The function is a wrapper around the function
<code><a href="evolqg.html#topic+MeanMatrixStatistics">MeanMatrixStatistics</a></code> from the package <span class="pkg">evolqg</span> (<cite>Melo et
al. 2015</cite>). It estimates ancestral character at internal nodes either
according to Brownian Motion or by means of <code><a href="#topic+RRphylo">RRphylo</a></code> (see the
argument <code>node.estimation</code>), then performs <code>MeanMatrixStatistics</code>
to calculate: Mean Squared Correlation, ICV, Autonomy,
ConditionalEvolvability, Constraints, Evolvability, Flexibility,
Pc1Percent, and Respondability. To assess the importance of phylogenetic
structuring (signal) on Respondability Evolvability, and Flexibility. The
function performs a randomization test by randomly shuffling the species on
tree and replicating the analyses <code>nsim</code> times. A p-value is computed
by contrasting the real metrics to the ones derived by randomization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.evolvability.test(tree,data,node.estimation=c("RR","BM"),
  aces=NULL,iterations=1000,nsim=100,clus=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.evolvability.test_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous.</p>
</td></tr>
<tr><td><code id="random.evolvability.test_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame of phenotypic data having species as rownames</p>
</td></tr>
<tr><td><code id="random.evolvability.test_+3A_node.estimation">node.estimation</code></td>
<td>
<p>specify the method to compute ancestral character at
nodes. It can be one of <code>"RR"</code>, to compute ancestral states by mean of
<code>RRphylo</code>, or <code>"BM"</code>, to use <span class="pkg">phytools</span>' function <code>fastAnc</code>
(<cite>Paradis &amp; Schliep 2019</cite>) to estimate ancestral characters at nodes
according to Brownian Motion.</p>
</td></tr>
<tr><td><code id="random.evolvability.test_+3A_aces">aces</code></td>
<td>
<p>a named matrix of known ancestral character values at nodes.
Names correspond to the nodes in the tree.</p>
</td></tr>
<tr><td><code id="random.evolvability.test_+3A_iterations">iterations</code></td>
<td>
<p>the iterations argument to be indicated in
<code>MeanMatrixStatistics</code></p>
</td></tr>
<tr><td><code id="random.evolvability.test_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to be performed for the randomization
test, by default <code>nrep</code> is set at 100.</p>
</td></tr>
<tr><td><code id="random.evolvability.test_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>NOME</code> set <code>clus</code> = 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list object including (<code>$means</code>) the mean
values for all statistics as produced by <code>MeanMatrixStatistics</code> and
(<code>$means</code>) the significance levels for Respondability, Evolvability,
and Flexibility.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Gabriele Sansalone, Pasquale Raia
</p>


<h3>References</h3>

<p>Melo, D., Garcia, G., Hubbe, A., Assis, A. P., &amp; Marroig, G.
(2015). EvolQG-An R package for evolutionary quantitative genetics.
<em>F1000Research</em>, 4.
</p>
<p>Revell, L. J. (2012) phytools: An R package for phylogenetic
comparative biology (and other things).
<em>Methods in Ecology and Evolution</em>, 3, 217-223.
</p>


<h3>See Also</h3>

<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 library(ape)
 library(phytools)

 rtree(30)-&gt;tree
 fastBM(tree,nsim=4)-&gt;y

 random.evolvability.test(tree=tree,data=y,node.estimation="RR")-&gt;rEvTest

    
## End(Not run)
</code></pre>

<hr>
<h2 id='rate.map'>Mapping rate and direction of phenotypic change on 3D surfaces.</h2><span id='topic+rate.map'></span>

<h3>Description</h3>

<p>Given vectors of RW (or PC) scores, the function selects the
RW(PC) axes linked to highest (and lowest) evolutionary rate values and
reconstructs the morphology weighted on them. In this way, <code>rate.map</code>
shows where and how the phenotype changed the most between any pair of
taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate.map(x, RR, PCscores, pcs, mshape, out.rem = TRUE,
  shape.diff=FALSE, show.names=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate.map_+3A_x">x</code></td>
<td>
<p>the species/nodes to be compared; it can be a single species, or a
vector containing two species or a species and any of its parental nodes.</p>
</td></tr>
<tr><td><code id="rate.map_+3A_rr">RR</code></td>
<td>
<p>an object generated by using the <code><a href="#topic+RRphylo">RRphylo</a></code> function</p>
</td></tr>
<tr><td><code id="rate.map_+3A_pcscores">PCscores</code></td>
<td>
<p>PC scores.</p>
</td></tr>
<tr><td><code id="rate.map_+3A_pcs">pcs</code></td>
<td>
<p>RW (or PC) vectors (eigenvectors of the covariance matrix) of all
the samples.</p>
</td></tr>
<tr><td><code id="rate.map_+3A_mshape">mshape</code></td>
<td>
<p>the Consensus configuration.</p>
</td></tr>
<tr><td><code id="rate.map_+3A_out.rem">out.rem</code></td>
<td>
<p>logical: if <code>TRUE</code> mesh triangles with outlying area
difference are removed.</p>
</td></tr>
<tr><td><code id="rate.map_+3A_shape.diff">shape.diff</code></td>
<td>
<p>logical: if <code>TRUE</code>, the mesh area differences are
displayed in an additional 3d plot.</p>
</td></tr>
<tr><td><code id="rate.map_+3A_show.names">show.names</code></td>
<td>
<p>logical: if <code>TRUE</code>, the names of the species are
displayed in the 3d plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After selecting the PC axes, <code>rate.map</code> automatically builds a
3D mesh on the mean shape calculated from the Relative Warp Analysis (RWA)
or Principal Component Analysis (PCA) (<cite>Schlager 2017</cite>) by applying
the function <code><a href="Rvcg.html#topic+vcgBallPivoting">vcgBallPivoting</a></code> (<span class="pkg">Rvcg</span>). Then, it
compares the area differences between corresponding triangles of the 3D
surfaces reconstructed for the species and surface of the mrca. Finally,
<code>rate.map</code> returns a 3D plot showing such comparisons displayed on
shape of the mrca used as the reference.The colour gradient goes from blue
to red, where blue areas represent expansion of the mesh, while the red
areas represent contractions of the mesh triangles. In the calculation of
the differences of areas we supply the possibility to find and remove
outliers from the vectors of areas calculated on the reference and target
surfaces. We suggest considering this possibility if the mesh may contain
degenerate facets. Additionally, <code>rate.map</code> allows to investigate the
pure morphological comparison of shapes by excluding the evolutionary rate
component by setting the argument <code>show.diff  = TRUE</code>. In this case, a
second 3D plot will be displayed highlighting area differences in terms of
expansion (green) and contraction (yellow).
</p>


<h3>Value</h3>

<p>The function returns a list including:
</p>
<ul>
<li><p><strong>$selected</strong> a list of PCs axes selected for higher
evolutionary rates for each species. </p>
</li>
<li><p><strong>$surfaces</strong> a list of
reconstructed coloured surfaces of the given species and of the most recent
common ancestor.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marina Melchionna, Antonio Profico, Silvia Castiglione, Gabriele
Sansalone, Pasquale Raia
</p>


<h3>References</h3>

<p>Schlager, S. (2017). <em>Morpho and Rvcg-Shape Analysis in R:
R-Packages for geometric morphometrics, shape analysis and surface
manipulations.</em> In: Statistical shape and deformation analysis. Academic
Press.
Castiglione, S., Melchionna, M., Profico, A., Sansalone, G.,
Modafferi, M., Mondanaro, A., Wroe, S., Piras, P., &amp; Raia, P. (2021). Human
face-off: a new method for mapping evolutionary rates on three-dimensional
digital models. Palaeontology. doi:10.1111/pala.12582
</p>


<h3>See Also</h3>

<p><a href="../doc/RRphylo.html"><code>RRphylo</code> vignette</a> ;
<code><a href="Morpho.html#topic+relWarps">relWarps</a></code> ; <code><a href="Morpho.html#topic+procSym">procSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  data(DataSimians)
  DataSimians$pca-&gt;pca
  DataSimians$tree-&gt;tree
  dato&lt;-pca$PCscores
  cc&lt;- 2/parallel::detectCores()

  RRphylo(tree,dato,clus=cc)-&gt;RR

  Rmap&lt;-rate.map(x=c("Pan_troglodytes","Gorilla_gorilla"),RR=RR, PCscores=dato,
                 pcs=pca$PCs, mshape=pca$mshape, shape.diff = TRUE)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='rescaleRR'>Rescaling phylogenetic trees</h2><span id='topic+rescaleRR'></span>

<h3>Description</h3>

<p>The function rescales all branches and leaves of the
phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleRR(tree,RR=NULL,height=NULL,trend=NULL,delta=NULL,kappa=NULL,lambda=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleRR_+3A_tree">tree</code></td>
<td>
<p>the phylogenetic tree to be rescaled.</p>
</td></tr>
<tr><td><code id="rescaleRR_+3A_rr">RR</code></td>
<td>
<p>is the output of <code>RRphylo</code> performed on <code>tree</code>. If this
parameter is indicated, the tree branches are rescaled according to
branch-wise phenotypic evolutionary rates fitted by <code><a href="#topic+RRphylo">RRphylo</a></code>.
When a multivariate phenotype is used, rescaling is operated on the norm-2
vector of rates.</p>
</td></tr>
<tr><td><code id="rescaleRR_+3A_height">height</code></td>
<td>
<p>is the desired height of the tree. If this parameter is
indicated, the tree branches are rescaled to match the total <code>height</code>.</p>
</td></tr>
<tr><td><code id="rescaleRR_+3A_trend">trend</code></td>
<td>
<p>is a diffusion model with linear trend in rates through time.
The <code>trend</code> scaling is largely based on package <span class="pkg">geiger</span>'s
<code>rescale.phylo</code> function.</p>
</td></tr>
<tr><td><code id="rescaleRR_+3A_delta">delta</code></td>
<td>
<p>if this parameter is indicated, the tree is rescaled according
to Pagel's delta transform (Pagel 1999). Nodes are pushed toward the
present for values of <code>delta</code> ranging between 0 and 1. The converse
applies for <code>delta</code> larger than 1. Negative <code>delta</code> values are
not allowed.</p>
</td></tr>
<tr><td><code id="rescaleRR_+3A_kappa">kappa</code></td>
<td>
<p>if this parameter is indicated, the tree is rescaled according
to Pagel's kappa transform (Pagel 1999). At <code>kappa = 1</code> the tree is
left unmodified. Branches become increasingly closer to 1 as <code>kappa</code>
approaches 0, making evolution independent from branch lengths. Negative
<code>kappa</code> values are not allowed.</p>
</td></tr>
<tr><td><code id="rescaleRR_+3A_lambda">lambda</code></td>
<td>
<p>if this parameter is indicated, the tree is rescaled according
to Pagel's lambda transform (Pagel 1999). At <code>lambda = 1</code> the tree is
left unmodified. The tree approaches a star phylogeny as <code>lambda</code>
approaches zero. <code>lambda</code> values larger than one are undefined
Negative <code>lambda</code> values are not allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rescaled phylogenetic tree.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Piccolo, M., Mondanaro, A.,
Melchionna, M., Di Febbraro, M., Sansalone, G., Wroe, S., &amp; Raia, P.
(2020). The influence of domestication, insularity and sociality on the
tempo and mode of brain size evolution in mammals. <em>Biological Journal
of the Linnean Society</em>,132: 221-231. doi:10.1093/biolinnean/blaa186
</p>
<p>Pagel, M. (1999). Inferring the historical patterns of biological
evolution. <em>Nature</em>, 401:877-884.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ape::rtree(100)-&gt;tree
phytools::fastBM(tree)-&gt;y
max(diag(vcv(tree)))-&gt;H

RRphylo(tree,y,clus=0)-&gt;RR
rescaleRR(tree,RR=RR)-&gt;treeRR

rescaleRR(tree,height=H/3)-&gt;tree_height

rescaleRR(tree,trend=5)-&gt;tree_trend

rescaleRR(tree,delta=0.5)-&gt;tree_delta05
rescaleRR(tree,delta=2)-&gt;tree_delta2

rescaleRR(tree,kappa=0.5)-&gt;tree_kappa

rescaleRR(tree,lambda=0.5)-&gt;tree_lambda

## End(Not run)
</code></pre>

<hr>
<h2 id='retrieve.angles'>Extracting a user-specified subset of the evo.dir results</h2><span id='topic+retrieve.angles'></span>

<h3>Description</h3>

<p>This function takes the result list produced by
<code><a href="#topic+evo.dir">evo.dir</a></code> as the input, and extracts a specific subset of it.
The user may specify whether to extract the set of angles between species
resultant vectors and the MRCA, the size of resultant vectors, or the set of
angles between species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve.angles(angles.res,wishlist=c("anglesMRCA","angleDir","angles.between.species"),
  random=c("yes","no"),focus=c("node","species","both","none"),
 node=NULL,species=NULL,write2csv=c("no","yes"),csvfile=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieve.angles_+3A_angles.res">angles.res</code></td>
<td>
<p>the object resulting from <code><a href="#topic+evo.dir">evo.dir</a></code> function.</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_wishlist">wishlist</code></td>
<td>
<p>specifies whether to extract angles and sizes
(<code>"anglesMRCA"</code>) of resultant vectors between individual species and
the MRCA, angles and sizes (<code>"angleDir"</code>) of vectors between individual
species and a fixed reference vector (the same for all species), or angles
between species resultant vectors (<code>"angles.between.species"</code>).</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_random">random</code></td>
<td>
<p>it needs to be <code>"yes"</code> if <code>'angles.res'</code> object
contains randomization results.</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_focus">focus</code></td>
<td>
<p>it can be <code>"node"</code>, <code>"species"</code>, <code>"both"</code>, or
<code>"none"</code>, whether the user wants the results for a focal node, or for a
given species, for both, or just wants to visualize everything.</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_node">node</code></td>
<td>
<p>must be indicated if <code>focus = "node"</code> or <code>"both"</code>. As
for <code>evo.dir</code>, the node number must refer to the dichotomic version of
the original tree, as produced by <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_species">species</code></td>
<td>
<p>must be indicated if <code>focus = "species"</code> or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_write2csv">write2csv</code></td>
<td>
<p>has been deprecated; please see the argument
<code>csvfile</code> instead.</p>
</td></tr>
<tr><td><code id="retrieve.angles_+3A_csvfile">csvfile</code></td>
<td>
<p>if results should be saved to a .csv file, a character
indicating the name of the csv file and the path where it is to be saved.
If no path is indicated the file is stored in the working directory.
If left unspecified, no file will be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>retrieve.angles</code> allows to focalize the extraction to a
particular node, species, or both. Otherwise it returns the whole dataset.
</p>


<h3>Value</h3>

<p><code>retrieve.angles</code> outputs an object of class <code>'data.frame'</code>.
</p>
<p>If <code>wishlist = "anglesMRCA"</code>, the data frame includes:
</p>
<ul>
<li><p><strong>MRCA</strong> the most recent common ancestor the angle is
computed to </p>
</li>
<li><p><strong>species</strong> species ID </p>
</li>
<li><p><strong>angle</strong> the angle
between the resultant vector of species and the MRCA
</p>
</li>
<li><p><strong>vector.size</strong> the size of the resultant vector computed from
species to MRCA </p>
</li></ul>

<p>If <code>wishlist = "angleDir"</code>, the data frame includes:
</p>
<ul>
<li><p><strong>MRCA</strong> the most recent common ancestor the vector is
computed to </p>
</li>
<li><p><strong>species</strong> species ID </p>
</li>
<li><p><strong>angle.direction</strong>
the angle between the vector of species and a fixed reference
</p>
</li>
<li><p><strong>vector.size</strong> the size of the vector of species </p>
</li></ul>

<p>If <code>wishlist = "angles.between.species"</code>, the data frame
includes: </p>
<ul>
<li><p><strong>MRCA</strong> the most recent common ancestor the
vector is computed from </p>
</li>
<li><p><strong>species</strong> pair IDs of the species pair
the &quot;angle between species&quot; is computed for
</p>
</li>
<li><p><strong>angleBTWspecies2MRCA</strong> angle between species resultant vectors
to MRCA </p>
</li>
<li><p><strong>anglesBTWspecies</strong> angle between species resultant
vectors </p>
</li></ul>



<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data("DataApes")
    DataApes$PCstage-&gt;PCstage
    DataApes$Tstage-&gt;Tstage

    cc&lt;- 2/parallel::detectCores()
    RRphylo(tree=Tstage,y=PCstage,clus=cc)-&gt;RR

# Case 1. "evo.dir" without performing randomization
    evo.dir(RR,angle.dimension="rates",pair.type="node",
    node=  57,random="no")-&gt;evo.p

 # Case 1.1 angles and sizes of resultant vectors between individual species and the MRCA:
  # for a focal node
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="no",focus="node",
    node=68)
  # for a focal species
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="no",focus="species",
    species="Sap")
  # for both focal node and species
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="no",focus="both",
    node=68,species="Sap")
  # without any specific requirement
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="no",focus="none")

 # Case 1.2 angles and sizes of vectors between individual species
 #and a fixed reference vector:
  # for a focal node
    retrieve.angles(evo.p,wishlist="angleDir",random="no",focus="node",
    node=68)
  # for a focal species
    retrieve.angles(evo.p,wishlist="angleDir",random="no",focus="species",
    species="Sap")
  # for both focal node and species
    retrieve.angles(evo.p,wishlist="angleDir",random="no",focus="both",
    node=68,species="Sap")
  # without any specific requirement
    retrieve.angles(evo.p,wishlist="angleDir",random="no",focus="none")

 # Case 1.3 angles between species resultant vectors:
  # for a focal node
    retrieve.angles(evo.p,wishlist="angles.between.species",random="no",
    focus="node", node=68)
  # for a focal species
    retrieve.angles(evo.p,wishlist="angles.between.species",random="no",
    focus="species", species="Sap")
  # for both focal node and species
    retrieve.angles(evo.p,wishlist="angles.between.species",random="no",
    focus="both",node=68,species="Sap")
  # without any specific requirement
    retrieve.angles(evo.p,wishlist="angles.between.species",random="no",
    focus="none")


# Case 2. "evo.dir" with performing randomization
    evo.dir(RR,angle.dimension="rates",pair.type="node",node=57,
    random="yes",nrep=10)-&gt;evo.p

 # Case 2.1 angles and sizes of resultant vectors between individual species and the MRCA:
  # for a focal node
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="yes",focus="node",
    node=68)
  # for a focal species
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="yes", focus="species",
    species="Sap")
  # for both focal node and species
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="yes",focus="both",
    node=68,species="Sap")
  # without any specific requirement
    retrieve.angles(evo.p,wishlist="anglesMRCA",random="yes",focus="none")

 # Case 2.2 angles and sizes of vectors between individual species and a fixed reference vector:
  # for a focal node
    retrieve.angles(evo.p,wishlist="angleDir",random="yes",focus="node",
    node=68)
  # for a focal species
    retrieve.angles(evo.p,wishlist="angleDir",random="yes",focus="species",
    species="Sap")
  # for both focal node and species
    retrieve.angles(evo.p,wishlist="angleDir",random="yes",focus="both",
    node=68, species="Sap")
  # without any specific requirement
    retrieve.angles(evo.p,wishlist="angleDir",random="yes",focus="none")

 # Case 2.3 retrieve angles between species resultant vectors:
  # for a focal node
    retrieve.angles(evo.p,wishlist="angles.between.species",random="yes",
    focus="node", node=68)
  # for a focal species
    retrieve.angles(evo.p,wishlist="angles.between.species",random="yes",
    focus="species", species="Sap")
  # for both focal node and species
    retrieve.angles(evo.p,wishlist="angles.between.species",random="yes",
    focus="both",node=68,species="Sap")
  # without any specific requirement
    retrieve.angles(evo.p,wishlist="angles.between.species",random="yes",
    focus="none")
    
## End(Not run)
</code></pre>

<hr>
<h2 id='RRphylo'>Evolutionary rates computation along phylogenies</h2><span id='topic+RRphylo'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+RRphylo">RRphylo</a></code> (<cite>Castiglione et al.
2018</cite>) performs the phylogenetic ridge regression. It takes a tree and a
vector of tip data (phenotypes) as entries, calculates the regularization
factor, produces the matrices of tip to root (<code><a href="#topic+makeL">makeL</a></code>), and
node to root distances (<code><a href="#topic+makeL1">makeL1</a></code>), the vector of ancestral
state estimates, the vector of predicted phenotypes, and the rates vector
for all the branches of the tree. For multivariate data, rates are given as
both one vector per variable, and as a multivariate vector obtained by
computing the Euclidean Norm of individual rate vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRphylo(tree,y,cov=NULL,rootV=NULL,aces=NULL,x1=NULL,
  aces.x1=NULL,clus=0.5,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRphylo_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_y">y</code></td>
<td>
<p>either a single vector variable or a multivariate dataset. In any
case, <code>y</code> must be named. In case of categorical variable, this should
be supplied to the function as a numeric vector.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_cov">cov</code></td>
<td>
<p>the covariate to be indicated if its effect on the rates must be
accounted for. In this case residuals of the covariate versus the rates are
used as rates. <code>'cov'</code> must be as long as the number of nodes plus the
number of tips of the tree, which can be obtained by running <code>RRphylo</code>
on the covariate as well, and taking the vector of ancestral states and tip
values to form the covariate, as in the example below. See
<a href="../doc/RRphylo.html#covariate">RRphylo vignette - covariate</a> for
details.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_rootv">rootV</code></td>
<td>
<p>phenotypic value (values if multivariate) at the tree root. If
<code>rootV=NULL</code> the function 'learns' about the root value from the 10%
tips being closest in time to the tree root, weighted by their temporal
distance from the root itself (close tips phenotypes weigh more than more
distant tips).</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_aces">aces</code></td>
<td>
<p>a named vector (or matrix if <code>y</code> is multivariate) of
ancestral character values at nodes. Names correspond to the nodes in the
tree. See <a href="../doc/RRphylo.html#aces">RRphylo vignette - aces</a> for
details.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_x1">x1</code></td>
<td>
<p>the additional predictor(s) to be indicated to perform the multiple
version of <code>RRphylo</code>. <code>'x1'</code> vector/matrix must be as long as the
number of nodes plus the number of tips of the tree, which can be obtained
by running <code>RRphylo</code> on the predictors (separately for each predictor)
as well, and taking the vector of ancestral states and tip values to form
the <code>x1</code>. See <a href="../doc/RRphylo.html#predictor">RRphylo vignette -
predictor</a> for details.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_aces.x1">aces.x1</code></td>
<td>
<p>a named vector/matrix of ancestral character values at nodes
for <code>x1</code>. It must be indicated if both <code>aces</code> and <code>x1</code> are
specified. Names/rownames correspond to the nodes in the tree.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing.
Default is 0.5. To run the single-threaded version of <code>RRphylo</code> set
<code>clus</code> = 0.</p>
</td></tr>
<tr><td><code id="RRphylo_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether a &quot;RRlog.txt&quot; printing progresses
should be stored into the working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>tree</strong> the tree used by <code>RRphylo</code>. The fully dichotomous
version of the tree argument. For trees with polytomies, the tree is
resolved by using <code>multi2di</code> function in the package <span class="pkg">ape</span>. Note,
tip labels are ordered according to their position in the tree.
</p>
<p><strong>tip.path</strong> a <code class="reqn">n * m</code> matrix, where n=number of tips and
m=number of branches (i.e. 2*n-1). Each row represents the branch lengths
along a root-to-tip path.
</p>
<p><strong>node.path</strong> a <code class="reqn">n * n</code> matrix, where n=number of internal
branches. Each row represents the branch lengths along a root-to-node path.
</p>
<p><strong>rates</strong> single rate values computed for each branch of the
tree. If <code>y</code> is a single vector variable, rates are equal to
multiple.rates. If <code>y</code> is a multivariate dataset, rates are computed
as the square root of the sum of squares of each row of
<code>$multiple.rates</code>.
</p>
<p><strong>aces</strong> the phenotypes reconstructed at nodes.
</p>
<p><strong>predicted.phenotypes</strong> the vector of estimated tip values. It
is a matrix in the case of multivariate data.
</p>
<p><strong>multiple.rates</strong> a <code class="reqn">n * m</code> matrix, where n= number of
branches (i.e. n*2-1) and m = number of variables. For each branch, the
column entries represent the evolutionary rate.
</p>
<p><strong>lambda</strong> the regularization factor fitted within
<code>RRphylo</code> by the inner function <code>optL</code>. With multivariate data,
several <code>optL</code> runs are performed. Hence, the function provides a
single lambda for each individual variable.
</p>
<p><strong>ace.values</strong> if <code>aces</code> are specified, the function
returns a dataframe containing the corresponding node number on the
<code>RRphylo</code> tree  for each node , along with estimated values.
</p>
<p><strong>x1.rate</strong> if <code>x1</code> is specified, the function returns the
partial regression coefficient for <code>x1</code>.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Castiglione, S., Tesone, G., Piccolo, M., Melchionna, M.,
Mondanaro, A., Serio, C., Di Febbraro, M., &amp; Raia, P.(2018). A new method
for testing evolutionary rate variation and shifts in phenotypic evolution.
<em>Methods in Ecology and Evolution</em>, 9:
974-983.doi:10.1111/2041-210X.12954
</p>
<p>Serio, C., Castiglione, S., Tesone, G., Piccolo, M., Melchionna,
M., Mondanaro, A., Di Febbraro, M., &amp; Raia, P.(2019). Macroevolution of
toothed whales exceptional relative brain size. <em>Evolutionary
Biology</em>, 46: 332-342. doi:10.1007/s11692-019-09485-7
</p>
<p>Melchionna, M., Mondanaro, A., Serio, C., Castiglione, S., Di
Febbraro, M., Rook, L.,Diniz-Filho,J.A.F., Manzi, G., Profico, A.,
Sansalone, G., &amp; Raia, P.(2020).Macroevolutionary trends of brain mass in
Primates. <em>Biological Journal of the Linnean Society</em>, 129: 14-25.
doi:10.1093/biolinnean/blz161
</p>
<p>Castiglione, S., Serio, C., Mondanaro, A., Melchionna, M.,
Carotenuto, F., Di Febbraro, M., Profico, A., Tamagnini, D., &amp; Raia, P.
(2020). Ancestral State Estimation with Phylogenetic Ridge Regression.
<em>Evolutionary Biology</em>, 47: 220-232. doi:10.1007/s11692-020-09505-x
</p>
<p>Castiglione, S., Serio, C., Piccolo, M., Mondanaro, A.,
Melchionna, M., Di Febbraro, M., Sansalone, G., Wroe, S., &amp; Raia, P.
(2020). The influence of domestication, insularity and sociality on the
tempo and mode of brain size evolution in mammals. <em>Biological Journal
of the Linnean Society</em>,132: 221-231. doi:10.1093/biolinnean/blaa186
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
cc&lt;- 2/parallel::detectCores()

# Case 1. "RRphylo" without accounting for the effect of a covariate
RRphylo(tree=treedino,y=massdino,clus=cc)-&gt;RRcova

# Case 2. "RRphylo" accounting for the effect of a covariate
# "RRphylo" on the covariate in order to retrieve ancestral state values
c(RRcova$aces,massdino)-&gt;cov.values
c(rownames(RRcova$aces),names(massdino))-&gt;names(cov.values)

RRphylo(tree=treedino,y=massdino,cov=cov.values,clus=cc)-&gt;RR

# Case 3. "RRphylo" specifying the ancestral states
data("DataCetaceans")
DataCetaceans$treecet-&gt;treecet
DataCetaceans$masscet-&gt;masscet
DataCetaceans$brainmasscet-&gt;brainmasscet
DataCetaceans$aceMyst-&gt;aceMyst

RRphylo(tree=treecet,y=masscet,aces=aceMyst,clus=cc)-&gt;RR

# Case 4. Multiple "RRphylo"
library(ape)
drop.tip(treecet,treecet$tip.label[-match(names(brainmasscet),treecet$tip.label)])-&gt;treecet.multi
masscet[match(treecet.multi$tip.label,names(masscet))]-&gt;masscet.multi

RRphylo(tree=treecet.multi, y=masscet.multi,clus=cc)-&gt;RRmass.multi
RRmass.multi$aces[,1]-&gt;acemass.multi
c(acemass.multi,masscet.multi)-&gt;x1.mass

RRphylo(tree=treecet.multi,y=brainmasscet,x1=x1.mass,clus=cc)-&gt;RR

# Case 5. Categorical and multiple "RRphylo" with 2 additional predictors
library(phytools)

set.seed(1458)
rtree(50)-&gt;tree
fastBM(tree)-&gt;y
jitter(y)*10-&gt;y1
rep(1,length(y))-&gt;y2
y2[sample(1:50,20)]&lt;-2
names(y2)&lt;-names(y)

c(RRphylo(tree,y1,clus=cc)$aces[,1],y1)-&gt;x1

RRphylo(tree,y2,clus=cc)-&gt;RRcat ### this is the RRphylo on the categorical variable
c(RRcat$aces[,1],y2)-&gt;x2

cbind(c(jitter(mean(y1[tips(tree,83)])),1),
      c(jitter(mean(y1[tips(tree,53)])),2))-&gt;acex
c(jitter(mean(y[tips(tree,83)])),jitter(mean(y[tips(tree,53)])))-&gt;acesy
names(acesy)&lt;-rownames(acex)&lt;-c(83,53)

RRphylo(tree,y,aces=acesy,x1=cbind(x1,x2),aces.x1 = acex,clus=cc)

    
## End(Not run)
</code></pre>

<hr>
<h2 id='RRphylo-defunct'>Defunct functions in Package RRphylo</h2><span id='topic+RRphylo-defunct'></span><span id='topic+swap.phylo'></span>

<h3>Description</h3>

<p>These functions are no longer available.
</p>

<ul>
<li> <p><code>swap.phylo</code>: This function is defunct. Please check <code><a href="#topic+overfitRR">overfitRR</a></code>, instead.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>swap.phylo()
</code></pre>

<hr>
<h2 id='RRphylo-deprecated'>Deprecated functions in Package RRphylo</h2><span id='topic+RRphylo-deprecated'></span>

<h3>Description</h3>

<p>These functions still work but will be removed (defunct) in the next version.
</p>

<hr>
<h2 id='scaleTree'>Phylogenetic tree calibration</h2><span id='topic+scaleTree'></span>

<h3>Description</h3>

<p>The function is a wrapper around the functions &quot;scalePhylo&quot;,
&quot;assign.ages&quot;, and &quot;assign.brlen&quot; written by Gene Hunt
(http://paleobiology.si.edu/staff/individuals/hunt.cfm). It rescales tree
branch lengths according to given calibration dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleTree(tree, tip.ages=NULL, node.ages=NULL,min.branch=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleTree_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="scaleTree_+3A_tip.ages">tip.ages</code></td>
<td>
<p>a named vector including the ages (i.e. distance from the
youngest tip within the tree) of the tips to be changed. If unspecified, the
function assumes all the tips are correctly placed with respect to the root.</p>
</td></tr>
<tr><td><code id="scaleTree_+3A_node.ages">node.ages</code></td>
<td>
<p>a named vector including the ages (i.e. distance from the
youngest tip within the tree) of the nodes to be changed. If no calibration
date for nodes is supplied, the tree root is fixed and the function shifts
node position only where needed to fit tip ages.</p>
</td></tr>
<tr><td><code id="scaleTree_+3A_min.branch">min.branch</code></td>
<td>
<p>has been deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rescaled phylogentic tree with tip labels ordered according to their position in the tree.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>See Also</h3>

<p><a href="../doc/Tree-Manipulation.html#scaleTree"><code>scaleTree</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ape)
library(phytools)

data("DataFelids")
DataFelids$treefel-&gt;tree

max(nodeHeights(tree))-&gt;H

#### Example 1 ####
rep(0,4)-&gt;tipAges
names(tipAges)&lt;-tips(tree,146)
scaleTree(tree,tipAges)-&gt;treeS1

edge.col&lt;-rep("black",nrow(tree$edge))
edge.col[which(treeS1$edge[,2]%in%getDescendants(treeS1,146))]&lt;-"red"

layout(2:1)
plot(tree,edge.color = edge.col,show.tip.label=FALSE)
plot(treeS1,edge.color = edge.col,show.tip.label=FALSE)

#### Example 2 ####
nodeAges&lt;-c(23.5,15.6)
names(nodeAges)&lt;-c(85,139)
scaleTree(tree,node.ages=nodeAges)-&gt;treeS2

edge.col&lt;-rep("black",nrow(tree$edge))
edge.col[which(treeS1$edge[,2]%in%c(getDescendants(treeS1,85),
                                    getDescendants(treeS1,139)))]&lt;-"red"

layout(2:1)
plot(tree,edge.color = edge.col,show.tip.label=FALSE)
nodelabels(bg="w",frame="n",node=c(85,139),col="green")
plot(treeS2,edge.color = edge.col,show.tip.label=FALSE)
nodelabels(bg="w",frame="n",node=c(85,139),col="green")

#### Example 3 ####
16-&gt;nodeAges
names(nodeAges)&lt;-"145"
tipAges&lt;-19
names(tipAges)&lt;-tree$tip.label[1]
scaleTree(tree,tip.ages = tipAges,node.ages=nodeAges)-&gt;treeS3

edge.col&lt;-rep("black",nrow(tree$edge))
edge.col[which(treeS3$edge[,2]%in%c(1,getMommy(tree,1),
                                    getDescendants(treeS3,145)))]&lt;-"red"

layout(2:1)
plot(tree,edge.color = edge.col,show.tip.label=FALSE)
nodelabels(bg="w",frame="n",node=145,col="green")
plot(treeS3,edge.color = edge.col,show.tip.label=FALSE)
nodelabels(bg="w",frame="n",node=145,col="green")

</code></pre>

<hr>
<h2 id='search.conv'>Searching for morphological convergence among species and clades</h2><span id='topic+search.conv'></span>

<h3>Description</h3>

<p>The function scans a phylogenetic tree looking for morphological
convergence between entire clades or species evolving under specific
states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.conv(RR=NULL,tree=NULL,y,nodes=NULL,state=NULL,aceV=NULL,
  min.dim=NULL,max.dim=NULL,min.dist=NULL,declust=FALSE,nsim=1000,rsim=1000,
  clus=0.5,filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.conv_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code><a href="#topic+RRphylo">RRphylo</a></code>. This is not indicated
if convergence among states is tested.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous. This is not indicated if convergence among clades is
tested.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_y">y</code></td>
<td>
<p>a multivariate phenotype. The object <code>y</code> should be either a
matrix or dataframe with species names as rownames.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_nodes">nodes</code></td>
<td>
<p>node pair to be tested. If unspecified, the function
automatically searches for convergence among clades. Notice the node number
must refer to the dichotomic version of the original tree, as produced by
<code>RRphylo</code>.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_state">state</code></td>
<td>
<p>the named vector of tip states. The function tests for
convergence within a single state or among different states (this latter
case is especially meant to test for iterative evolution as for example the
appearance of repeated morphotypes into different clades). In both cases,
the state for non-focal species (i.e. not belonging to any convergent
group) must be indicated as &quot;nostate&quot;.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_acev">aceV</code></td>
<td>
<p>phenotypic values at internal nodes. The object <code>aceV</code>
should be either a matrix or dataframe with nodes (referred to the
dichotomic version of the original tree, as produced by <code>RRphylo</code>) as
rownames. If <code>aceV</code> are not indicated, ancestral phenotypes are
estimated via <code>RRphylo</code>.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_min.dim">min.dim</code></td>
<td>
<p>the minimum size of the clades to be compared. When
<code>nodes</code> is indicated, it is the minimum size of the smallest clades in
<code>nodes</code>, otherwise it is set at one tenth of the tree size.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_max.dim">max.dim</code></td>
<td>
<p>the maximum size of the clades to be compared. When
<code>nodes</code> is indicated, it is <code>min.dim</code>*2 if the largest clade in
<code>nodes</code> is smaller than this value, otherwise it corresponds to the
size of the largest clade. Without <code>nodes</code> it is set at one third of
the tree size.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_min.dist">min.dist</code></td>
<td>
<p>the minimum distance between the clades to be compared. When
<code>nodes</code> is indicated, it is the distance between the pair. Under the
automatic mode, the user can choose whether time distance or node distance
(i.e. the number of nodes intervening between the pair) should be used. If
time distance has to be considered, <code>min.dist</code> should be a character
argument containing the word &quot;time&quot; and then the actual time distance to be
used. The same is true for node distance, but the word &quot;node&quot; must precede
the node distance to be used. For example, if the user want to test only
clades more distant than 10 time units, the argument should be &quot;time10&quot;. If
clades separated by more than 8 nodes has to be tested, the argument
<code>min.dist</code> should be &quot;node8&quot;. If left unspecified, it automatically
searches for convergence between clades separated by a number of nodes
bigger than one tenth of the tree size.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_declust">declust</code></td>
<td>
<p>if species under a given state (or a pair of states) to be
tested for convergence are phylogenetically closer than expected by chance,
trait similarity might depend on proximity rather than true convergence. In
this case, by setting <code>declust = TRUE</code>, tips under the focal state (or
states) are removed randomly until clustering disappears. A minimum of 3
species per state is enforced to remain anyway.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform sampling within the theta random
distribution. It is set at 1000 by default.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_rsim">rsim</code></td>
<td>
<p>number of simulations to be performed to produce the random
distribution of theta values. It is set at 1000 by default.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>search.conv</code> set <code>clus</code> = 0.</p>
</td></tr>
<tr><td><code id="search.conv_+3A_filename">filename</code></td>
<td>
<p>is deprecated. <code>search.conv</code> does not return plots
anymore, check the function <code><a href="#topic+plotConv">plotConv</a></code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If convergence between clades is tested, the function returns a list
including:
</p>
<ul>
<li><p><strong>$node pairs</strong>: a dataframe containing for each
pair of nodes: </p>
<ul>
<li><p> ang.bydist.tip: the mean theta angle between
clades divided by the time distance. </p>
</li>
<li><p> ang.conv: the mean theta angle
between clades plus the angle between aces, divided by the time distance.
</p>
</li>
<li><p> ang.ace: the angle between aces. </p>
</li>
<li><p> ang.tip: the mean theta angle
between clades. </p>
</li>
<li><p> nod.dist: the distance intervening between clades in
terms of number of nodes. </p>
</li>
<li><p> time.dist: the time distance intervening
between the clades. </p>
</li>
<li><p> p.ang.bydist: the p-value computed for
ang.bydist.tip. </p>
</li>
<li><p> p.ang.conv: the p-value computed for ang.conv. </p>
</li>
<li>
<p>clade.size: the size of clades. </p>
</li></ul>
 </li>
<li><p><strong>$node pairs comparison</strong>:
pairwise comparison between significantly convergent pairs (all pairs if no
instance of significance was found) performed on the distance from group
centroids (the mean phenotype per clade). </p>
</li>
<li><p><strong>$average distance
from group centroids</strong>: smaller average distances mean less variable
phenotypes within the pair. </p>
</li></ul>

<p>If convergence between (or within a single state) states is tested,
the function returns a list including: </p>
<ul>
<li><p><strong>state.res</strong> a
dataframe including for each pair of states (or single state): </p>

<ul>
<li><p> ang.state: the mean theta angle between species belonging to
different states (or within a single state). </p>
</li>
<li><p> ang.state.time: the mean
of theta angle between species belonging to different states (or within a
single state) divided by time distance. </p>
</li>
<li><p> p.ang.state: the p-value
computed for ang.state. </p>
</li>
<li><p> p.ang.state.time: the p-value computed for
ang.state.time.</p>
</li></ul>
</li></ul>
 <ul>
<li><p><strong>plotData</strong> a dataframe including
data to plot the results via <code><a href="#topic+plotConv">plotConv</a></code></p>
</li></ul>
<p>.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto, Paolo Piras, Davide Tamagnini
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Tamagnini, D., Melchionna, M.,
Mondanaro, A., Di Febbraro, M., Profico, A., Piras, P.,Barattolo, F., &amp;
Raia, P. (2019). A new, fast method to search for morphological convergence
with shape data. <em>PLoS ONE</em>, 14, e0226949.
https://doi.org/10.1371/journal.pone.0226949
</p>


<h3>See Also</h3>

<p><a href="../doc/search.conv.html"><code>search.conv</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotConv</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataFelids")
DataFelids$PCscoresfel-&gt;PCscoresfel
DataFelids$treefel-&gt;treefel
DataFelids$statefel-&gt;statefel
cc&lt;- 2/parallel::detectCores()

RRphylo(treefel,PCscoresfel,clus=cc)-&gt;RRfel


## Case 1. searching convergence between clades
# by setting min.dist as node distance
search.conv(RR=RRfel, y=PCscoresfel, min.dim=5, min.dist="node9",clus=cc)
# by setting min.dist as time distance
search.conv(RR=RRfel, y=PCscoresfel, min.dim=5, min.dist="time38",clus=cc)

## Case 2. searching convergence within a single state
search.conv(tree=treefel, y=PCscoresfel, state=statefel,declust=TRUE,clus=cc)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='search.shift'>Locating shifts in phenotypic evolutionary rates</h2><span id='topic+search.shift'></span>

<h3>Description</h3>

<p>The function <code>search.shift</code> (<cite>Castiglione et al.
2018</cite>) tests whether individual clades or isolated tips dispersed through
the phylogeny evolve at different <code><a href="#topic+RRphylo">RRphylo</a></code> rates as compared
to the rest of the tree. Instances of rate shifts may be automatically
found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.shift(RR, status.type = c("clade", "sparse"),node = NULL, state
  = NULL, cov = NULL, nrep = 1000, f = NULL,filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.shift_+3A_rr">RR</code></td>
<td>
<p>an object fitted by the function <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="search.shift_+3A_status.type">status.type</code></td>
<td>
<p>whether the <code>"clade"</code> or <code>"sparse"</code> condition
must be tested.</p>
</td></tr>
<tr><td><code id="search.shift_+3A_node">node</code></td>
<td>
<p>under the <code>"clade"</code> condition, the node (clade) to be tested
for the rate shift. When multiple nodes are tested, they need to be written
as in the example below. If <code>node</code> is left unspecified, the function
performs under the 'auto-recognize' feature, meaning it will automatically
test individual clades for deviation of their rates from the background
rate of the rest of the tree (see details).</p>
</td></tr>
<tr><td><code id="search.shift_+3A_state">state</code></td>
<td>
<p>the state of the tips specified under the <code>"sparse"</code>
condition.</p>
</td></tr>
<tr><td><code id="search.shift_+3A_cov">cov</code></td>
<td>
<p>the covariate vector to be indicated if its effect on rate values must be
accounted for. Contrary to <code>RRphylo</code>, <code>cov</code> needs to be as long
as the number of tips of the tree.</p>
</td></tr>
<tr><td><code id="search.shift_+3A_nrep">nrep</code></td>
<td>
<p>the number of simulations to be performed for the rate shift
test, by default <code>nrep</code> is set at 1000.</p>
</td></tr>
<tr><td><code id="search.shift_+3A_f">f</code></td>
<td>
<p>the size of the smallest clade to be tested. By default, nodes
subtending to one tenth of the tree tips are tested.</p>
</td></tr>
<tr><td><code id="search.shift_+3A_filename">filename</code></td>
<td>
<p>is deprecated. <code>search.shift</code> does not return plots
anymore, check the function <code><a href="#topic+plotShift">plotShift</a></code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>search.shift</code> takes the object produced by
<code><a href="#topic+RRphylo">RRphylo</a></code>. Two different conditions of rate change can be
investigated. Under the <code>"clade"</code> condition the vector of node or
nodes subjected to the shift must be provided. Alternatively, under the
<code>"sparse"</code> case the (named) vector of states (indicating which tips
are or are not evolving under the rate shift according to the tested
hypothesis) must be indicated. In the <code>"clade"</code> case, the function may
perform an 'auto-recognize' feature. Under such specification, the function
automatically tests individual clades (from clades as large as one half of
the tree down to a specified clade size) for deviation of their rates from
the background rate of the rest of the tree, which is identical to the
<code>"clade"</code> case. An inclusive clade with significantly high rates is
likely to include descending clades with similarly significantly high
rates. Hence, with 'auto-recognize' the <code>search.shift</code> function is
written as to scan clades individually and to select only the node
subtending to the highest difference in mean absolute rates as compared to
the rest of the tree. Caution must be put into interpreting the
'auto-recognize' results. For instance, a clade with small rates and
another with large rates could be individuated even under BM. This does not
mean these clades are actual instances for rate shifts. Clades must be
tested on their own without the 'auto-recognize' feature, which serves as
guidance to the investigator, when no strong a priori hypothesis to be
tested is advanced. The 'auto-recognize' feature is not meant to provide a
test for a specific hypothesis. It serves as an optional guidance to
understand whether and which clades show significantly large or small rates
as compared to the rest of the tree. Individual clades are tested at once,
meaning that significant instances of rate variation elsewhere on the tree
are ignored. Conversely, running the <code>"clade"</code> condition without
including the 'auto-recognize' feature, multiple clades presumed to evolve
under the same shift are tested together, meaning that their rates are
collectively contrasted to the rest of the tree, albeit they can
additionally be compared to each other upon request. Under both the
<code>"clade"</code> and <code>"sparse"</code> conditions, multiple clades could be
specified at once, and optionally tested individually (for deviation of
rates) against the rates of the rest of the tree and against each other.
Regardless of which condition is specified, the function output produces
the real difference of means, and their significance value.
</p>


<h3>Value</h3>

<p>Under all circumstances, <code>search.shift</code> provides a vector of
<code>$rates</code>. If <code>'cov'</code> values are provided, rates are regressed
against the covariate and the residuals of such regression form the vector
<strong><code>$rates</code></strong>. Otherwise, <strong><code>$rates</code></strong> are the same
rates as with the <code>RR</code> argument.
</p>
<p>Under <code>"clade"</code> case without specifying nodes (i.e.
'auto-recognize') a list including:
</p>
<p><strong>$all.clades</strong> for each detected node, the data-frame includes
the average rate difference (computed as the mean rate over all branches
subtended by the node minus the average rate for the rest of the tree) and
the probability that it do represent a real shift. Probabilities are
contrasted to simulations shuffling the rates across the tree branches for
a number of replicates specified by the argument <code>nrep</code>. Note that the
p-values refer to the number of times the real average rates are larger (or
smaller) than the rates averaged over the rest of the tree, divided by the
number of simulations. Hence, large rates are significantly larger than the
rest of the tree (at alpha = 0.05), when the probability is &gt; 0.975; and
small rates are significantly small for p &lt; 0.025.
</p>
<p><strong>$single.clades</strong> the same as with 'all.clades' but restricted
to the largest/smallest rate values along a single clade (i.e. nested
clades with smaller rate shifts are excluded). Large rates are
significantly larger than the rest of the tree (at alpha = 0.05), when the
probability is &gt; 0.975; and small rates are significantly small for p &lt;
0.025.
</p>
<p>Under <code>"clade"</code> condition by specifying the <code>node</code>
argument:
</p>
<p><strong>$all.clades.together</strong> if more than one node is tested, this
specifies the average rate difference and the significance of the rate
shift, by considering all the specified nodes as evolving under a single
rate. As with the 'auto-recognize' feature, large rates are significantly
larger than the rest of the tree (at alpha = 0.05), when the probability is
&gt; 0.975; and small rates are significantly small for p &lt; 0.025.
</p>
<p><strong>$single.clades</strong> this gives the significance for individual
clades, tested separately. As previously, large rates are significantly
larger than the rest of the tree (at alpha = 0.05), when the probability is
&gt; 0.975; and small rates are significantly small for p &lt; 0.025.
</p>
<p>Under the <code>"sparse"</code> condition:
</p>
<p><strong>$state.results</strong> for each state, the data-frame includes the
average rate difference (computed as the mean rate over all leaves evolving
under a given state, minus the average rate for each other state or the
rest of the tree) and the probability that the shift is real. Large rates
are significantly larger (at alpha = 0.05), when the probability is &gt;
0.975; and small rates are significantly small for p &lt; 0.025. States are
compared pairwise.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Castiglione, S., Tesone, G., Piccolo, M., Melchionna, M.,
Mondanaro, A., Serio, C., Di Febbraro, M., &amp; Raia, P.(2018). A new method
for testing evolutionary rate variation and shifts in phenotypic evolution.
<em>Methods in Ecology and Evolution</em>, 9:
974-983.doi:10.1111/2041-210X.12954
</p>


<h3>See Also</h3>

<p><a href="../doc/search.shift.html"><code>search.shift</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotShift</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
DataOrnithodirans$statedino-&gt;statedino
cc&lt;- 2/parallel::detectCores()

RRphylo(tree=treedino,y=massdino,clus=cc)-&gt;dinoRates

# Case 1. Without accounting for the effect of a covariate

# Case 1.1 "clade" condition
# with auto-recognize
search.shift(RR=dinoRates,status.type="clade")
# testing two hypothetical clades
search.shift(RR=dinoRates,status.type="clade",node=c(696,746))

# Case 1.2 "sparse" condition
# testing the sparse condition.
search.shift(RR=dinoRates,status.type= "sparse",state=statedino)


# Case 2. Accounting for the effect of a covariate

# Case 2.1 "clade" condition
search.shift(RR=dinoRates,status.type= "clade",cov=massdino)

# Case 2.2 "sparse" condition
search.shift(RR=dinoRates,status.type="sparse",state=statedino,cov=massdino)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='search.trend'>Searching for evolutionary trends in phenotypes and rates</h2><span id='topic+search.trend'></span>

<h3>Description</h3>

<p>This function searches for evolutionary trends in the phenotypic
mean and the evolutionary rates for the entire tree and individual clades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.trend(RR,y,x1=NULL,x1.residuals = FALSE,
 node=NULL,cov=NULL,nsim=100,clus=0.5,ConfInt=NULL,filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.trend_+3A_rr">RR</code></td>
<td>
<p>an object produced by <code><a href="#topic+RRphylo">RRphylo</a></code>.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_y">y</code></td>
<td>
<p>the named vector (or matrix if multivariate) of phenotypes.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_x1">x1</code></td>
<td>
<p>the additional predictor to be specified if the RR object has been
created using an additional predictor (i.e. multiple version of
<code>RRphylo</code>). <code>'x1'</code> vector must be as long as the number of nodes
plus the number of tips of the tree, which can be obtained by running
<code>RRphylo</code> on the predictor as well, and taking the vector of ancestral
states and tip values to form the <code>x1</code>. Note: only one predictor at
once can be specified.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_x1.residuals">x1.residuals</code></td>
<td>
<p>logical specifying whether the residuals of regression
between <code>y</code> and <code>x1</code> should be inspected for a phenotypic trend
(see details and examples below). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_node">node</code></td>
<td>
<p>the node number of individual clades to be specifically tested and
contrasted to each other. It is <code>NULL</code> by default. Notice the node
number must refer to the dichotomic version of the original tree, as
produced by <code>RRphylo</code>.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_cov">cov</code></td>
<td>
<p>the covariate values to be specified if the RR object has been
created using a  covariate for rates calculation.  As for <code>RRphylo</code>,
<code>'cov'</code> must be as long as the number of nodes plus the number of tips
of the tree, which can be obtained by running <code>RRphylo</code> on the
covariate as well, and taking the vector of ancestral states and tip values
to form the covariate (see the example below).</p>
</td></tr>
<tr><td><code id="search.trend_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to be performed. It is set at 100 by
default.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_clus">clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>search.trend</code> set <code>clus</code> = 0.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_confint">ConfInt</code></td>
<td>
<p>is deprecated.</p>
</td></tr>
<tr><td><code id="search.trend_+3A_filename">filename</code></td>
<td>
<p>is deprecated. <code>search.trend</code> does not return plots
anymore, check the function <code><a href="#topic+plotTrend">plotTrend</a></code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simultaneously returns the regression of phenotypes and
phenotypic evolutionary rates against age tested against Brownian motion
simulations to assess significance. To this aim rates are rescaled in the
0-1 range and then logged. To assess significance, slopes are compared to a
family of simulated slopes (BMslopes, where the number of simulations is
equal to <code>nsim</code>), generated under the Brownian motion, using the
<code>fastBM</code> function in the package <span class="pkg">phytools</span>. Individual nodes are
compared to the rest of the tree in different ways depending on whether
phenotypes or rates (always unscaled in this case) versus age regressions
are tested. With the former, the regression slopes for individual clades and
the slope difference between clades is contrasted to slopes obtained through
Brownian motion simulations. For the latter, regression models are tested
and contrasted to each other referring to estimated marginal means, by using
the <code>emmeans</code> function in the package <span class="pkg">emmeans</span>.
</p>
<p>The <a href="../doc/RRphylo.html#predictor">multiple regression version of
RRphylo</a> allows to incorporate the effect of an additional predictor in the
computation of evolutionary rates without altering the ancestral character
estimation. Thus, when a multiple <code>RRphylo</code> output is fed to
<code>search.trend</code>, the predictor effect is accounted for on the absolute
evolutionary rates, but not on the phenotype. However, in some situations
the user might want to factor out the predictor effect on phenotypes as
well. Under the latter circumstance, by setting the argument
<code>x1.residuals = TRUE</code>, the residuals of the response to predictor
regression are used as to represent the phenotype.
</p>


<h3>Value</h3>

<p>The function returns a list object containing:
</p>
<p><strong>$trends.data</strong> a 'RRphyloList' object including:
</p>
<ol>
<li><p><code>$phenotypeVStime</code>: a data frame of phenotypic values
(or <code>y</code> versus <code>x1</code> regression residuals if
<code>x1.residuals=TRUE</code>) and their distance from the tree root for each
node (i.e. ancestral states) and tip of the tree.
</p>
</li>
<li><p><code>$absrateVStime</code>: a data frame of <code>RRphylo</code> rates and the
distance from the tree root (age). If y is multivariate, it also includes
the multiple rates for each y vector. If <code>node</code> is specified, each
branch is classified as belonging to an indicated clade.
</p>
</li>
<li><p><code>$rescaledrateVStime</code>: a data frame of rescaled <code>RRphylo</code>
rates and the distance from the tree root (age). If y is multivariate, it
also includes the multiple rates for each y vector. If <code>node</code> is
specified, each branch is classified as belonging to an indicated clade. NAs
correspond either to very small values or to outliers which are excluded
from the analysis.</p>
</li></ol>

<p><strong>$phenotypic.regression</strong> results of phenotype (<code>y</code> versus
<code>x1</code> regression residuals) versus age regression. It reports a p-value
for the regression slope between the variables (p.real), a p-value computed
contrasting the real slope to Brownian motion simulations (p.random), and a
parameter indicating the deviation of the phenotypic mean from the root
value in terms of the number of standard deviations of the trait
distribution (dev). dev is 0 under Brownian Motion. Only p.random should be
inspected to assess significance.
</p>
<p><strong>$rate.regression</strong> results of the rates (rescaled absolute
values) versus age regression. It reports a p-value for the regression
between the variables (p.real), a p-value computed contrasting the real
slope to Brownian motion simulations (p.random), and a parameter indicating
the ratio between the range of phenotypic values and the range of such
values halfway along the tree height, divided to the same figure under
Brownian motion (spread). spread is 1 under Brownian Motion. Only p.random
should be inspected to assess significance.
</p>
<p><strong>$ConfInts</strong> a 'RRphyloList' object including the 95%
confidence intervals around regression slopes of phenotypes and rates (both
rescaled and unscaled absolute rates) produced according to the Brownian
motion model of evolution.
</p>
<p>If specified, individual nodes are tested as the whole tree, the
results are summarized in the objects:
</p>
<p><strong>$node.phenotypic.regression</strong> results of phenotype (or <code>y</code>
versus <code>x1</code> regression residuals) versus age regression through node.
It reports the slope for the regression between the variables at node
(slope), a p-value computed contrasting the real slope to Brownian motion
simulations (p.random), the difference between estimated marginal means
predictions for the group and for the rest of the tree (emm.difference), and
a p-value for the emm.difference (p.emm).
</p>
<p><strong>$node.rate.regression</strong> results of the rates (absolute values)
versus age regression through node. It reports the difference between
estimated marginal means predictions for the group and for the rest of the
tree (emm.difference), a p-value for the emm.difference (p.emm), the
regression slopes for the group (slope.node) and for the rest of the tree
(slope.others), and a p-value for the difference between such slopes
(p.slope).
</p>
<p>If more than one node is specified, the object
<strong>$group.comparison</strong> reports the same results as
$node.phenotypic.regression and $node.rate.regression obtained by comparing
individual clades to each other.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Mondanaro, A., Di Febbraro, M.,
Profico, A., Girardi, G., &amp; Raia, P. (2019) Simultaneous detection of
macroevolutionary patterns in phenotypic means and rate of change with and
within phylogenetic trees including extinct species. <em>PLoS ONE</em>, 14:
e0210101. https://doi.org/10.1371/journal.pone.0210101
</p>


<h3>See Also</h3>

<p><a href="../doc/search.trend.html"><code>search.trend</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotTrend</code> vignette</a>
</p>
<p><code><a href="#topic+plotTrend">plotTrend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
cc&lt;- 2/parallel::detectCores()

# Extract Pterosaurs tree and data
library(ape)
extract.clade(treedino,746)-&gt;treeptero
massdino[match(treeptero$tip.label,names(massdino))]-&gt;massptero
massptero[match(treeptero$tip.label,names(massptero))]-&gt;massptero

# Case 1. "RRphylo" whitout accounting for the effect of a covariate
RRphylo(tree=treeptero,y=log(massptero),clus=cc)-&gt;RRptero

# Case 1.1. "search.trend" whitout indicating nodes to be tested for trends
search.trend(RR=RRptero, y=log(massptero), nsim=100, clus=cc,cov=NULL,node=NULL)

# Case 1.2. "search.trend" indicating nodes to be specifically tested for trends
search.trend(RR=RRptero, y=log(massptero), nsim=100, node=143, clus=cc,cov=NULL)


# Case 2. "RRphylo" accounting for the effect of a covariate
# "RRphylo" on the covariate in order to retrieve ancestral state values
RRphylo(tree=treeptero,y=log(massptero),clus=cc)-&gt;RRptero
c(RRptero$aces,log(massptero))-&gt;cov.values
names(cov.values)&lt;-c(rownames(RRptero$aces),names(massptero))
RRphylo(tree=treeptero,y=log(massptero),cov=cov.values,clus=cc)-&gt;RRpteroCov

# Case 2.1. "search.trend" whitout indicating nodes to be tested for trends
search.trend(RR=RRpteroCov, y=log(massptero), nsim=100, clus=cc,cov=cov.values)

# Case 2.2. "search.trend" indicating nodes to be specifically tested for trends
search.trend(RR=RRpteroCov, y=log(massptero), nsim=100, node=143, clus=cc,cov=cov.values)


# Case 3. "search.trend" on multiple "RRphylo"
data("DataCetaceans")
DataCetaceans$treecet-&gt;treecet
DataCetaceans$masscet-&gt;masscet
DataCetaceans$brainmasscet-&gt;brainmasscet
DataCetaceans$aceMyst-&gt;aceMyst

drop.tip(treecet,treecet$tip.label[-match(names(brainmasscet),treecet$tip.label)])-&gt;treecet.multi
masscet[match(treecet.multi$tip.label,names(masscet))]-&gt;masscet.multi

RRphylo(tree=treecet.multi,y=masscet.multi,clus=cc)-&gt;RRmass.multi
RRmass.multi$aces[,1]-&gt;acemass.multi
c(acemass.multi,masscet.multi)-&gt;x1.mass

RRphylo(tree=treecet.multi,y=brainmasscet,x1=x1.mass,clus=cc)-&gt;RRmulti

# incorporating the effect of body size at inspecting trends in absolute evolutionary rates
search.trend(RR=RRmulti, y=brainmasscet,x1=x1.mass,clus=cc)

# incorporating the effect of body size at inspecting trends in both absolute evolutionary
# rates and phenotypic values (by using brain versus body mass regression residuals)
search.trend(RR=RRmulti, y=brainmasscet,x1=x1.mass,x1.residuals=TRUE,clus=cc)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='setBM'>Producing simulated phenotypes with trends</h2><span id='topic+setBM'></span>

<h3>Description</h3>

<p>The function <code>setBM</code> is wrapper around <span class="pkg">phytools</span>
<code>fastBM</code> function, which generates BM simulated phenotypes with or
without a trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBM(tree, nY = 1, s2 = 1, a = 0, type = c("", "brown","trend",
  "drift"), trend.type = c("linear", "stepwise"),tr = 10, t.shift = 0.5,
  es=2, ds=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setBM_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="setBM_+3A_ny">nY</code></td>
<td>
<p>the number of phenotypes to simulate.</p>
</td></tr>
<tr><td><code id="setBM_+3A_s2">s2</code></td>
<td>
<p>value of the Brownian rate to use in the simulations.</p>
</td></tr>
<tr><td><code id="setBM_+3A_a">a</code></td>
<td>
<p>the phenotype at the tree root.</p>
</td></tr>
<tr><td><code id="setBM_+3A_type">type</code></td>
<td>
<p>the type of phenotype to simulate. With the option <code>"brown"</code>
the phenotype will have no trend in the phenotypic mean or in the rate of
evolution. A variation in the phenotypic mean over time (a phenotypic
trend) is obtained by selecting the option <code>"drift"</code>. A trend in the
rate of evolution produces an increased variance in the residuals over
time. This is obtained by specifying the option <code>"trend"</code>.</p>
</td></tr>
<tr><td><code id="setBM_+3A_trend.type">trend.type</code></td>
<td>
<p>two kinds of heteroscedastic residuals are generated under
the <code>"trend"</code> type. The option <code>"linear"</code> produces an exponential
linear increase (or decrease) in heteroscedasticity, whereas the
<code>"stepwise"</code> option produces an increase (or decrease) after a
specified point in time.</p>
</td></tr>
<tr><td><code id="setBM_+3A_tr">tr</code></td>
<td>
<p>the intensity of the trend with the <code>"stepwise"</code> option is
controlled by the <code>tr</code> argument. The scalar <code>tr</code> is the
multiplier of the branches extending after the shift point as indicated by
<code>t.shift</code>.</p>
</td></tr>
<tr><td><code id="setBM_+3A_t.shift">t.shift</code></td>
<td>
<p>the relative time distance from the tree root where the
stepwise change in the rate of evolution is indicated to apply.</p>
</td></tr>
<tr><td><code id="setBM_+3A_es">es</code></td>
<td>
<p>when <code>trend.type="linear"</code>, <code>es</code> is a scalar representing
the exponent at which the evolutionary time (i.e. distance from the root)
scales to change to phenotypic variance. With <code>es</code> = 1 the phenotypic
rate will be trendless, with <code>es</code> &lt; 1 the variance of the phenotypes
will decrease exponentially towards the present and the other way around
with <code>es</code> &gt; 1.</p>
</td></tr>
<tr><td><code id="setBM_+3A_ds">ds</code></td>
<td>
<p>a scalar indicating the change in phenotypic mean in the unit time,
in <code>type="drift"</code> case. With <code>ds</code> = 0 the phenotype will be
trendless, with <code>ds</code> &lt; 0 the phenotypic mean will decrease
exponentially towards the present and the other way around with <code>ds</code> &gt;
0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>setBM</code> differs from <code>fastBM</code> in that the
produced phenotypes are checked for the existence of a temporal trend in
the phenotype. The user may specify whether she wants trendless data
(option <code>"brown"</code>), phenotypes trending in time (option
<code>"drift"</code>), or phenotypes whose variance increases/decreases
exponentially over time, consistently with the existence of a trend in the
rate of evolution (option <code>"trend"</code>). In the latter case, the user may
indicate the intensity of the trend (by applying different values of
<code>es</code>), and whether it should occur after a given proportion of the
tree height (hence a given point back in time, specified by the argument
<code>t.shift</code>). Trees in <code>setBM</code> are treated as non ultrametric. If
an ultrametric tree is fed to the function, <code>setBM</code> alters slightly
the leaf lengths multiplying randomly half of the leaves by 1 * 10e-3,in
order to make it non-ultrametric.
</p>


<h3>Value</h3>

<p>Either an object of class <code>'array'</code> containing a single
phenotype or an object of class <code>'matrix'</code> of <em>n</em> phenotypes as
columns, where <em>n</em> is indicated as <code>nY</code> = <em>n</em>.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino

setBM(tree=treedino, nY= 1, type="brown")
setBM(tree=treedino, nY= 1, type="drift", ds=2)
setBM(tree=treedino, nY= 1, type="trend", trend.type="linear", es=2)
</code></pre>

<hr>
<h2 id='sig2BM'>Brownian Motion rate computation</h2><span id='topic+sig2BM'></span>

<h3>Description</h3>

<p>The function computes rate of phenotypic evolution along a phylogeny assuming Brownian Motion model of evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig2BM(tree,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig2BM_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="sig2BM_+3A_y">y</code></td>
<td>
<p>either a single vector variable or a multivariate dataset. In any
case, <code>y</code> must be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Brownian Motion rate of phenotypic evolution for each variable in <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Univariate data ###
data(DataCetaceans)
DataCetaceans$treecet-&gt;treecet
DataCetaceans$masscet-&gt;masscet
sig2BM(tree=treecet,y=masscet)

### Multivariate data ###
data(DataUng)
DataUng$treeung-&gt;treeung
DataUng$PCscoresung-&gt;PCscores
sig2BM(tree=treeung,y=PCscores)
</code></pre>

<hr>
<h2 id='sizedsubtree'>Find a node subtending to a clade of desired size</h2><span id='topic+sizedsubtree'></span>

<h3>Description</h3>

<p>The function <code>sizedsubtree</code> scans a phylogentic tree to
randomly find nodes subtending to a subtree of desired minimum size, up to
one half of the tree size (number of tips).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizedsubtree(tree,Size=NULL,time.limit=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizedsubtree_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="sizedsubtree_+3A_size">Size</code></td>
<td>
<p>the desired size of the tree subtending to the extracted node. By
default, the minimum tree size is set at one tenth of the tree size (i.e.
number of tips).</p>
</td></tr>
<tr><td><code id="sizedsubtree_+3A_time.limit">time.limit</code></td>
<td>
<p>specifies a limit to the searching time, a warning message
is thrown if the limit is reached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>time.limit</code> sets the searching time. The
algorithm stops if that limit is reached, avoiding recursive search when no
solution is in fact possible.
</p>


<h3>Value</h3>

<p>A node subtending to a subtree of desired minimum size.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino

sizedsubtree(tree=treedino,Size=40)
</code></pre>

<hr>
<h2 id='StableTraitsR'>Run StableTraits from within R</h2><span id='topic+StableTraitsR'></span>

<h3>Description</h3>

<p>This function runs StableTraits and StableTraitsSum
(<cite>Elliot and Mooers 2014</cite>) from within the R environment and returns
its output into the workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StableTraitsR(tree,y,path,output=NULL,aces=NULL,argST=NULL,argSTS=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StableTraitsR_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be either ultrametric
or fully dichotomous.</p>
</td></tr>
<tr><td><code id="StableTraitsR_+3A_y">y</code></td>
<td>
<p>a named vector of phenotypic trait.</p>
</td></tr>
<tr><td><code id="StableTraitsR_+3A_path">path</code></td>
<td>
<p>the folder path where the StableTraits output will be stored.
Notice that the input tree and data (modified automatically if the original
tree is not fully dichotomous or if <code>aces</code> are specified) will be
stored in this folder as well.</p>
</td></tr>
<tr><td><code id="StableTraitsR_+3A_output">output</code></td>
<td>
<p>name of the output to be returned, if unspecified it will be
named &quot;output&quot;.</p>
</td></tr>
<tr><td><code id="StableTraitsR_+3A_aces">aces</code></td>
<td>
<p>a named vector of ancestral character values at nodes specified
in advance. Names correspond to the nodes in the tree.</p>
</td></tr>
<tr><td><code id="StableTraitsR_+3A_argst">argST</code></td>
<td>
<p>a list of further arguments passed to StableTraits. If the
argument has no value (for example &quot;brownian&quot;) it must be specified as
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="StableTraitsR_+3A_argsts">argSTS</code></td>
<td>
<p>list of further arguments passed to StableTraitsSum. If the
argument has no value (for example &quot;brownian&quot;) it must be specified as
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The StableTraits software is available at https://mickelliot.com/,
along with instructions for compilation. Once it is installed, the user
must set as R working directory the folder where the StableTraits software
are installed. Further information about the arguments and outputs of
StableTraits and StableTraitsSum can be found at https://mickelliot.com/.
<code>StableTraitsR</code> automatically recognizes which Operating System is
running on the computer (it has been tested successfully on MacOS and
Windows machines).
</p>


<h3>Value</h3>

<p>The function returns a 'list' containing the output of StableTraits
and StableTraitsSum.
</p>
<p><strong>$progress</strong> a table reporting the DIC and PRSF diagnostics.
</p>
<p><strong>$rates_tree</strong> a copy of the original tree with branch lengths
set to the evolutionary rate imputed by the stable reconstruction.
Specifically, each branch length is equal to the absolute difference in the
stable reconstruction occurring on that branch divided by the square root
of the input branch length.
</p>
<p><strong>$rates</strong> the original branch lengths, evolutionary rates, node
height and (optionally) scaled branch lengths.
</p>
<p><strong>$aces</strong> the median estimates of ancestral states and stable
parameters along with the 95% credible interval.
</p>
<p><strong>$brownian_tree</strong> if &quot;brownian&quot; is <code>TRUE</code> in
<code>argSTS</code>, a copy of the original tree with branch lengths set such
that the Brownian motion reconstruction of the character on this tree is
approximately the same as the stable ancestral reconstruction.
</p>
<p><strong>$ace.prior.values</strong> if <code>aces</code> is specified, the function
returns a dataframe containing the corresponding node number on the
<code>RRphylo</code> tree for each node, the original (preset) and the estimated
values, and the 95% credible interval.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia
</p>


<h3>References</h3>

<p>Elliot, M. G., &amp; Mooers, A. Ø. (2014). Inferring ancestral states
without assuming neutrality or gradualism using a stable model of
continuous character evolution. <em>BMC evolutionary biology</em>, 14: 226.
doi.org/10.1186/s12862-014-0226-8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ape)
library(phytools)

# Set as working directory the folder where StableTraits software are stored
# setwd("~/StableTraits")

dir.create("Analyses")
rtree(100)-&gt;tree
fastBM(tree)-&gt;y
c(1,2,3)-&gt;acev
sample(Ntip(tree)+seq(1:Nnode(tree)),3)-&gt;names(acev)
StableTraitsR(tree,y,path="Analyses/",output="my_output",aces=acev,
argST=list(iterations=500000,chains=4),argSTS=list(brownian=TRUE))-&gt;ST

## End(Not run)
</code></pre>

<hr>
<h2 id='swapONE'>Create alternative phylogenies from a given tree</h2><span id='topic+swapONE'></span>

<h3>Description</h3>

<p>The function produces an alternative phylogeny with altered
topology and branch length, and computes the Kuhner-Felsenstein (Kuhner &amp;
Felsenstein 1994) distance between original and 'swapped' tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapONE(tree,node=NULL,si=0.5,si2=0.5,plot.swap=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swapONE_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous.</p>
</td></tr>
<tr><td><code id="swapONE_+3A_node">node</code></td>
<td>
<p>if specified, the clades subtended by such <code>node(s)</code> are
imposed to be monophyletic. In this case, the function can still swap tips
<em>within</em> the clade.</p>
</td></tr>
<tr><td><code id="swapONE_+3A_si">si</code></td>
<td>
<p>the proportion of tips whose topologic arrangement will be swapped.</p>
</td></tr>
<tr><td><code id="swapONE_+3A_si2">si2</code></td>
<td>
<p>the proportion of nodes whose age will be changed.</p>
</td></tr>
<tr><td><code id="swapONE_+3A_plot.swap">plot.swap</code></td>
<td>
<p>if <code>TRUE</code>, the function plots the swapped tree. Swapped
positions appear in red. Nodes with altered ages appear in green.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>swapONE</code> changes the tree topology and branch lengths. Up to
half of the tips, and half of the branch lengths can be changed randomly.
Each randomly selected node is allowed to move up to 2 nodes apart from its
original position.
</p>


<h3>Value</h3>

<p>The function returns a list containing the 'swapped' version of the
original tree, and the Kuhner-Felsenstein distance between the trees. Note,
tip labels are ordered according to their position in the tree.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Kuhner, M. K. &amp; Felsenstein, J. (1994). A simulation comparison
of phylogeny algorithms under equal and unequal evolutionary rates,
<em>Molecular Biology and Evolution</em>, 11: 459-468.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino

## Case 1. change the topology and the branch lengths for the entire tree
swapONE(tree=treedino,si=0.5,si2=0.5,plot.swap=FALSE)

## Case 2. change the topology and the branch lengths of the
##         tree by keeping the monophyly of a specific clade
swapONE(tree=treedino,node=422,si=0.5,si2=0.5,plot.swap=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='tips'>Get descending tips</h2><span id='topic+tips'></span>

<h3>Description</h3>

<p>The function returns the numbers or labels of tips descending from a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tips(tree,node,labels=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tips_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="tips_+3A_node">node</code></td>
<td>
<p>the number of focal node</p>
</td></tr>
<tr><td><code id="tips_+3A_labels">labels</code></td>
<td>
<p>if <code>TRUE</code> (default) the function returns the labels of descending tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tips, either labels or numbers depending on the argument <code>labels</code>, descending from the <code>node</code>.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DataOrnithodirans)
DataOrnithodirans$treedino-&gt;treedino
tips(tree=treedino,node=677,labels=FALSE)
tips(tree=treedino,node=677,labels=TRUE)
</code></pre>

<hr>
<h2 id='tree.merger'>Fast addition of tips and clades on an existing tree</h2><span id='topic+tree.merger'></span>

<h3>Description</h3>

<p>The function attaches new tips and/or clades derived from a
source phylogeny to a pre-existing backbone tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.merger(backbone,data,source.tree=NULL,age.offset=NULL,tip.ages =
  NULL, node.ages = NULL,min.branch=NULL,plot=TRUE,filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.merger_+3A_backbone">backbone</code></td>
<td>
<p>the backbone tree to attach tips/clades on.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_data">data</code></td>
<td>
<p>a dataset including as columns:</p>
<ol>
<li><p> bind = the
tips/clades to be attached; </p>
</li>
<li><p> reference = the reference tip or clade
where 'bind' must be attached; </p>
</li>
<li><p> poly = logical specifying if 'bind'
and 'reference' should form a polytomous clade.</p>
</li></ol>
<p> See details for further
explanations.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_source.tree">source.tree</code></td>
<td>
<p>the tree where 'bind' clades are to be extracted from. If
no clade has to be attached, it can be left unspecified.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_age.offset">age.offset</code></td>
<td>
<p>if the most recent age (i.e. the maximum distance from the
tree root) differs between the source and the backbone trees, the
“age.offset” is the difference between them in this exact order (source
minus backbone). It is positive when the backbone tree attains younger age
than the source tree, and vice-versa.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_tip.ages">tip.ages</code></td>
<td>
<p>as in <code><a href="#topic+scaleTree">scaleTree</a></code>, a named vector including the
ages (i.e. the time distance from the youngest tip within the tree) of the
tips. If unspecified, the function assumes all the tips on the backbone
tree are correctly placed and places all the new tips at the maximum
distance from the tree root (i.e. the present if the tips are extant).</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_node.ages">node.ages</code></td>
<td>
<p>as in <code>scaleTree</code>, a named vector including the ages
(i.e. the time distance from the youngest tip within the tree) of the
nodes. The nodes must be defined by collating the names of the two
phylogenetically furthest tips it subtends to, separated by the &quot;-&quot; symbol (see
examples). If no calibration date for nodes is supplied, the function may
shift the node position back in time as to place new tips/clades and to fit
tip ages.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_min.branch">min.branch</code></td>
<td>
<p>has been deprecated.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>, the function produces an interactive plotting
device to check the placing of each <code>bind</code>.</p>
</td></tr>
<tr><td><code id="tree.merger_+3A_filename">filename</code></td>
<td>
<p>if <code>plot=TRUE</code> and provided a <code>filename</code> (with or
without the path), the function stores a pdf file showing the plot of the
entire phylogeny.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function attaches tips and/or clades from the <code>source</code> tree
to the <code>backbone</code> tree according to the <code>data</code> object. Within the
latter, a clade, either to be bound or to be the reference, must be
indicated by collating the names of the two phylogenetically furthest tips
belonging to it, separated by the &quot;-&quot; symbol. Alternatively, if
<code>backbone$node.label</code>/<code>source.tree$node.label</code> is not
<code>NULL</code>, a bind/reference clade can be indicated as &quot;Clade
NAMEOFTHECLADE&quot; when appropriate. Similarly, an entire genus on both the
<code>backbone</code> and the <code>source.tree</code> can be indicated as &quot;Genus
NAMEOFTHEGENUS&quot; (see examples below). Duplicated 'bind' produce error.
Tips/clades set to be attached to the same 'reference' with
'poly=FALSE' are considered to represent a polytomy. Tips set as 'bind'
which are already on the backbone tree are removed from the latter and
placed according to the 'reference'. See examples and
<a href="../doc/Tree-Manipulation.html#tree.merger.html">vignette</a> for
clarifications.
</p>


<h3>Value</h3>

<p>Merged phylogenetic tree.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Mondanaro, A., Melchionna, M., &amp;
Raia, P. (2022). Fast production of large, time-calibrated, informal
supertrees with tree.merger. <em>Palaeontology</em>, 65:
e12588.https://doi.org/10.1111/pala.12588
</p>


<h3>See Also</h3>

<p><a href="../doc/Tree-Manipulation.html#tree.merger.html"><code>tree.merger</code>
vignette</a>; <a href="../doc/Tree-Manipulation.html#scaleTree"><code>scaleTree</code>
vignette</a>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 require(ape)
 DataCetaceans$treecet-&gt;tree
 tree$node.label[131-Ntip(tree)]&lt;-"Crown_Mysticeti"

 data.frame(bind=c("Clade Crown_Mysticeti",
                   "Aetiocetus_weltoni",
                   "Saghacetus_osiris",
                   "Zygorhiza_kochii",
                   "Ambulocetus_natans",
                   "Genus Kentriodon",
                   "Tursiops_truncatus-Delphinus_delphis",
                   "Kogia_sima",
                   "Eurhinodelphis_cristatus",
                   "Grampus_griseus",
                   "Eurhinodelphis_bossi"),
            reference=c("Fucaia_buelli-Aetiocetus_weltoni",
                        "Aetiocetus_cotylalveus",
                        "Fucaia_buelli-Tursiops_truncatus",
                        "Saghacetus_osiris-Fucaia_buelli",
                        "Dalanistes_ahmedi-Fucaia_buelli",
                        "Clade Delphinida",
                        "Stenella_attenuata-Stenella_longirostris",
                        "Kogia_breviceps",
                        "Eurhinodelphis_longirostris",
                        "Globicephala_melas-Pseudorca_crassidens",
                        "Eurhinodelphis_longirostris"),
            poly=c(FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE,
                   FALSE))-&gt;dato

 c(Aetiocetus_weltoni=28.0,
   Saghacetus_osiris=33.9,
   Zygorhiza_kochii=34.0,
   Ambulocetus_natans=40.4,
   Kentriodon_pernix=15.9,
   Kentriodon_schneideri=11.61,
   Kentriodon_obscurus=13.65,
   Eurhinodelphis_bossi=13.65,
   Eurhinodelphis_cristatus=5.33)-&gt;tip.ages
 c("Ambulocetus_natans-Fucaia_buelli"=52.6,
   "Balaena_mysticetus-Caperea_marginata"=21.5)-&gt;node.ages

 # remove some tips from the original tree and create a source tree
 drop.tip(tree,c(names(tip.ages),
                 tips(tree,131)[-which(tips(tree,131)%in%
                               c("Caperea_marginata","Eubalaena_australis"))],
                 tips(tree,195)[-which(tips(tree,195)=="Tursiops_aduncus")]))-&gt;backtree
 drop.tip(tree,which(!tree$tip.label%in%c(names(tip.ages),
                                          tips(tree,131),
                                          tips(tree,195))))-&gt;sourcetree

 plot(backtree,cex=.6)
 plot(sourcetree,cex=.6)

 tree.merger(backbone=backtree,data=dato,source.tree=sourcetree,
             tip.ages=tip.ages,node.ages = node.ages, plot=TRUE)-&gt;treeM
   
## End(Not run)
</code></pre>

<hr>
<h2 id='treeCompare'>Visualize the difference between phylogenetic trees</h2><span id='topic+treeCompare'></span>

<h3>Description</h3>

<p>The function scans a pair of phylogenetic trees to find
topological differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeCompare(tree, tree1, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeCompare_+3A_tree">tree</code>, <code id="treeCompare_+3A_tree1">tree1</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric
and fully dichotomous. Generic name and specific epithet must be separated
by '_'.</p>
</td></tr>
<tr><td><code id="treeCompare_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>, the function produces an interactive plotting
device to check differences in species placement at the genus level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data-frame indicating for each un-matching
species its sister species/clades on both trees.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Antonella Esposito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DataSimians$tree-&gt;tree
set.seed(22)
swapONE(tree,si=0.5)[[1]]-&gt;tree1

treeCompare(tree,tree1)


## End(Not run)
</code></pre>

<hr>
<h2 id='treedataMatch'>Cross-reference tree and data</h2><span id='topic+treedataMatch'></span>

<h3>Description</h3>

<p>The function matches data names with tree tips. If either there is no
data for a tip or it is not present on the tree, the function removes the entry
from both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treedataMatch(tree,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treedataMatch_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric and
fully dichotomous.</p>
</td></tr>
<tr><td><code id="treedataMatch_+3A_y">y</code></td>
<td>
<p>either a single vector variable or a multivariate dataset. In any
case, <code>y</code> must be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>list</code> object. If no mismatch between
<code>tree</code> and <code>y</code> is detected, the list only includes the matrix of
<code>y</code> ordered according to the order of tips on the tree (<code>$y</code>).
If some tips on the <code>tree</code> are missing from <code>y</code>, they are
removed from the phylogeny. Thus, the list also includes the pruned tree
(<code>$tree</code>) and the vector of dropped tips
(<code>$removed.from.tree</code>). Similarly, if some entries in <code>y</code> are
missing from the <code>tree</code>, the list also includes the vector of
mismatching entry names (<code>$removed.from.y</code>). In this latter case, the
first element of the list (<code>$y</code>) does not include the entries
<code>$removed.from.y</code>, so that it perfectly matches the phylogeny.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Pasquale Raia, Carmela Serio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DataCetaceans)
DataCetaceans$treecet-&gt;treecet
DataCetaceans$masscet-&gt;masscet
DataCetaceans$brainmasscet-&gt;brainmasscet

treedataMatch(tree=treecet,y=masscet)
treedataMatch(tree=treecet,y=brainmasscet)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
