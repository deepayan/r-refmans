<!DOCTYPE html><html><head><title>Help for package slendr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slendr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#slendr'><p>A Simulation Framework for Spatiotemporal Population Genetics</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#animate_model'><p>Animate the simulated population dynamics</p></a></li>
<li><a href='#area'><p>Calculate the area covered by the given slendr object</p></a></li>
<li><a href='#as.phylo.slendr_phylo'><p>Convert an annotated <code>slendr_phylo</code> object to a <code>phylo</code> object</p></a></li>
<li><a href='#check_dependencies'><p>Check that the required dependencies are available for slendr to work</p></a></li>
<li><a href='#check_env'><p>Check that the active Python environment is setup for slendr</p></a></li>
<li><a href='#clear_env'><p>Remove the automatically created slendr Python environment</p></a></li>
<li><a href='#compile_model'><p>Compile a slendr demographic model</p></a></li>
<li><a href='#distance'><p>Calculate the distance between a pair of spatial boundaries</p></a></li>
<li><a href='#expand_range'><p>Expand the population range</p></a></li>
<li><a href='#explore_model'><p>Open an interactive browser of the spatial model</p></a></li>
<li><a href='#gene_flow'><p>Define a gene-flow event between two populations</p></a></li>
<li><a href='#get_env'><p>Get the name of the current slendr Python environment</p></a></li>
<li><a href='#init_env'><p>Activate slendr's own dedicated Python environment</p></a></li>
<li><a href='#join'><p>Merge two spatial <code>slendr</code> objects into one</p></a></li>
<li><a href='#move'><p>Move the population to a new location in a given amount of time</p></a></li>
<li><a href='#msprime'><p>Run a slendr model in msprime</p></a></li>
<li><a href='#overlap'><p>Generate the overlap of two <code>slendr</code> objects</p></a></li>
<li><a href='#plot_map'><p>Plot <code>slendr</code> geographic features on a map</p></a></li>
<li><a href='#plot_model'><p>Plot demographic history encoded in a slendr model</p></a></li>
<li><a href='#population'><p>Define a population</p></a></li>
<li><a href='#print.slendr_pop'><p>Print a short summary of a <code>slendr</code> object</p></a></li>
<li><a href='#print.slendr_ts'><p>Print tskit's summary table of the Python tree-sequence object</p></a></li>
<li><a href='#read_model'><p>Read a previously serialized model configuration</p></a></li>
<li><a href='#region'><p>Define a geographic region</p></a></li>
<li><a href='#reproject'><p>Reproject coordinates between coordinate systems</p></a></li>
<li><a href='#resize'><p>Change the population size</p></a></li>
<li><a href='#schedule_sampling'><p>Define sampling events for a given set of populations</p></a></li>
<li><a href='#set_dispersal'><p>Change dispersal parameters</p></a></li>
<li><a href='#set_range'><p>Update the population range</p></a></li>
<li><a href='#setup_env'><p>Setup a dedicated Python virtual environment for slendr</p></a></li>
<li><a href='#shrink_range'><p>Shrink the population range</p></a></li>
<li><a href='#slim'><p>Run a slendr model in SLiM</p></a></li>
<li><a href='#subtract'><p>Generate the difference between two <code>slendr</code> objects</p></a></li>
<li><a href='#summary.slendr_nodes'><p>Summarise the contents of a <code>ts_nodes</code> result</p></a></li>
<li><a href='#ts_afs'><p>Compute the allele frequency spectrum (AFS)</p></a></li>
<li><a href='#ts_ancestors'><p>Extract (spatio-)temporal ancestral history for given nodes/individuals</p></a></li>
<li><a href='#ts_coalesced'><p>Check that all trees in the tree sequence are fully coalesced</p></a></li>
<li><a href='#ts_descendants'><p>Extract all descendants of a given tree-sequence node</p></a></li>
<li><a href='#ts_divergence'><p>Calculate pairwise divergence between sets of individuals</p></a></li>
<li><a href='#ts_diversity'><p>Calculate diversity in given sets of individuals</p></a></li>
<li><a href='#ts_draw'><p>Plot a graphical representation of a single tree</p></a></li>
<li><a href='#ts_edges'><p>Extract spatio-temporal edge annotation table from a given tree or tree</p>
sequence</a></li>
<li><a href='#ts_eigenstrat'><p>Convert genotypes to the EIGENSTRAT file format</p></a></li>
<li><a href='#ts_f2'><p>Calculate the f2, f3, f4, and f4-ratio statistics</p></a></li>
<li><a href='#ts_fst'><p>Calculate pairwise statistics between sets of individuals</p></a></li>
<li><a href='#ts_genotypes'><p>Extract genotype table from the tree sequence</p></a></li>
<li><a href='#ts_ibd'><p>Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL)</p></a></li>
<li><a href='#ts_load'><p>Load a tree sequence file produced by a given model</p></a></li>
<li><a href='#ts_metadata'><p>Extract list with tree sequence metadata saved by SLiM</p></a></li>
<li><a href='#ts_mutate'><p>Add mutations to the given tree sequence</p></a></li>
<li><a href='#ts_names'><p>Extract names of individuals in a tree sequence</p></a></li>
<li><a href='#ts_nodes'><p>Extract combined annotated table of individuals and nodes</p></a></li>
<li><a href='#ts_phylo'><p>Convert a tree in the tree sequence to an object of the class <code>phylo</code></p></a></li>
<li><a href='#ts_recapitate'><p>Recapitate the tree sequence</p></a></li>
<li><a href='#ts_samples'><p>Extract names and times of individuals of interest in the current tree sequence</p>
(either all sampled individuals or those that the user simplified to)</a></li>
<li><a href='#ts_save'><p>Save a tree sequence to a file</p></a></li>
<li><a href='#ts_segregating'><p>Calculate the density of segregating sites for the given sets of individuals</p></a></li>
<li><a href='#ts_simplify'><p>Simplify the tree sequence down to a given set of individuals</p></a></li>
<li><a href='#ts_table'><p>Get the table of individuals/nodes/edges/mutations from the tree sequence</p></a></li>
<li><a href='#ts_tajima'><p>Calculate Tajima's D for given sets of individuals</p></a></li>
<li><a href='#ts_tracts'><p>Extract ancestry tracts from a tree sequence (EXPERIMENTAL)</p></a></li>
<li><a href='#ts_tree'><p>Get a tree from a given tree sequence</p></a></li>
<li><a href='#ts_vcf'><p>Save genotypes from the tree sequence as a VCF file</p></a></li>
<li><a href='#world'><p>Define a world map for all spatial operations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Simulation Framework for Spatiotemporal Population Genetics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for simulating spatially explicit genomic data which
    leverages real cartographic information for programmatic and visual encoding
    of spatiotemporal population dynamics on real geographic landscapes. Population
    genetic models are then automatically executed by the 'SLiM' software by Haller
    et al. (2019) &lt;<a href="https://doi.org/10.1093%2Fmolbev%2Fmsy228">doi:10.1093/molbev/msy228</a>&gt; behind the scenes, using a custom
    built-in simulation 'SLiM' script. Additionally, fully abstract spatial models
    not tied to a specific geographic location are supported, and users can also
    simulate data from standard, non-spatial, random-mating models. These can be
    simulated either with the 'SLiM' built-in back-end script, or using an efficient
    coalescent population genetics simulator 'msprime' by Baumdicker et al. (2022)
    &lt;<a href="https://doi.org/10.1093%2Fgenetics%2Fiyab229">doi:10.1093/genetics/iyab229</a>&gt; with a custom-built 'Python' script bundled with the
    R package. Simulated genomic data is saved in a tree-sequence format and can be
    loaded, manipulated, and summarised using tree-sequence functionality via an R
    interface to the 'Python' module 'tskit' by Kelleher et al. (2019)
    &lt;<a href="https://doi.org/10.1038%2Fs41588-019-0483-y">doi:10.1038/s41588-019-0483-y</a>&gt;. Complete model configuration, simulation and
    analysis pipelines can be therefore constructed without a need to leave the R
    environment, eliminating friction between disparate tools for population genetic
    simulations and data analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>'SLiM' is a forward simulation software for
population genetics and evolutionary biology. See
&lt;https://messerlab.org/slim/&gt; for installation instructions and
further information. The 'Python' coalescent framework
'msprime' and the 'tskit' module can by installed by following
the instructions at &lt;https://tskit.dev/&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, dplyr, purrr, readr, magrittr, reticulate, tidyr,
png, ijtiff, ape, shinyWidgets, shiny, scales, digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), sf, stars, rnaturalearth, gganimate,
knitr, rmarkdown, admixr, units, magick, cowplot, forcats, rsvg</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bodkan/slendr">https://github.com/bodkan/slendr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bodkan/slendr/issues">https://github.com/bodkan/slendr/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 14:16:58 UTC; mp</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Petr <a href="https://orcid.org/0000-0003-4879-8421"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Petr &lt;contact@bodkan.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='slendr'>A Simulation Framework for Spatiotemporal Population Genetics</h2><span id='topic+slendr-package'></span><span id='topic+slendr'></span>

<h3>Description</h3>

<p>A framework for simulating spatially explicit genomic data which
leverages real cartographic information for programmatic and visual encoding
of spatiotemporal population dynamics on real geographic landscapes. Population
genetic models are then automatically executed by the 'SLiM' software behind
the scenes, using a custom built-in simulation 'SLiM' script. Additionally,
fully abstract spatial models not tied to a specific geographic location are
supported, and users can also simulate data from standard, non-spatial,
random-mating models. These can be simulated either with the 'SLiM' built-in
back-end script, or using an efficient coalescent population genetics simulator
'msprime' with a custom-built 'Python' script bundled with the R package.
Simulated genomic data is saved in a tree-sequence format and can be loaded,
manipulated, and summarised using tree-sequence functionality via an R
interface to the 'Python' module 'tskit'. Complete model configuration,
simulation and analysis pipelines can be therefore constructed without
a need to leave the R environment, eliminating friction between disparate
tools for population genetic simulations and data analysis.
</p>


<h3>Details</h3>

<p>You can find installation instructions, reference manual, and tutorials at
<a href="https://www.slendr.net">https://www.slendr.net</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Petr <a href="mailto:contact@bodkan.net">contact@bodkan.net</a> (<a href="https://orcid.org/0000-0003-4879-8421">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bodkan/slendr">https://github.com/bodkan/slendr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bodkan/slendr/issues">https://github.com/bodkan/slendr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>

<hr>
<h2 id='animate_model'>Animate the simulated population dynamics</h2><span id='topic+animate_model'></span>

<h3>Description</h3>

<p>Animate the simulated population dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate_model(model, file, steps, gif = NULL, width = 800, height = 560)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_model_+3A_model">model</code></td>
<td>
<p>Compiled <code>slendr_model</code> model object</p>
</td></tr>
<tr><td><code id="animate_model_+3A_file">file</code></td>
<td>
<p>Path to the table of saved individual locations</p>
</td></tr>
<tr><td><code id="animate_model_+3A_steps">steps</code></td>
<td>
<p>How many frames should the animation have?</p>
</td></tr>
<tr><td><code id="animate_model_+3A_gif">gif</code></td>
<td>
<p>Path to an output GIF file (animation object returned
by default)</p>
</td></tr>
<tr><td><code id="animate_model_+3A_width">width</code>, <code id="animate_model_+3A_height">height</code></td>
<td>
<p>Dimensions of the animation in pixels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>gif = NULL</code>, return gganimate animation object. Otherwise a GIF
file is saved and no value is returned.
</p>

<hr>
<h2 id='area'>Calculate the area covered by the given slendr object</h2><span id='topic+area'></span>

<h3>Description</h3>

<p>Calculate the area covered by the given slendr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_+3A_x">x</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area covered by the input object. If a <code>slendr_pop</code>
was given, a table with an population range area in each time
point will be returned. If a <code>slendr_region</code> or
<code>slendr_world</code> object was specified, the total area covered
by this object's spatial boundary will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>region_a &lt;- region("A", center = c(20, 50), radius = 20)
region_b &lt;- region("B", polygon = list(c(50, 40), c(70, 40), c(70, 60), c(50, 60)))
plot_map(region_a, region_b)

# note that area won't be *exactly* equal to pi*r^2:
#   https://stackoverflow.com/a/65280376
area(region_a)

area(region_b)
</code></pre>

<hr>
<h2 id='as.phylo.slendr_phylo'>Convert an annotated <code>slendr_phylo</code> object to a <code>phylo</code> object</h2><span id='topic+as.phylo.slendr_phylo'></span>

<h3>Description</h3>

<p>This function servers as a workaround around a ggtree error:
<code>Error in UseMethod("as.phylo") :
    no applicable method for 'as.phylo' applied to an object of class
    "c('phylo', 'slendr_phylo')"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slendr_phylo'
as.phylo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.phylo.slendr_phylo_+3A_x">x</code></td>
<td>
<p>Tree object of the class <code>slendr_phylo</code></p>
</td></tr>
<tr><td><code id="as.phylo.slendr_phylo_+3A_...">...</code></td>
<td>
<p>Additional (unused) arguments of the <code>as.phylo</code> S3 method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard phylogenetic tree object implemented by the R package ape
</p>

<hr>
<h2 id='check_dependencies'>Check that the required dependencies are available for slendr to work</h2><span id='topic+check_dependencies'></span>

<h3>Description</h3>

<p>Check that the required dependencies are available for slendr to work
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dependencies(python = FALSE, slim = FALSE, quit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dependencies_+3A_python">python</code></td>
<td>
<p>Is the slendr Python environment required?</p>
</td></tr>
<tr><td><code id="check_dependencies_+3A_slim">slim</code></td>
<td>
<p>Is SLiM required?</p>
</td></tr>
<tr><td><code id="check_dependencies_+3A_quit">quit</code></td>
<td>
<p>Should the R interpreter quit if required slendr dependencies are
missing? This option (which is not turned on by default, being set to
<code>FALSE</code>) is used mainly in avoiding running slendr man page examples on
machines which lack dependencies. If set to <code>TRUE</code>, a logical value
is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>quit = TRUE</code>, no values is returned, if <code>quit = FALSE</code>,
a scalar logical value is returned indicating whether or not the dependencies
are present.
</p>

<hr>
<h2 id='check_env'>Check that the active Python environment is setup for slendr</h2><span id='topic+check_env'></span>

<h3>Description</h3>

<p>This function inspects the Python environment which has been activated by the
reticulate package and prints the versions of all slendr Python dependencies
to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_env(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_env_+3A_verbose">verbose</code></td>
<td>
<p>Should a log message be printed? If <code>FALSE</code>, only a logical
value is returned (invisibly).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>TRUE</code> (slendr Python environment is present) or <code>FALSE</code>
(slendr Python environment is not present).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()
check_env()
</code></pre>

<hr>
<h2 id='clear_env'>Remove the automatically created slendr Python environment</h2><span id='topic+clear_env'></span>

<h3>Description</h3>

<p>Remove the automatically created slendr Python environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_env(force = FALSE, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_env_+3A_force">force</code></td>
<td>
<p>Ask before deleting any environment?</p>
</td></tr>
<tr><td><code id="clear_env_+3A_all">all</code></td>
<td>
<p>Should all (present and past) slendr Python environments be removed
(default is <code>FALSE</code>) or just the current environment?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='compile_model'>Compile a slendr demographic model</h2><span id='topic+compile_model'></span>

<h3>Description</h3>

<p>First, compiles the vectorized population spatial maps into a series of
binary raster PNG files, which is the format that SLiM understands and uses
it to define population boundaries. Then extracts the demographic model
defined by the user (i.e. population divergences and gene flow events) into a
series of tables which are later used by the built-in SLiM script to program
the timing of simulation events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_model(
  populations,
  generation_time,
  path = NULL,
  resolution = NULL,
  competition = NULL,
  mating = NULL,
  dispersal = NULL,
  gene_flow = list(),
  overwrite = FALSE,
  force = FALSE,
  simulation_length = NULL,
  direction = NULL,
  serialize = TRUE,
  slim_script = NULL,
  description = "",
  sim_length = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_model_+3A_populations">populations</code></td>
<td>
<p>Object(s) of the <code>slendr_pop</code> class (multiple objects
need to be specified in a <code>list</code>)</p>
</td></tr>
<tr><td><code id="compile_model_+3A_generation_time">generation_time</code></td>
<td>
<p>Generation time (in model time units)</p>
</td></tr>
<tr><td><code id="compile_model_+3A_path">path</code></td>
<td>
<p>Output directory for the model configuration files which will be
loaded by the backend SLiM script. If <code>NULL</code>, model configuration
files will be saved to a temporary directory.</p>
</td></tr>
<tr><td><code id="compile_model_+3A_resolution">resolution</code></td>
<td>
<p>How many distance units per pixel?</p>
</td></tr>
<tr><td><code id="compile_model_+3A_competition">competition</code>, <code id="compile_model_+3A_mating">mating</code></td>
<td>
<p>Maximum spatial competition and mating choice
distance</p>
</td></tr>
<tr><td><code id="compile_model_+3A_dispersal">dispersal</code></td>
<td>
<p>Standard deviation of the normal distribution of the
parent-offspring distance</p>
</td></tr>
<tr><td><code id="compile_model_+3A_gene_flow">gene_flow</code></td>
<td>
<p>Gene flow events generated by the <code>gene_flow</code> function
(either a list of data.frame objects in the format defined by the
<code>gene_flow</code> function, or a single data.frame)</p>
</td></tr>
<tr><td><code id="compile_model_+3A_overwrite">overwrite</code></td>
<td>
<p>Completely delete the specified directory, in case it
already exists, and create a new one?</p>
</td></tr>
<tr><td><code id="compile_model_+3A_force">force</code></td>
<td>
<p>Force a deletion of the model directory if it is already
present? Useful for non-interactive uses. In an interactive mode, the user
is asked to confirm the deletion manually.</p>
</td></tr>
<tr><td><code id="compile_model_+3A_simulation_length">simulation_length</code></td>
<td>
<p>Total length of the simulation (required for forward time
models, optional for models specified in backward time units which by
default run to &quot;the present time&quot;)</p>
</td></tr>
<tr><td><code id="compile_model_+3A_direction">direction</code></td>
<td>
<p>Intended direction of time. Under normal circumstances this
parameter is inferred from the model and does not need to be set manually.</p>
</td></tr>
<tr><td><code id="compile_model_+3A_serialize">serialize</code></td>
<td>
<p>Should model files be serialized to disk? If not, only an
R model object will be returned but no files will be created. This speeds
up simulation with msprime but prevents using the SLiM back end.</p>
</td></tr>
<tr><td><code id="compile_model_+3A_slim_script">slim_script</code></td>
<td>
<p>Path to a SLiM script to be used for executing the model
(by default, a bundled backend script will be used). If <code>NULL</code>, the
SLiM script bundled with slendr will be used.</p>
</td></tr>
<tr><td><code id="compile_model_+3A_description">description</code></td>
<td>
<p>Optional short description of the model</p>
</td></tr>
<tr><td><code id="compile_model_+3A_sim_length">sim_length</code></td>
<td>
<p>Deprecated. Use <code>simulation_length</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Compiled <code>slendr_model</code> model object which encapsulates all
information about the specified model (which populations are involved,
when and how much gene flow should occur, what is the spatial resolution
of a map, and what spatial dispersal and mating parameters should be used
in a SLiM simulation, if applicable)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='distance'>Calculate the distance between a pair of spatial boundaries</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Calculate the distance between a pair of spatial boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x, y, measure, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code>, <code id="distance_+3A_y">y</code></td>
<td>
<p>Objects of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="distance_+3A_measure">measure</code></td>
<td>
<p>How to measure distance? This can be either <code>'border'</code>
(distance between the borders of <code>x</code> and <code>y</code>) or <code>'center'</code>
(distance between their centroids).</p>
</td></tr>
<tr><td><code id="distance_+3A_time">time</code></td>
<td>
<p>Time closest to the spatial maps of <code>x</code> and <code>y</code> if they
represent <code>slendr_pop</code> population boundaries (ignored for general
<code>slendr_region</code> objects)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the coordinate reference system was specified, a distance in
projected units (i.e. meters) is returned. Otherwise the function returns a
normal Euclidean distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create two regions on a blank abstract landscape
region_a &lt;- region("A", center = c(20, 50), radius = 20)
region_b &lt;- region("B", center = c(80, 50), radius = 20)
plot_map(region_a, region_b)

# compute the distance between the centers of both population ranges
distance(region_a, region_b, measure = "center")

# compute the distance between the borders of both population ranges
distance(region_a, region_b, measure = "border")
</code></pre>

<hr>
<h2 id='expand_range'>Expand the population range</h2><span id='topic+expand_range'></span>

<h3>Description</h3>

<p>Expands the spatial population range by a specified distance in a given
time-window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_range(
  pop,
  by,
  end,
  start,
  overlap = 0.8,
  snapshots = NULL,
  polygon = NULL,
  lock = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_range_+3A_pop">pop</code></td>
<td>
<p>Object of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="expand_range_+3A_by">by</code></td>
<td>
<p>How many units of distance to expand by?</p>
</td></tr>
<tr><td><code id="expand_range_+3A_start">start</code>, <code id="expand_range_+3A_end">end</code></td>
<td>
<p>When does the expansion start/end?</p>
</td></tr>
<tr><td><code id="expand_range_+3A_overlap">overlap</code></td>
<td>
<p>Minimum overlap between subsequent spatial boundaries</p>
</td></tr>
<tr><td><code id="expand_range_+3A_snapshots">snapshots</code></td>
<td>
<p>The number of intermediate snapshots (overrides the
<code>overlap</code> parameter)</p>
</td></tr>
<tr><td><code id="expand_range_+3A_polygon">polygon</code></td>
<td>
<p>Geographic region to restrict the expansion to</p>
</td></tr>
<tr><td><code id="expand_range_+3A_lock">lock</code></td>
<td>
<p>Maintain the same density of individuals. If
<code>FALSE</code> (the default), the number of individuals in the
population will not change. If <code>TRUE</code>, the number of
individuals simulated will be changed (increased or decreased)
appropriately, to match the new population range area.</p>
</td></tr>
<tr><td><code id="expand_range_+3A_verbose">verbose</code></td>
<td>
<p>Report on the progress of generating intermediate spatial
boundaries?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that because slendr models have to accomodate both SLiM and msprime
back ends, population sizes and times of events are rounded to the nearest
integer value.
</p>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='explore_model'>Open an interactive browser of the spatial model</h2><span id='topic+explore_model'></span>

<h3>Description</h3>

<p>Open an interactive browser of the spatial model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explore_model_+3A_model">model</code></td>
<td>
<p>Compiled <code>slendr_model</code> model object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called in order to start an interactive browser-based
interface to explore the dynamics of a slendr model
</p>

<hr>
<h2 id='gene_flow'>Define a gene-flow event between two populations</h2><span id='topic+gene_flow'></span>

<h3>Description</h3>

<p>Define a gene-flow event between two populations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_flow(from, to, rate, start, end, overlap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_flow_+3A_from">from</code>, <code id="gene_flow_+3A_to">to</code></td>
<td>
<p>Objects of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="gene_flow_+3A_rate">rate</code></td>
<td>
<p>Scalar value in the range (0, 1] specifying the
proportion of migration over given time period</p>
</td></tr>
<tr><td><code id="gene_flow_+3A_start">start</code>, <code id="gene_flow_+3A_end">end</code></td>
<td>
<p>Start and end of the gene-flow event</p>
</td></tr>
<tr><td><code id="gene_flow_+3A_overlap">overlap</code></td>
<td>
<p>Require spatial overlap between admixing
populations?  (default <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class data.frame containing parameters of the specified
gene-flow event.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='get_env'>Get the name of the current slendr Python environment</h2><span id='topic+get_env'></span>

<h3>Description</h3>

<p>Get the name of the current slendr Python environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_env()
</code></pre>


<h3>Value</h3>

<p>Name of the slendr Python environment
</p>

<hr>
<h2 id='init_env'>Activate slendr's own dedicated Python environment</h2><span id='topic+init_env'></span>

<h3>Description</h3>

<p>This function attempts to activate a dedicated slendr Miniconda Python
environment previously set up via <code>setup_env</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_env(quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_env_+3A_quiet">quiet</code></td>
<td>
<p>Should informative messages be printed to the console? Default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='join'>Merge two spatial <code>slendr</code> objects into one</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>Merge two spatial <code>slendr</code> objects into one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(x, y, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_x">x</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="join_+3A_y">y</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="join_+3A_name">name</code></td>
<td>
<p>Optional name of the resulting geographic region. If missing,
name will be constructed from the function arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_region</code> which encodes a standard
spatial object of the class <code>sf</code> with several additional attributes
(most importantly a corresponding <code>slendr_map</code> object, if applicable).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a blank abstract world 1000x1000 distance units in size
blank_map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# it is possible to construct custom landscapes (islands, corridors, etc.)
island1 &lt;- region("island1", polygon = list(c(10, 30), c(50, 30), c(40, 50), c(0, 40)))
island2 &lt;- region("island2", polygon = list(c(60, 60), c(80, 40), c(100, 60), c(80, 80)))
island3 &lt;- region("island3", center = c(20, 80), radius = 10)
archipelago &lt;- island1 %&gt;% join(island2) %&gt;% join(island3)

custom_map &lt;- world(xrange = c(1, 100), c(1, 100), landscape = archipelago)

# real Earth landscapes can be defined using freely-available Natural Earth
# project data and with the possibility to specify an appropriate Coordinate
# Reference System, such as this example of a map of Europe

real_map &lt;- world(xrange = c(-15, 40), yrange = c(30, 60), crs = "EPSG:3035")
</code></pre>

<hr>
<h2 id='move'>Move the population to a new location in a given amount of time</h2><span id='topic+move'></span>

<h3>Description</h3>

<p>This function defines a displacement of a population along a given trajectory
in a given time frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move(
  pop,
  trajectory,
  end,
  start,
  overlap = 0.8,
  snapshots = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_+3A_pop">pop</code></td>
<td>
<p>Object of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="move_+3A_trajectory">trajectory</code></td>
<td>
<p>List of two-dimensional vectors (longitude, latitude)
specifying the migration trajectory</p>
</td></tr>
<tr><td><code id="move_+3A_start">start</code>, <code id="move_+3A_end">end</code></td>
<td>
<p>Start/end points of the population migration</p>
</td></tr>
<tr><td><code id="move_+3A_overlap">overlap</code></td>
<td>
<p>Minimum overlap between subsequent spatial boundaries</p>
</td></tr>
<tr><td><code id="move_+3A_snapshots">snapshots</code></td>
<td>
<p>The number of intermediate snapshots (overrides the
<code>overlap</code> parameter)</p>
</td></tr>
<tr><td><code id="move_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of searching through the number of
sufficient snapshots?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='msprime'>Run a slendr model in msprime</h2><span id='topic+msprime'></span>

<h3>Description</h3>

<p>This function will execute a built-in msprime script and run a compiled
slendr demographic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msprime(
  model,
  sequence_length,
  recombination_rate,
  samples = NULL,
  output = NULL,
  random_seed = NULL,
  load = TRUE,
  verbose = FALSE,
  debug = FALSE,
  run = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msprime_+3A_model">model</code></td>
<td>
<p>Model object created by the <code>compile</code> function</p>
</td></tr>
<tr><td><code id="msprime_+3A_sequence_length">sequence_length</code></td>
<td>
<p>Total length of the simulated sequence (in base-pairs)</p>
</td></tr>
<tr><td><code id="msprime_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>Recombination rate of the simulated sequence (in
recombinations per basepair per generation)</p>
</td></tr>
<tr><td><code id="msprime_+3A_samples">samples</code></td>
<td>
<p>A data frame of times at which a given number of individuals
should be remembered in the tree-sequence (see <code>schedule_sampling</code> for a
function that can generate the sampling schedule in the correct format). If
missing, only individuals present at the end of the simulation will be
recorded in the tree-sequence output file.</p>
</td></tr>
<tr><td><code id="msprime_+3A_output">output</code></td>
<td>
<p>Path to the output tree-sequence file. If <code>NULL</code> (the default),
tree sequence will be saved to a temporary file.</p>
</td></tr>
<tr><td><code id="msprime_+3A_random_seed">random_seed</code></td>
<td>
<p>Random seed (if <code>NULL</code>, a seed will be generated between
0 and the maximum integer number available)</p>
</td></tr>
<tr><td><code id="msprime_+3A_load">load</code></td>
<td>
<p>Should the final tree sequence be immediately loaded and returned?
Default is <code>TRUE</code>. The alternative (<code>FALSE</code>) is useful when a tree-sequence
file is written to a custom location to be loaded at a later point.</p>
</td></tr>
<tr><td><code id="msprime_+3A_verbose">verbose</code></td>
<td>
<p>Write the output log to the console (default <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="msprime_+3A_debug">debug</code></td>
<td>
<p>Write msprime's debug log to the console (default <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="msprime_+3A_run">run</code></td>
<td>
<p>Should the msprime engine be run? If <code>FALSE</code>, the command line msprime
command will be printed (and returned invisibly as a character vector) but not executed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree-sequence object loaded via Python-R reticulate interface function <code>ts_load</code>
(internally represented by the Python object <code>tskit.trees.TreeSequence</code>). Optionally,
depending on the value of the arguments <code>load =</code> or <code>run =</code>, nothing or a character
vector, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# afr and eur objects would normally be created before slendr model compilation,
# but here we take them out of the model object already compiled for this
# example (in a standard slendr simulation pipeline, this wouldn't be necessary)
afr &lt;- model$populations[["AFR"]]
eur &lt;- model$populations[["EUR"]]
chimp &lt;- model$populations[["CH"]]

# schedule the sampling of a couple of ancient and present-day individuals
# given model at 20 ky, 10 ky, 5ky ago and at present-day (time 0)
modern_samples &lt;- schedule_sampling(model, times = 0, list(afr, 10), list(eur, 100), list(chimp, 1))
ancient_samples &lt;- schedule_sampling(model, times = c(40000, 30000, 20000, 10000), list(eur, 1))

# sampling schedules are just data frames and can be merged easily
samples &lt;- rbind(modern_samples, ancient_samples)

# run a simulation using the msprime back end from a compiled slendr model object
ts &lt;- msprime(model, sequence_length = 1e5, recombination_rate = 0, samples = samples)

# automatic loading of a simulated output can be prevented by `load = FALSE`, which can be
# useful when a custom path to a tree-sequence output is given for later downstream analyses
output_file &lt;- tempfile(fileext = ".trees")
msprime(model, sequence_length = 1e5, recombination_rate = 0, samples = samples,
        output = output_file, load = FALSE, random_seed = 42)
# ... at a later stage:
ts &lt;- ts_load(output_file, model)

summary(ts)
</code></pre>

<hr>
<h2 id='overlap'>Generate the overlap of two <code>slendr</code> objects</h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>Generate the overlap of two <code>slendr</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(x, y, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_x">x</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="overlap_+3A_y">y</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="overlap_+3A_name">name</code></td>
<td>
<p>Optional name of the resulting geographic region. If missing,
name will be constructed from the function arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_region</code> which encodes a standard
spatial object of the class <code>sf</code> with several additional attributes
(most importantly a corresponding <code>slendr_map</code> object, if applicable).
</p>

<hr>
<h2 id='plot_map'>Plot <code>slendr</code> geographic features on a map</h2><span id='topic+plot_map'></span>

<h3>Description</h3>

<p>Plots objects of the three <code>slendr</code> spatial classes (<code>slendr_map</code>,
<code>slendr_region</code>, and <code>slendr_pop</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_map(
  ...,
  time = NULL,
  gene_flow = FALSE,
  graticules = "original",
  intersect = TRUE,
  show_map = TRUE,
  title = NULL,
  interpolated_maps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_map_+3A_...">...</code></td>
<td>
<p>Objects of classes <code>slendr_map</code>, <code>slendr_region</code>, or
<code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="plot_map_+3A_time">time</code></td>
<td>
<p>Plot a concrete time point</p>
</td></tr>
<tr><td><code id="plot_map_+3A_gene_flow">gene_flow</code></td>
<td>
<p>Indicate geneflow events with an arrow</p>
</td></tr>
<tr><td><code id="plot_map_+3A_graticules">graticules</code></td>
<td>
<p>Plot graticules in the original Coordinate Reference System
(such as longitude-latitude), or in the internal CRS (such as meters)?</p>
</td></tr>
<tr><td><code id="plot_map_+3A_intersect">intersect</code></td>
<td>
<p>Intersect the population boundaries against landscape and
other geographic boundaries (default TRUE)?</p>
</td></tr>
<tr><td><code id="plot_map_+3A_show_map">show_map</code></td>
<td>
<p>Show the underlying world map</p>
</td></tr>
<tr><td><code id="plot_map_+3A_title">title</code></td>
<td>
<p>Title of the plot</p>
</td></tr>
<tr><td><code id="plot_map_+3A_interpolated_maps">interpolated_maps</code></td>
<td>
<p>Interpolated spatial boundaries for all populations
in all time points (this is only used for plotting using the <code>explore</code>
shiny app)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the visualized slendr map
</p>

<hr>
<h2 id='plot_model'>Plot demographic history encoded in a slendr model</h2><span id='topic+plot_model'></span>

<h3>Description</h3>

<p>Plot demographic history encoded in a slendr model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_model(
  model,
  sizes = TRUE,
  proportions = FALSE,
  gene_flow = TRUE,
  log = FALSE,
  order = NULL,
  file = NULL,
  samples = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_model_+3A_model">model</code></td>
<td>
<p>Compiled <code>slendr_model</code> model object</p>
</td></tr>
<tr><td><code id="plot_model_+3A_sizes">sizes</code></td>
<td>
<p>Should population size changes be visualized?</p>
</td></tr>
<tr><td><code id="plot_model_+3A_proportions">proportions</code></td>
<td>
<p>Should gene flow proportions be visualized (<code>FALSE</code>
by default to prevent cluttering and overplotting)</p>
</td></tr>
<tr><td><code id="plot_model_+3A_gene_flow">gene_flow</code></td>
<td>
<p>Should gene-flow arrows be visualized (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot_model_+3A_log">log</code></td>
<td>
<p>Should the y-axis be plotted on a log scale? Useful for models
over very long time-scales.</p>
</td></tr>
<tr><td><code id="plot_model_+3A_order">order</code></td>
<td>
<p>Order of the populations along the x-axis, given as a character
vector of population names. If <code>NULL</code> (the default), the default plotting
algorithm will be used, ordering populations from the most ancestral to the
most recent using an in-order tree traversal.</p>
</td></tr>
<tr><td><code id="plot_model_+3A_file">file</code></td>
<td>
<p>Output file for a figure saved via <code>ggsave</code></p>
</td></tr>
<tr><td><code id="plot_model_+3A_samples">samples</code></td>
<td>
<p>Sampling schedule to be visualized over the model</p>
</td></tr>
<tr><td><code id="plot_model_+3A_...">...</code></td>
<td>
<p>Optional argument which will be passed to <code>ggsave</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the visualized slendr model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
path &lt;- system.file("extdata/models/introgression", package = "slendr")
model &lt;- read_model(path)

plot_model(model, sizes = FALSE, log = TRUE)
</code></pre>

<hr>
<h2 id='population'>Define a population</h2><span id='topic+population'></span>

<h3>Description</h3>

<p>Defines the parameters of a population (non-spatial and spatial).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population(
  name,
  time,
  N,
  parent = NULL,
  map = FALSE,
  center = NULL,
  radius = NULL,
  polygon = NULL,
  remove = NULL,
  intersect = TRUE,
  competition = NA,
  mating = NA,
  dispersal = NA,
  dispersal_fun = NULL,
  aquatic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="population_+3A_name">name</code></td>
<td>
<p>Name of the population</p>
</td></tr>
<tr><td><code id="population_+3A_time">time</code></td>
<td>
<p>Time of the population's first appearance</p>
</td></tr>
<tr><td><code id="population_+3A_n">N</code></td>
<td>
<p>Number of individuals at the time of first appearance</p>
</td></tr>
<tr><td><code id="population_+3A_parent">parent</code></td>
<td>
<p>Parent population object or <code>NULL</code> (which indicates that
the population does not have an ancestor, as it is the first population
in its &quot;lineage&quot;)</p>
</td></tr>
<tr><td><code id="population_+3A_map">map</code></td>
<td>
<p>Object of the type <code>slendr_map</code> which defines the world
context (created using the <code>world</code> function). If the value
<code>FALSE</code> is provided, a non-spatial model will be run.</p>
</td></tr>
<tr><td><code id="population_+3A_center">center</code></td>
<td>
<p>Two-dimensional vector specifying the center of the circular
range</p>
</td></tr>
<tr><td><code id="population_+3A_radius">radius</code></td>
<td>
<p>Radius of the circular range</p>
</td></tr>
<tr><td><code id="population_+3A_polygon">polygon</code></td>
<td>
<p>List of vector pairs, defining corners of the polygon range or
a geographic region of the class <code>slendr_region</code> from which the
polygon coordinates will be extracted (see the <code>region() function</code>)</p>
</td></tr>
<tr><td><code id="population_+3A_remove">remove</code></td>
<td>
<p>Time at which the population should be removed</p>
</td></tr>
<tr><td><code id="population_+3A_intersect">intersect</code></td>
<td>
<p>Intersect the population's boundaries with landscape
features?</p>
</td></tr>
<tr><td><code id="population_+3A_competition">competition</code>, <code id="population_+3A_mating">mating</code></td>
<td>
<p>Maximum spatial competition and mating
choice distance</p>
</td></tr>
<tr><td><code id="population_+3A_dispersal">dispersal</code></td>
<td>
<p>Standard deviation of the normal distribution of the
distance that offspring disperses from its parent</p>
</td></tr>
<tr><td><code id="population_+3A_dispersal_fun">dispersal_fun</code></td>
<td>
<p>Distribution function governing the dispersal of
offspring. One of &quot;normal&quot;, &quot;uniform&quot;, &quot;cauchy&quot;, &quot;exponential&quot;, or
&quot;brownian&quot; (in which vertical and horizontal displacements are drawn from a
normal distribution independently).</p>
</td></tr>
<tr><td><code id="population_+3A_aquatic">aquatic</code></td>
<td>
<p>Is the species aquatic (<code>FALSE</code> by default, i.e.
terrestrial species)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four ways to specify a spatial boundary: i) circular range
specified using a center coordinate and a radius, ii) polygon specified as a
list of two-dimensional vector coordinates, iii) polygon as in ii), but
defined (and named) using the <code>region</code> function, iv) with just a world
map specified (circular or polygon range parameters set to the default
<code>NULL</code> value), the population will be allowed to occupy the entire
landscape.
</p>
<p>Note that because slendr models have to accomodate both SLiM and msprime
back ends, population sizes and split times are rounded to the nearest
integer value.
</p>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='print.slendr_pop'>Print a short summary of a <code>slendr</code> object</h2><span id='topic+print.slendr_pop'></span><span id='topic+print.slendr_region'></span><span id='topic+print.slendr_map'></span><span id='topic+print.slendr_model'></span>

<h3>Description</h3>

<p>All spatial objects in the slendr package are internally represented as
Simple Features (<code>sf</code>) objects. This fact is hidden in most
circumstances this, as the goal of the slendr package is to provide
functionality at a much higher level (population boundaries, geographic
regions, instead of individual polygons and other &quot;low-level&quot; geometric
objects), without the users having to worry about low-level details involved
in handling spatial geometries. However, the full <code>sf</code> object
representation can be always printed by calling <code>x[]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slendr_pop'
print(x, ...)

## S3 method for class 'slendr_region'
print(x, ...)

## S3 method for class 'slendr_map'
print(x, ...)

## S3 method for class 'slendr_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.slendr_pop_+3A_x">x</code></td>
<td>
<p>Object of a class <code>slendr</code> (either <code>slendr_pop</code>,
<code>slendr_map</code>, <code>slendr_region</code>, or <code>slendr_table</code>)</p>
</td></tr>
<tr><td><code id="print.slendr_pop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used only for printing
</p>

<hr>
<h2 id='print.slendr_ts'>Print tskit's summary table of the Python tree-sequence object</h2><span id='topic+print.slendr_ts'></span>

<h3>Description</h3>

<p>Print tskit's summary table of the Python tree-sequence object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slendr_ts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.slendr_ts_+3A_x">x</code></td>
<td>
<p>Tree object of the class <code>slendr_phylo</code></p>
</td></tr>
<tr><td><code id="print.slendr_ts_+3A_...">...</code></td>
<td>
<p>Additional arguments normally passed to <code>print</code> (not used in this case)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, simply prints the tskit summary table to the terminal
</p>

<hr>
<h2 id='read_model'>Read a previously serialized model configuration</h2><span id='topic+read_model'></span>

<h3>Description</h3>

<p>Reads all configuration tables and other model data from a location
where it was previously compiled to by the <code>compile</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_model(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_model_+3A_path">path</code></td>
<td>
<p>Directory with all required configuration files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Compiled <code>slendr_model</code> model object which encapsulates all
information about the specified model (which populations are involved,
when and how much gene flow should occur, what is the spatial resolution
of a map, and what spatial dispersal and mating parameters should be used
in a SLiM simulation, if applicable)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
path &lt;- system.file("extdata/models/introgression", package = "slendr")
model &lt;- read_model(path)

plot_model(model, sizes = FALSE, log = TRUE)
</code></pre>

<hr>
<h2 id='region'>Define a geographic region</h2><span id='topic+region'></span>

<h3>Description</h3>

<p>Creates a geographic region (a polygon) on a given map and gives it
a name. This can be used to define objects which can be reused in
multiple places in a slendr script (such as <code>region</code> arguments
of <code>population</code>) without having to repeatedly define polygon
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>region(name = NULL, map = NULL, center = NULL, radius = NULL, polygon = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="region_+3A_name">name</code></td>
<td>
<p>Name of the geographic region</p>
</td></tr>
<tr><td><code id="region_+3A_map">map</code></td>
<td>
<p>Object of the type <code>sf</code> which defines the map</p>
</td></tr>
<tr><td><code id="region_+3A_center">center</code></td>
<td>
<p>Two-dimensional vector specifying the center of the
circular range</p>
</td></tr>
<tr><td><code id="region_+3A_radius">radius</code></td>
<td>
<p>Radius of the circular range</p>
</td></tr>
<tr><td><code id="region_+3A_polygon">polygon</code></td>
<td>
<p>List of vector pairs, defining corners of the
polygon range or a geographic region of the class
<code>slendr_region</code> from which the polygon coordinates will be
extracted (see the <code>region() function</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_region</code> which encodes a standard
spatial object of the class <code>sf</code> with several additional attributes
(most importantly a corresponding <code>slendr_map</code> object, if applicable).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a blank abstract world 1000x1000 distance units in size
blank_map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# it is possible to construct custom landscapes (islands, corridors, etc.)
island1 &lt;- region("island1", polygon = list(c(10, 30), c(50, 30), c(40, 50), c(0, 40)))
island2 &lt;- region("island2", polygon = list(c(60, 60), c(80, 40), c(100, 60), c(80, 80)))
island3 &lt;- region("island3", center = c(20, 80), radius = 10)
archipelago &lt;- island1 %&gt;% join(island2) %&gt;% join(island3)

custom_map &lt;- world(xrange = c(1, 100), c(1, 100), landscape = archipelago)

# real Earth landscapes can be defined using freely-available Natural Earth
# project data and with the possibility to specify an appropriate Coordinate
# Reference System, such as this example of a map of Europe

real_map &lt;- world(xrange = c(-15, 40), yrange = c(30, 60), crs = "EPSG:3035")
</code></pre>

<hr>
<h2 id='reproject'>Reproject coordinates between coordinate systems</h2><span id='topic+reproject'></span>

<h3>Description</h3>

<p>Converts between coordinates on a compiled raster map (i.e. pixel
units) and different Geographic Coordinate Systems (CRS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproject(
  from,
  to,
  x = NULL,
  y = NULL,
  coords = NULL,
  model = NULL,
  add = FALSE,
  input_prefix = "",
  output_prefix = "new"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reproject_+3A_from">from</code>, <code id="reproject_+3A_to">to</code></td>
<td>
<p>Either a CRS code accepted by GDAL, a valid integer
EPSG value, an object of class <code>crs</code>, the value &quot;raster&quot;
(converting from/to pixel coordinates), or &quot;world&quot; (converting
from/to whatever CRS is set for the underlying map)</p>
</td></tr>
<tr><td><code id="reproject_+3A_x">x</code>, <code id="reproject_+3A_y">y</code></td>
<td>
<p>Coordinates in two dimensions (if missing, coordinates
are expected to be in the <code>data.frame</code> specified in the
<code>coords</code> parameter as columns &quot;x&quot; and &quot;y&quot;)</p>
</td></tr>
<tr><td><code id="reproject_+3A_coords">coords</code></td>
<td>
<p>data.frame-like object with coordinates in columns
&quot;x&quot; and &quot;y&quot;</p>
</td></tr>
<tr><td><code id="reproject_+3A_model">model</code></td>
<td>
<p>Object of the class <code>slendr_model</code></p>
</td></tr>
<tr><td><code id="reproject_+3A_add">add</code></td>
<td>
<p>Add column coordinates to the input data.frame
<code>coords</code> (coordinates otherwise returned as a separate
object)?</p>
</td></tr>
<tr><td><code id="reproject_+3A_input_prefix">input_prefix</code>, <code id="reproject_+3A_output_prefix">output_prefix</code></td>
<td>
<p>Input and output prefixes of data
frame columns with spatial coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with converted two-dimensional coordinates given as input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon_lat_df &lt;- data.frame(x = c(30, 0, 15), y = c(60, 40, 10))

reproject(
  from = "epsg:4326",
  to = "epsg:3035",
  coords = lon_lat_df,
  add = TRUE # add converted [lon,lat] coordinates as a new column
)
</code></pre>

<hr>
<h2 id='resize'>Change the population size</h2><span id='topic+resize'></span>

<h3>Description</h3>

<p>Resizes the population starting from the current value of <code>N</code>
individuals to the specified value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize(pop, N, how, time, end = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resize_+3A_pop">pop</code></td>
<td>
<p>Object of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="resize_+3A_n">N</code></td>
<td>
<p>Population size after the change</p>
</td></tr>
<tr><td><code id="resize_+3A_how">how</code></td>
<td>
<p>How to change the population size (options are <code>"step"</code> or
<code>"exponential"</code>)</p>
</td></tr>
<tr><td><code id="resize_+3A_time">time</code></td>
<td>
<p>Time of the population size change</p>
</td></tr>
<tr><td><code id="resize_+3A_end">end</code></td>
<td>
<p>End of the population size change period (used for exponential
change events)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of exponential size change, if the final <code>N</code> is larger than
the current size, the population will be exponentially growing over the
specified time period until it reaches <code>N</code> individuals. If <code>N</code> is
smaller, the population will shrink exponentially.
</p>
<p>Note that because slendr models have to accomodate both SLiM and msprime
back ends, population sizes and split times are rounded to the nearest
integer value.
</p>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='schedule_sampling'>Define sampling events for a given set of populations</h2><span id='topic+schedule_sampling'></span>

<h3>Description</h3>

<p>Schedule sampling events at specified times and, optionally, a given set of
locations on a landscape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schedule_sampling(model, times, ..., locations = NULL, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schedule_sampling_+3A_model">model</code></td>
<td>
<p>Object of the class <code>slendr_model</code></p>
</td></tr>
<tr><td><code id="schedule_sampling_+3A_times">times</code></td>
<td>
<p>Integer vector of times (in model time units) at which to
schedule remembering of individuals in the tree-sequence</p>
</td></tr>
<tr><td><code id="schedule_sampling_+3A_...">...</code></td>
<td>
<p>Lists of two elements (<code>slendr_pop</code> population object-&lt;number
of individuals to sample), representing from which populations should how
many individuals be remembered at times given by <code>times</code></p>
</td></tr>
<tr><td><code id="schedule_sampling_+3A_locations">locations</code></td>
<td>
<p>List of vector pairs, defining two-dimensional coordinates
of locations at which the closest number of individuals from given
populations should be sampled. If <code>NULL</code> (the default), individuals
will be sampled randomly throughout their spatial boundary.</p>
</td></tr>
<tr><td><code id="schedule_sampling_+3A_strict">strict</code></td>
<td>
<p>Should any occurence of a population not being present at a
given time result in an error? Default is <code>FALSE</code>, meaning that
invalid sampling times for any populations will be quietly ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both times and locations are given, the the sampling will be scheduled on
each specified location in each given time-point. Note that for the
time-being, in the interest of simplicity, no sanity checks are performed on
the locations given except the restriction that the sampling points must fall
within the bounding box around the simulated world map. Other than that,
slendr will simply instruct its SLiM backend script to sample individuals as
close to the sampling points given as possible, regardless of whether those
points lie within a population spatial boundary at that particular moment of
time.
</p>


<h3>Value</h3>

<p>Data frame with three columns: time of sampling, population to sample
from, how many individuals to sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
path &lt;- system.file("extdata/models/introgression", package = "slendr")
model &lt;- read_model(path)

# afr and eur objects would normally be created before slendr model compilation,
# but here we take them out of the model object already compiled for this
# example (in a standard slendr simulation pipeline, this wouldn't be necessary)
afr &lt;- model$populations[["AFR"]]
eur &lt;- model$populations[["EUR"]]

# schedule the recording of 10 African and 100 European individuals from a
# given model at 20 ky, 10 ky, 5ky ago and at present-day (time 0)
schedule &lt;- schedule_sampling(
  model, times = c(20000, 10000, 5000, 0),
  list(afr, 10), list(eur, 100)
)

# the result of `schedule_sampling` is a simple data frame (note that the locations
# of sampling locations have `NA` values because the model is non-spatial)
schedule
</code></pre>

<hr>
<h2 id='set_dispersal'>Change dispersal parameters</h2><span id='topic+set_dispersal'></span>

<h3>Description</h3>

<p>Changes either the competition interactive distance, mating choice distance,
or the dispersal of offspring from its parent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dispersal(
  pop,
  time,
  competition = NA,
  mating = NA,
  dispersal = NA,
  dispersal_fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_dispersal_+3A_pop">pop</code></td>
<td>
<p>Object of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="set_dispersal_+3A_time">time</code></td>
<td>
<p>Time of the population size change</p>
</td></tr>
<tr><td><code id="set_dispersal_+3A_competition">competition</code>, <code id="set_dispersal_+3A_mating">mating</code></td>
<td>
<p>Maximum spatial competition and mating
choice distance</p>
</td></tr>
<tr><td><code id="set_dispersal_+3A_dispersal">dispersal</code></td>
<td>
<p>Standard deviation of the normal distribution of the
distance that offspring disperses from its parent</p>
</td></tr>
<tr><td><code id="set_dispersal_+3A_dispersal_fun">dispersal_fun</code></td>
<td>
<p>Distribution function governing the dispersal of
offspring. One of &quot;normal&quot;, &quot;uniform&quot;, &quot;cauchy&quot;, &quot;exponential&quot;, or
&quot;brownian&quot; (in which vertical and horizontal displacements are drawn from a
normal distribution independently).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='set_range'>Update the population range</h2><span id='topic+set_range'></span>

<h3>Description</h3>

<p>This function allows a more manual control of spatial map changes
in addition to the <code>expand</code> and <code>move</code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_range(
  pop,
  time,
  center = NULL,
  radius = NULL,
  polygon = NULL,
  lock = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_range_+3A_pop">pop</code></td>
<td>
<p>Object of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="set_range_+3A_time">time</code></td>
<td>
<p>Time of the change</p>
</td></tr>
<tr><td><code id="set_range_+3A_center">center</code></td>
<td>
<p>Two-dimensional vector specifying the center of the
circular range</p>
</td></tr>
<tr><td><code id="set_range_+3A_radius">radius</code></td>
<td>
<p>Radius of the circular range</p>
</td></tr>
<tr><td><code id="set_range_+3A_polygon">polygon</code></td>
<td>
<p>List of vector pairs, defining corners of the
polygon range (see also the <code>region</code> argument) or a
geographic region of the class <code>slendr_region</code> from which
the polygon coordinates will be extracted</p>
</td></tr>
<tr><td><code id="set_range_+3A_lock">lock</code></td>
<td>
<p>Maintain the same density of individuals. If
<code>FALSE</code> (the default), the number of individuals in the
population will not change. If <code>TRUE</code>, the number of
individuals simulated will be changed (increased or decreased)
appropriately, to match the new population range area.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='setup_env'>Setup a dedicated Python virtual environment for slendr</h2><span id='topic+setup_env'></span>

<h3>Description</h3>

<p>This function will automatically download a Python miniconda distribution
dedicated to an R-Python interface. It will also create a slendr-specific
Python environment with all the required Python dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_env(quiet = FALSE, agree = FALSE, pip = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_env_+3A_quiet">quiet</code></td>
<td>
<p>Should informative messages be printed to the console? Default
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="setup_env_+3A_agree">agree</code></td>
<td>
<p>Automatically agree to all questions?</p>
</td></tr>
<tr><td><code id="setup_env_+3A_pip">pip</code></td>
<td>
<p>Should pip be used instead of conda for installing slendr's Python
dependencies? Note that this will still use the conda distribution to
install Python itself, but will change the repository from which slendr
will install its Python dependencies. Unless explicitly set to <code>TRUE</code>,
Python dependencies will be installed from conda repositories by default,
expect for the case of osx-arm64 Mac architecture, for which conda
dependencies are broken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='shrink_range'>Shrink the population range</h2><span id='topic+shrink_range'></span>

<h3>Description</h3>

<p>Shrinks the spatial population range by a specified distance in a given
time-window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_range(
  pop,
  by,
  end,
  start,
  overlap = 0.8,
  snapshots = NULL,
  lock = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink_range_+3A_pop">pop</code></td>
<td>
<p>Object of the class <code>slendr_pop</code></p>
</td></tr>
<tr><td><code id="shrink_range_+3A_by">by</code></td>
<td>
<p>How many units of distance to shrink by?</p>
</td></tr>
<tr><td><code id="shrink_range_+3A_start">start</code>, <code id="shrink_range_+3A_end">end</code></td>
<td>
<p>When does the boundary shrinking start/end?</p>
</td></tr>
<tr><td><code id="shrink_range_+3A_overlap">overlap</code></td>
<td>
<p>Minimum overlap between subsequent spatial boundaries</p>
</td></tr>
<tr><td><code id="shrink_range_+3A_snapshots">snapshots</code></td>
<td>
<p>The number of intermediate snapshots (overrides the
<code>overlap</code> parameter)</p>
</td></tr>
<tr><td><code id="shrink_range_+3A_lock">lock</code></td>
<td>
<p>Maintain the same density of individuals. If
<code>FALSE</code> (the default), the number of individuals in the
population will not change. If <code>TRUE</code>, the number of
individuals simulated will be changed (increased or decreased)
appropriately, to match the new population range area.</p>
</td></tr>
<tr><td><code id="shrink_range_+3A_verbose">verbose</code></td>
<td>
<p>Report on the progress of generating intermediate spatial
boundaries?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that because slendr models have to accomodate both SLiM and msprime
back ends, population sizes and split times are rounded to the nearest
integer value.
</p>


<h3>Value</h3>

<p>Object of the class <code>slendr_pop</code>, which contains population
parameters such as name, time of appearance in the simulation, parent
population (if any), and its spatial parameters such as map and spatial
boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spatial definitions -----------------------------------------------------

# create a blank abstract world 1000x1000 distance units in size
map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# create a circular population with the center of a population boundary at
# [200, 800] and a radius of 100 distance units, 1000 individuals at time 1
# occupying a map just specified
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100)

# printing a population object to a console shows a brief summary
pop1

# create another population occupying a polygon range, splitting from pop1
# at a given time point (note that specifying a map is not necessary because
# it is "inherited" from the parent)
pop2 &lt;- population("pop2", N = 100, time = 50, parent = pop1,
                        polygon = list(c(100, 100), c(320, 30), c(500, 200),
                                  c(500, 400), c(300, 450), c(100, 400)))

pop3 &lt;- population("pop3", N = 200, time = 80, parent = pop2,
                   center = c(800, 800), radius = 200)

# move "pop1" to another location along a specified trajectory and saved the
# resulting object to the same variable (the number of intermediate spatial
# snapshots can be also determined automatically by leaving out the
# `snapshots = ` argument)
pop1_moved &lt;- move(pop1, start = 100, end = 200, snapshots = 6,
                   trajectory = list(c(600, 820), c(800, 400), c(800, 150)))
pop1_moved

# many slendr functions are pipe-friendly, making it possible to construct
# pipelines which construct entire history of a population
pop1 &lt;- population("pop1", N = 1000, time = 1,
                   map = map, center = c(200, 800), radius = 100) %&gt;%
  move(start = 100, end = 200, snapshots = 6,
       trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %&gt;%
  set_range(time = 300, polygon = list(
    c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),
    c(600, 100), c(500, 50))
  )

# population ranges can expand by a given distance in all directions
pop2 &lt;- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)

# we can check the positions of all populations interactively by plotting their
# ranges together on a single map
plot_map(pop1, pop2, pop3)

# gene flow events --------------------------------------------------------

# individual gene flow events can be saved to a list
gf &lt;- list(
  gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),
  gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25)
)

# compilation -------------------------------------------------------------

# compile model components in a serialized form to dist, returning a single
# slendr model object (in practice, the resolution should be smaller)
model &lt;- compile_model(
  populations = list(pop1, pop2, pop3), generation_time = 1,
  resolution = 100, simulation_length = 500,
  competition = 5, mating = 5, dispersal = 1
)
</code></pre>

<hr>
<h2 id='slim'>Run a slendr model in SLiM</h2><span id='topic+slim'></span>

<h3>Description</h3>

<p>This function will execute a SLiM script generated by the <code>compile</code>
function during the compilation of a slendr demographic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slim(
  model,
  sequence_length,
  recombination_rate,
  samples = NULL,
  output = NULL,
  burnin = 0,
  max_attempts = 1,
  spatial = !is.null(model$world),
  coalescent_only = TRUE,
  method = c("batch", "gui"),
  random_seed = NULL,
  run = TRUE,
  verbose = FALSE,
  load = TRUE,
  locations = NULL,
  slim_path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slim_+3A_model">model</code></td>
<td>
<p>Model object created by the <code>compile</code> function</p>
</td></tr>
<tr><td><code id="slim_+3A_sequence_length">sequence_length</code></td>
<td>
<p>Total length of the simulated sequence (in base-pairs)</p>
</td></tr>
<tr><td><code id="slim_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>Recombination rate of the simulated sequence (in
recombinations per basepair per generation)</p>
</td></tr>
<tr><td><code id="slim_+3A_samples">samples</code></td>
<td>
<p>A data frame of times at which a given number of individuals
should be remembered in the tree-sequence (see <code>schedule_sampling</code> for a
function that can generate the sampling schedule in the correct format). If
missing, only individuals present at the end of the simulation will be
recorded in the tree-sequence output file.</p>
</td></tr>
<tr><td><code id="slim_+3A_output">output</code></td>
<td>
<p>Path to the output tree-sequence file. If <code>NULL</code> (the default),
tree sequence will be saved to a temporary file.</p>
</td></tr>
<tr><td><code id="slim_+3A_burnin">burnin</code></td>
<td>
<p>Length of the burnin (in model's time units, i.e. years)</p>
</td></tr>
<tr><td><code id="slim_+3A_max_attempts">max_attempts</code></td>
<td>
<p>How many attempts should be made to place an offspring
near one of its parents? Serves to prevent infinite loops on the SLiM
backend. Default value is 1.</p>
</td></tr>
<tr><td><code id="slim_+3A_spatial">spatial</code></td>
<td>
<p>Should the model be executed in spatial mode? By default, if a
world map was specified during model definition, simulation will proceed in
a spatial mode.</p>
</td></tr>
<tr><td><code id="slim_+3A_coalescent_only">coalescent_only</code></td>
<td>
<p>Should <code>initializeTreeSeq(retainCoalescentOnly =
  &lt;...&gt;)</code> be set to <code>TRUE</code> (the default) or <code>FALSE</code>? See
&quot;retainCoalescentOnly&quot; in the SLiM manual for more detail.</p>
</td></tr>
<tr><td><code id="slim_+3A_method">method</code></td>
<td>
<p>How to run the script? (&quot;gui&quot; - open in SLiMgui, &quot;batch&quot; - run
on the command line)</p>
</td></tr>
<tr><td><code id="slim_+3A_random_seed">random_seed</code></td>
<td>
<p>Random seed (if <code>NULL</code>, a seed will be generated between
0 and the maximum integer number available)</p>
</td></tr>
<tr><td><code id="slim_+3A_run">run</code></td>
<td>
<p>Should the SLiM engine be run? If <code>FALSE</code>, the command line SLiM
command will be printed (and returned invisibly as a character vector) but not executed.</p>
</td></tr>
<tr><td><code id="slim_+3A_verbose">verbose</code></td>
<td>
<p>Write the SLiM output log to the console (default
<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="slim_+3A_load">load</code></td>
<td>
<p>Should the final tree sequence be immediately loaded and returned?
Default is <code>TRUE</code>. The alternative (<code>FALSE</code>) is useful when a tree-sequence
file is written to a custom location to be loaded at a later point.</p>
</td></tr>
<tr><td><code id="slim_+3A_locations">locations</code></td>
<td>
<p>If <code>NULL</code>, locations are not saved. Otherwise, the
path to the file where locations of each individual throughout the simulation
will be saved (most likely for use with <code>animate_model</code>).</p>
</td></tr>
<tr><td><code id="slim_+3A_slim_path">slim_path</code></td>
<td>
<p>Path to the appropriate SLiM binary (this is useful if the
<code>slim</code> binary is not on the <code>$PATH</code>). Note that this argument must
be specified if the function is being run on Windows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree-sequence object loaded via Python-R reticulate interface function <code>ts_load</code>
(internally represented by the Python object <code>tskit.trees.TreeSequence</code>). Optionally,
depending on the value of the arguments <code>load =</code> or <code>run =</code>, nothing or a character
vector, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# afr and eur objects would normally be created before slendr model compilation,
# but here we take them out of the model object already compiled for this
# example (in a standard slendr simulation pipeline, this wouldn't be necessary)
afr &lt;- model$populations[["AFR"]]
eur &lt;- model$populations[["EUR"]]
chimp &lt;- model$populations[["CH"]]

# schedule the sampling of a couple of ancient and present-day individuals
# given model at 20 ky, 10 ky, 5ky ago and at present-day (time 0)
modern_samples &lt;- schedule_sampling(model, times = 0, list(afr, 5), list(eur, 5), list(chimp, 1))
ancient_samples &lt;- schedule_sampling(model, times = c(30000, 20000, 10000), list(eur, 1))

# sampling schedules are just data frames and can be merged easily
samples &lt;- rbind(modern_samples, ancient_samples)

# run a simulation using the SLiM back end from a compiled slendr model object and return
# a tree-sequence output
ts &lt;- slim(model, sequence_length = 1e5, recombination_rate = 0, samples = samples)

# automatic loading of a simulated output can be prevented by `load = FALSE`, which can be
# useful when a custom path to a tree-sequence output is given for later downstream analyses
output_file &lt;- tempfile(fileext = ".trees")
slim(model, sequence_length = 1e5, recombination_rate = 0, samples = samples,
     output = output_file, load = FALSE)
# ... at a later stage:
ts &lt;- ts_load(output_file, model)

ts
</code></pre>

<hr>
<h2 id='subtract'>Generate the difference between two <code>slendr</code> objects</h2><span id='topic+subtract'></span>

<h3>Description</h3>

<p>Generate the difference between two <code>slendr</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtract(x, y, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtract_+3A_x">x</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="subtract_+3A_y">y</code></td>
<td>
<p>Object of the class <code>slendr</code></p>
</td></tr>
<tr><td><code id="subtract_+3A_name">name</code></td>
<td>
<p>Optional name of the resulting geographic region. If missing,
name will be constructed from the function arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_region</code> which encodes a standard
spatial object of the class <code>sf</code> with several additional attributes
(most importantly a corresponding <code>slendr_map</code> object, if applicable).
</p>

<hr>
<h2 id='summary.slendr_nodes'>Summarise the contents of a <code>ts_nodes</code> result</h2><span id='topic+summary.slendr_nodes'></span>

<h3>Description</h3>

<p>Summarise the contents of a <code>ts_nodes</code> result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slendr_nodes'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.slendr_nodes_+3A_object">object</code></td>
<td>
<p>Data frame produced by the function <code>ts_nodes</code></p>
</td></tr>
<tr><td><code id="summary.slendr_nodes_+3A_...">...</code></td>
<td>
<p>Additional formal arguments to the <code>summary</code> method (unused here)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for its output to the terminal
</p>

<hr>
<h2 id='ts_afs'>Compute the allele frequency spectrum (AFS)</h2><span id='topic+ts_afs'></span>

<h3>Description</h3>

<p>This function computes the AFS with respect to the given set of individuals
or nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_afs(
  ts,
  sample_sets = NULL,
  mode = c("site", "branch", "node"),
  windows = NULL,
  span_normalise = FALSE,
  polarised = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_afs_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_afs_+3A_sample_sets">sample_sets</code></td>
<td>
<p>A list (optionally a named list) of character vectors with
individual names (one vector per set). If NULL, allele frequency spectrum
for all individuals in the tree sequence will be computed.</p>
</td></tr>
<tr><td><code id="ts_afs_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_afs_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
are added automatically)</p>
</td></tr>
<tr><td><code id="ts_afs_+3A_span_normalise">span_normalise</code></td>
<td>
<p>Argument passed to tskit's <code>allele_frequency_spectrum</code>
method</p>
</td></tr>
<tr><td><code id="ts_afs_+3A_polarised">polarised</code></td>
<td>
<p>When TRUE (the default) the allele frequency spectrum will
not be folded (i.e. the counts will assume knowledge of which allele is ancestral,
and which is derived, which is known in a simulation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on the format of the result and dimensions, in
particular the interpretation of the first and the last element of the AFS
(when <code>complete = TRUE</code>), please see the tskit manual at
<a href="https://tskit.dev/tskit/docs/stable/python-api.html">https://tskit.dev/tskit/docs/stable/python-api.html</a> and the example
section dedicated to AFS at
<a href="https://tskit.dev/tutorials/analysing_tree_sequences.html#allele-frequency-spectra">https://tskit.dev/tutorials/analysing_tree_sequences.html#allele-frequency-spectra</a>.
</p>


<h3>Value</h3>

<p>Allele frequency spectrum values for the given sample set. Note that the
contents of the first and last elements of the AFS might surprise you. Read the
links in the description for more detail on how tskit handles things.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

samples &lt;- ts_samples(ts) %&gt;% .[.$pop %in% c("AFR", "EUR"), ]

# compute AFS for the given set of individuals
ts_afs(ts, sample_sets = list(samples$name))
</code></pre>

<hr>
<h2 id='ts_ancestors'>Extract (spatio-)temporal ancestral history for given nodes/individuals</h2><span id='topic+ts_ancestors'></span>

<h3>Description</h3>

<p>Extract (spatio-)temporal ancestral history for given nodes/individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_ancestors(ts, x, verbose = FALSE, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_ancestors_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_ancestors_+3A_x">x</code></td>
<td>
<p>Either an individual name or an integer node ID</p>
</td></tr>
<tr><td><code id="ts_ancestors_+3A_verbose">verbose</code></td>
<td>
<p>Report on the progress of ancestry path generation?</p>
</td></tr>
<tr><td><code id="ts_ancestors_+3A_complete">complete</code></td>
<td>
<p>Does every individual in the tree sequence need to have
complete metadata recorded? If <code>TRUE</code>, only individuals/nodes with
complete metadata will be included in the reconstruction of ancestral
relationships. For instance, nodes added during the coalescent recapitation
phase will not be included because they don't have spatial information
associated with them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of ancestral nodes of a given tree-sequence node all the
way up to the root of the tree sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# find the complete ancestry information for a given individual
ts_ancestors(ts, "EUR_1", verbose = TRUE)
</code></pre>

<hr>
<h2 id='ts_coalesced'>Check that all trees in the tree sequence are fully coalesced</h2><span id='topic+ts_coalesced'></span>

<h3>Description</h3>

<p>Check that all trees in the tree sequence are fully coalesced
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_coalesced(ts, return_failed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_coalesced_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_coalesced_+3A_return_failed">return_failed</code></td>
<td>
<p>Report back which trees failed the coalescence
check?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE value if <code>return_failed = FALSE</code>, otherwise a vector of
(tskit Python 0-based) indices of trees which failed the coalescence test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

ts_coalesced(ts) # is the tree sequence fully coalesced? (TRUE or FALSE)

# returns a vector of tree sequence segments which are not coalesced
not_coalesced &lt;- ts_coalesced(ts, return_failed = TRUE)
</code></pre>

<hr>
<h2 id='ts_descendants'>Extract all descendants of a given tree-sequence node</h2><span id='topic+ts_descendants'></span>

<h3>Description</h3>

<p>Extract all descendants of a given tree-sequence node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_descendants(ts, x, verbose = FALSE, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_descendants_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_descendants_+3A_x">x</code></td>
<td>
<p>An integer node ID of the ancestral node</p>
</td></tr>
<tr><td><code id="ts_descendants_+3A_verbose">verbose</code></td>
<td>
<p>Report on the progress of ancestry path generation?</p>
</td></tr>
<tr><td><code id="ts_descendants_+3A_complete">complete</code></td>
<td>
<p>Does every individual in the tree sequence need to have
complete metadata recorded? If <code>TRUE</code>, only individuals/nodes with
complete metadata will be included in the reconstruction of ancestral
relationships. For instance, nodes added during the coalescent recapitation
phase will not be included because they don't have spatial information
associated with them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of descendant nodes of a given tree-sequence node all the
way down to the leaves of the tree sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# find the complete descendancy information for a given individual
ts_descendants(ts, x = 62, verbose = TRUE)
</code></pre>

<hr>
<h2 id='ts_divergence'>Calculate pairwise divergence between sets of individuals</h2><span id='topic+ts_divergence'></span>

<h3>Description</h3>

<p>Calculate pairwise divergence between sets of individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_divergence(
  ts,
  sample_sets,
  mode = c("site", "branch", "node"),
  windows = NULL,
  span_normalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_divergence_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_divergence_+3A_sample_sets">sample_sets</code></td>
<td>
<p>A list (optionally a named list) of character vectors with
individual names (one vector per set)</p>
</td></tr>
<tr><td><code id="ts_divergence_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_divergence_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
do not have to be specified as they are added automatically.</p>
</td></tr>
<tr><td><code id="ts_divergence_+3A_span_normalise">span_normalise</code></td>
<td>
<p>Divide the result by the span of the window? Default
TRUE, see the tskit documentation for more detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each pairwise calculation, either a single divergence value or a
vector of divergence values (one for each window)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# collect sampled individuals from all populations in a list
sample_sets &lt;- ts_samples(ts) %&gt;%
  split(., .$pop) %&gt;%
  lapply(function(pop) pop$name)

# compute the divergence between individuals from each sample set (list of
# individual names generated in the previous step)
ts_divergence(ts, sample_sets) %&gt;% .[order(.$divergence), ]
</code></pre>

<hr>
<h2 id='ts_diversity'>Calculate diversity in given sets of individuals</h2><span id='topic+ts_diversity'></span>

<h3>Description</h3>

<p>Calculate diversity in given sets of individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_diversity(
  ts,
  sample_sets,
  mode = c("site", "branch", "node"),
  windows = NULL,
  span_normalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_diversity_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_diversity_+3A_sample_sets">sample_sets</code></td>
<td>
<p>A list (optionally a named list) of character vectors with
individual names (one vector per set). If a simple vector is provided, it
will be interpreted as <code>as.list(sample_sets)</code>, meaning that a given
statistic will be calculated for each individual separately.</p>
</td></tr>
<tr><td><code id="ts_diversity_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_diversity_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
are added automatically)</p>
</td></tr>
<tr><td><code id="ts_diversity_+3A_span_normalise">span_normalise</code></td>
<td>
<p>Divide the result by the span of the window? Default
TRUE, see the tskit documentation for more detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each set of individuals either a single diversity value or a
vector of diversity values (one for each window)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# collect sampled individuals from all populations in a list
sample_sets &lt;- ts_samples(ts) %&gt;%
  split(., .$pop) %&gt;%
  lapply(function(pop) pop$name)

# compute diversity in each population based on sample sets extracted
# in the previous step
ts_diversity(ts, sample_sets) %&gt;% .[order(.$diversity), ]
</code></pre>

<hr>
<h2 id='ts_draw'>Plot a graphical representation of a single tree</h2><span id='topic+ts_draw'></span>

<h3>Description</h3>

<p>This function first obtains an SVG representation of the tree by calling the
<code>draw_svg</code> method of tskit and renders it as a bitmap image in R. All of
the many optional keyword arguments of the <code>draw_svg</code> method can be
provided and will be automatically passed to the method behind the scenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_draw(
  x,
  width = 1000,
  height = 1000,
  labels = FALSE,
  sampled_only = TRUE,
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_draw_+3A_x">x</code></td>
<td>
<p>A single tree extracted by <code><a href="#topic+ts_tree">ts_tree</a></code></p>
</td></tr>
<tr><td><code id="ts_draw_+3A_width">width</code>, <code id="ts_draw_+3A_height">height</code></td>
<td>
<p>Pixel dimensions of the rendered bitmap</p>
</td></tr>
<tr><td><code id="ts_draw_+3A_labels">labels</code></td>
<td>
<p>Label each node with the individual name?</p>
</td></tr>
<tr><td><code id="ts_draw_+3A_sampled_only">sampled_only</code></td>
<td>
<p>Should only individuals explicitly sampled through
simplification be labeled? This is relevant in situations in which sampled
individuals can themselves be among the ancestral nodes.</p>
</td></tr>
<tr><td><code id="ts_draw_+3A_title">title</code></td>
<td>
<p>Optional title for the figure</p>
</td></tr>
<tr><td><code id="ts_draw_+3A_...">...</code></td>
<td>
<p>Keyword arguments to the tskit <code>draw_svg</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# extract the first tree in the tree sequence and draw it
tree &lt;- ts_tree(ts, i = 1)

# ts_draw accepts various optional arguments of tskit.Tree.draw_svg
ts_draw(tree, time_scale = "rank")
</code></pre>

<hr>
<h2 id='ts_edges'>Extract spatio-temporal edge annotation table from a given tree or tree
sequence</h2><span id='topic+ts_edges'></span>

<h3>Description</h3>

<p>Extract spatio-temporal edge annotation table from a given tree or tree
sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_edges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_edges_+3A_x">x</code></td>
<td>
<p>Tree object generated by <code>ts_phylo</code> or a slendr tree sequence
object produced by <code>ts_load</code>, <code>ts_recapitate</code>,
<code>ts_simplify</code>, or <code>ts_mutate</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of the <code>sf</code> type containing the times of nodes and
start-end coordinates of edges across space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# extract an annotated table with (spatio-)temporal edge information
ts_edges(ts)
</code></pre>

<hr>
<h2 id='ts_eigenstrat'>Convert genotypes to the EIGENSTRAT file format</h2><span id='topic+ts_eigenstrat'></span>

<h3>Description</h3>

<p>EIGENSTRAT data produced by this function can be used by the admixr R package
(<a href="https://bodkan.net/admixr/">https://bodkan.net/admixr/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_eigenstrat(ts, prefix, chrom = "chr1", outgroup = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_eigenstrat_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_eigenstrat_+3A_prefix">prefix</code></td>
<td>
<p>EIGENSTRAT trio prefix</p>
</td></tr>
<tr><td><code id="ts_eigenstrat_+3A_chrom">chrom</code></td>
<td>
<p>The name of the chromosome in the EIGENSTRAT snp file
(default &quot;chr1&quot;)</p>
</td></tr>
<tr><td><code id="ts_eigenstrat_+3A_outgroup">outgroup</code></td>
<td>
<p>Should a formal, artificial outgroup be added? If <code>NULL</code>
(default), no outgroup is added. A non-NULL character name will serve as
the name of the outgroup in an ind file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case an outgroup was not formally specified in a slendr model which
generated the tree sequence data, it is possible to artificially create an
outgroup sample with the name specified by the <code>outgroup</code> argument,
which will carry all ancestral alleles (i.e. value &quot;2&quot; in a geno file
for each position in a snp file).
</p>


<h3>Value</h3>

<p>Object of the class EIGENSTRAT created by the admixr package
</p>

<hr>
<h2 id='ts_f2'>Calculate the f2, f3, f4, and f4-ratio statistics</h2><span id='topic+ts_f2'></span><span id='topic+ts_f3'></span><span id='topic+ts_f4'></span><span id='topic+ts_f4ratio'></span>

<h3>Description</h3>

<p>These functions present an R interface to the corresponding f-statistics methods
in tskit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_f2(
  ts,
  A,
  B,
  mode = c("site", "branch", "node"),
  span_normalise = TRUE,
  windows = NULL
)

ts_f3(
  ts,
  A,
  B,
  C,
  mode = c("site", "branch", "node"),
  span_normalise = TRUE,
  windows = NULL
)

ts_f4(
  ts,
  W,
  X,
  Y,
  Z,
  mode = c("site", "branch", "node"),
  span_normalise = TRUE,
  windows = NULL
)

ts_f4ratio(
  ts,
  X,
  A,
  B,
  C,
  O,
  mode = c("site", "branch"),
  span_normalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_f2_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_f2_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_f2_+3A_span_normalise">span_normalise</code></td>
<td>
<p>Divide the result by the span of the window? Default
TRUE, see the tskit documentation for more detail.</p>
</td></tr>
<tr><td><code id="ts_f2_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
do not have to be specified as they are added automatically.</p>
</td></tr>
<tr><td><code id="ts_f2_+3A_w">W</code>, <code id="ts_f2_+3A_x">X</code>, <code id="ts_f2_+3A_y">Y</code>, <code id="ts_f2_+3A_z">Z</code>, <code id="ts_f2_+3A_a">A</code>, <code id="ts_f2_+3A_b">B</code>, <code id="ts_f2_+3A_c">C</code>, <code id="ts_f2_+3A_o">O</code></td>
<td>
<p>Character vectors of individual names (largely following
the nomenclature of Patterson 2021, but see crucial differences between
tskit and ADMIXTOOLS in Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the order of populations f3 statistic implemented in tskit
(<a href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.f3">https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.f3</a>) is
different from what you might expect from ADMIXTOOLS, as defined in
Patterson 2012 (see <a href="https://academic.oup.com/genetics/article/192/3/1065/5935193">https://academic.oup.com/genetics/article/192/3/1065/5935193</a>
under heading &quot;The three-population test and introduction of f-statistics&quot;,
as well as ADMIXTOOLS documentation at
<a href="https://github.com/DReichLab/AdmixTools/blob/master/README.3PopTest#L5">https://github.com/DReichLab/AdmixTools/blob/master/README.3PopTest#L5</a>).
Specifically, the widely used notation introduced by Patterson assumes the
population triplet as f3(C; A, B), with C being the &quot;focal&quot; sample (i.e., either
the outgroup or a sample tested for admixture). In contrast, tskit implements
f3(A; B, C), with the &quot;focal sample&quot; being A.
</p>
<p>Although this is likely to confuse many ADMIXTOOLS users, slendr does not have
much choice in this, because its <code>ts_*()</code> functions are designed to be
broadly compatible with raw tskit methods.
</p>


<h3>Value</h3>

<p>Data frame with statistics calculated for the given sets of individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk and add mutations to it
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# calculate f2 for two individuals in a previously loaded tree sequence
ts_f2(ts, A = "AFR_1", B = "EUR_1")

# calculate f2 for two sets of individuals
ts_f2(ts, A = c("AFR_1", "AFR_2"), B = c("EUR_1", "EUR_3"))

# calculate f3 for two individuals in a previously loaded tree sequence
ts_f3(ts, A = "EUR_1", B = "AFR_1", C = "NEA_1")

# calculate f3 for two sets of individuals
ts_f3(ts, A = c("AFR_1", "AFR_2", "EUR_1", "EUR_2"),
          B = c("NEA_1", "NEA_2"),
          C = "CH_1")

# calculate f4 for single individuals
ts_f4(ts, W = "EUR_1", X = "AFR_1", Y = "NEA_1", Z = "CH_1")

# calculate f4 for sets of individuals
ts_f4(ts, W = c("EUR_1", "EUR_2"),
          X = c("AFR_1", "AFR_2"),
          Y = "NEA_1",
          Z = "CH_1")

# calculate f4-ratio for a given set of target individuals X
ts_f4ratio(ts, X = c("EUR_1", "EUR_2", "EUR_4", "EUR_5"),
               A = "NEA_1", B = "NEA_2", C = "AFR_1", O = "CH_1")
</code></pre>

<hr>
<h2 id='ts_fst'>Calculate pairwise statistics between sets of individuals</h2><span id='topic+ts_fst'></span>

<h3>Description</h3>

<p>For a discussion on the difference between &quot;site&quot;, &quot;branch&quot;, and &quot;node&quot;
options of the <code>mode</code> argument, please see the tskit documentation at
<a href="https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode">https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_fst(
  ts,
  sample_sets,
  mode = c("site", "branch", "node"),
  windows = NULL,
  span_normalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_fst_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_fst_+3A_sample_sets">sample_sets</code></td>
<td>
<p>A list (optionally a named list) of character vectors with
individual names (one vector per set)</p>
</td></tr>
<tr><td><code id="ts_fst_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_fst_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
do not have to be specified as they are added automatically.</p>
</td></tr>
<tr><td><code id="ts_fst_+3A_span_normalise">span_normalise</code></td>
<td>
<p>Divide the result by the span of the window? Default
TRUE, see the tskit documentation for more detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each pairwise calculation, either a single Fst value or a vector
of Fst values (one for each window)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# compute F_st between two sets of individuals in a given tree sequence ts
ts_fst(ts, sample_sets = list(afr = c("AFR_1", "AFR_2", "AFR_3"),
                              eur = c("EUR_1", "EUR_2")))
</code></pre>

<hr>
<h2 id='ts_genotypes'>Extract genotype table from the tree sequence</h2><span id='topic+ts_genotypes'></span>

<h3>Description</h3>

<p>Extract genotype table from the tree sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_genotypes(ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_genotypes_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame object of the class <code>tibble</code> containing genotypes
of simulated individuals in columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk, recapitate it, simplify it, and mutate it
ts &lt;- ts_load(slendr_ts, model) %&gt;%
  ts_recapitate(Ne = 10000, recombination_rate = 1e-8) %&gt;%
  ts_simplify() %&gt;%
  ts_mutate(mutation_rate = 1e-8)

# extract the genotype matrix (this could take  a long time consume lots
# of memory!)
gts &lt;- ts_genotypes(ts)
</code></pre>

<hr>
<h2 id='ts_ibd'>Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL)</h2><span id='topic+ts_ibd'></span>

<h3>Description</h3>

<p>This function iterates over a tree sequence and returns IBD tracts between
pairs of individuals or nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_ibd(
  ts,
  coordinates = FALSE,
  within = NULL,
  between = NULL,
  squash = FALSE,
  minimum_length = NULL,
  maximum_time = NULL,
  sf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_ibd_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_coordinates">coordinates</code></td>
<td>
<p>Should coordinates of all detected IBD tracts be reported?
If <code>FALSE</code> (the default), only the total length of shared IBD segments
and their numbers are reported. If <code>TRUE</code>, coordinates of each segment
will be returned (but note that this can have a massive impact on memory
usage). See details for more information.</p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_within">within</code></td>
<td>
<p>A character vector with individual names or an integer vector with
node IDs indicating a set of nodes within which to look for IBD segments.</p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_between">between</code></td>
<td>
<p>A list of lists of character vectors with individual names or
integer vectors with node IDs, indicating a set of nodes between which to
look for shared IBD segments.</p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_squash">squash</code></td>
<td>
<p>Should adjacent IBD segments for pairs of nodes be squashed if they
only differ by their 'genealogical paths' but not by their MRCA? Default is
<code>FALSE</code>. For more context, see <a href="https://github.com/tskit-dev/tskit/issues/2459">https://github.com/tskit-dev/tskit/issues/2459</a>.
This option is EXPERIMENTAL!</p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_minimum_length">minimum_length</code></td>
<td>
<p>Minimum length of an IBD segment to return in results.
This is useful for reducing the total amount of IBD returned (but see Details).</p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_maximum_time">maximum_time</code></td>
<td>
<p>Oldest MRCA of a node to be considered as an IBD ancestor
to return that IBD segment in results. This is useful for reducing the total
amount of IBD returned.</p>
</td></tr>
<tr><td><code id="ts_ibd_+3A_sf">sf</code></td>
<td>
<p>If IBD segments in a spatial tree sequence are being analyzed, should
the returned table be a spatial sf object? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is considered experimental. For full control over IBD segment
detection in tree-sequence data, users can (and perhaps, for the time being,
should) rely on the tskit method <code>ibd_segments</code>
(see <a href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.ibd_segments">https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.ibd_segments</a>).
</p>
<p>Iternally, this function leverages the tskit <code>TreeSequence</code> method
<code>ibd_segments</code>. However, note that the <code>ts_ibd</code> function always
returns a data frame of IBD tracts, it does not provide an option to iterate
over individual IBD segments as shown in the official tskit documentation
at <a href="https://tskit.dev/tskit/docs/stable/ibd.html">https://tskit.dev/tskit/docs/stable/ibd.html</a>. In general, R handles
heavy iteration poorly, and this function does not attempt to serve as
a full wrapper to <code>ibd_segments</code>.
</p>
<p>Unfortunately, the distinction between &quot;squashed IBD&quot; (what many would consider
to be the expected definition of IBD) and tskit’s IBD which is defined via
distinct genealogical paths (see <a href="https://github.com/tskit-dev/tskit/issues/2459">https://github.com/tskit-dev/tskit/issues/2459</a>
for a discussion of the topic), makes the meaning of the filtering parameter
of the <code>ibd_segments()</code> method of tskit <code>minimum_length</code> somewhat
unintuitive. As of this moment, this function argument filters on IBD segments
on the tskit level, not the level of the squashed IBD segments!
</p>


<h3>Value</h3>

<p>A data frame with IBD results (either coordinates of each IBD segment
shared by a pair of nodes, or summary statistics about the total IBD sharing
for that pair)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# find IBD segments between specified Neanderthals and Europeans
ts_ibd(
  ts,
  coordinates = TRUE,
  between = list(c("NEA_1", "NEA_2"), c("EUR_1", "EUR_2")),
  minimum_length = 40000
)
</code></pre>

<hr>
<h2 id='ts_load'>Load a tree sequence file produced by a given model</h2><span id='topic+ts_load'></span>

<h3>Description</h3>

<p>This function loads a tree sequence file simulated from a given slendr model.
Optionally, the tree sequence can be recapitated and simplified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_load(file, model = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_load_+3A_file">file</code></td>
<td>
<p>A path to the tree-sequence file (either originating from a
slendr model or a standard non-slendr tree sequence).</p>
</td></tr>
<tr><td><code id="ts_load_+3A_model">model</code></td>
<td>
<p>Optional <code>slendr_model</code> object which produced the
tree-sequence <code>file</code>. Used for adding various annotation data and
metadata to the standard tskit tree-sequence object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loading, recapitation and simplification is performed using the Python
module pyslim which serves as a link between tree sequences generated by SLiM
and the tskit module for manipulation of tree sequence data. All of these
steps have been modelled after the official pyslim tutorial and documentation
available at: <a href="https://tskit.dev/pyslim/docs/latest/tutorial.html">https://tskit.dev/pyslim/docs/latest/tutorial.html</a>.
</p>
<p>The recapitation and simplification steps can also be performed individually
using the functions <code><a href="#topic+ts_recapitate">ts_recapitate</a></code> and
<code><a href="#topic+ts_simplify">ts_simplify</a></code>.
</p>


<h3>Value</h3>

<p>Tree-sequence object of the class <code>slendr_ts</code>, which serves as
an interface point for the Python module tskit using slendr functions with
the <code>ts_</code> prefix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts_nodes">ts_nodes</a></code> for extracting useful information about
individuals, nodes, coalescent times and geospatial locations of nodes on a
map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load tree sequence generated by a given model
ts &lt;- ts_load(slendr_ts, model)

# even tree sequences generated by non-slendr models can be
msprime_ts &lt;- system.file("extdata/models/msprime.trees", package = "slendr")
ts &lt;- ts_load(msprime_ts)

# load tree sequence and immediately simplify it only to sampled individuals
# (note that the example tree sequence is already simplified so this operation
# does not do anything in this case)
ts &lt;- ts_load(slendr_ts, model = model) %&gt;% ts_simplify(keep_input_roots = TRUE)

# load tree sequence and simplify it to a subset of sampled individuals
ts_small &lt;- ts_simplify(ts, simplify_to = c("CH_1", "NEA_1", "NEA_2",
                                            "AFR_1", "AFR_2", "EUR_1", "EUR_2"))

# load tree sequence, recapitate it and simplify it
ts &lt;- ts_load(slendr_ts, model) %&gt;%
  ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = 42) %&gt;%
  ts_simplify()

# load tree sequence, recapitate it, simplify it and overlay neutral mutations
ts &lt;- ts_load(slendr_ts, model) %&gt;%
  ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = 42) %&gt;%
  ts_simplify() %&gt;%
  ts_mutate(mutation_rate = 1e-8)

ts
</code></pre>

<hr>
<h2 id='ts_metadata'>Extract list with tree sequence metadata saved by SLiM</h2><span id='topic+ts_metadata'></span>

<h3>Description</h3>

<p>Extract list with tree sequence metadata saved by SLiM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_metadata(ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_metadata_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of metadata fields extracted from the tree-sequence object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# extract the list of metadata information from the tree sequence
ts_metadata(ts)
</code></pre>

<hr>
<h2 id='ts_mutate'>Add mutations to the given tree sequence</h2><span id='topic+ts_mutate'></span>

<h3>Description</h3>

<p>Add mutations to the given tree sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_mutate(
  ts,
  mutation_rate,
  random_seed = NULL,
  keep_existing = TRUE,
  mut_type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_mutate_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_mutate_+3A_mutation_rate">mutation_rate</code></td>
<td>
<p>Mutation rate used by msprime to simulate mutations</p>
</td></tr>
<tr><td><code id="ts_mutate_+3A_random_seed">random_seed</code></td>
<td>
<p>Random seed passed to msprime's <code>mutate</code> method
(if <code>NULL</code>, a seed will be generated between 0 and the maximum integer
number available)</p>
</td></tr>
<tr><td><code id="ts_mutate_+3A_keep_existing">keep_existing</code></td>
<td>
<p>Keep existing mutations?</p>
</td></tr>
<tr><td><code id="ts_mutate_+3A_mut_type">mut_type</code></td>
<td>
<p>Assign SLiM mutation type to neutral mutations? If
<code>NULL</code> (default), no special mutation type will be used. If an
integer number is given, mutations of the SLiM mutation type with that
integer identifier will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tree-sequence object of the class <code>slendr_ts</code>, which serves as
an interface point for the Python module tskit using slendr functions with
the <code>ts_</code> prefix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts_nodes">ts_nodes</a></code> for extracting useful information about
individuals, nodes, coalescent times and geospatial locations of nodes on a
map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

ts &lt;- ts_load(slendr_ts, model)
ts_mutate &lt;- ts_mutate(ts, mutation_rate = 1e-8, random_seed = 42)

ts_mutate
</code></pre>

<hr>
<h2 id='ts_names'>Extract names of individuals in a tree sequence</h2><span id='topic+ts_names'></span>

<h3>Description</h3>

<p>Extract names of individuals in a tree sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_names(ts, split = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_names_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_names_+3A_split">split</code></td>
<td>
<p>Should sample names in the tree sequence be split by a column
(a population or time column)? Default is <code>NULL</code> and all names of
samples will be returned as a single character vector. If set to &quot;pop&quot; or
&quot;time&quot;, a list of character vectors will be returned, one vector for each
unique &quot;pop&quot; or &quot;time&quot; grouping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character sample names. If <code>split</code> is specified,
a list of such vectors is returned, one element of the list per population
or sampling time.
</p>

<hr>
<h2 id='ts_nodes'>Extract combined annotated table of individuals and nodes</h2><span id='topic+ts_nodes'></span>

<h3>Description</h3>

<p>This function combines information from the table of individuals and table of
nodes into a single data frame which can be used in downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_nodes(x, sf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_nodes_+3A_x">x</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code> or a <code>phylo</code>
object extracted by <code>ts_phylo</code></p>
</td></tr>
<tr><td><code id="ts_nodes_+3A_sf">sf</code></td>
<td>
<p>Should spatial data be returned in an sf format? If <code>FALSE</code>,
spatial geometries will be returned simply as x and y columns, instead of
the standard POINT data type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The source of data (tables of individuals and nodes recorded in the tree
sequence generated by SLiM) are combined into a single data frame. If the
model which generated the data was spatial, coordinates of nodes (which are
pixel-based by default because SLiM spatial simulations occur on a raster),
the coordinates are automatically converted to an explicit spatial object of
the <code>sf</code> class unless <code>spatial = FALSE</code>. See
<a href="https://r-spatial.github.io/sf/">https://r-spatial.github.io/sf/</a> for an extensive introduction to the sf
package and the ways in which spatial data can be processed, analysed, and
visualised.
</p>


<h3>Value</h3>

<p>Data frame with processed information from the tree sequence object.
If the model which generated this data was spatial, result will be returned
as a spatial object of the class <code>sf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts_table">ts_table</a></code> for accessing raw tree sequence tables
without added metadata annotation. See also <code><a href="#topic+ts_ancestors">ts_ancestors</a></code> to
learn how to extract information about relationship beteween nodes in the
tree sequence, and how to analysed data about distances between nodes in
the spatial context.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# extract an annotated table with (spatio-)temporal node information
ts_nodes(ts)
</code></pre>

<hr>
<h2 id='ts_phylo'>Convert a tree in the tree sequence to an object of the class <code>phylo</code></h2><span id='topic+ts_phylo'></span>

<h3>Description</h3>

<p>Convert a tree in the tree sequence to an object of the class <code>phylo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_phylo(
  ts,
  i,
  mode = c("index", "position"),
  labels = c("tskit", "pop"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_phylo_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_phylo_+3A_i">i</code></td>
<td>
<p>Position of the tree in the tree sequence. If <code>mode = "index"</code>,
an i-th tree will be returned (in zero-based indexing as in tskit), if
<code>mode = "position"</code>, a tree covering the i-th base of the simulated genome will be
returned (again, in tskit's indexing).</p>
</td></tr>
<tr><td><code id="ts_phylo_+3A_mode">mode</code></td>
<td>
<p>How should the <code>i</code> argument be interpreted? Either &quot;index&quot;
as an i-th tree in the sequence of genealogies, or &quot;position&quot; along the
simulated genome.</p>
</td></tr>
<tr><td><code id="ts_phylo_+3A_labels">labels</code></td>
<td>
<p>What should be stored as node labels in the final <code>phylo</code>
object? Options are either a population name or a tskit integer node ID
(which is a different thing from a <code>phylo</code> class node integer index).</p>
</td></tr>
<tr><td><code id="ts_phylo_+3A_quiet">quiet</code></td>
<td>
<p>Should ape's internal phylo validity test be printed out?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard phylogenetic tree object implemented by the R package ape
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;%
  ts_recapitate(Ne = 10000, recombination_rate = 1e-8) %&gt;%
  ts_simplify()

# extract the 1st tree from a given tree sequence, return ape object
tree &lt;- ts_phylo(ts, i = 1, mode = "index", quiet = TRUE)
tree

# extract the tree at a 42th basepair in the given tree sequence
tree &lt;- ts_phylo(ts, i = 42, mode = "position", quiet = TRUE)

# because the tree is a standard ape phylo object, we can plot it easily
plot(tree, use.edge.length = FALSE)
ape::nodelabels()
</code></pre>

<hr>
<h2 id='ts_recapitate'>Recapitate the tree sequence</h2><span id='topic+ts_recapitate'></span>

<h3>Description</h3>

<p>Recapitate the tree sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_recapitate(
  ts,
  recombination_rate,
  Ne = NULL,
  demography = NULL,
  random_seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_recapitate_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object loaded by <code>ts_load</code></p>
</td></tr>
<tr><td><code id="ts_recapitate_+3A_recombination_rate">recombination_rate</code></td>
<td>
<p>A constant value of the recombination rate</p>
</td></tr>
<tr><td><code id="ts_recapitate_+3A_ne">Ne</code></td>
<td>
<p>Effective population size during the recapitation process</p>
</td></tr>
<tr><td><code id="ts_recapitate_+3A_demography">demography</code></td>
<td>
<p>Ancestral demography to be passed internally to
<code>msprime.sim_ancestry()</code> (see msprime's documentation for mode detail)</p>
</td></tr>
<tr><td><code id="ts_recapitate_+3A_random_seed">random_seed</code></td>
<td>
<p>Random seed passed to pyslim's <code>recapitate</code> method
(if <code>NULL</code>, a seed will be generated between 0 and the maximum integer
number available)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tree-sequence object of the class <code>slendr_ts</code>, which serves as
an interface point for the Python module tskit using slendr functions with
the <code>ts_</code> prefix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts_nodes">ts_nodes</a></code> for extracting useful information about
individuals, nodes, coalescent times and geospatial locations of nodes on a
map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

ts &lt;- ts_load(slendr_ts, model) %&gt;%
  ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = 42)

ts
</code></pre>

<hr>
<h2 id='ts_samples'>Extract names and times of individuals of interest in the current tree sequence
(either all sampled individuals or those that the user simplified to)</h2><span id='topic+ts_samples'></span>

<h3>Description</h3>

<p>Extract names and times of individuals of interest in the current tree sequence
(either all sampled individuals or those that the user simplified to)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_samples(ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_samples_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table of individuals scheduled for sampling across space and time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# extract the table of individuals scheduled for simulation and sampling
ts_samples(ts)
</code></pre>

<hr>
<h2 id='ts_save'>Save a tree sequence to a file</h2><span id='topic+ts_save'></span>

<h3>Description</h3>

<p>Save a tree sequence to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_save(ts, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_save_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object loaded by <code>ts_load</code></p>
</td></tr>
<tr><td><code id="ts_save_+3A_file">file</code></td>
<td>
<p>File to which the tree sequence should be saved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree sequence
ts &lt;- ts_load(slendr_ts, model)

# save the tree-sequence object to a different location
another_file &lt;- paste(tempfile(), ".trees")
ts_save(ts, another_file)
</code></pre>

<hr>
<h2 id='ts_segregating'>Calculate the density of segregating sites for the given sets of individuals</h2><span id='topic+ts_segregating'></span>

<h3>Description</h3>

<p>Calculate the density of segregating sites for the given sets of individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_segregating(
  ts,
  sample_sets,
  mode = c("site", "branch", "node"),
  windows = NULL,
  span_normalise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_segregating_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_segregating_+3A_sample_sets">sample_sets</code></td>
<td>
<p>A list (optionally a named list) of character vectors with
individual names (one vector per set). If a simple vector is provided, it
will be interpreted as <code>as.list(sample_sets)</code>, meaning that a given
statistic will be calculated for each individual separately.</p>
</td></tr>
<tr><td><code id="ts_segregating_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_segregating_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
are added automatically)</p>
</td></tr>
<tr><td><code id="ts_segregating_+3A_span_normalise">span_normalise</code></td>
<td>
<p>Divide the result by the span of the window? Default
TRUE, see the tskit documentation for more detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each set of individuals either a single diversity value or a
vector of diversity values (one for each window)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# collect sampled individuals from all populations in a list
sample_sets &lt;- ts_samples(ts) %&gt;%
  split(., .$pop) %&gt;%
  lapply(function(pop) pop$name)

ts_segregating(ts, sample_sets)
</code></pre>

<hr>
<h2 id='ts_simplify'>Simplify the tree sequence down to a given set of individuals</h2><span id='topic+ts_simplify'></span>

<h3>Description</h3>

<p>This function is a convenience wrapper around the <code>simplify</code> method
implemented in tskit, designed to work on tree sequence data simulated by
SLiM using the <span class="pkg">slendr</span> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_simplify(
  ts,
  simplify_to = NULL,
  keep_input_roots = FALSE,
  keep_unary = FALSE,
  keep_unary_in_individuals = FALSE,
  filter_nodes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_simplify_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_simplify_+3A_simplify_to">simplify_to</code></td>
<td>
<p>A character vector of individual names. If NULL, all
explicitly remembered individuals (i.e. those specified via the
<code><a href="#topic+schedule_sampling">schedule_sampling</a></code> function will be left in the tree sequence
after the simplification.</p>
</td></tr>
<tr><td><code id="ts_simplify_+3A_keep_input_roots">keep_input_roots</code></td>
<td>
<p>Should the history ancestral to the MRCA of all
samples be retained in the tree sequence? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ts_simplify_+3A_keep_unary">keep_unary</code></td>
<td>
<p>Should unary nodes be preserved through simplification?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ts_simplify_+3A_keep_unary_in_individuals">keep_unary_in_individuals</code></td>
<td>
<p>Should unary nodes be preserved through
simplification if they are associated with an individual recorded in
the table of individuals? Default is <code>FALSE</code>. Cannot be set to
<code>TRUE</code> if <code>keep_unary</code> is also TRUE</p>
</td></tr>
<tr><td><code id="ts_simplify_+3A_filter_nodes">filter_nodes</code></td>
<td>
<p>Should nodes be reindexed after simplification? Default is
<code>TRUE</code>. See tskit's documentation for the Python method <code>simplify()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplification process is used to remove redundant information from the
tree sequence and retains only information necessary to describe the
genealogical history of a set of samples.
</p>
<p>For more information on how simplification works in pyslim and tskit, see the
official documentation at
<a href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify">https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify</a>
and <a href="https://tskit.dev/pyslim/docs/latest/tutorial.html#simplification">https://tskit.dev/pyslim/docs/latest/tutorial.html#simplification</a>.
</p>
<p>A very clear description of the difference between remembering and retaining
and how to use these techniques to implement historical individuals (i.e.
ancient DNA samples) is in the pyslim documentation at
<a href="https://tskit.dev/pyslim/docs/latest/tutorial.html#historical-individuals">https://tskit.dev/pyslim/docs/latest/tutorial.html#historical-individuals</a>.
</p>


<h3>Value</h3>

<p>Tree-sequence object of the class <code>slendr_ts</code>, which serves as
an interface point for the Python module tskit using slendr functions with
the <code>ts_</code> prefix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts_nodes">ts_nodes</a></code> for extracting useful information about
individuals, nodes, coalescent times and geospatial locations of nodes on a
map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

ts &lt;- ts_load(slendr_ts, model)
ts

# simplify tree sequence to sampled individuals
ts_simplified &lt;- ts_simplify(ts)

# simplify to a subset of sampled individuals
ts_small &lt;- ts_simplify(ts, simplify_to = c("CH_1", "NEA_1", "NEA_2", "AFR_1",
                                            "AFR_2", "EUR_1", "EUR_2"))

ts_small
</code></pre>

<hr>
<h2 id='ts_table'>Get the table of individuals/nodes/edges/mutations from the tree sequence</h2><span id='topic+ts_table'></span>

<h3>Description</h3>

<p>This function extracts data from a given tree sequence table. All times are
converted to model-specific time units from tskit's &quot;generations backwards&quot;
time direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_table(ts, table = c("individuals", "edges", "nodes", "mutations"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_table_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_table_+3A_table">table</code></td>
<td>
<p>Which tree sequence table to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further processing and analyses, the output of the function
<code><a href="#topic+ts_nodes">ts_nodes</a></code> might be more useful, as it merges the information in
node and individual tables into one table and further annotates it with
useful information from the model configuration data.
</p>


<h3>Value</h3>

<p>Data frame with the information from the give tree-sequence table
(can be either a table of individuals, edges, nodes, or mutations).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts_nodes">ts_nodes</a></code> and <code><a href="#topic+ts_edges">ts_edges</a></code> for accessing an
annotated, more user-friendly and analysis-friendly tree-sequence table
data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk and add mutations to it
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# get the 'raw' tskit table of individuals
ts_table(ts, "individuals")

# get the 'raw' tskit table of edges
ts_table(ts, "edges")

# get the 'raw' tskit table of nodes
ts_table(ts, "nodes")

# get the 'raw' tskit table of mutations
ts_table(ts, "mutations")
</code></pre>

<hr>
<h2 id='ts_tajima'>Calculate Tajima's D for given sets of individuals</h2><span id='topic+ts_tajima'></span>

<h3>Description</h3>

<p>For a discussion on the difference between &quot;site&quot; and &quot;branch&quot; options of the
<code>mode</code> argument, please see the tskit documentation at
<a href="https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode">https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_tajima(ts, sample_sets, mode = c("site", "branch", "node"), windows = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_tajima_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_tajima_+3A_sample_sets">sample_sets</code></td>
<td>
<p>A list (optionally a named list) of character vectors with
individual names (one vector per set). If a simple vector is provided, it
will be interpreted as <code>as.list(sample_sets)</code>, meaning that a given
statistic will be calculated for each individual separately.</p>
</td></tr>
<tr><td><code id="ts_tajima_+3A_mode">mode</code></td>
<td>
<p>The mode for the calculation (&quot;sites&quot; or &quot;branch&quot;)</p>
</td></tr>
<tr><td><code id="ts_tajima_+3A_windows">windows</code></td>
<td>
<p>Coordinates of breakpoints between windows. The first
coordinate (0) and the last coordinate (equal to <code>ts$sequence_length</code>)
are added automatically)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each set of individuals either a single Tajima's D value or a
vector of Tajima's D values (one for each window)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model) %&gt;% ts_mutate(mutation_rate = 1e-8, random_seed = 42)

# calculate Tajima's D for given sets of individuals in a tree sequence ts
ts_tajima(ts, list(eur = c("EUR_1", "EUR_2", "EUR_3", "EUR_4", "EUR_5"),
                   nea = c("NEA_1", "NEA_2")))
</code></pre>

<hr>
<h2 id='ts_tracts'>Extract ancestry tracts from a tree sequence (EXPERIMENTAL)</h2><span id='topic+ts_tracts'></span>

<h3>Description</h3>

<p>Extract a data frame with coordinates of ancestry tracts from a given tree sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_tracts(
  ts,
  census,
  squashed = TRUE,
  source = NULL,
  target = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_tracts_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_tracts_+3A_census">census</code></td>
<td>
<p>Census time. See the documentation linked in the Details for more
information. If a slendr-specific tree sequence was provided as <code>ts</code>,
the census time is expected to be given in slendr model-specific time units,
and must correspond to some gene-flow event encoded by the model.</p>
</td></tr>
<tr><td><code id="ts_tracts_+3A_squashed">squashed</code></td>
<td>
<p>Should ancestry tracts be squashed (i.e., should continuous
tracts that can be traced to different ancestral nodes be merged)? Default
is <code>TRUE</code>. If <code>FALSE</code>, these effectively continuous ancestry
tracts will be split into individual segments, each assigned to a specific
ancestral node ID (recorded in a column <code>ancestor_id</code>).</p>
</td></tr>
<tr><td><code id="ts_tracts_+3A_source">source</code></td>
<td>
<p>From which source population to extract tracts for? if <code>NULL</code>
(the default), ancestry tracts for all populations contributing gene flow
at the census time will be reported. Otherwise, ancestry tracts from only
specified source populations will be extracted. Note that this option is
ignored for non-slendr tree sequences!</p>
</td></tr>
<tr><td><code id="ts_tracts_+3A_target">target</code></td>
<td>
<p>Similar purpose as <code>source</code> above, except that it filters
for tracts discovered in the target population(s)</p>
</td></tr>
<tr><td><code id="ts_tracts_+3A_quiet">quiet</code></td>
<td>
<p>Should the default summary output of the <code>tspop</code> Python package
be silenced? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements an R-friendly interface to an algorithm for
extracting ancestry tracts provided by the Python module tspop
<a href="https://tspop.readthedocs.io/en/latest/">https://tspop.readthedocs.io/en/latest/</a> and developed by Georgia Tsambos.
Please make sure to cite the paper which describes the algorithm in
detail: <a href="https://academic.oup.com/bioinformaticsadvances/article/3/1/vbad163/7429395">https://academic.oup.com/bioinformaticsadvances/article/3/1/vbad163/7429395</a>.
For more technical details, see also the tutorial at:
<a href="https://tspop.readthedocs.io/en/latest/basicusage.html">https://tspop.readthedocs.io/en/latest/basicusage.html</a>.
</p>
<p>In general, when using this function on a slendr-generated tree sequence,
please be aware that the output changes slightly to what you would get by
running the pure <code>tspop.get_pop_ancestry()</code> in Python. First,
<code>ts_tracts()</code> populates the output data frame with additional metadata
(such as names of individuals or populations). Additionally, for slendr models,
it is specifically designed to only return ancestry tracts originating to a
an ancestral population which contributed its ancestry during a gene-flow
event which started at a specific time (i.e., scheduled in a model via
the <code>gene_flow()</code>) function. It does not return every single ancestry
tracts present in the tree sequence for every single sample node (and every
single potential ancestry population) as does the <code>tspop.get_pop_ancestry()</code>
Python method.
</p>
<p>That said, when run on a tree sequence which does not originate from a slendr
simulation, the behavior of <code>ts_tracts()</code> is identical to that of the
underlying <code>tspop.get_pop_ancestry()</code>.
</p>
<p>As of the current version of slendr, <code>ts_tracts()</code> only works for
slendr/msprime sequences but not on slendr/SLiM tree sequences. Support for
slendr-generated SLiM tree sequences is in development. Tracts from tree
sequences originating from non-slendr msprime and SLiM simulations are not
restricted in any way and, as mentioned in the previous paragraph,
<code>ts_tracts()</code> in this situation effectively reduces to the standard
<code>tspop.get_pop_ancestry()</code> call.
</p>


<h3>Value</h3>

<p>A data frame containing coordinates of ancestry tracts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env(quiet = TRUE)

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_msprime.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(file = slendr_ts, model = model)

# extract Neanderthal ancestry tracts (i.e. those corresponding to the
# census event at the gene-flow time at 55000 kya as scheduled by
# the simulation which produced the tree sequence)
nea_tracts &lt;- ts_tracts(ts, census = 55000, source = "NEA")
nea_tracts
</code></pre>

<hr>
<h2 id='ts_tree'>Get a tree from a given tree sequence</h2><span id='topic+ts_tree'></span>

<h3>Description</h3>

<p>For more information about optional keyword arguments see tskit documentation:
<a href="https://tskit.dev/tskit/docs/stable/python-api.html#the-treesequence-class">https://tskit.dev/tskit/docs/stable/python-api.html#the-treesequence-class</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_tree(ts, i, mode = c("index", "position"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_tree_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_tree_+3A_i">i</code></td>
<td>
<p>Position of the tree in the tree sequence. If <code>mode = "index"</code>,
an i-th tree will be returned (in zero-based indexing as in tskit), if
<code>mode = "position"</code>, a tree covering the i-th base of the simulated genome will be
returned (again, in tskit's indexing).</p>
</td></tr>
<tr><td><code id="ts_tree_+3A_mode">mode</code></td>
<td>
<p>How should the <code>i</code> argument be interpreted? Either &quot;index&quot;
as an i-th tree in the sequence of genealogies, or &quot;position&quot; along the
simulated genome.</p>
</td></tr>
<tr><td><code id="ts_tree_+3A_...">...</code></td>
<td>
<p>Additional keyword arguments accepted by
<code>tskit.TreeSequence.at and tskit.TreeSequence.at_index</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Python-reticulate-based object of the class tskit.trees.Tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
init_env()

# load an example model with an already simulated tree sequence
slendr_ts &lt;- system.file("extdata/models/introgression_slim.trees", package = "slendr")
model &lt;- read_model(path = system.file("extdata/models/introgression", package = "slendr"))

# load the tree-sequence object from disk
ts &lt;- ts_load(slendr_ts, model)

# extract the zero-th tree in the tree sequence
tree &lt;- ts_tree(ts, i = 0)

# extract the tree at a position in the tree sequence
tree &lt;- ts_tree(ts, i = 100000, mode = "position")
</code></pre>

<hr>
<h2 id='ts_vcf'>Save genotypes from the tree sequence as a VCF file</h2><span id='topic+ts_vcf'></span>

<h3>Description</h3>

<p>Save genotypes from the tree sequence as a VCF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_vcf(ts, path, chrom = NULL, individuals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_vcf_+3A_ts">ts</code></td>
<td>
<p>Tree sequence object of the class <code>slendr_ts</code></p>
</td></tr>
<tr><td><code id="ts_vcf_+3A_path">path</code></td>
<td>
<p>Path to a VCF file</p>
</td></tr>
<tr><td><code id="ts_vcf_+3A_chrom">chrom</code></td>
<td>
<p>Chromosome name to be written in the CHROM column of the VCF</p>
</td></tr>
<tr><td><code id="ts_vcf_+3A_individuals">individuals</code></td>
<td>
<p>A character vector of individuals in the tree sequence. If
missing, all individuals present in the tree sequence will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='world'>Define a world map for all spatial operations</h2><span id='topic+world'></span>

<h3>Description</h3>

<p>Defines either an abstract geographic landscape (blank or containing
user-defined landscape) or using a real Earth cartographic data from the
Natural Earth project (<a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>world(
  xrange,
  yrange,
  landscape = "naturalearth",
  crs = NULL,
  scale = c("small", "medium", "large")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="world_+3A_xrange">xrange</code></td>
<td>
<p>Two-dimensional vector specifying minimum and maximum
horizontal range (&quot;longitude&quot; if using real Earth cartographic data)</p>
</td></tr>
<tr><td><code id="world_+3A_yrange">yrange</code></td>
<td>
<p>Two-dimensional vector specifying minimum and maximum vertical
range (&quot;latitude&quot; if using real Earth cartographic data)</p>
</td></tr>
<tr><td><code id="world_+3A_landscape">landscape</code></td>
<td>
<p>Either &quot;blank&quot; (for blank abstract geography),
&quot;naturalearth&quot; (for real Earth geography) or an object of the class
<code>sf</code> defining abstract geographic features of the world</p>
</td></tr>
<tr><td><code id="world_+3A_crs">crs</code></td>
<td>
<p>EPSG code of a coordinate reference system to use for spatial
operations. No CRS is assumed by default (<code>NULL</code>), implying an
abstract landscape not tied to any real-world geographic region (when
<code>landscape = "blank"</code> or when <code>landscape</code> is a custom-defined
geographic landscape), or implying WGS-84 (EPSG 4326) coordinate system
when a real Earth landscape was defined (<code>landscape =
  "naturalearth"</code>).</p>
</td></tr>
<tr><td><code id="world_+3A_scale">scale</code></td>
<td>
<p>If Natural Earth geographic data is used (i.e. <code>landscape =
  "naturalearth"</code>), this parameter determines the resolution of the data
used. The value &quot;small&quot; corresponds to 1:110m data and is provided with the
package, values &quot;medium&quot; and &quot;large&quot; correspond to 1:50m and 1:10m
respectively and will be downloaded from the internet. Default value is
&quot;small&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class <code>slendr_map</code>, which encodes a standard
spatial object of the class <code>sf</code> with additional slendr-specific
attributes such as requested x-range and y-range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a blank abstract world 1000x1000 distance units in size
blank_map &lt;- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = "blank")

# it is possible to construct custom landscapes (islands, corridors, etc.)
island1 &lt;- region("island1", polygon = list(c(10, 30), c(50, 30), c(40, 50), c(0, 40)))
island2 &lt;- region("island2", polygon = list(c(60, 60), c(80, 40), c(100, 60), c(80, 80)))
island3 &lt;- region("island3", center = c(20, 80), radius = 10)
archipelago &lt;- island1 %&gt;% join(island2) %&gt;% join(island3)

custom_map &lt;- world(xrange = c(1, 100), c(1, 100), landscape = archipelago)

# real Earth landscapes can be defined using freely-available Natural Earth
# project data and with the possibility to specify an appropriate Coordinate
# Reference System, such as this example of a map of Europe

real_map &lt;- world(xrange = c(-15, 40), yrange = c(30, 60), crs = "EPSG:3035")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
