<!DOCTYPE html><html lang="en"><head><title>Help for package timedeppar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timedeppar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc.acceptfreq'><p>Calculate apparent acceptance frequency of time-dependent parameter</p></a></li>
<li><a href='#calc.logpdf'><p>Calculate log pdf values (prior, internal, posterior) from an object of type <code>timedeppar</code></p></a></li>
<li><a href='#get.label'><p>Construct a plot label from expressions for variables and units</p></a></li>
<li><a href='#get.param'><p>Extract parameter list and process parameter vectors from an object of type <code>timedeppar</code></p></a></li>
<li><a href='#get.parsamp'><p>Get a sample of lists of constant and time-dependent parameters from inference results of <code>infer.timedeppar</code></p></a></li>
<li><a href='#infer.timedeppar'><p>Jointly infer constant and time-dependent parameters of a dynamic model given time-series data</p></a></li>
<li><a href='#logpdfOU'><p>Calculate log pdf of an Ornstein-Uhlenbeck process</p></a></li>
<li><a href='#plot.timedeppar'><p>Plot results of time-dependent parameter estimation</p></a></li>
<li><a href='#randOU'><p>Draw from an Ornstein-Uhlenbeck process</p></a></li>
<li><a href='#randsplit'><p>Draw indices for a random split of a vector into intervals of the same mean length</p></a></li>
<li><a href='#readres.timedeppar'><p>Reads an object of type <code>timedeppar</code> saved to a file by <code>infer.timedeppar</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Infer Constant and Stochastic, Time-Dependent Model Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt; </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Infer constant and stochastic, time-dependent parameters to consider intrinsic stochasticity of a dynamic model and/or to analyze model structure modifications that could reduce model deficits.
  The concept is based on inferring time-dependent parameters as stochastic processes in the form of Ornstein-Uhlenbeck processes jointly with inferring constant model parameters and parameters of the Ornstein-Uhlenbeck processes.
  The package also contains functions to sample from and calculate densities of Ornstein-Uhlenbeck processes.
  References:
  Tomassini, L., Reichert, P., Kuensch, H.-R. Buser, C., Knutti, R. and Borsuk, M.E. (2009), A smoothing algorithm for estimating stochastic, continuous-time model parameters and its application to a simple climate model, Journal of the Royal Statistical Society: Series C (Applied Statistics) 58, 679-704, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9876.2009.00678.x">doi:10.1111/j.1467-9876.2009.00678.x</a>&gt;
  Reichert, P., and Mieleitner, J. (2009), Analyzing input and structural uncertainty of nonlinear dynamic models with stochastic, time-dependent parameters. Water Resources Research, 45, W10402, &lt;<a href="https://doi.org/10.1029%2F2009WR007814">doi:10.1029/2009WR007814</a>&gt;
  Reichert, P., Ammann, L. and Fenicia, F. (2021), Potential and challenges of investigating intrinsic uncertainty of hydrological models with time-dependent, stochastic parameters. Water Resources Research 57(8), e2020WR028311, &lt;<a href="https://doi.org/10.1029%2F2020WR028311">doi:10.1029/2020WR028311</a>&gt;
  Reichert, P. (2022), timedeppar: An R package for inferring stochastic, time-dependent model parameters, in preparation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/p.reichert/timedeppar">https://gitlab.com/p.reichert/timedeppar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/p.reichert/timedeppar/-/issues">https://gitlab.com/p.reichert/timedeppar/-/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 10:10:39 UTC; peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc.acceptfreq'>Calculate apparent acceptance frequency of time-dependent parameter</h2><span id='topic+calc.acceptfreq'></span>

<h3>Description</h3>

<p>This function calculates the apparent acceptance frequency from a potentially thinned Markov chain sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.acceptfreq(x, n.burnin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.acceptfreq_+3A_x">x</code></td>
<td>
<p>results from the function <code>infer.timedeppar</code> of class <code>timedeppar</code>.</p>
</td></tr>
<tr><td><code id="calc.acceptfreq_+3A_n.burnin">n.burnin</code></td>
<td>
<p>number of (unthinned) burnin points of the Markov chain to omit from analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list two-column matrices with time and apparent acceptance frequencies
</p>

<hr>
<h2 id='calc.logpdf'>Calculate log pdf values (prior, internal, posterior) from an object of type <code>timedeppar</code></h2><span id='topic+calc.logpdf'></span>

<h3>Description</h3>

<p>This function calculated log priors, log pdf of Ornstein-Uhlenbeck time dependent parameters, and
log posterior from an object of type <code>timedeppar</code> produced by the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.logpdf(x, param, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.logpdf_+3A_x">x</code></td>
<td>
<p>results from the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code> of class <code>timedeppar</code>.</p>
</td></tr>
<tr><td><code id="calc.logpdf_+3A_param">param</code></td>
<td>
<p>list of parameter lists and vectors extracted from an object of class
<code>timedeppar</code> using the function <code><a href="#topic+get.param">get.param</a></code>.</p>
</td></tr>
<tr><td><code id="calc.logpdf_+3A_verbose">verbose</code></td>
<td>
<p>boolean indicator for writing the results to the console
(default is not to do it).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vecctor of values of the different log pdfs.
</p>

<hr>
<h2 id='get.label'>Construct a plot label from expressions for variables and units</h2><span id='topic+get.label'></span>

<h3>Description</h3>

<p>This function produces an expression to label plots from expressions for variables and units and from character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.label(var.name, labels = NA, units = NA, t1 = "", t2 = "", t3 = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.label_+3A_var.name">var.name</code></td>
<td>
<p>name of the variable.</p>
</td></tr>
<tr><td><code id="get.label_+3A_labels">labels</code></td>
<td>
<p>named vector of expressions encoding variable names with greek letters, sub- and superscripts.</p>
</td></tr>
<tr><td><code id="get.label_+3A_units">units</code></td>
<td>
<p>named vector of expressions encoding units with sub- and superscripts.</p>
</td></tr>
<tr><td><code id="get.label_+3A_t1">t1</code></td>
<td>
<p>optional text (see below).</p>
</td></tr>
<tr><td><code id="get.label_+3A_t2">t2</code></td>
<td>
<p>optional text (see below).</p>
</td></tr>
<tr><td><code id="get.label_+3A_t3">t3</code></td>
<td>
<p>optional text (see below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expression of a label of the form: t1 label t2 [unit] t3<br />
label and unit are extracted from the vectors <code>labels</code> and <code>units</code>
by using the compontents named <code>var.name</code>
</p>

<hr>
<h2 id='get.param'>Extract parameter list and process parameter vectors from an object of type <code>timedeppar</code></h2><span id='topic+get.param'></span>

<h3>Description</h3>

<p>This function extracts an element of the stored Markov chain from an object of type <code>timedeppar</code> 
produced by the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code> and converts it to a format that facilitates
re-evaluation of the posterior, evaluation of the underlying model, and sampling from the Ornstein-Uhlenbeck
process.
In particular, the constant and time-dependent parameters are provided in the same list format as supplied
as <code>param.ini</code> to the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code>.
In addition, the parameters of the Ornstein-Uhlenbeck process(es) of the time-dependent parameters are
provided in different formats (see details below under <code>Value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.param(x, ind.sample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.param_+3A_x">x</code></td>
<td>
<p>results from the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code> of class <code>timedeppar</code>.</p>
</td></tr>
<tr><td><code id="get.param_+3A_ind.sample">ind.sample</code></td>
<td>
<p>index of the stored (potentially thinned) Markov chain defining which parameters 
to reconstruct.
Default is to extract the parameters corresponding to the maximum posterior 
solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements:<br />
<code>param</code>: list of constant and time-dependent model parameters,<br />
<code>param.ou.estim</code>: vector of estimated process parameters of all time-dependent parameters,<br />
<code>param.ou.fixed</code>: vector of fixed process parameters of all time-dependent parameters,<br />
<code>param.ou</code>: matrix of Ornstein-Uhlenbeck parameters for all time-dependent parameters;
columns are mean, sd and gamma of the processes, rows are the time-dependent parameter(s).<br />
<code>logpdf</code>: corresponding lopdf values (posterior, intermediate densities, and priors),<br />
<code>ind.timedeppar</code>: indices of <code>param</code> at which parameters are time-dependent.<br />
<code>ind.sample</code>: sample index.<br />
<code>ind.chain</code>: corresponding index of the Markov chain.<br />
</p>

<hr>
<h2 id='get.parsamp'>Get a sample of lists of constant and time-dependent parameters from inference results of <code>infer.timedeppar</code></h2><span id='topic+get.parsamp'></span>

<h3>Description</h3>

<p>This function produces a sample of parameter sets for past and potentially future time points based on the results of
class <code>timedeppar</code> generated by Bayesian inference with the function <code>infer.timedeppar</code>.
For time points used for inference, the sample is a sub-samble of the Markov chain, for future time points of 
time-dependent parameters it is a random sample based on the corresponding Ornstein-Uhlenbeck parameters and 
constrained at there initial point to the end point of the sub-sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.parsamp(x, samp.size = 1000, n.burnin = 0, times.new = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.parsamp_+3A_x">x</code></td>
<td>
<p>results from the function <code>infer.timedeppar</code> of class <code>timedeppar</code>.</p>
</td></tr>
<tr><td><code id="get.parsamp_+3A_samp.size">samp.size</code></td>
<td>
<p>size of the produced sample constructed from the Markov chain stored in the
object of class <code>timedeppar</code> omitting the adaptation and burnin phases.</p>
</td></tr>
<tr><td><code id="get.parsamp_+3A_n.burnin">n.burnin</code></td>
<td>
<p>number of Markov chain points to omit for density and pairs plots
(number of omitted points is max(control$n.adapt,n.burnin)).</p>
</td></tr>
<tr><td><code id="get.parsamp_+3A_times.new">times.new</code></td>
<td>
<p>vector of time points to predict for.
If no time points are provided, sampling is only from the inference Markov chain;
if time points are provided, they need to be increasing and start with a larger value 
than the time points used for inference.
In the latter case, time-dependent parameters are sampled for the future points and
appended to the inferred part of the time-dependend parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of<br />
<code>param.maxpost</code>:   list of constant and time-dependent parameters corresponding to the maximum posterior
solution for inference (no extrapolation to the future).<br />
<code>param.maxlikeli</code>: list of constant and time-dependent parameters corresponding to the solution with
maximum observation likelihood found so far.<br />
<code>param.list</code>:      list of length <code>samp.size</code> containing lists of constant and time-dependent parameters;
for time-dependent parameters sub-sample of the Markov chain for past time points, 
sample from Ornstein-Uhlenbeck processes conditioned at the initial point for future
time points (see argument <code>times.new</code>).<br />
<code>param.const</code>:     sub-sample of constant parameters.<br />
<code>param.timedep</code>:   list of sub-samples of time-dependent parameters.<br />
<code>param.ou</code>:        sub-sample of Ornstein-Uhlebeck parameters of the time-dependent parameter(s).<br />
<code>ind.timedeppar</code>:  indices of time-dependent parameters in the parameter lists.<br />
<code>ind.sample</code>:      indices of the stored, thinned sample defining the sub-sample.<br />
<code>ind.chain</code>:       indices of the original non-thinned Markov chain defining the sub-sample.<br />
<code>dot.args</code>:        ... arguments passed to <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code>; to be re-used for new
model evaluations.<br />
</p>

<hr>
<h2 id='infer.timedeppar'>Jointly infer constant and time-dependent parameters of a dynamic model given time-series data</h2><span id='topic+infer.timedeppar'></span>

<h3>Description</h3>

<p>This function draws a Markov Chain from the posterior of constant and time-dependent parameters
(following Ornstein-Uhlenbeck processes) of a dynamic model.
The dynamic model is specified by a function that calculates the log likelihood for given time-series 
data.
The Ornstein-Uhlenbeck processes of time-dependent processes are characterized by there mean (<code>mean</code>),
standard deviation (<code>sd</code>), and a rate parameter (<code>gamma</code>) that quantifies temporal correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer.timedeppar(
  loglikeli = NULL,
  loglikeli.keepstate = FALSE,
  param.ini = list(),
  param.range = list(),
  param.log = logical(0),
  param.logprior = NULL,
  param.ou.ini = numeric(0),
  param.ou.fixed = numeric(0),
  param.ou.logprior = NULL,
  task = c("start", "continue", "restart"),
  n.iter = NA,
  cov.prop.const.ini = NA,
  cov.prop.ou.ini = NA,
  scale.prop.const.ini = NA,
  scale.prop.ou.ini = NA,
  control = list(),
  res.infer.timedeppar = list(),
  verbose = 0,
  file.save = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infer.timedeppar_+3A_loglikeli">loglikeli</code></td>
<td>
<p>function that calculates the log likelihood of the model for given constant or
time-dependent parameters and given observational data.<br />
The parameters are passed as a named list in the first argument of the function.
The list elements are either scalar values representing constant parameters
or two-column matrices with columns for time points and values for time-dependent 
parameters.
If the argument <code>loglikeli.keepstate</code> is <code>FALSE</code> no further arguments
are needed (but can be provided, see below).
In this case, the function should return the log likelihood as a single double
value.<br />
If the argument <code>loglikeli.keepstate</code> is <code>TRUE</code>, the second argument
provides the time range over which a time-dependent parameter was changed or NA
if the full simulation time has to be evaluated, and the third argument
provides the state of the functon at the last successful call. 
This allows the function to only calculate and return modifications to that
previous state.
In this case, the function has to return a list with the log likelihood value
as its first element and the current state of the function as the second argument.
This state can be an R variable of an arbitrary data type.
The version from the last accepted MCMC step will be returnde at the next call.<br />
Further arguments provided to <code>infer.timedeppar</code> will be passed to this function.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_loglikeli.keepstate">loglikeli.keepstate</code></td>
<td>
<p>boolean to indicate which kind of interface to the likelihood function is used.
See argument <code>loglikeli</code> for details.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.ini">param.ini</code></td>
<td>
<p>named list of initial vallues of parameters to be estimated.
scalar initial values for constant parameters,
two-column matrices for time and parameter values for time-dependent parameters
(values of time-dependent parameters may be NA and are then drawn from the 
Ornstein-Uhlenbeck process).
The list <code>param.ini</code> needs to be a legal and complete first element of the 
function passed by the argument <code>loglikeli</code>.
For each time-dependent parameter with name <code>&lt;name&gt;</code> 
initial values or fixed value of the parameters
<code>&lt;name&gt;_mean</code>, <code>&lt;name&gt;_sd</code> and <code>&lt;name&gt;_gamma</code> must be provided
in the arguments <code>param.ou.ini</code> or <code>param.ou.fixed</code>, respectively.
These parameters represent the mean, the asymptotic standard deviation, and 
the rate parameter of the Ornstein-Uhlenbeck process.
If these parameters are given in the argument <code>param.ou.ini</code>, 
they are used as initial condition of the inference process and the parameters 
are estimated, 
if they are given in the argument <code>param.ou.fixed</code>,
they are assumed to be given and are kept fixed.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.range">param.range</code></td>
<td>
<p>named list of ranges (2 element vectors with minimum and maximum) of parameters 
that are constrained (non-logarithmic for all parameters)</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.log">param.log</code></td>
<td>
<p>named vector of logicals indicating if inference should be done on the log scale 
(parameters are still given and returned on non-log scales).
For time-dependent parameters, selecting this option implies the use of a lognormal
marginal for the Ornstein-Uhlenbeck process.
This means that the parameter is modelled as exp(Ornstein-Uhlenbeck), but mean
and standard devistion of the process are still on non-log scales.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.logprior">param.logprior</code></td>
<td>
<p>function to calculate the (joint) log prior of all estimaged constant parameters 
of the model.
The function gets as its argument a named vector of the values of the estimaged  
constant parameters to allow the function to identify for which parameters a
joint prior is required in the current setting).</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.ou.ini">param.ou.ini</code></td>
<td>
<p>named vector of initial values of parameters of the Ornstein-Uhlenbeck processes of
time-dependent parameters; see description of argument <code>param.ini</code>.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.ou.fixed">param.ou.fixed</code></td>
<td>
<p>named vector of values of parameters of the Ornstein-Uhlenbeck processes of 
time-dependent parameters that are kept fixed rather than being extimated.
If all process parameters are kept fixed, these names are 
<code>&lt;name&gt;_mean</code>, <code>&lt;name&gt;_sd</code> and <code>&lt;name&gt;_gamma</code> for each
time-dependent parameter with name <code>&lt;name&gt;</code>; see description of the
argument <code>param.ini</code>.
The values specified in <code>param.fixed</code> are ignored if the parameter is also
given in the argument <code>param.ini</code>; in this case it is estimated.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_param.ou.logprior">param.ou.logprior</code></td>
<td>
<p>function to calculate the (joint) log prior of all estimated parameters of
the Ornstein-Uhlenbeck processes of a single time-dependent parameter.
The function gets as its argument a named vector of the values of the process 
parameters to estimated.
These names are a subset of 
<code>&lt;name&gt;_mean</code>, <code>&lt;name&gt;_sd</code> and <code>&lt;name&gt;_gamma</code>; 
see description of the argument <code>param.ini</code>.
The function has to work for each time-dependent parameter by being sensitive
to the parameter names.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_task">task</code></td>
<td>
<p>Which task to perform (default value: &quot;start&quot;):<br />
<code>"start"</code>: start an inference process from scratch based on the arguments of
the function.
The argument <code>res.infer.timedeppar</code> is ignored.<br />
<code>"continue"</code>: continue a Markov chain from a previous call to 
<code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code>.
The results of a previous call have to be provided as the argument 
<code>res.infer.timedeppar</code> in the form of an object of type <code>timedeppar</code>.
To guarantee convergence of the chain, all numerical specifications including the
final state of the chain are taken from the object provided by 
<code>res.infer.timedeppar</code> and the actual arguments of the function are ignored 
except <code>n.iter</code> which specifies the number of iterations to be added 
to the chain.<br />
<code>"restart"</code>: A new chain is started from the last point of a previous chain
except if the argument <code>param.ini</code> is provided.
The results of a previous call have to be provided as the argument 
<code>res.infer.timedeppar</code> in the form of an object of type <code>timedeppar</code>.
Likelihood, prior pdf functions, initial proposal covariance matrices, 
scales and control parameters are taken from 
the previous chain unless explicitly provided.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations of the Markov chain to be performed (default value: 10000).</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_cov.prop.const.ini">cov.prop.const.ini</code></td>
<td>
<p>scaled covariance matrix of the proposal distribution for the Metropolis step of
constant parameters.
The proposal distribution of the Metropolis step is a normal distribution centered
at the last point of the chain with a covariance matrix equal to 
<code>scale.prop.const^2 * cov.prop.const</code>.
Note that if <code>param.log</code> is <code>TRUE</code> for a parameter, then the proposal
is evaluated at the log scale of the parameter.
During the adaptation phase, the covariance matrix is periodically adapted to the
covariance matrix of the current sample and the scale to get a reasonable
acceptance rate.
After the adaptation phase, both variables are kept constant to guarantee 
convergence.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_cov.prop.ou.ini">cov.prop.ou.ini</code></td>
<td>
<p>list of scaled covariance matrices of the proposal distributions for the Metropolis 
step of the parameters of the Ornstein-Uhlenbeck processes of time-dependent
parameters.
The proposal distribution of the Metropolis step for the process parameters of the
time-dependent parameter i is a normal distribution centered
at the last point of the chain with a covariance matrix equal to 
<code>cov.prop.ou[[i]] * scale.prop.ou[i]^2</code>.
Note that if <code>param.log</code> is <code>TRUE</code> for a parameter, then the proposal
for the mean is evaluated at the log scale of the parameter.
This is anyway the case for the standard deviation and the rate parameter of the
Ornstein-Uhlenbeck process.
During the adaptation phase, the covariance matrices are periodically adapted to the
covariance matrix of the current sample and the scale to get a reasonable
acceptance rate.
After the adaptation phase, both variables are kept constant to guarantee 
convergence.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_scale.prop.const.ini">scale.prop.const.ini</code></td>
<td>
<p>scale factor for the covariance matrix of the Metropolis step for constant parameters
with a proposal distribution equal to a normal distribution centered at the previous 
point of the chain and a covariance matrix equal to 
<code>scale.prop.const^2 * cov.prop.const</code>.
During the adaptation phase, the covariance matrix is periodically adapted to the
covariance matrix of the current sample and the scale to get a reasonable
acceptance rate.
After the adaptation phase, both variables are kept constant to guarantee 
convergence.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_scale.prop.ou.ini">scale.prop.ou.ini</code></td>
<td>
<p>vector of scale factors for the covariance matrices of the Metropolis step for parameters
of Ornstein-Uhlenbeck processes with a proposal distribution equal to a normal 
distribution centered at the previous point of the chain and a covariance matrix 
for the time dependent parameter i equal to <code>cov.prop.ou[[i]] * scale.prop.ou[i]^2</code>.
During the adaptation phase, the covariance matrix is periodically adapted to the
covariance matrix of the current sample and the scale to get a reasonable
acceptance rate.
After the adaptation phase, both variables are kept constant to guarantee 
convergence.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_control">control</code></td>
<td>
<p>list of control parameters of the algorithm:
</p>

<ul>
<li>
<p><code>n.interval</code>: number of sub-intervals into which the time domain is splitted
to infer the time-dependent parameters; either scalar for universal
choice for all parameters or named vector for parameter-specific
choices
(default value: 50; this number must be increased if the acceptance
rates of the time-dependent parameters are very low, it can be decreased
if they are high);
</p>
</li>
<li>
<p><code>min.internal</code>: minimum number of internal points in an interval 
(default value: 1; may be increased if time resolution is high).
</p>
</li>
<li>
<p><code>splitmethod</code>: method used for random splitting of time domain into sub-intervals.
Possible values:
<code>"modunif"</code>:     modification of uniform intervals;
<code>"random"</code>:      random split (higher variability in inverval lengths);
<code>"weighted"</code>:    weighted random split leading to shorter intervals
where the acceptance frequency is low;
<code>"autoweights"</code>: use weighted random split but adjusts weights 
adaptively.
(default value: <code>"modunif"</code>).
</p>
</li>
<li>
<p><code>interval.weights</code>: numerical vector or named list of numerical vectors 
(by time-dependent parameter) of weights for sampling interval 
boundaries (the length(s) of the vector(s) must be equal to the
time series length in the parameter specification).
The weight vectors do not have to be normalized.
The weights are used if the parameter <code>splitmethod</code> is
equal to <code>"weighted"</code> or as optional initial weights
if <code>splitmethod</code> is equal to <code>"autoweights"</code>.
</p>
</li>
<li>
<p><code>n.autoweighting</code>: number of past iterations to consider for weight calculation
for <code>splitmethod</code> <code>"autoweights"</code>
(default value: 1000). 
Note that the calculation of weights only starts after 
<code>n.autoweights</code> iterations and that only stored points 
are considerd so that the number of points considered is
equal to <code>n.autoweighting</code>/<code>thin</code>.
</p>
</li>
<li>
<p><code>offset.weighting</code>: offset used to caluclate weights from apparent acceptance
frequencies for <code>splitmethod</code> <code>"autoweights"</code>
(default value: 0.05).
</p>
</li>
<li>
<p><code>n.widening</code>: number grid points used to widen areas of high weight
for <code>splitmethod</code> <code>"autoweights"</code>
(default value: 10).
</p>
</li>
<li>
<p><code>n.timedep.perstep</code>: number of updates of the time-dependent parameter(s) before
updating the constant parameters (default value: 1).
</p>
</li>
<li>
<p><code>n.const.perstep</code>: number of Markov chain steps for the constant parameters
to be performed between updating the time-dependent parameters
(default value: 1).
</p>
</li>
<li>
<p><code>n.adapt</code>: number of iterations of the Markov chain during which adaptation is made 
(default value: 2000; only during this phase, the covariance matrix 
and the scaling factors are adapted).
</p>
</li>
<li>
<p><code>n.adapt.scale</code>: number of iterations after which the acceptance rate is checked for
potentially adapting the scaling factor (default value: 30).
</p>
</li>
<li>
<p><code>n.adapt.cov</code>: number of iterations of the Markov chain, after which the covariance matrix 
of the proposal distribution is adapted 
(default value: 900; 0 means no adaptation of the covariance matrix;
note that after <code>control$n.adapt</code> iterations 
adaptation is turned off; for this reason, after the last multiple of
<code>n.adapt.cov</code> below <code>n.adapt</code> there should be sufficient 
iterations left to adapt the scaling factors).
</p>
</li>
<li>
<p><code>f.reduce.cor</code>: factor by which sample correlations are reduced when constructing
the covariance matrix of the proposal distribution (default value: 0.90).
</p>
</li>
<li>
<p><code>f.accept.decscale</code>: acceptance rate below which the proposal scaling factor is decreased
during the adaptation phase (default value: 0.05).
</p>
</li>
<li>
<p><code>f.accept.incscale</code>: acceptance rate above which the proposal scaling factor is increased
during the adaptation phase (default value: 0.30).
</p>
</li>
<li>
<p><code>f.max.scalechange</code>: max. factor for changing proposal distribution scale from reference
(default value: 10; reference is either initial value or modified 
value when the covariance matrix was adapted).
</p>
</li>
<li>
<p><code>f.sample.cov.restart</code>: fraction of previous samples to be used to calculate the 
covariance matrix of proposal distribution when restarting 
inference (default value: 0.3;
the last part of the samples is used).
</p>
</li>
<li>
<p><code>thin</code>: thinning for storing Markov chain results (default value: 1).
</p>
</li>
<li>
<p><code>n.save</code>: number of iterations after which the results are (periodically) saved 
(default value: 1000).
</p>
</li>
<li>
<p><code>save.diag</code>: save diagnostic information about acceptance ratio, acceptance, and 
interval lengths for inference of the time-dependent parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_res.infer.timedeppar">res.infer.timedeppar</code></td>
<td>
<p>results of a previous call to this function.
These results are ignored if the argument <code>task</code> is equal to <code>"start"</code>, but it is
needed for the tasks <code>"continue"</code> and <code>"restart"</code>.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_verbose">verbose</code></td>
<td>
<p>integer parameter indicating the level of progress reporting:<br />
0: no reporting;<br />
1: reporting of thinned and accepted Markov Chain steps and of adapted proposal covariance matrices;<br />
2: reporting of proposals and accepted steps before thinning.</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_file.save">file.save</code></td>
<td>
<p>if non-empty string, the intermediate results are saved to this file as variable <code>res</code>
in a workspace after every <code>control$n.save</code> iterations 
(the extension <code>.RData</code> will be appended to the file name).</p>
</td></tr>
<tr><td><code id="infer.timedeppar_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the function <code>loglikeli</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>class of type <code>timedeppar</code> with the following elements:
</p>

<ul>
<li>
<p><code>package</code>: package timedeppar: version and date,
</p>
</li>
<li>
<p><code>func</code>: function called (infer.timedeppar),
</p>
</li>
<li>
<p><code>date</code>: date of call,
</p>
</li>
<li>
<p><code>dot.args</code>: arguments passed to the likelihood function (included for reproducibility of results),
</p>
</li>
<li>
<p><code>task</code>: task that was performed (<code>start</code>, <code>restart</code> or <code>continue</code>),
</p>
</li>
<li>
<p><code>file</code>: name of file to which output was written,
</p>
</li>
<li>
<p><code>param.ini</code>: initial values of likelihood parameters (constant and time-dependent),
</p>
</li>
<li>
<p><code>param.ou.ini</code>: initial values of Ornstein-Uhlenbeck process parameters that are estimated,
</p>
</li>
<li>
<p><code>param.ou.fixed</code>: values of Ornstein-Uhlenbeck process parameters that are not estimated,
</p>
</li>
<li>
<p><code>loglikeli</code>: function that was passed to calculate the log likelihood of the observations,
</p>
</li>
<li>
<p><code>loglikeli.keepstate</code>: boolean indicating whether or not the state from the previous run should be kept 
(this allows only partial time evaluation when only part of the input was replaced),
</p>
</li>
<li>
<p><code>param.logprior</code>: function that was passed to calculate the joint log prior of the constant likelihood parameters,
</p>
</li>
<li>
<p><code>param.ou.logprior</code>: function that was passed to calculate the joint log prior of the estimated Ornstein-Uhlenbeck process parameters
(in case of multiple Ornstein-Uhlenbeck processes the function has to return the prior for the correct process;
this can be identified by the names of the argument),
</p>
</li>
<li>
<p><code>param.range</code>: parameter ranges,
</p>
</li>
<li>
<p><code>param.log</code>: named logical vector of indicators for log inference,
</p>
</li>
<li>
<p><code>control</code>: named list of control parameters as passed to the call (or read from a previous call),
</p>
</li>
<li>
<p><code>n.iter</code>: number of iterations peformed (note that the size of the sample will be n.iter/control$thin),
</p>
</li>
<li>
<p><code>sample.diag</code>: list of samples of proposals, log acceptance ratios, and interval lengths of time-dependent
parameters (only available if the control variable <code>save.diag</code> is set to <code>TRUE</code>),
</p>
</li>
<li>
<p><code>sample.param.timedep</code>: list of samples of time dependent parameters (first row contains time points),
</p>
</li>
<li>
<p><code>sample.param.ou</code>: sample of Ornstein-Uhlenbeck process parameters,
</p>
</li>
<li>
<p><code>sample.param.const</code>: sample of constant parameters,
</p>
</li>
<li>
<p><code>sample.logpdf</code>: sample of prior, Ornstein-Uhlenbeck and posterior pdf,
</p>
</li>
<li>
<p><code>acceptfreq.constpar</code>: acceptance frequency of constant parameters after adaptation phase,
</p>
</li>
<li>
<p><code>acceptfreq.oupar</code>: acceptance frequencies of Ornstein-Uhlenbeck process parameters after adaptation phase,
</p>
</li>
<li>
<p><code>acceptfreq.timedeppar</code>: acceptance frequencies of time-depenent parameters,
</p>
</li>
<li>
<p><code>param.maxpost</code>: parameters at the maximum posterior (constant and time-dependent parameters),
</p>
</li>
<li>
<p><code>param.ou.maxpost</code>: Ornstein-Uhlenbeck process parameters at the maximum posterior,
</p>
</li>
<li>
<p><code>cov.prop.const</code>: final covariance matrix used for proposal distribution of constant parameters,
</p>
</li>
<li>
<p><code>cov.prop.ou</code>: list of final covariance matrices used for proposal distribution of Ornstein-Uhlenbeck process paramemters,
</p>
</li>
<li>
<p><code>scale.prop.const</code>: final scale of proposal distribution of constant parameters,
</p>
</li>
<li>
<p><code>scale.prop.ou</code>: final scale of proposal distribution of Ornstein-Uhlenbeck process parameters,
</p>
</li>
<li>
<p><code>sys.time</code>: run time used for the previous inference job.
</p>
</li></ul>



<h3>References</h3>

<p>Reichert, P.
timedeppar: An R package for inferring stochastic, time-dependent model parameters
in preparation, 2020.<br /><br />
Reichert, P., Ammann, L. and Fenicia, F.
Potential and challenges of investigating intrinsic uncertainty of hydrological models with time-dependent, stochastic parameters.
<em>Water Resources Research</em> 57(8), e2020WR028311, 2021.
<a href="https://doi.org/10.1029/2020WR028311">doi:10.1029/2020WR028311</a><br /><br />
Reichert, P. and Mieleitner, J. 
Analyzing input and structural uncertainty of nonlinear dynamic models with stochastic, time-dependent parameters. 
<em>Water Resources Research</em>, 45, W10402, 2009. 
<a href="https://doi.org/10.1029/2009WR007814">doi:10.1029/2009WR007814</a><br /><br />
Tomassini, L., Reichert, P., Kuensch, H.-R. Buser, C., Knutti, R. and Borsuk, M.E. 
A smoothing algorithm for estimating stochastic, continuous-time model parameters 
and its application to a simple climate model. 
<em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em> 58, 679-704, 2009. 
<a href="https://doi.org/10.1111/j.1467-9876.2009.00678.x">doi:10.1111/j.1467-9876.2009.00678.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.timedeppar">plot.timedeppar</a></code> for visualizing results.<br />
<code><a href="#topic+calc.acceptfreq">calc.acceptfreq</a></code> for calculating (apparent) acceptance frequencies.<br />
<code><a href="#topic+calc.logpdf">calc.logpdf</a></code> for calculating log pdf values (prior, internal, posterior) from the results.<br />
<code><a href="#topic+get.param">get.param</a></code> for extracting individual parameters from the Markov chain.<br />
<code><a href="#topic+get.parsamp">get.parsamp</a></code> for extracting subsamples of the Markov chain.<br />
<code><a href="#topic+readres.timedeppar">readres.timedeppar</a></code> for reading saved results from a previous run.<br />
<code><a href="#topic+randOU">randOU</a></code> for sampling from an Ornstein-Uhlenbeck process.<br />
<code><a href="#topic+logpdfOU">logpdfOU</a></code> for calculating the probability density of a sample from an Ornstein-Uhlenbeck process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example for re-inferring parameters of an Ornstein-Uhlenbeck process
# with observational noise from synthetically generated data
# ---------------------------------------------------------------------------

# load package:
if ( !require("timedeppar") ) { install.packages("timedeppar"); library(timedeppar) }

# choose model parameters:
y_mean      &lt;-  0
y_sd        &lt;-  1
y_gamma     &lt;- 10
obs_sd      &lt;-  0.2

# choose control parameters of numerical algorithm:
n.iter      &lt;-   100   # this is just to demonstrate how it works and is compatible
# with the computation time requirements for examples in CRAN
# n.iter      &lt;- 50000   # please go for a sample size like this
#                        # for getting a reasonable sample
n.interval  &lt;-    25   # increase if rejection frequency of stoch. par. too high
fract.adapt &lt;- 0.4
n.adapt     &lt;- floor(fract.adapt*n.iter)

# synthetically generate data:
set.seed(123)
data &lt;- randOU(mean=y_mean,sd=y_sd,gamma=y_gamma,t=seq(from=0,to=2,length.out=101))
data$yobs &lt;- data$y + rnorm(nrow(data),mean=0,sd=obs_sd)

# define observational likelihood:
loglikeli &lt;- function(param,data)
{
 # get parameter y at time points of observations::
 y &lt;- param$y
 if ( is.matrix(y) | is.data.frame(y) ) y &lt;- approx(x=y[,1],y=y[,2],xout=data[,1])$y
 # calculate likelihood:
 loglikeli &lt;- sum(dnorm(data[,"yobs"],mean=y,sd=param$obs_sd,log=TRUE))
 # return result:
 return(loglikeli)
}

# sample from the posterior of y, mu_y, sd_y and sd_obs assuming a uniform prior:
res &lt;- infer.timedeppar(loglikeli      = loglikeli,
                       param.ini      = list(y=randOU(mean=y_mean,sd=y_sd,gamma=y_gamma,
                                                      t=seq(from=0,to=2,length.out=501)),
                                             obs_sd=obs_sd),
                       param.log      = c(y=FALSE,obs_sd=TRUE),
                       param.ou.ini   = c(y_mean=0,y_sd=1),
                       param.ou.fixed = c(y_gamma=10),
                       n.iter         = n.iter,
                       control        = list(n.interval = n.interval,
                                             n.adapt    = n.adapt),
                       data = data)

# plot results using pre-defined options:
# pdf(paste0("infer_OU_",n.iter,"_",n.adapt,"_original.pdf"),width=8,height=12)
plot(res,
    labels=expression(y       = y,
                      y_mean  = mu[y],
                      y_sd    = sigma[y],
                      y_gamma = gamma[y]))
# dev.off()

# plot time series and data:
# pdf(paste0("infer_OU_",n.iter,"_",n.adapt,"_comparison.pdf"),width=8,height=6)
t &lt;- res$sample.param.timedep$y[1,]
sample &lt;- res$sample.param.timedep$y[(1+n.adapt+1):nrow(res$sample.param.timedep$y),]
q &lt;- apply(sample,2,quantile,probs=c(0.025,0.5,0.975))
plot(numeric(0),numeric(0),type="n",xaxs="i",yaxs="i",
    xlim=range(t),ylim=2.5*c(-1,1),xlab="t",ylab="y")
polygon(c(t,rev(t),t[1]),c(q[1,],rev(q[3,]),q[1,1]),
       col="grey80",border=NA)
lines(t,q[2,])
lines(data$t,data$y,col="red")
points(data$t,data$yobs,pch=19,cex=0.8)
legend("bottomright",
      legend=c("original process","noisy data","inferred median","inferred 95% range"),
      lwd=c(1,NA,1,5),lty=c("solid",NA,"solid","solid"),col=c("red","black","black","grey80"),
      pch=c(NA,19,NA,NA),cex=0.8)
# dev.off()
</code></pre>

<hr>
<h2 id='logpdfOU'>Calculate log pdf of an Ornstein-Uhlenbeck process</h2><span id='topic+logpdfOU'></span>

<h3>Description</h3>

<p>This function calculates the log pdf of a realization of an Ornstein-Uhlenbeck process
with given parameters. 
The calculation can be done for an Ornstein-Uhlenbeck process with a random start value,
for a process conditional on the start value, or for a process conditional on start and end values.
The function includes the option of performing the calculation for lognormal marginal generated by 
exponential tranformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logpdfOU(t, y, mean = 0, sd = 1, gamma = 1, cond = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logpdfOU_+3A_t">t</code></td>
<td>
<p>vector of time points at which the OU process is available.</p>
</td></tr>
<tr><td><code id="logpdfOU_+3A_y">y</code></td>
<td>
<p>vector of y-values corresponing to the t-values
(note that t and y need to be of the same length).</p>
</td></tr>
<tr><td><code id="logpdfOU_+3A_mean">mean</code></td>
<td>
<p>asymptotic mean of the process.</p>
</td></tr>
<tr><td><code id="logpdfOU_+3A_sd">sd</code></td>
<td>
<p>asymptotic standard deviation of the process.</p>
</td></tr>
<tr><td><code id="logpdfOU_+3A_gamma">gamma</code></td>
<td>
<p>rate coefficient for return to the mean</p>
</td></tr>
<tr><td><code id="logpdfOU_+3A_cond">cond</code></td>
<td>
<p>conditioning: 0 indicates no conditioning, 1 conditioning to start value, and
2 conditioning to start and end value</p>
</td></tr>
<tr><td><code id="logpdfOU_+3A_log">log</code></td>
<td>
<p>if true, the log pdf of the log of y is calculated
(mean and sd are interpreted in y, not in log(y) units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns the log pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OU &lt;- randOU(mean=0,sd=1,gamma=1,t=0:1000/1000)
logpdfOU(OU$t,OU$y,mean=0,sd=1,gamma=1)
</code></pre>

<hr>
<h2 id='plot.timedeppar'>Plot results of time-dependent parameter estimation</h2><span id='topic+plot.timedeppar'></span>

<h3>Description</h3>

<p>This function plot Markov chains and marginal densities of constant parameters, distributions of
time dependent parameters, and Markov chains and marginal densities of time-dependent parameters at
selected points in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timedeppar'
plot(
  x,
  type = c("traces", "marginals", "summary", "pairs", "time-series", "accept"),
  chains.at = numeric(0),
  labels = NA,
  units = NA,
  prob.band = 0.9,
  max.diag.plots = 100,
  xlim.ts = numeric(0),
  n.burnin = 0,
  nrow = 4,
  nrow.constpar = NA,
  nrow.timedeppar = NA,
  nrow.diagnostics = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.timedeppar_+3A_x">x</code></td>
<td>
<p>results from the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code> of class <code>timedeppar</code> or
list of such results for comparing multiple chains (in the latter case you have to call
explicitly <code>plot.timedeppar</code> rather than being able to do the generic call <code>plot</code>
as the list of results is not an object of class <code>timedeppar</code>).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_type">type</code></td>
<td>
<p>vector of plot types:<br />
<code>"traces"</code> or <code>"marginals"</code>: traces and 1d marginals of Markov chains of 
constant parameters, of time-dependent parameters at certain time points
(see argument <code>chains.at</code>), chains of log posterior and
log observational likelihood values. 
For selected outputs only, specify
<code>traces.constpar</code>, <code>traces.timedeppar</code>, 
<code>traces.logposterior</code>.<br />
<code>"summary"</code>: print summary of acceptance rates and maximum log posterior and 
log likelihood values.<br />
<code>"pairs"</code>: scatterplot matrix of posterior sample of constant parameters.<br />
<code>"time-series"</code>: uncertainty range and median time series of
time-dependent parameters.<br />
<code>"accept"</code>: time series of apparent acceptance frequencies (at the level of thinning).<br />
<code>"realizations"</code>: realizations of time-dependent parameters to check for burnin..<br />
<code>"diagnostics"</code>: plot diagnostics for inference of time-dependent parameters
(note that the plot file could become very large 
to follow the inference steps).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_chains.at">chains.at</code></td>
<td>
<p>vector of time points at which chains and marginals of time-dependent parameters 
should be plotted if <code>"traces"</code> or <code>"marginals"</code> is contained in the vector argument
<code>type</code> (default: none [numeric(0)]).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_labels">labels</code></td>
<td>
<p>optional named vector of expressions to label variables in the plots (names of the expression
have to correspond to the variable names as used by the program, expressions can have special
symbols, e.g. <code>expression(a=alpha,b=beta,c1=gamma[1])</code>).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_units">units</code></td>
<td>
<p>optional named vector of expressions to add units to variables in the plots (names of the expression
have to correspond to the variable names as used by the program, expressions can have special
symbols, e.g. <code>expression(a=m^3/s,b=h^-1,c1=m)</code>).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_prob.band">prob.band</code></td>
<td>
<p>probability defining the width of the uncertainty bands plotted for output variables
(default value: 0.9)</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_max.diag.plots">max.diag.plots</code></td>
<td>
<p>maximum number of diagnostic plots of inference steps</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_xlim.ts">xlim.ts</code></td>
<td>
<p>optional range of time values for time-series plot</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_n.burnin">n.burnin</code></td>
<td>
<p>number of Markov chain points to omit for density and pairs plots
(number of omitted points is max(control$n.adapt,n.burnin)).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_nrow">nrow</code></td>
<td>
<p>number of plot rows per page (except for pairs plot).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_nrow.constpar">nrow.constpar</code></td>
<td>
<p>number of plot rows per page for traces and marginals (default is nrow).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_nrow.timedeppar">nrow.timedeppar</code></td>
<td>
<p>number of plot rows per page for time-dependent parameters (default is nrow).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_nrow.diagnostics">nrow.diagnostics</code></td>
<td>
<p>number of plot rows per page for diagnostics plots (default is nrow).</p>
</td></tr>
<tr><td><code id="plot.timedeppar_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting function.</p>
</td></tr>
</table>

<hr>
<h2 id='randOU'>Draw from an Ornstein-Uhlenbeck process</h2><span id='topic+randOU'></span>

<h3>Description</h3>

<p>This function draws a realization of an Ornstein-Uhlenbeck process 
with a random start value (drawn from the marginal distribution),
conditional of the start value, or conditional on both start and end values.
The function includes the option of obtaining a lognormal marginal by 
exponential tranformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randOU(
  mean = 0,
  sd = 1,
  gamma = 1,
  t = 0:1000/1000,
  yini = NA,
  yend = NA,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randOU_+3A_mean">mean</code></td>
<td>
<p>asymptotic mean of the process.</p>
</td></tr>
<tr><td><code id="randOU_+3A_sd">sd</code></td>
<td>
<p>asymptotic standard deviation of the process</p>
</td></tr>
<tr><td><code id="randOU_+3A_gamma">gamma</code></td>
<td>
<p>rate coefficient for return to the mean</p>
</td></tr>
<tr><td><code id="randOU_+3A_t">t</code></td>
<td>
<p>vector of time points at which the process should be sampled
(note: the value at t[1] will be the starting value yini,
the value at t[length(t)] the end value yend if these are specified)</p>
</td></tr>
<tr><td><code id="randOU_+3A_yini">yini</code></td>
<td>
<p>start value of the process 
(NA indicates random with asymptotic mean and sd)</p>
</td></tr>
<tr><td><code id="randOU_+3A_yend">yend</code></td>
<td>
<p>end value of the process 
(NA indicates no conditioning at the end)</p>
</td></tr>
<tr><td><code id="randOU_+3A_log">log</code></td>
<td>
<p>indicator whether the log of the variable should be an Ornstein-Uhlenbeck 
process (log=TRUE) rather than the variable itself
(mean and sd are interpreted in original units also for log=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with t and y columns for time and for the realization of the Ornstein-Uhlenbeck process
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000),type="l",ylim=2.5*c(-1,1))
abline(h=0)
lines(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000),col="red")
lines(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000),col="blue")
lines(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000),col="green")

plot(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000,yini=0,yend=0),type="l",ylim=2.5*c(-1,1))
abline(h=0)
lines(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000,yini=0,yend=0),col="red")
lines(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000,yini=0,yend=0),col="blue")
lines(randOU(mean=0,sd=1,gamma=1,t=0:1000/1000,yini=0,yend=0),col="green")
</code></pre>

<hr>
<h2 id='randsplit'>Draw indices for a random split of a vector into intervals of the same mean length</h2><span id='topic+randsplit'></span>

<h3>Description</h3>

<p>This function draws indices for a random split of a vector into sub-vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randsplit(
  n.grid,
  n.interval,
  method = c("modunif", "random", "weighted"),
  weights = numeric(0),
  offset = 0,
  min.internal = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randsplit_+3A_n.grid">n.grid</code></td>
<td>
<p>number of grid points to divide into intervals</p>
</td></tr>
<tr><td><code id="randsplit_+3A_n.interval">n.interval</code></td>
<td>
<p>number of intervals</p>
</td></tr>
<tr><td><code id="randsplit_+3A_method">method</code></td>
<td>
<p>method for random splitting:<br />
<code>modunif</code>  modification of uniform intervals<br />
<code>random</code>   random split (higher variability in inverval lengths)<br />
<code>weighted</code> random split with weights; 
non-normalized weights must be specified by the argument <code>weights</code><br /></p>
</td></tr>
<tr><td><code id="randsplit_+3A_weights">weights</code></td>
<td>
<p>weights for choosing interval boundaries for method <code>weighted</code>; 
vector of length i2-i1+1 (does not need to be normalized and will be
ignored for all methods except for method <code>weighted</code>)</p>
</td></tr>
<tr><td><code id="randsplit_+3A_offset">offset</code></td>
<td>
<p>offset to shift subset of potential interval boundaries to draw from.
To guarantee different intervals on subsequent calls, offset should be
increased by one between subsequent calls for the same variable.</p>
</td></tr>
<tr><td><code id="randsplit_+3A_min.internal">min.internal</code></td>
<td>
<p>minimum number of internal points between interval boundary points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function returns an index vector of length n+1 with the endpoint indices of
the random intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randsplit(100,10)
randsplit(100,10)
randsplit(100,10,method="random")
randsplit(100,10,method="weighted",weights=1:100)
for ( i in 1:10 ) print(randsplit(100,10,method="weighted",weights=1:100,offset=i))
</code></pre>

<hr>
<h2 id='readres.timedeppar'>Reads an object of type <code>timedeppar</code> saved to a file by <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code></h2><span id='topic+readres.timedeppar'></span>

<h3>Description</h3>

<p>This function read a workspace stored by the function <code><a href="#topic+infer.timedeppar">infer.timedeppar</a></code> and returns
the object of type <code>timedeppar</code> that contains the intermediate or final results of the 
inference process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readres.timedeppar(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readres.timedeppar_+3A_file">file</code></td>
<td>
<p>file name of the workspace to be read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of type <code>timedeppar</code> containing the intermediate or final results of the inference process 
or a list of length zero if the file was not found of no object called <code>res</code> of type <code>timedeppar</code>
was found in the workspace.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
