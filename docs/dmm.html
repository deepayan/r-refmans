<!DOCTYPE html><html><head><title>Help for package dmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dmm-package'>
<p>Dyadic mixed model analysis for pedigree data</p></a></li>
<li><a href='#chartodec'>
<p>Convert a vector from character to decimal numbers</p></a></li>
<li><a href='#condense.dmmarray'>
<p>Condense an object of type <code>dmmarray</code> to an object of type <code>dmm</code></p></a></li>
<li><a href='#condense.dmmblockarray'>
<p>Condense an object of type <code>dmmblockarray</code> to an object of type <code>dmm</code></p></a></li>
<li><a href='#csummary.dmm'>
<p>Make summary tables of (co)variance component estimates sorted into class-specific classes for a dmm object.</p></a></li>
<li><a href='#dmm'>
<p>Fit a dyadic mixed model to pedigree data</p></a></li>
<li><a href='#dmm-internal'>
<p>Functions internal to dmm</p></a></li>
<li><a href='#dt8bal.df'>
<p>A balanced dataset with eight individuals.</p></a></li>
<li><a href='#gprint'>
<p>Generic function for printing genetic parameters contained in an object of class <code>dmm</code>.</p></a></li>
<li><a href='#gprint.dmm'>
<p>Print method for genetic parameters contained in an object of class <code>dmm</code>.</p></a></li>
<li><a href='#gresponse.dmm'>
<p>Compute response to selection, given phenotypic selection differentials.</p></a></li>
<li><a href='#gsummary.dmm'>
<p>Make summary tables of genetic parameters for a dmm object</p></a></li>
<li><a href='#harv101.df'>
<p>Harvey dataset</p></a></li>
<li><a href='#make.countarray'>
<p>Count the number of observations in a dataframe or an <code>mdf</code> object for all traitpairs in the supplied list of traits.</p></a></li>
<li><a href='#make.ctable'>
<p>Generates a list of vectors containing sets of variance component names</p></a></li>
<li><a href='#make.dmmobj'>
<p>Construct an object of class <code>dmm</code> from user-supplied data</p></a></li>
<li><a href='#mdf'>
<p>Prepare a dataframe for use with dmm function</p></a></li>
<li><a href='#merino.df'>
<p>Australian Merino sheep research dataset</p></a></li>
<li><a href='#pedcheck'>
<p>Checks that the Id, SId, and DId columns of a dataframe are valid for function <code>dmm()</code>.</p></a></li>
<li><a href='#pedrenum'>
<p>Renumbers the Id, SId, and DId columns of a dataframe</p></a></li>
<li><a href='#plot.dmm'>
<p>Plot residuals from fitting dyadic model</p></a></li>
<li><a href='#print.csummary.dmm'>
<p>Print method for object of class <code>csummary.dmm</code>.</p></a></li>
<li><a href='#print.dmm'>
<p>Print method for a <code>dmm()</code> fitted model object.</p></a></li>
<li><a href='#print.gresponse.dmm'>
<p>Print method for object of class <code>gresponse.dmm</code>.</p></a></li>
<li><a href='#print.gsummary.dmm'>
<p>Print method for object of class <code>gsummary.dmm</code>.</p></a></li>
<li><a href='#print.summary.dmm'>
<p>Print method for an object of class <code>summary.dmm</code>.</p></a></li>
<li><a href='#quercus.df'>
<p>Quercus example dataset</p></a></li>
<li><a href='#sheep.df'>
<p>Demonstration sheep dataset</p></a></li>
<li><a href='#summary.dmm'>
<p>Make summary tables of (co)variance component estimates and fixed effect estimates for a dmm object.</p></a></li>
<li><a href='#summary.gresponse.dmm'>
<p>Summary method for object of class <code>gresponse.dmm</code>.</p></a></li>
<li><a href='#tstmo1.df'>
<p>Dfreml example dataset</p></a></li>
<li><a href='#unfactor'>
<p>Convert a vector from factor to numeric</p></a></li>
<li><a href='#warcolak.convert'>
<p>Convert <code>warcolak</code> data file to format required for a dataframe for <code>dmm()</code> or <code>mdf()</code>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dyadic Mixed Model for Pedigree Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Neville Jackson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Neville Jackson &lt;nanddjackson@bigpond.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Dyadic mixed model analysis with multi-trait responses and
  pedigree-based partitioning of individual variation into a range of
  environmental and genetic variance components for individual and 
  maternal effects. Method documented in dmmOverview.pdf; dmm is an 
  implementation of dispersion mean model described by
  Searle et al. (1992) "Variance Components", Wiley, NY.</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, Matrix, robustbase, pls, nadiv</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL-2 | GPL (&ge; 2) | GPL-3]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-02 11:10:20 UTC; nevj</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-03 06:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='dmm-package'>
Dyadic mixed model analysis for pedigree data
</h2><span id='topic+dmm-package'></span>

<h3>Description</h3>

<p>Dyadic mixed model analysis with multi-trait responses and pedigree-based partitioning of an individual random effect into a range of genetic and environmental (co)variance components for individual (ie direct) and maternal contributions to phenotype.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dmm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-07-13</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package provides tools for setting up and solving dyadic model equations 
leading to estimates of variance components and their standard errors, for 
transforming variance components to genetic parameters and their standard errors, 
and for computing genetic response to selection.
</p>
<p>You may wish to use this package if you are looking for any of the following features
in a quantitative genetic analysis:
</p>

<ul>
<li><p> suited to small multi-trait datasets with pedigree information
</p>
</li>
<li><p> individual, maternal, and cohort environmental component estimates and standard errors
</p>
</li>
<li><p> individual and maternal additive, dominance, epistatic, and sex-linked genetic component estimates and standard errors
</p>
</li>
<li><p> cross-effect and cross-trait covariance components
</p>
</li>
<li><p> multicollinearities among the components
</p>
</li>
<li><p> genetic parameters (ie proportion of variance and correlation) and standard errors for all fitted components
</p>
</li>
<li><p> genetic response to phenotypic selection for individual additive and maternal additive cases with autosomal and sexlinked components
</p>
</li>
<li><p> data preparation tools
</p>
</li>
<li><p> S3 methods to organize output
</p>
</li>
<li><p> test example datasets
</p>
</li>
<li><p> alternative approach to iterative ML and REML estimation procedures
</p>
</li>
<li><p> component estimates equivalent to MINQUE (after fixed effects by OLS) and bias-corrected-ML (after fixed effects by GLS)
</p>
</li>
<li><p> multi-trait or traitspairwise or traitsblockwise analyses
</p>
</li>
<li><p> class-specific genetic parameters
</p>
</li>
<li><p> maternal or paternal founderline components
</p>
</li></ul>

<p>The main functions in dmm are:
</p>

<dl>
<dt>dmm()</dt><dd><p> Sets up and solves dyadic model equations for a dataset which is supplied as a dataframe containing both the pedigree information and the observations</p>
</dd>
<dt>mdf()</dt><dd><p>Checks the dataframe for compliance with dmm requirements, converts multi-trait data to a matrix within the dataframe, and optionally appends relationship matrices to the dataframe.</p>
</dd>
<dt>summary()</dt><dd><p>S3 method, reports estimated (co)variance components and standard errors</p>
</dd>
<dt>csummary()</dt><dd><p>S3 method, reports reports (co)varianve components with standard erors, sorted into class-specific groups, so that thaey sum to phenotypic (co)variance within each group</p>
</dd>
<dt>gsummary()</dt><dd><p>S3 method, reports genetic parameters and standard errors</p>
</dd>
<dt>gresponse()</dt><dd><p>S3 method, reports genetic response to selection</p>
</dd>
<dt>print()</dt><dd><p>S3 method, briefly reports output object from dmm()</p>
</dd>
<dt>plot()</dt><dd><p>S3 method, plots residuals for dyadic model fit</p>
</dd>
</dl>

<p>There are also some example datasets, some with  'known' answers:
</p>

<dl>
<dt>dt8bal.df</dt><dd><p> A small balanced dataset showing agreement with aov in balanced case</p>
</dd>
<dt>harv103.df</dt><dd><p> A real dataset from Harvey(1960) with extensive fixed effects</p>
</dd>
<dt>merino.df</dt><dd><p> A large real multi-trait dataset from a Merino sheep breeding experiment</p>
</dd>
<dt>quercus.df</dt><dd><p> A 2-trait dataset supplied with the QUERCUS program</p>
</dd>
<dt>sheep.df</dt><dd><p> A small 3-trait dataset used for demonstration</p>
</dd>
<dt>tstmo1.df</dt><dd><p> A univariate dataset supplied with the DFREML program</p>
</dd>
<dt>warcolak</dt><dd><p> We also use the warcolak dataset from package <code>nadiv</code> </p>
</dd>
</dl>

<p>To use dmm one first must put the desired dataset into an R workspace as a dataframe object. The minimum requirement is for a dataframe with columns labelled :
</p>

<dl>
<dt>Id</dt><dd><p> Identifier for each individual</p>
</dd>
<dt>SId</dt><dd><p> Identifier for the sire of each individual</p>
</dd>
<dt>DId</dt><dd><p> Identifier for the dam of each individual</p>
</dd>
<dt>Sex</dt><dd><p> Sex code for each individual</p>
</dd>
<dt>Fixed factors</dt><dd><p> Codes for levels of each fixed factor</p>
</dd>
<dt>Observations</dt><dd><p> Numeric values for each observation or trait</p>
</dd>
</dl>

<p>There are other requirements, and these are documented under the <code>mdf()</code> help page, which also documents how to use <code>mdf()</code> to convert the user's dataframe to an acceptable form, which can be either another dataframe or an object of class <code>mdf</code>.
</p>
<p>Given an acceptable data object, one simply calls function <code>dmm()</code> with appropriate arguments, the first of which is the data object's name. There are <code>formula</code> arguments to specify fixed effects and cohorts, and the components to be partitioned are specified in a simple vector of names. Arguments are documented under the <code>dmm()</code> help page. An object of class <code>dmm</code> is returned and should be saved in the R workspace.
</p>
<p>Given a <code>dmm</code> object, there are S3 methods to display the results as follows:
</p>

<dl>
<dt>print()</dt><dd><p> Reports fixed effect coefficient and (co)variance component estimates</p>
</dd>
<dt>summary()</dt><dd><p> Reports fixed effect coefficient and (co)variance component estimates with standard errors and confidence limits</p>
</dd>
<dt>gprint()</dt><dd><p> Reports genetic parameters (proportion of variance and correlation) for each component partitioned</p>
</dd>
<dt>gsummary()</dt><dd><p> Reports genetic parameters with standard errors and confidence limits</p>
</dd>
<dt>gresponse()</dt><dd><p> reports genetic response to selection, for estimated parameters</p>
</dd>
</dl>

<p>These functions are documented on their help pages.
Other results (eg plots) may be obtained by accessing the <code>dmm</code> object's attributes directly. See <code>dmm.object</code> help page.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>
<p>Maintainer: Neville Jackson &lt;nanddjackson@bigpond.com&gt;
</p>


<h3>References</h3>

<p>dmmOverview.pdf
</p>


<h3>See Also</h3>

<p>In the <code>dmm</code> package
</p>

<dl>
<dt>dmm()</dt><dd><p> for dmm function arguments and return value</p>
</dd>
<dt>summary()</dt><dd><p> for fixed coefficients and (co)variance components</p>
</dd>
<dt>gsummary()</dt><dd><p> for genetic parameters</p>
</dd>
<dt>gresponse()</dt><dd><p> for predicted selection response</p>
</dd>
<dt>make.ctable()</dt><dd><p> for comprehensive list of variance components</p>
</dd>
<dt>mdf()</dt><dd><p> for data preparation</p>
</dd>
<dt>print()</dt><dd><p> for brief print of dmm() output</p>
</dd>
<dt>plot()</dt><dd><p> for residual plots for dyadic model</p>
</dd>
</dl>

<p>Other R packages
</p>

<ul>
<li><p> pedigreemm 
</p>
</li>
<li><p> nadiv 
</p>
</li>
<li><p> varComp 
</p>
</li>
<li><p> minque 
</p>
</li>
<li><p> gremlin
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
# simple univariate case, direct from the dataframe
data(dt8bal.df)
dt8.fit &lt;- dmm(dt8bal.df, CWW ~ 1 + Sex,
   components=c("VarE(I)","VarG(Ia)"))  
summary(dt8.fit)  # fixed effects and variance components
gsummary(dt8.fit) # heritability with se's
rm(dt8.fit)
rm(dt8bal.df)

# Note: 'dt8bal.df' is a small demo dataset. Results are 
#        illustrative but not meaningful.
# for more examples see 'dmm' help page and references
# for a tutorial and fully documented examples see  'dmmOverview.pdf'
</code></pre>

<hr>
<h2 id='chartodec'>
Convert a vector from character to decimal numbers
</h2><span id='topic+chartodec'></span>

<h3>Description</h3>

<p>A vector of numbers encoded as character strings without a decimal point is converted to numbers with a decimal point in a given position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chartodec(cvec, ndec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chartodec_+3A_cvec">cvec</code></td>
<td>

<p>A vector of type character. 
</p>
</td></tr>
<tr><td><code id="chartodec_+3A_ndec">ndec</code></td>
<td>

<p>An integer giving the number of digits to follow the implied decimal point
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a common problem when reading a table of fixed width formatted data into a dataframe using function <code>read.fwf()</code> for the dataframe columns to end up of type character with no decimal point. If these columns are actually meant to be decimal numbers with an implied decimal point in a fixed position, they can be converted to numeric with this function.
</p>


<h3>Value</h3>

<p>A vector of numerical values with a decimal point inserted as per argument <code>ndec</code>
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>read.fwf()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
tmp &lt;- c("1","2","3",NA)
ntmp &lt;- chartodec(tmp,1)
str(ntmp)
rm(tmp)
rm(ntmp)
</code></pre>

<hr>
<h2 id='condense.dmmarray'>
Condense an object of type <code>dmmarray</code> to an object of type <code>dmm</code>
</h2><span id='topic+condense.dmmarray'></span>

<h3>Description</h3>

<p>An object of type <code>dmmarray</code> is an array of objects of type <code>dmm</code>, with each array element representing the reult of a <code>dmm()</code> analysis for one pair of traits. The function <code>condense.dmmarray</code> will recombine these results into a single object of class <code>dmm</code> with the variance component and genetic parameter estimates matrices being for all traits, and other elements of the <code>dmm</code> object being appropriately pooled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense.dmmarray(da)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense.dmmarray_+3A_da">da</code></td>
<td>

<p>An object of class <code>dmmarray</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In bringing together the results of several <code>traitspairwise</code> analyses into a single matrix of (for example) individual additive genetic variance/covariance components, one is putting together into one matrix elements estimated with different precisions due to differnt replication for each pair of traits. The resulting matrix may not be positive definite even if all the contributing traitspairwise 2 x 2 matrices are forced positive definite. 
</p>
<p>If the argument <code>da</code> contains results from a <code>dmm</code> run with <code>gls=T</code> then the GLS results for each traitpair will also be condensed. In this case the GLS results must be present for every traitpair. It can be quite difficult to get <code>gls=T</code> runs to converge successfully for every trait pair.
</p>


<h3>Value</h3>

<p>An object of class <code>dmm</code>, containing the recombined results for all traits.
</p>


<h3>Note</h3>

<p>An object of class <code>dmmarray</code> can be manipulated as is without using the <code>condense.dmmarray()</code> function. For example one element of the array can be printed with
</p>
<p>print(objectname[[i,j]])
</p>
<p>where <code>i</code> and <code>j</code> are subscripts indicating the row and column position of the element to be printed. The <code>summary()</code>  and <code>gsummary()</code> functions are also available for use in this manner.  It is necessary that the <code>library(dmm)</code> statement be made, otherwise one will get the standard <code>print()</code> and <code>summary()</code> functions instead of those appropriate for an object of class <code>dmm</code>. The double square brackets are necessary because each element of the array is a list object, and you want its contents, not its name attribute.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>dmm()</code>, <code>condense.dmmblockarray()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
# prepare the dataset sheep.df
data(sheep.df)
# add a matrix 'Ymat' to the dataframe,
#    which is required for traitspairwise
# keep=TRUE is required
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),keep=TRUE)
# make sheep.fit as a class dmmarray object
sheep.fit &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"),traitspairwise=TRUE)
#  look at one element of the dmmarray
summary(sheep.fit[["Cww","Diam"]])
# condense the dmmarray to a class dmm object
sheep.condense &lt;- condense.dmmarray(sheep.fit)
# compute a response to selection
sheep.resp &lt;- gresponse(sheep.condense,
       psd=list(dp=c(1,1,1)),effects=c("G(Ia)"))
# look at response object
summary(sheep.resp)
#cleanup
rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fit)
rm(sheep.condense)
rm(sheep.resp)

</code></pre>

<hr>
<h2 id='condense.dmmblockarray'>
Condense an object of type <code>dmmblockarray</code> to an object of type <code>dmm</code>
</h2><span id='topic+condense.dmmblockarray'></span>

<h3>Description</h3>

<p>An object of class <code>dmmblockarray</code> is a list containing two items called <code>array</code> and <code>blocks</code>. Item <code>array</code> is an array of objects of type <code>dmm</code>, with each array element representing the reult of a <code>dmm()</code> analysis for one pair of blocks of traits. The function <code>condense.dmmarray</code> will recombine these results into a single object of class <code>dmm</code> with the variance component and genetic parameter estimates matrices being for all traits, and other elements of the <code>dmm</code> object being appropriately pooled. Item <code>blocks</code> is a list, each element of which is a list of the traits present in each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense.dmmblockarray(da)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense.dmmblockarray_+3A_da">da</code></td>
<td>

<p>An object of class <code>dmmblockarray</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In bringing together the results of several <code>traitsblockwise</code> analyses into a single matrix of (for example) individual additive genetic variance/covariance components, one is putting together into one matrix elements estimated with different precisions due to differnt replication for each block of traits. The resulting matrix may not be positive definite even if all the contributing <code>traitsblockwise</code> ni x nj matrices are forced positive definite. 
</p>
<p>If the argument <code>da</code> contains results from a <code>dmm</code> run with <code>gls=T</code> then the GLS results for each traitblockpair will also be condensed. In this case the GLS results must be present for every traitblockpair. It can be quite difficult to get <code>gls=T</code> runs to converge successfully for every pair of blocks.
</p>


<h3>Value</h3>

<p>An object of class <code>dmm</code>, containing the recombined results for all traits.
</p>


<h3>Note</h3>

<p>An object of class <code>dmmblockarray</code> can be manipulated as is without using the  
</p>
<p><code>condense.dmmblockarray</code> function. For example one element of the array can be printed with 
print(objectname$array[[i,j]])
</p>
<p>where <code>i</code> and <code>j</code> are subscripts indicating the row and column position of the element to be printed. The <code>summary()</code>  and <code>gsummary()</code> functions are also available.  It is necessary that the 
</p>
<p><code>library(dmm)</code> statement be made, otherwise one will get the standard <code>print()</code> and <code>summary()</code> functions instead of those appropriate for an object of class <code>dmm</code>. The double square brackets are necessary because each element of the array is a list object, and you want its contents, not its name attribute.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>dmm()</code>, <code>condense.dmmarray()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
# prepare the dataset sheep.df
data(sheep.df)
# add a matrix 'Ymat' to the dataframe,
#         which is required for traitsblockwise
# keep=TRUE also required
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),keep=TRUE)
# make sheep.fit as a class dmmarray object
sheep.fit &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"),traitsblockwise=TRUE,
    Block1=c("Cww","Diam"),Block2="Bwt")
#  look at one element of the dmmblockarray
summary(sheep.fit$array[["Block1","Block2"]])
# condense the dmmblockarray to a class dmm object
sheep.condense &lt;- condense.dmmblockarray(sheep.fit)
# compute a response to selection
sheep.resp &lt;- gresponse(sheep.condense,
       psd=list(dp=c(1,1,1)),effects=c("G(Ia)"))
# look at response object
summary(sheep.resp)
#cleanup
rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fit)
rm(sheep.condense)
rm(sheep.resp)

</code></pre>

<hr>
<h2 id='csummary.dmm'>
Make summary tables of (co)variance component estimates sorted into class-specific classes for a dmm object.
</h2><span id='topic+csummary.dmm'></span><span id='topic+csummary'></span>

<h3>Description</h3>

<p>Extracts the (co)variance component estimates from an object of class <code>dmm</code>, for the specified set of traits and set of components. Makes tables of component estimates ordered either by trait or by component. Tables include component estimate, its standard error, and its 95 percent confidence limits. Components are grouped into class-specific classes, if there are any class-specific components fitted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
csummary(object, traitset = "all", componentset = "all", bytrait = T,
            gls = F, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csummary.dmm_+3A_object">object</code></td>
<td>

<p>An object of class <code>dmm</code>. (Co)variance component estimates are obtained from this object.
</p>
</td></tr>
<tr><td><code id="csummary.dmm_+3A_traitset">traitset</code></td>
<td>

<p>A vector containing the names of the subset of traits for which tables of (co)variance component estimates are to be constructed. Default is &quot;all&quot; which means all traits present in object <code>object</code>.
</p>
</td></tr>
<tr><td><code id="csummary.dmm_+3A_componentset">componentset</code></td>
<td>

<p>A vector containing the names of the subset of (co)variance components for which tables are to be constructed. Default is &quot;all&quot; which means all (co)variance components present in object <code>object</code>.
</p>
</td></tr>
<tr><td><code id="csummary.dmm_+3A_bytrait">bytrait</code></td>
<td>

<p>Logical flag: should the tables of (co)variance component estimates be constructed with trait varying least rapidly from line to line? If TRUE each subtable contains component estimates for one trait or traitpair and for all components in argument <code>componentset</code>. If FALSE each subtable contains component estimates for one component and for all traits or traitpairs.
</p>
</td></tr>
<tr><td><code id="csummary.dmm_+3A_gls">gls</code></td>
<td>

<p>Logical flag: should the (co)variance component estimates by GLS-b method be tabled in addition to the (co)variance component estimates by OLS-b method? Default is <code>gls=FALSE</code>. The GLS-b (co)variance component estimates can only be tabled if object <code>object</code> contains the attribute <code>gls</code>, that is if <code>object</code> was constructed by a <code>dmm()</code> call with argument <code>gls=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="csummary.dmm_+3A_digits">digits</code></td>
<td>

<p>Number of digits for output. This is returned as part of the return value for us
e by the S3 print function <code>print.csummary.dmm()</code>.
</p>
</td></tr>
<tr><td><code id="csummary.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a long printout with  estimates, standard errors and confidence limits, arranged in tables with one estimate per line. For a short printout see function <code>print.dmm()</code>.
In the case of class-specific components, the components are listed in class groups, so that they sum to the class phenotypic variance within each group. 
In the case where all components are non-specific, there is just one class group.
</p>


<h3>Value</h3>

<p>An object of class <code>csummary.dmm</code> which is a list containing the following 
items:
</p>
<table>
<tr><td><code>ctables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the (co)variance components, along with the appropriate standard errors and confidence limits. Based on OLS-b component estimates.</p>
</td></tr>
<tr><td><code>gctables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the (co)variance components, along with the appropriate standard errors and confidence limits. Based on GLS-b component estimates. Only present if argument <code>gls=TRUE</code>.</p>
</td></tr>
<tr><td><code>traits</code></td>
<td>
<p>A vector of traitnames as specified in argument <code>traitset</code>.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>A vector of component names as specified in argument <code>componentset</code>.</p>
</td></tr>
<tr><td><code>bytrait</code></td>
<td>
<p>Logical flag: as specified in argument <code>bytrait</code>.</p>
</td></tr>
<tr><td><code>gls</code></td>
<td>
<p>Logical flag: as specified in argument <code>gls</code>.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>A numeric value, as specified in argument <code>digits</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no provision to constrain the 95 percent confidence limits for component estimates. Hence for small samples, these may vary outside the bounds for the component, that is for components which are variances, they may be negative. Fixed effects are not bounded.
Use <code>csummary()</code> if you want to see the components summing to phenotypic (co)variance, and sorted into class-specific groups. Use <code>summary()</code> if you just want all the components as estimated.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>print.csummary.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get some data
data(sheep.df)
# prepare it - only need "E" and "A" relationship matrices
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# estimate (co)variance components  - VarG(Ia) is Sex-specific
sheep.fitc &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
              components=c("VarE(I)"),
              specific.components=list(Sex=c("VarG(Ia)")))
# look  at components within Sex classes 
csummary(sheep.fitc,bytrait=FALSE)
# look just at trait "Cww"
summary(sheep.fitc,traitset="Cww")
# cleanup
rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fitc)

</code></pre>

<hr>
<h2 id='dmm'>
Fit a dyadic mixed model to pedigree data
</h2><span id='topic+dmm'></span><span id='topic+dmm.default'></span>

<h3>Description</h3>

<p>Dyadic mixed model analysis with multi-trait responses and
pedigree-based partitioning of individual variation into a range of
environmental and genetic variance components for individual and maternal 
effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmm(mdf, fixform = Ymat ~ 1, components = c("VarE(I)", "VarG(Ia)"),
    specific.components=NULL, cohortform = NULL, posdef = T, gls = F,
    glsopt = list(maxiter = 200, bdamp = 0.8, stoptol = 0.01),
    dmeopt = "qr", ncomp.pcr = "rank", relmat = "inline", dmekeep = F,
    dmekeepfit = F, traitspairwise=F, traitsblockwise=F,...)

## Default S3 method:
dmm(mdf, fixform = Ymat ~ 1, 
    components = c("VarE(I)", "VarG(Ia)"),
    specific.components=NULL, cohortform = NULL, posdef = T, gls = F,
    glsopt = list(maxiter = 200, bdamp = 0.8, stoptol = 0.01),
    dmeopt = "qr", ncomp.pcr = "rank", relmat = "inline", dmekeep = F,
    dmekeepfit = F, traitspairwise=F, traitsblockwise=F,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmm_+3A_mdf">mdf</code></td>
<td>

<p>Either a dataframe or an object of class <code>mdf</code> which is a list containing a dataframe and one or more relationship matrices, as made by function <code>mdf()</code> If missing the variables are searched for in the standard way.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_fixform">fixform</code></td>
<td>

<p>A formula specifying the fixed-effect part of the model and the response variate(s). Response should be a matrix for multi-trait models. Default is <code>Ymat ~ 1</code> that is a response matrix called <code>Ymat</code> and a fitted mean effect.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_components">components</code></td>
<td>

<p>A simple vector specifying each of the components to be partitioned from the residual variation after fitting fixed effects. Residual is assumed to be the level of variation attributed to individuals. The components given here are assumed to sum to phenotypic variance so that if there are cross-effect covariances (eg &quot;CovG(Ia,Ma)&quot; and &quot;CovG(Ma,Ia)&quot;) they need to be both present. The default is <code>c("VarE(I)", "VarG(Ia)")</code>, that is a simple partitioning into individual environmental (&quot;VarE(I)&quot;) and individual additive genetic (&quot;VarG(Ia)&quot;) variation. It is  necessary to  specify the individual environmental variance, as it is actually fitted as a parameter in the dyadic model, not obtained from residual variation. For a full list of available components see <code>make.ctable()</code> function. 
For a brief introduction to the notation for components see Note section below. For a comprehensive definition of notation see 'dmmOverview.pdf' Section 6.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_specific.components">specific.components</code></td>
<td>

<p>A list specifying the name of each specific factor and the variance components which are to be specific to that factor. The list takes the form 
</p>
<p><code>list(Factor1=c(component1,component2,...),</code> 
</p>
<p><code>     Factor2=c(component3,component4,...),...)</code>. 
</p>
<p>The default is <code>NULL</code>, that is no class specific components are partitioned . Each specific factor must exist as a column in the dataframe. The specific factors do not have to be fitted as fixed effects, but can be. The classes ( ie levels) within each factor must be mutually exclusive, that is, each individual can only belong to one level of each factor. For a full coverage of class specific components see the document <em>dmmClassSpecific.pdf</em>.
</p>
<p>If one wishes all of the specified components to be class specific, one needs to specify <code>components=NULL</code> in order to cancel out the default for the <code>components=</code> argument.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_cohortform">cohortform</code></td>
<td>

<p>A formula specifying the effects which define cohort grouping of individuals.  For example <code>cohortform = ~ Year</code>. A cohort is a grouping of individuals experiencing the same external environmental conditions, eg a group of sheep born and reared together, commonly referred to as a drop. Cohort should not contain DId - the dam's Id. If one needs to consider littermates, function <code>dmm()</code> provides a means of combining maternal environmental and cohort variance components to achieve this. The default is NULL - ie no cohort defined.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_posdef">posdef</code></td>
<td>

<p>A logical flag: should the matrices of variance components be constrained to be positive definite? If TRUE each matrix of cross-trait (co)variances for each &quot;Varxxx&quot; component defined in <code>components</code> will be individually positive definite, and each cross-effect covariance (if &quot;Covxxx&quot; components are defined) will be constrained such that the corresponding correlation is in the bounds -1 to 1. If FALSE all components will be as estimated. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_gls">gls</code></td>
<td>

<p>A logical flag: should <code>dmm()</code> go on after fitting fixed effects by OLS and estimating components, to re-fit the fixed effects by GLS and re-estimate the components. If TRUE the option <code>posdef=T</code> is enforced, as the GLS iteration will fail if matrixes do not remain positive definite. Default is FALSE - ie do the OLS analysis only.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_glsopt">glsopt</code></td>
<td>

<p>A list object containing variables used to control the GLS iteration :
</p>

<dl>
<dt>maxiter</dt><dd><p>Maximum number of iterations. Default 200.</p>
</dd>
<dt>bdamp</dt><dd><p>Factor used to damp the setting of new GLS-b coefficients at each round of iteration. A value of 1.0 means no damping.</p>
</dd>
<dt>stoptol</dt><dd><p>Value below which the sum of absolute deviations of new from old coefficients must fall to achieve convergence.</p>
</dd>
</dl>

<p>The GLS iteration normally converges very rapidly. If it does not, consider changing the model, before fiddling with these parameters. 
</p>
</td></tr>
<tr><td><code id="dmm_+3A_dmeopt">dmeopt</code></td>
<td>

<p>One of four regression techniques used to solve the dyadic model equations (DME's) to estimate components:
</p>

<dl>
<dt>&quot;qr&quot;</dt><dd><p> The default option is to use the QR algorithm directly on the dyadic model equations. This is most efficient, but does not produce a <em>fit</em> object for looking at further statistics such as with <code>anova</code> or <code>plot</code> or <code>resid</code>.</p>
</dd>
<dt>&quot;lm&quot;</dt><dd><p> This option calls the <code>lm()</code> function to solve the DME's. This is equivalent to QR, but <code>lm()</code> produces a <em>fit</em> object which can optionally be part of the returned <code>dmm</code> object.</p>
</dd>
<dt>&quot;lmrob&quot;</dt><dd><p> This option calls the <code>lmrob()</code> function from package <code>robustbase</code> to solve the DME's. Robust regression only works for single-trait models. A <em>fit</em> object can be returned.</p>
</dd>
<dt>&quot;pcr&quot;</dt><dd><p> This option calls the <code>mvr()</code> function from package <code>pls</code> with argument <code>method="svdpc"</code>. Principal component regression is intended to be used where there are multicollinearities among the components to be estimated. The number of principal components is set to the rank of the DME matrix, but can be overwritten (see <code>ncomp.pcr</code> argument). A <em>fit</em> object can be returned.</p>
</dd>
</dl>

<p>If gls=TRUE the same <code>dmeopt</code> option is also used during the GLS iteration.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_ncomp.pcr">ncomp.pcr</code></td>
<td>

<p>Number of principal components to use during a principal components regression (see <code>dmeopt</code> argument). Default is the rank of the DME matrix
</p>
</td></tr>
<tr><td><code id="dmm_+3A_relmat">relmat</code></td>
<td>

<p>One of two ways of setting up the relationship matrices required to estimate the variance components:
</p>

<dl>
<dt>&quot;inline&quot;</dt><dd><p> The additive genetic relationship matrix will be calculated by inline code each time <code>dmm()</code> is run. OK for small datasets. Do not use if non-additive relationship matrices are required. This is the default.</p>
</dd>
<dt>&quot;withdf&quot;</dt><dd><p> The required relationship matrices are assumed to be pre-stored in the object of class <code>mdf</code> defined in the first argument. See function <code>mdf()</code> for setting up relationship matrices in the <code>mdf</code> object. Function <code>mdf()</code> makes extensive use of the package <code>nadiv</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="dmm_+3A_dmekeep">dmekeep</code></td>
<td>

<p>Logical flag: should the dyadic model equations be returned as part of the <code>dmm()</code> return object? Default is FALSE. The DME's may be a large object.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_dmekeepfit">dmekeepfit</code></td>
<td>

<p>Logical flag: should the <em>fit</em> object from solving the DME's be returned as part of the <code>dmm()</code> return object. Default is FALSE. The <em>fit</em> object may be large.
</p>
</td></tr>
<tr><td><code id="dmm_+3A_traitspairwise">traitspairwise</code></td>
<td>

<p>Logical flag: should the traits be analysed two at a time in all permutations? Default is FALSE, in which case traits are all analysed simultaneously. This option is useful if traits have different replication. If this option is TRUE <code>dmm()</code> will return an object of class <code>dmmarray</code>, being an array of class <code>dmm</code> objects with the rows and columns named by the trait names. See the  Value section for the structure of an object of class <code>dmmarray</code>. For this option the dataframe specified as argument <code>mdf</code> must be made with function <code>mdf()</code> and must contain the matrix of traits 'Ymat' plus the individual traits as columns (<code>keep=T</code> option for <code>mdf()</code>).
</p>
</td></tr>
<tr><td><code id="dmm_+3A_traitsblockwise">traitsblockwise</code></td>
<td>

<p>Logical flag: should the traits be analysed in defined blocks of traits in all permutations of pairs of blocks? Default is FALSE. This option is useful if blocks of traits have different replication. If this option is TRUE, the ellipsis option defining blocks must be present. For this option the dataframe specified as argument <code>mdf</code> must be made with function <code>mdf()</code> and must contain the matrix of traits 'Ymat' plus the individual traits as columns (<code>keep=T</code> option for <code>mdf()</code>).
</p>
</td></tr>
<tr><td><code id="dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument: if <code>traitsblockwise</code> is TRUE this argument should contain a number of block definitions of the form 
</p>
<p><code>Block1=c("Trait1","Trait2"),Block2=c("Trait3","Trait4"),...</code>
</p>
<p>, specifying the traits to be present in each block. In this case <code>dmm()</code> will return an object of class <code>dmmblockarray</code>, being an array of class <code>dmm</code> objects with the rows and columns named <code>"Block1" and "Block2"</code>, together with lists of the trait names present in each block. See the Value section for the structure of an object of class <code>dmmblockarray</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum requirement to use <code>dmm()</code> directly on a simple dataframe is that it contain columns named &quot;Id&quot;, &quot;SId&quot;, &quot;DId&quot;, and &quot;Sex&quot; plus any fixed effects and traits. The &quot;Id&quot; column must contain identifiers which are unique, numeric, and sequential ( ie they must be numbered 1 to n with unit increments, no duplicates and no gaps). Any fixed effects must be factors, and traits must be numeric. Every &quot;SId&quot; and &quot;DId&quot; code must appear also in the &quot;Id&quot; column even if this results in NA's in every other column. If these requirements are not met, process the dataframe with <code>mdf()</code> before using <code>dmm()</code> Also if any relationship matrix other than additive is required, pre-processing with <code>mdf()</code> is necessary.
</p>
<p>Missing values for either traits or fixed effects are simply omitted by <code>dmm()</code> before any processing. There is an heirarchy of models fitted by <code>dmm()</code>. There is one fixed model and one dyadic model, for all traits, and only individuals for which all traits are present are included in the model fit steps. In contrast, all individuals are included in the pedigree and in setting up relationship matrices. Hence the number of individuals with data, may be less than the number of individuals in the pedigree. If options <code>traitspairwise</code> or <code>traitsblockwise</code> are used both the fixed model and the dyadic model will be the same for all traitpairs (or traitblocks) but the replication may differ, so missing values for some traits  or sets of traits can be handled in this way.
</p>
<p>The (co)variance which is partitioned into components is always the residual (co)variance from the fixed effects model. This is assumed to represent the observed variation among individuals. There is, at this stage, no provision for models with more than one error level, so split plot and repeated measures designs are not provided for. There is nothing to stop one formulating the appropriate fixed effects model and doing the <code>aov()</code> step, but partitioning of any (co)variance other than residual is not at present provided.
</p>
<p>The naming conventions for components may seem a little strange. They are designed to be all ASCII and therefore usable by R as rownames or colnames. The function <code>make.ctable()</code> returns a list of all available components ( as returnobject$all), as well as a spectrum of sublists which are used internally. The available components are fully documented in the pdf file <em>dmmOverview.pdf</em> Section 6. Most of the names are obvious (eg &quot;VarG(Ia)&quot; means variance-genetic-individual-additive). The term <em>individual</em> distinguishes individual or direct genetic or environmental effects from maternal genetic or environmental effects.
</p>
<p>It is important for the proper estimation of phenotypic (co)variance that any cross-effect covariance components are fitted in symmetric pairs ( for example &quot;CovE(I,M)&quot; and &quot;CovE(M,I)&quot;). For one trait these will be identical, so the covariance will simply enter twice in the sum, as required. However cross-trait-cross-effect covariances will not be identical and the sum, which is a phenotypic covariance, requires that the symmetric pair be present.
</p>
<p>In addition to the value returned, <code>dmm()</code> makes a number of lines of screen output which show each processing step and some minimal model check numbers.
</p>


<h3>Value</h3>

<p>An object of class <code>dmm</code> is returned whenever options <code>traitspairwise</code> and <code>traitsblockwise</code> are both FALSE (ie a normal multi-trait analysis). This object is basically a list of some or all of the following items:
</p>
<table>
<tr><td><code>aov</code></td>
<td>

<p>An object of class <code>aov</code> containing the results of fitting the fixed effects (specified in  argument <code>fixform</code>) by OLS using a call to the <code>aov()</code> function
</p>
</td></tr>
<tr><td><code>mdf</code></td>
<td>

<p>Not currently used - ignore.
</p>
</td></tr>
<tr><td><code>fixform</code></td>
<td>

<p>Formula specifying fixed effects fitted.
</p>
</td></tr>
<tr><td><code>b</code></td>
<td>

<p>Coefficients fitted for fixed effects.
</p>
</td></tr>
<tr><td><code>seb</code></td>
<td>

<p>Standard errors for fixed effect coefficients.
</p>
</td></tr>
<tr><td><code>vara</code></td>
<td>

<p>Matrix of (co)variances of individuals after adjusting for fixed effects fitted by OLS.
</p>
</td></tr>
<tr><td><code>totn</code></td>
<td>

<p>Total number of individuals in the analysis (ie with data)
</p>
</td></tr>
<tr><td><code>degf</code></td>
<td>

<p>Degrees of freedom remaining after fitting fixed effects.
</p>
</td></tr>
<tr><td><code>dme.wmat</code></td>
<td>

<p>The dyadic model equations matrix. Present only if dmekeep=TRUE. The name 'wmat' refers to the matrix <code class="reqn">W</code> in equations 12 and 13 of the document dmmOverview.pdf.
</p>
</td></tr>
<tr><td><code>dme.psi</code></td>
<td>

<p>The dyadic model equations right hand sides (or traits) matrix. Present only if dmekeep=TRUE. The name 'psi' refers to the matrix <code class="reqn">\Psi</code> in equations 12 and 13 of the document dmmOverview.pdf.
</p>
</td></tr>
<tr><td><code>dme.fit</code></td>
<td>

<p>The <em>fit</em> object from solving dyadic model equations. Its form depends on the <code>dmeopt</code> argument. For dmeopt=&quot;qr&quot; (the default) it just contains the QR transform of the DME's. For dmeopt=&quot;lm&quot; it contains the object returned by function <code>lm()</code> For dmeopt=&quot;lmrob&quot; it contains the object returned by function <code>lmrob()</code> For dmeopt=&quot;pcr&quot; it contains the object returned by function <code>mvr()</code> Present only if dmekeepfit=TRUE.
</p>
</td></tr>
<tr><td><code>dme.mean</code></td>
<td>

<p>Means of columns of dyadic model equation matrix
</p>
</td></tr>
<tr><td><code>dme.var</code></td>
<td>

<p>Variances of columns of dyadic model equation matrix
</p>
</td></tr>
<tr><td><code>dme.correl</code></td>
<td>

<p>Correlations between columns of dyadic model equation matrix.
</p>
</td></tr>
<tr><td><code>pcr.loadings</code></td>
<td>

<p>Loadings from principal component regression. Only present when dmeopt=&quot;pcr&quot;.
</p>
</td></tr>
<tr><td><code>dmeopt</code></td>
<td>

<p>Value of <code>dmeopt</code> argument in call to <code>dmm()</code> function. Specifies method used to solve DME's, and hence the type of fit object (if one is present).
</p>
</td></tr>
<tr><td><code>siga</code></td>
<td>

<p>Variance component estimates obtained by solving DME's.
</p>
</td></tr>
<tr><td><code>sesiga</code></td>
<td>

<p>Standard errors of variance component estimates.
</p>
</td></tr>
<tr><td><code>vard</code></td>
<td>

<p>Residual (co)variance matrix from solving DME's
</p>
</td></tr>
<tr><td><code>degfd</code></td>
<td>

<p>Degrees of freedom for residual covariance matrix.
</p>
</td></tr>
<tr><td><code>component</code></td>
<td>

<p>Vector of component names from the <code>component</code> argument in call to <code>dmm()</code> function, with the element &quot;VarP(I)&quot; appended.
</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>

<p>Estimated genetic or environmental correlation coefficient corresponding to each component
</p>
</td></tr>
<tr><td><code>correlation.variance</code></td>
<td>

<p>Estimated sampling variance of each correlation coefficient.
</p>
</td></tr>
<tr><td><code>correlation.se</code></td>
<td>

<p>Estimated standard error of each correlation coefficient.
</p>
</td></tr>
<tr><td><code>fraction</code></td>
<td>

<p>Estimated proportion of variance (relative to the total phenotypic (co)variance)) corresponding to each component. For example the proportion corresponding to component &quot;VarG(Ia)&quot; is the usual additive genetic heritability.
</p>
</td></tr>
<tr><td><code>fraction.variance</code></td>
<td>

<p>Estimated sampling variance of each proportion.
</p>
</td></tr>
<tr><td><code>fraction.se</code></td>
<td>

<p>Estimated standard error of each proportion.
</p>
</td></tr>
<tr><td><code>variance.components</code></td>
<td>

<p>Variance component estimates ( as in <em>siga</em>) but with their total which is phenotypic (co)variance appended.
</p>
</td></tr>
<tr><td><code>variance.components.se</code></td>
<td>

<p>Standard errors of variance component estimates, including phenotypic (co)variance.
</p>
</td></tr>
<tr><td><code>phenotypic.variance</code></td>
<td>

<p>Phenotypic (co)variances as a trait x trait matrix.
</p>
</td></tr>
<tr><td><code>phenotypic.variance.se</code></td>
<td>

<p>Standard errors of phenotypic (co)variances as a matrix.
</p>
</td></tr>
<tr><td><code>observed.variance</code></td>
<td>

<p>Observed variance, adjusted for fixed effects, in current population. Will differ from phenotypic variance because related animals are correlated. All the estimated components, and their sum ( which is phenotypic variance) are estimates of what the components would be in a population of unrelated individuals.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The call made to <code>dmm()</code> function to generate this object
</p>
</td></tr>
<tr><td><code>gls</code></td>
<td>

<p>Another list containing all the above items, but for fixed effects fitted by GLS instead of OLS. Will only be present if gls=TRUE and if the gls iteration converged successfully.
</p>
</td></tr>
<tr><td><code>specific</code></td>
<td>

<p>Another list containing those of the above items which are relevant when class-specific (co)varianc components are estimated. Will only be present if the argument <code>specific.components</code> is not NULL, that is if at least one class-specific component is fitted.
</p>
</td></tr>
</table>
<p>If option <code>traitspairwise</code> is TRUE, the value returned by <code>dmm()</code> is an object of class <code>dmmarray</code>, which is an array of which each element is an object of class <code>dmm</code> representing an analysis for one pair of traits. The rows and columns of the array are named using trait names.
</p>
<p>If option <code>traitsblockwise</code> is TRUE, the value returned by <code>dmm()</code> is an object of class <code>dmmblockarray</code>, which is a list of two items named <code>array</code> and <code>blocks</code>. List item <code>array</code> is an array of which each element is an object of class <code>dmm</code> representing an analysis for one pair of blocks of traits. The rows and columns of the array are named using block names. List item <code>blocks</code> is a list with one element per block, each containig the set of trait names present in the block.
</p>
<p>The functions <code>condense.dmmarray</code> and <code>condense.dmmblockarray</code> are available to facilitate recombining an array of <code>dmm</code> objects into a single object of class <code>dmm</code> with the variance component and genetic parameter estimates appropriately assembled into multi-trait matrices.  For example, one would use these functions to prepare an input file for function <code>gresponse</code>.
</p>


<h3>Note</h3>

<p>Two methods of estimating fixed effects are offered by <code>dmm()</code> - termed OLS-b and GLS-b.
OLS-b is computationally simple and non-iterative and is the default. Use OLS-b for preliminary runs until the set of components to be estimated from the dyadic model equations is settled. Use GLS-b for the final run. 
OLS-b leads to MINQUE estimates of the variance components and OLS estimates of the fixed effects. GLS-b leads to bias-corrected-ML estimates of the variance components , and GLS estimates of the fixed effects.
</p>
<p>The notation for (co)variance components was designed to use ASCII characters only so that it could be usable as dimnames in R. Some examples should make it clear
</p>

<dl>
<dt>&quot;VarE(Ia)&quot;</dt><dd><p> variance environmental individual additive</p>
</dd>
<dt>&quot;VarG(Ia)&quot;</dt><dd><p> variance genetic individual additive</p>
</dd>
<dt>&quot;VarG(Ma)&quot;</dt><dd><p> variance genetic maternal additive</p>
</dd>
<dt>&quot;CovG(Ia,Ma)&quot;</dt><dd><p> covariance genetic individual additive x maternal additive</p>
</dd>
<dt>&quot;VarGs(Ia)&quot;</dt><dd><p> variance genetic sexlinked individual additive</p>
</dd> 
</dl>

<p>For a full coverage of notation see the document dmmOverview.pdf Section 6.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>References</h3>

<p>The document dmmOverview.pdf has a bibliography of literature references.
</p>


<h3>See Also</h3>

<p>Functions <code>mdf()</code>, <code>make.ctable()</code>, <code>condense.dmmarray()</code>, <code>condense.dmmblockarray()</code>. 
Packages nadiv, robustbase, pls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
# Prepare the dataset sheep.df
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A","D"))
# The above code renumbers the pedigree Id's, makes columns "Year","Tb","Sex"
#    into factors,
#    assembles columns "CWW",Diam","Bwt" into a matrix (called 'Ymat')
#    for multivariate processing,
#    and sets up the environmental, additive genetic, and dominance genetic
#    relationship matrices.

# a simple model with individual environmenmtal and 
#    additive genetic components (default)
sheep.fit &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
   components=c("VarE(I)","VarG(Ia)"),gls=TRUE)
# view the components and fixed effect coefficients ( 2 traits only)
summary(sheep.fit,traitset=c("Cww","Diam"),gls=TRUE)
# view the genetic parameters
gsummary(sheep.fit,traitset=c("Cww","Diam"))

rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fit)

# Note: sheep.df is a small demo dataset. The results are illustrative, 
# but not meaningful.
# for a tutorial and fully documented examples see {\em dmmOverview.pdf}
</code></pre>

<hr>
<h2 id='dmm-internal'>
Functions internal to dmm
</h2><span id='topic+am.arel'></span><span id='topic+am.mcrel'></span><span id='topic+am.pyrel'></span><span id='topic+am.zandrel'></span><span id='topic+combpaste'></span><span id='topic+comtopar'></span><span id='topic+comtopar.specific'></span><span id='topic+countnotna'></span><span id='topic+covcit'></span><span id='topic+covlyz'></span><span id='topic+covtopar'></span><span id='topic+covt'></span><span id='topic+crossclasscovtopar'></span><span id='topic+crosseffectcovtopar'></span><span id='topic+csummary_specific'></span><span id='topic+dae.nonspecific.I'></span><span id='topic+dae.nonspecific'></span><span id='topic+dae.nonspecific.S'></span><span id='topic+dae.specific.I'></span><span id='topic+dae.specific'></span><span id='topic+dae.specific.S'></span><span id='topic+dmesolve'></span><span id='topic+dmm_array'></span><span id='topic+dmm_blockarray'></span><span id='topic+duplicated_first'></span><span id='topic+dyad.am.expect'></span><span id='topic+expect.v'></span><span id='topic+fixpaste'></span><span id='topic+genericvarvcnames'></span><span id='topic+genericvcnames'></span><span id='topic+gls.b.gmat'></span><span id='topic+gls.iter.b'></span><span id='topic+gsummary_specific'></span><span id='topic+is.cecov'></span><span id='topic+is.crossclass'></span><span id='topic+is.specific'></span><span id='topic+is.var'></span><span id='topic+is.withinclass'></span><span id='topic+make.cohort'></span><span id='topic+make.csummarytables'></span><span id='topic+make.gsummarytables'></span><span id='topic+make.matcline'></span><span id='topic+make.patyline'></span><span id='topic+match.cecov.nonspecific'></span><span id='topic+match.cecov.specific'></span><span id='topic+match.var.specific'></span><span id='topic+part.add'></span><span id='topic+partocov'></span><span id='topic+permpaste'></span><span id='topic+phenclasses'></span><span id='topic+selfpaste'></span><span id='topic+separ'></span><span id='topic+siga.posdef'></span><span id='topic+siga.posdef.specific'></span><span id='topic+sigatoie'></span><span id='topic+sigatovc'></span><span id='topic+traitpairstotraits'></span><span id='topic+varlz'></span><span id='topic+varz'></span><span id='topic+vt'></span>

<h3>Description</h3>

<p>Internal functions not documented and not visible to user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>am.arel(df)
am.mcrel(df)
am.pyrel(df)
am.zandrel(mdf, df, k, l, x, y, cohortparts, components,
     specific.components, relmat, ctable)
combpaste(x, y)
comtopar(v, l, siga, vara, vsiga, sesiga, ctable)
comtopar.specific(v, l, thisvc, vara, vthisvc, sethisvc, ctable,
     ic, phencovclass, longrownames, siga)
countnotna(x)
covcit(v, l, iv, vsiga, il, jl)
covlyz(cyz, y, z)
covtopar(covg, covt)
covt(v, l, vsiga, il, jl, kl)
crossclasscovtopar(covx, covt, var1, var2)
crosseffectcovtopar(covx, covt, varcomp, var1, var2)
csummary_specific(object, traitset, componentset, bytrait, gls, digits, ...)
dae.nonspecific.I(zpre, zpost, mmat, componentname, cnames, cnamesie,
     emat, vmat, icol, iecol, gls)
dae.nonspecific(zpre, rel, zpost, mmat, componentname, cnames, cnamesie,
     emat, vmat, icol, iecol, gls)
dae.nonspecific.S(zpre1, zpost1, zpre2, zpost2, zop, mmat,
     componentname, cnames, cnamesie, emat, vmat, icol, iecol, gls)
dae.specific.I(zpre, zpost, mmat, factorno, componentname,
     effnames, effcodes, effnandc, comcodes, varcodes, cnames, cnamesie,
     emat, vmat, icol, iecol, gls, ctable)
dae.specific(zpre, rel, zpost, mmat, factorno, componentname,
     effnames, effcodes, effnandc, comcodes, varcodes, cnames, cnamesie,
     emat, vmat, icol, iecol, gls, ctable)
dae.specific.S(zpre1, zpost1, zpre2, zpost2, zop, mmat, factorno,
     componentname, effnames, effcodes, effnandc, comcodes, varcodes,
     cnames, cnamesie, emat, vmat, icol, iecol, gls, ctable)
dmesolve(mdf, fixform = Ymat ~ 1, components = c("VarE(I)", "VarG(Ia)"),
     specific.components = NULL, cohortform = NULL, posdef = T, gls = F,
     glsopt = list(maxiter = 200, bdamp = 0.8, stoptol = 0.01),
     dmeopt = "qr", ncomp.pcr = "rank", relmat = "inline",
     dmekeep = F, dmekeepfit = F)
dmm_array(mdf, fixform, components, specific.components, cohortform,
     posdef, gls, glsopt, dmeopt, ncomp.pcr, relmat, dmekeep, dmekeepfit)
dmm_blockarray(mdf, fixform, components, specific.components, cohortform,
     posdef, gls, glsopt, dmeopt, ncomp.pcr, relmat, dmekeep, dmekeepfit, ...)
duplicated_first(x)
dyad.am.expect(am, gls, dmeopt)
expect.v(am, siga, dme.explist)
fixpaste(x, fix)
genericvarvcnames(x)
genericvcnames(x)
gls.b.gmat(am, vinv, dme.explist, vmatblock)
gls.iter.b(am, start.b, start.siga, dyad.explist, glsopt, dmeopt, ctable,
     ncomp.pcr, dmekeepfit)
gsummary_specific(dmmobj, traitset, componentset, bytrait, gls, digits, ...)
is.cecov(x, allcovs)
is.crossclass(x)
is.specific(x)
is.var(x)
is.withinclass(x)
make.cohort(df, ce)
make.csummarytables(object, traitset = "all",
     componentset = "all", bytrait = T, gls = F, digits = 3)
make.gsummarytables(dmmobj, traitset = "all",
     componentset = "all", bytrait = T, gls = F, digits = 3)
make.matcline(df)
make.patyline(df)
match.cecov.nonspecific(longrowname)
match.cecov.specific(longrowname)
match.var.specific(longrowname)
part.add(x, p, prow, pcol)
partocov(par, covt)
permpaste(x)
phenclasses(comcodes)
selfpaste(x)
separ(siga, vsiga, v, l, fracta, correa)
siga.posdef(siga, am, ctable, varopt = "both", covopt = "bound")
siga.posdef.specific(siga, am, ctable, varopt = "both", covopt = "bound")
sigatoie(cnames,cnamesie,siga,vsiga,sesiga,am,nsf)
sigatovc(siga, vsiga, sesiga, am, nsf)
traitpairstotraits(tp)
varlz(vz, z)
varz(vlz, z)
vt(v, l, vsiga, il, jl)
</code></pre>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>

<hr>
<h2 id='dt8bal.df'>
A balanced dataset with eight individuals.
</h2><span id='topic+dt8bal.df'></span>

<h3>Description</h3>

<p>A very small, simple dataset with a balanced design, one fixed effect, and two traits. The design consists of 4 sire families, with 2 offspring per sire, one of each sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dt8bal.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and the following 6 variables.
</p>

<dl>
<dt><code>Id</code></dt><dd><p>Identifier for individuals</p>
</dd>
<dt><code>SId</code></dt><dd><p>Identifier for sires of individuals</p>
</dd>
<dt><code>DId</code></dt><dd><p>Identifier for dams of individuals</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A factor with levels <code>F</code> <code>M</code>. Sex of individual</p>
</dd>
<dt><code>CWW</code></dt><dd><p>A numeric vector. Clean wool weight in Kg observed for each individual</p>
</dd>
<dt><code>DIA</code></dt><dd><p>A numeric vector. Fibre diameter in microns observed for each individual</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are intended to be used for testing and for demonstrating agreement with analysis of variance estimates in the balanced case.
</p>
<p>This dataframe meets the minimal requirements for <code>dmm()</code> function; that is its pedigree identifiers are suitably numbered and the base individuals are present. For an univariate analysis it can be utilized directly, without preprocessing by function <code>mdf()</code>.
</p>


<h3>Source</h3>

<p>A small subset of real data from an Australian sheep flock.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(dt8bal.df)
str(dt8bal.df) 
rm(dt8bal.df)
</code></pre>

<hr>
<h2 id='gprint'>
Generic function for printing genetic parameters contained in an object of class <code>dmm</code>.
</h2><span id='topic+gprint'></span>

<h3>Description</h3>

<p>Provide a short description of the model fitted and the genetic parameters obtained for an object of class <code>dmm</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gprint(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprint_+3A_x">x</code></td>
<td>

<p>An object of class <code>dmm</code>.
</p>
</td></tr>
<tr><td><code id="gprint_+3A_...">...</code></td>
<td>

<p>See other arguments defined for function <code>gprint.dmm()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a short printout without standard errors or confidence limits. It is the analog of <code>print()</code> for a dmm object, but with genetic parameters instead of variance components. For a more extensive printout with standard errors and confidence limits, see function <code>gsummary()</code>.
If there are class specific components and genetic parameters,  the short printout is repeated for each class.
</p>


<h3>Value</h3>

<p>There is no return value. 
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>gprint.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
# Prepare the dataset sheep.df
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A","D"))

# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"))
# look at parameters for 2 traits
gprint(sheep.fit1,traitset=c("Cww","Diam"))

rm(sheep.fit1)
rm(sheep.mdf)
rm(sheep.df)

</code></pre>

<hr>
<h2 id='gprint.dmm'>
Print method for genetic parameters contained in an object of class <code>dmm</code>.
</h2><span id='topic+gprint.dmm'></span>

<h3>Description</h3>

<p>Provide a short description of the model fitted and the genetic parameters obtained for an object of class <code>dmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
gprint(x, traitset = "all", gls = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprint.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>dmm</code>.
</p>
</td></tr>
<tr><td><code id="gprint.dmm_+3A_traitset">traitset</code></td>
<td>

<p>A vector containing the names of the subset of traits for which genetic parameters are to be printed. Default is &quot;all&quot; which means to print parameters for all traits present in object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="gprint.dmm_+3A_gls">gls</code></td>
<td>

<p>Logical flag: should the parameter estimates by GLS-b method be printed in addition to the parameter estimates by OLS-b method? Default is <code>gls=FALSE</code>. The GLS-b parameters can only be printed if object <code>x</code> contains the attribute <code>gls</code>, that is if <code>x</code> was constructed by a <code>dmm()</code> call with parameter <code>gls=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gprint.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a short printout without standard errors or confidence limits. It is the analog of <code>print()</code> for a dmm object, but with genetic parameters instead of variance components. For a more extensive printout with standard errors and confidence limits, see function <code>gsummary()</code>.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>gprint()</code>, <code>gsummary()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A","D"))

# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"))
# look at parameters for two traits
gprint(sheep.fit1,traitset=c("Cww","Diam"))
rm(sheep.fit1)
rm(sheep.mdf)
rm(sheep.df)
</code></pre>

<hr>
<h2 id='gresponse.dmm'>
Compute response to selection, given phenotypic selection differentials.
</h2><span id='topic+gresponse.dmm'></span><span id='topic+gresponse'></span>

<h3>Description</h3>

<p>Computes genetic selection differentials, given phenotypic selection differentials and a set of genetic parameters.  Effects contributing to response can be any combination of individual additive genetic, individual additive sexlinked genetic, maternal additive genetic, and maternal additive sexlinked genetic. Warning; this function does not currently handle class specific genetic parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
gresponse(dmmobj, traitset = "all", gls = F,
          psd = list(dp=NULL,dp.sex=NULL,dp.path=NULL),
          effects = "G(Ia)", digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gresponse.dmm_+3A_dmmobj">dmmobj</code></td>
<td>

<p>An object of class <code>dmm</code>. Genetic parameters are obtained from this object. Normally this object would be obtained from an output from function <code>dmm()</code>, but there is provision ( function <code>make.dmmobj()</code>) for the user to construct a <code>dmm</code> object from external data.
</p>
</td></tr>
<tr><td><code id="gresponse.dmm_+3A_traitset">traitset</code></td>
<td>

<p>A vector containing the names of the subset of traits for which genetic selection differentials are to be computed, and for which phenotypic selection differentials are to be specified. Default is &quot;all&quot; which means all traits present in object <code>dmmobj</code>. The order of traits listed here determines the order in all objects returned.
</p>
</td></tr>
<tr><td><code id="gresponse.dmm_+3A_gls">gls</code></td>
<td>

<p>Logical flag: should the parameter estimates by GLS-b method be used rather than the parameter estimates by OLS-b method? Default is <code>gls=FALSE</code>. The GLS-b parameters can only be used if object <code>dmmobj</code> contains the attribute <code>gls</code>, that is if <code>dmmobj</code> was constructed by a <code>dmm()</code> call with parameter <code>gls=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gresponse.dmm_+3A_psd">psd</code></td>
<td>

<p>A list containing the overall (dp), sex-specific (dp.sex), or path-specific (dp.path) phenotypic selection differentials. Only one of these three need be specified. Units for phenotypic selection differentials are the same as units for the traits in the dataframe used to construct <code>dmmobj</code>. Units for traits in the phenotypic (co)variance matrix are also the same, albeit squared because they are second moments. The default is a NULL so something must be specified for the <code>psd</code> argument or the function will return an error. Phenotypic selection differentials are defined as the difference between the mean of the selected group of individuals and the mean of the whole unselected population, for each trait.
</p>
<p>The three <code>psd</code> options are specified as follows
</p>

<dl>
<dt>dp</dt><dd><p>dp=vector</p>
</dd>
<dt>dp.sex</dt><dd><p>dp.sex=list(he=vector,ho=vector)</p>
</dd>
<dt>dp.path</dt><dd><p>dp.path=list(he.he=vector,ho.he=vector,he.ho=vector,ho.ho=vector)</p>
</dd>
</dl>

<p>where 'vector' is always of length equal to the number of traits.
</p>
<p>Regardless of which <code>psd</code> option is specified the <code>gresponse()</code> function always sets up <code>dp.path</code> internally and uses this to compute the genetic selection differentials separately for each <code>path</code>.
</p>
</td></tr>
<tr><td><code id="gresponse.dmm_+3A_effects">effects</code></td>
<td>

<p>A vector of character codes specifying the genetic effects contributing to the response computed. There are four options which can be used in any combination:
</p>

<dl>
<dt>&quot;G(Ia)&quot;</dt><dd><p>Individual additive genetic effect</p>
</dd>
<dt>&quot;Gs(Ia)&quot;</dt><dd><p>Individual additive sexlinked genetic effect</p>
</dd>
<dt>&quot;G(Ma)&quot;</dt><dd><p>Maternal additive genetic effect</p>
</dd>
<dt>&quot;Gs(Ma)&quot;</dt><dd><p>Maternal additive sexlinked genetic effect</p>
</dd>
</dl>

<p>The default is <code>"G(Ia)"</code>.
</p>
</td></tr>
<tr><td><code id="gresponse.dmm_+3A_digits">digits</code></td>
<td>

<p>Number of digits for output. This is returned as part of the return value for use by the S3 print function <code>print.gresponse.dmm()</code>.
</p>
</td></tr>
<tr><td><code id="gresponse.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gresponse()</code> function defines four 'paths' of improvement as follows
</p>

<dl>
<dt>he.he</dt><dd><p>Heterogametic sex in the parent to heterogametic sex in the progeny</p>
</dd>
<dt>ho.he</dt><dd><p>Homogametic sex in the parent to heterogametic sex in the progeny</p>
</dd>
<dt>he.ho</dt><dd><p>Heterogametic sex in the parent to homogametic sex in the progeny</p>
</dd>
<dt>ho.ho</dt><dd><p>Homogametic sex in the parent to homogametic sex in the progeny</p>
</dd>
</dl>

<p>The response or genetic selection differentials are always calculated separately for each of the four paths, then pooled to give sex specific gsd's, then pooled again to give an overall gsd. This is strictly only needed for responses due to sexlinked effects, but is done for generality.
</p>
<p>Clearly if we are computing individual additive genetic responses, the individual additive genetic variance (called &quot;VarG(Ia)&quot;) must be available in object <code>dmmobj</code>. If computing both individual and maternal additive genetic responses, both the individual and maternal additive genetic variances (called &quot;VarG(Ia)&quot; and &quot;VarG(Ma)&quot;) must be available in object <code>dmmobj</code>. Their genetic covariances (called &quot;CovG(Ia,Ma)&quot; and &quot;CovG(Ma,Ia)&quot;) can optionally be available in object <code>dmmobj</code>, if they are not present they are assumed zero. The same applies for sexlinked additive genetic response and maternal sexlinked additive genetic response.
</p>
<p>It is advisable to ensure that all parameter matrices are positive definite. In particular the phenotypic covariance matrix must have an inverse.
</p>


<h3>Value</h3>

<p>An object of class <code>gresponse.dmm</code>, which is a list containing the following items:
</p>
<table>
<tr><td><code>psdcase</code></td>
<td>
<p>A character string which is either &quot;overall&quot;, &quot;sex&quot;, or &quot;path&quot;. Describes the type of object used to specify the <code>psd</code> argument</p>
</td></tr>
<tr><td><code>psd</code></td>
<td>
<p>A list containing one of <code>dp</code>, <code>dp.sex</code>, <code>dp.path</code>, with the others defaulting to NULL, as specifieds in the <code>psd</code> argument</p>
</td></tr>
<tr><td><code>gcov</code></td>
<td>
<p>The combined genetic covariance matrix. In all cases there will be 4 partitions, one for each of the effects &quot;G(Ia)&quot;, &quot;Gs(Ia)&quot;, &quot;G(Ma)&quot;, and &quot;Gs(Ma)&quot;, so the matrix will be of size (4 * l) x (4 * l) where l is number of traits. Effects not specified in argument <code>effects</code> will have their corresponding partitions of <code>gcov</code> set to zero matrices.</p>
</td></tr>
<tr><td><code>pcov</code></td>
<td>
<p>The given phenotypic covariance matrix.</p>
</td></tr>
<tr><td><code>rmat</code></td>
<td>
<p>A list containing the R matrices for each path. These incorporate the factor of 0.5 for maternal effects, and the appropriate path factors (0.0, 1.0, or 0.5) for transmission of effects located on the sex chromosome.</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>A list containing the genetic selection differentials (gsd) for given psd, the genetic selection differentials (ugsd) for unit psd on each trait, the directional selection gradients (dsg), and the given phenotypic selection differentials (psd). Each of these is given separately for each of the paths (he.he, ho.he, he.ho, ho.ho), where 'he' stands for the heterogametic sex, and 'ho' stands for the homogametic sex. The genetic selection differentials are also given summed across all the effects (gdsum), again separately for each of the paths. </p>
</td></tr>
<tr><td><code>sex</code></td>
<td>
<p>A list containing the genetic selection differentials (gsd) achieved by selection of each sex separately (gsd.he. and gsd.ho.), and observed in each sex separately (gsd..he and gsd..ho), as well as summed over effects (gsdsum), again separately for each sex selected, and observed in each sex. The separate phenotypic selection differentials for each sex (psd.he. and psd.ho.)are also given.</p>
</td></tr>
<tr><td><code>overall</code></td>
<td>
<p>A list containing the overall genetic selection differentials (gsd), for each effect (gsd..) and summed over effects(gsdsum... The overall phenotypic selection differential (psd..) is also given.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>The argument <code>digits</code> specified in the function call</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>The argument <code>effects</code> specified in the function call</p>
</td></tr>
<tr><td><code>traits</code></td>
<td>
<p>A character vector containing all the specified trait names</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no provision for computing the effect of non-additive genetic (co)variances  on genetic selection differentials. The genetic selection differentials calculated are for a one generation response only. In the case of maternal effects there will be lags in response and the phenotypic response will not match the genetic response.  There is no provision for overlapping generations. There is no provision for sex-specific genetic parameters.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>References</h3>

<p>Dickerson,G(1947) Iowa Agricultural Research Station Bulletin No.354 pp489-524
</p>
<p>Griffing,B(1966) &quot;Influence of Sex on Selection. III Joint contribution of sex-linked and autosomal genes&quot; Aust. J. Biol. Sci. 19: 775-93
</p>
<p>Walsh,B(2009) &quot;Multivariate Selection Response and Estimation of Fitness Surfaces&quot; 2nd Annual NSF short course on Statistical Genetics, Honolulu (13-17 July,2009). 
</p>


<h3>See Also</h3>

<p>Functions <code>print.gresponse.dmm()</code>, <code>summary.gresponse.dmm()</code>, <code>make.dmmobj()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(dmm)
# get some data
data(sheep.df)
# prepare it - only need "E" and "A" relationship matrices
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# estimate genetic parameters - individual and maternal
sheep.fit5 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
              components=c("VarE(I)","VarG(Ia)","VarE(M)","VarG(Ma)",
              "CovG(Ia,Ma)","CovG(Ma,Ia)"))
# compute response using overall psd
sheep.resp &lt;- gresponse(sheep.fit5,psd=list(dp=c(1,1,1)),effects=c("G(Ia)","G(Ma)"))
# look at the response object
summary(sheep.resp)
# cleanup
rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fit5)
rm(sheep.resp)

</code></pre>

<hr>
<h2 id='gsummary.dmm'>
Make summary tables of genetic parameters for a dmm object
</h2><span id='topic+gsummary.dmm'></span><span id='topic+gsummary'></span>

<h3>Description</h3>

<p>Extracts the genetic parameters from an object of class <code>dmm</code>, for the specified set of traits and set of components. Makes tables of parameters ordered either by trait or by component. Tables include parameter estimate, its standard error, and its 95 percent confidence limits. Parameters are grouped intp class-specific classes, if there are any class-specific components fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
gsummary(dmmobj, traitset = "all", componentset = "all", bytrait = T,
                    gls = F, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsummary.dmm_+3A_dmmobj">dmmobj</code></td>
<td>

<p>An object of class <code>dmm</code>. Genetic parameters are obtained from this object.
</p>
</td></tr>
<tr><td><code id="gsummary.dmm_+3A_traitset">traitset</code></td>
<td>

<p>A vector containing the names of the subset of traits for which tables of genetic parameters are to be constructed. Default is &quot;all&quot; which means all traits present in object <code>dmmobj</code>.
</p>
</td></tr>
<tr><td><code id="gsummary.dmm_+3A_componentset">componentset</code></td>
<td>

<p>A vector containing the names of the subset of (co)variance components for which tables of genetic parmeters are to be constructed. Default is &quot;all&quot; which means all (co)variance components present in object <code>dmmobj</code>.
</p>
</td></tr>
<tr><td><code id="gsummary.dmm_+3A_bytrait">bytrait</code></td>
<td>

<p>Logical flag: should the tables of genetic parameters be constructed with trait varying least rapidly from line to line? If TRUE each subtable contains parameters for one trait or traitpair and for all components. If FALSE each subtable contains parameters for one component and for all traits or traitpairs.
</p>
</td></tr>
<tr><td><code id="gsummary.dmm_+3A_gls">gls</code></td>
<td>

<p>Logical flag: should the parameter estimates by GLS-b method be tabled in addition to the parameter estimates by OLS-b method? Default is <code>gls=FALSE</code>. The GLS-b parameters can only be tabled if object <code>dmmobj</code> contains the attribute <code>gls</code>, that is if <code>dmmobj</code> was constructed by a <code>dmm()</code> call with argument <code>gls=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gsummary.dmm_+3A_digits">digits</code></td>
<td>

<p>Number of digits for output. This is returned as part of the return value for use by the S3 print function <code>print.gsummary.dmm()</code>.
</p>
</td></tr>
<tr><td><code id="gsummary.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a long printout with  estimates, standard errors and confidence limits, arranged in tables with one estimate per line. It is the analog of <code>csummary()</code> for a <code>dmm</code> object, but with genetic parameters instead of variance components. In the case of class-specific parameters, the parameters are listed in class groups, so that the proportions of variance sum to unity within each group. In the case where all parameters are non-specific, there is just one class group.
</p>


<h3>Value</h3>

<p>An object of class <code>gsummary.dmm</code> which is a list containing the following items:
</p>
<table>
<tr><td><code>ftables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the proportion of variance attributable to components, along with the appropriate standard errors and confidence limits. Based on OLS-b component estimates.</p>
</td></tr>
<tr><td><code>rtables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the correlation coefficient attributable to components, along with the appropriate standard errors and confidence limits. Based on OLS-b component estimates.</p>
</td></tr>
<tr><td><code>ptables</code></td>
<td>
<p>A single dataframe object containing estimates of the phenotypic (co)variance. Note that these are based on all components, even if a subset of components is specified in argument <code>componentset</code>. Based on OLS-b component estimates.</p>
</td></tr>
<tr><td><code>gftables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the proportion of variance attributable to components, along with the appropriate standard errors and confidence limits. Based on GLS-b component estimates. Only present if argument <code>gls=TRUE</code>.</p>
</td></tr>
<tr><td><code>grtables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the correlation coefficient attributable to components, along with the appropriate standard errors and confidence limits. Based on GLS-b component estimates. Only present if argument <code>gls=TRUE</code>.</p>
</td></tr>
<tr><td><code>gptables</code></td>
<td>
<p>A single dataframe object containing estimates of the phenotypic (co)variance. Note that these are based on all components, even if a subset of components is specified in argument <code>componentset</code>. Based on GLS-b component estimates. Only present if argument <code>gls=TRUE</code>.</p>
</td></tr>
<tr><td><code>traits</code></td>
<td>
<p>A vector of traitnames as specified in argument <code>traitset</code>.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>A vector of component names as specified in argument <code>componentset</code>.</p>
</td></tr>
<tr><td><code>bytrait</code></td>
<td>
<p>Logical flag: as specified in argument <code>bytrait</code>.</p>
</td></tr>
<tr><td><code>gls</code></td>
<td>
<p>Logical flag: as specified in argument <code>gls</code>.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>A numeric value, as specified in argument <code>digits</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no provision to constrain the 95 percent confidence limits for parameter estimates. Hence for small samples, these may vary outside the bounds for the parameter. 
</p>


<h3>Author(s)</h3>

<p>Nevillle Jackson
</p>


<h3>See Also</h3>

<p>Function <code>print.gsummary.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get some data
data(sheep.df)
# prepare it - only need "E" and "A" relationship matrices
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# estimate genetic parameters - individual and maternal
sheep.fit5 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Tb + Sex,
              components=c("VarE(I)","VarG(Ia)","VarE(M)","VarG(Ma)",
              "CovG(Ia,Ma)","CovG(Ma,Ia)"))
# look just at parameter "VarG(Ma)" across all traits
gsummary(sheep.fit5,componentset="VarG(Ma)",bytrait=FALSE)
# look just at trait "Cww"
gsummary(sheep.fit5,traitset="Cww")
# cleanup
rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fit5)
</code></pre>

<hr>
<h2 id='harv101.df'>
Harvey dataset
</h2><span id='topic+harv101.df'></span>

<h3>Description</h3>

<p>Real data for average daily gain <code>(Adg)</code> of each of 65 Hereford steers, with age <code>(Age)</code> and initial weight <code>(Weight)</code> as covariates. First used by Walter Harvey in the publication listed below, on page 101 and following pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(harv101.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 139 observations on the following 9 variables.
</p>

<dl>
<dt><code>Id</code></dt><dd><p>Identifier for individuals</p>
</dd>
<dt><code>SId</code></dt><dd><p>Identifier for sires of individuals</p>
</dd>
<dt><code>DId</code></dt><dd><p>Identifier for dams of individuals</p>
</dd>
<dt><code>Line</code></dt><dd><p>A numeric vector: breeding line for each individual</p>
</dd>
<dt><code>Agedam</code></dt><dd><p>A numeric vector: age of dam for each individual</p>
</dd>
<dt><code>Age</code></dt><dd><p>A numeric vector: age at weaning for each individual</p>
</dd>
<dt><code>Weight</code></dt><dd><p>A numeric vector: initial weight at beginning of test feeding in a feedlot</p>
</dd>
<dt><code>Adg</code></dt><dd><p>A numeric vector: average daily gain in weight in the feedlot</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A numeric vector: code for Sex of each individual</p>
</dd>
</dl>



<h3>Details</h3>

<p>It has been assumed that all individuals have a unique dam, that is there are no twins or repeat matings. This is not clear in the original presentation. The nonzero relationships in this pedigree are therefore entirely due to individuals having a common sire.
</p>
<p>This dataframe is close to meeting the requirements for function <code>dmm()</code>. The pedigree Id's are OK, the base animals are present, and there is only one trait to be analysed, so we do not need a traits matrix. However the Line and Agedam need to ba made into factors. We can either fix this by hand, or use function <code>mdf()</code>.
</p>


<h3>Source</h3>

<p>Harvey W.R.(1960) &quot;Least Squares Analysis of Data with Unequal Subclass Numbers&quot; United States Department of Agriculture Publication ARS-20-8, July 1960.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(harv101.df)
str(harv101.df)
# preprocess, keeping Weight and Adg for use as covariates
# we need the keep=T agrument to preserve the covariates
harv.mdf &lt;- mdf(harv101.df, pedcols=c(1:3), factorcols=c(4,5,9), ycols=3, 
            keep=TRUE, sexcode=c(1,2))
str(harv.mdf)
#cleanup
rm(harv101.df)
rm(harv.mdf)
#
# There is a full analysis of this dataset in 'dmmOverview.pdf'.
#
</code></pre>

<hr>
<h2 id='make.countarray'>
Count the number of observations in a dataframe or an <code>mdf</code> object for all traitpairs in the supplied list of traits.
</h2><span id='topic+make.countarray'></span>

<h3>Description</h3>

<p>For some of the traits in a dataframe or an <code>mdf</code> object there may be missing observations, coded as <code>NA</code>, on some individuals. The function <code>make.countarray</code> assembles an array containing observation counts for all pairs of traits from the supplied vector of trait names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.countarray(mdf, traits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.countarray_+3A_mdf">mdf</code></td>
<td>

<p>A dataframe or an object of class <code>mdf</code>. If made with function <code>mdf()</code> the argument <code>keep=TRUE</code> should be used, because the traits must be present as dataframe columns.
</p>
</td></tr>
<tr><td><code id="make.countarray_+3A_traits">traits</code></td>
<td>

<p>A vector of the names of traits given as character strings
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be useful if the number of observations varies between traits and one is planning to do a <code>dmm()</code> analysis with either the <code>traitspairwise</code> or <code>traitsblockwise</code> option.
</p>


<h3>Value</h3>

<p>An array object with 2 dimensions, both of size equal to the number of traits in argument <code>traits</code>. Rows and columns are labelled with trait names. Each element is a count of the number of observations not equal to <code>NA</code> for a pair of traits.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>dmm()</code>, <code>mdf()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
# prepare the dataset sheep.df
data(sheep.df)
# count the observations
countarray &lt;- make.countarray(sheep.df,c("Cww","Diam","Bwt"))
# lookat the counts
print(countarray)
#cleanup
rm(sheep.df)
rm(countarray)
</code></pre>

<hr>
<h2 id='make.ctable'>
Generates a list of vectors containing sets of variance component names
</h2><span id='topic+make.ctable'></span>

<h3>Description</h3>

<p>Internal function used by <code>dmm()</code> to construct vectors containing various subsets of the available variance component names, for use in testing and flow control. Made available at user level because it may be useful in constructing the <code>components</code> argument of <code>dmm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.ctable()
</code></pre>


<h3>Details</h3>

<p>There are at present 33 variance and cross-effect-covariance components available in <code>dmm()</code>. Each of these corresponds to a particular effect in a genetic model. Component names are used throughout <code>dmm()</code> to name rows and columns, and hence to label output. For the user, correct specification of component names is vital. The list generated by an internal call to <code>make.ctable()</code> is used to check validity, and to manage internal flow control.
</p>


<h3>Value</h3>

<p>A list containing the following items:
</p>
<table>
<tr><td><code>cohortvar</code></td>
<td>
<p>Vector containing all variance components involving cohort</p>
</td></tr>
<tr><td><code>cohortcov</code></td>
<td>
<p>Vector containing all covariance components involving cohort</p>
</td></tr>
<tr><td><code>cohort</code></td>
<td>
<p>Vector containing all (co)variance components involving cohort</p>
</td></tr>
<tr><td><code>evar</code></td>
<td>
<p>Vector containing all environmental variance comonents</p>
</td></tr>
<tr><td><code>ecov</code></td>
<td>
<p>Vector containing all environments covariance components</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Vector containing all environmental (co)variance components</p>
</td></tr>
<tr><td><code>addgvar</code></td>
<td>
<p>Vector containing all additive genetic variance components</p>
</td></tr>
<tr><td><code>domgvar</code></td>
<td>
<p>Vector containing all dominance genetic variance components</p>
</td></tr>
<tr><td><code>epiaddgvar</code></td>
<td>
<p>Vector containing all additive x additive epistatic genetic variance components</p>
</td></tr>
<tr><td><code>epidomgvar</code></td>
<td>
<p>Vector containing all epistatic genetic variance components involving dominance</p>
</td></tr>
<tr><td><code>sexlinaddgvar</code></td>
<td>
<p>Vector containing all sexlinked additive genetic variance components</p>
</td></tr>
<tr><td><code>gvar</code></td>
<td>
<p>Vector containing all genetic variance components</p>
</td></tr>
<tr><td><code>allvar</code></td>
<td>
<p>Vector containing all variance components</p>
</td></tr>
<tr><td><code>addgcov</code></td>
<td>
<p>Vector containing all additive genetic covariance components</p>
</td></tr>
<tr><td><code>domgcov</code></td>
<td>
<p>Vector containing all dominance genetic covariance components</p>
</td></tr>
<tr><td><code>epiaddgcov</code></td>
<td>
<p>Vector containing all additive x additive epistatic genetic covariance components</p>
</td></tr>
<tr><td><code>epidomgcov</code></td>
<td>
<p>Vector containing all epistatic genetic covariance components involving dominance</p>
</td></tr>
<tr><td><code>sexlinaddgcov</code></td>
<td>
<p>Vector containing all sexlinked additive genetic covariance components</p>
</td></tr>
<tr><td><code>gcov</code></td>
<td>
<p>Vector containing all genetic covariance components</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>Vector containing all genetic (co)variance components</p>
</td></tr>
<tr><td><code>allcov</code></td>
<td>
<p>Vector containing all covariance components</p>
</td></tr>
<tr><td><code>addg</code></td>
<td>
<p>Vector containing all additive genetic (co)variance components</p>
</td></tr>
<tr><td><code>domg</code></td>
<td>
<p>Vector containing all dominance genetic (co)variance components</p>
</td></tr>
<tr><td><code>epiaddg</code></td>
<td>
<p>Vector containing all additive x additive epistatic genetic (co)variance components</p>
</td></tr>
<tr><td><code>epidomg</code></td>
<td>
<p>Vector containing all epistatic genetic (co)variance components involving dominance</p>
</td></tr>
<tr><td><code>sexlinaddg</code></td>
<td>
<p>Vector containing all sexlinked additive genetic (co)variance components</p>
</td></tr>
<tr><td><code>indvar</code></td>
<td>
<p>Vector containing all individual variance components</p>
</td></tr>
<tr><td><code>indcov</code></td>
<td>
<p>Vector containing all individual covariance components</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>Vector containing all individual (co)variance components</p>
</td></tr>
<tr><td><code>matvar</code></td>
<td>
<p>Vector containing all maternal variance components</p>
</td></tr>
<tr><td><code>matcov</code></td>
<td>
<p>Vector containing all maternal covariance components</p>
</td></tr>
<tr><td><code>mat</code></td>
<td>
<p>Vector containing all maternal (co)variance components</p>
</td></tr>
<tr><td><code>all</code></td>
<td>
<p>Vector containing all (co)variance components</p>
</td></tr>
<tr><td><code>allzpre</code></td>
<td>
<p>Vector containing internal codes for type of Z matrix used in constructing column of W</p>
</td></tr>
<tr><td><code>allzpost</code></td>
<td>
<p>Vector containing internal codes for type of Z matrix used in constructing column of W</p>
</td></tr>
<tr><td><code>allrel</code></td>
<td>
<p>Vector containing internal codes for type of relationship matrix used in constructing column of W</p>
</td></tr>
<tr><td><code>cohortzpre1</code></td>
<td>
<p>Vector of special codes for Z matrix for cohort effects</p>
</td></tr>
<tr><td><code>cohortzpost1</code></td>
<td>
<p>Vector of special codes for Z matrix for cohort effects</p>
</td></tr>
<tr><td><code>cohortzpre2</code></td>
<td>
<p>Vector of special codes for Z matrix for cohort effects</p>
</td></tr>
<tr><td><code>cohortzpost2</code></td>
<td>
<p>Vector of special codes for Z matrix for cohort effects</p>
</td></tr>
<tr><td><code>cohortop</code></td>
<td>
<p>Vector of special operator codes  for cohort effects</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is an internal function, its definition and its return value may change in future versions.
</p>
<p>Component names are defined in the document <em>dmmOverview.pdf</em>.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
# make a ctable
tmp &lt;- make.ctable()
# see its structure
str(tmp)
# look at all additive genetic variances
tmp$addgvar
# tidy up
rm(tmp)
</code></pre>

<hr>
<h2 id='make.dmmobj'>
Construct an object of class <code>dmm</code> from user-supplied data
</h2><span id='topic+make.dmmobj'></span>

<h3>Description</h3>

<p>Construct an object of class <code>dmm</code> containing all attributes needed to run the <code>gresponse()</code> function. The user must supply a phenotypic covariance matrix, and a genetic covariance matrix for each of the components needed by <code>gresponse()</code> Warning; this function does not currently support class specific genetic parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.dmmobj(p = NULL, components = c("VarG(Ia)"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.dmmobj_+3A_p">p</code></td>
<td>

<p>A phenotypic covariance matrix. Dimnames for rows and columns must be set to the trait names
</p>
</td></tr>
<tr><td><code id="make.dmmobj_+3A_components">components</code></td>
<td>

<p>A character vector specifying names of all of the genetic variance components for which a genetic covariance matrix is to be supplied. If there are genetic covariance components ( eg &quot;CovG(Ia,Ma)&quot;), these must be listed after all the genetic variance components
</p>
</td></tr>
<tr><td><code id="make.dmmobj_+3A_...">...</code></td>
<td>

<p>A variable number of genetic covariance matrices, one for each of the names listed in the <code>components</code> argument. Each matrix must have dimnames the same as the phenotypic covariance matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the minimal attributes for use by the <code>gresponse()</code> function are constructed. The remainder are set to NULL
</p>


<h3>Value</h3>

<p>An object of class <code>dmm</code>. Only the following attributes contain data
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p>A dummy set of fixed effects</p>
</td></tr>
<tr><td><code>siga</code></td>
<td>
<p>A matrix of genetic variance (and covariance) components set out one component per row and the traitpairs in columns</p>
</td></tr>
<tr><td><code>variance.components</code></td>
<td>
<p>A matrix of genetic variance (and covariance) components with the phenotypic covariance matrix appended</p>
</td></tr>
<tr><td><code>phenotypic.variance</code></td>
<td>
<p>A matrix of phenotypic covariances set out one trait per row and per column</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If matrices are supplied which are not positive definite, function <code>make.dmmobj()</code> will alter them to the nearest positive definite matrix using routine <code>neadPD()</code> from package <code>Matrix</code>. No message is given. Check the value returned to see if matrices have been adjusted.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>gresponse()</code> and <code>dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
p &lt;- matrix(c(3,2,2,4),2,2)
dimnames(p) &lt;- list(c("T1","T2"),c("T1","T2"))
gia &lt;- matrix(c(2,1,1,3),2,2)
dimnames(gia) &lt;- dimnames(p)
myobj &lt;- make.dmmobj(p,components=c("VarG(Ia)"),gia)
myresp &lt;- gresponse(myobj,psd=list(dp=c(0.5,0.1)))
print(myresp)
#cleanup
rm(p)
rm(gia)
rm(myobj)
rm(myresp)

</code></pre>

<hr>
<h2 id='mdf'>
Prepare a dataframe for use with dmm function
</h2><span id='topic+mdf'></span>

<h3>Description</h3>

<p>The function <code>mdf()</code> converts an R dataframe to one which meets the requirements of function <code>dmm()</code>, and may optionally append to that dataframe one or more relationship matrices obtained using package <code>nadiv</code>. 
Conversion involves renumbering pedigree Id's, removing duplicates, adding base animals, setting up columns to be fixed factors, putting multivariate traits into a matrix, defining the heterogametic sex, and optionally calling <code>nadiv</code> functions to append relationship matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdf(df, pedcols = c(1:3), factorcols = NULL, ycols = NULL, sexcode = NULL,
    keep = F, relmat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdf_+3A_df">df</code></td>
<td>

<p>A dataframe object with columns labelled:
</p>

<dl>
<dt>Id</dt><dd><p> An identifier for each individual</p>
</dd>
<dt>SId</dt><dd><p> An identifier for each sire</p>
</dd>
<dt>DId</dt><dd><p> An identifier for each dam</p>
</dd>
<dt>Sex</dt><dd><p> A coding for sex of each individual</p>
</dd>
<dt>Fixed effect names</dt><dd><p> Codings for each fixed effect</p>
</dd>
<dt>Observation names</dt><dd><p> Numerical values for each trait</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mdf_+3A_pedcols">pedcols</code></td>
<td>

<p>A vector specifying which columns of <code>df</code> contain the pedigree information (ie Id, SId, and DId). The vector can contain either column numbers, or column names. The dafault is c(1:3).
</p>
</td></tr>
<tr><td><code id="mdf_+3A_factorcols">factorcols</code></td>
<td>

<p>A vector specifying which columns of <code>df</code> contain codes for factors which are to be used as either fixed effects or in defining cohort. The default is NULL.
</p>
</td></tr>
<tr><td><code id="mdf_+3A_ycols">ycols</code></td>
<td>

<p>A vector specifying which columns of <code>df</code> contain observations which are to become traits in a matrix. The default is NULL. The matrix is always called 'Ymat'.
</p>
</td></tr>
<tr><td><code id="mdf_+3A_sexcode">sexcode</code></td>
<td>

<p>A vector of length 2 specifying the codings used for Sex, with the heterogametic sex code given first position. This should always be specified. The default is NULL. If the <code>Sex</code> column in the dataframe <code>df</code> is a character vector, then <code>sexcode</code> should be a charcter vector. If the <code>Sex</code> column in the dataframe <code>df</code> is an integer vector, then <code>sexcode</code> should be an integer vector. If the <code>Sex</code> column in the dataframe <code>df</code> is a character vector coerced to a factor, then <code>sexcode</code> should be a charcter vector. If the <code>Sex</code> column in the dataframe <code>df</code> is an integer vector coerced to a factor, then <code>sexcode</code> should be an integer vector.
</p>
</td></tr>
<tr><td><code id="mdf_+3A_keep">keep</code></td>
<td>

<p>A logical variable. Are columns not specified by <code>pedcols</code>, <code>factorcols</code>, or <code>ycols</code> to be retained in the output object? Default is FALSE - ie unused columns are discarded.
</p>
</td></tr>
<tr><td><code id="mdf_+3A_relmat">relmat</code></td>
<td>

<p>A vector listing the relationship matrices to be generated and appended to the dataframe thus creating a return object of class <code>mdf</code>.
Each relationship matrix has a code letter or name as follows:
</p>

<dl>
<dt>&quot;E&quot;</dt><dd><p> An environmental correlation matrix. At present this produces an identity matrix - ie no environmental correlation effects. Must always be included.</p>
</dd>
<dt>&quot;A&quot;</dt><dd><p> Additive genetic relationship matrix.</p>
</dd>
<dt>&quot;D&quot;</dt><dd><p> Dominance relationship matrix.</p>
</dd>
<dt>&quot;Dsim&quot;</dt><dd><p> Dominance relationship matrix by the simulation method (see <code>nadiv</code>).</p>
</dd>
<dt>&quot;AA&quot;</dt><dd><p> Additive x additive epistatic relationship matrix.</p>
</dd>
<dt>&quot;AD&quot;</dt><dd><p> Additive x dominance epistatic relationship matrix.</p>
</dd>
<dt>&quot;DD&quot;</dt><dd><p> Dominance x dominance relationship matrix.</p>
</dd>
<dt>&quot;S&quot;</dt><dd><p> Sex linked additive genetic relationship matrix with no global dosage compensation ('ngdc' option see <code>nadiv</code>)</p>
</dd>
<dt>&quot;S.hori&quot;</dt><dd><p> Sex linked additive genetic relationship matrix with 'hori' dosage compensation model ( see <code>nadiv</code>)</p>
</dd>
<dt>&quot;S.hedo&quot;</dt><dd><p> Sex linked additive genetic relationship matrix with 'hedo' dosage compensation model ( see <code>nadiv</code>)</p>
</dd>
<dt>&quot;S.hoha&quot;</dt><dd><p> Sex linked additive genetic relationship matrix with 'hoha' dosage compensation model ( see <code>nadiv</code>)</p>
</dd>
<dt>&quot;S.hopi&quot;</dt><dd><p> Sex linked additive genetic relationship matrix with 'hopi' dosage compensation model ( see <code>nadiv</code>)</p>
</dd>
</dl>

<p>Default is NULL - ie no relationship matrices constructed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If planning to use numerical observations as covariates in the fixed effects model under <code>dmm()</code> use argument <code>keep=TRUE</code>, so that the covariate columns are retained in the returned dataframe object.
</p>
<p>The following actions are performed by <code>mdf()</code>:
</p>

<ul>
<li><p> remove any Id's which are NA or duplicate (including first duplicate)
</p>
</li>
<li><p> add SId's which do not match any Id as base Id's
</p>
</li>
<li><p> add DId's which do not match any Id as base Id's
</p>
</li>
<li><p> renumber all Id's
</p>
</li>
<li><p> retain original Id's as row names
</p>
</li>
<li><p> if <code>keep=TRUE</code> retain unused columns of dataframe
</p>
</li>
<li><p> if <code>keep=FALSE</code> do not retain unused columns of dataframe
</p>
</li>
<li><p> always retain Id, SId, DId, and factors
</p>
</li>
<li><p> Sex should be one of the factors
</p>
</li>
<li><p> transform Sex codes to NA if not in argument <code>sexcode[]</code>
</p>
</li>
<li><p> take first entry in <code>sexcode[]</code> as the heterogametic sex
</p>
</li>
<li><p> make columns in <code>factorcols</code> into factors
</p>
</li>
<li><p> make columns in <code>ycols</code> into a matrix of traits called 'Ymat'
</p>
</li>
<li><p> if <code>relmat</code> argument is present, compute the relationship matrices specified and make a returned list object <code>mdf</code> containing the modified dataframe as <code>mdf$df</code> and the relationship matrices as <code>mdf$rel</code>
</p>
</li>
<li><p> if <code>relmat</code> argument is not present simply return the modified dataframe
</p>
</li></ul>



<h3>Value</h3>

<p>The return object is of class <code>mdf</code> if relationship matrices are requested, and is of class <code>dataframe</code> if relationship matrices are not requested.
</p>
<p>An object of class <code>mdf</code> is a list containing the following items:
</p>

<dl>
<dt>df</dt><dd>
<p>A dataframe conforming to the requirements of function <code>dmm()</code>
</p>
</dd>
<dt>rel</dt><dd>
<p>A list of relationship matrices
</p>
</dd>
</dl>

<p>An object of class <code>dataframe</code> as returned by function <code>mdf()</code> is a dataframe conforming to the requirements of function <code>dmm()</code>
</p>


<h3>Note</h3>

<p>Individuals which appear in the SId or DId columns, but not in the Id column are assumed to be 'base individuals', ie they have unknown sire and dam. They will be given an Id and added to the dataframe, but their SId and DId and all data except for Sex coding will be set to NA, so they will be assumed unrelated and will not contribute data. It is important that 'base individuals' be present for relationship matrices to be calculated correctly.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>dmm()</code>, <code>pedrenum()</code>. 
Package <code>nadiv</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)

# prepare a multi-trait dataset from sheep.df
data(sheep.df)
# look at its structure
str(sheep.df)
# needs some work - Id, SId, DId are alphanumeric
#                 - Year is numeric and we want it as a factor
#                 - there are 3 traits (Cww,Diam,Bwt) to put into a trait matrix
sheep.mdf1 &lt;- mdf(sheep.df,pedcols=c(1:3), factorcols=c(4:6), ycols=c(7:9),
             sexcode=c("M","F"))
# note the screen messages - it also had to add 2 base Id's for 2 of the dams
str(sheep.mdf1)
# so it returned a dataframe object with 44 observations
# and one of the columns is a matrix called 'Ymat'

# prepare a dataset requiring relationship matrices
sheep.mdf2 &lt;- mdf(sheep.df,pedcols=c(1:3), factorcols=c(4:6), ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# note the screen messages - it now makes an object of class mdf
str(sheep.mdf2)
# so it returned a list object with 2 items
#    df - the dataframe
#   rel - a list of relationship matrices ( note those not requested are NULL)
#
 
</code></pre>

<hr>
<h2 id='merino.df'>
Australian Merino sheep research dataset
</h2><span id='topic+merino.df'></span>

<h3>Description</h3>

<p>A set of real data from an Australian Merino sheep research flock with a multi-generation pedigree, eight fixed effects, and 11 traits related to wool production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(merino.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 4449 observations on the following 22 variables.
</p>

<dl>
<dt><code>Id</code></dt><dd><p>Identifier for individuals</p>
</dd>
<dt><code>SId</code></dt><dd><p>Identifier for sires of individuals</p>
</dd>
<dt><code>DId</code></dt><dd><p>Identifier for dams of individuals</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A factor with levels <code>M</code> (male) <code>F</code> (female)</p>
</dd>
<dt><code>Yearbi</code></dt><dd><p>A factor: year of birth of each individual</p>
</dd>
<dt><code>YearSbi</code></dt><dd><p>A factor: year of birth of each individual's sire</p>
</dd>
<dt><code>YearDbi</code></dt><dd><p>A factor: year of birth of each individual's dam</p>
</dd>
<dt><code>Mob</code></dt><dd><p>A factor: each individual was reared in one of two grazing environments coded  <code>1</code> and <code>2</code></p>
</dd>
<dt><code>Agem</code></dt><dd><p>A factor: each individual was measured at one of two ages coded <code>3</code> (12 months) and <code>9</code> (15 months)</p>
</dd>
<dt><code>Birwt</code></dt><dd><p>A numeric vector: weight at birth in Kg</p>
</dd>
<dt><code>Weanwt</code></dt><dd><p>A numeric vector: weight at weaning in Kg</p>
</dd>
<dt><code>Birls</code></dt><dd><p>A factor:  litter size at birth coded as <code>1</code> and <code>2</code></p>
</dd>
<dt><code>Weanls</code></dt><dd><p>A factor: litter size at weaning coded as  <code>1</code> and <code>2</code></p>
</dd>
<dt><code>Crimp</code></dt><dd><p>A numeric vector: staple crimp frequency in crimps per 2.5cm</p>
</dd>
<dt><code>Densty</code></dt><dd><p>A numeric vector: density of wool fibres on the skin surface in fibres per square mm</p>
</dd>
<dt><code>Diamtr</code></dt><dd><p>A numeric vector: average fibre diameter in microns</p>
</dd>
<dt><code>Yield</code></dt><dd><p>A numeric vector: wool yield as a percentage. The amount of clean wool as a percentage of the greasy weight of fleece</p>
</dd>
<dt><code>Bodywt</code></dt><dd><p>A numeric vector: weight in Kg at the time of wool measurement, that being either 12 or 15 months, see item <code>Agem</code></p>
</dd>
<dt><code>Wrinkl</code></dt><dd><p>A numeric vector: a visual score for skin wrinkle</p>
</dd>
<dt><code>Length</code></dt><dd><p>A numeric vector: staple length in cm</p>
</dd>
<dt><code>Flcwt</code></dt><dd><p>A numeric vector: greasy fleece weight in Kg</p>
</dd>
<dt><code>Woolwt</code></dt><dd><p>A numeric vector: clean wool weight in Kg</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are intended to show the utility of <code>dmm()</code> for analysis of a multi-trait dataset with all the real world complications. The dataframe has identifiers which are NA or duplicate or alphanumeric, some base animals are missing, some traits and factors have missing values, and the eleven traits need to be in a matrix for multivariate analysis.
</p>


<h3>Source</h3>

<p>These data were collected over the period 1950 to 1970 by CSIRO under the direction of Dr Helen Newton Turner. The dataset was recovered from the author's research files, and are used with permission from CSIRO.
</p>


<h3>References</h3>

<p>These data form part of the set which were used to estimate genetic parameters in the publication:
Brown,G.H. and Turner,Helen Newton(1968)Aust.J.Agric.Res.19:303-22
</p>
<p>For a coverage of Australian Merino sheep research see :
Turner,Helen Newton and Young,S.S.Y(1969) Quantitative Genetics in Sheep Breeding. Macmillan, Melbourne, 1969.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(merino.df)
str(merino.df)
rm(merino.df)
#
# there is a full analysis of this dataset in 'dmmOverview.pdf'.
#
</code></pre>

<hr>
<h2 id='pedcheck'>
Checks that the Id, SId, and DId columns of a dataframe are valid for function <code>dmm()</code>.
</h2><span id='topic+pedcheck'></span>

<h3>Description</h3>

<p>Checks that Id's form an arithmetic sequence, and that every SId and DId appears as an Id.This ensures that relationship matrix construction can proceed without error.
Also checks each SId is a male, and each DId is a female
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedcheck(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedcheck_+3A_df">df</code></td>
<td>

<p>A dataframe containing the columns Id, SId, and DId as required to include pedigree information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pedcheck()</code> would normally be used before function <code>mdf()</code>, to indicate whether <code>mdf()</code> is needed.  If there are base animals missing from the dataframe, it will report errors. It can be used after <code>mdf()</code> just to check for errors in the Sex of individuals.  Errors in the Sex of individuals can affect calculation of sexlinked relationship matrices.
</p>
<p>Both the inline code in function <code>dmm()</code> and the routines in package <code>nadiv</code> require Id's in a numerical sequence and base animals present, for correct relationship matrix calculations.
</p>


<h3>Value</h3>

<p>Returns zero if the dataframe passes check tests. Returns number of message(s) if the dataframe fails check tests, and prints the messages.
</p>


<h3>Note</h3>

<p>Function <code>pedcheck()</code> is an internal function called by function <code>dmm()</code>. It
is made available because it may be useful for preliminary checking.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(dt8bal.df)
pedcheck(dt8bal.df)
# this one returns 
#[1] 0
# which is a pass
## Not run: 
data(sheep.df)
pedcheck(sheep.df)
# this one returns 
#Id's must start at 1:
#Id's must be an arithmetic sequence:
#Id's must be unique:
#DId's must occur as an Id in the dataframe:
#All DId's must be female:
#[1] 5
# which is a fail

## End(Not run)
rm(dt8bal.df)
</code></pre>

<hr>
<h2 id='pedrenum'>
Renumbers the Id, SId, and DId columns of a dataframe
</h2><span id='topic+pedrenum'></span>

<h3>Description</h3>

<p>Converts the identifiers in column Id of a dataframe into numeric codes which form a sequence from  1 to n with unit increments and no duplicates. Converts the identifiers in columns SId and DId to correspond. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedrenum(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedrenum_+3A_df">df</code></td>
<td>

<p>A dataframe containing columns named Id, SId, and DId as required to include pedigree information
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that any identifiers in columns SId or DId also appear in column Id. If not use function <code>mdf()</code> instead of function <code>pedrenum()</code>. Function <code>mdf()</code> actually calls function <code>pedrenum()</code>, but ensures that the above requirement is met first.
</p>


<h3>Value</h3>

<p>A dataframe containing the renumbered Id, SId, and DId columns, as well as any other columns present in argument <code>df</code>
</p>


<h3>Note</h3>

<p>Function <code>pedrenum()</code> is an internal function called by function <code>mdf()</code>. It is made available because it may be useful in cases where the complex dataframe manipulations performed by function <code>mdf()</code> are not required.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>mdf()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(dt8bal.df)
# note these data do not need renumbering, but will use as a demo
tmprenum &lt;- pedrenum(dt8bal.df)
# In this case all that happens is that SId, which was a factor in dt8bal.df, is
# converted back to int. The numeric codes are unaltered.
rm(dt8bal.df)
rm(tmprenum)
</code></pre>

<hr>
<h2 id='plot.dmm'>
Plot residuals from fitting dyadic model
</h2><span id='topic+plot.dmm'></span>

<h3>Description</h3>

<p>Plots dyadic residuals as five separate plots showing histogram of residuals, qqnorm plot of residuals, fitted values against residuals, dyadic covariances against residuals, and dyadic covariances against fittes values. Multi trait case shows all trait pairs on each plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
plot(x, traitset = "all", gls = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>dmm</code>. This will be a 'fit' object for the dyadic model equations. It should contain attributes <code>dme.fit</code> and <code>dme.psi</code> obtained by calling <code>dmm()</code> with arguments
<code>dmekeep=TRUE</code> and <code>dmekeepfit=TRUE</code> respectively.
</p>
</td></tr>
<tr><td><code id="plot.dmm_+3A_traitset">traitset</code></td>
<td>

<p>Either a character vector specifying trait names to be plotted, or the default valuse which is <code>"all"</code> meaning plot all traits present in object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.dmm_+3A_gls">gls</code></td>
<td>

<p>A logical flag. Should the plot be of dyadic residuals given OLS-b fixed effects, or of dyadic residuals given GLS-b fixed effects. Default is <code>gls=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.dmm_+3A_...">...</code></td>
<td>

<p>Other arguments passed to plotting functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In plots with <code>gls=FALSE</code> there will be <code class="reqn">N^{2}</code> residuals, where <code class="reqn">N</code> is the number of individuals with data. In plots with <code>gls=TRUE</code> there will be <code class="reqn">N^{2} * L^{2}</code> residuals, where <code class="reqn">L</code> is the number of traits. This is because the GLS-b fit is always multivariate, whereas the OLS-b fit is multi-trait, just like a multiple regression with multi-trait response.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>print.dmm()</code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"),
    dmekeep=TRUE,dmekeepfit=TRUE)
# plot dyadic model residuals for all traits
plot(sheep.fit1)
#cleanup
rm(sheep.fit1)
rm(sheep.mdf)
rm(sheep.df)

</code></pre>

<hr>
<h2 id='print.csummary.dmm'>
Print method for object of class <code>csummary.dmm</code>.
</h2><span id='topic+print.csummary.dmm'></span>

<h3>Description</h3>

<p>Formats each attribute of a <code>csummary.dmm</code> object for printing, adding appropriate headings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csummary.dmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.csummary.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>csummary.dmm</code>.
</p>
</td></tr>
<tr><td><code id="print.csummary.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each table in an object of class <code>csummary.dmm</code> is a dataframe. This method uses the default dataframe print method to format each table for printing, passing the <code>digits</code> attribute from the <code>csummary.dmm</code> object to the print call.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>csummary.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# make a simple fit object - OLS-b only
sheep.fits &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
          components="VarE(I)",specific.components=list(Sex="VarG(Ia)"))
# compute a 'csummary.dmm' object, use all the defaults
sheep.csum &lt;- csummary(sheep.fits)
# print the summary of genetic parameters
print(sheep.csum)
## Not run: 
# can do the same thing without saving response object
csummary(sheep.fits)
# so this is the default print method for an object of class 'csummary.dmm'

## End(Not run)
#cleanup
rm(sheep.fits)
rm(sheep.csum)
rm(sheep.mdf)
rm(sheep.df)
</code></pre>

<hr>
<h2 id='print.dmm'>
Print method for a <code>dmm()</code> fitted model object.
</h2><span id='topic+print.dmm'></span>

<h3>Description</h3>

<p>Provide a short description of the model fitted and the fixed effects and (co)variance component estimates obtained for an object of class <code>dmm</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
print(x, traitset = "all", gls = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>dmm</code>.
</p>
</td></tr>
<tr><td><code id="print.dmm_+3A_traitset">traitset</code></td>
<td>

<p>A vector containing the names of the subset of traits for which fixed effects and (co)variance components are to be printed. Default is &quot;all&quot; which means to print estimates for all traits present in object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="print.dmm_+3A_gls">gls</code></td>
<td>

<p>Logical flag: should the fixed effects and (co)variance component estimates by GLS-b method be printed in addition to the fixed effects and (co)variance component estimates by OLS-b method? Default is <code>gls=FALSE</code>. The GLS-b fixed effects and (co)variance component estimates can only be printed if object <code>x</code> contains the attribute <code>gls</code>, that is if <code>x</code> was constructed by a <code>dmm()</code> call with argument <code>gls=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="print.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a short printout without standard errors or confidence limits. For a more extensive printout with standard errors and confidence limits, see function <code>summary.dmm()</code>. The printout includes fixed effects, variance component estimates, and correlations among columns of the W matrix of the dyadic model equations.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Note</h3>

<p>For a similar short printout, but with genetic parameters instead on (co)variance components, see function <code>gprint.dmm()</code>.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>summary.dmm()</code> and <code>gprint.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A","D"))
# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"))
# look at model plus fixed effects and components for all traits
print(sheep.fit1)
## Not run: 
# can do the same thing without saving fit object
dmm(sheep.mdf, Ymat ~ 1 + Year + Tb + Sex,
    components=c("VarE(I)","VarG(Ia)"))
# so this is the default print method for an object of class 'dmm'

## End(Not run)
#cleanup
rm(sheep.fit1)
rm(sheep.mdf)
rm(sheep.df)
</code></pre>

<hr>
<h2 id='print.gresponse.dmm'>
Print method for object of class <code>gresponse.dmm</code>.
</h2><span id='topic+print.gresponse.dmm'></span>

<h3>Description</h3>

<p>Prints overall responses only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gresponse.dmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gresponse.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>gresponse.dmm</code>.
</p>
</td></tr>
<tr><td><code id="print.gresponse.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argumnet.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple printout of overall response estimates. There are no standard errors or confidence limits for response estimates.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>gresponse.dmm()</code>, <code>summary.gresponse.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"))
# compute some response estimates, use all the defaults
sheep.resp &lt;- gresponse(sheep.fit1,psd=list(dp=c(1,1,1)))
# print these
print(sheep.resp)
## Not run: 
# can do the same thing without saving response object
gresponse(sheep.fit1,psd=list(dp=c(1,1,1)))
# so this is the default print method for an object of class 'gresponse.dmm'

## End(Not run)
#cleanup
rm(sheep.fit1)
rm(sheep.resp)
rm(sheep.mdf)
rm(sheep.df)
</code></pre>

<hr>
<h2 id='print.gsummary.dmm'>
Print method for object of class <code>gsummary.dmm</code>.
</h2><span id='topic+print.gsummary.dmm'></span>

<h3>Description</h3>

<p>Formats each attribute of a <code>gsummary.dmm</code> object for printing, adding appropriate headings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsummary.dmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gsummary.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>gsummary.dmm</code>.
</p>
</td></tr>
<tr><td><code id="print.gsummary.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each table in an object of class <code>gsummary.dmm</code> is a dataframe. This method uses the default dataframe print method to format each table for printing, passing the <code>digits</code> attribute from the <code>gsummary.dmm</code> object to the print call.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>gsummary.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
   components=c("VarE(I)","VarG(Ia)"))
# compute a 'gsummary.dmm' object, use all the defaults
sheep.gsum &lt;- gsummary(sheep.fit1)
# print the summary of genetic parameters
print(sheep.gsum)
## Not run: 
# can do the same thing without saving response object
gsummary(sheep.fit1)
# so this is the default print method for an object of class 'gsummary.dmm'

## End(Not run)
#cleanup
rm(sheep.fit1)
rm(sheep.gsum)
rm(sheep.mdf)
rm(sheep.df)
</code></pre>

<hr>
<h2 id='print.summary.dmm'>
Print method for an object of class <code>summary.dmm</code>.
</h2><span id='topic+print.summary.dmm'></span>

<h3>Description</h3>

<p>Formats each attribute of a <code>summary.dmm</code> object for printing, adding appropriate headings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.dmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.dmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>summary.dmm</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each table in an object of class <code>summary.dmm</code> is a dataframe. This method uses the default dataframe print method to format each table for printing, passing the <code>digits</code> attribute from the <code>summary.dmm</code> object to the print call.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>summary.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
    components=c("VarE(I)","VarG(Ia)"))
# compute a 'summary.dmm' object, use all the defaults
sheep.sum &lt;- summary(sheep.fit1)
# print the summary of genetic parameters
print(sheep.sum)
## Not run: 
# can do the same thing without saving response object
summary(sheep.fit1)
# so this is the default print method for an object of class 'summary.dmm'

## End(Not run)
#cleanup
rm(sheep.fit1)
rm(sheep.sum)
rm(sheep.mdf)
rm(sheep.df)

</code></pre>

<hr>
<h2 id='quercus.df'>
Quercus example dataset
</h2><span id='topic+quercus.df'></span>

<h3>Description</h3>

<p>Example dataset from the program package 'QUERCUS', developed by Ruth G. Shaw and Frank H. Shaw. Known to 'quercus' as the 'demo2' dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quercus.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 180 observations on the following 6 variables.
</p>

<dl>
<dt><code>Id</code></dt><dd><p>Identifier for individuals</p>
</dd>
<dt><code>SId</code></dt><dd><p>Identifier for sires of individuals</p>
</dd>
<dt><code>DId</code></dt><dd><p>Identifier for dams of individuals</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A numeric vector: code for Sex of each individual</p>
</dd>
<dt><code>Trait1</code></dt><dd><p>A numeric vector: an observation called Trait1</p>
</dd>
<dt><code>Trait2</code></dt><dd><p>A numeric vector: an observation called Trait2</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a simulated dataset suitable for a 3-component analysis, the components being environmental variance, additive genetic variance, and dominance genetic variance. It needs pre-processing with function <code>mdf()</code> to add base animals, to combine the two traits into a matrix, and to calculate additive and dominance relationship matrices.
</p>


<h3>Source</h3>

<p><a href="https://cbs.umn.edu/eeb/about-eeb/helpful-links/quercus-quantitative-genetics-software">https://cbs.umn.edu/eeb/about-eeb/helpful-links/quercus-quantitative-genetics-software</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(quercus.df)
str(quercus.df)
# preprocess
quercus.mdf &lt;- mdf(quercus.df,pedcols=c(1:3),factorcols=4,ycols=c(5:6),
               relmat=c("E","A","D"),sexcode=c(1,2))
str(quercus.mdf)
# cleanup
rm(quercus.df)
rm(quercus.mdf)
#
# there is a full analysis of this dataset in 'dmmOverview.pdf'.
#
</code></pre>

<hr>
<h2 id='sheep.df'>
Demonstration sheep dataset
</h2><span id='topic+sheep.df'></span>

<h3>Description</h3>

<p>A small dataset with an unbalanced design, three fixed effects one of which can be interpreted as a cohort, three traits, and a pedigree which permits most available variance components to be fitted. Deliberately set up to be useful for a variety of demonstrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sheep.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations on the following 9 variables.
</p>

<dl>
<dt><code>Id</code></dt><dd><p>Identifier for individuals</p>
</dd>
<dt><code>SId</code></dt><dd><p>Identifier for sires of individuals</p>
</dd>
<dt><code>DId</code></dt><dd><p>Identifier for dams of individuals</p>
</dd>
<dt><code>Year</code></dt><dd><p>A numeric vector: year of birth of each individual</p>
</dd>
<dt><code>Tb</code></dt><dd><p>A factor with levels <code>S</code> (born as a single lamb) <code>T</code> (born as a twin lamb)</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A factor with levels <code>M</code> (male) <code>F</code> (female)</p>
</dd>
<dt><code>Cww</code></dt><dd><p>A numeric vector. Clean wool weight in Kg observed for eac
h individual</p>
</dd>
<dt><code>Diam</code></dt><dd><p>A numeric vector. Fibre diameter in microns observed for e
ach individual</p>
</dd>
<dt><code>Bwt</code></dt><dd><p>A numeric vector. Body weight in Kg observed for each individual</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are intended for demonstration, and are extensively used in examples in the <code>dmm</code> package help files.
</p>
<p>This dataframe does not meet the minimum requirements for function <code>dmm()</code>. The identifiers are alphanumeric, some base animals are missing, and the three traits need to be in a matrix for multivariate analysis. It requires preprocessing by function <code>mdf()</code>.
</p>


<h3>Source</h3>

<p>A small subset of real data from an Australian sheep flock. Not the whole flock, and not a random sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(sheep.df)
str(sheep.df)
#do some preprocessing
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# The above code renumbers the pedigree Id's, makes columns "Year","Tb","Sex"
#    into factors,
#    assembles columns "CWW",Diam","Bwt" into a matrix (called 'Ymat')
#    for multivariate processing,
#    and sets up the environmental, and additive genetic
#    relationship matrices.
str(sheep.mdf)
#cleanup
rm(sheep.df)
rm(sheep.mdf)

</code></pre>

<hr>
<h2 id='summary.dmm'>
Make summary tables of (co)variance component estimates and fixed effect estimates for a dmm object.
</h2><span id='topic+summary.dmm'></span>

<h3>Description</h3>

<p>Extracts the (co)variance component and fixed effect estimates from an object of class <code>dmm</code>, for the specified set of traits and set of components. Makes tables of component estimates ordered either by trait or by component. Tables include component estimate, its standard error, and its 95 percent confidence limits. If there are class specific components these appear with appropriate labels in the list of components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dmm'
summary(object, traitset = "all", componentset = "all", bytrait = T,
            gls = F, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dmm_+3A_object">object</code></td>
<td>

<p>An object of class <code>dmm</code>. (Co)variance component estimates are obtained from this object.
</p>
</td></tr>
<tr><td><code id="summary.dmm_+3A_traitset">traitset</code></td>
<td>

<p>A vector containing the names of the subset of traits for which tables of (co)variance component estimates are to be constructed. Default is &quot;all&quot; which means all traits present in object <code>object</code>.
</p>
</td></tr>
<tr><td><code id="summary.dmm_+3A_componentset">componentset</code></td>
<td>

<p>A vector containing the names of the subset of (co)variance components for which tables are to be constructed. Default is &quot;all&quot; which means all (co)variance components present in object <code>object</code>.
</p>
</td></tr>
<tr><td><code id="summary.dmm_+3A_bytrait">bytrait</code></td>
<td>

<p>Logical flag: should the tables of (co)variance component estimates be constructed with trait varying least rapidly from line to line? If TRUE each subtable contains component estimates for one trait or traitpair and for all components in argument <code>componentset</code>. If FALSE each subtable contains component estimates for one component and for all traits or traitpairs.
</p>
</td></tr>
<tr><td><code id="summary.dmm_+3A_gls">gls</code></td>
<td>

<p>Logical flag: should the (co)variance component estimates by GLS-b method be tabled in addition to the (co)variance component estimates by OLS-b method? Default is <code>gls=FALSE</code>. The GLS-b (co)variance component estimates can only be tabled if object <code>object</code> contains the attribute <code>gls</code>, that is if <code>object</code> was constructed by a <code>dmm()</code> call with argument <code>gls=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.dmm_+3A_digits">digits</code></td>
<td>

<p>Number of digits for output. This is returned as part of the return value for us
e by the S3 print function <code>print.summary.dmm()</code>.
</p>
</td></tr>
<tr><td><code id="summary.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a long printout with  estimates, standard errors and confidence limits, arranged in tables with one estimate per line. For a short printout see function <code>print.dmm()</code>.
In the case of class-specific components, the components which are class-specific are labelled with their class-codes prepended to the variance component name, and components for all classes are included, so the listed components do not sum to phenotypic variance. To list the components in class groups, so that they sum to the class phenotypic variance use function <code>csummary()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>gsummary.dmm</code> which is a list containing the following 
items:
</p>
<table>
<tr><td><code>btables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the fixed effects, along with the appropriate standard errors and confidence limits. Based on OLS-b fixed effect estimates.</p>
</td></tr>
<tr><td><code>ctables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the (co)variance components, along with the appropriate standard errors and confidence limits. Based on OLS-b component estimates.</p>
</td></tr>
<tr><td><code>gbtables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the fixed effects, along with the appropriate standard errors and confidence limits. Based on GLS-b fixed effect estimates.</p>
</td></tr>
<tr><td><code>gctables</code></td>
<td>
<p>A list of dataframe objects each containing one subtable of estimates of the (co)variance components, along with the appropriate standard errors and confidence limits. Based on GLS-b component estimates. Only present if argument <code>gls=TRUE</code>.</p>
</td></tr>
<tr><td><code>traits</code></td>
<td>
<p>A vector of traitnames as specified in argument <code>traitset</code>.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>A vector of component names as specified in argument <code>componentset</code>.</p>
</td></tr>
<tr><td><code>bytrait</code></td>
<td>
<p>Logical flag: as specified in argument <code>bytrait</code>.</p>
</td></tr>
<tr><td><code>gls</code></td>
<td>
<p>Logical flag: as specified in argument <code>gls</code>.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>A numeric value, as specified in argument <code>digits</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no provision to constrain the 95 percent confidence limits for component estimates. Hence for small samples, these may vary outside the bounds for the component, that is for components which are variances, they may be negative. Fixed effects are not bounded.
Use <code>summary()</code> if you want to see the components as estimated. Use <code>csummrry()</code> if you want to see the components summing to phenotypic (co)variance, or sorted into class-specific groups.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Function <code>print.summary.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get some data
data(sheep.df)
# prepare it - only need "E" and "A" relationship matrices
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# estimate (co)variance components  - individual and maternal
sheep.fit5 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
              components=c("VarE(I)","VarG(Ia)","VarE(M)","VarG(Ma)",
              "CovG(Ia,Ma)","CovG(Ma,Ia)"))
# look just at component "VarG(Ma)" across all traits
summary(sheep.fit5,componentset="VarG(Ma)",bytrait=FALSE)
# look just at trait "Cww"
summary(sheep.fit5,traitset="Cww")
# cleanup
rm(sheep.df)
rm(sheep.mdf)
rm(sheep.fit5)

</code></pre>

<hr>
<h2 id='summary.gresponse.dmm'>
Summary method for object of class <code>gresponse.dmm</code>.
</h2><span id='topic+summary.gresponse.dmm'></span>

<h3>Description</h3>

<p>Summarizes path specific, sex specific, and overall responses in a <code>gresponse.dmm</code> object, adding appropriate headings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gresponse.dmm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gresponse.dmm_+3A_object">object</code></td>
<td>

<p>An object of class <code>gresponse.dmm</code>.
</p>
</td></tr>
<tr><td><code id="summary.gresponse.dmm_+3A_...">...</code></td>
<td>

<p>Ellipsis argumnet.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a summary of response estimates and the parameters used to calculate them. It includes path specific, sex specific and overall responses. There are no standard errors or confidence limits for response estimates.
</p>


<h3>Value</h3>

<p>There is no return value. Function is used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>gresponse.dmm()</code>, <code>print.gresponse.dmm()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
data(sheep.df)
sheep.mdf &lt;- mdf(sheep.df,pedcols=c(1:3),factorcols=c(4:6),ycols=c(7:9),
             sexcode=c("M","F"),relmat=c("E","A"))
# make a simple fit object - OLS-b only
sheep.fit1 &lt;- dmm(sheep.mdf, Ymat ~ 1 + Year + Sex,
   components=c("VarE(I)","VarG(Ia)"))
# compute some response estimates, use all the defaults
sheep.resp &lt;- gresponse(sheep.fit1,psd=list(dp=c(1,1,1)))
# summarize these
summary(sheep.resp)
#cleanup
rm(sheep.fit1)
rm(sheep.resp)
rm(sheep.mdf)
rm(sheep.df)
</code></pre>

<hr>
<h2 id='tstmo1.df'>
Dfreml example dataset
</h2><span id='topic+tstmo1.df'></span>

<h3>Description</h3>

<p>Example dataset from the program 'DFREML', developed by Karin Meyer. Known to 'DFREML' as the 'Example 1' dataset. A univariate dataset with 282 individuals in a 2 generation pedigree with full-sib families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tstmo1.df)</code></pre>


<h3>Format</h3>

<p>A data frame with 282 observations on the following 6 variables.
</p>

<dl>
<dt><code>Id</code></dt><dd><p>Identifier for individuals</p>
</dd>
<dt><code>SId</code></dt><dd><p>Identifier for sires of individuals</p>
</dd>
<dt><code>DId</code></dt><dd><p>Identifier for dams of individuals</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A factor: Sex of each individual</p>
</dd>
<dt><code>Gen</code></dt><dd><p>A numeric vector: generation number of each individual</p>
</dd>
<dt><code>Weight</code></dt><dd><p>A numeric vector: weight in ? of each individual</p>
</dd>
</dl>



<h3>Details</h3>

<p>Karin Meyer gives the following description of these data:
</p>
<p>&ldquo;
.... The test data given is that used by Meyer(1989) to illustrate univariate REML estimation via a derivtive-free algorithm. They are simulated records for a trait with a phenotypic variance of 100, direct heritability of 0.40, maternal heritability of 0.20, maternal-direct covariance (divided by 100) of -0.05, and a &quot;c-squared&quot; effect of 0.15. Data were generated for 2 generations of animals with a heirarchical full-sib family structure, yielding a total of 282 records and 306 animals in the analysis with generations as the only fixed effect.
&rdquo;
</p>


<h3>Source</h3>

<p>DFREML Version 3.0 User Notes. Karin Meyer. September 9,1998.
</p>
<p>These data were distributed with the DFREML program. Note DFREML is not currently available.
</p>


<h3>References</h3>

<p>Meyer,K.(1989) Restricted Maximum Likelihood to estimate variance components for animal models with several random effects using a derivative-free algorithm. Genet. Select. Evol. 21:317-340
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dmm)
data(tstmo1.df)
str(tstmo1.df)
rm(tstmo1.df)
#
# There is a full analysis of this dataset in 'dmmOverview.pdf'.
#

</code></pre>

<hr>
<h2 id='unfactor'>
Convert a vector from factor to numeric
</h2><span id='topic+unfactor'></span>

<h3>Description</h3>

<p>Convert a vector (such as a dataframe column) from factor to numeric. Non-numeric values will coerce to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfactor(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfactor_+3A_x">x</code></td>
<td>

<p>A vector of type factor. Typically this would be one column of a dataframe.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be useful when preparing a dataframe for <code>dmm()</code>.  It is a common problem for dataframe columns to be automatically made type factor when constructing the dataframe with functions such as <code>read.table</code>, due to the presence of a small number of non-numeric values. Dataframe columns used as traits or as covariates should not be of type factor.
</p>


<h3>Value</h3>

<p>A vector of numeric values is returned.
</p>


<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>dmm()</code>, <code>read.table()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dmm)
tmp &lt;- as.factor(c(1,2,3))
str(tmp)
utmp &lt;- unfactor(tmp)
str(utmp)
rm(tmp)
rm(utmp)
</code></pre>

<hr>
<h2 id='warcolak.convert'>
Convert <code>warcolak</code> data file to format required for a dataframe for <code>dmm()</code> or <code>mdf()</code>.
</h2><span id='topic+warcolak.convert'></span>

<h3>Description</h3>

<p>A simple function to relabel the columns of the <code>warcolak</code> dataset from package <code>nadiv</code>, to comply with the requirements of <code>dmm()</code> or <code>mdf()</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warcolak.convert(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warcolak.convert_+3A_w">w</code></td>
<td>

<p>An object produced by the call <code>data(warcolak)</code> from package <code>nadiv</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>warcolak</code> dataset has columns named slightly differently from what <code>dmm()</code> requires, but is otherwise compatable. We use this function to do a simple conversion before using <code>warcolak</code> as test data for <code>dmm()</code>.
</p>


<h3>Value</h3>

<p>A dataframe containing the following columns:
</p>

<dl>
<dt>&quot;Id&quot;</dt><dd><p>Individual identifier</p>
</dd>
<dt>&quot;SId&quot;</dt><dd><p>Sire identifier</p>
</dd>
<dt>&quot;DId&quot;</dt><dd><p>Dam identifier</p>
</dd>
<dt>&quot;Sex&quot;</dt><dd><p>Coding for sex</p>
</dd>
<dt>&quot;Trait1&quot;</dt><dd><p>First trait phenotypic value</p>
</dd>
<dt>&quot;Trait2&quot;</dt><dd><p>Second trait phenotypic value</p>
</dd>
<dt>&quot;t1_a&quot;</dt><dd><p>First trait additive genetic effect</p>
</dd>
<dt>&quot;t2_a&quot;</dt><dd><p>Second trait additive genetic effect</p>
</dd>
<dt>&quot;t2_s&quot;</dt><dd><p>Second trait additive genetic sexlinked effect</p>
</dd>
<dt>&quot;t1_d&quot;</dt><dd><p>First trait dominance genetic effect</p>
</dd>
<dt>&quot;t2_d&quot;</dt><dd><p>Second trait dominance genetic effect</p>
</dd>
<dt>&quot;t1_r&quot;</dt><dd><p>First trait environmental effect</p>
</dd>
<dt>&quot;t2_r&quot;</dt><dd><p>Second trait environmental effect</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Neville Jackson
</p>


<h3>See Also</h3>

<p>Functions <code>dmm()</code>, <code>mdf()</code>. Package <code>nadiv</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#library(dmm)
#data(warcolak)
#warcolak.df &lt;- warcolak.convert(warcolak)
#str(warcolak.df)
#rm(warcolak.df)
#rm(warcolak)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
