<!DOCTYPE html><html><head><title>Help for package nbTransmission</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nbTransmission}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clusterInfectors'><p>Clusters the infectors based on their transmission probabilities</p></a></li>
<li><a href='#estimateR'><p>Estimates the effective reproductive number</p></a></li>
<li><a href='#estimateRi'><p>Estimates individual-level reproductive numbers</p></a></li>
<li><a href='#estimateRt'><p>Estimates time-level reproductive numbers</p></a></li>
<li><a href='#estimateRtAvg'><p>Estimates the average effective reproductive number</p></a></li>
<li><a href='#estimateSI'><p>Estimates the generation/serial interval distribution</p></a></li>
<li><a href='#indData'><p>Individual-level simulated outbreak dataset</p></a></li>
<li><a href='#indToPair'><p>Transforms a dataset of individuals to a dataset of pairs</p></a></li>
<li><a href='#nbHeatmap'><p>Plots a heatmap of the relative transmission probabilities</p></a></li>
<li><a href='#nbNetwork'><p>Plots a network of the relative transmission probabilities</p></a></li>
<li><a href='#nbProbabilities'><p>Estimates relative transmission probabilities</p></a></li>
<li><a href='#nbResults'><p>Dataset with results of <code>nbProbabilities</code></p></a></li>
<li><a href='#pairData'><p>Pair-level simulated outbreak dataset</p></a></li>
<li><a href='#performNB'><p>Performs naive bayes classification</p></a></li>
<li><a href='#performPEM'><p>Executes the PEM algorthim to estimate the generation/serial interval distribution</p></a></li>
<li><a href='#plotRt'><p>Creates a plot of the effective reproductive number</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Naive Bayes Transmission Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-30</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sarah V Leavitt &lt;sv1205@bu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates the relative transmission probabilities between cases in an infectious disease outbreak or cluster using naive Bayes. Included are various functions to use these probabilities to estimate transmission parameters such as the generation/serial interval and reproductive number as well as finding the contribution of covariates to the probabilities and visualizing results. The ideal use is for an infectious disease dataset with metadata on the majority of cases but more informative data such as contact tracing or pathogen whole genome sequencing on only a subset of cases. For a detailed description of the methods see Leavitt et al. (2020) &lt;<a href="https://doi.org/10.1093%2Fije%2Fdyaa031">doi:10.1093/ije/dyaa031</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sarahleavitt.github.io/nbTransmission/">https://sarahleavitt.github.io/nbTransmission/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sarahleavitt/nbTransmission/issues">https://github.com/sarahleavitt/nbTransmission/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, rlang, caret, lubridate, poisbinom, stats, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, Hmisc, igraph, knitr, methods, pheatmap,
RColorBrewer, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 19:42:12 UTC; sevan</td>
</tr>
<tr>
<td>Author:</td>
<td>Sarah V Leavitt [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 20:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='clusterInfectors'>Clusters the infectors based on their transmission probabilities</h2><span id='topic+clusterInfectors'></span>

<h3>Description</h3>

<p>The function <code>clusterInfectors</code> uses either kernel density estimation or
hierarchical clustering to cluster the infectors for each infectee. This clustering
provides a way to separate out the few top possible infectors for each infectee
if there is such a cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterInfectors(
  df,
  indIDVar,
  pVar,
  clustMethod = c("n", "kd", "hc_absolute", "hc_relative"),
  cutoff
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterInfectors_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities (column <code>pVar</code>),
individual IDs (columns <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="clusterInfectors_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the individual ID columns
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="clusterInfectors_+3A_pvar">pVar</code></td>
<td>
<p>The name (in quotes) of the column with transmission probabilities.</p>
</td></tr>
<tr><td><code id="clusterInfectors_+3A_clustmethod">clustMethod</code></td>
<td>
<p>The method used to cluster the infectors; 
one of <code>"n", "kd", "hc_absolute", "hc_relative"</code> (see details).</p>
</td></tr>
<tr><td><code id="clusterInfectors_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff for clustering (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a way to find the most likely infectors for each infectee
using various clustering methods indicated by the <code>clustmethod</code>.
The methods can be one of <code>c("n", "kd", "hc_constant", "hc_relative")</code>.
</p>
<p>If <code>clustMethod == "n"</code> then this function simply assigns the top n possible 
infectors in the top cluster where n is defined by the value of <code>cutoff</code>.
</p>
<p>If <code>clustMethod == "kd"</code> then kernel density estimation is used to split the infectors.
The density for the probabilities for all infectors is estimated using a binwidth defined
by the value of <code>cutoff</code>. If the density is made up of at least two separate curves
(separated by a region where the density drops to 0) then the infectors with probabilities
greater than the lowest 0 region are assigned to the high probability cluster. If the density of the
probabilities does not drop to 0 then all infectors are assigned to the low probability cluster 
(indicating no real clustering).
</p>
<p>If <code>clustMethod == "hc_absolute"</code> or <code>clustMethod == "hc_relative"</code>, then
hierarchical clustering with minimum distance is used to split the possible infectors
into two clusters. This method functionally splits the infectors by the largest gap
in their probabilities.
</p>
<p>Then if <code>clustMethod == "hc_absolute"</code>, those infectees
where the gap between the two clusters is less than <code>cutoff</code> have all of their
possible infectors reassigned to the low probability cluster (indicating no real clustering).
If <code>clustMethod == "hc_relative"</code>, then all infectees where the gap between the two
clusters is less than <code>cutoff</code> times the second largest gap in probabilities
are reassigned to the low probability cluster (indicating no real clustering).
</p>


<h3>Value</h3>

<p>The original data frame (<code>df</code>) with a new column called <code>cluster</code>
which is a factor variable with value <code>1</code> if the infector is in the high probability cluster
or <code>2</code> if the infector is in the low probability cluster.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the nbResults data frame included in the package which has the results
## of the nbProbabilities() function on a TB-like outbreak.

## Clustering using top n
# High probability cluster includes infectors with highest 3 probabilities
clust1 &lt;- clusterInfectors(nbResults, indIDVar = "individualID", pVar = "pScaled",
                           clustMethod = "n", cutoff = 3)
table(clust1$cluster)

## Clustering using hierarchical clustering

# Cluster all infectees, do not force gap to be certain size
clust2 &lt;- clusterInfectors(nbResults, indIDVar = "individualID", pVar = "pScaled",
                            clustMethod = "hc_absolute", cutoff = 0)
table(clust2$cluster)


# Absolute difference: gap between top and bottom clusters is more than 0.05
clust3 &lt;- clusterInfectors(nbResults, indIDVar = "individualID", pVar = "pScaled",
                           clustMethod = "hc_absolute", cutoff = 0.05)
table(clust3$cluster)

# Relative difference: gap between top and bottom clusters is more than double any other gap
clust4 &lt;- clusterInfectors(nbResults, indIDVar = "individualID", pVar = "pScaled",
                           clustMethod = "hc_relative", cutoff = 2)
table(clust4$cluster)

## Clustering using kernel density estimation
# Using a small binwidth of 0.01
clust5 &lt;- clusterInfectors(nbResults, indIDVar = "individualID", pVar = "pScaled",
                           clustMethod = "kd", cutoff = 0.01)
table(clust5$cluster)


</code></pre>

<hr>
<h2 id='estimateR'>Estimates the effective reproductive number</h2><span id='topic+estimateR'></span>

<h3>Description</h3>

<p>The function <code>estimateR</code> uses the relative transmission probabilities to estimate
the individual-level, time-level, and average effective reproductive numbers
for an outbreak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateR(
  df,
  indIDVar,
  dateVar,
  pVar,
  timeFrame = c("days", "months", "weeks", "years"),
  rangeForAvg = NULL,
  bootSamples = 0,
  alpha = 0.05,
  progressBar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateR_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities (column <code>pVar</code>),
individual IDs (columns <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>), and the dates of
observation (columns <code>&lt;dateVar&gt;.1</code> and <code>&lt;dateVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="estimateR_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the individual ID columns
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="estimateR_+3A_datevar">dateVar</code></td>
<td>
<p>The name (in quotes) of the columns with the dates that the individuals are
observed (data frame <code>df</code> must have variables called <code>&lt;dateVar&gt;.1</code> and
<code>&lt;dateVar&gt;.2</code>) which must be date or date-time (POSIXt) objects.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_pvar">pVar</code></td>
<td>
<p>The column name (in quotes) of the transmission probabilities.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_timeframe">timeFrame</code></td>
<td>
<p>The time frame used to calculate Rt
(one of <code>"days", "months", "weeks", "years"</code>).</p>
</td></tr>
<tr><td><code id="estimateR_+3A_rangeforavg">rangeForAvg</code></td>
<td>
<p>A vector with the start and ending time period to be used to calculate
the average effective reproductive number.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_bootsamples">bootSamples</code></td>
<td>
<p>The number of bootstrap samples; if 0, then no confidence intervals
are calculated.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for the confidence intervals.</p>
</td></tr>
<tr><td><code id="estimateR_+3A_progressbar">progressBar</code></td>
<td>
<p>A logical indicating if a progress bar should be printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective reproductive number is the average number of cases an infectious case
will produce in a population of both susceptible and non-susceptibe individuals.
The rational behind this reproductive number estimation is Wallinga and Teunis (2004)
where the individual-level reproductive number is estimated by summing
the relative probability that the individual infected any other individual. 
</p>
<p>If <code class="reqn">p_{ij}</code> equals the relative probability that case <code class="reqn">i</code> was infected by
case <code class="reqn">j</code>, then the individual-level reproductive number (<code class="reqn">R_j</code>) is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">R_j = \sum_{m \ne j} {p_{mj}}</code>
</p>

<p>The time-level reproductive number is then estimated by averaging the individual-level
reproductive numbers for all individuals observed in the time frame (can specify days,
weeks, months, years).
</p>
<p>Finally, the time-level reproductive numbers are averaged to
estimate the average effective reproductive number within <code>rangeForAvg</code>.
To get the best estimate of the average effective reproductive number, one should
only consider the stable portion of the outbreak (exclude the beginning and end).
</p>
<p>If <code>bootSamples &gt; 0</code>, bootstrap confidence intervals will be estimated for
both the time-level and average reproductive numbers using parametric bootstrapping.
</p>


<h3>Value</h3>

<p>A list with five elements:
</p>

<ol>
<li> <p><code>RiDf</code> - a data frame with the individual-level reproductive numbers. Column names:
</p>

<ul>
<li> <p><code>&lt;indIDVar&gt;</code> - the individual ID with name specified.
</p>
</li>
<li> <p><code>&lt;dateVar&gt;</code> - the date the individual was observed with name specified.
</p>
</li>
<li> <p><code>Ri</code> - the individual-level reproductive number.
</p>
</li>
<li> <p><code>nInfectees</code> - the number of possible infectees for this individual.
</p>
</li></ul>

</li>
<li> <p><code>RtDf</code> - a data frame with the time-level reproductive numbers. Column names:
</p>

<ul>
<li> <p><code>time</code> - the time frame corresponding to the reproductive number estimate 
(day for &quot;days&quot; and &quot;weeks&quot;, month for &quot;months&quot;, year for &quot;years&quot;).
</p>
</li>
<li> <p><code>timeRank</code> - the rank of the time frame.
</p>
</li>
<li> <p><code>Rt</code> - the time-level reproductive number for this time frame.
</p>
</li>
<li> <p><code>ciLower</code> - lower bound of confidence interval for Rt
(only if bootSamples &gt; 0).
</p>
</li>
<li> <p><code>ciUpper</code> - upper bound of confidence interval for Rt 
(only if bootSamples &gt; 0).
</p>
</li></ul>

</li>
<li> <p><code>RtAvgDf</code> - a data frame with the average effective reproductive. Column names:
</p>

<ul>
<li> <p><code>RtAvg</code> - the average time-level reproductive number between the range
specified in <code>rangeForAvg</code>.
</p>
</li>
<li> <p><code>ciLower</code> - lower bound of confidence interval for Rt
(only if bootSamples &gt; 0).
</p>
</li>
<li> <p><code>ciUpper</code> - upper bound of confidence interval for Rt 
(only if bootSamples &gt; 0).
</p>
</li></ul>

</li>
<li> <p><code>timeFrame</code> - a vector with the timeFrame input
</p>
</li>
<li> <p><code>rangeForAvg</code> - a vector with the rangeForAvg input
</p>
</li></ol>



<h3>References</h3>

<p>Wallinga J, Teunis P. Different epidemic curves for severe acute respiratory
syndrome reveal similar impacts of control measures.
<em>American Journal of Epidemiology</em>. 2004 Sep 15;160(6):509-16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code> <code><a href="#topic+estimateRi">estimateRi</a></code>
<code><a href="#topic+estimateRt">estimateRt</a></code> <code><a href="#topic+estimateRtAvg">estimateRtAvg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the nbResults data frame included in the package which has the results
## of the nbProbabilities() function on a TB-like outbreak.

## Getting initial estimates of the reproductive number
# (without specifying rangeForAvg and without confidence intervals)
rInitial &lt;- estimateR(nbResults, dateVar = "infectionDate",
               indIDVar = "individualID", pVar = "pScaled",
               timeFrame = "months")
               
## Finding the stable portion of the outbreak for rangeForAvg using plot of Rt
cut1 &lt;- 25
cut2 &lt;- 125

# Optional plot to determine the cutpoints above
# ggplot(data = rInitial$RtDf, aes(x = timeRank, y = Rt)) +
#    geom_point() +
#    geom_line() +
#    geom_hline(data = rInitial$RtAvgDf, aes(yintercept = RtAvg), size = 0.7) +
#    geom_vline(aes(xintercept = cut1), linetype = 2, size = 0.7) +
#    geom_vline(aes(xintercept = cut2), linetype = 2, size = 0.7)
  
## Finding the final reproductive number estimates with confidence intervals
# NOTE should run with bootSamples &gt; 2.
rFinal &lt;- estimateR(nbResults, dateVar = "infectionDate",
             indIDVar = "individualID", pVar = "pScaled",
             timeFrame = "months", rangeForAvg = c(cut1, cut2),
             bootSamples = 2, alpha = 0.05)

rFinal$RtAvgDf

</code></pre>

<hr>
<h2 id='estimateRi'>Estimates individual-level reproductive numbers</h2><span id='topic+estimateRi'></span>

<h3>Description</h3>

<p>The function <code>estimateRi</code> uses relative transmission probabilities to estimate the
individual-level reproductive number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateRi(df, indIDVar, dateVar, pVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateRi_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities</p>
</td></tr>
<tr><td><code id="estimateRi_+3A_indidvar">indIDVar</code></td>
<td>
<p>The variable name (in quotes) of the individual ID varaibles 
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="estimateRi_+3A_datevar">dateVar</code></td>
<td>
<p>The variable name (in quotes) of the dates that the individuals
are observed (data frame <code>df</code>  must have variables called <code>&lt;dateVar&gt;.1</code>
and <code>&lt;dateVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="estimateRi_+3A_pvar">pVar</code></td>
<td>
<p>The variable name (in quotes) of the transmission probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be called by <code><a href="#topic+estimateR">estimateR</a></code>
which estimates the individual-level, time-level, and average reproductive numbers, 
but it can also be run directly.
</p>


<h3>Value</h3>

<p>A data frame with the individual-level reproductive numbers. Column names:
</p>

<ul>
<li> <p><code>&lt;indIDVar&gt;</code> - the individual ID with name specified.
</p>
</li>
<li> <p><code>&lt;dateVar&gt;</code> - the date the individual was observed with name specified.
</p>
</li>
<li> <p><code>Ri</code> - the individual-level reproductive number.
</p>
</li>
<li> <p><code>nInfectees</code> - the number of possible infectees for this individual.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+estimateR">estimateR</a></code> <code><a href="#topic+estimateRt">estimateRt</a></code> <code><a href="#topic+estimateRtAvg">estimateRtAvg</a></code>
</p>

<hr>
<h2 id='estimateRt'>Estimates time-level reproductive numbers</h2><span id='topic+estimateRt'></span>

<h3>Description</h3>

<p>The function <code>estimateRt</code> estimates the time-level effective reproductive number
from individual-level reproductive numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateRt(riData, dateVar, timeFrame = c("days", "weeks", "months", "years"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateRt_+3A_ridata">riData</code></td>
<td>
<p>The name of the dateset with individual-level reproductive numbers.</p>
</td></tr>
<tr><td><code id="estimateRt_+3A_datevar">dateVar</code></td>
<td>
<p>The variable name (in quotes) of the dates that the individuals are observed
(data frame <code>riData</code>  must have a variable called <code>&lt;dateVar&gt;</code>).</p>
</td></tr>
<tr><td><code id="estimateRt_+3A_timeframe">timeFrame</code></td>
<td>
<p>The time frame used to calculate Rt
(one of <code>"days", "months", "weeks", "years"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be called by <code><a href="#topic+estimateR">estimateR</a></code>
which estimates the individual-level and time-level, and average reproductive numbers, 
but it can also be run directly.
</p>


<h3>Value</h3>

<p>A data frame with the time-level reproductive numbers. Column names:
</p>

<ul>
<li> <p><code>time</code> - the time frame corresponding to the reproductive number estimate 
(day for &quot;days&quot; and &quot;weeks&quot;, month for &quot;months&quot;, year for &quot;years&quot;).
</p>
</li>
<li> <p><code>timeRank</code> - the rank of the time frame.
</p>
</li>
<li> <p><code>Rt</code> - the time-level reproductive number for this time frame.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+estimateR">estimateR</a></code> <code><a href="#topic+estimateRi">estimateRi</a></code> <code><a href="#topic+estimateRtAvg">estimateRtAvg</a></code>
</p>

<hr>
<h2 id='estimateRtAvg'>Estimates the average effective reproductive number</h2><span id='topic+estimateRtAvg'></span>

<h3>Description</h3>

<p>Averages the time-level reproductive numbers within a certain range to estimate the overall
reproductive number for an oubreak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateRtAvg(rtData, rangeForAvg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateRtAvg_+3A_rtdata">rtData</code></td>
<td>
<p>The name of the dateset with time-level reproductive numbers.</p>
</td></tr>
<tr><td><code id="estimateRtAvg_+3A_rangeforavg">rangeForAvg</code></td>
<td>
<p>A vector with the start and ending time period to be used to calculate the
average effective reproductive number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be called by <code><a href="#topic+estimateR">estimateR</a></code>
which estimates the individual-level and time-level, and average reproductive numbers,
but it can also be run directly.
</p>


<h3>Value</h3>

<p>A data frame with the average effective reproductive. Column names:
</p>

<ul>
<li> <p><code>RtAvg</code> - the average time-level reproductive number between the range
specified in <code>rangeForAvg</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+estimateR">estimateR</a></code> <code><a href="#topic+estimateRi">estimateRi</a></code> <code><a href="#topic+estimateRt">estimateRt</a></code>
</p>

<hr>
<h2 id='estimateSI'>Estimates the generation/serial interval distribution</h2><span id='topic+estimateSI'></span>

<h3>Description</h3>

<p>The function <code>estimateSI</code> uses the relative transmission probabilities to estimate
the generation/serial interval distribution assuming a gamma distribution.
It uses the PEM algorithm developed by Hens et al. 2012 extending their method to include
restricting analysis to the top cluster of possible infectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSI(
  df,
  indIDVar,
  timeDiffVar,
  pVar,
  clustMethod = c("none", "n", "kd", "hc_absolute", "hc_relative"),
  cutoffs = NULL,
  initialPars,
  shift = 0,
  epsilon = 1e-05,
  bootSamples = 0,
  alpha = 0.05,
  progressBar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateSI_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities (column <code>pVar</code>),
individual IDs (columns <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>), and difference
in time between the pair of cases (column <code>timeDiffVar</code>)</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the individual ID columns
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_timediffvar">timeDiffVar</code></td>
<td>
<p>The name (in quotes) of the column with the difference
in time between infection (generation interval) or symptom onset (serial interval) for the
pair of cases. The units of this variable (hours, days, years) defines the units of the 
resulting distribution.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_pvar">pVar</code></td>
<td>
<p>The column name (in quotes) of the transmission probabilities.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_clustmethod">clustMethod</code></td>
<td>
<p>The method used to cluster the infectors; one of 
<code>"none", "n", "kd", "hc_absolute", "hc_relative"</code> where <code>"none"</code> or
not specifying a value means use all pairs with no clustering
(see <code><a href="#topic+clusterInfectors">clusterInfectors</a></code> for detials on clustering methods).</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_cutoffs">cutoffs</code></td>
<td>
<p>A vector of cutoffs for clustering (see <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>).
If more than one cutoff is provided, a pooled estimate will also be provided.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_initialpars">initialPars</code></td>
<td>
<p>A vector of length two with the shape and scale 
to initialize the gamma distribution parameters.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_shift">shift</code></td>
<td>
<p>A value in the same units as <code>timeDiffVar</code> that the
gamma distribution should be shifted. The default value of 0 is an 
unmodifed gamma distribution.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_epsilon">epsilon</code></td>
<td>
<p>The difference between successive estimates of the shape and
scale parameters that indicates convergence.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_bootsamples">bootSamples</code></td>
<td>
<p>The number of bootstrap samples; if 0, then no confidence intervals
are calculated.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for the confidence intervals.</p>
</td></tr>
<tr><td><code id="estimateSI_+3A_progressbar">progressBar</code></td>
<td>
<p>A logical indicating if a progress bar should be printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PEM algorithm uses the prior probability that each pair is connected by direct
transmission to estimate the generation/serial interval using estimation maximization.
This code will provide an estimate of the generation interval if <code>timeDiffVar</code> represents the
difference in infection dates and the serial interval if it represents the difference in symptom onset dates.
The current generation/serial interval distribution parameters are used to update the probabilities
which are then used to update the generation/serial interval distribution parameters. The process
continues until the parameters converge (indicated by a change of less than <code>epsilon</code>)
between iterations. <em>Note: time difference between pairs should not be used to 
estimate the probabilities</em>
</p>
<p>This function acts as a wrapper around <code><a href="#topic+performPEM">performPEM</a></code> which integrates
estimation of the generation/serial interval distribution with clustering the infectors and calculates
derived parameters (mean, median, sd) of the distribution. Generally, this function
should be called instead of <code><a href="#topic+performPEM">performPEM</a></code> directly.
</p>
<p>All pairs of cases can be used in the estimation process by setting
<code>clustMethod = "none"</code>. However, if the probabilities are from a algorithm such as
<code><a href="#topic+nbProbabilities">nbProbabilities</a></code>, then it is recommeneded to use a clustering method
and only include the top cluster of infectors for infectees which have such a cluster.
This can be specified by using the <code>clustMethod</code> and <code>cutoff</code> arguments which
are passed into <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>. See the details of this function for
a description of the different clustering methods.
</p>
<p>The method can be performed with any generation/serial interval distribution,
but this version of this function assumes that the generation/serial interval has a gamma distribution.
The function does allow for a shifted gamma distribution. The <code>shift</code> argument
defines how much the gamma distribution should be shifted. Any observed generation/serial intervals
that are less than this shift will have probability 0. This parameter should be used if 
there is a clinical lower bound for the possible generation/serial interval. If this argument
is not specified then an unmodified gamma function is used. The units of the
estimated gamma distribution will be defined by the units of the provided
<code>&lt;timeDiffVar&gt;</code> column. The value of the <code>shift</code> should be in the same units.
</p>
<p>The algorithm requires initial parameters which should be specified as a vector: 
<code>c(&lt;shape&gt;, &lt;scale&gt;)</code>. These parameters should result in a gamma distribution
that is on the desired scale, set by the <code>&lt;timeDiffVar&gt;</code> column.
</p>
<p>If <code>bootSamples &gt; 0</code>, bootstrap confidence intervals will be estimated for
both the shape and scale parameters as well as the mean, median, and mode of the
distribution using cluster bootstrapping.
</p>


<h3>Value</h3>

<p>A data frame with one row and the following columns:
</p>

<ul>
<li> <p><code>nIndividuals</code> - the number of infectees who have intervals included in the estimate.
</p>
</li>
<li> <p><code>pCluster</code> - the proportion of cases who have intervals included in the estimate.
</p>
</li>
<li> <p><code>nInfectors</code> - the average number of infectors in the top cluster.
</p>
</li>
<li> <p><code>shape</code> - the shape of the estimated gamma distribution for the interval
</p>
</li>
<li> <p><code>scale</code> - the scale of the estimated gamma distribution for the interval
</p>
</li>
<li> <p><code>meanSI</code> - the mean of the estimated gamma distribution for the interval 
(<code>shape * scale + shift</code>)
</p>
</li>
<li> <p><code>medianSI</code> - the median of the estimated gamma distribution for the interval
(<code>qgamma(0.5, shape, scale) + shift)</code>)
</p>
</li>
<li> <p><code>sdSI</code> - the standard deviation of the estimated gamma distribution for
the interval (<code>shape * scale ^ 2</code>)
</p>
</li></ul>

<p>If bootSamples &gt; 0, then the data frame also includes the following columns:
</p>

<ul>
<li> <p><code>shapeCILB</code> and <code>shapeCIUB</code> - lower bound and upper bounds
of the bootstrap confidence interval for the shape parameter
</p>
</li>
<li> <p><code>scaleCILB</code> and <code>scaleCIUB</code> - lower bound and upper bounds
of the bootstrap confidence interval for the scale parameter
</p>
</li>
<li> <p><code>meanCILB</code> and <code>meanCIUB</code> - lower bound and upper bounds
of the bootstrap confidence interval for the mean of the interval distribution
</p>
</li>
<li> <p><code>medianCILB</code> and <code>medianCIUB</code> - lower bound and upper bounds
of the bootstrap confidence interval for the median of the interval distribution
</p>
</li>
<li> <p><code>sdCILB</code> and <code>sdCIUB</code> - lower bound and upper bounds
of the bootstrap confidence interval for the sd of the interval distribution
</p>
</li></ul>



<h3>References</h3>

<p>Hens N, Calatayud L, Kurkela S, Tamme T, Wallinga J. Robust reconstruction and
analysis of outbreak data: influenza A (H1N1) v transmission in a school-based 
population. <em>American Journal of Epidemiology</em>. 2012 Jul 12;176(3):196-203.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code> <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>
<code><a href="#topic+performPEM">performPEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, run the algorithm without including time as a covariate.
orderedPair &lt;- pairData[pairData$infectionDiffY &gt; 0, ]

## Create a variable called snpClose that will define probable links
# (&lt;3 SNPs) and nonlinks (&gt;12 SNPs) all pairs with between 2-12 SNPs
# will not be used to train.
orderedPair$snpClose &lt;- ifelse(orderedPair$snpDist &lt; 3, TRUE,
                        ifelse(orderedPair$snpDist &gt; 12, FALSE, NA))
table(orderedPair$snpClose)

## Running the algorithm
# NOTE should run with nReps &gt; 1.
resGen &lt;- nbProbabilities(orderedPair = orderedPair,
                            indIDVar = "individualID",
                            pairIDVar = "pairID",
                            goldStdVar = "snpClose",
                            covariates = c("Z1", "Z2", "Z3", "Z4"),
                            label = "SNPs", l = 1,
                            n = 10, m = 1, nReps = 1)
                            
## Merging the probabilities back with the pair-level data
nbResultsNoT &lt;- merge(resGen[[1]], orderedPair, by = "pairID", all = TRUE)

## Estimating the serial interval

# Using hierarchical clustering with a 0.05 absolute difference cutoff
estimateSI(nbResultsNoT, indIDVar = "individualID",
             timeDiffVar = "infectionDiffY", pVar = "pScaled",
             clustMethod = "hc_absolute", cutoff = 0.05, initialPars = c(2, 2))
             

# Using all pairs
estimateSI(nbResultsNoT, indIDVar = "individualID",
              timeDiffVar = "infectionDiffY", pVar = "pScaled",
              clustMethod = "none", initialPars = c(2, 2))


# # Using a shifted gamma distribution:
# # not allowing serial intervals of less than 3 months (0.25 years)
estimateSI(nbResultsNoT, indIDVar = "individualID",
              timeDiffVar = "infectionDiffY", pVar = "pScaled",
              clustMethod = "hc_absolute", cutoff = 0.05,
              initialPars = c(2, 2), shift = 0.25)


# # Using multiple cutoffs
estimateSI(nbResultsNoT, indIDVar = "individualID",
              timeDiffVar = "infectionDiffY", pVar = "pScaled",
              clustMethod = "hc_absolute", cutoff = c(0.025, 0.05), initialPars = c(2, 2))



## Adding confidence intervals
# NOTE should run with bootSamples &gt; 2.
estimateSI(nbResultsNoT, indIDVar = "individualID",
             timeDiffVar = "infectionDiffY", pVar = "pScaled",
             clustMethod = "hc_absolute", cutoff = 0.05,
             initialPars = c(2, 2), shift = 0.25, bootSamples = 2)

</code></pre>

<hr>
<h2 id='indData'>Individual-level simulated outbreak dataset</h2><span id='topic+indData'></span>

<h3>Description</h3>

<p>A dataset of an outbreak of 100 individuals starting from one case.
It was simulated with using the package TransPhylo with parameters resembling TB:
</p>

<ul>
<li><p> average reproductive number = 1.2
</p>
</li>
<li><p> generation interval = gamma(1.2, 2) years
</p>
</li>
<li><p> outbreak duration = 14 years
</p>
</li>
<li><p> mutation rate 0.5 snps/genome/year
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>indData
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 8 variables:
</p>

<dl>
<dt>individualID</dt><dd><p>An individual-level id for each case.</p>
</dd>
<dt>infector</dt><dd><p>The individualID of the true infector.</p>
</dd>
<dt>infectionDate</dt><dd><p>The date and time of infection.</p>
</dd>
<dt>sampleDate</dt><dd><p>The date and time of sampling.</p>
</dd>
<dt>X1</dt><dd><p>Covariate with 2 values: a, b (e.g. sex).</p>
</dd>
<dt>X2</dt><dd><p>Covariate with 4 values: a, b, c, d (e.g. nationality).</p>
</dd>
<dt>X3</dt><dd><p>Covariate with 2 values: a, b (e.g. homelessness).</p>
</dd>
<dt>X4</dt><dd><p>Covariate with 10 values: a-j (e.g. county of residence).</p>
</dd>
</dl>



<h3>References</h3>

<p>Didelot X, Fraser C, Gardy J, Colijn C. Genomic Infectious Disease Epidemiology in Partially
Sampled and Ongoing Outbreaks. Mol Biol Evol. 2017;34(4):997-1007.
</p>

<hr>
<h2 id='indToPair'>Transforms a dataset of individuals to a dataset of pairs</h2><span id='topic+indToPair'></span>

<h3>Description</h3>

<p>The function <code>indToPair</code> takes a dataset of observations (such as individuals in an infectious
disease outbreak) and transforms it into a dataset of pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indToPair(
  indData,
  indIDVar,
  separator = "_",
  dateVar = NULL,
  units = c("mins", "hours", "days", "weeks"),
  ordered = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indToPair_+3A_inddata">indData</code></td>
<td>
<p>An individual-level dataframe.</p>
</td></tr>
<tr><td><code id="indToPair_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the column with the individual ID.</p>
</td></tr>
<tr><td><code id="indToPair_+3A_separator">separator</code></td>
<td>
<p>The character to be used to separate the individual IDs when creating
the pairID.</p>
</td></tr>
<tr><td><code id="indToPair_+3A_datevar">dateVar</code></td>
<td>
<p>The name (in quotes) of the column with the dates that the individuals are observed
(optional unless <code>ordered = TRUE</code>). This column must be a date or date-time (POSIXt) object.
If supplied, the time difference between individuals will be calculated in the units specified.</p>
</td></tr>
<tr><td><code id="indToPair_+3A_units">units</code></td>
<td>
<p>The units for the time difference, only necessary if <code>dateVar</code> is supplied.
Must be one of <code>"mins", "hours", "days", "weeks"</code>.</p>
</td></tr>
<tr><td><code id="indToPair_+3A_ordered">ordered</code></td>
<td>
<p>A logical indicating if a set of ordered pairs should be returned
(<code>&lt;dateVar&gt;.1</code> before <code>&lt;dateVar&gt;.2</code> or <code>&lt;dateVar&gt;.1</code> = <code>&lt;dateVar&gt;.2</code>).
If FALSE a dataframe of all pairs will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires an id column: <code>indIDVar</code> to identify the individual observations.
The resulting pair-level dataframe will have a <code>pairID</code> column which combines the individual IDs
for that pair.
</p>
<p>The function can either output all possible pairs (<code>ordered = FALSE</code>) or only ordered pairs 
(<code>ordered = TRUE</code>) where the ordered is determined by a date variable (<code>dateVar</code>).
If <code>orded = TRUE</code>, then <code>dateVar</code> must be provided and if <code>ordered = FALSE</code>,
it is optional. In both cases, if <code>dateVar</code> is provided, the output will include the time
difference between the individuals in the pair in the <code>units</code> specified (&quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, &quot;weeks&quot;).
</p>


<h3>Value</h3>

<p>A dataframe of either all possible pairs of individuals (<code>ordered = FALSE</code>) or ordered
pairs of individuals (<code>ordered = TRUE</code>). The dataframe will have all of the original variables
with suffixes &quot;.1&quot; and &quot;.2&quot; corresponding to the original values of 
<code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>.
</p>
<p>Added to the dataframe will be a column called <code>pairID</code> which is <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code> separated by <code>separator</code>.
</p>
<p>If dateVar is provided the dataframe will also include variables <code>&lt;dateVar&gt;.Diff</code> giving 
the difference of time of <code>dateVar</code> for <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code> 
in the units specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a dataset of all pairs with no date variable
pairU &lt;- indToPair(indData = indData, indIDVar = "individualID")

## Create a dataset of all pairs with a date variable
pairUD &lt;- indToPair(indData = indData, indIDVar = "individualID",
                      dateVar = "infectionDate", units = "days")

## Create a dataset of ordered pairs
pairO &lt;- indToPair(indData = indData, indIDVar = "individualID",
                     dateVar = "infectionDate", units = "days", ordered = TRUE)

</code></pre>

<hr>
<h2 id='nbHeatmap'>Plots a heatmap of the relative transmission probabilities</h2><span id='topic+nbHeatmap'></span>

<h3>Description</h3>

<p>The function <code>nbHeatmap</code> plots a heatmap of the transmission probabilities.
The rows are the possible infectors and the columns are the possible infectees both
ordered by <code>&lt;dateVar&gt;</code>. The darker the square the higher the probability that
the pair represented by that square is a transmission link. If a cluster method is specified 
using <code>clustMethod</code> and <code>cutoff</code>, then stars will be drawn in the squares of the
infectors in the top cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbHeatmap(
  df,
  indIDVar,
  dateVar,
  pVar,
  clustMethod = c("none", "n", "kd", "hc_absolute", "hc_relative"),
  cutoff = NA,
  blackAndWhite = FALSE,
  probBreaks = c(-0.01, 0.001, 0.005, 0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbHeatmap_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities (column <code>pVar</code>),
individual IDs (columns <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>), and the dates of
observation (columns <code>&lt;dateVar&gt;.1</code> and <code>&lt;dateVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the individual ID columns
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_datevar">dateVar</code></td>
<td>
<p>The name (in quotes) of the columns with the dates that the individuals are
observed (data frame <code>df</code> must have variables called <code>&lt;dateVar&gt;.1</code> and
<code>&lt;dateVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_pvar">pVar</code></td>
<td>
<p>The name (in quotes) of the column with transmission probabilities.</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_clustmethod">clustMethod</code></td>
<td>
<p>The method used to cluster the infectors; one of 
<code>"none", "n", "kd", "hc_absolute", "hc_relative"</code> where <code>"none"</code> or
not specifying a value means use all pairs with no clustering
(see <code><a href="#topic+clusterInfectors">clusterInfectors</a></code> for detials on clustering methods).</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff for clustering (see <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>).</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_blackandwhite">blackAndWhite</code></td>
<td>
<p>A logical. If <code>TRUE</code>, then the squares are colored in greyscale,
if <code>FALSE</code>, then the squares are colored with shades of blue.</p>
</td></tr>
<tr><td><code id="nbHeatmap_+3A_probbreaks">probBreaks</code></td>
<td>
<p>A numeric vector containing between 3 and 10 elements specifying the
boundaries used to classify the probabilities and color the squares.
The first element should be less than 0 and the last should be 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users have the option of specifying how the probabilities should be grouped into different
color shades through the argument <code>probBreaks</code>. The probabilities are split into groups by
using <code>probBreaks</code> as the <code>breaks</code> argument in <code><a href="base.html#topic+cut">cut</a></code> with the default options.
The length of the vector should be between 3 and 10 and the first element should be less than 0 and 
the last 1 so that all probabilities are guarenteed to be classified.
The colors are defined with the code <code>brewer.pal(length(probBreaks) - 1, "Blues")</code>
(where &quot;Blues&quot; is replaced by &quot;Greys&quot; if <code>blackAndWhite</code> is set to <code>TRUE</code>).
</p>
<p><strong>NOTE: This plot will take long to run and may not look good with
larger outbreaks (&gt;200 individuals)</strong>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code> <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Heatmap with no clustering in color with the default probability breaks
par(mar = c(0, 0, 1, 0))
nbHeatmap(nbResults, indIDVar = "individualID", dateVar = "infectionDate",
pVar = "pScaled", clustMethod = "none")
dev.off() 


## Adding stars for the top cluster, in black and white, changing the probability breaks
par(mar = c(0, 0, 1, 0))
nbHeatmap(nbResults, indIDVar = "individualID", dateVar = "infectionDate",
          pVar = "pScaled", clustMethod = "hc_absolute", cutoff = 0.05,
          blackAndWhite = TRUE, probBreaks = c(-0.01, 0.01, 0.1, 0.25, 0.5, 1))
dev.off()



</code></pre>

<hr>
<h2 id='nbNetwork'>Plots a network of the relative transmission probabilities</h2><span id='topic+nbNetwork'></span>

<h3>Description</h3>

<p>The function <code>nNetwork</code> plots a network of the transmission probabilities.
The nodes are the individuals and the edges represent possible transmission pairs.
The darker the edge, the higher the probability that the pair is a transmission link.
If a cluster method is specified using <code>clustMethod</code> and <code>cutoff</code>, only edges
that are in the high probability cluster of infectors will be drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbNetwork(
  df,
  indIDVar,
  dateVar,
  pVar,
  clustMethod = c("none", "n", "kd", "hc_absolute", "hc_relative"),
  cutoff = NA,
  blackAndWhite = FALSE,
  probBreaks = c(-0.01, 0.001, 0.005, 0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbNetwork_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities (column <code>pVar</code>),
individual IDs (columns <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>), and the dates of
observation (columns <code>&lt;dateVar&gt;.1</code> and <code>&lt;dateVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the individual ID columns
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_datevar">dateVar</code></td>
<td>
<p>The name (in quotes) of the columns with the dates that the individuals are
observed (data frame <code>df</code> must have variables called <code>&lt;dateVar&gt;.1</code> and
<code>&lt;dateVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_pvar">pVar</code></td>
<td>
<p>The name (in quotes) of the column with transmission probabilities.</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_clustmethod">clustMethod</code></td>
<td>
<p>The method used to cluster the infectors; one of 
<code>"none", "n", "kd", "hc_absolute", "hc_relative"</code> where <code>"none"</code> or
not specifying a value means use all pairs with no clustering
(see <code><a href="#topic+clusterInfectors">clusterInfectors</a></code> for detials on clustering methods).</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff for clustering (see <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>).</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_blackandwhite">blackAndWhite</code></td>
<td>
<p>A logical. If <code>TRUE</code>, then the edges are colored in greyscale,
if <code>FALSE</code>, then the edges are colored with shades of blue.</p>
</td></tr>
<tr><td><code id="nbNetwork_+3A_probbreaks">probBreaks</code></td>
<td>
<p>A numeric vector containing between 3 and 10 elements specifying the
boundaries used to classify the probabilities and color the edges.
The first element should be less than 0 and the last should be 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users have the option of specifying how the probabilities should be grouped into different
color shades through the argument <code>probBreaks</code>. The probabilities are split into groups by
using <code>probBreaks</code> as the <code>breaks</code> argument in <code><a href="base.html#topic+cut">cut</a></code> with the default options.
The length of the vector should be between 3 and 10 and the first element should be less than 0 and 
the last 1 so that all probabilities are guarenteed to be classified.
The colors are defined with the code <code>brewer.pal(length(probBreaks) - 1, "Blues")</code>
(where &quot;Blues&quot; is replaced by &quot;Greys&quot; if <code>blackAndWhite</code> is set to <code>TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code> <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Network of all pairs in color with the default probability breaks
par(mar = c(0, 0, 0.2, 0))
nbNetwork(nbResults, indIDVar = "individualID", dateVar = "infectionDate",
pVar = "pScaled", clustMethod = "none")
dev.off()


## Network of just the top cluster of infectors, black and white, changing the probability breaks
par(mar = c(0, 0, 0.2, 0))
nbNetwork(nbResults, indIDVar = "individualID", dateVar = "infectionDate",
          pVar = "pScaled", clustMethod = "hc_absolute", cutoff = 0.05,
          blackAndWhite = TRUE, probBreaks = c(-0.01, 0.01, 0.1, 0.25, 0.5, 1))
dev.off()         



</code></pre>

<hr>
<h2 id='nbProbabilities'>Estimates relative transmission probabilities</h2><span id='topic+nbProbabilities'></span>

<h3>Description</h3>

<p>The function <code>nbProbabilities</code> uses naive Bayes and an interative estimation
procedure to estimate relative transmission probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbProbabilities(
  orderedPair,
  indIDVar,
  pairIDVar,
  goldStdVar,
  covariates,
  label = "",
  l = 1,
  n = 10,
  m = 1,
  nReps = 10,
  progressBar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbProbabilities_+3A_orderedpair">orderedPair</code></td>
<td>
<p>The name of the ordered pair-level dataset with the covariates.</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the column with the individual ID. 
(data frame <code>orderedPair</code> must have columns called <code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_pairidvar">pairIDVar</code></td>
<td>
<p>The name (in quotes) of the column with the unique pair ID variable.</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_goldstdvar">goldStdVar</code></td>
<td>
<p>The name (in quotes) of the column with a logical vector defining
training links/non-links</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_covariates">covariates</code></td>
<td>
<p>A character vector containing the covariate column names (in quotes).
All covariates need to be categorical factor variables.</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_label">label</code></td>
<td>
<p>An optional label string for the run.</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_l">l</code></td>
<td>
<p>Laplace smoothing parameter that is added to each cell.</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_n">n</code></td>
<td>
<p>The number of folds for nxm cross validation (should be at least 10).</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_m">m</code></td>
<td>
<p>The number of times to create n folds in nxm cross validation.</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_nreps">nReps</code></td>
<td>
<p>The number of times to randomly select the &quot;true&quot; infector (should be at least 10).</p>
</td></tr>
<tr><td><code id="nbProbabilities_+3A_progressbar">progressBar</code></td>
<td>
<p>A logical indicating if a progress bar should be printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm takes a dataset of ordered possible infector-infectee pairs in an
infectious disease outbreak or cluster and estimates the relative probability the cases are
linked by direct transmission using a classification technique called naive Bayes (NB).
NB is a simple machine learning algorithm that uses Bayes rule to estimate the
probability of an outcome in a prediction dataset given a set of covariates from
the observed frequencies in a training dataset.
</p>
<p>The input dataset - <code>orderedPair</code> - should represent ordered pairs of cases
(where the potential infector was observed before the infectee) and have
a unique identifier for each pair (<code>pairIDVar</code>) as well as the individual ids that are
included in the pair (<code>&lt;indIDVar&gt;.1</code> and <code>&lt;indIDVar&gt;.2</code>). If cases are concurrent
(meaning the order cannot determined) both orders can be included.
</p>
<p>A subset of pairs should also have pathogen WGS, contact investigation,  or some other
'gold standard' defined by <code>goldStdVar</code> which should be a logical vector with
<code>TRUE</code> indicating links, <code>FALSE</code> nonlinks, and <code>NA</code> if
the pair cannot be used to train (does not have the information or is indeterminate).
These pairs will be used to a training dataset of probable links and non/links.
The covariates can be any categorical variables and could represent
spatial, clinical, demographic, and temporal characteristics of the case pair. 
</p>
<p>Because the outcomes in the training set represent probable and not certain 
transmission events and a given case could have mulitple probable infectors, 
the algorithm uses an iterative estimation procedure. This procedure randomly chooses one
link of all of the possible links to include in the training dataset <code>nReps</code>
times, and then uses <code>mxn</code> cross prediction to give all pairs a turn 
in the prediction dataset.
</p>
<p>The output of this function is a list of two dataframes: one with the estimates of the
transmission probabilities (<code>probabilities</code>) and the other with the contribution of
the covariates to the probabilities in the form of odds ratios (<code>estimates</code>). The 
95
for multiple imputation, to pool the error across all iterations.
</p>


<h3>Value</h3>

<p>List containing two data frames:
</p>

<ol>
<li> <p><code>probabilities</code> - a data frame of transmission probabilities. Column names:
</p>

<ul>
<li> <p><code>label</code> - the optional label of the run.
</p>
</li>
<li> <p><code>&lt;pairIDVar&gt;</code> - the pair ID with the name specified.
</p>
</li>
<li> <p><code>pAvg</code> - the mean transmission probability for the pair over all iterations.
</p>
</li>
<li> <p><code>pSD</code> - the standard deviation of the transmission probability for the pair
over all iterations.
</p>
</li>
<li> <p><code>pScaled</code> - the mean relative transmission probability for the pair over.
all iterations: pAvg scaled so that the probabilities for all infectors per infectee add to 1.
</p>
</li>
<li> <p><code>pRank</code> - the rank of the probability of the the pair out of all pairs for that
infectee (in case of ties all values have the minimum rank of the group).
</p>
</li>
<li> <p><code>nEstimates</code> - the number of probability estimates that contributed to pAvg. This
represents the number of prediction datasets this pair was included in over the <code>nxm</code>
cross prediction repeated <code>nReps</code> times.
</p>
</li></ul>

</li>
<li> <p><code>estimates</code> - a data frame with the contribution of covariates. Column names:
</p>

<ul>
<li> <p><code>label</code> - the optional label of the run
</p>
</li>
<li> <p><code>level</code> - the covariate name and level
</p>
</li>
<li> <p><code>nIter</code> - the number of iterations included in the estimates: <code>n*m*nReps</code>
</p>
</li>
<li> <p><code>logorMean</code> - the mean value of the log odds ratio across iterations
</p>
</li>
<li> <p><code>logorSE</code> - the standard error of the log odds ratio across iterations
</p>
</li>
<li> <p><code>logorCILB</code> - the lower bound of the 95
across iterations
</p>
</li>
<li> <p><code>logorCIUB</code> - the upper bound of the 95
across iterations
</p>
</li></ul>

</li></ol>



<h3>References</h3>

<p>Barnard J. and Rubin D. Small-Sample Degrees of Freedom with Multiple Imputation
<em>Biometrika</em>. 1999 Dec;86(4):948-55.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the pairData dataset which represents a TB-like outbreak
# First create a dataset of ordered pairs
orderedPair &lt;- pairData[pairData$infectionDiffY &gt;= 0, ]

## Create a variable called snpClose that will define probable links
# (&lt;3 SNPs) and nonlinks (&gt;12 SNPs) all pairs with between 2-12 SNPs
# will not be used to train.
orderedPair$snpClose &lt;- ifelse(orderedPair$snpDist &lt; 3, TRUE,
                        ifelse(orderedPair$snpDist &gt; 12, FALSE, NA))
table(orderedPair$snpClose)

## Running the algorithm
#NOTE should run with nReps &gt; 1.
resGen &lt;- nbProbabilities(orderedPair = orderedPair,
                            indIDVar = "individualID",
                            pairIDVar = "pairID",
                            goldStdVar = "snpClose",
                            covariates = c("Z1", "Z2", "Z3", "Z4", "timeCat"),
                            label = "SNPs", l = 1,
                            n = 10, m = 1, nReps = 1)
                            
## Merging the probabilities back with the pair-level data
nbResults &lt;- merge(resGen[[1]], orderedPair, by = "pairID", all = TRUE)

</code></pre>

<hr>
<h2 id='nbResults'>Dataset with results of <code><a href="#topic+nbProbabilities">nbProbabilities</a></code></h2><span id='topic+nbResults'></span>

<h3>Description</h3>

<p>A ordered dataset created from <code><a href="#topic+pairData">pairData</a></code> of the outbreak of 100 individuals 
including the relative transmission probabilities for each pair estimated using the function
<code><a href="#topic+nbProbabilities">nbProbabilities</a></code>. The code to recreate this dataset from <code><a href="#topic+pairData">pairData</a></code> 
is shown below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbResults
</code></pre>


<h3>Format</h3>

<p>A data frame with 9900 rows and 24 variables:
</p>

<dl>
<dt>pairID</dt><dd><p>A pair-level ID variable (the individual IDs separated by an '_').</p>
</dd>
<dt>label</dt><dd><p>The label for the run, here &quot;SNPs&quot;.</p>
</dd>
<dt>pAvg</dt><dd><p>The mean transmission probability for the pair over all runs.</p>
</dd>
<dt>pSD</dt><dd><p>The standard deviation of the transmission probability for the pair over all runs.</p>
</dd>
<dt>pScaled</dt><dd><p>The mean relative transmission probability for the pair over
all runs: pAvg scaled so that the probabilities for all infectors per infectee add to 1.</p>
</dd>
<dt>pRank</dt><dd><p>The rank of the probability of the the pair out of all pairs for that
infectee (in case of ties all values have the minimum rank of the group).</p>
</dd>
<dt>nSamples</dt><dd><p>The number of probability estimates that contributed to pAvg. This
represents the number of prediction datasets this pair was included in over the 10x1
cross prediction repeated 50 times.</p>
</dd>
<dt>individualID.1</dt><dd><p>The ID of the potential &quot;infector&quot;.</p>
</dd>
<dt>individualID.2</dt><dd><p>The ID of the potential &quot;infectee&quot;.</p>
</dd>
<dt>transmission</dt><dd><p>Did individual.1 truly infect individual.2?</p>
</dd>
<dt>snpDist</dt><dd><p>The number of SNPs between the individuals.</p>
</dd>
<dt>infectionDate.1</dt><dd><p>The date and time of infection of individualID.1.</p>
</dd>
<dt>infectionDate.2</dt><dd><p>The date and time of infection of individualID.2.</p>
</dd>
<dt>sampleDate.1</dt><dd><p>The date and time of sampling of individualID.1.</p>
</dd>
<dt>sampleDate.2</dt><dd><p>The date and time of sampling of individualID.2.</p>
</dd>
<dt>sampleDiff</dt><dd><p>The number of days between sampleDate.1 and sampleDate.2.</p>
</dd>
<dt>infectionDiff</dt><dd><p>The number of days between infectionDate.1 and infectionDate.2.</p>
</dd>
<dt>infectionDiffY</dt><dd><p>The number of years between infectionDate.1 and infectionDate.2.</p>
</dd>
<dt>timeCat</dt><dd><p>A categorical representation of infectionDiff: &lt;1y, 1-2y, 2-3y, 3-4y, 4-5y, &gt;5y.</p>
</dd>
<dt>Z1</dt><dd><p>Pair-level covariate derived from X1: 1 if match, 0 if not match.</p>
</dd>
<dt>Z2</dt><dd><p>Pair-level covariate derived from X2: 1 if match, 0 if not match.</p>
</dd>
<dt>Z3</dt><dd><p>Pair-level covariate derived from X3: 1 if a-a, 2 if b-b, 3 if a-b, 4 if b-a.</p>
</dd>
<dt>Z4</dt><dd><p>Pair-level covariate derived from X4: 1 if match, 2 if adjacent, 2 otherwise.</p>
</dd>
<dt>snpClose</dt><dd><p>Logical value indicating if a pair is a probable link. 
TRUE if the pair has fewer than 3 SNPs, FALSE if the pair has more than 12 SNPs, NA otherwise</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# ## NOT RUN ##
# ## This is the code used to create this dataset ##
# orderedPair &lt;- pairData[pairData$infectionDiff &gt; 0, ]
# orderedPair$snpClose &lt;- ifelse(orderedPair$snpDist &lt; 3, TRUE,
#                         ifelse(orderedPair$snpDist &gt; 12, FALSE, NA))
# set.seed(0)
# covariates = c("Z1", "Z2", "Z3", "Z4", "timeCat")
# resGen &lt;- nbProbabilities(orderedPair = orderedPair,
#                             indIDVar = "individualID",
#                             pairIDVar = "pairID",
#                             goldStdVar = "snpClose",
#                             covariates = covariates,
#                             label = "SNPs", l = 1,
#                             n = 10, m = 1, nReps = 50)
# nbResults &lt;- merge(resGen[[1]], orderedPair, by = "pairID", all = TRUE)
</code></pre>

<hr>
<h2 id='pairData'>Pair-level simulated outbreak dataset</h2><span id='topic+pairData'></span>

<h3>Description</h3>

<p>A dataset of all pairs (unordered) of the outbreak of 100 individuals 
described in <code><a href="#topic+indData">indData</a></code> with SNP distance between each pair. Genomes were
simulated using the package phangorn from the phylogentic tree created
during the outbreak simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairData
</code></pre>


<h3>Format</h3>

<p>A data frame with 9900 rows and 17 variables:
</p>

<dl>
<dt>pairID</dt><dd><p>A pair-level ID variable (the individual IDs separated by an '_').</p>
</dd>
<dt>individualID.1</dt><dd><p>The ID of the potential &quot;infector&quot;.</p>
</dd>
<dt>individualID.2</dt><dd><p>The ID of the potential &quot;infectee&quot;.</p>
</dd>
<dt>transmission</dt><dd><p>Did individual.1 infect individual.2.</p>
</dd>
<dt>snpDist</dt><dd><p>What is the number of SNPs between the individuals.</p>
</dd>
<dt>infectionDate.1</dt><dd><p>The date and time of infection of individualID.1.</p>
</dd>
<dt>infectionDate.2</dt><dd><p>The date and time of infection of individualID.2.</p>
</dd>
<dt>sampleDate.1</dt><dd><p>The date and time of sampling of individualID.1.</p>
</dd>
<dt>sampleDate.2</dt><dd><p>The date and time of sampling of individualID.2.</p>
</dd>
<dt>sampleDiff</dt><dd><p>The number of days between sampleDate.1 and sampleDate.2.</p>
</dd>
<dt>infectionDiff</dt><dd><p>The number of days between infectionDate.1 and infectionDate.2.</p>
</dd>
<dt>infectionDiffY</dt><dd><p>The number of years between infectionDate.1 and infectionDate.2.</p>
</dd>
<dt>timeCat</dt><dd><p>A categorical representation of infectionDiff: &lt;1y, 1-2y, 2-3y, 3-4y, 4-5y, &gt;5y.</p>
</dd>
<dt>Z1</dt><dd><p>Pair-level covariate derived from X1: 1 if match, 0 if not match.</p>
</dd>
<dt>Z2</dt><dd><p>Pair-level covariate derived from X2: 1 if match, 0 if not match.</p>
</dd>
<dt>Z3</dt><dd><p>Pair-level covariate derived from X3: 1 if a-a, 2 if b-b, 3 if a-b, 4 if b-a.</p>
</dd>
<dt>Z4</dt><dd><p>Pair-level covariate derived from X4: 1 if match, 2 if adjacent, 2 otherwise.</p>
</dd>
</dl>



<h3>References</h3>

<p>Schliep KP. phangorn: Phylogenetic analysis in R. Bioinformatics. 2011;27(4):592-3.
</p>

<hr>
<h2 id='performNB'>Performs naive bayes classification</h2><span id='topic+performNB'></span>

<h3>Description</h3>

<p>The function <code>performNB</code> Calculates the posterior probabilities of a dichotomous class
variable given a set of covariates using Bayes rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performNB(training, prediction, obsIDVar, goldStdVar, covariates, l = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performNB_+3A_training">training</code></td>
<td>
<p>The training dataset name.</p>
</td></tr>
<tr><td><code id="performNB_+3A_prediction">prediction</code></td>
<td>
<p>The prediction dataset name.</p>
</td></tr>
<tr><td><code id="performNB_+3A_obsidvar">obsIDVar</code></td>
<td>
<p>The variable name (in quotes) of the observation ID variable.</p>
</td></tr>
<tr><td><code id="performNB_+3A_goldstdvar">goldStdVar</code></td>
<td>
<p>The variable name (in quotes) of the outcome in the training dataset
(needs to be a logical variable with value <code>TRUE</code> for observations with
the outcome of interest.)</p>
</td></tr>
<tr><td><code id="performNB_+3A_covariates">covariates</code></td>
<td>
<p>A character vector containing the covariate variable names.
All covariates need to be categorical factor variables.</p>
</td></tr>
<tr><td><code id="performNB_+3A_l">l</code></td>
<td>
<p>Laplace smoothing parameter that is added to each cell
(a value of 0 indicates no smoothing).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to be used by <code><a href="#topic+nbProbabilities">nbProbabilities</a></code> to 
estimate the relative transmission probability between individuals in an infectious
disease outbreak. However, it can be used more generally to estimate the probability
of any dichotomous outcome given a set of categorical covariates.
</p>
<p>The function needs a training dataset with the outcome variable (<code>goldStdVar</code>)
which is <code>TRUE</code> for those who have the value of interest and <code>FALSE</code>
for those who do not. The probability of having the outcome 
(<code>&lt;goldStdVar&gt; = TRUE</code>) is predicted in the prediction dataset.
</p>


<h3>Value</h3>

<p>List containing two dataframes: 
</p>

<ol>
<li> <p><code>probabilities</code> - a dataframe combining <code>training</code> and <code>prediction</code>
with predictied probabilities for the <code>prediction</code> dataframe. Column names:
</p>

<ul>
<li> <p><code>&lt;obsIDVar&gt;</code> - the observation ID with the name specified
</p>
</li>
<li> <p><code>p</code> - the probability that <code>&lt;goldStdVar&gt; = TRUE</code> for observations in the
<code>prediction</code> dataset.
</p>
</li></ul>

</li>
<li> <p><code>estimates</code> - a dataframe with the effect estimates derived from the training dataset.
Column names:
</p>

<ul>
<li> <p><code>level</code> - the covariate name and level
</p>
</li>
<li> <p><code>est</code> - the log odds ratio for this covariate and level
</p>
</li>
<li> <p><code>se</code> - the standard error of the log odds ratio
</p>
</li></ul>

</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use iris dataset and predict if a flower is of the specices "virginica".

data(iris)
irisNew &lt;- iris
## Creating an id variable
irisNew$id &lt;- seq(1:nrow(irisNew))
## Creating logical variable indicating if the flower is of the species virginica
irisNew$spVirginica &lt;- irisNew$Species == "virginica"

## Creating categorical/factor versions of the covariates
irisNew$Sepal.Length.Cat &lt;- factor(cut(irisNew$Sepal.Length, c(0, 5, 6, 7, Inf)),
                                 labels = c("&lt;=5.0", "5.1-6.0", "6.1-7.0", "7.1+"))

irisNew$Sepal.Width.Cat &lt;- factor(cut(irisNew$Sepal.Width, c(0, 2.5, 3, 3.5, Inf)),
                                 labels = c("&lt;=2.5", "2.6-3.0", "3.1-3.5", "3.6+"))

irisNew$Petal.Length.Cat &lt;- factor(cut(irisNew$Petal.Length, c(0, 2, 4, 6, Inf)),
                                 labels = c("&lt;=2.0", "2.1-4.0", "4.1-6.0", "6.0+"))

irisNew$Petal.Width.Cat &lt;- factor(cut(irisNew$Petal.Width, c(0, 1, 2, Inf)),
                               labels = c("&lt;=1.0", "1.1-2.0", "2.1+"))

## Using NB to predict if the species is virginica
## (training and predicting on same dataset)
pred &lt;- performNB(irisNew, irisNew, obsIDVar = "id",
                    goldStdVar = "spVirginica",
                    covariates = c("Sepal.Length.Cat", "Sepal.Width.Cat",
                                   "Petal.Length.Cat", "Petal.Width.Cat"), l = 1)
irisResults &lt;- merge(irisNew, pred$probabilities, by = "id")
tapply(irisResults$p, irisResults$Species, summary)

</code></pre>

<hr>
<h2 id='performPEM'>Executes the PEM algorthim to estimate the generation/serial interval distribution</h2><span id='topic+performPEM'></span>

<h3>Description</h3>

<p>The function <code>performPEM</code> uses relative transmission probabilities to estimate
the generation/serial interval distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performPEM(
  df,
  indIDVar,
  timeDiffVar,
  pVar,
  initialPars,
  shift = 0,
  epsilon = 1e-05,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performPEM_+3A_df">df</code></td>
<td>
<p>The name of the dateset with transmission probabilities.</p>
</td></tr>
<tr><td><code id="performPEM_+3A_indidvar">indIDVar</code></td>
<td>
<p>The name (in quotes) of the individual ID columns
(data frame <code>df</code> must have variables called <code>&lt;indIDVar&gt;.1</code>
and <code>&lt;indIDVar&gt;.2</code>).</p>
</td></tr>
<tr><td><code id="performPEM_+3A_timediffvar">timeDiffVar</code></td>
<td>
<p>The name (in quotes) of the column with the difference
in time between infection (generation interval) or symptom onset (serial interval) for the
pair of cases. The units of this variable (hours, days, years) defines the units of the 
resulting distribution.</p>
</td></tr>
<tr><td><code id="performPEM_+3A_pvar">pVar</code></td>
<td>
<p>The column name (in quotes) of the transmission probabilities.</p>
</td></tr>
<tr><td><code id="performPEM_+3A_initialpars">initialPars</code></td>
<td>
<p>A vector of length two with the shape and scale 
to initialize the gamma distribution parameters.</p>
</td></tr>
<tr><td><code id="performPEM_+3A_shift">shift</code></td>
<td>
<p>A value in the same units as <code>timeDiffVar</code> that the
gamma distribution should be shifted. The Default value of 0 is an 
unmodifed gamma distribution.</p>
</td></tr>
<tr><td><code id="performPEM_+3A_epsilon">epsilon</code></td>
<td>
<p>The difference between successive estimates of the shape and
scale parameters that indicates convergence.</p>
</td></tr>
<tr><td><code id="performPEM_+3A_plot">plot</code></td>
<td>
<p>A logical indicating if a plot should be printed showing the
parameter estimates at each iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be called by <code><a href="#topic+estimateSI">estimateSI</a></code>
which estimates the generation/serial interval distribution as well as clustering the
probabilities, but can be called directly. The main reason to call <code>performPEM</code>
directly is for the <code>plot</code> argument. Setting this argument to <code>TRUE</code>
will produce a plot of the shape and scale parameters at each iteration.
For more details on the PEM algorithm see <code><a href="#topic+estimateSI">estimateSI</a></code>.
</p>


<h3>Value</h3>

<p>A data frame with one row and the following columns:
</p>

<ul>
<li> <p><code>nIndividuals</code> - the number of infectees who have intervals included
in the SI estimate.
</p>
</li>
<li> <p><code>shape</code> - the shape of the estimated gamma distribution for the interval.
</p>
</li>
<li> <p><code>scale</code> - the scale of the estimated gamma distribution for the interval.
</p>
</li>
<li> <p><code>meanSI</code> - the mean of the estimated gamma distribution for the interval 
(<code>shape * scale + shift</code>).
</p>
</li>
<li> <p><code>medianSI</code> - the median of the estimated gamma distribution for the interval
(<code>qgamma(0.5, shape, scale) + shift)</code>).
</p>
</li>
<li> <p><code>sdSI</code> - the standard deviation of the estimated gamma distribution for
the interval (<code>shape * scale ^ 2</code>)
</p>
</li></ul>



<h3>References</h3>

<p>Hens N, Calatayud L, Kurkela S, Tamme T, Wallinga J. Robust reconstruction and
analysis of outbreak data: influenza A (H1N1) v transmission in a school-based 
population. <em>American Journal of Epidemiology</em>. 2012 Jul 12;176(3):196-203.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code> <code><a href="#topic+clusterInfectors">clusterInfectors</a></code>
<code><a href="#topic+performPEM">performPEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, run the algorithm without including time as a covariate.
orderedPair &lt;- pairData[pairData$infectionDiffY &gt; 0, ]

## Create a variable called snpClose that will define probable links
# (&lt;3 SNPs) and nonlinks (&gt;12 SNPs) all pairs with between 2-12 SNPs
# will not be used to train.
orderedPair$snpClose &lt;- ifelse(orderedPair$snpDist &lt; 3, TRUE,
                        ifelse(orderedPair$snpDist &gt; 12, FALSE, NA))
table(orderedPair$snpClose)

## Running the algorithm
#NOTE should run with nReps &gt; 1.
resGen &lt;- nbProbabilities(orderedPair = orderedPair,
                            indIDVar = "individualID",
                            pairIDVar = "pairID",
                            goldStdVar = "snpClose",
                            covariates = c("Z1", "Z2", "Z3", "Z4"),
                            label = "SNPs", l = 1,
                            n = 10, m = 1, nReps = 1)
                            
## Merging the probabilities back with the pair-level data
nbResultsNoT &lt;- merge(resGen[[1]], orderedPair, by = "pairID", all = TRUE)

## Estimating the serial interval


# Using all pairs and plotting the parameters
  performPEM(nbResultsNoT, indIDVar = "individualID", timeDiffVar = "infectionDiffY",
  pVar = "pScaled", initialPars = c(2, 2), shift = 0, plot = TRUE)



# Clustering the probabilities first
allClust &lt;- clusterInfectors(nbResultsNoT, indIDVar = "individualID", pVar = "pScaled",
                            clustMethod = "hc_absolute", cutoff = 0.05)

performPEM(allClust[allClust$cluster == 1, ], indIDVar = "individualID",
           timeDiffVar = "infectionDiffY", pVar = "pScaled",
           initialPars = c(2, 2), shift = 0, plot = TRUE)


# The above is equivalent to the following code using the function estimateSI()
# though the plot will not be printed and more details will be added
estimateSI(nbResultsNoT, indIDVar = "individualID", timeDiffVar = "infectionDiffY",
           pVar = "pScaled", clustMethod = "hc_absolute", cutoff = 0.05,
           initialPars = c(2, 2))



</code></pre>

<hr>
<h2 id='plotRt'>Creates a plot of the effective reproductive number</h2><span id='topic+plotRt'></span>

<h3>Description</h3>

<p>The function <code>plotRt</code> creates a plot of the effective reproductive number (Rt) over
the course of the outbreak. Using various options, the plot can include the overall average
Rt value for the outbreak and the confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRt(
  rData,
  includeRtAvg = FALSE,
  includeRtCI = FALSE,
  includeRtAvgCI = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRt_+3A_rdata">rData</code></td>
<td>
<p>A list that is the output of <code><a href="#topic+estimateR">estimateR</a></code>. It should contain
the dataframes <code>RtDf</code>, <code>RtAvgDf</code>, and vectors <code>timeFrame</code> and <code>rangeForAvg</code></p>
</td></tr>
<tr><td><code id="plotRt_+3A_includertavg">includeRtAvg</code></td>
<td>
<p>A logical. If TRUE, a horizontal line will be drawn for the average
Rt value over <code>rangeForAvg</code> and verticle lines will be drawn at the 
<code>rangeForAvg</code> values.</p>
</td></tr>
<tr><td><code id="plotRt_+3A_includertci">includeRtCI</code></td>
<td>
<p>A logical. If TRUE, error bars will be added to the Rt values
representing the bootstrap confidence intervals.</p>
</td></tr>
<tr><td><code id="plotRt_+3A_includertavgci">includeRtAvgCI</code></td>
<td>
<p>A logical. If TRUE, horizontal lines will be drawn around the Rt average
line representing the bootstrap confidence interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main input <code>rData</code> should be the output of <code><a href="#topic+estimateRt">estimateRt</a></code> with the
time-level reproductive numbers, overall average, range used to calculate that average,
and time frame.
</p>
<p>The options <code>includeRtCI</code> and <code>includeRtAvgCI</code> add confidence interval bounds
to the plot. If set to true, <code>rData</code> should be from a call of <code><a href="#topic+estimateRt">estimateRt</a></code>
with <code>bootSamples &gt; 0</code> so that confidence intervals are available.
If <code>includeRtAvgCI</code> is set to <code>TRUE</code>, a line for the point estimate of the average
Rt value will be drawn even if <code>includeRtAvg</code> is set to <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbProbabilities">nbProbabilities</a></code> <code><a href="#topic+estimateR">estimateR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the nbResults data frame included in the package which has the results
# of the nbProbabilities() function on a TB-like outbreak.

## Getting initial estimates of the reproductive number
# (without specifying nbResults and without confidence intervals)
rInitial &lt;- estimateR(nbResults, dateVar = "infectionDate",
               indIDVar = "individualID", pVar = "pScaled",
               timeFrame = "months")
               
## Finding the stable portion of the outbreak for rangeForAvg using the plot
plotRt(rInitial)
cut1 &lt;- 25
cut2 &lt;- 125

## Finding the final reproductive number estimates with confidence intervals
# NOTE should run with bootSamples &gt; 10.
rFinal &lt;- estimateR(nbResults, dateVar = "infectionDate",
             indIDVar = "individualID", pVar = "pScaled",
             timeFrame = "months", rangeForAvg = c(cut1, cut2),
             bootSamples = 10, alpha = 0.05)

## Ploting the final result              
plotRt(rFinal, includeRtAvg = TRUE, includeRtCI = TRUE, includeRtAvgCI = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
