<!DOCTYPE html><html><head><title>Help for package metacore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metacore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#check_columns'><p>Check all data frames include the correct types of columns</p></a></li>
<li><a href='#check_inconsistent_labels'><p>Optional checks to consistency of metadata</p></a></li>
<li><a href='#check_structure'><p>Column Validation Function</p></a></li>
<li><a href='#check_words'><p>Check Words in Column</p></a></li>
<li><a href='#create_tbl'><p>Create table</p></a></li>
<li><a href='#define_to_metacore'><p>Define XML to DataDef Object</p></a></li>
<li><a href='#get_control_term'><p>Get Control Term</p></a></li>
<li><a href='#is_metacore'><p>Is metacore object</p></a></li>
<li><a href='#load_metacore'><p>load metacore object</p></a></li>
<li><a href='#metacore'><p>R6 Class wrapper to create your own metacore object</p></a></li>
<li><a href='#metacore_example'><p>Get path to metacore example</p></a></li>
<li><a href='#MetaCore_filter'><p>Select method to subset by a single dataframe</p></a></li>
<li><a href='#read_all_sheets'><p>Read in all Sheets</p></a></li>
<li><a href='#save_metacore'><p>save metacore object</p></a></li>
<li><a href='#select_dataset'><p>Select metacore object to single dataset</p></a></li>
<li><a href='#spec_to_metacore'><p>Specification document to metacore object</p></a></li>
<li><a href='#spec_type'><p>Check the type of spec document</p></a></li>
<li><a href='#spec_type_to_codelist'><p>Spec to codelist</p></a></li>
<li><a href='#spec_type_to_derivations'><p>Spec to derivation</p></a></li>
<li><a href='#spec_type_to_ds_spec'><p>Spec to ds_spec</p></a></li>
<li><a href='#spec_type_to_ds_vars'><p>Spec to ds_vars</p></a></li>
<li><a href='#spec_type_to_value_spec'><p>Spec to value_spec</p></a></li>
<li><a href='#spec_type_to_var_spec'><p>Spec to var_spec</p></a></li>
<li><a href='#xml_to_codelist'><p>XML to code list</p></a></li>
<li><a href='#xml_to_derivations'><p>XML to derivation table</p></a></li>
<li><a href='#xml_to_ds_spec'><p>XML to Data Set Spec</p></a></li>
<li><a href='#xml_to_ds_vars'><p>XML to Data Set Var table</p></a></li>
<li><a href='#xml_to_value_spec'><p>XML to value spec</p></a></li>
<li><a href='#xml_to_var_spec'><p>XML to variable spec</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Centralized Metadata Object Focus on Clinical Trial Data
Programming Workflows</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Create an immutable container holding metadata for the purpose of better enabling programming activities and functionality of other packages within the clinical programming workflow.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, tidyr, dplyr, stringr, magrittr, xml2, purrr, readxl,
rlang, tibble, tidyselect</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://atorus-research.github.io/metacore/">https://atorus-research.github.io/metacore/</a>,
<a href="https://github.com/atorus-research/metacore">https://github.com/atorus-research/metacore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/atorus-research/metacore/issues">https://github.com/atorus-research/metacore/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-02 14:57:55 UTC; christinafillmore</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Fillmore
    <a href="https://orcid.org/0000-0003-0595-2302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Maya Gans <a href="https://orcid.org/0000-0002-5452-6089"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ashley Tarasiewicz [aut],
  Mike Stackhouse <a href="https://orcid.org/0000-0001-6030-723X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  GSK/Atorus JPT [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Fillmore &lt;christina.e.fillmore@gsk.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-02 17:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='check_columns'>Check all data frames include the correct types of columns</h2><span id='topic+check_columns'></span>

<h3>Description</h3>

<p>This function checks for vector types and accepted words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_columns(
  ds_spec,
  ds_vars,
  var_spec,
  value_spec,
  derivations,
  codelist,
  supp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_columns_+3A_ds_spec">ds_spec</code></td>
<td>
<p>dataset specification</p>
</td></tr>
<tr><td><code id="check_columns_+3A_ds_vars">ds_vars</code></td>
<td>
<p>dataset variables</p>
</td></tr>
<tr><td><code id="check_columns_+3A_var_spec">var_spec</code></td>
<td>
<p>variable specification</p>
</td></tr>
<tr><td><code id="check_columns_+3A_value_spec">value_spec</code></td>
<td>
<p>value specification</p>
</td></tr>
<tr><td><code id="check_columns_+3A_derivations">derivations</code></td>
<td>
<p>derivation information</p>
</td></tr>
<tr><td><code id="check_columns_+3A_codelist">codelist</code></td>
<td>
<p>codelist information</p>
</td></tr>
<tr><td><code id="check_columns_+3A_supp">supp</code></td>
<td>
<p>supp information</p>
</td></tr>
</table>

<hr>
<h2 id='check_inconsistent_labels'>Optional checks to consistency of metadata</h2><span id='topic+check_inconsistent_labels'></span><span id='topic+check_inconsistent_types'></span><span id='topic+check_inconsistent_formats'></span>

<h3>Description</h3>

<p>These functions check to see if values (e.g labels, formats)
that should be consistent for a variable across all data are actually
consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_inconsistent_labels(metacore)

check_inconsistent_types(metacore)

check_inconsistent_formats(metacore)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_inconsistent_labels_+3A_metacore">metacore</code></td>
<td>
<p>metacore object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all variables are consistent it will return a message. If there
are inconsistencies it will return a message and a dataset of the variables
with inconsistencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE WITH DUPLICATES
# Loads in a metacore obj called metacore
load(metacore_example("pilot_ADaM.rda"))
check_inconsistent_labels(metacore)

check_inconsistent_types(metacore)

## EXAMPLE WITHOUT DUPLICATES
# Loads in a metacore obj called metacore
load(metacore_example("pilot_SDTM.rda"))
check_inconsistent_labels(metacore)

check_inconsistent_formats(metacore)

check_inconsistent_types(metacore)
</code></pre>

<hr>
<h2 id='check_structure'>Column Validation Function</h2><span id='topic+check_structure'></span>

<h3>Description</h3>

<p>Column Validation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_structure(.data, col, func, any_na_acceptable, nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_structure_+3A_.data">.data</code></td>
<td>
<p>the dataframe to check the column for</p>
</td></tr>
<tr><td><code id="check_structure_+3A_col">col</code></td>
<td>
<p>the column to test</p>
</td></tr>
<tr><td><code id="check_structure_+3A_func">func</code></td>
<td>
<p>the function to use to assert column structure</p>
</td></tr>
<tr><td><code id="check_structure_+3A_any_na_acceptable">any_na_acceptable</code></td>
<td>
<p>boolean, testing if the column can have missing</p>
</td></tr>
<tr><td><code id="check_structure_+3A_nm">nm</code></td>
<td>
<p>name of column to check (for warning and error clarification)</p>
</td></tr>
</table>

<hr>
<h2 id='check_words'>Check Words in Column</h2><span id='topic+check_words'></span>

<h3>Description</h3>

<p>Check Words in Column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_words(..., col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_words_+3A_...">...</code></td>
<td>
<p>permissible words in the column</p>
</td></tr>
<tr><td><code id="check_words_+3A_col">col</code></td>
<td>
<p>the column to check for specific words</p>
</td></tr>
</table>

<hr>
<h2 id='create_tbl'>Create table</h2><span id='topic+create_tbl'></span>

<h3>Description</h3>

<p>This function creates a table from excel sheets. This is mainly used
internally for building spec readers, but is exported so others who need to
build spec readers can use it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tbl(doc, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_tbl_+3A_doc">doc</code></td>
<td>
<p>list of sheets from a excel doc</p>
</td></tr>
<tr><td><code id="create_tbl_+3A_cols">cols</code></td>
<td>
<p>vector of regex to get a datasets base on which columns it has.
If the vector is named it will also rename the columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset (or list of datasets if not specific enough)
</p>

<hr>
<h2 id='define_to_metacore'>Define XML to DataDef Object</h2><span id='topic+define_to_metacore'></span>

<h3>Description</h3>

<p>Given a path, this function converts the define xml to a DataDef Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_to_metacore(path, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_to_metacore_+3A_path">path</code></td>
<td>
<p>location of the define xml as a string</p>
</td></tr>
<tr><td><code id="define_to_metacore_+3A_quiet">quiet</code></td>
<td>
<p>Option to quietly load in, this will suppress warnings, but not errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>DataDef Object
</p>

<hr>
<h2 id='get_control_term'>Get Control Term</h2><span id='topic+get_control_term'></span>

<h3>Description</h3>

<p>Returns the control term (a vector for permitted values and a tibble for code
lists) for a given variable. The dataset can be optionally specified if there
is different control terminology for different datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_control_term(metacode, variable, dataset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_control_term_+3A_metacode">metacode</code></td>
<td>
<p>metacore object</p>
</td></tr>
<tr><td><code id="get_control_term_+3A_variable">variable</code></td>
<td>
<p>A variable name to get the controlled terms for. This can
either be a string or just the name of the variable</p>
</td></tr>
<tr><td><code id="get_control_term_+3A_dataset">dataset</code></td>
<td>
<p>A dataset name. This is not required if there is only one set
of control terminology across all datasets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector for permitted values and a 2-column tibble for codelists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meta_ex &lt;- spec_to_metacore(metacore_example("p21_mock.xlsx"))
get_control_term(meta_ex, QVAL, SUPPAE)
get_control_term(meta_ex, "QVAL", "SUPPAE")
</code></pre>

<hr>
<h2 id='is_metacore'>Is metacore object</h2><span id='topic+is_metacore'></span>

<h3>Description</h3>

<p>Is metacore object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_metacore(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_metacore_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if metacore, <code>FALSE</code> if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loads in a metacore obj called metacore
load(metacore_example("pilot_ADaM.rda"))
is_metacore(metacore)

</code></pre>

<hr>
<h2 id='load_metacore'>load metacore object</h2><span id='topic+load_metacore'></span>

<h3>Description</h3>

<p>load metacore object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_metacore(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_metacore_+3A_path">path</code></td>
<td>
<p>location of the metacore object to load into memory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>metacore object in memory
</p>

<hr>
<h2 id='metacore'>R6 Class wrapper to create your own metacore object</h2><span id='topic+metacore'></span>

<h3>Description</h3>

<p>R6 Class wrapper to create your own metacore object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metacore(
  ds_spec = tibble(dataset = character(), structure = character(), label = character()),
  ds_vars = tibble(dataset = character(), variable = character(), keep = logical(),
    key_seq = integer(), order = integer(), core = character(), supp_flag = logical()),
  var_spec = tibble(variable = character(), label = character(), length = integer(), type
    = character(), common = character(), format = character()),
  value_spec = tibble(dataset = character(), variable = character(), where = character(),
    type = character(), sig_dig = integer(), code_id = character(), origin = character(),
    derivation_id = integer()),
  derivations = tibble(derivation_id = integer(), derivation = character()),
  codelist = tibble(code_id = character(), name = character(), type = character(), codes
    = list()),
  supp = tibble(dataset = character(), variable = character(), idvar = character(), qeval
    = character())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metacore_+3A_ds_spec">ds_spec</code></td>
<td>
<p>contains each dataset in the study, with the labels for each</p>
</td></tr>
<tr><td><code id="metacore_+3A_ds_vars">ds_vars</code></td>
<td>
<p>information on what variables are in each dataset + plus dataset specific variable information</p>
</td></tr>
<tr><td><code id="metacore_+3A_var_spec">var_spec</code></td>
<td>
<p>variable information that is shared across all datasets</p>
</td></tr>
<tr><td><code id="metacore_+3A_value_spec">value_spec</code></td>
<td>
<p>parameter specific information, as data is long the specs for wbc might be difference the hgb</p>
</td></tr>
<tr><td><code id="metacore_+3A_derivations">derivations</code></td>
<td>
<p>contains derivation, it allows for different variables to have the same derivation</p>
</td></tr>
<tr><td><code id="metacore_+3A_codelist">codelist</code></td>
<td>
<p>contains the code/decode information</p>
</td></tr>
<tr><td><code id="metacore_+3A_supp">supp</code></td>
<td>
<p>contains the idvar and qeval information for supplemental variables</p>
</td></tr>
</table>

<hr>
<h2 id='metacore_example'>Get path to metacore example</h2><span id='topic+metacore_example'></span>

<h3>Description</h3>

<p>metacore comes bundled with a number of sample files in its <code>inst/extdata</code>
directory. This function make them easy to access. When testing or writing
examples in other packages, it is best to use the 'pilot_ADaM.rda' example as
it loads fastest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metacore_example(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metacore_example_+3A_file">file</code></td>
<td>
<p>Name of file. If <code>NULL</code>, the example files will be listed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>metacore_example()
metacore_example("mock_spec.xlsx")
</code></pre>

<hr>
<h2 id='MetaCore_filter'>Select method to subset by a single dataframe</h2><span id='topic+MetaCore_filter'></span>

<h3>Description</h3>

<p>Select method to subset by a single dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetaCore_filter(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetaCore_filter_+3A_value">value</code></td>
<td>
<p>the dataframe to subset by</p>
</td></tr>
</table>

<hr>
<h2 id='read_all_sheets'>Read in all Sheets</h2><span id='topic+read_all_sheets'></span>

<h3>Description</h3>

<p>Given a path to a file, this function reads in all sheets of an excel file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_all_sheets(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_all_sheets_+3A_path">path</code></td>
<td>
<p>string of the file path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of datasets
</p>

<hr>
<h2 id='save_metacore'>save metacore object</h2><span id='topic+save_metacore'></span>

<h3>Description</h3>

<p>save metacore object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_metacore(metacore_object, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_metacore_+3A_metacore_object">metacore_object</code></td>
<td>
<p>the metacore object in memory to save to disc</p>
</td></tr>
<tr><td><code id="save_metacore_+3A_path">path</code></td>
<td>
<p>file path and file name to save metacore object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an .rda file
</p>

<hr>
<h2 id='select_dataset'>Select metacore object to single dataset</h2><span id='topic+select_dataset'></span>

<h3>Description</h3>

<p>Select metacore object to single dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_dataset(.data, dataset, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_dataset_+3A_.data">.data</code></td>
<td>
<p>the metacore object of dataframes</p>
</td></tr>
<tr><td><code id="select_dataset_+3A_dataset">dataset</code></td>
<td>
<p>the specific dataset to subset by</p>
</td></tr>
<tr><td><code id="select_dataset_+3A_simplify">simplify</code></td>
<td>
<p>return a single dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a filtered subset of the metacore object
</p>

<hr>
<h2 id='spec_to_metacore'>Specification document to metacore object</h2><span id='topic+spec_to_metacore'></span>

<h3>Description</h3>

<p>This function takes the location of an excel specification document and reads
it in as a meta core object. At the moment it only supports specification in
the format of pinnacle 21 specifications. But, the @family spec builder can
be used as building blocks for bespoke specification documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_to_metacore(path, quiet = FALSE, where_sep_sheet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_to_metacore_+3A_path">path</code></td>
<td>
<p>string of file location</p>
</td></tr>
<tr><td><code id="spec_to_metacore_+3A_quiet">quiet</code></td>
<td>
<p>Option to quietly load in, this will suppress warnings, but not
errors</p>
</td></tr>
<tr><td><code id="spec_to_metacore_+3A_where_sep_sheet">where_sep_sheet</code></td>
<td>
<p>Option to tell if the where is in a separate sheet,
like in older p21 specs or in a single sheet like newer p21 specs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>given a spec document it returns a metacore object
</p>

<hr>
<h2 id='spec_type'>Check the type of spec document</h2><span id='topic+spec_type'></span>

<h3>Description</h3>

<p>Check the type of spec document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_+3A_path">path</code></td>
<td>
<p>file location as a string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns string indicating the type of spec document
</p>

<hr>
<h2 id='spec_type_to_codelist'>Spec to codelist</h2><span id='topic+spec_type_to_codelist'></span>

<h3>Description</h3>

<p>Creates the value_spec from a list of datasets (optionally filtered by the
sheet input). The named vector <code style="white-space: pre;">&#8288;*_cols&#8288;</code> is used to determine which is the
correct sheet and renames the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type_to_codelist(
  doc,
  codelist_cols = c(code_id = "ID", name = "[N|n]ame", code = "^[C|c]ode|^[T|t]erm",
    decode = "[D|d]ecode"),
  permitted_val_cols = NULL,
  dict_cols = c(code_id = "ID", name = "[N|n]ame", dictionary = "[D|d]ictionary", version
    = "[V|v]ersion"),
  sheets = NULL,
  simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_to_codelist_+3A_doc">doc</code></td>
<td>
<p>Named list of datasets @seealso <code><a href="#topic+read_all_sheets">read_all_sheets()</a></code> for exact
format</p>
</td></tr>
<tr><td><code id="spec_type_to_codelist_+3A_codelist_cols">codelist_cols</code></td>
<td>
<p>Named vector of column names that make up the codelist.
The column names can be regular expressions for more flexibility. But, the
names must follow the given pattern</p>
</td></tr>
<tr><td><code id="spec_type_to_codelist_+3A_permitted_val_cols">permitted_val_cols</code></td>
<td>
<p>Named vector of column names that make up the
permitted value The column names can be regular expressions for more
flexibility. This is optional, can be left as null if there isn't a
permitted value sheet</p>
</td></tr>
<tr><td><code id="spec_type_to_codelist_+3A_dict_cols">dict_cols</code></td>
<td>
<p>Named vector of column names that make up the dictionary
value The column names can be regular expressions for more flexibility.
This is optional, can be left as null if there isn't a permitted value
sheet</p>
</td></tr>
<tr><td><code id="spec_type_to_codelist_+3A_sheets">sheets</code></td>
<td>
<p>Optional, regular expressions of the sheets</p>
</td></tr>
<tr><td><code id="spec_type_to_codelist_+3A_simplify">simplify</code></td>
<td>
<p>Boolean value, if true will convert code/decode pairs that
are all equal to a permitted value list. True by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset formatted for the metacore object
</p>


<h3>See Also</h3>

<p>Other spec builder: 
<code><a href="#topic+spec_type_to_derivations">spec_type_to_derivations</a>()</code>,
<code><a href="#topic+spec_type_to_ds_spec">spec_type_to_ds_spec</a>()</code>,
<code><a href="#topic+spec_type_to_ds_vars">spec_type_to_ds_vars</a>()</code>,
<code><a href="#topic+spec_type_to_value_spec">spec_type_to_value_spec</a>()</code>,
<code><a href="#topic+spec_type_to_var_spec">spec_type_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='spec_type_to_derivations'>Spec to derivation</h2><span id='topic+spec_type_to_derivations'></span>

<h3>Description</h3>

<p>Creates the derivation table from a list of datasets (optionally filtered by
the sheet input). The named vector <code>cols</code> is used to determine which is the
correct sheet and renames the columns. The derivation will be used for
&quot;derived&quot; origins, the comments for &quot;assigned&quot; origins, and predecessor for
&quot;predecessor&quot; origins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type_to_derivations(
  doc,
  cols = c(derivation_id = "ID", derivation = "[D|d]efinition|[D|d]escription"),
  sheet = "Method|Derivations?",
  var_cols = c(dataset = "[D|d]ataset|[D|d]omain", variable = "[N|n]ame|[V|v]ariables?",
    origin = "[O|o]rigin", predecessor = "[P|p]redecessor", comment = "[C|c]omment")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_to_derivations_+3A_doc">doc</code></td>
<td>
<p>Named list of datasets @seealso <code><a href="#topic+read_all_sheets">read_all_sheets()</a></code> for exact
format</p>
</td></tr>
<tr><td><code id="spec_type_to_derivations_+3A_cols">cols</code></td>
<td>
<p>Named vector of column names. The column names can be regular
expressions for more flexibility. But, the names must follow the given
pattern</p>
</td></tr>
<tr><td><code id="spec_type_to_derivations_+3A_sheet">sheet</code></td>
<td>
<p>Regular expression for the sheet name</p>
</td></tr>
<tr><td><code id="spec_type_to_derivations_+3A_var_cols">var_cols</code></td>
<td>
<p>Named vector of the name(s) of the origin, predecessor and
comment columns. These do not have to be on the specified sheet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset formatted for the metacore object
</p>


<h3>See Also</h3>

<p>Other spec builder: 
<code><a href="#topic+spec_type_to_codelist">spec_type_to_codelist</a>()</code>,
<code><a href="#topic+spec_type_to_ds_spec">spec_type_to_ds_spec</a>()</code>,
<code><a href="#topic+spec_type_to_ds_vars">spec_type_to_ds_vars</a>()</code>,
<code><a href="#topic+spec_type_to_value_spec">spec_type_to_value_spec</a>()</code>,
<code><a href="#topic+spec_type_to_var_spec">spec_type_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='spec_type_to_ds_spec'>Spec to ds_spec</h2><span id='topic+spec_type_to_ds_spec'></span>

<h3>Description</h3>

<p>Creates the ds_spec from a list of datasets (optionally filtered by the sheet
input). The named vector <code>cols</code> is used to determine which is the correct
sheet and renames the columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type_to_ds_spec(
  doc,
  cols = c(dataset = "[N|n]ame|[D|d]ataset|[D|d]omain", structure = "[S|s]tructure",
    label = "[L|l]abel|[D|d]escription"),
  sheet = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_to_ds_spec_+3A_doc">doc</code></td>
<td>
<p>Named list of datasets @seealso <code><a href="#topic+read_all_sheets">read_all_sheets()</a></code> for exact
format</p>
</td></tr>
<tr><td><code id="spec_type_to_ds_spec_+3A_cols">cols</code></td>
<td>
<p>Named vector of column names. The column names can be regular
expressions for more flexibility. But, the names must follow the given pattern</p>
</td></tr>
<tr><td><code id="spec_type_to_ds_spec_+3A_sheet">sheet</code></td>
<td>
<p>Regular expression for the sheet name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset formatted for the metacore object
</p>


<h3>See Also</h3>

<p>Other spec builder: 
<code><a href="#topic+spec_type_to_codelist">spec_type_to_codelist</a>()</code>,
<code><a href="#topic+spec_type_to_derivations">spec_type_to_derivations</a>()</code>,
<code><a href="#topic+spec_type_to_ds_vars">spec_type_to_ds_vars</a>()</code>,
<code><a href="#topic+spec_type_to_value_spec">spec_type_to_value_spec</a>()</code>,
<code><a href="#topic+spec_type_to_var_spec">spec_type_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='spec_type_to_ds_vars'>Spec to ds_vars</h2><span id='topic+spec_type_to_ds_vars'></span>

<h3>Description</h3>

<p>Creates the ds_vars from a list of datasets (optionally filtered by the sheet
input). The named vector <code>cols</code> is used to determine which is the correct
sheet and renames the columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type_to_ds_vars(
  doc,
  cols = c(dataset = "[D|d]ataset|[D|d]omain", variable =
    "[V|v]ariable [[N|n]ame]?|[V|v]ariables?", order =
    "[V|v]ariable [O|o]rder|[O|o]rder", keep = "[K|k]eep|[M|m]andatory"),
  key_seq_sep_sheet = TRUE,
  key_seq_cols = c(dataset = "Dataset", key_seq = "Key Variables"),
  sheet = "[V|v]ar|Datasets"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_to_ds_vars_+3A_doc">doc</code></td>
<td>
<p>Named list of datasets @seealso <code><a href="#topic+read_all_sheets">read_all_sheets()</a></code> for exact
format</p>
</td></tr>
<tr><td><code id="spec_type_to_ds_vars_+3A_cols">cols</code></td>
<td>
<p>Named vector of column names. The column names can be regular
expressions for more flexibility. But, the names must follow the given
pattern</p>
</td></tr>
<tr><td><code id="spec_type_to_ds_vars_+3A_key_seq_sep_sheet">key_seq_sep_sheet</code></td>
<td>
<p>A boolean to indicate if the key sequence is on a
separate sheet. If set to false add the key_seq column name to the <code>cols</code>
vector.</p>
</td></tr>
<tr><td><code id="spec_type_to_ds_vars_+3A_key_seq_cols">key_seq_cols</code></td>
<td>
<p>names vector to get the key_sequence for each dataset</p>
</td></tr>
<tr><td><code id="spec_type_to_ds_vars_+3A_sheet">sheet</code></td>
<td>
<p>Regular expression for the sheet names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset formatted for the metacore object
</p>


<h3>See Also</h3>

<p>Other spec builder: 
<code><a href="#topic+spec_type_to_codelist">spec_type_to_codelist</a>()</code>,
<code><a href="#topic+spec_type_to_derivations">spec_type_to_derivations</a>()</code>,
<code><a href="#topic+spec_type_to_ds_spec">spec_type_to_ds_spec</a>()</code>,
<code><a href="#topic+spec_type_to_value_spec">spec_type_to_value_spec</a>()</code>,
<code><a href="#topic+spec_type_to_var_spec">spec_type_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='spec_type_to_value_spec'>Spec to value_spec</h2><span id='topic+spec_type_to_value_spec'></span>

<h3>Description</h3>

<p>Creates the value_spec from a list of datasets (optionally filtered by the
sheet input). The named vector <code>cols</code> is used to determine which is the
correct sheet and renames the columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type_to_value_spec(
  doc,
  cols = c(dataset = "[D|d]ataset|[D|d]omain", variable = "[N|n]ame|[V|v]ariables?",
    origin = "[O|o]rigin", type = "[T|t]ype", code_id = "[C|c]odelist|Controlled Term",
    sig_dig = "[S|s]ignificant", where = "[W|w]here", derivation_id = "[M|m]ethod",
    predecessor = "[P|p]redecessor"),
  sheet = NULL,
  where_sep_sheet = TRUE,
  where_cols = c(id = "ID", where = c("Variable", "Comparator", "Value")),
  var_sheet = "[V|v]ar"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_to_value_spec_+3A_doc">doc</code></td>
<td>
<p>Named list of datasets @seealso <code><a href="#topic+read_all_sheets">read_all_sheets()</a></code> for exact
format</p>
</td></tr>
<tr><td><code id="spec_type_to_value_spec_+3A_cols">cols</code></td>
<td>
<p>Named vector of column names. The column names can be regular
expressions for more flexibility. But, the names must follow the given
pattern</p>
</td></tr>
<tr><td><code id="spec_type_to_value_spec_+3A_sheet">sheet</code></td>
<td>
<p>Regular expression for the sheet name</p>
</td></tr>
<tr><td><code id="spec_type_to_value_spec_+3A_where_sep_sheet">where_sep_sheet</code></td>
<td>
<p>Boolean value to control if the where information in a
separate dataset. If the where information is on a separate sheet, set to
true and provide the column information with the <code>where_cols</code> inputs.</p>
</td></tr>
<tr><td><code id="spec_type_to_value_spec_+3A_where_cols">where_cols</code></td>
<td>
<p>Named list with an id and where field. All columns in the
where field will be collapsed together</p>
</td></tr>
<tr><td><code id="spec_type_to_value_spec_+3A_var_sheet">var_sheet</code></td>
<td>
<p>Name of sheet with the Variable information on it. Metacore
expects each variable will have a row in the value_spec. Because many
specification only have information in the value tab this is added. If the
information already exists in the value tab of your specification set to
NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset formatted for the metacore object
</p>


<h3>See Also</h3>

<p>Other spec builder: 
<code><a href="#topic+spec_type_to_codelist">spec_type_to_codelist</a>()</code>,
<code><a href="#topic+spec_type_to_derivations">spec_type_to_derivations</a>()</code>,
<code><a href="#topic+spec_type_to_ds_spec">spec_type_to_ds_spec</a>()</code>,
<code><a href="#topic+spec_type_to_ds_vars">spec_type_to_ds_vars</a>()</code>,
<code><a href="#topic+spec_type_to_var_spec">spec_type_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='spec_type_to_var_spec'>Spec to var_spec</h2><span id='topic+spec_type_to_var_spec'></span>

<h3>Description</h3>

<p>Creates the var_spec from a list of datasets (optionally filtered by the sheet
input). The named vector <code>cols</code> is used to determine which is the correct
sheet and renames the columns. (Note: the keep column will be converted logical)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_type_to_var_spec(
  doc,
  cols = c(variable = "[N|n]ame|[V|v]ariables?", length = "[L|l]ength", label =
    "[L|l]abel", type = "[T|t]ype", dataset = "[D|d]ataset|[D|d]omain", format =
    "[F|f]ormat"),
  sheet = "[V|v]ar"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_type_to_var_spec_+3A_doc">doc</code></td>
<td>
<p>Named list of datasets @seealso <code><a href="#topic+read_all_sheets">read_all_sheets()</a></code> for exact
format</p>
</td></tr>
<tr><td><code id="spec_type_to_var_spec_+3A_cols">cols</code></td>
<td>
<p>Named vector of column names. The column names can be regular
expressions for more flexibility. But, the names must follow the given pattern</p>
</td></tr>
<tr><td><code id="spec_type_to_var_spec_+3A_sheet">sheet</code></td>
<td>
<p>Regular expression for the sheet name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset formatted for the metacore object
</p>


<h3>See Also</h3>

<p>Other spec builder: 
<code><a href="#topic+spec_type_to_codelist">spec_type_to_codelist</a>()</code>,
<code><a href="#topic+spec_type_to_derivations">spec_type_to_derivations</a>()</code>,
<code><a href="#topic+spec_type_to_ds_spec">spec_type_to_ds_spec</a>()</code>,
<code><a href="#topic+spec_type_to_ds_vars">spec_type_to_ds_vars</a>()</code>,
<code><a href="#topic+spec_type_to_value_spec">spec_type_to_value_spec</a>()</code>
</p>

<hr>
<h2 id='xml_to_codelist'>XML to code list</h2><span id='topic+xml_to_codelist'></span>

<h3>Description</h3>

<p>Reads in a define xml and creates a code_list table. The code_list table is a
nested tibble where each row is a code list or permitted value list. The code
column contains a vector of a tibble depending on if it is a permitted values
or code list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_codelist(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_to_codelist_+3A_doc">doc</code></td>
<td>
<p>xml document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble containing the code list and permitted value information
</p>


<h3>See Also</h3>

<p>Other xml builder: 
<code><a href="#topic+xml_to_derivations">xml_to_derivations</a>()</code>,
<code><a href="#topic+xml_to_ds_spec">xml_to_ds_spec</a>()</code>,
<code><a href="#topic+xml_to_ds_vars">xml_to_ds_vars</a>()</code>,
<code><a href="#topic+xml_to_value_spec">xml_to_value_spec</a>()</code>,
<code><a href="#topic+xml_to_var_spec">xml_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='xml_to_derivations'>XML to derivation table</h2><span id='topic+xml_to_derivations'></span>

<h3>Description</h3>

<p>This reads in a xml document and gets all the derivations/comments. These can
be cross referenced to variables using the derivation_id's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_derivations(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_to_derivations_+3A_doc">doc</code></td>
<td>
<p>xml document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with derivation id's and derivations
</p>


<h3>See Also</h3>

<p>Other xml builder: 
<code><a href="#topic+xml_to_codelist">xml_to_codelist</a>()</code>,
<code><a href="#topic+xml_to_ds_spec">xml_to_ds_spec</a>()</code>,
<code><a href="#topic+xml_to_ds_vars">xml_to_ds_vars</a>()</code>,
<code><a href="#topic+xml_to_value_spec">xml_to_value_spec</a>()</code>,
<code><a href="#topic+xml_to_var_spec">xml_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='xml_to_ds_spec'>XML to Data Set Spec</h2><span id='topic+xml_to_ds_spec'></span>

<h3>Description</h3>

<p>Creates a dataset specification, which has the domain name and label for each dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_ds_spec(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_to_ds_spec_+3A_doc">doc</code></td>
<td>
<p>xml document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with the data set specifications
</p>


<h3>See Also</h3>

<p>Other xml builder: 
<code><a href="#topic+xml_to_codelist">xml_to_codelist</a>()</code>,
<code><a href="#topic+xml_to_derivations">xml_to_derivations</a>()</code>,
<code><a href="#topic+xml_to_ds_vars">xml_to_ds_vars</a>()</code>,
<code><a href="#topic+xml_to_value_spec">xml_to_value_spec</a>()</code>,
<code><a href="#topic+xml_to_var_spec">xml_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='xml_to_ds_vars'>XML to Data Set Var table</h2><span id='topic+xml_to_ds_vars'></span>

<h3>Description</h3>

<p>Creates the ds_vars table, which acts as a key between the datasets and the var spec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_ds_vars(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_to_ds_vars_+3A_doc">doc</code></td>
<td>
<p>xml document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with the dataset and variables
</p>


<h3>See Also</h3>

<p>Other xml builder: 
<code><a href="#topic+xml_to_codelist">xml_to_codelist</a>()</code>,
<code><a href="#topic+xml_to_derivations">xml_to_derivations</a>()</code>,
<code><a href="#topic+xml_to_ds_spec">xml_to_ds_spec</a>()</code>,
<code><a href="#topic+xml_to_value_spec">xml_to_value_spec</a>()</code>,
<code><a href="#topic+xml_to_var_spec">xml_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='xml_to_value_spec'>XML to value spec</h2><span id='topic+xml_to_value_spec'></span>

<h3>Description</h3>

<p>Takes a define xml and pulls out the value level metadata including codelist_id's,
defines_id's, and where clause. There is one row per variable expect when there
is a where clause, at which point there is one row per value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_value_spec(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_to_value_spec_+3A_doc">doc</code></td>
<td>
<p>xml document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with the value level information
</p>


<h3>See Also</h3>

<p>Other xml builder: 
<code><a href="#topic+xml_to_codelist">xml_to_codelist</a>()</code>,
<code><a href="#topic+xml_to_derivations">xml_to_derivations</a>()</code>,
<code><a href="#topic+xml_to_ds_spec">xml_to_ds_spec</a>()</code>,
<code><a href="#topic+xml_to_ds_vars">xml_to_ds_vars</a>()</code>,
<code><a href="#topic+xml_to_var_spec">xml_to_var_spec</a>()</code>
</p>

<hr>
<h2 id='xml_to_var_spec'>XML to variable spec</h2><span id='topic+xml_to_var_spec'></span>

<h3>Description</h3>

<p>Takes a define xml and returns a dataset with specifications for each
variable. The variable will just be the variable, unless the specification
for that variable differ between datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_var_spec(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_to_var_spec_+3A_doc">doc</code></td>
<td>
<p>define xml document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with variable, length, label columns
</p>


<h3>See Also</h3>

<p>Other xml builder: 
<code><a href="#topic+xml_to_codelist">xml_to_codelist</a>()</code>,
<code><a href="#topic+xml_to_derivations">xml_to_derivations</a>()</code>,
<code><a href="#topic+xml_to_ds_spec">xml_to_ds_spec</a>()</code>,
<code><a href="#topic+xml_to_ds_vars">xml_to_ds_vars</a>()</code>,
<code><a href="#topic+xml_to_value_spec">xml_to_value_spec</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
