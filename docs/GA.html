<!DOCTYPE html><html><head><title>Help for package GA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binary2decimal'><p>Binary encoding of decimal numbers and vice versa.</p></a></li>
<li><a href='#binary2gray'><p>Gray encoding for binary strings</p></a></li>
<li><a href='#de'><p>Differential Evolution via Genetic Algorithms</p></a></li>
<li><a href='#de-class'><p>Class &quot;de&quot;</p></a></li>
<li><a href='#ga'><p>Genetic Algorithms</p></a></li>
<li><a href='#ga_Crossover'><p>Crossover operators in genetic algorithms</p></a></li>
<li><a href='#ga_Mutation'><p>Mutation operators in genetic algorithms</p></a></li>
<li><a href='#ga_pmutation'><p>Variable mutation probability in genetic algorithms</p></a></li>
<li><a href='#ga_Population'><p>Population initialization in genetic algorithms</p></a></li>
<li><a href='#ga_Selection'><p>Selection operators in genetic algorithms</p></a></li>
<li><a href='#ga-class'><p>Class &quot;ga&quot;</p></a></li>
<li><a href='#GA-internal'><p>Internal GA functions</p></a></li>
<li><a href='#GA-package'><p>Genetic Algorithms</p></a></li>
<li><a href='#gaControl'><p>A function for setting or retrieving defaults genetic operators</p></a></li>
<li><a href='#gaisl'><p>Islands Genetic Algorithms</p></a></li>
<li><a href='#gaisl-class'><p>Class &quot;gaisl&quot;</p></a></li>
<li><a href='#gaMonitor'><p>Monitor genetic algorithm evolution</p></a></li>
<li><a href='#gaSummary'><p>Summarize genetic algorithm evolution</p></a></li>
<li><a href='#numericOrNA-class'><p>Virtual Class &quot;numericOrNA&quot; - Simple Class for sub-assignment Values</p></a></li>
<li><a href='#palettes'><p>Colours palettes</p></a></li>
<li><a href='#parNames-methods'><p>Parameters or decision variables names from an object of class <code>ga-class</code>.</p></a></li>
<li><a href='#persp3D'><p>Perspective plot with colour levels</p></a></li>
<li><a href='#plot.de-method'><p>Plot of Differential Evolution search path</p></a></li>
<li><a href='#plot.ga-method'><p>Plot of Genetic Algorithm search path</p></a></li>
<li><a href='#plot.gaisl-method'><p>Plot of Islands Genetic Algorithm search path</p></a></li>
<li><a href='#summary.de-method'><p>Summary for Differential Evolution</p></a></li>
<li><a href='#summary.ga-method'><p>Summary for Genetic Algorithms</p></a></li>
<li><a href='#summary.gaisl-method'><p>Summary for Islands Genetic Algorithms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Algorithms</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible general-purpose toolbox implementing genetic 
  algorithms (GAs) for stochastic optimisation. Binary, real-valued, and
  permutation representations are available to optimize a fitness 
  function, i.e. a function provided by users depending on their 
  objective function. Several genetic operators are available and can be
  combined to explore the best settings for the current task. 
  Furthermore, users can define new genetic operators and easily 
  evaluate their performances. Local search using general-purpose 
  optimisation algorithms can be applied stochastically to exploit 
  interesting regions. GAs can be run sequentially or in parallel, using
  an explicit master-slave parallelisation or a coarse-grain islands 
  approach. For more details see Scrucca (2013) 
  &lt;<a href="https://doi.org/10.18637%2Fjss.v053.i04">doi:10.18637/jss.v053.i04</a>&gt; and Scrucca (2017) 
  &lt;<a href="https://doi.org/10.32614%2FRJ-2017-008">doi:10.32614/RJ-2017-008</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4), methods, foreach, iterators</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils, cli, crayon, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, doParallel, doRNG (&ge; 1.6), knitr (&ge; 1.8),
rmarkdown (&ge; 2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://luca-scr.github.io/GA/">https://luca-scr.github.io/GA/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luca-scr/GA/issues">https://github.com/luca-scr/GA/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 09:58:42 UTC; luca</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Scrucca <a href="https://orcid.org/0000-0003-3826-0484"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Scrucca &lt;luca.scrucca@unipg.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-28 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binary2decimal'>Binary encoding of decimal numbers and vice versa.</h2><span id='topic+binary2decimal'></span><span id='topic+decimal2binary'></span>

<h3>Description</h3>

<p>Functions for computing binary to decimal conversion of numbers and vice versa.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimal2binary(x, length)
binary2decimal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary2decimal_+3A_x">x</code></td>
<td>
<p>input value.</p>
</td></tr>
<tr><td><code id="binary2decimal_+3A_length">length</code></td>
<td>
<p>an optional value giving the length of binary string to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>decimal2binary</code> converts a numerical value (which is forced to be an integer) to a binary representation, i.e. a vector of 0s and 1s. For real numerical values see the example below.
</p>
<p><code>binary2decimal</code> converts a binary value, i.e. a vector of 0s and 1s, to a decimal representation.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary2gray">binary2gray</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># for integer values
dval &lt;- 12
(bval &lt;- decimal2binary(dval))
binary2decimal(bval)

# for real values
dval &lt;- 12.456
# use
(bval &lt;- decimal2binary(dval*1000))
binary2decimal(bval)/1000
</code></pre>

<hr>
<h2 id='binary2gray'>Gray encoding for binary strings</h2><span id='topic+binary2gray'></span><span id='topic+gray2binary'></span>

<h3>Description</h3>

<p>Functions for computing Gray encoding from/to binary strings.</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary2gray(x)
gray2binary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary2gray_+3A_x">x</code></td>
<td>
<p>the string to be evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gray encoding allows to obtain binary strings not affected by the well-known Hamming cliff problem. With Gray encoding the number of bit differences between any two consecutive values is one, whereas in binary strings this is not always true.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary2decimal">binary2decimal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a five-bit encoding of values 15 and 16  using the standard 
# binary coding
decimal2binary(15, 5)
decimal2binary(16, 5)
# Moving from 15 to 16 (or vice versa) all five bits need to be changed,
# but using Gray encoding the two binary strings differ by one bit.
binary2gray(decimal2binary(15, 5))
binary2gray(decimal2binary(16, 5))
</code></pre>

<hr>
<h2 id='de'>Differential Evolution via Genetic Algorithms</h2><span id='topic+de'></span><span id='topic+show+2Cde-method'></span><span id='topic+print+2Cde-method'></span>

<h3>Description</h3>

<p>Maximization of a fitness function using Differential Evolution (DE).
DE is a population-based evolutionary algorithm for optimisation of fitness functions defined over a continuous parameter space.</p>


<h3>Usage</h3>

<pre><code class='language-R'>de(fitness,
   lower, upper,
   popSize = 10*d,
   stepsize = 0.8,
   pcrossover = 0.5,
   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="de_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as input a vector of values representing a potential solution, and returns a numerical value describing its &ldquo;fitness&rdquo;.</p>
</td></tr>
<tr><td><code id="de_+3A_lower">lower</code></td>
<td>
<p>a vector of length equal to the decision variables providing the lower bounds of the search space.</p>
</td></tr>
<tr><td><code id="de_+3A_upper">upper</code></td>
<td>
<p>a vector of length equal to the decision variables providing the upper bounds of the search space.</p>
</td></tr>
<tr><td><code id="de_+3A_popsize">popSize</code></td>
<td>
<p>the population size. By default is set at 10 times the number of decision variables.</p>
</td></tr>
<tr><td><code id="de_+3A_pcrossover">pcrossover</code></td>
<td>
<p>the probability of crossover, by default set to 0.5.</p>
</td></tr>
<tr><td><code id="de_+3A_stepsize">stepsize</code></td>
<td>
<p>the stepsize or weighting factor. A value in the interval [0,2], by default set to 0.8. If set at <code>NA</code> a random value is selected in the interval [0.5, 1.0] (so called dithering).</p>
</td></tr>
<tr><td><code id="de_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the <code><a href="#topic+ga">ga</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Differential Evolution (DE) is a stochastic evolutionary algorithm that optimises multidimensional real-valued fitness functions without requiring the optimisation problem to be differentiable.
</p>
<p>This implimentation follows the description in Simon (2013; Sec. 12.4, and Fig. 12.12) and uses the functionalities available in the <code><a href="#topic+ga">ga</a></code> function for Genetic Algorithms. 
</p>
<p>The DE selection operator is defined by <code><a href="#topic+gareal_de">gareal_de</a></code> with parameters <code>p = pcrossover</code> and <code>F = stepsize</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>de-class</code>. See <code><a href="#topic+de-class">de-class</a></code> for a description of available slots information.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Scrucca L. (2013). GA: A Package for Genetic Algorithms in R.
<em>Journal of Statistical Software</em>, 53(4), 1-37, <a href="https://doi.org/10.18637/jss.v053.i04">doi:10.18637/jss.v053.i04</a>.
</p>
<p>Scrucca, L. (2017) On some extensions to GA package: hybrid optimisation, parallelisation and islands evolution. <em>The R Journal</em>, 9/1, 187-206,  <a href="https://doi.org/10.32614/RJ-2017-008">doi:10.32614/RJ-2017-008</a>.
</p>
<p>Simon D. (2013) <em>Evolutionary Optimization Algorithms</em>. John Wiley &amp; Sons.
</p>
<p>Price K., Storn R.M., Lampinen J.A. (2005) <em>Differential Evolution: A Practical Approach to Global Optimization</em>. Springer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary+2Cde-method">summary,de-method</a></code>, 
<code><a href="#topic+plot+2Cde-method">plot,de-method</a></code>, 
<code><a href="#topic+de-class">de-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) one-dimensional function
f &lt;- function(x)  abs(x)+cos(x)
curve(f, -20, 20)

DE &lt;- de(fitness = function(x) -f(x), lower = -20, upper = 20)
plot(DE)
summary(DE)

curve(f, -20, 20, n = 1000)
abline(v = DE@solution, lty = 3)

# 2) "Wild" function, global minimum at about -15.81515

wild &lt;- function(x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x + 80
plot(wild, -50, 50, n = 1000)

# from help("optim")
SANN &lt;- optim(50, fn = wild, method = "SANN",
              control = list(maxit = 20000, temp = 20, parscale = 20))
unlist(SANN[1:2])

DE &lt;- de(fitness = function(...) -wild(...), lower = -50, upper = 50)
plot(DE)
summary(DE)

# 3) two-dimensional Rastrigin function

Rastrigin &lt;- function(x1, x2)
{
  20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}

x1 &lt;- x2 &lt;- seq(-5.12, 5.12, by = 0.1)
f &lt;- outer(x1, x2, Rastrigin)
persp3D(x1, x2, f, theta = 50, phi = 20, col.palette = bl2gr.colors)

DE &lt;- de(fitness = function(x) -Rastrigin(x[1], x[2]),
         lower = c(-5.12, -5.12), upper = c(5.12, 5.12),
         popSize = 50)
plot(DE)
summary(DE)

filled.contour(x1, x2, f, color.palette = bl2gr.colors,
               plot.axes = { axis(1); axis(2); 
                             points(DE@solution, 
                                    col = "yellow", pch = 3, lwd = 2) })

# 4) two-dimensional Ackley function

Ackley &lt;- function(x1, x2)
{
  -20*exp(-0.2*sqrt(0.5*(x1^2 + x2^2))) - 
  exp(0.5*(cos(2*pi*x1) + cos(2*pi*x2))) + exp(1) + 20
}

x1 &lt;- x2 &lt;- seq(-3, 3, by = 0.1)
f &lt;- outer(x1, x2, Ackley)
persp3D(x1, x2, f, theta = 50, phi = 20, col.palette = bl2gr.colors)

DE &lt;- de(fitness = function(x) -Ackley(x[1], x[2]),
         lower = c(-3, -3), upper = c(3, 3),
         stepsize = NA)
plot(DE)
summary(DE)

filled.contour(x1, x2, f, color.palette = bl2gr.colors,
               plot.axes = { axis(1); axis(2); 
                             points(DE@solution, 
                                    col = "yellow", pch = 3, lwd = 2) })
                                    
# 5) Curve fitting example (see Scrucca JSS 2013)

## Not run: 
# subset of data from data(trees, package = "spuRs")
tree &lt;- data.frame(Age = c(2.44, 12.44, 22.44, 32.44, 42.44, 52.44, 62.44, 
                           72.44, 82.44, 92.44, 102.44, 112.44),
                   Vol = c(2.2, 20, 93, 262, 476, 705, 967, 1203, 1409, 
                           1659, 1898, 2106))
richards &lt;- function(x, theta) 
  { theta[1]*(1 - exp(-theta[2]*x))^theta[3] }
fitnessL2 &lt;- function(theta, x, y) 
  { -sum((y - richards(x, theta))^2) }
DE &lt;- de(fitness = fitnessL2, x = tree$Age, y = tree$Vol, 
         lower = c(3000, 0, 2), upper = c(4000, 1, 4),
         popSize = 500, maxiter = 1000, run = 100, 
         names = c("a", "b", "c"))
summary(DE)

## End(Not run)

</code></pre>

<hr>
<h2 id='de-class'>Class &quot;de&quot;</h2><span id='topic+de-class'></span>

<h3>Description</h3>

<p>An S4 class for differential evolution algorithm</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the <code><a href="#topic+de">de</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>an object of class <code>"call"</code> representing the matched call;</p>
</dd>
<dt><code>type</code></dt><dd><p>a character string specifying the type of genetic algorithm used;</p>
</dd>
<dt><code>lower</code></dt><dd><p>a vector providing for each decision variable the lower bounds of the search space in case of real-valued or permutation encoded optimisations. Formerly this slot was named <code>min</code>;</p>
</dd>
<dt><code>upper</code></dt><dd><p>a vector providing for each decision variable the upper bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this slot was named <code>max</code>;</p>
</dd>
<dt><code>names</code></dt><dd><p>a vector of character strings providing the names of decision variables (optional);</p>
</dd>
<dt><code>popSize</code></dt><dd><p>the population size;</p>
</dd>
<dt><code>iter</code></dt><dd><p>the actual (or final) iteration of DE search;</p>
</dd>
<dt><code>run</code></dt><dd><p>the number of consecutive generations without any improvement in the best fitness value before the DE is stopped;</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>the maximum number of iterations to run before the DE search is halted;</p>
</dd>
<dt><code>suggestions</code></dt><dd><p>a matrix of user provided solutions and included in the initial population;</p>
</dd>
<dt><code>population</code></dt><dd><p>the current (or final) population;</p>
</dd>
<dt><code>elitism</code></dt><dd><p>the number of best fitness individuals to survive at each generation;</p>
</dd>
<dt><code>stepsize</code></dt><dd><p>the stepsize or weighting factor;</p>
</dd>
<dt><code>pcrossover</code></dt><dd><p>the crossover probability;</p>
</dd>
<dt><code>pmutation</code></dt><dd><p>the mutation probability;</p>
</dd>
<dt><code>optim</code></dt><dd><p>a logical specifying whether or not a local search using general-purpose optimisation algorithms should be used;</p>
</dd>
<dt><code>fitness</code></dt><dd><p>the values of fitness function for the current (or final) population;</p>
</dd>
<dt><code>summary</code></dt><dd><p>a matrix of summary statistics for fitness values at each iteration (along the rows);</p>
</dd>
<dt><code>bestSol</code></dt><dd><p>if <code>keepBest = TRUE</code>, the best solutions at each iteration;</p>
</dd>
<dt><code>fitnessValue</code></dt><dd><p>the best fitness value at the final iteration;</p>
</dd>
<dt><code>solution</code></dt><dd><p>the value(s) of the decision variables giving the best fitness at the final iteration.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p>For examples of usage see <code><a href="#topic+de">de</a></code>.</p>

<hr>
<h2 id='ga'>Genetic Algorithms</h2><span id='topic+ga'></span><span id='topic+show+2Cga-method'></span><span id='topic+print+2Cga-method'></span>

<h3>Description</h3>

<p>Maximization of a fitness function using genetic algorithms (GAs). Local search using general-purpose optimisation algorithms can be applied stochastically to exploit interesting regions. The algorithm can be run sequentially or in parallel using an explicit master-slave parallelisation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ga(type = c("binary", "real-valued", "permutation"), 
   fitness, ...,
   lower, upper, nBits,
   population = gaControl(type)$population,
   selection = gaControl(type)$selection,
   crossover = gaControl(type)$crossover, 
   mutation = gaControl(type)$mutation,
   popSize = 50, 
   pcrossover = 0.8, 
   pmutation = 0.1, 
   elitism = base::max(1, round(popSize*0.05)), 
   updatePop = FALSE,
   postFitness = NULL,
   maxiter = 100,
   run = maxiter,
   maxFitness = Inf,
   names = NULL,
   suggestions = NULL, 
   optim = FALSE,
   optimArgs = list(method = "L-BFGS-B", 
                    poptim = 0.05,
                    pressel = 0.5,
                    control = list(fnscale = -1, maxit = 100)),
   keepBest = FALSE,
   parallel = FALSE,
   monitor = if(interactive()) gaMonitor else FALSE,
   seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_+3A_type">type</code></td>
<td>
<p>the type of genetic algorithm to be run depending on the nature of decision variables. Possible values are: 
</p>

<dl>
<dt><code>"binary"</code></dt><dd><p>for binary representations of decision variables.</p>
</dd>
<dt><code>"real-valued"</code></dt><dd><p>for optimization problems where the decision variables are floating-point representations of real numbers.</p>
</dd>
<dt><code>"permutation"</code></dt><dd><p>for problems that involves reordering of a list of objects.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="ga_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as input an individual <code>string</code> representing a potential solution, and returns a numerical value describing its &ldquo;fitness&rdquo;.</p>
</td></tr>
<tr><td><code id="ga_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitness function. This allows to write fitness functions that keep some variables fixed during the search.</p>
</td></tr>
<tr><td><code id="ga_+3A_lower">lower</code></td>
<td>
<p>a vector of length equal to the decision variables providing the lower bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this argument was named <code>min</code>; its usage is allowed but deprecated.</p>
</td></tr>
<tr><td><code id="ga_+3A_upper">upper</code></td>
<td>
<p>a vector of length equal to the decision variables providing the upper bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this argument was named <code>max</code>; its usage is allowed but deprecated.</p>
</td></tr>
<tr><td><code id="ga_+3A_nbits">nBits</code></td>
<td>
<p>a value specifying the number of bits to be used in binary encoded optimizations.</p>
</td></tr>
<tr><td><code id="ga_+3A_population">population</code></td>
<td>
<p>an R function for randomly generating an initial population. See <code><a href="#topic+ga_Population">ga_Population</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="ga_+3A_selection">selection</code></td>
<td>
<p>an R function performing selection, i.e. a function which generates a new population of individuals from the current population probabilistically according to individual fitness. See <code><a href="#topic+ga_Selection">ga_Selection</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="ga_+3A_crossover">crossover</code></td>
<td>
<p>an R function performing crossover, i.e. a function which forms offsprings by combining part of the genetic information from their parents. See <code><a href="#topic+ga_Crossover">ga_Crossover</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="ga_+3A_mutation">mutation</code></td>
<td>
<p>an R function performing mutation, i.e. a function which randomly alters the values of some genes in a parent chromosome. See <code><a href="#topic+ga_Mutation">ga_Mutation</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="ga_+3A_popsize">popSize</code></td>
<td>
<p>the population size.</p>
</td></tr>
<tr><td><code id="ga_+3A_updatepop">updatePop</code></td>
<td>
<p>a logical defaulting to <code>FALSE</code>. If set at <code>TRUE</code> the first attribute attached to the value returned by the user-defined fitness function is used to update the population. <br />
<em>Be careful though, this is an experimental feature!</em></p>
</td></tr>
<tr><td><code id="ga_+3A_postfitness">postFitness</code></td>
<td>
<p>a user-defined function which, if provided, receives the current <code>ga-class</code> object as input, performs post fitness-evaluation steps, then returns an updated version of the object which is used to update the GA search.<br />
<em>Be careful though, this is an experimental feature!</em></p>
</td></tr>
<tr><td><code id="ga_+3A_pcrossover">pcrossover</code></td>
<td>
<p>the probability of crossover between pairs of chromosomes. Typically this is a large value and by default is set to 0.8.</p>
</td></tr>
<tr><td><code id="ga_+3A_pmutation">pmutation</code></td>
<td>
<p>the probability of mutation in a parent chromosome. Usually mutation occurs with a small probability, and by default is set to 0.1.</p>
</td></tr>
<tr><td><code id="ga_+3A_elitism">elitism</code></td>
<td>
<p>the number of best fitness individuals to survive at each generation. By default the top 5% individuals will survive at each iteration.</p>
</td></tr>
<tr><td><code id="ga_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations to run before the GA search is halted.</p>
</td></tr>
<tr><td><code id="ga_+3A_run">run</code></td>
<td>
<p>the number of consecutive generations without any improvement in the best fitness value before the GA is stopped.</p>
</td></tr>
<tr><td><code id="ga_+3A_maxfitness">maxFitness</code></td>
<td>
<p>the upper bound on the fitness function after that the GA search is interrupted.</p>
</td></tr>
<tr><td><code id="ga_+3A_names">names</code></td>
<td>
<p>a vector of character strings providing the names of decision variables.</p>
</td></tr>
<tr><td><code id="ga_+3A_suggestions">suggestions</code></td>
<td>
<p>a matrix of solutions strings to be included in the initial population. If provided the number of columns must match the number of decision variables.</p>
</td></tr>
<tr><td><code id="ga_+3A_optim">optim</code></td>
<td>
<p>a logical defaulting to <code>FALSE</code> determining whether or not a local search using general-purpose optimisation algorithms should be used. See argument <code>optimArgs</code> for further details and finer control.</p>
</td></tr>
<tr><td><code id="ga_+3A_optimargs">optimArgs</code></td>
<td>
<p>a list controlling the local search algorithm with the following components:
</p>

<dl>
<dt><code>method</code></dt><dd><p>a string specifying the general-purpose optimisation method to be used, by default is set to <code>"L-BFGS-B"</code>. Other possible methods are those reported in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>poptim</code></dt><dd><p>a value in the range [0,1] specifying the probability of performing a local search at each iteration of GA (default 0.1).</p>
</dd>
<dt><code>pressel</code></dt><dd><p>a value in the range [0,1] specifying the pressure selection (default 0.5). The local search is started from a random solution selected with probability proportional to fitness. High values of <code>pressel</code> tend to select the solutions with the largest fitness, whereas low values of <code>pressel</code> assign quasi-uniform probabilities to any solution.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list of control parameters. See 'Details' section in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="ga_+3A_keepbest">keepBest</code></td>
<td>
<p>a logical argument specifying if best solutions at each iteration should be saved in a slot called <code>bestSol</code>. See <code><a href="#topic+ga-class">ga-class</a></code>.</p>
</td></tr>
<tr><td><code id="ga_+3A_parallel">parallel</code></td>
<td>

<p>An optional argument which allows to specify if the Genetic Algorithm should be run sequentially or in parallel. 
</p>
<p>For a single machine with multiple cores, possible values are: 
</p>

<ul>
<li><p> a logical value specifying if parallel computing should be used (<code>TRUE</code>) or not (<code>FALSE</code>, default) for evaluating the fitness function;
</p>
</li>
<li><p> a numerical value which gives the number of cores to employ. By default, this is obtained from the function <code><a href="parallel.html#topic+detectCores">detectCores</a></code>; 
</p>
</li>
<li><p> a character string specifying the type of parallelisation to use. This depends on system OS: on Windows OS only <code>"snow"</code> type functionality is available, while on Unix/Linux/Mac OSX both <code>"snow"</code> and <code>"multicore"</code> (default) functionalities are available.
</p>
</li></ul>

<p>In all the cases described above, at the end of the search the cluster is automatically stopped by shutting down the workers.
</p>
<p>If a cluster of multiple machines is available, evaluation of the fitness function can be executed in parallel using all, or a subset of, the cores available to the machines belonging to the cluster. However, this option requires more work from the user, who needs to set up and register a parallel back end. 
In this case the cluster must be explicitly stopped with <code><a href="parallel.html#topic+stopCluster">stopCluster</a></code>.
</p>
</td></tr>
<tr><td><code id="ga_+3A_monitor">monitor</code></td>
<td>
<p>a logical or an R function which takes as input the current state of the <code>ga-class</code> object and show the evolution of the search. By default, for interactive sessions the function <code><a href="#topic+gaMonitor">gaMonitor</a></code> prints the average and best fitness values at each iteration. If set to <code>plot</code> these information are plotted on a graphical device. Other functions can be written by the user and supplied as argument. In non interactive sessions, by default <code>monitor = FALSE</code> so any output is suppressed.</p>
</td></tr>
<tr><td><code id="ga_+3A_seed">seed</code></td>
<td>
<p>an integer value containing the random number generator state. This argument can be used to replicate the results of a GA search. Note that if parallel computing is required, the <span class="pkg">doRNG</span> package must be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genetic algorithms (GAs) are stochastic search algorithms inspired by the basic principles of biological evolution and natural selection. GAs simulate the evolution of living organisms, where the fittest individuals dominate over the weaker ones, by mimicking the biological mechanisms of evolution, such as selection, crossover and mutation.
</p>
<p>The <span class="pkg">GA</span> package is a collection of general purpose functions that provide a flexible set of tools for applying a wide range of genetic algorithm methods.
</p>
<p>The <code>ga</code> function enables the application of GAs to problems where the decision variables are encoded as <code>"binary"</code>, <code>"real-valued"</code>, or <code>"permutation"</code> strings.
</p>
<p>Default genetic operators are set via <code><a href="#topic+gaControl">gaControl</a></code>. To retrieve the currently set operators:
</p>
<pre>gaControl("binary")</pre>
<pre>gaControl("real-valued")</pre>
<pre>gaControl("permutation")</pre>


<h3>Value</h3>

<p>Returns an object of class <code>ga-class</code>. See <code><a href="#topic+ga-class">ga-class</a></code> for a description of available slots information.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Back T., Fogel D., Michalewicz Z. (2000). <em>Evolutionary Computation 1: Basic Algorithms and Operators</em>. IOP Publishing Ltd., Bristol and Philadelphia.
</p>
<p>Back T., Fogel D., Michalewicz Z. (2000b). <em>Evolutionary Computation 2: Advanced Algorithms and Operators</em>. IOP Publishing Ltd., Bristol and Philadelphia.
</p>
<p>Coley D. (1999). <em>An Introduction to Genetic Algorithms for Scientists and Engineers</em>. World Scientific Pub. Co. Inc., Singapore.
</p>
<p>Eiben A., Smith J. (2003). <em>Introduction to Evolutionary Computing</em>. Springer-Verlag, Berlin Heidelberg.
</p>
<p>Goldberg D. (1989). <em>Genetic Algorithms in Search, Optimization, and Machine Learning</em>. Addison-Wesley Professional, Boston, MA.
</p>
<p>Haupt R. L., Haupt S. E. (2004). <em>Practical Genetic Algorithms</em>. 2nd edition. John Wiley &amp; Sons, New York.
</p>
<p>Luke S. (2013) <em>Essentials of Metaheuristics</em>, 2nd edition. Lulu. 
</p>
<p>Scrucca L. (2013). GA: A Package for Genetic Algorithms in R.
<em>Journal of Statistical Software</em>, 53(4), 1-37, <a href="https://doi.org/10.18637/jss.v053.i04">doi:10.18637/jss.v053.i04</a>.
</p>
<p>Scrucca, L. (2017) On some extensions to GA package: hybrid optimisation, parallelisation and islands evolution. <em>The R Journal</em>, 9/1, 187-206, <a href="https://doi.org/10.32614/RJ-2017-008">doi:10.32614/RJ-2017-008</a>.
</p>
<p>Simon D. (2013) <em>Evolutionary Optimization Algorithms</em>. John Wiley &amp; Sons.
</p>
<p>Sivanandam S., Deepa S. (2007). <em>Introduction to Genetic Algorithms</em>. Springer-Verlag, Berlin Heidelberg.
</p>
<p>Yu X., Gen M. (2010). <em>Introduction to Evolutionary Algorithms</em>. Springer-Verlag, Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary+2Cga-method">summary,ga-method</a></code>, 
<code><a href="#topic+plot+2Cga-method">plot,ga-method</a></code>, 
<code><a href="#topic+ga-class">ga-class</a></code>,
<code><a href="#topic+ga_Population">ga_Population</a></code>,
<code><a href="#topic+ga_Selection">ga_Selection</a></code>,
<code><a href="#topic+ga_Crossover">ga_Crossover</a></code>,
<code><a href="#topic+ga_Mutation">ga_Mutation</a></code>,
<code><a href="#topic+gaControl">gaControl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) one-dimensional function
f &lt;- function(x)  abs(x)+cos(x)
curve(f, -20, 20)

fitness &lt;- function(x) -f(x)
GA &lt;- ga(type = "real-valued", fitness = fitness, lower = -20, upper = 20)
summary(GA)
plot(GA)

curve(f, -20, 20)
abline(v = GA@solution, lty = 3)

# 2) one-dimensional function
f &lt;- function(x)  (x^2+x)*cos(x) # -10 &lt; x &lt; 10
curve(f, -10, 10)

# write your own tracing function
monitor &lt;- function(obj) 
{ 
  curve(f, -10, 10, main = paste("iteration =", obj@iter))
  points(obj@population, obj@fitness, pch = 20, col = 2)
  rug(obj@population, col = 2)
  Sys.sleep(0.2)
}
## Not run: 
GA &lt;- ga(type = "real-valued", fitness = f, lower = -10, upper = 10, monitor = monitor)

## End(Not run)
# or if you want to suppress the tracing
GA &lt;- ga(type = "real-valued", fitness = f, lower = -10, upper = 10, monitor = NULL)
summary(GA)

monitor(GA)
abline(v = GA@solution, lty = 3)

# 3) two-dimensional Rastrigin function

Rastrigin &lt;- function(x1, x2)
{
  20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}

x1 &lt;- x2 &lt;- seq(-5.12, 5.12, by = 0.1)
f &lt;- outer(x1, x2, Rastrigin)
persp3D(x1, x2, f, theta = 50, phi = 20, col.palette = bl2gr.colors)
filled.contour(x1, x2, f, color.palette = bl2gr.colors)

GA &lt;- ga(type = "real-valued", fitness =  function(x) -Rastrigin(x[1], x[2]),
         lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
         popSize = 50, maxiter = 100)
summary(GA)
plot(GA)

# 4) Parallel GA
# Simple example of an expensive fitness function obtained artificially by
# introducing a pause statement. 
## Not run: 
Rastrigin &lt;- function(x1, x2)
{
  Sys.sleep(0.1)
  20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}

system.time(GA1 &lt;- ga(type = "real-valued", 
                      fitness =  function(x) -Rastrigin(x[1], x[2]),
                      lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
                      popSize = 50, maxiter = 100, monitor = FALSE,
                      seed = 12345))

system.time(GA2 &lt;- ga(type = "real-valued", 
                      fitness =  function(x) -Rastrigin(x[1], x[2]),
                      lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
                      popSize = 50, maxiter = 100, monitor = FALSE,
                      seed = 12345, parallel = TRUE))

## End(Not run)

# 5) Hybrid GA
# Example of GA with local search 

Rastrigin &lt;- function(x1, x2)
{
  20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}

GA &lt;- ga(type = "real-valued", 
         fitness =  function(x) -Rastrigin(x[1], x[2]),
         lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
         popSize = 50, maxiter = 100,
         optim = TRUE)
summary(GA)

</code></pre>

<hr>
<h2 id='ga_Crossover'>Crossover operators in genetic algorithms</h2><span id='topic+ga_Crossover'></span><span id='topic+ga_Crossover_R'></span><span id='topic+ga_Crossover_Rcpp'></span><span id='topic+ga_spCrossover'></span><span id='topic+ga_spCrossover_R'></span><span id='topic+ga_spCrossover_Rcpp'></span><span id='topic+gabin_spCrossover'></span><span id='topic+gabin_spCrossover_R'></span><span id='topic+gabin_spCrossover_Rcpp'></span><span id='topic+gabin_uCrossover'></span><span id='topic+gabin_uCrossover_R'></span><span id='topic+gabin_uCrossover_Rcpp'></span><span id='topic+gareal_spCrossover'></span><span id='topic+gareal_spCrossover_R'></span><span id='topic+gareal_spCrossover_Rcpp'></span><span id='topic+gareal_waCrossover'></span><span id='topic+gareal_waCrossover_R'></span><span id='topic+gareal_waCrossover_Rcpp'></span><span id='topic+gareal_laCrossover'></span><span id='topic+gareal_laCrossover_R'></span><span id='topic+gareal_laCrossover_Rcpp'></span><span id='topic+gareal_blxCrossover'></span><span id='topic+gareal_blxCrossover_R'></span><span id='topic+gareal_blxCrossover_Rcpp'></span><span id='topic+gareal_laplaceCrossover'></span><span id='topic+gareal_laplaceCrossover_R'></span><span id='topic+gareal_laplaceCrossover_Rcpp'></span><span id='topic+gaperm_cxCrossover'></span><span id='topic+gaperm_cxCrossover_R'></span><span id='topic+gaperm_cxCrossover_Rcpp'></span><span id='topic+gaperm_pmxCrossover'></span><span id='topic+gaperm_pmxCrossover_R'></span><span id='topic+gaperm_pmxCrossover_Rcpp'></span><span id='topic+gaperm_oxCrossover'></span><span id='topic+gaperm_oxCrossover_R'></span><span id='topic+gaperm_oxCrossover_Rcpp'></span><span id='topic+gaperm_pbxCrossover'></span><span id='topic+gaperm_pbxCrossover_R'></span><span id='topic+gaperm_pbxCrossover_Rcpp'></span>

<h3>Description</h3>

<p>Functions implementing crossover genetic operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ga_spCrossover(object, parents, ...)

gabin_spCrossover(object, parents, ...)
gabin_uCrossover(object, parents, ...)

gareal_spCrossover(object, parents, ...)
gareal_waCrossover(object, parents, ...)
gareal_laCrossover(object, parents, ...)
gareal_blxCrossover(object, parents, a = 0.5, ...)
gareal_laplaceCrossover(object, parents, a = 0, b = 0.15, ...)

gaperm_cxCrossover(object, parents, ...)
gaperm_pmxCrossover(object, parents, ...)
gaperm_oxCrossover(object, parents, ...)
gaperm_pbxCrossover(object, parents, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_Crossover_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ga"</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="ga_Crossover_+3A_parents">parents</code></td>
<td>
<p>A two-rows matrix of values indexing the parents from the current population.</p>
</td></tr>
<tr><td><code id="ga_Crossover_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="ga_Crossover_+3A_a">a</code>, <code id="ga_Crossover_+3A_b">b</code></td>
<td>
<p>Parameters of genetic operators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with two elements:
</p>
<table>
<tr><td><code>children</code></td>
<td>
<p>a matrix of dimension 2 times the number of decision variables containing the generated offsprings;</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>a vector of length 2 containing the fitness values for the offsprings. A value <code>NA</code> is returned if an offspring is different (which is usually the case) from the two parents.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code></p>

<hr>
<h2 id='ga_Mutation'>Mutation operators in genetic algorithms</h2><span id='topic+ga_Mutation'></span><span id='topic+gabin_raMutation'></span><span id='topic+gabin_raMutation_R'></span><span id='topic+gabin_raMutation_Rcpp'></span><span id='topic+gareal_raMutation'></span><span id='topic+gareal_raMutation_R'></span><span id='topic+gareal_raMutation_Rcpp'></span><span id='topic+gareal_nraMutation'></span><span id='topic+gareal_nraMutation_R'></span><span id='topic+gareal_nraMutation_Rcpp'></span><span id='topic+gareal_rsMutation'></span><span id='topic+gareal_rsMutation_R'></span><span id='topic+gareal_rsMutation_Rcpp'></span><span id='topic+gareal_powMutation'></span><span id='topic+gareal_powMutation_R'></span><span id='topic+gareal_powMutation_Rcpp'></span><span id='topic+gaperm_simMutation'></span><span id='topic+gaperm_simMutation_R'></span><span id='topic+gaperm_simMutation_Rcpp'></span><span id='topic+gaperm_ismMutation'></span><span id='topic+gaperm_ismMutation_R'></span><span id='topic+gaperm_ismMutation_Rcpp'></span><span id='topic+gaperm_swMutation'></span><span id='topic+gaperm_swMutation_R'></span><span id='topic+gaperm_swMutation_Rcpp'></span><span id='topic+gaperm_dmMutation'></span><span id='topic+gaperm_dmMutation_R'></span><span id='topic+gaperm_dmMutation_Rcpp'></span><span id='topic+gaperm_scrMutation'></span><span id='topic+gaperm_scrMutation_R'></span><span id='topic+gaperm_scrMutation_Rcpp'></span>

<h3>Description</h3>

<p>Functions implementing mutation genetic operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gabin_raMutation(object, parent, ...)

gareal_raMutation(object, parent, ...)
gareal_nraMutation(object, parent, ...)
gareal_rsMutation(object, parent, ...)
gareal_powMutation(object, parent, pow = 10, ...)

gaperm_simMutation(object, parent, ...)
gaperm_ismMutation(object, parent, ...)
gaperm_swMutation(object, parent, ...)
gaperm_dmMutation(object, parent, ...)
gaperm_scrMutation(object, parent, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_Mutation_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ga"</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="ga_Mutation_+3A_parent">parent</code></td>
<td>
<p>A vector of values for the parent from the current population where mutation should occur.</p>
</td></tr>
<tr><td><code id="ga_Mutation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="ga_Mutation_+3A_pow">pow</code></td>
<td>
<p>Parameters of genetic operators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector of values containing the mutated string.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>

<hr>
<h2 id='ga_pmutation'>Variable mutation probability in genetic algorithms</h2><span id='topic+ga_pmutation'></span><span id='topic+ga_pmutation_R'></span><span id='topic+ga_pmutation_Rcpp'></span>

<h3>Description</h3>

<p>A function which calculates the mutation probability for the current iteration. This enables to use GAs with variable mutation rate (see examples).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ga_pmutation(object, p0 = 0.5, p = 0.01, T = round(object@maxiter/2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_pmutation_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ga"</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="ga_pmutation_+3A_p0">p0</code></td>
<td>
<p>initial probability of mutation.</p>
</td></tr>
<tr><td><code id="ga_pmutation_+3A_p">p</code></td>
<td>
<p>limiting probability of mutation.</p>
</td></tr>
<tr><td><code id="ga_pmutation_+3A_t">T</code></td>
<td>
<p>maximum iteration after which it should converges to <code>p</code>.</p>
</td></tr>  
<tr><td><code id="ga_pmutation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a numeric value in the range (0,1).</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code>, <code><a href="#topic+ga_Mutation">ga_Mutation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Rastrigin &lt;- function(x1, x2)
{
  20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}

GA &lt;- ga(type = "real-valued", 
         fitness =  function(x) -Rastrigin(x[1], x[2]),
         lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
         popSize = 50, maxiter = 500, run = 100,
         pmutation = ga_pmutation)
plot(GA)

GA &lt;- ga(type = "real-valued", 
         fitness =  function(x) -Rastrigin(x[1], x[2]),
         lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
         popSize = 50, maxiter = 500, run = 100,
         pmutation = function(...) ga_pmutation(..., p0 = 0.1))
plot(GA)

## End(Not run)
</code></pre>

<hr>
<h2 id='ga_Population'>Population initialization in genetic algorithms</h2><span id='topic+ga_Population'></span><span id='topic+gabin_Population'></span><span id='topic+gabin_Population_R'></span><span id='topic+gabin_Population_Rcpp'></span><span id='topic+gareal_Population'></span><span id='topic+gareal_Population_R'></span><span id='topic+gareal_Population_Rcpp'></span><span id='topic+gaperm_Population'></span><span id='topic+gaperm_Population_R'></span><span id='topic+gaperm_Population_Rcpp'></span>

<h3>Description</h3>

<p>Functions for creating a random initial population to be used in genetic algorithms.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gabin_Population(object, ...)

gareal_Population(object, ...)

gaperm_Population(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_Population_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ga"</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="ga_Population_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gabin_Population</code> generates a random population of <code>object@nBits</code> binary values; 
</p>
<p><code>gareal_Population</code> generates a random (uniform) population of real values in the range [<code>object@min</code>, <code>object@max</code>]; 
</p>
<p><code>gaperm_Population</code> generates a random (uniform) population of integer values in the range [<code>object@min</code>, <code>object@max</code>].
</p>


<h3>Value</h3>

<p>Return a matrix of dimension <code>object@popSize</code> times the number of decision variables.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code></p>

<hr>
<h2 id='ga_Selection'>Selection operators in genetic algorithms</h2><span id='topic+ga_Selection'></span><span id='topic+ga_lrSelection'></span><span id='topic+ga_lrSelection_R'></span><span id='topic+ga_lrSelection_Rcpp'></span><span id='topic+ga_nlrSelection'></span><span id='topic+ga_nlrSelection_R'></span><span id='topic+ga_nlrSelection_Rcpp'></span><span id='topic+ga_rwSelection'></span><span id='topic+ga_rwSelection_R'></span><span id='topic+ga_rwSelection_Rcpp'></span><span id='topic+ga_tourSelection'></span><span id='topic+ga_tourSelection_R'></span><span id='topic+ga_tourSelection_Rcpp'></span><span id='topic+gabin_lrSelection'></span><span id='topic+gabin_lrSelection_R'></span><span id='topic+gabin_lrSelection_Rcpp'></span><span id='topic+gabin_nlrSelection'></span><span id='topic+gabin_nlrSelection_R'></span><span id='topic+gabin_nlrSelection_Rcpp'></span><span id='topic+gabin_rwSelection'></span><span id='topic+gabin_rwSelection_R'></span><span id='topic+gabin_rwSelection_Rcpp'></span><span id='topic+gabin_tourSelection'></span><span id='topic+gabin_tourSelection_R'></span><span id='topic+gabin_tourSelection_Rcpp'></span><span id='topic+gareal_lrSelection'></span><span id='topic+gareal_lrSelection_R'></span><span id='topic+gareal_lrSelection_Rcpp'></span><span id='topic+gareal_nlrSelection'></span><span id='topic+gareal_nlrSelection_R'></span><span id='topic+gareal_nlrSelection_Rcpp'></span><span id='topic+gareal_rwSelection'></span><span id='topic+gareal_rwSelection_R'></span><span id='topic+gareal_rwSelection_Rcpp'></span><span id='topic+gareal_tourSelection'></span><span id='topic+gareal_tourSelection_R'></span><span id='topic+gareal_tourSelection_Rcpp'></span><span id='topic+gareal_lsSelection'></span><span id='topic+gareal_lsSelection_R'></span><span id='topic+gareal_lsSelection_Rcpp'></span><span id='topic+gareal_sigmaSelection'></span><span id='topic+gareal_sigmaSelection_R'></span><span id='topic+gareal_sigmaSelection_Rcpp'></span><span id='topic+gaperm_lrSelection'></span><span id='topic+gaperm_lrSelection_R'></span><span id='topic+gaperm_lrSelection_Rcpp'></span><span id='topic+gaperm_nlrSelection'></span><span id='topic+gaperm_nlrSelection_R'></span><span id='topic+gaperm_nlrSelection_Rcpp'></span><span id='topic+gaperm_rwSelection'></span><span id='topic+gaperm_rwSelection_R'></span><span id='topic+gaperm_rwSelection_Rcpp'></span><span id='topic+gaperm_tourSelection'></span><span id='topic+gaperm_tourSelection_R'></span><span id='topic+gaperm_tourSelection_Rcpp'></span><span id='topic+gareal_de'></span><span id='topic+gareal_de_R'></span><span id='topic+gareal_de_Rcpp'></span>

<h3>Description</h3>

<p>Functions implementing selection genetic operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ga_lrSelection(object, r = 2/(object@popSize * (object@popSize - 1)),
                       q = 2/object@popSize, ...)
ga_nlrSelection(object, q = 0.25, ...)
ga_rwSelection(object, ...)
ga_tourSelection(object, k = 3, ...)

gabin_lrSelection(object, r = 2/(object@popSize * (object@popSize - 1)), 
                          q = 2/object@popSize, ...)
gabin_nlrSelection(object, q = 0.25, ...)
gabin_rwSelection(object, ...)
gabin_tourSelection(object, k = 3, ...)

gareal_lrSelection(object, r = 2/(object@popSize * (object@popSize - 1)), 
                           q = 2/object@popSize, ...)
gareal_nlrSelection(object, q = 0.25, ...)
gareal_rwSelection(object, ...)
gareal_tourSelection(object, k = 3, ...)
gareal_lsSelection(object, ...)
gareal_sigmaSelection(object, ...)

gaperm_lrSelection(object, r = 2/(object@popSize * (object@popSize - 1)), 
                           q = 2/object@popSize, ...)
gaperm_nlrSelection(object, q = 0.25, ...)
gaperm_rwSelection(object, ...)
gaperm_tourSelection(object, k = 3, ...)

gareal_de(object, F = 0.8, p = 0.5, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ga_Selection_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ga"</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="ga_Selection_+3A_r">r</code></td>
<td>
<p>A tuning parameter for the GA selection operator.</p>
</td></tr>
<tr><td><code id="ga_Selection_+3A_q">q</code></td>
<td>
<p>A tuning parameter for the GA selection operator.</p>
</td></tr>
<tr><td><code id="ga_Selection_+3A_k">k</code></td>
<td>
<p>A tuning parameter for the GA selection operator.</p>
</td></tr>
<tr><td><code id="ga_Selection_+3A_f">F</code>, <code id="ga_Selection_+3A_p">p</code></td>
<td>
<p>Tuning parameters for the DE selection operator.</p>
</td></tr>
<tr><td><code id="ga_Selection_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with two elements:
</p>
<table>
<tr><td><code>population</code></td>
<td>
<p>a matrix of dimension <code>object@popSize</code> times the number of decision variables containing the selected individuals or strings;</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>a vector of length <code>object@popSize</code> containing the fitness values for the selected individuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code>, <code><a href="#topic+de">de</a></code>.</p>

<hr>
<h2 id='ga-class'>Class &quot;ga&quot;</h2><span id='topic+ga-class'></span>

<h3>Description</h3>

<p>An S4 class for genetic algorithms</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the <code><a href="#topic+ga">ga</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>an object of class <code>"call"</code> representing the matched call;</p>
</dd>
<dt><code>type</code></dt><dd><p>a character string specifying the type of genetic algorithm used;</p>
</dd>
<dt><code>lower</code></dt><dd><p>a vector providing for each decision variable the lower bounds of the search space in case of real-valued or permutation encoded optimisations. Formerly this slot was named <code>min</code>;</p>
</dd>
<dt><code>upper</code></dt><dd><p>a vector providing for each decision variable the upper bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this slot was named <code>max</code>;</p>
</dd>
<dt><code>nBits</code></dt><dd><p>a value specifying the number of bits to be used in binary encoded optimizations;</p>
</dd>
<dt><code>names</code></dt><dd><p>a vector of character strings providing the names of decision variables (optional);</p>
</dd>
<dt><code>popSize</code></dt><dd><p>the population size;</p>
</dd>
<dt><code>iter</code></dt><dd><p>the actual (or final) iteration of GA search;</p>
</dd>
<dt><code>run</code></dt><dd><p>the number of consecutive generations without any improvement in the best fitness value before the GA is stopped;</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>the maximum number of iterations to run before the GA search is halted;</p>
</dd>
<dt><code>suggestions</code></dt><dd><p>a matrix of user provided solutions and included in the initial population;</p>
</dd>
<dt><code>population</code></dt><dd><p>the current (or final) population;</p>
</dd>
<dt><code>elitism</code></dt><dd><p>the number of best fitness individuals to survive at each generation;</p>
</dd>
<dt><code>pcrossover</code></dt><dd><p>the crossover probability;</p>
</dd>
<dt><code>pmutation</code></dt><dd><p>the mutation probability;</p>
</dd>
<dt><code>optim</code></dt><dd><p>a logical specifying whether or not a local search using general-purpose optimisation algorithms should be used;</p>
</dd>
<dt><code>fitness</code></dt><dd><p>the values of fitness function for the current (or final) population;</p>
</dd>
<dt><code>summary</code></dt><dd><p>a matrix of summary statistics for fitness values at each iteration (along the rows);</p>
</dd>
<dt><code>bestSol</code></dt><dd><p>if <code>keepBest = TRUE</code>, the best solutions at each iteration;</p>
</dd>
<dt><code>fitnessValue</code></dt><dd><p>the best fitness value at the final iteration;</p>
</dd>
<dt><code>solution</code></dt><dd><p>the value(s) of the decision variables giving the best fitness at the final iteration.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p>For examples of usage see <code><a href="#topic+ga">ga</a></code>.</p>

<hr>
<h2 id='GA-internal'>Internal GA functions</h2><span id='topic+.printShortMatrix'></span><span id='topic+startParallel'></span><span id='topic+stopParallel'></span><span id='topic+garun'></span><span id='topic+optimProbsel'></span><span id='topic+reflectSolution'></span><span id='topic+repairSolution'></span><span id='topic+GAStartupMessage'></span>

<h3>Description</h3>

<p>Internal functions not intended to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printShortMatrix(x, head = 2, tail = 1, chead = 5, ctail = 1, ...)
startParallel(parallel = TRUE, ...) 
stopParallel(cluster, ...)
garun(x)
optimProbsel(x, q = 0.25, ...)
reflectSolution(x, lo, up, tol = sqrt(.Machine$double.eps))
repairSolution(x, lo, up) 
GAStartupMessage()
</code></pre>

<hr>
<h2 id='GA-package'>Genetic Algorithms</h2><span id='topic+GA-package'></span><span id='topic+GA'></span>

<h3>Description</h3>

<p>Flexible general-purpose toolbox implementing genetic algorithms (GAs) for stochastic optimisation. Binary, real-valued, and permutation representations are available to optimize a fitness function, i.e. a function provided by users depending on their objective function. Several genetic operators are available and can be combined to explore the best settings for the current task. Furthermore, users can define new genetic operators and easily evaluate their performances. Local search using general-purpose optimisation algorithms can be applied stochastically to exploit interesting regions. GAs can be run sequentially or in parallel, using an explicit master-slave parallelisation or a coarse-grain islands approach.
</p>


<h3>Details</h3>

<p>For a quick intro to GA package see the <a href="../doc/index.html">vignette</a> accompanying the package. Further details are provided in the papers referenced below.


</p>


<h3>References</h3>

<p>Scrucca L. (2013). GA: A Package for Genetic Algorithms in R.
<em>Journal of Statistical Software</em>, 53(4), 1-37, <a href="https://doi.org/10.18637/jss.v053.i04">doi:10.18637/jss.v053.i04</a>.
</p>
<p>Scrucca, L. (2017) On some extensions to GA package: hybrid optimisation, parallelisation and islands evolution. <em>The R Journal</em>, 9/1, 187-206. <a href="https://doi.org/10.32614/RJ-2017-008">doi:10.32614/RJ-2017-008</a>
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>

<hr>
<h2 id='gaControl'>A function for setting or retrieving defaults genetic operators</h2><span id='topic+gaControl'></span>

<h3>Description</h3>

<p>Default settings for genetic operators used in the GA package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaControl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaControl_+3A_...">...</code></td>
<td>
<p>no arguments, a single character vector, or a named list 
with components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the function is called with no arguments returns the current default 
settings, i.e., a list with the following default components:
</p>

<dl>
<dt><code>binary</code></dt><dd>

<ul>
<li> <p><code>population</code> = <code>"gabin_Population"</code>
</p>
</li>
<li> <p><code>selection</code> = <code>"gabin_lrSelection"</code>
</p>
</li>
<li> <p><code>crossover</code> = <code>"gabin_spCrossover"</code>
</p>
</li>
<li> <p><code>mutation</code> = <code>"gabin_raMutation"</code>
</p>
</li></ul>

</dd>
<dt><code>real-valued</code></dt><dd>

<ul>
<li> <p><code>population</code> = <code>"gareal_Population"</code>
</p>
</li>
<li> <p><code>selection</code> = <code>"gareal_lsSelection"</code>
</p>
</li>
<li> <p><code>crossover</code> = <code>"gareal_laCrossover"</code>
</p>
</li>
<li> <p><code>mutation</code> = <code>"gareal_raMutation"</code>
</p>
</li></ul>

</dd>
<dt><code>permutation</code></dt><dd>

<ul>
<li> <p><code>population</code> = <code>"gaperm_Population"</code>
</p>
</li>
<li> <p><code>selection</code> = <code>"gaperm_lrSelection"</code>
</p>
</li>
<li> <p><code>crossover</code> = <code>"gaperm_oxCrossover"</code>
</p>
</li>
<li> <p><code>mutation</code> = <code>"gaperm_simMutation"</code>
</p>
</li></ul>

</dd>
<dt><code>eps</code></dt><dd><p>the tolerance value used by the package functions. By default set at <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
<dt><code>useRcpp</code></dt><dd><p>a logical specifying if a faster C++ implementation of genetic operators should be used (<code>TRUE</code> by default), or an R implementation.</p>
</dd>
</dl>

<p>The function may be called with a single string specifying the name of the component. In this case the function returns the current default settings.
</p>
<p>To change the default values, a named component must be followed by a single value (in case of <code>eps</code> or <code>useRcpp</code>) or a list of component(s) specifying the name of the function for a genetic operator. See the Examples section.
</p>


<h3>Value</h3>

<p>If the argument list is empty the function returns the current list of values.  
If the argument list is not empty, the returned list is invisible.
</p>


<h3>Note</h3>

<p>The parameter values set via a call to this function will remain in effect for the rest of the session, affecting the subsequent behaviour of the functions for which the given parameters are relevant.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># get and save defaults
defaultControl &lt;- gaControl()
print(defaultControl)
# get current defaults only for binary search
gaControl("binary")
# set defaults for selection operator of binary search
gaControl("binary" = list(selection = "gabin_tourSelection"))
gaControl("binary")
# set defaults for selection and crossover operators of binary search
gaControl("binary" = list(selection = "ga_rwSelection", 
                          crossover = "gabin_uCrossover"))
gaControl("binary")
# restore defaults
gaControl(defaultControl)
gaControl()
</code></pre>

<hr>
<h2 id='gaisl'>Islands Genetic Algorithms</h2><span id='topic+gaisl'></span><span id='topic+show+2Cgaisl-method'></span><span id='topic+print+2Cgaisl-method'></span>

<h3>Description</h3>

<p>Maximization of a fitness function using islands genetic algorithms (ISLGAs). This is a distributed multiple-population GA, where the population is partitioned into several subpopulations and assigned to separated islands. Independent GAs are executed in each island, and only occasionally sparse exchanges of individuals are performed among the islands. In principle islands can evolve sequentially, but increased computational efficiency is obtained by running GAs in parallel on each island. The latter is called island parallel GAs (ISLPGAs) and it is used by default.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaisl(type = c("binary", "real-valued", "permutation"), 
      fitness, ...,
      lower, upper, nBits,
      population = gaControl(type)$population,
      selection = gaControl(type)$selection,
      crossover = gaControl(type)$crossover, 
      mutation = gaControl(type)$mutation,
      popSize = 100, 
      numIslands = 4, 
      migrationRate = 0.1, 
      migrationInterval = 10,
      pcrossover = 0.8, 
      pmutation = 0.1, 
      elitism = base::max(1, round(popSize/numIslands*0.05)), 
      updatePop = FALSE,
      postFitness = NULL,
      maxiter = 1000,
      run = maxiter,
      maxFitness = Inf,
      names = NULL,
      suggestions = NULL, 
      optim = FALSE,
      optimArgs = list(method = "L-BFGS-B", 
                       poptim = 0.05,
                       pressel = 0.5,
                       control = list(fnscale = -1, maxit = 100)),
      parallel = TRUE,
      monitor = if(interactive()) gaislMonitor else FALSE,
      seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaisl_+3A_type">type</code></td>
<td>
<p>the type of genetic algorithm to be run depending on the nature of decision variables. Possible values are: 
</p>

<dl>
<dt><code>"binary"</code></dt><dd><p>for binary representations of decision variables.</p>
</dd>
<dt><code>"real-valued"</code></dt><dd><p>for optimization problems where the decision variables are floating-point representations of real numbers.</p>
</dd>
<dt><code>"permutation"</code></dt><dd><p>for problems that involves reordering of a list.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="gaisl_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as input an individual <code>string</code> representing a potential solution, and returns a numerical value describing its &ldquo;fitness&rdquo;.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitness function. This allows to write fitness functions that keep some variables fixed during the search.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_lower">lower</code></td>
<td>
<p>a vector of length equal to the decision variables providing the lower bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this argument was named <code>min</code>; its usage is allowed but deprecated.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_upper">upper</code></td>
<td>
<p>a vector of length equal to the decision variables providing the upper bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this argument was named <code>max</code>; its usage is allowed but deprecated.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_nbits">nBits</code></td>
<td>
<p>a value specifying the number of bits to be used in binary encoded optimizations.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_population">population</code></td>
<td>
<p>an R function for randomly generating an initial population. See <code><a href="#topic+ga_Population">ga_Population</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_numislands">numIslands</code></td>
<td>
<p>an integer value specifying the number of islands to be used in a <em>ring topology</em>, in which each island is connected unidirectionally with another island, hence forming a single continuous pathway.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_migrationrate">migrationRate</code></td>
<td>
<p>a value in the range $[0,1]$ providing the proportion of individuals that should migrate between the islands.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_migrationinterval">migrationInterval</code></td>
<td>
<p>an integer value specifying the number of iterations at which exchange of individuals takes place.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_selection">selection</code></td>
<td>
<p>an R function performing selection, i.e. a function which generates a new population of individuals from the current population probabilistically according to individual fitness. See <code><a href="#topic+ga_Selection">ga_Selection</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_crossover">crossover</code></td>
<td>
<p>an R function performing crossover, i.e. a function which forms offsprings by combining part of the genetic information from their parents. See <code><a href="#topic+ga_Crossover">ga_Crossover</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_mutation">mutation</code></td>
<td>
<p>an R function performing mutation, i.e. a function which randomly alters the values of some genes in a parent chromosome. See <code><a href="#topic+ga_Mutation">ga_Mutation</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_popsize">popSize</code></td>
<td>
<p>the population size.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_updatepop">updatePop</code></td>
<td>
<p>a logical defaulting to <code>FALSE</code>. If set at <code>TRUE</code> the first attribute attached to the value returned by the user-defined fitness function is used to update the population. <br />
<em>Be careful though, this is an experimental feature!</em></p>
</td></tr>
<tr><td><code id="gaisl_+3A_postfitness">postFitness</code></td>
<td>
<p>a user-defined function which, if provided, receives the current <code>ga-class</code> object as input, performs post fitness-evaluation steps, then returns an updated version of the object which is used to update the GA search.<br />
<em>Be careful though, this is an experimental feature!</em></p>
</td></tr>
<tr><td><code id="gaisl_+3A_pcrossover">pcrossover</code></td>
<td>
<p>the probability of crossover between pairs of chromosomes. Typically this is a large value and by default is set to 0.8.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_pmutation">pmutation</code></td>
<td>
<p>the probability of mutation in a parent chromosome. Usually mutation occurs with a small probability, and by default is set to 0.1.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_elitism">elitism</code></td>
<td>
<p>the number of best fitness individuals to survive at each generation. By default the top 5% individuals in each island will survive at each iteration.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations to run before the GA search is halted.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_run">run</code></td>
<td>
<p>the number of consecutive generations without any improvement in the best fitness value before the GA is stopped.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_maxfitness">maxFitness</code></td>
<td>
<p>the upper bound on the fitness function after that the GA search is interrupted.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_names">names</code></td>
<td>
<p>a vector of character strings providing the names of decision variables.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_suggestions">suggestions</code></td>
<td>
<p>a matrix of solutions strings to be included in the initial population. If provided the number of columns must match the number of decision variables.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_optim">optim</code></td>
<td>
<p>a logical defaulting to <code>FALSE</code> determining whether or not a local search using general-purpose optimisation algorithms should be used. See argument <code>optimArgs</code> for further details and finer control.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_optimargs">optimArgs</code></td>
<td>
<p>a list controlling the local search algorithm with the following components:
</p>

<dl>
<dt><code>method</code></dt><dd><p>a string specifying the general-purpose optimisation method to be used, by default is set to <code>"L-BFGS-B"</code>. Other possible methods are those reported in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>poptim</code></dt><dd><p>a value in the range [0,1] specifying the probability of performing a local search at each iteration of GA (default 0.1).</p>
</dd>
<dt><code>pressel</code></dt><dd><p>a value in the range [0,1] specifying the pressure selection (default 0.5). The local search is started from a random solution selected with probability proportional to fitness. High values of <code>pressel</code> tend to select the solutions with the largest fitness, whereas low values of <code>pressel</code> assign quasi-uniform probabilities to any solution.</p>
</dd>
<dt><code>control</code></dt><dd><p>a list of control parameters. See 'Details' section in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="gaisl_+3A_parallel">parallel</code></td>
<td>
<p>An optional argument which allows to specify if the Islands Genetic Algorithm should be run sequentially or in parallel. 
</p>
<p>For a single machine with multiple cores, possible values are: 
</p>

<ul>
<li><p> a logical value specifying if parallel computing should be used (<code>TRUE</code>) or not (<code>FALSE</code>, default) for running GAs on each island;
</p>
</li>
<li><p> a numerical value which gives the number of cores to employ. By default, this is obtained from the function <code><a href="parallel.html#topic+detectCores">detectCores</a></code>; 
</p>
</li>
<li><p> a character string specifying the type of parallelisation to use. This depends on system OS: on Windows OS only <code>"snow"</code> type functionality is available, while on Unix/Linux/Mac OSX both <code>"snow"</code> and <code>"multicore"</code> (default) functionalities are available.
</p>
</li></ul>

<p>In all the cases described above, at the end of the search the cluster is automatically stopped by shutting down the workers.
</p>
<p>If a cluster of multiple machines is available, evolution of GAs on each island can be executed in parallel using all, or a subset of, the cores available to the machines belonging to the cluster. However, this option requires more work from the user, who needs to set up and register a parallel back end. 
In this case the cluster must be explicitly stopped with <code><a href="parallel.html#topic+stopCluster">stopCluster</a></code>.
</p>
</td></tr>
<tr><td><code id="gaisl_+3A_monitor">monitor</code></td>
<td>
<p>a logical or an R function which takes as input the current state of the <code>gaisl-class</code> object and show the evolution of the search in different epochs. By default, for interactive sessions, the function <code><a href="#topic+gaislMonitor">gaislMonitor</a></code> prints the average and best fitness values at each epoch for each island. In non interactive sessions, by default <code>monitor = FALSE</code> so any output is suppressed.</p>
</td></tr>
<tr><td><code id="gaisl_+3A_seed">seed</code></td>
<td>
<p>an integer value containing the random number generator state. This argument can be used to replicate the results of a ISLGA search. Note that if parallel computing is required, the <span class="pkg">doRNG</span> package must be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genetic algorithms (GAs) are stochastic search algorithms inspired by the basic principles of biological evolution and natural selection. GAs simulate the evolution of living organisms, where the fittest individuals dominate over the weaker ones, by mimicking the biological mechanisms of evolution, such as selection, crossover and mutation.
</p>
<p>The <code>gaisl</code> function implements the islands GAs approach, where the population is partitioned into several subpopulations and assigned to separated islands. Independent GAs are executed in each island, and only occasionally sparse exchanges of individuals are performed among the islands. The algorithm can be run in parallel or sequentially. 
For more information on GAs see <code><a href="#topic+ga">ga</a></code>. 
</p>


<h3>Value</h3>

<p>Returns an object of class <code>gaisl-class</code>. See <code><a href="#topic+gaisl-class">gaisl-class</a></code> for a description of available slots information.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a></p>


<h3>References</h3>

<p>Luque G., Alba E. (2011) <em>Parallel Genetic Algorithms: Theory and Real World Applications</em>. Springer.
</p>
<p>Luke S. (2013) <em>Essentials of Metaheuristics</em>, 2nd edition. Lulu.
</p>
<p>Scrucca, L. (2017) On some extensions to GA package: hybrid optimisation, parallelisation and islands evolution. <em>The R Journal</em>, 9/1, 187-206. <a href="https://journal.r-project.org/archive/2017/RJ-2017-008/">https://journal.r-project.org/archive/2017/RJ-2017-008/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary+2Cgaisl-method">summary,gaisl-method</a></code>, 
<code><a href="#topic+plot+2Cgaisl-method">plot,gaisl-method</a></code>, 
<code><a href="#topic+gaisl-class">gaisl-class</a></code>,
<code><a href="#topic+ga">ga</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# two-dimensional Rastrigin function
Rastrigin &lt;- function(x1, x2)
{
  20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}

x1 &lt;- x2 &lt;- seq(-5.12, 5.12, by = 0.1)
f &lt;- outer(x1, x2, Rastrigin)
persp3D(x1, x2, f, theta = 50, phi = 20)
filled.contour(x1, x2, f, color.palette = jet.colors)

GA &lt;- gaisl(type = "real-valued", 
            fitness =  function(x) -Rastrigin(x[1], x[2]),
            lower = c(-5.12, -5.12), upper = c(5.12, 5.12), 
            popSize = 80, maxiter = 500, 
            numIslands = 4, migrationInterval = 50)
summary(GA)
plot(GA)

## End(Not run)
</code></pre>

<hr>
<h2 id='gaisl-class'>Class &quot;gaisl&quot;</h2><span id='topic+gaisl-class'></span>

<h3>Description</h3>

<p>An S4 class for islands genetic algorithms (ISLGAs)</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the <code><a href="#topic+gaisl">gaisl</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>an object of class <code>"call"</code> representing the matched call;</p>
</dd>
<dt><code>type</code></dt><dd><p>a character string specifying the type of genetic algorithm used;</p>
</dd>
<dt><code>lower</code></dt><dd><p>a vector providing for each decision variable the lower bounds of the search space in case of real-valued or permutation encoded optimisations. Formerly this slot was named <code>min</code>;</p>
</dd>
<dt><code>upper</code></dt><dd><p>a vector providing for each decision variable the upper bounds of the search space in case of real-valued or permutation encoded optimizations. Formerly this slot was named <code>max</code>;</p>
</dd>
<dt><code>nBits</code></dt><dd><p>a value specifying the number of bits to be used in binary encoded optimizations;</p>
</dd>
<dt><code>names</code></dt><dd><p>a vector of character strings providing the names of decision variables (optional);</p>
</dd>
<dt><code>popSize</code></dt><dd><p>the population size;</p>
</dd>
<dt><code>numIslands</code></dt><dd><p>the number of islands;</p>
</dd>
<dt><code>migrationRate</code></dt><dd><p>the migration rate;</p>
</dd>
<dt><code>migrationInterval</code></dt><dd><p>the migration interval;</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>the maximum number of ISLGA iterations before the search is halted;</p>
</dd>
<dt><code>run</code></dt><dd><p>the number of consecutive generations without any improvement in the best fitness value before the ISLGA is stopped;</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>the maximum number of iterations to run before the GA search is halted;</p>
</dd>
<dt><code>suggestions</code></dt><dd><p>a matrix of user provided solutions and included in the initial population;</p>
</dd>
<dt><code>elitism</code></dt><dd><p>the number of best fitness individuals to survive at each generation;</p>
</dd>
<dt><code>pcrossover</code></dt><dd><p>the crossover probability;</p>
</dd>
<dt><code>pmutation</code></dt><dd><p>the mutation probability;</p>
</dd>
<dt><code>optim</code></dt><dd><p>a logical specifying whether or not a local search using general-purpose optimisation algorithms should be used;</p>
</dd>
<dt><code>islands</code></dt><dd><p>a list containing the objects of class <code>ga</code> corresponding to each island GA evolution;</p>
</dd>
<dt><code>summary</code></dt><dd><p>a list of matrices of summary statistics for fitness values at each iteration (along the rows). Each element of the list corresponds to the evolution of an island;</p>
</dd>
<dt><code>fitnessValues</code></dt><dd><p>a list of best fitness values found in each island at the final iteration;</p>
</dd>
<dt><code>solutions</code></dt><dd><p>a list of matrices, one for each island, containing the values of the decision variables giving the best fitness at the final iteration;</p>
</dd>
<dt><code>fitnessValue</code></dt><dd><p>the best fitness value at the final iteration;</p>
</dd>
<dt><code>solution</code></dt><dd><p>a matrix containing the values of the decision variables giving the best fitness at the final iteration.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p>For examples of usage see <code><a href="#topic+gaisl">gaisl</a></code>.</p>

<hr>
<h2 id='gaMonitor'>Monitor genetic algorithm evolution</h2><span id='topic+gaMonitor'></span><span id='topic+gaislMonitor'></span>

<h3>Description</h3>

<p>Functions to print summary statistics of fitness values at each iteration of a GA search.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaMonitor(object, digits = getOption("digits"), ...)

gaislMonitor(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaMonitor_+3A_object">object</code></td>
<td>
<p>an object of class <code>ga-class</code> or <code>gaisl-class</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code> or <code><a href="#topic+gaisl">gaisl</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="gaMonitor_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits.</p>
</td></tr>
<tr><td><code id="gaMonitor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions print a summary of current GA step on the console.<br />
By default, <code>gaMonitor</code> is called in interactive sessions by <code><a href="#topic+ga">ga</a></code>. The old monitoring function, used as the default until version 2.2 of <span class="pkg">GA</span> package, is provided in <code>gaMonitor2</code>.<br />
By default, <code>gaislMonitor</code> is called in interactive sessions by <code><a href="#topic+gaisl">gaisl</a></code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>

<hr>
<h2 id='gaSummary'>Summarize genetic algorithm evolution</h2><span id='topic+gaSummary'></span>

<h3>Description</h3>

<p>A function which returns fitness summary statistics at each iteration of GA search.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaSummary(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaSummary_+3A_x">x</code></td>
<td>
<p>a vector of fitness values for which summary statistics should be computed.</p>
</td></tr>
<tr><td><code id="gaSummary_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes summary statistics for a vector of fitness values at current iteration of GA search.</p>


<h3>Value</h3>

<p>A vector with the following values: <code>(max, mean, median, min)</code>
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code></p>

<hr>
<h2 id='numericOrNA-class'>Virtual Class &quot;numericOrNA&quot; - Simple Class for sub-assignment Values</h2><span id='topic+numericOrNA-class'></span>

<h3>Description</h3>

<p>The class <code>"numericOrNA"</code> is a simple class union 
(<code><a href="methods.html#topic+setClassUnion">setClassUnion</a></code>) of <code>"numeric"</code> and <code>"logical"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Since it is a virtual Class, no objects
may be created from it.</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("numericOrNA")
</code></pre>

<hr>
<h2 id='palettes'>Colours palettes</h2><span id='topic+jet.colors'></span><span id='topic+spectral.colors'></span><span id='topic+bl2gr.colors'></span>

<h3>Description</h3>

<p>Functions for creating a vector of colours from pre-specified palettes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jet.colors(n)

spectral.colors(n)

bl2gr.colors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palettes_+3A_n">n</code></td>
<td>
<p>a numerical value specifying the number of colours in the palette.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>jet.colors()</code> creates a palette of colours which tend to have high brightness and not uniform luminance. Furthermore, the brightest colours, yellow and cyan, are used for intermediate data values, and this has the effect of emphasizing uninteresting (and arbitrary) values while de-emphasizing the extremes. For these reasons this popular palette is not recommended.<br />
<code>spectral.colors()</code> creates a palette based on ColorBrewer <a href="https://colorbrewer2.org">https://colorbrewer2.org</a>, so the resulting colours have a much uniform luminance.<br />
The <code>bl2gr.colors()</code> palette returns a palette of colours from blue to green.
</p>


<h3>Value</h3>

<p>Returns a character vector of colours encoded in hexadecimal values.</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>jet.colors(9)
spectral.colors(9)
bl2gr.colors(9)

par(mfrow = c(3,1), mar = c(1,1,1,1))
n = 21
image(1:21, 1, as.matrix(1:21), col = jet.colors(21),
      ylab = "", xlab = "", xaxt = "n", yaxt = "n", bty = "n")
image(1:21, 1, as.matrix(1:21), col = spectral.colors(21),
      ylab = "", xlab = "", xaxt = "n", yaxt = "n", bty = "n")
image(1:21, 1, as.matrix(1:21), col = bl2gr.colors(21),
      ylab = "", xlab = "", xaxt = "n", yaxt = "n", bty = "n")
</code></pre>

<hr>
<h2 id='parNames-methods'>Parameters or decision variables names from an object of class <code><a href="#topic+ga-class">ga-class</a></code>.</h2><span id='topic+parNames'></span><span id='topic+parNames+2Cga-method'></span>

<h3>Description</h3>

<p>A method for obtaining the names of parameters or decision variables 
from an object of class <code><a href="#topic+ga-class">ga-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parNames(object, ...)
## S4 method for signature 'ga'
parNames(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parNames-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ga"</code>, usually resulting from a call to function <code><a href="#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="parNames-methods_+3A_...">...</code></td>
<td>
<p>Further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character values providing the names of parameters or decision variables.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code></p>

<hr>
<h2 id='persp3D'>Perspective plot with colour levels</h2><span id='topic+persp3D'></span>

<h3>Description</h3>

<p>This function draws a perspective plot of a surface with different levels in different colours.</p>


<h3>Usage</h3>

<pre><code class='language-R'>persp3D(x, y, z, theta = 30, phi = 20, d = 5, expand = 2/3,
        xlim = range(x, finite = TRUE), ylim = range(y, finite = TRUE), 
        zlim = range(z, finite = TRUE), levels = pretty(zlim, nlevels),
        nlevels = 20, col.palette = jet.colors, border = NA, 
        ticktype = "detailed", xlab = NULL, ylab = NULL, zlab = NULL, 
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp3D_+3A_x">x</code>, <code id="persp3D_+3A_y">y</code></td>
<td>
<p>locations of grid lines at which the values in <code>z</code> are measured. These must be in ascending order. By default, equally spaced values from 0 to 1 are used. If <code>x</code> is a list, its components <code>x$x</code> and <code>x$y</code> are used for <code>x</code> and <code>y</code>, respectively.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_z">z</code></td>
<td>
<p>a matrix containing the values to be plotted (NAs are allowed).</p>
</td></tr> 
<tr><td><code id="persp3D_+3A_theta">theta</code>, <code id="persp3D_+3A_phi">phi</code></td>
<td>
<p>angles defining the viewing direction. <code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_d">d</code></td>
<td>
<p>a value which can be used to vary the strength of the perspective transformation.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_expand">expand</code></td>
<td>
<p>a expansion factor applied to the <code>z</code> coordinates.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_xlim">xlim</code>, <code id="persp3D_+3A_ylim">ylim</code>, <code id="persp3D_+3A_zlim">zlim</code></td>
<td>
<p>x-, y- and z-limits for the axes.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_levels">levels</code></td>
<td>
<p>a vector of values specifying the levels to be used for plotting the surface with different colours.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_nlevels">nlevels</code></td>
<td>
<p>a value specifying the number of levels to be used for plotting. This value is used if <code>levels</code> argument is not specified.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_col.palette">col.palette</code></td>
<td>
<p>the colour palette used for plotting.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_border">border</code></td>
<td>
<p>the colour of the line drawn around the surface facets. By default is set to <code>NA</code> so no borders are drawn.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_ticktype">ticktype</code></td>
<td>
<p>a character specifying the type of axes tickmarks. By default <code>"detailed"</code> ticks are drawn.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_xlab">xlab</code>, <code id="persp3D_+3A_ylab">ylab</code>, <code id="persp3D_+3A_zlab">zlab</code></td>
<td>
<p>character strings specifying the titles for the axes.</p>
</td></tr>
<tr><td><code id="persp3D_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enhances the default perspective plot for drawing 3-dimensional surfaces.</p>


<h3>Value</h3>

<p>Return a list with the following elements:
</p>
<table>
<tr><td><code>persp</code></td>
<td>
<p>the viewing transformation matrix (see <code><a href="graphics.html#topic+persp">persp</a></code>);</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>a vector of values giving the levels used for plotting the surface;</p>
</td></tr>
<tr><td><code>colors</code></td>
<td>
<p>a vector of strings giving the colour used for plotting the surface.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+persp">persp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- x &lt;- seq(-10, 10, length=60)
f &lt;- function(x,y) { r &lt;- sqrt(x^2+y^2); 10 * sin(r)/r }
z &lt;- outer(x, y, f)
persp3D(x, y, z, theta = 30, phi = 30, expand = 0.5)
persp3D(x, y, z, col.palette = heat.colors, phi = 30, theta = 225, 
        box = TRUE, border = NA, shade = .4)
x1 &lt;- seq(-3,3,length=50)
x2 &lt;- seq(-3,3,length=50)
y &lt;- function(x1, x2) sin(x1)+cos(x2)
persp3D(x1, x2, outer(x1,x2,y), zlab="y", theta = 150, phi = 20, expand = 0.6)
</code></pre>

<hr>
<h2 id='plot.de-method'>Plot of Differential Evolution search path</h2><span id='topic+plot+2Cde-method'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code><a href="#topic+de-class">de-class</a></code> objects gives a plot
of best and average fitness values found during the iterations of the 
DE search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'de'
plot(x, y, ylim, cex.points = 0.7, 
     col = c("green3", "dodgerblue3",  adjustcolor("green3", alpha.f = 0.1)),
     pch = c(16, 1), lty = c(1,2), legend = TRUE, grid = graphics::grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.de-method_+3A_x">x</code></td>
<td>
<p>An object of class <code>"ga"</code>.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_ylim">ylim</code></td>
<td>
<p>A vector of two values specifying the limits on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_cex.points">cex.points</code></td>
<td>
<p>The magnification to be used for points.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_col">col</code></td>
<td>
<p>The colours to be used for best and average fitness values.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_pch">pch</code></td>
<td>
<p>The type of points to be used for best and average fitness values.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_lty">lty</code></td>
<td>
<p>The type of lines to be used for best and average fitness values.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_legend">legend</code></td>
<td>
<p>A logical specifying if a legend should be included.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_grid">grid</code></td>
<td>
<p>A function for grid drawing of NULL to avoid drawing one.</p>
</td></tr>
<tr><td><code id="plot.de-method_+3A_...">...</code></td>
<td>
<p>Further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot best and average fitness values at each iteration of DE search.</p>


<h3>Value</h3>

<p>The method invisibly return a <code>data.frame</code> with the iterations and summary statistics for the fitness function evaluated at each iteration.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+de">de</a></code>, <code><a href="#topic+de-class">de-class</a></code>, <code><a href="#topic+plot+2Cde-method">plot,de-method</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in help(de)
</code></pre>

<hr>
<h2 id='plot.ga-method'>Plot of Genetic Algorithm search path</h2><span id='topic+plot+2Cga-method'></span><span id='topic+plot.ga'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code><a href="#topic+ga-class">ga-class</a></code> objects gives a plot
of best and average fitness values found during the iterations of the 
GA search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ga'
plot(x, y, ylim, cex.points = 0.7, 
     col = c("green3", "dodgerblue3",  adjustcolor("green3", alpha.f = 0.1)),
     pch = c(16, 1), lty = c(1,2), legend = TRUE, grid = graphics::grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ga-method_+3A_x">x</code></td>
<td>
<p>An object of class <code>"ga"</code>.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_ylim">ylim</code></td>
<td>
<p>A vector of two values specifying the limits on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_cex.points">cex.points</code></td>
<td>
<p>The magnification to be used for points.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_col">col</code></td>
<td>
<p>The colours to be used for best and average fitness values.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_pch">pch</code></td>
<td>
<p>The type of points to be used for best and average fitness values.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_lty">lty</code></td>
<td>
<p>The type of lines to be used for best and average fitness values.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_legend">legend</code></td>
<td>
<p>A logical specifying if a legend should be included.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_grid">grid</code></td>
<td>
<p>A function for grid drawing of NULL to avoid drawing one.</p>
</td></tr>
<tr><td><code id="plot.ga-method_+3A_...">...</code></td>
<td>
<p>Further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot best and average fitness values at each iteration of GA search.</p>


<h3>Value</h3>

<p>The method invisibly return a <code>data.frame</code> with the iterations and summary statistics for the fitness function evaluated at each iteration.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code>, <code><a href="#topic+ga-class">ga-class</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in help(ga)

# The following code shows how to obtain graphs using the 
# ggplot2 plotting system 
## Not run: 
GA &lt;- ga(type = "real-valued", 
         fitness = function(x) -(abs(x)+cos(x)), 
         lower = -20, upper = 20, 
         popSize = 20, pmutation = 0.2, maxiter = 50)
out &lt;- plot(GA)
library(reshape2)
df &lt;- melt(out[,c(1:3,5)], id.var = "iter")
library(ggplot2)
ggplot(out) +
  geom_ribbon(aes(x = iter, ymin = median, ymax = max, 
                  colour = "median", fill = "median")) +
  geom_line(aes(x = iter, y = max, colour = "max")) +
  geom_point(aes(x = iter, y = max, colour = "max")) +
  geom_line(aes(x = iter, y = mean, colour = "mean"), lty = 2) +
  geom_point(aes(x = iter, y = mean, colour = "mean"), pch = 1) +
  xlab("Generation") +  ylab("Fitness values") +
  scale_colour_manual(breaks = c("max", "mean", "median"),
                      values = c("green3", "dodgerblue3", adjustcolor("green3", alpha.f = 0.1))) +
  scale_fill_manual(breaks = "median",
                    values = adjustcolor("green3", alpha.f = 0.1)) +
  guides(fill = "none", 
         colour = guide_legend(override.aes = 
                                 list(fill = c(NA, NA, adjustcolor("green3", alpha.f = 0.1)),
                                       pch = c(19,1,NA)))) +
  theme_bw() +
  theme(legend.title = element_blank(), 
        legend.pos = "top",
        legend.background = element_blank())

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.gaisl-method'>Plot of Islands Genetic Algorithm search path</h2><span id='topic+plot+2Cgaisl-method'></span><span id='topic+plot.gaisl'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code><a href="#topic+gaisl-class">gaisl-class</a></code> objects gives a plot
of best fitness values found in each island during the GA iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gaisl'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gaisl-method_+3A_x">x</code></td>
<td>
<p>An object of class <code>"gaisl"</code>.</p>
</td></tr>
<tr><td><code id="plot.gaisl-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.gaisl-method_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, such as <code>ylim</code>, <code>ylab</code>, etc., or to <code><a href="graphics.html#topic+matplot">matplot</a></code>, such as <code>col</code>, <code>lty</code>, and <code>lwd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot best fitness values found in each island during the GA iterations.</p>


<h3>Value</h3>

<p>The method invisibly return a list with the following components:
</p>
<table>
<tr><td><code>iter</code></td>
<td>
<p>a vector of values specifying the iteration.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a matrix of best fitness values for each island along the columns.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaisl">gaisl</a></code>, <code><a href="#topic+gaisl-class">gaisl-class</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in help(gaisl)
</code></pre>

<hr>
<h2 id='summary.de-method'>Summary for Differential Evolution</h2><span id='topic+summary+2Cde-method'></span><span id='topic+summary.de'></span><span id='topic+print.summary.de'></span>

<h3>Description</h3>

<p>Summary method for class <code><a href="#topic+de-class">de-class</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'de'
summary(object, ...)

## S3 method for class 'summary.de'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.de-method_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+de-class">de-class</a></code>.</p>
</td></tr>
<tr><td><code id="summary.de-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.de</code>.</p>
</td></tr>
<tr><td><code id="summary.de-method_+3A_digits">digits</code></td>
<td>
<p>number of significant digits.</p>
</td></tr>
<tr><td><code id="summary.de-method_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> function returns an object of class <code>summary.de</code> which can be printed by the corresponding <code>print</code> method. The function also returns invisibly a list with the information from the differential evolution search.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+de">de</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) abs(x)+cos(x)
DE &lt;- de(fitness = function(x) -f(x), 
         lower = -20, upper = 20, run = 50)
out &lt;- summary(DE)
print(out)
str(out)
</code></pre>

<hr>
<h2 id='summary.ga-method'>Summary for Genetic Algorithms</h2><span id='topic+summary+2Cga-method'></span><span id='topic+summary.ga'></span><span id='topic+print.summary.ga'></span>

<h3>Description</h3>

<p>Summary method for class <code><a href="#topic+ga-class">ga-class</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ga'
summary(object, ...)

## S3 method for class 'summary.ga'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ga-method_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+ga-class">ga-class</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ga-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.ga</code>.</p>
</td></tr>
<tr><td><code id="summary.ga-method_+3A_digits">digits</code></td>
<td>
<p>number of significant digits.</p>
</td></tr>
<tr><td><code id="summary.ga-method_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> function returns an object of class <code>summary.ga</code> which can be printed by the corresponding <code>print</code> method. The function also returns invisibly a list with the information from the genetic algorithm search.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+ga">ga</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x)  abs(x)+cos(x)
GA &lt;- ga(type = "real-valued", 
         fitness = function(x) -f(x), 
         lower = -20, upper = 20, run = 50)
out &lt;- summary(GA)
print(out)
str(out)
</code></pre>

<hr>
<h2 id='summary.gaisl-method'>Summary for Islands Genetic Algorithms</h2><span id='topic+summary+2Cgaisl-method'></span><span id='topic+summary.gaisl'></span><span id='topic+print.summary.gaisl'></span>

<h3>Description</h3>

<p>Summary method for class <code><a href="#topic+gaisl-class">gaisl-class</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gaisl'
summary(object, ...)

## S3 method for class 'summary.gaisl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gaisl-method_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+gaisl-class">gaisl-class</a></code>.</p>
</td></tr>
<tr><td><code id="summary.gaisl-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.gaisl</code>.</p>
</td></tr>
<tr><td><code id="summary.gaisl-method_+3A_digits">digits</code></td>
<td>
<p>number of significant digits.</p>
</td></tr>
<tr><td><code id="summary.gaisl-method_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> function returns an object of class <code>summary.gaisl</code> which can be printed by the corresponding <code>print</code> method. The function also returns invisibly a list with the information from the islands genetic algorithm search.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaisl">gaisl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- function(x)  abs(x)+cos(x)
GA &lt;- gaisl(type = "real-valued", 
            fitness = function(x) -f(x), 
            lower = -20, upper = 20, run = 10,
            numIslands = 4)
out &lt;- summary(GA)
print(out)
str(out)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
