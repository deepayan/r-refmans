<!DOCTYPE html><html lang="en"><head><title>Help for package RapidPolygonLookup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RapidPolygonLookup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RapidPolygonLookup-package'><p>Polygon lookup using kd trees</p></a></li>
<li><a href='#AddRanges'><p>Add xlim and ylim for each polygon</p></a></li>
<li><a href='#california.tract10'><p>Census Tract spatial polygons for the state of California</p></a></li>
<li><a href='#CropSpatialPolygonsDataFrame'><p>Crop polygons to bounding box and adds polygon centers</p></a></li>
<li><a href='#DiagnoseFailure'><p>Visualize points that could not be mapped using RapidPolygonLookup()</p></a></li>
<li><a href='#FindPolygonInRanges'><p>Use range-search to map points to polygon.</p></a></li>
<li><a href='#RapidPolygonLookup'><p>Efficient spatial polygon search using kd-trees.</p></a></li>
<li><a href='#SearchForPolygon'><p>Use kd-trees to search the nearest neighbour polygons for a given set of points</p></a></li>
<li><a href='#sf.crime.2012'><p>Sample data with lat/long information</p></a></li>
<li><a href='#sf.polys'><p>Spatial polygons of San Francisco</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>POLYGON LOOKUP USING KD TREES</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-01-13</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0), sp, RANN, PBSmapping, RgoogleMaps</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Loecher &lt;markus.loecher@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates efficient polygon search using kd trees.
    Coordinate level spatial data can be aggregated to higher geographical
    identities like census blocks, ZIP codes or police district boundaries.
    This process requires mapping each point in the given data set to a
    particular identity of the desired geographical hierarchy. Unless efficient
    data structures are used, this can be a daunting task. The operation
    point.in.polygon() from the package sp is computationally expensive.
    Here, we exploit kd-trees as efficient nearest neighbor search algorithm
    to dramatically reduce the effective number of polygons being searched.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-13 09:21:30 UTC; loecherm</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-14 10:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='RapidPolygonLookup-package'>Polygon lookup using kd trees</h2><span id='topic+RapidPolygonLookup-package'></span>

<h3>Description</h3>

<p>This package facilitates efficient polygon search using kd trees.
Coordinate level spatial data can be aggregated to higher geographical
identities like census blocks, ZIP codes or police district boundaries.
This process requires mapping each point in the given data set to a
particular identity of the desired geographical hierarchy. Unless efficient
data structures are used, this can be a daunting task. The operation
point.in.polygon() from the package sp is computationally expensive.
Here, we exploit kd-trees as efficient nearest neighbor search algorithm
to dramatically reduce the effective number of polygons being searched.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">Package: </td><td style="text-align: left;"> RapidPolygonLookup</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Polygon lookup using kd trees</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-11-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> 
R(&gt;= 2.10.0),
sp,
RANN,
PBSmapping,
RgoogleMaps</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> "Markus Loecher, Berlin School of Economics and Law (BSEL)"
&lt;markus.loecher@gmail.com&gt;,
Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> "Markus Loecher" &lt;markus.loecher@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>

<hr>
<h2 id='AddRanges'>Add xlim and ylim for each polygon</h2><span id='topic+AddRanges'></span>

<h3>Description</h3>

<p>This function computes the bounding box for each polygon and adds this information
to the list. The bounding boxes can be used in various applications.
Our main motivation is for the massive PointsInPolygon search to exclude those 
polygons as candidates whose bounding box does not contain the current point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddRanges(poly.list)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddRanges_+3A_poly.list">poly.list</code></td>
<td>
<p>polygon list with three elements: data, polys, and poly.centers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns augmented polygon list with additional element &ndash; &quot;ranges&quot; </p>


<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sf.polys, envir = environment())
sf.polys &lt;- AddRanges(sf.polys)
str(sf.polys$ranges)

</code></pre>

<hr>
<h2 id='california.tract10'>Census Tract spatial polygons for the state of California</h2><span id='topic+california.tract10'></span>

<h3>Description</h3>

<p>Object of class SpatialPolygonsDataFrame containing spatial polygons of Census tracts in California. The object has been originally created from the 2010 US Census tiger/line boundary files (http://www.census.gov/geo/www/tiger/) for Census Tracts. The polygons have been manually cropped to the area in and around San Francisco.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(california.tract10)</code></pre>


<h3>Format</h3>

<p>An object of class SpatialPolygonsDataFrame from the sp package
</p>

<dl>
<dt><code>data</code></dt><dd><p>data frame containing information for 457 variables (excluding ids) available from the summary file 1</p>
</dd>
<dt><code>polygons</code></dt><dd><p>polygons of Census Tracts</p>
</dd>
<dt><code>plotOrder</code></dt><dd><p>plotting order of polygons</p>
</dd>
<dt><code>bbox</code></dt><dd><p>bounding box of spatial polygons</p>
</dd>
<dt><code>proj4string</code></dt><dd><p>projection of polygons. All polygons are projected in CRS(&quot; +proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs +towgs84=0,0,0&quot;)</p>
</dd>
</dl>



<h3>Details</h3>

<p>For details on the summary variables present in the data frame please refer 
</p>
<p>http://www.census.gov/prod/cen2000/doc/sf1.pdf 
</p>


<h3>Source</h3>

<p>http://cran.r-project.org/web/packages/UScensus2010/index.html</p>


<h3>References</h3>

<p>Zack W. Almquist (2010). US Census Spatial and Demographic Data in R: The UScensus2000 Suite of Packages. Journal of Statistical Software, 37(6), 1-31. URL http://www.jstatsoft.org/v37/i06/
http://www.census.gov/prod/cen2000/doc/sf1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(california.tract10, envir = environment())
plot(california.tract10)
</code></pre>

<hr>
<h2 id='CropSpatialPolygonsDataFrame'>Crop polygons to bounding box and adds polygon centers</h2><span id='topic+CropSpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p>This function serves three purposes:
(i)   changes the (complicated) data structure of a spatial polygon (from the sp package) to a format which is aligned with the (simpler) PBSmapping polygon format.
(ii)  clips/crops the polygons to a pre specified bounding box
(iii) computes and adds the polygon centers for each polygon </p>


<h3>Usage</h3>

<pre><code class='language-R'>CropSpatialPolygonsDataFrame(x, bb = NULL, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CropSpatialPolygonsDataFrame_+3A_x">x</code></td>
<td>
<p>object of class SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="CropSpatialPolygonsDataFrame_+3A_bb">bb</code></td>
<td>
<p>bounding box to crop the polygons</p>
</td></tr>
<tr><td><code id="CropSpatialPolygonsDataFrame_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New list with separate entries for data, polys, and poly centers</p>


<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'># San Francisco:
data(california.tract10, envir = environment())
sf.polys &lt;- CropSpatialPolygonsDataFrame(x= california.tract10, 
                                       bb= data.frame(X=c(-122.5132, -122.37), 
                                                      Y= c(37.70760, 37.81849)))

</code></pre>

<hr>
<h2 id='DiagnoseFailure'>Visualize points that could not be mapped using RapidPolygonLookup()</h2><span id='topic+DiagnoseFailure'></span>

<h3>Description</h3>

<p>This functions plots the points that could not be mapped using RapidPolygonLookup()
The points are overlayed on the polygons to contextualize their
geographical location and understand the reason behind their exclusion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiagnoseFailure(XY.polys, poly.list = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DiagnoseFailure_+3A_xy.polys">XY.polys</code></td>
<td>
<p>output from function RapidPolygonLookup()</p>
</td></tr>
<tr><td><code id="DiagnoseFailure_+3A_poly.list">poly.list</code></td>
<td>
<p>polygon list with 3 or 4 elements: data, polys, poly.centers, and possibly ranges. Needs to be supplied if RapidPolygonLookup() was run with keep.data= FALSE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sf.crime.2012, envir = environment())
data(sf.polys, envir = environment())
cat(nrow(sf.crime.2012), "rows in SF crime \n")

XY.kdtree &lt;- RapidPolygonLookup(sf.crime.2012[,c("X","Y")], poly.list= sf.polys, 
                                k= 10, N= 1000, 
                                poly.id= "fips", poly.id.colname= "census.block", 
                                keep.data= TRUE, verbose= TRUE)
DiagnoseFailure(XY.kdtree)
</code></pre>

<hr>
<h2 id='FindPolygonInRanges'>Use range-search to map points to polygon.</h2><span id='topic+FindPolygonInRanges'></span>

<h3>Description</h3>

<p>This function searches the lat-long ranges of polygons to come up
with a shorter list of candidates on which point.in.polygon() from the
sp package can be applied.</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindPolygonInRanges(poly.list, XY, poly.id = "fips", poly.id.colname = "census.block", 
    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindPolygonInRanges_+3A_poly.list">poly.list</code></td>
<td>
<p>polygon list with 3 or 4 elements: data, polys, poly.centers, and possibly ranges</p>
</td></tr>
<tr><td><code id="FindPolygonInRanges_+3A_xy">XY</code></td>
<td>
<p>data frame containing X-Y columns</p>
</td></tr>
<tr><td><code id="FindPolygonInRanges_+3A_poly.id">poly.id</code></td>
<td>
<p>column name in 'poly.list$data' containing the polygon identifier</p>
</td></tr>
<tr><td><code id="FindPolygonInRanges_+3A_poly.id.colname">poly.id.colname</code></td>
<td>
<p>desired column name in the output data frame containing the polygon identifier</p>
</td></tr>
<tr><td><code id="FindPolygonInRanges_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sf.crime.2012, envir = environment())
data(sf.polys, envir = environment())

sf.polys &lt;- AddRanges(sf.polys)
XY &lt;- FindPolygonInRanges(sf.polys, sf.crime.2012[1:1000,], verbose=0)

which(is.na(XY[,"census.block"]))
table(XY$rank)

</code></pre>

<hr>
<h2 id='RapidPolygonLookup'>Efficient spatial polygon search using kd-trees.</h2><span id='topic+RapidPolygonLookup'></span>

<h3>Description</h3>

<p>Given spatial partitions such as census blocks, ZIP codes or police district boundaries, we are
frequently faced with the need to spatially aggregate data. 
Unless efficient data structures are used, this can be a daunting task. 
The operation point.in.polygon() from the package sp is computationally expensive.
Here, we exploit kd-trees as efficient nearest neighbor search algorithm 
to dramatically reduce the effective number of polygons being searched.
Points that are left unmapped are put through a linear search to find the
associated polygon.</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapidPolygonLookup(XY, polygons, poly.list = NULL, k = 10, N = nrow(XY), 
    poly.id = "fips", poly.id.colname = "census.block", keep.data = TRUE, 
    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapidPolygonLookup_+3A_xy">XY</code></td>
<td>
<p>data frame containing X-Y or (lon-lat, long-lat, longitude-latitude) columns</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_polygons">polygons</code></td>
<td>
<p>polygons to crop and add poly centres</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_poly.list">poly.list</code></td>
<td>
<p>polygon list with three elements: data, polys, and poly.centers as output from function CropSpatialPolygonsDataFrame()</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_k">k</code></td>
<td>
<p>maximum number of near neighbours to compute. The default value is set to 10</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_n">N</code></td>
<td>
<p>number of rows of XY to search</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_poly.id">poly.id</code></td>
<td>
<p>column name in 'poly.list$data' containing the polygon identifier</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_poly.id.colname">poly.id.colname</code></td>
<td>
<p>desired column name in the output data frame containing the polygon identifier</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_keep.data">keep.data</code></td>
<td>
<p>retain polygon list and centers for future referece</p>
</td></tr>
<tr><td><code id="RapidPolygonLookup_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original points augmented with polygon ID are returned along with the poly centers and other call information</p>


<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sf.crime.2012, envir = environment())
data(sf.polys, envir = environment())
cat(nrow(sf.crime.2012), "rows in SF crime \n")

XY.kdtree &lt;- RapidPolygonLookup(sf.crime.2012[,c("X","Y")], poly.list= sf.polys, 
                                  k= 10, N= 1000, 
                                  poly.id= "fips", poly.id.colname= "census.block", 
                                  keep.data= TRUE, verbose= TRUE)

XY.kdtree.DF &lt;- XY.kdtree$XY
table(XY.kdtree.DF$rank, useNA= "always")
hist(XY.kdtree.DF$rank, xlab = "rank of neighbor")

</code></pre>

<hr>
<h2 id='SearchForPolygon'>Use kd-trees to search the nearest neighbour polygons for a given set of points</h2><span id='topic+SearchForPolygon'></span>

<h3>Description</h3>

<p>This function uses the nn2() function from the RANN package to come up
with a shorter list of candidates on which point.in.polygon() from the 
sp package can be applied.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SearchForPolygon(poly.list, XY, k, poly.id, poly.id.colname, 
    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SearchForPolygon_+3A_poly.list">poly.list</code></td>
<td>
<p>polygon list with 3-4 elements: poly.centers, data, polys and possibly ranges</p>
</td></tr>
<tr><td><code id="SearchForPolygon_+3A_xy">XY</code></td>
<td>
<p>data frame containing X-Y columns to assign polygons to</p>
</td></tr>
<tr><td><code id="SearchForPolygon_+3A_k">k</code></td>
<td>
<p>maximum number of nearest neighbours to compute. The default value is set to 10.</p>
</td></tr>
<tr><td><code id="SearchForPolygon_+3A_poly.id">poly.id</code></td>
<td>
<p>column name in 'poly.list$data' containing the polygon identifier</p>
</td></tr>
<tr><td><code id="SearchForPolygon_+3A_poly.id.colname">poly.id.colname</code></td>
<td>
<p>desired column name in the output data frame containing the polygon identifier</p>
</td></tr>
<tr><td><code id="SearchForPolygon_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data frame with identified polygon and nearest neighbour rank</p>


<h3>Author(s)</h3>

<p>Markus Loecher &lt;markus.loecher@gmail.com&gt; and Madhav Kumar &lt;madhavkumar2005@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sf.crime.2012, envir = environment())
data(sf.polys, envir = environment())
XY.polys &lt;- SearchForPolygon(poly.list= sf.polys, XY= sf.crime.2012[1:1000,], k= 10,
                             poly.id= "fips", poly.id.colname= "census.block",
                             verbose= TRUE)

</code></pre>

<hr>
<h2 id='sf.crime.2012'>Sample data with lat/long information</h2><span id='topic+sf.crime.2012'></span>

<h3>Description</h3>

<p>2012 crime incident data from the city of San Francisco</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sf.crime.2012)</code></pre>


<h3>Format</h3>

<p>A data frame with 20,000 randomly selected observations with the following variables and their types:
</p>

<dl>
<dt><code>Date</code></dt><dd><p>character</p>
</dd>
<dt><code>X</code></dt><dd><p>numeric</p>
</dd>
<dt><code>Y</code></dt><dd><p>numeric</p>
</dd>
<dt><code>violent</code></dt><dd><p>Factor</p>
</dd>
</dl>



<h3>Details</h3>

<p>There are no more details required</p>


<h3>Source</h3>

<p>https://data.sfgov.org/Public-Safety/SFPD-Reported-Incidents-2003-to-Present/dyj4-n68b</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sf.crime.2012, envir = environment())
</code></pre>

<hr>
<h2 id='sf.polys'>Spatial polygons of San Francisco</h2><span id='topic+sf.polys'></span>

<h3>Description</h3>

<p>Cropped spatial polygons from California Census tracts bounded between San Francisco limits</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sf.polys)</code></pre>


<h3>Format</h3>

<p>A list object with the following elements:
</p>

<dl>
<dt><code>data</code></dt><dd><p>data frame retained from California tracts object of class SpatialPolygonsDataFrame</p>
</dd>
<dt><code>polys</code></dt><dd><p>PolySet object from PBSmapping containing the spatial polygons</p>
</dd>
<dt><code>poly.centers</code></dt><dd><p>PolyData object from PBSmapping containing the polygon centroids</p>
</dd>
</dl>



<h3>Details</h3>

<p>This object is created from a function of CropSpatialPolygonsDataFrame() from the RapidPolygonLookup package</p>


<h3>Source</h3>

<p>http://cran.r-project.org/web/packages/UScensus2010/index.html</p>


<h3>References</h3>

<p>Zack W. Almquist (2010). US Census Spatial and Demographic Data in R: The UScensus2000 Suite of Packages. Journal of Statistical Software, 37(6), 1-31. URL http://www.jstatsoft.org/v37/i06/</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sf.polys, envir = environment())
plotPolys(sf.polys$polys)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
