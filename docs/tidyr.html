<!DOCTYPE html><html><head><title>Help for package tidyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#billboard'><p>Song rankings for Billboard top 100 in the year 2000</p></a></li>
<li><a href='#check_pivot_spec'><p>Check assumptions about a pivot <code>spec</code></p></a></li>
<li><a href='#chop'><p>Chop and unchop</p></a></li>
<li><a href='#cms_patient_experience'><p>Data from the Centers for Medicare &amp; Medicaid Services</p></a></li>
<li><a href='#complete'><p>Complete a data frame with missing combinations of data</p></a></li>
<li><a href='#construction'><p>Completed construction in the US in 2018</p></a></li>
<li><a href='#deprecated-se'><p>Deprecated SE versions of main verbs</p></a></li>
<li><a href='#drop_na'><p>Drop rows containing missing values</p></a></li>
<li><a href='#expand'><p>Expand data frame to include all possible combinations of values</p></a></li>
<li><a href='#expand_grid'><p>Create a tibble from all combinations of inputs</p></a></li>
<li><a href='#extract'><p>Extract a character column into multiple columns using regular</p>
expression groups</a></li>
<li><a href='#extract_numeric'><p>Extract numeric component of variable.</p></a></li>
<li><a href='#fill'><p>Fill in missing values with previous or next value</p></a></li>
<li><a href='#fish_encounters'><p>Fish encounters</p></a></li>
<li><a href='#full_seq'><p>Create the full sequence of values in a vector</p></a></li>
<li><a href='#gather'><p>Gather columns into key-value pairs</p></a></li>
<li><a href='#hoist'><p>Hoist values out of list-columns</p></a></li>
<li><a href='#household'><p>Household data</p></a></li>
<li><a href='#nest'><p>Nest rows into a list-column of data frames</p></a></li>
<li><a href='#nest_legacy'><p>Legacy versions of <code>nest()</code> and <code>unnest()</code></p></a></li>
<li><a href='#pack'><p>Pack and unpack</p></a></li>
<li><a href='#pivot_longer'><p>Pivot data from wide to long</p></a></li>
<li><a href='#pivot_longer_spec'><p>Pivot data from wide to long using a spec</p></a></li>
<li><a href='#pivot_wider'><p>Pivot data from long to wide</p></a></li>
<li><a href='#pivot_wider_spec'><p>Pivot data from long to wide using a spec</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relig_income'><p>Pew religion and income survey</p></a></li>
<li><a href='#replace_na'><p>Replace NAs with specified values</p></a></li>
<li><a href='#separate'><p>Separate a character column into multiple columns with a regular</p>
expression or numeric locations</a></li>
<li><a href='#separate_longer_delim'><p>Split a string into rows</p></a></li>
<li><a href='#separate_rows'><p>Separate a collapsed column into multiple rows</p></a></li>
<li><a href='#separate_wider_delim'><p>Split a string into columns</p></a></li>
<li><a href='#smiths'><p>Some data about the Smith family</p></a></li>
<li><a href='#spread'><p>Spread a key-value pair across multiple columns</p></a></li>
<li><a href='#table1'><p>Example tabular representations</p></a></li>
<li><a href='#tidyr_data_masking'><p>Argument type: data-masking</p></a></li>
<li><a href='#tidyr_legacy'><p>Legacy name repair</p></a></li>
<li><a href='#tidyr_tidy_select'><p>Argument type: tidy-select</p></a></li>
<li><a href='#tidyr-package'><p>tidyr: Tidy Messy Data</p></a></li>
<li><a href='#uncount'><p>&quot;Uncount&quot; a data frame</p></a></li>
<li><a href='#unite'><p>Unite multiple columns into one by pasting strings together</p></a></li>
<li><a href='#unnest'><p>Unnest a list-column of data frames into rows and columns</p></a></li>
<li><a href='#unnest_auto'><p>Automatically call <code>unnest_wider()</code> or <code>unnest_longer()</code></p></a></li>
<li><a href='#unnest_longer'><p>Unnest a list-column into rows</p></a></li>
<li><a href='#unnest_wider'><p>Unnest a list-column into columns</p></a></li>
<li><a href='#us_rent_income'><p>US rent and income data</p></a></li>
<li><a href='#who'><p>World Health Organization TB data</p></a></li>
<li><a href='#world_bank_pop'><p>Population data from the world bank</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Messy Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to help to create tidy data, where each column is a
    variable, each row is an observation, and each cell contains a single
    value.  'tidyr' contains tools for changing the shape (pivoting) and
    hierarchy (nesting and 'unnesting') of a dataset, turning deeply
    nested lists into rectangular data frames ('rectangling'), and
    extracting values out of string columns. It also includes tools for
    working with missing values (both implicit and explicit).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tidyr.tidyverse.org">https://tidyr.tidyverse.org</a>, <a href="https://github.com/tidyverse/tidyr">https://github.com/tidyverse/tidyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/tidyr/issues">https://github.com/tidyverse/tidyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.1), dplyr (&ge; 1.0.10), glue, lifecycle (&ge; 1.0.3),
magrittr, purrr (&ge; 1.0.1), rlang (&ge; 1.0.4), stringr (&ge;
1.5.0), tibble (&ge; 2.1.1), tidyselect (&ge; 1.2.0), utils, vctrs
(&ge; 0.5.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, data.table, knitr, readr, repurrrsive (&ge; 1.1.0),
rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.4.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-23 22:21:00 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Davis Vaughan [aut],
  Maximilian Girlich [aut],
  Kevin Ushey [ctb],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-24 16:00:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:59:40 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code><a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='billboard'>Song rankings for Billboard top 100 in the year 2000</h2><span id='topic+billboard'></span>

<h3>Description</h3>

<p>Song rankings for Billboard top 100 in the year 2000
</p>


<h3>Usage</h3>

<pre><code class='language-R'>billboard
</code></pre>


<h3>Format</h3>

<p>A dataset with variables:
</p>

<dl>
<dt>artist</dt><dd><p>Artist name</p>
</dd>
<dt>track</dt><dd><p>Song name</p>
</dd>
<dt>date.enter</dt><dd><p>Date the song entered the top 100</p>
</dd>
<dt>wk1 &ndash; wk76</dt><dd><p>Rank of the song in each week after it entered</p>
</dd>
</dl>



<h3>Source</h3>

<p>The &quot;Whitburn&quot; project, <a href="https://waxy.org/2008/05/the_whitburn_project/">https://waxy.org/2008/05/the_whitburn_project/</a>,
(downloaded April 2008)
</p>

<hr>
<h2 id='check_pivot_spec'>Check assumptions about a pivot <code>spec</code></h2><span id='topic+check_pivot_spec'></span>

<h3>Description</h3>

<p><code>check_pivot_spec()</code> is a developer facing helper function for validating
the pivot spec used in <code><a href="tidyr.html#topic+pivot_longer_spec">pivot_longer_spec()</a></code> or <code><a href="tidyr.html#topic+pivot_wider_spec">pivot_wider_spec()</a></code>. It is
only useful if you are extending <code><a href="tidyr.html#topic+pivot_longer">pivot_longer()</a></code> or <code><a href="tidyr.html#topic+pivot_wider">pivot_wider()</a></code> with
new S3 methods.
</p>
<p><code>check_pivot_spec()</code> makes the following assertions:
</p>

<ul>
<li> <p><code>spec</code> must be a data frame.
</p>
</li>
<li> <p><code>spec</code> must have a character column named <code>.name</code>.
</p>
</li>
<li> <p><code>spec</code> must have a character column named <code>.value</code>.
</p>
</li>
<li><p> The <code>.name</code> column must be unique.
</p>
</li>
<li><p> The <code>.name</code> and <code>.value</code> columns must be the first two columns in the data
frame, and will be reordered if that is not true.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>check_pivot_spec(spec, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pivot_spec_+3A_spec">spec</code></td>
<td>
<p>A specification data frame. This is useful for more complex
pivots because it gives you greater control on how metadata stored in the
columns become column names in the result.
</p>
<p>Must be a data frame containing character <code>.name</code> and <code>.value</code> columns.
Additional columns in <code>spec</code> should be named to match columns in the
long format of the dataset and contain values corresponding to columns
pivoted from the wide format.
The special <code>.seq</code> variable is used to disambiguate rows internally;
it is automatically removed after pivoting.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A valid spec
spec &lt;- tibble(.name = "a", .value = "b", foo = 1)
check_pivot_spec(spec)

spec &lt;- tibble(.name = "a")
try(check_pivot_spec(spec))

# `.name` and `.value` are forced to be the first two columns
spec &lt;- tibble(foo = 1, .value = "b", .name = "a")
check_pivot_spec(spec)
</code></pre>

<hr>
<h2 id='chop'>Chop and unchop</h2><span id='topic+chop'></span><span id='topic+unchop'></span>

<h3>Description</h3>

<p>Chopping and unchopping preserve the width of a data frame, changing its
length. <code>chop()</code> makes <code>df</code> shorter by converting rows within each group
into list-columns. <code>unchop()</code> makes <code>df</code> longer by expanding list-columns
so that each element of the list-column gets its own row in the output.
<code>chop()</code> and <code>unchop()</code> are building blocks for more complicated functions
(like <code><a href="tidyr.html#topic+unnest">unnest()</a></code>, <code><a href="tidyr.html#topic+unnest_longer">unnest_longer()</a></code>, and <code><a href="tidyr.html#topic+unnest_wider">unnest_wider()</a></code>) and are generally
more suitable for programming than interactive data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop(data, cols, ..., error_call = current_env())

unchop(
  data,
  cols,
  ...,
  keep_empty = FALSE,
  ptype = NULL,
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chop_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="chop_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to chop or unchop.
</p>
<p>For <code>unchop()</code>, each column should be a list-column containing generalised
vectors (e.g. any mix of <code>NULL</code>s, atomic vector, S3 vectors, a lists,
or data frames).</p>
</td></tr>
<tr><td><code id="chop_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="chop_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="chop_+3A_keep_empty">keep_empty</code></td>
<td>
<p>By default, you get one row of output for each element
of the list that you are unchopping/unnesting. This means that if there's a
size-0 element (like <code>NULL</code> or an empty data frame or vector), then that
entire row will be dropped from the output. If you want to preserve all
rows, use <code>keep_empty = TRUE</code> to replace size-0 elements with a single row
of missing values.</p>
</td></tr>
<tr><td><code id="chop_+3A_ptype">ptype</code></td>
<td>
<p>Optionally, a named list of column name-prototype pairs to
coerce <code>cols</code> to, overriding the default that will be guessed from
combining the individual values. Alternatively, a single empty ptype
can be supplied, which will be applied to all <code>cols</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, unchopping is more useful than chopping because it simplifies
a complex data structure, and <code><a href="tidyr.html#topic+nest">nest()</a></code>ing is usually more appropriate
than <code>chop()</code>ing since it better preserves the connections between
observations.
</p>
<p><code>chop()</code> creates list-columns of class <code><a href="vctrs.html#topic+list_of">vctrs::list_of()</a></code> to ensure
consistent behaviour when the chopped data frame is emptied. For
instance this helps getting back the original column types after
the roundtrip chop and unchop. Because <code style="white-space: pre;">&#8288;&lt;list_of&gt;&#8288;</code> keeps tracks of
the type of its elements, <code>unchop()</code> is able to reconstitute the
correct vector type even for empty list-columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Chop ----------------------------------------------------------------------
df &lt;- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
# Note that we get one row of output for each unique combination of
# non-chopped variables
df %&gt;% chop(c(y, z))
# cf nest
df %&gt;% nest(data = c(y, z))

# Unchop --------------------------------------------------------------------
df &lt;- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))
df %&gt;% unchop(y)
df %&gt;% unchop(y, keep_empty = TRUE)

# unchop will error if the types are not compatible:
df &lt;- tibble(x = 1:2, y = list("1", 1:3))
try(df %&gt;% unchop(y))

# Unchopping a list-col of data frames must generate a df-col because
# unchop leaves the column names unchanged
df &lt;- tibble(x = 1:3, y = list(NULL, tibble(x = 1), tibble(y = 1:2)))
df %&gt;% unchop(y)
df %&gt;% unchop(y, keep_empty = TRUE)
</code></pre>

<hr>
<h2 id='cms_patient_experience'>Data from the Centers for Medicare &amp; Medicaid Services</h2><span id='topic+cms_patient_experience'></span><span id='topic+cms_patient_care'></span>

<h3>Description</h3>

<p>Two datasets from public data provided the Centers for Medicare &amp; Medicaid
Services, <a href="https://data.cms.gov">https://data.cms.gov</a>.
</p>

<ul>
<li> <p><code>cms_patient_experience</code> contains some lightly cleaned data from
&quot;Hospice - Provider Data&quot;, which provides a list of hospice agencies
along with some data on quality of patient care,
<a href="https://data.cms.gov/provider-data/dataset/252m-zfp9">https://data.cms.gov/provider-data/dataset/252m-zfp9</a>.
</p>
</li>
<li> <p><code>cms_patient_care</code> &quot;Doctors and Clinicians Quality Payment Program PY 2020
Virtual Group Public Reporting&quot;,
<a href="https://data.cms.gov/provider-data/dataset/8c70-d353">https://data.cms.gov/provider-data/dataset/8c70-d353</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cms_patient_experience

cms_patient_care
</code></pre>


<h3>Format</h3>

<p><code>cms_patient_experience</code> is a data frame with 500 observations and
five variables:
</p>

<dl>
<dt>org_pac_id,org_nm</dt><dd><p>Organisation ID and name</p>
</dd>
<dt>measure_cd,measure_title</dt><dd><p>Measure code and title</p>
</dd>
<dt>prf_rate</dt><dd><p>Measure performance rate</p>
</dd>
</dl>

<p><code>cms_patient_care</code> is a data frame with 252 observations and
five variables:
</p>

<dl>
<dt>ccn,facility_name</dt><dd><p>Facility ID and name</p>
</dd>
<dt>measure_abbr</dt><dd><p>Abbreviated measurement title, suitable for use as variable name</p>
</dd>
<dt>score</dt><dd><p>Measure score</p>
</dd>
<dt>type</dt><dd><p>Whether score refers to the rating out of 100 (&quot;observed&quot;), or
the maximum possible value of the raw score (&quot;denominator&quot;)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>cms_patient_experience %&gt;%
  dplyr::distinct(measure_cd, measure_title)

cms_patient_experience %&gt;%
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
 )

cms_patient_care %&gt;%
  pivot_wider(
    names_from = type,
    values_from = score
  )

cms_patient_care %&gt;%
  pivot_wider(
    names_from = measure_abbr,
    values_from = score
  )

cms_patient_care %&gt;%
  pivot_wider(
    names_from = c(measure_abbr, type),
    values_from = score
  )
</code></pre>

<hr>
<h2 id='complete'>Complete a data frame with missing combinations of data</h2><span id='topic+complete'></span>

<h3>Description</h3>

<p>Turns implicit missing values into explicit missing values. This is a wrapper
around <code><a href="Matrix.html#topic+expand">expand()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code> and <code><a href="tidyr.html#topic+replace_na">replace_na()</a></code> that's useful for
completing missing combinations of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(data, ..., fill = list(), explicit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="complete_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_data_masking">data-masking</a></code>&gt; Specification of columns
to expand or complete. Columns can be atomic vectors or lists.
</p>

<ul>
<li><p> To find all unique combinations of <code>x</code>, <code>y</code> and <code>z</code>, including those not
present in the data, supply each variable as a separate argument:
<code>expand(df, x, y, z)</code> or <code>complete(df, x, y, z)</code>.
</p>
</li>
<li><p> To find only the combinations that occur in the
data, use <code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.
</p>
</li>
<li><p> You can combine the two forms. For example,
<code>expand(df, nesting(school_id, student_id), date)</code> would produce
a row for each present school-student combination for all possible
dates.
</p>
</li></ul>

<p>When used with factors, <code><a href="Matrix.html#topic+expand">expand()</a></code> and <code><a href="tidyr.html#topic+complete">complete()</a></code> use the full set of
levels, not just those that appear in the data. If you want to use only the
values seen in the data, use <code>forcats::fct_drop()</code>.
</p>
<p>When used with continuous variables, you may need to fill in values
that do not appear in the data: to do so use expressions like
<code>year = 2010:2020</code> or <code>year = full_seq(year,1)</code>.</p>
</td></tr>
<tr><td><code id="complete_+3A_fill">fill</code></td>
<td>
<p>A named list that for each variable supplies a single value to
use instead of <code>NA</code> for missing combinations.</p>
</td></tr>
<tr><td><code id="complete_+3A_explicit">explicit</code></td>
<td>
<p>Should both implicit (newly created) and explicit
(pre-existing) missing values be filled by <code>fill</code>? By default, this is
<code>TRUE</code>, but if set to <code>FALSE</code> this will limit the fill to only implicit
missing values.</p>
</td></tr>
</table>


<h3>Grouped data frames</h3>

<p>With grouped data frames created by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, <code>complete()</code>
operates <em>within</em> each group. Because of this, you cannot complete a grouping
column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  group = c(1:2, 1, 2),
  item_id = c(1:2, 2, 3),
  item_name = c("a", "a", "b", "b"),
  value1 = c(1, NA, 3, 4),
  value2 = 4:7
)
df

# Combinations --------------------------------------------------------------
# Generate all possible combinations of `group`, `item_id`, and `item_name`
# (whether or not they appear in the data)
df %&gt;% complete(group, item_id, item_name)

# Cross all possible `group` values with the unique pairs of
# `(item_id, item_name)` that already exist in the data
df %&gt;% complete(group, nesting(item_id, item_name))

# Within each `group`, generate all possible combinations of
# `item_id` and `item_name` that occur in that group
df %&gt;%
  dplyr::group_by(group) %&gt;%
  complete(item_id, item_name)

# Supplying values for new rows ---------------------------------------------
# Use `fill` to replace NAs with some value. By default, affects both new
# (implicit) and pre-existing (explicit) missing values.
df %&gt;%
  complete(
    group,
    nesting(item_id, item_name),
    fill = list(value1 = 0, value2 = 99)
  )

# Limit the fill to only the newly created (i.e. previously implicit)
# missing values with `explicit = FALSE`
df %&gt;%
  complete(
    group,
    nesting(item_id, item_name),
    fill = list(value1 = 0, value2 = 99),
    explicit = FALSE
  )
</code></pre>

<hr>
<h2 id='construction'>Completed construction in the US in 2018</h2><span id='topic+construction'></span>

<h3>Description</h3>

<p>Completed construction in the US in 2018
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construction
</code></pre>


<h3>Format</h3>

<p>A dataset with variables:
</p>

<dl>
<dt>Year,Month</dt><dd><p>Record date</p>
</dd>
<dt><code style="white-space: pre;">&#8288;1 unit&#8288;</code>, <code style="white-space: pre;">&#8288;2 to 4 units&#8288;</code>, <code style="white-space: pre;">&#8288;5 units or mote&#8288;</code></dt><dd><p>Number of completed
units of each size</p>
</dd>
<dt>Northeast,Midwest,South,West</dt><dd><p>Number of completed units in each region</p>
</dd>
</dl>



<h3>Source</h3>

<p>Completions of &quot;New Residential Construction&quot; found in Table 5 at
<a href="https://www.census.gov/construction/nrc/xls/newresconst.xls">https://www.census.gov/construction/nrc/xls/newresconst.xls</a>
(downloaded March 2019)
</p>

<hr>
<h2 id='deprecated-se'>Deprecated SE versions of main verbs</h2><span id='topic+deprecated-se'></span><span id='topic+complete_'></span><span id='topic+drop_na_'></span><span id='topic+expand_'></span><span id='topic+crossing_'></span><span id='topic+nesting_'></span><span id='topic+extract_'></span><span id='topic+fill_'></span><span id='topic+gather_'></span><span id='topic+nest_'></span><span id='topic+separate_rows_'></span><span id='topic+separate_'></span><span id='topic+spread_'></span><span id='topic+unite_'></span><span id='topic+unnest_'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>tidyr used to offer twin versions of each verb suffixed with an
underscore. These versions had standard evaluation (SE) semantics:
rather than taking arguments by code, like NSE verbs, they took
arguments by value. Their purpose was to make it possible to
program with tidyr. However, tidyr now uses tidy evaluation
semantics. NSE verbs still capture their arguments, but you can now
unquote parts of these arguments. This offers full programmability
with NSE verbs. Thus, the underscored versions are now superfluous.
</p>
<p>Unquoting triggers immediate evaluation of its operand and inlines
the result within the captured expression. This result can be a
value or an expression to be evaluated later with the rest of the
argument. See <code>vignette("programming", "dplyr")</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_(data, cols, fill = list(), ...)

drop_na_(data, vars)

expand_(data, dots, ...)

crossing_(x)

nesting_(x)

extract_(
  data,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)

fill_(data, fill_cols, .direction = c("down", "up"))

gather_(
  data,
  key_col,
  value_col,
  gather_cols,
  na.rm = FALSE,
  convert = FALSE,
  factor_key = FALSE
)

nest_(...)

separate_rows_(data, cols, sep = "[^[:alnum:].]+", convert = FALSE)

separate_(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)

spread_(
  data,
  key_col,
  value_col,
  fill = NA,
  convert = FALSE,
  drop = TRUE,
  sep = NULL
)

unite_(data, col, from, sep = "_", remove = TRUE)

unnest_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated-se_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_fill">fill</code></td>
<td>
<p>A named list that for each variable supplies a single value to
use instead of <code>NA</code> for missing combinations.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_data_masking">data-masking</a></code>&gt; Specification of columns
to expand or complete. Columns can be atomic vectors or lists.
</p>

<ul>
<li><p> To find all unique combinations of <code>x</code>, <code>y</code> and <code>z</code>, including those not
present in the data, supply each variable as a separate argument:
<code>expand(df, x, y, z)</code> or <code>complete(df, x, y, z)</code>.
</p>
</li>
<li><p> To find only the combinations that occur in the
data, use <code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.
</p>
</li>
<li><p> You can combine the two forms. For example,
<code>expand(df, nesting(school_id, student_id), date)</code> would produce
a row for each present school-student combination for all possible
dates.
</p>
</li></ul>

<p>When used with factors, <code><a href="Matrix.html#topic+expand">expand()</a></code> and <code><a href="tidyr.html#topic+complete">complete()</a></code> use the full set of
levels, not just those that appear in the data. If you want to use only the
values seen in the data, use <code>forcats::fct_drop()</code>.
</p>
<p>When used with continuous variables, you may need to fill in values
that do not appear in the data: to do so use expressions like
<code>year = 2010:2020</code> or <code>year = full_seq(year,1)</code>.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_vars">vars</code>, <code id="deprecated-se_+3A_cols">cols</code>, <code id="deprecated-se_+3A_col">col</code></td>
<td>
<p>Name of columns.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_x">x</code></td>
<td>
<p>For <code>nesting_</code> and <code>crossing_</code> a list of variables.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_regex">regex</code></td>
<td>
<p>A string representing a regular expression used to extract the
desired values. There should be one group (defined by <code style="white-space: pre;">&#8288;()&#8288;</code>) for each
element of <code>into</code>.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_fill_cols">fill_cols</code></td>
<td>
<p>Character vector of column names.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently
either &quot;down&quot; (the default), &quot;up&quot;, &quot;downup&quot; (i.e. first down and then up)
or &quot;updown&quot; (first up and then down).</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_key_col">key_col</code>, <code id="deprecated-se_+3A_value_col">value_col</code></td>
<td>
<p>Strings giving names of key and value cols.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_gather_cols">gather_cols</code></td>
<td>
<p>Character vector giving column names to be gathered into
pair of key-value columns.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, will remove rows from output where the
value column is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_factor_key">factor_key</code></td>
<td>
<p>If <code>FALSE</code>, the default, the key values will be
stored as a character vector. If <code>TRUE</code>, will be stored as a factor,
which preserves the original ordering of the columns.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_sep">sep</code></td>
<td>
<p>Separator delimiting collapsed values.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_extra">extra</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and drop extra values.
</p>
</li>
<li> <p><code>"drop"</code>: drop any extra values without a warning.
</p>
</li>
<li> <p><code>"merge"</code>: only splits at most <code>length(into)</code> times
</p>
</li></ul>
</td></tr>
<tr><td><code id="deprecated-se_+3A_drop">drop</code></td>
<td>
<p>If <code>FALSE</code>, will keep factor levels that don't appear in the
data, filling in missing combinations with <code>fill</code>.</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_from">from</code></td>
<td>
<p>Names of existing columns as character vector</p>
</td></tr>
<tr><td><code id="deprecated-se_+3A_expand_cols">expand_cols</code></td>
<td>
<p>Character vector of column names to be expanded.</p>
</td></tr>
</table>

<hr>
<h2 id='drop_na'>Drop rows containing missing values</h2><span id='topic+drop_na'></span>

<h3>Description</h3>

<p><code>drop_na()</code> drops rows where any column specified by <code>...</code> contains a
missing value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="drop_na_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to inspect for
missing values. If empty, all columns are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Another way to interpret <code>drop_na()</code> is that it only keeps the &quot;complete&quot;
rows (where no rows contain missing values). Internally, this completeness is
computed through <code><a href="vctrs.html#topic+vec_detect_complete">vctrs::vec_detect_complete()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = c(1, 2, NA), y = c("a", NA, "b"))
df %&gt;% drop_na()
df %&gt;% drop_na(x)

vars &lt;- "y"
df %&gt;% drop_na(x, any_of(vars))
</code></pre>

<hr>
<h2 id='expand'>Expand data frame to include all possible combinations of values</h2><span id='topic+expand'></span><span id='topic+crossing'></span><span id='topic+nesting'></span>

<h3>Description</h3>

<p><code>expand()</code> generates all combination of variables found in a dataset.
It is paired with <code>nesting()</code> and <code>crossing()</code> helpers. <code>crossing()</code>
is a wrapper around <code><a href="tidyr.html#topic+expand_grid">expand_grid()</a></code> that de-duplicates and sorts its inputs;
<code>nesting()</code> is a helper that only finds combinations already present in the
data.
</p>
<p><code>expand()</code> is often useful in conjunction with joins:
</p>

<ul>
<li><p> use it with <code>right_join()</code> to convert implicit missing values to
explicit missing values (e.g., fill in gaps in your data frame).
</p>
</li>
<li><p> use it with <code>anti_join()</code> to figure out which combinations are missing
(e.g., identify gaps in your data frame).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>expand(data, ..., .name_repair = "check_unique")

crossing(..., .name_repair = "check_unique")

nesting(..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="expand_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_data_masking">data-masking</a></code>&gt; Specification of columns
to expand or complete. Columns can be atomic vectors or lists.
</p>

<ul>
<li><p> To find all unique combinations of <code>x</code>, <code>y</code> and <code>z</code>, including those not
present in the data, supply each variable as a separate argument:
<code>expand(df, x, y, z)</code> or <code>complete(df, x, y, z)</code>.
</p>
</li>
<li><p> To find only the combinations that occur in the
data, use <code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.
</p>
</li>
<li><p> You can combine the two forms. For example,
<code>expand(df, nesting(school_id, student_id), date)</code> would produce
a row for each present school-student combination for all possible
dates.
</p>
</li></ul>

<p>When used with factors, <code><a href="Matrix.html#topic+expand">expand()</a></code> and <code><a href="tidyr.html#topic+complete">complete()</a></code> use the full set of
levels, not just those that appear in the data. If you want to use only the
values seen in the data, use <code>forcats::fct_drop()</code>.
</p>
<p>When used with continuous variables, you may need to fill in values
that do not appear in the data: to do so use expressions like
<code>year = 2010:2020</code> or <code>year = full_seq(year,1)</code>.</p>
</td></tr>
<tr><td><code id="expand_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Grouped data frames</h3>

<p>With grouped data frames created by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, <code>expand()</code> operates
<em>within</em> each group. Because of this, you cannot expand on a grouping column.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+complete">complete()</a></code> to expand list objects. <code><a href="tidyr.html#topic+expand_grid">expand_grid()</a></code>
to input vectors rather than a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding combinations ------------------------------------------------------
fruits &lt;- tibble(
  type = c("apple", "orange", "apple", "orange", "orange", "orange"),
  year = c(2010, 2010, 2012, 2010, 2011, 2012),
  size = factor(
    c("XS", "S", "M", "S", "S", "M"),
    levels = c("XS", "S", "M", "L")
  ),
  weights = rnorm(6, as.numeric(size) + 2)
)

# All combinations, including factor levels that are not used
fruits %&gt;% expand(type)
fruits %&gt;% expand(size)
fruits %&gt;% expand(type, size)
fruits %&gt;% expand(type, size, year)

# Only combinations that already appear in the data
fruits %&gt;% expand(nesting(type))
fruits %&gt;% expand(nesting(size))
fruits %&gt;% expand(nesting(type, size))
fruits %&gt;% expand(nesting(type, size, year))

# Other uses ----------------------------------------------------------------
# Use with `full_seq()` to fill in values of continuous variables
fruits %&gt;% expand(type, size, full_seq(year, 1))
fruits %&gt;% expand(type, size, 2010:2013)

# Use `anti_join()` to determine which observations are missing
all &lt;- fruits %&gt;% expand(type, size, year)
all
all %&gt;% dplyr::anti_join(fruits)

# Use with `right_join()` to fill in missing rows (like `complete()`)
fruits %&gt;% dplyr::right_join(all)

# Use with `group_by()` to expand within each group
fruits %&gt;%
  dplyr::group_by(type) %&gt;%
  expand(year, size)
</code></pre>

<hr>
<h2 id='expand_grid'>Create a tibble from all combinations of inputs</h2><span id='topic+expand_grid'></span>

<h3>Description</h3>

<p><code>expand_grid()</code> is heavily motivated by <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>.
Compared to <code>expand.grid()</code>, it:
</p>

<ul>
<li><p> Produces sorted output (by varying the first column the slowest, rather
than the fastest).
</p>
</li>
<li><p> Returns a tibble, not a data frame.
</p>
</li>
<li><p> Never converts strings to factors.
</p>
</li>
<li><p> Does not add any additional attributes.
</p>
</li>
<li><p> Can expand any generalised vector, including data frames.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>expand_grid(..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_grid_+3A_...">...</code></td>
<td>
<p>Name-value pairs. The name will become the column name in the
output.</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with one column for each input in <code>...</code>. The output
will have one row for each combination of the inputs, i.e. the size
be equal to the product of the sizes of the inputs. This implies
that if any input has length 0, the output will have zero rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expand_grid(x = 1:3, y = 1:2)
expand_grid(l1 = letters, l2 = LETTERS)

# Can also expand data frames
expand_grid(df = tibble(x = 1:2, y = c(2, 1)), z = 1:3)
# And matrices
expand_grid(x1 = matrix(1:4, nrow = 2), x2 = matrix(5:8, nrow = 2))
</code></pre>

<hr>
<h2 id='extract'>Extract a character column into multiple columns using regular
expression groups</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>extract()</code> has been superseded in favour of <code><a href="tidyr.html#topic+separate_wider_regex">separate_wider_regex()</a></code>
because it has a more polished API and better handling of problems.
Superseded functions will not go away, but will only receive critical bug
fixes.
</p>
<p>Given a regular expression with capturing groups, <code>extract()</code> turns
each group into a new column. If the groups don't match, or the input
is NA, the output will be NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(
  data,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="extract_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Column to expand.</p>
</td></tr>
<tr><td><code id="extract_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="extract_+3A_regex">regex</code></td>
<td>
<p>A string representing a regular expression used to extract the
desired values. There should be one group (defined by <code style="white-space: pre;">&#8288;()&#8288;</code>) for each
element of <code>into</code>.</p>
</td></tr>
<tr><td><code id="extract_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="extract_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate()</a></code> to split up by a separator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = c(NA, "a-b", "a-d", "b-c", "d-e"))
df %&gt;% extract(x, "A")
df %&gt;% extract(x, c("A", "B"), "([[:alnum:]]+)-([[:alnum:]]+)")

# Now recommended
df %&gt;%
  separate_wider_regex(
    x,
    patterns = c(A = "[[:alnum:]]+", "-", B = "[[:alnum:]]+")
  )

# If no match, NA:
df %&gt;% extract(x, c("A", "B"), "([a-d]+)-([a-d]+)")
</code></pre>

<hr>
<h2 id='extract_numeric'>Extract numeric component of variable.</h2><span id='topic+extract_numeric'></span>

<h3>Description</h3>

<p>DEPRECATED: please use <code>readr::parse_number()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_numeric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_numeric_+3A_x">x</code></td>
<td>
<p>A character vector (or a factor).</p>
</td></tr>
</table>

<hr>
<h2 id='fill'>Fill in missing values with previous or next value</h2><span id='topic+fill'></span>

<h3>Description</h3>

<p>Fills missing values in selected columns using the next or previous entry.
This is useful in the common output format where values are not repeated,
and are only recorded when they change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(data, ..., .direction = c("down", "up", "downup", "updown"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fill_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to fill.</p>
</td></tr>
<tr><td><code id="fill_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently
either &quot;down&quot; (the default), &quot;up&quot;, &quot;downup&quot; (i.e. first down and then up)
or &quot;updown&quot; (first up and then down).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are replaced in atomic vectors; <code>NULL</code>s are replaced in lists.
</p>


<h3>Grouped data frames</h3>

<p>With grouped data frames created by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, <code>fill()</code> will be
applied <em>within</em> each group, meaning that it won't fill across group
boundaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># direction = "down" --------------------------------------------------------
# Value (year) is recorded only when it changes
sales &lt;- tibble::tribble(
  ~quarter, ~year, ~sales,
  "Q1",    2000,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",      NA,    21001,
  "Q1",    2001,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",      NA,    50197,
  "Q1",    2002,    39113,
  "Q2",      NA,    41668,
  "Q3",      NA,    30144,
  "Q4",      NA,    52897,
  "Q1",    2004,    32129,
  "Q2",      NA,    67686,
  "Q3",      NA,    31768,
  "Q4",      NA,    49094
)
# `fill()` defaults to replacing missing data from top to bottom
sales %&gt;% fill(year)

# direction = "up" ----------------------------------------------------------
# Value (pet_type) is missing above
tidy_pets &lt;- tibble::tribble(
  ~rank, ~pet_type, ~breed,
  1L,        NA,    "Boston Terrier",
  2L,        NA,    "Retrievers (Labrador)",
  3L,        NA,    "Retrievers (Golden)",
  4L,        NA,    "French Bulldogs",
  5L,        NA,    "Bulldogs",
  6L,     "Dog",    "Beagles",
  1L,        NA,    "Persian",
  2L,        NA,    "Maine Coon",
  3L,        NA,    "Ragdoll",
  4L,        NA,    "Exotic",
  5L,        NA,    "Siamese",
  6L,     "Cat",    "American Short"
)

# For values that are missing above you can use `.direction = "up"`
tidy_pets %&gt;%
  fill(pet_type, .direction = "up")

# direction = "downup" ------------------------------------------------------
# Value (n_squirrels) is missing above and below within a group
squirrels &lt;- tibble::tribble(
  ~group,    ~name,     ~role,     ~n_squirrels,
  1,      "Sam",    "Observer",   NA,
  1,     "Mara", "Scorekeeper",    8,
  1,    "Jesse",    "Observer",   NA,
  1,      "Tom",    "Observer",   NA,
  2,     "Mike",    "Observer",   NA,
  2,  "Rachael",    "Observer",   NA,
  2,  "Sydekea", "Scorekeeper",   14,
  2, "Gabriela",    "Observer",   NA,
  3,  "Derrick",    "Observer",   NA,
  3,     "Kara", "Scorekeeper",    9,
  3,    "Emily",    "Observer",   NA,
  3, "Danielle",    "Observer",   NA
)

# The values are inconsistently missing by position within the group
# Use .direction = "downup" to fill missing values in both directions
squirrels %&gt;%
  dplyr::group_by(group) %&gt;%
  fill(n_squirrels, .direction = "downup") %&gt;%
  dplyr::ungroup()

# Using `.direction = "updown"` accomplishes the same goal in this example
</code></pre>

<hr>
<h2 id='fish_encounters'>Fish encounters</h2><span id='topic+fish_encounters'></span>

<h3>Description</h3>

<p>Information about fish swimming down a river: each station represents an
autonomous monitor that records if a tagged fish was seen at that location.
Fish travel in one direction (migrating downstream). Information about
misses is just as important as hits, but is not directly recorded in this
form of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fish_encounters
</code></pre>


<h3>Format</h3>

<p>A dataset with variables:
</p>

<dl>
<dt>fish</dt><dd><p>Fish identifier</p>
</dd>
<dt>station</dt><dd><p>Measurement station</p>
</dd>
<dt>seen</dt><dd><p>Was the fish seen? (1 if yes, and true for all rows)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dataset provided by Myfanwy Johnston; more details at
<a href="https://fishsciences.github.io/post/visualizing-fish-encounter-histories/">https://fishsciences.github.io/post/visualizing-fish-encounter-histories/</a>
</p>

<hr>
<h2 id='full_seq'>Create the full sequence of values in a vector</h2><span id='topic+full_seq'></span>

<h3>Description</h3>

<p>This is useful if you want to fill in missing values that should have
been observed but weren't. For example, <code>full_seq(c(1, 2, 4, 6), 1)</code>
will return <code>1:6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_seq(x, period, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_seq_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="full_seq_+3A_period">period</code></td>
<td>
<p>Gap between each observation. The existing data will be
checked to ensure that it is actually of this periodicity.</p>
</td></tr>
<tr><td><code id="full_seq_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance for checking periodicity.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>full_seq(c(1, 2, 4, 5, 10), 1)
</code></pre>

<hr>
<h2 id='gather'>Gather columns into key-value pairs</h2><span id='topic+gather'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Development on <code>gather()</code> is complete, and for new code we recommend
switching to <code>pivot_longer()</code>, which is easier to use, more featureful, and
still under active development.
<code>df %&gt;% gather("key", "value", x, y, z)</code> is equivalent to
<code>df %&gt;% pivot_longer(c(x, y, z), names_to = "key", values_to = "value")</code>
</p>
<p>See more details in <code>vignette("pivot")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather(
  data,
  key = "key",
  value = "value",
  ...,
  na.rm = FALSE,
  convert = FALSE,
  factor_key = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="gather_+3A_key">key</code>, <code id="gather_+3A_value">value</code></td>
<td>
<p>Names of new key and value columns, as strings or
symbols.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="gather_+3A_...">...</code></td>
<td>
<p>A selection of columns. If empty, all variables are
selected. You can supply bare variable names, select all
variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For
more options, see the <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> documentation. See also
the section on selection rules below.</p>
</td></tr>
<tr><td><code id="gather_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, will remove rows from output where the
value column is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="gather_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code> will automatically run
<code><a href="utils.html#topic+type.convert">type.convert()</a></code> on the key column. This is useful if the column
types are actually numeric, integer, or logical.</p>
</td></tr>
<tr><td><code id="gather_+3A_factor_key">factor_key</code></td>
<td>
<p>If <code>FALSE</code>, the default, the key values will be
stored as a character vector. If <code>TRUE</code>, will be stored as a factor,
which preserves the original ordering of the columns.</p>
</td></tr>
</table>


<h3>Rules for selection</h3>

<p>Arguments for selecting columns are passed to <code><a href="tidyselect.html#topic+vars_select">tidyselect::vars_select()</a></code>
and are treated specially. Unlike other verbs, selecting functions make a
strict distinction between data expressions and context expressions.
</p>

<ul>
<li><p> A data expression is either a bare name like <code>x</code> or an expression
like <code>x:y</code> or <code>c(x, y)</code>. In a data expression, you can only refer
to columns from the data frame.
</p>
</li>
<li><p> Everything else is a context expression in which you can only
refer to objects that you have defined with <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>.
</p>
</li></ul>

<p>For instance, <code>col1:col3</code> is a data expression that refers to data
columns, while <code>seq(start, end)</code> is a context expression that
refers to objects from the contexts.
</p>
<p>If you need to refer to contextual objects from a data expression, you can
use <code>all_of()</code> or <code>any_of()</code>. These functions are used to select
data-variables whose names are stored in a env-variable. For instance,
<code>all_of(a)</code> selects the variables listed in the character vector <code>a</code>.
For more details, see the <code><a href="tidyselect.html#topic+language">tidyselect::select_helpers()</a></code> documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From https://stackoverflow.com/questions/1181060
stocks &lt;- tibble(
  time = as.Date("2009-01-01") + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

gather(stocks, "stock", "price", -time)
stocks %&gt;% gather("stock", "price", -time)

# get first observation for each Species in iris data -- base R
mini_iris &lt;- iris[c(1, 51, 101), ]
# gather Sepal.Length, Sepal.Width, Petal.Length, Petal.Width
gather(mini_iris, key = "flower_att", value = "measurement",
       Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
# same result but less verbose
gather(mini_iris, key = "flower_att", value = "measurement", -Species)
</code></pre>

<hr>
<h2 id='hoist'>Hoist values out of list-columns</h2><span id='topic+hoist'></span>

<h3>Description</h3>

<p><code>hoist()</code> allows you to selectively pull components of a list-column
into their own top-level columns, using the same syntax as <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code>.
</p>
<p>Learn more in <code>vignette("rectangle")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoist(
  .data,
  .col,
  ...,
  .remove = TRUE,
  .simplify = TRUE,
  .ptype = NULL,
  .transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hoist_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="hoist_+3A_.col">.col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-column to extract
components from.</p>
</td></tr>
<tr><td><code id="hoist_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Components of <code>.col</code> to turn
into columns in the form <code>col_name = "pluck_specification"</code>. You can pluck
by name with a character vector, by position with an integer vector, or
with a combination of the two with a list. See <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code> for
details.
</p>
<p>The column names must be unique in a call to <code>hoist()</code>, although existing
columns with the same name will be overwritten. When plucking with a
single string you can choose to omit the name, i.e. <code>hoist(df, col, "x")</code>
is short-hand for <code>hoist(df, col, x = "x")</code>.</p>
</td></tr>
<tr><td><code id="hoist_+3A_.remove">.remove</code></td>
<td>
<p>If <code>TRUE</code>, the default, will remove extracted components
from <code>.col</code>. This ensures that each value lives only in one place. If all
components are removed from <code>.col</code>, then <code>.col</code> will be removed from the
result entirely.</p>
</td></tr>
<tr><td><code id="hoist_+3A_.simplify">.simplify</code></td>
<td>
<p>If <code>TRUE</code>, will attempt to simplify lists of
length-1 vectors to an atomic vector. Can also be a named list containing
<code>TRUE</code> or <code>FALSE</code> declaring whether or not to attempt to simplify a
particular column. If a named list is provided, the default for any
unspecified columns is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hoist_+3A_.ptype">.ptype</code></td>
<td>
<p>Optionally, a named list of prototypes declaring the
desired output type of each component. Alternatively, a single empty
prototype can be supplied, which will be applied to all components. Use
this argument if you want to check that each element has the type you
expect when simplifying.
</p>
<p>If a <code>ptype</code> has been specified, but <code>simplify = FALSE</code> or simplification
isn't possible, then a <a href="vctrs.html#topic+list_of">list-of</a> column will be returned
and each element will have type <code>ptype</code>.</p>
</td></tr>
<tr><td><code id="hoist_+3A_.transform">.transform</code></td>
<td>
<p>Optionally, a named list of transformation
functions applied to each component. Alternatively, a single function can
be supplied, which will be applied to all components. Use this argument if
you want to transform or parse individual elements as they are extracted.
</p>
<p>When both <code>ptype</code> and <code>transform</code> are supplied, the <code>transform</code> is applied
before the <code>ptype</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other rectangling: 
<code><a href="tidyr.html#topic+unnest_longer">unnest_longer</a>()</code>,
<code><a href="tidyr.html#topic+unnest_wider">unnest_wider</a>()</code>,
<code><a href="tidyr.html#topic+unnest">unnest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  character = c("Toothless", "Dory"),
  metadata = list(
    list(
      species = "dragon",
      color = "black",
      films = c(
        "How to Train Your Dragon",
        "How to Train Your Dragon 2",
        "How to Train Your Dragon: The Hidden World"
      )
    ),
    list(
      species = "blue tang",
      color = "blue",
      films = c("Finding Nemo", "Finding Dory")
    )
  )
)
df

# Extract only specified components
df %&gt;% hoist(metadata,
  "species",
  first_film = list("films", 1L),
  third_film = list("films", 3L)
)
</code></pre>

<hr>
<h2 id='household'>Household data</h2><span id='topic+household'></span>

<h3>Description</h3>

<p>This dataset is based on an example in
<code>vignette("datatable-reshape", package = "data.table")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>household
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 rows and 5 columns:
</p>

<dl>
<dt>family</dt><dd><p>Family identifier</p>
</dd>
<dt>dob_child1</dt><dd><p>Date of birth of first child</p>
</dd>
<dt>dob_child2</dt><dd><p>Date of birth of second child</p>
</dd>
<dt>name_child1</dt><dd><p>Name of first child</p>
</dd></dl>
<p>?
</p>
<dl>
<dt>name_child2</dt><dd><p>Name of second child</p>
</dd>
</dl>


<hr>
<h2 id='nest'>Nest rows into a list-column of data frames</h2><span id='topic+nest'></span>

<h3>Description</h3>

<p>Nesting creates a list-column of data frames; unnesting flattens it back out
into regular columns. Nesting is implicitly a summarising operation: you
get one row for each group defined by the non-nested columns. This is useful
in conjunction with other summaries that work with whole datasets, most
notably models.
</p>
<p>Learn more in <code>vignette("nest")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest(.data, ..., .by = NULL, .key = NULL, .names_sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nest_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to nest; these will
appear in the inner data frames.
</p>
<p>Specified using name-variable pairs of the form
<code>new_col = c(col1, col2, col3)</code>. The right hand side can be any valid
tidyselect expression.
</p>
<p>If not supplied, then <code>...</code> is derived as all columns <em>not</em> selected by
<code>.by</code>, and will use the column name from <code>.key</code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
previously you could write <code>df %&gt;% nest(x, y, z)</code>.
Convert to <code>df %&gt;% nest(data = c(x, y, z))</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_.by">.by</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to nest <em>by</em>; these
will remain in the outer data frame.
</p>
<p><code>.by</code> can be used in place of or in conjunction with columns supplied
through <code>...</code>.
</p>
<p>If not supplied, then <code>.by</code> is derived as all columns <em>not</em> selected by
<code>...</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_.key">.key</code></td>
<td>
<p>The name of the resulting nested column. Only applicable when
<code>...</code> isn't specified, i.e. in the case of <code>df %&gt;% nest(.by = x)</code>.
</p>
<p>If <code>NULL</code>, then <code>"data"</code> will be used by default.</p>
</td></tr>
<tr><td><code id="nest_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the inner names will come from
the former outer names. If a string, the  new inner names will use the
outer names with <code>names_sep</code> automatically stripped. This makes
<code>names_sep</code> roughly symmetric between nesting and unnesting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If neither <code>...</code> nor <code>.by</code> are supplied, <code>nest()</code> will nest all variables,
and will use the column name supplied through <code>.key</code>.
</p>


<h3>New syntax</h3>

<p>tidyr 1.0.0 introduced a new syntax for <code>nest()</code> and <code>unnest()</code> that's
designed to be more similar to other functions. Converting to the new syntax
should be straightforward (guided by the message you'll receive) but if
you just need to run an old analysis, you can easily revert to the previous
behaviour using <code><a href="tidyr.html#topic+nest_legacy">nest_legacy()</a></code> and <code><a href="tidyr.html#topic+unnest_legacy">unnest_legacy()</a></code> as follows:
</p>
<div class="sourceCode"><pre>library(tidyr)
nest &lt;- nest_legacy
unnest &lt;- unnest_legacy
</pre></div>


<h3>Grouped data frames</h3>

<p><code>df %&gt;% nest(data = c(x, y))</code> specifies the columns to be nested; i.e. the
columns that will appear in the inner data frame. <code>df %&gt;% nest(.by = c(x, y))</code> specifies the columns to nest <em>by</em>; i.e. the columns that will remain in
the outer data frame. An alternative way to achieve the latter is to <code>nest()</code>
a grouped data frame created by <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. The grouping variables
remain in the outer data frame and the others are nested. The result
preserves the grouping of the input.
</p>
<p>Variables supplied to <code>nest()</code> will override grouping variables so that
<code>df %&gt;% group_by(x, y) %&gt;% nest(data = !z)</code> will be equivalent to
<code>df %&gt;% nest(data = !z)</code>.
</p>
<p>You can't supply <code>.by</code> with a grouped data frame, as the groups already
represent what you are nesting by.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)

# Specify variables to nest using name-variable pairs.
# Note that we get one row of output for each unique combination of
# non-nested variables.
df %&gt;% nest(data = c(y, z))

# Specify variables to nest by (rather than variables to nest) using `.by`
df %&gt;% nest(.by = x)

# In this case, since `...` isn't used you can specify the resulting column
# name with `.key`
df %&gt;% nest(.by = x, .key = "cols")

# Use tidyselect syntax and helpers, just like in `dplyr::select()`
df %&gt;% nest(data = any_of(c("y", "z")))

# `...` and `.by` can be used together to drop columns you no longer need,
# or to include the columns you are nesting by in the inner data frame too.
# This drops `z`:
df %&gt;% nest(data = y, .by = x)
# This includes `x` in the inner data frame:
df %&gt;% nest(data = everything(), .by = x)

# Multiple nesting structures can be specified at once
iris %&gt;%
  nest(petal = starts_with("Petal"), sepal = starts_with("Sepal"))
iris %&gt;%
  nest(width = contains("Width"), length = contains("Length"))

# Nesting a grouped data frame nests all variables apart from the group vars
fish_encounters %&gt;%
  dplyr::group_by(fish) %&gt;%
  nest()

# That is similar to `nest(.by = )`, except here the result isn't grouped
fish_encounters %&gt;%
  nest(.by = fish)

# Nesting is often useful for creating per group models
mtcars %&gt;%
  nest(.by = cyl) %&gt;%
  dplyr::mutate(models = lapply(data, function(df) lm(mpg ~ wt, data = df)))
</code></pre>

<hr>
<h2 id='nest_legacy'>Legacy versions of <code>nest()</code> and <code>unnest()</code></h2><span id='topic+nest_legacy'></span><span id='topic+unnest_legacy'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>tidyr 1.0.0 introduced a new syntax for <code><a href="tidyr.html#topic+nest">nest()</a></code> and <code><a href="tidyr.html#topic+unnest">unnest()</a></code>. The majority
of existing usage should be automatically translated to the new syntax with a
warning. However, if you need to quickly roll back to the previous behaviour,
these functions provide the previous interface. To make old code work as is,
add the following code to the top of your script:
</p>
<div class="sourceCode"><pre>library(tidyr)
nest &lt;- nest_legacy
unnest &lt;- unnest_legacy
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>nest_legacy(data, ..., .key = "data")

unnest_legacy(data, ..., .drop = NA, .id = NULL, .sep = NULL, .preserve = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_legacy_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nest_legacy_+3A_...">...</code></td>
<td>
<p>Specification of columns to unnest. Use bare variable names or
functions of variables. If omitted, defaults to all list-cols.</p>
</td></tr>
<tr><td><code id="nest_legacy_+3A_.key">.key</code></td>
<td>
<p>The name of the new column, as a string or symbol. This argument
is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings and
symbols). The name is captured from the expression with <code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code>
(note that this kind of interface where symbols do not represent actual
objects is now discouraged in the tidyverse; we support it here for
backward compatibility).</p>
</td></tr>
<tr><td><code id="nest_legacy_+3A_.drop">.drop</code></td>
<td>
<p>Should additional list columns be dropped? By default,
<code>unnest()</code> will drop them if unnesting the specified columns requires the
rows to be duplicated.</p>
</td></tr>
<tr><td><code id="nest_legacy_+3A_.id">.id</code></td>
<td>
<p>Data frame identifier - if supplied, will create a new column with
name <code>.id</code>, giving a unique identifier. This is most useful if the list
column is named.</p>
</td></tr>
<tr><td><code id="nest_legacy_+3A_.sep">.sep</code></td>
<td>
<p>If non-<code>NULL</code>, the names of unnested data frame columns will
combine the name of the original list-col with the names from the nested
data frame, separated by <code>.sep</code>.</p>
</td></tr>
<tr><td><code id="nest_legacy_+3A_.preserve">.preserve</code></td>
<td>
<p>Optionally, list-columns to preserve in the output. These
will be duplicated in the same way as atomic vectors. This has
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code> semantics so you can preserve multiple variables with
<code>.preserve = c(x, y)</code> or <code>.preserve = starts_with("list")</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Nest and unnest are inverses
df &lt;- tibble(x = c(1, 1, 2), y = 3:1)
df %&gt;% nest_legacy(y)
df %&gt;% nest_legacy(y) %&gt;% unnest_legacy()

# nesting -------------------------------------------------------------------
as_tibble(iris) %&gt;% nest_legacy(!Species)
as_tibble(chickwts) %&gt;% nest_legacy(weight)

# unnesting -----------------------------------------------------------------
df &lt;- tibble(
  x = 1:2,
  y = list(
    tibble(z = 1),
    tibble(z = 3:4)
  )
)
df %&gt;% unnest_legacy(y)

# You can also unnest multiple columns simultaneously
df &lt;- tibble(
  a = list(c("a", "b"), "c"),
  b = list(1:2, 3),
  c = c(11, 22)
)
df %&gt;% unnest_legacy(a, b)
# If you omit the column names, it'll unnest all list-cols
df %&gt;% unnest_legacy()
</code></pre>

<hr>
<h2 id='pack'>Pack and unpack</h2><span id='topic+pack'></span><span id='topic+unpack'></span>

<h3>Description</h3>

<p>Packing and unpacking preserve the length of a data frame, changing its
width. <code>pack()</code> makes <code>df</code> narrow by collapsing a set of columns into a
single df-column. <code>unpack()</code> makes <code>data</code> wider by expanding df-columns
back out into individual columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack(.data, ..., .names_sep = NULL, .error_call = current_env())

unpack(
  data,
  cols,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_+3A_...">...</code></td>
<td>
<p>For <code>pack()</code>, &lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; columns to
pack, specified using name-variable pairs of the form
<code>new_col = c(col1, col2, col3)</code>. The right hand side can be any valid tidy
select expression.
</p>
<p>For <code>unpack()</code>, these dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="pack_+3A_data">data</code>, <code id="pack_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="pack_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unpack.</p>
</td></tr>
<tr><td><code id="pack_+3A_names_sep">names_sep</code>, <code id="pack_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left
as is. In <code>pack()</code>, inner names will come from the former outer names;
in <code>unpack()</code>, the new outer names will come from the inner names.
</p>
<p>If a string, the inner and outer names will be used together. In
<code>unpack()</code>, the names of the new outer columns will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>. In
<code>pack()</code>, the new inner names will have the outer names + <code>names_sep</code>
automatically stripped. This makes <code>names_sep</code> roughly symmetric between
packing and unpacking.</p>
</td></tr>
<tr><td><code id="pack_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="pack_+3A_error_call">error_call</code>, <code id="pack_+3A_.error_call">.error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, unpacking is more useful than packing because it simplifies
a complex data structure. Currently, few functions work with df-cols,
and they are mostly a curiosity, but seem worth exploring further because
they mimic the nested column headers that are so popular in Excel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Packing -------------------------------------------------------------------
# It's not currently clear why you would ever want to pack columns
# since few functions work with this sort of data.
df &lt;- tibble(x1 = 1:3, x2 = 4:6, x3 = 7:9, y = 1:3)
df
df %&gt;% pack(x = starts_with("x"))
df %&gt;% pack(x = c(x1, x2, x3), y = y)

# .names_sep allows you to strip off common prefixes; this
# acts as a natural inverse to name_sep in unpack()
iris %&gt;%
  as_tibble() %&gt;%
  pack(
    Sepal = starts_with("Sepal"),
    Petal = starts_with("Petal"),
    .names_sep = "."
  )

# Unpacking -----------------------------------------------------------------
df &lt;- tibble(
  x = 1:3,
  y = tibble(a = 1:3, b = 3:1),
  z = tibble(X = c("a", "b", "c"), Y = runif(3), Z = c(TRUE, FALSE, NA))
)
df
df %&gt;% unpack(y)
df %&gt;% unpack(c(y, z))
df %&gt;% unpack(c(y, z), names_sep = "_")
</code></pre>

<hr>
<h2 id='pivot_longer'>Pivot data from wide to long</h2><span id='topic+pivot_longer'></span>

<h3>Description</h3>

<p><code>pivot_longer()</code> &quot;lengthens&quot; data, increasing the number of rows and
decreasing the number of columns. The inverse transformation is
<code><a href="tidyr.html#topic+pivot_wider">pivot_wider()</a></code>
</p>
<p>Learn more in <code>vignette("pivot")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_longer(
  data,
  cols,
  ...,
  cols_vary = "fastest",
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_longer_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_cols_vary">cols_vary</code></td>
<td>
<p>When pivoting <code>cols</code> into longer format, how should the
output rows be arranged relative to their original row number?
</p>

<ul>
<li> <p><code>"fastest"</code>, the default, keeps individual rows from <code>cols</code> close
together in the output. This often produces intuitively ordered output
when you have at least one key column from <code>data</code> that is not involved in
the pivoting process.
</p>
</li>
<li> <p><code>"slowest"</code> keeps individual columns from <code>cols</code> close together in the
output. This often produces intuitively ordered output when you utilize
all of the columns from <code>data</code> in the pivoting process.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_to">names_to</code></td>
<td>
<p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_sep">names_sep</code>, <code id="pivot_longer_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="magrittr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_transform">names_transform</code>, <code id="pivot_longer_+3A_values_transform">values_transform</code></td>
<td>
<p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pivot_longer()</code> is an updated approach to <code><a href="tidyr.html#topic+gather">gather()</a></code>, designed to be both
simpler to use and to handle more use cases. We recommend you use
<code>pivot_longer()</code> for new code; <code>gather()</code> isn't going away but is no longer
under active development.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("pivot") for examples and explanation

# Simplest case where column names are character data
relig_income
relig_income %&gt;%
  pivot_longer(!religion, names_to = "income", values_to = "count")

# Slightly more complex case where columns have common prefix,
# and missing missings are structural so should be dropped.
billboard
billboard %&gt;%
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    names_prefix = "wk",
    values_to = "rank",
    values_drop_na = TRUE
  )

# Multiple variables stored in column names
who %&gt;% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c("diagnosis", "gender", "age"),
  names_pattern = "new_?(.*)_(.)(.*)",
  values_to = "count"
)

# Multiple observations per row. Since all columns are used in the pivoting
# process, we'll use `cols_vary` to keep values from the original columns
# close together in the output.
anscombe
anscombe %&gt;%
  pivot_longer(
    everything(),
    cols_vary = "slowest",
    names_to = c(".value", "set"),
    names_pattern = "(.)(.)"
  )
</code></pre>

<hr>
<h2 id='pivot_longer_spec'>Pivot data from wide to long using a spec</h2><span id='topic+pivot_longer_spec'></span><span id='topic+build_longer_spec'></span>

<h3>Description</h3>

<p>This is a low level interface to pivoting, inspired by the cdata package,
that allows you to describe pivoting with a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_longer_spec(
  data,
  spec,
  ...,
  cols_vary = "fastest",
  names_repair = "check_unique",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  error_call = current_env()
)

build_longer_spec(
  data,
  cols,
  ...,
  names_to = "name",
  values_to = "value",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_longer_spec_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_spec">spec</code></td>
<td>
<p>A specification data frame. This is useful for more complex
pivots because it gives you greater control on how metadata stored in the
column names turns into columns in the result.
</p>
<p>Must be a data frame containing character <code>.name</code> and <code>.value</code> columns.
Additional columns in <code>spec</code> should be named to match columns in the
long format of the dataset and contain values corresponding to columns
pivoted from the wide format.
The special <code>.seq</code> variable is used to disambiguate rows internally;
it is automatically removed after pivoting.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_cols_vary">cols_vary</code></td>
<td>
<p>When pivoting <code>cols</code> into longer format, how should the
output rows be arranged relative to their original row number?
</p>

<ul>
<li> <p><code>"fastest"</code>, the default, keeps individual rows from <code>cols</code> close
together in the output. This often produces intuitively ordered output
when you have at least one key column from <code>data</code> that is not involved in
the pivoting process.
</p>
</li>
<li> <p><code>"slowest"</code> keeps individual columns from <code>cols</code> close together in the
output. This often produces intuitively ordered output when you utilize
all of the columns from <code>data</code> in the pivoting process.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_names_to">names_to</code></td>
<td>
<p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_names_sep">names_sep</code>, <code id="pivot_longer_spec_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="magrittr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer_spec_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.</p>
</td></tr>
<tr><td><code id="pivot_longer_spec_+3A_names_transform">names_transform</code>, <code id="pivot_longer_spec_+3A_values_transform">values_transform</code></td>
<td>
<p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("pivot") for examples and explanation

# Use `build_longer_spec()` to build `spec` using similar syntax to `pivot_longer()`
# and run `pivot_longer_spec()` based on `spec`.
spec &lt;- relig_income %&gt;% build_longer_spec(
  cols = !religion,
  names_to = "income",
  values_to = "count"
)
spec

pivot_longer_spec(relig_income, spec)

# Is equivalent to:
relig_income %&gt;% pivot_longer(
  cols = !religion,
  names_to = "income",
  values_to = "count"
)
</code></pre>

<hr>
<h2 id='pivot_wider'>Pivot data from long to wide</h2><span id='topic+pivot_wider'></span>

<h3>Description</h3>

<p><code>pivot_wider()</code> &quot;widens&quot; data, increasing the number of columns and
decreasing the number of rows. The inverse transformation is
<code><a href="tidyr.html#topic+pivot_longer">pivot_longer()</a></code>.
</p>
<p>Learn more in <code>vignette("pivot")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_wider(
  data,
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = NULL,
  unused_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_wider_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_id_cols">id_cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns that
uniquely identify each observation. Typically used when you have
redundant variables, i.e. variables whose values are perfectly correlated
with existing variables.
</p>
<p>Defaults to all columns in <code>data</code> except for the columns specified through
<code>names_from</code> and <code>values_from</code>. If a tidyselect expression is supplied, it
will be evaluated on <code>data</code> after removing the columns specified through
<code>names_from</code> and <code>values_from</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_id_expand">id_expand</code></td>
<td>
<p>Should the values in the <code>id_cols</code> columns be expanded by
<code><a href="Matrix.html#topic+expand">expand()</a></code> before pivoting? This results in more rows, the output will
contain a complete expansion of all possible values in <code>id_cols</code>. Implicit
factor levels that aren't represented in the data will become explicit.
Additionally, the row values corresponding to the expanded <code>id_cols</code> will
be sorted.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_from">names_from</code>, <code id="pivot_wider_+3A_values_from">values_from</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_prefix">names_prefix</code></td>
<td>
<p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to
create syntactic variable names.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_vary">names_vary</code></td>
<td>
<p>When <code>names_from</code> identifies a column (or columns) with
multiple unique values, and multiple <code>values_from</code> columns are provided,
in what order should the resulting column names be combined?
</p>

<ul>
<li> <p><code>"fastest"</code> varies <code>names_from</code> values fastest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value1_name2, value2_name1, value2_name2&#8288;</code>. This is the default.
</p>
</li>
<li> <p><code>"slowest"</code> varies <code>names_from</code> values slowest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value2_name1, value1_name2, value2_name2&#8288;</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_expand">names_expand</code></td>
<td>
<p>Should the values in the <code>names_from</code> columns be expanded
by <code><a href="Matrix.html#topic+expand">expand()</a></code> before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in <code>names_from</code>. Implicit factor levels that aren't
represented in the data will become explicit. Additionally, the column
names will be sorted, identical to what <code>names_sort</code> would produce.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_fn">values_fn</code></td>
<td>
<p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_unused_fn">unused_fn</code></td>
<td>
<p>Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by <code>id_cols</code>,
<code>names_from</code>, or <code>values_from</code>).
</p>
<p>The default drops all unused columns from the result.
</p>
<p>This can be a named list if you want to apply different aggregations
to different unused columns.
</p>
<p><code>id_cols</code> must be supplied for <code>unused_fn</code> to be useful, since otherwise
all unspecified columns will be considered <code>id_cols</code>.
</p>
<p>This is similar to grouping by the <code>id_cols</code> then summarizing the
unused columns using <code>unused_fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pivot_wider()</code> is an updated approach to <code><a href="tidyr.html#topic+spread">spread()</a></code>, designed to be both
simpler to use and to handle more use cases. We recommend you use
<code>pivot_wider()</code> for new code; <code>spread()</code> isn't going away but is no longer
under active development.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+pivot_wider_spec">pivot_wider_spec()</a></code> to pivot &quot;by hand&quot; with a data frame that
defines a pivoting specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("pivot") for examples and explanation

fish_encounters
fish_encounters %&gt;%
  pivot_wider(names_from = station, values_from = seen)
# Fill in missing values
fish_encounters %&gt;%
  pivot_wider(names_from = station, values_from = seen, values_fill = 0)

# Generate column names from multiple variables
us_rent_income
us_rent_income %&gt;%
  pivot_wider(
    names_from = variable,
    values_from = c(estimate, moe)
  )

# You can control whether `names_from` values vary fastest or slowest
# relative to the `values_from` column names using `names_vary`.
us_rent_income %&gt;%
  pivot_wider(
    names_from = variable,
    values_from = c(estimate, moe),
    names_vary = "slowest"
  )

# When there are multiple `names_from` or `values_from`, you can use
# use `names_sep` or `names_glue` to control the output variable names
us_rent_income %&gt;%
  pivot_wider(
    names_from = variable,
    names_sep = ".",
    values_from = c(estimate, moe)
  )
us_rent_income %&gt;%
  pivot_wider(
    names_from = variable,
    names_glue = "{variable}_{.value}",
    values_from = c(estimate, moe)
  )

# Can perform aggregation with `values_fn`
warpbreaks &lt;- as_tibble(warpbreaks[c("wool", "tension", "breaks")])
warpbreaks
warpbreaks %&gt;%
  pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = mean
  )

# Can pass an anonymous function to `values_fn` when you
# need to supply additional arguments
warpbreaks$breaks[1] &lt;- NA
warpbreaks %&gt;%
  pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = ~ mean(.x, na.rm = TRUE)
  )
</code></pre>

<hr>
<h2 id='pivot_wider_spec'>Pivot data from long to wide using a spec</h2><span id='topic+pivot_wider_spec'></span><span id='topic+build_wider_spec'></span>

<h3>Description</h3>

<p>This is a low level interface to pivoting, inspired by the cdata package,
that allows you to describe pivoting with a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_wider_spec(
  data,
  spec,
  ...,
  names_repair = "check_unique",
  id_cols = NULL,
  id_expand = FALSE,
  values_fill = NULL,
  values_fn = NULL,
  unused_fn = NULL,
  error_call = current_env()
)

build_wider_spec(
  data,
  ...,
  names_from = name,
  values_from = value,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_wider_spec_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_spec">spec</code></td>
<td>
<p>A specification data frame. This is useful for more complex
pivots because it gives you greater control on how metadata stored in the
columns become column names in the result.
</p>
<p>Must be a data frame containing character <code>.name</code> and <code>.value</code> columns.
Additional columns in <code>spec</code> should be named to match columns in the
long format of the dataset and contain values corresponding to columns
pivoted from the wide format.
The special <code>.seq</code> variable is used to disambiguate rows internally;
it is automatically removed after pivoting.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_id_cols">id_cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns that
uniquely identifies each observation. Defaults to all columns in <code>data</code>
except for the columns specified in <code>spec$.value</code> and the columns of the
<code>spec</code> that aren't named <code>.name</code> or <code>.value</code>. Typically used when you have
redundant variables, i.e. variables whose values are perfectly correlated
with existing variables.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_id_expand">id_expand</code></td>
<td>
<p>Should the values in the <code>id_cols</code> columns be expanded by
<code><a href="Matrix.html#topic+expand">expand()</a></code> before pivoting? This results in more rows, the output will
contain a complete expansion of all possible values in <code>id_cols</code>. Implicit
factor levels that aren't represented in the data will become explicit.
Additionally, the row values corresponding to the expanded <code>id_cols</code> will
be sorted.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_values_fn">values_fn</code></td>
<td>
<p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_unused_fn">unused_fn</code></td>
<td>
<p>Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by <code>id_cols</code>,
<code>names_from</code>, or <code>values_from</code>).
</p>
<p>The default drops all unused columns from the result.
</p>
<p>This can be a named list if you want to apply different aggregations
to different unused columns.
</p>
<p><code>id_cols</code> must be supplied for <code>unused_fn</code> to be useful, since otherwise
all unspecified columns will be considered <code>id_cols</code>.
</p>
<p>This is similar to grouping by the <code>id_cols</code> then summarizing the
unused columns using <code>unused_fn</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_from">names_from</code>, <code id="pivot_wider_spec_+3A_values_from">values_from</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_prefix">names_prefix</code></td>
<td>
<p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to
create syntactic variable names.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_vary">names_vary</code></td>
<td>
<p>When <code>names_from</code> identifies a column (or columns) with
multiple unique values, and multiple <code>values_from</code> columns are provided,
in what order should the resulting column names be combined?
</p>

<ul>
<li> <p><code>"fastest"</code> varies <code>names_from</code> values fastest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value1_name2, value2_name1, value2_name2&#8288;</code>. This is the default.
</p>
</li>
<li> <p><code>"slowest"</code> varies <code>names_from</code> values slowest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value2_name1, value1_name2, value2_name2&#8288;</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_wider_spec_+3A_names_expand">names_expand</code></td>
<td>
<p>Should the values in the <code>names_from</code> columns be expanded
by <code><a href="Matrix.html#topic+expand">expand()</a></code> before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in <code>names_from</code>. Implicit factor levels that aren't
represented in the data will become explicit. Additionally, the column
names will be sorted, identical to what <code>names_sort</code> would produce.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("pivot") for examples and explanation

us_rent_income
spec1 &lt;- us_rent_income %&gt;%
  build_wider_spec(names_from = variable, values_from = c(estimate, moe))
spec1

us_rent_income %&gt;%
  pivot_wider_spec(spec1)

# Is equivalent to
us_rent_income %&gt;%
  pivot_wider(names_from = variable, values_from = c(estimate, moe))

# `pivot_wider_spec()` provides more control over column names and output format
# instead of creating columns with estimate_ and moe_ prefixes,
# keep original variable name for estimates and attach _moe as suffix
spec2 &lt;- tibble(
  .name = c("income", "rent", "income_moe", "rent_moe"),
  .value = c("estimate", "estimate", "moe", "moe"),
  variable = c("income", "rent", "income", "rent")
)

us_rent_income %&gt;%
  pivot_wider_spec(spec2)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tribble'></span><span id='topic+tibble'></span><span id='topic+as_tibble'></span><span id='topic+all_of'></span><span id='topic+select_helpers'></span><span id='topic+any_of'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+last_col'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code>, <code><a href="tibble.html#topic+tibble">tibble</a></code>, <code><a href="tibble.html#topic+tribble">tribble</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relig_income'>Pew religion and income survey</h2><span id='topic+relig_income'></span>

<h3>Description</h3>

<p>Pew religion and income survey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relig_income
</code></pre>


<h3>Format</h3>

<p>A dataset with variables:
</p>

<dl>
<dt>religion</dt><dd><p>Name of religion</p>
</dd>
<dt><code style="white-space: pre;">&#8288;&lt;$10k&#8288;</code>-<code style="white-space: pre;">&#8288;Don\'t know/refused&#8288;</code></dt><dd><p>Number of respondees with
income range in column name</p>
</dd>
</dl>



<h3>Source</h3>

<p>Downloaded from <a href="https://www.pewresearch.org/religion/religious-landscape-study/">https://www.pewresearch.org/religion/religious-landscape-study/</a>
(downloaded November 2009)
</p>

<hr>
<h2 id='replace_na'>Replace NAs with specified values</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>Replace NAs with specified values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(data, replace, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_+3A_data">data</code></td>
<td>
<p>A data frame or vector.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_replace">replace</code></td>
<td>
<p>If <code>data</code> is a data frame, <code>replace</code> takes a named list of
values, with one value for each column that has missing values to be
replaced. Each value in <code>replace</code> will be cast to the type of the column
in <code>data</code> that it being used as a replacement in.
</p>
<p>If <code>data</code> is a vector, <code>replace</code> takes a single value. This single value
replaces all of the missing values in the vector. <code>replace</code> will be cast
to the type of <code>data</code>.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>replace_na()</code> returns an object with the same type as <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+na_if">dplyr::na_if()</a></code> to replace specified values with <code>NA</code>s;
<code><a href="dplyr.html#topic+coalesce">dplyr::coalesce()</a></code> to replaces <code>NA</code>s with values from other vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Replace NAs in a data frame
df &lt;- tibble(x = c(1, 2, NA), y = c("a", NA, "b"))
df %&gt;% replace_na(list(x = 0, y = "unknown"))

# Replace NAs in a vector
df %&gt;% dplyr::mutate(x = replace_na(x, 0))
# OR
df$x %&gt;% replace_na(0)
df$y %&gt;% replace_na("unknown")

# Replace NULLs in a list: NULLs are the list-col equivalent of NAs
df_list &lt;- tibble(z = list(1:5, NULL, 10:20))
df_list %&gt;% replace_na(list(z = list(5)))
</code></pre>

<hr>
<h2 id='separate'>Separate a character column into multiple columns with a regular
expression or numeric locations</h2><span id='topic+separate'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>separate()</code> has been superseded in favour of <code><a href="tidyr.html#topic+separate_wider_position">separate_wider_position()</a></code>
and <code><a href="tidyr.html#topic+separate_wider_delim">separate_wider_delim()</a></code> because the two functions make the two uses
more obvious, the API is more polished, and the handling of problems is
better. Superseded functions will not go away, but will only receive
critical bug fixes.
</p>
<p>Given either a regular expression or a vector of character positions,
<code>separate()</code> turns a single character column into multiple columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Column to expand.</p>
</td></tr>
<tr><td><code id="separate_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="separate_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.
</p>
<p>If character, <code>sep</code> is interpreted as a regular expression. The default
value is a regular expression that matches any sequence of
non-alphanumeric values.
</p>
<p>If numeric, <code>sep</code> is interpreted as character positions to split at. Positive
values start at 1 at the far-left of the string; negative value start at -1 at
the far-right of the string. The length of <code>sep</code> should be one less than
<code>into</code>.</p>
</td></tr>
<tr><td><code id="separate_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="separate_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="separate_+3A_extra">extra</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and drop extra values.
</p>
</li>
<li> <p><code>"drop"</code>: drop any extra values without a warning.
</p>
</li>
<li> <p><code>"merge"</code>: only splits at most <code>length(into)</code> times
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate_+3A_fill">fill</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and fill from the right
</p>
</li>
<li> <p><code>"right"</code>: fill with missing values on the right
</p>
</li>
<li> <p><code>"left"</code>: fill with missing values on the left
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+unite">unite()</a></code>, the complement, <code><a href="magrittr.html#topic+extract">extract()</a></code> which uses regular
expression capturing groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If you want to split by any non-alphanumeric value (the default):
df &lt;- tibble(x = c(NA, "x.y", "x.z", "y.z"))
df %&gt;% separate(x, c("A", "B"))

# If you just want the second variable:
df %&gt;% separate(x, c(NA, "B"))

# We now recommend separate_wider_delim() instead:
df %&gt;% separate_wider_delim(x, ".", names = c("A", "B"))
df %&gt;% separate_wider_delim(x, ".", names = c(NA, "B"))

# Controlling uneven splits -------------------------------------------------
# If every row doesn't split into the same number of pieces, use
# the extra and fill arguments to control what happens:
df &lt;- tibble(x = c("x", "x y", "x y z", NA))
df %&gt;% separate(x, c("a", "b"))
# The same behaviour as previous, but drops the c without warnings:
df %&gt;% separate(x, c("a", "b"), extra = "drop", fill = "right")
# Opposite of previous, keeping the c and filling left:
df %&gt;% separate(x, c("a", "b"), extra = "merge", fill = "left")
# Or you can keep all three:
df %&gt;% separate(x, c("a", "b", "c"))

# To only split a specified number of times use extra = "merge":
df &lt;- tibble(x = c("x: 123", "y: error: 7"))
df %&gt;% separate(x, c("key", "value"), ": ", extra = "merge")

# Controlling column types --------------------------------------------------
# convert = TRUE detects column classes:
df &lt;- tibble(x = c("x:1", "x:2", "y:4", "z", NA))
df %&gt;% separate(x, c("key", "value"), ":") %&gt;% str()
df %&gt;% separate(x, c("key", "value"), ":", convert = TRUE) %&gt;% str()
</code></pre>

<hr>
<h2 id='separate_longer_delim'>Split a string into rows</h2><span id='topic+separate_longer_delim'></span><span id='topic+separate_longer_position'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Each of these functions takes a string and splits it into multiple rows:
</p>

<ul>
<li> <p><code>separate_longer_delim()</code> splits by a delimiter.
</p>
</li>
<li> <p><code>separate_longer_position()</code> splits by a fixed width.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>separate_longer_delim(data, cols, delim, ...)

separate_longer_position(data, cols, width, ..., keep_empty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_longer_delim_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to separate.</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_delim">delim</code></td>
<td>
<p>For <code>separate_longer_delim()</code>, a string giving the delimiter
between values. By default, it is interpreted as a fixed string; use
<code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code> and friends to split in other ways.</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_width">width</code></td>
<td>
<p>For <code>separate_longer_position()</code>, an integer giving the
number of characters to split by.</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_keep_empty">keep_empty</code></td>
<td>
<p>By default, you'll get <code>ceiling(nchar(x) / width)</code> rows for
each observation. If <code>nchar(x)</code> is zero, this means the entire input
row will be dropped from the output. If you want to preserve all rows,
use <code>keep_empty = TRUE</code> to replace size-0 elements with a missing value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame based on <code>data</code>. It has the same columns, but different
rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
df %&gt;% separate_longer_delim(x, delim = " ")

# You can separate multiple columns at once if they have the same structure
df &lt;- tibble(id = 1:3, x = c("x", "x y", "x y z"), y = c("a", "a b", "a b c"))
df %&gt;% separate_longer_delim(c(x, y), delim = " ")

# Or instead split by a fixed length
df &lt;- tibble(id = 1:3, x = c("ab", "def", ""))
df %&gt;% separate_longer_position(x, 1)
df %&gt;% separate_longer_position(x, 2)
df %&gt;% separate_longer_position(x, 2, keep_empty = TRUE)
</code></pre>

<hr>
<h2 id='separate_rows'>Separate a collapsed column into multiple rows</h2><span id='topic+separate_rows'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>separate_rows()</code> has been superseded in favour of <code><a href="tidyr.html#topic+separate_longer_delim">separate_longer_delim()</a></code>
because it has a more consistent API with other separate functions.
Superseded functions will not go away, but will only receive critical bug
fixes.
</p>
<p>If a variable contains observations with multiple delimited values,
<code>separate_rows()</code> separates the values and places each one in its own row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_rows(data, ..., sep = "[^[:alnum:].]+", convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_rows_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_rows_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to separate across
multiple rows</p>
</td></tr>
<tr><td><code id="separate_rows_+3A_sep">sep</code></td>
<td>
<p>Separator delimiting collapsed values.</p>
</td></tr>
<tr><td><code id="separate_rows_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code> will automatically run
<code><a href="utils.html#topic+type.convert">type.convert()</a></code> on the key column. This is useful if the column
types are actually numeric, integer, or logical.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  x = 1:3,
  y = c("a", "d,e,f", "g,h"),
  z = c("1", "2,3,4", "5,6")
)
separate_rows(df, y, z, convert = TRUE)

# Now recommended
df %&gt;%
  separate_longer_delim(c(y, z), delim = ",")
</code></pre>

<hr>
<h2 id='separate_wider_delim'>Split a string into columns</h2><span id='topic+separate_wider_delim'></span><span id='topic+separate_wider_position'></span><span id='topic+separate_wider_regex'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Each of these functions takes a string column and splits it into multiple
new columns:
</p>

<ul>
<li> <p><code>separate_wider_delim()</code> splits by delimiter.
</p>
</li>
<li> <p><code>separate_wider_position()</code> splits at fixed widths.
</p>
</li>
<li> <p><code>separate_wider_regex()</code> splits with regular expression matches.
</p>
</li></ul>

<p>These functions are equivalent to <code><a href="tidyr.html#topic+separate">separate()</a></code> and <code><a href="magrittr.html#topic+extract">extract()</a></code>, but use
<a href="https://stringr.tidyverse.org/">stringr</a> as the underlying string
manipulation engine, and their interfaces reflect what we've learned from
<code><a href="tidyr.html#topic+unnest_wider">unnest_wider()</a></code> and <code><a href="tidyr.html#topic+unnest_longer">unnest_longer()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_wider_delim(
  data,
  cols,
  delim,
  ...,
  names = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  too_few = c("error", "debug", "align_start", "align_end"),
  too_many = c("error", "debug", "drop", "merge"),
  cols_remove = TRUE
)

separate_wider_position(
  data,
  cols,
  widths,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  too_few = c("error", "debug", "align_start"),
  too_many = c("error", "debug", "drop"),
  cols_remove = TRUE
)

separate_wider_regex(
  data,
  cols,
  patterns,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  too_few = c("error", "debug", "align_start"),
  cols_remove = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_wider_delim_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to separate.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_delim">delim</code></td>
<td>
<p>For <code>separate_wider_delim()</code>, a string giving the delimiter
between values. By default, it is interpreted as a fixed string; use
<code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code> and friends to split in other ways.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_names">names</code></td>
<td>
<p>For <code>separate_wider_delim()</code>, a character vector of output
column names. Use <code>NA</code> if there are components that you don't want
to appear in the output; the number of non-<code>NA</code> elements determines the
number of new columns in the result.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_names_sep">names_sep</code></td>
<td>
<p>If supplied, output names will be composed
of the input column name followed by the separator followed by the
new column name. Required when <code>cols</code> selects multiple columns.
</p>
<p>For <code>separate_wider_delim()</code> you can specify instead of <code>names</code>, in which
case the names will be generated from the source column name, <code>names_sep</code>,
and a numeric suffix.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_too_few">too_few</code></td>
<td>
<p>What should happen if a value separates into too few
pieces?
</p>

<ul>
<li> <p><code>"error"</code>, the default, will throw an error.
</p>
</li>
<li> <p><code>"debug"</code> adds additional columns to the output to help you
locate and resolve the underlying problem. This option is intended to
help you debug the issue and address and should not generally remain in
your final code.
</p>
</li>
<li> <p><code>"align_start"</code> aligns starts of short matches, adding <code>NA</code> on the end
to pad to the correct length.
</p>
</li>
<li> <p><code>"align_end"</code> (<code>separate_wider_delim()</code> only) aligns the ends of short
matches, adding <code>NA</code> at the start to pad to the correct length.
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_too_many">too_many</code></td>
<td>
<p>What should happen if a value separates into too many
pieces?
</p>

<ul>
<li> <p><code>"error"</code>, the default, will throw an error.
</p>
</li>
<li> <p><code>"debug"</code> will add additional columns to the output to help you
locate and resolve the underlying problem.
</p>
</li>
<li> <p><code>"drop"</code> will silently drop any extra pieces.
</p>
</li>
<li> <p><code>"merge"</code> (<code>separate_wider_delim()</code> only) will merge together any
additional pieces.
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_cols_remove">cols_remove</code></td>
<td>
<p>Should the input <code>cols</code> be removed from the output?
Always <code>FALSE</code> if <code>too_few</code> or <code>too_many</code> are set to <code>"debug"</code>.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_widths">widths</code></td>
<td>
<p>A named numeric vector where the names become column names,
and the values specify the column width. Unnamed components will match,
but not be included in the output.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_patterns">patterns</code></td>
<td>
<p>A named character vector where the names become column names
and the values are regular expressions that match the contents of the
vector. Unnamed components will match, but not be included in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame based on <code>data</code>. It has the same rows, but different
columns:
</p>

<ul>
<li><p> The primary purpose of the functions are to create new columns from
components of the string.
For <code>separate_wider_delim()</code> the names of new columns come from <code>names</code>.
For <code>separate_wider_position()</code> the names come from the names of <code>widths</code>.
For <code>separate_wider_regex()</code> the names come from the names of
<code>patterns</code>.
</p>
</li>
<li><p> If <code>too_few</code> or <code>too_many</code> is <code>"debug"</code>, the output will contain additional
columns useful for debugging:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;{col}_ok&#8288;</code>: a logical vector which tells you if the input was ok or
not. Use to quickly find the problematic rows.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;{col}_remainder&#8288;</code>: any text remaining after separation.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;{col}_pieces&#8288;</code>, <code style="white-space: pre;">&#8288;{col}_width&#8288;</code>, <code style="white-space: pre;">&#8288;{col}_matches&#8288;</code>: number of pieces,
number of characters, and number of matches for <code>separate_wider_delim()</code>,
<code>separate_wider_position()</code> and <code>separate_regexp_wider()</code> respectively.
</p>
</li></ul>

</li>
<li><p> If <code>cols_remove = TRUE</code> (the default), the input <code>cols</code> will be removed
from the output.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(id = 1:3, x = c("m-123", "f-455", "f-123"))
# There are three basic ways to split up a string into pieces:
# 1. with a delimiter
df %&gt;% separate_wider_delim(x, delim = "-", names = c("gender", "unit"))
# 2. by length
df %&gt;% separate_wider_position(x, c(gender = 1, 1, unit = 3))
# 3. defining each component with a regular expression
df %&gt;% separate_wider_regex(x, c(gender = ".", ".", unit = "\\d+"))

# Sometimes you split on the "last" delimiter
df &lt;- tibble(var = c("race_1", "race_2", "age_bucket_1", "age_bucket_2"))
# _delim won't help because it always splits on the first delimiter
try(df %&gt;% separate_wider_delim(var, "_", names = c("var1", "var2")))
df %&gt;% separate_wider_delim(var, "_", names = c("var1", "var2"), too_many = "merge")
# Instead, you can use _regex
df %&gt;% separate_wider_regex(var, c(var1 = ".*", "_", var2 = ".*"))
# this works because * is greedy; you can mimic the _delim behaviour with .*?
df %&gt;% separate_wider_regex(var, c(var1 = ".*?", "_", var2 = ".*"))

# If the number of components varies, it's most natural to split into rows
df &lt;- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
df %&gt;% separate_longer_delim(x, delim = " ")
# But separate_wider_delim() provides some tools to deal with the problem
# The default behaviour tells you that there's a problem
try(df %&gt;% separate_wider_delim(x, delim = " ", names = c("a", "b")))
# You can get additional insight by using the debug options
df %&gt;%
  separate_wider_delim(
    x,
    delim = " ",
    names = c("a", "b"),
    too_few = "debug",
    too_many = "debug"
  )

# But you can suppress the warnings
df %&gt;%
  separate_wider_delim(
    x,
    delim = " ",
    names = c("a", "b"),
    too_few = "align_start",
    too_many = "merge"
  )

# Or choose to automatically name the columns, producing as many as needed
df %&gt;% separate_wider_delim(x, delim = " ", names_sep = "", too_few = "align_start")
</code></pre>

<hr>
<h2 id='smiths'>Some data about the Smith family</h2><span id='topic+smiths'></span>

<h3>Description</h3>

<p>A small demo dataset describing John and Mary Smith.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smiths
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 rows and 5 columns.
</p>

<hr>
<h2 id='spread'>Spread a key-value pair across multiple columns</h2><span id='topic+spread'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Development on <code>spread()</code> is complete, and for new code we recommend
switching to <code>pivot_wider()</code>, which is easier to use, more featureful, and
still under active development.
<code>df %&gt;% spread(key, value)</code> is equivalent to
<code>df %&gt;% pivot_wider(names_from = key, values_from = value)</code>
</p>
<p>See more details in <code>vignette("pivot")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE, sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="spread_+3A_key">key</code>, <code id="spread_+3A_value">value</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to use
for <code>key</code> and <code>value</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_fill">fill</code></td>
<td>
<p>If set, missing values will be replaced with this value. Note
that there are two types of missingness in the input: explicit missing
values (i.e. <code>NA</code>), and implicit missings, rows that simply aren't
present. Both types of missing value will be replaced by <code>fill</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with <code>asis =
  TRUE</code> will be run on each of the new columns. This is useful if the value
column was a mix of variables that was coerced to a string. If the class of
the value column was factor or date, note that will not be true of the new
columns that are produced, which are coerced to character before type
conversion.</p>
</td></tr>
<tr><td><code id="spread_+3A_drop">drop</code></td>
<td>
<p>If <code>FALSE</code>, will keep factor levels that don't appear in the
data, filling in missing combinations with <code>fill</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_sep">sep</code></td>
<td>
<p>If <code>NULL</code>, the column names will be taken from the values of
<code>key</code> variable. If non-<code>NULL</code>, the column names will be given
by <code>"&lt;key_name&gt;&lt;sep&gt;&lt;key_value&gt;"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>stocks &lt;- tibble(
  time = as.Date("2009-01-01") + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)
stocksm &lt;- stocks %&gt;% gather(stock, price, -time)
stocksm %&gt;% spread(stock, price)
stocksm %&gt;% spread(time, price)

# Spread and gather are complements
df &lt;- tibble(x = c("a", "b"), y = c(3, 4), z = c(5, 6))
df %&gt;%
  spread(x, y) %&gt;%
  gather("x", "y", a:b, na.rm = TRUE)

# Use 'convert = TRUE' to produce variables of mixed type
df &lt;- tibble(
  row = rep(c(1, 51), each = 3),
  var = rep(c("Sepal.Length", "Species", "Species_num"), 2),
  value = c(5.1, "setosa", 1, 7.0, "versicolor", 2)
)
df %&gt;% spread(var, value) %&gt;% str()
df %&gt;% spread(var, value, convert = TRUE) %&gt;% str()
</code></pre>

<hr>
<h2 id='table1'>Example tabular representations</h2><span id='topic+table1'></span><span id='topic+table2'></span><span id='topic+table3'></span><span id='topic+table4a'></span><span id='topic+table4b'></span><span id='topic+table5'></span>

<h3>Description</h3>

<p>Data sets that demonstrate multiple ways to layout the same tabular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table1

table2

table3

table4a

table4b

table5
</code></pre>


<h3>Details</h3>

<p><code>table1</code>, <code>table2</code>, <code>table3</code>, <code>table4a</code>, <code>table4b</code>,
and <code>table5</code> all display the number of TB cases documented by the World
Health Organization in Afghanistan, Brazil, and China between 1999 and 2000.
The data contains values associated with four variables (country, year,
cases, and population), but each table organizes the values in a different
layout.
</p>
<p>The data is a subset of the data contained in the World Health
Organization Global Tuberculosis Report
</p>


<h3>Source</h3>

<p><a href="https://www.who.int/teams/global-tuberculosis-programme/data">https://www.who.int/teams/global-tuberculosis-programme/data</a>
</p>

<hr>
<h2 id='tidyr_data_masking'>Argument type: data-masking</h2><span id='topic+tidyr_data_masking'></span>

<h3>Description</h3>

<p>This page describes the <code style="white-space: pre;">&#8288;&lt;data-masking&gt;&#8288;</code> argument modifier which
indicates that the argument uses <strong>data masking</strong>, a sub-type of
tidy evaluation. If you've never heard of tidy evaluation before,
start with the practical introduction in
<a href="https://r4ds.hadley.nz/functions.html#data-frame-functions">https://r4ds.hadley.nz/functions.html#data-frame-functions</a> then
then read more about the underlying theory in
<a href="https://rlang.r-lib.org/reference/topic-data-mask.html">https://rlang.r-lib.org/reference/topic-data-mask.html</a>.
</p>


<h3>Key techniques</h3>


<ul>
<li><p> To allow the user to supply the column name in a function argument,
embrace the argument, e.g. <code>filter(df, {{ var }})</code>.
</p>
<div class="sourceCode R"><pre>dist_summary &lt;- function(df, var) {
  df %&gt;%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %&gt;% dist_summary(mpg)
mtcars %&gt;% group_by(cyl) %&gt;% dist_summary(mpg)
</pre></div>
</li>
<li><p> To work with a column name recorded as a string, use the <code>.data</code>
pronoun, e.g. <code>summarise(df, mean = mean(.data[[var]]))</code>.
</p>
<div class="sourceCode R"><pre>for (var in names(mtcars)) {
  mtcars %&gt;% count(.data[[var]]) %&gt;% print()
}

lapply(names(mtcars), function(var) mtcars %&gt;% count(.data[[var]]))
</pre></div>
</li>
<li><p> To suppress <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> <code>NOTE</code>s about unknown variables
use <code>.data$var</code> instead of <code>var</code>:
</p>
<div class="sourceCode R"><pre># has NOTE
df %&gt;% mutate(z = x + y)

# no NOTE
df %&gt;% mutate(z = .data$x + .data$y)
</pre></div>
<p>You'll also need to import <code>.data</code> from rlang with (e.g.)
<code style="white-space: pre;">&#8288;@importFrom rlang .data&#8288;</code>.
</p>
</li></ul>



<h3>Dot-dot-dot (...)</h3>

<p><code>...</code> automatically provides indirection, so you can use it as is
(i.e. without embracing) inside a function:
</p>
<div class="sourceCode"><pre>grouped_mean &lt;- function(df, var, ...) {
  df %&gt;%
    group_by(...) %&gt;%
    summarise(mean = mean({{ var }}))
}
</pre></div>
<p>You can also use <code style="white-space: pre;">&#8288;:=&#8288;</code> instead of <code>=</code> to enable a glue-like syntax for
creating variables from user supplied data:
</p>
<div class="sourceCode"><pre>var_name &lt;- "l100km"
mtcars %&gt;% mutate("{var_name}" := 235 / mpg)

summarise_mean &lt;- function(df, var) {
  df %&gt;%
    summarise("mean_of_{{var}}" := mean({{ var }}))
}
mtcars %&gt;% group_by(cyl) %&gt;% summarise_mean(mpg)
</pre></div>
<p>Learn more in <a href="https://rlang.r-lib.org/reference/topic-data-mask-programming.html">https://rlang.r-lib.org/reference/topic-data-mask-programming.html</a>.
</p>

<hr>
<h2 id='tidyr_legacy'>Legacy name repair</h2><span id='topic+tidyr_legacy'></span>

<h3>Description</h3>

<p>Ensures all column names are unique using the approach found in
tidyr 0.8.3 and earlier. Only use this function if you want to preserve
the naming strategy, otherwise you're better off adopting the new
tidyverse standard with <code>name_repair = "universal"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyr_legacy(nms, prefix = "V", sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyr_legacy_+3A_prefix">prefix</code></td>
<td>
<p>prefix Prefix to use for unnamed column</p>
</td></tr>
<tr><td><code id="tidyr_legacy_+3A_sep">sep</code></td>
<td>
<p>Separator to use between name and unique suffix</p>
</td></tr>
<tr><td><code id="tidyr_legacy_+3A_nm">nm</code></td>
<td>
<p>Character vector of names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = 1:2, y = list(tibble(x = 3:5), tibble(x = 4:7)))

# Doesn't work because it would produce a data frame with two
# columns called x
## Not run: 
unnest(df, y)

## End(Not run)

# The new tidyverse standard:
unnest(df, y, names_repair = "universal")

# The old tidyr approach
unnest(df, y, names_repair = tidyr_legacy)
</code></pre>

<hr>
<h2 id='tidyr_tidy_select'>Argument type: tidy-select</h2><span id='topic+tidyr_tidy_select'></span>

<h3>Description</h3>

<p>This page describes the <code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> argument modifier which
indicates that the argument uses <strong>tidy selection</strong>, a sub-type of
tidy evaluation. If you've never heard of tidy evaluation before,
start with the practical introduction in
<a href="https://r4ds.hadley.nz/functions.html#data-frame-functions">https://r4ds.hadley.nz/functions.html#data-frame-functions</a> then
then read more about the underlying theory in
<a href="https://rlang.r-lib.org/reference/topic-data-mask.html">https://rlang.r-lib.org/reference/topic-data-mask.html</a>.
</p>


<h3>Overview of selection features</h3>

<p>tidyselect implements a DSL for selecting variables. It provides helpers
for selecting variables:
</p>

<ul>
<li> <p><code>var1:var10</code>: variables lying between <code>var1</code> on the left and <code>var10</code> on the right.
</p>
</li></ul>


<ul>
<li> <p><code><a href="tidyselect.html#topic+starts_with">starts_with(&quot;a&quot;)</a></code>: names that start with <code>"a"</code>.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">ends_with(&quot;z&quot;)</a></code>: names that end with <code>"z"</code>.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">contains(&quot;b&quot;)</a></code>: names that contain <code>"b"</code>.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">matches(&quot;x.y&quot;)</a></code>: names that match regular expression <code>x.y</code>.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">num_range(x, 1:4)</a></code>: names following the pattern, <code>x1</code>, <code>x2</code>, ..., <code>x4</code>.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+all_of">all_of(vars)</a></code>/<code><a href="tidyselect.html#topic+all_of">any_of(vars)</a></code>:
matches names stored in the character vector <code>vars</code>. <code>all_of(vars)</code> will
error if the variables aren't present; <code>any_of(var)</code> will match just the
variables that exist.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+everything">everything()</a></code>: all variables.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+everything">last_col()</a></code>: furthest column on the right.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+where">where(is.numeric)</a></code>: all variables where
<code>is.numeric()</code> returns <code>TRUE</code>.
</p>
</li></ul>

<p>As well as operators for combining those selections:
</p>

<ul>
<li> <p><code>!selection</code>: only variables that don't match <code>selection</code>.
</p>
</li>
<li> <p><code>selection1 &amp; selection2</code>: only variables included in both <code>selection1</code> and <code>selection2</code>.
</p>
</li>
<li> <p><code>selection1 | selection2</code>: all variables that match either <code>selection1</code> or <code>selection2</code>.
</p>
</li></ul>



<h3>Key techniques</h3>


<ul>
<li><p> If you want the user to supply a tidyselect specification in a
function argument, you need to tunnel the selection through the function
argument. This is done by embracing the function argument <code>{{ }}</code>,
e.g <code>unnest(df, {{ vars }})</code>.
</p>
</li>
<li><p> If you have a character vector of column names, use <code>all_of()</code>
or <code>any_of()</code>, depending on whether or not you want unknown variable
names to cause an error, e.g <code>unnest(df, all_of(vars))</code>,
<code>unnest(df, !any_of(vars))</code>.
</p>
</li>
<li><p> To suppress <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> <code>NOTE</code>s about unknown variables use <code>"var"</code>
instead of <code>var</code>:
</p>
</li></ul>

<div class="sourceCode R"><pre># has NOTE
df %&gt;% select(x, y, z)

# no NOTE
df %&gt;% select("x", "y", "z")
</pre></div>

<hr>
<h2 id='tidyr-package'>tidyr: Tidy Messy Data</h2><span id='topic+tidyr'></span><span id='topic+tidyr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Tools to help to create tidy data, where each column is a variable, each row is an observation, and each cell contains a single value. 'tidyr' contains tools for changing the shape (pivoting) and hierarchy (nesting and 'unnesting') of a dataset, turning deeply nested lists into rectangular data frames ('rectangling'), and extracting values out of string columns. It also includes tools for working with missing values (both implicit and explicit).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
</li>
<li><p> Maximilian Girlich
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kevin Ushey <a href="mailto:kevin@posit.co">kevin@posit.co</a> [contributor]
</p>
</li>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tidyr.tidyverse.org">https://tidyr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/tidyr">https://github.com/tidyverse/tidyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/tidyr/issues">https://github.com/tidyverse/tidyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='uncount'>&quot;Uncount&quot; a data frame</h2><span id='topic+uncount'></span>

<h3>Description</h3>

<p>Performs the opposite operation to <code><a href="dplyr.html#topic+count">dplyr::count()</a></code>, duplicating rows
according to a weighting variable (or expression).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncount(data, weights, ..., .remove = TRUE, .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncount_+3A_data">data</code></td>
<td>
<p>A data frame, tibble, or grouped tibble.</p>
</td></tr>
<tr><td><code id="uncount_+3A_weights">weights</code></td>
<td>
<p>A vector of weights. Evaluated in the context of <code>data</code>;
supports quasiquotation.</p>
</td></tr>
<tr><td><code id="uncount_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="uncount_+3A_.remove">.remove</code></td>
<td>
<p>If <code>TRUE</code>, and <code>weights</code> is the name of a column in <code>data</code>,
then this column is removed.</p>
</td></tr>
<tr><td><code id="uncount_+3A_.id">.id</code></td>
<td>
<p>Supply a string to create a new variable which gives a unique
identifier for each created row.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = c("a", "b"), n = c(1, 2))
uncount(df, n)
uncount(df, n, .id = "id")

# You can also use constants
uncount(df, 2)

# Or expressions
uncount(df, 2 / n)
</code></pre>

<hr>
<h2 id='unite'>Unite multiple columns into one by pasting strings together</h2><span id='topic+unite'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="unite_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unite</p>
</td></tr>
<tr><td><code id="unite_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be removed prior to uniting
each value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate()</a></code>, the complement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- expand_grid(x = c("a", NA), y = c("b", NA))
df

df %&gt;% unite("z", x:y, remove = FALSE)
# To remove missing values:
df %&gt;% unite("z", x:y, na.rm = TRUE, remove = FALSE)

# Separate is almost the complement of unite
df %&gt;%
  unite("xy", x:y) %&gt;%
  separate(xy, c("x", "y"))
# (but note `x` and `y` contain now "NA" not NA)
</code></pre>

<hr>
<h2 id='unnest'>Unnest a list-column of data frames into rows and columns</h2><span id='topic+unnest'></span>

<h3>Description</h3>

<p>Unnest expands a list-column containing data frames into rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest(
  data,
  cols,
  ...,
  keep_empty = FALSE,
  ptype = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  .drop = deprecated(),
  .id = deprecated(),
  .sep = deprecated(),
  .preserve = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unnest_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-columns to unnest.
</p>
<p>When selecting multiple columns, values from the same row will be recycled
to their common size.</p>
</td></tr>
<tr><td><code id="unnest_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
previously you could write <code>df %&gt;% unnest(x, y, z)</code>.
Convert to <code>df %&gt;% unnest(c(x, y, z))</code>. If you previously created a new
variable in <code>unnest()</code> you'll now need to do it explicitly with <code>mutate()</code>.
Convert <code>df %&gt;% unnest(y = fun(x, y, z))</code>
to <code>df %&gt;% mutate(y = fun(x, y, z)) %&gt;% unnest(y)</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_keep_empty">keep_empty</code></td>
<td>
<p>By default, you get one row of output for each element
of the list that you are unchopping/unnesting. This means that if there's a
size-0 element (like <code>NULL</code> or an empty data frame or vector), then that
entire row will be dropped from the output. If you want to preserve all
rows, use <code>keep_empty = TRUE</code> to replace size-0 elements with a single row
of missing values.</p>
</td></tr>
<tr><td><code id="unnest_+3A_ptype">ptype</code></td>
<td>
<p>Optionally, a named list of column name-prototype pairs to
coerce <code>cols</code> to, overriding the default that will be guessed from
combining the individual values. Alternatively, a single empty ptype
can be supplied, which will be applied to all <code>cols</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the outer names will come from the
inner names. If a string, the outer names will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="unnest_+3A_.drop">.drop</code>, <code id="unnest_+3A_.preserve">.preserve</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
all list-columns are now preserved; If there are any that you
don't want in the output use <code>select()</code> to remove them prior to
unnesting.</p>
</td></tr>
<tr><td><code id="unnest_+3A_.id">.id</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
convert <code>df %&gt;% unnest(x, .id = "id")</code> to <code style="white-space: pre;">&#8288;df %&gt;% mutate(id = names(x)) %&gt;% unnest(x))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="unnest_+3A_.sep">.sep</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
use <code>names_sep</code> instead.</p>
</td></tr>
</table>


<h3>New syntax</h3>

<p>tidyr 1.0.0 introduced a new syntax for <code>nest()</code> and <code>unnest()</code> that's
designed to be more similar to other functions. Converting to the new syntax
should be straightforward (guided by the message you'll receive) but if
you just need to run an old analysis, you can easily revert to the previous
behaviour using <code><a href="tidyr.html#topic+nest_legacy">nest_legacy()</a></code> and <code><a href="tidyr.html#topic+unnest_legacy">unnest_legacy()</a></code> as follows:
</p>
<div class="sourceCode"><pre>library(tidyr)
nest &lt;- nest_legacy
unnest &lt;- unnest_legacy
</pre></div>


<h3>See Also</h3>

<p>Other rectangling: 
<code><a href="tidyr.html#topic+hoist">hoist</a>()</code>,
<code><a href="tidyr.html#topic+unnest_longer">unnest_longer</a>()</code>,
<code><a href="tidyr.html#topic+unnest_wider">unnest_wider</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># unnest() is designed to work with lists of data frames
df &lt;- tibble(
  x = 1:3,
  y = list(
    NULL,
    tibble(a = 1, b = 2),
    tibble(a = 1:3, b = 3:1, c = 4)
  )
)
# unnest() recycles input rows for each row of the list-column
# and adds a column for each column
df %&gt;% unnest(y)

# input rows with 0 rows in the list-column will usually disappear,
# but you can keep them (generating NAs) with keep_empty = TRUE:
df %&gt;% unnest(y, keep_empty = TRUE)

# Multiple columns ----------------------------------------------------------
# You can unnest multiple columns simultaneously
df &lt;- tibble(
  x = 1:2,
  y = list(
    tibble(a = 1, b = 2),
    tibble(a = 3:4, b = 5:6)
  ),
  z = list(
    tibble(c = 1, d = 2),
    tibble(c = 3:4, d = 5:6)
  )
)
df %&gt;% unnest(c(y, z))

# Compare with unnesting one column at a time, which generates
# the Cartesian product
df %&gt;%
  unnest(y) %&gt;%
  unnest(z)
</code></pre>

<hr>
<h2 id='unnest_auto'>Automatically call <code>unnest_wider()</code> or <code>unnest_longer()</code></h2><span id='topic+unnest_auto'></span>

<h3>Description</h3>

<p><code>unnest_auto()</code> picks between <code>unnest_wider()</code> or <code>unnest_longer()</code>
by inspecting the inner names of the list-col:
</p>

<ul>
<li><p> If all elements are unnamed, it uses
<code>unnest_longer(indices_include = FALSE)</code>.
</p>
</li>
<li><p> If all elements are named, and there's at least one name in
common across all components, it uses <code>unnest_wider()</code>.
</p>
</li>
<li><p> Otherwise, it falls back to <code>unnest_longer(indices_include = TRUE)</code>.
</p>
</li></ul>

<p>It's handy for very rapid interactive exploration but I don't recommend
using it in scripts, because it will succeed even if the underlying data
radically changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_auto(data, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_auto_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unnest_auto_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-column to unnest.</p>
</td></tr>
</table>

<hr>
<h2 id='unnest_longer'>Unnest a list-column into rows</h2><span id='topic+unnest_longer'></span>

<h3>Description</h3>

<p><code>unnest_longer()</code> turns each element of a list-column into a row. It
is most naturally suited to list-columns where the elements are unnamed
and the length of each element varies from row to row.
</p>
<p><code>unnest_longer()</code> generally preserves the number of columns of <code>x</code> while
modifying the number of rows.
</p>
<p>Learn more in <code>vignette("rectangle")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_longer(
  data,
  col,
  values_to = NULL,
  indices_to = NULL,
  indices_include = NULL,
  keep_empty = FALSE,
  names_repair = "check_unique",
  simplify = TRUE,
  ptype = NULL,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_longer_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-column(s) to unnest.
</p>
<p>When selecting multiple columns, values from the same row will be recycled
to their common size.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_values_to">values_to</code></td>
<td>
<p>A string giving the column name (or names) to store the
unnested values in. If multiple columns are specified in <code>col</code>, this can
also be a glue string containing <code>"{col}"</code> to provide a template for the
column names. The default, <code>NULL</code>, gives the output columns the same names
as the input columns.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_indices_to">indices_to</code></td>
<td>
<p>A string giving the column name (or names) to store the
inner names or positions (if not named) of the values. If multiple columns
are specified in <code>col</code>, this can also be a glue string containing <code>"{col}"</code>
to provide a template for the column names. The default, <code>NULL</code>, gives the
output columns the same names as <code>values_to</code>, but suffixed with <code>"_id"</code>.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_indices_include">indices_include</code></td>
<td>
<p>A single logical value specifying whether or not to
add an index column. If any value has inner names, the index column will be
a character vector of those names, otherwise it will be an integer vector
of positions. If <code>NULL</code>, defaults to <code>TRUE</code> if any value has inner names
or if <code>indices_to</code> is provided.
</p>
<p>If <code>indices_to</code> is provided, then <code>indices_include</code> can't be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_keep_empty">keep_empty</code></td>
<td>
<p>By default, you get one row of output for each element
of the list that you are unchopping/unnesting. This means that if there's a
size-0 element (like <code>NULL</code> or an empty data frame or vector), then that
entire row will be dropped from the output. If you want to preserve all
rows, use <code>keep_empty = TRUE</code> to replace size-0 elements with a single row
of missing values.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, will attempt to simplify lists of
length-1 vectors to an atomic vector. Can also be a named list containing
<code>TRUE</code> or <code>FALSE</code> declaring whether or not to attempt to simplify a
particular column. If a named list is provided, the default for any
unspecified columns is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_ptype">ptype</code></td>
<td>
<p>Optionally, a named list of prototypes declaring the
desired output type of each component. Alternatively, a single empty
prototype can be supplied, which will be applied to all components. Use
this argument if you want to check that each element has the type you
expect when simplifying.
</p>
<p>If a <code>ptype</code> has been specified, but <code>simplify = FALSE</code> or simplification
isn't possible, then a <a href="vctrs.html#topic+list_of">list-of</a> column will be returned
and each element will have type <code>ptype</code>.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_transform">transform</code></td>
<td>
<p>Optionally, a named list of transformation
functions applied to each component. Alternatively, a single function can
be supplied, which will be applied to all components. Use this argument if
you want to transform or parse individual elements as they are extracted.
</p>
<p>When both <code>ptype</code> and <code>transform</code> are supplied, the <code>transform</code> is applied
before the <code>ptype</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other rectangling: 
<code><a href="tidyr.html#topic+hoist">hoist</a>()</code>,
<code><a href="tidyr.html#topic+unnest_wider">unnest_wider</a>()</code>,
<code><a href="tidyr.html#topic+unnest">unnest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `unnest_longer()` is useful when each component of the list should
# form a row
df &lt;- tibble(
  x = 1:4,
  y = list(NULL, 1:3, 4:5, integer())
)
df %&gt;% unnest_longer(y)

# Note that empty values like `NULL` and `integer()` are dropped by
# default. If you'd like to keep them, set `keep_empty = TRUE`.
df %&gt;% unnest_longer(y, keep_empty = TRUE)

# If the inner vectors are named, the names are copied to an `_id` column
df &lt;- tibble(
  x = 1:2,
  y = list(c(a = 1, b = 2), c(a = 10, b = 11, c = 12))
)
df %&gt;% unnest_longer(y)

# Multiple columns ----------------------------------------------------------
# If columns are aligned, you can unnest simultaneously
df &lt;- tibble(
  x = 1:2,
  y = list(1:2, 3:4),
  z = list(5:6, 7:8)
)
df %&gt;%
  unnest_longer(c(y, z))

# This is important because sequential unnesting would generate the
# Cartesian product of the rows
df %&gt;%
  unnest_longer(y) %&gt;%
  unnest_longer(z)
</code></pre>

<hr>
<h2 id='unnest_wider'>Unnest a list-column into columns</h2><span id='topic+unnest_wider'></span>

<h3>Description</h3>

<p><code>unnest_wider()</code> turns each element of a list-column into a column. It
is most naturally suited to list-columns where every element is named,
and the names are consistent from row-to-row.
<code>unnest_wider()</code> preserves the rows of <code>x</code> while modifying the columns.
</p>
<p>Learn more in <code>vignette("rectangle")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_wider(
  data,
  col,
  names_sep = NULL,
  simplify = TRUE,
  strict = FALSE,
  names_repair = "check_unique",
  ptype = NULL,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_wider_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_col">col</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-column(s) to unnest.
</p>
<p>When selecting multiple columns, values from the same row will be recycled
to their common size.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left
as is. If a string, the outer and inner names will be pasted together using
<code>names_sep</code> as a separator.
</p>
<p>If any values being unnested are unnamed, then <code>names_sep</code> must be
supplied, otherwise an error is thrown. When <code>names_sep</code> is supplied,
names are automatically generated for unnamed values as an increasing
sequence of integers.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, will attempt to simplify lists of
length-1 vectors to an atomic vector. Can also be a named list containing
<code>TRUE</code> or <code>FALSE</code> declaring whether or not to attempt to simplify a
particular column. If a named list is provided, the default for any
unspecified columns is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_strict">strict</code></td>
<td>
<p>A single logical specifying whether or not to apply strict
vctrs typing rules. If <code>FALSE</code>, typed empty values (like <code>list()</code> or
<code>integer()</code>) nested within list-columns will be treated like <code>NULL</code> and
will not contribute to the type of the unnested column. This is useful
when working with JSON, where empty values tend to lose their type
information and show up as <code>list()</code>.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_ptype">ptype</code></td>
<td>
<p>Optionally, a named list of prototypes declaring the
desired output type of each component. Alternatively, a single empty
prototype can be supplied, which will be applied to all components. Use
this argument if you want to check that each element has the type you
expect when simplifying.
</p>
<p>If a <code>ptype</code> has been specified, but <code>simplify = FALSE</code> or simplification
isn't possible, then a <a href="vctrs.html#topic+list_of">list-of</a> column will be returned
and each element will have type <code>ptype</code>.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_transform">transform</code></td>
<td>
<p>Optionally, a named list of transformation
functions applied to each component. Alternatively, a single function can
be supplied, which will be applied to all components. Use this argument if
you want to transform or parse individual elements as they are extracted.
</p>
<p>When both <code>ptype</code> and <code>transform</code> are supplied, the <code>transform</code> is applied
before the <code>ptype</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other rectangling: 
<code><a href="tidyr.html#topic+hoist">hoist</a>()</code>,
<code><a href="tidyr.html#topic+unnest_longer">unnest_longer</a>()</code>,
<code><a href="tidyr.html#topic+unnest">unnest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  character = c("Toothless", "Dory"),
  metadata = list(
    list(
      species = "dragon",
      color = "black",
      films = c(
        "How to Train Your Dragon",
        "How to Train Your Dragon 2",
        "How to Train Your Dragon: The Hidden World"
      )
    ),
    list(
      species = "blue tang",
      color = "blue",
      films = c("Finding Nemo", "Finding Dory")
    )
  )
)
df

# Turn all components of metadata into columns
df %&gt;% unnest_wider(metadata)

# Choose not to simplify list-cols of length-1 elements
df %&gt;% unnest_wider(metadata, simplify = FALSE)
df %&gt;% unnest_wider(metadata, simplify = list(color = FALSE))

# You can also widen unnamed list-cols:
df &lt;- tibble(
  x = 1:3,
  y = list(NULL, 1:3, 4:5)
)
# but you must supply `names_sep` to do so, which generates automatic names:
df %&gt;% unnest_wider(y, names_sep = "_")

# 0-length elements ---------------------------------------------------------
# The defaults of `unnest_wider()` treat empty types (like `list()`) as `NULL`.
json &lt;- list(
  list(x = 1:2, y = 1:2),
  list(x = list(), y = 3:4),
  list(x = 3L, y = list())
)

df &lt;- tibble(json = json)
df %&gt;%
  unnest_wider(json)

# To instead enforce strict vctrs typing rules, use `strict`
df %&gt;%
  unnest_wider(json, strict = TRUE)
</code></pre>

<hr>
<h2 id='us_rent_income'>US rent and income data</h2><span id='topic+us_rent_income'></span>

<h3>Description</h3>

<p>Captured from the 2017 American Community Survey using the tidycensus
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>us_rent_income
</code></pre>


<h3>Format</h3>

<p>A dataset with variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>FIP state identifier</p>
</dd>
<dt>NAME</dt><dd><p>Name of state</p>
</dd>
<dt>variable</dt><dd><p>Variable name: income = median yearly income,
rent = median monthly rent</p>
</dd>
<dt>estimate</dt><dd><p>Estimated value</p>
</dd>
<dt>moe</dt><dd><p>90% margin of error</p>
</dd>
</dl>


<hr>
<h2 id='who'>World Health Organization TB data</h2><span id='topic+who'></span><span id='topic+who2'></span><span id='topic+population'></span>

<h3>Description</h3>

<p>A subset of data from the World Health Organization Global Tuberculosis
Report, and accompanying global populations. <code>who</code> uses the original
codes from the World Health Organization. The column names for columns
5 through 60 are made by combining <code>new_</code> with:
</p>

<ul>
<li><p> the method of diagnosis (<code>rel</code> = relapse, <code>sn</code> = negative pulmonary
smear, <code>sp</code> = positive pulmonary smear, <code>ep</code> = extrapulmonary),
</p>
</li>
<li><p> gender (<code>f</code> = female, <code>m</code> = male), and
</p>
</li>
<li><p> age group (<code>014</code> = 0-14 yrs of age, <code>1524</code> = 15-24, <code>2534</code> = 25-34,
<code>3544</code> = 35-44 years of age, <code>4554</code> = 45-54, <code>5564</code> = 55-64,
<code>65</code> = 65 years or older).
</p>
</li></ul>

<p><code>who2</code> is a lightly modified version that makes teaching the basics
easier by tweaking the variables to be slightly more consistent and
dropping <code>iso2</code> and <code>iso3</code>. <code>newrel</code> is replaced by <code>new_rel</code>, and a
<code style="white-space: pre;">&#8288;_&#8288;</code> is added after the gender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>who

who2

population
</code></pre>


<h3>Format</h3>



<h4><code>who</code></h4>

<p>A data frame with 7,240 rows and 60 columns:
</p>

<dl>
<dt>country</dt><dd><p>Country name</p>
</dd>
<dt>iso2, iso3</dt><dd><p>2 &amp; 3 letter ISO country codes</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>new_sp_m014 - new_rel_f65</dt><dd><p>Counts of new TB cases recorded by group.
Column names encode three variables that describe the group.</p>
</dd>
</dl>




<h4><code>who2</code></h4>

<p>A data frame with 7,240 rows and 58 columns.
</p>



<h4><code>population</code></h4>

<p>A data frame with 4,060 rows and three columns:
</p>

<dl>
<dt>country</dt><dd><p>Country name</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>population</dt><dd><p>Population</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://www.who.int/teams/global-tuberculosis-programme/data">https://www.who.int/teams/global-tuberculosis-programme/data</a>
</p>

<hr>
<h2 id='world_bank_pop'>Population data from the world bank</h2><span id='topic+world_bank_pop'></span>

<h3>Description</h3>

<p>Data about population from the World Bank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>world_bank_pop
</code></pre>


<h3>Format</h3>

<p>A dataset with variables:
</p>

<dl>
<dt>country</dt><dd><p>Three letter country code</p>
</dd>
<dt>indicator</dt><dd><p>Indicator name: <code>SP.POP.GROW</code> = population growth,
<code>SP.POP.TOTL</code> = total population, <code>SP.URB.GROW</code> = urban population
growth, <code>SP.URB.TOTL</code> = total urban population</p>
</dd>
<dt>2000-2018</dt><dd><p>Value for each year</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dataset from the World Bank data bank: <a href="https://data.worldbank.org">https://data.worldbank.org</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
