<!DOCTYPE html><html><head><title>Help for package xml2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xml2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_list'><p>Coerce xml nodes to a list.</p></a></li>
<li><a href='#as_xml_document'><p>Coerce a R list to xml nodes.</p></a></li>
<li><a href='#download_xml'><p>Download a HTML or XML file</p></a></li>
<li><a href='#read_xml'><p>Read HTML or XML.</p></a></li>
<li><a href='#url_absolute'><p>Convert between relative and absolute urls.</p></a></li>
<li><a href='#url_escape'><p>Escape and unescape urls.</p></a></li>
<li><a href='#url_parse'><p>Parse a url into its component pieces.</p></a></li>
<li><a href='#write_xml'><p>Write XML or HTML to disk.</p></a></li>
<li><a href='#xml_attr'><p>Retrieve an attribute.</p></a></li>
<li><a href='#xml_cdata'><p>Construct a cdata node</p></a></li>
<li><a href='#xml_children'><p>Navigate around the family tree.</p></a></li>
<li><a href='#xml_comment'><p>Construct a comment node</p></a></li>
<li><a href='#xml_document-class'><p>Register S4 classes</p></a></li>
<li><a href='#xml_dtd'><p>Construct a document type definition</p></a></li>
<li><a href='#xml_find_all'><p>Find nodes that match an xpath expression.</p></a></li>
<li><a href='#xml_missing'><p>Construct an missing xml object</p></a></li>
<li><a href='#xml_name'><p>The (tag) name of an xml element.</p></a></li>
<li><a href='#xml_new_document'><p>Create a new document, possibly with a root node</p></a></li>
<li><a href='#xml_ns'><p>XML namespaces.</p></a></li>
<li><a href='#xml_ns_strip'><p>Strip the default namespaces from a document</p></a></li>
<li><a href='#xml_path'><p>Retrieve the xpath to a node</p></a></li>
<li><a href='#xml_replace'><p>Modify a tree by inserting, replacing or removing nodes</p></a></li>
<li><a href='#xml_serialize'><p>Serializing XML objects to connections.</p></a></li>
<li><a href='#xml_set_namespace'><p>Set the node's namespace</p></a></li>
<li><a href='#xml_structure'><p>Show the structure of an html/xml document.</p></a></li>
<li><a href='#xml_text'><p>Extract or modify the text</p></a></li>
<li><a href='#xml_type'><p>Determine the type of a node.</p></a></li>
<li><a href='#xml_url'><p>The URL of an XML document</p></a></li>
<li><a href='#xml_validate'><p>Validate XML schema</p></a></li>
<li><a href='#xml2_example'><p>Get path to a xml2 example</p></a></li>
<li><a href='#xml2-package'><p>xml2: Parse XML</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Parse XML</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Work with XML files using a simple, consistent interface.
    Built on top of the 'libxml2' C library.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://xml2.r-lib.org/">https://xml2.r-lib.org/</a>, <a href="https://github.com/r-lib/xml2">https://github.com/r-lib/xml2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/xml2/issues">https://github.com/r-lib/xml2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, methods, rlang (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, curl, httr, knitr, magrittr, mockery, rmarkdown,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libxml2: libxml2-dev (deb), libxml2-devel (rpm)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'S4.R' 'as_list.R' 'xml_parse.R' 'as_xml_document.R'
'classes.R' 'format.R' 'import-standalone-obj-type.R'
'import-standalone-purrr.R' 'import-standalone-types-check.R'
'init.R' 'nodeset_apply.R' 'paths.R' 'utils.R' 'xml2-package.R'
'xml_attr.R' 'xml_children.R' 'xml_document.R' 'xml_find.R'
'xml_missing.R' 'xml_modify.R' 'xml_name.R' 'xml_namespaces.R'
'xml_node.R' 'xml_nodeset.R' 'xml_path.R' 'xml_schema.R'
'xml_serialize.R' 'xml_structure.R' 'xml_text.R' 'xml_type.R'
'xml_url.R' 'xml_write.R' 'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 14:50:27 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Jim Hester [aut],
  Jeroen Ooms [aut],
  Posit Software, PBC [cph, fnd],
  R Foundation [ctb] (Copy of R-project homepage cached as example)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 16:30:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:33:58 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='as_list'>Coerce xml nodes to a list.</h2><span id='topic+as_list'></span>

<h3>Description</h3>

<p>This turns an XML document (or node or nodeset) into the equivalent R
list. Note that this is <code>as_list()</code>, not <code>as.list()</code>:
<code>lapply()</code> automatically calls <code>as.list()</code> on its inputs, so
we can't override the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_list(x, ns = character(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_list_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="as_list_+3A_ns">ns</code></td>
<td>
<p>Optionally, a named vector giving prefix-url pairs, as produced
by <code><a href="xml2.html#topic+xml_ns">xml_ns()</a></code>. If provided, all names will be explicitly
qualified with the ns prefix, i.e. if the element <code>bar</code> is defined
in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And
similarly for attributes). Default namespaces must be given an explicit
name. The ns is ignored when using <code><a href="xml2.html#topic+xml_name+3C-">xml_name&lt;-()</a></code> and
<code><a href="xml2.html#topic+xml_set_name">xml_set_name()</a></code>.</p>
</td></tr>
<tr><td><code id="as_list_+3A_...">...</code></td>
<td>
<p>Needed for compatibility with generic. Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_list</code> currently only handles the four most common types of
children that an element might have:
</p>

<ul>
<li><p> Other elements, converted to lists.
</p>
</li>
<li><p> Attributes, stored as R attributes. Attributes that have special meanings in R
(<code><a href="base.html#topic+class">class()</a></code>, <code><a href="base.html#topic+comment">comment()</a></code>, <code><a href="base.html#topic+dim">dim()</a></code>,
<code><a href="base.html#topic+dimnames">dimnames()</a></code>, <code><a href="base.html#topic+names">names()</a></code>, <code><a href="base.html#topic+row.names">row.names()</a></code> and
<code><a href="stats.html#topic+tsp">tsp()</a></code>) are escaped with '.'
</p>
</li>
<li><p> Text, stored as a character vector.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>as_list(read_xml("&lt;foo&gt; a &lt;b /&gt;&lt;c&gt;&lt;![CDATA[&lt;d&gt;&lt;/d&gt;]]&gt;&lt;/c&gt;&lt;/foo&gt;"))
as_list(read_xml("&lt;foo&gt; &lt;bar&gt;&lt;baz /&gt;&lt;/bar&gt; &lt;/foo&gt;"))
as_list(read_xml("&lt;foo id = 'a'&gt;&lt;/foo&gt;"))
as_list(read_xml("&lt;foo&gt;&lt;bar id='a'/&gt;&lt;bar id='b'/&gt;&lt;/foo&gt;"))
</code></pre>

<hr>
<h2 id='as_xml_document'>Coerce a R list to xml nodes.</h2><span id='topic+as_xml_document'></span>

<h3>Description</h3>

<p>This turns an R list into the equivalent XML document. Not all R lists will
produce valid XML, in particular there can only be one root node and all
child nodes need to be named (or empty) lists. R attributes become XML
attributes and R names become XML node names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_xml_document(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_xml_document_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="as_xml_document_+3A_...">...</code></td>
<td>
<p>Needed for compatibility with generic. Unused.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>as_xml_document(list(x = list()))

# Nesting multiple nodes
as_xml_document(list(foo = list(bar = list(baz = list()))))

# attributes are stored as R attributes
as_xml_document(list(foo = structure(list(), id = "a")))
as_xml_document(list(foo = list(
  bar = structure(list(), id = "a"),
  bar = structure(list(), id = "b")
)))
</code></pre>

<hr>
<h2 id='download_xml'>Download a HTML or XML file</h2><span id='topic+download_xml'></span><span id='topic+download_html'></span>

<h3>Description</h3>

<p>Libcurl implementation of <code>C_download</code> (the &quot;internal&quot; download method)
with added support for https, ftps, gzip, etc. Default behavior is identical
to <code><a href="utils.html#topic+download.file">download.file()</a></code>, but request can be fully configured by passing
a custom <code><a href="curl.html#topic+handle">curl::handle()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_xml(
  url,
  file = basename(url),
  quiet = TRUE,
  mode = "wb",
  handle = curl::new_handle()
)

download_html(
  url,
  file = basename(url),
  quiet = TRUE,
  mode = "wb",
  handle = curl::new_handle()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_xml_+3A_url">url</code></td>
<td>
<p>A character string naming the URL of a resource to be downloaded.</p>
</td></tr>
<tr><td><code id="download_xml_+3A_file">file</code></td>
<td>
<p>A character string with the name where the downloaded file is
saved.</p>
</td></tr>
<tr><td><code id="download_xml_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress status messages (if any), and the
progress bar.</p>
</td></tr>
<tr><td><code id="download_xml_+3A_mode">mode</code></td>
<td>
<p>A character string specifying the mode with which to write the file.
Useful values are <code>"w"</code>, <code>"wb"</code> (binary), <code>"a"</code> (append)
and <code>"ab"</code>.</p>
</td></tr>
<tr><td><code id="download_xml_+3A_handle">handle</code></td>
<td>
<p>a curl handle object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main difference between <code>curl_download</code> and <code>curl_fetch_disk</code>
is that <code>curl_download</code> checks the http status code before starting the
download, and raises an error when status is non-successful. The behavior of
<code>curl_fetch_disk</code> on the other hand is to proceed as normal and write
the error page to disk in case of a non success response.
</p>
<p>For a more advanced download interface which supports concurrent requests and
resuming large files, have a look at the <a href="curl.html#topic+multi_download">multi_download</a> function.
</p>


<h3>Value</h3>

<p>Path of downloaded file (invisibly).
</p>


<h3>See Also</h3>

<p><a href="curl.html#topic+curl_download">curl_download</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
download_html("http://tidyverse.org/index.html")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_xml'>Read HTML or XML.</h2><span id='topic+read_xml'></span><span id='topic+read_html'></span><span id='topic+read_xml.character'></span><span id='topic+read_xml.raw'></span><span id='topic+read_xml.connection'></span>

<h3>Description</h3>

<p>Read HTML or XML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xml(x, encoding = "", ..., as_html = FALSE, options = "NOBLANKS")

read_html(x, encoding = "", ..., options = c("RECOVER", "NOERROR", "NOBLANKS"))

## S3 method for class 'character'
read_xml(x, encoding = "", ..., as_html = FALSE, options = "NOBLANKS")

## S3 method for class 'raw'
read_xml(
  x,
  encoding = "",
  base_url = "",
  ...,
  as_html = FALSE,
  options = "NOBLANKS"
)

## S3 method for class 'connection'
read_xml(
  x,
  encoding = "",
  n = 64 * 1024,
  verbose = FALSE,
  ...,
  base_url = "",
  as_html = FALSE,
  options = "NOBLANKS"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_xml_+3A_x">x</code></td>
<td>
<p>A string, a connection, or a raw vector.
</p>
<p>A string can be either a path, a url or literal xml. Urls will
be converted into connections either using <code>base::url</code> or, if
installed, <code>curl::curl</code>. Local paths ending in <code>.gz</code>,
<code>.bz2</code>, <code>.xz</code>, <code>.zip</code> will be automatically uncompressed.
</p>
<p>If a connection, the complete connection is read into a raw vector before
being parsed.</p>
</td></tr>
<tr><td><code id="read_xml_+3A_encoding">encoding</code></td>
<td>
<p>Specify a default encoding for the document. Unless
otherwise specified XML documents are assumed to be in UTF-8 or
UTF-16. If the document is not UTF-8/16, and lacks an explicit
encoding directive, this allows you to supply a default.</p>
</td></tr>
<tr><td><code id="read_xml_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="read_xml_+3A_as_html">as_html</code></td>
<td>
<p>Optionally parse an xml file as if it's html.</p>
</td></tr>
<tr><td><code id="read_xml_+3A_options">options</code></td>
<td>
<p>Set parsing options for the libxml2 parser. Zero or more of
</p>
<dl>
<dt>RECOVER</dt><dd><p>recover on errors</p>
</dd><dt>NOENT</dt><dd><p>substitute entities</p>
</dd><dt>DTDLOAD</dt><dd><p>load the external subset</p>
</dd><dt>DTDATTR</dt><dd><p>default DTD attributes</p>
</dd><dt>DTDVALID</dt><dd><p>validate with the DTD</p>
</dd><dt>NOERROR</dt><dd><p>suppress error reports</p>
</dd><dt>NOWARNING</dt><dd><p>suppress warning reports</p>
</dd><dt>PEDANTIC</dt><dd><p>pedantic error reporting</p>
</dd><dt>NOBLANKS</dt><dd><p>remove blank nodes</p>
</dd><dt>SAX1</dt><dd><p>use the SAX1 interface internally</p>
</dd><dt>XINCLUDE</dt><dd><p>Implement XInclude substitition</p>
</dd><dt>NONET</dt><dd><p>Forbid network access</p>
</dd><dt>NODICT</dt><dd><p>Do not reuse the context dictionary</p>
</dd><dt>NSCLEAN</dt><dd><p>remove redundant namespaces declarations</p>
</dd><dt>NOCDATA</dt><dd><p>merge CDATA as text nodes</p>
</dd><dt>NOXINCNODE</dt><dd><p>do not generate XINCLUDE START/END nodes</p>
</dd><dt>COMPACT</dt><dd><p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p>
</dd><dt>OLD10</dt><dd><p>parse using XML-1.0 before update 5</p>
</dd><dt>NOBASEFIX</dt><dd><p>do not fixup XINCLUDE xml:base uris</p>
</dd><dt>HUGE</dt><dd><p>relax any hardcoded limit from the parser</p>
</dd><dt>OLDSAX</dt><dd><p>parse using SAX2 interface before 2.7.0</p>
</dd><dt>IGNORE_ENC</dt><dd><p>ignore internal document encoding hint</p>
</dd><dt>BIG_LINES</dt><dd><p>Store big lines numbers in text PSVI field</p>
</dd></dl>
</td></tr>
<tr><td><code id="read_xml_+3A_base_url">base_url</code></td>
<td>
<p>When loading from a connection, raw vector or literal
html/xml, this allows you to specify a base url for the document. Base
urls are used to turn relative urls into absolute urls.</p>
</td></tr>
<tr><td><code id="read_xml_+3A_n">n</code></td>
<td>
<p>If <code>file</code> is a connection, the number of bytes to read per
iteration. Defaults to 64kb.</p>
</td></tr>
<tr><td><code id="read_xml_+3A_verbose">verbose</code></td>
<td>
<p>When reading from a slow connection, this prints some
output on every iteration so you know its working.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An XML document. HTML is normalised to valid XML - this may not
be exactly the same transformation performed by the browser, but it's
a reasonable approximation.
</p>


<h3>Setting the &quot;user agent&quot; header</h3>

<p>When performing web scraping tasks it is both good practice &mdash; and often required &mdash;
to set the <a href="https://en.wikipedia.org/wiki/User_agent">user agent</a> request header
to a specific value. Sometimes this value is assigned to emulate a browser in order
to have content render in a certain way (e.g. <code style="white-space: pre;">&#8288;Mozilla/5.0 (Windows NT 5.1; rv:52.0) Gecko/20100101 Firefox/52.0&#8288;</code> to emulate more recent Windows browsers). Most often,
this value should be set to provide the web resource owner information on who you are
and the intent of your actions like this Google scraping bot user agent identifier:
<code style="white-space: pre;">&#8288;Googlebot/2.1 (+http://www.google.com/bot.html)&#8288;</code>.
</p>
<p>You can set the HTTP user agent for URL-based requests using <code><a href="httr.html#topic+set_config">httr::set_config()</a></code> and <code><a href="httr.html#topic+user_agent">httr::user_agent()</a></code>:
</p>
<p><code>httr::set_config(httr::user_agent("me@example.com; +https://example.com/info.html"))</code>
</p>
<p><code><a href="httr.html#topic+set_config">httr::set_config()</a></code> changes the configuration globally,
<code><a href="httr.html#topic+with_config">httr::with_config()</a></code> can be used to change configuration temporarily.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Literal xml/html is useful for small examples
read_xml("&lt;foo&gt;&lt;bar /&gt;&lt;/foo&gt;")
read_html("&lt;html&gt;&lt;title&gt;Hi&lt;title&gt;&lt;/html&gt;")
read_html("&lt;html&gt;&lt;title&gt;Hi")

# From a local path
read_html(system.file("extdata", "r-project.html", package = "xml2"))

## Not run: 
# From a url
cd &lt;- read_xml(xml2_example("cd_catalog.xml"))
me &lt;- read_html("http://had.co.nz")

## End(Not run)
</code></pre>

<hr>
<h2 id='url_absolute'>Convert between relative and absolute urls.</h2><span id='topic+url_absolute'></span><span id='topic+url_relative'></span>

<h3>Description</h3>

<p>Convert between relative and absolute urls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_absolute(x, base)

url_relative(x, base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_absolute_+3A_x">x</code></td>
<td>
<p>A character vector of urls relative to that base</p>
</td></tr>
<tr><td><code id="url_absolute_+3A_base">base</code></td>
<td>
<p>A string giving a base url.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of urls
</p>


<h3>See Also</h3>

<p><code><a href="xml2.html#topic+xml_url">xml_url</a></code> to retrieve the URL associated with a document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url_absolute(c(".", "..", "/", "/x"), "http://hadley.nz/a/b/c/d")

url_relative("http://hadley.nz/a/c", "http://hadley.nz")
url_relative("http://hadley.nz/a/c", "http://hadley.nz/")
url_relative("http://hadley.nz/a/c", "http://hadley.nz/a/b")
url_relative("http://hadley.nz/a/c", "http://hadley.nz/a/b/")
</code></pre>

<hr>
<h2 id='url_escape'>Escape and unescape urls.</h2><span id='topic+url_escape'></span><span id='topic+url_unescape'></span>

<h3>Description</h3>

<p>Escape and unescape urls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_escape(x, reserved = "")

url_unescape(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_escape_+3A_x">x</code></td>
<td>
<p>A character vector of urls.</p>
</td></tr>
<tr><td><code id="url_escape_+3A_reserved">reserved</code></td>
<td>
<p>A string containing additional characters to avoid escaping.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>url_escape("a b c")
url_escape("a b c", "")

url_unescape("a%20b%2fc")
url_unescape("%C2%B5")
</code></pre>

<hr>
<h2 id='url_parse'>Parse a url into its component pieces.</h2><span id='topic+url_parse'></span>

<h3>Description</h3>

<p>Parse a url into its component pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_parse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_parse_+3A_x">x</code></td>
<td>
<p>A character vector of urls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with one row for each element of <code>x</code> and
columns: scheme, server, port, user, path, query, fragment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url_parse("http://had.co.nz/")
url_parse("http://had.co.nz:1234/")
url_parse("http://had.co.nz:1234/?a=1&amp;b=2")
url_parse("http://had.co.nz:1234/?a=1&amp;b=2#def")
</code></pre>

<hr>
<h2 id='write_xml'>Write XML or HTML to disk.</h2><span id='topic+write_xml'></span><span id='topic+write_xml.xml_document'></span><span id='topic+write_html'></span><span id='topic+write_html.xml_document'></span>

<h3>Description</h3>

<p>This writes out both XML and normalised HTML. The default behavior will
output the same format which was read. If you want to force output pass
<code>option = "as_xml"</code> or <code>option = "as_html"</code> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_xml(x, file, ...)

## S3 method for class 'xml_document'
write_xml(x, file, ..., options = "format", encoding = "UTF-8")

write_html(x, file, ...)

## S3 method for class 'xml_document'
write_html(x, file, ..., options = "format", encoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_xml_+3A_x">x</code></td>
<td>
<p>A document or node to write to disk. It's not possible to
save nodesets containing more than one node.</p>
</td></tr>
<tr><td><code id="write_xml_+3A_file">file</code></td>
<td>
<p>Path to file or connection to write to.</p>
</td></tr>
<tr><td><code id="write_xml_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
<tr><td><code id="write_xml_+3A_options">options</code></td>
<td>
<p>default: &lsquo;format&rsquo;. Zero or more of
</p>
<dl>
<dt>format</dt><dd><p>Format output</p>
</dd><dt>no_declaration</dt><dd><p>Drop the XML declaration</p>
</dd><dt>no_empty_tags</dt><dd><p>Remove empty tags</p>
</dd><dt>no_xhtml</dt><dd><p>Disable XHTML1 rules</p>
</dd><dt>require_xhtml</dt><dd><p>Force XHTML rules</p>
</dd><dt>as_xml</dt><dd><p>Force XML output</p>
</dd><dt>as_html</dt><dd><p>Force HTML output</p>
</dd><dt>format_whitespace</dt><dd><p>Format with non-significant whitespace</p>
</dd></dl>
</td></tr>
<tr><td><code id="write_xml_+3A_encoding">encoding</code></td>
<td>
<p>The character encoding to use in the document. The default
encoding is &lsquo;UTF-8&rsquo;. Available encodings are specified at
<a href="http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding">http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- read_html("&lt;p&gt;Hi!&lt;/p&gt;")

tmp &lt;- tempfile(fileext = ".xml")
write_xml(h, tmp, options = "format")
readLines(tmp)

# write formatted HTML output
write_html(h, tmp, options = "format")
readLines(tmp)
</code></pre>

<hr>
<h2 id='xml_attr'>Retrieve an attribute.</h2><span id='topic+xml_attr'></span><span id='topic+xml_has_attr'></span><span id='topic+xml_attrs'></span><span id='topic+xml_attr+3C-'></span><span id='topic+xml_set_attr'></span><span id='topic+xml_attrs+3C-'></span><span id='topic+xml_set_attrs'></span>

<h3>Description</h3>

<p><code>xml_attrs()</code> retrieves all attributes values as a named character
vector, <code style="white-space: pre;">&#8288;xml_attrs() &lt;-&#8288;</code> or <code>xml_set_attrs()</code> sets all attribute
values. <code>xml_attr()</code> retrieves the value of single attribute and
<code style="white-space: pre;">&#8288;xml_attr() &lt;-&#8288;</code> or <code>xml_set_attr()</code> modifies its value. If the
attribute doesn't exist, it will return <code>default</code>, which defaults to
<code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_attr(x, attr, ns = character(), default = NA_character_)

xml_has_attr(x, attr, ns = character())

xml_attrs(x, ns = character())

xml_attr(x, attr, ns = character()) &lt;- value

xml_set_attr(x, attr, value, ns = character())

xml_attrs(x, ns = character()) &lt;- value

xml_set_attrs(x, value, ns = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_attr_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_attr_+3A_attr">attr</code></td>
<td>
<p>Name of attribute to extract.</p>
</td></tr>
<tr><td><code id="xml_attr_+3A_ns">ns</code></td>
<td>
<p>Optionally, a named vector giving prefix-url pairs, as produced
by <code><a href="xml2.html#topic+xml_ns">xml_ns()</a></code>. If provided, all names will be explicitly
qualified with the ns prefix, i.e. if the element <code>bar</code> is defined
in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And
similarly for attributes). Default namespaces must be given an explicit
name. The ns is ignored when using <code><a href="xml2.html#topic+xml_name+3C-">xml_name&lt;-()</a></code> and
<code><a href="xml2.html#topic+xml_set_name">xml_set_name()</a></code>.</p>
</td></tr>
<tr><td><code id="xml_attr_+3A_default">default</code></td>
<td>
<p>Default value to use when attribute is not present.</p>
</td></tr>
<tr><td><code id="xml_attr_+3A_value">value</code></td>
<td>
<p>character vector of new value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>xml_attr()</code> returns a character vector. <code>NA</code> is used
to represent of attributes that aren't defined.
</p>
<p><code>xml_has_attr()</code> returns a logical vector.
</p>
<p><code>xml_attrs()</code> returns a named character vector if <code>x</code> x is single
node, or a list of character vectors if given a nodeset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;root id='1'&gt;&lt;child id ='a' /&gt;&lt;child id='b' d='b'/&gt;&lt;/root&gt;")
xml_attr(x, "id")
xml_attr(x, "apple")
xml_attrs(x)

kids &lt;- xml_children(x)
kids
xml_attr(kids, "id")
xml_has_attr(kids, "id")
xml_attrs(kids)

# Missing attributes give missing values
xml_attr(xml_children(x), "d")
xml_has_attr(xml_children(x), "d")

# If the document has a namespace, use the ns argument and
# qualified attribute names
x &lt;- read_xml('
 &lt;root xmlns:b="http://bar.com" xmlns:f="http://foo.com"&gt;
   &lt;doc b:id="b" f:id="f" id="" /&gt;
 &lt;/root&gt;
')
doc &lt;- xml_children(x)[[1]]
ns &lt;- xml_ns(x)

xml_attrs(doc)
xml_attrs(doc, ns)

# If you don't supply a ns spec, you get the first matching attribute
xml_attr(doc, "id")
xml_attr(doc, "b:id", ns)
xml_attr(doc, "id", ns)

# Can set a single attribute with `xml_attr() &lt;-` or `xml_set_attr()`
xml_attr(doc, "id") &lt;- "one"
xml_set_attr(doc, "id", "two")

# Or set multiple attributes with `xml_attrs()` or `xml_set_attrs()`
xml_attrs(doc) &lt;- c("b:id" = "one", "f:id" = "two", "id" = "three")
xml_set_attrs(doc, c("b:id" = "one", "f:id" = "two", "id" = "three"))
</code></pre>

<hr>
<h2 id='xml_cdata'>Construct a cdata node</h2><span id='topic+xml_cdata'></span>

<h3>Description</h3>

<p>Construct a cdata node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_cdata(content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_cdata_+3A_content">content</code></td>
<td>
<p>The CDATA content, does not include <code style="white-space: pre;">&#8288;&lt;![CDATA[&#8288;</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xml_new_root("root")
xml_add_child(x, xml_cdata("&lt;d/&gt;"))
as.character(x)
</code></pre>

<hr>
<h2 id='xml_children'>Navigate around the family tree.</h2><span id='topic+xml_children'></span><span id='topic+xml_child'></span><span id='topic+xml_contents'></span><span id='topic+xml_parents'></span><span id='topic+xml_siblings'></span><span id='topic+xml_parent'></span><span id='topic+xml_length'></span><span id='topic+xml_root'></span>

<h3>Description</h3>

<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns
all nodes. <code>xml_length</code> returns the number of children.
<code>xml_parent</code> returns the parent node, <code>xml_parents</code>
returns all parents up to the root. <code>xml_siblings</code> returns all nodes
at the same level. <code>xml_child</code> makes it easy to specify a specific
child to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_children(x)

xml_child(x, search = 1, ns = xml_ns(x))

xml_contents(x)

xml_parents(x)

xml_siblings(x)

xml_parent(x)

xml_length(x, only_elements = TRUE)

xml_root(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_children_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_children_+3A_search">search</code></td>
<td>
<p>For <code>xml_child</code>, either the child number to return (by
position), or the name of the child node to return. If there are multiple
child nodes with the same name, the first will be returned</p>
</td></tr>
<tr><td><code id="xml_children_+3A_ns">ns</code></td>
<td>
<p>Optionally, a named vector giving prefix-url pairs, as produced
by <code><a href="xml2.html#topic+xml_ns">xml_ns()</a></code>. If provided, all names will be explicitly
qualified with the ns prefix, i.e. if the element <code>bar</code> is defined
in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And
similarly for attributes). Default namespaces must be given an explicit
name. The ns is ignored when using <code><a href="xml2.html#topic+xml_name+3C-">xml_name&lt;-()</a></code> and
<code><a href="xml2.html#topic+xml_set_name">xml_set_name()</a></code>.</p>
</td></tr>
<tr><td><code id="xml_children_+3A_only_elements">only_elements</code></td>
<td>
<p>For <code>xml_length</code>, should it count all children,
or just children that are elements (the default)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A node or nodeset (possibly empty). Results are always de-duplicated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;foo&gt; &lt;bar&gt;&lt;boo /&gt;&lt;/bar&gt; &lt;baz/&gt; &lt;/foo&gt;")
xml_children(x)
xml_children(xml_children(x))
xml_siblings(xml_children(x)[[1]])

# Note the each unique node only appears once in the output
xml_parent(xml_children(x))

# Mixed content
x &lt;- read_xml("&lt;foo&gt; a &lt;b/&gt; c &lt;d&gt;e&lt;/d&gt; f&lt;/foo&gt;")
# Childen gets the elements, contents gets all node types
xml_children(x)
xml_contents(x)

xml_length(x)
xml_length(x, only_elements = FALSE)

# xml_child makes it easier to select specific children
xml_child(x)
xml_child(x, 2)
xml_child(x, "baz")
</code></pre>

<hr>
<h2 id='xml_comment'>Construct a comment node</h2><span id='topic+xml_comment'></span>

<h3>Description</h3>

<p>Construct a comment node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_comment(content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_comment_+3A_content">content</code></td>
<td>
<p>The comment content</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- xml_new_document()
r &lt;- xml_add_child(x, "root")
xml_add_child(r, xml_comment("Hello!"))
as.character(x)
</code></pre>

<hr>
<h2 id='xml_document-class'>Register S4 classes</h2><span id='topic+xml_document-class'></span><span id='topic+xml_missing-class'></span><span id='topic+xml_node-class'></span><span id='topic+xml_nodeset-class'></span>

<h3>Description</h3>

<p>Classes are exported so they can be re-used within S4 classes, see <code><a href="methods.html#topic+setOldClass">methods::setOldClass()</a></code>.
</p>

<ul>
<li> <p><code>xml_document</code>: a complete document.
</p>
</li>
<li> <p><code>xml_nodeset</code>: a <em>set</em> of nodes within a document.
</p>
</li>
<li> <p><code>xml_missing</code>: a missing object, e.g. for an empty result set.
</p>
</li>
<li> <p><code>xml_node</code>: a single node in a document.
</p>
</li></ul>


<hr>
<h2 id='xml_dtd'>Construct a document type definition</h2><span id='topic+xml_dtd'></span>

<h3>Description</h3>

<p>This is used to create simple document type definitions. If you need to
create a more complicated definition with internal subsets it is recommended
to parse a string directly with <code>read_xml()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_dtd(name = "", external_id = "", system_id = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_dtd_+3A_name">name</code></td>
<td>
<p>The name of the declaration</p>
</td></tr>
<tr><td><code id="xml_dtd_+3A_external_id">external_id</code></td>
<td>
<p>The external ID of the declaration</p>
</td></tr>
<tr><td><code id="xml_dtd_+3A_system_id">system_id</code></td>
<td>
<p>The system ID of the declaration</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- xml_new_root(
  xml_dtd(
    "html",
    "-//W3C//DTD XHTML 1.0 Transitional//EN",
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
  )
)

# Use read_xml directly for more complicated DTD
d &lt;- read_xml(
  '&lt;!DOCTYPE doc [
&lt;!ELEMENT doc (#PCDATA)&gt;
&lt;!ENTITY foo " test "&gt;
]&gt;
&lt;doc&gt;This is a valid document &amp;foo; !&lt;/doc&gt;'
)
</code></pre>

<hr>
<h2 id='xml_find_all'>Find nodes that match an xpath expression.</h2><span id='topic+xml_find_all'></span><span id='topic+xml_find_all.xml_nodeset'></span><span id='topic+xml_find_first'></span><span id='topic+xml_find_num'></span><span id='topic+xml_find_int'></span><span id='topic+xml_find_chr'></span><span id='topic+xml_find_lgl'></span><span id='topic+xml_find_one'></span>

<h3>Description</h3>

<p>Xpath is like regular expressions for trees - it's worth learning if
you're trying to extract nodes from arbitrary locations in a document.
Use <code>xml_find_all</code> to find all matches - if there's no match you'll
get an empty result. Use <code>xml_find_first</code> to find a specific match -
if there's no match you'll get an <code>xml_missing</code> node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_find_all(x, xpath, ns = xml_ns(x), ...)

## S3 method for class 'xml_nodeset'
xml_find_all(x, xpath, ns = xml_ns(x), flatten = TRUE, ...)

xml_find_first(x, xpath, ns = xml_ns(x))

xml_find_num(x, xpath, ns = xml_ns(x))

xml_find_int(x, xpath, ns = xml_ns(x))

xml_find_chr(x, xpath, ns = xml_ns(x))

xml_find_lgl(x, xpath, ns = xml_ns(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_find_all_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_find_all_+3A_xpath">xpath</code></td>
<td>
<p>A string containing an xpath (1.0) expression.</p>
</td></tr>
<tr><td><code id="xml_find_all_+3A_ns">ns</code></td>
<td>
<p>Optionally, a named vector giving prefix-url pairs, as produced
by <code><a href="xml2.html#topic+xml_ns">xml_ns()</a></code>. If provided, all names will be explicitly
qualified with the ns prefix, i.e. if the element <code>bar</code> is defined
in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And
similarly for attributes). Default namespaces must be given an explicit
name. The ns is ignored when using <code><a href="xml2.html#topic+xml_name+3C-">xml_name&lt;-()</a></code> and
<code><a href="xml2.html#topic+xml_set_name">xml_set_name()</a></code>.</p>
</td></tr>
<tr><td><code id="xml_find_all_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="xml_find_all_+3A_flatten">flatten</code></td>
<td>
<p>A logical indicating whether to return a single, flattened
nodeset or a list of nodesets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>xml_find_all</code> returns a nodeset if applied to a node, and a nodeset
or a list of nodesets if applied to a nodeset. If there are no matches,
the nodeset(s) will be empty. Within each nodeset, the result will always
be unique; repeated nodes are automatically de-duplicated.
</p>
<p><code>xml_find_first</code> returns a node if applied to a node, and a nodeset
if applied to a nodeset. The output is <em>always</em> the same size as
the input. If there are no matches, <code>xml_find_first</code> will return a
missing node; if there are multiple matches, it will return the first
only.
</p>
<p><code>xml_find_num</code>, <code>xml_find_chr</code>, <code>xml_find_lgl</code> return
numeric, character and logical results respectively.
</p>


<h3>Deprecated functions</h3>

<p><code>xml_find_one()</code> has been deprecated. Instead use
<code>xml_find_first()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="xml2.html#topic+xml_ns_strip">xml_ns_strip()</a></code> to remove the default namespaces
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;foo&gt;&lt;bar&gt;&lt;baz/&gt;&lt;/bar&gt;&lt;baz/&gt;&lt;/foo&gt;")
xml_find_all(x, ".//baz")
xml_path(xml_find_all(x, ".//baz"))

# Note the difference between .// and //
# //  finds anywhere in the document (ignoring the current node)
# .// finds anywhere beneath the current node
(bar &lt;- xml_find_all(x, ".//bar"))
xml_find_all(bar, ".//baz")
xml_find_all(bar, "//baz")

# Find all vs find one -----------------------------------------------------
x &lt;- read_xml("&lt;body&gt;
  &lt;p&gt;Some &lt;b&gt;text&lt;/b&gt;.&lt;/p&gt;
  &lt;p&gt;Some &lt;b&gt;other&lt;/b&gt; &lt;b&gt;text&lt;/b&gt;.&lt;/p&gt;
  &lt;p&gt;No bold here!&lt;/p&gt;
&lt;/body&gt;")
para &lt;- xml_find_all(x, ".//p")

# By default, if you apply xml_find_all to a nodeset, it finds all matches,
# de-duplicates them, and returns as a single nodeset. This means you
# never know how many results you'll get
xml_find_all(para, ".//b")

# If you set flatten to FALSE, though, xml_find_all will return a list of
# nodesets, where each nodeset contains the matches for the corresponding
# node in the original nodeset.
xml_find_all(para, ".//b", flatten = FALSE)

# xml_find_first only returns the first match per input node. If there are 0
# matches it will return a missing node
xml_find_first(para, ".//b")
xml_text(xml_find_first(para, ".//b"))

# Namespaces ---------------------------------------------------------------
# If the document uses namespaces, you'll need use xml_ns to form
# a unique mapping between full namespace url and a short prefix
x &lt;- read_xml('
 &lt;root xmlns:f = "http://foo.com" xmlns:g = "http://bar.com"&gt;
   &lt;f:doc&gt;&lt;g:baz /&gt;&lt;/f:doc&gt;
   &lt;f:doc&gt;&lt;g:baz /&gt;&lt;/f:doc&gt;
 &lt;/root&gt;
')
xml_find_all(x, ".//f:doc")
xml_find_all(x, ".//f:doc", xml_ns(x))
</code></pre>

<hr>
<h2 id='xml_missing'>Construct an missing xml object</h2><span id='topic+xml_missing'></span>

<h3>Description</h3>

<p>Construct an missing xml object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_missing()
</code></pre>

<hr>
<h2 id='xml_name'>The (tag) name of an xml element.</h2><span id='topic+xml_name'></span><span id='topic+xml_name+3C-'></span><span id='topic+xml_set_name'></span>

<h3>Description</h3>

<p>The (tag) name of an xml element.
</p>
<p>Modify the (tag) name of an element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_name(x, ns = character())

xml_name(x, ns = character()) &lt;- value

xml_set_name(x, value, ns = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_name_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_name_+3A_ns">ns</code></td>
<td>
<p>Optionally, a named vector giving prefix-url pairs, as produced
by <code><a href="xml2.html#topic+xml_ns">xml_ns()</a></code>. If provided, all names will be explicitly
qualified with the ns prefix, i.e. if the element <code>bar</code> is defined
in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And
similarly for attributes). Default namespaces must be given an explicit
name. The ns is ignored when using <code><a href="xml2.html#topic+xml_name+3C-">xml_name&lt;-()</a></code> and
<code><a href="xml2.html#topic+xml_set_name">xml_set_name()</a></code>.</p>
</td></tr>
<tr><td><code id="xml_name_+3A_value">value</code></td>
<td>
<p>a character vector with replacement name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;bar&gt;123&lt;/bar&gt;")
xml_name(x)

y &lt;- read_xml("&lt;bar&gt;&lt;baz&gt;1&lt;/baz&gt;abc&lt;foo /&gt;&lt;/bar&gt;")
z &lt;- xml_children(y)
xml_name(xml_children(y))
</code></pre>

<hr>
<h2 id='xml_new_document'>Create a new document, possibly with a root node</h2><span id='topic+xml_new_document'></span><span id='topic+xml_new_root'></span>

<h3>Description</h3>

<p><code>xml_new_document</code> creates only a new document without a root node. In
most cases you should instead use <code>xml_new_root</code>, which creates a new
document and assigns the root node in one step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_new_document(version = "1.0", encoding = "UTF-8")

xml_new_root(
  .value,
  ...,
  .copy = inherits(.value, "xml_node"),
  .version = "1.0",
  .encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_new_document_+3A_version">version</code></td>
<td>
<p>The version number of the document.</p>
</td></tr>
<tr><td><code id="xml_new_document_+3A_encoding">encoding</code></td>
<td>
<p>The character encoding to use in the document. The default
encoding is &lsquo;UTF-8&rsquo;. Available encodings are specified at
<a href="http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding">http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p>
</td></tr>
<tr><td><code id="xml_new_document_+3A_.value">.value</code></td>
<td>
<p>node to insert.</p>
</td></tr>
<tr><td><code id="xml_new_document_+3A_...">...</code></td>
<td>
<p>If named attributes or namespaces to set on the node, if unnamed
text to assign to the node.</p>
</td></tr>
<tr><td><code id="xml_new_document_+3A_.copy">.copy</code></td>
<td>
<p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code>
then the node will be moved from it's current location.</p>
</td></tr>
<tr><td><code id="xml_new_document_+3A_.version">.version</code></td>
<td>
<p>The version number of the document, passed to <code>xml_new_document(version)</code>.</p>
</td></tr>
<tr><td><code id="xml_new_document_+3A_.encoding">.encoding</code></td>
<td>
<p>The encoding of the document, passed to <code>xml_new_document(encoding)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>xml_document</code> object.
</p>

<hr>
<h2 id='xml_ns'>XML namespaces.</h2><span id='topic+xml_ns'></span><span id='topic+xml_ns_rename'></span>

<h3>Description</h3>

<p><code>xml_ns</code> extracts all namespaces from a document, matching each
unique namespace url with the prefix it was first associated with. Default
namespaces are named <code>d1</code>, <code>d2</code> etc. Use <code>xml_ns_rename</code>
to change the prefixes. Once you have a namespace object, you can pass it to
other functions to work with fully qualified names instead of local names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_ns(x)

xml_ns_rename(old, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_ns_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_ns_+3A_old">old</code>, <code id="xml_ns_+3A_...">...</code></td>
<td>
<p>An existing xml_namespace object followed by name-value
(old prefix-new prefix) pairs to replace.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with class <code>xml_namespace</code> so the
default display is a little nicer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml('
 &lt;root&gt;
   &lt;doc1 xmlns = "http://foo.com"&gt;&lt;baz /&gt;&lt;/doc1&gt;
   &lt;doc2 xmlns = "http://bar.com"&gt;&lt;baz /&gt;&lt;/doc2&gt;
 &lt;/root&gt;
')
xml_ns(x)

# When there are default namespaces, it's a good idea to rename
# them to give informative names:
ns &lt;- xml_ns_rename(xml_ns(x), d1 = "foo", d2 = "bar")
ns

# Now we can pass ns to other xml function to use fully qualified names
baz &lt;- xml_children(xml_children(x))
xml_name(baz)
xml_name(baz, ns)

xml_find_all(x, "//baz")
xml_find_all(x, "//foo:baz", ns)

str(as_list(x))
str(as_list(x, ns))
</code></pre>

<hr>
<h2 id='xml_ns_strip'>Strip the default namespaces from a document</h2><span id='topic+xml_ns_strip'></span>

<h3>Description</h3>

<p>Strip the default namespaces from a document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_ns_strip(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_ns_strip_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml(
  "&lt;foo xmlns = 'http://foo.com'&gt;
   &lt;baz/&gt;
   &lt;bar xmlns = 'http://bar.com'&gt;
     &lt;baz/&gt;
   &lt;/bar&gt;
  &lt;/foo&gt;"
)
# Need to specify the default namespaces to find the baz nodes
xml_find_all(x, "//d1:baz")
xml_find_all(x, "//d2:baz")

# After stripping the default namespaces you can find both baz nodes directly
xml_ns_strip(x)
xml_find_all(x, "//baz")
</code></pre>

<hr>
<h2 id='xml_path'>Retrieve the xpath to a node</h2><span id='topic+xml_path'></span>

<h3>Description</h3>

<p>This is useful when you want to figure out where nodes matching an
xpath expression live in a document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_path(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_path_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;foo&gt;&lt;bar&gt;&lt;baz /&gt;&lt;/bar&gt;&lt;baz /&gt;&lt;/foo&gt;")
xml_path(xml_find_all(x, ".//baz"))
</code></pre>

<hr>
<h2 id='xml_replace'>Modify a tree by inserting, replacing or removing nodes</h2><span id='topic+xml_replace'></span><span id='topic+xml_add_sibling'></span><span id='topic+xml_add_child'></span><span id='topic+xml_add_parent'></span><span id='topic+xml_remove'></span>

<h3>Description</h3>

<p><code>xml_add_sibling()</code> and <code>xml_add_child()</code> are used to insert a node
as a sibling or a child. <code>xml_add_parent()</code> adds a new parent in
between the input node and the current parent. <code>xml_replace()</code>
replaces an existing node with a new node. <code>xml_remove()</code> removes a
node from the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_replace(.x, .value, ..., .copy = TRUE)

xml_add_sibling(.x, .value, ..., .where = c("after", "before"), .copy = TRUE)

xml_add_child(.x, .value, ..., .where = length(xml_children(.x)), .copy = TRUE)

xml_add_parent(.x, .value, ...)

xml_remove(.x, free = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_replace_+3A_.x">.x</code></td>
<td>
<p>a document, node or nodeset.</p>
</td></tr>
<tr><td><code id="xml_replace_+3A_.value">.value</code></td>
<td>
<p>node to insert.</p>
</td></tr>
<tr><td><code id="xml_replace_+3A_...">...</code></td>
<td>
<p>If named attributes or namespaces to set on the node, if unnamed
text to assign to the node.</p>
</td></tr>
<tr><td><code id="xml_replace_+3A_.copy">.copy</code></td>
<td>
<p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code>
then the node will be moved from it's current location.</p>
</td></tr>
<tr><td><code id="xml_replace_+3A_.where">.where</code></td>
<td>
<p>to add the new node, for <code>xml_add_child</code> the position
after which to add, use <code>0</code> for the first child. For
<code>xml_add_sibling</code> either &lsquo;&quot;before&quot;&rsquo; or &lsquo;&quot;after&quot;&rsquo;
indicating if the new node should be before or after <code>.x</code>.</p>
</td></tr>
<tr><td><code id="xml_replace_+3A_free">free</code></td>
<td>
<p>When removing the node also free the memory used for that node.
Note if you use this option you cannot use any existing objects pointing to
the node or its children, it is likely to crash R or return garbage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Care needs to be taken when using <code>xml_remove()</code>,
</p>

<hr>
<h2 id='xml_serialize'>Serializing XML objects to connections.</h2><span id='topic+xml_serialize'></span><span id='topic+xml_unserialize'></span>

<h3>Description</h3>

<p>Serializing XML objects to connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_serialize(object, connection, ...)

xml_unserialize(connection, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_serialize_+3A_object">object</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object to serialize.</p>
</td></tr>
<tr><td><code id="xml_serialize_+3A_connection">connection</code></td>
<td>
<p>an open <a href="base.html#topic+connection">connection</a> or (for <code>serialize</code>)
<code>NULL</code> or (for <code>unserialize</code>) a raw vector
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="xml_serialize_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="xml2.html#topic+read_xml">read_xml()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>serialize</code>, <code>NULL</code> unless <code>connection = NULL</code>, when
the result is returned in a raw vector.
</p>
<p>For <code>unserialize</code> an <span class="rlang"><b>R</b></span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xml2)
x &lt;- read_xml("&lt;a&gt;
  &lt;b&gt;&lt;c&gt;123&lt;/c&gt;&lt;/b&gt;
  &lt;b&gt;&lt;c&gt;456&lt;/c&gt;&lt;/b&gt;
&lt;/a&gt;")

b &lt;- xml_find_all(x, "//b")
out &lt;- xml_serialize(b, NULL)
xml_unserialize(out)
</code></pre>

<hr>
<h2 id='xml_set_namespace'>Set the node's namespace</h2><span id='topic+xml_set_namespace'></span>

<h3>Description</h3>

<p>The namespace to be set must be already defined in one of the node's
ancestors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_set_namespace(.x, prefix = "", uri = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_set_namespace_+3A_.x">.x</code></td>
<td>
<p>a node</p>
</td></tr>
<tr><td><code id="xml_set_namespace_+3A_prefix">prefix</code></td>
<td>
<p>The namespace prefix to use</p>
</td></tr>
<tr><td><code id="xml_set_namespace_+3A_uri">uri</code></td>
<td>
<p>The namespace URI to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the node (invisibly)
</p>

<hr>
<h2 id='xml_structure'>Show the structure of an html/xml document.</h2><span id='topic+xml_structure'></span><span id='topic+html_structure'></span>

<h3>Description</h3>

<p>Show the structure of an html/xml document without displaying any of
the values. This is useful if you want to get a high level view of the
way a document is organised. Compared to <code>xml_structure</code>,
<code>html_structure</code> prints the id and class attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_structure(x, indent = 2, file = "")

html_structure(x, indent = 2, file = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_structure_+3A_x">x</code></td>
<td>
<p>HTML/XML document (or part there of)</p>
</td></tr>
<tr><td><code id="xml_structure_+3A_indent">indent</code></td>
<td>
<p>Number of spaces to ident</p>
</td></tr>
<tr><td><code id="xml_structure_+3A_file">file</code></td>
<td>
<p>A <a href="base.html#topic+connection">connection</a>, or a character string naming the file
to print to.  If <code>""</code> (the default), <code>cat</code> prints to the
standard output connection, the console unless redirected by
<code><a href="base.html#topic+sink">sink</a></code>.
If it is <code>"|cmd"</code>, the output is piped to the command given
by &lsquo;<span class="file">cmd</span>&rsquo;, by opening a pipe connection.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xml_structure(read_xml("&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;c/&gt;&lt;/b&gt;&lt;d/&gt;&lt;/a&gt;"))

rproj &lt;- read_html(system.file("extdata", "r-project.html", package = "xml2"))
xml_structure(rproj)
xml_structure(xml_find_all(rproj, ".//p"))

h &lt;- read_html("&lt;body&gt;&lt;p id = 'a'&gt;&lt;/p&gt;&lt;p class = 'c d'&gt;&lt;/p&gt;&lt;/body&gt;")
html_structure(h)
</code></pre>

<hr>
<h2 id='xml_text'>Extract or modify the text</h2><span id='topic+xml_text'></span><span id='topic+xml_text+3C-'></span><span id='topic+xml_set_text'></span><span id='topic+xml_double'></span><span id='topic+xml_integer'></span>

<h3>Description</h3>

<p><code>xml_text</code> returns a character vector, <code>xml_double</code> returns a
numeric vector, <code>xml_integer</code> returns an integer vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_text(x, trim = FALSE)

xml_text(x) &lt;- value

xml_set_text(x, value)

xml_double(x)

xml_integer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_text_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_text_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code> will trim leading and trailing spaces.</p>
</td></tr>
<tr><td><code id="xml_text_+3A_value">value</code></td>
<td>
<p>character vector with replacement text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, the same length as x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;p&gt;This is some text. This is &lt;b&gt;bold!&lt;/b&gt;&lt;/p&gt;")
xml_text(x)
xml_text(xml_children(x))

x &lt;- read_xml("&lt;x&gt;This is some text. &lt;x&gt;This is some nested text.&lt;/x&gt;&lt;/x&gt;")
xml_text(x)
xml_text(xml_find_all(x, "//x"))

x &lt;- read_xml("&lt;p&gt;   Some text    &lt;/p&gt;")
xml_text(x, trim = TRUE)

# xml_double() and xml_integer() are useful for extracting numeric attributes
x &lt;- read_xml("&lt;plot&gt;&lt;point x='1' y='2' /&gt;&lt;point x='2' y='1' /&gt;&lt;/plot&gt;")
xml_integer(xml_find_all(x, "//@x"))
</code></pre>

<hr>
<h2 id='xml_type'>Determine the type of a node.</h2><span id='topic+xml_type'></span>

<h3>Description</h3>

<p>Determine the type of a node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_type_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_xml("&lt;foo&gt; a &lt;b /&gt; &lt;![CDATA[ blah]]&gt;&lt;/foo&gt;")
xml_type(x)
xml_type(xml_contents(x))
</code></pre>

<hr>
<h2 id='xml_url'>The URL of an XML document</h2><span id='topic+xml_url'></span>

<h3>Description</h3>

<p>This is useful for interpreting relative urls with <code><a href="xml2.html#topic+url_relative">url_relative()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_url(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_url_+3A_x">x</code></td>
<td>
<p>A node or document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1. Returns <code>NA</code> if the name is
not set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catalog &lt;- read_xml(xml2_example("cd_catalog.xml"))
xml_url(catalog)

x &lt;- read_xml("&lt;foo/&gt;")
xml_url(x)
</code></pre>

<hr>
<h2 id='xml_validate'>Validate XML schema</h2><span id='topic+xml_validate'></span>

<h3>Description</h3>

<p>Validate an XML document against an XML 1.0 schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_validate(x, schema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_validate_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="xml_validate_+3A_schema">schema</code></td>
<td>
<p>an XML document containing the schema</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from https://msdn.microsoft.com/en-us/library/ms256129(v=vs.110).aspx
doc &lt;- read_xml(system.file("extdata/order-doc.xml", package = "xml2"))
schema &lt;- read_xml(system.file("extdata/order-schema.xml", package = "xml2"))
xml_validate(doc, schema)
</code></pre>

<hr>
<h2 id='xml2_example'>Get path to a xml2 example</h2><span id='topic+xml2_example'></span>

<h3>Description</h3>

<p>xml2 comes bundled with a number of sample files in its &lsquo;inst/extdata&rsquo;
directory. This function makes them easy to access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml2_example(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml2_example_+3A_path">path</code></td>
<td>
<p>Name of file. If <code>NULL</code>, the example files will be listed.</p>
</td></tr>
</table>

<hr>
<h2 id='xml2-package'>xml2: Parse XML</h2><span id='topic+xml2'></span><span id='topic+xml2-package'></span>

<h3>Description</h3>

<p>Work with XML files using a simple, consistent interface. Built on top of the 'libxml2' C library.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jim Hester
</p>
</li>
<li><p> Jeroen Ooms
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li>
<li><p> R Foundation (Copy of R-project homepage cached as example) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://xml2.r-lib.org/">https://xml2.r-lib.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/xml2">https://github.com/r-lib/xml2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/xml2/issues">https://github.com/r-lib/xml2/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
