<!DOCTYPE html><html><head><title>Help for package klic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {klic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#copheneticCorrelation'><p>Cophenetic correlation coefficient</p></a></li>
<li><a href='#kkmeans'><p>Kernel k-means</p></a></li>
<li><a href='#klic'><p>Kernel learning integrative clustering</p></a></li>
<li><a href='#lmkkmeans'><p>Localised multiple kernel k-means</p></a></li>
<li><a href='#lmkkmeans_missingData'><p>Localised multiple kernel k-means</p></a></li>
<li><a href='#plotSimilarityMatrix'><p>Plot similarity matrix with pheatmap</p></a></li>
<li><a href='#spectrumShift'><p>Spectrum shift</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Kernel Learning Integrative Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandra Cabassi
    <a href="https://orcid.org/0000-0003-1605-652X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paul DW Kirk <a href="https://orcid.org/0000-0002-5931-7489"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths],
  Mehmet Gonen <a href="https://orcid.org/0000-0002-2483-075X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Description:</td>
<td>Kernel Learning Integrative Clustering (KLIC) is an algorithm that allows to combine multiple kernels, each representing a different measure of the similarity between a set of observations. The contribution of each kernel on the final clustering is weighted according to the amount of information carried by it. As well as providing the functions required to perform the kernel-based clustering, this package also allows the user to simply give the data as input: the kernels are then built using consensus clustering. Different strategies to choose the best number of clusters are also available. For further details please see Cabassi and Kirk (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa593">doi:10.1093/bioinformatics/btaa593</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/acabassi/klic">http://github.com/acabassi/klic</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/acabassi/klic/issues">http://github.com/acabassi/klic/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, cluster, coca, RColorBrewer, pheatmap, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rmosek, tikzDevice, mclust, grDevices, graphics, knitr,
markdown</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>MOSEK (http://www.mosek.com) and MOSEK license.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-06 14:39:23 UTC; alessandracabassi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandra Cabassi &lt;alessandra.cabassi@mrc-bsu.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-06 16:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='copheneticCorrelation'>Cophenetic correlation coefficient</h2><span id='topic+copheneticCorrelation'></span>

<h3>Description</h3>

<p>Compute the cophenetic correlation coefficient of a kernel matrix, which is
a measure of how faithfully hierarchical clustering would preserve the
pairwise distances between the original data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copheneticCorrelation(kernelMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copheneticCorrelation_+3A_kernelmatrix">kernelMatrix</code></td>
<td>
<p>kernel matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns the cophenetic correlation coefficient of the
kernel matrix provided as input.
</p>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Cabassi, A. and Kirk, P. D. W. (2019). Multiple kernel learning
for integrative consensus clustering of genomic datasets. arXiv preprint.
arXiv:1904.07701.
</p>
<p>Sokal, R.R. and Rohlf, F.J., 1962. The comparison of dendrograms
by objective methods. Taxon, 11(2), pp.33-40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load kernel matrix
consensus_matrix &lt;- as.matrix(read.csv(system.file('extdata',
'consensus_matrix1.csv', package = 'klic'), row.names = 1))

# Compute cophenetic correlation
coph_corr_coeff &lt;- copheneticCorrelation(consensus_matrix)
cat(coph_corr_coeff)
</code></pre>

<hr>
<h2 id='kkmeans'>Kernel k-means</h2><span id='topic+kkmeans'></span>

<h3>Description</h3>

<p>Perform the training step of kernel k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kkmeans(K, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kkmeans_+3A_k">K</code></td>
<td>
<p>Kernel matrix.</p>
</td></tr>
<tr><td><code id="kkmeans_+3A_parameters">parameters</code></td>
<td>
<p>A list containing the number of clusters
<code>number_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list containing:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>the cluster labels for each element (i.e. row/column) of
the kernel matrix.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function for the given
clustering.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>same parameters as in the input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Gonen
</p>


<h3>References</h3>

<p>Gonen, M. and Margolin, A.A., 2014. Localized data fusion for
kernel k-means clustering with application to cancer biology. In Advances in
Neural Information Processing Systems (pp. 1305-1313).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load one dataset with 100 observations, 2 variables, 4 clusters
data &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "klic"), row.names = 1))
# Compute consensus clustering with K=4 clusters
cm &lt;- coca::consensusCluster(data, 4)
# Shift eigenvalues of the matrix by a constant: (min eigenvalue) * (coeff)
km &lt;- spectrumShift(cm, coeff = 1.05)
# Initalize the parameters of the algorithm
parameters &lt;- list()
# Set the number of clusters
parameters$cluster_count &lt;- 4
# Perform training
state &lt;- kkmeans(km, parameters)
# Display the clustering
print(state$clustering)
</code></pre>

<hr>
<h2 id='klic'>Kernel learning integrative clustering</h2><span id='topic+klic'></span>

<h3>Description</h3>

<p>This function allows to perform Kernel Learning Integrative Clustering on M
data sets relative to the same observations. The similarities between the
observations in each data set are summarised into M different kernels, that
are then fed into a kernel k-means clustering algorithm. The output is a
clustering of the observations that takes into account all the available data
types and a set of weights that sum up to one, indicating how much each data
set contributed to the kernel k-means clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>klic(
  data,
  M,
  individualK = NULL,
  individualMaxK = 6,
  individualClAlgorithm = "kkmeans",
  globalK = NULL,
  globalMaxK = 6,
  B = 1000,
  C = 100,
  scale = FALSE,
  savePNG = FALSE,
  fileName = "klic",
  verbose = TRUE,
  annotations = NULL,
  ccClMethods = "kmeans",
  ccDistHCs = "euclidean",
  widestGap = FALSE,
  dunns = FALSE,
  dunn2s = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="klic_+3A_data">data</code></td>
<td>
<p>List of M datasets, each of size N X P_m, m = 1, ..., M.</p>
</td></tr>
<tr><td><code id="klic_+3A_m">M</code></td>
<td>
<p>number of datasets.</p>
</td></tr>
<tr><td><code id="klic_+3A_individualk">individualK</code></td>
<td>
<p>Vector containing the number of clusters in each dataset.
Default is NULL. If the number of clusters is not provided, then all the
possible values between 2 and individualMaxK are considered and the best
value is chosen for each dataset by maximising the silhouette.</p>
</td></tr>
<tr><td><code id="klic_+3A_individualmaxk">individualMaxK</code></td>
<td>
<p>Maximum number of clusters considered for the
individual data. Default is 6.</p>
</td></tr>
<tr><td><code id="klic_+3A_individualclalgorithm">individualClAlgorithm</code></td>
<td>
<p>Clustering algorithm used for clustering of each
dataset individually if is required to find the best number of clusters.</p>
</td></tr>
<tr><td><code id="klic_+3A_globalk">globalK</code></td>
<td>
<p>Number of global clusters. Default is NULL. If the number of
clusters is not provided, then all the possible values between 2 and
globalMaxK are considered and the best value is chosen by maximising the
silhouette.</p>
</td></tr>
<tr><td><code id="klic_+3A_globalmaxk">globalMaxK</code></td>
<td>
<p>Maximum number of clusters considered for the final
clustering. Default is 6.</p>
</td></tr>
<tr><td><code id="klic_+3A_b">B</code></td>
<td>
<p>Number of iterations for consensus clustering. Default is 1000.</p>
</td></tr>
<tr><td><code id="klic_+3A_c">C</code></td>
<td>
<p>Maximum number of iterations for localised kernel k-means. Default
is 100.</p>
</td></tr>
<tr><td><code id="klic_+3A_scale">scale</code></td>
<td>
<p>Boolean. If TRUE, each dataset is scaled such that each column
has zero mean and unitary variance.</p>
</td></tr>
<tr><td><code id="klic_+3A_savepng">savePNG</code></td>
<td>
<p>Boolean. If TRUE, a plot of the silhouette is saved in the
working folder. Default is FALSE.</p>
</td></tr>
<tr><td><code id="klic_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the name of the png file.
Can be used to specify the folder path too. Default is &quot;klic&quot;.</p>
</td></tr>
<tr><td><code id="klic_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Default is TRUE.</p>
</td></tr>
<tr><td><code id="klic_+3A_annotations">annotations</code></td>
<td>
<p>Data frame containing annotations for final plot.</p>
</td></tr>
<tr><td><code id="klic_+3A_ccclmethods">ccClMethods</code></td>
<td>
<p>The i-th element of this vector goes into the
<code>clMethod</code> argument of consensusCluster() for the i-th dataset. If only
one string is provided, then the same method is used for all datasets.</p>
</td></tr>
<tr><td><code id="klic_+3A_ccdisthcs">ccDistHCs</code></td>
<td>
<p>The i-th element of this vector goes into the <code>dist</code>
argument of <code>consensusCluster()</code> for the i-th dataset.</p>
</td></tr>
<tr><td><code id="klic_+3A_widestgap">widestGap</code></td>
<td>
<p>Boolean. If TRUE, compute also widest gap index to choose
best number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="klic_+3A_dunns">dunns</code></td>
<td>
<p>Boolean. If TRUE, compute also Dunn's index to choose best
number of clusters. Default is FALSE.</p>
</td></tr>
<tr><td><code id="klic_+3A_dunn2s">dunn2s</code></td>
<td>
<p>Boolean. If TRUE, compute also alternative Dunn's index to
choose best number of clusters. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list contatining:
</p>
<table>
<tr><td><code>consensusMatrices</code></td>
<td>
<p>an array containing one consensus matrix per data
set.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a vector containing the weights assigned by the
kernel k-means algorithm to each consensus matrix.</p>
</td></tr>
<tr><td><code>weightedKM</code></td>
<td>
<p>the weighted kernel matrix obtained by taking a weighted
sum of all kernels, where the weights are those specified in the
<code>weights</code> matrix.</p>
</td></tr>
<tr><td><code>globalClusterLabels</code></td>
<td>
<p>a vector containing the cluster labels
of the observations, according to kernel k-means clustering done on the
kernel matrices.</p>
</td></tr>
<tr><td><code>bestK</code></td>
<td>
<p>a vector containing the best number of clusters between 2 and
<code>maxIndividualK</code> for each kernel. These are chosen so as to maximise the
silhouette and only returned if the number of clusters <code>individualK</code>
is not provided.</p>
</td></tr>
<tr><td><code>globalK</code></td>
<td>
<p>the
best number of clusters for the final (global) clustering. This is chosen so
as to maximise the silhouette and only returned if the final number of
clusters <code>globalK</code> is not provided.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Cabassi, A. and Kirk, P. D. W. (2019). Multiple kernel learning
for integrative consensus clustering of genomic datasets. arXiv preprint.
arXiv:1904.07701.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("Rmosek", quietly = TRUE) &amp;&amp;
(!is.null(utils::packageDescription("Rmosek")$Configured.MSK_VERSION))){

# Load synthetic data
data1 &lt;- as.matrix(read.csv(system.file('extdata',
'dataset1.csv', package = 'klic'), row.names = 1))
data2 &lt;- as.matrix(read.csv(system.file('extdata',
'dataset2.csv', package = 'klic'), row.names = 1))
data3 &lt;- as.matrix(read.csv(system.file('extdata',
'dataset3.csv', package = 'klic'), row.names = 1))
data &lt;- list(data1, data2, data3)

# Perform clustering with KLIC assuming to know the
# number of clusters in each individual dataset and in
# the final clustering
klicOutput &lt;- klic(data, 3, individualK = c(4, 4, 4),
globalK = 4, B = 30, C = 5)

# Extract cluster labels
klic_labels &lt;- klicOutput$globalClusterLabels

cluster_labels &lt;- as.matrix(read.csv(system.file('extdata',
'cluster_labels.csv', package = 'klic'), row.names = 1))
# Compute ARI
ari &lt;- mclust::adjustedRandIndex(klic_labels, cluster_labels)
}
</code></pre>

<hr>
<h2 id='lmkkmeans'>Localised multiple kernel k-means</h2><span id='topic+lmkkmeans'></span>

<h3>Description</h3>

<p>Perform the training step of the localised multiple kernel k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmkkmeans(Km, parameters, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmkkmeans_+3A_km">Km</code></td>
<td>
<p>An array of size N x N x M containing M different N x N kernel
matrices.</p>
</td></tr>
<tr><td><code id="lmkkmeans_+3A_parameters">parameters</code></td>
<td>
<p>A list of parameters containing the desired number of
clusters, <code>cluster_count</code>, and the number of iterations of the
algorithm to be run, <code>iteration_count</code>.</p>
</td></tr>
<tr><td><code id="lmkkmeans_+3A_verbose">verbose</code></td>
<td>
<p>Boolean flag. If TRUE, at each iteration the iteration number
is printed. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list containing:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>the cluster labels for each element (i.e. row/column) of
the kernel matrix.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function for the given
clustering.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>same parameters as in the input.</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>N x M matrix of weights, each row corresponds to an observation
and each column to one of the kernels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Gonen
</p>


<h3>References</h3>

<p>Gonen, M. and Margolin, A.A., 2014. Localized data fusion for
kernel k-means clustering with application to cancer biology. In Advances in
Neural Information Processing Systems (pp. 1305-1313).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("Rmosek", quietly = TRUE) &amp;&amp;
(!is.null(utils::packageDescription("Rmosek")$Configured.MSK_VERSION))){

# Initialise 100 x 100 x 3 array containing M kernel matrices
# representing three different types of similarities between 100 data points
km &lt;- array(NA, c(100, 100, 3))
# Load kernel matrices
km[,,1] &lt;- as.matrix(read.csv(system.file('extdata',
'kernel_matrix1.csv', package = 'klic'), row.names = 1))
km[,,2] &lt;- as.matrix(read.csv(system.file('extdata',
'kernel_matrix2.csv', package = 'klic'), row.names = 1))
km[,,3] &lt;- as.matrix(read.csv(system.file('extdata',
'kernel_matrix3.csv', package = 'klic'), row.names = 1))

# Initalize the parameters of the algorithm
parameters &lt;- list()
# Set the number of clusters
parameters$cluster_count &lt;- 4
# Set the number of iterations
parameters$iteration_count &lt;- 10

# Perform training
state &lt;- lmkkmeans(km, parameters)

# Display the clustering
print(state$clustering)
# Display the kernel weights
print(state$Theta)
}
</code></pre>

<hr>
<h2 id='lmkkmeans_missingData'>Localised multiple kernel k-means</h2><span id='topic+lmkkmeans_missingData'></span>

<h3>Description</h3>

<p>Perform the training step of the localised multiple kernel k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmkkmeans_missingData(Km, parameters, missing = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmkkmeans_missingData_+3A_km">Km</code></td>
<td>
<p>Array of size N X N X M containing M  different N x N kernel
matrices.</p>
</td></tr>
<tr><td><code id="lmkkmeans_missingData_+3A_parameters">parameters</code></td>
<td>
<p>A list of parameters containing the desired number of
clusters, <code>cluster_count</code>, and the number of iterations of the
algorithm to be run, <code>iteration_count</code>.</p>
</td></tr>
<tr><td><code id="lmkkmeans_missingData_+3A_missing">missing</code></td>
<td>
<p>Matrix of size N X M containing missingness indicators, i.e.
missing[i,j] = 1 (or = TRUE) if observation <code>i</code> is missing in dataset
<code>j</code>, missing[i,j] = 0 (or = FALSE).</p>
</td></tr>
<tr><td><code id="lmkkmeans_missingData_+3A_verbose">verbose</code></td>
<td>
<p>Boolean flag. If TRUE, at each iteration the iteration number
is printed. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list containing:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>the cluster labels for each element (i.e. row/column) of
the kernel matrix.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function for the given
clustering.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>same parameters as in the input.</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>N x M matrix of weights, each row corresponds to an observation
and each column to one of the kernels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Gonen, Alessandra Cabassi
</p>


<h3>References</h3>

<p>Gonen, M. and Margolin, A.A., 2014. Localized data fusion for
kernel k-means clustering with application to cancer biology. In Advances in
Neural Information Processing Systems (pp. 1305-1313).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("Rmosek", quietly = TRUE) &amp;&amp;
(!is.null(utils::packageDescription("Rmosek")$Configured.MSK_VERSION))){

# Intialise 100 x 100 x 3 array containing M kernel matrices
# representing three different types of similarities between 100 data points
km &lt;- array(NA, c(100, 100, 3))
# Load kernel matrices
km[,,1] &lt;- as.matrix(read.csv(system.file('extdata',
'kernel_matrix1.csv', package = 'klic'), row.names = 1))
km[,,2] &lt;- as.matrix(read.csv(system.file('extdata',
'kernel_matrix2.csv', package = 'klic'), row.names = 1))
km[,,3] &lt;- as.matrix(read.csv(system.file('extdata',
'kernel_matrix3.csv', package = 'klic'), row.names = 1))
# Introduce some missing data
km[76:80, , 1] &lt;- NA
km[, 76:80, 1] &lt;- NA

# Define missingness indicators
missing &lt;- matrix(FALSE, 100, 3)
missing[76:80,1] &lt;- TRUE

# Initalize the parameters of the algorithm
parameters &lt;- list()
# Set the number of clusters
parameters$cluster_count &lt;- 4
# Set the number of iterations
parameters$iteration_count &lt;- 10

# Perform training
state &lt;- lmkkmeans_missingData(km, parameters, missing)

# Display the clustering
print(state$clustering)
# Display the kernel weights
print(state$Theta)
}
</code></pre>

<hr>
<h2 id='plotSimilarityMatrix'>Plot similarity matrix with pheatmap</h2><span id='topic+plotSimilarityMatrix'></span>

<h3>Description</h3>

<p>Plot similarity matrix with pheatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSimilarityMatrix(
  X,
  y = NULL,
  clusLabels = NULL,
  colX = NULL,
  colY = NULL,
  myLegend = NULL,
  fileName = "posteriorSimilarityMatrix",
  savePNG = FALSE,
  semiSupervised = FALSE,
  showObsNames = FALSE,
  clr = FALSE,
  clc = FALSE,
  plotWidth = 500,
  plotHeight = 450
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSimilarityMatrix_+3A_x">X</code></td>
<td>
<p>Similarity matrix.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_y">y</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_cluslabels">clusLabels</code></td>
<td>
<p>Cluster labels</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_colx">colX</code></td>
<td>
<p>Colours for the matrix</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_coly">colY</code></td>
<td>
<p>Colours for the response</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_mylegend">myLegend</code></td>
<td>
<p>Vector of strings with the names of the variables</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_filename">fileName</code></td>
<td>
<p>If <code>savePNG</code> is TRUE, this is the string containing the
name of the output file. Can be used to specify the folder path too. Default
is &quot;posteriorSimilarityMatrix&quot;. The extension &quot;.png&quot; is automatically added
to this string.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_savepng">savePNG</code></td>
<td>
<p>Boolean: if TRUE, the plot is saved as a png file. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_semisupervised">semiSupervised</code></td>
<td>
<p>Boolean flag: if TRUE, the response is plotted next to
the matrix.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_showobsnames">showObsNames</code></td>
<td>
<p>Boolean. If TRUE, observation names are shown in the
plot. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_clr">clr</code></td>
<td>
<p>Boolean. If TRUE, rows are ordered by hierarchical clustering.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_clc">clc</code></td>
<td>
<p>Boolean. If TRUE, columns are ordered by hierarchical clustering.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_plotwidth">plotWidth</code></td>
<td>
<p>Plot width. Default is 500.</p>
</td></tr>
<tr><td><code id="plotSimilarityMatrix_+3A_plotheight">plotHeight</code></td>
<td>
<p>Plot height. Default is 450.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function plots the similarity matrix either
to screen or to a png file.
</p>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load one dataset with 100 observations, 2 variables, 4 clusters
data &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "klic"), row.names = 1))
# Load cluster labels
cluster_labels &lt;- as.matrix(read.csv(system.file("extdata",
"cluster_labels.csv", package = "klic"), row.names = 1))

# Compute consensus clustering with K=4 clusters
cm &lt;- coca::consensusCluster(data, 4)

# Plot consensus (similarity) matrix
plotSimilarityMatrix(cm)

# Plot consensus (similarity) matrix with response
names(cluster_labels) &lt;- as.character(1:100)
rownames(cm) &lt;- names(cluster_labels)
plotSimilarityMatrix(cm, y = cluster_labels)
</code></pre>

<hr>
<h2 id='spectrumShift'>Spectrum shift</h2><span id='topic+spectrumShift'></span>

<h3>Description</h3>

<p>Make a symmetric matrix positive semi-definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrumShift(kernelMatrix, coeff = 1.2, shift = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrumShift_+3A_kernelmatrix">kernelMatrix</code></td>
<td>
<p>symmetric matrix</p>
</td></tr>
<tr><td><code id="spectrumShift_+3A_coeff">coeff</code></td>
<td>
<p>Coefficient by which the minimum eigenvalue is multiplied when
shifting the eigenvalues, in order to avoid numeric problems. Default is 1.2.</p>
</td></tr>
<tr><td><code id="spectrumShift_+3A_shift">shift</code></td>
<td>
<p>Value of the constant added to the diagonal, if known a priori.
Default is NULL.</p>
</td></tr>
<tr><td><code id="spectrumShift_+3A_verbose">verbose</code></td>
<td>
<p>Boolean flag: if TRUE, information about the shift is printed
to screen. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the matrix <code>kernelMatrix</code> after applying
the required spectrum shift.
</p>


<h3>Author(s)</h3>

<p>Alessandra Cabassi <a href="mailto:alessandra.cabassi@mrc-bsu.cam.ac.uk">alessandra.cabassi@mrc-bsu.cam.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load one dataset with 300 observations, 2 variables, 6 clusters
data &lt;- as.matrix(read.csv(system.file("extdata", "dataset1.csv",
package = "klic"), row.names = 1))

# Compute consensus clustering with K=4 clusters
cm &lt;- coca::consensusCluster(data, 4)

# Shift eigenvalues of the matrix by a constant: (min eigenvalue) * (coeff)
km &lt;- spectrumShift(cm, coeff = 1.05)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
