<!DOCTYPE html><html><head><title>Help for package nseval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nseval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arg'><p>Capture lazy variables as quotations.</p></a></li>
<li><a href='#arg_env'><p>Get information about currently bound arguments.</p></a></li>
<li><a href='#as.dots'><p>Convert items into quotations or dots.</p></a></li>
<li><a href='#as.lazy_dots.dots'><p>Compatibility conversions.</p></a></li>
<li><a href='#caller'><p>Find the caller of a given environment.</p></a></li>
<li><a href='#do'><p>Making function calls, with full control of argument scope.</p></a></li>
<li><a href='#dots'><p>Dots objects: lists of quotations.</p></a></li>
<li><a href='#dots2env'><p>Make or update an environment with bindings from a dots list.</p></a></li>
<li><a href='#env2dots'><p>Copy bindings from an environment into a dots object, or vice versa.</p></a></li>
<li><a href='#forced'><p>Forcing and forcedness of arguments and quotations.</p></a></li>
<li><a href='#format.dots'><p>Formatting methods for dots and quotations.</p></a></li>
<li><a href='#function_'><p>Explicitly create closures.</p></a></li>
<li><a href='#get_call'><p>Get information about currently executing calls.</p></a></li>
<li><a href='#get_dots'><p>Set or get the contents of <code>...</code>.</p></a></li>
<li><a href='#locate'><p>Find the environment which defines a name.</p></a></li>
<li><a href='#missing_value'><p>R's missing value.</p></a></li>
<li><a href='#quo'><p>Quotation objects.</p></a></li>
<li><a href='#set_'><p>Assign values to variables.</p></a></li>
<li><a href='#unwrap'><p>Unwrap variable references.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Lazy and Non-Standard Evaluation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Meilstrup &lt;peter.meilstrup@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Meilstrup &lt;peter.meilstrup@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to capture, inspect, manipulate, and create
             lazy values (promises), "..." lists, and active calls.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), compiler (&ge; 3.4), roxygen2 (&ge; 2.2.2),
knitr (&ge; 1.2), plyr (&ge; 1.8.1), lazyeval (&ge; 0.2.0), stringr
(&ge; 1.2.0), rlang, covr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'arg.R' 'caller.R' 'quo.R' 'dots.R' 'getpromise.R'
'conversions.R' 'format.R' 'force.R' 'shortcut.R' 'missing.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 00:08:34 UTC; peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 05:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='arg'>Capture lazy variables as quotations.</h2><span id='topic+arg'></span><span id='topic+arg_'></span><span id='topic+arg_list'></span><span id='topic+arg_list_'></span><span id='topic+set_arg'></span><span id='topic+set_arg_'></span>

<h3>Description</h3>

<p><code>arg(x)</code> looks in the calling environment for the binding <code>x</code>,
taken literally, and returns it as a <a href="#topic+quotation">quotation</a>. <code>arg(x)</code> is
equivalent to <code>unwrap(quo(x))</code>.
</p>
<p><code>arg_</code> evaluates the first element normally;
<code>arg(x, e)</code> is equivalent to <code>arg_(quote(x), e)</code>.
</p>
<p><code>arg_list</code> looks up multiple variables, and returns a <a href="#topic+dots">dots</a>
object.  <code>arg_list(x, y)</code> is equivalent to <code>unwrap(dots(x=x, y=y))</code>. If any of the requested variables are not bound, an error
will be raised.
</p>
<p><code>arg_list_</code> is a normally evaluating version of <code>arg_list</code>;
<code>arg_list(x, y)</code> is equivalent to
<code>arg_list_(alist(x, y), environment())</code>.
</p>
<p><code>set_arg</code> and set_arg_ create bindings from quotations. They
replace base function <a href="base.html#topic+delayedAssign">delayedAssign</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg(sym, env = arg_env_(quote(sym), environment()))

arg_(sym, env = arg_env(sym, environment()))

arg_list(...)

arg_list_(syms, envs)

set_arg(dst, src)

set_arg_(dst, src)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg_+3A_sym">sym</code></td>
<td>
<p>The name to look up. For <code>arg</code> this is a literal name,
not evaluated. For <code>arg_</code> this should evaluate to a symbol or
character.</p>
</td></tr>
<tr><td><code id="arg_+3A_env">env</code></td>
<td>
<p>The environment to look in. By default, the environment
from which <code>sym</code> was passed.</p>
</td></tr>
<tr><td><code id="arg_+3A_...">...</code></td>
<td>
<p>Bare names (not forced). Arguments may be named; these
names determine the names on the output list. If arguments are
not named, the names given are used.</p>
</td></tr>
<tr><td><code id="arg_+3A_syms">syms</code></td>
<td>
<p>A character vector or list of names.</p>
</td></tr>
<tr><td><code id="arg_+3A_envs">envs</code></td>
<td>
<p>An environment, or a list of environments, to look for
the bindings in.</p>
</td></tr>
<tr><td><code id="arg_+3A_dst">dst</code></td>
<td>
<p>A name; for <code>set_arg</code> this is quoted literally; for
<code>set_arg_</code> this should be a <a href="#topic+quotation">quotation</a>.</p>
</td></tr>
<tr><td><code id="arg_+3A_src">src</code></td>
<td>
<p>A <a href="#topic+quotation">quotation</a> (or something that can be converted to a
quotation, like a formula).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>arg</code> returns a <a href="#topic+quotation">quotation</a> object.
</p>
<p><code>args</code> returns a <a href="#topic+dots">dots</a> object.
</p>
<p><code>arg_list</code> returns a <a href="#topic+dots">dots</a> object.
</p>


<h3>Note</h3>

<p>If you use a a literal character value, as in <code>arg_("x", environment())</code>, you MUST also give the environment
parameter. The reason is that R will discard scope information
about code literals in byte-compiled code; so when <code>arg_("x")</code> is
called in compiled code, the default value for <code>env</code> will be
found to be <code><a href="base.html#topic+emptyenv">emptyenv()</a></code>.
</p>
<p>Beware of writing <code>arg_list(a, b, ...)</code> which probably
doesn't do what you want. This is because R unwraps <code>...</code> before
invoking <code>arg_list</code>, so this ends up double-unwrapping <code>...</code>. To
capture <code>...</code> alongside named arguments you can use the syntax
<code>arg_list(x, y, (...))</code> (which is equivalent to <code>c(arg_list(x, y), dots(...))</code>). You can also use <code><a href="#topic+get_call">get_call()</a></code> to extract all
function inputs to an active function.
</p>


<h3>See Also</h3>

<p>dots get_dots unwrap
</p>

<hr>
<h2 id='arg_env'>Get information about currently bound arguments.</h2><span id='topic+arg_env'></span><span id='topic+arg_env_'></span><span id='topic+arg_expr'></span><span id='topic+arg_expr_'></span><span id='topic+arg_value'></span><span id='topic+arg_value_'></span><span id='topic+dots_envs'></span><span id='topic+dots_exprs'></span><span id='topic+is_forced'></span><span id='topic+is_forced_'></span><span id='topic+is_literal'></span><span id='topic+is_literal_'></span><span id='topic+is_missing'></span><span id='topic+is_missing_'></span><span id='topic+is_missing_.quotation'></span><span id='topic+is_promise'></span><span id='topic+is_promise_'></span><span id='topic+is_promise_.quotation'></span><span id='topic+is_default'></span><span id='topic+is_default_'></span><span id='topic+is_default_.quotation'></span>

<h3>Description</h3>

<p>These are shortcut methods for querying current bindings.  For
example, <code>arg_env(x)</code> is equivalent to <code>env(arg(x))</code>,
<code>is_forced(x, y)</code> is equivalent to <code>forced(arg_list(x,y))</code>,
<code>dots_exprs(...)</code> is equivalent to <code>exprs(dots(...))</code>, and so
on. The shortcut forms skip the construction of the
intermediate <a href="#topic+quotation">quotation</a> objects.
</p>
<p><code>dots_exprs(...)</code> quotes its arguments and returns a
list of expressions. It is equivalent to <code>exprs(dots(...))</code> (and
is nearly equivalent to <code>alist(...)</code>, one difference being that
dots_exprs will expand <code>...</code>.)
</p>
<p><code>is_literal(x)</code> returns TRUE if an argument <code>x</code> could be a
source literal. Specifically it tests whether <code>x</code> is bound to a
singleton vector or a <a href="#topic+missing_value">missing_value</a>. This check happens without
forcing <code>x</code>.
</p>
<p><code>is_missing(...)</code> checks whether an argument is
missing, without forcing. It is similar to <a href="base.html#topic+missing">missing</a> but can take
multiple arguments, and can be called in more situations, such as
from a nested inner function.
</p>
<p><code>is_missing_(syms, envs)</code> is a normally evaluating version
of is_missing.  <code>syms</code> should be a symbol, character vector or
list of such. <code>envs</code> should be an environment, or list of
environments. Vector recycling rules apply, so you can call with
a vector of names and one env, or vice versa.
</p>
<p><code>is_promise</code> returns TRUE if the given variable is bound to
a promise. Not all arguments are bound to promises; byte-compiled
code often omits creating a promise for literal or missing arguments.
</p>
<p><code>is_default</code>  determines whether an argument is bound to the
function's default value for that argument. It must be called
before the arguments have been forced (afterwards it will return
FALSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg_env(sym, env = arg_env_(quote(sym), environment()))

arg_env_(sym, env = arg_env_(quote(sym), environment()))

arg_expr(sym, env = arg_env_(quote(sym), environment()))

arg_expr_(sym, env = arg_env_(quote(sym), environment()))

arg_value(
  sym,
  env = arg_env_(quote(sym), environment()),
  ifnotforced = stop("Variable is not forced, so has no value")
)

arg_value_(
  sym,
  env = arg_env_(quote(sym), environment()),
  ifnotforced = stop("Variable is not forced, so has no value")
)

dots_envs(...)

dots_exprs(...)

is_forced(...)

is_forced_(syms, envs)

is_literal(...)

is_literal_(syms, envs)

is_missing(...)

is_missing_(syms, envs, unwrap = TRUE)

## S3 method for class 'quotation'
is_missing_(syms, ..., unwrap = TRUE)

is_promise(...)

is_promise_(syms, envs)

## S3 method for class 'quotation'
is_promise_(syms, ...)

is_default(...)

is_default_(syms, envs)

## S3 method for class 'quotation'
is_default_(syms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg_env_+3A_sym">sym</code></td>
<td>
<p>For plain <code>arg_env</code>, etc, a bare name, which is
quoted. For the underscore versions <code>arg_env_</code>, something that
evaluates to a name or character.</p>
</td></tr>
<tr><td><code id="arg_env_+3A_env">env</code></td>
<td>
<p>The environment to search in.</p>
</td></tr>
<tr><td><code id="arg_env_+3A_ifnotforced">ifnotforced</code></td>
<td>
<p>What to return if calling arg_value on a promise
that has not been forced.</p>
</td></tr>
<tr><td><code id="arg_env_+3A_...">...</code></td>
<td>
<p>Bare variable names (for <code style="white-space: pre;">&#8288;is_*&#8288;</code>) or expressions (for
<code style="white-space: pre;">&#8288;dots_*&#8288;</code>). Not forced.</p>
</td></tr>
<tr><td><code id="arg_env_+3A_syms">syms</code></td>
<td>
<p>A character vector or list of symbols.</p>
</td></tr>
<tr><td><code id="arg_env_+3A_envs">envs</code></td>
<td>
<p>An environment or list of environments.</p>
</td></tr>
<tr><td><code id="arg_env_+3A_unwrap">unwrap</code></td>
<td>
<p>Whether to recursively <a href="#topic+unwrap">unwrap</a> before testing for
missingness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Throughout this package, some functions come in two forms, a &quot;bare&quot;
version which quotes its first argument literally, and a
normally-evaluating version with a trailing underscore in its
name. So <code>is_forced(x)</code> chiecks whether &quot;x&quot; is a missing variable,
while <code>is_forced_(x, environment())</code> checks whether &quot;x&quot; contains
the <em>name</em> of another variable which is missing. The following are
all equivalent:
</p>

<ul>
<li> <p><code>arg_env(x)</code>
</p>
</li>
<li> <p><code>{y &lt;- quo(x); arg_env_(y)}</code>
</p>
</li>
<li> <p><code>arg_env_(quote(x), environment())</code>
</p>
</li>
<li> <p><code>arg_env_(quo(x))</code>
</p>
</li>
<li> <p><code>env(arg_(quo(x)))</code>.
</p>
</li></ul>

<p>When used with quotation objects, the <code style="white-space: pre;">&#8288;is_*_&#8288;</code> functions
with trailing underscore work at one level of indirection
compared to quotation methods. For example, <code>missing_(x)</code> tests
whether <code>expr(x)</code> is <code style="white-space: pre;">&#8288;[missing_value()]&#8288;</code>, whereas <code>is_missing_(x)</code>
assumes <code>expr(x)</code> is a <em>name</em> and checks if that name refers to a
variable that is missing. The following are equivalent:
</p>

<ul>
<li> <p><code>is_missing(x)</code>
</p>
</li>
<li> <p><code>is_missing_(quo(x))</code>
</p>
</li>
<li> <p><code>missing_(arg(x))</code>
</p>
</li></ul>

<p>When used with a <code>quotation</code> or <code>dots</code>, is_missing(q)
looks for the variable(s) specified by expr(q) in environment env(q)]'.
</p>


<h3>Value</h3>

<p><code>arg_env</code> returns an environment.
</p>
<p><code>arg_expr</code> returns the expression bound to a named argument.
</p>
<p><code>arg_value</code> returns the value bound to a named argument.
</p>
<p><code>is_forced</code> and other <code style="white-space: pre;">&#8288;is_*&#8288;</code> return a logical vector with
optional names.
</p>

<hr>
<h2 id='as.dots'>Convert items into quotations or dots.</h2><span id='topic+as.dots'></span><span id='topic+as.dots.dots'></span><span id='topic+as.dots.quotation'></span><span id='topic+as.dots.list'></span><span id='topic+as.dots.environment'></span><span id='topic+as.dots.lazy_dots'></span><span id='topic+as.dots.default'></span>

<h3>Description</h3>

<p><code>as.dots</code> is a generic function for converting data into <a href="#topic+dots">dots</a>.
</p>
<p><code>as.dots.environment</code> is a synonym for <code><a href="#topic+env2dots">env2dots</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dots(x)

## S3 method for class 'dots'
as.dots(x)

## S3 method for class 'quotation'
as.dots(x)

## S3 method for class 'list'
as.dots(x)

## S3 method for class 'environment'
as.dots(x)

## S3 method for class 'lazy_dots'
as.dots(x)

## Default S3 method:
as.dots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dots_+3A_x">x</code></td>
<td>
<p>a vector or list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>...</code>.
</p>


<h3>See Also</h3>

<p>env2dots
rdname dots2env
</p>

<hr>
<h2 id='as.lazy_dots.dots'>Compatibility conversions.</h2><span id='topic+as.lazy_dots.dots'></span><span id='topic+as.lazy.quotation'></span><span id='topic+as.quo.quosure'></span><span id='topic+as.quo.formula'></span><span id='topic+as.quosure.quo'></span><span id='topic+as.quosures.dots'></span>

<h3>Description</h3>

<p>Convert quotations and dot lists to representations used
by some other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lazy_dots.dots(x, env = "ignored")

as.lazy.quotation(x, env = "ignored")

## S3 method for class 'quosure'
as.quo(x)

## S3 method for class 'formula'
as.quo(x)

as.quosure.quo(x)

as.quosures.dots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lazy_dots.dots_+3A_x">x</code></td>
<td>
<p>an object to convert.</p>
</td></tr>
<tr><td><code id="as.lazy_dots.dots_+3A_env">env</code></td>
<td>
<p>Ignored for quotations or dots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted object.
</p>

<hr>
<h2 id='caller'>Find the caller of a given environment.</h2><span id='topic+caller'></span>

<h3>Description</h3>

<p>Given an environment that is currently on the stack, <code>caller</code>
determines the calling environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caller(
  env = caller(environment()),
  ifnotfound = stop("caller: environment not found on stack"),
  n = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caller_+3A_env">env</code></td>
<td>
<p>The environment whose caller to find. The default is
<code>caller</code>'s caller; that is, <code>caller()</code> should return the the same
value as <code>caller(environment())</code>.)</p>
</td></tr>
<tr><td><code id="caller_+3A_ifnotfound">ifnotfound</code></td>
<td>
<p>What to return in case the caller cannot be
determined. By default an error is raised.</p>
</td></tr>
<tr><td><code id="caller_+3A_n">n</code></td>
<td>
<p>How many levels to work up the stack.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, in the code:
</p>
<div class="sourceCode"><pre>X &lt;- environment()
F &lt;- function() {
  Y &lt;- environment()
  caller(Y)
}
F()
</pre></div>
<p>the environment called <code>Y</code> was created by calling <code>F()</code>, and that
call occurs in the environment called <code>X</code>. In this case <code>X</code> is the
calling environment of <code>Y</code>, so <code>F()</code> returns the same environment
as <code>X()</code>.
</p>
<p><code>caller</code> is intended as a replacement for <a href="base.html#topic+parent.frame">parent.frame</a>, which
returns the next environment up the calling stack &ndash; which is
sometimes the same value, but differs in some situations, such as
when lazy evaluation re-activates an environment. <code>parent.frame()</code>
can return different things depending on the order in which
arguments are evaluated, without warning. <code>caller</code> will by default
throw an error if the caller cannot be determined.
</p>
<p>In addition, <code>caller</code> tries to do the right thing when the
environment was instantiated by means of <code>do.call</code>, <a href="base.html#topic+eval">eval</a> or
<a href="#topic+do">do</a> rather than an ordinary function call.
</p>


<h3>Value</h3>

<p>The environment which called <code>env</code> into being. If that
environment cannot be determined, <code>ifnotfound</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E &lt;- environment()
F &lt;- function() {
 Y &lt;- environment()
 caller(Y)
}
identical(F(), E) ## TRUE
</code></pre>

<hr>
<h2 id='do'>Making function calls, with full control of argument scope.</h2><span id='topic+do'></span><span id='topic+do_'></span>

<h3>Description</h3>

<p>The functions <code>do</code> and <code>do_</code> construct and invoke a function call.
In combination with <a href="#topic+dots">dots</a> and <a href="#topic+quotation">quotation</a> objects they allow you
to control the scope of the function call and each of its arguments
independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do(...)

do_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_+3A_...">...</code></td>
<td>
<p>A function to call and list(s) of arguments to pass. All
should be <code>quotation</code> or <code>dots</code> objects, except the first
argument for <code>do</code> which is quoted literally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>do_</code> all arguments should be <code>quotation</code> or <code>dots</code> objects, or
convertible to such using <code>as.quo()</code>. They will be concatenated
together by <a href="#topic+c.dots">c.dots</a> to form the call list (a <code>dots</code> object).
For <code>do</code> the first argument is quoted literally, but the
rest of the arguments are evaluated the same way as <code>do_</code>.
</p>
<p>The head, or first element of the call list, represents the
function, and it should evaluate to a function object. The rest of
the call list is used as that function's arguments.
</p>
<p>When a quotation is used as the first element, the call is evaluated
from the environment given in that quotation. This means that calls
to <code><a href="#topic+caller">caller()</a></code> (or <code>parent.frame()</code>) from within that function
should return that environment.
</p>
<p><code>do</code> is intended to be a replacement for base function <a href="base.html#topic+do.call">do.call</a>.
For instance these two lines are similar in effect:
</p>
<div class="sourceCode"><pre>do.call("complex", list(imaginary = 1:3))
do(complex, dots(imaginary = 1:3))
</pre></div>
<p>As are all these:
</p>
<div class="sourceCode"><pre>do.call("f", list(as.name("A")), envir = env)
do_(quo(f, env), quo(A, env)):
do_(dots_(list(as.name("f"), as.name("A")), env))
do_(dots_(alist(f, A), env))
</pre></div>


<h3>Value</h3>

<p>The return value of the call.
</p>


<h3>Note</h3>

<p>When the environment of the call head differs from that of
the arguments, <code>do</code> may make a temporary binding of <code>...</code> to pass
arguments. This will cause some primitive functions, like (
<code><a href="base.html#topic++3C-">&lt;-</a></code>, or <code><a href="base.html#topic+for">for</a></code>), to fail with an error like
&quot;'...' used an in incorrect context,&quot; because these primitives do
not understand how to unpack <code>...</code>. To avoid the use of <code>...</code>,
ensure that all args have the same environment as the call head,
or are forced.
</p>
<p>For the specific case of calling <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>, you can use <code><a href="#topic+set_">set_</a></code> to
make assignments.
</p>


<h3>See Also</h3>

<p>get_call do.call match.call set_
</p>

<hr>
<h2 id='dots'>Dots objects: lists of quotations.</h2><span id='topic+dots'></span><span id='topic+dots_'></span><span id='topic+exprs'></span><span id='topic+exprs.dots'></span><span id='topic+exprs+3C-'></span><span id='topic+exprs+3C-.dots'></span><span id='topic+envs'></span><span id='topic+envs.dots'></span><span id='topic+envs+3C-'></span><span id='topic++5B.dots'></span><span id='topic++5B+3C-.dots'></span><span id='topic+c.dots'></span><span id='topic+c.quotation'></span><span id='topic+as.data.frame.dots'></span><span id='topic+forced_dots'></span><span id='topic+forced_dots_'></span>

<h3>Description</h3>

<p><code>d &lt;- dots(a = one, b = two)</code> captures each of its arguments,
unevaluated, in a dots object (a named list of <a href="#topic+quotation">quotation</a>s).
</p>
<p><code>as.data.frame.dots</code> transforms the contents of a <a href="#topic+dots">dots</a> object
into a data frame with one row per <a href="#topic+quotation">quotation</a>, with columns:
</p>

<ul>
<li> <p><code>name</code>: a character,
</p>
</li>
<li> <p><code>expr</code>: an expression,
</p>
</li>
<li> <p><code>env</code>: an <a href="base.html#topic+environment">environment</a> object or NULL if <a href="#topic+forced">forced</a>,
</p>
</li>
<li> <p><code>value</code>: NULL or a value if forced.
</p>
</li></ul>

<p><code>forced_dots(...)</code> forces its arguments and constructs a <code>dots</code> object with
<a href="#topic+forced">forced</a> quotations.
</p>
<p><code>forced_dots_(values)</code> creates a dots object from a list of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots(...)

dots_(exprs, envs)

exprs(d)

## S3 method for class 'dots'
exprs(d)

exprs(d) &lt;- value

## S3 replacement method for class 'dots'
exprs(d) &lt;- value

envs(d)

## S3 method for class 'dots'
envs(d)

envs(d) &lt;- value

## S3 method for class 'dots'
x[..., drop = FALSE]

## S3 replacement method for class 'dots'
x[...] &lt;- value

## S3 method for class 'dots'
c(...)

## S3 method for class 'quotation'
c(...)

## S3 method for class 'dots'
as.data.frame(x, row.names = NULL, ...)

forced_dots(...)

forced_dots_(values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_+3A_...">...</code></td>
<td>
<p>Any number of arguments.</p>
</td></tr>
<tr><td><code id="dots_+3A_exprs">exprs</code></td>
<td>
<p>An expression or list of expressions.</p>
</td></tr>
<tr><td><code id="dots_+3A_envs">envs</code></td>
<td>
<p>An environment or list of environments.</p>
</td></tr>
<tr><td><code id="dots_+3A_d">d</code></td>
<td>
<p>A <a href="#topic+dots">dots</a> object.</p>
</td></tr>
<tr><td><code id="dots_+3A_value">value</code></td>
<td>
<p>A replacement value or list of values.</p>
</td></tr>
<tr><td><code id="dots_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+dots">dots</a></code> object.</p>
</td></tr>
<tr><td><code id="dots_+3A_drop">drop</code></td>
<td>
<p>See <a href="base.html#topic+Extract">Extract</a>.</p>
</td></tr>
<tr><td><code id="dots_+3A_row.names">row.names</code></td>
<td>
<p>If not given, uses <code>make.unique(x$name)</code></p>
</td></tr>
<tr><td><code id="dots_+3A_values">values</code></td>
<td>
<p>A list; each element will be used as data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class &quot;dots&quot; mirror R's special variable <code>...</code>.
Unlike <code>...</code>, a <code>dots</code> is:
</p>

<ul>
<li><p> immutable (evaluating does not change it),
</p>
</li>
<li><p> first-class (you can give it any name, not just <code>...</code>),
</p>
</li>
<li><p> data (The R interpreter treates it as literal data rather
than triggering argument splicing).
</p>
</li></ul>

<p><code>d &lt;- dots(...)</code> is used to capture the contents of <code>...</code> without
triggering evaluation. This improves on
<code>as.list(substitute(...()))</code> by capturing the environment of each
argument along with their expressions. (You can also use
<code><a href="#topic+get_dots">get_dots()</a></code>.)
</p>


<h3>Value</h3>

<p><code>dots(...)</code> constructs a list with class 'dots', each
element of which is a <a href="#topic+quotation">quotation</a>.
</p>
<p><code>dots_(exprs, envs)</code> constructs a dots object given lists
of expressions and environments. (To construct a dots object from
quotation objects, use <code><a href="base.html#topic+c">c()</a></code>.)
</p>
<p><code>exprs(d)</code> extracts a list of expressions from a dots object.
</p>
<p>The mutator <code>exprs(d) &lt;- value</code> returns a new dots object
with the new expressions.
</p>
<p><code>envs(d)</code> extracts a list of environments from a dots
object.
</p>
<p><code>envs(d)</code> returns a named list of environments.
</p>
<p><code>envs(d) &lt;- value</code> returns an updated dots object with the
environments replaced with the new value(s).
</p>
<p><code>as.data.frame.dots</code> returns a data frame.
</p>


<h3>Note</h3>

<p>The columns have a class <code>"oneline"</code> for better printing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
named.list &lt;- function(...) {
 # Collect only named arguments, ignoring unnamed arguments.
 d &lt;- dots(...)
 do(list, d[names(d) != ""])
}

named.list(a=1, b=2*2, stop("this is not evaluated"))
</code></pre>

<hr>
<h2 id='dots2env'>Make or update an environment with bindings from a dots list.</h2><span id='topic+dots2env'></span><span id='topic+as.environment.dots'></span>

<h3>Description</h3>

<p>All named entries in the dots object will be bound to
variables. Unnamed entries will be appended to any existing value
of <code>...</code> in the order in which they appear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots2env(
  x,
  env = new.env(hash = hash, parent = parent, size = size),
  names = NULL,
  use_dots = TRUE,
  append = TRUE,
  hash = (length(dots) &gt; 100),
  size = max(29L, length(dots)),
  parent = emptyenv()
)

## S3 method for class 'dots'
as.environment(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots2env_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+dots">dots</a> object with names.</p>
</td></tr>
<tr><td><code id="dots2env_+3A_env">env</code></td>
<td>
<p>Specify an environment object to populate and return. By
default a new environment is created.</p>
</td></tr>
<tr><td><code id="dots2env_+3A_names">names</code></td>
<td>
<p>Which variables to populate in the environment. If
NULL is given, will use all names present in the dotlist.  If a
name is given that does not match any names from the dots object,
an error is raised.</p>
</td></tr>
<tr><td><code id="dots2env_+3A_use_dots">use_dots</code></td>
<td>
<p>Whether to bind unnamed or unmatched items to
<code>...</code>. If FALSE, these items are discarded. If TRUE, they
bound to <code>...</code> in the environment. If items have duplicate
names, the earlier ones are used and the rest placed in &quot;...&quot;.</p>
</td></tr>
<tr><td><code id="dots2env_+3A_append">append</code></td>
<td>
<p>if <code>TRUE</code>, unmatched or unnamed items will be
appended to any existing value of '...'. If <code>FALSE</code>, the existing
binding of <code>...</code> will be cleared. (Neither happens if <code>use_dots</code>
is FALSE.)</p>
</td></tr>
<tr><td><code id="dots2env_+3A_hash">hash</code></td>
<td>
<p>if <code>env</code> is NULL, this argument is passed to
<code><a href="base.html#topic+new.env">new.env</a></code>.</p>
</td></tr>
<tr><td><code id="dots2env_+3A_size">size</code></td>
<td>
<p>if <code>env</code> is NULL, this argument is paseed to
<code><a href="base.html#topic+new.env">new.env</a></code>.</p>
</td></tr>
<tr><td><code id="dots2env_+3A_parent">parent</code></td>
<td>
<p>if <code>env</code> is NULL, this argument is paseed to
<code><a href="base.html#topic+new.env">new.env</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment object.
</p>


<h3>See Also</h3>

<p>env2dots
</p>

<hr>
<h2 id='env2dots'>Copy bindings from an environment into a dots object, or vice versa.</h2><span id='topic+env2dots'></span>

<h3>Description</h3>

<p><code>env2dots</code> copies all bindings in the environment (but not those
from its parents) into a new <a href="#topic+dots">dots</a> object. Bindings that are
promises will be captured without forcing. Bindings that are not
promises will be rendered as <a href="#topic+forced">forced</a> quotations. The output will
not be in any guaranteed order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env2dots(
  env = caller(environment()),
  names = ls(envir = env, all.names = TRUE),
  include_missing = TRUE,
  expand_dots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env2dots_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="env2dots_+3A_names">names</code></td>
<td>
<p>Which names to extract from the environment. By
default extracts all bindings present in <code>env</code>, but not in
its enclosing environments.</p>
</td></tr>
<tr><td><code id="env2dots_+3A_include_missing">include_missing</code></td>
<td>
<p>Whether to include missing bindings.</p>
</td></tr>
<tr><td><code id="env2dots_+3A_expand_dots">expand_dots</code></td>
<td>
<p>Whether to include the contents of <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+dots">dots</a> object.
</p>

<hr>
<h2 id='forced'>Forcing and forcedness of arguments and quotations.</h2><span id='topic+forced'></span><span id='topic+forced.quotation'></span><span id='topic+forced.dots'></span><span id='topic+forced.default'></span><span id='topic+force_'></span><span id='topic+force_.quotation'></span><span id='topic+force_.dots'></span><span id='topic+value'></span><span id='topic+value.quotation'></span><span id='topic+value.dots'></span><span id='topic+values'></span><span id='topic+values.dots'></span>

<h3>Description</h3>

<p>There are two kinds of <a href="#topic+quotation">quotation</a>s: forced and unforced.
Unforced quotations have an expression and an environment; forced
quotations have an expression and a value.
</p>
<p><code>forced(q)</code> tests whether a <a href="#topic+quotation">quotation</a> is forced.
</p>
<p><code>forced(d)</code> on a <a href="#topic+dots">dots</a> object tests whether each element
is forced, and returns a logical vector.
</p>
<p><code>force_(x)</code> converts an unforced quotation or dots object into a
forced one, by evaluating it.
</p>
<p><code>value(x)</code> or <code>values(...)</code> returns the value of a quotation or dots,
forcing it if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forced(x)

## S3 method for class 'quotation'
forced(x, ...)

## S3 method for class 'dots'
forced(x)

## Default S3 method:
forced(x)

force_(x, ...)

## S3 method for class 'quotation'
force_(x, eval = base::eval, ...)

## S3 method for class 'dots'
force_(x, ...)

value(x, ...)

## S3 method for class 'quotation'
value(x, ...)

## S3 method for class 'dots'
value(x, ...)

values(x)

## S3 method for class 'dots'
values(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forced_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+quotation">quotation</a> or <a href="#topic+dots">dots</a> object.</p>
</td></tr>
<tr><td><code id="forced_+3A_...">...</code></td>
<td>
<p>Options used by methods</p>
</td></tr>
<tr><td><code id="forced_+3A_eval">eval</code></td>
<td>
<p>Which evaluation function to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>forced(x)</code> returns a <a href="base.html#topic+logical">logical</a>.
</p>
<p><code>value(x)</code> returns the result of forcing the quotation.
</p>
<p><code>values</code> returns a list.
</p>


<h3>See Also</h3>

<p>is_forced forced_quo
</p>
<p><a href="base.html#topic+force">force</a>
</p>

<hr>
<h2 id='format.dots'>Formatting methods for dots and quotations.</h2><span id='topic+format.dots'></span><span id='topic+format.quotation'></span><span id='topic+format.oneline'></span><span id='topic+print.dots'></span><span id='topic+print.quotation'></span>

<h3>Description</h3>

<p><code>format.dots</code> constructs a string representation of a dots
object.
</p>
<p><code>format.quotation</code> constructs a string representation of a
quotation object.
</p>
<p><code>format.oneline</code> formats a vector or list so that each item is
displayed on one line. It is similar to <a href="base.html#topic+format.AsIs">format.AsIs</a> but tries
harder witlanguage objects. The &quot;oneline&quot; class is used by
<a href="#topic+as.data.frame.dots">as.data.frame.dots</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dots'
format(
  x,
  compact = FALSE,
  show.environments = !compact,
  show.expressions = !compact,
  width = NULL,
  ...
)

## S3 method for class 'quotation'
format(
  x,
  compact = FALSE,
  show.environments = !compact,
  show.expressions = !compact,
  width = NULL,
  ...
)

## S3 method for class 'oneline'
format(x, max.width = 50, width = max.width, ...)

## S3 method for class 'dots'
print(x, ...)

## S3 method for class 'quotation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.dots_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="format.dots_+3A_compact">compact</code></td>
<td>
<p>Implies <code>show.environments=FALSE</code> and
<code>show.expressions=FALSE</code>.</p>
</td></tr>
<tr><td><code id="format.dots_+3A_show.environments">show.environments</code></td>
<td>
<p>Whether to show environments for unforced
quotations.</p>
</td></tr>
<tr><td><code id="format.dots_+3A_show.expressions">show.expressions</code></td>
<td>
<p>Whether to show expressions for forced
quotations.</p>
</td></tr>
<tr><td><code id="format.dots_+3A_width">width</code></td>
<td>
<p>See <a href="base.html#topic+format">base::format</a>.</p>
</td></tr>
<tr><td><code id="format.dots_+3A_...">...</code></td>
<td>
<p>Further parameters passed along to <a href="base.html#topic+format">base::format</a>.</p>
</td></tr>
<tr><td><code id="format.dots_+3A_max.width">max.width</code></td>
<td>
<p>See <a href="base.html#topic+format">base::format</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='function_'>Explicitly create closures.</h2><span id='topic+function_'></span><span id='topic+arglist'></span>

<h3>Description</h3>

<p><code>function_</code> is a normally-evaluating version of <code><a href="base.html#topic+function">function</a></code>, which
creates closures. A closure object has three components: the
argument list, the body expression, and the enclosing environment.
</p>
<p><code>arglist()</code> is a helper that produces a named list of
<a href="#topic+missing_value">missing_value</a>s given a character vector of names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_(args, body, env = arg_env(args, environment()))

arglist(names, fill = missing_value())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function__+3A_args">args</code></td>
<td>
<p>The argument list of the new function. NULL is accepted
to make a function with no arguments. Arguments are specified as
a named list; the list names become the argument names, and the
list values become the default expressions. A value of
<code><a href="#topic+missing_value">missing_value()</a></code> indicates no default. <a href="base.html#topic+alist">alist</a> and <a href="#topic+arglist">arglist</a> are
useful for making argument lists.</p>
</td></tr>
<tr><td><code id="function__+3A_body">body</code></td>
<td>
<p>An expression for the body of the function.</p>
</td></tr>
<tr><td><code id="function__+3A_env">env</code></td>
<td>
<p>The enclosing environment of the new function.</p>
</td></tr>
<tr><td><code id="function__+3A_names">names</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="function__+3A_fill">fill</code></td>
<td>
<p>The expression (default missing)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A closure.
</p>


<h3>See Also</h3>

<p>environment formals body
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- function(x, y = x) { x + y }
f2 &lt;- function_(alist(x = , y = x),
                quote( { x + y } ),
                environment())
identical(f1, f2) # TRUE

# `fn` makes a compact way to write functions;
# `fn(x+y)` is equivalent to `function(x, y) x+y`
fn &lt;- function(exp) {
  exp_ &lt;- arg(exp)
  nn &lt;- arglist(all.names(expr(exp_), functions=FALSE))
  function_(nn, expr(exp_), env(exp_))
}

fn(x^2)
fn(x+y)
</code></pre>

<hr>
<h2 id='get_call'>Get information about currently executing calls.</h2><span id='topic+get_call'></span><span id='topic+get_function'></span>

<h3>Description</h3>

<p><code>get_call(env)</code>, given an environment associated with a currently
executing call, returns the function call and its arguments, as a
<a href="#topic+dots">dots</a> object. To replicate a call, the <a href="#topic+dots">dots</a> object returned can
be passed to <a href="#topic+do">do</a>.
</p>
<p><code>get_function(env)</code> finds the function object associated with a
currently executing call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_call(
  env = caller(environment()),
  ifnotfound = stop("get_call: environment not found on stack")
)

get_function(
  env = caller(environment()),
  ifnotfound = stop("get_function: environment not found on stack")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_call_+3A_env">env</code></td>
<td>
<p>An environment belonging to a currently executing
function call. By default, the <a href="#topic+caller">caller</a> of get_call itself
(so <code>get_call()</code> is equivalent to <code>get_call(environment())</code>.)</p>
</td></tr>
<tr><td><code id="get_call_+3A_ifnotfound">ifnotfound</code></td>
<td>
<p>What to return if the call is not found. By
default an error is thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_call</code> is meant to replace <code><a href="base.html#topic+match.call">match.call</a></code> and <code><a href="base.html#topic+sys.call">sys.call</a></code>;
its advantage is that it captures the environments bound to
arguments in addition to their written form.
</p>
<p><code>get_function</code> is similar to <code><a href="base.html#topic+sys.function">sys.function</a></code>, but is keyed by
environment rather than number.
</p>


<h3>Value</h3>

<p><code>get_call</code> returns a <a href="#topic+dots">dots</a> object, the first element of
which represents the function name and <a href="#topic+caller">caller</a> environment.
</p>
<p><code>get_function</code> returns a closure.
</p>


<h3>See Also</h3>

<p>do dots caller
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We might think of re-writing the start of [lm] like so:
LM &lt;- function(formula, data, subset, weights, na.action, method = "qr",
               model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
               contrasts = NULL, offset, ...) {
  cl &lt;- get_call()
  mf &lt;- do(model.frame,
           arg_list(formula, data, subset, weights, na.action, offset))

  z &lt;- get.call()

  class(z) &lt;- c("LM", class(z))
  z$call &lt;- cl
  z
}

# and `update` like so:
update.LM &lt;- function(object, formula., ...) {
  call &lt;- object$call
  extras &lt;- dots(...)
  call$formula &lt;- forced_quo(update.formula(formula(object), formula.))
  do(call)
}
</code></pre>

<hr>
<h2 id='get_dots'>Set or get the contents of <code>...</code>.</h2><span id='topic+get_dots'></span><span id='topic+set_dots'></span>

<h3>Description</h3>

<p><code>get_dots()</code> unpacks <code>...</code> from a given environment and returns a
<a href="#topic+dots">dots</a> object.
</p>
<p><code>set_dots</code> takes a <a href="#topic+dots">dots</a> list and uses it to create a binding for
<code>...</code> in a given environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dots(env = caller(environment()), inherits = FALSE)

set_dots(env, d, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dots_+3A_env">env</code></td>
<td>
<p>The environment to look in.</p>
</td></tr>
<tr><td><code id="get_dots_+3A_inherits">inherits</code></td>
<td>
<p>Whether to pull <code>...</code> from enclosing environments.</p>
</td></tr>
<tr><td><code id="get_dots_+3A_d">d</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;[dots]&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="get_dots_+3A_append">append</code></td>
<td>
<p>if TRUE, the values should be appended to the
existing binding. If false, existing binding for &quot;...&quot; will be
replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_dots()</code> is equivalent to <code>dots(...)</code> or
<code>arg_list(`...`)</code>.
</p>


<h3>Value</h3>

<p><code>get_dots</code> returns a <a href="#topic+dots">dots</a> list. If <code>...</code> is not bound or
is missing, it returns an empty dots list.
</p>
<p><code>set_dots</code> returns the updated environment, invisibly.
</p>


<h3>See Also</h3>

<p>env2dots set_arg dots2env
</p>

<hr>
<h2 id='locate'>Find the environment which defines a name.</h2><span id='topic+locate'></span><span id='topic+locate_'></span><span id='topic+locate_.list'></span><span id='topic+locate_.quotation'></span><span id='topic+locate_.character'></span><span id='topic+locate_.+28'></span><span id='topic+locate_.dots'></span><span id='topic+locate_.name'></span>

<h3>Description</h3>

<p><code>locate</code> starts at a given environment, and searches enclosing
environments for a name. It returns the first enclosing environment
which defines <code>sym</code>.
</p>
<p><code>locate_</code> is the normally evaluating method; <code>locate(x)</code> is
equivalent to <code>locate_(quo(x))</code> or <code>locate_(quote(x), environment())</code>.
</p>
<p>When <code>sym</code> is a <a href="#topic+quotation">quotation</a> or <a href="#topic+dots">dots</a>, any <code>env</code> argument is ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate(sym, env = arg_env_(quote(sym), environment()), mode = "any", ...)

locate_(sym, env = arg_env_(quote(sym), environment()), mode = "any", ...)

locate_.list(sym, env = arg_env_(quote(sym), environment()), mode = "any", ...)

locate_.quotation(sym, env = "ignored", mode = "any", ...)

locate_.character(
  sym,
  env = arg_env_(quote(sym), environment()),
  mode = "any",
  ...
)

`locate_.(`(sym, env = arg_env_(quote(sym), environment()), mode = "any", ...)

locate_.dots(sym, env = "ignored", mode = "any", ...)

locate_.name(
  sym,
  env = arg_env_(quote(sym), environment()),
  mode = "any",
  ifnotfound = stop("Binding ", deparse(sym), " not found")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_+3A_sym">sym</code></td>
<td>
<p>A name. For <code>locate</code> the argument is used literally. For
<code>locate_</code> it should be a <a href="base.html#topic+name">name</a> or list of names.</p>
</td></tr>
<tr><td><code id="locate_+3A_env">env</code></td>
<td>
<p>Which environment to begin searching from.</p>
</td></tr>
<tr><td><code id="locate_+3A_mode">mode</code></td>
<td>
<p>Either <code>"any"</code> or <code>"function"</code>. <code>"any"</code> finds the
lowest enclosing environment which gives any definiton for <code>sym</code>.
<code>"function"</code> searches for an environment which defines <code>sym</code> as a
function. This may force lazy arguments in the process, in the
same way as <a href="base.html#topic+get">get</a>.</p>
</td></tr>
<tr><td><code id="locate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="locate_+3A_ifnotfound">ifnotfound</code></td>
<td>
<p>What is returned if the symbol is not found. By
default an exception is raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment object which defines <code>sym</code>, if one is found.
</p>
<p>If <code>sym</code> is a list (of <a href="base.html#topic+name">name</a>s) or a <a href="#topic+dots">dots</a> object, <code>locate_(sym)</code>
returns a list.
</p>


<h3>Note</h3>

<p>To locate where <code>...</code> is bound, you can wrap it in parens, as
<code>locate( (...) )</code>.
</p>
<p>If you use a literal character argument, as in <code>locate("x", environment())</code>, you must also provide the environment argument
explicitly; <code>locate("x")</code> won't work in compiled
functions. However using a literal name like <code>locate(x)</code> will
work OK. See note under <a href="#topic+arg">arg</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is how to implement R's `&lt;&lt;-` operator, using `locate_`:
`%&lt;&lt;-%` &lt;- function(lval, rval) {
  lval_ &lt;- arg(lval)
  name &lt;- expr(lval_)
  target.env &lt;- locate_(name, parent.env(env(lval_)))
  assign(as.character(name), rval, envir=target.env)
}

x &lt;- "not this one"
local({
  x &lt;- "this one"
  local({
    x &lt;- "not this one either"
    x %&lt;&lt;-% "this works like builtin &lt;&lt;-"
  })
  print(x)
})
print(x)
</code></pre>

<hr>
<h2 id='missing_value'>R's missing value.</h2><span id='topic+missing_value'></span><span id='topic+missing_'></span><span id='topic+missing_.default'></span><span id='topic+missing_.dots'></span><span id='topic+missing_.quotation'></span><span id='topic+list_missing'></span>

<h3>Description</h3>

<p><code>missing_value()</code> returns R's missing object; what R uses to
represent a missing argument. It is distinct from either <a href="base.html#topic+NULL">NULL</a> or
<a href="base.html#topic+NA">NA</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_value(n)

missing_(x, unwrap = TRUE)

## Default S3 method:
missing_(x, unwrap = TRUE)

## S3 method for class 'dots'
missing_(x, unwrap = TRUE)

## S3 method for class 'quotation'
missing_(x, unwrap = TRUE)

list_missing(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_value_+3A_n">n</code></td>
<td>
<p>Optional; a number. If provided, will return a list of
missing values with this many elements.</p>
</td></tr>
<tr><td><code id="missing_value_+3A_x">x</code></td>
<td>
<p>a value, <a href="#topic+dots">dots</a>, or list.</p>
</td></tr>
<tr><td><code id="missing_value_+3A_unwrap">unwrap</code></td>
<td>
<p>Whether to descend recursively through unevaluated
promises using <code>unwrap(x, TRUE)</code></p>
</td></tr>
<tr><td><code id="missing_value_+3A_...">...</code></td>
<td>
<p>Arguments evaluated normally. except those which are missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The missing value occurs naturally in a quoted R expression that has an empty argument:
</p>
<pre>  exp &lt;- quote( x[1, ] )
  identical(exp[[4]], missing_value()) #TRUE
  is_missing(exp[[4]]) #also TRUE
</pre>
<p>So we can use <code>missing_value()</code> to help construct expressions:
</p>
<pre>  substitute(f[x, y], list(x = 1, y=missing_value()))
</pre>
<p>When such an expression is evaluated and starts a function call,
the missing value winds up in the promise expression.
</p>
<pre>  f &lt;- function(x) arg_expr(x)
  identical(f(), missing_value()) # TRUE
</pre>
<p>During &quot;normal evaluation&quot;, finding a missing value in a
variable raises an error.
</p>
<pre>  m &lt;- missing_value()
  list(m) # raises error
</pre>
<p>This means that it's sometimes tricky to work with missings:
</p>
<pre>  exp &lt;- quote( x[1, ] )
  cols &lt;- x[[4]]
  x &lt;- list(missing_value(), 2, 3)     # this is ok, but...
  a &lt;- missing_value(); b &lt;- 2; c &lt;- 3 # this stores missing in "cols",
  x &lt;- list(a, b, c)                   # throws an error: "a" missing
</pre>
<p>Generally, keep your missing values wrapped up in lists or quotations,
instead of assigning them to variables directly.
</p>


<h3>Value</h3>

<p><code>missing_value</code> returns the symbol with empty name, or a
list of such.
</p>
<p><code>missing_</code> returns a logical vector.
</p>
<p><code>list_missing</code> returns a list.
</p>


<h3>See Also</h3>

<p>missing is_missing
</p>
<p>missing is_missing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These expressions are equivalent:
function(x, y=1) {x+y}
function_(list(x=missing_value, y=1),
          quote( {x+y} ))

# These expressions are also equivalent:
quote(df[,1])
substitute(df[row,col],
           list(row = missing_value(), col = 1))
# How to do the trick of `[` where it can tell which arguments are
# missing:
`[.myclass` &lt;- function(x, ...) {
   indices &lt;- list_missing(...)
   kept.axes &lt;- which(missing_(indices))
   cat(paste0("Keeping axes ", kept_axes, "\n"))
   #...
}
ar &lt;- structure(array(1:24, c(2, 3, 4)))
ar[, 3, ]
</code></pre>

<hr>
<h2 id='quo'>Quotation objects.</h2><span id='topic+quo'></span><span id='topic+quotation'></span><span id='topic+quo_'></span><span id='topic+env'></span><span id='topic+env+3C-'></span><span id='topic+expr'></span><span id='topic+expr.quotation'></span><span id='topic+expr+3C-'></span><span id='topic+is.quotation'></span><span id='topic+is.quo'></span><span id='topic+as.quo'></span><span id='topic+forced_quo'></span><span id='topic+forced_quo_'></span>

<h3>Description</h3>

<p><code>quo(expr, env)</code> captures <code>expr</code> without evaluating, and returns a
qutation object. A quotation has two parts: an
expression <code>expr(q)</code> with an environment <code>env(q)</code>.
</p>
<p><code>quo_(expr, env)</code> is the normally evaluating version. It
constructs a quotation given an expression and environment.
</p>
<p><code>as.quo(x)</code> converts an object into a quotation. Closures,
formulas, and single-element <a href="#topic+dots">dots</a> can be converted this way.
</p>
<p><code>forced_quo(x)</code> captures the expression in its argument, then
forces it, returning a quotation with the expression and value.
</p>
<p><code>forced_quo_(val)</code> makes a <a href="#topic+forced">forced</a> quotation given a value.
Specifically it constructs a <a href="#topic+quotation">quotation</a> with the same object in
both the <code>expr</code> and <code>value</code> slots, except if is a
<a href="base.html#topic+is.language">language</a> object in which case the <code>expr</code> slot is wrapped
in <code>quote()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quo(expr, env = arg_env_(quote(expr), environment()), force = FALSE)

quo_(expr, env, force = FALSE)

env(q)

env(q) &lt;- value

expr(q)

## S3 method for class 'quotation'
expr(q)

expr(q) &lt;- value

is.quotation(x)

is.quo(x)

as.quo(x)

forced_quo(x)

forced_quo_(val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quo_+3A_expr">expr</code></td>
<td>
<p>An expression. For <code>quo</code> this is taken literally and
not evaluated. For <code>quo_</code> this is evaluated normally.</p>
</td></tr>
<tr><td><code id="quo_+3A_env">env</code></td>
<td>
<p>An <a href="base.html#topic+environment">environment</a>.</p>
</td></tr>
<tr><td><code id="quo_+3A_force">force</code></td>
<td>
<p>Whether to evaluate the expression and create a
<a href="#topic+forced">forced</a> quotation.</p>
</td></tr>
<tr><td><code id="quo_+3A_q">q</code></td>
<td>
<p>A quotation object.</p>
</td></tr>
<tr><td><code id="quo_+3A_value">value</code></td>
<td>
<p>An updated value.</p>
</td></tr>
<tr><td><code id="quo_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
<tr><td><code id="quo_+3A_val">val</code></td>
<td>
<p>A value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(Like in writing, an 'expression' may simply be a set of words, but
a 'quotation' comes bundled with a citation, to reference a context
in which it was said.)
</p>
<p>A quo is parallel to a 'promise' which is the data structure R uses
to hold lazily evaluated arguments. A quo is different from a
promise because it is an immutable data object.
</p>
<p>As a data object, a quo does not automatically evaluate like a
promise, but can be evaluated explicitly with the methods <a href="#topic+value">value</a>
or <a href="#topic+force_">force_</a>.  A quo is immutable, so it does not mutate into a
&quot;forced&quot; state if you choose to evaluate it; instead <code>force_(q)</code>
returns a new object in the forced state.
</p>
<p>A function can capture its arguments as quotations using <code><a href="#topic+arg">arg</a></code>.
</p>
<p>A <a href="#topic+dots">dots</a> object is a list of quotations.
</p>


<h3>Value</h3>

<p><code>quo_</code> and <code>quo</code> return an object of class &quot;quotation&quot;.
</p>
<p><code>as.quo</code> returns a quotation.
</p>

<hr>
<h2 id='set_'>Assign values to variables.</h2><span id='topic+set_'></span><span id='topic+set_enclos_'></span>

<h3>Description</h3>

<p><code>set_</code> is a normally-evaluating version of <code><a href="base.html#topic++3C-">&lt;-</a></code>.
<code>set_enclos_</code> is a normally evaluating version of
<code><a href="base.html#topic++3C+3C-">&lt;&lt;-</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_(dest, val)

set_enclos_(dest, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set__+3A_dest">dest</code></td>
<td>
<p>A <a href="#topic+quotation">quotation</a> specifying the destination environment
and name. This can also be an indexing, expression, and <code>set_</code> will
perform subassignment.</p>
</td></tr>
<tr><td><code id="set__+3A_val">val</code></td>
<td>
<p>The value to assign.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set_</code> differs from <code style="white-space: pre;">&#8288;[assign]&#8288;</code> in that <code>set_</code> will process
subassignments.
</p>
<p>These helpers are here because it is tricky to use <code><a href="#topic+do_">do_</a></code> with
<code><a href="base.html#topic++3C-">&lt;-</a></code> (see Note under <a href="#topic+do_">do_</a>).
</p>


<h3>Value</h3>

<p><code>set_</code> returns <code>val</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_(quo(x), 12) #equivalent to `x &lt;- 12`
set_(quo(x[3]), 12) #equivalent to `x[3] &lt;- 12`
e &lt;- new.env()
set_(quo(x[3], e), 12) #assigns in environment `e`
set_enclos_(quo(x[3], e), 12) #assigns in a parent of environment `e`
</code></pre>

<hr>
<h2 id='unwrap'>Unwrap variable references.</h2><span id='topic+unwrap'></span><span id='topic+unwrap.dots'></span>

<h3>Description</h3>

<p>Given an un<a href="#topic+forced">forced</a> <a href="#topic+quotation">quotation</a> whose expression is a bare variable
name, <code>unwrap</code> follows the variable reference, and returns a
quotation. When the argument is forced or has a nontrivial
expression <code>unwrap</code> has no effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap(x, recursive = FALSE)

## S3 method for class 'dots'
unwrap(x, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+quotation">quotation</a> to unwrap.</p>
</td></tr>
<tr><td><code id="unwrap_+3A_recursive">recursive</code></td>
<td>
<p>Default <code>FALSE</code> unwraps exactly once. If
<code>TRUE</code>, unwrap as far as possible (until a forced promise or
nontrivial expression is found.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two good use cases for <code>unwrap(x, recursive=TRUE)</code>. One
is to derive plot labels (the most inoccuous use of
metaprogramming). Another is to check for missingness (this is what
R's <a href="base.html#topic+missing">missing</a> and does as well).
</p>
<p>Using <code>unwrap(x, recursive=TRUE)</code> in other situations can get you
into confusing situations &ndash; effectively you are changing the
behavior of a parent function that may be an unknown number of
levels up the stack, possibly turning a standard-evaluating
function into nonstandard-evaluating function. So recursive
unerapping is not the default behavior.
</p>


<h3>Value</h3>

<p>The <a href="#topic+quotation">quotation</a> method returns a <a href="#topic+quotation">quotation</a>.
</p>
<p>The <a href="#topic+dots">dots</a> method returns a dots object with each quotation unwrapped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># different levels of unwrapping:
f &lt;- function(x) { g(x) }
g &lt;- function(y) { h(y) }
h &lt;- function(z) {
  print(arg(z))
  print(unwrap(quo(z)))
  print(unwrap(unwrap(quo(z))))
  print(unwrap(quo(z), recursive=TRUE))
}

w &lt;- 5
f(w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
