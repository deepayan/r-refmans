<!DOCTYPE html><html><head><title>Help for package smcfcs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smcfcs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ex_cc'><p>Simulated case cohort data</p></a></li>
<li><a href='#ex_compet'><p>Simulated example data with competing risks outcome and partially observed covariates</p></a></li>
<li><a href='#ex_coxquad'><p>Simulated example data with time to event outcome and quadratic covariate effects</p></a></li>
<li><a href='#ex_dtsam'><p>Simulated discrete time survival data set</p></a></li>
<li><a href='#ex_finegray'><p>Simulated example data with competing risks outcome and partially observed covariates</p></a></li>
<li><a href='#ex_lininter'><p>Simulated example data with continuous outcome and interaction between two partially observed covariates</p></a></li>
<li><a href='#ex_linquad'><p>Simulated example data with continuous outcome and quadratic covariate effects</p></a></li>
<li><a href='#ex_logisticquad'><p>Simulated example data with binary outcome and quadratic covariate effects</p></a></li>
<li><a href='#ex_ncc'><p>Simulated nested case-control data</p></a></li>
<li><a href='#ex_poisson'><p>Simulated example data with count outcome, modelled using Poisson regression</p></a></li>
<li><a href='#plot.smcfcs'><p>Assess convergence of a smcfcs object</p></a></li>
<li><a href='#smcfcs'><p>Substantive model compatible fully conditional specification imputation of covariates.</p></a></li>
<li><a href='#smcfcs.casecohort'><p>Substantive model compatible fully conditional specification imputation of covariates for case cohort studies</p></a></li>
<li><a href='#smcfcs.dtsam'><p>Substantive model compatible fully conditional specification imputation of covariates for</p>
discrete time survival analysis</a></li>
<li><a href='#smcfcs.finegray'><p>Substantive model compatible fully conditional specification imputation of</p>
covariates for a Fine-Gray model</a></li>
<li><a href='#smcfcs.nestedcc'><p>Substantive model compatible fully conditional specification imputation of covariates for nested case control</p>
studies</a></li>
<li><a href='#smcfcs.parallel'><p>Parallel substantive model compatible imputation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multiple Imputation of Covariates by Substantive Model
Compatible Fully Conditional Specification</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jwb133/smcfcs">https://github.com/jwb133/smcfcs</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements multiple imputation of missing covariates by
    Substantive Model Compatible Fully Conditional Specification.
    This is a modification of the popular FCS/chained equations
    multiple imputation approach, and allows imputation of missing
    covariate values from models which are compatible with the user
    specified substantive model.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, survival, VGAM, stats, rlang, checkmate, abind, brglm2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mitools, ggplot2, kmi</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-04 17:28:35 UTC; lshjb12</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Bartlett [aut, cre],
  Ruth Keogh [aut],
  Edouard F. Bonneville [aut],
  Claus Thorn Ekstr√∏m [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Bartlett &lt;jonathan.bartlett1@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ex_cc'>Simulated case cohort data</h2><span id='topic+ex_cc'></span>

<h3>Description</h3>

<p>A dataset containing simulated case cohort data, where the sub-cohort was a 10% random sample of the full cohort.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_cc
</code></pre>


<h3>Format</h3>

<p>A data frame with 1571 rows and 7 variables:
</p>

<dl>
<dt>t</dt><dd><p>Time to event or censoring</p>
</dd>
<dt>d</dt><dd><p>Indicator of whether event 1 occurred (d=1), or not (d=0)</p>
</dd>
<dt>x</dt><dd><p>Partially observed continuous covariate</p>
</dd>
<dt>z</dt><dd><p>Fully observed covariate</p>
</dd>
<dt>in.subco</dt><dd><p>A binary indicator of whether the subject is in the sub-cohort</p>
</dd>
<dt>id</dt><dd><p>An id variable</p>
</dd>
<dt>entertime</dt><dd><p>The entry time variable to be used in the analysis</p>
</dd>
</dl>


<hr>
<h2 id='ex_compet'>Simulated example data with competing risks outcome and partially observed covariates</h2><span id='topic+ex_compet'></span>

<h3>Description</h3>

<p>A dataset containing simulated competing risks data. There are two competing risks, and
some times are also censored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_compet
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 4 variables:
</p>

<dl>
<dt>t</dt><dd><p>Time to event or censoring</p>
</dd>
<dt>d</dt><dd><p>Indicator of whether event 1 occurred (d=1), event 2 occurred (d=2) or individual was censored (d=0)</p>
</dd>
<dt>x1</dt><dd><p>Partially observed binary covariate, with linear effects on log competing risk hazards</p>
</dd>
<dt>x2</dt><dd><p>Partially observed normally distributed (conditional on x1) covariate, with linear effects
on log competing risk hazards</p>
</dd>
</dl>


<hr>
<h2 id='ex_coxquad'>Simulated example data with time to event outcome and quadratic covariate effects</h2><span id='topic+ex_coxquad'></span>

<h3>Description</h3>

<p>A dataset containing simulated data where a time to event outcome depends quadratically
on a partially observed covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_coxquad
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 6 variables:
</p>

<dl>
<dt>t</dt><dd><p>Time to event or censoring</p>
</dd>
<dt>d</dt><dd><p>Binary indicator of whether event occurred or individual was censored</p>
</dd>
<dt>z</dt><dd><p>Fully observed covariate, with linear effect on outcome (on log hazard scale)</p>
</dd>
<dt>x</dt><dd><p>Partially observed normally distributed covariate, with quadratic effect on outcome (on log hazard scale)</p>
</dd>
<dt>xsq</dt><dd><p>The square of x, which thus has missing values also</p>
</dd>
<dt>v</dt><dd><p>An auxiliary variable (i.e. not contained in the substantive model)</p>
</dd>
</dl>


<hr>
<h2 id='ex_dtsam'>Simulated discrete time survival data set</h2><span id='topic+ex_dtsam'></span>

<h3>Description</h3>

<p>A dataset containing simulated discrete time survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_dtsam
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 8 variables:
</p>

<dl>
<dt>x1</dt><dd><p>A binary variable with missing values</p>
</dd>
<dt>x2</dt><dd><p>A fully observed continuous variable</p>
</dd>
<dt>failtime</dt><dd><p>The discrete failure/censoring time</p>
</dd>
<dt>d</dt><dd><p>Indicator of failure (=1) or censoring (=0)</p>
</dd>
</dl>


<hr>
<h2 id='ex_finegray'>Simulated example data with competing risks outcome and partially observed covariates</h2><span id='topic+ex_finegray'></span>

<h3>Description</h3>

<p>A dataset containing simulated competing risks data. There are two competing risks, and
some times are also censored. Proportionality holds on the subdistribution hazard scale for
cause 2, where for dataset 'ex_compet' it instead holds on the cause-specific
hazard scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_finegray
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 4 variables:
</p>

<dl>
<dt>times</dt><dd><p>Time to event or censoring</p>
</dd>
<dt>d</dt><dd><p>Indicator of whether event 1 occurred (d=1), event 2 occurred (d=2) or individual was censored (d=0)</p>
</dd>
<dt>x1</dt><dd><p>Partially observed binary covariate, with linear effects on log subdistribution hazard of cause 1</p>
</dd>
<dt>x2</dt><dd><p>Partially observed normally distributed (conditional on x1) covariate, with linear effects
on log subdistribution hazard of cause 1</p>
</dd>
</dl>


<hr>
<h2 id='ex_lininter'>Simulated example data with continuous outcome and interaction between two partially observed covariates</h2><span id='topic+ex_lininter'></span>

<h3>Description</h3>

<p>A dataset containing simulated data where the outcome depends on both main
effects and interaction of two partially observed covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_lininter
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 4 variables:
</p>

<dl>
<dt>y</dt><dd><p>Continuous outcome</p>
</dd>
<dt>x1</dt><dd><p>Partially observed normally distributed covariate</p>
</dd>
<dt>x2</dt><dd><p>Partially observed binary covariate</p>
</dd>
</dl>


<hr>
<h2 id='ex_linquad'>Simulated example data with continuous outcome and quadratic covariate effects</h2><span id='topic+ex_linquad'></span>

<h3>Description</h3>

<p>A dataset containing simulated data where the outcome depends quadratically
on a partially observed covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_linquad
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 5 variables:
</p>

<dl>
<dt>y</dt><dd><p>Continuous outcome</p>
</dd>
<dt>z</dt><dd><p>Fully observed covariate, with linear effect on outcome</p>
</dd>
<dt>x</dt><dd><p>Partially observed normally distributed covariate, with quadratic effect on outcome</p>
</dd>
<dt>xsq</dt><dd><p>The square of x, which thus has missing values also</p>
</dd>
<dt>v</dt><dd><p>An auxiliary variable (i.e. not contained in the substantive model)</p>
</dd>
</dl>


<hr>
<h2 id='ex_logisticquad'>Simulated example data with binary outcome and quadratic covariate effects</h2><span id='topic+ex_logisticquad'></span>

<h3>Description</h3>

<p>A dataset containing simulated data where the binary outcome depends quadratically
on a partially observed covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_logisticquad
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 5 variables:
</p>

<dl>
<dt>y</dt><dd><p>Binary outcome</p>
</dd>
<dt>z</dt><dd><p>Fully observed covariate, with linear effect on outcome (on log odds scale)</p>
</dd>
<dt>x</dt><dd><p>Partially observed normally distributed covariate, with quadratic effect on outcome (on log odds scale)</p>
</dd>
<dt>xsq</dt><dd><p>The square of x, which thus has missing values also</p>
</dd>
<dt>v</dt><dd><p>An auxiliary variable (i.e. not contained in the substantive model)</p>
</dd>
</dl>


<hr>
<h2 id='ex_ncc'>Simulated nested case-control data</h2><span id='topic+ex_ncc'></span>

<h3>Description</h3>

<p>A dataset containing simulated nested case-control data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_ncc
</code></pre>


<h3>Format</h3>

<p>A data frame with 728 rows and 8 variables:
</p>

<dl>
<dt>t</dt><dd><p>Time to event or censoring</p>
</dd>
<dt>d</dt><dd><p>Indicator of whether event 1 occurred (d=1), or not (d=0)</p>
</dd>
<dt>x</dt><dd><p>Partially observed binary covariate</p>
</dd>
<dt>z</dt><dd><p>Fully observed covariate</p>
</dd>
<dt>id</dt><dd><p>An id variable</p>
</dd>
<dt>numrisk</dt><dd><p>Number of patients at risk at time of case's event</p>
</dd>
<dt>setno</dt><dd><p>The case-control set number</p>
</dd>
<dt>case</dt><dd><p>Binary indicator of case (=1) or control (=0)</p>
</dd>
</dl>


<hr>
<h2 id='ex_poisson'>Simulated example data with count outcome, modelled using Poisson regression</h2><span id='topic+ex_poisson'></span>

<h3>Description</h3>

<p>A dataset containing simulated data where the count outcome depends on two
covariates, x and z, with missing values in x. The substantive model is
Poisson regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_poisson
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 3 variables:
</p>

<dl>
<dt>y</dt><dd><p>Count outcome</p>
</dd>
<dt>z</dt><dd><p>Fully observed covariate, with linear effect on outcome</p>
</dd>
<dt>x</dt><dd><p>Partially observed normally distributed covariate, with linear effect on outcome</p>
</dd>
</dl>


<hr>
<h2 id='plot.smcfcs'>Assess convergence of a smcfcs object</h2><span id='topic+plot.smcfcs'></span>

<h3>Description</h3>

<p>Visualises the contents of smCoefIter. Specifically, it plots the parameter
estimates of the substantive model against the number of iterations from
the imputation procedure. This is done for each regression coefficient,
and each line corresponds to an imputed dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smcfcs'
plot(x, include = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smcfcs_+3A_x">x</code></td>
<td>
<p>An object of class 'smcfcs'</p>
</td></tr>
<tr><td><code id="plot.smcfcs_+3A_include">include</code></td>
<td>
<p>Character vector of coefficient names for which to return the
convergence plot. Default is &quot;all&quot; and returns plots for all coefficients in
a facetted manner.
</p>
<p>Recommendation is to plot first with include = &quot;all&quot;, and then select
coefficient names to zoom in to.
</p>
<p>For competing risks, the coefficients are indexed by their cause. E.g. for
coefficient of a variable x1 in a model for cause 2, will be labelled
&quot;x1-cause2&quot;.</p>
</td></tr>
<tr><td><code id="plot.smcfcs_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass on to ggplot2::facet_wrap(),
eg. nrow = 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires loading of ggplot2 plotting library.
</p>


<h3>Value</h3>

<p>A ggplot2 object, containing the convergence plots, facetted per
covariate in the substantive model
</p>


<h3>Author(s)</h3>

<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use simulated competing risks example in package
imps &lt;- smcfcs(
  originaldata = ex_compet,
  smtype = "compet",
  smformula = list(
    "Surv(t, d == 1) ~ x1 + x2",
    "Surv(t, d == 2) ~ x1 + x2"
  ),
  method = c("", "", "norm", "norm")
)

plot(imps)
plot(imps, include = c("x1-cause1", "x2-cause2"))

## End(Not run)

</code></pre>

<hr>
<h2 id='smcfcs'>Substantive model compatible fully conditional specification imputation of covariates.</h2><span id='topic+smcfcs'></span>

<h3>Description</h3>

<p>Multiply imputes missing covariate values using substantive model compatible
fully conditional specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcfcs(
  originaldata,
  smtype,
  smformula,
  method,
  predictorMatrix = NULL,
  m = 5,
  numit = 10,
  rjlimit = 1000,
  noisy = FALSE,
  errorProneMatrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcfcs_+3A_originaldata">originaldata</code></td>
<td>
<p>The original data frame with missing values.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_smtype">smtype</code></td>
<td>
<p>A string specifying the type of substantive model. Possible
values are <code>"lm"</code>, <code>"logistic"</code>, <code>"brlogistic"</code>, <code>"poisson"</code>, <code>"weibull"</code>,
<code>"coxph"</code>, <code>"compet"</code>.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_smformula">smformula</code></td>
<td>
<p>The formula of the substantive model. For <code>"weibull"</code> and <code>"coxph"</code>
substantive models the left hand side should be of the form <code>"Surv(t,d)"</code>. For <code>"compet"</code>
substantive models, a list should be passed consisting of the Cox models
for each cause of failure (see example).</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_method">method</code></td>
<td>
<p>A required vector of strings specifying for each variable either
that it does not need to be imputed (&quot;&quot;), the type of regression model to be
be used to impute. Possible values are <code>"norm"</code> (normal linear regression),
<code>"logreg"</code> (logistic regression), <code>"brlogreg"</code> (bias reduced logistic regression),
<code>"poisson"</code> (Poisson regression),
<code>"podds"</code> (proportional odds regression for ordered categorical variables),
<code>"mlogit"</code> (multinomial logistic regression for unordered categorical variables),
or a custom expression which defines a passively imputed variable, e.g.
<code>"x^2"</code> or <code>"x1*x2"</code>. <code>"latnorm"</code> indicates the variable is a latent
normal variable which is measured with error. If this is specified for a variable,
the <code>"errorProneMatrix"</code> argument should also be used.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>An optional predictor matrix. If specified, the matrix defines which
covariates will be used as predictors in the imputation models
(the outcome must not be included). The i'th row of the matrix should consist of
0s and 1s, with a 1 in the j'th column indicating the j'th variable be used
as a covariate when imputing the i'th variable. If not specified, when
imputing a given variable, the imputation model covariates are the other
covariates of the substantive model which are partially observed
(but which are not passively imputed) and any fully observed covariates (if present)
in the substantive model. Note that the outcome variable is implicitly conditioned
on by the rejection sampling scheme used by smcfcs, and should not be specified as a predictor
in the predictor matrix.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_m">m</code></td>
<td>
<p>The number of imputed datasets to generate. The default is 5.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_numit">numit</code></td>
<td>
<p>The number of iterations to run when generating each imputation.
In a (limited) range of simulations good performance was obtained with the
default of 10 iterations. However, particularly when the proportion of missingness
is large, more iterations may be required for convergence to stationarity.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_rjlimit">rjlimit</code></td>
<td>
<p>Specifies the maximum number of attempts which should be made
when using rejection sampling to draw from imputation models. If the limit is reached
when running a warning will be issued. In this case it is probably advisable to
increase the <code>rjlimit</code> until the warning does not appear.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_noisy">noisy</code></td>
<td>
<p>logical value (default FALSE) indicating whether output should be noisy, which can
be useful for debugging or checking that models being used are as desired.</p>
</td></tr>
<tr><td><code id="smcfcs_+3A_errorpronematrix">errorProneMatrix</code></td>
<td>
<p>An optional matrix which if specified indicates that some variables
are measured with classical measurement error. If the i'th variable is measured with error
by variables j and k, then the (i,j) and (i,k) entries of this matrix should be 1, with the
remainder of entries 0. The i'th element of the method argument should then be specified
as <code>"latnorm"</code>. See the measurement error vignette for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>smcfcs imputes missing values of covariates using the Substantive Model Compatible
Fully Conditional Specification multiple imputation approach proposed by
Bartlett <em>et al</em> 2015 (see references).
</p>
<p>Imputation is supported for linear regression (<code>"lm"</code>),
logistic regression (<code>"logistic"</code>), bias reduced logistic regression (<code>"brlogistic"</code>),
Poisson regression (<code>"poisson"</code>), Weibull (<code>"weibull"</code>) and Cox regression
for time to event data (<code>"coxph"</code>),
and Cox models for competing risks data (<code>"compet"</code>). For <code>"coxph"</code>,
the event indicator should be integer coded with 0 for censoring and 1 for event.
For <code>"compet"</code>, a Cox model is assumed for each cause specific hazard function,
and the event indicator
should be integer coded with 0 corresponding to censoring, 1 corresponding to
failure from the first cause etc.
</p>
<p>The function returns a list. The first element <code>impDataset</code> of the list is a list of the imputed
datasets. Models (e.g. the substantive model) can be fitted to each and results
combined using Rubin's rules using the mitools package, as illustrated in the examples.
</p>
<p>The second element <code>smCoefIter</code> is a three dimensional array containing the values
of the substantive model parameters obtained at the end of each iteration of the algorithm.
The array is indexed by: imputation number, parameter number, iteration.
</p>
<p>If the substantive model is linear, logistic or Poisson regression,
<code>smcfcs</code> will automatically impute missing outcomes, if present, using
the specified substantive model. However, even in this case, the user should
specify &quot;&quot; in the element of method corresponding to the outcome variable.
</p>
<p>The bias reduced methods make use of the <code><a href="brglm2.html#topic+brglm2">brglm2</a></code> package to fit the corresponding glms
using Firth's bias reduced approach. These may be particularly useful to use in case
of perfect prediction, since the resulting model estimates are always guaranteed to be
finite, even in the case of perfect prediction.
</p>
<p>The development of this package was supported by the UK Medical Research Council
(Fellowship MR/K02180X/1 and grant MR/T023953/1). Part of its development took place while Bartlett was
kindly hosted by the University of Michigan's Department of Biostatistics &amp; Institute for
Social Research.
</p>
<p>The structure of many of the arguments to <code>smcfcs</code> are based on those of
the excellent <code>mice</code> package.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<p><code>impDatasets</code> a list containing the imputed datasets
</p>
<p><code>smCoefIter</code> a three dimension matrix containing the substantive model parameter
values. The matrix is indexed by [imputation,parameter number,iteration]
</p>


<h3>Author(s)</h3>

<p>Jonathan Bartlett <a href="mailto:jonathan.bartlett1@lshtm.ac.uk">jonathan.bartlett1@lshtm.ac.uk</a>
</p>


<h3>References</h3>

<p>Bartlett JW, Seaman SR, White IR, Carpenter JR. Multiple imputation of covariates
by fully conditional specification: accommodating the substantive model. Statistical Methods
in Medical Research 2015; 24(4): 462-487. <a href="https://doi.org/10.1177/0962280214521348">doi:10.1177/0962280214521348</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#set random number seed to make results reproducible
set.seed(123)

#linear substantive model with quadratic covariate effect
imps &lt;- smcfcs(ex_linquad, smtype="lm", smformula="y~z+x+xsq",
               method=c("","","norm","x^2",""))

#if mitools is installed, fit substantive model to imputed datasets
#and combine results using Rubin's rules
if (requireNamespace("mitools", quietly = TRUE)) {
  library(mitools)
  impobj &lt;- imputationList(imps$impDatasets)
  models &lt;- with(impobj, lm(y~z+x+xsq))
  summary(MIcombine(models))
}

#the following examples are not run when the package is compiled on CRAN
#(to keep computation time down), but they can be run by package users
## Not run: 
  #examining convergence, using 100 iterations, setting m=1
  imps &lt;- smcfcs(ex_linquad, smtype="lm", smformula="y~z+x+xsq",
                 method=c("","","norm","x^2",""),m=1,numit=100)
  #convergence plot from first imputation for third coefficient of substantive model
  plot(imps$smCoefIter[1,3,])

  #include auxiliary variable assuming it is conditionally independent of Y (which it is here)
  predMatrix &lt;- array(0, dim=c(ncol(ex_linquad),ncol(ex_linquad)))
  predMatrix[3,] &lt;- c(0,1,0,0,1)
  imps &lt;- smcfcs(ex_linquad, smtype="lm", smformula="y~z+x+xsq",
                 method=c("","","norm","x^2",""),predictorMatrix=predMatrix)

  #impute missing x1 and x2, where they interact in substantive model
  imps &lt;- smcfcs(ex_lininter, smtype="lm", smformula="y~x1+x2+x1*x2",
                 method=c("","norm","logreg"))

  #logistic regression substantive model, with quadratic covariate effects
  imps &lt;- smcfcs(ex_logisticquad, smtype="logistic", smformula="y~z+x+xsq",
                 method=c("","","norm","x^2",""))

  #Poisson regression substantive model
  imps &lt;- smcfcs(ex_poisson, smtype="poisson", smformula="y~x+z",
                 method=c("","norm",""))
  if (requireNamespace("mitools", quietly = TRUE)) {
    library(mitools)
    impobj &lt;- imputationList(imps$impDatasets)
    models &lt;- with(impobj, glm(y~x+z,family=poisson))
    summary(MIcombine(models))
  }

  #Cox regression substantive model, with only main covariate effects
  if (requireNamespace("survival", quietly = TRUE)) {
    imps &lt;- smcfcs(ex_coxquad, smtype="coxph", smformula="Surv(t,d)~z+x+xsq",
                   method=c("","","","norm","x^2",""))

    #competing risks substantive model, with only main covariate effects
    imps &lt;- smcfcs(ex_compet, smtype="compet",
                   smformula=c("Surv(t,d==1)~x1+x2", "Surv(t,d==2)~x1+x2"),
                   method=c("","","logreg","norm"))
  }

  #if mitools is installed, fit model for first competing risk
  if (requireNamespace("mitools", quietly = TRUE)) {
    library(mitools)
    impobj &lt;- imputationList(imps$impDatasets)
    models &lt;- with(impobj, coxph(Surv(t,d==1)~x1+x2))
    summary(MIcombine(models))
  }

  #discrete time survival analysis example
  M &lt;- 5
  imps &lt;- smcfcs(ex_dtsam, "dtsam", "Surv(failtime,d)~x1+x2",
                 method=c("logreg","", "", ""),m=M)
  #fit dtsam model to each dataset manually, since we need
  #to expand to person-period data form first
  ests &lt;- vector(mode = "list", length = M)
  vars &lt;- vector(mode = "list", length = M)
  for (i in 1:M) {
    longData &lt;- survSplit(Surv(failtime,d)~x1+x2, data=imps$impDatasets[[i]],
                          cut=unique(ex_dtsam$failtime[ex_dtsam$d==1]))
    mod &lt;- glm(d~-1+factor(tstart)+x1+x2, family="binomial", data=longData)
    ests[[i]] &lt;- coef(mod)
    vars[[i]] &lt;- diag(vcov(mod))
  }
  summary(MIcombine(ests,vars))


## End(Not run)
</code></pre>

<hr>
<h2 id='smcfcs.casecohort'>Substantive model compatible fully conditional specification imputation of covariates for case cohort studies</h2><span id='topic+smcfcs.casecohort'></span>

<h3>Description</h3>

<p>Multiply imputes missing covariate values using substantive model compatible
fully conditional specification for case cohort studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcfcs.casecohort(
  originaldata,
  smformula,
  sampfrac,
  in.subco,
  method,
  predictorMatrix = NULL,
  m = 5,
  numit = 10,
  rjlimit = 1000,
  noisy = FALSE,
  errorProneMatrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcfcs.casecohort_+3A_originaldata">originaldata</code></td>
<td>
<p>The case-cohort data set (NOT a full cohort data set with a case-cohort substudy within it)</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_smformula">smformula</code></td>
<td>
<p>A formula of the form &quot;Surv(entertime,t,d)~x&quot;, where d is the event (d=1) or censoring (d=0) indicator, t is the event or censoring time and entertime is equal to the time origin (typically 0) for individuals in the subcohort and is equal to (t-0.001) for cases outside the subcohort [this sets cases outside the subcohort to enter follow-up just before their event time. The value 0.001 may need to be modified depending on the time scale.]</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_sampfrac">sampfrac</code></td>
<td>
<p>The proportion of individuals from the underlying full cohort who are in the subcohort</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_in.subco">in.subco</code></td>
<td>
<p>The name of a column in the dataset with 0/1s that indicates whether the subject is in the subcohort</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_method">method</code></td>
<td>
<p>A required vector of strings specifying for each variable either
that it does not need to be imputed (&quot;&quot;), the type of regression model to be
be used to impute. Possible values are <code>"norm"</code> (normal linear regression),
<code>"logreg"</code> (logistic regression), <code>"brlogreg"</code> (bias reduced logistic regression),
<code>"poisson"</code> (Poisson regression),
<code>"podds"</code> (proportional odds regression for ordered categorical variables),
<code>"mlogit"</code> (multinomial logistic regression for unordered categorical variables),
or a custom expression which defines a passively imputed variable, e.g.
<code>"x^2"</code> or <code>"x1*x2"</code>. <code>"latnorm"</code> indicates the variable is a latent
normal variable which is measured with error. If this is specified for a variable,
the <code>"errorProneMatrix"</code> argument should also be used.</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>An optional predictor matrix. If specified, the matrix defines which
covariates will be used as predictors in the imputation models
(the outcome must not be included). The i'th row of the matrix should consist of
0s and 1s, with a 1 in the j'th column indicating the j'th variable be used
as a covariate when imputing the i'th variable. If not specified, when
imputing a given variable, the imputation model covariates are the other
covariates of the substantive model which are partially observed
(but which are not passively imputed) and any fully observed covariates (if present)
in the substantive model. Note that the outcome variable is implicitly conditioned
on by the rejection sampling scheme used by smcfcs, and should not be specified as a predictor
in the predictor matrix.</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_m">m</code></td>
<td>
<p>The number of imputed datasets to generate. The default is 5.</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_numit">numit</code></td>
<td>
<p>The number of iterations to run when generating each imputation.
In a (limited) range of simulations good performance was obtained with the
default of 10 iterations. However, particularly when the proportion of missingness
is large, more iterations may be required for convergence to stationarity.</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_rjlimit">rjlimit</code></td>
<td>
<p>Specifies the maximum number of attempts which should be made
when using rejection sampling to draw from imputation models. If the limit is reached
when running a warning will be issued. In this case it is probably advisable to
increase the <code>rjlimit</code> until the warning does not appear.</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_noisy">noisy</code></td>
<td>
<p>logical value (default FALSE) indicating whether output should be noisy, which can
be useful for debugging or checking that models being used are as desired.</p>
</td></tr>
<tr><td><code id="smcfcs.casecohort_+3A_errorpronematrix">errorProneMatrix</code></td>
<td>
<p>An optional matrix which if specified indicates that some variables
are measured with classical measurement error. If the i'th variable is measured with error
by variables j and k, then the (i,j) and (i,k) entries of this matrix should be 1, with the
remainder of entries 0. The i'th element of the method argument should then be specified
as <code>"latnorm"</code>. See the measurement error vignette for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of <code>smcfcs</code> is designed for use with case cohort studies but where the analyst does not wish to,
or cannot (due to not having the necessary data) impute the full cohort. The function's arguments are the same
as for the main smcfcs function, except for <code>smformula</code>, <code>in.subco</code>, and <code>sampfrac</code> - see above
for details on how these should be specified.
</p>


<h3>Author(s)</h3>

<p>Ruth Keogh <a href="mailto:ruth.keogh@lshtm.ac.uk">ruth.keogh@lshtm.ac.uk</a>
</p>
<p>Jonathan Bartlett <a href="mailto:j.w.bartlett@bath.ac.uk">j.w.bartlett@bath.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#the following example is not run when the package is compiled on CRAN
#(to keep computation time down), but it can be run by package users
## Not run: 
  #as per the documentation for ex_cc, the sampling fraction is 10%
  imps &lt;- smcfcs.casecohort(ex_cc, smformula="Surv(entertime, t, d)~x+z", sampfrac=0.1,
                            in.subco="in.subco", method=c("", "", "norm", "", "", "", ""))
  library(mitools)
  impobj &lt;- imputationList(imps$impDatasets)
  models &lt;- with(impobj, coxph(Surv(entertime,t,d)~x+z+cluster(id)))
  summary(MIcombine(models))

## End(Not run)
</code></pre>

<hr>
<h2 id='smcfcs.dtsam'>Substantive model compatible fully conditional specification imputation of covariates for
discrete time survival analysis</h2><span id='topic+smcfcs.dtsam'></span>

<h3>Description</h3>

<p>Multiply imputes missing covariate values using substantive model compatible
fully conditional specification for discrete time survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcfcs.dtsam(
  originaldata,
  smformula,
  timeEffects = "factor",
  method,
  predictorMatrix = NULL,
  m = 5,
  numit = 10,
  rjlimit = 1000,
  noisy = FALSE,
  errorProneMatrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcfcs.dtsam_+3A_originaldata">originaldata</code></td>
<td>
<p>The data in wide form (i.e. one row per subject)</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_smformula">smformula</code></td>
<td>
<p>A formula of the form &quot;Surv(t,d)~x1+x2+x3&quot;, where t is the discrete time variable, d is the binary event
indicator, and the covariates should not include time. The time variable should be
an integer coded numeric variable taking values from 1 up to the final time period.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_timeeffects">timeEffects</code></td>
<td>
<p>Specifies how the effect of time is modelled. <code>timeEffects="factor"</code> (the default) models time as a
factor variable. <code>timeEffects="linear"</code> and <code>timeEffects="quad"</code> specify that time be modelled as a continuous
linear or quadratic effect on the log odds scale respectively.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_method">method</code></td>
<td>
<p>A required vector of strings specifying for each variable either
that it does not need to be imputed (&quot;&quot;), the type of regression model to be
be used to impute. Possible values are <code>"norm"</code> (normal linear regression),
<code>"logreg"</code> (logistic regression), <code>"brlogreg"</code> (bias reduced logistic regression),
<code>"poisson"</code> (Poisson regression),
<code>"podds"</code> (proportional odds regression for ordered categorical variables),
<code>"mlogit"</code> (multinomial logistic regression for unordered categorical variables),
or a custom expression which defines a passively imputed variable, e.g.
<code>"x^2"</code> or <code>"x1*x2"</code>. <code>"latnorm"</code> indicates the variable is a latent
normal variable which is measured with error. If this is specified for a variable,
the <code>"errorProneMatrix"</code> argument should also be used.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>An optional predictor matrix. If specified, the matrix defines which
covariates will be used as predictors in the imputation models
(the outcome must not be included). The i'th row of the matrix should consist of
0s and 1s, with a 1 in the j'th column indicating the j'th variable be used
as a covariate when imputing the i'th variable. If not specified, when
imputing a given variable, the imputation model covariates are the other
covariates of the substantive model which are partially observed
(but which are not passively imputed) and any fully observed covariates (if present)
in the substantive model. Note that the outcome variable is implicitly conditioned
on by the rejection sampling scheme used by smcfcs, and should not be specified as a predictor
in the predictor matrix.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_m">m</code></td>
<td>
<p>The number of imputed datasets to generate. The default is 5.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_numit">numit</code></td>
<td>
<p>The number of iterations to run when generating each imputation.
In a (limited) range of simulations good performance was obtained with the
default of 10 iterations. However, particularly when the proportion of missingness
is large, more iterations may be required for convergence to stationarity.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_rjlimit">rjlimit</code></td>
<td>
<p>Specifies the maximum number of attempts which should be made
when using rejection sampling to draw from imputation models. If the limit is reached
when running a warning will be issued. In this case it is probably advisable to
increase the <code>rjlimit</code> until the warning does not appear.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_noisy">noisy</code></td>
<td>
<p>logical value (default FALSE) indicating whether output should be noisy, which can
be useful for debugging or checking that models being used are as desired.</p>
</td></tr>
<tr><td><code id="smcfcs.dtsam_+3A_errorpronematrix">errorProneMatrix</code></td>
<td>
<p>An optional matrix which if specified indicates that some variables
are measured with classical measurement error. If the i'th variable is measured with error
by variables j and k, then the (i,j) and (i,k) entries of this matrix should be 1, with the
remainder of entries 0. The i'th element of the method argument should then be specified
as <code>"latnorm"</code>. See the measurement error vignette for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this substantive model type, like for the other substantive model types, <code>smcfcs</code> expects the <code>originaldata</code> to have
one row per subject. Variables indicating the discrete time of failure/censoring
and the event indicator should be passed in <code>smformula</code>, as described.
</p>
<p>The default is to model the effect of time as a factor. This will not work in datasets where
there is not at least one observed event in each time period. In such cases you must specify
a simpler parametric model for the effect of time. At the moment you can specify either a linear or quadratic
effect of time (on the log odds scale).
</p>


<h3>Author(s)</h3>

<p>Jonathan Bartlett <a href="mailto:j.w.bartlett@bath.ac.uk">j.w.bartlett@bath.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#the following example is not run when the package is compiled on CRAN
#(to keep computation time down), but it can be run by package users
## Not run: 
  #discrete time survival analysis example
  M &lt;- 5
  imps &lt;- smcfcs.dtsam(ex_dtsam, "Surv(failtime,d)~x1+x2",
                 method=c("logreg","", "", ""),m=M)
  #fit dtsam model to each dataset manually, since we need
  #to expand to person-period data form first
  ests &lt;- vector(mode = "list", length = M)
  vars &lt;- vector(mode = "list", length = M)
  for (i in 1:M) {
    longData &lt;- survSplit(Surv(failtime,d)~x1+x2, data=imps$impDatasets[[i]],
                          cut=unique(ex_dtsam$failtime[ex_dtsam$d==1]))
    mod &lt;- glm(d~-1+factor(tstart)+x1+x2, family="binomial", data=longData)
    ests[[i]] &lt;- coef(mod)
    vars[[i]] &lt;- diag(vcov(mod))
  }
  library(mitools)
  summary(MIcombine(ests,vars))

## End(Not run)
</code></pre>

<hr>
<h2 id='smcfcs.finegray'>Substantive model compatible fully conditional specification imputation of
covariates for a Fine-Gray model</h2><span id='topic+smcfcs.finegray'></span>

<h3>Description</h3>

<p>Multiply imputes missing covariate values using substantive model compatible
fully conditional specification for competing risks outcomes, when the
substantive model is a Fine-Gray model for the subdistribution hazard of one event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcfcs.finegray(
  originaldata,
  smformula,
  method,
  cause = 1,
  m = 5,
  numit = 10,
  rjlimit = 5000,
  kmi_args = list(formula = ~1, bootstrap = FALSE, nboot = 10),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcfcs.finegray_+3A_originaldata">originaldata</code></td>
<td>
<p>The original data frame with missing values.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_smformula">smformula</code></td>
<td>
<p>The formula of the substantive model, given as a string. Needs to
be of the form &quot;Surv(t, d) ~ x1 + x2&quot;, where t is a vector of competing event
times, and d is a (numeric) competing event indicator, where 0 must designate
a censored observation.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_method">method</code></td>
<td>
<p>A required vector of strings specifying for each variable either
that it does not need to be imputed (&quot;&quot;), the type of regression model to be
be used to impute. Possible values are <code>"norm"</code> (normal linear regression),
<code>"logreg"</code> (logistic regression), <code>"brlogreg"</code> (bias reduced logistic regression),
<code>"poisson"</code> (Poisson regression),
<code>"podds"</code> (proportional odds regression for ordered categorical variables),
<code>"mlogit"</code> (multinomial logistic regression for unordered categorical variables),
or a custom expression which defines a passively imputed variable, e.g.
<code>"x^2"</code> or <code>"x1*x2"</code>. <code>"latnorm"</code> indicates the variable is a latent
normal variable which is measured with error. If this is specified for a variable,
the <code>"errorProneMatrix"</code> argument should also be used.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_cause">cause</code></td>
<td>
<p>Numeric, designating the competing event of interest (default is
'cause = 1').</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_m">m</code></td>
<td>
<p>The number of imputed datasets to generate. The default is 5.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_numit">numit</code></td>
<td>
<p>The number of iterations to run when generating each imputation.
In a (limited) range of simulations good performance was obtained with the
default of 10 iterations. However, particularly when the proportion of missingness
is large, more iterations may be required for convergence to stationarity.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_rjlimit">rjlimit</code></td>
<td>
<p>Specifies the maximum number of attempts which should be made
when using rejection sampling to draw from imputation models. If the limit is reached
when running a warning will be issued. In this case it is probably advisable to
increase the <code>rjlimit</code> until the warning does not appear.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_kmi_args">kmi_args</code></td>
<td>
<p>List, containing arguments to be passed on to <a href="kmi.html#topic+kmi">kmi</a>.
The &quot;formula&quot; element is a formula where the right-hand side specifies the
covariates used for multiply imputing the potential censoring times for
individual's failing from competing events. The default is 'formula = ~ 1',
which uses marginal Kaplan-Meier estimator of the censoring distribution.</p>
</td></tr>
<tr><td><code id="smcfcs.finegray_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass on to <a href="#topic+smcfcs">smcfcs</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the presence of random right censoring, the function first multiply imputes
the potential censoring times for those failing from competing events using
<a href="kmi.html#topic+kmi">kmi</a>, and thereafter uses <a href="#topic+smcfcs">smcfcs</a> to impute the missing
covariates. See Bonneville <em>et al.</em> 2024 for further details on the methodology.
</p>
<p>The function does not (yet) support parallel computation.
</p>


<h3>Value</h3>

<p>An object of type &quot;smcfcs&quot;, as would usually be returned from
<a href="#topic+smcfcs">smcfcs</a>.
</p>


<h3>Author(s)</h3>

<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>


<h3>References</h3>

<p>Bonneville EF, Beyersmann J, Keogh RH, Bartlett JW, Morris TP,
Polverelli N, de Wreede LC, Putter H. Multiple imputation of missing covariates
when using the Fine&ndash;Gray model. 2024. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(survival)
library(kmi)

imps &lt;- smcfcs.finegray(
  originaldata = ex_finegray,
  smformula = "Surv(times, d) ~ x1 + x2",
  method = c("", "", "logreg", "norm"),
  cause = 1,
  kmi_args = list("formula" = ~ 1)
)

if (requireNamespace("mitools", quietly = TRUE)) {
  library(mitools)
  impobj &lt;- imputationList(imps$impDatasets)
  # Important: use Surv(newtimes, newevent) ~ ... when pooling
  # (respectively: subdistribution time and indicator for cause of interest)
  models &lt;- with(impobj, coxph(Surv(newtimes, newevent) ~ x1 + x2))
  summary(MIcombine(models))
}

## End(Not run)

</code></pre>

<hr>
<h2 id='smcfcs.nestedcc'>Substantive model compatible fully conditional specification imputation of covariates for nested case control
studies</h2><span id='topic+smcfcs.nestedcc'></span>

<h3>Description</h3>

<p>Multiply imputes missing covariate values using substantive model compatible
fully conditional specification for nested case control studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcfcs.nestedcc(
  originaldata,
  smformula,
  set,
  event,
  nrisk,
  method,
  predictorMatrix = NULL,
  m = 5,
  numit = 10,
  rjlimit = 1000,
  noisy = FALSE,
  errorProneMatrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcfcs.nestedcc_+3A_originaldata">originaldata</code></td>
<td>
<p>The nested case-control data set (NOT a full cohort data set with a case-cohort substudy within it)</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_smformula">smformula</code></td>
<td>
<p>A formula of the form &quot;Surv(t,case)~x+strata(set)&quot;, where case is case-control indicator, t is the event or censoring time. Note that t could be set to the case's event time for the matched controls in a given set. The right hand side should include the case control set as a strata term (see example).</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_set">set</code></td>
<td>
<p>variable identifying matched sets in nested case-control study</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_event">event</code></td>
<td>
<p>variable which indicates who is a case/control in the nested case-control sample. Note that this is distinct from d.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_nrisk">nrisk</code></td>
<td>
<p>variable which is the number at risk (in the underlying full cohort) at the event time for the case in each matched set (i.e. nrisk is the same for all individuals in a matched set).</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_method">method</code></td>
<td>
<p>A required vector of strings specifying for each variable either
that it does not need to be imputed (&quot;&quot;), the type of regression model to be
be used to impute. Possible values are <code>"norm"</code> (normal linear regression),
<code>"logreg"</code> (logistic regression), <code>"brlogreg"</code> (bias reduced logistic regression),
<code>"poisson"</code> (Poisson regression),
<code>"podds"</code> (proportional odds regression for ordered categorical variables),
<code>"mlogit"</code> (multinomial logistic regression for unordered categorical variables),
or a custom expression which defines a passively imputed variable, e.g.
<code>"x^2"</code> or <code>"x1*x2"</code>. <code>"latnorm"</code> indicates the variable is a latent
normal variable which is measured with error. If this is specified for a variable,
the <code>"errorProneMatrix"</code> argument should also be used.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>An optional predictor matrix. If specified, the matrix defines which
covariates will be used as predictors in the imputation models
(the outcome must not be included). The i'th row of the matrix should consist of
0s and 1s, with a 1 in the j'th column indicating the j'th variable be used
as a covariate when imputing the i'th variable. If not specified, when
imputing a given variable, the imputation model covariates are the other
covariates of the substantive model which are partially observed
(but which are not passively imputed) and any fully observed covariates (if present)
in the substantive model. Note that the outcome variable is implicitly conditioned
on by the rejection sampling scheme used by smcfcs, and should not be specified as a predictor
in the predictor matrix.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_m">m</code></td>
<td>
<p>The number of imputed datasets to generate. The default is 5.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_numit">numit</code></td>
<td>
<p>The number of iterations to run when generating each imputation.
In a (limited) range of simulations good performance was obtained with the
default of 10 iterations. However, particularly when the proportion of missingness
is large, more iterations may be required for convergence to stationarity.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_rjlimit">rjlimit</code></td>
<td>
<p>Specifies the maximum number of attempts which should be made
when using rejection sampling to draw from imputation models. If the limit is reached
when running a warning will be issued. In this case it is probably advisable to
increase the <code>rjlimit</code> until the warning does not appear.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_noisy">noisy</code></td>
<td>
<p>logical value (default FALSE) indicating whether output should be noisy, which can
be useful for debugging or checking that models being used are as desired.</p>
</td></tr>
<tr><td><code id="smcfcs.nestedcc_+3A_errorpronematrix">errorProneMatrix</code></td>
<td>
<p>An optional matrix which if specified indicates that some variables
are measured with classical measurement error. If the i'th variable is measured with error
by variables j and k, then the (i,j) and (i,k) entries of this matrix should be 1, with the
remainder of entries 0. The i'th element of the method argument should then be specified
as <code>"latnorm"</code>. See the measurement error vignette for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of <code>smcfcs</code> is designed for use with nested case control studies. The function's arguments are the same
as for the main smcfcs function, except for <code>smformula</code>, <code>set</code>, <code>event</code> and <code>nrisk</code> - see above
for details on how these should be specified.
</p>


<h3>Author(s)</h3>

<p>Ruth Keogh <a href="mailto:ruth.keogh@lshtm.ac.uk">ruth.keogh@lshtm.ac.uk</a>
</p>
<p>Jonathan Bartlett <a href="mailto:j.w.bartlett@bath.ac.uk">j.w.bartlett@bath.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#the following example is not run when the package is compiled on CRAN
#(to keep computation time down), but it can be run by package users
## Not run: 
  predictorMatrix &lt;- matrix(0,nrow=dim(ex_ncc)[2],ncol=dim(ex_ncc)[2])
  predictorMatrix[which(colnames(ex_ncc)=="x"),c(which(colnames(ex_ncc)=="z"))] &lt;- 1

  imps &lt;- smcfcs.nestedcc(originaldata=ex_ncc,set="setno",nrisk="numrisk",event="d",
                          smformula="Surv(t,case)~x+z+strata(setno)",
                          method=c("", "", "logreg", "", "", "", "", ""),
                          predictorMatrix=predictorMatrix)
  library(mitools)
  impobj &lt;- imputationList(imps$impDatasets)
  models &lt;- with(impobj, clogit(case~x+z+strata(setno)))
  summary(MIcombine(models))

## End(Not run)
</code></pre>

<hr>
<h2 id='smcfcs.parallel'>Parallel substantive model compatible imputation</h2><span id='topic+smcfcs.parallel'></span>

<h3>Description</h3>

<p>Runs substantive model compatible imputation using parallel cores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcfcs.parallel(
  smcfcs_func = "smcfcs",
  seed = NULL,
  m = 5,
  n_cores = parallel::detectCores() - 1,
  cl_type = "PSOCK",
  outfile = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcfcs.parallel_+3A_smcfcs_func">smcfcs_func</code></td>
<td>
<p>Specifies which base smcfcs function to call. Possible values
are 'smcfcs', 'smcfcs.casecohort', 'smcfcs.dtasam', 'smcfcs.nestedcc'. Defaults
to 'smcfcs'.</p>
</td></tr>
<tr><td><code id="smcfcs.parallel_+3A_seed">seed</code></td>
<td>
<p>Optional seed, set as 'set.seed' when 'n_cores = 1',
or as 'parallel::clusterSetRNGStream' when 'n_cores &gt; 1'.</p>
</td></tr>
<tr><td><code id="smcfcs.parallel_+3A_m">m</code></td>
<td>
<p>Number of imputed datasets to generate.</p>
</td></tr>
<tr><td><code id="smcfcs.parallel_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores over which to split the 'm' imputations. If
'n_cores' is not divisible exactly by 'm', one of the cores will perform
more/less imputations that the rest such that the final result still contains
'm' imputed datasets.</p>
</td></tr>
<tr><td><code id="smcfcs.parallel_+3A_cl_type">cl_type</code></td>
<td>
<p>Either &quot;PSOCK&quot; or &quot;FORK&quot;. If running on a Windows system
&quot;PSOCK&quot; is recommended, otherwise for Linux/Mac machines &quot;FORK&quot; tends to
offer faster computation - see <a href="mice.html#topic+parlmice">parlmice</a>.</p>
</td></tr>
<tr><td><code id="smcfcs.parallel_+3A_outfile">outfile</code></td>
<td>
<p>Optional character path to location for
output from the workers. Useful to diagnose rejection sampling warnings.
File path must be formulated as &quot;path/to/filename.txt&quot;.</p>
</td></tr>
<tr><td><code id="smcfcs.parallel_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass on to <a href="#topic+smcfcs">smcfcs</a>,
<a href="#topic+smcfcs.casecohort">smcfcs.casecohort</a>,
<a href="#topic+smcfcs.dtsam">smcfcs.dtsam</a>, or
<a href="#topic+smcfcs.nestedcc">smcfcs.nestedcc</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to call one of the substantive model compatible imputation
methods using parallel cores, to reduce computation time. You must specify
the arguments required for the standard smcfcs call, and then specify your
the arguments for how to use parallel cores.
</p>


<h3>Value</h3>

<p>An object of type &quot;smcfcs&quot;, as would usually be returned from
<a href="#topic+smcfcs">smcfcs</a>.
</p>


<h3>Author(s)</h3>

<p>Edouard F. Bonneville <a href="mailto:e.f.bonneville@lumc.nl">e.f.bonneville@lumc.nl</a>
</p>
<p>Jonathan Bartlett <a href="mailto:jonathan.bartlett1@lshtm.ac.uk">jonathan.bartlett1@lshtm.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Detect number of cores
parallel::detectCores()

imps &lt;- smcfcs.parallel(
  smcfcs_func = "smcfcs",
  seed = 2021,
  n_cores = 2,
  originaldata = smcfcs::ex_compet,
  m = 10,
  smtype = "compet",
  smformula = list(
    "Surv(t, d == 1) ~ x1 + x2",
    "Surv(t, d == 2) ~ x1 + x2"
  ),
  method = c("", "", "norm", "norm")
)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
