<!DOCTYPE html><html lang="en"><head><title>Help for package epinetr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epinetr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addEffects'><p>Attach additive effects to population.</p></a></li>
<li><a href='#attachEpiNet'><p>Attach epistatic network to population.</p></a></li>
<li><a href='#epinetr'><p>epinetr</p></a></li>
<li><a href='#geno100snp'><p>Example genotype matrix.</p></a></li>
<li><a href='#getAddCoefs'><p>Get additive coefficients.</p></a></li>
<li><a href='#getAddOffset'><p>Retrieve additive offset.</p></a></li>
<li><a href='#getAlleleFreqRun'><p>Get allele frequencies.</p></a></li>
<li><a href='#getComponents'><p>Get phenotypic components.</p></a></li>
<li><a href='#getEpiNet'><p>Epistatic network retrieval.</p></a></li>
<li><a href='#getEpiOffset'><p>Retrieve epistatic offset.</p></a></li>
<li><a href='#getEpistasis'><p>Calculate epistatic interactions.</p></a></li>
<li><a href='#getGeno'><p>Get population unphased genotypes.</p></a></li>
<li><a href='#getHaplo'><p>Retrieve haplotypes.</p></a></li>
<li><a href='#getIncMatrix'><p>Incidence matrix retrieval.</p></a></li>
<li><a href='#getInteraction'><p>Retrieve interaction values.</p></a></li>
<li><a href='#getPedigree'><p>Get population pedigree.</p></a></li>
<li><a href='#getPhased'><p>Get population phased genotypes.</p></a></li>
<li><a href='#getQTL'><p>QTL retrieval.</p></a></li>
<li><a href='#getSubPop'><p>Get subpopulation</p></a></li>
<li><a href='#loadGeno'><p>Load epinetr genotype file.</p></a></li>
<li><a href='#map100snp'><p>Example map.</p></a></li>
<li><a href='#plot.EpiNet'><p>Plot epistatic network.</p></a></li>
<li><a href='#plot.Population'><p>Plot phenotypic value for a population.</p></a></li>
<li><a href='#Population'><p>Population constructor.</p></a></li>
<li><a href='#print.Population'><p>Print function for population.</p></a></li>
<li><a href='#rincmat100snp'><p>Example incidence matrix.</p></a></li>
<li><a href='#runSim'><p>Run simulation on population.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Epistatic Network Modelling with Forward-Time Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.96</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows for forward-in-time simulation of epistatic networks with associated
    phenotypic output.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/diondetterer/epinetr">https://github.com/diondetterer/epinetr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/diondetterer/epinetr/issues">https://github.com/diondetterer/epinetr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>GA (&ge; 3.2), ggplot2 (&ge; 3.1.1), igraph (&ge; 1.2.4), methods
(&ge; 2.10), Rcpp (&ge; 0.12.18), RcppAlgos (&ge; 2.4.1), reshape2
(&ge; 1.4.3), vcfR (&ge; 1.8.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-09 01:27:12 UTC; User</td>
</tr>
<tr>
<td>Author:</td>
<td>Dion Detterer [aut, cre],
  Paul Kwan [aut],
  Cedric Gondro [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dion Detterer &lt;ddettere@myune.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-10 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addEffects'>Attach additive effects to population.</h2><span id='topic+addEffects'></span>

<h3>Description</h3>

<p>Attach additive effects to a <code>Population</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEffects(pop, effects = NULL, distrib = rnorm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addEffects_+3A_pop">pop</code></td>
<td>
<p>an object of class <code>Population</code>.</p>
</td></tr>
<tr><td><code id="addEffects_+3A_effects">effects</code></td>
<td>
<p>an optional vector of additive effect coefficients.</p>
</td></tr>
<tr><td><code id="addEffects_+3A_distrib">distrib</code></td>
<td>
<p>an optional random number generator function for a
distribution, defaulting to <code><a href="stats.html#topic+rnorm">rnorm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>addEffects()</code> is a function for attaching additive effects to a given
population, ensuring that the initial additive variance is as given in the
population parameters.
</p>
<p>If additive effect coefficients are directly supplied via the <code>effects</code>
vector, these may be scaled in order to comply with the initial additive
variance.
</p>


<h3>Value</h3>

<p>A copy of the supplied <code>Population</code> object is returned, with
additive effects attached.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+attachEpiNet">attachEpiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create population
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)

# Attach additive effects using a normal distribution
pop &lt;- addEffects(pop)

# Attach additive effects using a uniform distribution
pop2 &lt;- addEffects(pop, distrib = runif)

# Attach additive effects using a vector of coefficients
effects &lt;- c(
  1.2, 1.5, -0.3, -1.4, 0.8,
  2.4, 0.2, -0.8, -0.4, 0.8,
  -0.2, -1.4, 1.4, 0.2, -0.9,
  0.4, -0.8, 0.0, -1.1, -1.3
)
pop3 &lt;- addEffects(pop, effects = effects)

# Print first population
pop

# Print second population
pop2

# Print third population
pop3
</code></pre>

<hr>
<h2 id='attachEpiNet'>Attach epistatic network to population.</h2><span id='topic+attachEpiNet'></span>

<h3>Description</h3>

<p>Constructs and attaches a new epistatic network between QTLs to a given
<code>Population</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attachEpiNet(pop, scaleFree = FALSE, k = 2, m = 1, additive = 0, incmat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attachEpiNet_+3A_pop">pop</code></td>
<td>
<p>the <code>Population</code> object to which the epistatic network will
be attached</p>
</td></tr>
<tr><td><code id="attachEpiNet_+3A_scalefree">scaleFree</code></td>
<td>
<p>an optional logical value indicating whether to construct
a network using the Barabasi-Albert model for generating scale-free
networks</p>
</td></tr>
<tr><td><code id="attachEpiNet_+3A_k">k</code></td>
<td>
<p>an optional vector listing orders of interaction to include</p>
</td></tr>
<tr><td><code id="attachEpiNet_+3A_m">m</code></td>
<td>
<p>an optional integer indicating the minimum number of interactions
for each QTL; see details below</p>
</td></tr>
<tr><td><code id="attachEpiNet_+3A_additive">additive</code></td>
<td>
<p>an optional integer indicating the number of QTLs which
will remain purely additive</p>
</td></tr>
<tr><td><code id="attachEpiNet_+3A_incmat">incmat</code></td>
<td>
<p>an optional incidence matrix specifying a user-defined
network</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>attachEpiNet()</code> can be used to construct a new epistatic network based
either on stochastic processes or by adapting a user-supplied incidence
matrix.
</p>
<p>If <code>scaleFree</code> is <code>FALSE</code>, a network is constructed at random; if
it is <code>TRUE</code>, however, a scale-free network is constructed between QTLs
using the Barabasi-Albert model. (The random network is constructed using
the same algorithm but without preferential attachment.)
</p>
<p>A minimal initial network of randomly selected QTLs is first constructed,
before then growing the network using randomly selected QTLs, preferentially
attaching each QTL to at least <code>m</code> other QTLs (in the scale-free case).
For increasing orders of interaction, degrees from lower orders of
interaction are used when determining preferential attachment.
</p>
<p>If a user-supplied incidence matrix is given via the <code>incmat</code>
argument, the <code>scaleFree</code>, <code>k</code> and <code>m</code> arguments are ignored,
and the network structure is instead derived from the incidence matrix. The
matrix should be such that the rows represent QTLs and the columns represent
interactions between QTLs: a <code>1</code> at both <code>incmat[i1,j]</code> and
<code>incmat[i2,j]</code> means there is an interaction between the QTLs
<code>i1</code> and <code>i2</code>.
</p>
<p>The contributions that interactions make towards the phenotypic value are
generated randomly when this function is called, based on a normal
distribution. By default, each order of interaction has the same variance;
however, using the <code>varfun</code> argument, a function can be supplied to
alter the variance per order of interaction.
</p>
<p>Internally, each QTL is assigned a randomly generated value per
interaction per genotype (i.e. the heterozygous genotype and the two
homozygous genotypes), and these values are summed according to the value
of the genotype.
</p>


<h3>Value</h3>

<p>A copy of the supplied <code>Population</code> is returned, with the new
epistatic network attached.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>References</h3>

<p>Barabasi AL, Albert R, 'Emergence of scaling in random networks,'
<em>Science</em> 286(5439): 509-12, 15 October 1999.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+getEpiNet">getEpiNet</a></code>,
<code><a href="#topic+plot.EpiNet">plot.EpiNet</a></code>, <code><a href="#topic+addEffects">addEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a population and attach additive effects
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)
pop &lt;- addEffects(pop)

# Attach a random epistatic network with two- to four-way
# interactions between QTLs
popRnd &lt;- attachEpiNet(pop, k = 2:4)

# Plot random network
plot(getEpiNet(popRnd))

# Attach a scale-free epistatic network with two-way interactions
# between QTLs and a minimum of three interactions per QTL
popSF &lt;- attachEpiNet(pop, scaleFree = TRUE, m = 3)

# Plot scale-free network
plot(getEpiNet(popSF))

# Attach user-defined epistatic network
popUser &lt;- attachEpiNet(pop, incmat = rincmat100snp)

# Plot user-defined network
plot(getEpiNet(popUser))

# Attach a random epistatic network with two- to ten-way
# interactions between QTLs and decaying variance
popDecay &lt;- attachEpiNet(pop, k = 2:10)

</code></pre>

<hr>
<h2 id='epinetr'>epinetr</h2><span id='topic+epinetr'></span>

<h3>Description</h3>

<p>epinetr is a package intended to aid in the investigation of the
contribution of epistatic networks to complex traits,
</p>


<h3>Details</h3>

<p>This package provides a range of functions for running
forward-time simulation using epistatic networks, including
visualisation tools.
</p>
<p>For a complete list of functions, use library(help = &quot;epinetr&quot;).
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>

<hr>
<h2 id='geno100snp'>Example genotype matrix.</h2><span id='topic+geno100snp'></span>

<h3>Description</h3>

<p>An example genotype matrix for 100 SNPs across 500 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno100snp
</code></pre>


<h3>Format</h3>

<p><code>geno100snp</code> is a matrix with 500 rows and 200
columns, used in examples when constructing a population from
genotypes using 500 individuals and 100 SNPs.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+map100snp">map100snp</a></code>
</p>

<hr>
<h2 id='getAddCoefs'>Get additive coefficients.</h2><span id='topic+getAddCoefs'></span>

<h3>Description</h3>

<p>Retrieve additive coefficients from population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAddCoefs(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAddCoefs_+3A_pop">pop</code></td>
<td>
<p>a <code>Population</code> object with additive effects
attached</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getAddCoefs</code> retrieves the additive coefficients currently
in use in a <code>Population</code> object, assuming additive effects
have been attached.
</p>


<h3>Value</h3>

<p><code>getAddCoefs</code> returns the additive coefficients
currently in use by the population.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addEffects">addEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a population with additive effects
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.6, narrowh2 = 0.6, traitVar = 40
)
pop &lt;- addEffects(pop)

# Get additive coefficients
additive &lt;- getAddCoefs(pop)
</code></pre>

<hr>
<h2 id='getAddOffset'>Retrieve additive offset.</h2><span id='topic+getAddOffset'></span>

<h3>Description</h3>

<p>Retrieve offset used for calculating additive component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAddOffset(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAddOffset_+3A_pop">pop</code></td>
<td>
<p>A valid <code>Population</code> object with additive effects
attached</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for the initial population to have an additive
component with a mean of 0 for its phenotype, an offset is added,
and it remains fixed across generations. This function retrieves
that offset.
</p>


<h3>Value</h3>

<p>The additive offset is returned.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAddCoefs">getAddCoefs</a></code>, <code><a href="#topic+addEffects">addEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a new population with additive effects
pop &lt;- Population(
  popSize = 20, map = map100snp, QTL = 20,
  broadH2 = 0.4, narrowh2 = 0.4, traitVar = 40,
  alleleFrequencies = runif(100, 0.05, 0.5)
)
pop &lt;- addEffects(pop)

# Find the additive contribution to the individuals' phenotypes
hap &lt;- getHaplo(pop)
hap &lt;- (hap[[1]] + hap[[2]])[, getQTL(pop)$Index]
(hap %*% getAddCoefs(pop))[, 1] + getAddOffset(pop)

# Compare with additive component from getComponents()
getComponents(pop)$Additive
</code></pre>

<hr>
<h2 id='getAlleleFreqRun'>Get allele frequencies.</h2><span id='topic+getAlleleFreqRun'></span>

<h3>Description</h3>

<p>Get allele frequencies across a simulation run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAlleleFreqRun(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAlleleFreqRun_+3A_pop">pop</code></td>
<td>
<p>a <code>Population</code> object as returned by a previous
simulation run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves the allele frequencies in each generation across a
simulation run.
</p>


<h3>Value</h3>

<p>Returns a matrix of allele frequencies, one generation per
row.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runSim">runSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Construct a population with additive and epistatic effects
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)
pop &lt;- addEffects(pop)
pop &lt;- attachEpiNet(pop)

# Run the simulator
pop2 &lt;- runSim(pop, generations = 150)

af &lt;- getAlleleFreqRun(pop2)

</code></pre>

<hr>
<h2 id='getComponents'>Get phenotypic components.</h2><span id='topic+getComponents'></span>

<h3>Description</h3>

<p>Get pedigree and phenotypic data from current population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getComponents(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getComponents_+3A_pop">pop</code></td>
<td>
<p>a <code>Population</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves the pedigree and phenotypic data components from all
individuals in the current population.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> giving the individual's ID,
the ID of the sire, the ID of the dam, the additive, epistatic and
environmental components of the phenotype and the overall
phenotypic value.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+addEffects">addEffects</a></code>,
<code><a href="#topic+attachEpiNet">attachEpiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a population with additive and epistatic effects
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)
pop &lt;- addEffects(pop)
pop &lt;- attachEpiNet(pop)

# Retrieve phenotypic components from population
components &lt;- getComponents(pop)
</code></pre>

<hr>
<h2 id='getEpiNet'>Epistatic network retrieval.</h2><span id='topic+getEpiNet'></span>

<h3>Description</h3>

<p>Get an epistatic network from a <code>Population</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEpiNet(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEpiNet_+3A_pop">pop</code></td>
<td>
<p>An object of class <code>'Population'</code> which has an
<code>EpiNet</code> object attached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getEpiNet()</code> is merely a function for retrieving an
epistatic network object. The common purpose is to plot the
network.
</p>


<h3>Value</h3>

<p>An object of class <code>'EpiNet'</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+plot.EpiNet">plot.EpiNet</a></code>,
<code><a href="#topic+attachEpiNet">attachEpiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create population and attach an epistatic network
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0, traitVar = 40
)
pop &lt;- attachEpiNet(pop)

# Plot epistatic network
epiNet &lt;- getEpiNet(pop)
plot(epiNet)
</code></pre>

<hr>
<h2 id='getEpiOffset'>Retrieve epistatic offset.</h2><span id='topic+getEpiOffset'></span>

<h3>Description</h3>

<p>Retrieve offset used for calculating epistatic component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEpiOffset(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEpiOffset_+3A_pop">pop</code></td>
<td>
<p>A valid <code>Population</code> object with epistatic effects
attached</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for the initial population to have an epistatic
component with a mean of 0 for its phenotype, an offset is added,
and it remains fixed across generations. This function retrieves
that offset.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEpistasis">getEpistasis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a new population with epistatic effects
pop &lt;- Population(
  popSize = 20, map = map100snp, QTL = 20,
  broadH2 = 0.4, narrowh2 = 0, traitVar = 40,
  alleleFrequencies = runif(100, 0.05, 0.5)
)
pop &lt;- attachEpiNet(pop)

# Find the epistatic contribution to the individuals' phenotypes
rowSums(getEpistasis(pop)) + getEpiOffset(pop)

# Compare with epistatic component from getComponents()
getComponents(pop)$Epistatic
</code></pre>

<hr>
<h2 id='getEpistasis'>Calculate epistatic interactions.</h2><span id='topic+getEpistasis'></span>

<h3>Description</h3>

<p>Calculate epistatic interactions for members of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEpistasis(pop, scale = TRUE, geno = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEpistasis_+3A_pop">pop</code></td>
<td>
<p>a valid <code>Population</code> object with epistatic effects
attached</p>
</td></tr>
<tr><td><code id="getEpistasis_+3A_scale">scale</code></td>
<td>
<p>a boolean value indicating whether to scale the
values to bring them in line with the desired initial variance</p>
</td></tr>
<tr><td><code id="getEpistasis_+3A_geno">geno</code></td>
<td>
<p>by default, the function uses the current genotypes
in the population; alternatively, <code>geno</code> is a user-supplied
set of genotypes (limited to QTLs) on which to base the
calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the values of each epistatic interaction
per individual, returning a matrix whose rows are the individuals
in the population and whose columns are the epistatic
interactions. The sums of these rows represent the total epistatic
contribution to the phenotype, once the epistatic offset is added.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEpiOffset">getEpiOffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a new population with epistatic effects
pop &lt;- Population(
  popSize = 20, map = map100snp, QTL = 20,
  broadH2 = 0.4, narrowh2 = 0, traitVar = 40,
  alleleFrequencies = runif(100, 0.05, 0.5)
)
pop &lt;- attachEpiNet(pop)

# Find the epistatic contribution to the individuals' phenotypes
rowSums(getEpistasis(pop)) + getEpiOffset(pop)

# Compare with epistatic component from getComponents()
getComponents(pop)$Epistatic
</code></pre>

<hr>
<h2 id='getGeno'>Get population unphased genotypes.</h2><span id='topic+getGeno'></span>

<h3>Description</h3>

<p>Retrieves the current unphased genotypes in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGeno(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGeno_+3A_pop">pop</code></td>
<td>
<p>a valid <code>Population</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getGeno</code> retrieves the current unphased genotypes in the population,
returning a single matrix with one individual per row and one SNP per
column.
</p>


<h3>Value</h3>

<p>Returns an unphased genotypes matrix.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+getPhased">getPhased</a></code>, <code><a href="#topic+getHaplo">getHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a population
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)

# Retrieve genotypes
geno &lt;- getGeno(pop)
</code></pre>

<hr>
<h2 id='getHaplo'>Retrieve haplotypes.</h2><span id='topic+getHaplo'></span>

<h3>Description</h3>

<p>Retrieve haplotypes from the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHaplo(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHaplo_+3A_pop">pop</code></td>
<td>
<p>a valid <code>Population</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves the haplotypes from both the population which, when
added together, form the genotypes.
</p>


<h3>Value</h3>

<p>A list is returned with two elements, corresponding to the
two haplotype matrices.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAddCoefs">getAddCoefs</a></code>, <code><a href="#topic+getAddOffset">getAddOffset</a></code>, <code><a href="#topic+getPhased">getPhased</a></code>, <code><a href="#topic+getGeno">getGeno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a new population with additive effects
pop &lt;- Population(
  popSize = 20, map = map100snp, QTL = 20,
  broadH2 = 0.4, narrowh2 = 0.4, traitVar = 40,
  alleleFrequencies = runif(100, 0.05, 0.5)
)
pop &lt;- addEffects(pop)

# Find the additive contribution to the individuals' phenotypes
hap &lt;- getHaplo(pop)
hap &lt;- (hap[[1]] + hap[[2]])[, getQTL(pop)$Index]
(hap %*% getAddCoefs(pop))[, 1] + getAddOffset(pop)
</code></pre>

<hr>
<h2 id='getIncMatrix'>Incidence matrix retrieval.</h2><span id='topic+getIncMatrix'></span>

<h3>Description</h3>

<p>Get an incidence matrix from a <code>Population</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIncMatrix(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIncMatrix_+3A_pop">pop</code></td>
<td>
<p>An object of class <code>'Population'</code> which has an
<code>EpiNet</code> object attached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getIncMatrix()</code> retrieves the incidence matrix used in
epistatic interactions within the given <code>Population</code> object.
This is most useful for copying the network structure to a new
<code>Population</code> object.
</p>


<h3>Value</h3>

<p>An incidence matrix representing the epistatic network
within the given <code>Population</code> object.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attachEpiNet">attachEpiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create population
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0, traitVar = 40
)

# Attach random epistatic network and retrieve incidence matrix
pop &lt;- attachEpiNet(pop)
inc &lt;- getIncMatrix(pop)

# Create second population
pop2 &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.8, narrowh2 = 0.6, traitVar = 40
)

# Attach epistatic network to second population
# using incidence matrix from first
pop2 &lt;- attachEpiNet(pop2, incmat = inc)
</code></pre>

<hr>
<h2 id='getInteraction'>Retrieve interaction values.</h2><span id='topic+getInteraction'></span>

<h3>Description</h3>

<p>Retrieve  values for an interaction within an epistatic network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInteraction(pop, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInteraction_+3A_pop">pop</code></td>
<td>
<p>a valid population object</p>
</td></tr>
<tr><td><code id="getInteraction_+3A_n">n</code></td>
<td>
<p>the interaction to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a <code class="reqn">k</code>-dimensional array for a particular
interaction, where <code class="reqn">k</code> is the order of interaction and the
array holds <code class="reqn">3^k</code> entries . This means that a 5-way
interaction, for example, will return a 5-dimensional array
consisting of <code class="reqn">3^5 = 243</code> entries.
</p>
<p>Within each dimension, the three indices (1, 2 and 3) correspond
to the homozygous genotype coded 0/0, the heterozygous genotype
and the homozygous genotype coded 1/1, respectively. Each entry
is drawn from a normal distribution. (Any offset needs to be
applied manually using <code>getEpiOffset</code>.)
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attachEpiNet">attachEpiNet</a></code>, <code><a href="#topic+getEpiOffset">getEpiOffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a new population
pop &lt;- Population(
  popSize = 150, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100), broadH2 = 0.7,
  narrowh2 = 0.45, traitVar = 40
)

# Attach additive effects
pop &lt;- addEffects(pop)

# Attach a network of epistatic effects
pop &lt;- attachEpiNet(pop)

# Retrieve the possible values for the first two-way interaction
getInteraction(pop, 1)

# Retrieve the value for the case where, in the fourth two-way
# interaction, the first QTL in the interaction is heterozygous
# and the second QTL in the interaction is the homozygous
# reference genotype.
getInteraction(pop, 4)[2, 1]

# Retrieve the value for the case where, in the second two-way
# interaction, the first QTL in the interaction is the homozygous
# reference genotype and the second QTL in the interaction is the
# homozygous alternative genotype.
getInteraction(pop, 2)[1, 3]
</code></pre>

<hr>
<h2 id='getPedigree'>Get population pedigree.</h2><span id='topic+getPedigree'></span>

<h3>Description</h3>

<p>Retrieve the pedigree of a <code>Population</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPedigree(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPedigree_+3A_pop">pop</code></td>
<td>
<p>a valid object of class <code>Population</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getPedigree()</code> can be used to retrieve the pedigree of a
population, including the phenotypic components of all individuals
in the pedigree.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing vectors for each
individual's ID, its sire and dam IDs, and its phenotypic
components, across the pedigree.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runSim">runSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Construct a population with additive and epistatic effects
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)
pop &lt;- addEffects(pop)
pop &lt;- attachEpiNet(pop)

# Run the simulator
pop2 &lt;- runSim(pop, generations = 150)

# Retrieve the population pedigree from the simulation
ped &lt;- getPedigree(pop2)

# Re-run the simulation using the same pedigree
pop3 &lt;- runSim(pop, ped)

</code></pre>

<hr>
<h2 id='getPhased'>Get population phased genotypes.</h2><span id='topic+getPhased'></span>

<h3>Description</h3>

<p>Retrieves the current phased genotypes in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPhased(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPhased_+3A_pop">pop</code></td>
<td>
<p>a valid <code>Population</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getPhased</code> retrieves the current phased genotypes in the population,
returning a single matrix with one individual per row and two
columns per SNP.
</p>


<h3>Value</h3>

<p>Returns a phased genotypes matrix.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+getHaplo">getHaplo</a></code>, <code><a href="#topic+getGeno">getGeno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a population
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)

# Retrieve genotypes
geno &lt;- getPhased(pop)
</code></pre>

<hr>
<h2 id='getQTL'>QTL retrieval.</h2><span id='topic+getQTL'></span>

<h3>Description</h3>

<p>Retrieve the QTLs being used for this population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQTL(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getQTL_+3A_pop">pop</code></td>
<td>
<p>An object of class <code>'Population'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getQTL</code> retrieves the IDs and indices of the SNPs being used
as QTLs for a given <code>Population</code> object.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the IDs and indices of all
QTLs is returned.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create population
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)

# Get the SNP IDs of the QTLs
getQTL(pop)
</code></pre>

<hr>
<h2 id='getSubPop'>Get subpopulation</h2><span id='topic+getSubPop'></span>

<h3>Description</h3>

<p>Retrieve a subset of a <code>Population</code> without recalculating effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubPop(pop, ID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSubPop_+3A_pop">pop</code></td>
<td>
<p>a valid object of class <code>Population</code>.</p>
</td></tr>
<tr><td><code id="getSubPop_+3A_id">ID</code></td>
<td>
<p>a vector giving the IDs of individuals to include in the
subset</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getSubPop()</code> returns a new <code>Population</code> object using the
individuals with IDs specified by the vector <code>ID</code>.
</p>
<p>Any additive and epistatic effects will be copied as-is to the new
<code>Population</code> object, with heritability parameters recalculated.
</p>
<p>Any IDs given but not present will be discarded.
</p>


<h3>Value</h3>

<p>A new <code>Population</code> object containing the specified
individuals is returned.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+getComponents">getComponents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Construct a population with additive and epistatic effects
pop &lt;- Population(
  popSize = 2000, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100)
)
pop &lt;- addEffects(pop)
pop &lt;- attachEpiNet(pop)

# Run the simulator
pop2 &lt;- runSim(pop, generations = 10)

# Create a new subpopulation of 500 individuals
ID &lt;- getComponents(pop2)$ID
ID &lt;- sample(ID, 500)
pop3 &lt;- getSubPop(pop2, ID)

</code></pre>

<hr>
<h2 id='loadGeno'>Load epinetr genotype file.</h2><span id='topic+loadGeno'></span>

<h3>Description</h3>

<p>Load genotypes from a previous epinetr session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadGeno(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadGeno_+3A_filename">filename</code></td>
<td>
<p>the filename for the epinetr genotypes file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When outputting all genotypes during an epinetr simulation run, the genotypes
will be written to a serialised format unique to epinetr. The <code>loadGeno</code>
function will load these genotypes into memory as a single matrix object.
</p>


<h3>Value</h3>

<p>a numeric matrix holding the genotypes
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load genotype file
filename &lt;- system.file("extdata", "geno.epi", package = "epinetr")
geno &lt;- loadGeno(filename)

# Use genotypes as basis for new population
pop &lt;- Population(
  map = map100snp, QTL = 20, genotypes = geno,
  broadH2 = 0.8, narrowh2 = 0.6, traitVar = 40
)
</code></pre>

<hr>
<h2 id='map100snp'>Example map.</h2><span id='topic+map100snp'></span>

<h3>Description</h3>

<p>An example map <code>data.frame</code> for 100 SNPs across 22
chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map100snp
</code></pre>


<h3>Format</h3>

<p><code>map100snp</code> is a <code>data.frame</code> with 100 rows and
3 variables:
</p>

<dl>
<dt>V1</dt><dd><p>SNP ID</p>
</dd>
<dt>V2</dt><dd><p>chromosome ID</p>
</dd>
<dt>v3</dt><dd><p>position on chromosome, in base pairs</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+geno100snp">geno100snp</a></code>
</p>

<hr>
<h2 id='plot.EpiNet'>Plot epistatic network.</h2><span id='topic+plot.EpiNet'></span>

<h3>Description</h3>

<p>Plot an epistatic network between a set of QTLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EpiNet'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.EpiNet_+3A_x">x</code></td>
<td>
<p>an object of class <code>'EpiNet'</code>.</p>
</td></tr>
<tr><td><code id="plot.EpiNet_+3A_...">...</code></td>
<td>
<p>additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>EpiNet</code> is typically first retrieved from
a <code>Population</code> object (using <code><a href="#topic+getEpiNet">getEpiNet</a></code>) before
being plotted using <code>plot.EpiNet()</code>.
</p>


<h3>Value</h3>

<p>A plot of the epistatic network is displayed.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+attachEpiNet">attachEpiNet</a></code>,
<code><a href="#topic+getEpiNet">getEpiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a population with an epistatic network attached
pop &lt;- Population(
  popSize = 100, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100), broadH2 = 0.9,
  narrowh2 = 0, traitVar = 40
)
pop &lt;- attachEpiNet(pop)

# Retrieve and plot the epistatic network
epinet &lt;- getEpiNet(pop)
plot(epinet)
</code></pre>

<hr>
<h2 id='plot.Population'>Plot phenotypic value for a population.</h2><span id='topic+plot.Population'></span>

<h3>Description</h3>

<p>Plot the phenotypic value for a population over the course of a
prior simulation run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Population'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Population_+3A_x">x</code></td>
<td>
<p>an object of class <code>'Population'</code> which has been run
in the simulator</p>
</td></tr>
<tr><td><code id="plot.Population_+3A_...">...</code></td>
<td>
<p>additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is a line graph depicting the mean, minimum and maximum
phenotypic value in the population across generations. This method
can only be used if the population has been run via the simulator.
</p>


<h3>Value</h3>

<p>A plot of the population's simulation run is displayed.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+runSim">runSim</a></code>,
<code><a href="#topic+addEffects">addEffects</a></code>, <code><a href="#topic+attachEpiNet">attachEpiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a population
pop &lt;- Population(
  popSize = 100, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100), broadH2 = 0.9,
  narrowh2 = 0.5, traitVar = 40
)
pop &lt;- addEffects(pop)
pop &lt;- attachEpiNet(pop)

# Run population in simulation
pop &lt;- runSim(pop)

# Plot population's run
plot(pop)
</code></pre>

<hr>
<h2 id='Population'>Population constructor.</h2><span id='topic+Population'></span>

<h3>Description</h3>

<p>The constructor for the <code>Population</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Population(
  pop = NULL,
  popSize = NULL,
  vcf = NULL,
  map = NULL,
  QTL = NULL,
  genotypes = NULL,
  literal = TRUE,
  alleleFrequencies = NULL,
  broadH2 = NULL,
  narrowh2 = NULL,
  traitVar = NULL,
  h2est = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Population_+3A_pop">pop</code></td>
<td>
<p>an optional <code>Population</code> object to use for default
values</p>
</td></tr>
<tr><td><code id="Population_+3A_popsize">popSize</code></td>
<td>
<p>an optional number of individuals in the new
<code>Population</code> to be created</p>
</td></tr>
<tr><td><code id="Population_+3A_vcf">vcf</code></td>
<td>
<p>an optional VCF file which will provide the map and
genotypes</p>
</td></tr>
<tr><td><code id="Population_+3A_map">map</code></td>
<td>
<p>an optional <code>data.frame</code> specifying the name,
chromosome and position (in base-pairs) of each SNP</p>
</td></tr>
<tr><td><code id="Population_+3A_qtl">QTL</code></td>
<td>
<p>an optional argument giving either a single number
which specifies the number of SNPs to randomly select as QTLs, or a
vector of SNP IDs (from <code>map</code>) to select as QTLs</p>
</td></tr>
<tr><td><code id="Population_+3A_genotypes">genotypes</code></td>
<td>
<p>an optional matrix of genotypes to use for the
population; see below for details</p>
</td></tr>
<tr><td><code id="Population_+3A_literal">literal</code></td>
<td>
<p>an optional <code>logical</code> value specifying whether
to use the genotypes directly or to generate new genotypes based
on the allele frequencies of the given genotypes</p>
</td></tr>
<tr><td><code id="Population_+3A_allelefrequencies">alleleFrequencies</code></td>
<td>
<p>an optional vector of allele frequencies for
generating genotypes</p>
</td></tr>
<tr><td><code id="Population_+3A_broadh2">broadH2</code></td>
<td>
<p>initial broad-sense heritability within the new
<code>Population</code></p>
</td></tr>
<tr><td><code id="Population_+3A_narrowh2">narrowh2</code></td>
<td>
<p>initial narrow-sense heritability within the new
<code>Population</code></p>
</td></tr>
<tr><td><code id="Population_+3A_traitvar">traitVar</code></td>
<td>
<p>initial phenotypic variance within the new
<code>Population</code></p>
</td></tr>
<tr><td><code id="Population_+3A_h2est">h2est</code></td>
<td>
<p>suggested heritability estimate for the new <code>Population</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Population()</code> creates a new <code>Population</code> object based
on arguments which optionally modify a previously defined
<code>Population</code> object. If no <code>Population</code> object is given,
the new <code>Population</code> is created using only the arguments
given.
</p>
<p>The arguments <code>vcf</code>, <code>map</code>, <code>genotypes</code>,
<code>literal</code> and <code>alleleFrequencies</code> all work together in a
specific way.
</p>
<p>If a VCF file is supplied via the <code>vcf</code> argument, the
<code>map</code>, <code>genotypes</code> and <code>alleleFrequencies</code>
arguments are not needed, since a map and set of genotypes are
given within the VCF file. If the number of individuals' genotypes
given by the VCF file does not match the number of individuals
specified by the <code>popSize</code> argument, the supplied genotypes
within the VCF file are used to suggest allele frequencies only:
this behaviour can also be forced by setting the <code>literal</code>
argument to <code>FALSE</code>.
</p>
<p>The <code>genotypes</code> argument supplies genotypes directly. In this
case, the user should supply a phased, individual-major genotypes matrix:
one individual per row and two columns per single nucleotide
polymorphism (SNP). Odd columns are assumed to be the haplotypes
inherited from the sires, while even columns are assumed to be the
haplotypes inherited from the dams. As with genotypes supplied via
a VCF file, if the number of individuals' genotypes given by the
matrix does not match the number of individuals specified by the
<code>popSize</code> argument, the supplied genotypes are used to
suggest allele frequencies only; again, this behaviour can also be
forced by setting the <code>literal</code> argument to <code>FALSE</code>.
</p>
<p>When supplying genotypes either directly or via a VCF file, all
SNPs should be biallelic and phased, with no missing values.
Genotypes supplied directly should have variants coded as either
0 or 1.
</p>
<p>Any map (either supplied directly or via a VCF file) will be sorted,
such that all SNPs along the first chromosome listed will appear at the
start of the map, sorted in terms of base-pair distance; the second
chromosome to appear will then be treated similarly, and so on. SNPs
will be referenced within the population in this order.
</p>
<p>The <code>alleleFrequencies</code> argument is used when genotypes are
not given directly. In this case, the <code>literal</code> argument has
no meaning.
</p>
<p>An example <code>map data.frame</code> has been included in the epinetr
package as <code>map100snp</code>. Note that all chromosomes must be
autosomal, whether given via the <code>map</code> parameter or via a VCF
file.
</p>
<p>The <code>Population</code> object will estimate breeding values once all
necessary effects are given. An optional heritability estimate can
be supplied using the <code>h2est</code> parameter.
</p>
<p>When supplying an existing <code>Population</code> object, any additive
effects and epistatic network will be carried over from the
previous population unless new QTLs are supplied.
</p>
<p>Note that if <code>broadH2</code> is equal to <code>narrowh2</code>, no
epistatic effects will be present; if <code>narrowh2</code> is 0, no
additive effects will be present; if <code>broadH2</code> is 1, no
environmental effects will be present.
</p>
<p>The <code>h2est</code> argument bypasses REML-based heritability estimates
by supplying a user-defined heritability estimate for use in calculating
estimated SNP effects.
</p>


<h3>Value</h3>

<p>The constructor creates a new object of class
<code>'Population'</code>.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addEffects">addEffects</a></code>, <code><a href="#topic+attachEpiNet">attachEpiNet</a></code>,
<code><a href="#topic+print.Population">print.Population</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a new population of size 500, with random allele
# frequencies and 20 QTLs chosen at random, broad-sense
# heritability set to 0.9, narrow-sense heritability set to 0.75
# and overall trait variance set to 40.

pop &lt;- Population(
  popSize = 500, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100), broadH2 = 0.9,
  narrowh2 = 0.75, traitVar = 40
)

# Construct a new population of size 500 using directly supplied
# genotypes and 20 QTLs chosen at random, broad-sense heritability
# set to 0.7, narrow-sense heritability set to 0.3 and overall
# trait variance set to 10.

pop2 &lt;- Population(
  map = map100snp, genotypes = geno100snp,
  literal = TRUE, QTL = 20,
  broadH2 = 0.7, narrowh2 = 0.3, traitVar = 10
)

# Modify the previous population to have narrow-sense heritabilty
# set to 0.45 and overall trait variance set to 20.

pop2 &lt;- Population(pop2, narrowh2 = 0.45, traitVar = 20)
</code></pre>

<hr>
<h2 id='print.Population'>Print function for population.</h2><span id='topic+print.Population'></span>

<h3>Description</h3>

<p>Print a summary of the population object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Population'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Population_+3A_x">x</code></td>
<td>
<p>a valid <code>Population</code> object</p>
</td></tr>
<tr><td><code id="print.Population_+3A_...">...</code></td>
<td>
<p>additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 method for printing a summary of a <code>Population</code>
object. Displayed are the initial parameters for the population
(i.e. population size, phenotypic variance, broad-sense
heritability, narrow-sense heritability and the SNPs used as
QTLs), followed by any current additive and epistatic variance in
the population.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+addEffects">addEffects</a></code>,
<code><a href="#topic+attachEpiNet">attachEpiNet</a></code>, <code><a href="#topic+runSim">runSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a population
pop &lt;- Population(
  popSize = 10, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100), broadH2 = 0.9,
  narrowh2 = 0.5, traitVar = 40
)
pop &lt;- addEffects(pop)
pop &lt;- attachEpiNet(pop)

# Print the initial population
pop

# Run population in simulation
pop2 &lt;- runSim(pop, generations = 50)

# Print the population following the simulation
pop2
</code></pre>

<hr>
<h2 id='rincmat100snp'>Example incidence matrix.</h2><span id='topic+rincmat100snp'></span>

<h3>Description</h3>

<p>An example incidence matrix for 19 pairwise interactions across
20 QTLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rincmat100snp
</code></pre>


<h3>Format</h3>

<p><code>rincmat100snp</code> is a matrix with 20 rows and 19
columns, used in examples when constructing an epistatic network
using a user-supplied incidence matrix.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attachEpiNet">attachEpiNet</a></code>
</p>

<hr>
<h2 id='runSim'>Run simulation on population.</h2><span id='topic+runSim'></span>

<h3>Description</h3>

<p>Run a forward-time simulation on a <code>Population</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSim(
  pop,
  pedigree = NULL,
  generations = 2,
  selection = "random",
  fitness = "phenotypic",
  burnIn = 0,
  truncSire = 1,
  truncDam = 1,
  roundsSire = 1,
  roundsDam = 1,
  litterDist = c(0, 0, 1),
  breedSire = 10,
  mutation = 10^-9,
  recombination = NULL,
  allGenoFileName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runSim_+3A_pop">pop</code></td>
<td>
<p>a valid <code>Population</code> object with all necessary
additive and epistatic effects attached</p>
</td></tr>
<tr><td><code id="runSim_+3A_pedigree">pedigree</code></td>
<td>
<p>an optional <code>data.frame</code> giving the pedigree
to follow for selection</p>
</td></tr>
<tr><td><code id="runSim_+3A_generations">generations</code></td>
<td>
<p>an optional integer giving the number of
generations to iterate through in the simulation</p>
</td></tr>
<tr><td><code id="runSim_+3A_selection">selection</code></td>
<td>
<p>an optional string specifying random (the default) or
linear ranking selection</p>
</td></tr>
<tr><td><code id="runSim_+3A_fitness">fitness</code></td>
<td>
<p>an optional string specifying whether selection takes
place based on phenotypic value (the default), true genetic value or
estimated breeding value</p>
</td></tr>
<tr><td><code id="runSim_+3A_burnin">burnIn</code></td>
<td>
<p>an optional integer giving the initial number of
generations in which to use random selection without truncation,
even when linear ranking selection or truncation is otherwise employed</p>
</td></tr>
<tr><td><code id="runSim_+3A_truncsire">truncSire</code></td>
<td>
<p>an optional value giving the proportion of the
males in the population with the highest phenotypic value to
select within</p>
</td></tr>
<tr><td><code id="runSim_+3A_truncdam">truncDam</code></td>
<td>
<p>an optional value giving the proportion of the
females in the population with the highest phenotypic value to
select within</p>
</td></tr>
<tr><td><code id="runSim_+3A_roundssire">roundsSire</code></td>
<td>
<p>an optional integer giving the maximum number of
generations for a male to survive; see details below</p>
</td></tr>
<tr><td><code id="runSim_+3A_roundsdam">roundsDam</code></td>
<td>
<p>an optional integer giving the maximum number of
generations for a female to survive; see details below</p>
</td></tr>
<tr><td><code id="runSim_+3A_litterdist">litterDist</code></td>
<td>
<p>an optional vector giving the probability mass
function for the litter sizes, starting with a litter of 0</p>
</td></tr>
<tr><td><code id="runSim_+3A_breedsire">breedSire</code></td>
<td>
<p>an optional integer indicating the maximum number
of times that a sire can breed per generation</p>
</td></tr>
<tr><td><code id="runSim_+3A_mutation">mutation</code></td>
<td>
<p>an optional value giving the rate of mutation per
SNP</p>
</td></tr>
<tr><td><code id="runSim_+3A_recombination">recombination</code></td>
<td>
<p>an optional vector giving the probabilities
for recombination events between each SNP</p>
</td></tr>
<tr><td><code id="runSim_+3A_allgenofilename">allGenoFileName</code></td>
<td>
<p>a string giving a file name,
indicating that all genotypes will be outputted to the file during the run</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>runSim</code> is the forward-time simulation engine of the
<code>epinetr</code> package. A <code>Population</code> object with necessary
additive and epistatic effects must be supplied; all other
arguments are optional, though either <code>pedigree</code> or
<code>generations</code> must be supplied.
</p>
<p><code>pedigree</code> should be a <code>data.frame</code> where the first
three columns are the ID, sire ID and dam ID respectively. Sire
and dam IDs of 0 indicate that the individual is in the first
generation; each ID in the first generation should match an ID in
the given <code>Population</code> object. The pedigree will be sorted
into generations before running, where a 'generation' in this case
is defined as the set of individuals whose parents are both from a
previous generation. If a pedigree is supplied, all further
arguments (which pertain to selection) will be ignored.
</p>
<p><code>generations</code> is the number of generations through which the
simulation will iterate. The supplied population represents the
first generation: the default value of 2 for this argument thus
means that the simulator will simply return the next generation.
</p>
<p><code>selection</code> is a string specifying 'ranking' for linear
ranking selection; any other string is interpreted as 'random' for
random selection.
</p>
<p>Linear ranking selection mimics natural selection: if the
individuals in a population of size <code class="reqn">n</code> are each given a rank
<code class="reqn">r</code> based on descending order of phenotypic value (i.e. the
individual with the highest phenotypic value is given the rank
<i>r</i><sub>1</sub> = 1 while the individual with the lowest phenotypic value
is given the rank <i>r<sub>n</sub></i> = <i>n</i>), the probability of an individual
<code class="reqn">i</code> being selected for mating is given by:
</p>


<i>P</i>(<i>i</i> is selected) = 2(<i>n</i> - <i>r<sub>i</sub></i> + 1) / <i>n</i>(<i>n</i> + 1)

<p>Selection occurs by the population first being split into male and female
sub-populations. Next, if the round is outside any initial burn-in period,
each sub-population is truncated to a proportion of its original size per
the values of <code>truncSire</code> and <code>truncDam</code>, respectively.
</p>
<p>When linear ranking selection is used, females are exhaustively
sampled, without replacement, for each mating pair using their linear
ranking probabilities, as given above; males are sampled for each mating
pair using their linear ranking probabilities but with replacement, where
they are each only replaced a maximum number of times as specified by
<code>breedSire</code>. Random selection occurs in the same manner, but all
probabilities are uniform. During any initial <code>burnIn</code> period, random
selection is enforced.
</p>
<p><code>fitness</code> specifies how fitness is determined for the purposes of selection:
'phenotypic' (the default) selects based on the phenotype while 'TGV' selects by
ignoring environmental noise; 'EBV' selects based on estimated breeding values
using estimated SNP effects.
</p>
<p>Each mating pair produces a number of full-sibling offspring by sampling
once from the litter-size probability mass function given by <code>litterDist</code>
(with the default guaranteeing two full-sibling offspring per mating pair).
The PMF is specified via a vector giving the probabilities for each
litter size, starting with a litter size of 0. For example,
<code>c(0.2, 0.0, 0.1, 0.4, 0.3)</code> gives a 20% chance of a litter
size of 0, a 10% chance of litter size of 2, a 40% chance of a
litter size of 3, a 30% chance of a litter size of 4 and a 0%
chance of a litter size of 1 or greater than 4.
</p>
<p>Half-siblings occur when sires can mate more than once per round (as given by
<code>breedSire</code>) or when sires or dams survive beyond one round (as given by
<code>roundsSire</code> and <code>roundsDam</code>, respectively). It is important to note
that <code>roundsSire</code> and <code>roundsDam</code>, which specify the maximum number
of generations for males and females to survive, respectively, will be ignored
in the case where an insufficient number of offspring are produced to replace
the individuals who have nonetheless survived the maximum number of rounds: in
this case, younger individuals will be preserved in order to meet the
population size.
</p>
<p><code>recombination</code> is a vector of recombination rates between
SNPs. The length of this vector should be equal to the number of
SNPs in the population's <code>map</code> minus the number of
chromosomes. The order of the chromosomes is as per the
<code>map</code>.
</p>
<p><code>allGenoFileName</code> is the name of a file in which the
phased genotype for every individual will be stored. The output
is serialised and can be read using <code>loadGeno</code>. If the
<code>allGenoFileName</code> argument is not given, no genotypes
will be written to file.
</p>


<h3>Value</h3>

<p>A new <code>Population</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Dion Detterer, Paul Kwan, Cedric Gondro
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Population">Population</a></code>, <code><a href="#topic+addEffects">addEffects</a></code>,
<code><a href="#topic+attachEpiNet">attachEpiNet</a></code>, <code><a href="#topic+print.Population">print.Population</a></code>,
<code><a href="#topic+plot.Population">plot.Population</a></code>, <code><a href="#topic+loadGeno">loadGeno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create population
pop &lt;- Population(
  popSize = 200, map = map100snp, QTL = 20,
  alleleFrequencies = runif(100),
  broadH2 = 0.9, narrowh2 = 0.6, traitVar = 40
)

# Attach additive effects using a normal distribution
pop &lt;- addEffects(pop)

# Attach epistatic effects
pop &lt;- attachEpiNet(pop)

# Run simulation for 150 generations
pop &lt;- runSim(pop, generations = 150)

# Display results
pop

# Plot results
plot(pop)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
