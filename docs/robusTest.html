<!DOCTYPE html><html lang="en"><head><title>Help for package robusTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robusTest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cortest'><p>Calibrated tests for correlation between paired samples</p></a></li>
<li><a href='#ecdf2D'><p>Bidimensional Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#Evans'><p>Evans County dataset</p></a></li>
<li><a href='#indeptest'><p>Robust independence test for two continuous variables of Kolmogorov-Smirnov's type</p></a></li>
<li><a href='#mediantest'><p>Test for the median in the one and two-sample paired tests</p></a></li>
<li><a href='#simulecdf'><p>Simulate the distribution of the test statistic for the robust independence test of Kolmogorov-Smirnov's type</p></a></li>
<li><a href='#stat_indeptest'><p>Compute the test statistic for the robust independence test of Kolmogorov-Smirnov's type</p></a></li>
<li><a href='#tiebreak'><p>Break the ties in a given vector or between two vectors</p></a></li>
<li><a href='#vartest'><p>Calibrated variance test between two or more independent samples</p></a></li>
<li><a href='#wilcoxtest'><p>Calibrated Wilcoxon rank sum and signed rank tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Calibrated Correlation and Two-Sample Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of corrected two-sample tests. A corrected version of the Pearson and Kendall correlation tests, 
 the Mann-Whitney (Wilcoxon) rank sum test, the Wilcoxon signed rank test and a variance test are implemented.
 The package also proposes a test for the median and an independence test between two continuous variables of Kolmogorov-Smirnov's type. 
 All these corrected tests are asymptotically calibrated in the sense that the probability of rejection under the null hypothesis is 
 asymptotically equal to the level of the test. See &lt;<a href="https://doi.org/10.48550%2FarXiv.2211.08784">doi:10.48550/arXiv.2211.08784</a>&gt; for more details on the statistical tests.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-18 10:13:59 UTC; obouaziz</td>
</tr>
<tr>
<td>Author:</td>
<td>Olivier Bouaziz [aut, cre],
  Jérôme Dedecker [aut],
  Anatole Dedecker [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olivier Bouaziz &lt;olivier.bouaziz@parisdescartes.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-18 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cortest'>Calibrated tests for correlation between paired samples</h2><span id='topic+cortest'></span>

<h3>Description</h3>

<p>Tests the association/correlation for continuous paired samples using corrected versions of Pearson's, Kendall's and Spearman's correlation tests. These three tests are asymptotically well calibrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cortest(
  x,
  y,
  alternative = "two.sided",
  method = "pearson",
  ties.break = "none",
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cortest_+3A_x">x</code>, <code id="cortest_+3A_y">y</code></td>
<td>
<p>the two continuous variables. Must be of same length.</p>
</td></tr>
<tr><td><code id="cortest_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="cortest_+3A_method">method</code></td>
<td>
<p>a character string indicating which test to implement. Can be <code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>.</p>
</td></tr>
<tr><td><code id="cortest_+3A_ties.break">ties.break</code></td>
<td>
<p>the method used to break ties in case there are ties in the x or y vectors. Can be <code>"none"</code> or <code>"random"</code>.</p>
</td></tr>
<tr><td><code id="cortest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the confidence interval of the correlation coefficient. It is used only for the Pearson's correlation test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three tests are implemented. The null hypothesis for the corrected Pearson test is: H0 Cor(X,Y)=0 where Cor represents Pearson's correlation coefficient.
The alternative is specified by the <code>alternative</code> argument. The null hypothesis for the corrected Kendall test is: H0 tau=0 where tau represents Kendall's tau coefficient.
The null hypothesis for the corrected Spearman test is: H0 rho=0 where rho represents Spearman's rho coefficient.
All tests are asymptotically well calibrated in the sense that the rejection probability under the null hypothesis is asymptotically equal to the level of the test.
For the Pearson test, the exact distribution of the test statistic under the Gaussian case has been tabulated for n&lt;130. For n&gt;=130, the Student distribution with n-2 degrees of
freedom is used.
</p>
<p>When Pearson's correlation test is used, a confidence interval for Pearson's correlation coefficient is also returned. This confidence interval has been implemented
from the delta-method. It should be noted that this method is asymptotic and can display very narrow intervals for small sample sizes and thus can suffer from
low coverage probabilities. We therefore recommend to use confidence intervals for Pearson's correlation coefficient only when n is at least larger than 100.
</p>
<p>The Kendall and Spearman correlation tests are not valid in the presence of ties in the <code>x</code> or <code>y</code> vector. If ties occur, they should be broken using the
<code>ties.break</code> option. Note that they can also be broken outside <code>cortest</code> using the function <code>tiebreak</code>.
</p>


<h3>Value</h3>

<p>Returns the result of the test with its corresponding p-value, the value of the test statistic and the estimated value of Pearson's correlation coefficient,
Kendall's tau or Spearman's rho. For Pearson's correlation test an asymptotic confidence interval for the correlation coefficient is also returned.
</p>


<h3>Note</h3>

<p>The option <code>ties.break</code> handles ties for both Kendall's and Spearman's test. If <code>ties.break="none"</code> the ties are ignored, if <code>ties.break="random"</code> they are randomly broken.
Note that only ties inside each vector are broken (but not ties between the two vectors).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vartest">vartest</a></code>, <code><a href="#topic+indeptest">indeptest</a></code>, <code><a href="#topic+mediantest">mediantest</a></code>, <code><a href="#topic+wilcoxtest">wilcoxtest</a></code>, <code><a href="#topic+tiebreak">tiebreak</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Application on the Evans dataset
#Description of this dataset is available in the lbreg package
data(Evans)
with(Evans,cor.test(CHL[CDH==1],DBP[CDH==1]))
with(Evans,cortest(CHL[CDH==1],DBP[CDH==1]))
#The pvalues are very different!

with(Evans,cortest(CHL[CDH==1],DBP[CDH==1],method="kendall",ties.break="random"))
with(Evans,cortest(CHL[CDH==1],DBP[CDH==1],method="spearman",ties.break="random"))

#We use the function tiebreak to remove ties and compare the results from cor.test with cortest
X=tiebreak(Evans$CHL[Evans$CDH==1])
Y=tiebreak(Evans$DBP[Evans$CDH==1])
cor.test(X,Y,method="kendall")
cortest(X,Y,method="kendall")
cor.test(X,Y,method="spearman")
cortest(X,Y,method="spearman")


#Simulated data
n=100 #sample size
M=10000 #number of replications
testone=function(n){
X=rnorm(n,0,1)
epsi=rnorm(n,0,1)
Y=X^2+0.3*epsi
list(test1=cortest(X,Y)$p.value,test2=cor.test(X,Y)$p.value) #cor.test is the standard Pearson test
}
res1=res2=rep(NA,M)
# Replications in order to check if the the corrected Pearson test and
# the standard test are well calibrated
for (i in 1:M)
{
result=testone(n)
res1[i]=result$test1
res2[i]=result$test2
}
mean(res1&lt;0.05)
mean(res2&lt;0.05)


#Replications with Kendall's test (may take a few minutes to run)
M=500
testone=function(n){
X=rnorm(n,0,1)
epsi=rnorm(n,0,1)
Y=X^2+0.3*epsi
list(test1=cortest(X,Y)$p.value,test2=cor.test(X,Y)$p.value,
test3=cortest(X,Y,method="kendall")$p.value,
test4=cor.test(X,Y,method="kendall")$p.value,
test5=cortest(X,Y,method="spearman")$p.value,
test6=cor.test(X,Y,method="spearman")$p.value)
#cor.test is the standard Pearson, Kendall or Spearman correlation test
}
res1=res2=res3=res4=res5=res6=rep(NA,M)
# Replications to check if the tests are well calibrated
for (i in 1:M)
{
result=testone(n)
res1[i]=result$test1
res2[i]=result$test2
res3[i]=result$test3
res4[i]=result$test4
res5[i]=result$test5
res6[i]=result$test6
}
mean(res1&lt;0.05)
mean(res2&lt;0.05)
mean(res3&lt;0.05)
mean(res4&lt;0.05)
mean(res5&lt;0.05)
mean(res6&lt;0.05)
</code></pre>

<hr>
<h2 id='ecdf2D'>Bidimensional Empirical Cumulative Distribution Function</h2><span id='topic+ecdf2D'></span>

<h3>Description</h3>

<p>Compute the empirical cumulative distribution function for a bivariate continuous distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdf2D(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecdf2D_+3A_x">x</code>, <code id="ecdf2D_+3A_y">y</code></td>
<td>
<p>the two continuous variables. Must be of same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bidimensional e.c.d.f. (empirical cumulative distribution function) Fn is a step function with jumps i/n at observation values, where i is
the number of tied observations at that value.
</p>
<p>For observations (x1,y1), ..., (x_n,y_n), Fn is defined as
</p>
<p style="text-align: center;"><code class="reqn">Fn(t1,t2) = 1/n sum_{i=1}^n Indicator(xi&lt;=t1,yi&lt;=t2)</code>
</p>



<h3>Value</h3>

<p>The result is returned as a matrix of dimension (n*n) where the entry (i,j) corresponds to Fn(xi,yj), i=1, ...,n,
j=1, ...,n.
</p>


<h3>Note</h3>

<p>Missing values are removed such that if a value of <code>x</code> (resp. <code>y</code>) is missing then the corresponding
values of both <code>x</code> and <code>y</code> are removed. The bidimensional e.c.d.f. is then computed on the remaining elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indeptest">indeptest</a></code>; the <code>bivariate</code> package also provides plots for the
bidimensional e.c.d.f.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulated data #1
x&lt;-c(0.2, 0.3, 0.1, 0.4)
y&lt;-c(0.5, 0.4, 0.05, 0.2)
ecdf2D(x,y)

#Simulated data #2
n&lt;-40
x&lt;-rnorm(n)
y&lt;-x^2+0.3*rnorm(n)
plot(x,y)
ecdf2D(x,y)
</code></pre>

<hr>
<h2 id='Evans'>Evans County dataset</h2><span id='topic+Evans'></span>

<h3>Description</h3>

<p>Data from cohort study in which white males in Evans County were followed for seven years,
with coronary heart disease as the outcome of interest. This dataset comes from the
<code>lbref</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Evans
</code></pre>


<h3>Format</h3>

<p>A data frame with 609 rows and 9 variables:
</p>

<dl>
<dt>CDH</dt><dd><p>outcome variable; 1 = coronary disease</p>
</dd>
<dt>CAT</dt><dd><p>1 = high, 0 = normal catecholamine level</p>
</dd>
<dt>AGE</dt><dd><p>age (in years)</p>
</dd>
<dt>CHL</dt><dd><p>cholesterol, mg/dl</p>
</dd>
<dt>SMK</dt><dd><p>1 = subject has ever smoked</p>
</dd>
<dt>ECG</dt><dd><p>1 = presence of electrocardiogram abnormality</p>
</dd>
<dt>DBP</dt><dd><p>diastolic blood pressure, mmHg</p>
</dd>
<dt>SBP</dt><dd><p>systolic blood pressure, mmHg</p>
</dd>
<dt>HPT</dt><dd><p>1 = SBP greater than or equal to 160 or DBP greater than or equal to 95</p>
</dd>
</dl>


<hr>
<h2 id='indeptest'>Robust independence test for two continuous variables of Kolmogorov-Smirnov's type</h2><span id='topic+indeptest'></span>

<h3>Description</h3>

<p>Test the independence between two continuous variables based on the maximum distance
between the joint empirical cumulative distribution function and the product of the marginal
empirical cumulative distribution functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indeptest(
  x,
  y,
  N = 50000,
  simu = FALSE,
  ties.break = "none",
  nb_tiebreak = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indeptest_+3A_x">x</code>, <code id="indeptest_+3A_y">y</code></td>
<td>
<p>the two continuous variables. Must be of same length.</p>
</td></tr>
<tr><td><code id="indeptest_+3A_n">N</code></td>
<td>
<p>the number of Monte-Carlo replications if simu=TRUE.</p>
</td></tr>
<tr><td><code id="indeptest_+3A_simu">simu</code></td>
<td>
<p>if TRUE a Monte-Carlo simulation with <code>N</code> replications is used to determine the
distribution of the test statistic under the null hypothesis. If FALSE, pre computed tables are used (see Details
for more information).</p>
</td></tr>
<tr><td><code id="indeptest_+3A_ties.break">ties.break</code></td>
<td>
<p>the method used to break ties in case there are ties in the x or y vectors. Can be <code>"none"</code>,
<code>"random"</code> or <code>"rep_random"</code>.</p>
</td></tr>
<tr><td><code id="indeptest_+3A_nb_tiebreak">nb_tiebreak</code></td>
<td>
<p>the number of repetition for breaking the ties when <code>ties.break="rep_random"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two continuous variables, <code>indeptest</code> tests H0 X and Y are independent
against H1 X and Y are not independent.
</p>
<p>For observations (x1,y1), ..., (x_n,y_n), the bivariate e.c.d.f.
(empirical cumulative distribution function) Fn is defined as:
</p>
<p style="text-align: center;"><code class="reqn">Fn(t1,t2) = sum_{i=1}^n Indicator(xi&lt;=t1,yi&lt;=t2)/n.</code>
</p>

<p>Let Fn(t1) and Fn(t2) be the marginals e.c.d.f. The test statistic is defined as:
</p>
<p style="text-align: center;"><code class="reqn">n^(1/2) sup_{t1,t2} |Fn(t1,t2)-Fn(t1)*Fn(t2)|.</code>
</p>

<p>Under H0 the test statistic is distribution free and is equivalent to
the same test statistic computed for two independent continuous uniform variables in <code class="reqn">[0,1]</code>,
where the supremum is taken for t1,t2 in <code class="reqn">[0,1]</code>. Using this result, the distribution of the test
statistic is obtained using Monte-Carlo simulations. The user can either use the argument simu=TRUE to
perform the Monte-Carlo simulation (with N the number of replications) or simply use the available tables
by choosing simu=FALSE. In the latter case, the exact distribution is estimated for n=1, ...,150. For <code class="reqn">151&lt;=n&lt;=175</code>, the
distribution with n=150 is used. For <code class="reqn">176&lt;=n&lt;=250</code>, the distribution with n=200 is used.
For <code class="reqn">251&lt;=n&lt;=400</code>, the distribution with n=300 is used. For <code class="reqn">401&lt;=n&lt;=750</code>, the distribution with n=500 is used.
For <code class="reqn">n&gt;=751</code>, the distribution with n=1000 is used. Those tables were computed using 2e^5 replications in Monte-Carlo simulations.
</p>


<h3>Value</h3>

<p>Returns the result of the test with its corresponding p-value and the value of the test statistic.
</p>


<h3>Note</h3>

<p>Only a two sided alternative is possible with this test. Missing values are removed such that if a value
of <code>x</code> (resp. <code>y</code>) is missing then the corresponding
values of both <code>x</code> and <code>y</code> are removed. The test is then implemented on the remaining elements. If <code>ties.break="none"</code> the ties are ignored, putting
mass (number of ties)/n at tied observations in the computation of the empirical cumulative distribution functions.
If <code>ties.break="random"</code> they are randomly broken. If <code>ties.break="rep_random"</code> they are randomly broken <code>nb_tiebreak</code>
times where <code>nb_tiebreak</code> is a parameter of the function. In that case, the test statistic and the p values are computed by taking
the average over all replications.
</p>
<p>This function is implemented using the Rcpp package.
</p>


<h3>Author(s)</h3>

<p>See <em>Distribution Free Tests of Independence Based on the Sample Distribution Function</em>.
J. R. Blum, J. Kiefer and M. Rosenblatt, 1961.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cortest">cortest</a></code>, <code><a href="#topic+vartest">vartest</a></code>, <code><a href="#topic+mediantest">mediantest</a></code>, <code><a href="#topic+wilcoxtest">wilcoxtest</a></code>.
See also the <code>hoeffd</code> function in the <code>Hmisc</code> package for the Hoeffding test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulated data 1
x&lt;-c(0.2, 0.3, 0.1, 0.4)
y&lt;-c(0.5, 0.4, 0.05, 0.2)
indeptest(x,y)

#Simulated data 2
n&lt;-40 #sample size
x&lt;-rnorm(n)
y&lt;-x^2+0.3*rnorm(n)
plot(x,y)
indeptest(x,y)

#Application on the Evans dataset
#Description of this dataset is available in the lbreg package
data(Evans)
with(Evans,plot(CHL[CDH==1],DBP[CDH==1]))
with(Evans,cor.test(CHL[CDH==1],DBP[CDH==1])) #the standard Pearson test
with(Evans,cortest(CHL[CDH==1],DBP[CDH==1])) #the robust Pearson test
with(Evans,indeptest(CHL[CDH==1],DBP[CDH==1])) #the robust independence test
#The robust tests give very different pvalues than the standard Pearson test!

#Breaking the ties
#The ties are broken once
with(Evans,indeptest(CHL[CDH==1],DBP[CDH==1],ties.break="random"))
#The ties are broken repeatedly and the average of the test statistics and p.values
#are computed
with(Evans,indeptest(CHL[CDH==1],DBP[CDH==1],ties.break="rep_random",nb_tiebreak=100))
</code></pre>

<hr>
<h2 id='mediantest'>Test for the median in the one and two-sample paired tests</h2><span id='topic+mediantest'></span>

<h3>Description</h3>

<p>In the one sample case, test if the median of the random variable is equal to 0. In the paired two-sample case, test if the median of the
difference between the two random variables is equal to 0. The function also returns the confidence interval for the median of the
random variable in the one-sample case or for the median of the difference between the two random variables in the two-sample case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mediantest(
  x,
  y = NULL,
  alternative = "two.sided",
  paired = FALSE,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mediantest_+3A_x">x</code>, <code id="mediantest_+3A_y">y</code></td>
<td>
<p>two continuous variables.</p>
</td></tr>
<tr><td><code id="mediantest_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="mediantest_+3A_paired">paired</code></td>
<td>
<p>a logical value. If <code>paired=TRUE</code>, the user must provide values for <code>x</code> and <code>y</code>
and the paired test is implemented. If <code>paired=FALSE</code>, only <code>x</code> must be provided.</p>
</td></tr>
<tr><td><code id="mediantest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the confidence interval of the median.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis for the one sample median test is: H0 Med(X)=0 where Med represents the median.
The alternative is specified by the <code>alternative</code> argument: &quot;<code>greater</code>&quot; means that Med(X)&gt;0, &quot;<code>less</code>&quot;
means that Med(X)&lt;0 and &quot;<code>two.sided</code>&quot; means that Med(X) is different from 0. The null hypothesis for the paired median test is: H0 Med(X-Y)=0. Both tests are asymptotically
calibrated in the sense that the rejection probability under the null hypothesis is asymptotically equal to the level of the test. The
test and the confidence interval are constructed based on asymptotic results on the rank statistics for the uniform distribution, as described in the book
<em>Asymptotic Statistics</em> from A. W. Van der Vaart, 1998.
</p>


<h3>Value</h3>

<p>Returns the result of the test with its corresponding p-value and the value of median of X or of X-Y. The confidence interval is also displayed
but only when <code>alternative=two.sided</code>.
</p>


<h3>Note</h3>

<p>The paired median test can be implemented either by providing the variables <code>x</code> and <code>y</code> with <code>paired=TRUE</code> or by just providing
one vector equal to the difference between <code>x</code> and <code>y</code> with <code>paired=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>See <em>Asymptotic Statistics</em>.
A. W. Van der Vaart, 1998.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cortest">cortest</a></code>, <code><a href="#topic+indeptest">indeptest</a></code>, <code><a href="#topic+vartest">vartest</a></code>, <code><a href="#topic+wilcoxtest">wilcoxtest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulations
x &lt;- rexp(200)-log(2)
mediantest(x)
x &lt;- rexp(200)-log(2)+0.2
mediantest(x,alternative="greater")

n=100 #sample size
M=1000 #number of replications
res1=res2=rep(NA,M)
testone=function(n){
D=rchisq(n,df=4)-qchisq(df=4, p=0.5)
list(test1=mediantest(D)$p.value,test2=binom.test(sum(D&gt;0),n)$p.value)
} #test2 is the sign test.
for (i in 1:M)
{
result=testone(n)
res1[i]=result$test1
res2[i]=result$test2
}
mean(res1&lt;0.05) #0.048
mean(res2&lt;0.05) # 0.04
</code></pre>

<hr>
<h2 id='simulecdf'>Simulate the distribution of the test statistic for the robust independence test of Kolmogorov-Smirnov's type</h2><span id='topic+simulecdf'></span>

<h3>Description</h3>

<p>For two independent continuous uniform variables on <code class="reqn">[0,1]</code> compute the maximal distance
between the joint empirical cumulative distribution function and the product of the marginal
empirical cumulative distribution functions using Monte-Carlo simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulecdf(n, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulecdf_+3A_n">n</code></td>
<td>
<p>the size of the sample.</p>
</td></tr>
<tr><td><code id="simulecdf_+3A_n">N</code></td>
<td>
<p>the number of replications in the Monte-Carlo simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">(x1,y1), ..., (x_n,y_n)</code> be a bivariate sample of <code>n</code> independent continuous uniform variables.
Its corresponding bivariate e.c.d.f. (empirical cumulative distribution function)
Fn is defined as:
</p>
<p>Fn(t1,t2) = #<code>{xi&lt;=t1,yi&lt;=t2}/n = sum_{i=1}^n Indicator(xi&lt;=t1,yi&lt;=t2)/n</code>.
</p>
<p>Let Fn(t1) and Fn(t2) be the marginals e.c.d.f. Based on N Monte_Carlo simulations,
the function computes the e.c.d.f. of </p>
<p style="text-align: center;"><code class="reqn">n^(1/2) sup_{t1,t2} |Fn(t1,t2)-Fn(t1)*Fn(t2)|.</code>
</p>



<h3>Value</h3>

<p>Returns the e.c.d.f. based on the N Monte_Carlo simulations. The returned object
is a stepfun object obtained from the function <code>ecdf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indeptest">indeptest</a></code>, <code><a href="#topic+stat_indeptest">stat_indeptest</a></code>, <code><a href="#topic+ecdf2D">ecdf2D</a></code>.
</p>

<hr>
<h2 id='stat_indeptest'>Compute the test statistic for the robust independence test of Kolmogorov-Smirnov's type</h2><span id='topic+stat_indeptest'></span>

<h3>Description</h3>

<p>For two continuous variables compute the maximal distance
between the joint empirical cumulative distribution function and the product of the marginal
empirical cumulative distribution functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_indeptest(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_indeptest_+3A_x">x</code>, <code id="stat_indeptest_+3A_y">y</code></td>
<td>
<p>the two continuous variables. Must be of same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let (x1,y1), ..., (x_n,y_n) be a bivariate sample of <code>n</code> continuous variables.
Its corresponding bivariate e.c.d.f. (empirical cumulative distribution function)
Fn is defined as:
</p>
<p>Fn(t1,t2) = #<code>{xi&lt;=t1,yi&lt;=t2}/n = sum_{i=1}^n Indicator(xi&lt;=t1,yi&lt;=t2)/n</code>.
</p>
<p>Let Fn(t1) and Fn(t2) be the marginals e.c.d.f. The function returns the value of:
</p>
<p><code>n^(1/2) sup_{t1,t2} |Fn(t1,t2)-Fn(t1)*Fn(t2)|</code>.
</p>


<h3>Value</h3>

<p>Returns the test statistic of the robust independent test.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indeptest">indeptest</a></code>, <code><a href="#topic+simulecdf">simulecdf</a></code>, <code><a href="#topic+ecdf2D">ecdf2D</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulated data 1
x&lt;-c(0.2, 0.3, 0.1, 0.4)
y&lt;-c(0.5, 0.4, 0.05, 0.2)
stat_indeptest(x,y)

#Simulated data 2
n&lt;-40
x&lt;-rnorm(n)
y&lt;-x^2+0.3*rnorm(n)
plot(x,y)
stat_indeptest(x,y)

#Application on the Evans dataset
data(Evans)
with(Evans,stat_indeptest(CHL[CDH==1],DBP[CDH==1]))
</code></pre>

<hr>
<h2 id='tiebreak'>Break the ties in a given vector or between two vectors</h2><span id='topic+tiebreak'></span>

<h3>Description</h3>

<p>If the vector contains ties (either inside a single or between two vectors), the function breaks them using a random perturbation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiebreak(x, y = NULL, nb_break = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tiebreak_+3A_x">x</code>, <code id="tiebreak_+3A_y">y</code></td>
<td>
<p>the variables containing ties.</p>
</td></tr>
<tr><td><code id="tiebreak_+3A_nb_break">nb_break</code></td>
<td>
<p>if TRUE return also the number of values that have been broken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y=NULL</code> the function detects the ties in the vector <code>x</code>. A uniform variable on the interval <code class="reqn">[-e^(-5),e^(-5)]</code> is added
to the value of all the ties but one in the vector <code>x</code>. If <code>y</code> is also provided, the function detects the ties between
<code>x</code> and <code>y</code> and break them (only in the <code>x</code> vector) by adding a uniform variable on the interval <code class="reqn">[-e^(-5),e^(-5)]</code> to these values.
If <code>nb_break=TRUE</code> the result is returned as a list that also includes the number of values that have been broken.
</p>


<h3>Value</h3>

<p>After breaking the ties, either returns the <code>x</code> variable as a vector or returns a list containing the <code>x</code> and <code>y</code>
variables. If <code>nb_break=TRUE</code>, the number of values that have been broken is also an element of the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,2,2,3,4,5,5,5,7)
xbreak=tiebreak(x)
xbreak
#a uniform value has been added to the second, sixth and seventh value of x.
tiebreak(x,nb_break=TRUE) #3 values have been broken in x
sum(duplicated(xbreak))#check if the breaking procedure has worked.
y &lt;- c(4,9,12,11,2,10)
xy_break=tiebreak(x,y)
xy_break$x
xy_break$y #a uniform value has been added to the second, third and fifth value of x.
xy_break$x%in%xy_break$y #check that no values for xbreak can be found in ybreak
tiebreak(x,y,nb_break=TRUE) #also returns the number of broken values
</code></pre>

<hr>
<h2 id='vartest'>Calibrated variance test between two or more independent samples</h2><span id='topic+vartest'></span>

<h3>Description</h3>

<p>Tests the equality of variance for continuous independent samples using Welch's ANOVA on the square of the centered variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vartest(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vartest_+3A_x">x</code>, <code id="vartest_+3A_y">y</code></td>
<td>
<p>the two continuous variables for the two samples variance test.</p>
</td></tr>
<tr><td><code id="vartest_+3A_...">...</code></td>
<td>
<p>other parameters such as <code>alternative</code> which indicates the alternative hypothesis
as one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;, or <code>data</code> and <code>formula</code> to include a dataset with a formula
from the command <code>vartest(x~y,data=dataset)</code> with dataset the name of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the two sample variance test, the null hypothesis is: H0 var(X)=var(Y) where var represents the variance.
The alternative is specified by the <code>alternative</code> argument.
The test uses Welch's ANOVA procedure on the variables <code class="reqn">(x_i-mean(x))^2</code>, <code class="reqn">(y_i-mean(y))^2</code> and is asymptotically well calibrated in the sense that the rejection probability under the null hypothesis is asymptotically equal to the level of the test.
The test can be applied to more than two groups in which case it tests if all groups have the same variance.
</p>


<h3>Value</h3>

<p>Returns the result of the test with its corresponding p-value and the value of the test statistic. In the two sample case, the function
also returns the confidence interval for the difference of the two variances.
</p>


<h3>Note</h3>

<p>The function can also be called using formulas: type <code>vartest(x~y,data)</code> with x the quantitative variable
and y a factor variable with two or more levels. For more than two groups, only the formula is valid.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cortest">cortest</a></code>, <code><a href="#topic+indeptest">indeptest</a></code>, <code><a href="#topic+mediantest">mediantest</a></code>, <code><a href="#topic+wilcoxtest">wilcoxtest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Application on the Evans dataset
data(Evans)
#Description of this dataset is available in the lbreg package
with(Evans,var.test(CHL[CDH==0],CHL[CDH==1]))
with(Evans,vartest(CHL[CDH==0],CHL[CDH==1]))
vartest(CHL~CDH,data=Evans) #using formulas

#Similar pvalues between var.test and vartest


#Simulated data
n=60 #sample size
M=10000 #number of replications
testone=function(n){
X=rnorm(n,0,1)
Y=rchisq(2*n,df=2)/2
list(test1=vartest(X,Y)$p.value,test2=var.test(X,Y)$p.value) #var.test is the standard Fisher test
}
res1=res2=rep(NA,M)
# Replications to check if the corrected Fisher test and the standard test are well calibrated
for (i in 1:M)
{
result=testone(n)
res1[i]=result$test1
res2[i]=result$test2
}
mean(res1&lt;0.05)  #0.0515
mean(res2&lt;0.05)  #0.1509

</code></pre>

<hr>
<h2 id='wilcoxtest'>Calibrated Wilcoxon rank sum and signed rank tests</h2><span id='topic+wilcoxtest'></span>

<h3>Description</h3>

<p>Compares the distribution between two random variables by testing if one variable tends to take larger (or smaller) values than the other. The test
works for independent and paired variables by using corrected versions of the Wilcoxon (or equivalently Mann-Whitney in the two-sample case) for one and two-sample tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilcoxtest(
  x,
  y = NULL,
  alternative = "two.sided",
  ties.break = "none",
  paired = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wilcoxtest_+3A_x">x</code>, <code id="wilcoxtest_+3A_y">y</code></td>
<td>
<p>two continuous variables.</p>
</td></tr>
<tr><td><code id="wilcoxtest_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="wilcoxtest_+3A_ties.break">ties.break</code></td>
<td>
<p>the method used to break ties in case there are ties in the x or y vectors. Can be <code>"none"</code> or <code>"random"</code>.</p>
</td></tr>
<tr><td><code id="wilcoxtest_+3A_paired">paired</code></td>
<td>
<p>a logical value. If <code>paired=TRUE</code>, you must provide values for <code>x</code> and <code>y</code> (of same length)
and the paired test is implemented. If <code>paired=FALSE</code>, the paired test is implemented when <code>y</code> is null and
only <code>x</code> is provided and the two sample test (for independent variables) is implemented when both <code>x</code> and <code>y</code> are provided.</p>
</td></tr>
<tr><td><code id="wilcoxtest_+3A_...">...</code></td>
<td>
<p>it is possible to use a formula with or without specifying a dataset
from the commands <code>wilcoxtest(x~y)</code> or <code>wilcoxtest(x~y,data=dataset)</code> with dataset the name of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two independent samples, the null hypothesis for the corrected Wilcoxon (Mann-Whitney) test is: H0 Med(X-Y)=0 where Med represents the median.
The alternative is specified by the <code>alternative</code> argument: &quot;<code>greater</code>&quot; means that Med(X-Y)&gt;0 and &quot;<code>less</code>&quot;
means that Med(X-Y)&lt;0. The null hypothesis for the paired Wilcoxon test is: H0 Med(D1+D2)=0 where D1 is the difference
between X1 and Y1 taken on the same pair (same with D2 on a different pair). Both tests are asymptotically well calibrated in the sense that the rejection probability under the
null hypothesis is asymptotically equal to the level of the test.
</p>


<h3>Value</h3>

<p>Returns the result of the test with its corresponding p-value and the value of the test statistic.
</p>


<h3>Note</h3>

<p>The function can also be called using formulas: type <code>wilcoxtest(x~y,data)</code> with x the quantitative variable
and y a factor variable with two levels. The option <code>ties.break</code> handles ties in the Wilcoxon test. If <code>ties.break="none"</code> the ties are ignored, if
<code>ties.break="random"</code> they are randomly broken. For the Wilcoxon rank sum test the ties between the <code>x</code> and <code>y</code> are
detected and broken (but the ties inside the <code>x</code> and <code>y</code> vectors are not changed). For the signed rank test, the ties in the
vector <code>x-y</code> (or in the <code>x</code> vector in case <code>y=NULL</code>) are randomly broken.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cortest">cortest</a></code>, <code><a href="#topic+indeptest">indeptest</a></code>, <code><a href="#topic+mediantest">mediantest</a></code>, <code><a href="#topic+vartest">vartest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Application on the Evans dataset
data(Evans)
#Description of this dataset is available in the lbreg package
with(Evans,wilcox.test(CHL[CDH==0],CHL[CDH==1]))
with(Evans,wilcoxtest(CHL[CDH==0],CHL[CDH==1]))
wilcoxtest(CHL~CDH,data=Evans) #using formulas
wilcoxtest(CHL~CDH,data=Evans,ties.break="random")
#the same test where ties are randomly broken


#For independent samples
n=100 #sample size
M=1000 #number of replications
testone=function(n){
X=runif(n,-0.5,0.5)
Y=rnorm(3*n,0,0.04)
list(test1=wilcoxtest(X,Y)$p.value,test2=wilcox.test(X,Y)$p.value)
#wilcox.test is the standard Wilcoxon test
}

#Simulation under the null hypothesis
#(note that P(X&gt;Y)=0.5)
#Takes a few seconds to run
res1=res2=rep(NA,M)
for (i in 1:M)
{
result=testone(n)
res1[i]=result$test1
res2[i]=result$test2
}
mean(res1&lt;0.05)
mean(res2&lt;0.05)

#For paired samples
#We use the value of the median of a Gamma distributed variable with shape
#parameter equal to 1/5 and scale parameter equal to 1. This value is
#computed from the command qgamma(shape=1/5, scale=1, 0.5)
n=100 #sample size
M=1000 #number of replications
testone=function(n){
D=rgamma(n,shape=1/10,scale=1)-qgamma(shape=1/5, scale=1, 0.5)/2
list(test1=wilcoxtest(D,ties.break = "random")$p.value,test2=wilcox.test(D)$p.value)
#wilcox.test is the standard paired Wilcoxon test
}
#Simulation under the null hypothesis
#(note that Med(D_1+D_2)=0)
#Takes a few seconds to run
for (i in 1:M)
{
result=testone(n)
res1[i]=result$test1
res2[i]=result$test2
}
mean(res1&lt;0.05)
mean(res2&lt;0.05)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
