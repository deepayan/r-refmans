<!DOCTYPE html><html><head><title>Help for package protHMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {protHMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chmm'><p>chmm</p></a></li>
<li><a href='#fp_hmm'><p>fp_hmm</p></a></li>
<li><a href='#hmm_ac'><p>hmm_ac</p></a></li>
<li><a href='#hmm_bigrams'><p>hmm_bigrams</p></a></li>
<li><a href='#hmm_cc'><p>hmm_cc</p></a></li>
<li><a href='#hmm_distance'><p>hmm_distance</p></a></li>
<li><a href='#hmm_GA'><p>hmm_GA</p></a></li>
<li><a href='#hmm_GSD'><p>hmm_GSD</p></a></li>
<li><a href='#hmm_LBP'><p>hmm_LBP</p></a></li>
<li><a href='#hmm_LPC'><p>hmm_LPC</p></a></li>
<li><a href='#hmm_MA'><p>hmm_MA</p></a></li>
<li><a href='#hmm_MB'><p>hmm_MB</p></a></li>
<li><a href='#hmm_read'><p>hmm_read</p></a></li>
<li><a href='#hmm_SCSH'><p>hmm_SCSH</p></a></li>
<li><a href='#hmm_SepDim'><p>hmm_SepDim</p></a></li>
<li><a href='#hmm_Single_Average'><p>hmm_Single_Average</p></a></li>
<li><a href='#hmm_smooth'><p>hmm_smooth</p></a></li>
<li><a href='#hmm_svd'><p>hmm_svd</p></a></li>
<li><a href='#hmm_trigrams'><p>hmm_trigrams</p></a></li>
<li><a href='#IM_psehmm'><p>IM_psehmm</p></a></li>
<li><a href='#pse_hmm'><p>pse_hmm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Protein Feature Extraction from Profile Hidden Markov Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shayaan Emran &lt;shayaan.emran@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates a comprehensive list of features from profile hidden Markov models (HMMs) of proteins. 
    Adapts and ports features for use with HMMs instead of Position Specific Scoring Matrices, in order to take 
    advantage of more accurate multiple sequence alignment by programs such as 'HHBlits' Remmert et al. (2012) 
    &lt;<a href="https://doi.org/10.1038%2Fnmeth.1818">doi:10.1038/nmeth.1818</a>&gt; and 'HMMer' Eddy (2011) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1002195">doi:10.1371/journal.pcbi.1002195</a>&gt;. Features calculated by 
    this package can be used for protein fold classification, protein structural class prediction, 
    sub-cellular localization and protein-protein interaction, among other tasks. Some examples of features 
    extracted are found in Song et al. (2018) &lt;<a href="https://doi.org/10.3390%2Fapp8010089">doi:10.3390/app8010089</a>&gt;, Jin &amp; Zhu (2021) &lt;<a href="https://doi.org/10.1155%2F2021%2F8629776">doi:10.1155/2021/8629776</a>&gt;, 
    Lyons et al. (2015) &lt;<a href="https://doi.org/10.1109%2Ftnb.2015.2457906">doi:10.1109/tnb.2015.2457906</a>&gt; and Saini et al. (2015) &lt;<a href="https://doi.org/10.1016%2Fj.jtbi.2015.05.030">doi:10.1016/j.jtbi.2015.05.030</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, utils, stats, phonTools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://semran9.github.io/protHMM/">https://semran9.github.io/protHMM/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/semran9/protHMM/issues">https://github.com/semran9/protHMM/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-05 03:26:50 UTC; shayaanemran</td>
</tr>
<tr>
<td>Author:</td>
<td>Shayaan Emran [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-05 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chmm'>chmm</h2><span id='topic+chmm'></span>

<h3>Description</h3>

<p>This feature begins by creating a CHMM, which is created by constructing 4 matrices, <code class="reqn">A, B, C, D</code> from
the original HMM <code class="reqn">H</code>. <code class="reqn">A</code> contains the first 75 percent of the original matrix <code class="reqn">H</code> row-wise, <code class="reqn">B</code> the
last 75 percent, <code class="reqn">C</code> the middle 75 percent and <code class="reqn">D</code> the entire original matrix. These are then merged to create the new
CHMM <code class="reqn">Z</code>. From there, the Bigrams feature is calculated with a flattened 20 x 20 matrix <code class="reqn">B</code>, in which <code class="reqn">B[i, j] = \sum_{a = 1}^{L-1} Z_{a, i} \times Z_{a+1, j}</code>.
<code class="reqn">H</code> corresponds to the original HMM matrix, and <code class="reqn">L</code> is the number of rows in <code class="reqn">Z</code>. Local Average Group,
or LAG is then calculated by splitting up the CHMM into 20 groups along the length of the protein sequence and calculating
the sums of each of the columns of each group, making a 1 x 20 vector per group, and a length 20 x 20 vector for all groups. These features are then fused.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chmm(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chmm_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fusion vector of length 800.
</p>
<p>A LAG vector of length 400.
</p>
<p>A Bigrams vector of length 400.
</p>


<h3>References</h3>

<p>An, J., Zhou, Y., Zhao, Y., &amp; Yan, Z. (2019).
An Efficient Feature Extraction Technique Based on Local Coding PSSM and Multifeatures Fusion for Predicting Protein-Protein Interactions.
Evolutionary Bioinformatics, 15, 117693431987992.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- chmm(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='fp_hmm'>fp_hmm</h2><span id='topic+fp_hmm'></span>

<h3>Description</h3>

<p>This feature consists of two vectors, <code class="reqn">d, s</code>. Vector <code class="reqn">d</code> corresponds to the sums across the sequence
for each of the 20 amino acid columns. Vector <code class="reqn">s</code> corresponds to a flattened matrix <code class="reqn">S[i, j] = \sum_{k = 1}^{L}
H[k, j] \times \delta[k, i]</code> in which <code class="reqn">\delta[k, i] = 1</code> when <code class="reqn">A_i = H[k, j]</code>. <code class="reqn">A</code> refers to a list of
all possible amino acids, <code class="reqn">i, j</code> span from <code class="reqn">1:20</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp_hmm(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp_hmm_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 20.
</p>
<p>A vector of length 400.
</p>


<h3>References</h3>

<p>Zahiri, J., Yaghoubi, O., Mohammad-Noori, M., Ebrahimpour, R., &amp; Masoudi-Nejad, A. (2013).
PPIevo: Protein–protein interaction prediction from PSSM based evolutionary information.
Genomics, 102(4), 237–242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- fp_hmm(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_ac'>hmm_ac</h2><span id='topic+hmm_ac'></span>

<h3>Description</h3>

<p>This feature calculates the covariance between two residues separated by a lag value within
the same amino acid emission frequency column along the protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_ac(hmm, lg = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_ac_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_ac_+3A_lg">lg</code></td>
<td>
<p>The lag value, which indicates the distance between residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 20 <code class="reqn">\times</code> the lag value; by default this is a vector of length 80.
</p>


<h3>Note</h3>

<p>The lag value must be less than the length of the protein sequence
</p>


<h3>References</h3>

<p>Dong, Q., Zhou, S., &amp; Guan, J. (2009).
A new taxonomy-based protein fold recognition approach based on autocross-covariance transformation.
Bioinformatics, 25(20), 2655–2662.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_ac(system.file("extdata", "1DLHA2-7", package="protHMM"))
</code></pre>

<hr>
<h2 id='hmm_bigrams'>hmm_bigrams</h2><span id='topic+hmm_bigrams'></span>

<h3>Description</h3>

<p>This feature is calculated with a 20 x 20 matrix <code class="reqn">B</code>, in which <code class="reqn">B[i, j] = \sum_{a = 1}^{L-1} H_{a, i}H_{a+1, j}</code>.
<code class="reqn">H</code> corresponds to the original HMM matrix, and <code class="reqn">L</code> is the number of rows in <code class="reqn">H</code>. Matrix <code class="reqn">B</code> is then flattened to
a feature vector of length 400, and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_bigrams(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_bigrams_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 400
</p>


<h3>References</h3>

<p>Lyons, J., Dehzangi, A., Heffernan, R., Yang, Y., Zhou, Y., Sharma, A., &amp; Paliwal, K. K. (2015).
Advancing the Accuracy of Protein Fold Recognition by Utilizing Profiles From Hidden Markov Models.
IEEE Transactions on Nanobioscience, 14(7), 761–772.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_bigrams(system.file("extdata", "1DLHA2-7", package="protHMM"))
</code></pre>

<hr>
<h2 id='hmm_cc'>hmm_cc</h2><span id='topic+hmm_cc'></span>

<h3>Description</h3>

<p>The feature calculates the covariance between different residues separated along the protein sequences
by a lag value across different amino acid emission frequency columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_cc(hmm, lg = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_cc_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_cc_+3A_lg">lg</code></td>
<td>
<p>The lag value, which indicates the distance between residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 20 x 19 x the lag value; by default this is a vector of length 1520.
</p>


<h3>Note</h3>

<p>The lag value must less than the length of the amino acid sequence.
</p>


<h3>References</h3>

<p>Dong, Q., Zhou, S., &amp; Guan, J. (2009).
A new taxonomy-based protein fold recognition approach based on autocross-covariance transformation.
Bioinformatics, 25(20), 2655–2662.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_cc(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_distance'>hmm_distance</h2><span id='topic+hmm_distance'></span>

<h3>Description</h3>

<p>This feature calculates the cosine distance matrix between two HMMs <code class="reqn">A</code> and <code class="reqn">B</code> before dynamic time warp is applied to
the distance matrix calculate the cumulative distance between the HMMs, which acts as a measure of similarity,
The cosine distance matrix <code class="reqn">D</code> is found to be <code class="reqn">D[a_i, b_j] = 1 - \frac{a_ib_j^{T}}{a_ia_i^Tb_jb_j^T}</code>,
in which <code class="reqn">a_i</code> and <code class="reqn">a_i</code> refer to row vectors of <code class="reqn">A</code> and <code class="reqn">B</code> respectively.
This in turn means that <code class="reqn">D</code> is of dimensions <code class="reqn">nrow(A), nrow(b)</code>. Dynamic time warp then calculates the
cumulative distance by calculating matrix <code class="reqn">C[i, j] = min(C[i-1, j], C[i, j-1], C[i-1, j-1]) + D[i, j]</code>,
where <code class="reqn">C_{i,j}</code> is 0 when <code class="reqn">i</code> or <code class="reqn">j</code> are less than 1. The lower rightmost point of the matrix <code class="reqn">C</code>
is then returned as the cumulative distance between proteins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_distance(hmm_1, hmm_2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_distance_+3A_hmm_1">hmm_1</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_distance_+3A_hmm_2">hmm_2</code></td>
<td>
<p>The name of another profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double that indicates distance between the two proteins.
</p>


<h3>References</h3>

<p>Lyons, J., Paliwal, K. K., Dehzangi, A., Heffernan, R., Tsunoda, T., &amp; Sharma, A. (2016).
Protein fold recognition using HMM–HMM alignment and dynamic programming.
Journal of Theoretical Biology, 393, 67–74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_distance(system.file("extdata", "1DLHA2-7", package="protHMM"),
system.file("extdata", "1TEN-7", package="protHMM"))
</code></pre>

<hr>
<h2 id='hmm_GA'>hmm_GA</h2><span id='topic+hmm_GA'></span>

<h3>Description</h3>

<p>This feature calculates the Geary autocorrelation of each amino acid type for each distance
d less than or equal to the lag value and greater than or equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_GA(hmm, lg = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_GA_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_GA_+3A_lg">lg</code></td>
<td>
<p>The lag value, which indicates the distance between residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length lg <code class="reqn">\times</code> 20, by default this is 180.
</p>


<h3>Note</h3>

<p>The lag value must be less than the length of the protein sequence
</p>


<h3>References</h3>

<p>Liang, Y., Liu, S., &amp; Zhang. (2015).
Prediction of Protein Structural Class Based on Different Autocorrelation Descriptors of Position–Specific Scoring Matrix.
MATCH: Communications in Mathematical and in Computer Chemistry, 73(3), 765–784.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_GA(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_GSD'>hmm_GSD</h2><span id='topic+hmm_GSD'></span>

<h3>Description</h3>

<p>This feature initially creates a grouping matrix <code class="reqn">G</code> by assigning each position a number <code class="reqn">1:3</code> based on
the value at each position of HMM matrix <code class="reqn">H</code>; <code class="reqn">1</code> represents the low probability group, <code class="reqn">2</code> the medium and <code class="reqn">3</code> the high probability group.
The number of total points in each group for each column is then calculated, and the sequence is then split
based upon the the positions of the 1st, 25th, 50th, 75th and 100th percentile (last) points for each of the three groups,
in each of the 20 columns of the grouping matrix. Thus for column <code class="reqn">j</code>, <code class="reqn">S(k, j, z) = \sum_{i = 1}^{(z)*.25*N} |G[i, j] = k|</code>,
where <code class="reqn">k</code> is the group number, <code class="reqn">z = 1:4</code> and <code class="reqn">N</code> corresponds to number of rows in matrix <code class="reqn">G</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_GSD(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_GSD_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 300.
</p>


<h3>References</h3>

<p>Jin, D., &amp; Zhu, P. (2021).
Protein Subcellular Localization Based on Evolutionary Information and Segmented Distribution.
Mathematical Problems in Engineering, 2021, 1–14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_GSD(system.file("extdata", "1DLHA2-7", package="protHMM"))
</code></pre>

<hr>
<h2 id='hmm_LBP'>hmm_LBP</h2><span id='topic+hmm_LBP'></span>

<h3>Description</h3>

<p>This feature uses local binary pattern with a neighborhood of radius 1 and 8 sample points to extract
features from the HMM. A 256 bin histogram is extracted as a 256 length feature vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_LBP(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_LBP_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 256.
</p>


<h3>References</h3>

<p>Li, Y., Li, L., Wang, L., Yu, C., Wang, Z., &amp; You, Z. (2019).
An Ensemble Classifier to Predict Protein–Protein Interactions by Combining PSSM-based Evolutionary Information with Local Binary Pattern Model.
International Journal of Molecular Sciences, 20(14), 3511.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_LBP(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_LPC'>hmm_LPC</h2><span id='topic+hmm_LPC'></span>

<h3>Description</h3>

<p>This feature uses linear predictive coding (LPC) to map each HMM to a <code class="reqn">20 \times 14 = 280</code> dimensional vector,
where for each of the 20 columns of the HMM, LPC is used to extract a 14 dimensional vector <code class="reqn">D_n</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_LPC(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_LPC_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 280.
</p>


<h3>References</h3>

<p>Qin, Y., Zheng, X., Wang, J., Chen, M., &amp; Zhou, C. (2015).
Prediction of protein structural class based on Linear Predictive Coding of PSI-BLAST profiles.
Central European Journal of Biology, 10(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_LPC(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_MA'>hmm_MA</h2><span id='topic+hmm_MA'></span>

<h3>Description</h3>

<p>This feature calculates the normalized Moran autocorrelation of each amino acid type, for each distance
d less than or equal to the lag value and greater than or equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_MA(hmm, lg = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_MA_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_MA_+3A_lg">lg</code></td>
<td>
<p>The lag value, which indicates the distance between residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length lg <code class="reqn">\times</code> 20, by default this is 180.
</p>


<h3>Note</h3>

<p>The lag value must be less than the length of the protein sequence
</p>


<h3>References</h3>

<p>Liang, Y., Liu, S., &amp; Zhang. (2015).
Prediction of Protein Structural Class Based on Di fferent Autocorrelation Descriptors of Position–Specific Scoring Matrix.
MATCH: Communications in Mathematical and in Computer Chemistry, 73(3), 765–784.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_MA(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_MB'>hmm_MB</h2><span id='topic+hmm_MB'></span>

<h3>Description</h3>

<p>This feature calculates the normalized Moreau-Broto autocorrelation of each amino acid type, for each distance
d less than or equal to the lag value and greater than or equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_MB(hmm, lg = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_MB_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_MB_+3A_lg">lg</code></td>
<td>
<p>The lag value, which indicates the distance between residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length lg <code class="reqn">\times</code> 20, by default this is 180.
</p>


<h3>Note</h3>

<p>The lag value must be less than the length of the protein sequence
</p>


<h3>References</h3>

<p>Liang, Y., Liu, S., &amp; Zhang. (2015).
Prediction of Protein Structural Class Based on Different Autocorrelation Descriptors of Position–Specific Scoring Matrix.
MATCH: Communications in Mathematical and in Computer Chemistry, 73(3), 765–784.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_MB(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_read'>hmm_read</h2><span id='topic+hmm_read'></span>

<h3>Description</h3>

<p>Reads in the amino acid emission frequency columns of a profile hidden markov model matrix
and converts each position to frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_read(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_read_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 20 x L matrix, in which L is the sequence length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_read(system.file("extdata", "1DLHA2-7", package="protHMM"))
</code></pre>

<hr>
<h2 id='hmm_SCSH'>hmm_SCSH</h2><span id='topic+hmm_SCSH'></span>

<h3>Description</h3>

<p>This feature returns the 2 and 3-mer compositions of the protein sequence. This is done by first
finding all possible 2 and 3-mers for any protein (<code class="reqn">20^2</code> and <code class="reqn">20^3</code> permutations for 2 and 3-mers respectively).
With those permutations, vectors of length 400 and 8000 are created, each point corresponding to one 2 or 3-mer.
Then, the protein sequence that corresponds to the HMM scores is extracted, and put into a bipartite graph with the protein sequence.
Each possible path of length 1 or 2 is found, and the corresponding vertices on the graph are noted as 2 and 3-mers.
For each 2 or 3-mer found from these paths, 1 is added to the position that responds to that 2/3-mer in the
2-mer and 3-mer vectors , which are the length 400 and 8000 vectors created previously. The vectors are then returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_SCSH(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_SCSH_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 400.
</p>
<p>A vector of length 8000.
</p>


<h3>References</h3>

<p>Mohammadi, A. M., Zahiri, J., Mohammadi, S., Khodarahmi, M., &amp; Arab, S. S. (2022).
PSSMCOOL: a comprehensive R package for generating evolutionary-based descriptors of protein sequences from PSSM profiles.
Biology Methods and Protocols, 7(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_400&lt;- hmm_SCSH(system.file("extdata", "1DLHA2-7", package="protHMM"))[[1]]
h_8000&lt;- hmm_SCSH(system.file("extdata", "1DLHA2-7", package="protHMM"))[[2]]
</code></pre>

<hr>
<h2 id='hmm_SepDim'>hmm_SepDim</h2><span id='topic+hmm_SepDim'></span>

<h3>Description</h3>

<p>This feature calculates the probabilistic expression of amino acid dimers that are spatially separated by a distance <code class="reqn">l</code>.
Mathematically, this is done with a 20 x 20 matrix <code class="reqn">F</code>, in which <code class="reqn">F[m, n] = \sum_{i = 1}^{L-l} H_{i, m}H_{i+k, n}</code>.
<code class="reqn">H</code> corresponds to the original HMM matrix, and <code class="reqn">L</code> is the number of rows in <code class="reqn">H</code>. Matrix <code class="reqn">F</code> is then flattened to
a feature vector of length 400, and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_SepDim(hmm, l = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_SepDim_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_SepDim_+3A_l">l</code></td>
<td>
<p>Spatial distance between dimer residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 400
</p>


<h3>References</h3>

<p>Saini, H., Raicar, G., Sharma, A., Lal, S. K., Dehzangi, A., Lyons, J., Paliwal, K. K., Imoto, S., &amp; Miyano, S. (2015).
Probabilistic expression of spatially varied amino acid dimers into general form of Chou's pseudo amino acid composition for protein fold recognition.
Journal of Theoretical Biology, 380, 291–298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_SepDim(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_Single_Average'>hmm_Single_Average</h2><span id='topic+hmm_Single_Average'></span>

<h3>Description</h3>

<p>This feature groups together rows that are related to the same amino acid. This is done using a vector
<code class="reqn">SA(k)</code>, in which <code class="reqn">k</code> spans <code class="reqn">1:400</code> and <code class="reqn">SA(k) = avg_{i = 1, 2... L}H[i, j] \times \delta(P(i), A(z))</code>,
in which <code class="reqn">H</code> is the HMM matrix, <code class="reqn">P</code> in the protein sequence, <code class="reqn">A</code> is an ordered set of amino acids,
the variables <code class="reqn">j, z = 1:20</code>, the variable <code class="reqn">k = j + 20 \times (z-1)</code> when creating the vector,
and <code class="reqn">\delta()</code> represents Kronecker's delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_Single_Average(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_Single_Average_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 400.
</p>


<h3>References</h3>

<p>Nanni, L., Lumini, A., &amp; Brahnam, S. (2014).
An Empirical Study of Different Approaches for Protein Classification. The Scientific World Journal, 2014, 1–17.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_Single_Average(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_smooth'>hmm_smooth</h2><span id='topic+hmm_smooth'></span>

<h3>Description</h3>

<p>This feature smooths the HMM matrix <code class="reqn">H</code> by using sliding window of length <code class="reqn">sw</code> to incorporate information
from up and downstream residues into each row of the HMM matrix. Each HMM row <code class="reqn">r_i</code> is made into the summation
of <code class="reqn">r_{i-(sw/2)}+... r_i...+r_{i+(sw/2)}</code>, for <code class="reqn">i = 1:L</code>, where <code class="reqn">L</code> is the number of rows in <code class="reqn">H</code>.
For rows such as the beginning and ending rows, <code class="reqn">0</code> matrices of dimensions <code class="reqn">sw/2, 20</code> are appended to the
original matrix <code class="reqn">H</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_smooth(hmm, sw = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_smooth_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="hmm_smooth_+3A_sw">sw</code></td>
<td>
<p>The size of the sliding window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimensions L <code class="reqn">\times</code> 20.
</p>


<h3>References</h3>

<p>Fang, C., Noguchi, T., &amp; Yamana, H. (2013).
SCPSSMpred: A General Sequence-based Method for Ligand-binding Site Prediction.
IPSJ Transactions on Bioinformatics, 6(0), 35–42.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_smooth(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_svd'>hmm_svd</h2><span id='topic+hmm_svd'></span>

<h3>Description</h3>

<p>This feature uses singular value decomposition (SVD) to reduce the dimensionality of the inputted hidden
markov model matrix. SVD factorizes a matrix C of dimensions <code class="reqn">i, j</code> to <code class="reqn">U[i, r] \times \Sigma[r, r] \times V[r, j]</code>.
The diagonal values of <code class="reqn">\Sigma</code> are known as the singular values of matrix C, and are what are returned with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_svd(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_svd_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 20.
</p>


<h3>References</h3>

<p>Song, X., Chen, Z., Sun, X., You, Z., Li, L., &amp; Zhao, Y. (2018).
An Ensemble Classifier with Random Projection for Predicting Protein–Protein Interactions Using Sequence and Evolutionary Information.
Applied Sciences, 8(1), 89.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_svd(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='hmm_trigrams'>hmm_trigrams</h2><span id='topic+hmm_trigrams'></span>

<h3>Description</h3>

<p>This feature is calculated with a 20 x 20 x 20 block <code class="reqn">B</code>, in which <code class="reqn">B[i, j, k] = \sum_{a = 1}^{L-2} H_{a, i}H_{a+1, j}H_{a+2, k}</code>.
<code class="reqn">H</code> corresponds to the original HMM matrix, and <code class="reqn">L</code> is the number of rows in <code class="reqn">H</code>. Matrix <code class="reqn">B</code> is then flattened to
a feature vector of length 8000, and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_trigrams(hmm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_trigrams_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 8000
</p>


<h3>References</h3>

<p>Lyons, J., Dehzangi, A., Heffernan, R., Yang, Y., Zhou, Y., Sharma, A., &amp; Paliwal, K. K. (2015).
Advancing the Accuracy of Protein Fold Recognition by Utilizing Profiles From Hidden Markov Models.
IEEE Transactions on Nanobioscience, 14(7), 761–772.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- hmm_trigrams(system.file("extdata", "1DLHA2-7", package="protHMM"))
</code></pre>

<hr>
<h2 id='IM_psehmm'>IM_psehmm</h2><span id='topic+IM_psehmm'></span>

<h3>Description</h3>

<p>The first twenty numbers of this feature correspond to the means of each column of the HMM matrix
<code class="reqn">H</code>. The rest of the features in the feature vector are found in matrix <code class="reqn">T[i,j]</code>, where <code class="reqn">T[i,j] =
\frac{1}{L-i}\sum_{n = 1}^{20-i} [H_{m,n}-H_{m, n+i}]^2, m = 1:L,\space i = 1:d\space and\space j = 1:20</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IM_psehmm(hmm, d = 13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IM_psehmm_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="IM_psehmm_+3A_d">d</code></td>
<td>
<p>The maximum distance between residues column-wise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code class="reqn">20+20\times d-d\times\frac{d+1}{2}</code>
</p>


<h3>Note</h3>

<p>d must be less than 20.
</p>


<h3>References</h3>

<p>Ruan, X., Zhou, D., Nie, R., &amp; Guo, Y. (2020).
Predictions of Apoptosis Proteins by Integrating Different Features Based on Improving Pseudo-Position-Specific Scoring Matrix.
BioMed Research International, 2020, 1–13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- IM_psehmm(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

<hr>
<h2 id='pse_hmm'>pse_hmm</h2><span id='topic+pse_hmm'></span>

<h3>Description</h3>

<p>The first twenty numbers of this feature correspond to the means of each column of the HMM matrix
<code class="reqn">H</code>. The rest of the features in the feature vector are given by correlation of the <code class="reqn">ith</code> most
contiguous values along the chain per each amino acid column, where <code class="reqn">0&lt;i&lt;g+1</code>. This creates a vector of 20 <code class="reqn">\times</code>
g, and this combines with the first 20 features to create the final feature vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pse_hmm(hmm, g = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pse_hmm_+3A_hmm">hmm</code></td>
<td>
<p>The name of a profile hidden markov model file.</p>
</td></tr>
<tr><td><code id="pse_hmm_+3A_g">g</code></td>
<td>
<p>The contiguous distance between residues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code class="reqn">20 + g \times 20</code>, by default this is 320.
</p>


<h3>Note</h3>

<p>g must be less than the length of the protein sequence
</p>


<h3>References</h3>

<p>Chou, K., &amp; Shen, H. (2007). MemType-2L: A Web server for predicting membrane proteins and their types
by incorporating evolution information through Pse-PSSM. Biochemical and Biophysical Research Communications,
360(2), 339–345.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h&lt;- pse_hmm(system.file("extdata", "1DLHA2-7", package="protHMM"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
